[
    {
        "func_name": "test_alap_agree_with_reverse_asap_reverse",
        "original": "def test_alap_agree_with_reverse_asap_reverse(self):\n    \"\"\"Test if ALAP schedule agrees with doubly-reversed ASAP schedule.\"\"\"\n    qc = QuantumCircuit(2)\n    qc.h(0)\n    qc.delay(500, 1)\n    qc.cx(0, 1)\n    qc.measure_all()\n    durations = InstructionDurations([('h', 0, 200), ('cx', [0, 1], 700), ('measure', None, 1000)])\n    pm = PassManager([ALAPScheduleAnalysis(durations), PadDelay()])\n    alap_qc = pm.run(qc)\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    new_qc = pm.run(qc.reverse_ops())\n    new_qc = new_qc.reverse_ops()\n    new_qc.name = new_qc.name\n    self.assertEqual(alap_qc, new_qc)",
        "mutated": [
            "def test_alap_agree_with_reverse_asap_reverse(self):\n    if False:\n        i = 10\n    'Test if ALAP schedule agrees with doubly-reversed ASAP schedule.'\n    qc = QuantumCircuit(2)\n    qc.h(0)\n    qc.delay(500, 1)\n    qc.cx(0, 1)\n    qc.measure_all()\n    durations = InstructionDurations([('h', 0, 200), ('cx', [0, 1], 700), ('measure', None, 1000)])\n    pm = PassManager([ALAPScheduleAnalysis(durations), PadDelay()])\n    alap_qc = pm.run(qc)\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    new_qc = pm.run(qc.reverse_ops())\n    new_qc = new_qc.reverse_ops()\n    new_qc.name = new_qc.name\n    self.assertEqual(alap_qc, new_qc)",
            "def test_alap_agree_with_reverse_asap_reverse(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test if ALAP schedule agrees with doubly-reversed ASAP schedule.'\n    qc = QuantumCircuit(2)\n    qc.h(0)\n    qc.delay(500, 1)\n    qc.cx(0, 1)\n    qc.measure_all()\n    durations = InstructionDurations([('h', 0, 200), ('cx', [0, 1], 700), ('measure', None, 1000)])\n    pm = PassManager([ALAPScheduleAnalysis(durations), PadDelay()])\n    alap_qc = pm.run(qc)\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    new_qc = pm.run(qc.reverse_ops())\n    new_qc = new_qc.reverse_ops()\n    new_qc.name = new_qc.name\n    self.assertEqual(alap_qc, new_qc)",
            "def test_alap_agree_with_reverse_asap_reverse(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test if ALAP schedule agrees with doubly-reversed ASAP schedule.'\n    qc = QuantumCircuit(2)\n    qc.h(0)\n    qc.delay(500, 1)\n    qc.cx(0, 1)\n    qc.measure_all()\n    durations = InstructionDurations([('h', 0, 200), ('cx', [0, 1], 700), ('measure', None, 1000)])\n    pm = PassManager([ALAPScheduleAnalysis(durations), PadDelay()])\n    alap_qc = pm.run(qc)\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    new_qc = pm.run(qc.reverse_ops())\n    new_qc = new_qc.reverse_ops()\n    new_qc.name = new_qc.name\n    self.assertEqual(alap_qc, new_qc)",
            "def test_alap_agree_with_reverse_asap_reverse(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test if ALAP schedule agrees with doubly-reversed ASAP schedule.'\n    qc = QuantumCircuit(2)\n    qc.h(0)\n    qc.delay(500, 1)\n    qc.cx(0, 1)\n    qc.measure_all()\n    durations = InstructionDurations([('h', 0, 200), ('cx', [0, 1], 700), ('measure', None, 1000)])\n    pm = PassManager([ALAPScheduleAnalysis(durations), PadDelay()])\n    alap_qc = pm.run(qc)\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    new_qc = pm.run(qc.reverse_ops())\n    new_qc = new_qc.reverse_ops()\n    new_qc.name = new_qc.name\n    self.assertEqual(alap_qc, new_qc)",
            "def test_alap_agree_with_reverse_asap_reverse(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test if ALAP schedule agrees with doubly-reversed ASAP schedule.'\n    qc = QuantumCircuit(2)\n    qc.h(0)\n    qc.delay(500, 1)\n    qc.cx(0, 1)\n    qc.measure_all()\n    durations = InstructionDurations([('h', 0, 200), ('cx', [0, 1], 700), ('measure', None, 1000)])\n    pm = PassManager([ALAPScheduleAnalysis(durations), PadDelay()])\n    alap_qc = pm.run(qc)\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    new_qc = pm.run(qc.reverse_ops())\n    new_qc = new_qc.reverse_ops()\n    new_qc.name = new_qc.name\n    self.assertEqual(alap_qc, new_qc)"
        ]
    },
    {
        "func_name": "test_alap_agree_with_reverse_asap_with_target",
        "original": "def test_alap_agree_with_reverse_asap_with_target(self):\n    \"\"\"Test if ALAP schedule agrees with doubly-reversed ASAP schedule.\"\"\"\n    qc = QuantumCircuit(2)\n    qc.h(0)\n    qc.delay(500, 1)\n    qc.cx(0, 1)\n    qc.measure_all()\n    target = Target(num_qubits=2, dt=3.5555555555555554)\n    target.add_instruction(HGate(), {(0,): InstructionProperties(duration=200)})\n    target.add_instruction(CXGate(), {(0, 1): InstructionProperties(duration=700)})\n    target.add_instruction(Measure(), {(0,): InstructionProperties(duration=1000), (1,): InstructionProperties(duration=1000)})\n    pm = PassManager([ALAPScheduleAnalysis(target=target), PadDelay()])\n    alap_qc = pm.run(qc)\n    pm = PassManager([ASAPScheduleAnalysis(target=target), PadDelay()])\n    new_qc = pm.run(qc.reverse_ops())\n    new_qc = new_qc.reverse_ops()\n    new_qc.name = new_qc.name\n    self.assertEqual(alap_qc, new_qc)",
        "mutated": [
            "def test_alap_agree_with_reverse_asap_with_target(self):\n    if False:\n        i = 10\n    'Test if ALAP schedule agrees with doubly-reversed ASAP schedule.'\n    qc = QuantumCircuit(2)\n    qc.h(0)\n    qc.delay(500, 1)\n    qc.cx(0, 1)\n    qc.measure_all()\n    target = Target(num_qubits=2, dt=3.5555555555555554)\n    target.add_instruction(HGate(), {(0,): InstructionProperties(duration=200)})\n    target.add_instruction(CXGate(), {(0, 1): InstructionProperties(duration=700)})\n    target.add_instruction(Measure(), {(0,): InstructionProperties(duration=1000), (1,): InstructionProperties(duration=1000)})\n    pm = PassManager([ALAPScheduleAnalysis(target=target), PadDelay()])\n    alap_qc = pm.run(qc)\n    pm = PassManager([ASAPScheduleAnalysis(target=target), PadDelay()])\n    new_qc = pm.run(qc.reverse_ops())\n    new_qc = new_qc.reverse_ops()\n    new_qc.name = new_qc.name\n    self.assertEqual(alap_qc, new_qc)",
            "def test_alap_agree_with_reverse_asap_with_target(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test if ALAP schedule agrees with doubly-reversed ASAP schedule.'\n    qc = QuantumCircuit(2)\n    qc.h(0)\n    qc.delay(500, 1)\n    qc.cx(0, 1)\n    qc.measure_all()\n    target = Target(num_qubits=2, dt=3.5555555555555554)\n    target.add_instruction(HGate(), {(0,): InstructionProperties(duration=200)})\n    target.add_instruction(CXGate(), {(0, 1): InstructionProperties(duration=700)})\n    target.add_instruction(Measure(), {(0,): InstructionProperties(duration=1000), (1,): InstructionProperties(duration=1000)})\n    pm = PassManager([ALAPScheduleAnalysis(target=target), PadDelay()])\n    alap_qc = pm.run(qc)\n    pm = PassManager([ASAPScheduleAnalysis(target=target), PadDelay()])\n    new_qc = pm.run(qc.reverse_ops())\n    new_qc = new_qc.reverse_ops()\n    new_qc.name = new_qc.name\n    self.assertEqual(alap_qc, new_qc)",
            "def test_alap_agree_with_reverse_asap_with_target(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test if ALAP schedule agrees with doubly-reversed ASAP schedule.'\n    qc = QuantumCircuit(2)\n    qc.h(0)\n    qc.delay(500, 1)\n    qc.cx(0, 1)\n    qc.measure_all()\n    target = Target(num_qubits=2, dt=3.5555555555555554)\n    target.add_instruction(HGate(), {(0,): InstructionProperties(duration=200)})\n    target.add_instruction(CXGate(), {(0, 1): InstructionProperties(duration=700)})\n    target.add_instruction(Measure(), {(0,): InstructionProperties(duration=1000), (1,): InstructionProperties(duration=1000)})\n    pm = PassManager([ALAPScheduleAnalysis(target=target), PadDelay()])\n    alap_qc = pm.run(qc)\n    pm = PassManager([ASAPScheduleAnalysis(target=target), PadDelay()])\n    new_qc = pm.run(qc.reverse_ops())\n    new_qc = new_qc.reverse_ops()\n    new_qc.name = new_qc.name\n    self.assertEqual(alap_qc, new_qc)",
            "def test_alap_agree_with_reverse_asap_with_target(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test if ALAP schedule agrees with doubly-reversed ASAP schedule.'\n    qc = QuantumCircuit(2)\n    qc.h(0)\n    qc.delay(500, 1)\n    qc.cx(0, 1)\n    qc.measure_all()\n    target = Target(num_qubits=2, dt=3.5555555555555554)\n    target.add_instruction(HGate(), {(0,): InstructionProperties(duration=200)})\n    target.add_instruction(CXGate(), {(0, 1): InstructionProperties(duration=700)})\n    target.add_instruction(Measure(), {(0,): InstructionProperties(duration=1000), (1,): InstructionProperties(duration=1000)})\n    pm = PassManager([ALAPScheduleAnalysis(target=target), PadDelay()])\n    alap_qc = pm.run(qc)\n    pm = PassManager([ASAPScheduleAnalysis(target=target), PadDelay()])\n    new_qc = pm.run(qc.reverse_ops())\n    new_qc = new_qc.reverse_ops()\n    new_qc.name = new_qc.name\n    self.assertEqual(alap_qc, new_qc)",
            "def test_alap_agree_with_reverse_asap_with_target(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test if ALAP schedule agrees with doubly-reversed ASAP schedule.'\n    qc = QuantumCircuit(2)\n    qc.h(0)\n    qc.delay(500, 1)\n    qc.cx(0, 1)\n    qc.measure_all()\n    target = Target(num_qubits=2, dt=3.5555555555555554)\n    target.add_instruction(HGate(), {(0,): InstructionProperties(duration=200)})\n    target.add_instruction(CXGate(), {(0, 1): InstructionProperties(duration=700)})\n    target.add_instruction(Measure(), {(0,): InstructionProperties(duration=1000), (1,): InstructionProperties(duration=1000)})\n    pm = PassManager([ALAPScheduleAnalysis(target=target), PadDelay()])\n    alap_qc = pm.run(qc)\n    pm = PassManager([ASAPScheduleAnalysis(target=target), PadDelay()])\n    new_qc = pm.run(qc.reverse_ops())\n    new_qc = new_qc.reverse_ops()\n    new_qc.name = new_qc.name\n    self.assertEqual(alap_qc, new_qc)"
        ]
    },
    {
        "func_name": "test_classically_controlled_gate_after_measure",
        "original": "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_classically_controlled_gate_after_measure(self, schedule_pass):\n    \"\"\"Test if ALAP/ASAP schedules circuits with c_if after measure with a common clbit.\n        See: https://github.com/Qiskit/qiskit-terra/issues/7654\n\n        (input)\n             \u250c\u2500\u2510\n        q_0: \u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2565\u2518   \u250c\u2500\u2500\u2500\u2510\n        q_1: \u2500\u256b\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\n              \u2551    \u2514\u2500\u2565\u2500\u2518\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\n        c: 1/\u2550\u2569\u2550\u2561 c_0 = T \u255e\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        (scheduled)\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551       \u2514\u2500\u2565\u2500\u2518\n                                 \u2551    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\n                                 0    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \"\"\"\n    qc = QuantumCircuit(2, 1)\n    qc.measure(0, 0)\n    qc.x(1).c_if(0, True)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2, 1)\n    expected.measure(0, 0)\n    expected.delay(1000, 1)\n    expected.x(1).c_if(0, True)\n    expected.delay(200, 0)\n    self.assertEqual(expected, scheduled)",
        "mutated": [
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_classically_controlled_gate_after_measure(self, schedule_pass):\n    if False:\n        i = 10\n    'Test if ALAP/ASAP schedules circuits with c_if after measure with a common clbit.\\n        See: https://github.com/Qiskit/qiskit-terra/issues/7654\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n              \u2551    \u2514\u2500\u2565\u2500\u2518\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2569\u2550\u2561 c_0 = T \u255e\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        (scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551       \u2514\u2500\u2565\u2500\u2518\\n                                 \u2551    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\\n                                 0    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.measure(0, 0)\n    qc.x(1).c_if(0, True)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2, 1)\n    expected.measure(0, 0)\n    expected.delay(1000, 1)\n    expected.x(1).c_if(0, True)\n    expected.delay(200, 0)\n    self.assertEqual(expected, scheduled)",
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_classically_controlled_gate_after_measure(self, schedule_pass):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test if ALAP/ASAP schedules circuits with c_if after measure with a common clbit.\\n        See: https://github.com/Qiskit/qiskit-terra/issues/7654\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n              \u2551    \u2514\u2500\u2565\u2500\u2518\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2569\u2550\u2561 c_0 = T \u255e\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        (scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551       \u2514\u2500\u2565\u2500\u2518\\n                                 \u2551    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\\n                                 0    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.measure(0, 0)\n    qc.x(1).c_if(0, True)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2, 1)\n    expected.measure(0, 0)\n    expected.delay(1000, 1)\n    expected.x(1).c_if(0, True)\n    expected.delay(200, 0)\n    self.assertEqual(expected, scheduled)",
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_classically_controlled_gate_after_measure(self, schedule_pass):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test if ALAP/ASAP schedules circuits with c_if after measure with a common clbit.\\n        See: https://github.com/Qiskit/qiskit-terra/issues/7654\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n              \u2551    \u2514\u2500\u2565\u2500\u2518\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2569\u2550\u2561 c_0 = T \u255e\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        (scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551       \u2514\u2500\u2565\u2500\u2518\\n                                 \u2551    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\\n                                 0    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.measure(0, 0)\n    qc.x(1).c_if(0, True)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2, 1)\n    expected.measure(0, 0)\n    expected.delay(1000, 1)\n    expected.x(1).c_if(0, True)\n    expected.delay(200, 0)\n    self.assertEqual(expected, scheduled)",
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_classically_controlled_gate_after_measure(self, schedule_pass):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test if ALAP/ASAP schedules circuits with c_if after measure with a common clbit.\\n        See: https://github.com/Qiskit/qiskit-terra/issues/7654\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n              \u2551    \u2514\u2500\u2565\u2500\u2518\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2569\u2550\u2561 c_0 = T \u255e\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        (scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551       \u2514\u2500\u2565\u2500\u2518\\n                                 \u2551    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\\n                                 0    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.measure(0, 0)\n    qc.x(1).c_if(0, True)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2, 1)\n    expected.measure(0, 0)\n    expected.delay(1000, 1)\n    expected.x(1).c_if(0, True)\n    expected.delay(200, 0)\n    self.assertEqual(expected, scheduled)",
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_classically_controlled_gate_after_measure(self, schedule_pass):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test if ALAP/ASAP schedules circuits with c_if after measure with a common clbit.\\n        See: https://github.com/Qiskit/qiskit-terra/issues/7654\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n              \u2551    \u2514\u2500\u2565\u2500\u2518\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2569\u2550\u2561 c_0 = T \u255e\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        (scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551       \u2514\u2500\u2565\u2500\u2518\\n                                 \u2551    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\\n                                 0    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.measure(0, 0)\n    qc.x(1).c_if(0, True)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2, 1)\n    expected.measure(0, 0)\n    expected.delay(1000, 1)\n    expected.x(1).c_if(0, True)\n    expected.delay(200, 0)\n    self.assertEqual(expected, scheduled)"
        ]
    },
    {
        "func_name": "test_measure_after_measure",
        "original": "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_measure_after_measure(self, schedule_pass):\n    \"\"\"Test if ALAP/ASAP schedules circuits with measure after measure with a common clbit.\n        See: https://github.com/Qiskit/qiskit-terra/issues/7654\n\n        (input)\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\n        q_0: \u2524 X \u251c\u2524M\u251c\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2518\u2514\u2565\u2518\u250c\u2500\u2510\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2524M\u251c\n                   \u2551 \u2514\u2565\u2518\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\n                   0  0\n\n        (scheduled)\n                    \u250c\u2500\u2500\u2500\u2510       \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(1000[dt]) \u251c\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        q_1: \u2524 Delay(1200[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551         \u2514\u2565\u2518\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n                                 0          0\n        \"\"\"\n    qc = QuantumCircuit(2, 1)\n    qc.x(0)\n    qc.measure(0, 0)\n    qc.measure(1, 0)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2, 1)\n    expected.x(0)\n    expected.measure(0, 0)\n    expected.delay(1200, 1)\n    expected.measure(1, 0)\n    expected.delay(1000, 0)\n    self.assertEqual(expected, scheduled)",
        "mutated": [
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_measure_after_measure(self, schedule_pass):\n    if False:\n        i = 10\n    'Test if ALAP/ASAP schedules circuits with measure after measure with a common clbit.\\n        See: https://github.com/Qiskit/qiskit-terra/issues/7654\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524M\u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2518\u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2524M\u251c\\n                   \u2551 \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                   0  0\\n\\n        (scheduled)\\n                    \u250c\u2500\u2500\u2500\u2510       \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(1000[dt]) \u251c\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1200[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551         \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                                 0          0\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.x(0)\n    qc.measure(0, 0)\n    qc.measure(1, 0)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2, 1)\n    expected.x(0)\n    expected.measure(0, 0)\n    expected.delay(1200, 1)\n    expected.measure(1, 0)\n    expected.delay(1000, 0)\n    self.assertEqual(expected, scheduled)",
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_measure_after_measure(self, schedule_pass):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test if ALAP/ASAP schedules circuits with measure after measure with a common clbit.\\n        See: https://github.com/Qiskit/qiskit-terra/issues/7654\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524M\u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2518\u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2524M\u251c\\n                   \u2551 \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                   0  0\\n\\n        (scheduled)\\n                    \u250c\u2500\u2500\u2500\u2510       \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(1000[dt]) \u251c\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1200[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551         \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                                 0          0\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.x(0)\n    qc.measure(0, 0)\n    qc.measure(1, 0)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2, 1)\n    expected.x(0)\n    expected.measure(0, 0)\n    expected.delay(1200, 1)\n    expected.measure(1, 0)\n    expected.delay(1000, 0)\n    self.assertEqual(expected, scheduled)",
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_measure_after_measure(self, schedule_pass):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test if ALAP/ASAP schedules circuits with measure after measure with a common clbit.\\n        See: https://github.com/Qiskit/qiskit-terra/issues/7654\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524M\u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2518\u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2524M\u251c\\n                   \u2551 \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                   0  0\\n\\n        (scheduled)\\n                    \u250c\u2500\u2500\u2500\u2510       \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(1000[dt]) \u251c\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1200[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551         \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                                 0          0\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.x(0)\n    qc.measure(0, 0)\n    qc.measure(1, 0)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2, 1)\n    expected.x(0)\n    expected.measure(0, 0)\n    expected.delay(1200, 1)\n    expected.measure(1, 0)\n    expected.delay(1000, 0)\n    self.assertEqual(expected, scheduled)",
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_measure_after_measure(self, schedule_pass):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test if ALAP/ASAP schedules circuits with measure after measure with a common clbit.\\n        See: https://github.com/Qiskit/qiskit-terra/issues/7654\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524M\u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2518\u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2524M\u251c\\n                   \u2551 \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                   0  0\\n\\n        (scheduled)\\n                    \u250c\u2500\u2500\u2500\u2510       \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(1000[dt]) \u251c\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1200[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551         \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                                 0          0\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.x(0)\n    qc.measure(0, 0)\n    qc.measure(1, 0)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2, 1)\n    expected.x(0)\n    expected.measure(0, 0)\n    expected.delay(1200, 1)\n    expected.measure(1, 0)\n    expected.delay(1000, 0)\n    self.assertEqual(expected, scheduled)",
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_measure_after_measure(self, schedule_pass):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test if ALAP/ASAP schedules circuits with measure after measure with a common clbit.\\n        See: https://github.com/Qiskit/qiskit-terra/issues/7654\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524M\u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2518\u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2524M\u251c\\n                   \u2551 \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                   0  0\\n\\n        (scheduled)\\n                    \u250c\u2500\u2500\u2500\u2510       \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(1000[dt]) \u251c\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1200[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551         \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                                 0          0\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.x(0)\n    qc.measure(0, 0)\n    qc.measure(1, 0)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2, 1)\n    expected.x(0)\n    expected.measure(0, 0)\n    expected.delay(1200, 1)\n    expected.measure(1, 0)\n    expected.delay(1000, 0)\n    self.assertEqual(expected, scheduled)"
        ]
    },
    {
        "func_name": "test_c_if_on_different_qubits",
        "original": "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_c_if_on_different_qubits(self, schedule_pass):\n    \"\"\"Test if ALAP/ASAP schedules circuits with `c_if`s on different qubits.\n\n        (input)\n             \u250c\u2500\u2510\n        q_0: \u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2565\u2518   \u250c\u2500\u2500\u2500\u2510\n        q_1: \u2500\u256b\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n              \u2551    \u2514\u2500\u2565\u2500\u2518      \u250c\u2500\u2500\u2500\u2510\n        q_2: \u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\n              \u2551      \u2551        \u2514\u2500\u2565\u2500\u2518\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\n        c: 1/\u2550\u2569\u2550\u2561 c_0 = T \u255e\u2561 c_0 = T \u255e\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        (scheduled)\n\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2551       \u2514\u2500\u2565\u2500\u2518          \u250c\u2500\u2500\u2500\u2510\n        q_2: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551         \u2551            \u2514\u2500\u2565\u2500\u2518\n                                 \u2551    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\n                                 0    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \"\"\"\n    qc = QuantumCircuit(3, 1)\n    qc.measure(0, 0)\n    qc.x(1).c_if(0, True)\n    qc.x(2).c_if(0, True)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(3, 1)\n    expected.measure(0, 0)\n    expected.delay(1000, 1)\n    expected.delay(1000, 2)\n    expected.x(1).c_if(0, True)\n    expected.x(2).c_if(0, True)\n    expected.delay(200, 0)\n    self.assertEqual(expected, scheduled)",
        "mutated": [
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_c_if_on_different_qubits(self, schedule_pass):\n    if False:\n        i = 10\n    'Test if ALAP/ASAP schedules circuits with `c_if`s on different qubits.\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n              \u2551    \u2514\u2500\u2565\u2500\u2518      \u250c\u2500\u2500\u2500\u2510\\n        q_2: \u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n              \u2551      \u2551        \u2514\u2500\u2565\u2500\u2518\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2569\u2550\u2561 c_0 = T \u255e\u2561 c_0 = T \u255e\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        (scheduled)\\n\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2551       \u2514\u2500\u2565\u2500\u2518          \u250c\u2500\u2500\u2500\u2510\\n        q_2: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551         \u2551            \u2514\u2500\u2565\u2500\u2518\\n                                 \u2551    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\\n                                 0    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        '\n    qc = QuantumCircuit(3, 1)\n    qc.measure(0, 0)\n    qc.x(1).c_if(0, True)\n    qc.x(2).c_if(0, True)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(3, 1)\n    expected.measure(0, 0)\n    expected.delay(1000, 1)\n    expected.delay(1000, 2)\n    expected.x(1).c_if(0, True)\n    expected.x(2).c_if(0, True)\n    expected.delay(200, 0)\n    self.assertEqual(expected, scheduled)",
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_c_if_on_different_qubits(self, schedule_pass):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test if ALAP/ASAP schedules circuits with `c_if`s on different qubits.\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n              \u2551    \u2514\u2500\u2565\u2500\u2518      \u250c\u2500\u2500\u2500\u2510\\n        q_2: \u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n              \u2551      \u2551        \u2514\u2500\u2565\u2500\u2518\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2569\u2550\u2561 c_0 = T \u255e\u2561 c_0 = T \u255e\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        (scheduled)\\n\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2551       \u2514\u2500\u2565\u2500\u2518          \u250c\u2500\u2500\u2500\u2510\\n        q_2: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551         \u2551            \u2514\u2500\u2565\u2500\u2518\\n                                 \u2551    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\\n                                 0    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        '\n    qc = QuantumCircuit(3, 1)\n    qc.measure(0, 0)\n    qc.x(1).c_if(0, True)\n    qc.x(2).c_if(0, True)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(3, 1)\n    expected.measure(0, 0)\n    expected.delay(1000, 1)\n    expected.delay(1000, 2)\n    expected.x(1).c_if(0, True)\n    expected.x(2).c_if(0, True)\n    expected.delay(200, 0)\n    self.assertEqual(expected, scheduled)",
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_c_if_on_different_qubits(self, schedule_pass):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test if ALAP/ASAP schedules circuits with `c_if`s on different qubits.\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n              \u2551    \u2514\u2500\u2565\u2500\u2518      \u250c\u2500\u2500\u2500\u2510\\n        q_2: \u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n              \u2551      \u2551        \u2514\u2500\u2565\u2500\u2518\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2569\u2550\u2561 c_0 = T \u255e\u2561 c_0 = T \u255e\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        (scheduled)\\n\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2551       \u2514\u2500\u2565\u2500\u2518          \u250c\u2500\u2500\u2500\u2510\\n        q_2: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551         \u2551            \u2514\u2500\u2565\u2500\u2518\\n                                 \u2551    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\\n                                 0    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        '\n    qc = QuantumCircuit(3, 1)\n    qc.measure(0, 0)\n    qc.x(1).c_if(0, True)\n    qc.x(2).c_if(0, True)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(3, 1)\n    expected.measure(0, 0)\n    expected.delay(1000, 1)\n    expected.delay(1000, 2)\n    expected.x(1).c_if(0, True)\n    expected.x(2).c_if(0, True)\n    expected.delay(200, 0)\n    self.assertEqual(expected, scheduled)",
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_c_if_on_different_qubits(self, schedule_pass):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test if ALAP/ASAP schedules circuits with `c_if`s on different qubits.\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n              \u2551    \u2514\u2500\u2565\u2500\u2518      \u250c\u2500\u2500\u2500\u2510\\n        q_2: \u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n              \u2551      \u2551        \u2514\u2500\u2565\u2500\u2518\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2569\u2550\u2561 c_0 = T \u255e\u2561 c_0 = T \u255e\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        (scheduled)\\n\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2551       \u2514\u2500\u2565\u2500\u2518          \u250c\u2500\u2500\u2500\u2510\\n        q_2: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551         \u2551            \u2514\u2500\u2565\u2500\u2518\\n                                 \u2551    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\\n                                 0    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        '\n    qc = QuantumCircuit(3, 1)\n    qc.measure(0, 0)\n    qc.x(1).c_if(0, True)\n    qc.x(2).c_if(0, True)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(3, 1)\n    expected.measure(0, 0)\n    expected.delay(1000, 1)\n    expected.delay(1000, 2)\n    expected.x(1).c_if(0, True)\n    expected.x(2).c_if(0, True)\n    expected.delay(200, 0)\n    self.assertEqual(expected, scheduled)",
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_c_if_on_different_qubits(self, schedule_pass):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test if ALAP/ASAP schedules circuits with `c_if`s on different qubits.\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n              \u2551    \u2514\u2500\u2565\u2500\u2518      \u250c\u2500\u2500\u2500\u2510\\n        q_2: \u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n              \u2551      \u2551        \u2514\u2500\u2565\u2500\u2518\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2569\u2550\u2561 c_0 = T \u255e\u2561 c_0 = T \u255e\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        (scheduled)\\n\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2551       \u2514\u2500\u2565\u2500\u2518          \u250c\u2500\u2500\u2500\u2510\\n        q_2: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551         \u2551            \u2514\u2500\u2565\u2500\u2518\\n                                 \u2551    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\\n                                 0    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        '\n    qc = QuantumCircuit(3, 1)\n    qc.measure(0, 0)\n    qc.x(1).c_if(0, True)\n    qc.x(2).c_if(0, True)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(3, 1)\n    expected.measure(0, 0)\n    expected.delay(1000, 1)\n    expected.delay(1000, 2)\n    expected.x(1).c_if(0, True)\n    expected.x(2).c_if(0, True)\n    expected.delay(200, 0)\n    self.assertEqual(expected, scheduled)"
        ]
    },
    {
        "func_name": "test_shorter_measure_after_measure",
        "original": "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_shorter_measure_after_measure(self, schedule_pass):\n    \"\"\"Test if ALAP/ASAP schedules circuits with shorter measure after measure with a common clbit.\n\n        (input)\n             \u250c\u2500\u2510\n        q_0: \u2524M\u251c\u2500\u2500\u2500\n             \u2514\u2565\u2518\u250c\u2500\u2510\n        q_1: \u2500\u256b\u2500\u2524M\u251c\n              \u2551 \u2514\u2565\u2518\n        c: 1/\u2550\u2569\u2550\u2550\u2569\u2550\n              0  0\n\n        (scheduled)\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(700[dt]) \u251c\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551        \u2514\u2565\u2518\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n                                 0         0\n        \"\"\"\n    qc = QuantumCircuit(2, 1)\n    qc.measure(0, 0)\n    qc.measure(1, 0)\n    durations = InstructionDurations([('measure', [0], 1000), ('measure', [1], 700)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2, 1)\n    expected.measure(0, 0)\n    expected.delay(1000, 1)\n    expected.measure(1, 0)\n    expected.delay(700, 0)\n    self.assertEqual(expected, scheduled)",
        "mutated": [
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_shorter_measure_after_measure(self, schedule_pass):\n    if False:\n        i = 10\n    'Test if ALAP/ASAP schedules circuits with shorter measure after measure with a common clbit.\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\\n             \u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2524M\u251c\\n              \u2551 \u2514\u2565\u2518\\n        c: 1/\u2550\u2569\u2550\u2550\u2569\u2550\\n              0  0\\n\\n        (scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(700[dt]) \u251c\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551        \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                                 0         0\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.measure(0, 0)\n    qc.measure(1, 0)\n    durations = InstructionDurations([('measure', [0], 1000), ('measure', [1], 700)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2, 1)\n    expected.measure(0, 0)\n    expected.delay(1000, 1)\n    expected.measure(1, 0)\n    expected.delay(700, 0)\n    self.assertEqual(expected, scheduled)",
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_shorter_measure_after_measure(self, schedule_pass):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test if ALAP/ASAP schedules circuits with shorter measure after measure with a common clbit.\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\\n             \u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2524M\u251c\\n              \u2551 \u2514\u2565\u2518\\n        c: 1/\u2550\u2569\u2550\u2550\u2569\u2550\\n              0  0\\n\\n        (scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(700[dt]) \u251c\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551        \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                                 0         0\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.measure(0, 0)\n    qc.measure(1, 0)\n    durations = InstructionDurations([('measure', [0], 1000), ('measure', [1], 700)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2, 1)\n    expected.measure(0, 0)\n    expected.delay(1000, 1)\n    expected.measure(1, 0)\n    expected.delay(700, 0)\n    self.assertEqual(expected, scheduled)",
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_shorter_measure_after_measure(self, schedule_pass):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test if ALAP/ASAP schedules circuits with shorter measure after measure with a common clbit.\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\\n             \u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2524M\u251c\\n              \u2551 \u2514\u2565\u2518\\n        c: 1/\u2550\u2569\u2550\u2550\u2569\u2550\\n              0  0\\n\\n        (scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(700[dt]) \u251c\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551        \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                                 0         0\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.measure(0, 0)\n    qc.measure(1, 0)\n    durations = InstructionDurations([('measure', [0], 1000), ('measure', [1], 700)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2, 1)\n    expected.measure(0, 0)\n    expected.delay(1000, 1)\n    expected.measure(1, 0)\n    expected.delay(700, 0)\n    self.assertEqual(expected, scheduled)",
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_shorter_measure_after_measure(self, schedule_pass):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test if ALAP/ASAP schedules circuits with shorter measure after measure with a common clbit.\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\\n             \u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2524M\u251c\\n              \u2551 \u2514\u2565\u2518\\n        c: 1/\u2550\u2569\u2550\u2550\u2569\u2550\\n              0  0\\n\\n        (scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(700[dt]) \u251c\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551        \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                                 0         0\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.measure(0, 0)\n    qc.measure(1, 0)\n    durations = InstructionDurations([('measure', [0], 1000), ('measure', [1], 700)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2, 1)\n    expected.measure(0, 0)\n    expected.delay(1000, 1)\n    expected.measure(1, 0)\n    expected.delay(700, 0)\n    self.assertEqual(expected, scheduled)",
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_shorter_measure_after_measure(self, schedule_pass):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test if ALAP/ASAP schedules circuits with shorter measure after measure with a common clbit.\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\\n             \u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2524M\u251c\\n              \u2551 \u2514\u2565\u2518\\n        c: 1/\u2550\u2569\u2550\u2550\u2569\u2550\\n              0  0\\n\\n        (scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(700[dt]) \u251c\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551        \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                                 0         0\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.measure(0, 0)\n    qc.measure(1, 0)\n    durations = InstructionDurations([('measure', [0], 1000), ('measure', [1], 700)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2, 1)\n    expected.measure(0, 0)\n    expected.delay(1000, 1)\n    expected.measure(1, 0)\n    expected.delay(700, 0)\n    self.assertEqual(expected, scheduled)"
        ]
    },
    {
        "func_name": "test_measure_after_c_if",
        "original": "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_measure_after_c_if(self, schedule_pass):\n    \"\"\"Test if ALAP/ASAP schedules circuits with c_if after measure with a common clbit.\n\n        (input)\n             \u250c\u2500\u2510\n        q_0: \u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2565\u2518   \u250c\u2500\u2500\u2500\u2510\n        q_1: \u2500\u256b\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\n              \u2551    \u2514\u2500\u2565\u2500\u2518   \u250c\u2500\u2510\n        q_2: \u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\n        c: 1/\u2550\u2569\u2550\u2561 c_0 = T \u255e\u2550\u2569\u2550\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0\n\n        (scheduled)\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(1000[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Delay(800[dt]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2551        \u2514\u2500\u2565\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        q_2: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551     \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510           \u2514\u2565\u2518\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n                                 0     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            0\n        \"\"\"\n    qc = QuantumCircuit(3, 1)\n    qc.measure(0, 0)\n    qc.x(1).c_if(0, 1)\n    qc.measure(2, 0)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(3, 1)\n    expected.delay(1000, 1)\n    expected.delay(1000, 2)\n    expected.measure(0, 0)\n    expected.x(1).c_if(0, 1)\n    expected.measure(2, 0)\n    expected.delay(1000, 0)\n    expected.delay(800, 1)\n    self.assertEqual(expected, scheduled)",
        "mutated": [
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_measure_after_c_if(self, schedule_pass):\n    if False:\n        i = 10\n    'Test if ALAP/ASAP schedules circuits with c_if after measure with a common clbit.\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\\n              \u2551    \u2514\u2500\u2565\u2500\u2518   \u250c\u2500\u2510\\n        q_2: \u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\\n        c: 1/\u2550\u2569\u2550\u2561 c_0 = T \u255e\u2550\u2569\u2550\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0\\n\\n        (scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(1000[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Delay(800[dt]) \u251c\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2551        \u2514\u2500\u2565\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_2: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551     \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510           \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                                 0     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            0\\n        '\n    qc = QuantumCircuit(3, 1)\n    qc.measure(0, 0)\n    qc.x(1).c_if(0, 1)\n    qc.measure(2, 0)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(3, 1)\n    expected.delay(1000, 1)\n    expected.delay(1000, 2)\n    expected.measure(0, 0)\n    expected.x(1).c_if(0, 1)\n    expected.measure(2, 0)\n    expected.delay(1000, 0)\n    expected.delay(800, 1)\n    self.assertEqual(expected, scheduled)",
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_measure_after_c_if(self, schedule_pass):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test if ALAP/ASAP schedules circuits with c_if after measure with a common clbit.\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\\n              \u2551    \u2514\u2500\u2565\u2500\u2518   \u250c\u2500\u2510\\n        q_2: \u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\\n        c: 1/\u2550\u2569\u2550\u2561 c_0 = T \u255e\u2550\u2569\u2550\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0\\n\\n        (scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(1000[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Delay(800[dt]) \u251c\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2551        \u2514\u2500\u2565\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_2: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551     \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510           \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                                 0     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            0\\n        '\n    qc = QuantumCircuit(3, 1)\n    qc.measure(0, 0)\n    qc.x(1).c_if(0, 1)\n    qc.measure(2, 0)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(3, 1)\n    expected.delay(1000, 1)\n    expected.delay(1000, 2)\n    expected.measure(0, 0)\n    expected.x(1).c_if(0, 1)\n    expected.measure(2, 0)\n    expected.delay(1000, 0)\n    expected.delay(800, 1)\n    self.assertEqual(expected, scheduled)",
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_measure_after_c_if(self, schedule_pass):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test if ALAP/ASAP schedules circuits with c_if after measure with a common clbit.\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\\n              \u2551    \u2514\u2500\u2565\u2500\u2518   \u250c\u2500\u2510\\n        q_2: \u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\\n        c: 1/\u2550\u2569\u2550\u2561 c_0 = T \u255e\u2550\u2569\u2550\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0\\n\\n        (scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(1000[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Delay(800[dt]) \u251c\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2551        \u2514\u2500\u2565\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_2: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551     \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510           \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                                 0     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            0\\n        '\n    qc = QuantumCircuit(3, 1)\n    qc.measure(0, 0)\n    qc.x(1).c_if(0, 1)\n    qc.measure(2, 0)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(3, 1)\n    expected.delay(1000, 1)\n    expected.delay(1000, 2)\n    expected.measure(0, 0)\n    expected.x(1).c_if(0, 1)\n    expected.measure(2, 0)\n    expected.delay(1000, 0)\n    expected.delay(800, 1)\n    self.assertEqual(expected, scheduled)",
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_measure_after_c_if(self, schedule_pass):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test if ALAP/ASAP schedules circuits with c_if after measure with a common clbit.\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\\n              \u2551    \u2514\u2500\u2565\u2500\u2518   \u250c\u2500\u2510\\n        q_2: \u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\\n        c: 1/\u2550\u2569\u2550\u2561 c_0 = T \u255e\u2550\u2569\u2550\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0\\n\\n        (scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(1000[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Delay(800[dt]) \u251c\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2551        \u2514\u2500\u2565\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_2: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551     \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510           \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                                 0     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            0\\n        '\n    qc = QuantumCircuit(3, 1)\n    qc.measure(0, 0)\n    qc.x(1).c_if(0, 1)\n    qc.measure(2, 0)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(3, 1)\n    expected.delay(1000, 1)\n    expected.delay(1000, 2)\n    expected.measure(0, 0)\n    expected.x(1).c_if(0, 1)\n    expected.measure(2, 0)\n    expected.delay(1000, 0)\n    expected.delay(800, 1)\n    self.assertEqual(expected, scheduled)",
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_measure_after_c_if(self, schedule_pass):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test if ALAP/ASAP schedules circuits with c_if after measure with a common clbit.\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\\n              \u2551    \u2514\u2500\u2565\u2500\u2518   \u250c\u2500\u2510\\n        q_2: \u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\\n        c: 1/\u2550\u2569\u2550\u2561 c_0 = T \u255e\u2550\u2569\u2550\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0\\n\\n        (scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(1000[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Delay(800[dt]) \u251c\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2551        \u2514\u2500\u2565\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_2: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551     \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510           \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                                 0     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            0\\n        '\n    qc = QuantumCircuit(3, 1)\n    qc.measure(0, 0)\n    qc.x(1).c_if(0, 1)\n    qc.measure(2, 0)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    pm = PassManager([schedule_pass(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(3, 1)\n    expected.delay(1000, 1)\n    expected.delay(1000, 2)\n    expected.measure(0, 0)\n    expected.x(1).c_if(0, 1)\n    expected.measure(2, 0)\n    expected.delay(1000, 0)\n    expected.delay(800, 1)\n    self.assertEqual(expected, scheduled)"
        ]
    },
    {
        "func_name": "test_parallel_gate_different_length",
        "original": "def test_parallel_gate_different_length(self):\n    \"\"\"Test circuit having two parallel instruction with different length.\n\n        (input)\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\n        q_0: \u2524 X \u251c\u2524M\u251c\u2500\u2500\u2500\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2565\u2518\u250c\u2500\u2510\n        q_1: \u2524 X \u251c\u2500\u256b\u2500\u2524M\u251c\n             \u2514\u2500\u2500\u2500\u2518 \u2551 \u2514\u2565\u2518\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\n                   0  1\n\n        (expected, ALAP)\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\n        q_0: \u2524 Delay(200[dt]) \u251c\u2524 X \u251c\u2524M\u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u252c\u2500\u252c\u2518\u2514\u2565\u2518\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u256b\u2500\n                   \u2514\u2500\u2500\u2500\u2518        \u2514\u2565\u2518  \u2551\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2569\u2550\n                                 1   0\n\n        (expected, ASAP)\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 X \u251c\u2524M\u251c\u2524 Delay(200[dt]) \u251c\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        q_1: \u2524 X \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2518 \u2551        \u2514\u2565\u2518\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n                   0         1\n\n        \"\"\"\n    qc = QuantumCircuit(2, 2)\n    qc.x(0)\n    qc.x(1)\n    qc.measure(0, 0)\n    qc.measure(1, 1)\n    durations = InstructionDurations([('x', [0], 200), ('x', [1], 400), ('measure', None, 1000)])\n    pm = PassManager([ALAPScheduleAnalysis(durations), PadDelay()])\n    qc_alap = pm.run(qc)\n    alap_expected = QuantumCircuit(2, 2)\n    alap_expected.delay(200, 0)\n    alap_expected.x(0)\n    alap_expected.x(1)\n    alap_expected.measure(0, 0)\n    alap_expected.measure(1, 1)\n    self.assertEqual(qc_alap, alap_expected)\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    qc_asap = pm.run(qc)\n    asap_expected = QuantumCircuit(2, 2)\n    asap_expected.x(0)\n    asap_expected.x(1)\n    asap_expected.measure(0, 0)\n    asap_expected.measure(1, 1)\n    asap_expected.delay(200, 0)\n    self.assertEqual(qc_asap, asap_expected)",
        "mutated": [
            "def test_parallel_gate_different_length(self):\n    if False:\n        i = 10\n    'Test circuit having two parallel instruction with different length.\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524M\u251c\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2524 X \u251c\u2500\u256b\u2500\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2518 \u2551 \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                   0  1\\n\\n        (expected, ALAP)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 Delay(200[dt]) \u251c\u2524 X \u251c\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u252c\u2500\u252c\u2518\u2514\u2565\u2518\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u256b\u2500\\n                   \u2514\u2500\u2500\u2500\u2518        \u2514\u2565\u2518  \u2551\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2569\u2550\\n                                 1   0\\n\\n        (expected, ASAP)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524M\u251c\u2524 Delay(200[dt]) \u251c\\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 X \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2518 \u2551        \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                   0         1\\n\\n        '\n    qc = QuantumCircuit(2, 2)\n    qc.x(0)\n    qc.x(1)\n    qc.measure(0, 0)\n    qc.measure(1, 1)\n    durations = InstructionDurations([('x', [0], 200), ('x', [1], 400), ('measure', None, 1000)])\n    pm = PassManager([ALAPScheduleAnalysis(durations), PadDelay()])\n    qc_alap = pm.run(qc)\n    alap_expected = QuantumCircuit(2, 2)\n    alap_expected.delay(200, 0)\n    alap_expected.x(0)\n    alap_expected.x(1)\n    alap_expected.measure(0, 0)\n    alap_expected.measure(1, 1)\n    self.assertEqual(qc_alap, alap_expected)\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    qc_asap = pm.run(qc)\n    asap_expected = QuantumCircuit(2, 2)\n    asap_expected.x(0)\n    asap_expected.x(1)\n    asap_expected.measure(0, 0)\n    asap_expected.measure(1, 1)\n    asap_expected.delay(200, 0)\n    self.assertEqual(qc_asap, asap_expected)",
            "def test_parallel_gate_different_length(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test circuit having two parallel instruction with different length.\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524M\u251c\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2524 X \u251c\u2500\u256b\u2500\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2518 \u2551 \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                   0  1\\n\\n        (expected, ALAP)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 Delay(200[dt]) \u251c\u2524 X \u251c\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u252c\u2500\u252c\u2518\u2514\u2565\u2518\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u256b\u2500\\n                   \u2514\u2500\u2500\u2500\u2518        \u2514\u2565\u2518  \u2551\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2569\u2550\\n                                 1   0\\n\\n        (expected, ASAP)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524M\u251c\u2524 Delay(200[dt]) \u251c\\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 X \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2518 \u2551        \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                   0         1\\n\\n        '\n    qc = QuantumCircuit(2, 2)\n    qc.x(0)\n    qc.x(1)\n    qc.measure(0, 0)\n    qc.measure(1, 1)\n    durations = InstructionDurations([('x', [0], 200), ('x', [1], 400), ('measure', None, 1000)])\n    pm = PassManager([ALAPScheduleAnalysis(durations), PadDelay()])\n    qc_alap = pm.run(qc)\n    alap_expected = QuantumCircuit(2, 2)\n    alap_expected.delay(200, 0)\n    alap_expected.x(0)\n    alap_expected.x(1)\n    alap_expected.measure(0, 0)\n    alap_expected.measure(1, 1)\n    self.assertEqual(qc_alap, alap_expected)\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    qc_asap = pm.run(qc)\n    asap_expected = QuantumCircuit(2, 2)\n    asap_expected.x(0)\n    asap_expected.x(1)\n    asap_expected.measure(0, 0)\n    asap_expected.measure(1, 1)\n    asap_expected.delay(200, 0)\n    self.assertEqual(qc_asap, asap_expected)",
            "def test_parallel_gate_different_length(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test circuit having two parallel instruction with different length.\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524M\u251c\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2524 X \u251c\u2500\u256b\u2500\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2518 \u2551 \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                   0  1\\n\\n        (expected, ALAP)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 Delay(200[dt]) \u251c\u2524 X \u251c\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u252c\u2500\u252c\u2518\u2514\u2565\u2518\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u256b\u2500\\n                   \u2514\u2500\u2500\u2500\u2518        \u2514\u2565\u2518  \u2551\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2569\u2550\\n                                 1   0\\n\\n        (expected, ASAP)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524M\u251c\u2524 Delay(200[dt]) \u251c\\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 X \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2518 \u2551        \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                   0         1\\n\\n        '\n    qc = QuantumCircuit(2, 2)\n    qc.x(0)\n    qc.x(1)\n    qc.measure(0, 0)\n    qc.measure(1, 1)\n    durations = InstructionDurations([('x', [0], 200), ('x', [1], 400), ('measure', None, 1000)])\n    pm = PassManager([ALAPScheduleAnalysis(durations), PadDelay()])\n    qc_alap = pm.run(qc)\n    alap_expected = QuantumCircuit(2, 2)\n    alap_expected.delay(200, 0)\n    alap_expected.x(0)\n    alap_expected.x(1)\n    alap_expected.measure(0, 0)\n    alap_expected.measure(1, 1)\n    self.assertEqual(qc_alap, alap_expected)\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    qc_asap = pm.run(qc)\n    asap_expected = QuantumCircuit(2, 2)\n    asap_expected.x(0)\n    asap_expected.x(1)\n    asap_expected.measure(0, 0)\n    asap_expected.measure(1, 1)\n    asap_expected.delay(200, 0)\n    self.assertEqual(qc_asap, asap_expected)",
            "def test_parallel_gate_different_length(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test circuit having two parallel instruction with different length.\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524M\u251c\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2524 X \u251c\u2500\u256b\u2500\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2518 \u2551 \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                   0  1\\n\\n        (expected, ALAP)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 Delay(200[dt]) \u251c\u2524 X \u251c\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u252c\u2500\u252c\u2518\u2514\u2565\u2518\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u256b\u2500\\n                   \u2514\u2500\u2500\u2500\u2518        \u2514\u2565\u2518  \u2551\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2569\u2550\\n                                 1   0\\n\\n        (expected, ASAP)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524M\u251c\u2524 Delay(200[dt]) \u251c\\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 X \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2518 \u2551        \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                   0         1\\n\\n        '\n    qc = QuantumCircuit(2, 2)\n    qc.x(0)\n    qc.x(1)\n    qc.measure(0, 0)\n    qc.measure(1, 1)\n    durations = InstructionDurations([('x', [0], 200), ('x', [1], 400), ('measure', None, 1000)])\n    pm = PassManager([ALAPScheduleAnalysis(durations), PadDelay()])\n    qc_alap = pm.run(qc)\n    alap_expected = QuantumCircuit(2, 2)\n    alap_expected.delay(200, 0)\n    alap_expected.x(0)\n    alap_expected.x(1)\n    alap_expected.measure(0, 0)\n    alap_expected.measure(1, 1)\n    self.assertEqual(qc_alap, alap_expected)\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    qc_asap = pm.run(qc)\n    asap_expected = QuantumCircuit(2, 2)\n    asap_expected.x(0)\n    asap_expected.x(1)\n    asap_expected.measure(0, 0)\n    asap_expected.measure(1, 1)\n    asap_expected.delay(200, 0)\n    self.assertEqual(qc_asap, asap_expected)",
            "def test_parallel_gate_different_length(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test circuit having two parallel instruction with different length.\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524M\u251c\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2524 X \u251c\u2500\u256b\u2500\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2518 \u2551 \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                   0  1\\n\\n        (expected, ALAP)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 Delay(200[dt]) \u251c\u2524 X \u251c\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u252c\u2500\u252c\u2518\u2514\u2565\u2518\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u256b\u2500\\n                   \u2514\u2500\u2500\u2500\u2518        \u2514\u2565\u2518  \u2551\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2569\u2550\\n                                 1   0\\n\\n        (expected, ASAP)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524M\u251c\u2524 Delay(200[dt]) \u251c\\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 X \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2518 \u2551        \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                   0         1\\n\\n        '\n    qc = QuantumCircuit(2, 2)\n    qc.x(0)\n    qc.x(1)\n    qc.measure(0, 0)\n    qc.measure(1, 1)\n    durations = InstructionDurations([('x', [0], 200), ('x', [1], 400), ('measure', None, 1000)])\n    pm = PassManager([ALAPScheduleAnalysis(durations), PadDelay()])\n    qc_alap = pm.run(qc)\n    alap_expected = QuantumCircuit(2, 2)\n    alap_expected.delay(200, 0)\n    alap_expected.x(0)\n    alap_expected.x(1)\n    alap_expected.measure(0, 0)\n    alap_expected.measure(1, 1)\n    self.assertEqual(qc_alap, alap_expected)\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    qc_asap = pm.run(qc)\n    asap_expected = QuantumCircuit(2, 2)\n    asap_expected.x(0)\n    asap_expected.x(1)\n    asap_expected.measure(0, 0)\n    asap_expected.measure(1, 1)\n    asap_expected.delay(200, 0)\n    self.assertEqual(qc_asap, asap_expected)"
        ]
    },
    {
        "func_name": "test_parallel_gate_different_length_with_barrier",
        "original": "def test_parallel_gate_different_length_with_barrier(self):\n    \"\"\"Test circuit having two parallel instruction with different length with barrier.\n\n        (input)\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\n        q_0: \u2524 X \u251c\u2524M\u251c\u2500\u2500\u2500\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2565\u2518\u250c\u2500\u2510\n        q_1: \u2524 X \u251c\u2500\u256b\u2500\u2524M\u251c\n             \u2514\u2500\u2500\u2500\u2518 \u2551 \u2514\u2565\u2518\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\n                   0  1\n\n        (expected, ALAP)\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2510\n        q_0: \u2524 Delay(200[dt]) \u251c\u2524 X \u251c\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c\n                   \u2514\u2500\u2500\u2500\u2518             \u2591  \u2551 \u2514\u2565\u2518\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\n                                        0  1\n\n        (expected, ASAP)\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2510\n        q_0: \u2524 X \u251c\u2524 Delay(200[dt]) \u251c\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510\n        q_1: \u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c\n             \u2514\u2500\u2500\u2500\u2518                   \u2591  \u2551 \u2514\u2565\u2518\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\n                                        0  1\n        \"\"\"\n    qc = QuantumCircuit(2, 2)\n    qc.x(0)\n    qc.x(1)\n    qc.barrier()\n    qc.measure(0, 0)\n    qc.measure(1, 1)\n    durations = InstructionDurations([('x', [0], 200), ('x', [1], 400), ('measure', None, 1000)])\n    pm = PassManager([ALAPScheduleAnalysis(durations), PadDelay()])\n    qc_alap = pm.run(qc)\n    alap_expected = QuantumCircuit(2, 2)\n    alap_expected.delay(200, 0)\n    alap_expected.x(0)\n    alap_expected.x(1)\n    alap_expected.barrier()\n    alap_expected.measure(0, 0)\n    alap_expected.measure(1, 1)\n    self.assertEqual(qc_alap, alap_expected)\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    qc_asap = pm.run(qc)\n    asap_expected = QuantumCircuit(2, 2)\n    asap_expected.x(0)\n    asap_expected.delay(200, 0)\n    asap_expected.x(1)\n    asap_expected.barrier()\n    asap_expected.measure(0, 0)\n    asap_expected.measure(1, 1)\n    self.assertEqual(qc_asap, asap_expected)",
        "mutated": [
            "def test_parallel_gate_different_length_with_barrier(self):\n    if False:\n        i = 10\n    'Test circuit having two parallel instruction with different length with barrier.\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524M\u251c\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2524 X \u251c\u2500\u256b\u2500\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2518 \u2551 \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                   0  1\\n\\n        (expected, ALAP)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2510\\n        q_0: \u2524 Delay(200[dt]) \u251c\u2524 X \u251c\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c\\n                   \u2514\u2500\u2500\u2500\u2518             \u2591  \u2551 \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                                        0  1\\n\\n        (expected, ASAP)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524 Delay(200[dt]) \u251c\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2518                   \u2591  \u2551 \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                                        0  1\\n        '\n    qc = QuantumCircuit(2, 2)\n    qc.x(0)\n    qc.x(1)\n    qc.barrier()\n    qc.measure(0, 0)\n    qc.measure(1, 1)\n    durations = InstructionDurations([('x', [0], 200), ('x', [1], 400), ('measure', None, 1000)])\n    pm = PassManager([ALAPScheduleAnalysis(durations), PadDelay()])\n    qc_alap = pm.run(qc)\n    alap_expected = QuantumCircuit(2, 2)\n    alap_expected.delay(200, 0)\n    alap_expected.x(0)\n    alap_expected.x(1)\n    alap_expected.barrier()\n    alap_expected.measure(0, 0)\n    alap_expected.measure(1, 1)\n    self.assertEqual(qc_alap, alap_expected)\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    qc_asap = pm.run(qc)\n    asap_expected = QuantumCircuit(2, 2)\n    asap_expected.x(0)\n    asap_expected.delay(200, 0)\n    asap_expected.x(1)\n    asap_expected.barrier()\n    asap_expected.measure(0, 0)\n    asap_expected.measure(1, 1)\n    self.assertEqual(qc_asap, asap_expected)",
            "def test_parallel_gate_different_length_with_barrier(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test circuit having two parallel instruction with different length with barrier.\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524M\u251c\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2524 X \u251c\u2500\u256b\u2500\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2518 \u2551 \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                   0  1\\n\\n        (expected, ALAP)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2510\\n        q_0: \u2524 Delay(200[dt]) \u251c\u2524 X \u251c\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c\\n                   \u2514\u2500\u2500\u2500\u2518             \u2591  \u2551 \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                                        0  1\\n\\n        (expected, ASAP)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524 Delay(200[dt]) \u251c\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2518                   \u2591  \u2551 \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                                        0  1\\n        '\n    qc = QuantumCircuit(2, 2)\n    qc.x(0)\n    qc.x(1)\n    qc.barrier()\n    qc.measure(0, 0)\n    qc.measure(1, 1)\n    durations = InstructionDurations([('x', [0], 200), ('x', [1], 400), ('measure', None, 1000)])\n    pm = PassManager([ALAPScheduleAnalysis(durations), PadDelay()])\n    qc_alap = pm.run(qc)\n    alap_expected = QuantumCircuit(2, 2)\n    alap_expected.delay(200, 0)\n    alap_expected.x(0)\n    alap_expected.x(1)\n    alap_expected.barrier()\n    alap_expected.measure(0, 0)\n    alap_expected.measure(1, 1)\n    self.assertEqual(qc_alap, alap_expected)\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    qc_asap = pm.run(qc)\n    asap_expected = QuantumCircuit(2, 2)\n    asap_expected.x(0)\n    asap_expected.delay(200, 0)\n    asap_expected.x(1)\n    asap_expected.barrier()\n    asap_expected.measure(0, 0)\n    asap_expected.measure(1, 1)\n    self.assertEqual(qc_asap, asap_expected)",
            "def test_parallel_gate_different_length_with_barrier(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test circuit having two parallel instruction with different length with barrier.\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524M\u251c\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2524 X \u251c\u2500\u256b\u2500\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2518 \u2551 \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                   0  1\\n\\n        (expected, ALAP)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2510\\n        q_0: \u2524 Delay(200[dt]) \u251c\u2524 X \u251c\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c\\n                   \u2514\u2500\u2500\u2500\u2518             \u2591  \u2551 \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                                        0  1\\n\\n        (expected, ASAP)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524 Delay(200[dt]) \u251c\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2518                   \u2591  \u2551 \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                                        0  1\\n        '\n    qc = QuantumCircuit(2, 2)\n    qc.x(0)\n    qc.x(1)\n    qc.barrier()\n    qc.measure(0, 0)\n    qc.measure(1, 1)\n    durations = InstructionDurations([('x', [0], 200), ('x', [1], 400), ('measure', None, 1000)])\n    pm = PassManager([ALAPScheduleAnalysis(durations), PadDelay()])\n    qc_alap = pm.run(qc)\n    alap_expected = QuantumCircuit(2, 2)\n    alap_expected.delay(200, 0)\n    alap_expected.x(0)\n    alap_expected.x(1)\n    alap_expected.barrier()\n    alap_expected.measure(0, 0)\n    alap_expected.measure(1, 1)\n    self.assertEqual(qc_alap, alap_expected)\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    qc_asap = pm.run(qc)\n    asap_expected = QuantumCircuit(2, 2)\n    asap_expected.x(0)\n    asap_expected.delay(200, 0)\n    asap_expected.x(1)\n    asap_expected.barrier()\n    asap_expected.measure(0, 0)\n    asap_expected.measure(1, 1)\n    self.assertEqual(qc_asap, asap_expected)",
            "def test_parallel_gate_different_length_with_barrier(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test circuit having two parallel instruction with different length with barrier.\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524M\u251c\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2524 X \u251c\u2500\u256b\u2500\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2518 \u2551 \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                   0  1\\n\\n        (expected, ALAP)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2510\\n        q_0: \u2524 Delay(200[dt]) \u251c\u2524 X \u251c\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c\\n                   \u2514\u2500\u2500\u2500\u2518             \u2591  \u2551 \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                                        0  1\\n\\n        (expected, ASAP)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524 Delay(200[dt]) \u251c\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2518                   \u2591  \u2551 \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                                        0  1\\n        '\n    qc = QuantumCircuit(2, 2)\n    qc.x(0)\n    qc.x(1)\n    qc.barrier()\n    qc.measure(0, 0)\n    qc.measure(1, 1)\n    durations = InstructionDurations([('x', [0], 200), ('x', [1], 400), ('measure', None, 1000)])\n    pm = PassManager([ALAPScheduleAnalysis(durations), PadDelay()])\n    qc_alap = pm.run(qc)\n    alap_expected = QuantumCircuit(2, 2)\n    alap_expected.delay(200, 0)\n    alap_expected.x(0)\n    alap_expected.x(1)\n    alap_expected.barrier()\n    alap_expected.measure(0, 0)\n    alap_expected.measure(1, 1)\n    self.assertEqual(qc_alap, alap_expected)\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    qc_asap = pm.run(qc)\n    asap_expected = QuantumCircuit(2, 2)\n    asap_expected.x(0)\n    asap_expected.delay(200, 0)\n    asap_expected.x(1)\n    asap_expected.barrier()\n    asap_expected.measure(0, 0)\n    asap_expected.measure(1, 1)\n    self.assertEqual(qc_asap, asap_expected)",
            "def test_parallel_gate_different_length_with_barrier(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test circuit having two parallel instruction with different length with barrier.\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524M\u251c\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2524 X \u251c\u2500\u256b\u2500\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2518 \u2551 \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                   0  1\\n\\n        (expected, ALAP)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2510\\n        q_0: \u2524 Delay(200[dt]) \u251c\u2524 X \u251c\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c\\n                   \u2514\u2500\u2500\u2500\u2518             \u2591  \u2551 \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                                        0  1\\n\\n        (expected, ASAP)\\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2510\\n        q_0: \u2524 X \u251c\u2524 Delay(200[dt]) \u251c\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510\\n        q_1: \u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2518                   \u2591  \u2551 \u2514\u2565\u2518\\n        c: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\\n                                        0  1\\n        '\n    qc = QuantumCircuit(2, 2)\n    qc.x(0)\n    qc.x(1)\n    qc.barrier()\n    qc.measure(0, 0)\n    qc.measure(1, 1)\n    durations = InstructionDurations([('x', [0], 200), ('x', [1], 400), ('measure', None, 1000)])\n    pm = PassManager([ALAPScheduleAnalysis(durations), PadDelay()])\n    qc_alap = pm.run(qc)\n    alap_expected = QuantumCircuit(2, 2)\n    alap_expected.delay(200, 0)\n    alap_expected.x(0)\n    alap_expected.x(1)\n    alap_expected.barrier()\n    alap_expected.measure(0, 0)\n    alap_expected.measure(1, 1)\n    self.assertEqual(qc_alap, alap_expected)\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    qc_asap = pm.run(qc)\n    asap_expected = QuantumCircuit(2, 2)\n    asap_expected.x(0)\n    asap_expected.delay(200, 0)\n    asap_expected.x(1)\n    asap_expected.barrier()\n    asap_expected.measure(0, 0)\n    asap_expected.measure(1, 1)\n    self.assertEqual(qc_asap, asap_expected)"
        ]
    },
    {
        "func_name": "test_measure_after_c_if_on_edge_locking",
        "original": "def test_measure_after_c_if_on_edge_locking(self):\n    \"\"\"Test if ALAP/ASAP schedules circuits with c_if after measure with a common clbit.\n\n        The scheduler is configured to reproduce behavior of the 0.20.0,\n        in which clbit lock is applied to the end-edge of measure instruction.\n        See https://github.com/Qiskit/qiskit-terra/pull/7655\n\n        (input)\n             \u250c\u2500\u2510\n        q_0: \u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2565\u2518   \u250c\u2500\u2500\u2500\u2510\n        q_1: \u2500\u256b\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\n              \u2551    \u2514\u2500\u2565\u2500\u2518   \u250c\u2500\u2510\n        q_2: \u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\n        c: 1/\u2550\u2569\u2550\u2561 c_0 = T \u255e\u2550\u2569\u2550\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0\n\n        (ASAP scheduled)\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551       \u2514\u2500\u2565\u2500\u2518       \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\n                                 \u2551    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510    \u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n                                 0    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     0\n\n        (ALAP scheduled)\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2551       \u2514\u2500\u2565\u2500\u2518       \u250c\u2500\u2510\n        q_2: \u2500\u2524 Delay(200[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510    \u2514\u2565\u2518\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2569\u2550\n                                 0    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     0\n\n        \"\"\"\n    qc = QuantumCircuit(3, 1)\n    qc.measure(0, 0)\n    qc.x(1).c_if(0, 1)\n    qc.measure(2, 0)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    actual_asap = PassManager([SetIOLatency(clbit_write_latency=1000), ASAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    actual_alap = PassManager([SetIOLatency(clbit_write_latency=1000), ALAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    expected_asap = QuantumCircuit(3, 1)\n    expected_asap.measure(0, 0)\n    expected_asap.delay(1000, 1)\n    expected_asap.x(1).c_if(0, 1)\n    expected_asap.measure(2, 0)\n    expected_asap.delay(200, 0)\n    expected_asap.delay(200, 2)\n    self.assertEqual(expected_asap, actual_asap)\n    expected_alap = QuantumCircuit(3, 1)\n    expected_alap.measure(0, 0)\n    expected_alap.delay(1000, 1)\n    expected_alap.x(1).c_if(0, 1)\n    expected_alap.delay(200, 2)\n    expected_alap.measure(2, 0)\n    expected_alap.delay(200, 0)\n    self.assertEqual(expected_alap, actual_alap)",
        "mutated": [
            "def test_measure_after_c_if_on_edge_locking(self):\n    if False:\n        i = 10\n    'Test if ALAP/ASAP schedules circuits with c_if after measure with a common clbit.\\n\\n        The scheduler is configured to reproduce behavior of the 0.20.0,\\n        in which clbit lock is applied to the end-edge of measure instruction.\\n        See https://github.com/Qiskit/qiskit-terra/pull/7655\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\\n              \u2551    \u2514\u2500\u2565\u2500\u2518   \u250c\u2500\u2510\\n        q_2: \u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\\n        c: 1/\u2550\u2569\u2550\u2561 c_0 = T \u255e\u2550\u2569\u2550\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0\\n\\n        (ASAP scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551       \u2514\u2500\u2565\u2500\u2518       \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\\n                                 \u2551    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510    \u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                                 0    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     0\\n\\n        (ALAP scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2551       \u2514\u2500\u2565\u2500\u2518       \u250c\u2500\u2510\\n        q_2: \u2500\u2524 Delay(200[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510    \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2569\u2550\\n                                 0    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     0\\n\\n        '\n    qc = QuantumCircuit(3, 1)\n    qc.measure(0, 0)\n    qc.x(1).c_if(0, 1)\n    qc.measure(2, 0)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    actual_asap = PassManager([SetIOLatency(clbit_write_latency=1000), ASAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    actual_alap = PassManager([SetIOLatency(clbit_write_latency=1000), ALAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    expected_asap = QuantumCircuit(3, 1)\n    expected_asap.measure(0, 0)\n    expected_asap.delay(1000, 1)\n    expected_asap.x(1).c_if(0, 1)\n    expected_asap.measure(2, 0)\n    expected_asap.delay(200, 0)\n    expected_asap.delay(200, 2)\n    self.assertEqual(expected_asap, actual_asap)\n    expected_alap = QuantumCircuit(3, 1)\n    expected_alap.measure(0, 0)\n    expected_alap.delay(1000, 1)\n    expected_alap.x(1).c_if(0, 1)\n    expected_alap.delay(200, 2)\n    expected_alap.measure(2, 0)\n    expected_alap.delay(200, 0)\n    self.assertEqual(expected_alap, actual_alap)",
            "def test_measure_after_c_if_on_edge_locking(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test if ALAP/ASAP schedules circuits with c_if after measure with a common clbit.\\n\\n        The scheduler is configured to reproduce behavior of the 0.20.0,\\n        in which clbit lock is applied to the end-edge of measure instruction.\\n        See https://github.com/Qiskit/qiskit-terra/pull/7655\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\\n              \u2551    \u2514\u2500\u2565\u2500\u2518   \u250c\u2500\u2510\\n        q_2: \u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\\n        c: 1/\u2550\u2569\u2550\u2561 c_0 = T \u255e\u2550\u2569\u2550\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0\\n\\n        (ASAP scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551       \u2514\u2500\u2565\u2500\u2518       \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\\n                                 \u2551    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510    \u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                                 0    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     0\\n\\n        (ALAP scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2551       \u2514\u2500\u2565\u2500\u2518       \u250c\u2500\u2510\\n        q_2: \u2500\u2524 Delay(200[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510    \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2569\u2550\\n                                 0    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     0\\n\\n        '\n    qc = QuantumCircuit(3, 1)\n    qc.measure(0, 0)\n    qc.x(1).c_if(0, 1)\n    qc.measure(2, 0)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    actual_asap = PassManager([SetIOLatency(clbit_write_latency=1000), ASAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    actual_alap = PassManager([SetIOLatency(clbit_write_latency=1000), ALAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    expected_asap = QuantumCircuit(3, 1)\n    expected_asap.measure(0, 0)\n    expected_asap.delay(1000, 1)\n    expected_asap.x(1).c_if(0, 1)\n    expected_asap.measure(2, 0)\n    expected_asap.delay(200, 0)\n    expected_asap.delay(200, 2)\n    self.assertEqual(expected_asap, actual_asap)\n    expected_alap = QuantumCircuit(3, 1)\n    expected_alap.measure(0, 0)\n    expected_alap.delay(1000, 1)\n    expected_alap.x(1).c_if(0, 1)\n    expected_alap.delay(200, 2)\n    expected_alap.measure(2, 0)\n    expected_alap.delay(200, 0)\n    self.assertEqual(expected_alap, actual_alap)",
            "def test_measure_after_c_if_on_edge_locking(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test if ALAP/ASAP schedules circuits with c_if after measure with a common clbit.\\n\\n        The scheduler is configured to reproduce behavior of the 0.20.0,\\n        in which clbit lock is applied to the end-edge of measure instruction.\\n        See https://github.com/Qiskit/qiskit-terra/pull/7655\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\\n              \u2551    \u2514\u2500\u2565\u2500\u2518   \u250c\u2500\u2510\\n        q_2: \u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\\n        c: 1/\u2550\u2569\u2550\u2561 c_0 = T \u255e\u2550\u2569\u2550\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0\\n\\n        (ASAP scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551       \u2514\u2500\u2565\u2500\u2518       \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\\n                                 \u2551    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510    \u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                                 0    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     0\\n\\n        (ALAP scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2551       \u2514\u2500\u2565\u2500\u2518       \u250c\u2500\u2510\\n        q_2: \u2500\u2524 Delay(200[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510    \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2569\u2550\\n                                 0    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     0\\n\\n        '\n    qc = QuantumCircuit(3, 1)\n    qc.measure(0, 0)\n    qc.x(1).c_if(0, 1)\n    qc.measure(2, 0)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    actual_asap = PassManager([SetIOLatency(clbit_write_latency=1000), ASAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    actual_alap = PassManager([SetIOLatency(clbit_write_latency=1000), ALAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    expected_asap = QuantumCircuit(3, 1)\n    expected_asap.measure(0, 0)\n    expected_asap.delay(1000, 1)\n    expected_asap.x(1).c_if(0, 1)\n    expected_asap.measure(2, 0)\n    expected_asap.delay(200, 0)\n    expected_asap.delay(200, 2)\n    self.assertEqual(expected_asap, actual_asap)\n    expected_alap = QuantumCircuit(3, 1)\n    expected_alap.measure(0, 0)\n    expected_alap.delay(1000, 1)\n    expected_alap.x(1).c_if(0, 1)\n    expected_alap.delay(200, 2)\n    expected_alap.measure(2, 0)\n    expected_alap.delay(200, 0)\n    self.assertEqual(expected_alap, actual_alap)",
            "def test_measure_after_c_if_on_edge_locking(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test if ALAP/ASAP schedules circuits with c_if after measure with a common clbit.\\n\\n        The scheduler is configured to reproduce behavior of the 0.20.0,\\n        in which clbit lock is applied to the end-edge of measure instruction.\\n        See https://github.com/Qiskit/qiskit-terra/pull/7655\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\\n              \u2551    \u2514\u2500\u2565\u2500\u2518   \u250c\u2500\u2510\\n        q_2: \u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\\n        c: 1/\u2550\u2569\u2550\u2561 c_0 = T \u255e\u2550\u2569\u2550\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0\\n\\n        (ASAP scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551       \u2514\u2500\u2565\u2500\u2518       \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\\n                                 \u2551    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510    \u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                                 0    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     0\\n\\n        (ALAP scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2551       \u2514\u2500\u2565\u2500\u2518       \u250c\u2500\u2510\\n        q_2: \u2500\u2524 Delay(200[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510    \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2569\u2550\\n                                 0    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     0\\n\\n        '\n    qc = QuantumCircuit(3, 1)\n    qc.measure(0, 0)\n    qc.x(1).c_if(0, 1)\n    qc.measure(2, 0)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    actual_asap = PassManager([SetIOLatency(clbit_write_latency=1000), ASAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    actual_alap = PassManager([SetIOLatency(clbit_write_latency=1000), ALAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    expected_asap = QuantumCircuit(3, 1)\n    expected_asap.measure(0, 0)\n    expected_asap.delay(1000, 1)\n    expected_asap.x(1).c_if(0, 1)\n    expected_asap.measure(2, 0)\n    expected_asap.delay(200, 0)\n    expected_asap.delay(200, 2)\n    self.assertEqual(expected_asap, actual_asap)\n    expected_alap = QuantumCircuit(3, 1)\n    expected_alap.measure(0, 0)\n    expected_alap.delay(1000, 1)\n    expected_alap.x(1).c_if(0, 1)\n    expected_alap.delay(200, 2)\n    expected_alap.measure(2, 0)\n    expected_alap.delay(200, 0)\n    self.assertEqual(expected_alap, actual_alap)",
            "def test_measure_after_c_if_on_edge_locking(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test if ALAP/ASAP schedules circuits with c_if after measure with a common clbit.\\n\\n        The scheduler is configured to reproduce behavior of the 0.20.0,\\n        in which clbit lock is applied to the end-edge of measure instruction.\\n        See https://github.com/Qiskit/qiskit-terra/pull/7655\\n\\n        (input)\\n             \u250c\u2500\u2510\\n        q_0: \u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2500\u256b\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\\n              \u2551    \u2514\u2500\u2565\u2500\u2518   \u250c\u2500\u2510\\n        q_2: \u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\\n        c: 1/\u2550\u2569\u2550\u2561 c_0 = T \u255e\u2550\u2569\u2550\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0\\n\\n        (ASAP scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551       \u2514\u2500\u2565\u2500\u2518       \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\\n                                 \u2551    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510    \u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n                                 0    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     0\\n\\n        (ALAP scheduled)\\n                                \u250c\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2565\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        q_1: \u2524 Delay(1000[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u2514\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2551       \u2514\u2500\u2565\u2500\u2518       \u250c\u2500\u2510\\n        q_2: \u2500\u2524 Delay(200[dt]) \u251c\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510    \u2514\u2565\u2518\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2569\u2550\\n                                 0    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     0\\n\\n        '\n    qc = QuantumCircuit(3, 1)\n    qc.measure(0, 0)\n    qc.x(1).c_if(0, 1)\n    qc.measure(2, 0)\n    durations = InstructionDurations([('x', None, 200), ('measure', None, 1000)])\n    actual_asap = PassManager([SetIOLatency(clbit_write_latency=1000), ASAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    actual_alap = PassManager([SetIOLatency(clbit_write_latency=1000), ALAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    expected_asap = QuantumCircuit(3, 1)\n    expected_asap.measure(0, 0)\n    expected_asap.delay(1000, 1)\n    expected_asap.x(1).c_if(0, 1)\n    expected_asap.measure(2, 0)\n    expected_asap.delay(200, 0)\n    expected_asap.delay(200, 2)\n    self.assertEqual(expected_asap, actual_asap)\n    expected_alap = QuantumCircuit(3, 1)\n    expected_alap.measure(0, 0)\n    expected_alap.delay(1000, 1)\n    expected_alap.x(1).c_if(0, 1)\n    expected_alap.delay(200, 2)\n    expected_alap.measure(2, 0)\n    expected_alap.delay(200, 0)\n    self.assertEqual(expected_alap, actual_alap)"
        ]
    },
    {
        "func_name": "test_active_reset_circuit",
        "original": "@data([100, 200], [500, 0], [1000, 200])\n@unpack\ndef test_active_reset_circuit(self, write_lat, cond_lat):\n    \"\"\"Test practical example of reset circuit.\n\n        Because of the stimulus pulse overlap with the previous XGate on the q register,\n        measure instruction is always triggered after XGate regardless of write latency.\n        Thus only conditional latency matters in the scheduling.\n\n        (input)\n             \u250c\u2500\u2510   \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2510   \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2510   \u250c\u2500\u2500\u2500\u2510\n          q: \u2524M\u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\n             \u2514\u2565\u2518   \u2514\u2500\u2565\u2500\u2518   \u2514\u2565\u2518   \u2514\u2500\u2565\u2500\u2518   \u2514\u2565\u2518   \u2514\u2500\u2565\u2500\u2518\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\n        c: 1/\u2550\u2569\u2550\u2561 c_0=0x1 \u255e\u2550\u2569\u2550\u2561 c_0=0x1 \u255e\u2550\u2569\u2550\u2561 c_0=0x1 \u255e\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        \"\"\"\n    qc = QuantumCircuit(1, 1)\n    qc.measure(0, 0)\n    qc.x(0).c_if(0, 1)\n    qc.measure(0, 0)\n    qc.x(0).c_if(0, 1)\n    qc.measure(0, 0)\n    qc.x(0).c_if(0, 1)\n    durations = InstructionDurations([('x', None, 100), ('measure', None, 1000)])\n    actual_asap = PassManager([SetIOLatency(clbit_write_latency=write_lat, conditional_latency=cond_lat), ASAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    actual_alap = PassManager([SetIOLatency(clbit_write_latency=write_lat, conditional_latency=cond_lat), ALAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    expected = QuantumCircuit(1, 1)\n    expected.measure(0, 0)\n    if cond_lat > 0:\n        expected.delay(cond_lat, 0)\n    expected.x(0).c_if(0, 1)\n    expected.measure(0, 0)\n    if cond_lat > 0:\n        expected.delay(cond_lat, 0)\n    expected.x(0).c_if(0, 1)\n    expected.measure(0, 0)\n    if cond_lat > 0:\n        expected.delay(cond_lat, 0)\n    expected.x(0).c_if(0, 1)\n    self.assertEqual(expected, actual_asap)\n    self.assertEqual(expected, actual_alap)",
        "mutated": [
            "@data([100, 200], [500, 0], [1000, 200])\n@unpack\ndef test_active_reset_circuit(self, write_lat, cond_lat):\n    if False:\n        i = 10\n    'Test practical example of reset circuit.\\n\\n        Because of the stimulus pulse overlap with the previous XGate on the q register,\\n        measure instruction is always triggered after XGate regardless of write latency.\\n        Thus only conditional latency matters in the scheduling.\\n\\n        (input)\\n             \u250c\u2500\u2510   \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2510   \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2510   \u250c\u2500\u2500\u2500\u2510\\n          q: \u2524M\u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u2514\u2500\u2565\u2500\u2518   \u2514\u2565\u2518   \u2514\u2500\u2565\u2500\u2518   \u2514\u2565\u2518   \u2514\u2500\u2565\u2500\u2518\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2569\u2550\u2561 c_0=0x1 \u255e\u2550\u2569\u2550\u2561 c_0=0x1 \u255e\u2550\u2569\u2550\u2561 c_0=0x1 \u255e\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    qc = QuantumCircuit(1, 1)\n    qc.measure(0, 0)\n    qc.x(0).c_if(0, 1)\n    qc.measure(0, 0)\n    qc.x(0).c_if(0, 1)\n    qc.measure(0, 0)\n    qc.x(0).c_if(0, 1)\n    durations = InstructionDurations([('x', None, 100), ('measure', None, 1000)])\n    actual_asap = PassManager([SetIOLatency(clbit_write_latency=write_lat, conditional_latency=cond_lat), ASAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    actual_alap = PassManager([SetIOLatency(clbit_write_latency=write_lat, conditional_latency=cond_lat), ALAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    expected = QuantumCircuit(1, 1)\n    expected.measure(0, 0)\n    if cond_lat > 0:\n        expected.delay(cond_lat, 0)\n    expected.x(0).c_if(0, 1)\n    expected.measure(0, 0)\n    if cond_lat > 0:\n        expected.delay(cond_lat, 0)\n    expected.x(0).c_if(0, 1)\n    expected.measure(0, 0)\n    if cond_lat > 0:\n        expected.delay(cond_lat, 0)\n    expected.x(0).c_if(0, 1)\n    self.assertEqual(expected, actual_asap)\n    self.assertEqual(expected, actual_alap)",
            "@data([100, 200], [500, 0], [1000, 200])\n@unpack\ndef test_active_reset_circuit(self, write_lat, cond_lat):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test practical example of reset circuit.\\n\\n        Because of the stimulus pulse overlap with the previous XGate on the q register,\\n        measure instruction is always triggered after XGate regardless of write latency.\\n        Thus only conditional latency matters in the scheduling.\\n\\n        (input)\\n             \u250c\u2500\u2510   \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2510   \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2510   \u250c\u2500\u2500\u2500\u2510\\n          q: \u2524M\u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u2514\u2500\u2565\u2500\u2518   \u2514\u2565\u2518   \u2514\u2500\u2565\u2500\u2518   \u2514\u2565\u2518   \u2514\u2500\u2565\u2500\u2518\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2569\u2550\u2561 c_0=0x1 \u255e\u2550\u2569\u2550\u2561 c_0=0x1 \u255e\u2550\u2569\u2550\u2561 c_0=0x1 \u255e\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    qc = QuantumCircuit(1, 1)\n    qc.measure(0, 0)\n    qc.x(0).c_if(0, 1)\n    qc.measure(0, 0)\n    qc.x(0).c_if(0, 1)\n    qc.measure(0, 0)\n    qc.x(0).c_if(0, 1)\n    durations = InstructionDurations([('x', None, 100), ('measure', None, 1000)])\n    actual_asap = PassManager([SetIOLatency(clbit_write_latency=write_lat, conditional_latency=cond_lat), ASAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    actual_alap = PassManager([SetIOLatency(clbit_write_latency=write_lat, conditional_latency=cond_lat), ALAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    expected = QuantumCircuit(1, 1)\n    expected.measure(0, 0)\n    if cond_lat > 0:\n        expected.delay(cond_lat, 0)\n    expected.x(0).c_if(0, 1)\n    expected.measure(0, 0)\n    if cond_lat > 0:\n        expected.delay(cond_lat, 0)\n    expected.x(0).c_if(0, 1)\n    expected.measure(0, 0)\n    if cond_lat > 0:\n        expected.delay(cond_lat, 0)\n    expected.x(0).c_if(0, 1)\n    self.assertEqual(expected, actual_asap)\n    self.assertEqual(expected, actual_alap)",
            "@data([100, 200], [500, 0], [1000, 200])\n@unpack\ndef test_active_reset_circuit(self, write_lat, cond_lat):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test practical example of reset circuit.\\n\\n        Because of the stimulus pulse overlap with the previous XGate on the q register,\\n        measure instruction is always triggered after XGate regardless of write latency.\\n        Thus only conditional latency matters in the scheduling.\\n\\n        (input)\\n             \u250c\u2500\u2510   \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2510   \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2510   \u250c\u2500\u2500\u2500\u2510\\n          q: \u2524M\u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u2514\u2500\u2565\u2500\u2518   \u2514\u2565\u2518   \u2514\u2500\u2565\u2500\u2518   \u2514\u2565\u2518   \u2514\u2500\u2565\u2500\u2518\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2569\u2550\u2561 c_0=0x1 \u255e\u2550\u2569\u2550\u2561 c_0=0x1 \u255e\u2550\u2569\u2550\u2561 c_0=0x1 \u255e\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    qc = QuantumCircuit(1, 1)\n    qc.measure(0, 0)\n    qc.x(0).c_if(0, 1)\n    qc.measure(0, 0)\n    qc.x(0).c_if(0, 1)\n    qc.measure(0, 0)\n    qc.x(0).c_if(0, 1)\n    durations = InstructionDurations([('x', None, 100), ('measure', None, 1000)])\n    actual_asap = PassManager([SetIOLatency(clbit_write_latency=write_lat, conditional_latency=cond_lat), ASAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    actual_alap = PassManager([SetIOLatency(clbit_write_latency=write_lat, conditional_latency=cond_lat), ALAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    expected = QuantumCircuit(1, 1)\n    expected.measure(0, 0)\n    if cond_lat > 0:\n        expected.delay(cond_lat, 0)\n    expected.x(0).c_if(0, 1)\n    expected.measure(0, 0)\n    if cond_lat > 0:\n        expected.delay(cond_lat, 0)\n    expected.x(0).c_if(0, 1)\n    expected.measure(0, 0)\n    if cond_lat > 0:\n        expected.delay(cond_lat, 0)\n    expected.x(0).c_if(0, 1)\n    self.assertEqual(expected, actual_asap)\n    self.assertEqual(expected, actual_alap)",
            "@data([100, 200], [500, 0], [1000, 200])\n@unpack\ndef test_active_reset_circuit(self, write_lat, cond_lat):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test practical example of reset circuit.\\n\\n        Because of the stimulus pulse overlap with the previous XGate on the q register,\\n        measure instruction is always triggered after XGate regardless of write latency.\\n        Thus only conditional latency matters in the scheduling.\\n\\n        (input)\\n             \u250c\u2500\u2510   \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2510   \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2510   \u250c\u2500\u2500\u2500\u2510\\n          q: \u2524M\u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u2514\u2500\u2565\u2500\u2518   \u2514\u2565\u2518   \u2514\u2500\u2565\u2500\u2518   \u2514\u2565\u2518   \u2514\u2500\u2565\u2500\u2518\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2569\u2550\u2561 c_0=0x1 \u255e\u2550\u2569\u2550\u2561 c_0=0x1 \u255e\u2550\u2569\u2550\u2561 c_0=0x1 \u255e\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    qc = QuantumCircuit(1, 1)\n    qc.measure(0, 0)\n    qc.x(0).c_if(0, 1)\n    qc.measure(0, 0)\n    qc.x(0).c_if(0, 1)\n    qc.measure(0, 0)\n    qc.x(0).c_if(0, 1)\n    durations = InstructionDurations([('x', None, 100), ('measure', None, 1000)])\n    actual_asap = PassManager([SetIOLatency(clbit_write_latency=write_lat, conditional_latency=cond_lat), ASAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    actual_alap = PassManager([SetIOLatency(clbit_write_latency=write_lat, conditional_latency=cond_lat), ALAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    expected = QuantumCircuit(1, 1)\n    expected.measure(0, 0)\n    if cond_lat > 0:\n        expected.delay(cond_lat, 0)\n    expected.x(0).c_if(0, 1)\n    expected.measure(0, 0)\n    if cond_lat > 0:\n        expected.delay(cond_lat, 0)\n    expected.x(0).c_if(0, 1)\n    expected.measure(0, 0)\n    if cond_lat > 0:\n        expected.delay(cond_lat, 0)\n    expected.x(0).c_if(0, 1)\n    self.assertEqual(expected, actual_asap)\n    self.assertEqual(expected, actual_alap)",
            "@data([100, 200], [500, 0], [1000, 200])\n@unpack\ndef test_active_reset_circuit(self, write_lat, cond_lat):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test practical example of reset circuit.\\n\\n        Because of the stimulus pulse overlap with the previous XGate on the q register,\\n        measure instruction is always triggered after XGate regardless of write latency.\\n        Thus only conditional latency matters in the scheduling.\\n\\n        (input)\\n             \u250c\u2500\u2510   \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2510   \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2510   \u250c\u2500\u2500\u2500\u2510\\n          q: \u2524M\u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n             \u2514\u2565\u2518   \u2514\u2500\u2565\u2500\u2518   \u2514\u2565\u2518   \u2514\u2500\u2565\u2500\u2518   \u2514\u2565\u2518   \u2514\u2500\u2565\u2500\u2518\\n              \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2551 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2569\u2550\u2561 c_0=0x1 \u255e\u2550\u2569\u2550\u2561 c_0=0x1 \u255e\u2550\u2569\u2550\u2561 c_0=0x1 \u255e\\n              0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    qc = QuantumCircuit(1, 1)\n    qc.measure(0, 0)\n    qc.x(0).c_if(0, 1)\n    qc.measure(0, 0)\n    qc.x(0).c_if(0, 1)\n    qc.measure(0, 0)\n    qc.x(0).c_if(0, 1)\n    durations = InstructionDurations([('x', None, 100), ('measure', None, 1000)])\n    actual_asap = PassManager([SetIOLatency(clbit_write_latency=write_lat, conditional_latency=cond_lat), ASAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    actual_alap = PassManager([SetIOLatency(clbit_write_latency=write_lat, conditional_latency=cond_lat), ALAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    expected = QuantumCircuit(1, 1)\n    expected.measure(0, 0)\n    if cond_lat > 0:\n        expected.delay(cond_lat, 0)\n    expected.x(0).c_if(0, 1)\n    expected.measure(0, 0)\n    if cond_lat > 0:\n        expected.delay(cond_lat, 0)\n    expected.x(0).c_if(0, 1)\n    expected.measure(0, 0)\n    if cond_lat > 0:\n        expected.delay(cond_lat, 0)\n    expected.x(0).c_if(0, 1)\n    self.assertEqual(expected, actual_asap)\n    self.assertEqual(expected, actual_alap)"
        ]
    },
    {
        "func_name": "test_random_complicated_circuit",
        "original": "def test_random_complicated_circuit(self):\n    \"\"\"Test scheduling complicated circuit with control flow.\n\n        (input)\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510    \u2591                  \u250c\u2500\u2500\u2500\u2510   \u00bb\n        q_0: \u2524 Delay(100[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u00bb\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2565\u2500\u2518    \u2591       \u250c\u2500\u2500\u2500\u2510      \u2514\u2500\u2565\u2500\u2518   \u00bb\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u00bb\n                                    \u2551      \u2591 \u250c\u2500\u2510   \u2514\u2500\u2565\u2500\u2518        \u2551     \u00bb\n        q_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u00bb\n                               \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2591 \u2514\u2565\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u00bb\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2569\u2550\u2561 c_0=0x0 \u255e\u2561 c_0=0x0 \u255e\u00bb\n                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\n        \u00abq_0: \u2524 Delay(300[dt]) \u251c\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518   \u250c\u2500\u2534\u2500\u2510\n        \u00abq_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\n        \u00ab           \u250c\u2500\u2534\u2500\u2510        \u250c\u2500\u2510    \u2514\u2500\u2565\u2500\u2518\n        \u00abq_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\n        \u00ab           \u2514\u2500\u2500\u2500\u2518        \u2514\u2565\u2518 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\n        \u00abc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2561 c_0=0x0 \u255e\n        \u00ab                         0  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        (ASAP scheduled) duration = 2800 dt\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510    \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u00bb\n        q_0: \u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Delay(1400[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2514\u2500\u2565\u2500\u2518    \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u250c\u2500\u2500\u2500\u2510   \u00bb\n        q_1: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Delay(1200[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u00bb\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u2551      \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2565\u2500\u2518   \u00bb\n        q_2: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u00bb\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2591         \u2514\u2565\u2518        \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u00bb\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x0 \u255e\u00bb\n                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            0         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\n        \u00ab                          \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2510       \u00bb\n        \u00abq_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\n        \u00ab                          \u2514\u2500\u2565\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u00bb\n        \u00abq_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Delay(400[dt]) \u251c\u00bb\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2551           \u250c\u2500\u2534\u2500\u2510       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u00bb\n        \u00abq_2: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Delay(300[dt]) \u251c\u00bb\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510      \u2514\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\n        \u00abc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x0 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u00bb\n        \u00ab                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                    \u00bb\n        \u00ab                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u00abq_0: \u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2524 Delay(700[dt]) \u251c\n        \u00ab        \u250c\u2500\u2534\u2500\u2510   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u00abq_1: \u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 Delay(700[dt]) \u251c\n        \u00ab        \u2514\u2500\u2565\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u00abq_2: \u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510       \u2514\u2565\u2518\n        \u00abc: 1/\u2561 c_0=0x0 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        0\n\n        (ALAP scheduled) duration = 3100\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510    \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u00bb\n        q_0: \u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Delay(1400[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2514\u2500\u2565\u2500\u2518    \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u250c\u2500\u2500\u2500\u2510   \u00bb\n        q_1: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Delay(1200[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u00bb\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u2551      \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2565\u2500\u2518   \u00bb\n        q_2: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u00bb\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2591         \u2514\u2565\u2518        \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u00bb\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x0 \u255e\u00bb\n                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            0         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\n        \u00ab                          \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2510       \u00bb\n        \u00abq_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2514\u2500\u2565\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u00bb\n        \u00abq_1: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Delay(100[dt]) \u251c\u00bb\n        \u00ab     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u2551           \u250c\u2500\u2534\u2500\u2510       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\n        \u00abq_2: \u2524 Delay(600[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510      \u2514\u2500\u2500\u2500\u2518              \u2514\u2565\u2518        \u00bb\n        \u00abc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x0 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u00bb\n        \u00ab                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                          0         \u00bb\n        \u00ab                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u00abq_0: \u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2524 Delay(700[dt]) \u251c\n        \u00ab        \u250c\u2500\u2534\u2500\u2510   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u00abq_1: \u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 Delay(700[dt]) \u251c\n        \u00ab        \u2514\u2500\u2565\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u00abq_2: \u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\n        \u00abc: 1/\u2561 c_0=0x0 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        \"\"\"\n    qc = QuantumCircuit(3, 1)\n    qc.delay(100, 0)\n    qc.x(0).c_if(0, 1)\n    qc.barrier()\n    qc.measure(2, 0)\n    qc.x(1).c_if(0, 0)\n    qc.x(0).c_if(0, 0)\n    qc.delay(300, 0)\n    qc.cx(1, 2)\n    qc.x(0)\n    qc.cx(0, 1).c_if(0, 0)\n    qc.measure(2, 0)\n    durations = InstructionDurations([('x', None, 100), ('measure', None, 1000), ('cx', None, 200)])\n    actual_asap = PassManager([SetIOLatency(clbit_write_latency=100, conditional_latency=200), ASAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    actual_alap = PassManager([SetIOLatency(clbit_write_latency=100, conditional_latency=200), ALAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    expected_asap = QuantumCircuit(3, 1)\n    expected_asap.delay(200, 0)\n    expected_asap.delay(300, 1)\n    expected_asap.delay(300, 2)\n    expected_asap.x(0).c_if(0, 1)\n    expected_asap.barrier()\n    expected_asap.delay(1400, 0)\n    expected_asap.delay(1200, 1)\n    expected_asap.measure(2, 0)\n    expected_asap.x(1).c_if(0, 0)\n    expected_asap.x(0).c_if(0, 0)\n    expected_asap.delay(300, 0)\n    expected_asap.x(0)\n    expected_asap.delay(300, 2)\n    expected_asap.cx(1, 2)\n    expected_asap.delay(400, 1)\n    expected_asap.cx(0, 1).c_if(0, 0)\n    expected_asap.delay(700, 0)\n    expected_asap.delay(700, 1)\n    expected_asap.delay(300, 2)\n    expected_asap.measure(2, 0)\n    self.assertEqual(expected_asap, actual_asap)\n    self.assertEqual(actual_asap.duration, 3100)\n    expected_alap = QuantumCircuit(3, 1)\n    expected_alap.delay(200, 0)\n    expected_alap.delay(300, 1)\n    expected_alap.delay(300, 2)\n    expected_alap.x(0).c_if(0, 1)\n    expected_alap.barrier()\n    expected_alap.delay(1400, 0)\n    expected_alap.delay(1200, 1)\n    expected_alap.measure(2, 0)\n    expected_alap.x(1).c_if(0, 0)\n    expected_alap.x(0).c_if(0, 0)\n    expected_alap.delay(300, 0)\n    expected_alap.x(0)\n    expected_alap.delay(300, 1)\n    expected_alap.delay(600, 2)\n    expected_alap.cx(1, 2)\n    expected_alap.delay(100, 1)\n    expected_alap.cx(0, 1).c_if(0, 0)\n    expected_alap.measure(2, 0)\n    expected_alap.delay(700, 0)\n    expected_alap.delay(700, 1)\n    self.assertEqual(expected_alap, actual_alap)\n    self.assertEqual(actual_alap.duration, 3100)",
        "mutated": [
            "def test_random_complicated_circuit(self):\n    if False:\n        i = 10\n    'Test scheduling complicated circuit with control flow.\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510    \u2591                  \u250c\u2500\u2500\u2500\u2510   \u00bb\\n        q_0: \u2524 Delay(100[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u00bb\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2565\u2500\u2518    \u2591       \u250c\u2500\u2500\u2500\u2510      \u2514\u2500\u2565\u2500\u2518   \u00bb\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u00bb\\n                                    \u2551      \u2591 \u250c\u2500\u2510   \u2514\u2500\u2565\u2500\u2518        \u2551     \u00bb\\n        q_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u00bb\\n                               \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2591 \u2514\u2565\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u00bb\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2569\u2550\u2561 c_0=0x0 \u255e\u2561 c_0=0x0 \u255e\u00bb\\n                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\\n        \u00abq_0: \u2524 Delay(300[dt]) \u251c\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518   \u250c\u2500\u2534\u2500\u2510\\n        \u00abq_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n        \u00ab           \u250c\u2500\u2534\u2500\u2510        \u250c\u2500\u2510    \u2514\u2500\u2565\u2500\u2518\\n        \u00abq_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\\n        \u00ab           \u2514\u2500\u2500\u2500\u2518        \u2514\u2565\u2518 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        \u00abc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2561 c_0=0x0 \u255e\\n        \u00ab                         0  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        (ASAP scheduled) duration = 2800 dt\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510    \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u00bb\\n        q_0: \u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Delay(1400[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2514\u2500\u2565\u2500\u2518    \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u250c\u2500\u2500\u2500\u2510   \u00bb\\n        q_1: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Delay(1200[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u00bb\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u2551      \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2565\u2500\u2518   \u00bb\\n        q_2: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u00bb\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2591         \u2514\u2565\u2518        \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u00bb\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x0 \u255e\u00bb\\n                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            0         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00ab                          \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2510       \u00bb\\n        \u00abq_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n        \u00ab                          \u2514\u2500\u2565\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u00bb\\n        \u00abq_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Delay(400[dt]) \u251c\u00bb\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2551           \u250c\u2500\u2534\u2500\u2510       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u00bb\\n        \u00abq_2: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Delay(300[dt]) \u251c\u00bb\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510      \u2514\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00abc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x0 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u00bb\\n        \u00ab                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                    \u00bb\\n        \u00ab                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u00abq_0: \u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2524 Delay(700[dt]) \u251c\\n        \u00ab        \u250c\u2500\u2534\u2500\u2510   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n        \u00abq_1: \u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 Delay(700[dt]) \u251c\\n        \u00ab        \u2514\u2500\u2565\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        \u00abq_2: \u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510       \u2514\u2565\u2518\\n        \u00abc: 1/\u2561 c_0=0x0 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        0\\n\\n        (ALAP scheduled) duration = 3100\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510    \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u00bb\\n        q_0: \u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Delay(1400[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2514\u2500\u2565\u2500\u2518    \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u250c\u2500\u2500\u2500\u2510   \u00bb\\n        q_1: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Delay(1200[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u00bb\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u2551      \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2565\u2500\u2518   \u00bb\\n        q_2: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u00bb\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2591         \u2514\u2565\u2518        \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u00bb\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x0 \u255e\u00bb\\n                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            0         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00ab                          \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2510       \u00bb\\n        \u00abq_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2514\u2500\u2565\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u00bb\\n        \u00abq_1: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Delay(100[dt]) \u251c\u00bb\\n        \u00ab     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u2551           \u250c\u2500\u2534\u2500\u2510       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00abq_2: \u2524 Delay(600[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510      \u2514\u2500\u2500\u2500\u2518              \u2514\u2565\u2518        \u00bb\\n        \u00abc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x0 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u00bb\\n        \u00ab                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                          0         \u00bb\\n        \u00ab                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u00abq_0: \u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2524 Delay(700[dt]) \u251c\\n        \u00ab        \u250c\u2500\u2534\u2500\u2510   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n        \u00abq_1: \u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 Delay(700[dt]) \u251c\\n        \u00ab        \u2514\u2500\u2565\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        \u00abq_2: \u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        \u00abc: 1/\u2561 c_0=0x0 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    qc = QuantumCircuit(3, 1)\n    qc.delay(100, 0)\n    qc.x(0).c_if(0, 1)\n    qc.barrier()\n    qc.measure(2, 0)\n    qc.x(1).c_if(0, 0)\n    qc.x(0).c_if(0, 0)\n    qc.delay(300, 0)\n    qc.cx(1, 2)\n    qc.x(0)\n    qc.cx(0, 1).c_if(0, 0)\n    qc.measure(2, 0)\n    durations = InstructionDurations([('x', None, 100), ('measure', None, 1000), ('cx', None, 200)])\n    actual_asap = PassManager([SetIOLatency(clbit_write_latency=100, conditional_latency=200), ASAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    actual_alap = PassManager([SetIOLatency(clbit_write_latency=100, conditional_latency=200), ALAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    expected_asap = QuantumCircuit(3, 1)\n    expected_asap.delay(200, 0)\n    expected_asap.delay(300, 1)\n    expected_asap.delay(300, 2)\n    expected_asap.x(0).c_if(0, 1)\n    expected_asap.barrier()\n    expected_asap.delay(1400, 0)\n    expected_asap.delay(1200, 1)\n    expected_asap.measure(2, 0)\n    expected_asap.x(1).c_if(0, 0)\n    expected_asap.x(0).c_if(0, 0)\n    expected_asap.delay(300, 0)\n    expected_asap.x(0)\n    expected_asap.delay(300, 2)\n    expected_asap.cx(1, 2)\n    expected_asap.delay(400, 1)\n    expected_asap.cx(0, 1).c_if(0, 0)\n    expected_asap.delay(700, 0)\n    expected_asap.delay(700, 1)\n    expected_asap.delay(300, 2)\n    expected_asap.measure(2, 0)\n    self.assertEqual(expected_asap, actual_asap)\n    self.assertEqual(actual_asap.duration, 3100)\n    expected_alap = QuantumCircuit(3, 1)\n    expected_alap.delay(200, 0)\n    expected_alap.delay(300, 1)\n    expected_alap.delay(300, 2)\n    expected_alap.x(0).c_if(0, 1)\n    expected_alap.barrier()\n    expected_alap.delay(1400, 0)\n    expected_alap.delay(1200, 1)\n    expected_alap.measure(2, 0)\n    expected_alap.x(1).c_if(0, 0)\n    expected_alap.x(0).c_if(0, 0)\n    expected_alap.delay(300, 0)\n    expected_alap.x(0)\n    expected_alap.delay(300, 1)\n    expected_alap.delay(600, 2)\n    expected_alap.cx(1, 2)\n    expected_alap.delay(100, 1)\n    expected_alap.cx(0, 1).c_if(0, 0)\n    expected_alap.measure(2, 0)\n    expected_alap.delay(700, 0)\n    expected_alap.delay(700, 1)\n    self.assertEqual(expected_alap, actual_alap)\n    self.assertEqual(actual_alap.duration, 3100)",
            "def test_random_complicated_circuit(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test scheduling complicated circuit with control flow.\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510    \u2591                  \u250c\u2500\u2500\u2500\u2510   \u00bb\\n        q_0: \u2524 Delay(100[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u00bb\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2565\u2500\u2518    \u2591       \u250c\u2500\u2500\u2500\u2510      \u2514\u2500\u2565\u2500\u2518   \u00bb\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u00bb\\n                                    \u2551      \u2591 \u250c\u2500\u2510   \u2514\u2500\u2565\u2500\u2518        \u2551     \u00bb\\n        q_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u00bb\\n                               \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2591 \u2514\u2565\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u00bb\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2569\u2550\u2561 c_0=0x0 \u255e\u2561 c_0=0x0 \u255e\u00bb\\n                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\\n        \u00abq_0: \u2524 Delay(300[dt]) \u251c\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518   \u250c\u2500\u2534\u2500\u2510\\n        \u00abq_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n        \u00ab           \u250c\u2500\u2534\u2500\u2510        \u250c\u2500\u2510    \u2514\u2500\u2565\u2500\u2518\\n        \u00abq_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\\n        \u00ab           \u2514\u2500\u2500\u2500\u2518        \u2514\u2565\u2518 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        \u00abc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2561 c_0=0x0 \u255e\\n        \u00ab                         0  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        (ASAP scheduled) duration = 2800 dt\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510    \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u00bb\\n        q_0: \u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Delay(1400[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2514\u2500\u2565\u2500\u2518    \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u250c\u2500\u2500\u2500\u2510   \u00bb\\n        q_1: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Delay(1200[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u00bb\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u2551      \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2565\u2500\u2518   \u00bb\\n        q_2: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u00bb\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2591         \u2514\u2565\u2518        \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u00bb\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x0 \u255e\u00bb\\n                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            0         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00ab                          \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2510       \u00bb\\n        \u00abq_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n        \u00ab                          \u2514\u2500\u2565\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u00bb\\n        \u00abq_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Delay(400[dt]) \u251c\u00bb\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2551           \u250c\u2500\u2534\u2500\u2510       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u00bb\\n        \u00abq_2: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Delay(300[dt]) \u251c\u00bb\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510      \u2514\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00abc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x0 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u00bb\\n        \u00ab                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                    \u00bb\\n        \u00ab                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u00abq_0: \u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2524 Delay(700[dt]) \u251c\\n        \u00ab        \u250c\u2500\u2534\u2500\u2510   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n        \u00abq_1: \u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 Delay(700[dt]) \u251c\\n        \u00ab        \u2514\u2500\u2565\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        \u00abq_2: \u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510       \u2514\u2565\u2518\\n        \u00abc: 1/\u2561 c_0=0x0 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        0\\n\\n        (ALAP scheduled) duration = 3100\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510    \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u00bb\\n        q_0: \u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Delay(1400[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2514\u2500\u2565\u2500\u2518    \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u250c\u2500\u2500\u2500\u2510   \u00bb\\n        q_1: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Delay(1200[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u00bb\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u2551      \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2565\u2500\u2518   \u00bb\\n        q_2: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u00bb\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2591         \u2514\u2565\u2518        \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u00bb\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x0 \u255e\u00bb\\n                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            0         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00ab                          \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2510       \u00bb\\n        \u00abq_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2514\u2500\u2565\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u00bb\\n        \u00abq_1: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Delay(100[dt]) \u251c\u00bb\\n        \u00ab     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u2551           \u250c\u2500\u2534\u2500\u2510       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00abq_2: \u2524 Delay(600[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510      \u2514\u2500\u2500\u2500\u2518              \u2514\u2565\u2518        \u00bb\\n        \u00abc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x0 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u00bb\\n        \u00ab                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                          0         \u00bb\\n        \u00ab                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u00abq_0: \u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2524 Delay(700[dt]) \u251c\\n        \u00ab        \u250c\u2500\u2534\u2500\u2510   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n        \u00abq_1: \u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 Delay(700[dt]) \u251c\\n        \u00ab        \u2514\u2500\u2565\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        \u00abq_2: \u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        \u00abc: 1/\u2561 c_0=0x0 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    qc = QuantumCircuit(3, 1)\n    qc.delay(100, 0)\n    qc.x(0).c_if(0, 1)\n    qc.barrier()\n    qc.measure(2, 0)\n    qc.x(1).c_if(0, 0)\n    qc.x(0).c_if(0, 0)\n    qc.delay(300, 0)\n    qc.cx(1, 2)\n    qc.x(0)\n    qc.cx(0, 1).c_if(0, 0)\n    qc.measure(2, 0)\n    durations = InstructionDurations([('x', None, 100), ('measure', None, 1000), ('cx', None, 200)])\n    actual_asap = PassManager([SetIOLatency(clbit_write_latency=100, conditional_latency=200), ASAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    actual_alap = PassManager([SetIOLatency(clbit_write_latency=100, conditional_latency=200), ALAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    expected_asap = QuantumCircuit(3, 1)\n    expected_asap.delay(200, 0)\n    expected_asap.delay(300, 1)\n    expected_asap.delay(300, 2)\n    expected_asap.x(0).c_if(0, 1)\n    expected_asap.barrier()\n    expected_asap.delay(1400, 0)\n    expected_asap.delay(1200, 1)\n    expected_asap.measure(2, 0)\n    expected_asap.x(1).c_if(0, 0)\n    expected_asap.x(0).c_if(0, 0)\n    expected_asap.delay(300, 0)\n    expected_asap.x(0)\n    expected_asap.delay(300, 2)\n    expected_asap.cx(1, 2)\n    expected_asap.delay(400, 1)\n    expected_asap.cx(0, 1).c_if(0, 0)\n    expected_asap.delay(700, 0)\n    expected_asap.delay(700, 1)\n    expected_asap.delay(300, 2)\n    expected_asap.measure(2, 0)\n    self.assertEqual(expected_asap, actual_asap)\n    self.assertEqual(actual_asap.duration, 3100)\n    expected_alap = QuantumCircuit(3, 1)\n    expected_alap.delay(200, 0)\n    expected_alap.delay(300, 1)\n    expected_alap.delay(300, 2)\n    expected_alap.x(0).c_if(0, 1)\n    expected_alap.barrier()\n    expected_alap.delay(1400, 0)\n    expected_alap.delay(1200, 1)\n    expected_alap.measure(2, 0)\n    expected_alap.x(1).c_if(0, 0)\n    expected_alap.x(0).c_if(0, 0)\n    expected_alap.delay(300, 0)\n    expected_alap.x(0)\n    expected_alap.delay(300, 1)\n    expected_alap.delay(600, 2)\n    expected_alap.cx(1, 2)\n    expected_alap.delay(100, 1)\n    expected_alap.cx(0, 1).c_if(0, 0)\n    expected_alap.measure(2, 0)\n    expected_alap.delay(700, 0)\n    expected_alap.delay(700, 1)\n    self.assertEqual(expected_alap, actual_alap)\n    self.assertEqual(actual_alap.duration, 3100)",
            "def test_random_complicated_circuit(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test scheduling complicated circuit with control flow.\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510    \u2591                  \u250c\u2500\u2500\u2500\u2510   \u00bb\\n        q_0: \u2524 Delay(100[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u00bb\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2565\u2500\u2518    \u2591       \u250c\u2500\u2500\u2500\u2510      \u2514\u2500\u2565\u2500\u2518   \u00bb\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u00bb\\n                                    \u2551      \u2591 \u250c\u2500\u2510   \u2514\u2500\u2565\u2500\u2518        \u2551     \u00bb\\n        q_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u00bb\\n                               \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2591 \u2514\u2565\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u00bb\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2569\u2550\u2561 c_0=0x0 \u255e\u2561 c_0=0x0 \u255e\u00bb\\n                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\\n        \u00abq_0: \u2524 Delay(300[dt]) \u251c\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518   \u250c\u2500\u2534\u2500\u2510\\n        \u00abq_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n        \u00ab           \u250c\u2500\u2534\u2500\u2510        \u250c\u2500\u2510    \u2514\u2500\u2565\u2500\u2518\\n        \u00abq_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\\n        \u00ab           \u2514\u2500\u2500\u2500\u2518        \u2514\u2565\u2518 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        \u00abc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2561 c_0=0x0 \u255e\\n        \u00ab                         0  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        (ASAP scheduled) duration = 2800 dt\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510    \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u00bb\\n        q_0: \u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Delay(1400[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2514\u2500\u2565\u2500\u2518    \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u250c\u2500\u2500\u2500\u2510   \u00bb\\n        q_1: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Delay(1200[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u00bb\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u2551      \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2565\u2500\u2518   \u00bb\\n        q_2: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u00bb\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2591         \u2514\u2565\u2518        \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u00bb\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x0 \u255e\u00bb\\n                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            0         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00ab                          \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2510       \u00bb\\n        \u00abq_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n        \u00ab                          \u2514\u2500\u2565\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u00bb\\n        \u00abq_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Delay(400[dt]) \u251c\u00bb\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2551           \u250c\u2500\u2534\u2500\u2510       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u00bb\\n        \u00abq_2: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Delay(300[dt]) \u251c\u00bb\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510      \u2514\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00abc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x0 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u00bb\\n        \u00ab                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                    \u00bb\\n        \u00ab                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u00abq_0: \u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2524 Delay(700[dt]) \u251c\\n        \u00ab        \u250c\u2500\u2534\u2500\u2510   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n        \u00abq_1: \u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 Delay(700[dt]) \u251c\\n        \u00ab        \u2514\u2500\u2565\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        \u00abq_2: \u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510       \u2514\u2565\u2518\\n        \u00abc: 1/\u2561 c_0=0x0 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        0\\n\\n        (ALAP scheduled) duration = 3100\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510    \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u00bb\\n        q_0: \u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Delay(1400[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2514\u2500\u2565\u2500\u2518    \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u250c\u2500\u2500\u2500\u2510   \u00bb\\n        q_1: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Delay(1200[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u00bb\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u2551      \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2565\u2500\u2518   \u00bb\\n        q_2: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u00bb\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2591         \u2514\u2565\u2518        \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u00bb\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x0 \u255e\u00bb\\n                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            0         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00ab                          \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2510       \u00bb\\n        \u00abq_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2514\u2500\u2565\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u00bb\\n        \u00abq_1: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Delay(100[dt]) \u251c\u00bb\\n        \u00ab     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u2551           \u250c\u2500\u2534\u2500\u2510       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00abq_2: \u2524 Delay(600[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510      \u2514\u2500\u2500\u2500\u2518              \u2514\u2565\u2518        \u00bb\\n        \u00abc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x0 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u00bb\\n        \u00ab                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                          0         \u00bb\\n        \u00ab                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u00abq_0: \u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2524 Delay(700[dt]) \u251c\\n        \u00ab        \u250c\u2500\u2534\u2500\u2510   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n        \u00abq_1: \u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 Delay(700[dt]) \u251c\\n        \u00ab        \u2514\u2500\u2565\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        \u00abq_2: \u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        \u00abc: 1/\u2561 c_0=0x0 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    qc = QuantumCircuit(3, 1)\n    qc.delay(100, 0)\n    qc.x(0).c_if(0, 1)\n    qc.barrier()\n    qc.measure(2, 0)\n    qc.x(1).c_if(0, 0)\n    qc.x(0).c_if(0, 0)\n    qc.delay(300, 0)\n    qc.cx(1, 2)\n    qc.x(0)\n    qc.cx(0, 1).c_if(0, 0)\n    qc.measure(2, 0)\n    durations = InstructionDurations([('x', None, 100), ('measure', None, 1000), ('cx', None, 200)])\n    actual_asap = PassManager([SetIOLatency(clbit_write_latency=100, conditional_latency=200), ASAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    actual_alap = PassManager([SetIOLatency(clbit_write_latency=100, conditional_latency=200), ALAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    expected_asap = QuantumCircuit(3, 1)\n    expected_asap.delay(200, 0)\n    expected_asap.delay(300, 1)\n    expected_asap.delay(300, 2)\n    expected_asap.x(0).c_if(0, 1)\n    expected_asap.barrier()\n    expected_asap.delay(1400, 0)\n    expected_asap.delay(1200, 1)\n    expected_asap.measure(2, 0)\n    expected_asap.x(1).c_if(0, 0)\n    expected_asap.x(0).c_if(0, 0)\n    expected_asap.delay(300, 0)\n    expected_asap.x(0)\n    expected_asap.delay(300, 2)\n    expected_asap.cx(1, 2)\n    expected_asap.delay(400, 1)\n    expected_asap.cx(0, 1).c_if(0, 0)\n    expected_asap.delay(700, 0)\n    expected_asap.delay(700, 1)\n    expected_asap.delay(300, 2)\n    expected_asap.measure(2, 0)\n    self.assertEqual(expected_asap, actual_asap)\n    self.assertEqual(actual_asap.duration, 3100)\n    expected_alap = QuantumCircuit(3, 1)\n    expected_alap.delay(200, 0)\n    expected_alap.delay(300, 1)\n    expected_alap.delay(300, 2)\n    expected_alap.x(0).c_if(0, 1)\n    expected_alap.barrier()\n    expected_alap.delay(1400, 0)\n    expected_alap.delay(1200, 1)\n    expected_alap.measure(2, 0)\n    expected_alap.x(1).c_if(0, 0)\n    expected_alap.x(0).c_if(0, 0)\n    expected_alap.delay(300, 0)\n    expected_alap.x(0)\n    expected_alap.delay(300, 1)\n    expected_alap.delay(600, 2)\n    expected_alap.cx(1, 2)\n    expected_alap.delay(100, 1)\n    expected_alap.cx(0, 1).c_if(0, 0)\n    expected_alap.measure(2, 0)\n    expected_alap.delay(700, 0)\n    expected_alap.delay(700, 1)\n    self.assertEqual(expected_alap, actual_alap)\n    self.assertEqual(actual_alap.duration, 3100)",
            "def test_random_complicated_circuit(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test scheduling complicated circuit with control flow.\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510    \u2591                  \u250c\u2500\u2500\u2500\u2510   \u00bb\\n        q_0: \u2524 Delay(100[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u00bb\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2565\u2500\u2518    \u2591       \u250c\u2500\u2500\u2500\u2510      \u2514\u2500\u2565\u2500\u2518   \u00bb\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u00bb\\n                                    \u2551      \u2591 \u250c\u2500\u2510   \u2514\u2500\u2565\u2500\u2518        \u2551     \u00bb\\n        q_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u00bb\\n                               \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2591 \u2514\u2565\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u00bb\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2569\u2550\u2561 c_0=0x0 \u255e\u2561 c_0=0x0 \u255e\u00bb\\n                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\\n        \u00abq_0: \u2524 Delay(300[dt]) \u251c\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518   \u250c\u2500\u2534\u2500\u2510\\n        \u00abq_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n        \u00ab           \u250c\u2500\u2534\u2500\u2510        \u250c\u2500\u2510    \u2514\u2500\u2565\u2500\u2518\\n        \u00abq_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\\n        \u00ab           \u2514\u2500\u2500\u2500\u2518        \u2514\u2565\u2518 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        \u00abc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2561 c_0=0x0 \u255e\\n        \u00ab                         0  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        (ASAP scheduled) duration = 2800 dt\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510    \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u00bb\\n        q_0: \u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Delay(1400[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2514\u2500\u2565\u2500\u2518    \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u250c\u2500\u2500\u2500\u2510   \u00bb\\n        q_1: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Delay(1200[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u00bb\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u2551      \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2565\u2500\u2518   \u00bb\\n        q_2: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u00bb\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2591         \u2514\u2565\u2518        \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u00bb\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x0 \u255e\u00bb\\n                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            0         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00ab                          \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2510       \u00bb\\n        \u00abq_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n        \u00ab                          \u2514\u2500\u2565\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u00bb\\n        \u00abq_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Delay(400[dt]) \u251c\u00bb\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2551           \u250c\u2500\u2534\u2500\u2510       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u00bb\\n        \u00abq_2: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Delay(300[dt]) \u251c\u00bb\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510      \u2514\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00abc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x0 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u00bb\\n        \u00ab                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                    \u00bb\\n        \u00ab                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u00abq_0: \u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2524 Delay(700[dt]) \u251c\\n        \u00ab        \u250c\u2500\u2534\u2500\u2510   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n        \u00abq_1: \u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 Delay(700[dt]) \u251c\\n        \u00ab        \u2514\u2500\u2565\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        \u00abq_2: \u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510       \u2514\u2565\u2518\\n        \u00abc: 1/\u2561 c_0=0x0 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        0\\n\\n        (ALAP scheduled) duration = 3100\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510    \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u00bb\\n        q_0: \u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Delay(1400[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2514\u2500\u2565\u2500\u2518    \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u250c\u2500\u2500\u2500\u2510   \u00bb\\n        q_1: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Delay(1200[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u00bb\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u2551      \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2565\u2500\u2518   \u00bb\\n        q_2: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u00bb\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2591         \u2514\u2565\u2518        \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u00bb\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x0 \u255e\u00bb\\n                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            0         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00ab                          \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2510       \u00bb\\n        \u00abq_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2514\u2500\u2565\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u00bb\\n        \u00abq_1: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Delay(100[dt]) \u251c\u00bb\\n        \u00ab     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u2551           \u250c\u2500\u2534\u2500\u2510       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00abq_2: \u2524 Delay(600[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510      \u2514\u2500\u2500\u2500\u2518              \u2514\u2565\u2518        \u00bb\\n        \u00abc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x0 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u00bb\\n        \u00ab                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                          0         \u00bb\\n        \u00ab                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u00abq_0: \u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2524 Delay(700[dt]) \u251c\\n        \u00ab        \u250c\u2500\u2534\u2500\u2510   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n        \u00abq_1: \u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 Delay(700[dt]) \u251c\\n        \u00ab        \u2514\u2500\u2565\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        \u00abq_2: \u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        \u00abc: 1/\u2561 c_0=0x0 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    qc = QuantumCircuit(3, 1)\n    qc.delay(100, 0)\n    qc.x(0).c_if(0, 1)\n    qc.barrier()\n    qc.measure(2, 0)\n    qc.x(1).c_if(0, 0)\n    qc.x(0).c_if(0, 0)\n    qc.delay(300, 0)\n    qc.cx(1, 2)\n    qc.x(0)\n    qc.cx(0, 1).c_if(0, 0)\n    qc.measure(2, 0)\n    durations = InstructionDurations([('x', None, 100), ('measure', None, 1000), ('cx', None, 200)])\n    actual_asap = PassManager([SetIOLatency(clbit_write_latency=100, conditional_latency=200), ASAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    actual_alap = PassManager([SetIOLatency(clbit_write_latency=100, conditional_latency=200), ALAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    expected_asap = QuantumCircuit(3, 1)\n    expected_asap.delay(200, 0)\n    expected_asap.delay(300, 1)\n    expected_asap.delay(300, 2)\n    expected_asap.x(0).c_if(0, 1)\n    expected_asap.barrier()\n    expected_asap.delay(1400, 0)\n    expected_asap.delay(1200, 1)\n    expected_asap.measure(2, 0)\n    expected_asap.x(1).c_if(0, 0)\n    expected_asap.x(0).c_if(0, 0)\n    expected_asap.delay(300, 0)\n    expected_asap.x(0)\n    expected_asap.delay(300, 2)\n    expected_asap.cx(1, 2)\n    expected_asap.delay(400, 1)\n    expected_asap.cx(0, 1).c_if(0, 0)\n    expected_asap.delay(700, 0)\n    expected_asap.delay(700, 1)\n    expected_asap.delay(300, 2)\n    expected_asap.measure(2, 0)\n    self.assertEqual(expected_asap, actual_asap)\n    self.assertEqual(actual_asap.duration, 3100)\n    expected_alap = QuantumCircuit(3, 1)\n    expected_alap.delay(200, 0)\n    expected_alap.delay(300, 1)\n    expected_alap.delay(300, 2)\n    expected_alap.x(0).c_if(0, 1)\n    expected_alap.barrier()\n    expected_alap.delay(1400, 0)\n    expected_alap.delay(1200, 1)\n    expected_alap.measure(2, 0)\n    expected_alap.x(1).c_if(0, 0)\n    expected_alap.x(0).c_if(0, 0)\n    expected_alap.delay(300, 0)\n    expected_alap.x(0)\n    expected_alap.delay(300, 1)\n    expected_alap.delay(600, 2)\n    expected_alap.cx(1, 2)\n    expected_alap.delay(100, 1)\n    expected_alap.cx(0, 1).c_if(0, 0)\n    expected_alap.measure(2, 0)\n    expected_alap.delay(700, 0)\n    expected_alap.delay(700, 1)\n    self.assertEqual(expected_alap, actual_alap)\n    self.assertEqual(actual_alap.duration, 3100)",
            "def test_random_complicated_circuit(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test scheduling complicated circuit with control flow.\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510    \u2591                  \u250c\u2500\u2500\u2500\u2510   \u00bb\\n        q_0: \u2524 Delay(100[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u00bb\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2565\u2500\u2518    \u2591       \u250c\u2500\u2500\u2500\u2510      \u2514\u2500\u2565\u2500\u2518   \u00bb\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u00bb\\n                                    \u2551      \u2591 \u250c\u2500\u2510   \u2514\u2500\u2565\u2500\u2518        \u2551     \u00bb\\n        q_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u00bb\\n                               \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2591 \u2514\u2565\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u00bb\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2569\u2550\u2561 c_0=0x0 \u255e\u2561 c_0=0x0 \u255e\u00bb\\n                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    0 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\\n        \u00abq_0: \u2524 Delay(300[dt]) \u251c\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518   \u250c\u2500\u2534\u2500\u2510\\n        \u00abq_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n        \u00ab           \u250c\u2500\u2534\u2500\u2510        \u250c\u2500\u2510    \u2514\u2500\u2565\u2500\u2518\\n        \u00abq_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\\n        \u00ab           \u2514\u2500\u2500\u2500\u2518        \u2514\u2565\u2518 \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        \u00abc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2561 c_0=0x0 \u255e\\n        \u00ab                         0  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        (ASAP scheduled) duration = 2800 dt\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510    \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u00bb\\n        q_0: \u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Delay(1400[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2514\u2500\u2565\u2500\u2518    \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u250c\u2500\u2500\u2500\u2510   \u00bb\\n        q_1: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Delay(1200[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u00bb\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u2551      \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2565\u2500\u2518   \u00bb\\n        q_2: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u00bb\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2591         \u2514\u2565\u2518        \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u00bb\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x0 \u255e\u00bb\\n                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            0         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00ab                          \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2510       \u00bb\\n        \u00abq_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n        \u00ab                          \u2514\u2500\u2565\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u00bb\\n        \u00abq_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Delay(400[dt]) \u251c\u00bb\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2551           \u250c\u2500\u2534\u2500\u2510       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u00bb\\n        \u00abq_2: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Delay(300[dt]) \u251c\u00bb\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510      \u2514\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00abc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x0 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u00bb\\n        \u00ab                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                    \u00bb\\n        \u00ab                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u00abq_0: \u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2524 Delay(700[dt]) \u251c\\n        \u00ab        \u250c\u2500\u2534\u2500\u2510   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n        \u00abq_1: \u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 Delay(700[dt]) \u251c\\n        \u00ab        \u2514\u2500\u2565\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        \u00abq_2: \u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510       \u2514\u2565\u2518\\n        \u00abc: 1/\u2561 c_0=0x0 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        0\\n\\n        (ALAP scheduled) duration = 3100\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510    \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u00bb\\n        q_0: \u2524 Delay(200[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Delay(1400[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2514\u2500\u2565\u2500\u2518    \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u250c\u2500\u2500\u2500\u2510   \u00bb\\n        q_1: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Delay(1200[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u00bb\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u2551      \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2565\u2500\u2518   \u00bb\\n        q_2: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u00bb\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510 \u2591         \u2514\u2565\u2518        \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u00bb\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x0 \u255e\u00bb\\n                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            0         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00ab                          \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2510       \u00bb\\n        \u00abq_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2514\u2500\u2565\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u00bb\\n        \u00abq_1: \u2524 Delay(300[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Delay(100[dt]) \u251c\u00bb\\n        \u00ab     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u2551           \u250c\u2500\u2534\u2500\u2510       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u00bb\\n        \u00abq_2: \u2524 Delay(600[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510      \u2514\u2500\u2500\u2500\u2518              \u2514\u2565\u2518        \u00bb\\n        \u00abc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x0 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u00bb\\n        \u00ab                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                          0         \u00bb\\n        \u00ab                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        \u00abq_0: \u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2524 Delay(700[dt]) \u251c\\n        \u00ab        \u250c\u2500\u2534\u2500\u2510   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n        \u00abq_1: \u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 Delay(700[dt]) \u251c\\n        \u00ab        \u2514\u2500\u2565\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        \u00abq_2: \u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n        \u00ab     \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        \u00abc: 1/\u2561 c_0=0x0 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n        \u00ab     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        '\n    qc = QuantumCircuit(3, 1)\n    qc.delay(100, 0)\n    qc.x(0).c_if(0, 1)\n    qc.barrier()\n    qc.measure(2, 0)\n    qc.x(1).c_if(0, 0)\n    qc.x(0).c_if(0, 0)\n    qc.delay(300, 0)\n    qc.cx(1, 2)\n    qc.x(0)\n    qc.cx(0, 1).c_if(0, 0)\n    qc.measure(2, 0)\n    durations = InstructionDurations([('x', None, 100), ('measure', None, 1000), ('cx', None, 200)])\n    actual_asap = PassManager([SetIOLatency(clbit_write_latency=100, conditional_latency=200), ASAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    actual_alap = PassManager([SetIOLatency(clbit_write_latency=100, conditional_latency=200), ALAPScheduleAnalysis(durations), PadDelay()]).run(qc)\n    expected_asap = QuantumCircuit(3, 1)\n    expected_asap.delay(200, 0)\n    expected_asap.delay(300, 1)\n    expected_asap.delay(300, 2)\n    expected_asap.x(0).c_if(0, 1)\n    expected_asap.barrier()\n    expected_asap.delay(1400, 0)\n    expected_asap.delay(1200, 1)\n    expected_asap.measure(2, 0)\n    expected_asap.x(1).c_if(0, 0)\n    expected_asap.x(0).c_if(0, 0)\n    expected_asap.delay(300, 0)\n    expected_asap.x(0)\n    expected_asap.delay(300, 2)\n    expected_asap.cx(1, 2)\n    expected_asap.delay(400, 1)\n    expected_asap.cx(0, 1).c_if(0, 0)\n    expected_asap.delay(700, 0)\n    expected_asap.delay(700, 1)\n    expected_asap.delay(300, 2)\n    expected_asap.measure(2, 0)\n    self.assertEqual(expected_asap, actual_asap)\n    self.assertEqual(actual_asap.duration, 3100)\n    expected_alap = QuantumCircuit(3, 1)\n    expected_alap.delay(200, 0)\n    expected_alap.delay(300, 1)\n    expected_alap.delay(300, 2)\n    expected_alap.x(0).c_if(0, 1)\n    expected_alap.barrier()\n    expected_alap.delay(1400, 0)\n    expected_alap.delay(1200, 1)\n    expected_alap.measure(2, 0)\n    expected_alap.x(1).c_if(0, 0)\n    expected_alap.x(0).c_if(0, 0)\n    expected_alap.delay(300, 0)\n    expected_alap.x(0)\n    expected_alap.delay(300, 1)\n    expected_alap.delay(600, 2)\n    expected_alap.cx(1, 2)\n    expected_alap.delay(100, 1)\n    expected_alap.cx(0, 1).c_if(0, 0)\n    expected_alap.measure(2, 0)\n    expected_alap.delay(700, 0)\n    expected_alap.delay(700, 1)\n    self.assertEqual(expected_alap, actual_alap)\n    self.assertEqual(actual_alap.duration, 3100)"
        ]
    },
    {
        "func_name": "test_dag_introduces_extra_dependency_between_conditionals",
        "original": "def test_dag_introduces_extra_dependency_between_conditionals(self):\n    \"\"\"Test dependency between conditional operations in the scheduling.\n\n        In the below example circuit, the conditional x on q1 could start at time 0,\n        however it must be scheduled after the conditional x on q0 in ASAP scheduling.\n        That is because circuit model used in the transpiler passes (DAGCircuit)\n        interprets instructions acting on common clbits must be run in the order\n        given by the original circuit (QuantumCircuit).\n\n        (input)\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510\n        q_0: \u2524 Delay(100[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2565\u2500\u2518\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\n                   \u2514\u2500\u2565\u2500\u2518            \u2551\n                \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\n        c: 1/\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        (ASAP scheduled)\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510\n        q_0: \u2524 Delay(100[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2514\u2500\u2565\u2500\u2518      \u250c\u2500\u2500\u2500\u2510\n        q_1: \u2524 Delay(100[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2551        \u2514\u2500\u2565\u2500\u2518\n                               \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2561 c_0=0x1 \u255e\n                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \"\"\"\n    qc = QuantumCircuit(2, 1)\n    qc.delay(100, 0)\n    qc.x(0).c_if(0, True)\n    qc.x(1).c_if(0, True)\n    durations = InstructionDurations([('x', None, 160)])\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2, 1)\n    expected.delay(100, 0)\n    expected.delay(100, 1)\n    expected.x(0).c_if(0, True)\n    expected.x(1).c_if(0, True)\n    self.assertEqual(expected, scheduled)",
        "mutated": [
            "def test_dag_introduces_extra_dependency_between_conditionals(self):\n    if False:\n        i = 10\n    'Test dependency between conditional operations in the scheduling.\\n\\n        In the below example circuit, the conditional x on q1 could start at time 0,\\n        however it must be scheduled after the conditional x on q0 in ASAP scheduling.\\n        That is because circuit model used in the transpiler passes (DAGCircuit)\\n        interprets instructions acting on common clbits must be run in the order\\n        given by the original circuit (QuantumCircuit).\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510\\n        q_0: \u2524 Delay(100[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2565\u2500\u2518\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\\n                   \u2514\u2500\u2565\u2500\u2518            \u2551\\n                \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        (ASAP scheduled)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510\\n        q_0: \u2524 Delay(100[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2514\u2500\u2565\u2500\u2518      \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2524 Delay(100[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2551        \u2514\u2500\u2565\u2500\u2518\\n                               \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2561 c_0=0x1 \u255e\\n                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.delay(100, 0)\n    qc.x(0).c_if(0, True)\n    qc.x(1).c_if(0, True)\n    durations = InstructionDurations([('x', None, 160)])\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2, 1)\n    expected.delay(100, 0)\n    expected.delay(100, 1)\n    expected.x(0).c_if(0, True)\n    expected.x(1).c_if(0, True)\n    self.assertEqual(expected, scheduled)",
            "def test_dag_introduces_extra_dependency_between_conditionals(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test dependency between conditional operations in the scheduling.\\n\\n        In the below example circuit, the conditional x on q1 could start at time 0,\\n        however it must be scheduled after the conditional x on q0 in ASAP scheduling.\\n        That is because circuit model used in the transpiler passes (DAGCircuit)\\n        interprets instructions acting on common clbits must be run in the order\\n        given by the original circuit (QuantumCircuit).\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510\\n        q_0: \u2524 Delay(100[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2565\u2500\u2518\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\\n                   \u2514\u2500\u2565\u2500\u2518            \u2551\\n                \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        (ASAP scheduled)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510\\n        q_0: \u2524 Delay(100[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2514\u2500\u2565\u2500\u2518      \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2524 Delay(100[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2551        \u2514\u2500\u2565\u2500\u2518\\n                               \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2561 c_0=0x1 \u255e\\n                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.delay(100, 0)\n    qc.x(0).c_if(0, True)\n    qc.x(1).c_if(0, True)\n    durations = InstructionDurations([('x', None, 160)])\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2, 1)\n    expected.delay(100, 0)\n    expected.delay(100, 1)\n    expected.x(0).c_if(0, True)\n    expected.x(1).c_if(0, True)\n    self.assertEqual(expected, scheduled)",
            "def test_dag_introduces_extra_dependency_between_conditionals(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test dependency between conditional operations in the scheduling.\\n\\n        In the below example circuit, the conditional x on q1 could start at time 0,\\n        however it must be scheduled after the conditional x on q0 in ASAP scheduling.\\n        That is because circuit model used in the transpiler passes (DAGCircuit)\\n        interprets instructions acting on common clbits must be run in the order\\n        given by the original circuit (QuantumCircuit).\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510\\n        q_0: \u2524 Delay(100[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2565\u2500\u2518\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\\n                   \u2514\u2500\u2565\u2500\u2518            \u2551\\n                \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        (ASAP scheduled)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510\\n        q_0: \u2524 Delay(100[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2514\u2500\u2565\u2500\u2518      \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2524 Delay(100[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2551        \u2514\u2500\u2565\u2500\u2518\\n                               \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2561 c_0=0x1 \u255e\\n                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.delay(100, 0)\n    qc.x(0).c_if(0, True)\n    qc.x(1).c_if(0, True)\n    durations = InstructionDurations([('x', None, 160)])\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2, 1)\n    expected.delay(100, 0)\n    expected.delay(100, 1)\n    expected.x(0).c_if(0, True)\n    expected.x(1).c_if(0, True)\n    self.assertEqual(expected, scheduled)",
            "def test_dag_introduces_extra_dependency_between_conditionals(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test dependency between conditional operations in the scheduling.\\n\\n        In the below example circuit, the conditional x on q1 could start at time 0,\\n        however it must be scheduled after the conditional x on q0 in ASAP scheduling.\\n        That is because circuit model used in the transpiler passes (DAGCircuit)\\n        interprets instructions acting on common clbits must be run in the order\\n        given by the original circuit (QuantumCircuit).\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510\\n        q_0: \u2524 Delay(100[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2565\u2500\u2518\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\\n                   \u2514\u2500\u2565\u2500\u2518            \u2551\\n                \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        (ASAP scheduled)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510\\n        q_0: \u2524 Delay(100[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2514\u2500\u2565\u2500\u2518      \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2524 Delay(100[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2551        \u2514\u2500\u2565\u2500\u2518\\n                               \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2561 c_0=0x1 \u255e\\n                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.delay(100, 0)\n    qc.x(0).c_if(0, True)\n    qc.x(1).c_if(0, True)\n    durations = InstructionDurations([('x', None, 160)])\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2, 1)\n    expected.delay(100, 0)\n    expected.delay(100, 1)\n    expected.x(0).c_if(0, True)\n    expected.x(1).c_if(0, True)\n    self.assertEqual(expected, scheduled)",
            "def test_dag_introduces_extra_dependency_between_conditionals(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test dependency between conditional operations in the scheduling.\\n\\n        In the below example circuit, the conditional x on q1 could start at time 0,\\n        however it must be scheduled after the conditional x on q0 in ASAP scheduling.\\n        That is because circuit model used in the transpiler passes (DAGCircuit)\\n        interprets instructions acting on common clbits must be run in the order\\n        given by the original circuit (QuantumCircuit).\\n\\n        (input)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510\\n        q_0: \u2524 Delay(100[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2565\u2500\u2518\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\\n                   \u2514\u2500\u2565\u2500\u2518            \u2551\\n                \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n        (ASAP scheduled)\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510\\n        q_0: \u2524 Delay(100[dt]) \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2514\u2500\u2565\u2500\u2518      \u250c\u2500\u2500\u2500\u2510\\n        q_1: \u2524 Delay(100[dt]) \u251c\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2551        \u2514\u2500\u2565\u2500\u2518\\n                               \u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2510\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 c_0=0x1 \u255e\u2561 c_0=0x1 \u255e\\n                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.delay(100, 0)\n    qc.x(0).c_if(0, True)\n    qc.x(1).c_if(0, True)\n    durations = InstructionDurations([('x', None, 160)])\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2, 1)\n    expected.delay(100, 0)\n    expected.delay(100, 1)\n    expected.x(0).c_if(0, True)\n    expected.x(1).c_if(0, True)\n    self.assertEqual(expected, scheduled)"
        ]
    },
    {
        "func_name": "test_scheduling_with_calibration",
        "original": "def test_scheduling_with_calibration(self):\n    \"\"\"Test if calibrated instruction can update node duration.\"\"\"\n    qc = QuantumCircuit(2)\n    qc.x(0)\n    qc.cx(0, 1)\n    qc.x(1)\n    qc.cx(0, 1)\n    xsched = Schedule(Play(Constant(300, 0.1), DriveChannel(0)))\n    qc.add_calibration('x', (0,), xsched)\n    durations = InstructionDurations([('x', None, 160), ('cx', None, 600)])\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2)\n    expected.x(0)\n    expected.delay(300, 1)\n    expected.cx(0, 1)\n    expected.x(1)\n    expected.delay(160, 0)\n    expected.cx(0, 1)\n    expected.add_calibration('x', (0,), xsched)\n    self.assertEqual(expected, scheduled)",
        "mutated": [
            "def test_scheduling_with_calibration(self):\n    if False:\n        i = 10\n    'Test if calibrated instruction can update node duration.'\n    qc = QuantumCircuit(2)\n    qc.x(0)\n    qc.cx(0, 1)\n    qc.x(1)\n    qc.cx(0, 1)\n    xsched = Schedule(Play(Constant(300, 0.1), DriveChannel(0)))\n    qc.add_calibration('x', (0,), xsched)\n    durations = InstructionDurations([('x', None, 160), ('cx', None, 600)])\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2)\n    expected.x(0)\n    expected.delay(300, 1)\n    expected.cx(0, 1)\n    expected.x(1)\n    expected.delay(160, 0)\n    expected.cx(0, 1)\n    expected.add_calibration('x', (0,), xsched)\n    self.assertEqual(expected, scheduled)",
            "def test_scheduling_with_calibration(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test if calibrated instruction can update node duration.'\n    qc = QuantumCircuit(2)\n    qc.x(0)\n    qc.cx(0, 1)\n    qc.x(1)\n    qc.cx(0, 1)\n    xsched = Schedule(Play(Constant(300, 0.1), DriveChannel(0)))\n    qc.add_calibration('x', (0,), xsched)\n    durations = InstructionDurations([('x', None, 160), ('cx', None, 600)])\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2)\n    expected.x(0)\n    expected.delay(300, 1)\n    expected.cx(0, 1)\n    expected.x(1)\n    expected.delay(160, 0)\n    expected.cx(0, 1)\n    expected.add_calibration('x', (0,), xsched)\n    self.assertEqual(expected, scheduled)",
            "def test_scheduling_with_calibration(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test if calibrated instruction can update node duration.'\n    qc = QuantumCircuit(2)\n    qc.x(0)\n    qc.cx(0, 1)\n    qc.x(1)\n    qc.cx(0, 1)\n    xsched = Schedule(Play(Constant(300, 0.1), DriveChannel(0)))\n    qc.add_calibration('x', (0,), xsched)\n    durations = InstructionDurations([('x', None, 160), ('cx', None, 600)])\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2)\n    expected.x(0)\n    expected.delay(300, 1)\n    expected.cx(0, 1)\n    expected.x(1)\n    expected.delay(160, 0)\n    expected.cx(0, 1)\n    expected.add_calibration('x', (0,), xsched)\n    self.assertEqual(expected, scheduled)",
            "def test_scheduling_with_calibration(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test if calibrated instruction can update node duration.'\n    qc = QuantumCircuit(2)\n    qc.x(0)\n    qc.cx(0, 1)\n    qc.x(1)\n    qc.cx(0, 1)\n    xsched = Schedule(Play(Constant(300, 0.1), DriveChannel(0)))\n    qc.add_calibration('x', (0,), xsched)\n    durations = InstructionDurations([('x', None, 160), ('cx', None, 600)])\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2)\n    expected.x(0)\n    expected.delay(300, 1)\n    expected.cx(0, 1)\n    expected.x(1)\n    expected.delay(160, 0)\n    expected.cx(0, 1)\n    expected.add_calibration('x', (0,), xsched)\n    self.assertEqual(expected, scheduled)",
            "def test_scheduling_with_calibration(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test if calibrated instruction can update node duration.'\n    qc = QuantumCircuit(2)\n    qc.x(0)\n    qc.cx(0, 1)\n    qc.x(1)\n    qc.cx(0, 1)\n    xsched = Schedule(Play(Constant(300, 0.1), DriveChannel(0)))\n    qc.add_calibration('x', (0,), xsched)\n    durations = InstructionDurations([('x', None, 160), ('cx', None, 600)])\n    pm = PassManager([ASAPScheduleAnalysis(durations), PadDelay()])\n    scheduled = pm.run(qc)\n    expected = QuantumCircuit(2)\n    expected.x(0)\n    expected.delay(300, 1)\n    expected.cx(0, 1)\n    expected.x(1)\n    expected.delay(160, 0)\n    expected.cx(0, 1)\n    expected.add_calibration('x', (0,), xsched)\n    self.assertEqual(expected, scheduled)"
        ]
    },
    {
        "func_name": "test_padding_not_working_without_scheduling",
        "original": "def test_padding_not_working_without_scheduling(self):\n    \"\"\"Test padding fails when un-scheduled DAG is input.\"\"\"\n    qc = QuantumCircuit(1, 1)\n    qc.delay(100, 0)\n    qc.x(0)\n    qc.measure(0, 0)\n    with self.assertRaises(TranspilerError):\n        PassManager(PadDelay()).run(qc)",
        "mutated": [
            "def test_padding_not_working_without_scheduling(self):\n    if False:\n        i = 10\n    'Test padding fails when un-scheduled DAG is input.'\n    qc = QuantumCircuit(1, 1)\n    qc.delay(100, 0)\n    qc.x(0)\n    qc.measure(0, 0)\n    with self.assertRaises(TranspilerError):\n        PassManager(PadDelay()).run(qc)",
            "def test_padding_not_working_without_scheduling(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test padding fails when un-scheduled DAG is input.'\n    qc = QuantumCircuit(1, 1)\n    qc.delay(100, 0)\n    qc.x(0)\n    qc.measure(0, 0)\n    with self.assertRaises(TranspilerError):\n        PassManager(PadDelay()).run(qc)",
            "def test_padding_not_working_without_scheduling(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test padding fails when un-scheduled DAG is input.'\n    qc = QuantumCircuit(1, 1)\n    qc.delay(100, 0)\n    qc.x(0)\n    qc.measure(0, 0)\n    with self.assertRaises(TranspilerError):\n        PassManager(PadDelay()).run(qc)",
            "def test_padding_not_working_without_scheduling(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test padding fails when un-scheduled DAG is input.'\n    qc = QuantumCircuit(1, 1)\n    qc.delay(100, 0)\n    qc.x(0)\n    qc.measure(0, 0)\n    with self.assertRaises(TranspilerError):\n        PassManager(PadDelay()).run(qc)",
            "def test_padding_not_working_without_scheduling(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test padding fails when un-scheduled DAG is input.'\n    qc = QuantumCircuit(1, 1)\n    qc.delay(100, 0)\n    qc.x(0)\n    qc.measure(0, 0)\n    with self.assertRaises(TranspilerError):\n        PassManager(PadDelay()).run(qc)"
        ]
    },
    {
        "func_name": "test_no_pad_very_end_of_circuit",
        "original": "def test_no_pad_very_end_of_circuit(self):\n    \"\"\"Test padding option that inserts no delay at the very end of circuit.\n\n        This circuit will be unchanged after ASAP-schedule/padding.\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510\n        q_0: \u2524 Delay(100[dt]) \u251c\u2524M\u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2565\u2518\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\n                   \u2514\u2500\u2500\u2500\u2518        \u2551\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\n                                0\n        \"\"\"\n    qc = QuantumCircuit(2, 1)\n    qc.delay(100, 0)\n    qc.x(1)\n    qc.measure(0, 0)\n    durations = InstructionDurations([('x', None, 160), ('measure', None, 1000)])\n    scheduled = PassManager([ASAPScheduleAnalysis(durations), PadDelay(fill_very_end=False)]).run(qc)\n    self.assertEqual(scheduled, qc)",
        "mutated": [
            "def test_no_pad_very_end_of_circuit(self):\n    if False:\n        i = 10\n    'Test padding option that inserts no delay at the very end of circuit.\\n\\n        This circuit will be unchanged after ASAP-schedule/padding.\\n\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 Delay(100[dt]) \u251c\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2565\u2518\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\\n                   \u2514\u2500\u2500\u2500\u2518        \u2551\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\\n                                0\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.delay(100, 0)\n    qc.x(1)\n    qc.measure(0, 0)\n    durations = InstructionDurations([('x', None, 160), ('measure', None, 1000)])\n    scheduled = PassManager([ASAPScheduleAnalysis(durations), PadDelay(fill_very_end=False)]).run(qc)\n    self.assertEqual(scheduled, qc)",
            "def test_no_pad_very_end_of_circuit(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test padding option that inserts no delay at the very end of circuit.\\n\\n        This circuit will be unchanged after ASAP-schedule/padding.\\n\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 Delay(100[dt]) \u251c\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2565\u2518\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\\n                   \u2514\u2500\u2500\u2500\u2518        \u2551\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\\n                                0\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.delay(100, 0)\n    qc.x(1)\n    qc.measure(0, 0)\n    durations = InstructionDurations([('x', None, 160), ('measure', None, 1000)])\n    scheduled = PassManager([ASAPScheduleAnalysis(durations), PadDelay(fill_very_end=False)]).run(qc)\n    self.assertEqual(scheduled, qc)",
            "def test_no_pad_very_end_of_circuit(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test padding option that inserts no delay at the very end of circuit.\\n\\n        This circuit will be unchanged after ASAP-schedule/padding.\\n\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 Delay(100[dt]) \u251c\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2565\u2518\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\\n                   \u2514\u2500\u2500\u2500\u2518        \u2551\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\\n                                0\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.delay(100, 0)\n    qc.x(1)\n    qc.measure(0, 0)\n    durations = InstructionDurations([('x', None, 160), ('measure', None, 1000)])\n    scheduled = PassManager([ASAPScheduleAnalysis(durations), PadDelay(fill_very_end=False)]).run(qc)\n    self.assertEqual(scheduled, qc)",
            "def test_no_pad_very_end_of_circuit(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test padding option that inserts no delay at the very end of circuit.\\n\\n        This circuit will be unchanged after ASAP-schedule/padding.\\n\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 Delay(100[dt]) \u251c\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2565\u2518\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\\n                   \u2514\u2500\u2500\u2500\u2518        \u2551\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\\n                                0\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.delay(100, 0)\n    qc.x(1)\n    qc.measure(0, 0)\n    durations = InstructionDurations([('x', None, 160), ('measure', None, 1000)])\n    scheduled = PassManager([ASAPScheduleAnalysis(durations), PadDelay(fill_very_end=False)]).run(qc)\n    self.assertEqual(scheduled, qc)",
            "def test_no_pad_very_end_of_circuit(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test padding option that inserts no delay at the very end of circuit.\\n\\n        This circuit will be unchanged after ASAP-schedule/padding.\\n\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510\\n        q_0: \u2524 Delay(100[dt]) \u251c\u2524M\u251c\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2565\u2518\\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\\n                   \u2514\u2500\u2500\u2500\u2518        \u2551\\n        c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\\n                                0\\n        '\n    qc = QuantumCircuit(2, 1)\n    qc.delay(100, 0)\n    qc.x(1)\n    qc.measure(0, 0)\n    durations = InstructionDurations([('x', None, 160), ('measure', None, 1000)])\n    scheduled = PassManager([ASAPScheduleAnalysis(durations), PadDelay(fill_very_end=False)]).run(qc)\n    self.assertEqual(scheduled, qc)"
        ]
    },
    {
        "func_name": "test_respect_target_instruction_constraints",
        "original": "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_respect_target_instruction_constraints(self, schedule_pass):\n    \"\"\"Test if DD pass does not pad delays for qubits that do not support delay instructions.\n        See: https://github.com/Qiskit/qiskit-terra/issues/9993\n        \"\"\"\n    qc = QuantumCircuit(3)\n    qc.cx(1, 2)\n    target = Target(dt=1)\n    target.add_instruction(CXGate(), {(1, 2): InstructionProperties(duration=1000)})\n    pm = PassManager([schedule_pass(target=target), PadDelay(target=target)])\n    scheduled = pm.run(qc)\n    self.assertEqual(qc, scheduled)",
        "mutated": [
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_respect_target_instruction_constraints(self, schedule_pass):\n    if False:\n        i = 10\n    'Test if DD pass does not pad delays for qubits that do not support delay instructions.\\n        See: https://github.com/Qiskit/qiskit-terra/issues/9993\\n        '\n    qc = QuantumCircuit(3)\n    qc.cx(1, 2)\n    target = Target(dt=1)\n    target.add_instruction(CXGate(), {(1, 2): InstructionProperties(duration=1000)})\n    pm = PassManager([schedule_pass(target=target), PadDelay(target=target)])\n    scheduled = pm.run(qc)\n    self.assertEqual(qc, scheduled)",
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_respect_target_instruction_constraints(self, schedule_pass):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test if DD pass does not pad delays for qubits that do not support delay instructions.\\n        See: https://github.com/Qiskit/qiskit-terra/issues/9993\\n        '\n    qc = QuantumCircuit(3)\n    qc.cx(1, 2)\n    target = Target(dt=1)\n    target.add_instruction(CXGate(), {(1, 2): InstructionProperties(duration=1000)})\n    pm = PassManager([schedule_pass(target=target), PadDelay(target=target)])\n    scheduled = pm.run(qc)\n    self.assertEqual(qc, scheduled)",
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_respect_target_instruction_constraints(self, schedule_pass):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test if DD pass does not pad delays for qubits that do not support delay instructions.\\n        See: https://github.com/Qiskit/qiskit-terra/issues/9993\\n        '\n    qc = QuantumCircuit(3)\n    qc.cx(1, 2)\n    target = Target(dt=1)\n    target.add_instruction(CXGate(), {(1, 2): InstructionProperties(duration=1000)})\n    pm = PassManager([schedule_pass(target=target), PadDelay(target=target)])\n    scheduled = pm.run(qc)\n    self.assertEqual(qc, scheduled)",
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_respect_target_instruction_constraints(self, schedule_pass):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test if DD pass does not pad delays for qubits that do not support delay instructions.\\n        See: https://github.com/Qiskit/qiskit-terra/issues/9993\\n        '\n    qc = QuantumCircuit(3)\n    qc.cx(1, 2)\n    target = Target(dt=1)\n    target.add_instruction(CXGate(), {(1, 2): InstructionProperties(duration=1000)})\n    pm = PassManager([schedule_pass(target=target), PadDelay(target=target)])\n    scheduled = pm.run(qc)\n    self.assertEqual(qc, scheduled)",
            "@data(ALAPScheduleAnalysis, ASAPScheduleAnalysis)\ndef test_respect_target_instruction_constraints(self, schedule_pass):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test if DD pass does not pad delays for qubits that do not support delay instructions.\\n        See: https://github.com/Qiskit/qiskit-terra/issues/9993\\n        '\n    qc = QuantumCircuit(3)\n    qc.cx(1, 2)\n    target = Target(dt=1)\n    target.add_instruction(CXGate(), {(1, 2): InstructionProperties(duration=1000)})\n    pm = PassManager([schedule_pass(target=target), PadDelay(target=target)])\n    scheduled = pm.run(qc)\n    self.assertEqual(qc, scheduled)"
        ]
    }
]