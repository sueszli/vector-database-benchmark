[
    {
        "func_name": "lombscargle_slow",
        "original": "def lombscargle_slow(t, y, dy, frequency, normalization='standard', fit_mean=True, center_data=True):\n    \"\"\"Lomb-Scargle Periodogram.\n\n    This is a pure-python implementation of the original Lomb-Scargle formalism\n    (e.g. [1]_, [2]_), with the addition of the floating mean (e.g. [3]_)\n\n    Parameters\n    ----------\n    t, y, dy : array-like\n        times, values, and errors of the data points. These should be\n        broadcastable to the same shape. None should be `~astropy.units.Quantity`.\n    frequency : array-like\n        frequencies (not angular frequencies) at which to calculate periodogram\n    normalization : str, optional\n        Normalization to use for the periodogram.\n        Options are 'standard', 'model', 'log', or 'psd'.\n    fit_mean : bool, optional\n        if True, include a constant offset as part of the model at each\n        frequency. This can lead to more accurate results, especially in the\n        case of incomplete phase coverage.\n    center_data : bool, optional\n        if True, pre-center the data by subtracting the weighted mean\n        of the input data. This is especially important if ``fit_mean = False``\n\n    Returns\n    -------\n    power : array-like\n        Lomb-Scargle power associated with each frequency.\n        Units of the result depend on the normalization.\n\n    References\n    ----------\n    .. [1] W. Press et al, Numerical Recipes in C (2002)\n    .. [2] Scargle, J.D. 1982, ApJ 263:835-853\n    .. [3] M. Zechmeister and M. Kurster, A&A 496, 577-584 (2009)\n    \"\"\"\n    if dy is None:\n        dy = 1\n    (t, y, dy) = np.broadcast_arrays(t, y, dy)\n    frequency = np.asarray(frequency)\n    if t.ndim != 1:\n        raise ValueError('t, y, dy should be one dimensional')\n    if frequency.ndim != 1:\n        raise ValueError('frequency should be one-dimensional')\n    w = dy ** (-2.0)\n    w /= w.sum()\n    if fit_mean or center_data:\n        y = y - np.dot(w, y)\n    omega = 2 * np.pi * frequency\n    omega = omega.ravel()[np.newaxis, :]\n    (t, y, dy, w) = (x[:, np.newaxis] for x in (t, y, dy, w))\n    sin_omega_t = np.sin(omega * t)\n    cos_omega_t = np.cos(omega * t)\n    S2 = 2 * np.dot(w.T, sin_omega_t * cos_omega_t)\n    C2 = 2 * np.dot(w.T, 0.5 - sin_omega_t ** 2)\n    if fit_mean:\n        S = np.dot(w.T, sin_omega_t)\n        C = np.dot(w.T, cos_omega_t)\n        S2 -= 2 * S * C\n        C2 -= C * C - S * S\n    omega_t_tau = omega * t - 0.5 * np.arctan2(S2, C2)\n    sin_omega_t_tau = np.sin(omega_t_tau)\n    cos_omega_t_tau = np.cos(omega_t_tau)\n    Y = np.dot(w.T, y)\n    wy = w * y\n    YCtau = np.dot(wy.T, cos_omega_t_tau)\n    YStau = np.dot(wy.T, sin_omega_t_tau)\n    CCtau = np.dot(w.T, cos_omega_t_tau * cos_omega_t_tau)\n    SStau = np.dot(w.T, sin_omega_t_tau * sin_omega_t_tau)\n    if fit_mean:\n        Ctau = np.dot(w.T, cos_omega_t_tau)\n        Stau = np.dot(w.T, sin_omega_t_tau)\n        YCtau -= Y * Ctau\n        YStau -= Y * Stau\n        CCtau -= Ctau * Ctau\n        SStau -= Stau * Stau\n    p = YCtau * YCtau / CCtau + YStau * YStau / SStau\n    YY = np.dot(w.T, y * y)\n    if normalization == 'standard':\n        p /= YY\n    elif normalization == 'model':\n        p /= YY - p\n    elif normalization == 'log':\n        p = -np.log(1 - p / YY)\n    elif normalization == 'psd':\n        p *= 0.5 * (dy ** (-2.0)).sum()\n    else:\n        raise ValueError(f\"normalization='{normalization}' not recognized\")\n    return p.ravel()",
        "mutated": [
            "def lombscargle_slow(t, y, dy, frequency, normalization='standard', fit_mean=True, center_data=True):\n    if False:\n        i = 10\n    \"Lomb-Scargle Periodogram.\\n\\n    This is a pure-python implementation of the original Lomb-Scargle formalism\\n    (e.g. [1]_, [2]_), with the addition of the floating mean (e.g. [3]_)\\n\\n    Parameters\\n    ----------\\n    t, y, dy : array-like\\n        times, values, and errors of the data points. These should be\\n        broadcastable to the same shape. None should be `~astropy.units.Quantity`.\\n    frequency : array-like\\n        frequencies (not angular frequencies) at which to calculate periodogram\\n    normalization : str, optional\\n        Normalization to use for the periodogram.\\n        Options are 'standard', 'model', 'log', or 'psd'.\\n    fit_mean : bool, optional\\n        if True, include a constant offset as part of the model at each\\n        frequency. This can lead to more accurate results, especially in the\\n        case of incomplete phase coverage.\\n    center_data : bool, optional\\n        if True, pre-center the data by subtracting the weighted mean\\n        of the input data. This is especially important if ``fit_mean = False``\\n\\n    Returns\\n    -------\\n    power : array-like\\n        Lomb-Scargle power associated with each frequency.\\n        Units of the result depend on the normalization.\\n\\n    References\\n    ----------\\n    .. [1] W. Press et al, Numerical Recipes in C (2002)\\n    .. [2] Scargle, J.D. 1982, ApJ 263:835-853\\n    .. [3] M. Zechmeister and M. Kurster, A&A 496, 577-584 (2009)\\n    \"\n    if dy is None:\n        dy = 1\n    (t, y, dy) = np.broadcast_arrays(t, y, dy)\n    frequency = np.asarray(frequency)\n    if t.ndim != 1:\n        raise ValueError('t, y, dy should be one dimensional')\n    if frequency.ndim != 1:\n        raise ValueError('frequency should be one-dimensional')\n    w = dy ** (-2.0)\n    w /= w.sum()\n    if fit_mean or center_data:\n        y = y - np.dot(w, y)\n    omega = 2 * np.pi * frequency\n    omega = omega.ravel()[np.newaxis, :]\n    (t, y, dy, w) = (x[:, np.newaxis] for x in (t, y, dy, w))\n    sin_omega_t = np.sin(omega * t)\n    cos_omega_t = np.cos(omega * t)\n    S2 = 2 * np.dot(w.T, sin_omega_t * cos_omega_t)\n    C2 = 2 * np.dot(w.T, 0.5 - sin_omega_t ** 2)\n    if fit_mean:\n        S = np.dot(w.T, sin_omega_t)\n        C = np.dot(w.T, cos_omega_t)\n        S2 -= 2 * S * C\n        C2 -= C * C - S * S\n    omega_t_tau = omega * t - 0.5 * np.arctan2(S2, C2)\n    sin_omega_t_tau = np.sin(omega_t_tau)\n    cos_omega_t_tau = np.cos(omega_t_tau)\n    Y = np.dot(w.T, y)\n    wy = w * y\n    YCtau = np.dot(wy.T, cos_omega_t_tau)\n    YStau = np.dot(wy.T, sin_omega_t_tau)\n    CCtau = np.dot(w.T, cos_omega_t_tau * cos_omega_t_tau)\n    SStau = np.dot(w.T, sin_omega_t_tau * sin_omega_t_tau)\n    if fit_mean:\n        Ctau = np.dot(w.T, cos_omega_t_tau)\n        Stau = np.dot(w.T, sin_omega_t_tau)\n        YCtau -= Y * Ctau\n        YStau -= Y * Stau\n        CCtau -= Ctau * Ctau\n        SStau -= Stau * Stau\n    p = YCtau * YCtau / CCtau + YStau * YStau / SStau\n    YY = np.dot(w.T, y * y)\n    if normalization == 'standard':\n        p /= YY\n    elif normalization == 'model':\n        p /= YY - p\n    elif normalization == 'log':\n        p = -np.log(1 - p / YY)\n    elif normalization == 'psd':\n        p *= 0.5 * (dy ** (-2.0)).sum()\n    else:\n        raise ValueError(f\"normalization='{normalization}' not recognized\")\n    return p.ravel()",
            "def lombscargle_slow(t, y, dy, frequency, normalization='standard', fit_mean=True, center_data=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Lomb-Scargle Periodogram.\\n\\n    This is a pure-python implementation of the original Lomb-Scargle formalism\\n    (e.g. [1]_, [2]_), with the addition of the floating mean (e.g. [3]_)\\n\\n    Parameters\\n    ----------\\n    t, y, dy : array-like\\n        times, values, and errors of the data points. These should be\\n        broadcastable to the same shape. None should be `~astropy.units.Quantity`.\\n    frequency : array-like\\n        frequencies (not angular frequencies) at which to calculate periodogram\\n    normalization : str, optional\\n        Normalization to use for the periodogram.\\n        Options are 'standard', 'model', 'log', or 'psd'.\\n    fit_mean : bool, optional\\n        if True, include a constant offset as part of the model at each\\n        frequency. This can lead to more accurate results, especially in the\\n        case of incomplete phase coverage.\\n    center_data : bool, optional\\n        if True, pre-center the data by subtracting the weighted mean\\n        of the input data. This is especially important if ``fit_mean = False``\\n\\n    Returns\\n    -------\\n    power : array-like\\n        Lomb-Scargle power associated with each frequency.\\n        Units of the result depend on the normalization.\\n\\n    References\\n    ----------\\n    .. [1] W. Press et al, Numerical Recipes in C (2002)\\n    .. [2] Scargle, J.D. 1982, ApJ 263:835-853\\n    .. [3] M. Zechmeister and M. Kurster, A&A 496, 577-584 (2009)\\n    \"\n    if dy is None:\n        dy = 1\n    (t, y, dy) = np.broadcast_arrays(t, y, dy)\n    frequency = np.asarray(frequency)\n    if t.ndim != 1:\n        raise ValueError('t, y, dy should be one dimensional')\n    if frequency.ndim != 1:\n        raise ValueError('frequency should be one-dimensional')\n    w = dy ** (-2.0)\n    w /= w.sum()\n    if fit_mean or center_data:\n        y = y - np.dot(w, y)\n    omega = 2 * np.pi * frequency\n    omega = omega.ravel()[np.newaxis, :]\n    (t, y, dy, w) = (x[:, np.newaxis] for x in (t, y, dy, w))\n    sin_omega_t = np.sin(omega * t)\n    cos_omega_t = np.cos(omega * t)\n    S2 = 2 * np.dot(w.T, sin_omega_t * cos_omega_t)\n    C2 = 2 * np.dot(w.T, 0.5 - sin_omega_t ** 2)\n    if fit_mean:\n        S = np.dot(w.T, sin_omega_t)\n        C = np.dot(w.T, cos_omega_t)\n        S2 -= 2 * S * C\n        C2 -= C * C - S * S\n    omega_t_tau = omega * t - 0.5 * np.arctan2(S2, C2)\n    sin_omega_t_tau = np.sin(omega_t_tau)\n    cos_omega_t_tau = np.cos(omega_t_tau)\n    Y = np.dot(w.T, y)\n    wy = w * y\n    YCtau = np.dot(wy.T, cos_omega_t_tau)\n    YStau = np.dot(wy.T, sin_omega_t_tau)\n    CCtau = np.dot(w.T, cos_omega_t_tau * cos_omega_t_tau)\n    SStau = np.dot(w.T, sin_omega_t_tau * sin_omega_t_tau)\n    if fit_mean:\n        Ctau = np.dot(w.T, cos_omega_t_tau)\n        Stau = np.dot(w.T, sin_omega_t_tau)\n        YCtau -= Y * Ctau\n        YStau -= Y * Stau\n        CCtau -= Ctau * Ctau\n        SStau -= Stau * Stau\n    p = YCtau * YCtau / CCtau + YStau * YStau / SStau\n    YY = np.dot(w.T, y * y)\n    if normalization == 'standard':\n        p /= YY\n    elif normalization == 'model':\n        p /= YY - p\n    elif normalization == 'log':\n        p = -np.log(1 - p / YY)\n    elif normalization == 'psd':\n        p *= 0.5 * (dy ** (-2.0)).sum()\n    else:\n        raise ValueError(f\"normalization='{normalization}' not recognized\")\n    return p.ravel()",
            "def lombscargle_slow(t, y, dy, frequency, normalization='standard', fit_mean=True, center_data=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Lomb-Scargle Periodogram.\\n\\n    This is a pure-python implementation of the original Lomb-Scargle formalism\\n    (e.g. [1]_, [2]_), with the addition of the floating mean (e.g. [3]_)\\n\\n    Parameters\\n    ----------\\n    t, y, dy : array-like\\n        times, values, and errors of the data points. These should be\\n        broadcastable to the same shape. None should be `~astropy.units.Quantity`.\\n    frequency : array-like\\n        frequencies (not angular frequencies) at which to calculate periodogram\\n    normalization : str, optional\\n        Normalization to use for the periodogram.\\n        Options are 'standard', 'model', 'log', or 'psd'.\\n    fit_mean : bool, optional\\n        if True, include a constant offset as part of the model at each\\n        frequency. This can lead to more accurate results, especially in the\\n        case of incomplete phase coverage.\\n    center_data : bool, optional\\n        if True, pre-center the data by subtracting the weighted mean\\n        of the input data. This is especially important if ``fit_mean = False``\\n\\n    Returns\\n    -------\\n    power : array-like\\n        Lomb-Scargle power associated with each frequency.\\n        Units of the result depend on the normalization.\\n\\n    References\\n    ----------\\n    .. [1] W. Press et al, Numerical Recipes in C (2002)\\n    .. [2] Scargle, J.D. 1982, ApJ 263:835-853\\n    .. [3] M. Zechmeister and M. Kurster, A&A 496, 577-584 (2009)\\n    \"\n    if dy is None:\n        dy = 1\n    (t, y, dy) = np.broadcast_arrays(t, y, dy)\n    frequency = np.asarray(frequency)\n    if t.ndim != 1:\n        raise ValueError('t, y, dy should be one dimensional')\n    if frequency.ndim != 1:\n        raise ValueError('frequency should be one-dimensional')\n    w = dy ** (-2.0)\n    w /= w.sum()\n    if fit_mean or center_data:\n        y = y - np.dot(w, y)\n    omega = 2 * np.pi * frequency\n    omega = omega.ravel()[np.newaxis, :]\n    (t, y, dy, w) = (x[:, np.newaxis] for x in (t, y, dy, w))\n    sin_omega_t = np.sin(omega * t)\n    cos_omega_t = np.cos(omega * t)\n    S2 = 2 * np.dot(w.T, sin_omega_t * cos_omega_t)\n    C2 = 2 * np.dot(w.T, 0.5 - sin_omega_t ** 2)\n    if fit_mean:\n        S = np.dot(w.T, sin_omega_t)\n        C = np.dot(w.T, cos_omega_t)\n        S2 -= 2 * S * C\n        C2 -= C * C - S * S\n    omega_t_tau = omega * t - 0.5 * np.arctan2(S2, C2)\n    sin_omega_t_tau = np.sin(omega_t_tau)\n    cos_omega_t_tau = np.cos(omega_t_tau)\n    Y = np.dot(w.T, y)\n    wy = w * y\n    YCtau = np.dot(wy.T, cos_omega_t_tau)\n    YStau = np.dot(wy.T, sin_omega_t_tau)\n    CCtau = np.dot(w.T, cos_omega_t_tau * cos_omega_t_tau)\n    SStau = np.dot(w.T, sin_omega_t_tau * sin_omega_t_tau)\n    if fit_mean:\n        Ctau = np.dot(w.T, cos_omega_t_tau)\n        Stau = np.dot(w.T, sin_omega_t_tau)\n        YCtau -= Y * Ctau\n        YStau -= Y * Stau\n        CCtau -= Ctau * Ctau\n        SStau -= Stau * Stau\n    p = YCtau * YCtau / CCtau + YStau * YStau / SStau\n    YY = np.dot(w.T, y * y)\n    if normalization == 'standard':\n        p /= YY\n    elif normalization == 'model':\n        p /= YY - p\n    elif normalization == 'log':\n        p = -np.log(1 - p / YY)\n    elif normalization == 'psd':\n        p *= 0.5 * (dy ** (-2.0)).sum()\n    else:\n        raise ValueError(f\"normalization='{normalization}' not recognized\")\n    return p.ravel()",
            "def lombscargle_slow(t, y, dy, frequency, normalization='standard', fit_mean=True, center_data=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Lomb-Scargle Periodogram.\\n\\n    This is a pure-python implementation of the original Lomb-Scargle formalism\\n    (e.g. [1]_, [2]_), with the addition of the floating mean (e.g. [3]_)\\n\\n    Parameters\\n    ----------\\n    t, y, dy : array-like\\n        times, values, and errors of the data points. These should be\\n        broadcastable to the same shape. None should be `~astropy.units.Quantity`.\\n    frequency : array-like\\n        frequencies (not angular frequencies) at which to calculate periodogram\\n    normalization : str, optional\\n        Normalization to use for the periodogram.\\n        Options are 'standard', 'model', 'log', or 'psd'.\\n    fit_mean : bool, optional\\n        if True, include a constant offset as part of the model at each\\n        frequency. This can lead to more accurate results, especially in the\\n        case of incomplete phase coverage.\\n    center_data : bool, optional\\n        if True, pre-center the data by subtracting the weighted mean\\n        of the input data. This is especially important if ``fit_mean = False``\\n\\n    Returns\\n    -------\\n    power : array-like\\n        Lomb-Scargle power associated with each frequency.\\n        Units of the result depend on the normalization.\\n\\n    References\\n    ----------\\n    .. [1] W. Press et al, Numerical Recipes in C (2002)\\n    .. [2] Scargle, J.D. 1982, ApJ 263:835-853\\n    .. [3] M. Zechmeister and M. Kurster, A&A 496, 577-584 (2009)\\n    \"\n    if dy is None:\n        dy = 1\n    (t, y, dy) = np.broadcast_arrays(t, y, dy)\n    frequency = np.asarray(frequency)\n    if t.ndim != 1:\n        raise ValueError('t, y, dy should be one dimensional')\n    if frequency.ndim != 1:\n        raise ValueError('frequency should be one-dimensional')\n    w = dy ** (-2.0)\n    w /= w.sum()\n    if fit_mean or center_data:\n        y = y - np.dot(w, y)\n    omega = 2 * np.pi * frequency\n    omega = omega.ravel()[np.newaxis, :]\n    (t, y, dy, w) = (x[:, np.newaxis] for x in (t, y, dy, w))\n    sin_omega_t = np.sin(omega * t)\n    cos_omega_t = np.cos(omega * t)\n    S2 = 2 * np.dot(w.T, sin_omega_t * cos_omega_t)\n    C2 = 2 * np.dot(w.T, 0.5 - sin_omega_t ** 2)\n    if fit_mean:\n        S = np.dot(w.T, sin_omega_t)\n        C = np.dot(w.T, cos_omega_t)\n        S2 -= 2 * S * C\n        C2 -= C * C - S * S\n    omega_t_tau = omega * t - 0.5 * np.arctan2(S2, C2)\n    sin_omega_t_tau = np.sin(omega_t_tau)\n    cos_omega_t_tau = np.cos(omega_t_tau)\n    Y = np.dot(w.T, y)\n    wy = w * y\n    YCtau = np.dot(wy.T, cos_omega_t_tau)\n    YStau = np.dot(wy.T, sin_omega_t_tau)\n    CCtau = np.dot(w.T, cos_omega_t_tau * cos_omega_t_tau)\n    SStau = np.dot(w.T, sin_omega_t_tau * sin_omega_t_tau)\n    if fit_mean:\n        Ctau = np.dot(w.T, cos_omega_t_tau)\n        Stau = np.dot(w.T, sin_omega_t_tau)\n        YCtau -= Y * Ctau\n        YStau -= Y * Stau\n        CCtau -= Ctau * Ctau\n        SStau -= Stau * Stau\n    p = YCtau * YCtau / CCtau + YStau * YStau / SStau\n    YY = np.dot(w.T, y * y)\n    if normalization == 'standard':\n        p /= YY\n    elif normalization == 'model':\n        p /= YY - p\n    elif normalization == 'log':\n        p = -np.log(1 - p / YY)\n    elif normalization == 'psd':\n        p *= 0.5 * (dy ** (-2.0)).sum()\n    else:\n        raise ValueError(f\"normalization='{normalization}' not recognized\")\n    return p.ravel()",
            "def lombscargle_slow(t, y, dy, frequency, normalization='standard', fit_mean=True, center_data=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Lomb-Scargle Periodogram.\\n\\n    This is a pure-python implementation of the original Lomb-Scargle formalism\\n    (e.g. [1]_, [2]_), with the addition of the floating mean (e.g. [3]_)\\n\\n    Parameters\\n    ----------\\n    t, y, dy : array-like\\n        times, values, and errors of the data points. These should be\\n        broadcastable to the same shape. None should be `~astropy.units.Quantity`.\\n    frequency : array-like\\n        frequencies (not angular frequencies) at which to calculate periodogram\\n    normalization : str, optional\\n        Normalization to use for the periodogram.\\n        Options are 'standard', 'model', 'log', or 'psd'.\\n    fit_mean : bool, optional\\n        if True, include a constant offset as part of the model at each\\n        frequency. This can lead to more accurate results, especially in the\\n        case of incomplete phase coverage.\\n    center_data : bool, optional\\n        if True, pre-center the data by subtracting the weighted mean\\n        of the input data. This is especially important if ``fit_mean = False``\\n\\n    Returns\\n    -------\\n    power : array-like\\n        Lomb-Scargle power associated with each frequency.\\n        Units of the result depend on the normalization.\\n\\n    References\\n    ----------\\n    .. [1] W. Press et al, Numerical Recipes in C (2002)\\n    .. [2] Scargle, J.D. 1982, ApJ 263:835-853\\n    .. [3] M. Zechmeister and M. Kurster, A&A 496, 577-584 (2009)\\n    \"\n    if dy is None:\n        dy = 1\n    (t, y, dy) = np.broadcast_arrays(t, y, dy)\n    frequency = np.asarray(frequency)\n    if t.ndim != 1:\n        raise ValueError('t, y, dy should be one dimensional')\n    if frequency.ndim != 1:\n        raise ValueError('frequency should be one-dimensional')\n    w = dy ** (-2.0)\n    w /= w.sum()\n    if fit_mean or center_data:\n        y = y - np.dot(w, y)\n    omega = 2 * np.pi * frequency\n    omega = omega.ravel()[np.newaxis, :]\n    (t, y, dy, w) = (x[:, np.newaxis] for x in (t, y, dy, w))\n    sin_omega_t = np.sin(omega * t)\n    cos_omega_t = np.cos(omega * t)\n    S2 = 2 * np.dot(w.T, sin_omega_t * cos_omega_t)\n    C2 = 2 * np.dot(w.T, 0.5 - sin_omega_t ** 2)\n    if fit_mean:\n        S = np.dot(w.T, sin_omega_t)\n        C = np.dot(w.T, cos_omega_t)\n        S2 -= 2 * S * C\n        C2 -= C * C - S * S\n    omega_t_tau = omega * t - 0.5 * np.arctan2(S2, C2)\n    sin_omega_t_tau = np.sin(omega_t_tau)\n    cos_omega_t_tau = np.cos(omega_t_tau)\n    Y = np.dot(w.T, y)\n    wy = w * y\n    YCtau = np.dot(wy.T, cos_omega_t_tau)\n    YStau = np.dot(wy.T, sin_omega_t_tau)\n    CCtau = np.dot(w.T, cos_omega_t_tau * cos_omega_t_tau)\n    SStau = np.dot(w.T, sin_omega_t_tau * sin_omega_t_tau)\n    if fit_mean:\n        Ctau = np.dot(w.T, cos_omega_t_tau)\n        Stau = np.dot(w.T, sin_omega_t_tau)\n        YCtau -= Y * Ctau\n        YStau -= Y * Stau\n        CCtau -= Ctau * Ctau\n        SStau -= Stau * Stau\n    p = YCtau * YCtau / CCtau + YStau * YStau / SStau\n    YY = np.dot(w.T, y * y)\n    if normalization == 'standard':\n        p /= YY\n    elif normalization == 'model':\n        p /= YY - p\n    elif normalization == 'log':\n        p = -np.log(1 - p / YY)\n    elif normalization == 'psd':\n        p *= 0.5 * (dy ** (-2.0)).sum()\n    else:\n        raise ValueError(f\"normalization='{normalization}' not recognized\")\n    return p.ravel()"
        ]
    }
]