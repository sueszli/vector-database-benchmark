[
    {
        "func_name": "design_matrix",
        "original": "def design_matrix(t, frequency, dy=None, bias=True, nterms=1):\n    \"\"\"Compute the Lomb-Scargle design matrix at the given frequency.\n\n    This is the matrix X such that the periodic model at the given frequency\n    can be expressed :math:`\\\\hat{y} = X \\\\theta`.\n\n    Parameters\n    ----------\n    t : array-like, shape=(n_times,)\n        times at which to compute the design matrix\n    frequency : float\n        frequency for the design matrix\n    dy : float or array-like, optional\n        data uncertainties: should be broadcastable with `t`\n    bias : bool (default=True)\n        If true, include a bias column in the matrix\n    nterms : int (default=1)\n        Number of Fourier terms to include in the model\n\n    Returns\n    -------\n    X : ndarray, shape=(n_times, n_parameters)\n        The design matrix, where n_parameters = bool(bias) + 2 * nterms\n    \"\"\"\n    t = np.asarray(t)\n    frequency = np.asarray(frequency)\n    if t.ndim != 1:\n        raise ValueError('t should be one dimensional')\n    if frequency.ndim != 0:\n        raise ValueError('frequency must be a scalar')\n    if nterms == 0 and (not bias):\n        raise ValueError('cannot have nterms=0 and no bias')\n    if bias:\n        cols = [np.ones_like(t)]\n    else:\n        cols = []\n    for i in range(1, nterms + 1):\n        cols.append(np.sin(2 * np.pi * i * frequency * t))\n        cols.append(np.cos(2 * np.pi * i * frequency * t))\n    XT = np.vstack(cols)\n    if dy is not None:\n        XT /= dy\n    return np.transpose(XT)",
        "mutated": [
            "def design_matrix(t, frequency, dy=None, bias=True, nterms=1):\n    if False:\n        i = 10\n    'Compute the Lomb-Scargle design matrix at the given frequency.\\n\\n    This is the matrix X such that the periodic model at the given frequency\\n    can be expressed :math:`\\\\hat{y} = X \\\\theta`.\\n\\n    Parameters\\n    ----------\\n    t : array-like, shape=(n_times,)\\n        times at which to compute the design matrix\\n    frequency : float\\n        frequency for the design matrix\\n    dy : float or array-like, optional\\n        data uncertainties: should be broadcastable with `t`\\n    bias : bool (default=True)\\n        If true, include a bias column in the matrix\\n    nterms : int (default=1)\\n        Number of Fourier terms to include in the model\\n\\n    Returns\\n    -------\\n    X : ndarray, shape=(n_times, n_parameters)\\n        The design matrix, where n_parameters = bool(bias) + 2 * nterms\\n    '\n    t = np.asarray(t)\n    frequency = np.asarray(frequency)\n    if t.ndim != 1:\n        raise ValueError('t should be one dimensional')\n    if frequency.ndim != 0:\n        raise ValueError('frequency must be a scalar')\n    if nterms == 0 and (not bias):\n        raise ValueError('cannot have nterms=0 and no bias')\n    if bias:\n        cols = [np.ones_like(t)]\n    else:\n        cols = []\n    for i in range(1, nterms + 1):\n        cols.append(np.sin(2 * np.pi * i * frequency * t))\n        cols.append(np.cos(2 * np.pi * i * frequency * t))\n    XT = np.vstack(cols)\n    if dy is not None:\n        XT /= dy\n    return np.transpose(XT)",
            "def design_matrix(t, frequency, dy=None, bias=True, nterms=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute the Lomb-Scargle design matrix at the given frequency.\\n\\n    This is the matrix X such that the periodic model at the given frequency\\n    can be expressed :math:`\\\\hat{y} = X \\\\theta`.\\n\\n    Parameters\\n    ----------\\n    t : array-like, shape=(n_times,)\\n        times at which to compute the design matrix\\n    frequency : float\\n        frequency for the design matrix\\n    dy : float or array-like, optional\\n        data uncertainties: should be broadcastable with `t`\\n    bias : bool (default=True)\\n        If true, include a bias column in the matrix\\n    nterms : int (default=1)\\n        Number of Fourier terms to include in the model\\n\\n    Returns\\n    -------\\n    X : ndarray, shape=(n_times, n_parameters)\\n        The design matrix, where n_parameters = bool(bias) + 2 * nterms\\n    '\n    t = np.asarray(t)\n    frequency = np.asarray(frequency)\n    if t.ndim != 1:\n        raise ValueError('t should be one dimensional')\n    if frequency.ndim != 0:\n        raise ValueError('frequency must be a scalar')\n    if nterms == 0 and (not bias):\n        raise ValueError('cannot have nterms=0 and no bias')\n    if bias:\n        cols = [np.ones_like(t)]\n    else:\n        cols = []\n    for i in range(1, nterms + 1):\n        cols.append(np.sin(2 * np.pi * i * frequency * t))\n        cols.append(np.cos(2 * np.pi * i * frequency * t))\n    XT = np.vstack(cols)\n    if dy is not None:\n        XT /= dy\n    return np.transpose(XT)",
            "def design_matrix(t, frequency, dy=None, bias=True, nterms=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute the Lomb-Scargle design matrix at the given frequency.\\n\\n    This is the matrix X such that the periodic model at the given frequency\\n    can be expressed :math:`\\\\hat{y} = X \\\\theta`.\\n\\n    Parameters\\n    ----------\\n    t : array-like, shape=(n_times,)\\n        times at which to compute the design matrix\\n    frequency : float\\n        frequency for the design matrix\\n    dy : float or array-like, optional\\n        data uncertainties: should be broadcastable with `t`\\n    bias : bool (default=True)\\n        If true, include a bias column in the matrix\\n    nterms : int (default=1)\\n        Number of Fourier terms to include in the model\\n\\n    Returns\\n    -------\\n    X : ndarray, shape=(n_times, n_parameters)\\n        The design matrix, where n_parameters = bool(bias) + 2 * nterms\\n    '\n    t = np.asarray(t)\n    frequency = np.asarray(frequency)\n    if t.ndim != 1:\n        raise ValueError('t should be one dimensional')\n    if frequency.ndim != 0:\n        raise ValueError('frequency must be a scalar')\n    if nterms == 0 and (not bias):\n        raise ValueError('cannot have nterms=0 and no bias')\n    if bias:\n        cols = [np.ones_like(t)]\n    else:\n        cols = []\n    for i in range(1, nterms + 1):\n        cols.append(np.sin(2 * np.pi * i * frequency * t))\n        cols.append(np.cos(2 * np.pi * i * frequency * t))\n    XT = np.vstack(cols)\n    if dy is not None:\n        XT /= dy\n    return np.transpose(XT)",
            "def design_matrix(t, frequency, dy=None, bias=True, nterms=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute the Lomb-Scargle design matrix at the given frequency.\\n\\n    This is the matrix X such that the periodic model at the given frequency\\n    can be expressed :math:`\\\\hat{y} = X \\\\theta`.\\n\\n    Parameters\\n    ----------\\n    t : array-like, shape=(n_times,)\\n        times at which to compute the design matrix\\n    frequency : float\\n        frequency for the design matrix\\n    dy : float or array-like, optional\\n        data uncertainties: should be broadcastable with `t`\\n    bias : bool (default=True)\\n        If true, include a bias column in the matrix\\n    nterms : int (default=1)\\n        Number of Fourier terms to include in the model\\n\\n    Returns\\n    -------\\n    X : ndarray, shape=(n_times, n_parameters)\\n        The design matrix, where n_parameters = bool(bias) + 2 * nterms\\n    '\n    t = np.asarray(t)\n    frequency = np.asarray(frequency)\n    if t.ndim != 1:\n        raise ValueError('t should be one dimensional')\n    if frequency.ndim != 0:\n        raise ValueError('frequency must be a scalar')\n    if nterms == 0 and (not bias):\n        raise ValueError('cannot have nterms=0 and no bias')\n    if bias:\n        cols = [np.ones_like(t)]\n    else:\n        cols = []\n    for i in range(1, nterms + 1):\n        cols.append(np.sin(2 * np.pi * i * frequency * t))\n        cols.append(np.cos(2 * np.pi * i * frequency * t))\n    XT = np.vstack(cols)\n    if dy is not None:\n        XT /= dy\n    return np.transpose(XT)",
            "def design_matrix(t, frequency, dy=None, bias=True, nterms=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute the Lomb-Scargle design matrix at the given frequency.\\n\\n    This is the matrix X such that the periodic model at the given frequency\\n    can be expressed :math:`\\\\hat{y} = X \\\\theta`.\\n\\n    Parameters\\n    ----------\\n    t : array-like, shape=(n_times,)\\n        times at which to compute the design matrix\\n    frequency : float\\n        frequency for the design matrix\\n    dy : float or array-like, optional\\n        data uncertainties: should be broadcastable with `t`\\n    bias : bool (default=True)\\n        If true, include a bias column in the matrix\\n    nterms : int (default=1)\\n        Number of Fourier terms to include in the model\\n\\n    Returns\\n    -------\\n    X : ndarray, shape=(n_times, n_parameters)\\n        The design matrix, where n_parameters = bool(bias) + 2 * nterms\\n    '\n    t = np.asarray(t)\n    frequency = np.asarray(frequency)\n    if t.ndim != 1:\n        raise ValueError('t should be one dimensional')\n    if frequency.ndim != 0:\n        raise ValueError('frequency must be a scalar')\n    if nterms == 0 and (not bias):\n        raise ValueError('cannot have nterms=0 and no bias')\n    if bias:\n        cols = [np.ones_like(t)]\n    else:\n        cols = []\n    for i in range(1, nterms + 1):\n        cols.append(np.sin(2 * np.pi * i * frequency * t))\n        cols.append(np.cos(2 * np.pi * i * frequency * t))\n    XT = np.vstack(cols)\n    if dy is not None:\n        XT /= dy\n    return np.transpose(XT)"
        ]
    },
    {
        "func_name": "periodic_fit",
        "original": "def periodic_fit(t, y, dy, frequency, t_fit, center_data=True, fit_mean=True, nterms=1):\n    \"\"\"Compute the Lomb-Scargle model fit at a given frequency.\n\n    Parameters\n    ----------\n    t, y, dy : float or array-like\n        The times, observations, and uncertainties to fit\n    frequency : float\n        The frequency at which to compute the model\n    t_fit : float or array-like\n        The times at which the fit should be computed\n    center_data : bool (default=True)\n        If True, center the input data before applying the fit\n    fit_mean : bool (default=True)\n        If True, include the bias as part of the model\n    nterms : int (default=1)\n        The number of Fourier terms to include in the fit\n\n    Returns\n    -------\n    y_fit : ndarray\n        The model fit evaluated at each value of t_fit\n    \"\"\"\n    (t, y, frequency) = map(np.asarray, (t, y, frequency))\n    if dy is None:\n        dy = np.ones_like(y)\n    else:\n        dy = np.asarray(dy)\n    t_fit = np.asarray(t_fit)\n    if t.ndim != 1:\n        raise ValueError('t, y, dy should be one dimensional')\n    if t_fit.ndim != 1:\n        raise ValueError('t_fit should be one dimensional')\n    if frequency.ndim != 0:\n        raise ValueError('frequency should be a scalar')\n    if center_data:\n        w = dy ** (-2.0)\n        y_mean = np.dot(y, w) / w.sum()\n        y = y - y_mean\n    else:\n        y_mean = 0\n    X = design_matrix(t, frequency, dy=dy, bias=fit_mean, nterms=nterms)\n    theta_MLE = np.linalg.solve(np.dot(X.T, X), np.dot(X.T, y / dy))\n    X_fit = design_matrix(t_fit, frequency, bias=fit_mean, nterms=nterms)\n    return y_mean + np.dot(X_fit, theta_MLE)",
        "mutated": [
            "def periodic_fit(t, y, dy, frequency, t_fit, center_data=True, fit_mean=True, nterms=1):\n    if False:\n        i = 10\n    'Compute the Lomb-Scargle model fit at a given frequency.\\n\\n    Parameters\\n    ----------\\n    t, y, dy : float or array-like\\n        The times, observations, and uncertainties to fit\\n    frequency : float\\n        The frequency at which to compute the model\\n    t_fit : float or array-like\\n        The times at which the fit should be computed\\n    center_data : bool (default=True)\\n        If True, center the input data before applying the fit\\n    fit_mean : bool (default=True)\\n        If True, include the bias as part of the model\\n    nterms : int (default=1)\\n        The number of Fourier terms to include in the fit\\n\\n    Returns\\n    -------\\n    y_fit : ndarray\\n        The model fit evaluated at each value of t_fit\\n    '\n    (t, y, frequency) = map(np.asarray, (t, y, frequency))\n    if dy is None:\n        dy = np.ones_like(y)\n    else:\n        dy = np.asarray(dy)\n    t_fit = np.asarray(t_fit)\n    if t.ndim != 1:\n        raise ValueError('t, y, dy should be one dimensional')\n    if t_fit.ndim != 1:\n        raise ValueError('t_fit should be one dimensional')\n    if frequency.ndim != 0:\n        raise ValueError('frequency should be a scalar')\n    if center_data:\n        w = dy ** (-2.0)\n        y_mean = np.dot(y, w) / w.sum()\n        y = y - y_mean\n    else:\n        y_mean = 0\n    X = design_matrix(t, frequency, dy=dy, bias=fit_mean, nterms=nterms)\n    theta_MLE = np.linalg.solve(np.dot(X.T, X), np.dot(X.T, y / dy))\n    X_fit = design_matrix(t_fit, frequency, bias=fit_mean, nterms=nterms)\n    return y_mean + np.dot(X_fit, theta_MLE)",
            "def periodic_fit(t, y, dy, frequency, t_fit, center_data=True, fit_mean=True, nterms=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute the Lomb-Scargle model fit at a given frequency.\\n\\n    Parameters\\n    ----------\\n    t, y, dy : float or array-like\\n        The times, observations, and uncertainties to fit\\n    frequency : float\\n        The frequency at which to compute the model\\n    t_fit : float or array-like\\n        The times at which the fit should be computed\\n    center_data : bool (default=True)\\n        If True, center the input data before applying the fit\\n    fit_mean : bool (default=True)\\n        If True, include the bias as part of the model\\n    nterms : int (default=1)\\n        The number of Fourier terms to include in the fit\\n\\n    Returns\\n    -------\\n    y_fit : ndarray\\n        The model fit evaluated at each value of t_fit\\n    '\n    (t, y, frequency) = map(np.asarray, (t, y, frequency))\n    if dy is None:\n        dy = np.ones_like(y)\n    else:\n        dy = np.asarray(dy)\n    t_fit = np.asarray(t_fit)\n    if t.ndim != 1:\n        raise ValueError('t, y, dy should be one dimensional')\n    if t_fit.ndim != 1:\n        raise ValueError('t_fit should be one dimensional')\n    if frequency.ndim != 0:\n        raise ValueError('frequency should be a scalar')\n    if center_data:\n        w = dy ** (-2.0)\n        y_mean = np.dot(y, w) / w.sum()\n        y = y - y_mean\n    else:\n        y_mean = 0\n    X = design_matrix(t, frequency, dy=dy, bias=fit_mean, nterms=nterms)\n    theta_MLE = np.linalg.solve(np.dot(X.T, X), np.dot(X.T, y / dy))\n    X_fit = design_matrix(t_fit, frequency, bias=fit_mean, nterms=nterms)\n    return y_mean + np.dot(X_fit, theta_MLE)",
            "def periodic_fit(t, y, dy, frequency, t_fit, center_data=True, fit_mean=True, nterms=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute the Lomb-Scargle model fit at a given frequency.\\n\\n    Parameters\\n    ----------\\n    t, y, dy : float or array-like\\n        The times, observations, and uncertainties to fit\\n    frequency : float\\n        The frequency at which to compute the model\\n    t_fit : float or array-like\\n        The times at which the fit should be computed\\n    center_data : bool (default=True)\\n        If True, center the input data before applying the fit\\n    fit_mean : bool (default=True)\\n        If True, include the bias as part of the model\\n    nterms : int (default=1)\\n        The number of Fourier terms to include in the fit\\n\\n    Returns\\n    -------\\n    y_fit : ndarray\\n        The model fit evaluated at each value of t_fit\\n    '\n    (t, y, frequency) = map(np.asarray, (t, y, frequency))\n    if dy is None:\n        dy = np.ones_like(y)\n    else:\n        dy = np.asarray(dy)\n    t_fit = np.asarray(t_fit)\n    if t.ndim != 1:\n        raise ValueError('t, y, dy should be one dimensional')\n    if t_fit.ndim != 1:\n        raise ValueError('t_fit should be one dimensional')\n    if frequency.ndim != 0:\n        raise ValueError('frequency should be a scalar')\n    if center_data:\n        w = dy ** (-2.0)\n        y_mean = np.dot(y, w) / w.sum()\n        y = y - y_mean\n    else:\n        y_mean = 0\n    X = design_matrix(t, frequency, dy=dy, bias=fit_mean, nterms=nterms)\n    theta_MLE = np.linalg.solve(np.dot(X.T, X), np.dot(X.T, y / dy))\n    X_fit = design_matrix(t_fit, frequency, bias=fit_mean, nterms=nterms)\n    return y_mean + np.dot(X_fit, theta_MLE)",
            "def periodic_fit(t, y, dy, frequency, t_fit, center_data=True, fit_mean=True, nterms=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute the Lomb-Scargle model fit at a given frequency.\\n\\n    Parameters\\n    ----------\\n    t, y, dy : float or array-like\\n        The times, observations, and uncertainties to fit\\n    frequency : float\\n        The frequency at which to compute the model\\n    t_fit : float or array-like\\n        The times at which the fit should be computed\\n    center_data : bool (default=True)\\n        If True, center the input data before applying the fit\\n    fit_mean : bool (default=True)\\n        If True, include the bias as part of the model\\n    nterms : int (default=1)\\n        The number of Fourier terms to include in the fit\\n\\n    Returns\\n    -------\\n    y_fit : ndarray\\n        The model fit evaluated at each value of t_fit\\n    '\n    (t, y, frequency) = map(np.asarray, (t, y, frequency))\n    if dy is None:\n        dy = np.ones_like(y)\n    else:\n        dy = np.asarray(dy)\n    t_fit = np.asarray(t_fit)\n    if t.ndim != 1:\n        raise ValueError('t, y, dy should be one dimensional')\n    if t_fit.ndim != 1:\n        raise ValueError('t_fit should be one dimensional')\n    if frequency.ndim != 0:\n        raise ValueError('frequency should be a scalar')\n    if center_data:\n        w = dy ** (-2.0)\n        y_mean = np.dot(y, w) / w.sum()\n        y = y - y_mean\n    else:\n        y_mean = 0\n    X = design_matrix(t, frequency, dy=dy, bias=fit_mean, nterms=nterms)\n    theta_MLE = np.linalg.solve(np.dot(X.T, X), np.dot(X.T, y / dy))\n    X_fit = design_matrix(t_fit, frequency, bias=fit_mean, nterms=nterms)\n    return y_mean + np.dot(X_fit, theta_MLE)",
            "def periodic_fit(t, y, dy, frequency, t_fit, center_data=True, fit_mean=True, nterms=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute the Lomb-Scargle model fit at a given frequency.\\n\\n    Parameters\\n    ----------\\n    t, y, dy : float or array-like\\n        The times, observations, and uncertainties to fit\\n    frequency : float\\n        The frequency at which to compute the model\\n    t_fit : float or array-like\\n        The times at which the fit should be computed\\n    center_data : bool (default=True)\\n        If True, center the input data before applying the fit\\n    fit_mean : bool (default=True)\\n        If True, include the bias as part of the model\\n    nterms : int (default=1)\\n        The number of Fourier terms to include in the fit\\n\\n    Returns\\n    -------\\n    y_fit : ndarray\\n        The model fit evaluated at each value of t_fit\\n    '\n    (t, y, frequency) = map(np.asarray, (t, y, frequency))\n    if dy is None:\n        dy = np.ones_like(y)\n    else:\n        dy = np.asarray(dy)\n    t_fit = np.asarray(t_fit)\n    if t.ndim != 1:\n        raise ValueError('t, y, dy should be one dimensional')\n    if t_fit.ndim != 1:\n        raise ValueError('t_fit should be one dimensional')\n    if frequency.ndim != 0:\n        raise ValueError('frequency should be a scalar')\n    if center_data:\n        w = dy ** (-2.0)\n        y_mean = np.dot(y, w) / w.sum()\n        y = y - y_mean\n    else:\n        y_mean = 0\n    X = design_matrix(t, frequency, dy=dy, bias=fit_mean, nterms=nterms)\n    theta_MLE = np.linalg.solve(np.dot(X.T, X), np.dot(X.T, y / dy))\n    X_fit = design_matrix(t_fit, frequency, bias=fit_mean, nterms=nterms)\n    return y_mean + np.dot(X_fit, theta_MLE)"
        ]
    }
]