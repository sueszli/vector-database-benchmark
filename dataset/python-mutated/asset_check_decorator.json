[
    {
        "func_name": "_build_asset_check_input",
        "original": "def _build_asset_check_input(name: str, asset_key: AssetKey, fn: Callable) -> Mapping[AssetKey, Tuple[str, In]]:\n    asset_params = get_function_params_without_context_or_config_or_resources(fn)\n    if len(asset_params) == 0:\n        input_name = stringify_asset_key_to_input_name(asset_key)\n        in_def = In(cast(type, Nothing))\n    elif len(asset_params) == 1:\n        input_name = asset_params[0].name\n        in_def = In(metadata={}, input_manager_key=None, dagster_type=NoValueSentinel)\n    else:\n        raise DagsterInvalidDefinitionError(f\"When defining check '{name}', multiple target assets provided as parameters: {[param.name for param in asset_params]}. Only one is allowed.\")\n    return {asset_key: (input_name, in_def)}",
        "mutated": [
            "def _build_asset_check_input(name: str, asset_key: AssetKey, fn: Callable) -> Mapping[AssetKey, Tuple[str, In]]:\n    if False:\n        i = 10\n    asset_params = get_function_params_without_context_or_config_or_resources(fn)\n    if len(asset_params) == 0:\n        input_name = stringify_asset_key_to_input_name(asset_key)\n        in_def = In(cast(type, Nothing))\n    elif len(asset_params) == 1:\n        input_name = asset_params[0].name\n        in_def = In(metadata={}, input_manager_key=None, dagster_type=NoValueSentinel)\n    else:\n        raise DagsterInvalidDefinitionError(f\"When defining check '{name}', multiple target assets provided as parameters: {[param.name for param in asset_params]}. Only one is allowed.\")\n    return {asset_key: (input_name, in_def)}",
            "def _build_asset_check_input(name: str, asset_key: AssetKey, fn: Callable) -> Mapping[AssetKey, Tuple[str, In]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    asset_params = get_function_params_without_context_or_config_or_resources(fn)\n    if len(asset_params) == 0:\n        input_name = stringify_asset_key_to_input_name(asset_key)\n        in_def = In(cast(type, Nothing))\n    elif len(asset_params) == 1:\n        input_name = asset_params[0].name\n        in_def = In(metadata={}, input_manager_key=None, dagster_type=NoValueSentinel)\n    else:\n        raise DagsterInvalidDefinitionError(f\"When defining check '{name}', multiple target assets provided as parameters: {[param.name for param in asset_params]}. Only one is allowed.\")\n    return {asset_key: (input_name, in_def)}",
            "def _build_asset_check_input(name: str, asset_key: AssetKey, fn: Callable) -> Mapping[AssetKey, Tuple[str, In]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    asset_params = get_function_params_without_context_or_config_or_resources(fn)\n    if len(asset_params) == 0:\n        input_name = stringify_asset_key_to_input_name(asset_key)\n        in_def = In(cast(type, Nothing))\n    elif len(asset_params) == 1:\n        input_name = asset_params[0].name\n        in_def = In(metadata={}, input_manager_key=None, dagster_type=NoValueSentinel)\n    else:\n        raise DagsterInvalidDefinitionError(f\"When defining check '{name}', multiple target assets provided as parameters: {[param.name for param in asset_params]}. Only one is allowed.\")\n    return {asset_key: (input_name, in_def)}",
            "def _build_asset_check_input(name: str, asset_key: AssetKey, fn: Callable) -> Mapping[AssetKey, Tuple[str, In]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    asset_params = get_function_params_without_context_or_config_or_resources(fn)\n    if len(asset_params) == 0:\n        input_name = stringify_asset_key_to_input_name(asset_key)\n        in_def = In(cast(type, Nothing))\n    elif len(asset_params) == 1:\n        input_name = asset_params[0].name\n        in_def = In(metadata={}, input_manager_key=None, dagster_type=NoValueSentinel)\n    else:\n        raise DagsterInvalidDefinitionError(f\"When defining check '{name}', multiple target assets provided as parameters: {[param.name for param in asset_params]}. Only one is allowed.\")\n    return {asset_key: (input_name, in_def)}",
            "def _build_asset_check_input(name: str, asset_key: AssetKey, fn: Callable) -> Mapping[AssetKey, Tuple[str, In]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    asset_params = get_function_params_without_context_or_config_or_resources(fn)\n    if len(asset_params) == 0:\n        input_name = stringify_asset_key_to_input_name(asset_key)\n        in_def = In(cast(type, Nothing))\n    elif len(asset_params) == 1:\n        input_name = asset_params[0].name\n        in_def = In(metadata={}, input_manager_key=None, dagster_type=NoValueSentinel)\n    else:\n        raise DagsterInvalidDefinitionError(f\"When defining check '{name}', multiple target assets provided as parameters: {[param.name for param in asset_params]}. Only one is allowed.\")\n    return {asset_key: (input_name, in_def)}"
        ]
    },
    {
        "func_name": "inner",
        "original": "def inner(fn: AssetCheckFunction) -> AssetChecksDefinition:\n    check.callable_param(fn, 'fn')\n    resolved_name = name or fn.__name__\n    asset_key = AssetKey.from_coercible_or_definition(asset)\n    out = Out(dagster_type=None)\n    input_tuples_by_asset_key = _build_asset_check_input(resolved_name, asset_key, fn)\n    if len(input_tuples_by_asset_key) == 0:\n        raise DagsterInvalidDefinitionError(f\"No target asset provided when defining check '{resolved_name}'\")\n    if len(input_tuples_by_asset_key) > 1:\n        raise DagsterInvalidDefinitionError(f\"When defining check '{resolved_name}', Multiple target assets provided: {[key.to_user_string() for key in input_tuples_by_asset_key.keys()]}. Only one is allowed.\")\n    resolved_asset_key = next(iter(input_tuples_by_asset_key.keys()))\n    spec = AssetCheckSpec(name=resolved_name, description=description, asset=resolved_asset_key)\n    op_def = _Op(name=spec.get_python_identifier(), ins=dict(input_tuples_by_asset_key.values()), out=out, required_resource_keys=required_resource_keys, tags={**({'kind': compute_kind} if compute_kind else {}), **(op_tags or {})}, config_schema=config_schema, retry_policy=retry_policy)(fn)\n    checks_def = AssetChecksDefinition(node_def=op_def, resource_defs={}, specs=[spec], input_output_props=AssetChecksDefinitionInputOutputProps(asset_keys_by_input_name={input_tuples_by_asset_key[resolved_asset_key][0]: resolved_asset_key}, asset_check_keys_by_output_name={op_def.output_defs[0].name: spec.key}))\n    return checks_def",
        "mutated": [
            "def inner(fn: AssetCheckFunction) -> AssetChecksDefinition:\n    if False:\n        i = 10\n    check.callable_param(fn, 'fn')\n    resolved_name = name or fn.__name__\n    asset_key = AssetKey.from_coercible_or_definition(asset)\n    out = Out(dagster_type=None)\n    input_tuples_by_asset_key = _build_asset_check_input(resolved_name, asset_key, fn)\n    if len(input_tuples_by_asset_key) == 0:\n        raise DagsterInvalidDefinitionError(f\"No target asset provided when defining check '{resolved_name}'\")\n    if len(input_tuples_by_asset_key) > 1:\n        raise DagsterInvalidDefinitionError(f\"When defining check '{resolved_name}', Multiple target assets provided: {[key.to_user_string() for key in input_tuples_by_asset_key.keys()]}. Only one is allowed.\")\n    resolved_asset_key = next(iter(input_tuples_by_asset_key.keys()))\n    spec = AssetCheckSpec(name=resolved_name, description=description, asset=resolved_asset_key)\n    op_def = _Op(name=spec.get_python_identifier(), ins=dict(input_tuples_by_asset_key.values()), out=out, required_resource_keys=required_resource_keys, tags={**({'kind': compute_kind} if compute_kind else {}), **(op_tags or {})}, config_schema=config_schema, retry_policy=retry_policy)(fn)\n    checks_def = AssetChecksDefinition(node_def=op_def, resource_defs={}, specs=[spec], input_output_props=AssetChecksDefinitionInputOutputProps(asset_keys_by_input_name={input_tuples_by_asset_key[resolved_asset_key][0]: resolved_asset_key}, asset_check_keys_by_output_name={op_def.output_defs[0].name: spec.key}))\n    return checks_def",
            "def inner(fn: AssetCheckFunction) -> AssetChecksDefinition:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    check.callable_param(fn, 'fn')\n    resolved_name = name or fn.__name__\n    asset_key = AssetKey.from_coercible_or_definition(asset)\n    out = Out(dagster_type=None)\n    input_tuples_by_asset_key = _build_asset_check_input(resolved_name, asset_key, fn)\n    if len(input_tuples_by_asset_key) == 0:\n        raise DagsterInvalidDefinitionError(f\"No target asset provided when defining check '{resolved_name}'\")\n    if len(input_tuples_by_asset_key) > 1:\n        raise DagsterInvalidDefinitionError(f\"When defining check '{resolved_name}', Multiple target assets provided: {[key.to_user_string() for key in input_tuples_by_asset_key.keys()]}. Only one is allowed.\")\n    resolved_asset_key = next(iter(input_tuples_by_asset_key.keys()))\n    spec = AssetCheckSpec(name=resolved_name, description=description, asset=resolved_asset_key)\n    op_def = _Op(name=spec.get_python_identifier(), ins=dict(input_tuples_by_asset_key.values()), out=out, required_resource_keys=required_resource_keys, tags={**({'kind': compute_kind} if compute_kind else {}), **(op_tags or {})}, config_schema=config_schema, retry_policy=retry_policy)(fn)\n    checks_def = AssetChecksDefinition(node_def=op_def, resource_defs={}, specs=[spec], input_output_props=AssetChecksDefinitionInputOutputProps(asset_keys_by_input_name={input_tuples_by_asset_key[resolved_asset_key][0]: resolved_asset_key}, asset_check_keys_by_output_name={op_def.output_defs[0].name: spec.key}))\n    return checks_def",
            "def inner(fn: AssetCheckFunction) -> AssetChecksDefinition:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    check.callable_param(fn, 'fn')\n    resolved_name = name or fn.__name__\n    asset_key = AssetKey.from_coercible_or_definition(asset)\n    out = Out(dagster_type=None)\n    input_tuples_by_asset_key = _build_asset_check_input(resolved_name, asset_key, fn)\n    if len(input_tuples_by_asset_key) == 0:\n        raise DagsterInvalidDefinitionError(f\"No target asset provided when defining check '{resolved_name}'\")\n    if len(input_tuples_by_asset_key) > 1:\n        raise DagsterInvalidDefinitionError(f\"When defining check '{resolved_name}', Multiple target assets provided: {[key.to_user_string() for key in input_tuples_by_asset_key.keys()]}. Only one is allowed.\")\n    resolved_asset_key = next(iter(input_tuples_by_asset_key.keys()))\n    spec = AssetCheckSpec(name=resolved_name, description=description, asset=resolved_asset_key)\n    op_def = _Op(name=spec.get_python_identifier(), ins=dict(input_tuples_by_asset_key.values()), out=out, required_resource_keys=required_resource_keys, tags={**({'kind': compute_kind} if compute_kind else {}), **(op_tags or {})}, config_schema=config_schema, retry_policy=retry_policy)(fn)\n    checks_def = AssetChecksDefinition(node_def=op_def, resource_defs={}, specs=[spec], input_output_props=AssetChecksDefinitionInputOutputProps(asset_keys_by_input_name={input_tuples_by_asset_key[resolved_asset_key][0]: resolved_asset_key}, asset_check_keys_by_output_name={op_def.output_defs[0].name: spec.key}))\n    return checks_def",
            "def inner(fn: AssetCheckFunction) -> AssetChecksDefinition:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    check.callable_param(fn, 'fn')\n    resolved_name = name or fn.__name__\n    asset_key = AssetKey.from_coercible_or_definition(asset)\n    out = Out(dagster_type=None)\n    input_tuples_by_asset_key = _build_asset_check_input(resolved_name, asset_key, fn)\n    if len(input_tuples_by_asset_key) == 0:\n        raise DagsterInvalidDefinitionError(f\"No target asset provided when defining check '{resolved_name}'\")\n    if len(input_tuples_by_asset_key) > 1:\n        raise DagsterInvalidDefinitionError(f\"When defining check '{resolved_name}', Multiple target assets provided: {[key.to_user_string() for key in input_tuples_by_asset_key.keys()]}. Only one is allowed.\")\n    resolved_asset_key = next(iter(input_tuples_by_asset_key.keys()))\n    spec = AssetCheckSpec(name=resolved_name, description=description, asset=resolved_asset_key)\n    op_def = _Op(name=spec.get_python_identifier(), ins=dict(input_tuples_by_asset_key.values()), out=out, required_resource_keys=required_resource_keys, tags={**({'kind': compute_kind} if compute_kind else {}), **(op_tags or {})}, config_schema=config_schema, retry_policy=retry_policy)(fn)\n    checks_def = AssetChecksDefinition(node_def=op_def, resource_defs={}, specs=[spec], input_output_props=AssetChecksDefinitionInputOutputProps(asset_keys_by_input_name={input_tuples_by_asset_key[resolved_asset_key][0]: resolved_asset_key}, asset_check_keys_by_output_name={op_def.output_defs[0].name: spec.key}))\n    return checks_def",
            "def inner(fn: AssetCheckFunction) -> AssetChecksDefinition:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    check.callable_param(fn, 'fn')\n    resolved_name = name or fn.__name__\n    asset_key = AssetKey.from_coercible_or_definition(asset)\n    out = Out(dagster_type=None)\n    input_tuples_by_asset_key = _build_asset_check_input(resolved_name, asset_key, fn)\n    if len(input_tuples_by_asset_key) == 0:\n        raise DagsterInvalidDefinitionError(f\"No target asset provided when defining check '{resolved_name}'\")\n    if len(input_tuples_by_asset_key) > 1:\n        raise DagsterInvalidDefinitionError(f\"When defining check '{resolved_name}', Multiple target assets provided: {[key.to_user_string() for key in input_tuples_by_asset_key.keys()]}. Only one is allowed.\")\n    resolved_asset_key = next(iter(input_tuples_by_asset_key.keys()))\n    spec = AssetCheckSpec(name=resolved_name, description=description, asset=resolved_asset_key)\n    op_def = _Op(name=spec.get_python_identifier(), ins=dict(input_tuples_by_asset_key.values()), out=out, required_resource_keys=required_resource_keys, tags={**({'kind': compute_kind} if compute_kind else {}), **(op_tags or {})}, config_schema=config_schema, retry_policy=retry_policy)(fn)\n    checks_def = AssetChecksDefinition(node_def=op_def, resource_defs={}, specs=[spec], input_output_props=AssetChecksDefinitionInputOutputProps(asset_keys_by_input_name={input_tuples_by_asset_key[resolved_asset_key][0]: resolved_asset_key}, asset_check_keys_by_output_name={op_def.output_defs[0].name: spec.key}))\n    return checks_def"
        ]
    },
    {
        "func_name": "asset_check",
        "original": "@experimental\ndef asset_check(*, asset: Union[CoercibleToAssetKey, AssetsDefinition, SourceAsset], name: Optional[str]=None, description: Optional[str]=None, required_resource_keys: Optional[Set[str]]=None, resource_defs: Optional[Mapping[str, object]]=None, config_schema: Optional[UserConfigSchema]=None, compute_kind: Optional[str]=None, op_tags: Optional[Mapping[str, Any]]=None, retry_policy: Optional[RetryPolicy]=None) -> Callable[[AssetCheckFunction], AssetChecksDefinition]:\n    \"\"\"Create a definition for how to execute an asset check.\n\n    Args:\n        asset (Union[AssetKey, Sequence[str], str, AssetsDefinition, SourceAsset]): The\n            asset that the check applies to.\n        name (Optional[str]): The name of the check. If not specified, the name of the decorated\n            function will be used. Checks for the same asset must have unique names.\n        description (Optional[str]): The description of the check.\n        required_resource_keys (Optional[Set[str]]): A set of keys for resources that are required\n            by the function that execute the check. These can alternatively be specified by\n            including resource-typed parameters in the function signature.\n        config_schema (Optional[ConfigSchema): The configuration schema for the check's underlying\n            op. If set, Dagster will check that config provided for the op matches this schema and fail\n            if it does not. If not set, Dagster will accept any config provided for the op.\n        op_tags (Optional[Dict[str, Any]]): A dictionary of tags for the op that executes the check.\n            Frameworks may expect and require certain metadata to be attached to a op. Values that\n            are not strings will be json encoded and must meet the criteria that\n            `json.loads(json.dumps(value)) == value`.\n        compute_kind (Optional[str]): A string to represent the kind of computation that executes\n            the check, e.g. \"dbt\" or \"spark\".\n        retry_policy (Optional[RetryPolicy]): The retry policy for the op that executes the check.\n\n\n    Produces an :py:class:`AssetChecksDefinition` object.\n\n\n    Example:\n        .. code-block:: python\n\n            from dagster import asset, asset_check, AssetCheckResult\n\n            @asset\n            def my_asset() -> None:\n                ...\n\n            @asset_check(asset=my_asset, description=\"Check that my asset has enough rows\")\n            def my_asset_has_enough_rows() -> AssetCheckResult:\n                num_rows = ...\n                return AssetCheckResult(passed=num_rows > 5, metadata={\"num_rows\": num_rows})\n\n\n    Example with a DataFrame Output:\n        .. code-block:: python\n\n            from dagster import asset, asset_check, AssetCheckResult\n            from pandas import DataFrame\n\n            @asset\n            def my_asset() -> DataFrame:\n                ...\n\n            @asset_check(asset=my_asset, description=\"Check that my asset has enough rows\")\n            def my_asset_has_enough_rows(my_asset: DataFrame) -> AssetCheckResult:\n                num_rows = my_asset.shape[0]\n                return AssetCheckResult(passed=num_rows > 5, metadata={\"num_rows\": num_rows})\n    \"\"\"\n\n    def inner(fn: AssetCheckFunction) -> AssetChecksDefinition:\n        check.callable_param(fn, 'fn')\n        resolved_name = name or fn.__name__\n        asset_key = AssetKey.from_coercible_or_definition(asset)\n        out = Out(dagster_type=None)\n        input_tuples_by_asset_key = _build_asset_check_input(resolved_name, asset_key, fn)\n        if len(input_tuples_by_asset_key) == 0:\n            raise DagsterInvalidDefinitionError(f\"No target asset provided when defining check '{resolved_name}'\")\n        if len(input_tuples_by_asset_key) > 1:\n            raise DagsterInvalidDefinitionError(f\"When defining check '{resolved_name}', Multiple target assets provided: {[key.to_user_string() for key in input_tuples_by_asset_key.keys()]}. Only one is allowed.\")\n        resolved_asset_key = next(iter(input_tuples_by_asset_key.keys()))\n        spec = AssetCheckSpec(name=resolved_name, description=description, asset=resolved_asset_key)\n        op_def = _Op(name=spec.get_python_identifier(), ins=dict(input_tuples_by_asset_key.values()), out=out, required_resource_keys=required_resource_keys, tags={**({'kind': compute_kind} if compute_kind else {}), **(op_tags or {})}, config_schema=config_schema, retry_policy=retry_policy)(fn)\n        checks_def = AssetChecksDefinition(node_def=op_def, resource_defs={}, specs=[spec], input_output_props=AssetChecksDefinitionInputOutputProps(asset_keys_by_input_name={input_tuples_by_asset_key[resolved_asset_key][0]: resolved_asset_key}, asset_check_keys_by_output_name={op_def.output_defs[0].name: spec.key}))\n        return checks_def\n    return inner",
        "mutated": [
            "@experimental\ndef asset_check(*, asset: Union[CoercibleToAssetKey, AssetsDefinition, SourceAsset], name: Optional[str]=None, description: Optional[str]=None, required_resource_keys: Optional[Set[str]]=None, resource_defs: Optional[Mapping[str, object]]=None, config_schema: Optional[UserConfigSchema]=None, compute_kind: Optional[str]=None, op_tags: Optional[Mapping[str, Any]]=None, retry_policy: Optional[RetryPolicy]=None) -> Callable[[AssetCheckFunction], AssetChecksDefinition]:\n    if False:\n        i = 10\n    'Create a definition for how to execute an asset check.\\n\\n    Args:\\n        asset (Union[AssetKey, Sequence[str], str, AssetsDefinition, SourceAsset]): The\\n            asset that the check applies to.\\n        name (Optional[str]): The name of the check. If not specified, the name of the decorated\\n            function will be used. Checks for the same asset must have unique names.\\n        description (Optional[str]): The description of the check.\\n        required_resource_keys (Optional[Set[str]]): A set of keys for resources that are required\\n            by the function that execute the check. These can alternatively be specified by\\n            including resource-typed parameters in the function signature.\\n        config_schema (Optional[ConfigSchema): The configuration schema for the check\\'s underlying\\n            op. If set, Dagster will check that config provided for the op matches this schema and fail\\n            if it does not. If not set, Dagster will accept any config provided for the op.\\n        op_tags (Optional[Dict[str, Any]]): A dictionary of tags for the op that executes the check.\\n            Frameworks may expect and require certain metadata to be attached to a op. Values that\\n            are not strings will be json encoded and must meet the criteria that\\n            `json.loads(json.dumps(value)) == value`.\\n        compute_kind (Optional[str]): A string to represent the kind of computation that executes\\n            the check, e.g. \"dbt\" or \"spark\".\\n        retry_policy (Optional[RetryPolicy]): The retry policy for the op that executes the check.\\n\\n\\n    Produces an :py:class:`AssetChecksDefinition` object.\\n\\n\\n    Example:\\n        .. code-block:: python\\n\\n            from dagster import asset, asset_check, AssetCheckResult\\n\\n            @asset\\n            def my_asset() -> None:\\n                ...\\n\\n            @asset_check(asset=my_asset, description=\"Check that my asset has enough rows\")\\n            def my_asset_has_enough_rows() -> AssetCheckResult:\\n                num_rows = ...\\n                return AssetCheckResult(passed=num_rows > 5, metadata={\"num_rows\": num_rows})\\n\\n\\n    Example with a DataFrame Output:\\n        .. code-block:: python\\n\\n            from dagster import asset, asset_check, AssetCheckResult\\n            from pandas import DataFrame\\n\\n            @asset\\n            def my_asset() -> DataFrame:\\n                ...\\n\\n            @asset_check(asset=my_asset, description=\"Check that my asset has enough rows\")\\n            def my_asset_has_enough_rows(my_asset: DataFrame) -> AssetCheckResult:\\n                num_rows = my_asset.shape[0]\\n                return AssetCheckResult(passed=num_rows > 5, metadata={\"num_rows\": num_rows})\\n    '\n\n    def inner(fn: AssetCheckFunction) -> AssetChecksDefinition:\n        check.callable_param(fn, 'fn')\n        resolved_name = name or fn.__name__\n        asset_key = AssetKey.from_coercible_or_definition(asset)\n        out = Out(dagster_type=None)\n        input_tuples_by_asset_key = _build_asset_check_input(resolved_name, asset_key, fn)\n        if len(input_tuples_by_asset_key) == 0:\n            raise DagsterInvalidDefinitionError(f\"No target asset provided when defining check '{resolved_name}'\")\n        if len(input_tuples_by_asset_key) > 1:\n            raise DagsterInvalidDefinitionError(f\"When defining check '{resolved_name}', Multiple target assets provided: {[key.to_user_string() for key in input_tuples_by_asset_key.keys()]}. Only one is allowed.\")\n        resolved_asset_key = next(iter(input_tuples_by_asset_key.keys()))\n        spec = AssetCheckSpec(name=resolved_name, description=description, asset=resolved_asset_key)\n        op_def = _Op(name=spec.get_python_identifier(), ins=dict(input_tuples_by_asset_key.values()), out=out, required_resource_keys=required_resource_keys, tags={**({'kind': compute_kind} if compute_kind else {}), **(op_tags or {})}, config_schema=config_schema, retry_policy=retry_policy)(fn)\n        checks_def = AssetChecksDefinition(node_def=op_def, resource_defs={}, specs=[spec], input_output_props=AssetChecksDefinitionInputOutputProps(asset_keys_by_input_name={input_tuples_by_asset_key[resolved_asset_key][0]: resolved_asset_key}, asset_check_keys_by_output_name={op_def.output_defs[0].name: spec.key}))\n        return checks_def\n    return inner",
            "@experimental\ndef asset_check(*, asset: Union[CoercibleToAssetKey, AssetsDefinition, SourceAsset], name: Optional[str]=None, description: Optional[str]=None, required_resource_keys: Optional[Set[str]]=None, resource_defs: Optional[Mapping[str, object]]=None, config_schema: Optional[UserConfigSchema]=None, compute_kind: Optional[str]=None, op_tags: Optional[Mapping[str, Any]]=None, retry_policy: Optional[RetryPolicy]=None) -> Callable[[AssetCheckFunction], AssetChecksDefinition]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Create a definition for how to execute an asset check.\\n\\n    Args:\\n        asset (Union[AssetKey, Sequence[str], str, AssetsDefinition, SourceAsset]): The\\n            asset that the check applies to.\\n        name (Optional[str]): The name of the check. If not specified, the name of the decorated\\n            function will be used. Checks for the same asset must have unique names.\\n        description (Optional[str]): The description of the check.\\n        required_resource_keys (Optional[Set[str]]): A set of keys for resources that are required\\n            by the function that execute the check. These can alternatively be specified by\\n            including resource-typed parameters in the function signature.\\n        config_schema (Optional[ConfigSchema): The configuration schema for the check\\'s underlying\\n            op. If set, Dagster will check that config provided for the op matches this schema and fail\\n            if it does not. If not set, Dagster will accept any config provided for the op.\\n        op_tags (Optional[Dict[str, Any]]): A dictionary of tags for the op that executes the check.\\n            Frameworks may expect and require certain metadata to be attached to a op. Values that\\n            are not strings will be json encoded and must meet the criteria that\\n            `json.loads(json.dumps(value)) == value`.\\n        compute_kind (Optional[str]): A string to represent the kind of computation that executes\\n            the check, e.g. \"dbt\" or \"spark\".\\n        retry_policy (Optional[RetryPolicy]): The retry policy for the op that executes the check.\\n\\n\\n    Produces an :py:class:`AssetChecksDefinition` object.\\n\\n\\n    Example:\\n        .. code-block:: python\\n\\n            from dagster import asset, asset_check, AssetCheckResult\\n\\n            @asset\\n            def my_asset() -> None:\\n                ...\\n\\n            @asset_check(asset=my_asset, description=\"Check that my asset has enough rows\")\\n            def my_asset_has_enough_rows() -> AssetCheckResult:\\n                num_rows = ...\\n                return AssetCheckResult(passed=num_rows > 5, metadata={\"num_rows\": num_rows})\\n\\n\\n    Example with a DataFrame Output:\\n        .. code-block:: python\\n\\n            from dagster import asset, asset_check, AssetCheckResult\\n            from pandas import DataFrame\\n\\n            @asset\\n            def my_asset() -> DataFrame:\\n                ...\\n\\n            @asset_check(asset=my_asset, description=\"Check that my asset has enough rows\")\\n            def my_asset_has_enough_rows(my_asset: DataFrame) -> AssetCheckResult:\\n                num_rows = my_asset.shape[0]\\n                return AssetCheckResult(passed=num_rows > 5, metadata={\"num_rows\": num_rows})\\n    '\n\n    def inner(fn: AssetCheckFunction) -> AssetChecksDefinition:\n        check.callable_param(fn, 'fn')\n        resolved_name = name or fn.__name__\n        asset_key = AssetKey.from_coercible_or_definition(asset)\n        out = Out(dagster_type=None)\n        input_tuples_by_asset_key = _build_asset_check_input(resolved_name, asset_key, fn)\n        if len(input_tuples_by_asset_key) == 0:\n            raise DagsterInvalidDefinitionError(f\"No target asset provided when defining check '{resolved_name}'\")\n        if len(input_tuples_by_asset_key) > 1:\n            raise DagsterInvalidDefinitionError(f\"When defining check '{resolved_name}', Multiple target assets provided: {[key.to_user_string() for key in input_tuples_by_asset_key.keys()]}. Only one is allowed.\")\n        resolved_asset_key = next(iter(input_tuples_by_asset_key.keys()))\n        spec = AssetCheckSpec(name=resolved_name, description=description, asset=resolved_asset_key)\n        op_def = _Op(name=spec.get_python_identifier(), ins=dict(input_tuples_by_asset_key.values()), out=out, required_resource_keys=required_resource_keys, tags={**({'kind': compute_kind} if compute_kind else {}), **(op_tags or {})}, config_schema=config_schema, retry_policy=retry_policy)(fn)\n        checks_def = AssetChecksDefinition(node_def=op_def, resource_defs={}, specs=[spec], input_output_props=AssetChecksDefinitionInputOutputProps(asset_keys_by_input_name={input_tuples_by_asset_key[resolved_asset_key][0]: resolved_asset_key}, asset_check_keys_by_output_name={op_def.output_defs[0].name: spec.key}))\n        return checks_def\n    return inner",
            "@experimental\ndef asset_check(*, asset: Union[CoercibleToAssetKey, AssetsDefinition, SourceAsset], name: Optional[str]=None, description: Optional[str]=None, required_resource_keys: Optional[Set[str]]=None, resource_defs: Optional[Mapping[str, object]]=None, config_schema: Optional[UserConfigSchema]=None, compute_kind: Optional[str]=None, op_tags: Optional[Mapping[str, Any]]=None, retry_policy: Optional[RetryPolicy]=None) -> Callable[[AssetCheckFunction], AssetChecksDefinition]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Create a definition for how to execute an asset check.\\n\\n    Args:\\n        asset (Union[AssetKey, Sequence[str], str, AssetsDefinition, SourceAsset]): The\\n            asset that the check applies to.\\n        name (Optional[str]): The name of the check. If not specified, the name of the decorated\\n            function will be used. Checks for the same asset must have unique names.\\n        description (Optional[str]): The description of the check.\\n        required_resource_keys (Optional[Set[str]]): A set of keys for resources that are required\\n            by the function that execute the check. These can alternatively be specified by\\n            including resource-typed parameters in the function signature.\\n        config_schema (Optional[ConfigSchema): The configuration schema for the check\\'s underlying\\n            op. If set, Dagster will check that config provided for the op matches this schema and fail\\n            if it does not. If not set, Dagster will accept any config provided for the op.\\n        op_tags (Optional[Dict[str, Any]]): A dictionary of tags for the op that executes the check.\\n            Frameworks may expect and require certain metadata to be attached to a op. Values that\\n            are not strings will be json encoded and must meet the criteria that\\n            `json.loads(json.dumps(value)) == value`.\\n        compute_kind (Optional[str]): A string to represent the kind of computation that executes\\n            the check, e.g. \"dbt\" or \"spark\".\\n        retry_policy (Optional[RetryPolicy]): The retry policy for the op that executes the check.\\n\\n\\n    Produces an :py:class:`AssetChecksDefinition` object.\\n\\n\\n    Example:\\n        .. code-block:: python\\n\\n            from dagster import asset, asset_check, AssetCheckResult\\n\\n            @asset\\n            def my_asset() -> None:\\n                ...\\n\\n            @asset_check(asset=my_asset, description=\"Check that my asset has enough rows\")\\n            def my_asset_has_enough_rows() -> AssetCheckResult:\\n                num_rows = ...\\n                return AssetCheckResult(passed=num_rows > 5, metadata={\"num_rows\": num_rows})\\n\\n\\n    Example with a DataFrame Output:\\n        .. code-block:: python\\n\\n            from dagster import asset, asset_check, AssetCheckResult\\n            from pandas import DataFrame\\n\\n            @asset\\n            def my_asset() -> DataFrame:\\n                ...\\n\\n            @asset_check(asset=my_asset, description=\"Check that my asset has enough rows\")\\n            def my_asset_has_enough_rows(my_asset: DataFrame) -> AssetCheckResult:\\n                num_rows = my_asset.shape[0]\\n                return AssetCheckResult(passed=num_rows > 5, metadata={\"num_rows\": num_rows})\\n    '\n\n    def inner(fn: AssetCheckFunction) -> AssetChecksDefinition:\n        check.callable_param(fn, 'fn')\n        resolved_name = name or fn.__name__\n        asset_key = AssetKey.from_coercible_or_definition(asset)\n        out = Out(dagster_type=None)\n        input_tuples_by_asset_key = _build_asset_check_input(resolved_name, asset_key, fn)\n        if len(input_tuples_by_asset_key) == 0:\n            raise DagsterInvalidDefinitionError(f\"No target asset provided when defining check '{resolved_name}'\")\n        if len(input_tuples_by_asset_key) > 1:\n            raise DagsterInvalidDefinitionError(f\"When defining check '{resolved_name}', Multiple target assets provided: {[key.to_user_string() for key in input_tuples_by_asset_key.keys()]}. Only one is allowed.\")\n        resolved_asset_key = next(iter(input_tuples_by_asset_key.keys()))\n        spec = AssetCheckSpec(name=resolved_name, description=description, asset=resolved_asset_key)\n        op_def = _Op(name=spec.get_python_identifier(), ins=dict(input_tuples_by_asset_key.values()), out=out, required_resource_keys=required_resource_keys, tags={**({'kind': compute_kind} if compute_kind else {}), **(op_tags or {})}, config_schema=config_schema, retry_policy=retry_policy)(fn)\n        checks_def = AssetChecksDefinition(node_def=op_def, resource_defs={}, specs=[spec], input_output_props=AssetChecksDefinitionInputOutputProps(asset_keys_by_input_name={input_tuples_by_asset_key[resolved_asset_key][0]: resolved_asset_key}, asset_check_keys_by_output_name={op_def.output_defs[0].name: spec.key}))\n        return checks_def\n    return inner",
            "@experimental\ndef asset_check(*, asset: Union[CoercibleToAssetKey, AssetsDefinition, SourceAsset], name: Optional[str]=None, description: Optional[str]=None, required_resource_keys: Optional[Set[str]]=None, resource_defs: Optional[Mapping[str, object]]=None, config_schema: Optional[UserConfigSchema]=None, compute_kind: Optional[str]=None, op_tags: Optional[Mapping[str, Any]]=None, retry_policy: Optional[RetryPolicy]=None) -> Callable[[AssetCheckFunction], AssetChecksDefinition]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Create a definition for how to execute an asset check.\\n\\n    Args:\\n        asset (Union[AssetKey, Sequence[str], str, AssetsDefinition, SourceAsset]): The\\n            asset that the check applies to.\\n        name (Optional[str]): The name of the check. If not specified, the name of the decorated\\n            function will be used. Checks for the same asset must have unique names.\\n        description (Optional[str]): The description of the check.\\n        required_resource_keys (Optional[Set[str]]): A set of keys for resources that are required\\n            by the function that execute the check. These can alternatively be specified by\\n            including resource-typed parameters in the function signature.\\n        config_schema (Optional[ConfigSchema): The configuration schema for the check\\'s underlying\\n            op. If set, Dagster will check that config provided for the op matches this schema and fail\\n            if it does not. If not set, Dagster will accept any config provided for the op.\\n        op_tags (Optional[Dict[str, Any]]): A dictionary of tags for the op that executes the check.\\n            Frameworks may expect and require certain metadata to be attached to a op. Values that\\n            are not strings will be json encoded and must meet the criteria that\\n            `json.loads(json.dumps(value)) == value`.\\n        compute_kind (Optional[str]): A string to represent the kind of computation that executes\\n            the check, e.g. \"dbt\" or \"spark\".\\n        retry_policy (Optional[RetryPolicy]): The retry policy for the op that executes the check.\\n\\n\\n    Produces an :py:class:`AssetChecksDefinition` object.\\n\\n\\n    Example:\\n        .. code-block:: python\\n\\n            from dagster import asset, asset_check, AssetCheckResult\\n\\n            @asset\\n            def my_asset() -> None:\\n                ...\\n\\n            @asset_check(asset=my_asset, description=\"Check that my asset has enough rows\")\\n            def my_asset_has_enough_rows() -> AssetCheckResult:\\n                num_rows = ...\\n                return AssetCheckResult(passed=num_rows > 5, metadata={\"num_rows\": num_rows})\\n\\n\\n    Example with a DataFrame Output:\\n        .. code-block:: python\\n\\n            from dagster import asset, asset_check, AssetCheckResult\\n            from pandas import DataFrame\\n\\n            @asset\\n            def my_asset() -> DataFrame:\\n                ...\\n\\n            @asset_check(asset=my_asset, description=\"Check that my asset has enough rows\")\\n            def my_asset_has_enough_rows(my_asset: DataFrame) -> AssetCheckResult:\\n                num_rows = my_asset.shape[0]\\n                return AssetCheckResult(passed=num_rows > 5, metadata={\"num_rows\": num_rows})\\n    '\n\n    def inner(fn: AssetCheckFunction) -> AssetChecksDefinition:\n        check.callable_param(fn, 'fn')\n        resolved_name = name or fn.__name__\n        asset_key = AssetKey.from_coercible_or_definition(asset)\n        out = Out(dagster_type=None)\n        input_tuples_by_asset_key = _build_asset_check_input(resolved_name, asset_key, fn)\n        if len(input_tuples_by_asset_key) == 0:\n            raise DagsterInvalidDefinitionError(f\"No target asset provided when defining check '{resolved_name}'\")\n        if len(input_tuples_by_asset_key) > 1:\n            raise DagsterInvalidDefinitionError(f\"When defining check '{resolved_name}', Multiple target assets provided: {[key.to_user_string() for key in input_tuples_by_asset_key.keys()]}. Only one is allowed.\")\n        resolved_asset_key = next(iter(input_tuples_by_asset_key.keys()))\n        spec = AssetCheckSpec(name=resolved_name, description=description, asset=resolved_asset_key)\n        op_def = _Op(name=spec.get_python_identifier(), ins=dict(input_tuples_by_asset_key.values()), out=out, required_resource_keys=required_resource_keys, tags={**({'kind': compute_kind} if compute_kind else {}), **(op_tags or {})}, config_schema=config_schema, retry_policy=retry_policy)(fn)\n        checks_def = AssetChecksDefinition(node_def=op_def, resource_defs={}, specs=[spec], input_output_props=AssetChecksDefinitionInputOutputProps(asset_keys_by_input_name={input_tuples_by_asset_key[resolved_asset_key][0]: resolved_asset_key}, asset_check_keys_by_output_name={op_def.output_defs[0].name: spec.key}))\n        return checks_def\n    return inner",
            "@experimental\ndef asset_check(*, asset: Union[CoercibleToAssetKey, AssetsDefinition, SourceAsset], name: Optional[str]=None, description: Optional[str]=None, required_resource_keys: Optional[Set[str]]=None, resource_defs: Optional[Mapping[str, object]]=None, config_schema: Optional[UserConfigSchema]=None, compute_kind: Optional[str]=None, op_tags: Optional[Mapping[str, Any]]=None, retry_policy: Optional[RetryPolicy]=None) -> Callable[[AssetCheckFunction], AssetChecksDefinition]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Create a definition for how to execute an asset check.\\n\\n    Args:\\n        asset (Union[AssetKey, Sequence[str], str, AssetsDefinition, SourceAsset]): The\\n            asset that the check applies to.\\n        name (Optional[str]): The name of the check. If not specified, the name of the decorated\\n            function will be used. Checks for the same asset must have unique names.\\n        description (Optional[str]): The description of the check.\\n        required_resource_keys (Optional[Set[str]]): A set of keys for resources that are required\\n            by the function that execute the check. These can alternatively be specified by\\n            including resource-typed parameters in the function signature.\\n        config_schema (Optional[ConfigSchema): The configuration schema for the check\\'s underlying\\n            op. If set, Dagster will check that config provided for the op matches this schema and fail\\n            if it does not. If not set, Dagster will accept any config provided for the op.\\n        op_tags (Optional[Dict[str, Any]]): A dictionary of tags for the op that executes the check.\\n            Frameworks may expect and require certain metadata to be attached to a op. Values that\\n            are not strings will be json encoded and must meet the criteria that\\n            `json.loads(json.dumps(value)) == value`.\\n        compute_kind (Optional[str]): A string to represent the kind of computation that executes\\n            the check, e.g. \"dbt\" or \"spark\".\\n        retry_policy (Optional[RetryPolicy]): The retry policy for the op that executes the check.\\n\\n\\n    Produces an :py:class:`AssetChecksDefinition` object.\\n\\n\\n    Example:\\n        .. code-block:: python\\n\\n            from dagster import asset, asset_check, AssetCheckResult\\n\\n            @asset\\n            def my_asset() -> None:\\n                ...\\n\\n            @asset_check(asset=my_asset, description=\"Check that my asset has enough rows\")\\n            def my_asset_has_enough_rows() -> AssetCheckResult:\\n                num_rows = ...\\n                return AssetCheckResult(passed=num_rows > 5, metadata={\"num_rows\": num_rows})\\n\\n\\n    Example with a DataFrame Output:\\n        .. code-block:: python\\n\\n            from dagster import asset, asset_check, AssetCheckResult\\n            from pandas import DataFrame\\n\\n            @asset\\n            def my_asset() -> DataFrame:\\n                ...\\n\\n            @asset_check(asset=my_asset, description=\"Check that my asset has enough rows\")\\n            def my_asset_has_enough_rows(my_asset: DataFrame) -> AssetCheckResult:\\n                num_rows = my_asset.shape[0]\\n                return AssetCheckResult(passed=num_rows > 5, metadata={\"num_rows\": num_rows})\\n    '\n\n    def inner(fn: AssetCheckFunction) -> AssetChecksDefinition:\n        check.callable_param(fn, 'fn')\n        resolved_name = name or fn.__name__\n        asset_key = AssetKey.from_coercible_or_definition(asset)\n        out = Out(dagster_type=None)\n        input_tuples_by_asset_key = _build_asset_check_input(resolved_name, asset_key, fn)\n        if len(input_tuples_by_asset_key) == 0:\n            raise DagsterInvalidDefinitionError(f\"No target asset provided when defining check '{resolved_name}'\")\n        if len(input_tuples_by_asset_key) > 1:\n            raise DagsterInvalidDefinitionError(f\"When defining check '{resolved_name}', Multiple target assets provided: {[key.to_user_string() for key in input_tuples_by_asset_key.keys()]}. Only one is allowed.\")\n        resolved_asset_key = next(iter(input_tuples_by_asset_key.keys()))\n        spec = AssetCheckSpec(name=resolved_name, description=description, asset=resolved_asset_key)\n        op_def = _Op(name=spec.get_python_identifier(), ins=dict(input_tuples_by_asset_key.values()), out=out, required_resource_keys=required_resource_keys, tags={**({'kind': compute_kind} if compute_kind else {}), **(op_tags or {})}, config_schema=config_schema, retry_policy=retry_policy)(fn)\n        checks_def = AssetChecksDefinition(node_def=op_def, resource_defs={}, specs=[spec], input_output_props=AssetChecksDefinitionInputOutputProps(asset_keys_by_input_name={input_tuples_by_asset_key[resolved_asset_key][0]: resolved_asset_key}, asset_check_keys_by_output_name={op_def.output_defs[0].name: spec.key}))\n        return checks_def\n    return inner"
        ]
    }
]