[
    {
        "func_name": "__virtual__",
        "original": "def __virtual__():\n    \"\"\"\n    Set the virtual pkg module if the os is OpenBSD\n    \"\"\"\n    if __grains__['os'] == 'OpenBSD':\n        return __virtualname__\n    return (False, 'The openbsdpkg execution module cannot be loaded: only available on OpenBSD systems.')",
        "mutated": [
            "def __virtual__():\n    if False:\n        i = 10\n    '\\n    Set the virtual pkg module if the os is OpenBSD\\n    '\n    if __grains__['os'] == 'OpenBSD':\n        return __virtualname__\n    return (False, 'The openbsdpkg execution module cannot be loaded: only available on OpenBSD systems.')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Set the virtual pkg module if the os is OpenBSD\\n    '\n    if __grains__['os'] == 'OpenBSD':\n        return __virtualname__\n    return (False, 'The openbsdpkg execution module cannot be loaded: only available on OpenBSD systems.')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Set the virtual pkg module if the os is OpenBSD\\n    '\n    if __grains__['os'] == 'OpenBSD':\n        return __virtualname__\n    return (False, 'The openbsdpkg execution module cannot be loaded: only available on OpenBSD systems.')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Set the virtual pkg module if the os is OpenBSD\\n    '\n    if __grains__['os'] == 'OpenBSD':\n        return __virtualname__\n    return (False, 'The openbsdpkg execution module cannot be loaded: only available on OpenBSD systems.')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Set the virtual pkg module if the os is OpenBSD\\n    '\n    if __grains__['os'] == 'OpenBSD':\n        return __virtualname__\n    return (False, 'The openbsdpkg execution module cannot be loaded: only available on OpenBSD systems.')"
        ]
    },
    {
        "func_name": "_list_pkgs_from_context",
        "original": "def _list_pkgs_from_context(versions_as_list):\n    \"\"\"\n    Use pkg list from __context__\n    \"\"\"\n    if versions_as_list:\n        return __context__['pkg.list_pkgs']\n    else:\n        ret = copy.deepcopy(__context__['pkg.list_pkgs'])\n        __salt__['pkg_resource.stringify'](ret)\n        return ret",
        "mutated": [
            "def _list_pkgs_from_context(versions_as_list):\n    if False:\n        i = 10\n    '\\n    Use pkg list from __context__\\n    '\n    if versions_as_list:\n        return __context__['pkg.list_pkgs']\n    else:\n        ret = copy.deepcopy(__context__['pkg.list_pkgs'])\n        __salt__['pkg_resource.stringify'](ret)\n        return ret",
            "def _list_pkgs_from_context(versions_as_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Use pkg list from __context__\\n    '\n    if versions_as_list:\n        return __context__['pkg.list_pkgs']\n    else:\n        ret = copy.deepcopy(__context__['pkg.list_pkgs'])\n        __salt__['pkg_resource.stringify'](ret)\n        return ret",
            "def _list_pkgs_from_context(versions_as_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Use pkg list from __context__\\n    '\n    if versions_as_list:\n        return __context__['pkg.list_pkgs']\n    else:\n        ret = copy.deepcopy(__context__['pkg.list_pkgs'])\n        __salt__['pkg_resource.stringify'](ret)\n        return ret",
            "def _list_pkgs_from_context(versions_as_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Use pkg list from __context__\\n    '\n    if versions_as_list:\n        return __context__['pkg.list_pkgs']\n    else:\n        ret = copy.deepcopy(__context__['pkg.list_pkgs'])\n        __salt__['pkg_resource.stringify'](ret)\n        return ret",
            "def _list_pkgs_from_context(versions_as_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Use pkg list from __context__\\n    '\n    if versions_as_list:\n        return __context__['pkg.list_pkgs']\n    else:\n        ret = copy.deepcopy(__context__['pkg.list_pkgs'])\n        __salt__['pkg_resource.stringify'](ret)\n        return ret"
        ]
    },
    {
        "func_name": "list_pkgs",
        "original": "def list_pkgs(versions_as_list=False, **kwargs):\n    \"\"\"\n    List the packages currently installed as a dict::\n\n        {'<package_name>': '<version>'}\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.list_pkgs\n    \"\"\"\n    versions_as_list = salt.utils.data.is_true(versions_as_list)\n    if any([salt.utils.data.is_true(kwargs.get(x)) for x in ('removed', 'purge_desired')]):\n        return {}\n    if 'pkg.list_pkgs' in __context__ and kwargs.get('use_context', True):\n        return _list_pkgs_from_context(versions_as_list)\n    ret = {}\n    cmd = 'pkg_info -q -a'\n    out = __salt__['cmd.run_stdout'](cmd, output_loglevel='trace')\n    for line in out.splitlines():\n        try:\n            (pkgname, pkgver, flavor) = __PKG_RE.match(line).groups()\n        except AttributeError:\n            continue\n        pkgname += '--{}'.format(flavor) if flavor else ''\n        __salt__['pkg_resource.add_pkg'](ret, pkgname, pkgver)\n    __salt__['pkg_resource.sort_pkglist'](ret)\n    __context__['pkg.list_pkgs'] = copy.deepcopy(ret)\n    if not versions_as_list:\n        __salt__['pkg_resource.stringify'](ret)\n    return ret",
        "mutated": [
            "def list_pkgs(versions_as_list=False, **kwargs):\n    if False:\n        i = 10\n    \"\\n    List the packages currently installed as a dict::\\n\\n        {'<package_name>': '<version>'}\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_pkgs\\n    \"\n    versions_as_list = salt.utils.data.is_true(versions_as_list)\n    if any([salt.utils.data.is_true(kwargs.get(x)) for x in ('removed', 'purge_desired')]):\n        return {}\n    if 'pkg.list_pkgs' in __context__ and kwargs.get('use_context', True):\n        return _list_pkgs_from_context(versions_as_list)\n    ret = {}\n    cmd = 'pkg_info -q -a'\n    out = __salt__['cmd.run_stdout'](cmd, output_loglevel='trace')\n    for line in out.splitlines():\n        try:\n            (pkgname, pkgver, flavor) = __PKG_RE.match(line).groups()\n        except AttributeError:\n            continue\n        pkgname += '--{}'.format(flavor) if flavor else ''\n        __salt__['pkg_resource.add_pkg'](ret, pkgname, pkgver)\n    __salt__['pkg_resource.sort_pkglist'](ret)\n    __context__['pkg.list_pkgs'] = copy.deepcopy(ret)\n    if not versions_as_list:\n        __salt__['pkg_resource.stringify'](ret)\n    return ret",
            "def list_pkgs(versions_as_list=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    List the packages currently installed as a dict::\\n\\n        {'<package_name>': '<version>'}\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_pkgs\\n    \"\n    versions_as_list = salt.utils.data.is_true(versions_as_list)\n    if any([salt.utils.data.is_true(kwargs.get(x)) for x in ('removed', 'purge_desired')]):\n        return {}\n    if 'pkg.list_pkgs' in __context__ and kwargs.get('use_context', True):\n        return _list_pkgs_from_context(versions_as_list)\n    ret = {}\n    cmd = 'pkg_info -q -a'\n    out = __salt__['cmd.run_stdout'](cmd, output_loglevel='trace')\n    for line in out.splitlines():\n        try:\n            (pkgname, pkgver, flavor) = __PKG_RE.match(line).groups()\n        except AttributeError:\n            continue\n        pkgname += '--{}'.format(flavor) if flavor else ''\n        __salt__['pkg_resource.add_pkg'](ret, pkgname, pkgver)\n    __salt__['pkg_resource.sort_pkglist'](ret)\n    __context__['pkg.list_pkgs'] = copy.deepcopy(ret)\n    if not versions_as_list:\n        __salt__['pkg_resource.stringify'](ret)\n    return ret",
            "def list_pkgs(versions_as_list=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    List the packages currently installed as a dict::\\n\\n        {'<package_name>': '<version>'}\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_pkgs\\n    \"\n    versions_as_list = salt.utils.data.is_true(versions_as_list)\n    if any([salt.utils.data.is_true(kwargs.get(x)) for x in ('removed', 'purge_desired')]):\n        return {}\n    if 'pkg.list_pkgs' in __context__ and kwargs.get('use_context', True):\n        return _list_pkgs_from_context(versions_as_list)\n    ret = {}\n    cmd = 'pkg_info -q -a'\n    out = __salt__['cmd.run_stdout'](cmd, output_loglevel='trace')\n    for line in out.splitlines():\n        try:\n            (pkgname, pkgver, flavor) = __PKG_RE.match(line).groups()\n        except AttributeError:\n            continue\n        pkgname += '--{}'.format(flavor) if flavor else ''\n        __salt__['pkg_resource.add_pkg'](ret, pkgname, pkgver)\n    __salt__['pkg_resource.sort_pkglist'](ret)\n    __context__['pkg.list_pkgs'] = copy.deepcopy(ret)\n    if not versions_as_list:\n        __salt__['pkg_resource.stringify'](ret)\n    return ret",
            "def list_pkgs(versions_as_list=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    List the packages currently installed as a dict::\\n\\n        {'<package_name>': '<version>'}\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_pkgs\\n    \"\n    versions_as_list = salt.utils.data.is_true(versions_as_list)\n    if any([salt.utils.data.is_true(kwargs.get(x)) for x in ('removed', 'purge_desired')]):\n        return {}\n    if 'pkg.list_pkgs' in __context__ and kwargs.get('use_context', True):\n        return _list_pkgs_from_context(versions_as_list)\n    ret = {}\n    cmd = 'pkg_info -q -a'\n    out = __salt__['cmd.run_stdout'](cmd, output_loglevel='trace')\n    for line in out.splitlines():\n        try:\n            (pkgname, pkgver, flavor) = __PKG_RE.match(line).groups()\n        except AttributeError:\n            continue\n        pkgname += '--{}'.format(flavor) if flavor else ''\n        __salt__['pkg_resource.add_pkg'](ret, pkgname, pkgver)\n    __salt__['pkg_resource.sort_pkglist'](ret)\n    __context__['pkg.list_pkgs'] = copy.deepcopy(ret)\n    if not versions_as_list:\n        __salt__['pkg_resource.stringify'](ret)\n    return ret",
            "def list_pkgs(versions_as_list=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    List the packages currently installed as a dict::\\n\\n        {'<package_name>': '<version>'}\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_pkgs\\n    \"\n    versions_as_list = salt.utils.data.is_true(versions_as_list)\n    if any([salt.utils.data.is_true(kwargs.get(x)) for x in ('removed', 'purge_desired')]):\n        return {}\n    if 'pkg.list_pkgs' in __context__ and kwargs.get('use_context', True):\n        return _list_pkgs_from_context(versions_as_list)\n    ret = {}\n    cmd = 'pkg_info -q -a'\n    out = __salt__['cmd.run_stdout'](cmd, output_loglevel='trace')\n    for line in out.splitlines():\n        try:\n            (pkgname, pkgver, flavor) = __PKG_RE.match(line).groups()\n        except AttributeError:\n            continue\n        pkgname += '--{}'.format(flavor) if flavor else ''\n        __salt__['pkg_resource.add_pkg'](ret, pkgname, pkgver)\n    __salt__['pkg_resource.sort_pkglist'](ret)\n    __context__['pkg.list_pkgs'] = copy.deepcopy(ret)\n    if not versions_as_list:\n        __salt__['pkg_resource.stringify'](ret)\n    return ret"
        ]
    },
    {
        "func_name": "latest_version",
        "original": "def latest_version(*names, **kwargs):\n    \"\"\"\n    Return the latest version of the named package available for upgrade or\n    installation. If more than one package name is specified, a dict of\n    name/version pairs is returned.\n\n    If the latest version of a given package is already installed, an empty\n    string will be returned for that package.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.latest_version <package name>\n    \"\"\"\n    kwargs.pop('refresh', True)\n    pkgs = list_pkgs()\n    ret = {}\n    for name in names:\n        ret[name] = ''\n        cmd = 'pkg_info -Q {}'.format(name)\n        out = __salt__['cmd.run_stdout'](cmd, python_shell=False, output_loglevel='trace')\n        for line in out.splitlines():\n            try:\n                (pkgname, pkgver, flavor) = __PKG_RE.match(line).groups()\n            except AttributeError:\n                continue\n            match = re.match('.*\\\\(installed\\\\)$', pkgver)\n            if match:\n                break\n            if '{}--{}'.format(pkgname, flavor) == name:\n                pkgname += '--{}'.format(flavor)\n            elif pkgname == name:\n                pass\n            else:\n                continue\n            cur = pkgs.get(pkgname, '')\n            if not cur or salt.utils.versions.compare(ver1=cur, oper='<', ver2=pkgver):\n                ret[pkgname] = pkgver\n    if len(names) == 1:\n        return ret[names[0]]\n    return ret",
        "mutated": [
            "def latest_version(*names, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Return the latest version of the named package available for upgrade or\\n    installation. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    If the latest version of a given package is already installed, an empty\\n    string will be returned for that package.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.latest_version <package name>\\n    \"\n    kwargs.pop('refresh', True)\n    pkgs = list_pkgs()\n    ret = {}\n    for name in names:\n        ret[name] = ''\n        cmd = 'pkg_info -Q {}'.format(name)\n        out = __salt__['cmd.run_stdout'](cmd, python_shell=False, output_loglevel='trace')\n        for line in out.splitlines():\n            try:\n                (pkgname, pkgver, flavor) = __PKG_RE.match(line).groups()\n            except AttributeError:\n                continue\n            match = re.match('.*\\\\(installed\\\\)$', pkgver)\n            if match:\n                break\n            if '{}--{}'.format(pkgname, flavor) == name:\n                pkgname += '--{}'.format(flavor)\n            elif pkgname == name:\n                pass\n            else:\n                continue\n            cur = pkgs.get(pkgname, '')\n            if not cur or salt.utils.versions.compare(ver1=cur, oper='<', ver2=pkgver):\n                ret[pkgname] = pkgver\n    if len(names) == 1:\n        return ret[names[0]]\n    return ret",
            "def latest_version(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Return the latest version of the named package available for upgrade or\\n    installation. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    If the latest version of a given package is already installed, an empty\\n    string will be returned for that package.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.latest_version <package name>\\n    \"\n    kwargs.pop('refresh', True)\n    pkgs = list_pkgs()\n    ret = {}\n    for name in names:\n        ret[name] = ''\n        cmd = 'pkg_info -Q {}'.format(name)\n        out = __salt__['cmd.run_stdout'](cmd, python_shell=False, output_loglevel='trace')\n        for line in out.splitlines():\n            try:\n                (pkgname, pkgver, flavor) = __PKG_RE.match(line).groups()\n            except AttributeError:\n                continue\n            match = re.match('.*\\\\(installed\\\\)$', pkgver)\n            if match:\n                break\n            if '{}--{}'.format(pkgname, flavor) == name:\n                pkgname += '--{}'.format(flavor)\n            elif pkgname == name:\n                pass\n            else:\n                continue\n            cur = pkgs.get(pkgname, '')\n            if not cur or salt.utils.versions.compare(ver1=cur, oper='<', ver2=pkgver):\n                ret[pkgname] = pkgver\n    if len(names) == 1:\n        return ret[names[0]]\n    return ret",
            "def latest_version(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Return the latest version of the named package available for upgrade or\\n    installation. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    If the latest version of a given package is already installed, an empty\\n    string will be returned for that package.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.latest_version <package name>\\n    \"\n    kwargs.pop('refresh', True)\n    pkgs = list_pkgs()\n    ret = {}\n    for name in names:\n        ret[name] = ''\n        cmd = 'pkg_info -Q {}'.format(name)\n        out = __salt__['cmd.run_stdout'](cmd, python_shell=False, output_loglevel='trace')\n        for line in out.splitlines():\n            try:\n                (pkgname, pkgver, flavor) = __PKG_RE.match(line).groups()\n            except AttributeError:\n                continue\n            match = re.match('.*\\\\(installed\\\\)$', pkgver)\n            if match:\n                break\n            if '{}--{}'.format(pkgname, flavor) == name:\n                pkgname += '--{}'.format(flavor)\n            elif pkgname == name:\n                pass\n            else:\n                continue\n            cur = pkgs.get(pkgname, '')\n            if not cur or salt.utils.versions.compare(ver1=cur, oper='<', ver2=pkgver):\n                ret[pkgname] = pkgver\n    if len(names) == 1:\n        return ret[names[0]]\n    return ret",
            "def latest_version(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Return the latest version of the named package available for upgrade or\\n    installation. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    If the latest version of a given package is already installed, an empty\\n    string will be returned for that package.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.latest_version <package name>\\n    \"\n    kwargs.pop('refresh', True)\n    pkgs = list_pkgs()\n    ret = {}\n    for name in names:\n        ret[name] = ''\n        cmd = 'pkg_info -Q {}'.format(name)\n        out = __salt__['cmd.run_stdout'](cmd, python_shell=False, output_loglevel='trace')\n        for line in out.splitlines():\n            try:\n                (pkgname, pkgver, flavor) = __PKG_RE.match(line).groups()\n            except AttributeError:\n                continue\n            match = re.match('.*\\\\(installed\\\\)$', pkgver)\n            if match:\n                break\n            if '{}--{}'.format(pkgname, flavor) == name:\n                pkgname += '--{}'.format(flavor)\n            elif pkgname == name:\n                pass\n            else:\n                continue\n            cur = pkgs.get(pkgname, '')\n            if not cur or salt.utils.versions.compare(ver1=cur, oper='<', ver2=pkgver):\n                ret[pkgname] = pkgver\n    if len(names) == 1:\n        return ret[names[0]]\n    return ret",
            "def latest_version(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Return the latest version of the named package available for upgrade or\\n    installation. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    If the latest version of a given package is already installed, an empty\\n    string will be returned for that package.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.latest_version <package name>\\n    \"\n    kwargs.pop('refresh', True)\n    pkgs = list_pkgs()\n    ret = {}\n    for name in names:\n        ret[name] = ''\n        cmd = 'pkg_info -Q {}'.format(name)\n        out = __salt__['cmd.run_stdout'](cmd, python_shell=False, output_loglevel='trace')\n        for line in out.splitlines():\n            try:\n                (pkgname, pkgver, flavor) = __PKG_RE.match(line).groups()\n            except AttributeError:\n                continue\n            match = re.match('.*\\\\(installed\\\\)$', pkgver)\n            if match:\n                break\n            if '{}--{}'.format(pkgname, flavor) == name:\n                pkgname += '--{}'.format(flavor)\n            elif pkgname == name:\n                pass\n            else:\n                continue\n            cur = pkgs.get(pkgname, '')\n            if not cur or salt.utils.versions.compare(ver1=cur, oper='<', ver2=pkgver):\n                ret[pkgname] = pkgver\n    if len(names) == 1:\n        return ret[names[0]]\n    return ret"
        ]
    },
    {
        "func_name": "version",
        "original": "def version(*names, **kwargs):\n    \"\"\"\n    Returns a string representing the package version or an empty string if not\n    installed. If more than one package name is specified, a dict of\n    name/version pairs is returned.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.version <package name>\n        salt '*' pkg.version <package1> <package2> <package3> ...\n    \"\"\"\n    return __salt__['pkg_resource.version'](*names, **kwargs)",
        "mutated": [
            "def version(*names, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Returns a string representing the package version or an empty string if not\\n    installed. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.version <package name>\\n        salt '*' pkg.version <package1> <package2> <package3> ...\\n    \"\n    return __salt__['pkg_resource.version'](*names, **kwargs)",
            "def version(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Returns a string representing the package version or an empty string if not\\n    installed. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.version <package name>\\n        salt '*' pkg.version <package1> <package2> <package3> ...\\n    \"\n    return __salt__['pkg_resource.version'](*names, **kwargs)",
            "def version(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Returns a string representing the package version or an empty string if not\\n    installed. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.version <package name>\\n        salt '*' pkg.version <package1> <package2> <package3> ...\\n    \"\n    return __salt__['pkg_resource.version'](*names, **kwargs)",
            "def version(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Returns a string representing the package version or an empty string if not\\n    installed. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.version <package name>\\n        salt '*' pkg.version <package1> <package2> <package3> ...\\n    \"\n    return __salt__['pkg_resource.version'](*names, **kwargs)",
            "def version(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Returns a string representing the package version or an empty string if not\\n    installed. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.version <package name>\\n        salt '*' pkg.version <package1> <package2> <package3> ...\\n    \"\n    return __salt__['pkg_resource.version'](*names, **kwargs)"
        ]
    },
    {
        "func_name": "install",
        "original": "def install(name=None, pkgs=None, sources=None, **kwargs):\n    \"\"\"\n    Install the passed package\n\n    Return a dict containing the new package names and versions::\n\n        {'<package>': {'old': '<old-version>',\n                       'new': '<new-version>'}}\n\n    CLI Example, Install one package:\n\n    .. code-block:: bash\n\n        salt '*' pkg.install <package name>\n\n    CLI Example, Install more than one package:\n\n    .. code-block:: bash\n\n        salt '*' pkg.install pkgs='[\"<package name>\", \"<package name>\"]'\n\n    CLI Example, Install more than one package from a alternate source (e.g.\n    salt file-server, HTTP, FTP, local filesystem):\n\n    .. code-block:: bash\n\n        salt '*' pkg.install sources='[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]'\n    \"\"\"\n    try:\n        (pkg_params, pkg_type) = __salt__['pkg_resource.parse_targets'](name, pkgs, sources, **kwargs)\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    if not pkg_params:\n        return {}\n    old = list_pkgs()\n    errors = []\n    for pkg in pkg_params:\n        if pkg_type == 'repository':\n            (stem, branch) = (pkg.split('%') + [''])[:2]\n            (base, flavor) = (stem.split('--') + [''])[:2]\n            pkg = '{}--{}%{}'.format(base, flavor, branch)\n        cmd = 'pkg_add -x -I {}'.format(pkg)\n        out = __salt__['cmd.run_all'](cmd, python_shell=False, output_loglevel='trace')\n        if out['retcode'] != 0 and out['stderr']:\n            errors.append(out['stderr'])\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs()\n    ret = salt.utils.data.compare_dicts(old, new)\n    if errors:\n        raise CommandExecutionError('Problem encountered installing package(s)', info={'errors': errors, 'changes': ret})\n    return ret",
        "mutated": [
            "def install(name=None, pkgs=None, sources=None, **kwargs):\n    if False:\n        i = 10\n    '\\n    Install the passed package\\n\\n    Return a dict containing the new package names and versions::\\n\\n        {\\'<package>\\': {\\'old\\': \\'<old-version>\\',\\n                       \\'new\\': \\'<new-version>\\'}}\\n\\n    CLI Example, Install one package:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.install <package name>\\n\\n    CLI Example, Install more than one package:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.install pkgs=\\'[\"<package name>\", \"<package name>\"]\\'\\n\\n    CLI Example, Install more than one package from a alternate source (e.g.\\n    salt file-server, HTTP, FTP, local filesystem):\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]\\'\\n    '\n    try:\n        (pkg_params, pkg_type) = __salt__['pkg_resource.parse_targets'](name, pkgs, sources, **kwargs)\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    if not pkg_params:\n        return {}\n    old = list_pkgs()\n    errors = []\n    for pkg in pkg_params:\n        if pkg_type == 'repository':\n            (stem, branch) = (pkg.split('%') + [''])[:2]\n            (base, flavor) = (stem.split('--') + [''])[:2]\n            pkg = '{}--{}%{}'.format(base, flavor, branch)\n        cmd = 'pkg_add -x -I {}'.format(pkg)\n        out = __salt__['cmd.run_all'](cmd, python_shell=False, output_loglevel='trace')\n        if out['retcode'] != 0 and out['stderr']:\n            errors.append(out['stderr'])\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs()\n    ret = salt.utils.data.compare_dicts(old, new)\n    if errors:\n        raise CommandExecutionError('Problem encountered installing package(s)', info={'errors': errors, 'changes': ret})\n    return ret",
            "def install(name=None, pkgs=None, sources=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Install the passed package\\n\\n    Return a dict containing the new package names and versions::\\n\\n        {\\'<package>\\': {\\'old\\': \\'<old-version>\\',\\n                       \\'new\\': \\'<new-version>\\'}}\\n\\n    CLI Example, Install one package:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.install <package name>\\n\\n    CLI Example, Install more than one package:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.install pkgs=\\'[\"<package name>\", \"<package name>\"]\\'\\n\\n    CLI Example, Install more than one package from a alternate source (e.g.\\n    salt file-server, HTTP, FTP, local filesystem):\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]\\'\\n    '\n    try:\n        (pkg_params, pkg_type) = __salt__['pkg_resource.parse_targets'](name, pkgs, sources, **kwargs)\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    if not pkg_params:\n        return {}\n    old = list_pkgs()\n    errors = []\n    for pkg in pkg_params:\n        if pkg_type == 'repository':\n            (stem, branch) = (pkg.split('%') + [''])[:2]\n            (base, flavor) = (stem.split('--') + [''])[:2]\n            pkg = '{}--{}%{}'.format(base, flavor, branch)\n        cmd = 'pkg_add -x -I {}'.format(pkg)\n        out = __salt__['cmd.run_all'](cmd, python_shell=False, output_loglevel='trace')\n        if out['retcode'] != 0 and out['stderr']:\n            errors.append(out['stderr'])\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs()\n    ret = salt.utils.data.compare_dicts(old, new)\n    if errors:\n        raise CommandExecutionError('Problem encountered installing package(s)', info={'errors': errors, 'changes': ret})\n    return ret",
            "def install(name=None, pkgs=None, sources=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Install the passed package\\n\\n    Return a dict containing the new package names and versions::\\n\\n        {\\'<package>\\': {\\'old\\': \\'<old-version>\\',\\n                       \\'new\\': \\'<new-version>\\'}}\\n\\n    CLI Example, Install one package:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.install <package name>\\n\\n    CLI Example, Install more than one package:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.install pkgs=\\'[\"<package name>\", \"<package name>\"]\\'\\n\\n    CLI Example, Install more than one package from a alternate source (e.g.\\n    salt file-server, HTTP, FTP, local filesystem):\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]\\'\\n    '\n    try:\n        (pkg_params, pkg_type) = __salt__['pkg_resource.parse_targets'](name, pkgs, sources, **kwargs)\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    if not pkg_params:\n        return {}\n    old = list_pkgs()\n    errors = []\n    for pkg in pkg_params:\n        if pkg_type == 'repository':\n            (stem, branch) = (pkg.split('%') + [''])[:2]\n            (base, flavor) = (stem.split('--') + [''])[:2]\n            pkg = '{}--{}%{}'.format(base, flavor, branch)\n        cmd = 'pkg_add -x -I {}'.format(pkg)\n        out = __salt__['cmd.run_all'](cmd, python_shell=False, output_loglevel='trace')\n        if out['retcode'] != 0 and out['stderr']:\n            errors.append(out['stderr'])\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs()\n    ret = salt.utils.data.compare_dicts(old, new)\n    if errors:\n        raise CommandExecutionError('Problem encountered installing package(s)', info={'errors': errors, 'changes': ret})\n    return ret",
            "def install(name=None, pkgs=None, sources=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Install the passed package\\n\\n    Return a dict containing the new package names and versions::\\n\\n        {\\'<package>\\': {\\'old\\': \\'<old-version>\\',\\n                       \\'new\\': \\'<new-version>\\'}}\\n\\n    CLI Example, Install one package:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.install <package name>\\n\\n    CLI Example, Install more than one package:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.install pkgs=\\'[\"<package name>\", \"<package name>\"]\\'\\n\\n    CLI Example, Install more than one package from a alternate source (e.g.\\n    salt file-server, HTTP, FTP, local filesystem):\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]\\'\\n    '\n    try:\n        (pkg_params, pkg_type) = __salt__['pkg_resource.parse_targets'](name, pkgs, sources, **kwargs)\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    if not pkg_params:\n        return {}\n    old = list_pkgs()\n    errors = []\n    for pkg in pkg_params:\n        if pkg_type == 'repository':\n            (stem, branch) = (pkg.split('%') + [''])[:2]\n            (base, flavor) = (stem.split('--') + [''])[:2]\n            pkg = '{}--{}%{}'.format(base, flavor, branch)\n        cmd = 'pkg_add -x -I {}'.format(pkg)\n        out = __salt__['cmd.run_all'](cmd, python_shell=False, output_loglevel='trace')\n        if out['retcode'] != 0 and out['stderr']:\n            errors.append(out['stderr'])\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs()\n    ret = salt.utils.data.compare_dicts(old, new)\n    if errors:\n        raise CommandExecutionError('Problem encountered installing package(s)', info={'errors': errors, 'changes': ret})\n    return ret",
            "def install(name=None, pkgs=None, sources=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Install the passed package\\n\\n    Return a dict containing the new package names and versions::\\n\\n        {\\'<package>\\': {\\'old\\': \\'<old-version>\\',\\n                       \\'new\\': \\'<new-version>\\'}}\\n\\n    CLI Example, Install one package:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.install <package name>\\n\\n    CLI Example, Install more than one package:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.install pkgs=\\'[\"<package name>\", \"<package name>\"]\\'\\n\\n    CLI Example, Install more than one package from a alternate source (e.g.\\n    salt file-server, HTTP, FTP, local filesystem):\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]\\'\\n    '\n    try:\n        (pkg_params, pkg_type) = __salt__['pkg_resource.parse_targets'](name, pkgs, sources, **kwargs)\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    if not pkg_params:\n        return {}\n    old = list_pkgs()\n    errors = []\n    for pkg in pkg_params:\n        if pkg_type == 'repository':\n            (stem, branch) = (pkg.split('%') + [''])[:2]\n            (base, flavor) = (stem.split('--') + [''])[:2]\n            pkg = '{}--{}%{}'.format(base, flavor, branch)\n        cmd = 'pkg_add -x -I {}'.format(pkg)\n        out = __salt__['cmd.run_all'](cmd, python_shell=False, output_loglevel='trace')\n        if out['retcode'] != 0 and out['stderr']:\n            errors.append(out['stderr'])\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs()\n    ret = salt.utils.data.compare_dicts(old, new)\n    if errors:\n        raise CommandExecutionError('Problem encountered installing package(s)', info={'errors': errors, 'changes': ret})\n    return ret"
        ]
    },
    {
        "func_name": "remove",
        "original": "def remove(name=None, pkgs=None, purge=False, **kwargs):\n    \"\"\"\n    Remove a single package with pkg_delete\n\n    Multiple Package Options:\n\n    pkgs\n        A list of packages to delete. Must be passed as a python list. The\n        ``name`` parameter will be ignored if this option is passed.\n\n    .. versionadded:: 0.16.0\n\n\n    Returns a dict containing the changes.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.remove <package name>\n        salt '*' pkg.remove <package1>,<package2>,<package3>\n        salt '*' pkg.remove pkgs='[\"foo\", \"bar\"]'\n    \"\"\"\n    try:\n        pkg_params = [x.split('--')[0] for x in __salt__['pkg_resource.parse_targets'](name, pkgs)[0]]\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    old = list_pkgs()\n    targets = [x for x in pkg_params if x in old]\n    if not targets:\n        return {}\n    cmd = ['pkg_delete', '-Ix', '-Ddependencies']\n    if purge:\n        cmd.append('-cqq')\n    cmd.extend(targets)\n    out = __salt__['cmd.run_all'](cmd, python_shell=False, output_loglevel='trace')\n    if out['retcode'] != 0 and out['stderr']:\n        errors = [out['stderr']]\n    else:\n        errors = []\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs()\n    ret = salt.utils.data.compare_dicts(old, new)\n    if errors:\n        raise CommandExecutionError('Problem encountered removing package(s)', info={'errors': errors, 'changes': ret})\n    return ret",
        "mutated": [
            "def remove(name=None, pkgs=None, purge=False, **kwargs):\n    if False:\n        i = 10\n    '\\n    Remove a single package with pkg_delete\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.remove <package name>\\n        salt \\'*\\' pkg.remove <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.remove pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    try:\n        pkg_params = [x.split('--')[0] for x in __salt__['pkg_resource.parse_targets'](name, pkgs)[0]]\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    old = list_pkgs()\n    targets = [x for x in pkg_params if x in old]\n    if not targets:\n        return {}\n    cmd = ['pkg_delete', '-Ix', '-Ddependencies']\n    if purge:\n        cmd.append('-cqq')\n    cmd.extend(targets)\n    out = __salt__['cmd.run_all'](cmd, python_shell=False, output_loglevel='trace')\n    if out['retcode'] != 0 and out['stderr']:\n        errors = [out['stderr']]\n    else:\n        errors = []\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs()\n    ret = salt.utils.data.compare_dicts(old, new)\n    if errors:\n        raise CommandExecutionError('Problem encountered removing package(s)', info={'errors': errors, 'changes': ret})\n    return ret",
            "def remove(name=None, pkgs=None, purge=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Remove a single package with pkg_delete\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.remove <package name>\\n        salt \\'*\\' pkg.remove <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.remove pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    try:\n        pkg_params = [x.split('--')[0] for x in __salt__['pkg_resource.parse_targets'](name, pkgs)[0]]\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    old = list_pkgs()\n    targets = [x for x in pkg_params if x in old]\n    if not targets:\n        return {}\n    cmd = ['pkg_delete', '-Ix', '-Ddependencies']\n    if purge:\n        cmd.append('-cqq')\n    cmd.extend(targets)\n    out = __salt__['cmd.run_all'](cmd, python_shell=False, output_loglevel='trace')\n    if out['retcode'] != 0 and out['stderr']:\n        errors = [out['stderr']]\n    else:\n        errors = []\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs()\n    ret = salt.utils.data.compare_dicts(old, new)\n    if errors:\n        raise CommandExecutionError('Problem encountered removing package(s)', info={'errors': errors, 'changes': ret})\n    return ret",
            "def remove(name=None, pkgs=None, purge=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Remove a single package with pkg_delete\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.remove <package name>\\n        salt \\'*\\' pkg.remove <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.remove pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    try:\n        pkg_params = [x.split('--')[0] for x in __salt__['pkg_resource.parse_targets'](name, pkgs)[0]]\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    old = list_pkgs()\n    targets = [x for x in pkg_params if x in old]\n    if not targets:\n        return {}\n    cmd = ['pkg_delete', '-Ix', '-Ddependencies']\n    if purge:\n        cmd.append('-cqq')\n    cmd.extend(targets)\n    out = __salt__['cmd.run_all'](cmd, python_shell=False, output_loglevel='trace')\n    if out['retcode'] != 0 and out['stderr']:\n        errors = [out['stderr']]\n    else:\n        errors = []\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs()\n    ret = salt.utils.data.compare_dicts(old, new)\n    if errors:\n        raise CommandExecutionError('Problem encountered removing package(s)', info={'errors': errors, 'changes': ret})\n    return ret",
            "def remove(name=None, pkgs=None, purge=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Remove a single package with pkg_delete\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.remove <package name>\\n        salt \\'*\\' pkg.remove <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.remove pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    try:\n        pkg_params = [x.split('--')[0] for x in __salt__['pkg_resource.parse_targets'](name, pkgs)[0]]\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    old = list_pkgs()\n    targets = [x for x in pkg_params if x in old]\n    if not targets:\n        return {}\n    cmd = ['pkg_delete', '-Ix', '-Ddependencies']\n    if purge:\n        cmd.append('-cqq')\n    cmd.extend(targets)\n    out = __salt__['cmd.run_all'](cmd, python_shell=False, output_loglevel='trace')\n    if out['retcode'] != 0 and out['stderr']:\n        errors = [out['stderr']]\n    else:\n        errors = []\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs()\n    ret = salt.utils.data.compare_dicts(old, new)\n    if errors:\n        raise CommandExecutionError('Problem encountered removing package(s)', info={'errors': errors, 'changes': ret})\n    return ret",
            "def remove(name=None, pkgs=None, purge=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Remove a single package with pkg_delete\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.remove <package name>\\n        salt \\'*\\' pkg.remove <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.remove pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    try:\n        pkg_params = [x.split('--')[0] for x in __salt__['pkg_resource.parse_targets'](name, pkgs)[0]]\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    old = list_pkgs()\n    targets = [x for x in pkg_params if x in old]\n    if not targets:\n        return {}\n    cmd = ['pkg_delete', '-Ix', '-Ddependencies']\n    if purge:\n        cmd.append('-cqq')\n    cmd.extend(targets)\n    out = __salt__['cmd.run_all'](cmd, python_shell=False, output_loglevel='trace')\n    if out['retcode'] != 0 and out['stderr']:\n        errors = [out['stderr']]\n    else:\n        errors = []\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs()\n    ret = salt.utils.data.compare_dicts(old, new)\n    if errors:\n        raise CommandExecutionError('Problem encountered removing package(s)', info={'errors': errors, 'changes': ret})\n    return ret"
        ]
    },
    {
        "func_name": "purge",
        "original": "def purge(name=None, pkgs=None, **kwargs):\n    \"\"\"\n    Remove a package and extra configuration files.\n\n    name\n        The name of the package to be deleted.\n\n\n    Multiple Package Options:\n\n    pkgs\n        A list of packages to delete. Must be passed as a python list. The\n        ``name`` parameter will be ignored if this option is passed.\n\n    .. versionadded:: 0.16.0\n\n\n    Returns a dict containing the changes.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.purge <package name>\n        salt '*' pkg.purge <package1>,<package2>,<package3>\n        salt '*' pkg.purge pkgs='[\"foo\", \"bar\"]'\n    \"\"\"\n    return remove(name=name, pkgs=pkgs, purge=True)",
        "mutated": [
            "def purge(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n    '\\n    Remove a package and extra configuration files.\\n\\n    name\\n        The name of the package to be deleted.\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.purge <package name>\\n        salt \\'*\\' pkg.purge <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.purge pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    return remove(name=name, pkgs=pkgs, purge=True)",
            "def purge(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Remove a package and extra configuration files.\\n\\n    name\\n        The name of the package to be deleted.\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.purge <package name>\\n        salt \\'*\\' pkg.purge <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.purge pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    return remove(name=name, pkgs=pkgs, purge=True)",
            "def purge(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Remove a package and extra configuration files.\\n\\n    name\\n        The name of the package to be deleted.\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.purge <package name>\\n        salt \\'*\\' pkg.purge <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.purge pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    return remove(name=name, pkgs=pkgs, purge=True)",
            "def purge(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Remove a package and extra configuration files.\\n\\n    name\\n        The name of the package to be deleted.\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.purge <package name>\\n        salt \\'*\\' pkg.purge <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.purge pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    return remove(name=name, pkgs=pkgs, purge=True)",
            "def purge(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Remove a package and extra configuration files.\\n\\n    name\\n        The name of the package to be deleted.\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.purge <package name>\\n        salt \\'*\\' pkg.purge <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.purge pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    return remove(name=name, pkgs=pkgs, purge=True)"
        ]
    },
    {
        "func_name": "upgrade_available",
        "original": "def upgrade_available(name, **kwargs):\n    \"\"\"\n    Check whether or not an upgrade is available for a given package\n\n    .. versionadded:: 2019.2.0\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.upgrade_available <package name>\n    \"\"\"\n    return latest_version(name) != ''",
        "mutated": [
            "def upgrade_available(name, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Check whether or not an upgrade is available for a given package\\n\\n    .. versionadded:: 2019.2.0\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.upgrade_available <package name>\\n    \"\n    return latest_version(name) != ''",
            "def upgrade_available(name, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Check whether or not an upgrade is available for a given package\\n\\n    .. versionadded:: 2019.2.0\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.upgrade_available <package name>\\n    \"\n    return latest_version(name) != ''",
            "def upgrade_available(name, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Check whether or not an upgrade is available for a given package\\n\\n    .. versionadded:: 2019.2.0\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.upgrade_available <package name>\\n    \"\n    return latest_version(name) != ''",
            "def upgrade_available(name, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Check whether or not an upgrade is available for a given package\\n\\n    .. versionadded:: 2019.2.0\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.upgrade_available <package name>\\n    \"\n    return latest_version(name) != ''",
            "def upgrade_available(name, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Check whether or not an upgrade is available for a given package\\n\\n    .. versionadded:: 2019.2.0\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.upgrade_available <package name>\\n    \"\n    return latest_version(name) != ''"
        ]
    },
    {
        "func_name": "upgrade",
        "original": "def upgrade(name=None, pkgs=None, **kwargs):\n    \"\"\"\n    Run a full package upgrade (``pkg_add -u``), or upgrade a specific package\n    if ``name`` or ``pkgs`` is provided.\n    ``name`` is ignored when ``pkgs`` is specified.\n\n    Returns a dictionary containing the changes:\n\n    .. versionadded:: 2019.2.0\n\n    .. code-block:: python\n\n        {'<package>': {'old': '<old-version>',\n                       'new': '<new-version>'}}\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.upgrade\n        salt '*' pkg.upgrade python%2.7\n    \"\"\"\n    old = list_pkgs()\n    cmd = ['pkg_add', '-Ix', '-u']\n    if kwargs.get('noop', False):\n        cmd.append('-n')\n    if pkgs:\n        cmd.extend(pkgs)\n    elif name:\n        cmd.append(name)\n    result = __salt__['cmd.run_all'](cmd, output_loglevel='trace', python_shell=False)\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs()\n    ret = salt.utils.data.compare_dicts(old, new)\n    if result['retcode'] != 0:\n        raise CommandExecutionError('Problem encountered upgrading packages', info={'changes': ret, 'result': result})\n    return ret",
        "mutated": [
            "def upgrade(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Run a full package upgrade (``pkg_add -u``), or upgrade a specific package\\n    if ``name`` or ``pkgs`` is provided.\\n    ``name`` is ignored when ``pkgs`` is specified.\\n\\n    Returns a dictionary containing the changes:\\n\\n    .. versionadded:: 2019.2.0\\n\\n    .. code-block:: python\\n\\n        {'<package>': {'old': '<old-version>',\\n                       'new': '<new-version>'}}\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.upgrade\\n        salt '*' pkg.upgrade python%2.7\\n    \"\n    old = list_pkgs()\n    cmd = ['pkg_add', '-Ix', '-u']\n    if kwargs.get('noop', False):\n        cmd.append('-n')\n    if pkgs:\n        cmd.extend(pkgs)\n    elif name:\n        cmd.append(name)\n    result = __salt__['cmd.run_all'](cmd, output_loglevel='trace', python_shell=False)\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs()\n    ret = salt.utils.data.compare_dicts(old, new)\n    if result['retcode'] != 0:\n        raise CommandExecutionError('Problem encountered upgrading packages', info={'changes': ret, 'result': result})\n    return ret",
            "def upgrade(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Run a full package upgrade (``pkg_add -u``), or upgrade a specific package\\n    if ``name`` or ``pkgs`` is provided.\\n    ``name`` is ignored when ``pkgs`` is specified.\\n\\n    Returns a dictionary containing the changes:\\n\\n    .. versionadded:: 2019.2.0\\n\\n    .. code-block:: python\\n\\n        {'<package>': {'old': '<old-version>',\\n                       'new': '<new-version>'}}\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.upgrade\\n        salt '*' pkg.upgrade python%2.7\\n    \"\n    old = list_pkgs()\n    cmd = ['pkg_add', '-Ix', '-u']\n    if kwargs.get('noop', False):\n        cmd.append('-n')\n    if pkgs:\n        cmd.extend(pkgs)\n    elif name:\n        cmd.append(name)\n    result = __salt__['cmd.run_all'](cmd, output_loglevel='trace', python_shell=False)\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs()\n    ret = salt.utils.data.compare_dicts(old, new)\n    if result['retcode'] != 0:\n        raise CommandExecutionError('Problem encountered upgrading packages', info={'changes': ret, 'result': result})\n    return ret",
            "def upgrade(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Run a full package upgrade (``pkg_add -u``), or upgrade a specific package\\n    if ``name`` or ``pkgs`` is provided.\\n    ``name`` is ignored when ``pkgs`` is specified.\\n\\n    Returns a dictionary containing the changes:\\n\\n    .. versionadded:: 2019.2.0\\n\\n    .. code-block:: python\\n\\n        {'<package>': {'old': '<old-version>',\\n                       'new': '<new-version>'}}\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.upgrade\\n        salt '*' pkg.upgrade python%2.7\\n    \"\n    old = list_pkgs()\n    cmd = ['pkg_add', '-Ix', '-u']\n    if kwargs.get('noop', False):\n        cmd.append('-n')\n    if pkgs:\n        cmd.extend(pkgs)\n    elif name:\n        cmd.append(name)\n    result = __salt__['cmd.run_all'](cmd, output_loglevel='trace', python_shell=False)\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs()\n    ret = salt.utils.data.compare_dicts(old, new)\n    if result['retcode'] != 0:\n        raise CommandExecutionError('Problem encountered upgrading packages', info={'changes': ret, 'result': result})\n    return ret",
            "def upgrade(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Run a full package upgrade (``pkg_add -u``), or upgrade a specific package\\n    if ``name`` or ``pkgs`` is provided.\\n    ``name`` is ignored when ``pkgs`` is specified.\\n\\n    Returns a dictionary containing the changes:\\n\\n    .. versionadded:: 2019.2.0\\n\\n    .. code-block:: python\\n\\n        {'<package>': {'old': '<old-version>',\\n                       'new': '<new-version>'}}\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.upgrade\\n        salt '*' pkg.upgrade python%2.7\\n    \"\n    old = list_pkgs()\n    cmd = ['pkg_add', '-Ix', '-u']\n    if kwargs.get('noop', False):\n        cmd.append('-n')\n    if pkgs:\n        cmd.extend(pkgs)\n    elif name:\n        cmd.append(name)\n    result = __salt__['cmd.run_all'](cmd, output_loglevel='trace', python_shell=False)\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs()\n    ret = salt.utils.data.compare_dicts(old, new)\n    if result['retcode'] != 0:\n        raise CommandExecutionError('Problem encountered upgrading packages', info={'changes': ret, 'result': result})\n    return ret",
            "def upgrade(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Run a full package upgrade (``pkg_add -u``), or upgrade a specific package\\n    if ``name`` or ``pkgs`` is provided.\\n    ``name`` is ignored when ``pkgs`` is specified.\\n\\n    Returns a dictionary containing the changes:\\n\\n    .. versionadded:: 2019.2.0\\n\\n    .. code-block:: python\\n\\n        {'<package>': {'old': '<old-version>',\\n                       'new': '<new-version>'}}\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.upgrade\\n        salt '*' pkg.upgrade python%2.7\\n    \"\n    old = list_pkgs()\n    cmd = ['pkg_add', '-Ix', '-u']\n    if kwargs.get('noop', False):\n        cmd.append('-n')\n    if pkgs:\n        cmd.extend(pkgs)\n    elif name:\n        cmd.append(name)\n    result = __salt__['cmd.run_all'](cmd, output_loglevel='trace', python_shell=False)\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs()\n    ret = salt.utils.data.compare_dicts(old, new)\n    if result['retcode'] != 0:\n        raise CommandExecutionError('Problem encountered upgrading packages', info={'changes': ret, 'result': result})\n    return ret"
        ]
    }
]