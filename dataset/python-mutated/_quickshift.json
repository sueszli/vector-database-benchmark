[
    {
        "func_name": "quickshift",
        "original": "@deprecate_kwarg({'random_seed': 'rng'}, deprecated_version='0.21', removed_version='0.23')\ndef quickshift(image, ratio=1.0, kernel_size=5, max_dist=10, return_tree=False, sigma=0, convert2lab=True, rng=42, *, channel_axis=-1):\n    \"\"\"Segment image using quickshift clustering in Color-(x,y) space.\n\n    Produces an oversegmentation of the image using the quickshift mode-seeking\n    algorithm.\n\n    Parameters\n    ----------\n    image : (M, N, C) ndarray\n        Input image. The axis corresponding to color channels can be specified\n        via the `channel_axis` argument.\n    ratio : float, optional, between 0 and 1\n        Balances color-space proximity and image-space proximity.\n        Higher values give more weight to color-space.\n    kernel_size : float, optional\n        Width of Gaussian kernel used in smoothing the\n        sample density. Higher means fewer clusters.\n    max_dist : float, optional\n        Cut-off point for data distances.\n        Higher means fewer clusters.\n    return_tree : bool, optional\n        Whether to return the full segmentation hierarchy tree and distances.\n    sigma : float, optional\n        Width for Gaussian smoothing as preprocessing. Zero means no smoothing.\n    convert2lab : bool, optional\n        Whether the input should be converted to Lab colorspace prior to\n        segmentation. For this purpose, the input is assumed to be RGB.\n    rng : {`numpy.random.Generator`, int}, optional\n        Pseudo-random number generator.\n        By default, a PCG64 generator is used (see :func:`numpy.random.default_rng`).\n        If `rng` is an int, it is used to seed the generator.\n\n        The PRNG is used to break ties, and is seeded with 42 by default.\n    channel_axis : int, optional\n        The axis of `image` corresponding to color channels. Defaults to the\n        last axis.\n\n    Returns\n    -------\n    segment_mask : (M, N) ndarray\n        Integer mask indicating segment labels.\n\n    Notes\n    -----\n    The authors advocate to convert the image to Lab color space prior to\n    segmentation, though this is not strictly necessary. For this to work, the\n    image must be given in RGB format.\n\n    References\n    ----------\n    .. [1] Quick shift and kernel methods for mode seeking,\n           Vedaldi, A. and Soatto, S.\n           European Conference on Computer Vision, 2008\n    \"\"\"\n    image = img_as_float(np.atleast_3d(image))\n    float_dtype = _supported_float_type(image.dtype)\n    image = image.astype(float_dtype, copy=False)\n    if image.ndim > 3:\n        raise ValueError('Only 2D color images are supported')\n    image = np.moveaxis(image, source=channel_axis, destination=-1)\n    if convert2lab:\n        if image.shape[-1] != 3:\n            raise ValueError('Only RGB images can be converted to Lab space.')\n        image = rgb2lab(image)\n    if kernel_size < 1:\n        raise ValueError('`kernel_size` should be >= 1.')\n    image = gaussian(image, [sigma, sigma, 0], mode='reflect', channel_axis=-1)\n    image = np.ascontiguousarray(image * ratio)\n    segment_mask = _quickshift_cython(image, kernel_size=kernel_size, max_dist=max_dist, return_tree=return_tree, rng=rng)\n    return segment_mask",
        "mutated": [
            "@deprecate_kwarg({'random_seed': 'rng'}, deprecated_version='0.21', removed_version='0.23')\ndef quickshift(image, ratio=1.0, kernel_size=5, max_dist=10, return_tree=False, sigma=0, convert2lab=True, rng=42, *, channel_axis=-1):\n    if False:\n        i = 10\n    'Segment image using quickshift clustering in Color-(x,y) space.\\n\\n    Produces an oversegmentation of the image using the quickshift mode-seeking\\n    algorithm.\\n\\n    Parameters\\n    ----------\\n    image : (M, N, C) ndarray\\n        Input image. The axis corresponding to color channels can be specified\\n        via the `channel_axis` argument.\\n    ratio : float, optional, between 0 and 1\\n        Balances color-space proximity and image-space proximity.\\n        Higher values give more weight to color-space.\\n    kernel_size : float, optional\\n        Width of Gaussian kernel used in smoothing the\\n        sample density. Higher means fewer clusters.\\n    max_dist : float, optional\\n        Cut-off point for data distances.\\n        Higher means fewer clusters.\\n    return_tree : bool, optional\\n        Whether to return the full segmentation hierarchy tree and distances.\\n    sigma : float, optional\\n        Width for Gaussian smoothing as preprocessing. Zero means no smoothing.\\n    convert2lab : bool, optional\\n        Whether the input should be converted to Lab colorspace prior to\\n        segmentation. For this purpose, the input is assumed to be RGB.\\n    rng : {`numpy.random.Generator`, int}, optional\\n        Pseudo-random number generator.\\n        By default, a PCG64 generator is used (see :func:`numpy.random.default_rng`).\\n        If `rng` is an int, it is used to seed the generator.\\n\\n        The PRNG is used to break ties, and is seeded with 42 by default.\\n    channel_axis : int, optional\\n        The axis of `image` corresponding to color channels. Defaults to the\\n        last axis.\\n\\n    Returns\\n    -------\\n    segment_mask : (M, N) ndarray\\n        Integer mask indicating segment labels.\\n\\n    Notes\\n    -----\\n    The authors advocate to convert the image to Lab color space prior to\\n    segmentation, though this is not strictly necessary. For this to work, the\\n    image must be given in RGB format.\\n\\n    References\\n    ----------\\n    .. [1] Quick shift and kernel methods for mode seeking,\\n           Vedaldi, A. and Soatto, S.\\n           European Conference on Computer Vision, 2008\\n    '\n    image = img_as_float(np.atleast_3d(image))\n    float_dtype = _supported_float_type(image.dtype)\n    image = image.astype(float_dtype, copy=False)\n    if image.ndim > 3:\n        raise ValueError('Only 2D color images are supported')\n    image = np.moveaxis(image, source=channel_axis, destination=-1)\n    if convert2lab:\n        if image.shape[-1] != 3:\n            raise ValueError('Only RGB images can be converted to Lab space.')\n        image = rgb2lab(image)\n    if kernel_size < 1:\n        raise ValueError('`kernel_size` should be >= 1.')\n    image = gaussian(image, [sigma, sigma, 0], mode='reflect', channel_axis=-1)\n    image = np.ascontiguousarray(image * ratio)\n    segment_mask = _quickshift_cython(image, kernel_size=kernel_size, max_dist=max_dist, return_tree=return_tree, rng=rng)\n    return segment_mask",
            "@deprecate_kwarg({'random_seed': 'rng'}, deprecated_version='0.21', removed_version='0.23')\ndef quickshift(image, ratio=1.0, kernel_size=5, max_dist=10, return_tree=False, sigma=0, convert2lab=True, rng=42, *, channel_axis=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Segment image using quickshift clustering in Color-(x,y) space.\\n\\n    Produces an oversegmentation of the image using the quickshift mode-seeking\\n    algorithm.\\n\\n    Parameters\\n    ----------\\n    image : (M, N, C) ndarray\\n        Input image. The axis corresponding to color channels can be specified\\n        via the `channel_axis` argument.\\n    ratio : float, optional, between 0 and 1\\n        Balances color-space proximity and image-space proximity.\\n        Higher values give more weight to color-space.\\n    kernel_size : float, optional\\n        Width of Gaussian kernel used in smoothing the\\n        sample density. Higher means fewer clusters.\\n    max_dist : float, optional\\n        Cut-off point for data distances.\\n        Higher means fewer clusters.\\n    return_tree : bool, optional\\n        Whether to return the full segmentation hierarchy tree and distances.\\n    sigma : float, optional\\n        Width for Gaussian smoothing as preprocessing. Zero means no smoothing.\\n    convert2lab : bool, optional\\n        Whether the input should be converted to Lab colorspace prior to\\n        segmentation. For this purpose, the input is assumed to be RGB.\\n    rng : {`numpy.random.Generator`, int}, optional\\n        Pseudo-random number generator.\\n        By default, a PCG64 generator is used (see :func:`numpy.random.default_rng`).\\n        If `rng` is an int, it is used to seed the generator.\\n\\n        The PRNG is used to break ties, and is seeded with 42 by default.\\n    channel_axis : int, optional\\n        The axis of `image` corresponding to color channels. Defaults to the\\n        last axis.\\n\\n    Returns\\n    -------\\n    segment_mask : (M, N) ndarray\\n        Integer mask indicating segment labels.\\n\\n    Notes\\n    -----\\n    The authors advocate to convert the image to Lab color space prior to\\n    segmentation, though this is not strictly necessary. For this to work, the\\n    image must be given in RGB format.\\n\\n    References\\n    ----------\\n    .. [1] Quick shift and kernel methods for mode seeking,\\n           Vedaldi, A. and Soatto, S.\\n           European Conference on Computer Vision, 2008\\n    '\n    image = img_as_float(np.atleast_3d(image))\n    float_dtype = _supported_float_type(image.dtype)\n    image = image.astype(float_dtype, copy=False)\n    if image.ndim > 3:\n        raise ValueError('Only 2D color images are supported')\n    image = np.moveaxis(image, source=channel_axis, destination=-1)\n    if convert2lab:\n        if image.shape[-1] != 3:\n            raise ValueError('Only RGB images can be converted to Lab space.')\n        image = rgb2lab(image)\n    if kernel_size < 1:\n        raise ValueError('`kernel_size` should be >= 1.')\n    image = gaussian(image, [sigma, sigma, 0], mode='reflect', channel_axis=-1)\n    image = np.ascontiguousarray(image * ratio)\n    segment_mask = _quickshift_cython(image, kernel_size=kernel_size, max_dist=max_dist, return_tree=return_tree, rng=rng)\n    return segment_mask",
            "@deprecate_kwarg({'random_seed': 'rng'}, deprecated_version='0.21', removed_version='0.23')\ndef quickshift(image, ratio=1.0, kernel_size=5, max_dist=10, return_tree=False, sigma=0, convert2lab=True, rng=42, *, channel_axis=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Segment image using quickshift clustering in Color-(x,y) space.\\n\\n    Produces an oversegmentation of the image using the quickshift mode-seeking\\n    algorithm.\\n\\n    Parameters\\n    ----------\\n    image : (M, N, C) ndarray\\n        Input image. The axis corresponding to color channels can be specified\\n        via the `channel_axis` argument.\\n    ratio : float, optional, between 0 and 1\\n        Balances color-space proximity and image-space proximity.\\n        Higher values give more weight to color-space.\\n    kernel_size : float, optional\\n        Width of Gaussian kernel used in smoothing the\\n        sample density. Higher means fewer clusters.\\n    max_dist : float, optional\\n        Cut-off point for data distances.\\n        Higher means fewer clusters.\\n    return_tree : bool, optional\\n        Whether to return the full segmentation hierarchy tree and distances.\\n    sigma : float, optional\\n        Width for Gaussian smoothing as preprocessing. Zero means no smoothing.\\n    convert2lab : bool, optional\\n        Whether the input should be converted to Lab colorspace prior to\\n        segmentation. For this purpose, the input is assumed to be RGB.\\n    rng : {`numpy.random.Generator`, int}, optional\\n        Pseudo-random number generator.\\n        By default, a PCG64 generator is used (see :func:`numpy.random.default_rng`).\\n        If `rng` is an int, it is used to seed the generator.\\n\\n        The PRNG is used to break ties, and is seeded with 42 by default.\\n    channel_axis : int, optional\\n        The axis of `image` corresponding to color channels. Defaults to the\\n        last axis.\\n\\n    Returns\\n    -------\\n    segment_mask : (M, N) ndarray\\n        Integer mask indicating segment labels.\\n\\n    Notes\\n    -----\\n    The authors advocate to convert the image to Lab color space prior to\\n    segmentation, though this is not strictly necessary. For this to work, the\\n    image must be given in RGB format.\\n\\n    References\\n    ----------\\n    .. [1] Quick shift and kernel methods for mode seeking,\\n           Vedaldi, A. and Soatto, S.\\n           European Conference on Computer Vision, 2008\\n    '\n    image = img_as_float(np.atleast_3d(image))\n    float_dtype = _supported_float_type(image.dtype)\n    image = image.astype(float_dtype, copy=False)\n    if image.ndim > 3:\n        raise ValueError('Only 2D color images are supported')\n    image = np.moveaxis(image, source=channel_axis, destination=-1)\n    if convert2lab:\n        if image.shape[-1] != 3:\n            raise ValueError('Only RGB images can be converted to Lab space.')\n        image = rgb2lab(image)\n    if kernel_size < 1:\n        raise ValueError('`kernel_size` should be >= 1.')\n    image = gaussian(image, [sigma, sigma, 0], mode='reflect', channel_axis=-1)\n    image = np.ascontiguousarray(image * ratio)\n    segment_mask = _quickshift_cython(image, kernel_size=kernel_size, max_dist=max_dist, return_tree=return_tree, rng=rng)\n    return segment_mask",
            "@deprecate_kwarg({'random_seed': 'rng'}, deprecated_version='0.21', removed_version='0.23')\ndef quickshift(image, ratio=1.0, kernel_size=5, max_dist=10, return_tree=False, sigma=0, convert2lab=True, rng=42, *, channel_axis=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Segment image using quickshift clustering in Color-(x,y) space.\\n\\n    Produces an oversegmentation of the image using the quickshift mode-seeking\\n    algorithm.\\n\\n    Parameters\\n    ----------\\n    image : (M, N, C) ndarray\\n        Input image. The axis corresponding to color channels can be specified\\n        via the `channel_axis` argument.\\n    ratio : float, optional, between 0 and 1\\n        Balances color-space proximity and image-space proximity.\\n        Higher values give more weight to color-space.\\n    kernel_size : float, optional\\n        Width of Gaussian kernel used in smoothing the\\n        sample density. Higher means fewer clusters.\\n    max_dist : float, optional\\n        Cut-off point for data distances.\\n        Higher means fewer clusters.\\n    return_tree : bool, optional\\n        Whether to return the full segmentation hierarchy tree and distances.\\n    sigma : float, optional\\n        Width for Gaussian smoothing as preprocessing. Zero means no smoothing.\\n    convert2lab : bool, optional\\n        Whether the input should be converted to Lab colorspace prior to\\n        segmentation. For this purpose, the input is assumed to be RGB.\\n    rng : {`numpy.random.Generator`, int}, optional\\n        Pseudo-random number generator.\\n        By default, a PCG64 generator is used (see :func:`numpy.random.default_rng`).\\n        If `rng` is an int, it is used to seed the generator.\\n\\n        The PRNG is used to break ties, and is seeded with 42 by default.\\n    channel_axis : int, optional\\n        The axis of `image` corresponding to color channels. Defaults to the\\n        last axis.\\n\\n    Returns\\n    -------\\n    segment_mask : (M, N) ndarray\\n        Integer mask indicating segment labels.\\n\\n    Notes\\n    -----\\n    The authors advocate to convert the image to Lab color space prior to\\n    segmentation, though this is not strictly necessary. For this to work, the\\n    image must be given in RGB format.\\n\\n    References\\n    ----------\\n    .. [1] Quick shift and kernel methods for mode seeking,\\n           Vedaldi, A. and Soatto, S.\\n           European Conference on Computer Vision, 2008\\n    '\n    image = img_as_float(np.atleast_3d(image))\n    float_dtype = _supported_float_type(image.dtype)\n    image = image.astype(float_dtype, copy=False)\n    if image.ndim > 3:\n        raise ValueError('Only 2D color images are supported')\n    image = np.moveaxis(image, source=channel_axis, destination=-1)\n    if convert2lab:\n        if image.shape[-1] != 3:\n            raise ValueError('Only RGB images can be converted to Lab space.')\n        image = rgb2lab(image)\n    if kernel_size < 1:\n        raise ValueError('`kernel_size` should be >= 1.')\n    image = gaussian(image, [sigma, sigma, 0], mode='reflect', channel_axis=-1)\n    image = np.ascontiguousarray(image * ratio)\n    segment_mask = _quickshift_cython(image, kernel_size=kernel_size, max_dist=max_dist, return_tree=return_tree, rng=rng)\n    return segment_mask",
            "@deprecate_kwarg({'random_seed': 'rng'}, deprecated_version='0.21', removed_version='0.23')\ndef quickshift(image, ratio=1.0, kernel_size=5, max_dist=10, return_tree=False, sigma=0, convert2lab=True, rng=42, *, channel_axis=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Segment image using quickshift clustering in Color-(x,y) space.\\n\\n    Produces an oversegmentation of the image using the quickshift mode-seeking\\n    algorithm.\\n\\n    Parameters\\n    ----------\\n    image : (M, N, C) ndarray\\n        Input image. The axis corresponding to color channels can be specified\\n        via the `channel_axis` argument.\\n    ratio : float, optional, between 0 and 1\\n        Balances color-space proximity and image-space proximity.\\n        Higher values give more weight to color-space.\\n    kernel_size : float, optional\\n        Width of Gaussian kernel used in smoothing the\\n        sample density. Higher means fewer clusters.\\n    max_dist : float, optional\\n        Cut-off point for data distances.\\n        Higher means fewer clusters.\\n    return_tree : bool, optional\\n        Whether to return the full segmentation hierarchy tree and distances.\\n    sigma : float, optional\\n        Width for Gaussian smoothing as preprocessing. Zero means no smoothing.\\n    convert2lab : bool, optional\\n        Whether the input should be converted to Lab colorspace prior to\\n        segmentation. For this purpose, the input is assumed to be RGB.\\n    rng : {`numpy.random.Generator`, int}, optional\\n        Pseudo-random number generator.\\n        By default, a PCG64 generator is used (see :func:`numpy.random.default_rng`).\\n        If `rng` is an int, it is used to seed the generator.\\n\\n        The PRNG is used to break ties, and is seeded with 42 by default.\\n    channel_axis : int, optional\\n        The axis of `image` corresponding to color channels. Defaults to the\\n        last axis.\\n\\n    Returns\\n    -------\\n    segment_mask : (M, N) ndarray\\n        Integer mask indicating segment labels.\\n\\n    Notes\\n    -----\\n    The authors advocate to convert the image to Lab color space prior to\\n    segmentation, though this is not strictly necessary. For this to work, the\\n    image must be given in RGB format.\\n\\n    References\\n    ----------\\n    .. [1] Quick shift and kernel methods for mode seeking,\\n           Vedaldi, A. and Soatto, S.\\n           European Conference on Computer Vision, 2008\\n    '\n    image = img_as_float(np.atleast_3d(image))\n    float_dtype = _supported_float_type(image.dtype)\n    image = image.astype(float_dtype, copy=False)\n    if image.ndim > 3:\n        raise ValueError('Only 2D color images are supported')\n    image = np.moveaxis(image, source=channel_axis, destination=-1)\n    if convert2lab:\n        if image.shape[-1] != 3:\n            raise ValueError('Only RGB images can be converted to Lab space.')\n        image = rgb2lab(image)\n    if kernel_size < 1:\n        raise ValueError('`kernel_size` should be >= 1.')\n    image = gaussian(image, [sigma, sigma, 0], mode='reflect', channel_axis=-1)\n    image = np.ascontiguousarray(image * ratio)\n    segment_mask = _quickshift_cython(image, kernel_size=kernel_size, max_dist=max_dist, return_tree=return_tree, rng=rng)\n    return segment_mask"
        ]
    }
]