[
    {
        "func_name": "channel_capacity",
        "original": "def channel_capacity(n, m, sum_x: float=1.0):\n    \"\"\"\nBoyd and Vandenberghe, Convex Optimization, exercise 4.57 page 207\nCapacity of a communication channel.\n\nWe consider a communication channel, with input x(t)\u2208{1,..,n} and\noutput Y(t)\u2208{1,...,m}, for t=1,2,... .The relation between the\ninput and output is given statistically:\np_(i,j) = \u2119(Y(t)=i|X(t)=j), i=1,..,m  j=1,...,m\nThe matrix P \u2208 \u211d^(m*n) is called the channel transition matrix, and\nthe channel is called a discrete memoryless channel. Assuming X has a\nprobability distribution denoted x \u2208 \u211d^n, i.e.,\nx_j = \u2119(X=j), j=1,...,n\nThe mutual information between X and Y is given by\n\u2211(\u2211(x_j p_(i,j)log_2(p_(i,j)/\u2211(x_k p_(i,k)))))\nThen channel capacity C is given by\nC = sup I(X;Y).\nWith a variable change of y = Px this becomes\nI(X;Y)=  c^T x - \u2211(y_i log_2 y_i)\nwhere c_j = \u2211(p_(i,j)log_2(p_(i,j)))\n  \"\"\"\n    if n * m == 0:\n        print('The range of both input and output values must be greater than zero')\n        return ('failed', np.nan, np.nan)\n    P = np.ones((m, n))\n    x = cvx.Variable(rows=n, cols=1)\n    y = P * x\n    c = np.sum(P * np.log2(P), axis=0)\n    I = c * x + cvx.sum(cvx.entr(y))\n    obj = cvx.Minimize(-I)\n    constraints = [cvx.sum(x) == sum_x, x >= 0]\n    prob = cvx.Problem(obj, constraints)\n    prob.solve()\n    if prob.status == 'optimal':\n        return (prob.status, prob.value, x.value)\n    else:\n        return (prob.status, np.nan, np.nan)",
        "mutated": [
            "def channel_capacity(n, m, sum_x: float=1.0):\n    if False:\n        i = 10\n    '\\nBoyd and Vandenberghe, Convex Optimization, exercise 4.57 page 207\\nCapacity of a communication channel.\\n\\nWe consider a communication channel, with input x(t)\u2208{1,..,n} and\\noutput Y(t)\u2208{1,...,m}, for t=1,2,... .The relation between the\\ninput and output is given statistically:\\np_(i,j) = \u2119(Y(t)=i|X(t)=j), i=1,..,m  j=1,...,m\\nThe matrix P \u2208 \u211d^(m*n) is called the channel transition matrix, and\\nthe channel is called a discrete memoryless channel. Assuming X has a\\nprobability distribution denoted x \u2208 \u211d^n, i.e.,\\nx_j = \u2119(X=j), j=1,...,n\\nThe mutual information between X and Y is given by\\n\u2211(\u2211(x_j p_(i,j)log_2(p_(i,j)/\u2211(x_k p_(i,k)))))\\nThen channel capacity C is given by\\nC = sup I(X;Y).\\nWith a variable change of y = Px this becomes\\nI(X;Y)=  c^T x - \u2211(y_i log_2 y_i)\\nwhere c_j = \u2211(p_(i,j)log_2(p_(i,j)))\\n  '\n    if n * m == 0:\n        print('The range of both input and output values must be greater than zero')\n        return ('failed', np.nan, np.nan)\n    P = np.ones((m, n))\n    x = cvx.Variable(rows=n, cols=1)\n    y = P * x\n    c = np.sum(P * np.log2(P), axis=0)\n    I = c * x + cvx.sum(cvx.entr(y))\n    obj = cvx.Minimize(-I)\n    constraints = [cvx.sum(x) == sum_x, x >= 0]\n    prob = cvx.Problem(obj, constraints)\n    prob.solve()\n    if prob.status == 'optimal':\n        return (prob.status, prob.value, x.value)\n    else:\n        return (prob.status, np.nan, np.nan)",
            "def channel_capacity(n, m, sum_x: float=1.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\nBoyd and Vandenberghe, Convex Optimization, exercise 4.57 page 207\\nCapacity of a communication channel.\\n\\nWe consider a communication channel, with input x(t)\u2208{1,..,n} and\\noutput Y(t)\u2208{1,...,m}, for t=1,2,... .The relation between the\\ninput and output is given statistically:\\np_(i,j) = \u2119(Y(t)=i|X(t)=j), i=1,..,m  j=1,...,m\\nThe matrix P \u2208 \u211d^(m*n) is called the channel transition matrix, and\\nthe channel is called a discrete memoryless channel. Assuming X has a\\nprobability distribution denoted x \u2208 \u211d^n, i.e.,\\nx_j = \u2119(X=j), j=1,...,n\\nThe mutual information between X and Y is given by\\n\u2211(\u2211(x_j p_(i,j)log_2(p_(i,j)/\u2211(x_k p_(i,k)))))\\nThen channel capacity C is given by\\nC = sup I(X;Y).\\nWith a variable change of y = Px this becomes\\nI(X;Y)=  c^T x - \u2211(y_i log_2 y_i)\\nwhere c_j = \u2211(p_(i,j)log_2(p_(i,j)))\\n  '\n    if n * m == 0:\n        print('The range of both input and output values must be greater than zero')\n        return ('failed', np.nan, np.nan)\n    P = np.ones((m, n))\n    x = cvx.Variable(rows=n, cols=1)\n    y = P * x\n    c = np.sum(P * np.log2(P), axis=0)\n    I = c * x + cvx.sum(cvx.entr(y))\n    obj = cvx.Minimize(-I)\n    constraints = [cvx.sum(x) == sum_x, x >= 0]\n    prob = cvx.Problem(obj, constraints)\n    prob.solve()\n    if prob.status == 'optimal':\n        return (prob.status, prob.value, x.value)\n    else:\n        return (prob.status, np.nan, np.nan)",
            "def channel_capacity(n, m, sum_x: float=1.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\nBoyd and Vandenberghe, Convex Optimization, exercise 4.57 page 207\\nCapacity of a communication channel.\\n\\nWe consider a communication channel, with input x(t)\u2208{1,..,n} and\\noutput Y(t)\u2208{1,...,m}, for t=1,2,... .The relation between the\\ninput and output is given statistically:\\np_(i,j) = \u2119(Y(t)=i|X(t)=j), i=1,..,m  j=1,...,m\\nThe matrix P \u2208 \u211d^(m*n) is called the channel transition matrix, and\\nthe channel is called a discrete memoryless channel. Assuming X has a\\nprobability distribution denoted x \u2208 \u211d^n, i.e.,\\nx_j = \u2119(X=j), j=1,...,n\\nThe mutual information between X and Y is given by\\n\u2211(\u2211(x_j p_(i,j)log_2(p_(i,j)/\u2211(x_k p_(i,k)))))\\nThen channel capacity C is given by\\nC = sup I(X;Y).\\nWith a variable change of y = Px this becomes\\nI(X;Y)=  c^T x - \u2211(y_i log_2 y_i)\\nwhere c_j = \u2211(p_(i,j)log_2(p_(i,j)))\\n  '\n    if n * m == 0:\n        print('The range of both input and output values must be greater than zero')\n        return ('failed', np.nan, np.nan)\n    P = np.ones((m, n))\n    x = cvx.Variable(rows=n, cols=1)\n    y = P * x\n    c = np.sum(P * np.log2(P), axis=0)\n    I = c * x + cvx.sum(cvx.entr(y))\n    obj = cvx.Minimize(-I)\n    constraints = [cvx.sum(x) == sum_x, x >= 0]\n    prob = cvx.Problem(obj, constraints)\n    prob.solve()\n    if prob.status == 'optimal':\n        return (prob.status, prob.value, x.value)\n    else:\n        return (prob.status, np.nan, np.nan)",
            "def channel_capacity(n, m, sum_x: float=1.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\nBoyd and Vandenberghe, Convex Optimization, exercise 4.57 page 207\\nCapacity of a communication channel.\\n\\nWe consider a communication channel, with input x(t)\u2208{1,..,n} and\\noutput Y(t)\u2208{1,...,m}, for t=1,2,... .The relation between the\\ninput and output is given statistically:\\np_(i,j) = \u2119(Y(t)=i|X(t)=j), i=1,..,m  j=1,...,m\\nThe matrix P \u2208 \u211d^(m*n) is called the channel transition matrix, and\\nthe channel is called a discrete memoryless channel. Assuming X has a\\nprobability distribution denoted x \u2208 \u211d^n, i.e.,\\nx_j = \u2119(X=j), j=1,...,n\\nThe mutual information between X and Y is given by\\n\u2211(\u2211(x_j p_(i,j)log_2(p_(i,j)/\u2211(x_k p_(i,k)))))\\nThen channel capacity C is given by\\nC = sup I(X;Y).\\nWith a variable change of y = Px this becomes\\nI(X;Y)=  c^T x - \u2211(y_i log_2 y_i)\\nwhere c_j = \u2211(p_(i,j)log_2(p_(i,j)))\\n  '\n    if n * m == 0:\n        print('The range of both input and output values must be greater than zero')\n        return ('failed', np.nan, np.nan)\n    P = np.ones((m, n))\n    x = cvx.Variable(rows=n, cols=1)\n    y = P * x\n    c = np.sum(P * np.log2(P), axis=0)\n    I = c * x + cvx.sum(cvx.entr(y))\n    obj = cvx.Minimize(-I)\n    constraints = [cvx.sum(x) == sum_x, x >= 0]\n    prob = cvx.Problem(obj, constraints)\n    prob.solve()\n    if prob.status == 'optimal':\n        return (prob.status, prob.value, x.value)\n    else:\n        return (prob.status, np.nan, np.nan)",
            "def channel_capacity(n, m, sum_x: float=1.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\nBoyd and Vandenberghe, Convex Optimization, exercise 4.57 page 207\\nCapacity of a communication channel.\\n\\nWe consider a communication channel, with input x(t)\u2208{1,..,n} and\\noutput Y(t)\u2208{1,...,m}, for t=1,2,... .The relation between the\\ninput and output is given statistically:\\np_(i,j) = \u2119(Y(t)=i|X(t)=j), i=1,..,m  j=1,...,m\\nThe matrix P \u2208 \u211d^(m*n) is called the channel transition matrix, and\\nthe channel is called a discrete memoryless channel. Assuming X has a\\nprobability distribution denoted x \u2208 \u211d^n, i.e.,\\nx_j = \u2119(X=j), j=1,...,n\\nThe mutual information between X and Y is given by\\n\u2211(\u2211(x_j p_(i,j)log_2(p_(i,j)/\u2211(x_k p_(i,k)))))\\nThen channel capacity C is given by\\nC = sup I(X;Y).\\nWith a variable change of y = Px this becomes\\nI(X;Y)=  c^T x - \u2211(y_i log_2 y_i)\\nwhere c_j = \u2211(p_(i,j)log_2(p_(i,j)))\\n  '\n    if n * m == 0:\n        print('The range of both input and output values must be greater than zero')\n        return ('failed', np.nan, np.nan)\n    P = np.ones((m, n))\n    x = cvx.Variable(rows=n, cols=1)\n    y = P * x\n    c = np.sum(P * np.log2(P), axis=0)\n    I = c * x + cvx.sum(cvx.entr(y))\n    obj = cvx.Minimize(-I)\n    constraints = [cvx.sum(x) == sum_x, x >= 0]\n    prob = cvx.Problem(obj, constraints)\n    prob.solve()\n    if prob.status == 'optimal':\n        return (prob.status, prob.value, x.value)\n    else:\n        return (prob.status, np.nan, np.nan)"
        ]
    }
]