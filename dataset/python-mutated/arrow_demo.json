[
    {
        "func_name": "make_arrow_graph",
        "original": "def make_arrow_graph(ax, data, size=4, display='length', shape='right', max_arrow_width=0.03, arrow_sep=0.02, alpha=0.5, normalize_data=False, ec=None, labelcolor=None, **kwargs):\n    \"\"\"\n    Makes an arrow plot.\n\n    Parameters\n    ----------\n    ax\n        The axes where the graph is drawn.\n    data\n        Dict with probabilities for the bases and pair transitions.\n    size\n        Size of the plot, in inches.\n    display : {'length', 'width', 'alpha'}\n        The arrow property to change.\n    shape : {'full', 'left', 'right'}\n        For full or half arrows.\n    max_arrow_width : float\n        Maximum width of an arrow, in data coordinates.\n    arrow_sep : float\n        Separation between arrows in a pair, in data coordinates.\n    alpha : float\n        Maximum opacity of arrows.\n    **kwargs\n        `.FancyArrow` properties, e.g. *linewidth* or *edgecolor*.\n    \"\"\"\n    ax.set(xlim=(-0.25, 1.25), ylim=(-0.25, 1.25), xticks=[], yticks=[], title=f'flux encoded as arrow {display}')\n    max_text_size = size * 12\n    min_text_size = size\n    label_text_size = size * 4\n    bases = 'ATGC'\n    coords = {'A': np.array([0, 1]), 'T': np.array([1, 1]), 'G': np.array([0, 0]), 'C': np.array([1, 0])}\n    colors = {'A': 'r', 'T': 'k', 'G': 'g', 'C': 'b'}\n    for base in bases:\n        fontsize = np.clip(max_text_size * data[base] ** (1 / 2), min_text_size, max_text_size)\n        ax.text(*coords[base], f'${base}_3$', color=colors[base], size=fontsize, horizontalalignment='center', verticalalignment='center', weight='bold')\n    arrow_h_offset = 0.25\n    max_arrow_length = 1 - 2 * arrow_h_offset\n    max_head_width = 2.5 * max_arrow_width\n    max_head_length = 2 * max_arrow_width\n    sf = 0.6\n    if normalize_data:\n        max_val = max((v for (k, v) in data.items() if len(k) == 2), default=0)\n        for (k, v) in data.items():\n            data[k] = v / max_val * sf\n    for pair in map(''.join, itertools.permutations(bases, 2)):\n        if display == 'length':\n            length = max_head_length + data[pair] / sf * (max_arrow_length - max_head_length)\n        else:\n            length = max_arrow_length\n        if display == 'alpha':\n            alpha = min(data[pair] / sf, alpha)\n        if display == 'width':\n            scale = data[pair] / sf\n            width = max_arrow_width * scale\n            head_width = max_head_width * scale\n            head_length = max_head_length * scale\n        else:\n            width = max_arrow_width\n            head_width = max_head_width\n            head_length = max_head_length\n        fc = colors[pair[0]]\n        cp0 = coords[pair[0]]\n        cp1 = coords[pair[1]]\n        delta = (cos, sin) = (cp1 - cp0) / np.hypot(*cp1 - cp0)\n        (x_pos, y_pos) = (cp0 + cp1) / 2 - delta * length / 2 + np.array([-sin, cos]) * arrow_sep\n        ax.arrow(x_pos, y_pos, cos * length, sin * length, fc=fc, ec=ec or fc, alpha=alpha, width=width, head_width=head_width, head_length=head_length, shape=shape, length_includes_head=True, **kwargs)\n        orig_positions = {'base': [3 * max_arrow_width, 3 * max_arrow_width], 'center': [length / 2, 3 * max_arrow_width], 'tip': [length - 3 * max_arrow_width, 3 * max_arrow_width]}\n        where = 'base' if (cp0 != cp1).all() else 'center'\n        M = [[cos, -sin], [sin, cos]]\n        (x, y) = np.dot(M, orig_positions[where]) + [x_pos, y_pos]\n        label = '$r_{_{\\\\mathrm{%s}}}$' % (pair,)\n        ax.text(x, y, label, size=label_text_size, ha='center', va='center', color=labelcolor or fc)",
        "mutated": [
            "def make_arrow_graph(ax, data, size=4, display='length', shape='right', max_arrow_width=0.03, arrow_sep=0.02, alpha=0.5, normalize_data=False, ec=None, labelcolor=None, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Makes an arrow plot.\\n\\n    Parameters\\n    ----------\\n    ax\\n        The axes where the graph is drawn.\\n    data\\n        Dict with probabilities for the bases and pair transitions.\\n    size\\n        Size of the plot, in inches.\\n    display : {'length', 'width', 'alpha'}\\n        The arrow property to change.\\n    shape : {'full', 'left', 'right'}\\n        For full or half arrows.\\n    max_arrow_width : float\\n        Maximum width of an arrow, in data coordinates.\\n    arrow_sep : float\\n        Separation between arrows in a pair, in data coordinates.\\n    alpha : float\\n        Maximum opacity of arrows.\\n    **kwargs\\n        `.FancyArrow` properties, e.g. *linewidth* or *edgecolor*.\\n    \"\n    ax.set(xlim=(-0.25, 1.25), ylim=(-0.25, 1.25), xticks=[], yticks=[], title=f'flux encoded as arrow {display}')\n    max_text_size = size * 12\n    min_text_size = size\n    label_text_size = size * 4\n    bases = 'ATGC'\n    coords = {'A': np.array([0, 1]), 'T': np.array([1, 1]), 'G': np.array([0, 0]), 'C': np.array([1, 0])}\n    colors = {'A': 'r', 'T': 'k', 'G': 'g', 'C': 'b'}\n    for base in bases:\n        fontsize = np.clip(max_text_size * data[base] ** (1 / 2), min_text_size, max_text_size)\n        ax.text(*coords[base], f'${base}_3$', color=colors[base], size=fontsize, horizontalalignment='center', verticalalignment='center', weight='bold')\n    arrow_h_offset = 0.25\n    max_arrow_length = 1 - 2 * arrow_h_offset\n    max_head_width = 2.5 * max_arrow_width\n    max_head_length = 2 * max_arrow_width\n    sf = 0.6\n    if normalize_data:\n        max_val = max((v for (k, v) in data.items() if len(k) == 2), default=0)\n        for (k, v) in data.items():\n            data[k] = v / max_val * sf\n    for pair in map(''.join, itertools.permutations(bases, 2)):\n        if display == 'length':\n            length = max_head_length + data[pair] / sf * (max_arrow_length - max_head_length)\n        else:\n            length = max_arrow_length\n        if display == 'alpha':\n            alpha = min(data[pair] / sf, alpha)\n        if display == 'width':\n            scale = data[pair] / sf\n            width = max_arrow_width * scale\n            head_width = max_head_width * scale\n            head_length = max_head_length * scale\n        else:\n            width = max_arrow_width\n            head_width = max_head_width\n            head_length = max_head_length\n        fc = colors[pair[0]]\n        cp0 = coords[pair[0]]\n        cp1 = coords[pair[1]]\n        delta = (cos, sin) = (cp1 - cp0) / np.hypot(*cp1 - cp0)\n        (x_pos, y_pos) = (cp0 + cp1) / 2 - delta * length / 2 + np.array([-sin, cos]) * arrow_sep\n        ax.arrow(x_pos, y_pos, cos * length, sin * length, fc=fc, ec=ec or fc, alpha=alpha, width=width, head_width=head_width, head_length=head_length, shape=shape, length_includes_head=True, **kwargs)\n        orig_positions = {'base': [3 * max_arrow_width, 3 * max_arrow_width], 'center': [length / 2, 3 * max_arrow_width], 'tip': [length - 3 * max_arrow_width, 3 * max_arrow_width]}\n        where = 'base' if (cp0 != cp1).all() else 'center'\n        M = [[cos, -sin], [sin, cos]]\n        (x, y) = np.dot(M, orig_positions[where]) + [x_pos, y_pos]\n        label = '$r_{_{\\\\mathrm{%s}}}$' % (pair,)\n        ax.text(x, y, label, size=label_text_size, ha='center', va='center', color=labelcolor or fc)",
            "def make_arrow_graph(ax, data, size=4, display='length', shape='right', max_arrow_width=0.03, arrow_sep=0.02, alpha=0.5, normalize_data=False, ec=None, labelcolor=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Makes an arrow plot.\\n\\n    Parameters\\n    ----------\\n    ax\\n        The axes where the graph is drawn.\\n    data\\n        Dict with probabilities for the bases and pair transitions.\\n    size\\n        Size of the plot, in inches.\\n    display : {'length', 'width', 'alpha'}\\n        The arrow property to change.\\n    shape : {'full', 'left', 'right'}\\n        For full or half arrows.\\n    max_arrow_width : float\\n        Maximum width of an arrow, in data coordinates.\\n    arrow_sep : float\\n        Separation between arrows in a pair, in data coordinates.\\n    alpha : float\\n        Maximum opacity of arrows.\\n    **kwargs\\n        `.FancyArrow` properties, e.g. *linewidth* or *edgecolor*.\\n    \"\n    ax.set(xlim=(-0.25, 1.25), ylim=(-0.25, 1.25), xticks=[], yticks=[], title=f'flux encoded as arrow {display}')\n    max_text_size = size * 12\n    min_text_size = size\n    label_text_size = size * 4\n    bases = 'ATGC'\n    coords = {'A': np.array([0, 1]), 'T': np.array([1, 1]), 'G': np.array([0, 0]), 'C': np.array([1, 0])}\n    colors = {'A': 'r', 'T': 'k', 'G': 'g', 'C': 'b'}\n    for base in bases:\n        fontsize = np.clip(max_text_size * data[base] ** (1 / 2), min_text_size, max_text_size)\n        ax.text(*coords[base], f'${base}_3$', color=colors[base], size=fontsize, horizontalalignment='center', verticalalignment='center', weight='bold')\n    arrow_h_offset = 0.25\n    max_arrow_length = 1 - 2 * arrow_h_offset\n    max_head_width = 2.5 * max_arrow_width\n    max_head_length = 2 * max_arrow_width\n    sf = 0.6\n    if normalize_data:\n        max_val = max((v for (k, v) in data.items() if len(k) == 2), default=0)\n        for (k, v) in data.items():\n            data[k] = v / max_val * sf\n    for pair in map(''.join, itertools.permutations(bases, 2)):\n        if display == 'length':\n            length = max_head_length + data[pair] / sf * (max_arrow_length - max_head_length)\n        else:\n            length = max_arrow_length\n        if display == 'alpha':\n            alpha = min(data[pair] / sf, alpha)\n        if display == 'width':\n            scale = data[pair] / sf\n            width = max_arrow_width * scale\n            head_width = max_head_width * scale\n            head_length = max_head_length * scale\n        else:\n            width = max_arrow_width\n            head_width = max_head_width\n            head_length = max_head_length\n        fc = colors[pair[0]]\n        cp0 = coords[pair[0]]\n        cp1 = coords[pair[1]]\n        delta = (cos, sin) = (cp1 - cp0) / np.hypot(*cp1 - cp0)\n        (x_pos, y_pos) = (cp0 + cp1) / 2 - delta * length / 2 + np.array([-sin, cos]) * arrow_sep\n        ax.arrow(x_pos, y_pos, cos * length, sin * length, fc=fc, ec=ec or fc, alpha=alpha, width=width, head_width=head_width, head_length=head_length, shape=shape, length_includes_head=True, **kwargs)\n        orig_positions = {'base': [3 * max_arrow_width, 3 * max_arrow_width], 'center': [length / 2, 3 * max_arrow_width], 'tip': [length - 3 * max_arrow_width, 3 * max_arrow_width]}\n        where = 'base' if (cp0 != cp1).all() else 'center'\n        M = [[cos, -sin], [sin, cos]]\n        (x, y) = np.dot(M, orig_positions[where]) + [x_pos, y_pos]\n        label = '$r_{_{\\\\mathrm{%s}}}$' % (pair,)\n        ax.text(x, y, label, size=label_text_size, ha='center', va='center', color=labelcolor or fc)",
            "def make_arrow_graph(ax, data, size=4, display='length', shape='right', max_arrow_width=0.03, arrow_sep=0.02, alpha=0.5, normalize_data=False, ec=None, labelcolor=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Makes an arrow plot.\\n\\n    Parameters\\n    ----------\\n    ax\\n        The axes where the graph is drawn.\\n    data\\n        Dict with probabilities for the bases and pair transitions.\\n    size\\n        Size of the plot, in inches.\\n    display : {'length', 'width', 'alpha'}\\n        The arrow property to change.\\n    shape : {'full', 'left', 'right'}\\n        For full or half arrows.\\n    max_arrow_width : float\\n        Maximum width of an arrow, in data coordinates.\\n    arrow_sep : float\\n        Separation between arrows in a pair, in data coordinates.\\n    alpha : float\\n        Maximum opacity of arrows.\\n    **kwargs\\n        `.FancyArrow` properties, e.g. *linewidth* or *edgecolor*.\\n    \"\n    ax.set(xlim=(-0.25, 1.25), ylim=(-0.25, 1.25), xticks=[], yticks=[], title=f'flux encoded as arrow {display}')\n    max_text_size = size * 12\n    min_text_size = size\n    label_text_size = size * 4\n    bases = 'ATGC'\n    coords = {'A': np.array([0, 1]), 'T': np.array([1, 1]), 'G': np.array([0, 0]), 'C': np.array([1, 0])}\n    colors = {'A': 'r', 'T': 'k', 'G': 'g', 'C': 'b'}\n    for base in bases:\n        fontsize = np.clip(max_text_size * data[base] ** (1 / 2), min_text_size, max_text_size)\n        ax.text(*coords[base], f'${base}_3$', color=colors[base], size=fontsize, horizontalalignment='center', verticalalignment='center', weight='bold')\n    arrow_h_offset = 0.25\n    max_arrow_length = 1 - 2 * arrow_h_offset\n    max_head_width = 2.5 * max_arrow_width\n    max_head_length = 2 * max_arrow_width\n    sf = 0.6\n    if normalize_data:\n        max_val = max((v for (k, v) in data.items() if len(k) == 2), default=0)\n        for (k, v) in data.items():\n            data[k] = v / max_val * sf\n    for pair in map(''.join, itertools.permutations(bases, 2)):\n        if display == 'length':\n            length = max_head_length + data[pair] / sf * (max_arrow_length - max_head_length)\n        else:\n            length = max_arrow_length\n        if display == 'alpha':\n            alpha = min(data[pair] / sf, alpha)\n        if display == 'width':\n            scale = data[pair] / sf\n            width = max_arrow_width * scale\n            head_width = max_head_width * scale\n            head_length = max_head_length * scale\n        else:\n            width = max_arrow_width\n            head_width = max_head_width\n            head_length = max_head_length\n        fc = colors[pair[0]]\n        cp0 = coords[pair[0]]\n        cp1 = coords[pair[1]]\n        delta = (cos, sin) = (cp1 - cp0) / np.hypot(*cp1 - cp0)\n        (x_pos, y_pos) = (cp0 + cp1) / 2 - delta * length / 2 + np.array([-sin, cos]) * arrow_sep\n        ax.arrow(x_pos, y_pos, cos * length, sin * length, fc=fc, ec=ec or fc, alpha=alpha, width=width, head_width=head_width, head_length=head_length, shape=shape, length_includes_head=True, **kwargs)\n        orig_positions = {'base': [3 * max_arrow_width, 3 * max_arrow_width], 'center': [length / 2, 3 * max_arrow_width], 'tip': [length - 3 * max_arrow_width, 3 * max_arrow_width]}\n        where = 'base' if (cp0 != cp1).all() else 'center'\n        M = [[cos, -sin], [sin, cos]]\n        (x, y) = np.dot(M, orig_positions[where]) + [x_pos, y_pos]\n        label = '$r_{_{\\\\mathrm{%s}}}$' % (pair,)\n        ax.text(x, y, label, size=label_text_size, ha='center', va='center', color=labelcolor or fc)",
            "def make_arrow_graph(ax, data, size=4, display='length', shape='right', max_arrow_width=0.03, arrow_sep=0.02, alpha=0.5, normalize_data=False, ec=None, labelcolor=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Makes an arrow plot.\\n\\n    Parameters\\n    ----------\\n    ax\\n        The axes where the graph is drawn.\\n    data\\n        Dict with probabilities for the bases and pair transitions.\\n    size\\n        Size of the plot, in inches.\\n    display : {'length', 'width', 'alpha'}\\n        The arrow property to change.\\n    shape : {'full', 'left', 'right'}\\n        For full or half arrows.\\n    max_arrow_width : float\\n        Maximum width of an arrow, in data coordinates.\\n    arrow_sep : float\\n        Separation between arrows in a pair, in data coordinates.\\n    alpha : float\\n        Maximum opacity of arrows.\\n    **kwargs\\n        `.FancyArrow` properties, e.g. *linewidth* or *edgecolor*.\\n    \"\n    ax.set(xlim=(-0.25, 1.25), ylim=(-0.25, 1.25), xticks=[], yticks=[], title=f'flux encoded as arrow {display}')\n    max_text_size = size * 12\n    min_text_size = size\n    label_text_size = size * 4\n    bases = 'ATGC'\n    coords = {'A': np.array([0, 1]), 'T': np.array([1, 1]), 'G': np.array([0, 0]), 'C': np.array([1, 0])}\n    colors = {'A': 'r', 'T': 'k', 'G': 'g', 'C': 'b'}\n    for base in bases:\n        fontsize = np.clip(max_text_size * data[base] ** (1 / 2), min_text_size, max_text_size)\n        ax.text(*coords[base], f'${base}_3$', color=colors[base], size=fontsize, horizontalalignment='center', verticalalignment='center', weight='bold')\n    arrow_h_offset = 0.25\n    max_arrow_length = 1 - 2 * arrow_h_offset\n    max_head_width = 2.5 * max_arrow_width\n    max_head_length = 2 * max_arrow_width\n    sf = 0.6\n    if normalize_data:\n        max_val = max((v for (k, v) in data.items() if len(k) == 2), default=0)\n        for (k, v) in data.items():\n            data[k] = v / max_val * sf\n    for pair in map(''.join, itertools.permutations(bases, 2)):\n        if display == 'length':\n            length = max_head_length + data[pair] / sf * (max_arrow_length - max_head_length)\n        else:\n            length = max_arrow_length\n        if display == 'alpha':\n            alpha = min(data[pair] / sf, alpha)\n        if display == 'width':\n            scale = data[pair] / sf\n            width = max_arrow_width * scale\n            head_width = max_head_width * scale\n            head_length = max_head_length * scale\n        else:\n            width = max_arrow_width\n            head_width = max_head_width\n            head_length = max_head_length\n        fc = colors[pair[0]]\n        cp0 = coords[pair[0]]\n        cp1 = coords[pair[1]]\n        delta = (cos, sin) = (cp1 - cp0) / np.hypot(*cp1 - cp0)\n        (x_pos, y_pos) = (cp0 + cp1) / 2 - delta * length / 2 + np.array([-sin, cos]) * arrow_sep\n        ax.arrow(x_pos, y_pos, cos * length, sin * length, fc=fc, ec=ec or fc, alpha=alpha, width=width, head_width=head_width, head_length=head_length, shape=shape, length_includes_head=True, **kwargs)\n        orig_positions = {'base': [3 * max_arrow_width, 3 * max_arrow_width], 'center': [length / 2, 3 * max_arrow_width], 'tip': [length - 3 * max_arrow_width, 3 * max_arrow_width]}\n        where = 'base' if (cp0 != cp1).all() else 'center'\n        M = [[cos, -sin], [sin, cos]]\n        (x, y) = np.dot(M, orig_positions[where]) + [x_pos, y_pos]\n        label = '$r_{_{\\\\mathrm{%s}}}$' % (pair,)\n        ax.text(x, y, label, size=label_text_size, ha='center', va='center', color=labelcolor or fc)",
            "def make_arrow_graph(ax, data, size=4, display='length', shape='right', max_arrow_width=0.03, arrow_sep=0.02, alpha=0.5, normalize_data=False, ec=None, labelcolor=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Makes an arrow plot.\\n\\n    Parameters\\n    ----------\\n    ax\\n        The axes where the graph is drawn.\\n    data\\n        Dict with probabilities for the bases and pair transitions.\\n    size\\n        Size of the plot, in inches.\\n    display : {'length', 'width', 'alpha'}\\n        The arrow property to change.\\n    shape : {'full', 'left', 'right'}\\n        For full or half arrows.\\n    max_arrow_width : float\\n        Maximum width of an arrow, in data coordinates.\\n    arrow_sep : float\\n        Separation between arrows in a pair, in data coordinates.\\n    alpha : float\\n        Maximum opacity of arrows.\\n    **kwargs\\n        `.FancyArrow` properties, e.g. *linewidth* or *edgecolor*.\\n    \"\n    ax.set(xlim=(-0.25, 1.25), ylim=(-0.25, 1.25), xticks=[], yticks=[], title=f'flux encoded as arrow {display}')\n    max_text_size = size * 12\n    min_text_size = size\n    label_text_size = size * 4\n    bases = 'ATGC'\n    coords = {'A': np.array([0, 1]), 'T': np.array([1, 1]), 'G': np.array([0, 0]), 'C': np.array([1, 0])}\n    colors = {'A': 'r', 'T': 'k', 'G': 'g', 'C': 'b'}\n    for base in bases:\n        fontsize = np.clip(max_text_size * data[base] ** (1 / 2), min_text_size, max_text_size)\n        ax.text(*coords[base], f'${base}_3$', color=colors[base], size=fontsize, horizontalalignment='center', verticalalignment='center', weight='bold')\n    arrow_h_offset = 0.25\n    max_arrow_length = 1 - 2 * arrow_h_offset\n    max_head_width = 2.5 * max_arrow_width\n    max_head_length = 2 * max_arrow_width\n    sf = 0.6\n    if normalize_data:\n        max_val = max((v for (k, v) in data.items() if len(k) == 2), default=0)\n        for (k, v) in data.items():\n            data[k] = v / max_val * sf\n    for pair in map(''.join, itertools.permutations(bases, 2)):\n        if display == 'length':\n            length = max_head_length + data[pair] / sf * (max_arrow_length - max_head_length)\n        else:\n            length = max_arrow_length\n        if display == 'alpha':\n            alpha = min(data[pair] / sf, alpha)\n        if display == 'width':\n            scale = data[pair] / sf\n            width = max_arrow_width * scale\n            head_width = max_head_width * scale\n            head_length = max_head_length * scale\n        else:\n            width = max_arrow_width\n            head_width = max_head_width\n            head_length = max_head_length\n        fc = colors[pair[0]]\n        cp0 = coords[pair[0]]\n        cp1 = coords[pair[1]]\n        delta = (cos, sin) = (cp1 - cp0) / np.hypot(*cp1 - cp0)\n        (x_pos, y_pos) = (cp0 + cp1) / 2 - delta * length / 2 + np.array([-sin, cos]) * arrow_sep\n        ax.arrow(x_pos, y_pos, cos * length, sin * length, fc=fc, ec=ec or fc, alpha=alpha, width=width, head_width=head_width, head_length=head_length, shape=shape, length_includes_head=True, **kwargs)\n        orig_positions = {'base': [3 * max_arrow_width, 3 * max_arrow_width], 'center': [length / 2, 3 * max_arrow_width], 'tip': [length - 3 * max_arrow_width, 3 * max_arrow_width]}\n        where = 'base' if (cp0 != cp1).all() else 'center'\n        M = [[cos, -sin], [sin, cos]]\n        (x, y) = np.dot(M, orig_positions[where]) + [x_pos, y_pos]\n        label = '$r_{_{\\\\mathrm{%s}}}$' % (pair,)\n        ax.text(x, y, label, size=label_text_size, ha='center', va='center', color=labelcolor or fc)"
        ]
    }
]