[
    {
        "func_name": "_doktocsr",
        "original": "def _doktocsr(dok):\n    \"\"\"Converts a sparse matrix to Compressed Sparse Row (CSR) format.\n\n    Parameters\n    ==========\n\n    A : contains non-zero elements sorted by key (row, column)\n    JA : JA[i] is the column corresponding to A[i]\n    IA : IA[i] contains the index in A for the first non-zero element\n        of row[i]. Thus IA[i+1] - IA[i] gives number of non-zero\n        elements row[i]. The length of IA is always 1 more than the\n        number of rows in the matrix.\n\n    Examples\n    ========\n\n    >>> from sympy.matrices.sparsetools import _doktocsr\n    >>> from sympy import SparseMatrix, diag\n    >>> m = SparseMatrix(diag(1, 2, 3))\n    >>> m[2, 0] = -1\n    >>> _doktocsr(m)\n    [[1, 2, -1, 3], [0, 1, 0, 2], [0, 1, 2, 4], [3, 3]]\n\n    \"\"\"\n    (row, JA, A) = [list(i) for i in zip(*dok.row_list())]\n    IA = [0] * ((row[0] if row else 0) + 1)\n    for (i, r) in enumerate(row):\n        IA.extend([i] * (r - row[i - 1]))\n    IA.extend([len(A)] * (dok.rows - len(IA) + 1))\n    shape = [dok.rows, dok.cols]\n    return [A, JA, IA, shape]",
        "mutated": [
            "def _doktocsr(dok):\n    if False:\n        i = 10\n    'Converts a sparse matrix to Compressed Sparse Row (CSR) format.\\n\\n    Parameters\\n    ==========\\n\\n    A : contains non-zero elements sorted by key (row, column)\\n    JA : JA[i] is the column corresponding to A[i]\\n    IA : IA[i] contains the index in A for the first non-zero element\\n        of row[i]. Thus IA[i+1] - IA[i] gives number of non-zero\\n        elements row[i]. The length of IA is always 1 more than the\\n        number of rows in the matrix.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.matrices.sparsetools import _doktocsr\\n    >>> from sympy import SparseMatrix, diag\\n    >>> m = SparseMatrix(diag(1, 2, 3))\\n    >>> m[2, 0] = -1\\n    >>> _doktocsr(m)\\n    [[1, 2, -1, 3], [0, 1, 0, 2], [0, 1, 2, 4], [3, 3]]\\n\\n    '\n    (row, JA, A) = [list(i) for i in zip(*dok.row_list())]\n    IA = [0] * ((row[0] if row else 0) + 1)\n    for (i, r) in enumerate(row):\n        IA.extend([i] * (r - row[i - 1]))\n    IA.extend([len(A)] * (dok.rows - len(IA) + 1))\n    shape = [dok.rows, dok.cols]\n    return [A, JA, IA, shape]",
            "def _doktocsr(dok):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Converts a sparse matrix to Compressed Sparse Row (CSR) format.\\n\\n    Parameters\\n    ==========\\n\\n    A : contains non-zero elements sorted by key (row, column)\\n    JA : JA[i] is the column corresponding to A[i]\\n    IA : IA[i] contains the index in A for the first non-zero element\\n        of row[i]. Thus IA[i+1] - IA[i] gives number of non-zero\\n        elements row[i]. The length of IA is always 1 more than the\\n        number of rows in the matrix.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.matrices.sparsetools import _doktocsr\\n    >>> from sympy import SparseMatrix, diag\\n    >>> m = SparseMatrix(diag(1, 2, 3))\\n    >>> m[2, 0] = -1\\n    >>> _doktocsr(m)\\n    [[1, 2, -1, 3], [0, 1, 0, 2], [0, 1, 2, 4], [3, 3]]\\n\\n    '\n    (row, JA, A) = [list(i) for i in zip(*dok.row_list())]\n    IA = [0] * ((row[0] if row else 0) + 1)\n    for (i, r) in enumerate(row):\n        IA.extend([i] * (r - row[i - 1]))\n    IA.extend([len(A)] * (dok.rows - len(IA) + 1))\n    shape = [dok.rows, dok.cols]\n    return [A, JA, IA, shape]",
            "def _doktocsr(dok):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Converts a sparse matrix to Compressed Sparse Row (CSR) format.\\n\\n    Parameters\\n    ==========\\n\\n    A : contains non-zero elements sorted by key (row, column)\\n    JA : JA[i] is the column corresponding to A[i]\\n    IA : IA[i] contains the index in A for the first non-zero element\\n        of row[i]. Thus IA[i+1] - IA[i] gives number of non-zero\\n        elements row[i]. The length of IA is always 1 more than the\\n        number of rows in the matrix.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.matrices.sparsetools import _doktocsr\\n    >>> from sympy import SparseMatrix, diag\\n    >>> m = SparseMatrix(diag(1, 2, 3))\\n    >>> m[2, 0] = -1\\n    >>> _doktocsr(m)\\n    [[1, 2, -1, 3], [0, 1, 0, 2], [0, 1, 2, 4], [3, 3]]\\n\\n    '\n    (row, JA, A) = [list(i) for i in zip(*dok.row_list())]\n    IA = [0] * ((row[0] if row else 0) + 1)\n    for (i, r) in enumerate(row):\n        IA.extend([i] * (r - row[i - 1]))\n    IA.extend([len(A)] * (dok.rows - len(IA) + 1))\n    shape = [dok.rows, dok.cols]\n    return [A, JA, IA, shape]",
            "def _doktocsr(dok):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Converts a sparse matrix to Compressed Sparse Row (CSR) format.\\n\\n    Parameters\\n    ==========\\n\\n    A : contains non-zero elements sorted by key (row, column)\\n    JA : JA[i] is the column corresponding to A[i]\\n    IA : IA[i] contains the index in A for the first non-zero element\\n        of row[i]. Thus IA[i+1] - IA[i] gives number of non-zero\\n        elements row[i]. The length of IA is always 1 more than the\\n        number of rows in the matrix.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.matrices.sparsetools import _doktocsr\\n    >>> from sympy import SparseMatrix, diag\\n    >>> m = SparseMatrix(diag(1, 2, 3))\\n    >>> m[2, 0] = -1\\n    >>> _doktocsr(m)\\n    [[1, 2, -1, 3], [0, 1, 0, 2], [0, 1, 2, 4], [3, 3]]\\n\\n    '\n    (row, JA, A) = [list(i) for i in zip(*dok.row_list())]\n    IA = [0] * ((row[0] if row else 0) + 1)\n    for (i, r) in enumerate(row):\n        IA.extend([i] * (r - row[i - 1]))\n    IA.extend([len(A)] * (dok.rows - len(IA) + 1))\n    shape = [dok.rows, dok.cols]\n    return [A, JA, IA, shape]",
            "def _doktocsr(dok):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Converts a sparse matrix to Compressed Sparse Row (CSR) format.\\n\\n    Parameters\\n    ==========\\n\\n    A : contains non-zero elements sorted by key (row, column)\\n    JA : JA[i] is the column corresponding to A[i]\\n    IA : IA[i] contains the index in A for the first non-zero element\\n        of row[i]. Thus IA[i+1] - IA[i] gives number of non-zero\\n        elements row[i]. The length of IA is always 1 more than the\\n        number of rows in the matrix.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.matrices.sparsetools import _doktocsr\\n    >>> from sympy import SparseMatrix, diag\\n    >>> m = SparseMatrix(diag(1, 2, 3))\\n    >>> m[2, 0] = -1\\n    >>> _doktocsr(m)\\n    [[1, 2, -1, 3], [0, 1, 0, 2], [0, 1, 2, 4], [3, 3]]\\n\\n    '\n    (row, JA, A) = [list(i) for i in zip(*dok.row_list())]\n    IA = [0] * ((row[0] if row else 0) + 1)\n    for (i, r) in enumerate(row):\n        IA.extend([i] * (r - row[i - 1]))\n    IA.extend([len(A)] * (dok.rows - len(IA) + 1))\n    shape = [dok.rows, dok.cols]\n    return [A, JA, IA, shape]"
        ]
    },
    {
        "func_name": "_csrtodok",
        "original": "def _csrtodok(csr):\n    \"\"\"Converts a CSR representation to DOK representation.\n\n    Examples\n    ========\n\n    >>> from sympy.matrices.sparsetools import _csrtodok\n    >>> _csrtodok([[5, 8, 3, 6], [0, 1, 2, 1], [0, 0, 2, 3, 4], [4, 3]])\n    Matrix([\n    [0, 0, 0],\n    [5, 8, 0],\n    [0, 0, 3],\n    [0, 6, 0]])\n\n    \"\"\"\n    smat = {}\n    (A, JA, IA, shape) = csr\n    for i in range(len(IA) - 1):\n        indices = slice(IA[i], IA[i + 1])\n        for (l, m) in zip(A[indices], JA[indices]):\n            smat[i, m] = l\n    return SparseMatrix(*shape, smat)",
        "mutated": [
            "def _csrtodok(csr):\n    if False:\n        i = 10\n    'Converts a CSR representation to DOK representation.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.matrices.sparsetools import _csrtodok\\n    >>> _csrtodok([[5, 8, 3, 6], [0, 1, 2, 1], [0, 0, 2, 3, 4], [4, 3]])\\n    Matrix([\\n    [0, 0, 0],\\n    [5, 8, 0],\\n    [0, 0, 3],\\n    [0, 6, 0]])\\n\\n    '\n    smat = {}\n    (A, JA, IA, shape) = csr\n    for i in range(len(IA) - 1):\n        indices = slice(IA[i], IA[i + 1])\n        for (l, m) in zip(A[indices], JA[indices]):\n            smat[i, m] = l\n    return SparseMatrix(*shape, smat)",
            "def _csrtodok(csr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Converts a CSR representation to DOK representation.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.matrices.sparsetools import _csrtodok\\n    >>> _csrtodok([[5, 8, 3, 6], [0, 1, 2, 1], [0, 0, 2, 3, 4], [4, 3]])\\n    Matrix([\\n    [0, 0, 0],\\n    [5, 8, 0],\\n    [0, 0, 3],\\n    [0, 6, 0]])\\n\\n    '\n    smat = {}\n    (A, JA, IA, shape) = csr\n    for i in range(len(IA) - 1):\n        indices = slice(IA[i], IA[i + 1])\n        for (l, m) in zip(A[indices], JA[indices]):\n            smat[i, m] = l\n    return SparseMatrix(*shape, smat)",
            "def _csrtodok(csr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Converts a CSR representation to DOK representation.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.matrices.sparsetools import _csrtodok\\n    >>> _csrtodok([[5, 8, 3, 6], [0, 1, 2, 1], [0, 0, 2, 3, 4], [4, 3]])\\n    Matrix([\\n    [0, 0, 0],\\n    [5, 8, 0],\\n    [0, 0, 3],\\n    [0, 6, 0]])\\n\\n    '\n    smat = {}\n    (A, JA, IA, shape) = csr\n    for i in range(len(IA) - 1):\n        indices = slice(IA[i], IA[i + 1])\n        for (l, m) in zip(A[indices], JA[indices]):\n            smat[i, m] = l\n    return SparseMatrix(*shape, smat)",
            "def _csrtodok(csr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Converts a CSR representation to DOK representation.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.matrices.sparsetools import _csrtodok\\n    >>> _csrtodok([[5, 8, 3, 6], [0, 1, 2, 1], [0, 0, 2, 3, 4], [4, 3]])\\n    Matrix([\\n    [0, 0, 0],\\n    [5, 8, 0],\\n    [0, 0, 3],\\n    [0, 6, 0]])\\n\\n    '\n    smat = {}\n    (A, JA, IA, shape) = csr\n    for i in range(len(IA) - 1):\n        indices = slice(IA[i], IA[i + 1])\n        for (l, m) in zip(A[indices], JA[indices]):\n            smat[i, m] = l\n    return SparseMatrix(*shape, smat)",
            "def _csrtodok(csr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Converts a CSR representation to DOK representation.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.matrices.sparsetools import _csrtodok\\n    >>> _csrtodok([[5, 8, 3, 6], [0, 1, 2, 1], [0, 0, 2, 3, 4], [4, 3]])\\n    Matrix([\\n    [0, 0, 0],\\n    [5, 8, 0],\\n    [0, 0, 3],\\n    [0, 6, 0]])\\n\\n    '\n    smat = {}\n    (A, JA, IA, shape) = csr\n    for i in range(len(IA) - 1):\n        indices = slice(IA[i], IA[i + 1])\n        for (l, m) in zip(A[indices], JA[indices]):\n            smat[i, m] = l\n    return SparseMatrix(*shape, smat)"
        ]
    },
    {
        "func_name": "rc",
        "original": "def rc(d):\n    r = -d if d < 0 else 0\n    c = 0 if r else d\n    return (r, c)",
        "mutated": [
            "def rc(d):\n    if False:\n        i = 10\n    r = -d if d < 0 else 0\n    c = 0 if r else d\n    return (r, c)",
            "def rc(d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    r = -d if d < 0 else 0\n    c = 0 if r else d\n    return (r, c)",
            "def rc(d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    r = -d if d < 0 else 0\n    c = 0 if r else d\n    return (r, c)",
            "def rc(d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    r = -d if d < 0 else 0\n    c = 0 if r else d\n    return (r, c)",
            "def rc(d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    r = -d if d < 0 else 0\n    c = 0 if r else d\n    return (r, c)"
        ]
    },
    {
        "func_name": "update",
        "original": "def update(i, j, v):\n    if v:\n        if (i, j) in smat and smat[i, j] not in (tba, v):\n            raise ValueError('collision at %s' % ((i, j),))\n        smat[i, j] = v",
        "mutated": [
            "def update(i, j, v):\n    if False:\n        i = 10\n    if v:\n        if (i, j) in smat and smat[i, j] not in (tba, v):\n            raise ValueError('collision at %s' % ((i, j),))\n        smat[i, j] = v",
            "def update(i, j, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if v:\n        if (i, j) in smat and smat[i, j] not in (tba, v):\n            raise ValueError('collision at %s' % ((i, j),))\n        smat[i, j] = v",
            "def update(i, j, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if v:\n        if (i, j) in smat and smat[i, j] not in (tba, v):\n            raise ValueError('collision at %s' % ((i, j),))\n        smat[i, j] = v",
            "def update(i, j, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if v:\n        if (i, j) in smat and smat[i, j] not in (tba, v):\n            raise ValueError('collision at %s' % ((i, j),))\n        smat[i, j] = v",
            "def update(i, j, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if v:\n        if (i, j) in smat and smat[i, j] not in (tba, v):\n            raise ValueError('collision at %s' % ((i, j),))\n        smat[i, j] = v"
        ]
    },
    {
        "func_name": "banded",
        "original": "def banded(*args, **kwargs):\n    \"\"\"Returns a SparseMatrix from the given dictionary describing\n    the diagonals of the matrix. The keys are positive for upper\n    diagonals and negative for those below the main diagonal. The\n    values may be:\n\n    * expressions or single-argument functions,\n\n    * lists or tuples of values,\n\n    * matrices\n\n    Unless dimensions are given, the size of the returned matrix will\n    be large enough to contain the largest non-zero value provided.\n\n    kwargs\n    ======\n\n    rows : rows of the resulting matrix; computed if\n           not given.\n\n    cols : columns of the resulting matrix; computed if\n           not given.\n\n    Examples\n    ========\n\n    >>> from sympy import banded, ones, Matrix\n    >>> from sympy.abc import x\n\n    If explicit values are given in tuples,\n    the matrix will autosize to contain all values, otherwise\n    a single value is filled onto the entire diagonal:\n\n    >>> banded({1: (1, 2, 3), -1: (4, 5, 6), 0: x})\n    Matrix([\n    [x, 1, 0, 0],\n    [4, x, 2, 0],\n    [0, 5, x, 3],\n    [0, 0, 6, x]])\n\n    A function accepting a single argument can be used to fill the\n    diagonal as a function of diagonal index (which starts at 0).\n    The size (or shape) of the matrix must be given to obtain more\n    than a 1x1 matrix:\n\n    >>> s = lambda d: (1 + d)**2\n    >>> banded(5, {0: s, 2: s, -2: 2})\n    Matrix([\n    [1, 0, 1,  0,  0],\n    [0, 4, 0,  4,  0],\n    [2, 0, 9,  0,  9],\n    [0, 2, 0, 16,  0],\n    [0, 0, 2,  0, 25]])\n\n    The diagonal of matrices placed on a diagonal will coincide\n    with the indicated diagonal:\n\n    >>> vert = Matrix([1, 2, 3])\n    >>> banded({0: vert}, cols=3)\n    Matrix([\n    [1, 0, 0],\n    [2, 1, 0],\n    [3, 2, 1],\n    [0, 3, 2],\n    [0, 0, 3]])\n\n    >>> banded(4, {0: ones(2)})\n    Matrix([\n    [1, 1, 0, 0],\n    [1, 1, 0, 0],\n    [0, 0, 1, 1],\n    [0, 0, 1, 1]])\n\n    Errors are raised if the designated size will not hold\n    all values an integral number of times. Here, the rows\n    are designated as odd (but an even number is required to\n    hold the off-diagonal 2x2 ones):\n\n    >>> banded({0: 2, 1: ones(2)}, rows=5)\n    Traceback (most recent call last):\n    ...\n    ValueError:\n    sequence does not fit an integral number of times in the matrix\n\n    And here, an even number of rows is given...but the square\n    matrix has an even number of columns, too. As we saw\n    in the previous example, an odd number is required:\n\n    >>> banded(4, {0: 2, 1: ones(2)})  # trying to make 4x4 and cols must be odd\n    Traceback (most recent call last):\n    ...\n    ValueError:\n    sequence does not fit an integral number of times in the matrix\n\n    A way around having to count rows is to enclosing matrix elements\n    in a tuple and indicate the desired number of them to the right:\n\n    >>> banded({0: 2, 2: (ones(2),)*3})\n    Matrix([\n    [2, 0, 1, 1, 0, 0, 0, 0],\n    [0, 2, 1, 1, 0, 0, 0, 0],\n    [0, 0, 2, 0, 1, 1, 0, 0],\n    [0, 0, 0, 2, 1, 1, 0, 0],\n    [0, 0, 0, 0, 2, 0, 1, 1],\n    [0, 0, 0, 0, 0, 2, 1, 1]])\n\n    An error will be raised if more than one value\n    is written to a given entry. Here, the ones overlap\n    with the main diagonal if they are placed on the\n    first diagonal:\n\n    >>> banded({0: (2,)*5, 1: (ones(2),)*3})\n    Traceback (most recent call last):\n    ...\n    ValueError: collision at (1, 1)\n\n    By placing a 0 at the bottom left of the 2x2 matrix of\n    ones, the collision is avoided:\n\n    >>> u2 = Matrix([\n    ... [1, 1],\n    ... [0, 1]])\n    >>> banded({0: [2]*5, 1: [u2]*3})\n    Matrix([\n    [2, 1, 1, 0, 0, 0, 0],\n    [0, 2, 1, 0, 0, 0, 0],\n    [0, 0, 2, 1, 1, 0, 0],\n    [0, 0, 0, 2, 1, 0, 0],\n    [0, 0, 0, 0, 2, 1, 1],\n    [0, 0, 0, 0, 0, 0, 1]])\n    \"\"\"\n    try:\n        if len(args) not in (1, 2, 3):\n            raise TypeError\n        if not isinstance(args[-1], (dict, Dict)):\n            raise TypeError\n        if len(args) == 1:\n            rows = kwargs.get('rows', None)\n            cols = kwargs.get('cols', None)\n            if rows is not None:\n                rows = as_int(rows)\n            if cols is not None:\n                cols = as_int(cols)\n        elif len(args) == 2:\n            rows = cols = as_int(args[0])\n        else:\n            (rows, cols) = map(as_int, args[:2])\n        _ = all((as_int(k) for k in args[-1]))\n    except (ValueError, TypeError):\n        raise TypeError(filldedent('unrecognized input to banded:\\n            expecting [[row,] col,] {int: value}'))\n\n    def rc(d):\n        r = -d if d < 0 else 0\n        c = 0 if r else d\n        return (r, c)\n    smat = {}\n    undone = []\n    tba = Dummy()\n    for (d, v) in args[-1].items():\n        (r, c) = rc(d)\n        if isinstance(v, (list, tuple)):\n            extra = 0\n            for (i, vi) in enumerate(v):\n                i += extra\n                if is_sequence(vi):\n                    vi = SparseMatrix(vi)\n                    smat[r + i, c + i] = vi\n                    extra += min(vi.shape) - 1\n                else:\n                    smat[r + i, c + i] = vi\n        elif is_sequence(v):\n            v = SparseMatrix(v)\n            (rv, cv) = v.shape\n            if rows and cols:\n                (nr, xr) = divmod(rows - r, rv)\n                (nc, xc) = divmod(cols - c, cv)\n                x = xr or xc\n                do = min(nr, nc)\n            elif rows:\n                (do, x) = divmod(rows - r, rv)\n            elif cols:\n                (do, x) = divmod(cols - c, cv)\n            else:\n                do = 1\n                x = 0\n            if x:\n                raise ValueError(filldedent('\\n                    sequence does not fit an integral number of times\\n                    in the matrix'))\n            j = min(v.shape)\n            for i in range(do):\n                smat[r, c] = v\n                r += j\n                c += j\n        elif v:\n            smat[r, c] = tba\n            undone.append((d, v))\n    s = SparseMatrix(None, smat)\n    smat = s.todok()\n    if rows is not None and rows < s.rows:\n        raise ValueError('Designated rows %s < needed %s' % (rows, s.rows))\n    if cols is not None and cols < s.cols:\n        raise ValueError('Designated cols %s < needed %s' % (cols, s.cols))\n    if rows is cols is None:\n        rows = s.rows\n        cols = s.cols\n    elif rows is not None and cols is None:\n        cols = max(rows, s.cols)\n    elif cols is not None and rows is None:\n        rows = max(cols, s.rows)\n\n    def update(i, j, v):\n        if v:\n            if (i, j) in smat and smat[i, j] not in (tba, v):\n                raise ValueError('collision at %s' % ((i, j),))\n            smat[i, j] = v\n    if undone:\n        for (d, vi) in undone:\n            (r, c) = rc(d)\n            v = vi if callable(vi) else lambda _: vi\n            i = 0\n            while r + i < rows and c + i < cols:\n                update(r + i, c + i, v(i))\n                i += 1\n    return SparseMatrix(rows, cols, smat)",
        "mutated": [
            "def banded(*args, **kwargs):\n    if False:\n        i = 10\n    'Returns a SparseMatrix from the given dictionary describing\\n    the diagonals of the matrix. The keys are positive for upper\\n    diagonals and negative for those below the main diagonal. The\\n    values may be:\\n\\n    * expressions or single-argument functions,\\n\\n    * lists or tuples of values,\\n\\n    * matrices\\n\\n    Unless dimensions are given, the size of the returned matrix will\\n    be large enough to contain the largest non-zero value provided.\\n\\n    kwargs\\n    ======\\n\\n    rows : rows of the resulting matrix; computed if\\n           not given.\\n\\n    cols : columns of the resulting matrix; computed if\\n           not given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import banded, ones, Matrix\\n    >>> from sympy.abc import x\\n\\n    If explicit values are given in tuples,\\n    the matrix will autosize to contain all values, otherwise\\n    a single value is filled onto the entire diagonal:\\n\\n    >>> banded({1: (1, 2, 3), -1: (4, 5, 6), 0: x})\\n    Matrix([\\n    [x, 1, 0, 0],\\n    [4, x, 2, 0],\\n    [0, 5, x, 3],\\n    [0, 0, 6, x]])\\n\\n    A function accepting a single argument can be used to fill the\\n    diagonal as a function of diagonal index (which starts at 0).\\n    The size (or shape) of the matrix must be given to obtain more\\n    than a 1x1 matrix:\\n\\n    >>> s = lambda d: (1 + d)**2\\n    >>> banded(5, {0: s, 2: s, -2: 2})\\n    Matrix([\\n    [1, 0, 1,  0,  0],\\n    [0, 4, 0,  4,  0],\\n    [2, 0, 9,  0,  9],\\n    [0, 2, 0, 16,  0],\\n    [0, 0, 2,  0, 25]])\\n\\n    The diagonal of matrices placed on a diagonal will coincide\\n    with the indicated diagonal:\\n\\n    >>> vert = Matrix([1, 2, 3])\\n    >>> banded({0: vert}, cols=3)\\n    Matrix([\\n    [1, 0, 0],\\n    [2, 1, 0],\\n    [3, 2, 1],\\n    [0, 3, 2],\\n    [0, 0, 3]])\\n\\n    >>> banded(4, {0: ones(2)})\\n    Matrix([\\n    [1, 1, 0, 0],\\n    [1, 1, 0, 0],\\n    [0, 0, 1, 1],\\n    [0, 0, 1, 1]])\\n\\n    Errors are raised if the designated size will not hold\\n    all values an integral number of times. Here, the rows\\n    are designated as odd (but an even number is required to\\n    hold the off-diagonal 2x2 ones):\\n\\n    >>> banded({0: 2, 1: ones(2)}, rows=5)\\n    Traceback (most recent call last):\\n    ...\\n    ValueError:\\n    sequence does not fit an integral number of times in the matrix\\n\\n    And here, an even number of rows is given...but the square\\n    matrix has an even number of columns, too. As we saw\\n    in the previous example, an odd number is required:\\n\\n    >>> banded(4, {0: 2, 1: ones(2)})  # trying to make 4x4 and cols must be odd\\n    Traceback (most recent call last):\\n    ...\\n    ValueError:\\n    sequence does not fit an integral number of times in the matrix\\n\\n    A way around having to count rows is to enclosing matrix elements\\n    in a tuple and indicate the desired number of them to the right:\\n\\n    >>> banded({0: 2, 2: (ones(2),)*3})\\n    Matrix([\\n    [2, 0, 1, 1, 0, 0, 0, 0],\\n    [0, 2, 1, 1, 0, 0, 0, 0],\\n    [0, 0, 2, 0, 1, 1, 0, 0],\\n    [0, 0, 0, 2, 1, 1, 0, 0],\\n    [0, 0, 0, 0, 2, 0, 1, 1],\\n    [0, 0, 0, 0, 0, 2, 1, 1]])\\n\\n    An error will be raised if more than one value\\n    is written to a given entry. Here, the ones overlap\\n    with the main diagonal if they are placed on the\\n    first diagonal:\\n\\n    >>> banded({0: (2,)*5, 1: (ones(2),)*3})\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: collision at (1, 1)\\n\\n    By placing a 0 at the bottom left of the 2x2 matrix of\\n    ones, the collision is avoided:\\n\\n    >>> u2 = Matrix([\\n    ... [1, 1],\\n    ... [0, 1]])\\n    >>> banded({0: [2]*5, 1: [u2]*3})\\n    Matrix([\\n    [2, 1, 1, 0, 0, 0, 0],\\n    [0, 2, 1, 0, 0, 0, 0],\\n    [0, 0, 2, 1, 1, 0, 0],\\n    [0, 0, 0, 2, 1, 0, 0],\\n    [0, 0, 0, 0, 2, 1, 1],\\n    [0, 0, 0, 0, 0, 0, 1]])\\n    '\n    try:\n        if len(args) not in (1, 2, 3):\n            raise TypeError\n        if not isinstance(args[-1], (dict, Dict)):\n            raise TypeError\n        if len(args) == 1:\n            rows = kwargs.get('rows', None)\n            cols = kwargs.get('cols', None)\n            if rows is not None:\n                rows = as_int(rows)\n            if cols is not None:\n                cols = as_int(cols)\n        elif len(args) == 2:\n            rows = cols = as_int(args[0])\n        else:\n            (rows, cols) = map(as_int, args[:2])\n        _ = all((as_int(k) for k in args[-1]))\n    except (ValueError, TypeError):\n        raise TypeError(filldedent('unrecognized input to banded:\\n            expecting [[row,] col,] {int: value}'))\n\n    def rc(d):\n        r = -d if d < 0 else 0\n        c = 0 if r else d\n        return (r, c)\n    smat = {}\n    undone = []\n    tba = Dummy()\n    for (d, v) in args[-1].items():\n        (r, c) = rc(d)\n        if isinstance(v, (list, tuple)):\n            extra = 0\n            for (i, vi) in enumerate(v):\n                i += extra\n                if is_sequence(vi):\n                    vi = SparseMatrix(vi)\n                    smat[r + i, c + i] = vi\n                    extra += min(vi.shape) - 1\n                else:\n                    smat[r + i, c + i] = vi\n        elif is_sequence(v):\n            v = SparseMatrix(v)\n            (rv, cv) = v.shape\n            if rows and cols:\n                (nr, xr) = divmod(rows - r, rv)\n                (nc, xc) = divmod(cols - c, cv)\n                x = xr or xc\n                do = min(nr, nc)\n            elif rows:\n                (do, x) = divmod(rows - r, rv)\n            elif cols:\n                (do, x) = divmod(cols - c, cv)\n            else:\n                do = 1\n                x = 0\n            if x:\n                raise ValueError(filldedent('\\n                    sequence does not fit an integral number of times\\n                    in the matrix'))\n            j = min(v.shape)\n            for i in range(do):\n                smat[r, c] = v\n                r += j\n                c += j\n        elif v:\n            smat[r, c] = tba\n            undone.append((d, v))\n    s = SparseMatrix(None, smat)\n    smat = s.todok()\n    if rows is not None and rows < s.rows:\n        raise ValueError('Designated rows %s < needed %s' % (rows, s.rows))\n    if cols is not None and cols < s.cols:\n        raise ValueError('Designated cols %s < needed %s' % (cols, s.cols))\n    if rows is cols is None:\n        rows = s.rows\n        cols = s.cols\n    elif rows is not None and cols is None:\n        cols = max(rows, s.cols)\n    elif cols is not None and rows is None:\n        rows = max(cols, s.rows)\n\n    def update(i, j, v):\n        if v:\n            if (i, j) in smat and smat[i, j] not in (tba, v):\n                raise ValueError('collision at %s' % ((i, j),))\n            smat[i, j] = v\n    if undone:\n        for (d, vi) in undone:\n            (r, c) = rc(d)\n            v = vi if callable(vi) else lambda _: vi\n            i = 0\n            while r + i < rows and c + i < cols:\n                update(r + i, c + i, v(i))\n                i += 1\n    return SparseMatrix(rows, cols, smat)",
            "def banded(*args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a SparseMatrix from the given dictionary describing\\n    the diagonals of the matrix. The keys are positive for upper\\n    diagonals and negative for those below the main diagonal. The\\n    values may be:\\n\\n    * expressions or single-argument functions,\\n\\n    * lists or tuples of values,\\n\\n    * matrices\\n\\n    Unless dimensions are given, the size of the returned matrix will\\n    be large enough to contain the largest non-zero value provided.\\n\\n    kwargs\\n    ======\\n\\n    rows : rows of the resulting matrix; computed if\\n           not given.\\n\\n    cols : columns of the resulting matrix; computed if\\n           not given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import banded, ones, Matrix\\n    >>> from sympy.abc import x\\n\\n    If explicit values are given in tuples,\\n    the matrix will autosize to contain all values, otherwise\\n    a single value is filled onto the entire diagonal:\\n\\n    >>> banded({1: (1, 2, 3), -1: (4, 5, 6), 0: x})\\n    Matrix([\\n    [x, 1, 0, 0],\\n    [4, x, 2, 0],\\n    [0, 5, x, 3],\\n    [0, 0, 6, x]])\\n\\n    A function accepting a single argument can be used to fill the\\n    diagonal as a function of diagonal index (which starts at 0).\\n    The size (or shape) of the matrix must be given to obtain more\\n    than a 1x1 matrix:\\n\\n    >>> s = lambda d: (1 + d)**2\\n    >>> banded(5, {0: s, 2: s, -2: 2})\\n    Matrix([\\n    [1, 0, 1,  0,  0],\\n    [0, 4, 0,  4,  0],\\n    [2, 0, 9,  0,  9],\\n    [0, 2, 0, 16,  0],\\n    [0, 0, 2,  0, 25]])\\n\\n    The diagonal of matrices placed on a diagonal will coincide\\n    with the indicated diagonal:\\n\\n    >>> vert = Matrix([1, 2, 3])\\n    >>> banded({0: vert}, cols=3)\\n    Matrix([\\n    [1, 0, 0],\\n    [2, 1, 0],\\n    [3, 2, 1],\\n    [0, 3, 2],\\n    [0, 0, 3]])\\n\\n    >>> banded(4, {0: ones(2)})\\n    Matrix([\\n    [1, 1, 0, 0],\\n    [1, 1, 0, 0],\\n    [0, 0, 1, 1],\\n    [0, 0, 1, 1]])\\n\\n    Errors are raised if the designated size will not hold\\n    all values an integral number of times. Here, the rows\\n    are designated as odd (but an even number is required to\\n    hold the off-diagonal 2x2 ones):\\n\\n    >>> banded({0: 2, 1: ones(2)}, rows=5)\\n    Traceback (most recent call last):\\n    ...\\n    ValueError:\\n    sequence does not fit an integral number of times in the matrix\\n\\n    And here, an even number of rows is given...but the square\\n    matrix has an even number of columns, too. As we saw\\n    in the previous example, an odd number is required:\\n\\n    >>> banded(4, {0: 2, 1: ones(2)})  # trying to make 4x4 and cols must be odd\\n    Traceback (most recent call last):\\n    ...\\n    ValueError:\\n    sequence does not fit an integral number of times in the matrix\\n\\n    A way around having to count rows is to enclosing matrix elements\\n    in a tuple and indicate the desired number of them to the right:\\n\\n    >>> banded({0: 2, 2: (ones(2),)*3})\\n    Matrix([\\n    [2, 0, 1, 1, 0, 0, 0, 0],\\n    [0, 2, 1, 1, 0, 0, 0, 0],\\n    [0, 0, 2, 0, 1, 1, 0, 0],\\n    [0, 0, 0, 2, 1, 1, 0, 0],\\n    [0, 0, 0, 0, 2, 0, 1, 1],\\n    [0, 0, 0, 0, 0, 2, 1, 1]])\\n\\n    An error will be raised if more than one value\\n    is written to a given entry. Here, the ones overlap\\n    with the main diagonal if they are placed on the\\n    first diagonal:\\n\\n    >>> banded({0: (2,)*5, 1: (ones(2),)*3})\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: collision at (1, 1)\\n\\n    By placing a 0 at the bottom left of the 2x2 matrix of\\n    ones, the collision is avoided:\\n\\n    >>> u2 = Matrix([\\n    ... [1, 1],\\n    ... [0, 1]])\\n    >>> banded({0: [2]*5, 1: [u2]*3})\\n    Matrix([\\n    [2, 1, 1, 0, 0, 0, 0],\\n    [0, 2, 1, 0, 0, 0, 0],\\n    [0, 0, 2, 1, 1, 0, 0],\\n    [0, 0, 0, 2, 1, 0, 0],\\n    [0, 0, 0, 0, 2, 1, 1],\\n    [0, 0, 0, 0, 0, 0, 1]])\\n    '\n    try:\n        if len(args) not in (1, 2, 3):\n            raise TypeError\n        if not isinstance(args[-1], (dict, Dict)):\n            raise TypeError\n        if len(args) == 1:\n            rows = kwargs.get('rows', None)\n            cols = kwargs.get('cols', None)\n            if rows is not None:\n                rows = as_int(rows)\n            if cols is not None:\n                cols = as_int(cols)\n        elif len(args) == 2:\n            rows = cols = as_int(args[0])\n        else:\n            (rows, cols) = map(as_int, args[:2])\n        _ = all((as_int(k) for k in args[-1]))\n    except (ValueError, TypeError):\n        raise TypeError(filldedent('unrecognized input to banded:\\n            expecting [[row,] col,] {int: value}'))\n\n    def rc(d):\n        r = -d if d < 0 else 0\n        c = 0 if r else d\n        return (r, c)\n    smat = {}\n    undone = []\n    tba = Dummy()\n    for (d, v) in args[-1].items():\n        (r, c) = rc(d)\n        if isinstance(v, (list, tuple)):\n            extra = 0\n            for (i, vi) in enumerate(v):\n                i += extra\n                if is_sequence(vi):\n                    vi = SparseMatrix(vi)\n                    smat[r + i, c + i] = vi\n                    extra += min(vi.shape) - 1\n                else:\n                    smat[r + i, c + i] = vi\n        elif is_sequence(v):\n            v = SparseMatrix(v)\n            (rv, cv) = v.shape\n            if rows and cols:\n                (nr, xr) = divmod(rows - r, rv)\n                (nc, xc) = divmod(cols - c, cv)\n                x = xr or xc\n                do = min(nr, nc)\n            elif rows:\n                (do, x) = divmod(rows - r, rv)\n            elif cols:\n                (do, x) = divmod(cols - c, cv)\n            else:\n                do = 1\n                x = 0\n            if x:\n                raise ValueError(filldedent('\\n                    sequence does not fit an integral number of times\\n                    in the matrix'))\n            j = min(v.shape)\n            for i in range(do):\n                smat[r, c] = v\n                r += j\n                c += j\n        elif v:\n            smat[r, c] = tba\n            undone.append((d, v))\n    s = SparseMatrix(None, smat)\n    smat = s.todok()\n    if rows is not None and rows < s.rows:\n        raise ValueError('Designated rows %s < needed %s' % (rows, s.rows))\n    if cols is not None and cols < s.cols:\n        raise ValueError('Designated cols %s < needed %s' % (cols, s.cols))\n    if rows is cols is None:\n        rows = s.rows\n        cols = s.cols\n    elif rows is not None and cols is None:\n        cols = max(rows, s.cols)\n    elif cols is not None and rows is None:\n        rows = max(cols, s.rows)\n\n    def update(i, j, v):\n        if v:\n            if (i, j) in smat and smat[i, j] not in (tba, v):\n                raise ValueError('collision at %s' % ((i, j),))\n            smat[i, j] = v\n    if undone:\n        for (d, vi) in undone:\n            (r, c) = rc(d)\n            v = vi if callable(vi) else lambda _: vi\n            i = 0\n            while r + i < rows and c + i < cols:\n                update(r + i, c + i, v(i))\n                i += 1\n    return SparseMatrix(rows, cols, smat)",
            "def banded(*args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a SparseMatrix from the given dictionary describing\\n    the diagonals of the matrix. The keys are positive for upper\\n    diagonals and negative for those below the main diagonal. The\\n    values may be:\\n\\n    * expressions or single-argument functions,\\n\\n    * lists or tuples of values,\\n\\n    * matrices\\n\\n    Unless dimensions are given, the size of the returned matrix will\\n    be large enough to contain the largest non-zero value provided.\\n\\n    kwargs\\n    ======\\n\\n    rows : rows of the resulting matrix; computed if\\n           not given.\\n\\n    cols : columns of the resulting matrix; computed if\\n           not given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import banded, ones, Matrix\\n    >>> from sympy.abc import x\\n\\n    If explicit values are given in tuples,\\n    the matrix will autosize to contain all values, otherwise\\n    a single value is filled onto the entire diagonal:\\n\\n    >>> banded({1: (1, 2, 3), -1: (4, 5, 6), 0: x})\\n    Matrix([\\n    [x, 1, 0, 0],\\n    [4, x, 2, 0],\\n    [0, 5, x, 3],\\n    [0, 0, 6, x]])\\n\\n    A function accepting a single argument can be used to fill the\\n    diagonal as a function of diagonal index (which starts at 0).\\n    The size (or shape) of the matrix must be given to obtain more\\n    than a 1x1 matrix:\\n\\n    >>> s = lambda d: (1 + d)**2\\n    >>> banded(5, {0: s, 2: s, -2: 2})\\n    Matrix([\\n    [1, 0, 1,  0,  0],\\n    [0, 4, 0,  4,  0],\\n    [2, 0, 9,  0,  9],\\n    [0, 2, 0, 16,  0],\\n    [0, 0, 2,  0, 25]])\\n\\n    The diagonal of matrices placed on a diagonal will coincide\\n    with the indicated diagonal:\\n\\n    >>> vert = Matrix([1, 2, 3])\\n    >>> banded({0: vert}, cols=3)\\n    Matrix([\\n    [1, 0, 0],\\n    [2, 1, 0],\\n    [3, 2, 1],\\n    [0, 3, 2],\\n    [0, 0, 3]])\\n\\n    >>> banded(4, {0: ones(2)})\\n    Matrix([\\n    [1, 1, 0, 0],\\n    [1, 1, 0, 0],\\n    [0, 0, 1, 1],\\n    [0, 0, 1, 1]])\\n\\n    Errors are raised if the designated size will not hold\\n    all values an integral number of times. Here, the rows\\n    are designated as odd (but an even number is required to\\n    hold the off-diagonal 2x2 ones):\\n\\n    >>> banded({0: 2, 1: ones(2)}, rows=5)\\n    Traceback (most recent call last):\\n    ...\\n    ValueError:\\n    sequence does not fit an integral number of times in the matrix\\n\\n    And here, an even number of rows is given...but the square\\n    matrix has an even number of columns, too. As we saw\\n    in the previous example, an odd number is required:\\n\\n    >>> banded(4, {0: 2, 1: ones(2)})  # trying to make 4x4 and cols must be odd\\n    Traceback (most recent call last):\\n    ...\\n    ValueError:\\n    sequence does not fit an integral number of times in the matrix\\n\\n    A way around having to count rows is to enclosing matrix elements\\n    in a tuple and indicate the desired number of them to the right:\\n\\n    >>> banded({0: 2, 2: (ones(2),)*3})\\n    Matrix([\\n    [2, 0, 1, 1, 0, 0, 0, 0],\\n    [0, 2, 1, 1, 0, 0, 0, 0],\\n    [0, 0, 2, 0, 1, 1, 0, 0],\\n    [0, 0, 0, 2, 1, 1, 0, 0],\\n    [0, 0, 0, 0, 2, 0, 1, 1],\\n    [0, 0, 0, 0, 0, 2, 1, 1]])\\n\\n    An error will be raised if more than one value\\n    is written to a given entry. Here, the ones overlap\\n    with the main diagonal if they are placed on the\\n    first diagonal:\\n\\n    >>> banded({0: (2,)*5, 1: (ones(2),)*3})\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: collision at (1, 1)\\n\\n    By placing a 0 at the bottom left of the 2x2 matrix of\\n    ones, the collision is avoided:\\n\\n    >>> u2 = Matrix([\\n    ... [1, 1],\\n    ... [0, 1]])\\n    >>> banded({0: [2]*5, 1: [u2]*3})\\n    Matrix([\\n    [2, 1, 1, 0, 0, 0, 0],\\n    [0, 2, 1, 0, 0, 0, 0],\\n    [0, 0, 2, 1, 1, 0, 0],\\n    [0, 0, 0, 2, 1, 0, 0],\\n    [0, 0, 0, 0, 2, 1, 1],\\n    [0, 0, 0, 0, 0, 0, 1]])\\n    '\n    try:\n        if len(args) not in (1, 2, 3):\n            raise TypeError\n        if not isinstance(args[-1], (dict, Dict)):\n            raise TypeError\n        if len(args) == 1:\n            rows = kwargs.get('rows', None)\n            cols = kwargs.get('cols', None)\n            if rows is not None:\n                rows = as_int(rows)\n            if cols is not None:\n                cols = as_int(cols)\n        elif len(args) == 2:\n            rows = cols = as_int(args[0])\n        else:\n            (rows, cols) = map(as_int, args[:2])\n        _ = all((as_int(k) for k in args[-1]))\n    except (ValueError, TypeError):\n        raise TypeError(filldedent('unrecognized input to banded:\\n            expecting [[row,] col,] {int: value}'))\n\n    def rc(d):\n        r = -d if d < 0 else 0\n        c = 0 if r else d\n        return (r, c)\n    smat = {}\n    undone = []\n    tba = Dummy()\n    for (d, v) in args[-1].items():\n        (r, c) = rc(d)\n        if isinstance(v, (list, tuple)):\n            extra = 0\n            for (i, vi) in enumerate(v):\n                i += extra\n                if is_sequence(vi):\n                    vi = SparseMatrix(vi)\n                    smat[r + i, c + i] = vi\n                    extra += min(vi.shape) - 1\n                else:\n                    smat[r + i, c + i] = vi\n        elif is_sequence(v):\n            v = SparseMatrix(v)\n            (rv, cv) = v.shape\n            if rows and cols:\n                (nr, xr) = divmod(rows - r, rv)\n                (nc, xc) = divmod(cols - c, cv)\n                x = xr or xc\n                do = min(nr, nc)\n            elif rows:\n                (do, x) = divmod(rows - r, rv)\n            elif cols:\n                (do, x) = divmod(cols - c, cv)\n            else:\n                do = 1\n                x = 0\n            if x:\n                raise ValueError(filldedent('\\n                    sequence does not fit an integral number of times\\n                    in the matrix'))\n            j = min(v.shape)\n            for i in range(do):\n                smat[r, c] = v\n                r += j\n                c += j\n        elif v:\n            smat[r, c] = tba\n            undone.append((d, v))\n    s = SparseMatrix(None, smat)\n    smat = s.todok()\n    if rows is not None and rows < s.rows:\n        raise ValueError('Designated rows %s < needed %s' % (rows, s.rows))\n    if cols is not None and cols < s.cols:\n        raise ValueError('Designated cols %s < needed %s' % (cols, s.cols))\n    if rows is cols is None:\n        rows = s.rows\n        cols = s.cols\n    elif rows is not None and cols is None:\n        cols = max(rows, s.cols)\n    elif cols is not None and rows is None:\n        rows = max(cols, s.rows)\n\n    def update(i, j, v):\n        if v:\n            if (i, j) in smat and smat[i, j] not in (tba, v):\n                raise ValueError('collision at %s' % ((i, j),))\n            smat[i, j] = v\n    if undone:\n        for (d, vi) in undone:\n            (r, c) = rc(d)\n            v = vi if callable(vi) else lambda _: vi\n            i = 0\n            while r + i < rows and c + i < cols:\n                update(r + i, c + i, v(i))\n                i += 1\n    return SparseMatrix(rows, cols, smat)",
            "def banded(*args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a SparseMatrix from the given dictionary describing\\n    the diagonals of the matrix. The keys are positive for upper\\n    diagonals and negative for those below the main diagonal. The\\n    values may be:\\n\\n    * expressions or single-argument functions,\\n\\n    * lists or tuples of values,\\n\\n    * matrices\\n\\n    Unless dimensions are given, the size of the returned matrix will\\n    be large enough to contain the largest non-zero value provided.\\n\\n    kwargs\\n    ======\\n\\n    rows : rows of the resulting matrix; computed if\\n           not given.\\n\\n    cols : columns of the resulting matrix; computed if\\n           not given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import banded, ones, Matrix\\n    >>> from sympy.abc import x\\n\\n    If explicit values are given in tuples,\\n    the matrix will autosize to contain all values, otherwise\\n    a single value is filled onto the entire diagonal:\\n\\n    >>> banded({1: (1, 2, 3), -1: (4, 5, 6), 0: x})\\n    Matrix([\\n    [x, 1, 0, 0],\\n    [4, x, 2, 0],\\n    [0, 5, x, 3],\\n    [0, 0, 6, x]])\\n\\n    A function accepting a single argument can be used to fill the\\n    diagonal as a function of diagonal index (which starts at 0).\\n    The size (or shape) of the matrix must be given to obtain more\\n    than a 1x1 matrix:\\n\\n    >>> s = lambda d: (1 + d)**2\\n    >>> banded(5, {0: s, 2: s, -2: 2})\\n    Matrix([\\n    [1, 0, 1,  0,  0],\\n    [0, 4, 0,  4,  0],\\n    [2, 0, 9,  0,  9],\\n    [0, 2, 0, 16,  0],\\n    [0, 0, 2,  0, 25]])\\n\\n    The diagonal of matrices placed on a diagonal will coincide\\n    with the indicated diagonal:\\n\\n    >>> vert = Matrix([1, 2, 3])\\n    >>> banded({0: vert}, cols=3)\\n    Matrix([\\n    [1, 0, 0],\\n    [2, 1, 0],\\n    [3, 2, 1],\\n    [0, 3, 2],\\n    [0, 0, 3]])\\n\\n    >>> banded(4, {0: ones(2)})\\n    Matrix([\\n    [1, 1, 0, 0],\\n    [1, 1, 0, 0],\\n    [0, 0, 1, 1],\\n    [0, 0, 1, 1]])\\n\\n    Errors are raised if the designated size will not hold\\n    all values an integral number of times. Here, the rows\\n    are designated as odd (but an even number is required to\\n    hold the off-diagonal 2x2 ones):\\n\\n    >>> banded({0: 2, 1: ones(2)}, rows=5)\\n    Traceback (most recent call last):\\n    ...\\n    ValueError:\\n    sequence does not fit an integral number of times in the matrix\\n\\n    And here, an even number of rows is given...but the square\\n    matrix has an even number of columns, too. As we saw\\n    in the previous example, an odd number is required:\\n\\n    >>> banded(4, {0: 2, 1: ones(2)})  # trying to make 4x4 and cols must be odd\\n    Traceback (most recent call last):\\n    ...\\n    ValueError:\\n    sequence does not fit an integral number of times in the matrix\\n\\n    A way around having to count rows is to enclosing matrix elements\\n    in a tuple and indicate the desired number of them to the right:\\n\\n    >>> banded({0: 2, 2: (ones(2),)*3})\\n    Matrix([\\n    [2, 0, 1, 1, 0, 0, 0, 0],\\n    [0, 2, 1, 1, 0, 0, 0, 0],\\n    [0, 0, 2, 0, 1, 1, 0, 0],\\n    [0, 0, 0, 2, 1, 1, 0, 0],\\n    [0, 0, 0, 0, 2, 0, 1, 1],\\n    [0, 0, 0, 0, 0, 2, 1, 1]])\\n\\n    An error will be raised if more than one value\\n    is written to a given entry. Here, the ones overlap\\n    with the main diagonal if they are placed on the\\n    first diagonal:\\n\\n    >>> banded({0: (2,)*5, 1: (ones(2),)*3})\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: collision at (1, 1)\\n\\n    By placing a 0 at the bottom left of the 2x2 matrix of\\n    ones, the collision is avoided:\\n\\n    >>> u2 = Matrix([\\n    ... [1, 1],\\n    ... [0, 1]])\\n    >>> banded({0: [2]*5, 1: [u2]*3})\\n    Matrix([\\n    [2, 1, 1, 0, 0, 0, 0],\\n    [0, 2, 1, 0, 0, 0, 0],\\n    [0, 0, 2, 1, 1, 0, 0],\\n    [0, 0, 0, 2, 1, 0, 0],\\n    [0, 0, 0, 0, 2, 1, 1],\\n    [0, 0, 0, 0, 0, 0, 1]])\\n    '\n    try:\n        if len(args) not in (1, 2, 3):\n            raise TypeError\n        if not isinstance(args[-1], (dict, Dict)):\n            raise TypeError\n        if len(args) == 1:\n            rows = kwargs.get('rows', None)\n            cols = kwargs.get('cols', None)\n            if rows is not None:\n                rows = as_int(rows)\n            if cols is not None:\n                cols = as_int(cols)\n        elif len(args) == 2:\n            rows = cols = as_int(args[0])\n        else:\n            (rows, cols) = map(as_int, args[:2])\n        _ = all((as_int(k) for k in args[-1]))\n    except (ValueError, TypeError):\n        raise TypeError(filldedent('unrecognized input to banded:\\n            expecting [[row,] col,] {int: value}'))\n\n    def rc(d):\n        r = -d if d < 0 else 0\n        c = 0 if r else d\n        return (r, c)\n    smat = {}\n    undone = []\n    tba = Dummy()\n    for (d, v) in args[-1].items():\n        (r, c) = rc(d)\n        if isinstance(v, (list, tuple)):\n            extra = 0\n            for (i, vi) in enumerate(v):\n                i += extra\n                if is_sequence(vi):\n                    vi = SparseMatrix(vi)\n                    smat[r + i, c + i] = vi\n                    extra += min(vi.shape) - 1\n                else:\n                    smat[r + i, c + i] = vi\n        elif is_sequence(v):\n            v = SparseMatrix(v)\n            (rv, cv) = v.shape\n            if rows and cols:\n                (nr, xr) = divmod(rows - r, rv)\n                (nc, xc) = divmod(cols - c, cv)\n                x = xr or xc\n                do = min(nr, nc)\n            elif rows:\n                (do, x) = divmod(rows - r, rv)\n            elif cols:\n                (do, x) = divmod(cols - c, cv)\n            else:\n                do = 1\n                x = 0\n            if x:\n                raise ValueError(filldedent('\\n                    sequence does not fit an integral number of times\\n                    in the matrix'))\n            j = min(v.shape)\n            for i in range(do):\n                smat[r, c] = v\n                r += j\n                c += j\n        elif v:\n            smat[r, c] = tba\n            undone.append((d, v))\n    s = SparseMatrix(None, smat)\n    smat = s.todok()\n    if rows is not None and rows < s.rows:\n        raise ValueError('Designated rows %s < needed %s' % (rows, s.rows))\n    if cols is not None and cols < s.cols:\n        raise ValueError('Designated cols %s < needed %s' % (cols, s.cols))\n    if rows is cols is None:\n        rows = s.rows\n        cols = s.cols\n    elif rows is not None and cols is None:\n        cols = max(rows, s.cols)\n    elif cols is not None and rows is None:\n        rows = max(cols, s.rows)\n\n    def update(i, j, v):\n        if v:\n            if (i, j) in smat and smat[i, j] not in (tba, v):\n                raise ValueError('collision at %s' % ((i, j),))\n            smat[i, j] = v\n    if undone:\n        for (d, vi) in undone:\n            (r, c) = rc(d)\n            v = vi if callable(vi) else lambda _: vi\n            i = 0\n            while r + i < rows and c + i < cols:\n                update(r + i, c + i, v(i))\n                i += 1\n    return SparseMatrix(rows, cols, smat)",
            "def banded(*args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a SparseMatrix from the given dictionary describing\\n    the diagonals of the matrix. The keys are positive for upper\\n    diagonals and negative for those below the main diagonal. The\\n    values may be:\\n\\n    * expressions or single-argument functions,\\n\\n    * lists or tuples of values,\\n\\n    * matrices\\n\\n    Unless dimensions are given, the size of the returned matrix will\\n    be large enough to contain the largest non-zero value provided.\\n\\n    kwargs\\n    ======\\n\\n    rows : rows of the resulting matrix; computed if\\n           not given.\\n\\n    cols : columns of the resulting matrix; computed if\\n           not given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import banded, ones, Matrix\\n    >>> from sympy.abc import x\\n\\n    If explicit values are given in tuples,\\n    the matrix will autosize to contain all values, otherwise\\n    a single value is filled onto the entire diagonal:\\n\\n    >>> banded({1: (1, 2, 3), -1: (4, 5, 6), 0: x})\\n    Matrix([\\n    [x, 1, 0, 0],\\n    [4, x, 2, 0],\\n    [0, 5, x, 3],\\n    [0, 0, 6, x]])\\n\\n    A function accepting a single argument can be used to fill the\\n    diagonal as a function of diagonal index (which starts at 0).\\n    The size (or shape) of the matrix must be given to obtain more\\n    than a 1x1 matrix:\\n\\n    >>> s = lambda d: (1 + d)**2\\n    >>> banded(5, {0: s, 2: s, -2: 2})\\n    Matrix([\\n    [1, 0, 1,  0,  0],\\n    [0, 4, 0,  4,  0],\\n    [2, 0, 9,  0,  9],\\n    [0, 2, 0, 16,  0],\\n    [0, 0, 2,  0, 25]])\\n\\n    The diagonal of matrices placed on a diagonal will coincide\\n    with the indicated diagonal:\\n\\n    >>> vert = Matrix([1, 2, 3])\\n    >>> banded({0: vert}, cols=3)\\n    Matrix([\\n    [1, 0, 0],\\n    [2, 1, 0],\\n    [3, 2, 1],\\n    [0, 3, 2],\\n    [0, 0, 3]])\\n\\n    >>> banded(4, {0: ones(2)})\\n    Matrix([\\n    [1, 1, 0, 0],\\n    [1, 1, 0, 0],\\n    [0, 0, 1, 1],\\n    [0, 0, 1, 1]])\\n\\n    Errors are raised if the designated size will not hold\\n    all values an integral number of times. Here, the rows\\n    are designated as odd (but an even number is required to\\n    hold the off-diagonal 2x2 ones):\\n\\n    >>> banded({0: 2, 1: ones(2)}, rows=5)\\n    Traceback (most recent call last):\\n    ...\\n    ValueError:\\n    sequence does not fit an integral number of times in the matrix\\n\\n    And here, an even number of rows is given...but the square\\n    matrix has an even number of columns, too. As we saw\\n    in the previous example, an odd number is required:\\n\\n    >>> banded(4, {0: 2, 1: ones(2)})  # trying to make 4x4 and cols must be odd\\n    Traceback (most recent call last):\\n    ...\\n    ValueError:\\n    sequence does not fit an integral number of times in the matrix\\n\\n    A way around having to count rows is to enclosing matrix elements\\n    in a tuple and indicate the desired number of them to the right:\\n\\n    >>> banded({0: 2, 2: (ones(2),)*3})\\n    Matrix([\\n    [2, 0, 1, 1, 0, 0, 0, 0],\\n    [0, 2, 1, 1, 0, 0, 0, 0],\\n    [0, 0, 2, 0, 1, 1, 0, 0],\\n    [0, 0, 0, 2, 1, 1, 0, 0],\\n    [0, 0, 0, 0, 2, 0, 1, 1],\\n    [0, 0, 0, 0, 0, 2, 1, 1]])\\n\\n    An error will be raised if more than one value\\n    is written to a given entry. Here, the ones overlap\\n    with the main diagonal if they are placed on the\\n    first diagonal:\\n\\n    >>> banded({0: (2,)*5, 1: (ones(2),)*3})\\n    Traceback (most recent call last):\\n    ...\\n    ValueError: collision at (1, 1)\\n\\n    By placing a 0 at the bottom left of the 2x2 matrix of\\n    ones, the collision is avoided:\\n\\n    >>> u2 = Matrix([\\n    ... [1, 1],\\n    ... [0, 1]])\\n    >>> banded({0: [2]*5, 1: [u2]*3})\\n    Matrix([\\n    [2, 1, 1, 0, 0, 0, 0],\\n    [0, 2, 1, 0, 0, 0, 0],\\n    [0, 0, 2, 1, 1, 0, 0],\\n    [0, 0, 0, 2, 1, 0, 0],\\n    [0, 0, 0, 0, 2, 1, 1],\\n    [0, 0, 0, 0, 0, 0, 1]])\\n    '\n    try:\n        if len(args) not in (1, 2, 3):\n            raise TypeError\n        if not isinstance(args[-1], (dict, Dict)):\n            raise TypeError\n        if len(args) == 1:\n            rows = kwargs.get('rows', None)\n            cols = kwargs.get('cols', None)\n            if rows is not None:\n                rows = as_int(rows)\n            if cols is not None:\n                cols = as_int(cols)\n        elif len(args) == 2:\n            rows = cols = as_int(args[0])\n        else:\n            (rows, cols) = map(as_int, args[:2])\n        _ = all((as_int(k) for k in args[-1]))\n    except (ValueError, TypeError):\n        raise TypeError(filldedent('unrecognized input to banded:\\n            expecting [[row,] col,] {int: value}'))\n\n    def rc(d):\n        r = -d if d < 0 else 0\n        c = 0 if r else d\n        return (r, c)\n    smat = {}\n    undone = []\n    tba = Dummy()\n    for (d, v) in args[-1].items():\n        (r, c) = rc(d)\n        if isinstance(v, (list, tuple)):\n            extra = 0\n            for (i, vi) in enumerate(v):\n                i += extra\n                if is_sequence(vi):\n                    vi = SparseMatrix(vi)\n                    smat[r + i, c + i] = vi\n                    extra += min(vi.shape) - 1\n                else:\n                    smat[r + i, c + i] = vi\n        elif is_sequence(v):\n            v = SparseMatrix(v)\n            (rv, cv) = v.shape\n            if rows and cols:\n                (nr, xr) = divmod(rows - r, rv)\n                (nc, xc) = divmod(cols - c, cv)\n                x = xr or xc\n                do = min(nr, nc)\n            elif rows:\n                (do, x) = divmod(rows - r, rv)\n            elif cols:\n                (do, x) = divmod(cols - c, cv)\n            else:\n                do = 1\n                x = 0\n            if x:\n                raise ValueError(filldedent('\\n                    sequence does not fit an integral number of times\\n                    in the matrix'))\n            j = min(v.shape)\n            for i in range(do):\n                smat[r, c] = v\n                r += j\n                c += j\n        elif v:\n            smat[r, c] = tba\n            undone.append((d, v))\n    s = SparseMatrix(None, smat)\n    smat = s.todok()\n    if rows is not None and rows < s.rows:\n        raise ValueError('Designated rows %s < needed %s' % (rows, s.rows))\n    if cols is not None and cols < s.cols:\n        raise ValueError('Designated cols %s < needed %s' % (cols, s.cols))\n    if rows is cols is None:\n        rows = s.rows\n        cols = s.cols\n    elif rows is not None and cols is None:\n        cols = max(rows, s.cols)\n    elif cols is not None and rows is None:\n        rows = max(cols, s.rows)\n\n    def update(i, j, v):\n        if v:\n            if (i, j) in smat and smat[i, j] not in (tba, v):\n                raise ValueError('collision at %s' % ((i, j),))\n            smat[i, j] = v\n    if undone:\n        for (d, vi) in undone:\n            (r, c) = rc(d)\n            v = vi if callable(vi) else lambda _: vi\n            i = 0\n            while r + i < rows and c + i < cols:\n                update(r + i, c + i, v(i))\n                i += 1\n    return SparseMatrix(rows, cols, smat)"
        ]
    }
]