[
    {
        "func_name": "get_data",
        "original": "def get_data(us_data, mean_M=None, std_M=None, mean_Q=None, std_Q=None):\n    dta_M = us_data[['CPIAUCSL', 'UNRATE', 'PAYEMS', 'RSAFS', 'TTLCONS', 'TCU']].copy()\n    dta_Q = us_data[['GDPC1', 'ULCNFB']].copy().resample('Q').last()\n    dta_M['CPIAUCSL'] = (dta_M['CPIAUCSL'] / dta_M['CPIAUCSL'].shift(1) - 1) * 100\n    dta_M['UNRATE'] = dta_M['UNRATE'].diff()\n    dta_M['PAYEMS'] = dta_M['PAYEMS'].diff()\n    dta_M['TCU'] = dta_M['TCU'].diff()\n    dta_M['RSAFS'] = (dta_M['RSAFS'] / dta_M['RSAFS'].shift(1) - 1) * 100\n    dta_M['TTLCONS'] = (dta_M['TTLCONS'] / dta_M['TTLCONS'].shift(1) - 1) * 100\n    dta_Q = ((dta_Q / dta_Q.shift(1)) ** 4 - 1) * 100\n    start = '2000'\n    dta_M = dta_M.loc[start:]\n    dta_Q = dta_Q.loc[start:]\n    first_ix = dta_M.first_valid_index()\n    last_ix = dta_M.last_valid_index()\n    dta_M = dta_M.loc[first_ix:last_ix]\n    first_ix = dta_Q.first_valid_index()\n    last_ix = dta_Q.last_valid_index()\n    dta_Q = dta_Q.loc[first_ix:last_ix]\n    return (dta_M, dta_Q)",
        "mutated": [
            "def get_data(us_data, mean_M=None, std_M=None, mean_Q=None, std_Q=None):\n    if False:\n        i = 10\n    dta_M = us_data[['CPIAUCSL', 'UNRATE', 'PAYEMS', 'RSAFS', 'TTLCONS', 'TCU']].copy()\n    dta_Q = us_data[['GDPC1', 'ULCNFB']].copy().resample('Q').last()\n    dta_M['CPIAUCSL'] = (dta_M['CPIAUCSL'] / dta_M['CPIAUCSL'].shift(1) - 1) * 100\n    dta_M['UNRATE'] = dta_M['UNRATE'].diff()\n    dta_M['PAYEMS'] = dta_M['PAYEMS'].diff()\n    dta_M['TCU'] = dta_M['TCU'].diff()\n    dta_M['RSAFS'] = (dta_M['RSAFS'] / dta_M['RSAFS'].shift(1) - 1) * 100\n    dta_M['TTLCONS'] = (dta_M['TTLCONS'] / dta_M['TTLCONS'].shift(1) - 1) * 100\n    dta_Q = ((dta_Q / dta_Q.shift(1)) ** 4 - 1) * 100\n    start = '2000'\n    dta_M = dta_M.loc[start:]\n    dta_Q = dta_Q.loc[start:]\n    first_ix = dta_M.first_valid_index()\n    last_ix = dta_M.last_valid_index()\n    dta_M = dta_M.loc[first_ix:last_ix]\n    first_ix = dta_Q.first_valid_index()\n    last_ix = dta_Q.last_valid_index()\n    dta_Q = dta_Q.loc[first_ix:last_ix]\n    return (dta_M, dta_Q)",
            "def get_data(us_data, mean_M=None, std_M=None, mean_Q=None, std_Q=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dta_M = us_data[['CPIAUCSL', 'UNRATE', 'PAYEMS', 'RSAFS', 'TTLCONS', 'TCU']].copy()\n    dta_Q = us_data[['GDPC1', 'ULCNFB']].copy().resample('Q').last()\n    dta_M['CPIAUCSL'] = (dta_M['CPIAUCSL'] / dta_M['CPIAUCSL'].shift(1) - 1) * 100\n    dta_M['UNRATE'] = dta_M['UNRATE'].diff()\n    dta_M['PAYEMS'] = dta_M['PAYEMS'].diff()\n    dta_M['TCU'] = dta_M['TCU'].diff()\n    dta_M['RSAFS'] = (dta_M['RSAFS'] / dta_M['RSAFS'].shift(1) - 1) * 100\n    dta_M['TTLCONS'] = (dta_M['TTLCONS'] / dta_M['TTLCONS'].shift(1) - 1) * 100\n    dta_Q = ((dta_Q / dta_Q.shift(1)) ** 4 - 1) * 100\n    start = '2000'\n    dta_M = dta_M.loc[start:]\n    dta_Q = dta_Q.loc[start:]\n    first_ix = dta_M.first_valid_index()\n    last_ix = dta_M.last_valid_index()\n    dta_M = dta_M.loc[first_ix:last_ix]\n    first_ix = dta_Q.first_valid_index()\n    last_ix = dta_Q.last_valid_index()\n    dta_Q = dta_Q.loc[first_ix:last_ix]\n    return (dta_M, dta_Q)",
            "def get_data(us_data, mean_M=None, std_M=None, mean_Q=None, std_Q=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dta_M = us_data[['CPIAUCSL', 'UNRATE', 'PAYEMS', 'RSAFS', 'TTLCONS', 'TCU']].copy()\n    dta_Q = us_data[['GDPC1', 'ULCNFB']].copy().resample('Q').last()\n    dta_M['CPIAUCSL'] = (dta_M['CPIAUCSL'] / dta_M['CPIAUCSL'].shift(1) - 1) * 100\n    dta_M['UNRATE'] = dta_M['UNRATE'].diff()\n    dta_M['PAYEMS'] = dta_M['PAYEMS'].diff()\n    dta_M['TCU'] = dta_M['TCU'].diff()\n    dta_M['RSAFS'] = (dta_M['RSAFS'] / dta_M['RSAFS'].shift(1) - 1) * 100\n    dta_M['TTLCONS'] = (dta_M['TTLCONS'] / dta_M['TTLCONS'].shift(1) - 1) * 100\n    dta_Q = ((dta_Q / dta_Q.shift(1)) ** 4 - 1) * 100\n    start = '2000'\n    dta_M = dta_M.loc[start:]\n    dta_Q = dta_Q.loc[start:]\n    first_ix = dta_M.first_valid_index()\n    last_ix = dta_M.last_valid_index()\n    dta_M = dta_M.loc[first_ix:last_ix]\n    first_ix = dta_Q.first_valid_index()\n    last_ix = dta_Q.last_valid_index()\n    dta_Q = dta_Q.loc[first_ix:last_ix]\n    return (dta_M, dta_Q)",
            "def get_data(us_data, mean_M=None, std_M=None, mean_Q=None, std_Q=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dta_M = us_data[['CPIAUCSL', 'UNRATE', 'PAYEMS', 'RSAFS', 'TTLCONS', 'TCU']].copy()\n    dta_Q = us_data[['GDPC1', 'ULCNFB']].copy().resample('Q').last()\n    dta_M['CPIAUCSL'] = (dta_M['CPIAUCSL'] / dta_M['CPIAUCSL'].shift(1) - 1) * 100\n    dta_M['UNRATE'] = dta_M['UNRATE'].diff()\n    dta_M['PAYEMS'] = dta_M['PAYEMS'].diff()\n    dta_M['TCU'] = dta_M['TCU'].diff()\n    dta_M['RSAFS'] = (dta_M['RSAFS'] / dta_M['RSAFS'].shift(1) - 1) * 100\n    dta_M['TTLCONS'] = (dta_M['TTLCONS'] / dta_M['TTLCONS'].shift(1) - 1) * 100\n    dta_Q = ((dta_Q / dta_Q.shift(1)) ** 4 - 1) * 100\n    start = '2000'\n    dta_M = dta_M.loc[start:]\n    dta_Q = dta_Q.loc[start:]\n    first_ix = dta_M.first_valid_index()\n    last_ix = dta_M.last_valid_index()\n    dta_M = dta_M.loc[first_ix:last_ix]\n    first_ix = dta_Q.first_valid_index()\n    last_ix = dta_Q.last_valid_index()\n    dta_Q = dta_Q.loc[first_ix:last_ix]\n    return (dta_M, dta_Q)",
            "def get_data(us_data, mean_M=None, std_M=None, mean_Q=None, std_Q=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dta_M = us_data[['CPIAUCSL', 'UNRATE', 'PAYEMS', 'RSAFS', 'TTLCONS', 'TCU']].copy()\n    dta_Q = us_data[['GDPC1', 'ULCNFB']].copy().resample('Q').last()\n    dta_M['CPIAUCSL'] = (dta_M['CPIAUCSL'] / dta_M['CPIAUCSL'].shift(1) - 1) * 100\n    dta_M['UNRATE'] = dta_M['UNRATE'].diff()\n    dta_M['PAYEMS'] = dta_M['PAYEMS'].diff()\n    dta_M['TCU'] = dta_M['TCU'].diff()\n    dta_M['RSAFS'] = (dta_M['RSAFS'] / dta_M['RSAFS'].shift(1) - 1) * 100\n    dta_M['TTLCONS'] = (dta_M['TTLCONS'] / dta_M['TTLCONS'].shift(1) - 1) * 100\n    dta_Q = ((dta_Q / dta_Q.shift(1)) ** 4 - 1) * 100\n    start = '2000'\n    dta_M = dta_M.loc[start:]\n    dta_Q = dta_Q.loc[start:]\n    first_ix = dta_M.first_valid_index()\n    last_ix = dta_M.last_valid_index()\n    dta_M = dta_M.loc[first_ix:last_ix]\n    first_ix = dta_Q.first_valid_index()\n    last_ix = dta_Q.last_valid_index()\n    dta_Q = dta_Q.loc[first_ix:last_ix]\n    return (dta_M, dta_Q)"
        ]
    },
    {
        "func_name": "matlab_results",
        "original": "@pytest.fixture(scope='module')\ndef matlab_results():\n    results = {}\n    for run in ['111', '112', '11F', '221', '222', '22F']:\n        res = matlab.loadmat(os.path.join(results_path, f'test_dfm_{run}.mat'))\n        k_factors = res['Spec']['k'][0, 0][0, 0]\n        factor_orders = res['Spec']['p'][0, 0][0, 0]\n        _factor_orders = max(5, factor_orders)\n        idio = k_factors * _factor_orders + 3\n        ix = np.r_[np.arange(idio), idio + np.arange(10).reshape(2, 5).ravel(order='F')]\n        initial_state = res['Res']['Z_0'][0, 0][:, 0][ix]\n        initial_state_cov = res['Res']['V_0'][0, 0][ix][:, ix]\n        if k_factors == 2:\n            factor_orders = {('0', '1'): factor_orders}\n        results[run] = {'k_endog_M': 3, 'factors': k_factors, 'factor_orders': factor_orders, 'factor_multiplicities': None, 'params': res['params'][:, 0], 'llf': res['Res']['loglik'][0, 0][0, 0], 'initial_state': initial_state, 'initial_state_cov': initial_state_cov, 'smoothed_forecasts': res['Res']['x_sm'][0, 0]}\n    for run in ['112', '222']:\n        res = matlab.loadmat(os.path.join(results_path, f'test_news_{run}.mat'))\n        k_factors = res['Spec']['k'][0, 0][0, 0]\n        factor_orders = res['Spec']['p'][0, 0][0, 0]\n        _factor_orders = max(5, factor_orders)\n        idio = k_factors * _factor_orders + 3\n        ix = np.r_[np.arange(idio), idio + np.arange(10).reshape(2, 5).ravel(order='F')]\n        initial_state = res['Res']['Z_0'][0, 0][:, 0][ix]\n        initial_state_cov = res['Res']['V_0'][0, 0][ix][:, ix]\n        if k_factors == 2:\n            factor_orders = {('0', '1'): factor_orders}\n        results[f'news_{run}'] = {'k_endog_M': 3, 'factors': k_factors, 'factor_orders': factor_orders, 'factor_multiplicities': None, 'params': res['params'][:, 0], 'initial_state': initial_state, 'initial_state_cov': initial_state_cov, 'revision_impacts': res['Res']['impact_revisions'][0, 0], 'weight': res['Res']['weight'], 'news_table': res['Res']['news_table'][0, 0]}\n    for run in ['111', '112', '221', '222']:\n        res = matlab.loadmat(os.path.join(results_path, f'test_dfm_blocks_{run}.mat'))\n        k_factors = res['Spec']['k'][0, 0][0, 0]\n        factor_order = res['Spec']['p'][0, 0][0, 0]\n        _factor_order = max(5, factor_order)\n        idio = 3 * k_factors * _factor_order + 6\n        ix = np.r_[np.arange(idio), idio + np.arange(10).reshape(2, 5).ravel(order='F')]\n        initial_state = res['Res']['Z_0'][0, 0][:, 0][ix]\n        initial_state_cov = res['Res']['V_0'][0, 0][ix][:, ix]\n        if k_factors == 1:\n            factors = BLOCK_FACTORS_KP1.copy()\n            factor_orders = BLOCK_FACTOR_ORDERS_KP1.copy()\n            factor_multiplicities = None\n        else:\n            factors = BLOCK_FACTORS_KP1.copy()\n            factor_orders = BLOCK_FACTOR_ORDERS_KP2.copy()\n            factor_multiplicities = BLOCK_FACTOR_MULTIPLICITIES_KP2.copy()\n        results[f'block_{run}'] = {'k_endog_M': 6, 'factors': factors, 'factor_orders': factor_orders, 'factor_multiplicities': factor_multiplicities, 'params': res['params'][:, 0], 'llf': res['Res']['loglik'][0, 0][0, 0], 'initial_state': initial_state, 'initial_state_cov': initial_state_cov, 'smoothed_forecasts': res['Res']['x_sm'][0, 0]}\n    for run in ['112', '222']:\n        res = matlab.loadmat(os.path.join(results_path, f'test_news_blocks_{run}.mat'))\n        k_factors = res['Spec']['k'][0, 0][0, 0]\n        factor_order = res['Spec']['p'][0, 0][0, 0]\n        _factor_order = max(5, factor_order)\n        idio = 3 * k_factors * _factor_order + 6\n        ix = np.r_[np.arange(idio), idio + np.arange(10).reshape(2, 5).ravel(order='F')]\n        initial_state = res['Res']['Z_0'][0, 0][:, 0][ix]\n        initial_state_cov = res['Res']['V_0'][0, 0][ix][:, ix]\n        if k_factors == 1:\n            factors = BLOCK_FACTORS_KP1.copy()\n            factor_orders = BLOCK_FACTOR_ORDERS_KP1.copy()\n            factor_multiplicities = None\n        else:\n            factors = BLOCK_FACTORS_KP1.copy()\n            factor_orders = BLOCK_FACTOR_ORDERS_KP2.copy()\n            factor_multiplicities = BLOCK_FACTOR_MULTIPLICITIES_KP2.copy()\n        results[f'news_block_{run}'] = {'k_endog_M': 6, 'factors': factors, 'factor_orders': factor_orders, 'factor_multiplicities': factor_multiplicities, 'params': res['params'][:, 0], 'initial_state': initial_state, 'initial_state_cov': initial_state_cov, 'revision_impacts': res['Res']['impact_revisions'][0, 0], 'weight': res['Res']['weight'], 'news_table': res['Res']['news_table'][0, 0]}\n\n    def get_data(us_data, mean_M=None, std_M=None, mean_Q=None, std_Q=None):\n        dta_M = us_data[['CPIAUCSL', 'UNRATE', 'PAYEMS', 'RSAFS', 'TTLCONS', 'TCU']].copy()\n        dta_Q = us_data[['GDPC1', 'ULCNFB']].copy().resample('Q').last()\n        dta_M['CPIAUCSL'] = (dta_M['CPIAUCSL'] / dta_M['CPIAUCSL'].shift(1) - 1) * 100\n        dta_M['UNRATE'] = dta_M['UNRATE'].diff()\n        dta_M['PAYEMS'] = dta_M['PAYEMS'].diff()\n        dta_M['TCU'] = dta_M['TCU'].diff()\n        dta_M['RSAFS'] = (dta_M['RSAFS'] / dta_M['RSAFS'].shift(1) - 1) * 100\n        dta_M['TTLCONS'] = (dta_M['TTLCONS'] / dta_M['TTLCONS'].shift(1) - 1) * 100\n        dta_Q = ((dta_Q / dta_Q.shift(1)) ** 4 - 1) * 100\n        start = '2000'\n        dta_M = dta_M.loc[start:]\n        dta_Q = dta_Q.loc[start:]\n        first_ix = dta_M.first_valid_index()\n        last_ix = dta_M.last_valid_index()\n        dta_M = dta_M.loc[first_ix:last_ix]\n        first_ix = dta_Q.first_valid_index()\n        last_ix = dta_Q.last_valid_index()\n        dta_Q = dta_Q.loc[first_ix:last_ix]\n        return (dta_M, dta_Q)\n    (endog_M, endog_Q) = get_data(us_data)\n    (updated_M, updated_Q) = get_data(us_data_update)\n    return (endog_M, endog_Q, results, updated_M, updated_Q)",
        "mutated": [
            "@pytest.fixture(scope='module')\ndef matlab_results():\n    if False:\n        i = 10\n    results = {}\n    for run in ['111', '112', '11F', '221', '222', '22F']:\n        res = matlab.loadmat(os.path.join(results_path, f'test_dfm_{run}.mat'))\n        k_factors = res['Spec']['k'][0, 0][0, 0]\n        factor_orders = res['Spec']['p'][0, 0][0, 0]\n        _factor_orders = max(5, factor_orders)\n        idio = k_factors * _factor_orders + 3\n        ix = np.r_[np.arange(idio), idio + np.arange(10).reshape(2, 5).ravel(order='F')]\n        initial_state = res['Res']['Z_0'][0, 0][:, 0][ix]\n        initial_state_cov = res['Res']['V_0'][0, 0][ix][:, ix]\n        if k_factors == 2:\n            factor_orders = {('0', '1'): factor_orders}\n        results[run] = {'k_endog_M': 3, 'factors': k_factors, 'factor_orders': factor_orders, 'factor_multiplicities': None, 'params': res['params'][:, 0], 'llf': res['Res']['loglik'][0, 0][0, 0], 'initial_state': initial_state, 'initial_state_cov': initial_state_cov, 'smoothed_forecasts': res['Res']['x_sm'][0, 0]}\n    for run in ['112', '222']:\n        res = matlab.loadmat(os.path.join(results_path, f'test_news_{run}.mat'))\n        k_factors = res['Spec']['k'][0, 0][0, 0]\n        factor_orders = res['Spec']['p'][0, 0][0, 0]\n        _factor_orders = max(5, factor_orders)\n        idio = k_factors * _factor_orders + 3\n        ix = np.r_[np.arange(idio), idio + np.arange(10).reshape(2, 5).ravel(order='F')]\n        initial_state = res['Res']['Z_0'][0, 0][:, 0][ix]\n        initial_state_cov = res['Res']['V_0'][0, 0][ix][:, ix]\n        if k_factors == 2:\n            factor_orders = {('0', '1'): factor_orders}\n        results[f'news_{run}'] = {'k_endog_M': 3, 'factors': k_factors, 'factor_orders': factor_orders, 'factor_multiplicities': None, 'params': res['params'][:, 0], 'initial_state': initial_state, 'initial_state_cov': initial_state_cov, 'revision_impacts': res['Res']['impact_revisions'][0, 0], 'weight': res['Res']['weight'], 'news_table': res['Res']['news_table'][0, 0]}\n    for run in ['111', '112', '221', '222']:\n        res = matlab.loadmat(os.path.join(results_path, f'test_dfm_blocks_{run}.mat'))\n        k_factors = res['Spec']['k'][0, 0][0, 0]\n        factor_order = res['Spec']['p'][0, 0][0, 0]\n        _factor_order = max(5, factor_order)\n        idio = 3 * k_factors * _factor_order + 6\n        ix = np.r_[np.arange(idio), idio + np.arange(10).reshape(2, 5).ravel(order='F')]\n        initial_state = res['Res']['Z_0'][0, 0][:, 0][ix]\n        initial_state_cov = res['Res']['V_0'][0, 0][ix][:, ix]\n        if k_factors == 1:\n            factors = BLOCK_FACTORS_KP1.copy()\n            factor_orders = BLOCK_FACTOR_ORDERS_KP1.copy()\n            factor_multiplicities = None\n        else:\n            factors = BLOCK_FACTORS_KP1.copy()\n            factor_orders = BLOCK_FACTOR_ORDERS_KP2.copy()\n            factor_multiplicities = BLOCK_FACTOR_MULTIPLICITIES_KP2.copy()\n        results[f'block_{run}'] = {'k_endog_M': 6, 'factors': factors, 'factor_orders': factor_orders, 'factor_multiplicities': factor_multiplicities, 'params': res['params'][:, 0], 'llf': res['Res']['loglik'][0, 0][0, 0], 'initial_state': initial_state, 'initial_state_cov': initial_state_cov, 'smoothed_forecasts': res['Res']['x_sm'][0, 0]}\n    for run in ['112', '222']:\n        res = matlab.loadmat(os.path.join(results_path, f'test_news_blocks_{run}.mat'))\n        k_factors = res['Spec']['k'][0, 0][0, 0]\n        factor_order = res['Spec']['p'][0, 0][0, 0]\n        _factor_order = max(5, factor_order)\n        idio = 3 * k_factors * _factor_order + 6\n        ix = np.r_[np.arange(idio), idio + np.arange(10).reshape(2, 5).ravel(order='F')]\n        initial_state = res['Res']['Z_0'][0, 0][:, 0][ix]\n        initial_state_cov = res['Res']['V_0'][0, 0][ix][:, ix]\n        if k_factors == 1:\n            factors = BLOCK_FACTORS_KP1.copy()\n            factor_orders = BLOCK_FACTOR_ORDERS_KP1.copy()\n            factor_multiplicities = None\n        else:\n            factors = BLOCK_FACTORS_KP1.copy()\n            factor_orders = BLOCK_FACTOR_ORDERS_KP2.copy()\n            factor_multiplicities = BLOCK_FACTOR_MULTIPLICITIES_KP2.copy()\n        results[f'news_block_{run}'] = {'k_endog_M': 6, 'factors': factors, 'factor_orders': factor_orders, 'factor_multiplicities': factor_multiplicities, 'params': res['params'][:, 0], 'initial_state': initial_state, 'initial_state_cov': initial_state_cov, 'revision_impacts': res['Res']['impact_revisions'][0, 0], 'weight': res['Res']['weight'], 'news_table': res['Res']['news_table'][0, 0]}\n\n    def get_data(us_data, mean_M=None, std_M=None, mean_Q=None, std_Q=None):\n        dta_M = us_data[['CPIAUCSL', 'UNRATE', 'PAYEMS', 'RSAFS', 'TTLCONS', 'TCU']].copy()\n        dta_Q = us_data[['GDPC1', 'ULCNFB']].copy().resample('Q').last()\n        dta_M['CPIAUCSL'] = (dta_M['CPIAUCSL'] / dta_M['CPIAUCSL'].shift(1) - 1) * 100\n        dta_M['UNRATE'] = dta_M['UNRATE'].diff()\n        dta_M['PAYEMS'] = dta_M['PAYEMS'].diff()\n        dta_M['TCU'] = dta_M['TCU'].diff()\n        dta_M['RSAFS'] = (dta_M['RSAFS'] / dta_M['RSAFS'].shift(1) - 1) * 100\n        dta_M['TTLCONS'] = (dta_M['TTLCONS'] / dta_M['TTLCONS'].shift(1) - 1) * 100\n        dta_Q = ((dta_Q / dta_Q.shift(1)) ** 4 - 1) * 100\n        start = '2000'\n        dta_M = dta_M.loc[start:]\n        dta_Q = dta_Q.loc[start:]\n        first_ix = dta_M.first_valid_index()\n        last_ix = dta_M.last_valid_index()\n        dta_M = dta_M.loc[first_ix:last_ix]\n        first_ix = dta_Q.first_valid_index()\n        last_ix = dta_Q.last_valid_index()\n        dta_Q = dta_Q.loc[first_ix:last_ix]\n        return (dta_M, dta_Q)\n    (endog_M, endog_Q) = get_data(us_data)\n    (updated_M, updated_Q) = get_data(us_data_update)\n    return (endog_M, endog_Q, results, updated_M, updated_Q)",
            "@pytest.fixture(scope='module')\ndef matlab_results():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    results = {}\n    for run in ['111', '112', '11F', '221', '222', '22F']:\n        res = matlab.loadmat(os.path.join(results_path, f'test_dfm_{run}.mat'))\n        k_factors = res['Spec']['k'][0, 0][0, 0]\n        factor_orders = res['Spec']['p'][0, 0][0, 0]\n        _factor_orders = max(5, factor_orders)\n        idio = k_factors * _factor_orders + 3\n        ix = np.r_[np.arange(idio), idio + np.arange(10).reshape(2, 5).ravel(order='F')]\n        initial_state = res['Res']['Z_0'][0, 0][:, 0][ix]\n        initial_state_cov = res['Res']['V_0'][0, 0][ix][:, ix]\n        if k_factors == 2:\n            factor_orders = {('0', '1'): factor_orders}\n        results[run] = {'k_endog_M': 3, 'factors': k_factors, 'factor_orders': factor_orders, 'factor_multiplicities': None, 'params': res['params'][:, 0], 'llf': res['Res']['loglik'][0, 0][0, 0], 'initial_state': initial_state, 'initial_state_cov': initial_state_cov, 'smoothed_forecasts': res['Res']['x_sm'][0, 0]}\n    for run in ['112', '222']:\n        res = matlab.loadmat(os.path.join(results_path, f'test_news_{run}.mat'))\n        k_factors = res['Spec']['k'][0, 0][0, 0]\n        factor_orders = res['Spec']['p'][0, 0][0, 0]\n        _factor_orders = max(5, factor_orders)\n        idio = k_factors * _factor_orders + 3\n        ix = np.r_[np.arange(idio), idio + np.arange(10).reshape(2, 5).ravel(order='F')]\n        initial_state = res['Res']['Z_0'][0, 0][:, 0][ix]\n        initial_state_cov = res['Res']['V_0'][0, 0][ix][:, ix]\n        if k_factors == 2:\n            factor_orders = {('0', '1'): factor_orders}\n        results[f'news_{run}'] = {'k_endog_M': 3, 'factors': k_factors, 'factor_orders': factor_orders, 'factor_multiplicities': None, 'params': res['params'][:, 0], 'initial_state': initial_state, 'initial_state_cov': initial_state_cov, 'revision_impacts': res['Res']['impact_revisions'][0, 0], 'weight': res['Res']['weight'], 'news_table': res['Res']['news_table'][0, 0]}\n    for run in ['111', '112', '221', '222']:\n        res = matlab.loadmat(os.path.join(results_path, f'test_dfm_blocks_{run}.mat'))\n        k_factors = res['Spec']['k'][0, 0][0, 0]\n        factor_order = res['Spec']['p'][0, 0][0, 0]\n        _factor_order = max(5, factor_order)\n        idio = 3 * k_factors * _factor_order + 6\n        ix = np.r_[np.arange(idio), idio + np.arange(10).reshape(2, 5).ravel(order='F')]\n        initial_state = res['Res']['Z_0'][0, 0][:, 0][ix]\n        initial_state_cov = res['Res']['V_0'][0, 0][ix][:, ix]\n        if k_factors == 1:\n            factors = BLOCK_FACTORS_KP1.copy()\n            factor_orders = BLOCK_FACTOR_ORDERS_KP1.copy()\n            factor_multiplicities = None\n        else:\n            factors = BLOCK_FACTORS_KP1.copy()\n            factor_orders = BLOCK_FACTOR_ORDERS_KP2.copy()\n            factor_multiplicities = BLOCK_FACTOR_MULTIPLICITIES_KP2.copy()\n        results[f'block_{run}'] = {'k_endog_M': 6, 'factors': factors, 'factor_orders': factor_orders, 'factor_multiplicities': factor_multiplicities, 'params': res['params'][:, 0], 'llf': res['Res']['loglik'][0, 0][0, 0], 'initial_state': initial_state, 'initial_state_cov': initial_state_cov, 'smoothed_forecasts': res['Res']['x_sm'][0, 0]}\n    for run in ['112', '222']:\n        res = matlab.loadmat(os.path.join(results_path, f'test_news_blocks_{run}.mat'))\n        k_factors = res['Spec']['k'][0, 0][0, 0]\n        factor_order = res['Spec']['p'][0, 0][0, 0]\n        _factor_order = max(5, factor_order)\n        idio = 3 * k_factors * _factor_order + 6\n        ix = np.r_[np.arange(idio), idio + np.arange(10).reshape(2, 5).ravel(order='F')]\n        initial_state = res['Res']['Z_0'][0, 0][:, 0][ix]\n        initial_state_cov = res['Res']['V_0'][0, 0][ix][:, ix]\n        if k_factors == 1:\n            factors = BLOCK_FACTORS_KP1.copy()\n            factor_orders = BLOCK_FACTOR_ORDERS_KP1.copy()\n            factor_multiplicities = None\n        else:\n            factors = BLOCK_FACTORS_KP1.copy()\n            factor_orders = BLOCK_FACTOR_ORDERS_KP2.copy()\n            factor_multiplicities = BLOCK_FACTOR_MULTIPLICITIES_KP2.copy()\n        results[f'news_block_{run}'] = {'k_endog_M': 6, 'factors': factors, 'factor_orders': factor_orders, 'factor_multiplicities': factor_multiplicities, 'params': res['params'][:, 0], 'initial_state': initial_state, 'initial_state_cov': initial_state_cov, 'revision_impacts': res['Res']['impact_revisions'][0, 0], 'weight': res['Res']['weight'], 'news_table': res['Res']['news_table'][0, 0]}\n\n    def get_data(us_data, mean_M=None, std_M=None, mean_Q=None, std_Q=None):\n        dta_M = us_data[['CPIAUCSL', 'UNRATE', 'PAYEMS', 'RSAFS', 'TTLCONS', 'TCU']].copy()\n        dta_Q = us_data[['GDPC1', 'ULCNFB']].copy().resample('Q').last()\n        dta_M['CPIAUCSL'] = (dta_M['CPIAUCSL'] / dta_M['CPIAUCSL'].shift(1) - 1) * 100\n        dta_M['UNRATE'] = dta_M['UNRATE'].diff()\n        dta_M['PAYEMS'] = dta_M['PAYEMS'].diff()\n        dta_M['TCU'] = dta_M['TCU'].diff()\n        dta_M['RSAFS'] = (dta_M['RSAFS'] / dta_M['RSAFS'].shift(1) - 1) * 100\n        dta_M['TTLCONS'] = (dta_M['TTLCONS'] / dta_M['TTLCONS'].shift(1) - 1) * 100\n        dta_Q = ((dta_Q / dta_Q.shift(1)) ** 4 - 1) * 100\n        start = '2000'\n        dta_M = dta_M.loc[start:]\n        dta_Q = dta_Q.loc[start:]\n        first_ix = dta_M.first_valid_index()\n        last_ix = dta_M.last_valid_index()\n        dta_M = dta_M.loc[first_ix:last_ix]\n        first_ix = dta_Q.first_valid_index()\n        last_ix = dta_Q.last_valid_index()\n        dta_Q = dta_Q.loc[first_ix:last_ix]\n        return (dta_M, dta_Q)\n    (endog_M, endog_Q) = get_data(us_data)\n    (updated_M, updated_Q) = get_data(us_data_update)\n    return (endog_M, endog_Q, results, updated_M, updated_Q)",
            "@pytest.fixture(scope='module')\ndef matlab_results():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    results = {}\n    for run in ['111', '112', '11F', '221', '222', '22F']:\n        res = matlab.loadmat(os.path.join(results_path, f'test_dfm_{run}.mat'))\n        k_factors = res['Spec']['k'][0, 0][0, 0]\n        factor_orders = res['Spec']['p'][0, 0][0, 0]\n        _factor_orders = max(5, factor_orders)\n        idio = k_factors * _factor_orders + 3\n        ix = np.r_[np.arange(idio), idio + np.arange(10).reshape(2, 5).ravel(order='F')]\n        initial_state = res['Res']['Z_0'][0, 0][:, 0][ix]\n        initial_state_cov = res['Res']['V_0'][0, 0][ix][:, ix]\n        if k_factors == 2:\n            factor_orders = {('0', '1'): factor_orders}\n        results[run] = {'k_endog_M': 3, 'factors': k_factors, 'factor_orders': factor_orders, 'factor_multiplicities': None, 'params': res['params'][:, 0], 'llf': res['Res']['loglik'][0, 0][0, 0], 'initial_state': initial_state, 'initial_state_cov': initial_state_cov, 'smoothed_forecasts': res['Res']['x_sm'][0, 0]}\n    for run in ['112', '222']:\n        res = matlab.loadmat(os.path.join(results_path, f'test_news_{run}.mat'))\n        k_factors = res['Spec']['k'][0, 0][0, 0]\n        factor_orders = res['Spec']['p'][0, 0][0, 0]\n        _factor_orders = max(5, factor_orders)\n        idio = k_factors * _factor_orders + 3\n        ix = np.r_[np.arange(idio), idio + np.arange(10).reshape(2, 5).ravel(order='F')]\n        initial_state = res['Res']['Z_0'][0, 0][:, 0][ix]\n        initial_state_cov = res['Res']['V_0'][0, 0][ix][:, ix]\n        if k_factors == 2:\n            factor_orders = {('0', '1'): factor_orders}\n        results[f'news_{run}'] = {'k_endog_M': 3, 'factors': k_factors, 'factor_orders': factor_orders, 'factor_multiplicities': None, 'params': res['params'][:, 0], 'initial_state': initial_state, 'initial_state_cov': initial_state_cov, 'revision_impacts': res['Res']['impact_revisions'][0, 0], 'weight': res['Res']['weight'], 'news_table': res['Res']['news_table'][0, 0]}\n    for run in ['111', '112', '221', '222']:\n        res = matlab.loadmat(os.path.join(results_path, f'test_dfm_blocks_{run}.mat'))\n        k_factors = res['Spec']['k'][0, 0][0, 0]\n        factor_order = res['Spec']['p'][0, 0][0, 0]\n        _factor_order = max(5, factor_order)\n        idio = 3 * k_factors * _factor_order + 6\n        ix = np.r_[np.arange(idio), idio + np.arange(10).reshape(2, 5).ravel(order='F')]\n        initial_state = res['Res']['Z_0'][0, 0][:, 0][ix]\n        initial_state_cov = res['Res']['V_0'][0, 0][ix][:, ix]\n        if k_factors == 1:\n            factors = BLOCK_FACTORS_KP1.copy()\n            factor_orders = BLOCK_FACTOR_ORDERS_KP1.copy()\n            factor_multiplicities = None\n        else:\n            factors = BLOCK_FACTORS_KP1.copy()\n            factor_orders = BLOCK_FACTOR_ORDERS_KP2.copy()\n            factor_multiplicities = BLOCK_FACTOR_MULTIPLICITIES_KP2.copy()\n        results[f'block_{run}'] = {'k_endog_M': 6, 'factors': factors, 'factor_orders': factor_orders, 'factor_multiplicities': factor_multiplicities, 'params': res['params'][:, 0], 'llf': res['Res']['loglik'][0, 0][0, 0], 'initial_state': initial_state, 'initial_state_cov': initial_state_cov, 'smoothed_forecasts': res['Res']['x_sm'][0, 0]}\n    for run in ['112', '222']:\n        res = matlab.loadmat(os.path.join(results_path, f'test_news_blocks_{run}.mat'))\n        k_factors = res['Spec']['k'][0, 0][0, 0]\n        factor_order = res['Spec']['p'][0, 0][0, 0]\n        _factor_order = max(5, factor_order)\n        idio = 3 * k_factors * _factor_order + 6\n        ix = np.r_[np.arange(idio), idio + np.arange(10).reshape(2, 5).ravel(order='F')]\n        initial_state = res['Res']['Z_0'][0, 0][:, 0][ix]\n        initial_state_cov = res['Res']['V_0'][0, 0][ix][:, ix]\n        if k_factors == 1:\n            factors = BLOCK_FACTORS_KP1.copy()\n            factor_orders = BLOCK_FACTOR_ORDERS_KP1.copy()\n            factor_multiplicities = None\n        else:\n            factors = BLOCK_FACTORS_KP1.copy()\n            factor_orders = BLOCK_FACTOR_ORDERS_KP2.copy()\n            factor_multiplicities = BLOCK_FACTOR_MULTIPLICITIES_KP2.copy()\n        results[f'news_block_{run}'] = {'k_endog_M': 6, 'factors': factors, 'factor_orders': factor_orders, 'factor_multiplicities': factor_multiplicities, 'params': res['params'][:, 0], 'initial_state': initial_state, 'initial_state_cov': initial_state_cov, 'revision_impacts': res['Res']['impact_revisions'][0, 0], 'weight': res['Res']['weight'], 'news_table': res['Res']['news_table'][0, 0]}\n\n    def get_data(us_data, mean_M=None, std_M=None, mean_Q=None, std_Q=None):\n        dta_M = us_data[['CPIAUCSL', 'UNRATE', 'PAYEMS', 'RSAFS', 'TTLCONS', 'TCU']].copy()\n        dta_Q = us_data[['GDPC1', 'ULCNFB']].copy().resample('Q').last()\n        dta_M['CPIAUCSL'] = (dta_M['CPIAUCSL'] / dta_M['CPIAUCSL'].shift(1) - 1) * 100\n        dta_M['UNRATE'] = dta_M['UNRATE'].diff()\n        dta_M['PAYEMS'] = dta_M['PAYEMS'].diff()\n        dta_M['TCU'] = dta_M['TCU'].diff()\n        dta_M['RSAFS'] = (dta_M['RSAFS'] / dta_M['RSAFS'].shift(1) - 1) * 100\n        dta_M['TTLCONS'] = (dta_M['TTLCONS'] / dta_M['TTLCONS'].shift(1) - 1) * 100\n        dta_Q = ((dta_Q / dta_Q.shift(1)) ** 4 - 1) * 100\n        start = '2000'\n        dta_M = dta_M.loc[start:]\n        dta_Q = dta_Q.loc[start:]\n        first_ix = dta_M.first_valid_index()\n        last_ix = dta_M.last_valid_index()\n        dta_M = dta_M.loc[first_ix:last_ix]\n        first_ix = dta_Q.first_valid_index()\n        last_ix = dta_Q.last_valid_index()\n        dta_Q = dta_Q.loc[first_ix:last_ix]\n        return (dta_M, dta_Q)\n    (endog_M, endog_Q) = get_data(us_data)\n    (updated_M, updated_Q) = get_data(us_data_update)\n    return (endog_M, endog_Q, results, updated_M, updated_Q)",
            "@pytest.fixture(scope='module')\ndef matlab_results():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    results = {}\n    for run in ['111', '112', '11F', '221', '222', '22F']:\n        res = matlab.loadmat(os.path.join(results_path, f'test_dfm_{run}.mat'))\n        k_factors = res['Spec']['k'][0, 0][0, 0]\n        factor_orders = res['Spec']['p'][0, 0][0, 0]\n        _factor_orders = max(5, factor_orders)\n        idio = k_factors * _factor_orders + 3\n        ix = np.r_[np.arange(idio), idio + np.arange(10).reshape(2, 5).ravel(order='F')]\n        initial_state = res['Res']['Z_0'][0, 0][:, 0][ix]\n        initial_state_cov = res['Res']['V_0'][0, 0][ix][:, ix]\n        if k_factors == 2:\n            factor_orders = {('0', '1'): factor_orders}\n        results[run] = {'k_endog_M': 3, 'factors': k_factors, 'factor_orders': factor_orders, 'factor_multiplicities': None, 'params': res['params'][:, 0], 'llf': res['Res']['loglik'][0, 0][0, 0], 'initial_state': initial_state, 'initial_state_cov': initial_state_cov, 'smoothed_forecasts': res['Res']['x_sm'][0, 0]}\n    for run in ['112', '222']:\n        res = matlab.loadmat(os.path.join(results_path, f'test_news_{run}.mat'))\n        k_factors = res['Spec']['k'][0, 0][0, 0]\n        factor_orders = res['Spec']['p'][0, 0][0, 0]\n        _factor_orders = max(5, factor_orders)\n        idio = k_factors * _factor_orders + 3\n        ix = np.r_[np.arange(idio), idio + np.arange(10).reshape(2, 5).ravel(order='F')]\n        initial_state = res['Res']['Z_0'][0, 0][:, 0][ix]\n        initial_state_cov = res['Res']['V_0'][0, 0][ix][:, ix]\n        if k_factors == 2:\n            factor_orders = {('0', '1'): factor_orders}\n        results[f'news_{run}'] = {'k_endog_M': 3, 'factors': k_factors, 'factor_orders': factor_orders, 'factor_multiplicities': None, 'params': res['params'][:, 0], 'initial_state': initial_state, 'initial_state_cov': initial_state_cov, 'revision_impacts': res['Res']['impact_revisions'][0, 0], 'weight': res['Res']['weight'], 'news_table': res['Res']['news_table'][0, 0]}\n    for run in ['111', '112', '221', '222']:\n        res = matlab.loadmat(os.path.join(results_path, f'test_dfm_blocks_{run}.mat'))\n        k_factors = res['Spec']['k'][0, 0][0, 0]\n        factor_order = res['Spec']['p'][0, 0][0, 0]\n        _factor_order = max(5, factor_order)\n        idio = 3 * k_factors * _factor_order + 6\n        ix = np.r_[np.arange(idio), idio + np.arange(10).reshape(2, 5).ravel(order='F')]\n        initial_state = res['Res']['Z_0'][0, 0][:, 0][ix]\n        initial_state_cov = res['Res']['V_0'][0, 0][ix][:, ix]\n        if k_factors == 1:\n            factors = BLOCK_FACTORS_KP1.copy()\n            factor_orders = BLOCK_FACTOR_ORDERS_KP1.copy()\n            factor_multiplicities = None\n        else:\n            factors = BLOCK_FACTORS_KP1.copy()\n            factor_orders = BLOCK_FACTOR_ORDERS_KP2.copy()\n            factor_multiplicities = BLOCK_FACTOR_MULTIPLICITIES_KP2.copy()\n        results[f'block_{run}'] = {'k_endog_M': 6, 'factors': factors, 'factor_orders': factor_orders, 'factor_multiplicities': factor_multiplicities, 'params': res['params'][:, 0], 'llf': res['Res']['loglik'][0, 0][0, 0], 'initial_state': initial_state, 'initial_state_cov': initial_state_cov, 'smoothed_forecasts': res['Res']['x_sm'][0, 0]}\n    for run in ['112', '222']:\n        res = matlab.loadmat(os.path.join(results_path, f'test_news_blocks_{run}.mat'))\n        k_factors = res['Spec']['k'][0, 0][0, 0]\n        factor_order = res['Spec']['p'][0, 0][0, 0]\n        _factor_order = max(5, factor_order)\n        idio = 3 * k_factors * _factor_order + 6\n        ix = np.r_[np.arange(idio), idio + np.arange(10).reshape(2, 5).ravel(order='F')]\n        initial_state = res['Res']['Z_0'][0, 0][:, 0][ix]\n        initial_state_cov = res['Res']['V_0'][0, 0][ix][:, ix]\n        if k_factors == 1:\n            factors = BLOCK_FACTORS_KP1.copy()\n            factor_orders = BLOCK_FACTOR_ORDERS_KP1.copy()\n            factor_multiplicities = None\n        else:\n            factors = BLOCK_FACTORS_KP1.copy()\n            factor_orders = BLOCK_FACTOR_ORDERS_KP2.copy()\n            factor_multiplicities = BLOCK_FACTOR_MULTIPLICITIES_KP2.copy()\n        results[f'news_block_{run}'] = {'k_endog_M': 6, 'factors': factors, 'factor_orders': factor_orders, 'factor_multiplicities': factor_multiplicities, 'params': res['params'][:, 0], 'initial_state': initial_state, 'initial_state_cov': initial_state_cov, 'revision_impacts': res['Res']['impact_revisions'][0, 0], 'weight': res['Res']['weight'], 'news_table': res['Res']['news_table'][0, 0]}\n\n    def get_data(us_data, mean_M=None, std_M=None, mean_Q=None, std_Q=None):\n        dta_M = us_data[['CPIAUCSL', 'UNRATE', 'PAYEMS', 'RSAFS', 'TTLCONS', 'TCU']].copy()\n        dta_Q = us_data[['GDPC1', 'ULCNFB']].copy().resample('Q').last()\n        dta_M['CPIAUCSL'] = (dta_M['CPIAUCSL'] / dta_M['CPIAUCSL'].shift(1) - 1) * 100\n        dta_M['UNRATE'] = dta_M['UNRATE'].diff()\n        dta_M['PAYEMS'] = dta_M['PAYEMS'].diff()\n        dta_M['TCU'] = dta_M['TCU'].diff()\n        dta_M['RSAFS'] = (dta_M['RSAFS'] / dta_M['RSAFS'].shift(1) - 1) * 100\n        dta_M['TTLCONS'] = (dta_M['TTLCONS'] / dta_M['TTLCONS'].shift(1) - 1) * 100\n        dta_Q = ((dta_Q / dta_Q.shift(1)) ** 4 - 1) * 100\n        start = '2000'\n        dta_M = dta_M.loc[start:]\n        dta_Q = dta_Q.loc[start:]\n        first_ix = dta_M.first_valid_index()\n        last_ix = dta_M.last_valid_index()\n        dta_M = dta_M.loc[first_ix:last_ix]\n        first_ix = dta_Q.first_valid_index()\n        last_ix = dta_Q.last_valid_index()\n        dta_Q = dta_Q.loc[first_ix:last_ix]\n        return (dta_M, dta_Q)\n    (endog_M, endog_Q) = get_data(us_data)\n    (updated_M, updated_Q) = get_data(us_data_update)\n    return (endog_M, endog_Q, results, updated_M, updated_Q)",
            "@pytest.fixture(scope='module')\ndef matlab_results():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    results = {}\n    for run in ['111', '112', '11F', '221', '222', '22F']:\n        res = matlab.loadmat(os.path.join(results_path, f'test_dfm_{run}.mat'))\n        k_factors = res['Spec']['k'][0, 0][0, 0]\n        factor_orders = res['Spec']['p'][0, 0][0, 0]\n        _factor_orders = max(5, factor_orders)\n        idio = k_factors * _factor_orders + 3\n        ix = np.r_[np.arange(idio), idio + np.arange(10).reshape(2, 5).ravel(order='F')]\n        initial_state = res['Res']['Z_0'][0, 0][:, 0][ix]\n        initial_state_cov = res['Res']['V_0'][0, 0][ix][:, ix]\n        if k_factors == 2:\n            factor_orders = {('0', '1'): factor_orders}\n        results[run] = {'k_endog_M': 3, 'factors': k_factors, 'factor_orders': factor_orders, 'factor_multiplicities': None, 'params': res['params'][:, 0], 'llf': res['Res']['loglik'][0, 0][0, 0], 'initial_state': initial_state, 'initial_state_cov': initial_state_cov, 'smoothed_forecasts': res['Res']['x_sm'][0, 0]}\n    for run in ['112', '222']:\n        res = matlab.loadmat(os.path.join(results_path, f'test_news_{run}.mat'))\n        k_factors = res['Spec']['k'][0, 0][0, 0]\n        factor_orders = res['Spec']['p'][0, 0][0, 0]\n        _factor_orders = max(5, factor_orders)\n        idio = k_factors * _factor_orders + 3\n        ix = np.r_[np.arange(idio), idio + np.arange(10).reshape(2, 5).ravel(order='F')]\n        initial_state = res['Res']['Z_0'][0, 0][:, 0][ix]\n        initial_state_cov = res['Res']['V_0'][0, 0][ix][:, ix]\n        if k_factors == 2:\n            factor_orders = {('0', '1'): factor_orders}\n        results[f'news_{run}'] = {'k_endog_M': 3, 'factors': k_factors, 'factor_orders': factor_orders, 'factor_multiplicities': None, 'params': res['params'][:, 0], 'initial_state': initial_state, 'initial_state_cov': initial_state_cov, 'revision_impacts': res['Res']['impact_revisions'][0, 0], 'weight': res['Res']['weight'], 'news_table': res['Res']['news_table'][0, 0]}\n    for run in ['111', '112', '221', '222']:\n        res = matlab.loadmat(os.path.join(results_path, f'test_dfm_blocks_{run}.mat'))\n        k_factors = res['Spec']['k'][0, 0][0, 0]\n        factor_order = res['Spec']['p'][0, 0][0, 0]\n        _factor_order = max(5, factor_order)\n        idio = 3 * k_factors * _factor_order + 6\n        ix = np.r_[np.arange(idio), idio + np.arange(10).reshape(2, 5).ravel(order='F')]\n        initial_state = res['Res']['Z_0'][0, 0][:, 0][ix]\n        initial_state_cov = res['Res']['V_0'][0, 0][ix][:, ix]\n        if k_factors == 1:\n            factors = BLOCK_FACTORS_KP1.copy()\n            factor_orders = BLOCK_FACTOR_ORDERS_KP1.copy()\n            factor_multiplicities = None\n        else:\n            factors = BLOCK_FACTORS_KP1.copy()\n            factor_orders = BLOCK_FACTOR_ORDERS_KP2.copy()\n            factor_multiplicities = BLOCK_FACTOR_MULTIPLICITIES_KP2.copy()\n        results[f'block_{run}'] = {'k_endog_M': 6, 'factors': factors, 'factor_orders': factor_orders, 'factor_multiplicities': factor_multiplicities, 'params': res['params'][:, 0], 'llf': res['Res']['loglik'][0, 0][0, 0], 'initial_state': initial_state, 'initial_state_cov': initial_state_cov, 'smoothed_forecasts': res['Res']['x_sm'][0, 0]}\n    for run in ['112', '222']:\n        res = matlab.loadmat(os.path.join(results_path, f'test_news_blocks_{run}.mat'))\n        k_factors = res['Spec']['k'][0, 0][0, 0]\n        factor_order = res['Spec']['p'][0, 0][0, 0]\n        _factor_order = max(5, factor_order)\n        idio = 3 * k_factors * _factor_order + 6\n        ix = np.r_[np.arange(idio), idio + np.arange(10).reshape(2, 5).ravel(order='F')]\n        initial_state = res['Res']['Z_0'][0, 0][:, 0][ix]\n        initial_state_cov = res['Res']['V_0'][0, 0][ix][:, ix]\n        if k_factors == 1:\n            factors = BLOCK_FACTORS_KP1.copy()\n            factor_orders = BLOCK_FACTOR_ORDERS_KP1.copy()\n            factor_multiplicities = None\n        else:\n            factors = BLOCK_FACTORS_KP1.copy()\n            factor_orders = BLOCK_FACTOR_ORDERS_KP2.copy()\n            factor_multiplicities = BLOCK_FACTOR_MULTIPLICITIES_KP2.copy()\n        results[f'news_block_{run}'] = {'k_endog_M': 6, 'factors': factors, 'factor_orders': factor_orders, 'factor_multiplicities': factor_multiplicities, 'params': res['params'][:, 0], 'initial_state': initial_state, 'initial_state_cov': initial_state_cov, 'revision_impacts': res['Res']['impact_revisions'][0, 0], 'weight': res['Res']['weight'], 'news_table': res['Res']['news_table'][0, 0]}\n\n    def get_data(us_data, mean_M=None, std_M=None, mean_Q=None, std_Q=None):\n        dta_M = us_data[['CPIAUCSL', 'UNRATE', 'PAYEMS', 'RSAFS', 'TTLCONS', 'TCU']].copy()\n        dta_Q = us_data[['GDPC1', 'ULCNFB']].copy().resample('Q').last()\n        dta_M['CPIAUCSL'] = (dta_M['CPIAUCSL'] / dta_M['CPIAUCSL'].shift(1) - 1) * 100\n        dta_M['UNRATE'] = dta_M['UNRATE'].diff()\n        dta_M['PAYEMS'] = dta_M['PAYEMS'].diff()\n        dta_M['TCU'] = dta_M['TCU'].diff()\n        dta_M['RSAFS'] = (dta_M['RSAFS'] / dta_M['RSAFS'].shift(1) - 1) * 100\n        dta_M['TTLCONS'] = (dta_M['TTLCONS'] / dta_M['TTLCONS'].shift(1) - 1) * 100\n        dta_Q = ((dta_Q / dta_Q.shift(1)) ** 4 - 1) * 100\n        start = '2000'\n        dta_M = dta_M.loc[start:]\n        dta_Q = dta_Q.loc[start:]\n        first_ix = dta_M.first_valid_index()\n        last_ix = dta_M.last_valid_index()\n        dta_M = dta_M.loc[first_ix:last_ix]\n        first_ix = dta_Q.first_valid_index()\n        last_ix = dta_Q.last_valid_index()\n        dta_Q = dta_Q.loc[first_ix:last_ix]\n        return (dta_M, dta_Q)\n    (endog_M, endog_Q) = get_data(us_data)\n    (updated_M, updated_Q) = get_data(us_data_update)\n    return (endog_M, endog_Q, results, updated_M, updated_Q)"
        ]
    },
    {
        "func_name": "test_known",
        "original": "@pytest.mark.parametrize('run', ['111', '112', '11F', '221', '222', '22F', 'block_111', 'block_112', 'block_221', 'block_222'])\ndef test_known(matlab_results, run):\n    (endog_M, endog_Q) = matlab_results[:2]\n    results = matlab_results[2][run]\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M.iloc[:, :results['k_endog_M']], endog_quarterly=endog_Q, factors=results['factors'], factor_orders=results['factor_orders'], factor_multiplicities=results['factor_multiplicities'], idiosyncratic_ar1=True, init_t0=True, obs_cov_diag=True, standardize=True)\n    mod.initialize_known(results['initial_state'], results['initial_state_cov'])\n    res = mod.smooth(results['params'], cov_type='none')\n    assert_allclose(res.llf - mod.loglike_constant, results['llf'])\n    assert_allclose(res.filter_results.smoothed_forecasts.T[1:], results['smoothed_forecasts'][:-1])\n    assert_allclose(res.forecast(1, original_scale=False).iloc[0], results['smoothed_forecasts'][-1])",
        "mutated": [
            "@pytest.mark.parametrize('run', ['111', '112', '11F', '221', '222', '22F', 'block_111', 'block_112', 'block_221', 'block_222'])\ndef test_known(matlab_results, run):\n    if False:\n        i = 10\n    (endog_M, endog_Q) = matlab_results[:2]\n    results = matlab_results[2][run]\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M.iloc[:, :results['k_endog_M']], endog_quarterly=endog_Q, factors=results['factors'], factor_orders=results['factor_orders'], factor_multiplicities=results['factor_multiplicities'], idiosyncratic_ar1=True, init_t0=True, obs_cov_diag=True, standardize=True)\n    mod.initialize_known(results['initial_state'], results['initial_state_cov'])\n    res = mod.smooth(results['params'], cov_type='none')\n    assert_allclose(res.llf - mod.loglike_constant, results['llf'])\n    assert_allclose(res.filter_results.smoothed_forecasts.T[1:], results['smoothed_forecasts'][:-1])\n    assert_allclose(res.forecast(1, original_scale=False).iloc[0], results['smoothed_forecasts'][-1])",
            "@pytest.mark.parametrize('run', ['111', '112', '11F', '221', '222', '22F', 'block_111', 'block_112', 'block_221', 'block_222'])\ndef test_known(matlab_results, run):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (endog_M, endog_Q) = matlab_results[:2]\n    results = matlab_results[2][run]\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M.iloc[:, :results['k_endog_M']], endog_quarterly=endog_Q, factors=results['factors'], factor_orders=results['factor_orders'], factor_multiplicities=results['factor_multiplicities'], idiosyncratic_ar1=True, init_t0=True, obs_cov_diag=True, standardize=True)\n    mod.initialize_known(results['initial_state'], results['initial_state_cov'])\n    res = mod.smooth(results['params'], cov_type='none')\n    assert_allclose(res.llf - mod.loglike_constant, results['llf'])\n    assert_allclose(res.filter_results.smoothed_forecasts.T[1:], results['smoothed_forecasts'][:-1])\n    assert_allclose(res.forecast(1, original_scale=False).iloc[0], results['smoothed_forecasts'][-1])",
            "@pytest.mark.parametrize('run', ['111', '112', '11F', '221', '222', '22F', 'block_111', 'block_112', 'block_221', 'block_222'])\ndef test_known(matlab_results, run):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (endog_M, endog_Q) = matlab_results[:2]\n    results = matlab_results[2][run]\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M.iloc[:, :results['k_endog_M']], endog_quarterly=endog_Q, factors=results['factors'], factor_orders=results['factor_orders'], factor_multiplicities=results['factor_multiplicities'], idiosyncratic_ar1=True, init_t0=True, obs_cov_diag=True, standardize=True)\n    mod.initialize_known(results['initial_state'], results['initial_state_cov'])\n    res = mod.smooth(results['params'], cov_type='none')\n    assert_allclose(res.llf - mod.loglike_constant, results['llf'])\n    assert_allclose(res.filter_results.smoothed_forecasts.T[1:], results['smoothed_forecasts'][:-1])\n    assert_allclose(res.forecast(1, original_scale=False).iloc[0], results['smoothed_forecasts'][-1])",
            "@pytest.mark.parametrize('run', ['111', '112', '11F', '221', '222', '22F', 'block_111', 'block_112', 'block_221', 'block_222'])\ndef test_known(matlab_results, run):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (endog_M, endog_Q) = matlab_results[:2]\n    results = matlab_results[2][run]\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M.iloc[:, :results['k_endog_M']], endog_quarterly=endog_Q, factors=results['factors'], factor_orders=results['factor_orders'], factor_multiplicities=results['factor_multiplicities'], idiosyncratic_ar1=True, init_t0=True, obs_cov_diag=True, standardize=True)\n    mod.initialize_known(results['initial_state'], results['initial_state_cov'])\n    res = mod.smooth(results['params'], cov_type='none')\n    assert_allclose(res.llf - mod.loglike_constant, results['llf'])\n    assert_allclose(res.filter_results.smoothed_forecasts.T[1:], results['smoothed_forecasts'][:-1])\n    assert_allclose(res.forecast(1, original_scale=False).iloc[0], results['smoothed_forecasts'][-1])",
            "@pytest.mark.parametrize('run', ['111', '112', '11F', '221', '222', '22F', 'block_111', 'block_112', 'block_221', 'block_222'])\ndef test_known(matlab_results, run):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (endog_M, endog_Q) = matlab_results[:2]\n    results = matlab_results[2][run]\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M.iloc[:, :results['k_endog_M']], endog_quarterly=endog_Q, factors=results['factors'], factor_orders=results['factor_orders'], factor_multiplicities=results['factor_multiplicities'], idiosyncratic_ar1=True, init_t0=True, obs_cov_diag=True, standardize=True)\n    mod.initialize_known(results['initial_state'], results['initial_state_cov'])\n    res = mod.smooth(results['params'], cov_type='none')\n    assert_allclose(res.llf - mod.loglike_constant, results['llf'])\n    assert_allclose(res.filter_results.smoothed_forecasts.T[1:], results['smoothed_forecasts'][:-1])\n    assert_allclose(res.forecast(1, original_scale=False).iloc[0], results['smoothed_forecasts'][-1])"
        ]
    },
    {
        "func_name": "test_emstep1",
        "original": "@pytest.mark.parametrize('run', ['11', '22', 'block_11', 'block_22'])\ndef test_emstep1(matlab_results, run):\n    (endog_M, endog_Q) = matlab_results[:2]\n    results1 = matlab_results[2][f'{run}1']\n    results2 = matlab_results[2][f'{run}2']\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M.iloc[:, :results1['k_endog_M']], endog_quarterly=endog_Q, factors=results1['factors'], factor_orders=results1['factor_orders'], factor_multiplicities=results1['factor_multiplicities'], idiosyncratic_ar1=True, init_t0=True, obs_cov_diag=True, standardize=True)\n    init = initialization.Initialization(mod.k_states, 'known', constant=results1['initial_state'], stationary_cov=results1['initial_state_cov'])\n    (res2, params2) = mod._em_iteration(results1['params'], init=init, mstep_method='missing')\n    true2 = results2['params']\n    assert_allclose(params2[mod._p['loadings']], true2[mod._p['loadings']])\n    assert_allclose(params2[mod._p['factor_ar']], true2[mod._p['factor_ar']])\n    assert_allclose(params2[mod._p['factor_cov']], true2[mod._p['factor_cov']])\n    assert_allclose(params2[mod._p['idiosyncratic_ar1']], true2[mod._p['idiosyncratic_ar1']])\n    assert_allclose(params2[mod._p['idiosyncratic_var']], true2[mod._p['idiosyncratic_var']])",
        "mutated": [
            "@pytest.mark.parametrize('run', ['11', '22', 'block_11', 'block_22'])\ndef test_emstep1(matlab_results, run):\n    if False:\n        i = 10\n    (endog_M, endog_Q) = matlab_results[:2]\n    results1 = matlab_results[2][f'{run}1']\n    results2 = matlab_results[2][f'{run}2']\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M.iloc[:, :results1['k_endog_M']], endog_quarterly=endog_Q, factors=results1['factors'], factor_orders=results1['factor_orders'], factor_multiplicities=results1['factor_multiplicities'], idiosyncratic_ar1=True, init_t0=True, obs_cov_diag=True, standardize=True)\n    init = initialization.Initialization(mod.k_states, 'known', constant=results1['initial_state'], stationary_cov=results1['initial_state_cov'])\n    (res2, params2) = mod._em_iteration(results1['params'], init=init, mstep_method='missing')\n    true2 = results2['params']\n    assert_allclose(params2[mod._p['loadings']], true2[mod._p['loadings']])\n    assert_allclose(params2[mod._p['factor_ar']], true2[mod._p['factor_ar']])\n    assert_allclose(params2[mod._p['factor_cov']], true2[mod._p['factor_cov']])\n    assert_allclose(params2[mod._p['idiosyncratic_ar1']], true2[mod._p['idiosyncratic_ar1']])\n    assert_allclose(params2[mod._p['idiosyncratic_var']], true2[mod._p['idiosyncratic_var']])",
            "@pytest.mark.parametrize('run', ['11', '22', 'block_11', 'block_22'])\ndef test_emstep1(matlab_results, run):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (endog_M, endog_Q) = matlab_results[:2]\n    results1 = matlab_results[2][f'{run}1']\n    results2 = matlab_results[2][f'{run}2']\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M.iloc[:, :results1['k_endog_M']], endog_quarterly=endog_Q, factors=results1['factors'], factor_orders=results1['factor_orders'], factor_multiplicities=results1['factor_multiplicities'], idiosyncratic_ar1=True, init_t0=True, obs_cov_diag=True, standardize=True)\n    init = initialization.Initialization(mod.k_states, 'known', constant=results1['initial_state'], stationary_cov=results1['initial_state_cov'])\n    (res2, params2) = mod._em_iteration(results1['params'], init=init, mstep_method='missing')\n    true2 = results2['params']\n    assert_allclose(params2[mod._p['loadings']], true2[mod._p['loadings']])\n    assert_allclose(params2[mod._p['factor_ar']], true2[mod._p['factor_ar']])\n    assert_allclose(params2[mod._p['factor_cov']], true2[mod._p['factor_cov']])\n    assert_allclose(params2[mod._p['idiosyncratic_ar1']], true2[mod._p['idiosyncratic_ar1']])\n    assert_allclose(params2[mod._p['idiosyncratic_var']], true2[mod._p['idiosyncratic_var']])",
            "@pytest.mark.parametrize('run', ['11', '22', 'block_11', 'block_22'])\ndef test_emstep1(matlab_results, run):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (endog_M, endog_Q) = matlab_results[:2]\n    results1 = matlab_results[2][f'{run}1']\n    results2 = matlab_results[2][f'{run}2']\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M.iloc[:, :results1['k_endog_M']], endog_quarterly=endog_Q, factors=results1['factors'], factor_orders=results1['factor_orders'], factor_multiplicities=results1['factor_multiplicities'], idiosyncratic_ar1=True, init_t0=True, obs_cov_diag=True, standardize=True)\n    init = initialization.Initialization(mod.k_states, 'known', constant=results1['initial_state'], stationary_cov=results1['initial_state_cov'])\n    (res2, params2) = mod._em_iteration(results1['params'], init=init, mstep_method='missing')\n    true2 = results2['params']\n    assert_allclose(params2[mod._p['loadings']], true2[mod._p['loadings']])\n    assert_allclose(params2[mod._p['factor_ar']], true2[mod._p['factor_ar']])\n    assert_allclose(params2[mod._p['factor_cov']], true2[mod._p['factor_cov']])\n    assert_allclose(params2[mod._p['idiosyncratic_ar1']], true2[mod._p['idiosyncratic_ar1']])\n    assert_allclose(params2[mod._p['idiosyncratic_var']], true2[mod._p['idiosyncratic_var']])",
            "@pytest.mark.parametrize('run', ['11', '22', 'block_11', 'block_22'])\ndef test_emstep1(matlab_results, run):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (endog_M, endog_Q) = matlab_results[:2]\n    results1 = matlab_results[2][f'{run}1']\n    results2 = matlab_results[2][f'{run}2']\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M.iloc[:, :results1['k_endog_M']], endog_quarterly=endog_Q, factors=results1['factors'], factor_orders=results1['factor_orders'], factor_multiplicities=results1['factor_multiplicities'], idiosyncratic_ar1=True, init_t0=True, obs_cov_diag=True, standardize=True)\n    init = initialization.Initialization(mod.k_states, 'known', constant=results1['initial_state'], stationary_cov=results1['initial_state_cov'])\n    (res2, params2) = mod._em_iteration(results1['params'], init=init, mstep_method='missing')\n    true2 = results2['params']\n    assert_allclose(params2[mod._p['loadings']], true2[mod._p['loadings']])\n    assert_allclose(params2[mod._p['factor_ar']], true2[mod._p['factor_ar']])\n    assert_allclose(params2[mod._p['factor_cov']], true2[mod._p['factor_cov']])\n    assert_allclose(params2[mod._p['idiosyncratic_ar1']], true2[mod._p['idiosyncratic_ar1']])\n    assert_allclose(params2[mod._p['idiosyncratic_var']], true2[mod._p['idiosyncratic_var']])",
            "@pytest.mark.parametrize('run', ['11', '22', 'block_11', 'block_22'])\ndef test_emstep1(matlab_results, run):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (endog_M, endog_Q) = matlab_results[:2]\n    results1 = matlab_results[2][f'{run}1']\n    results2 = matlab_results[2][f'{run}2']\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M.iloc[:, :results1['k_endog_M']], endog_quarterly=endog_Q, factors=results1['factors'], factor_orders=results1['factor_orders'], factor_multiplicities=results1['factor_multiplicities'], idiosyncratic_ar1=True, init_t0=True, obs_cov_diag=True, standardize=True)\n    init = initialization.Initialization(mod.k_states, 'known', constant=results1['initial_state'], stationary_cov=results1['initial_state_cov'])\n    (res2, params2) = mod._em_iteration(results1['params'], init=init, mstep_method='missing')\n    true2 = results2['params']\n    assert_allclose(params2[mod._p['loadings']], true2[mod._p['loadings']])\n    assert_allclose(params2[mod._p['factor_ar']], true2[mod._p['factor_ar']])\n    assert_allclose(params2[mod._p['factor_cov']], true2[mod._p['factor_cov']])\n    assert_allclose(params2[mod._p['idiosyncratic_ar1']], true2[mod._p['idiosyncratic_ar1']])\n    assert_allclose(params2[mod._p['idiosyncratic_var']], true2[mod._p['idiosyncratic_var']])"
        ]
    },
    {
        "func_name": "test_emstep_methods_missing",
        "original": "@pytest.mark.parametrize('k_factors,factor_orders,factor_multiplicities,idiosyncratic_ar1', [(1, 1, 1, True), (3, 1, 1, True), (1, 6, 1, True), (3, 6, 1, True), (1, 1, 1, False), (3, 1, 1, False), (1, 6, 1, False), (3, 6, 1, False), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP1.copy(), 1, True), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP1.copy(), 1, False), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP2.copy(), BLOCK_FACTOR_MULTIPLICITIES_KP2, True), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP2.copy(), BLOCK_FACTOR_MULTIPLICITIES_KP2, False)])\n@pytest.mark.filterwarnings('ignore::UserWarning')\ndef test_emstep_methods_missing(matlab_results, k_factors, factor_orders, factor_multiplicities, idiosyncratic_ar1):\n    endog_M = matlab_results[0].iloc[:, :10]\n    endog_Q = matlab_results[1].iloc[:, :10]\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, factors=k_factors, factor_orders=factor_orders, factor_multiplicities=factor_multiplicities, idiosyncratic_ar1=idiosyncratic_ar1, standardize=True)\n    mod.ssm.filter_univariate = True\n    params0 = mod.start_params\n    (_, params1) = mod._em_iteration(params0, mstep_method='missing')\n    mod.update(params1)\n    res = mod.ssm.smooth()\n    a = res.smoothed_state.T[..., None]\n    cov_a = res.smoothed_state_cov.transpose(2, 0, 1)\n    Eaa = cov_a + np.matmul(a, a.transpose(0, 2, 1))\n    (Lambda, H) = mod._em_maximization_obs_missing(res, Eaa, a, compute_H=True)",
        "mutated": [
            "@pytest.mark.parametrize('k_factors,factor_orders,factor_multiplicities,idiosyncratic_ar1', [(1, 1, 1, True), (3, 1, 1, True), (1, 6, 1, True), (3, 6, 1, True), (1, 1, 1, False), (3, 1, 1, False), (1, 6, 1, False), (3, 6, 1, False), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP1.copy(), 1, True), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP1.copy(), 1, False), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP2.copy(), BLOCK_FACTOR_MULTIPLICITIES_KP2, True), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP2.copy(), BLOCK_FACTOR_MULTIPLICITIES_KP2, False)])\n@pytest.mark.filterwarnings('ignore::UserWarning')\ndef test_emstep_methods_missing(matlab_results, k_factors, factor_orders, factor_multiplicities, idiosyncratic_ar1):\n    if False:\n        i = 10\n    endog_M = matlab_results[0].iloc[:, :10]\n    endog_Q = matlab_results[1].iloc[:, :10]\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, factors=k_factors, factor_orders=factor_orders, factor_multiplicities=factor_multiplicities, idiosyncratic_ar1=idiosyncratic_ar1, standardize=True)\n    mod.ssm.filter_univariate = True\n    params0 = mod.start_params\n    (_, params1) = mod._em_iteration(params0, mstep_method='missing')\n    mod.update(params1)\n    res = mod.ssm.smooth()\n    a = res.smoothed_state.T[..., None]\n    cov_a = res.smoothed_state_cov.transpose(2, 0, 1)\n    Eaa = cov_a + np.matmul(a, a.transpose(0, 2, 1))\n    (Lambda, H) = mod._em_maximization_obs_missing(res, Eaa, a, compute_H=True)",
            "@pytest.mark.parametrize('k_factors,factor_orders,factor_multiplicities,idiosyncratic_ar1', [(1, 1, 1, True), (3, 1, 1, True), (1, 6, 1, True), (3, 6, 1, True), (1, 1, 1, False), (3, 1, 1, False), (1, 6, 1, False), (3, 6, 1, False), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP1.copy(), 1, True), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP1.copy(), 1, False), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP2.copy(), BLOCK_FACTOR_MULTIPLICITIES_KP2, True), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP2.copy(), BLOCK_FACTOR_MULTIPLICITIES_KP2, False)])\n@pytest.mark.filterwarnings('ignore::UserWarning')\ndef test_emstep_methods_missing(matlab_results, k_factors, factor_orders, factor_multiplicities, idiosyncratic_ar1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    endog_M = matlab_results[0].iloc[:, :10]\n    endog_Q = matlab_results[1].iloc[:, :10]\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, factors=k_factors, factor_orders=factor_orders, factor_multiplicities=factor_multiplicities, idiosyncratic_ar1=idiosyncratic_ar1, standardize=True)\n    mod.ssm.filter_univariate = True\n    params0 = mod.start_params\n    (_, params1) = mod._em_iteration(params0, mstep_method='missing')\n    mod.update(params1)\n    res = mod.ssm.smooth()\n    a = res.smoothed_state.T[..., None]\n    cov_a = res.smoothed_state_cov.transpose(2, 0, 1)\n    Eaa = cov_a + np.matmul(a, a.transpose(0, 2, 1))\n    (Lambda, H) = mod._em_maximization_obs_missing(res, Eaa, a, compute_H=True)",
            "@pytest.mark.parametrize('k_factors,factor_orders,factor_multiplicities,idiosyncratic_ar1', [(1, 1, 1, True), (3, 1, 1, True), (1, 6, 1, True), (3, 6, 1, True), (1, 1, 1, False), (3, 1, 1, False), (1, 6, 1, False), (3, 6, 1, False), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP1.copy(), 1, True), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP1.copy(), 1, False), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP2.copy(), BLOCK_FACTOR_MULTIPLICITIES_KP2, True), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP2.copy(), BLOCK_FACTOR_MULTIPLICITIES_KP2, False)])\n@pytest.mark.filterwarnings('ignore::UserWarning')\ndef test_emstep_methods_missing(matlab_results, k_factors, factor_orders, factor_multiplicities, idiosyncratic_ar1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    endog_M = matlab_results[0].iloc[:, :10]\n    endog_Q = matlab_results[1].iloc[:, :10]\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, factors=k_factors, factor_orders=factor_orders, factor_multiplicities=factor_multiplicities, idiosyncratic_ar1=idiosyncratic_ar1, standardize=True)\n    mod.ssm.filter_univariate = True\n    params0 = mod.start_params\n    (_, params1) = mod._em_iteration(params0, mstep_method='missing')\n    mod.update(params1)\n    res = mod.ssm.smooth()\n    a = res.smoothed_state.T[..., None]\n    cov_a = res.smoothed_state_cov.transpose(2, 0, 1)\n    Eaa = cov_a + np.matmul(a, a.transpose(0, 2, 1))\n    (Lambda, H) = mod._em_maximization_obs_missing(res, Eaa, a, compute_H=True)",
            "@pytest.mark.parametrize('k_factors,factor_orders,factor_multiplicities,idiosyncratic_ar1', [(1, 1, 1, True), (3, 1, 1, True), (1, 6, 1, True), (3, 6, 1, True), (1, 1, 1, False), (3, 1, 1, False), (1, 6, 1, False), (3, 6, 1, False), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP1.copy(), 1, True), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP1.copy(), 1, False), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP2.copy(), BLOCK_FACTOR_MULTIPLICITIES_KP2, True), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP2.copy(), BLOCK_FACTOR_MULTIPLICITIES_KP2, False)])\n@pytest.mark.filterwarnings('ignore::UserWarning')\ndef test_emstep_methods_missing(matlab_results, k_factors, factor_orders, factor_multiplicities, idiosyncratic_ar1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    endog_M = matlab_results[0].iloc[:, :10]\n    endog_Q = matlab_results[1].iloc[:, :10]\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, factors=k_factors, factor_orders=factor_orders, factor_multiplicities=factor_multiplicities, idiosyncratic_ar1=idiosyncratic_ar1, standardize=True)\n    mod.ssm.filter_univariate = True\n    params0 = mod.start_params\n    (_, params1) = mod._em_iteration(params0, mstep_method='missing')\n    mod.update(params1)\n    res = mod.ssm.smooth()\n    a = res.smoothed_state.T[..., None]\n    cov_a = res.smoothed_state_cov.transpose(2, 0, 1)\n    Eaa = cov_a + np.matmul(a, a.transpose(0, 2, 1))\n    (Lambda, H) = mod._em_maximization_obs_missing(res, Eaa, a, compute_H=True)",
            "@pytest.mark.parametrize('k_factors,factor_orders,factor_multiplicities,idiosyncratic_ar1', [(1, 1, 1, True), (3, 1, 1, True), (1, 6, 1, True), (3, 6, 1, True), (1, 1, 1, False), (3, 1, 1, False), (1, 6, 1, False), (3, 6, 1, False), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP1.copy(), 1, True), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP1.copy(), 1, False), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP2.copy(), BLOCK_FACTOR_MULTIPLICITIES_KP2, True), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP2.copy(), BLOCK_FACTOR_MULTIPLICITIES_KP2, False)])\n@pytest.mark.filterwarnings('ignore::UserWarning')\ndef test_emstep_methods_missing(matlab_results, k_factors, factor_orders, factor_multiplicities, idiosyncratic_ar1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    endog_M = matlab_results[0].iloc[:, :10]\n    endog_Q = matlab_results[1].iloc[:, :10]\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, factors=k_factors, factor_orders=factor_orders, factor_multiplicities=factor_multiplicities, idiosyncratic_ar1=idiosyncratic_ar1, standardize=True)\n    mod.ssm.filter_univariate = True\n    params0 = mod.start_params\n    (_, params1) = mod._em_iteration(params0, mstep_method='missing')\n    mod.update(params1)\n    res = mod.ssm.smooth()\n    a = res.smoothed_state.T[..., None]\n    cov_a = res.smoothed_state_cov.transpose(2, 0, 1)\n    Eaa = cov_a + np.matmul(a, a.transpose(0, 2, 1))\n    (Lambda, H) = mod._em_maximization_obs_missing(res, Eaa, a, compute_H=True)"
        ]
    },
    {
        "func_name": "test_emstep_methods_nonmissing",
        "original": "@pytest.mark.parametrize('k_factors,factor_orders,factor_multiplicities,idiosyncratic_ar1', [(1, 1, 1, True), (3, 1, 1, True), (1, 6, 1, True), (3, {('0', '1', '2'): 6}, 1, True), (1, 1, 1, False), (3, 1, 1, False), (1, 6, 1, False), (3, {('0', '1', '2'): 6}, 1, False), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP1.copy(), 1, True), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP1.copy(), 1, False), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP2.copy(), BLOCK_FACTOR_MULTIPLICITIES_KP2, True), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP2.copy(), BLOCK_FACTOR_MULTIPLICITIES_KP2, False)])\n@pytest.mark.filterwarnings('ignore::UserWarning')\ndef test_emstep_methods_nonmissing(matlab_results, k_factors, factor_orders, factor_multiplicities, idiosyncratic_ar1):\n    dta_M = matlab_results[0].iloc[:, :8]\n    dta_M = (dta_M - dta_M.mean()) / dta_M.std()\n    endog_M = dta_M.interpolate().bfill()\n    if isinstance(k_factors, dict):\n        if 'GDPC1' in k_factors:\n            del k_factors['GDPC1']\n        if 'ULCNFB' in k_factors:\n            del k_factors['ULCNFB']\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, factors=k_factors, factor_orders=factor_orders, factor_multiplicities=factor_multiplicities, idiosyncratic_ar1=idiosyncratic_ar1)\n    mod.ssm.filter_univariate = True\n    params0 = mod.start_params\n    (_, params1) = mod._em_iteration(params0, mstep_method='missing')\n    (_, params1_nonmissing) = mod._em_iteration(params0, mstep_method='nonmissing')\n    assert_allclose(params1_nonmissing, params1, atol=1e-13)\n    mod.update(params1)\n    res = mod.ssm.smooth()\n    a = res.smoothed_state.T[..., None]\n    cov_a = res.smoothed_state_cov.transpose(2, 0, 1)\n    Eaa = cov_a + np.matmul(a, a.transpose(0, 2, 1))\n    (Lambda, H) = mod._em_maximization_obs_missing(res, Eaa, a, compute_H=True)\n    (Lambda_nonmissing, H_nonmissing) = mod._em_maximization_obs_nonmissing(res, Eaa, a, compute_H=True)\n    assert_allclose(Lambda_nonmissing, Lambda, atol=1e-13)\n    assert_allclose(H_nonmissing, H, atol=1e-13)",
        "mutated": [
            "@pytest.mark.parametrize('k_factors,factor_orders,factor_multiplicities,idiosyncratic_ar1', [(1, 1, 1, True), (3, 1, 1, True), (1, 6, 1, True), (3, {('0', '1', '2'): 6}, 1, True), (1, 1, 1, False), (3, 1, 1, False), (1, 6, 1, False), (3, {('0', '1', '2'): 6}, 1, False), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP1.copy(), 1, True), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP1.copy(), 1, False), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP2.copy(), BLOCK_FACTOR_MULTIPLICITIES_KP2, True), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP2.copy(), BLOCK_FACTOR_MULTIPLICITIES_KP2, False)])\n@pytest.mark.filterwarnings('ignore::UserWarning')\ndef test_emstep_methods_nonmissing(matlab_results, k_factors, factor_orders, factor_multiplicities, idiosyncratic_ar1):\n    if False:\n        i = 10\n    dta_M = matlab_results[0].iloc[:, :8]\n    dta_M = (dta_M - dta_M.mean()) / dta_M.std()\n    endog_M = dta_M.interpolate().bfill()\n    if isinstance(k_factors, dict):\n        if 'GDPC1' in k_factors:\n            del k_factors['GDPC1']\n        if 'ULCNFB' in k_factors:\n            del k_factors['ULCNFB']\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, factors=k_factors, factor_orders=factor_orders, factor_multiplicities=factor_multiplicities, idiosyncratic_ar1=idiosyncratic_ar1)\n    mod.ssm.filter_univariate = True\n    params0 = mod.start_params\n    (_, params1) = mod._em_iteration(params0, mstep_method='missing')\n    (_, params1_nonmissing) = mod._em_iteration(params0, mstep_method='nonmissing')\n    assert_allclose(params1_nonmissing, params1, atol=1e-13)\n    mod.update(params1)\n    res = mod.ssm.smooth()\n    a = res.smoothed_state.T[..., None]\n    cov_a = res.smoothed_state_cov.transpose(2, 0, 1)\n    Eaa = cov_a + np.matmul(a, a.transpose(0, 2, 1))\n    (Lambda, H) = mod._em_maximization_obs_missing(res, Eaa, a, compute_H=True)\n    (Lambda_nonmissing, H_nonmissing) = mod._em_maximization_obs_nonmissing(res, Eaa, a, compute_H=True)\n    assert_allclose(Lambda_nonmissing, Lambda, atol=1e-13)\n    assert_allclose(H_nonmissing, H, atol=1e-13)",
            "@pytest.mark.parametrize('k_factors,factor_orders,factor_multiplicities,idiosyncratic_ar1', [(1, 1, 1, True), (3, 1, 1, True), (1, 6, 1, True), (3, {('0', '1', '2'): 6}, 1, True), (1, 1, 1, False), (3, 1, 1, False), (1, 6, 1, False), (3, {('0', '1', '2'): 6}, 1, False), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP1.copy(), 1, True), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP1.copy(), 1, False), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP2.copy(), BLOCK_FACTOR_MULTIPLICITIES_KP2, True), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP2.copy(), BLOCK_FACTOR_MULTIPLICITIES_KP2, False)])\n@pytest.mark.filterwarnings('ignore::UserWarning')\ndef test_emstep_methods_nonmissing(matlab_results, k_factors, factor_orders, factor_multiplicities, idiosyncratic_ar1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dta_M = matlab_results[0].iloc[:, :8]\n    dta_M = (dta_M - dta_M.mean()) / dta_M.std()\n    endog_M = dta_M.interpolate().bfill()\n    if isinstance(k_factors, dict):\n        if 'GDPC1' in k_factors:\n            del k_factors['GDPC1']\n        if 'ULCNFB' in k_factors:\n            del k_factors['ULCNFB']\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, factors=k_factors, factor_orders=factor_orders, factor_multiplicities=factor_multiplicities, idiosyncratic_ar1=idiosyncratic_ar1)\n    mod.ssm.filter_univariate = True\n    params0 = mod.start_params\n    (_, params1) = mod._em_iteration(params0, mstep_method='missing')\n    (_, params1_nonmissing) = mod._em_iteration(params0, mstep_method='nonmissing')\n    assert_allclose(params1_nonmissing, params1, atol=1e-13)\n    mod.update(params1)\n    res = mod.ssm.smooth()\n    a = res.smoothed_state.T[..., None]\n    cov_a = res.smoothed_state_cov.transpose(2, 0, 1)\n    Eaa = cov_a + np.matmul(a, a.transpose(0, 2, 1))\n    (Lambda, H) = mod._em_maximization_obs_missing(res, Eaa, a, compute_H=True)\n    (Lambda_nonmissing, H_nonmissing) = mod._em_maximization_obs_nonmissing(res, Eaa, a, compute_H=True)\n    assert_allclose(Lambda_nonmissing, Lambda, atol=1e-13)\n    assert_allclose(H_nonmissing, H, atol=1e-13)",
            "@pytest.mark.parametrize('k_factors,factor_orders,factor_multiplicities,idiosyncratic_ar1', [(1, 1, 1, True), (3, 1, 1, True), (1, 6, 1, True), (3, {('0', '1', '2'): 6}, 1, True), (1, 1, 1, False), (3, 1, 1, False), (1, 6, 1, False), (3, {('0', '1', '2'): 6}, 1, False), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP1.copy(), 1, True), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP1.copy(), 1, False), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP2.copy(), BLOCK_FACTOR_MULTIPLICITIES_KP2, True), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP2.copy(), BLOCK_FACTOR_MULTIPLICITIES_KP2, False)])\n@pytest.mark.filterwarnings('ignore::UserWarning')\ndef test_emstep_methods_nonmissing(matlab_results, k_factors, factor_orders, factor_multiplicities, idiosyncratic_ar1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dta_M = matlab_results[0].iloc[:, :8]\n    dta_M = (dta_M - dta_M.mean()) / dta_M.std()\n    endog_M = dta_M.interpolate().bfill()\n    if isinstance(k_factors, dict):\n        if 'GDPC1' in k_factors:\n            del k_factors['GDPC1']\n        if 'ULCNFB' in k_factors:\n            del k_factors['ULCNFB']\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, factors=k_factors, factor_orders=factor_orders, factor_multiplicities=factor_multiplicities, idiosyncratic_ar1=idiosyncratic_ar1)\n    mod.ssm.filter_univariate = True\n    params0 = mod.start_params\n    (_, params1) = mod._em_iteration(params0, mstep_method='missing')\n    (_, params1_nonmissing) = mod._em_iteration(params0, mstep_method='nonmissing')\n    assert_allclose(params1_nonmissing, params1, atol=1e-13)\n    mod.update(params1)\n    res = mod.ssm.smooth()\n    a = res.smoothed_state.T[..., None]\n    cov_a = res.smoothed_state_cov.transpose(2, 0, 1)\n    Eaa = cov_a + np.matmul(a, a.transpose(0, 2, 1))\n    (Lambda, H) = mod._em_maximization_obs_missing(res, Eaa, a, compute_H=True)\n    (Lambda_nonmissing, H_nonmissing) = mod._em_maximization_obs_nonmissing(res, Eaa, a, compute_H=True)\n    assert_allclose(Lambda_nonmissing, Lambda, atol=1e-13)\n    assert_allclose(H_nonmissing, H, atol=1e-13)",
            "@pytest.mark.parametrize('k_factors,factor_orders,factor_multiplicities,idiosyncratic_ar1', [(1, 1, 1, True), (3, 1, 1, True), (1, 6, 1, True), (3, {('0', '1', '2'): 6}, 1, True), (1, 1, 1, False), (3, 1, 1, False), (1, 6, 1, False), (3, {('0', '1', '2'): 6}, 1, False), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP1.copy(), 1, True), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP1.copy(), 1, False), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP2.copy(), BLOCK_FACTOR_MULTIPLICITIES_KP2, True), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP2.copy(), BLOCK_FACTOR_MULTIPLICITIES_KP2, False)])\n@pytest.mark.filterwarnings('ignore::UserWarning')\ndef test_emstep_methods_nonmissing(matlab_results, k_factors, factor_orders, factor_multiplicities, idiosyncratic_ar1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dta_M = matlab_results[0].iloc[:, :8]\n    dta_M = (dta_M - dta_M.mean()) / dta_M.std()\n    endog_M = dta_M.interpolate().bfill()\n    if isinstance(k_factors, dict):\n        if 'GDPC1' in k_factors:\n            del k_factors['GDPC1']\n        if 'ULCNFB' in k_factors:\n            del k_factors['ULCNFB']\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, factors=k_factors, factor_orders=factor_orders, factor_multiplicities=factor_multiplicities, idiosyncratic_ar1=idiosyncratic_ar1)\n    mod.ssm.filter_univariate = True\n    params0 = mod.start_params\n    (_, params1) = mod._em_iteration(params0, mstep_method='missing')\n    (_, params1_nonmissing) = mod._em_iteration(params0, mstep_method='nonmissing')\n    assert_allclose(params1_nonmissing, params1, atol=1e-13)\n    mod.update(params1)\n    res = mod.ssm.smooth()\n    a = res.smoothed_state.T[..., None]\n    cov_a = res.smoothed_state_cov.transpose(2, 0, 1)\n    Eaa = cov_a + np.matmul(a, a.transpose(0, 2, 1))\n    (Lambda, H) = mod._em_maximization_obs_missing(res, Eaa, a, compute_H=True)\n    (Lambda_nonmissing, H_nonmissing) = mod._em_maximization_obs_nonmissing(res, Eaa, a, compute_H=True)\n    assert_allclose(Lambda_nonmissing, Lambda, atol=1e-13)\n    assert_allclose(H_nonmissing, H, atol=1e-13)",
            "@pytest.mark.parametrize('k_factors,factor_orders,factor_multiplicities,idiosyncratic_ar1', [(1, 1, 1, True), (3, 1, 1, True), (1, 6, 1, True), (3, {('0', '1', '2'): 6}, 1, True), (1, 1, 1, False), (3, 1, 1, False), (1, 6, 1, False), (3, {('0', '1', '2'): 6}, 1, False), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP1.copy(), 1, True), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP1.copy(), 1, False), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP2.copy(), BLOCK_FACTOR_MULTIPLICITIES_KP2, True), (BLOCK_FACTORS_KP1.copy(), BLOCK_FACTOR_ORDERS_KP2.copy(), BLOCK_FACTOR_MULTIPLICITIES_KP2, False)])\n@pytest.mark.filterwarnings('ignore::UserWarning')\ndef test_emstep_methods_nonmissing(matlab_results, k_factors, factor_orders, factor_multiplicities, idiosyncratic_ar1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dta_M = matlab_results[0].iloc[:, :8]\n    dta_M = (dta_M - dta_M.mean()) / dta_M.std()\n    endog_M = dta_M.interpolate().bfill()\n    if isinstance(k_factors, dict):\n        if 'GDPC1' in k_factors:\n            del k_factors['GDPC1']\n        if 'ULCNFB' in k_factors:\n            del k_factors['ULCNFB']\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, factors=k_factors, factor_orders=factor_orders, factor_multiplicities=factor_multiplicities, idiosyncratic_ar1=idiosyncratic_ar1)\n    mod.ssm.filter_univariate = True\n    params0 = mod.start_params\n    (_, params1) = mod._em_iteration(params0, mstep_method='missing')\n    (_, params1_nonmissing) = mod._em_iteration(params0, mstep_method='nonmissing')\n    assert_allclose(params1_nonmissing, params1, atol=1e-13)\n    mod.update(params1)\n    res = mod.ssm.smooth()\n    a = res.smoothed_state.T[..., None]\n    cov_a = res.smoothed_state_cov.transpose(2, 0, 1)\n    Eaa = cov_a + np.matmul(a, a.transpose(0, 2, 1))\n    (Lambda, H) = mod._em_maximization_obs_missing(res, Eaa, a, compute_H=True)\n    (Lambda_nonmissing, H_nonmissing) = mod._em_maximization_obs_nonmissing(res, Eaa, a, compute_H=True)\n    assert_allclose(Lambda_nonmissing, Lambda, atol=1e-13)\n    assert_allclose(H_nonmissing, H, atol=1e-13)"
        ]
    },
    {
        "func_name": "test_news",
        "original": "@pytest.mark.parametrize('run', ['news_112', 'news_222', 'news_block_112', 'news_block_222'])\ndef test_news(matlab_results, run):\n    (endog_M, endog_Q) = matlab_results[:2]\n    results = matlab_results[2][run]\n    (updated_M, updated_Q) = matlab_results[-2:]\n    mod1 = dynamic_factor_mq.DynamicFactorMQ(endog_M.iloc[:, :results['k_endog_M']], endog_quarterly=endog_Q, factors=results['factors'], factor_orders=results['factor_orders'], factor_multiplicities=results['factor_multiplicities'], idiosyncratic_ar1=True, init_t0=True, obs_cov_diag=True, standardize=True)\n    mod1.initialize_known(results['initial_state'], results['initial_state_cov'])\n    res1 = mod1.smooth(results['params'], cov_type='none')\n    res2 = res1.apply(updated_M.iloc[:, :results['k_endog_M']], endog_quarterly=updated_Q, retain_standardization=True)\n    news = res2.news(res1, impact_date='2016-09', comparison_type='previous')\n    assert_allclose(news.revision_impacts.loc['2016-09', 'GDPC1'], results['revision_impacts'])\n    columns = ['forecast (prev)', 'observed', 'weight', 'impact']\n    actual = news.details_by_impact.loc['2016-09', 'GDPC1'][columns]\n    assert_allclose(actual.loc['2016-06', 'CPIAUCSL'], results['news_table'][0])\n    assert_allclose(actual.loc['2016-06', 'UNRATE'], results['news_table'][1])\n    assert_allclose(actual.loc['2016-06', 'PAYEMS'], results['news_table'][2])\n    if mod1.k_endog_M == 6:\n        i = 6\n        assert_allclose(actual.loc['2016-06', 'RSAFS'], results['news_table'][3])\n        assert_allclose(actual.loc['2016-05', 'TTLCONS'], results['news_table'][4])\n        assert_allclose(actual.loc['2016-06', 'TCU'], results['news_table'][5])\n    else:\n        i = 3\n    assert_allclose(actual.loc['2016-06', 'GDPC1'], results['news_table'][i])",
        "mutated": [
            "@pytest.mark.parametrize('run', ['news_112', 'news_222', 'news_block_112', 'news_block_222'])\ndef test_news(matlab_results, run):\n    if False:\n        i = 10\n    (endog_M, endog_Q) = matlab_results[:2]\n    results = matlab_results[2][run]\n    (updated_M, updated_Q) = matlab_results[-2:]\n    mod1 = dynamic_factor_mq.DynamicFactorMQ(endog_M.iloc[:, :results['k_endog_M']], endog_quarterly=endog_Q, factors=results['factors'], factor_orders=results['factor_orders'], factor_multiplicities=results['factor_multiplicities'], idiosyncratic_ar1=True, init_t0=True, obs_cov_diag=True, standardize=True)\n    mod1.initialize_known(results['initial_state'], results['initial_state_cov'])\n    res1 = mod1.smooth(results['params'], cov_type='none')\n    res2 = res1.apply(updated_M.iloc[:, :results['k_endog_M']], endog_quarterly=updated_Q, retain_standardization=True)\n    news = res2.news(res1, impact_date='2016-09', comparison_type='previous')\n    assert_allclose(news.revision_impacts.loc['2016-09', 'GDPC1'], results['revision_impacts'])\n    columns = ['forecast (prev)', 'observed', 'weight', 'impact']\n    actual = news.details_by_impact.loc['2016-09', 'GDPC1'][columns]\n    assert_allclose(actual.loc['2016-06', 'CPIAUCSL'], results['news_table'][0])\n    assert_allclose(actual.loc['2016-06', 'UNRATE'], results['news_table'][1])\n    assert_allclose(actual.loc['2016-06', 'PAYEMS'], results['news_table'][2])\n    if mod1.k_endog_M == 6:\n        i = 6\n        assert_allclose(actual.loc['2016-06', 'RSAFS'], results['news_table'][3])\n        assert_allclose(actual.loc['2016-05', 'TTLCONS'], results['news_table'][4])\n        assert_allclose(actual.loc['2016-06', 'TCU'], results['news_table'][5])\n    else:\n        i = 3\n    assert_allclose(actual.loc['2016-06', 'GDPC1'], results['news_table'][i])",
            "@pytest.mark.parametrize('run', ['news_112', 'news_222', 'news_block_112', 'news_block_222'])\ndef test_news(matlab_results, run):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (endog_M, endog_Q) = matlab_results[:2]\n    results = matlab_results[2][run]\n    (updated_M, updated_Q) = matlab_results[-2:]\n    mod1 = dynamic_factor_mq.DynamicFactorMQ(endog_M.iloc[:, :results['k_endog_M']], endog_quarterly=endog_Q, factors=results['factors'], factor_orders=results['factor_orders'], factor_multiplicities=results['factor_multiplicities'], idiosyncratic_ar1=True, init_t0=True, obs_cov_diag=True, standardize=True)\n    mod1.initialize_known(results['initial_state'], results['initial_state_cov'])\n    res1 = mod1.smooth(results['params'], cov_type='none')\n    res2 = res1.apply(updated_M.iloc[:, :results['k_endog_M']], endog_quarterly=updated_Q, retain_standardization=True)\n    news = res2.news(res1, impact_date='2016-09', comparison_type='previous')\n    assert_allclose(news.revision_impacts.loc['2016-09', 'GDPC1'], results['revision_impacts'])\n    columns = ['forecast (prev)', 'observed', 'weight', 'impact']\n    actual = news.details_by_impact.loc['2016-09', 'GDPC1'][columns]\n    assert_allclose(actual.loc['2016-06', 'CPIAUCSL'], results['news_table'][0])\n    assert_allclose(actual.loc['2016-06', 'UNRATE'], results['news_table'][1])\n    assert_allclose(actual.loc['2016-06', 'PAYEMS'], results['news_table'][2])\n    if mod1.k_endog_M == 6:\n        i = 6\n        assert_allclose(actual.loc['2016-06', 'RSAFS'], results['news_table'][3])\n        assert_allclose(actual.loc['2016-05', 'TTLCONS'], results['news_table'][4])\n        assert_allclose(actual.loc['2016-06', 'TCU'], results['news_table'][5])\n    else:\n        i = 3\n    assert_allclose(actual.loc['2016-06', 'GDPC1'], results['news_table'][i])",
            "@pytest.mark.parametrize('run', ['news_112', 'news_222', 'news_block_112', 'news_block_222'])\ndef test_news(matlab_results, run):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (endog_M, endog_Q) = matlab_results[:2]\n    results = matlab_results[2][run]\n    (updated_M, updated_Q) = matlab_results[-2:]\n    mod1 = dynamic_factor_mq.DynamicFactorMQ(endog_M.iloc[:, :results['k_endog_M']], endog_quarterly=endog_Q, factors=results['factors'], factor_orders=results['factor_orders'], factor_multiplicities=results['factor_multiplicities'], idiosyncratic_ar1=True, init_t0=True, obs_cov_diag=True, standardize=True)\n    mod1.initialize_known(results['initial_state'], results['initial_state_cov'])\n    res1 = mod1.smooth(results['params'], cov_type='none')\n    res2 = res1.apply(updated_M.iloc[:, :results['k_endog_M']], endog_quarterly=updated_Q, retain_standardization=True)\n    news = res2.news(res1, impact_date='2016-09', comparison_type='previous')\n    assert_allclose(news.revision_impacts.loc['2016-09', 'GDPC1'], results['revision_impacts'])\n    columns = ['forecast (prev)', 'observed', 'weight', 'impact']\n    actual = news.details_by_impact.loc['2016-09', 'GDPC1'][columns]\n    assert_allclose(actual.loc['2016-06', 'CPIAUCSL'], results['news_table'][0])\n    assert_allclose(actual.loc['2016-06', 'UNRATE'], results['news_table'][1])\n    assert_allclose(actual.loc['2016-06', 'PAYEMS'], results['news_table'][2])\n    if mod1.k_endog_M == 6:\n        i = 6\n        assert_allclose(actual.loc['2016-06', 'RSAFS'], results['news_table'][3])\n        assert_allclose(actual.loc['2016-05', 'TTLCONS'], results['news_table'][4])\n        assert_allclose(actual.loc['2016-06', 'TCU'], results['news_table'][5])\n    else:\n        i = 3\n    assert_allclose(actual.loc['2016-06', 'GDPC1'], results['news_table'][i])",
            "@pytest.mark.parametrize('run', ['news_112', 'news_222', 'news_block_112', 'news_block_222'])\ndef test_news(matlab_results, run):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (endog_M, endog_Q) = matlab_results[:2]\n    results = matlab_results[2][run]\n    (updated_M, updated_Q) = matlab_results[-2:]\n    mod1 = dynamic_factor_mq.DynamicFactorMQ(endog_M.iloc[:, :results['k_endog_M']], endog_quarterly=endog_Q, factors=results['factors'], factor_orders=results['factor_orders'], factor_multiplicities=results['factor_multiplicities'], idiosyncratic_ar1=True, init_t0=True, obs_cov_diag=True, standardize=True)\n    mod1.initialize_known(results['initial_state'], results['initial_state_cov'])\n    res1 = mod1.smooth(results['params'], cov_type='none')\n    res2 = res1.apply(updated_M.iloc[:, :results['k_endog_M']], endog_quarterly=updated_Q, retain_standardization=True)\n    news = res2.news(res1, impact_date='2016-09', comparison_type='previous')\n    assert_allclose(news.revision_impacts.loc['2016-09', 'GDPC1'], results['revision_impacts'])\n    columns = ['forecast (prev)', 'observed', 'weight', 'impact']\n    actual = news.details_by_impact.loc['2016-09', 'GDPC1'][columns]\n    assert_allclose(actual.loc['2016-06', 'CPIAUCSL'], results['news_table'][0])\n    assert_allclose(actual.loc['2016-06', 'UNRATE'], results['news_table'][1])\n    assert_allclose(actual.loc['2016-06', 'PAYEMS'], results['news_table'][2])\n    if mod1.k_endog_M == 6:\n        i = 6\n        assert_allclose(actual.loc['2016-06', 'RSAFS'], results['news_table'][3])\n        assert_allclose(actual.loc['2016-05', 'TTLCONS'], results['news_table'][4])\n        assert_allclose(actual.loc['2016-06', 'TCU'], results['news_table'][5])\n    else:\n        i = 3\n    assert_allclose(actual.loc['2016-06', 'GDPC1'], results['news_table'][i])",
            "@pytest.mark.parametrize('run', ['news_112', 'news_222', 'news_block_112', 'news_block_222'])\ndef test_news(matlab_results, run):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (endog_M, endog_Q) = matlab_results[:2]\n    results = matlab_results[2][run]\n    (updated_M, updated_Q) = matlab_results[-2:]\n    mod1 = dynamic_factor_mq.DynamicFactorMQ(endog_M.iloc[:, :results['k_endog_M']], endog_quarterly=endog_Q, factors=results['factors'], factor_orders=results['factor_orders'], factor_multiplicities=results['factor_multiplicities'], idiosyncratic_ar1=True, init_t0=True, obs_cov_diag=True, standardize=True)\n    mod1.initialize_known(results['initial_state'], results['initial_state_cov'])\n    res1 = mod1.smooth(results['params'], cov_type='none')\n    res2 = res1.apply(updated_M.iloc[:, :results['k_endog_M']], endog_quarterly=updated_Q, retain_standardization=True)\n    news = res2.news(res1, impact_date='2016-09', comparison_type='previous')\n    assert_allclose(news.revision_impacts.loc['2016-09', 'GDPC1'], results['revision_impacts'])\n    columns = ['forecast (prev)', 'observed', 'weight', 'impact']\n    actual = news.details_by_impact.loc['2016-09', 'GDPC1'][columns]\n    assert_allclose(actual.loc['2016-06', 'CPIAUCSL'], results['news_table'][0])\n    assert_allclose(actual.loc['2016-06', 'UNRATE'], results['news_table'][1])\n    assert_allclose(actual.loc['2016-06', 'PAYEMS'], results['news_table'][2])\n    if mod1.k_endog_M == 6:\n        i = 6\n        assert_allclose(actual.loc['2016-06', 'RSAFS'], results['news_table'][3])\n        assert_allclose(actual.loc['2016-05', 'TTLCONS'], results['news_table'][4])\n        assert_allclose(actual.loc['2016-06', 'TCU'], results['news_table'][5])\n    else:\n        i = 3\n    assert_allclose(actual.loc['2016-06', 'GDPC1'], results['news_table'][i])"
        ]
    }
]