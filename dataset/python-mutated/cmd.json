[
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    super(AutoSploitParser, self).__init__()",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    super(AutoSploitParser, self).__init__()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(AutoSploitParser, self).__init__()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(AutoSploitParser, self).__init__()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(AutoSploitParser, self).__init__()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(AutoSploitParser, self).__init__()"
        ]
    },
    {
        "func_name": "optparser",
        "original": "@staticmethod\ndef optparser():\n    \"\"\"\n        the options function for our parser, it will put everything into play\n        \"\"\"\n    parser = argparse.ArgumentParser(usage='python autosploit.py -c[z|s|a] -q QUERY [-O|A]\\n{spacer}[-C WORKSPACE LHOST LPORT] [-e] [--whitewash PATH] [-H]\\n{spacer}[--ruby-exec] [--msf-path] PATH [-E EXPLOIT-FILE-PATH]\\n{spacer}[--rand-agent] [--proxy PROTO://IP:PORT] [-P AGENT] [-D QUERY,QUERY,..]'.format(spacer=' ' * 28))\n    se = parser.add_argument_group('search engines', 'possible search engines to use')\n    se.add_argument('-c', '--censys', action='store_true', dest='searchCensys', help='use censys.io as the search engine to gather hosts')\n    se.add_argument('-z', '--zoomeye', action='store_true', dest='searchZoomeye', help='use zoomeye.org as the search engine to gather hosts')\n    se.add_argument('-s', '--shodan', action='store_true', dest='searchShodan', help='use shodan.io as the search engine to gather hosts')\n    se.add_argument('-a', '--all', action='store_true', dest='searchAll', help='search all available search engines to gather hosts')\n    save_results_args = se.add_mutually_exclusive_group(required=False)\n    save_results_args.add_argument('-O', '--overwrite', action='store_true', dest='overwriteHosts', help='When specified, start from scratch by overwriting the host file with new search results.')\n    save_results_args.add_argument('-A', '--append', action='store_true', dest='appendHosts', help='When specified, append discovered hosts to the host file.')\n    req = parser.add_argument_group('requests', 'arguments to edit your requests')\n    req.add_argument('--proxy', metavar='PROTO://IP:PORT', dest='proxyConfig', help='run behind a proxy while performing the searches')\n    req.add_argument('--random-agent', action='store_true', dest='randomAgent', help='use a random HTTP User-Agent header')\n    req.add_argument('-P', '--personal-agent', metavar='USER-AGENT', dest='personalAgent', help='pass a personal User-Agent to use for HTTP requests')\n    req.add_argument('-q', '--query', metavar='QUERY', dest='searchQuery', help='pass your search query')\n    exploit = parser.add_argument_group('exploits', 'arguments to edit your exploits')\n    exploit.add_argument('-E', '--exploit-file', metavar='PATH', dest='exploitList', help='provide a text file to convert into JSON and save for later use')\n    exploit.add_argument('-C', '--config', nargs=3, metavar=('WORKSPACE', 'LHOST', 'LPORT'), dest='msfConfig', help='set the configuration for MSF (IE -C default 127.0.0.1 8080)')\n    exploit.add_argument('-e', '--exploit', action='store_true', dest='startExploit', help='start exploiting the already gathered hosts')\n    exploit.add_argument('-d', '--dry-run', action='store_true', dest='dryRun', help='msfconsole will never be called when this flag is passed')\n    exploit.add_argument('-f', '--exploit-file-to-use', metavar='PATH', dest='exploitFile', help='Run AutoSploit with provided exploit JSON file.')\n    exploit.add_argument('-H', '--is-honeypot', type=float, default=1000, dest='checkIfHoneypot', metavar='HONEY-SCORE', help='Determine if the host is a honeypot or not')\n    misc = parser.add_argument_group('misc arguments', \"arguments that don't fit anywhere else\")\n    misc.add_argument('--ruby-exec', action='store_true', dest='rubyExecutableNeeded', help='if you need to run the Ruby executable with MSF use this')\n    misc.add_argument('--msf-path', metavar='MSF-PATH', dest='pathToFramework', help='pass the path to your framework if it is not in your ENV PATH')\n    misc.add_argument('--ethics', action='store_true', dest='displayEthics', help=argparse.SUPPRESS)\n    misc.add_argument('--whitelist', metavar='PATH', dest='whitelist', help='only exploit hosts listed in the whitelist file')\n    misc.add_argument('-D', '--download', nargs='+', metavar='SEARCH1 SEARCH2 ...', dest='downloadModules', help='download new exploit modules with a provided search flag')\n    opts = parser.parse_args()\n    return opts",
        "mutated": [
            "@staticmethod\ndef optparser():\n    if False:\n        i = 10\n    '\\n        the options function for our parser, it will put everything into play\\n        '\n    parser = argparse.ArgumentParser(usage='python autosploit.py -c[z|s|a] -q QUERY [-O|A]\\n{spacer}[-C WORKSPACE LHOST LPORT] [-e] [--whitewash PATH] [-H]\\n{spacer}[--ruby-exec] [--msf-path] PATH [-E EXPLOIT-FILE-PATH]\\n{spacer}[--rand-agent] [--proxy PROTO://IP:PORT] [-P AGENT] [-D QUERY,QUERY,..]'.format(spacer=' ' * 28))\n    se = parser.add_argument_group('search engines', 'possible search engines to use')\n    se.add_argument('-c', '--censys', action='store_true', dest='searchCensys', help='use censys.io as the search engine to gather hosts')\n    se.add_argument('-z', '--zoomeye', action='store_true', dest='searchZoomeye', help='use zoomeye.org as the search engine to gather hosts')\n    se.add_argument('-s', '--shodan', action='store_true', dest='searchShodan', help='use shodan.io as the search engine to gather hosts')\n    se.add_argument('-a', '--all', action='store_true', dest='searchAll', help='search all available search engines to gather hosts')\n    save_results_args = se.add_mutually_exclusive_group(required=False)\n    save_results_args.add_argument('-O', '--overwrite', action='store_true', dest='overwriteHosts', help='When specified, start from scratch by overwriting the host file with new search results.')\n    save_results_args.add_argument('-A', '--append', action='store_true', dest='appendHosts', help='When specified, append discovered hosts to the host file.')\n    req = parser.add_argument_group('requests', 'arguments to edit your requests')\n    req.add_argument('--proxy', metavar='PROTO://IP:PORT', dest='proxyConfig', help='run behind a proxy while performing the searches')\n    req.add_argument('--random-agent', action='store_true', dest='randomAgent', help='use a random HTTP User-Agent header')\n    req.add_argument('-P', '--personal-agent', metavar='USER-AGENT', dest='personalAgent', help='pass a personal User-Agent to use for HTTP requests')\n    req.add_argument('-q', '--query', metavar='QUERY', dest='searchQuery', help='pass your search query')\n    exploit = parser.add_argument_group('exploits', 'arguments to edit your exploits')\n    exploit.add_argument('-E', '--exploit-file', metavar='PATH', dest='exploitList', help='provide a text file to convert into JSON and save for later use')\n    exploit.add_argument('-C', '--config', nargs=3, metavar=('WORKSPACE', 'LHOST', 'LPORT'), dest='msfConfig', help='set the configuration for MSF (IE -C default 127.0.0.1 8080)')\n    exploit.add_argument('-e', '--exploit', action='store_true', dest='startExploit', help='start exploiting the already gathered hosts')\n    exploit.add_argument('-d', '--dry-run', action='store_true', dest='dryRun', help='msfconsole will never be called when this flag is passed')\n    exploit.add_argument('-f', '--exploit-file-to-use', metavar='PATH', dest='exploitFile', help='Run AutoSploit with provided exploit JSON file.')\n    exploit.add_argument('-H', '--is-honeypot', type=float, default=1000, dest='checkIfHoneypot', metavar='HONEY-SCORE', help='Determine if the host is a honeypot or not')\n    misc = parser.add_argument_group('misc arguments', \"arguments that don't fit anywhere else\")\n    misc.add_argument('--ruby-exec', action='store_true', dest='rubyExecutableNeeded', help='if you need to run the Ruby executable with MSF use this')\n    misc.add_argument('--msf-path', metavar='MSF-PATH', dest='pathToFramework', help='pass the path to your framework if it is not in your ENV PATH')\n    misc.add_argument('--ethics', action='store_true', dest='displayEthics', help=argparse.SUPPRESS)\n    misc.add_argument('--whitelist', metavar='PATH', dest='whitelist', help='only exploit hosts listed in the whitelist file')\n    misc.add_argument('-D', '--download', nargs='+', metavar='SEARCH1 SEARCH2 ...', dest='downloadModules', help='download new exploit modules with a provided search flag')\n    opts = parser.parse_args()\n    return opts",
            "@staticmethod\ndef optparser():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        the options function for our parser, it will put everything into play\\n        '\n    parser = argparse.ArgumentParser(usage='python autosploit.py -c[z|s|a] -q QUERY [-O|A]\\n{spacer}[-C WORKSPACE LHOST LPORT] [-e] [--whitewash PATH] [-H]\\n{spacer}[--ruby-exec] [--msf-path] PATH [-E EXPLOIT-FILE-PATH]\\n{spacer}[--rand-agent] [--proxy PROTO://IP:PORT] [-P AGENT] [-D QUERY,QUERY,..]'.format(spacer=' ' * 28))\n    se = parser.add_argument_group('search engines', 'possible search engines to use')\n    se.add_argument('-c', '--censys', action='store_true', dest='searchCensys', help='use censys.io as the search engine to gather hosts')\n    se.add_argument('-z', '--zoomeye', action='store_true', dest='searchZoomeye', help='use zoomeye.org as the search engine to gather hosts')\n    se.add_argument('-s', '--shodan', action='store_true', dest='searchShodan', help='use shodan.io as the search engine to gather hosts')\n    se.add_argument('-a', '--all', action='store_true', dest='searchAll', help='search all available search engines to gather hosts')\n    save_results_args = se.add_mutually_exclusive_group(required=False)\n    save_results_args.add_argument('-O', '--overwrite', action='store_true', dest='overwriteHosts', help='When specified, start from scratch by overwriting the host file with new search results.')\n    save_results_args.add_argument('-A', '--append', action='store_true', dest='appendHosts', help='When specified, append discovered hosts to the host file.')\n    req = parser.add_argument_group('requests', 'arguments to edit your requests')\n    req.add_argument('--proxy', metavar='PROTO://IP:PORT', dest='proxyConfig', help='run behind a proxy while performing the searches')\n    req.add_argument('--random-agent', action='store_true', dest='randomAgent', help='use a random HTTP User-Agent header')\n    req.add_argument('-P', '--personal-agent', metavar='USER-AGENT', dest='personalAgent', help='pass a personal User-Agent to use for HTTP requests')\n    req.add_argument('-q', '--query', metavar='QUERY', dest='searchQuery', help='pass your search query')\n    exploit = parser.add_argument_group('exploits', 'arguments to edit your exploits')\n    exploit.add_argument('-E', '--exploit-file', metavar='PATH', dest='exploitList', help='provide a text file to convert into JSON and save for later use')\n    exploit.add_argument('-C', '--config', nargs=3, metavar=('WORKSPACE', 'LHOST', 'LPORT'), dest='msfConfig', help='set the configuration for MSF (IE -C default 127.0.0.1 8080)')\n    exploit.add_argument('-e', '--exploit', action='store_true', dest='startExploit', help='start exploiting the already gathered hosts')\n    exploit.add_argument('-d', '--dry-run', action='store_true', dest='dryRun', help='msfconsole will never be called when this flag is passed')\n    exploit.add_argument('-f', '--exploit-file-to-use', metavar='PATH', dest='exploitFile', help='Run AutoSploit with provided exploit JSON file.')\n    exploit.add_argument('-H', '--is-honeypot', type=float, default=1000, dest='checkIfHoneypot', metavar='HONEY-SCORE', help='Determine if the host is a honeypot or not')\n    misc = parser.add_argument_group('misc arguments', \"arguments that don't fit anywhere else\")\n    misc.add_argument('--ruby-exec', action='store_true', dest='rubyExecutableNeeded', help='if you need to run the Ruby executable with MSF use this')\n    misc.add_argument('--msf-path', metavar='MSF-PATH', dest='pathToFramework', help='pass the path to your framework if it is not in your ENV PATH')\n    misc.add_argument('--ethics', action='store_true', dest='displayEthics', help=argparse.SUPPRESS)\n    misc.add_argument('--whitelist', metavar='PATH', dest='whitelist', help='only exploit hosts listed in the whitelist file')\n    misc.add_argument('-D', '--download', nargs='+', metavar='SEARCH1 SEARCH2 ...', dest='downloadModules', help='download new exploit modules with a provided search flag')\n    opts = parser.parse_args()\n    return opts",
            "@staticmethod\ndef optparser():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        the options function for our parser, it will put everything into play\\n        '\n    parser = argparse.ArgumentParser(usage='python autosploit.py -c[z|s|a] -q QUERY [-O|A]\\n{spacer}[-C WORKSPACE LHOST LPORT] [-e] [--whitewash PATH] [-H]\\n{spacer}[--ruby-exec] [--msf-path] PATH [-E EXPLOIT-FILE-PATH]\\n{spacer}[--rand-agent] [--proxy PROTO://IP:PORT] [-P AGENT] [-D QUERY,QUERY,..]'.format(spacer=' ' * 28))\n    se = parser.add_argument_group('search engines', 'possible search engines to use')\n    se.add_argument('-c', '--censys', action='store_true', dest='searchCensys', help='use censys.io as the search engine to gather hosts')\n    se.add_argument('-z', '--zoomeye', action='store_true', dest='searchZoomeye', help='use zoomeye.org as the search engine to gather hosts')\n    se.add_argument('-s', '--shodan', action='store_true', dest='searchShodan', help='use shodan.io as the search engine to gather hosts')\n    se.add_argument('-a', '--all', action='store_true', dest='searchAll', help='search all available search engines to gather hosts')\n    save_results_args = se.add_mutually_exclusive_group(required=False)\n    save_results_args.add_argument('-O', '--overwrite', action='store_true', dest='overwriteHosts', help='When specified, start from scratch by overwriting the host file with new search results.')\n    save_results_args.add_argument('-A', '--append', action='store_true', dest='appendHosts', help='When specified, append discovered hosts to the host file.')\n    req = parser.add_argument_group('requests', 'arguments to edit your requests')\n    req.add_argument('--proxy', metavar='PROTO://IP:PORT', dest='proxyConfig', help='run behind a proxy while performing the searches')\n    req.add_argument('--random-agent', action='store_true', dest='randomAgent', help='use a random HTTP User-Agent header')\n    req.add_argument('-P', '--personal-agent', metavar='USER-AGENT', dest='personalAgent', help='pass a personal User-Agent to use for HTTP requests')\n    req.add_argument('-q', '--query', metavar='QUERY', dest='searchQuery', help='pass your search query')\n    exploit = parser.add_argument_group('exploits', 'arguments to edit your exploits')\n    exploit.add_argument('-E', '--exploit-file', metavar='PATH', dest='exploitList', help='provide a text file to convert into JSON and save for later use')\n    exploit.add_argument('-C', '--config', nargs=3, metavar=('WORKSPACE', 'LHOST', 'LPORT'), dest='msfConfig', help='set the configuration for MSF (IE -C default 127.0.0.1 8080)')\n    exploit.add_argument('-e', '--exploit', action='store_true', dest='startExploit', help='start exploiting the already gathered hosts')\n    exploit.add_argument('-d', '--dry-run', action='store_true', dest='dryRun', help='msfconsole will never be called when this flag is passed')\n    exploit.add_argument('-f', '--exploit-file-to-use', metavar='PATH', dest='exploitFile', help='Run AutoSploit with provided exploit JSON file.')\n    exploit.add_argument('-H', '--is-honeypot', type=float, default=1000, dest='checkIfHoneypot', metavar='HONEY-SCORE', help='Determine if the host is a honeypot or not')\n    misc = parser.add_argument_group('misc arguments', \"arguments that don't fit anywhere else\")\n    misc.add_argument('--ruby-exec', action='store_true', dest='rubyExecutableNeeded', help='if you need to run the Ruby executable with MSF use this')\n    misc.add_argument('--msf-path', metavar='MSF-PATH', dest='pathToFramework', help='pass the path to your framework if it is not in your ENV PATH')\n    misc.add_argument('--ethics', action='store_true', dest='displayEthics', help=argparse.SUPPRESS)\n    misc.add_argument('--whitelist', metavar='PATH', dest='whitelist', help='only exploit hosts listed in the whitelist file')\n    misc.add_argument('-D', '--download', nargs='+', metavar='SEARCH1 SEARCH2 ...', dest='downloadModules', help='download new exploit modules with a provided search flag')\n    opts = parser.parse_args()\n    return opts",
            "@staticmethod\ndef optparser():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        the options function for our parser, it will put everything into play\\n        '\n    parser = argparse.ArgumentParser(usage='python autosploit.py -c[z|s|a] -q QUERY [-O|A]\\n{spacer}[-C WORKSPACE LHOST LPORT] [-e] [--whitewash PATH] [-H]\\n{spacer}[--ruby-exec] [--msf-path] PATH [-E EXPLOIT-FILE-PATH]\\n{spacer}[--rand-agent] [--proxy PROTO://IP:PORT] [-P AGENT] [-D QUERY,QUERY,..]'.format(spacer=' ' * 28))\n    se = parser.add_argument_group('search engines', 'possible search engines to use')\n    se.add_argument('-c', '--censys', action='store_true', dest='searchCensys', help='use censys.io as the search engine to gather hosts')\n    se.add_argument('-z', '--zoomeye', action='store_true', dest='searchZoomeye', help='use zoomeye.org as the search engine to gather hosts')\n    se.add_argument('-s', '--shodan', action='store_true', dest='searchShodan', help='use shodan.io as the search engine to gather hosts')\n    se.add_argument('-a', '--all', action='store_true', dest='searchAll', help='search all available search engines to gather hosts')\n    save_results_args = se.add_mutually_exclusive_group(required=False)\n    save_results_args.add_argument('-O', '--overwrite', action='store_true', dest='overwriteHosts', help='When specified, start from scratch by overwriting the host file with new search results.')\n    save_results_args.add_argument('-A', '--append', action='store_true', dest='appendHosts', help='When specified, append discovered hosts to the host file.')\n    req = parser.add_argument_group('requests', 'arguments to edit your requests')\n    req.add_argument('--proxy', metavar='PROTO://IP:PORT', dest='proxyConfig', help='run behind a proxy while performing the searches')\n    req.add_argument('--random-agent', action='store_true', dest='randomAgent', help='use a random HTTP User-Agent header')\n    req.add_argument('-P', '--personal-agent', metavar='USER-AGENT', dest='personalAgent', help='pass a personal User-Agent to use for HTTP requests')\n    req.add_argument('-q', '--query', metavar='QUERY', dest='searchQuery', help='pass your search query')\n    exploit = parser.add_argument_group('exploits', 'arguments to edit your exploits')\n    exploit.add_argument('-E', '--exploit-file', metavar='PATH', dest='exploitList', help='provide a text file to convert into JSON and save for later use')\n    exploit.add_argument('-C', '--config', nargs=3, metavar=('WORKSPACE', 'LHOST', 'LPORT'), dest='msfConfig', help='set the configuration for MSF (IE -C default 127.0.0.1 8080)')\n    exploit.add_argument('-e', '--exploit', action='store_true', dest='startExploit', help='start exploiting the already gathered hosts')\n    exploit.add_argument('-d', '--dry-run', action='store_true', dest='dryRun', help='msfconsole will never be called when this flag is passed')\n    exploit.add_argument('-f', '--exploit-file-to-use', metavar='PATH', dest='exploitFile', help='Run AutoSploit with provided exploit JSON file.')\n    exploit.add_argument('-H', '--is-honeypot', type=float, default=1000, dest='checkIfHoneypot', metavar='HONEY-SCORE', help='Determine if the host is a honeypot or not')\n    misc = parser.add_argument_group('misc arguments', \"arguments that don't fit anywhere else\")\n    misc.add_argument('--ruby-exec', action='store_true', dest='rubyExecutableNeeded', help='if you need to run the Ruby executable with MSF use this')\n    misc.add_argument('--msf-path', metavar='MSF-PATH', dest='pathToFramework', help='pass the path to your framework if it is not in your ENV PATH')\n    misc.add_argument('--ethics', action='store_true', dest='displayEthics', help=argparse.SUPPRESS)\n    misc.add_argument('--whitelist', metavar='PATH', dest='whitelist', help='only exploit hosts listed in the whitelist file')\n    misc.add_argument('-D', '--download', nargs='+', metavar='SEARCH1 SEARCH2 ...', dest='downloadModules', help='download new exploit modules with a provided search flag')\n    opts = parser.parse_args()\n    return opts",
            "@staticmethod\ndef optparser():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        the options function for our parser, it will put everything into play\\n        '\n    parser = argparse.ArgumentParser(usage='python autosploit.py -c[z|s|a] -q QUERY [-O|A]\\n{spacer}[-C WORKSPACE LHOST LPORT] [-e] [--whitewash PATH] [-H]\\n{spacer}[--ruby-exec] [--msf-path] PATH [-E EXPLOIT-FILE-PATH]\\n{spacer}[--rand-agent] [--proxy PROTO://IP:PORT] [-P AGENT] [-D QUERY,QUERY,..]'.format(spacer=' ' * 28))\n    se = parser.add_argument_group('search engines', 'possible search engines to use')\n    se.add_argument('-c', '--censys', action='store_true', dest='searchCensys', help='use censys.io as the search engine to gather hosts')\n    se.add_argument('-z', '--zoomeye', action='store_true', dest='searchZoomeye', help='use zoomeye.org as the search engine to gather hosts')\n    se.add_argument('-s', '--shodan', action='store_true', dest='searchShodan', help='use shodan.io as the search engine to gather hosts')\n    se.add_argument('-a', '--all', action='store_true', dest='searchAll', help='search all available search engines to gather hosts')\n    save_results_args = se.add_mutually_exclusive_group(required=False)\n    save_results_args.add_argument('-O', '--overwrite', action='store_true', dest='overwriteHosts', help='When specified, start from scratch by overwriting the host file with new search results.')\n    save_results_args.add_argument('-A', '--append', action='store_true', dest='appendHosts', help='When specified, append discovered hosts to the host file.')\n    req = parser.add_argument_group('requests', 'arguments to edit your requests')\n    req.add_argument('--proxy', metavar='PROTO://IP:PORT', dest='proxyConfig', help='run behind a proxy while performing the searches')\n    req.add_argument('--random-agent', action='store_true', dest='randomAgent', help='use a random HTTP User-Agent header')\n    req.add_argument('-P', '--personal-agent', metavar='USER-AGENT', dest='personalAgent', help='pass a personal User-Agent to use for HTTP requests')\n    req.add_argument('-q', '--query', metavar='QUERY', dest='searchQuery', help='pass your search query')\n    exploit = parser.add_argument_group('exploits', 'arguments to edit your exploits')\n    exploit.add_argument('-E', '--exploit-file', metavar='PATH', dest='exploitList', help='provide a text file to convert into JSON and save for later use')\n    exploit.add_argument('-C', '--config', nargs=3, metavar=('WORKSPACE', 'LHOST', 'LPORT'), dest='msfConfig', help='set the configuration for MSF (IE -C default 127.0.0.1 8080)')\n    exploit.add_argument('-e', '--exploit', action='store_true', dest='startExploit', help='start exploiting the already gathered hosts')\n    exploit.add_argument('-d', '--dry-run', action='store_true', dest='dryRun', help='msfconsole will never be called when this flag is passed')\n    exploit.add_argument('-f', '--exploit-file-to-use', metavar='PATH', dest='exploitFile', help='Run AutoSploit with provided exploit JSON file.')\n    exploit.add_argument('-H', '--is-honeypot', type=float, default=1000, dest='checkIfHoneypot', metavar='HONEY-SCORE', help='Determine if the host is a honeypot or not')\n    misc = parser.add_argument_group('misc arguments', \"arguments that don't fit anywhere else\")\n    misc.add_argument('--ruby-exec', action='store_true', dest='rubyExecutableNeeded', help='if you need to run the Ruby executable with MSF use this')\n    misc.add_argument('--msf-path', metavar='MSF-PATH', dest='pathToFramework', help='pass the path to your framework if it is not in your ENV PATH')\n    misc.add_argument('--ethics', action='store_true', dest='displayEthics', help=argparse.SUPPRESS)\n    misc.add_argument('--whitelist', metavar='PATH', dest='whitelist', help='only exploit hosts listed in the whitelist file')\n    misc.add_argument('-D', '--download', nargs='+', metavar='SEARCH1 SEARCH2 ...', dest='downloadModules', help='download new exploit modules with a provided search flag')\n    opts = parser.parse_args()\n    return opts"
        ]
    },
    {
        "func_name": "parse_provided",
        "original": "@staticmethod\ndef parse_provided(opt):\n    \"\"\"\n        parse the provided arguments to make sure that they are all compatible with one another\n        \"\"\"\n    parser = any([opt.searchAll, opt.searchZoomeye, opt.searchCensys, opt.searchShodan])\n    if opt.rubyExecutableNeeded and opt.pathToFramework is None:\n        lib.settings.close('if the Ruby exec is needed, so is the path to metasploit, pass the `--msf-path` switch')\n    if opt.pathToFramework is not None and (not opt.rubyExecutableNeeded):\n        lib.settings.close('if you need the metasploit path, you also need the ruby executable. pass the `--ruby-exec` switch')\n    if opt.personalAgent is not None and opt.randomAgent:\n        lib.settings.close('you cannot use both a personal agent and a random agent, choose only one')\n    if parser and opt.searchQuery is None:\n        lib.settings.close('must provide a search query with the `-q/--query` switch')\n    if not parser and opt.searchQuery is not None:\n        lib.settings.close('you provided a query and no search engine, choose one with `-s/--shodan/-z/--zoomeye/-c/--censys` or all with `-a/--all`')\n    if opt.startExploit and opt.msfConfig is None:\n        lib.settings.close(\"you must provide the configuration for metasploit in order to start the exploits do so by passing the `-C\\\\--config` switch (IE -C default 127.0.0.1 8080). don't be an idiot and keep in mind that sending connections back to your localhost is probably not a good idea\")\n    if not opt.startExploit and opt.msfConfig is not None:\n        lib.settings.close('you have provided configuration without attempting to exploit, you must pass the `-e/--exploit` switch to start exploiting')",
        "mutated": [
            "@staticmethod\ndef parse_provided(opt):\n    if False:\n        i = 10\n    '\\n        parse the provided arguments to make sure that they are all compatible with one another\\n        '\n    parser = any([opt.searchAll, opt.searchZoomeye, opt.searchCensys, opt.searchShodan])\n    if opt.rubyExecutableNeeded and opt.pathToFramework is None:\n        lib.settings.close('if the Ruby exec is needed, so is the path to metasploit, pass the `--msf-path` switch')\n    if opt.pathToFramework is not None and (not opt.rubyExecutableNeeded):\n        lib.settings.close('if you need the metasploit path, you also need the ruby executable. pass the `--ruby-exec` switch')\n    if opt.personalAgent is not None and opt.randomAgent:\n        lib.settings.close('you cannot use both a personal agent and a random agent, choose only one')\n    if parser and opt.searchQuery is None:\n        lib.settings.close('must provide a search query with the `-q/--query` switch')\n    if not parser and opt.searchQuery is not None:\n        lib.settings.close('you provided a query and no search engine, choose one with `-s/--shodan/-z/--zoomeye/-c/--censys` or all with `-a/--all`')\n    if opt.startExploit and opt.msfConfig is None:\n        lib.settings.close(\"you must provide the configuration for metasploit in order to start the exploits do so by passing the `-C\\\\--config` switch (IE -C default 127.0.0.1 8080). don't be an idiot and keep in mind that sending connections back to your localhost is probably not a good idea\")\n    if not opt.startExploit and opt.msfConfig is not None:\n        lib.settings.close('you have provided configuration without attempting to exploit, you must pass the `-e/--exploit` switch to start exploiting')",
            "@staticmethod\ndef parse_provided(opt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        parse the provided arguments to make sure that they are all compatible with one another\\n        '\n    parser = any([opt.searchAll, opt.searchZoomeye, opt.searchCensys, opt.searchShodan])\n    if opt.rubyExecutableNeeded and opt.pathToFramework is None:\n        lib.settings.close('if the Ruby exec is needed, so is the path to metasploit, pass the `--msf-path` switch')\n    if opt.pathToFramework is not None and (not opt.rubyExecutableNeeded):\n        lib.settings.close('if you need the metasploit path, you also need the ruby executable. pass the `--ruby-exec` switch')\n    if opt.personalAgent is not None and opt.randomAgent:\n        lib.settings.close('you cannot use both a personal agent and a random agent, choose only one')\n    if parser and opt.searchQuery is None:\n        lib.settings.close('must provide a search query with the `-q/--query` switch')\n    if not parser and opt.searchQuery is not None:\n        lib.settings.close('you provided a query and no search engine, choose one with `-s/--shodan/-z/--zoomeye/-c/--censys` or all with `-a/--all`')\n    if opt.startExploit and opt.msfConfig is None:\n        lib.settings.close(\"you must provide the configuration for metasploit in order to start the exploits do so by passing the `-C\\\\--config` switch (IE -C default 127.0.0.1 8080). don't be an idiot and keep in mind that sending connections back to your localhost is probably not a good idea\")\n    if not opt.startExploit and opt.msfConfig is not None:\n        lib.settings.close('you have provided configuration without attempting to exploit, you must pass the `-e/--exploit` switch to start exploiting')",
            "@staticmethod\ndef parse_provided(opt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        parse the provided arguments to make sure that they are all compatible with one another\\n        '\n    parser = any([opt.searchAll, opt.searchZoomeye, opt.searchCensys, opt.searchShodan])\n    if opt.rubyExecutableNeeded and opt.pathToFramework is None:\n        lib.settings.close('if the Ruby exec is needed, so is the path to metasploit, pass the `--msf-path` switch')\n    if opt.pathToFramework is not None and (not opt.rubyExecutableNeeded):\n        lib.settings.close('if you need the metasploit path, you also need the ruby executable. pass the `--ruby-exec` switch')\n    if opt.personalAgent is not None and opt.randomAgent:\n        lib.settings.close('you cannot use both a personal agent and a random agent, choose only one')\n    if parser and opt.searchQuery is None:\n        lib.settings.close('must provide a search query with the `-q/--query` switch')\n    if not parser and opt.searchQuery is not None:\n        lib.settings.close('you provided a query and no search engine, choose one with `-s/--shodan/-z/--zoomeye/-c/--censys` or all with `-a/--all`')\n    if opt.startExploit and opt.msfConfig is None:\n        lib.settings.close(\"you must provide the configuration for metasploit in order to start the exploits do so by passing the `-C\\\\--config` switch (IE -C default 127.0.0.1 8080). don't be an idiot and keep in mind that sending connections back to your localhost is probably not a good idea\")\n    if not opt.startExploit and opt.msfConfig is not None:\n        lib.settings.close('you have provided configuration without attempting to exploit, you must pass the `-e/--exploit` switch to start exploiting')",
            "@staticmethod\ndef parse_provided(opt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        parse the provided arguments to make sure that they are all compatible with one another\\n        '\n    parser = any([opt.searchAll, opt.searchZoomeye, opt.searchCensys, opt.searchShodan])\n    if opt.rubyExecutableNeeded and opt.pathToFramework is None:\n        lib.settings.close('if the Ruby exec is needed, so is the path to metasploit, pass the `--msf-path` switch')\n    if opt.pathToFramework is not None and (not opt.rubyExecutableNeeded):\n        lib.settings.close('if you need the metasploit path, you also need the ruby executable. pass the `--ruby-exec` switch')\n    if opt.personalAgent is not None and opt.randomAgent:\n        lib.settings.close('you cannot use both a personal agent and a random agent, choose only one')\n    if parser and opt.searchQuery is None:\n        lib.settings.close('must provide a search query with the `-q/--query` switch')\n    if not parser and opt.searchQuery is not None:\n        lib.settings.close('you provided a query and no search engine, choose one with `-s/--shodan/-z/--zoomeye/-c/--censys` or all with `-a/--all`')\n    if opt.startExploit and opt.msfConfig is None:\n        lib.settings.close(\"you must provide the configuration for metasploit in order to start the exploits do so by passing the `-C\\\\--config` switch (IE -C default 127.0.0.1 8080). don't be an idiot and keep in mind that sending connections back to your localhost is probably not a good idea\")\n    if not opt.startExploit and opt.msfConfig is not None:\n        lib.settings.close('you have provided configuration without attempting to exploit, you must pass the `-e/--exploit` switch to start exploiting')",
            "@staticmethod\ndef parse_provided(opt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        parse the provided arguments to make sure that they are all compatible with one another\\n        '\n    parser = any([opt.searchAll, opt.searchZoomeye, opt.searchCensys, opt.searchShodan])\n    if opt.rubyExecutableNeeded and opt.pathToFramework is None:\n        lib.settings.close('if the Ruby exec is needed, so is the path to metasploit, pass the `--msf-path` switch')\n    if opt.pathToFramework is not None and (not opt.rubyExecutableNeeded):\n        lib.settings.close('if you need the metasploit path, you also need the ruby executable. pass the `--ruby-exec` switch')\n    if opt.personalAgent is not None and opt.randomAgent:\n        lib.settings.close('you cannot use both a personal agent and a random agent, choose only one')\n    if parser and opt.searchQuery is None:\n        lib.settings.close('must provide a search query with the `-q/--query` switch')\n    if not parser and opt.searchQuery is not None:\n        lib.settings.close('you provided a query and no search engine, choose one with `-s/--shodan/-z/--zoomeye/-c/--censys` or all with `-a/--all`')\n    if opt.startExploit and opt.msfConfig is None:\n        lib.settings.close(\"you must provide the configuration for metasploit in order to start the exploits do so by passing the `-C\\\\--config` switch (IE -C default 127.0.0.1 8080). don't be an idiot and keep in mind that sending connections back to your localhost is probably not a good idea\")\n    if not opt.startExploit and opt.msfConfig is not None:\n        lib.settings.close('you have provided configuration without attempting to exploit, you must pass the `-e/--exploit` switch to start exploiting')"
        ]
    },
    {
        "func_name": "single_run_args",
        "original": "@staticmethod\ndef single_run_args(opt, keys, loaded_modules):\n    \"\"\"\n        run the arguments provided\n        \"\"\"\n    api_searches = (api_calls.zoomeye.ZoomEyeAPIHook, api_calls.shodan.ShodanAPIHook, api_calls.censys.CensysAPIHook)\n    headers = lib.settings.configure_requests(proxy=opt.proxyConfig, agent=opt.personalAgent, rand_agent=opt.randomAgent)\n    single_search_msg = 'using {} as the search engine'\n    if opt.displayEthics:\n        ethics_file = '{}/etc/text_files/ethics.lst'.format(os.getcwd())\n        with open(ethics_file) as ethics:\n            ethic = random.choice(ethics.readlines()).strip()\n            lib.settings.close('You should take this ethical lesson into consideration before you continue with the use of this tool:\\n\\n{}\\n'.format(ethic))\n    if opt.downloadModules is not None:\n        import re\n        modules_to_download = opt.downloadModules\n        links_list = '{}/etc/text_files/links.txt'.format(lib.settings.CUR_DIR)\n        possibles = open(links_list).readlines()\n        for module in modules_to_download:\n            searcher = re.compile('{}'.format(module))\n            for link in possibles:\n                if searcher.search(link) is not None:\n                    filename = lib.settings.download_modules(link.strip())\n                    download_filename = '{}.json'.format(link.split('/')[-1].split('.')[0])\n                    download_path = '{}/etc/json'.format(os.getcwd())\n                    current_files = os.listdir(download_path)\n                    if download_filename not in current_files:\n                        full_path = '{}/{}'.format(download_path, download_filename)\n                        lib.jsonize.text_file_to_dict(filename, filename=full_path)\n                        lib.output.info('downloaded into: {}'.format(download_path))\n                    else:\n                        lib.output.warning('file already downloaded, skipping')\n    if opt.exploitList:\n        try:\n            lib.output.info('converting {} to JSON format'.format(opt.exploitList))\n            done = lib.jsonize.text_file_to_dict(opt.exploitList)\n            lib.output.info('converted successfully and saved under {}'.format(done))\n        except IOError as e:\n            lib.output.error(\"caught IOError '{}' check the file path and try again\".format(str(e)))\n        sys.exit(0)\n    search_save_mode = None\n    if opt.overwriteHosts:\n        open(lib.settings.HOST_FILE, mode='w').close()\n        search_save_mode = 'a'\n    elif opt.appendHosts:\n        search_save_mode = 'a'\n    if opt.searchCensys:\n        lib.output.info(single_search_msg.format('Censys'))\n        api_searches[2](keys['censys'][1], keys['censys'][0], opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n    if opt.searchZoomeye:\n        lib.output.info(single_search_msg.format('Zoomeye'))\n        api_searches[0](opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n    if opt.searchShodan:\n        lib.output.info(single_search_msg.format('Shodan'))\n        api_searches[1](keys['shodan'][0], opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n    if opt.searchAll:\n        lib.output.info('searching all search engines in order')\n        api_searches[0](opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n        api_searches[1](keys['shodan'][0], opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n        api_searches[2](keys['censys'][1], keys['censys'][0], opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n    if opt.startExploit:\n        hosts = open(lib.settings.HOST_FILE).readlines()\n        if opt.whitelist:\n            hosts = lib.exploitation.exploiter.whitelist_wash(hosts, whitelist_file=opt.whitelist)\n        if opt.checkIfHoneypot != 1000:\n            check_pot = True\n        else:\n            check_pot = False\n        lib.exploitation.exploiter.AutoSploitExploiter(opt.msfConfig, loaded_modules, hosts, ruby_exec=opt.rubyExecutableNeeded, msf_path=opt.pathToFramework, dryRun=opt.dryRun, shodan_token=keys['shodan'][0], check_honey=check_pot, compare_honey=opt.checkIfHoneypot).start_exploit()",
        "mutated": [
            "@staticmethod\ndef single_run_args(opt, keys, loaded_modules):\n    if False:\n        i = 10\n    '\\n        run the arguments provided\\n        '\n    api_searches = (api_calls.zoomeye.ZoomEyeAPIHook, api_calls.shodan.ShodanAPIHook, api_calls.censys.CensysAPIHook)\n    headers = lib.settings.configure_requests(proxy=opt.proxyConfig, agent=opt.personalAgent, rand_agent=opt.randomAgent)\n    single_search_msg = 'using {} as the search engine'\n    if opt.displayEthics:\n        ethics_file = '{}/etc/text_files/ethics.lst'.format(os.getcwd())\n        with open(ethics_file) as ethics:\n            ethic = random.choice(ethics.readlines()).strip()\n            lib.settings.close('You should take this ethical lesson into consideration before you continue with the use of this tool:\\n\\n{}\\n'.format(ethic))\n    if opt.downloadModules is not None:\n        import re\n        modules_to_download = opt.downloadModules\n        links_list = '{}/etc/text_files/links.txt'.format(lib.settings.CUR_DIR)\n        possibles = open(links_list).readlines()\n        for module in modules_to_download:\n            searcher = re.compile('{}'.format(module))\n            for link in possibles:\n                if searcher.search(link) is not None:\n                    filename = lib.settings.download_modules(link.strip())\n                    download_filename = '{}.json'.format(link.split('/')[-1].split('.')[0])\n                    download_path = '{}/etc/json'.format(os.getcwd())\n                    current_files = os.listdir(download_path)\n                    if download_filename not in current_files:\n                        full_path = '{}/{}'.format(download_path, download_filename)\n                        lib.jsonize.text_file_to_dict(filename, filename=full_path)\n                        lib.output.info('downloaded into: {}'.format(download_path))\n                    else:\n                        lib.output.warning('file already downloaded, skipping')\n    if opt.exploitList:\n        try:\n            lib.output.info('converting {} to JSON format'.format(opt.exploitList))\n            done = lib.jsonize.text_file_to_dict(opt.exploitList)\n            lib.output.info('converted successfully and saved under {}'.format(done))\n        except IOError as e:\n            lib.output.error(\"caught IOError '{}' check the file path and try again\".format(str(e)))\n        sys.exit(0)\n    search_save_mode = None\n    if opt.overwriteHosts:\n        open(lib.settings.HOST_FILE, mode='w').close()\n        search_save_mode = 'a'\n    elif opt.appendHosts:\n        search_save_mode = 'a'\n    if opt.searchCensys:\n        lib.output.info(single_search_msg.format('Censys'))\n        api_searches[2](keys['censys'][1], keys['censys'][0], opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n    if opt.searchZoomeye:\n        lib.output.info(single_search_msg.format('Zoomeye'))\n        api_searches[0](opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n    if opt.searchShodan:\n        lib.output.info(single_search_msg.format('Shodan'))\n        api_searches[1](keys['shodan'][0], opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n    if opt.searchAll:\n        lib.output.info('searching all search engines in order')\n        api_searches[0](opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n        api_searches[1](keys['shodan'][0], opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n        api_searches[2](keys['censys'][1], keys['censys'][0], opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n    if opt.startExploit:\n        hosts = open(lib.settings.HOST_FILE).readlines()\n        if opt.whitelist:\n            hosts = lib.exploitation.exploiter.whitelist_wash(hosts, whitelist_file=opt.whitelist)\n        if opt.checkIfHoneypot != 1000:\n            check_pot = True\n        else:\n            check_pot = False\n        lib.exploitation.exploiter.AutoSploitExploiter(opt.msfConfig, loaded_modules, hosts, ruby_exec=opt.rubyExecutableNeeded, msf_path=opt.pathToFramework, dryRun=opt.dryRun, shodan_token=keys['shodan'][0], check_honey=check_pot, compare_honey=opt.checkIfHoneypot).start_exploit()",
            "@staticmethod\ndef single_run_args(opt, keys, loaded_modules):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        run the arguments provided\\n        '\n    api_searches = (api_calls.zoomeye.ZoomEyeAPIHook, api_calls.shodan.ShodanAPIHook, api_calls.censys.CensysAPIHook)\n    headers = lib.settings.configure_requests(proxy=opt.proxyConfig, agent=opt.personalAgent, rand_agent=opt.randomAgent)\n    single_search_msg = 'using {} as the search engine'\n    if opt.displayEthics:\n        ethics_file = '{}/etc/text_files/ethics.lst'.format(os.getcwd())\n        with open(ethics_file) as ethics:\n            ethic = random.choice(ethics.readlines()).strip()\n            lib.settings.close('You should take this ethical lesson into consideration before you continue with the use of this tool:\\n\\n{}\\n'.format(ethic))\n    if opt.downloadModules is not None:\n        import re\n        modules_to_download = opt.downloadModules\n        links_list = '{}/etc/text_files/links.txt'.format(lib.settings.CUR_DIR)\n        possibles = open(links_list).readlines()\n        for module in modules_to_download:\n            searcher = re.compile('{}'.format(module))\n            for link in possibles:\n                if searcher.search(link) is not None:\n                    filename = lib.settings.download_modules(link.strip())\n                    download_filename = '{}.json'.format(link.split('/')[-1].split('.')[0])\n                    download_path = '{}/etc/json'.format(os.getcwd())\n                    current_files = os.listdir(download_path)\n                    if download_filename not in current_files:\n                        full_path = '{}/{}'.format(download_path, download_filename)\n                        lib.jsonize.text_file_to_dict(filename, filename=full_path)\n                        lib.output.info('downloaded into: {}'.format(download_path))\n                    else:\n                        lib.output.warning('file already downloaded, skipping')\n    if opt.exploitList:\n        try:\n            lib.output.info('converting {} to JSON format'.format(opt.exploitList))\n            done = lib.jsonize.text_file_to_dict(opt.exploitList)\n            lib.output.info('converted successfully and saved under {}'.format(done))\n        except IOError as e:\n            lib.output.error(\"caught IOError '{}' check the file path and try again\".format(str(e)))\n        sys.exit(0)\n    search_save_mode = None\n    if opt.overwriteHosts:\n        open(lib.settings.HOST_FILE, mode='w').close()\n        search_save_mode = 'a'\n    elif opt.appendHosts:\n        search_save_mode = 'a'\n    if opt.searchCensys:\n        lib.output.info(single_search_msg.format('Censys'))\n        api_searches[2](keys['censys'][1], keys['censys'][0], opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n    if opt.searchZoomeye:\n        lib.output.info(single_search_msg.format('Zoomeye'))\n        api_searches[0](opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n    if opt.searchShodan:\n        lib.output.info(single_search_msg.format('Shodan'))\n        api_searches[1](keys['shodan'][0], opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n    if opt.searchAll:\n        lib.output.info('searching all search engines in order')\n        api_searches[0](opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n        api_searches[1](keys['shodan'][0], opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n        api_searches[2](keys['censys'][1], keys['censys'][0], opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n    if opt.startExploit:\n        hosts = open(lib.settings.HOST_FILE).readlines()\n        if opt.whitelist:\n            hosts = lib.exploitation.exploiter.whitelist_wash(hosts, whitelist_file=opt.whitelist)\n        if opt.checkIfHoneypot != 1000:\n            check_pot = True\n        else:\n            check_pot = False\n        lib.exploitation.exploiter.AutoSploitExploiter(opt.msfConfig, loaded_modules, hosts, ruby_exec=opt.rubyExecutableNeeded, msf_path=opt.pathToFramework, dryRun=opt.dryRun, shodan_token=keys['shodan'][0], check_honey=check_pot, compare_honey=opt.checkIfHoneypot).start_exploit()",
            "@staticmethod\ndef single_run_args(opt, keys, loaded_modules):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        run the arguments provided\\n        '\n    api_searches = (api_calls.zoomeye.ZoomEyeAPIHook, api_calls.shodan.ShodanAPIHook, api_calls.censys.CensysAPIHook)\n    headers = lib.settings.configure_requests(proxy=opt.proxyConfig, agent=opt.personalAgent, rand_agent=opt.randomAgent)\n    single_search_msg = 'using {} as the search engine'\n    if opt.displayEthics:\n        ethics_file = '{}/etc/text_files/ethics.lst'.format(os.getcwd())\n        with open(ethics_file) as ethics:\n            ethic = random.choice(ethics.readlines()).strip()\n            lib.settings.close('You should take this ethical lesson into consideration before you continue with the use of this tool:\\n\\n{}\\n'.format(ethic))\n    if opt.downloadModules is not None:\n        import re\n        modules_to_download = opt.downloadModules\n        links_list = '{}/etc/text_files/links.txt'.format(lib.settings.CUR_DIR)\n        possibles = open(links_list).readlines()\n        for module in modules_to_download:\n            searcher = re.compile('{}'.format(module))\n            for link in possibles:\n                if searcher.search(link) is not None:\n                    filename = lib.settings.download_modules(link.strip())\n                    download_filename = '{}.json'.format(link.split('/')[-1].split('.')[0])\n                    download_path = '{}/etc/json'.format(os.getcwd())\n                    current_files = os.listdir(download_path)\n                    if download_filename not in current_files:\n                        full_path = '{}/{}'.format(download_path, download_filename)\n                        lib.jsonize.text_file_to_dict(filename, filename=full_path)\n                        lib.output.info('downloaded into: {}'.format(download_path))\n                    else:\n                        lib.output.warning('file already downloaded, skipping')\n    if opt.exploitList:\n        try:\n            lib.output.info('converting {} to JSON format'.format(opt.exploitList))\n            done = lib.jsonize.text_file_to_dict(opt.exploitList)\n            lib.output.info('converted successfully and saved under {}'.format(done))\n        except IOError as e:\n            lib.output.error(\"caught IOError '{}' check the file path and try again\".format(str(e)))\n        sys.exit(0)\n    search_save_mode = None\n    if opt.overwriteHosts:\n        open(lib.settings.HOST_FILE, mode='w').close()\n        search_save_mode = 'a'\n    elif opt.appendHosts:\n        search_save_mode = 'a'\n    if opt.searchCensys:\n        lib.output.info(single_search_msg.format('Censys'))\n        api_searches[2](keys['censys'][1], keys['censys'][0], opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n    if opt.searchZoomeye:\n        lib.output.info(single_search_msg.format('Zoomeye'))\n        api_searches[0](opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n    if opt.searchShodan:\n        lib.output.info(single_search_msg.format('Shodan'))\n        api_searches[1](keys['shodan'][0], opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n    if opt.searchAll:\n        lib.output.info('searching all search engines in order')\n        api_searches[0](opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n        api_searches[1](keys['shodan'][0], opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n        api_searches[2](keys['censys'][1], keys['censys'][0], opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n    if opt.startExploit:\n        hosts = open(lib.settings.HOST_FILE).readlines()\n        if opt.whitelist:\n            hosts = lib.exploitation.exploiter.whitelist_wash(hosts, whitelist_file=opt.whitelist)\n        if opt.checkIfHoneypot != 1000:\n            check_pot = True\n        else:\n            check_pot = False\n        lib.exploitation.exploiter.AutoSploitExploiter(opt.msfConfig, loaded_modules, hosts, ruby_exec=opt.rubyExecutableNeeded, msf_path=opt.pathToFramework, dryRun=opt.dryRun, shodan_token=keys['shodan'][0], check_honey=check_pot, compare_honey=opt.checkIfHoneypot).start_exploit()",
            "@staticmethod\ndef single_run_args(opt, keys, loaded_modules):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        run the arguments provided\\n        '\n    api_searches = (api_calls.zoomeye.ZoomEyeAPIHook, api_calls.shodan.ShodanAPIHook, api_calls.censys.CensysAPIHook)\n    headers = lib.settings.configure_requests(proxy=opt.proxyConfig, agent=opt.personalAgent, rand_agent=opt.randomAgent)\n    single_search_msg = 'using {} as the search engine'\n    if opt.displayEthics:\n        ethics_file = '{}/etc/text_files/ethics.lst'.format(os.getcwd())\n        with open(ethics_file) as ethics:\n            ethic = random.choice(ethics.readlines()).strip()\n            lib.settings.close('You should take this ethical lesson into consideration before you continue with the use of this tool:\\n\\n{}\\n'.format(ethic))\n    if opt.downloadModules is not None:\n        import re\n        modules_to_download = opt.downloadModules\n        links_list = '{}/etc/text_files/links.txt'.format(lib.settings.CUR_DIR)\n        possibles = open(links_list).readlines()\n        for module in modules_to_download:\n            searcher = re.compile('{}'.format(module))\n            for link in possibles:\n                if searcher.search(link) is not None:\n                    filename = lib.settings.download_modules(link.strip())\n                    download_filename = '{}.json'.format(link.split('/')[-1].split('.')[0])\n                    download_path = '{}/etc/json'.format(os.getcwd())\n                    current_files = os.listdir(download_path)\n                    if download_filename not in current_files:\n                        full_path = '{}/{}'.format(download_path, download_filename)\n                        lib.jsonize.text_file_to_dict(filename, filename=full_path)\n                        lib.output.info('downloaded into: {}'.format(download_path))\n                    else:\n                        lib.output.warning('file already downloaded, skipping')\n    if opt.exploitList:\n        try:\n            lib.output.info('converting {} to JSON format'.format(opt.exploitList))\n            done = lib.jsonize.text_file_to_dict(opt.exploitList)\n            lib.output.info('converted successfully and saved under {}'.format(done))\n        except IOError as e:\n            lib.output.error(\"caught IOError '{}' check the file path and try again\".format(str(e)))\n        sys.exit(0)\n    search_save_mode = None\n    if opt.overwriteHosts:\n        open(lib.settings.HOST_FILE, mode='w').close()\n        search_save_mode = 'a'\n    elif opt.appendHosts:\n        search_save_mode = 'a'\n    if opt.searchCensys:\n        lib.output.info(single_search_msg.format('Censys'))\n        api_searches[2](keys['censys'][1], keys['censys'][0], opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n    if opt.searchZoomeye:\n        lib.output.info(single_search_msg.format('Zoomeye'))\n        api_searches[0](opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n    if opt.searchShodan:\n        lib.output.info(single_search_msg.format('Shodan'))\n        api_searches[1](keys['shodan'][0], opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n    if opt.searchAll:\n        lib.output.info('searching all search engines in order')\n        api_searches[0](opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n        api_searches[1](keys['shodan'][0], opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n        api_searches[2](keys['censys'][1], keys['censys'][0], opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n    if opt.startExploit:\n        hosts = open(lib.settings.HOST_FILE).readlines()\n        if opt.whitelist:\n            hosts = lib.exploitation.exploiter.whitelist_wash(hosts, whitelist_file=opt.whitelist)\n        if opt.checkIfHoneypot != 1000:\n            check_pot = True\n        else:\n            check_pot = False\n        lib.exploitation.exploiter.AutoSploitExploiter(opt.msfConfig, loaded_modules, hosts, ruby_exec=opt.rubyExecutableNeeded, msf_path=opt.pathToFramework, dryRun=opt.dryRun, shodan_token=keys['shodan'][0], check_honey=check_pot, compare_honey=opt.checkIfHoneypot).start_exploit()",
            "@staticmethod\ndef single_run_args(opt, keys, loaded_modules):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        run the arguments provided\\n        '\n    api_searches = (api_calls.zoomeye.ZoomEyeAPIHook, api_calls.shodan.ShodanAPIHook, api_calls.censys.CensysAPIHook)\n    headers = lib.settings.configure_requests(proxy=opt.proxyConfig, agent=opt.personalAgent, rand_agent=opt.randomAgent)\n    single_search_msg = 'using {} as the search engine'\n    if opt.displayEthics:\n        ethics_file = '{}/etc/text_files/ethics.lst'.format(os.getcwd())\n        with open(ethics_file) as ethics:\n            ethic = random.choice(ethics.readlines()).strip()\n            lib.settings.close('You should take this ethical lesson into consideration before you continue with the use of this tool:\\n\\n{}\\n'.format(ethic))\n    if opt.downloadModules is not None:\n        import re\n        modules_to_download = opt.downloadModules\n        links_list = '{}/etc/text_files/links.txt'.format(lib.settings.CUR_DIR)\n        possibles = open(links_list).readlines()\n        for module in modules_to_download:\n            searcher = re.compile('{}'.format(module))\n            for link in possibles:\n                if searcher.search(link) is not None:\n                    filename = lib.settings.download_modules(link.strip())\n                    download_filename = '{}.json'.format(link.split('/')[-1].split('.')[0])\n                    download_path = '{}/etc/json'.format(os.getcwd())\n                    current_files = os.listdir(download_path)\n                    if download_filename not in current_files:\n                        full_path = '{}/{}'.format(download_path, download_filename)\n                        lib.jsonize.text_file_to_dict(filename, filename=full_path)\n                        lib.output.info('downloaded into: {}'.format(download_path))\n                    else:\n                        lib.output.warning('file already downloaded, skipping')\n    if opt.exploitList:\n        try:\n            lib.output.info('converting {} to JSON format'.format(opt.exploitList))\n            done = lib.jsonize.text_file_to_dict(opt.exploitList)\n            lib.output.info('converted successfully and saved under {}'.format(done))\n        except IOError as e:\n            lib.output.error(\"caught IOError '{}' check the file path and try again\".format(str(e)))\n        sys.exit(0)\n    search_save_mode = None\n    if opt.overwriteHosts:\n        open(lib.settings.HOST_FILE, mode='w').close()\n        search_save_mode = 'a'\n    elif opt.appendHosts:\n        search_save_mode = 'a'\n    if opt.searchCensys:\n        lib.output.info(single_search_msg.format('Censys'))\n        api_searches[2](keys['censys'][1], keys['censys'][0], opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n    if opt.searchZoomeye:\n        lib.output.info(single_search_msg.format('Zoomeye'))\n        api_searches[0](opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n    if opt.searchShodan:\n        lib.output.info(single_search_msg.format('Shodan'))\n        api_searches[1](keys['shodan'][0], opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n    if opt.searchAll:\n        lib.output.info('searching all search engines in order')\n        api_searches[0](opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n        api_searches[1](keys['shodan'][0], opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n        api_searches[2](keys['censys'][1], keys['censys'][0], opt.searchQuery, proxy=headers[0], agent=headers[1], save_mode=search_save_mode).search()\n    if opt.startExploit:\n        hosts = open(lib.settings.HOST_FILE).readlines()\n        if opt.whitelist:\n            hosts = lib.exploitation.exploiter.whitelist_wash(hosts, whitelist_file=opt.whitelist)\n        if opt.checkIfHoneypot != 1000:\n            check_pot = True\n        else:\n            check_pot = False\n        lib.exploitation.exploiter.AutoSploitExploiter(opt.msfConfig, loaded_modules, hosts, ruby_exec=opt.rubyExecutableNeeded, msf_path=opt.pathToFramework, dryRun=opt.dryRun, shodan_token=keys['shodan'][0], check_honey=check_pot, compare_honey=opt.checkIfHoneypot).start_exploit()"
        ]
    }
]