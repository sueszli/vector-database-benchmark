"""Script for updating tensorflow/tools/compatibility/reorders_v2.py.

To update reorders_v2.py, run:
  bazel run tensorflow/tools/compatibility/update:generate_v2_reorders_map
"""
from absl import app
import tensorflow as tf
from tensorflow import python as tf_python
from tensorflow.python.lib.io import file_io
from tensorflow.python.util import tf_decorator
from tensorflow.python.util import tf_export
from tensorflow.python.util import tf_inspect
from tensorflow.tools.common import public_api
from tensorflow.tools.common import traverse
from tensorflow.tools.compatibility import tf_upgrade_v2
_OUTPUT_FILE_PATH = 'third_party/tensorflow/tools/compatibility/reorders_v2.py'
_FILE_HEADER = '# Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an "AS IS" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n# pylint: disable=line-too-long\n"""List of renames to apply when converting from TF 1.0 to TF 2.0.\n\nTHIS FILE IS AUTOGENERATED: To update, please run:\n  bazel run tensorflow/tools/compatibility/update:generate_v2_reorders_map\nThis file should be updated whenever a function is added to\nself.reordered_function_names in tf_upgrade_v2.py.\n"""\n'

def collect_function_arg_names(function_names, return_all_args_function_names, function_renames):
    if False:
        while True:
            i = 10
    'Determines argument names for reordered function signatures.\n\n  Args:\n    function_names: Functions to collect arguments for.\n    return_all_args_function_names: Functions to collect all argument names for.\n    function_renames: Function renames between v1 and v2.\n\n  Returns:\n    Dictionary mapping function names to a list of argument names. Each argument\n    name list can have leading `None` elements to indicate that some of the\n    function arguments did not change between v1 and v2.\n  '
    function_name_v1_to_attr = {}
    function_name_v2_to_attr = {}

    def visit(unused_path, unused_parent, children):
        if False:
            return 10
        'Visitor that collects arguments for reordered functions.'
        for child in children:
            (_, attr) = tf_decorator.unwrap(child[1])
            api_names_v1 = ['tf.' + name for name in tf_export.get_v1_names(attr)]
            if any((name in function_names for name in api_names_v1)):
                for name in api_names_v1:
                    function_name_v1_to_attr[name] = attr
            api_names_v2 = ['tf.' + name for name in tf_export.get_v2_names(attr)]
            for name in api_names_v2:
                function_name_v2_to_attr[name] = attr
    visitor = public_api.PublicAPIVisitor(visit)
    visitor.do_not_descend_map['tf'].append('contrib')
    visitor.private_map['tf.compat'] = ['v1', 'v2']
    traverse.traverse(tf.compat.v1, visitor)
    traverse.traverse(tf.compat.v1.estimator, visitor)
    traverse.traverse(tf.compat.v2, visitor)
    traverse.traverse(tf.compat.v2.estimator, visitor)

    def get_arguments_list(attr):
        if False:
            return 10
        if tf_inspect.isclass(attr):
            arg_list = tf_inspect.getargspec(getattr(attr, '__init__'))[0]
            return arg_list[1:]
        else:
            return tf_inspect.getargspec(attr)[0]
    function_to_args = {}
    if any((name not in function_name_v1_to_attr for name in function_names)):
        raise ValueError(f"Symbols not found in `tf.compat.v1`: `{'`, `'.join(function_names - function_name_v1_to_attr.keys())}`")
    for (name_v1, attr_v1) in function_name_v1_to_attr.items():
        args_v1 = get_arguments_list(attr_v1)
        if name_v1 in return_all_args_function_names:
            function_to_args[name_v1] = args_v1
            continue
        name_v2 = name_v1
        if name_v1 in function_renames:
            name_v2 = function_renames[name_v1]
            if name_v2.startswith('tf.compat.v1.'):
                raise ValueError(f'Symbol `{name_v1}` is renamed to `{name_v2}`, no need to add keyword argument names, remove from `reordered_function_names`')
        if name_v2 not in function_name_v2_to_attr:
            raise ValueError(f'Symbol `{name_v2}` not found in `tf.compat.v2`')
        args_v2 = get_arguments_list(function_name_v2_to_attr[name_v2])
        if args_v1 == args_v2:
            raise ValueError(f'Symbol `{name_v1}` has no changes in arguments, no need to add keyword argument names, remove from `reordered_function_names`')
        needed_arg_names = []
        same_so_far = True
        for (index, arg) in enumerate(args_v1):
            if same_so_far and index < len(args_v2) and (arg == args_v2[index]):
                needed_arg_names.append(None)
            else:
                same_so_far = False
                needed_arg_names.append(arg)
        function_to_args[name_v1] = needed_arg_names
    return function_to_args

def get_reorder_line(name, arg_list):
    if False:
        return 10
    return "    '%s': %s" % (name, str(arg_list))

def update_reorders_v2(output_file_path):
    if False:
        for i in range(10):
            print('nop')
    'Writes a Python dictionary mapping function name to argument order.\n\n  Args:\n    output_file_path: File path to write output to. Any existing contents\n      would be replaced.\n  '
    spec = tf_upgrade_v2.TFAPIChangeSpec()
    reordered_function_names = spec.reordered_function_names
    need_kwargs_function_names = spec.function_transformers.keys()
    function_renames = spec.symbol_renames
    all_reorders = collect_function_arg_names(reordered_function_names, need_kwargs_function_names, function_renames)
    rename_lines = [get_reorder_line(name, arg_names) for (name, arg_names) in all_reorders.items()]
    renames_file_text = '%sreorders = {\n%s\n}\n' % (_FILE_HEADER, ',\n'.join(sorted(rename_lines)))
    file_io.write_string_to_file(output_file_path, renames_file_text)

def main(unused_argv):
    if False:
        while True:
            i = 10
    update_reorders_v2(_OUTPUT_FILE_PATH)
if __name__ == '__main__':
    app.run(main=main)