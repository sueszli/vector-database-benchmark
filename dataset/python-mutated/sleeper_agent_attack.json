[
    {
        "func_name": "__init__",
        "original": "def __init__(self, classifier: 'CLASSIFIER_NEURALNETWORK_TYPE', percent_poison: float, patch: np.ndarray, indices_target: List[int], epsilon: float=0.1, max_trials: int=8, max_epochs: int=250, learning_rate_schedule: Tuple[List[float], List[int]]=([0.1, 0.01, 0.001, 0.0001], [100, 150, 200, 220]), batch_size: int=128, clip_values: Tuple[float, float]=(0, 1.0), verbose: int=1, patching_strategy: str='random', selection_strategy: str='random', retraining_factor: int=1, model_retrain: bool=False, model_retraining_epoch: int=1, class_source: int=0, class_target: int=1, device_name: str='cpu', retrain_batch_size: int=128):\n    \"\"\"\n        Initialize a Sleeper Agent poisoning attack.\n\n        :param classifier: The proxy classifier used for the attack.\n        :param percent_poison: The ratio of samples to poison among x_train, with range [0,1].\n        :param patch: The patch to be applied as trigger.\n        :param indices_target: The indices of training data having target label.\n        :param epsilon: The L-inf perturbation budget.\n        :param max_trials: The maximum number of restarts to optimize the poison.\n        :param max_epochs: The maximum number of epochs to optimize the train per trial.\n        :param learning_rate_schedule: The learning rate schedule to optimize the poison.\n            A List of (learning rate, epoch) pairs. The learning rate is used\n            if the current epoch is less than the specified epoch.\n        :param batch_size: Batch size.\n        :param clip_values: The range of the input features to the classifier.\n        :param verbose: Show progress bars.\n        :param patching_strategy: Patching strategy to be used for adding trigger, either random/fixed.\n        :param selection_strategy: Selection strategy for getting the indices of\n                             poison examples - either random/maximum gradient norm.\n        :param retraining_factor: The factor for which retraining needs to be applied.\n        :param model_retrain: True, if retraining has to be applied, else False.\n        :param model_retraining_epoch: The epochs for which retraining has to be applied.\n        :param class_source: The source class from which triggers were selected.\n        :param class_target: The target label to which the poisoned model needs to misclassify.\n        :param retrain_batch_size: Batch size required for model retraining.\n        \"\"\"\n    if isinstance(classifier.preprocessing, (StandardisationMeanStdPyTorch, StandardisationMeanStdTensorFlow)):\n        clip_values_normalised = (classifier.clip_values - classifier.preprocessing.mean) / classifier.preprocessing.std\n        clip_values_normalised = (clip_values_normalised[0], clip_values_normalised[1])\n        epsilon_normalised = epsilon * (clip_values_normalised[1] - clip_values_normalised[0])\n        patch_normalised = (patch - classifier.preprocessing.mean) / classifier.preprocessing.std\n    else:\n        raise ValueError('classifier.preprocessing not an instance of pytorch/tensorflow')\n    super().__init__(classifier, percent_poison, epsilon_normalised, max_trials, max_epochs, learning_rate_schedule, batch_size, clip_values_normalised, verbose)\n    self.indices_target = indices_target\n    self.selection_strategy = selection_strategy\n    self.patching_strategy = patching_strategy\n    self.retraining_factor = retraining_factor\n    self.model_retrain = model_retrain\n    self.model_retraining_epoch = model_retraining_epoch\n    self.indices_poison: np.ndarray\n    self.patch = patch_normalised\n    self.class_target = class_target\n    self.class_source = class_source\n    self.device_name = device_name\n    self.initial_epoch = 0\n    self.retrain_batch_size = retrain_batch_size",
        "mutated": [
            "def __init__(self, classifier: 'CLASSIFIER_NEURALNETWORK_TYPE', percent_poison: float, patch: np.ndarray, indices_target: List[int], epsilon: float=0.1, max_trials: int=8, max_epochs: int=250, learning_rate_schedule: Tuple[List[float], List[int]]=([0.1, 0.01, 0.001, 0.0001], [100, 150, 200, 220]), batch_size: int=128, clip_values: Tuple[float, float]=(0, 1.0), verbose: int=1, patching_strategy: str='random', selection_strategy: str='random', retraining_factor: int=1, model_retrain: bool=False, model_retraining_epoch: int=1, class_source: int=0, class_target: int=1, device_name: str='cpu', retrain_batch_size: int=128):\n    if False:\n        i = 10\n    '\\n        Initialize a Sleeper Agent poisoning attack.\\n\\n        :param classifier: The proxy classifier used for the attack.\\n        :param percent_poison: The ratio of samples to poison among x_train, with range [0,1].\\n        :param patch: The patch to be applied as trigger.\\n        :param indices_target: The indices of training data having target label.\\n        :param epsilon: The L-inf perturbation budget.\\n        :param max_trials: The maximum number of restarts to optimize the poison.\\n        :param max_epochs: The maximum number of epochs to optimize the train per trial.\\n        :param learning_rate_schedule: The learning rate schedule to optimize the poison.\\n            A List of (learning rate, epoch) pairs. The learning rate is used\\n            if the current epoch is less than the specified epoch.\\n        :param batch_size: Batch size.\\n        :param clip_values: The range of the input features to the classifier.\\n        :param verbose: Show progress bars.\\n        :param patching_strategy: Patching strategy to be used for adding trigger, either random/fixed.\\n        :param selection_strategy: Selection strategy for getting the indices of\\n                             poison examples - either random/maximum gradient norm.\\n        :param retraining_factor: The factor for which retraining needs to be applied.\\n        :param model_retrain: True, if retraining has to be applied, else False.\\n        :param model_retraining_epoch: The epochs for which retraining has to be applied.\\n        :param class_source: The source class from which triggers were selected.\\n        :param class_target: The target label to which the poisoned model needs to misclassify.\\n        :param retrain_batch_size: Batch size required for model retraining.\\n        '\n    if isinstance(classifier.preprocessing, (StandardisationMeanStdPyTorch, StandardisationMeanStdTensorFlow)):\n        clip_values_normalised = (classifier.clip_values - classifier.preprocessing.mean) / classifier.preprocessing.std\n        clip_values_normalised = (clip_values_normalised[0], clip_values_normalised[1])\n        epsilon_normalised = epsilon * (clip_values_normalised[1] - clip_values_normalised[0])\n        patch_normalised = (patch - classifier.preprocessing.mean) / classifier.preprocessing.std\n    else:\n        raise ValueError('classifier.preprocessing not an instance of pytorch/tensorflow')\n    super().__init__(classifier, percent_poison, epsilon_normalised, max_trials, max_epochs, learning_rate_schedule, batch_size, clip_values_normalised, verbose)\n    self.indices_target = indices_target\n    self.selection_strategy = selection_strategy\n    self.patching_strategy = patching_strategy\n    self.retraining_factor = retraining_factor\n    self.model_retrain = model_retrain\n    self.model_retraining_epoch = model_retraining_epoch\n    self.indices_poison: np.ndarray\n    self.patch = patch_normalised\n    self.class_target = class_target\n    self.class_source = class_source\n    self.device_name = device_name\n    self.initial_epoch = 0\n    self.retrain_batch_size = retrain_batch_size",
            "def __init__(self, classifier: 'CLASSIFIER_NEURALNETWORK_TYPE', percent_poison: float, patch: np.ndarray, indices_target: List[int], epsilon: float=0.1, max_trials: int=8, max_epochs: int=250, learning_rate_schedule: Tuple[List[float], List[int]]=([0.1, 0.01, 0.001, 0.0001], [100, 150, 200, 220]), batch_size: int=128, clip_values: Tuple[float, float]=(0, 1.0), verbose: int=1, patching_strategy: str='random', selection_strategy: str='random', retraining_factor: int=1, model_retrain: bool=False, model_retraining_epoch: int=1, class_source: int=0, class_target: int=1, device_name: str='cpu', retrain_batch_size: int=128):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Initialize a Sleeper Agent poisoning attack.\\n\\n        :param classifier: The proxy classifier used for the attack.\\n        :param percent_poison: The ratio of samples to poison among x_train, with range [0,1].\\n        :param patch: The patch to be applied as trigger.\\n        :param indices_target: The indices of training data having target label.\\n        :param epsilon: The L-inf perturbation budget.\\n        :param max_trials: The maximum number of restarts to optimize the poison.\\n        :param max_epochs: The maximum number of epochs to optimize the train per trial.\\n        :param learning_rate_schedule: The learning rate schedule to optimize the poison.\\n            A List of (learning rate, epoch) pairs. The learning rate is used\\n            if the current epoch is less than the specified epoch.\\n        :param batch_size: Batch size.\\n        :param clip_values: The range of the input features to the classifier.\\n        :param verbose: Show progress bars.\\n        :param patching_strategy: Patching strategy to be used for adding trigger, either random/fixed.\\n        :param selection_strategy: Selection strategy for getting the indices of\\n                             poison examples - either random/maximum gradient norm.\\n        :param retraining_factor: The factor for which retraining needs to be applied.\\n        :param model_retrain: True, if retraining has to be applied, else False.\\n        :param model_retraining_epoch: The epochs for which retraining has to be applied.\\n        :param class_source: The source class from which triggers were selected.\\n        :param class_target: The target label to which the poisoned model needs to misclassify.\\n        :param retrain_batch_size: Batch size required for model retraining.\\n        '\n    if isinstance(classifier.preprocessing, (StandardisationMeanStdPyTorch, StandardisationMeanStdTensorFlow)):\n        clip_values_normalised = (classifier.clip_values - classifier.preprocessing.mean) / classifier.preprocessing.std\n        clip_values_normalised = (clip_values_normalised[0], clip_values_normalised[1])\n        epsilon_normalised = epsilon * (clip_values_normalised[1] - clip_values_normalised[0])\n        patch_normalised = (patch - classifier.preprocessing.mean) / classifier.preprocessing.std\n    else:\n        raise ValueError('classifier.preprocessing not an instance of pytorch/tensorflow')\n    super().__init__(classifier, percent_poison, epsilon_normalised, max_trials, max_epochs, learning_rate_schedule, batch_size, clip_values_normalised, verbose)\n    self.indices_target = indices_target\n    self.selection_strategy = selection_strategy\n    self.patching_strategy = patching_strategy\n    self.retraining_factor = retraining_factor\n    self.model_retrain = model_retrain\n    self.model_retraining_epoch = model_retraining_epoch\n    self.indices_poison: np.ndarray\n    self.patch = patch_normalised\n    self.class_target = class_target\n    self.class_source = class_source\n    self.device_name = device_name\n    self.initial_epoch = 0\n    self.retrain_batch_size = retrain_batch_size",
            "def __init__(self, classifier: 'CLASSIFIER_NEURALNETWORK_TYPE', percent_poison: float, patch: np.ndarray, indices_target: List[int], epsilon: float=0.1, max_trials: int=8, max_epochs: int=250, learning_rate_schedule: Tuple[List[float], List[int]]=([0.1, 0.01, 0.001, 0.0001], [100, 150, 200, 220]), batch_size: int=128, clip_values: Tuple[float, float]=(0, 1.0), verbose: int=1, patching_strategy: str='random', selection_strategy: str='random', retraining_factor: int=1, model_retrain: bool=False, model_retraining_epoch: int=1, class_source: int=0, class_target: int=1, device_name: str='cpu', retrain_batch_size: int=128):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Initialize a Sleeper Agent poisoning attack.\\n\\n        :param classifier: The proxy classifier used for the attack.\\n        :param percent_poison: The ratio of samples to poison among x_train, with range [0,1].\\n        :param patch: The patch to be applied as trigger.\\n        :param indices_target: The indices of training data having target label.\\n        :param epsilon: The L-inf perturbation budget.\\n        :param max_trials: The maximum number of restarts to optimize the poison.\\n        :param max_epochs: The maximum number of epochs to optimize the train per trial.\\n        :param learning_rate_schedule: The learning rate schedule to optimize the poison.\\n            A List of (learning rate, epoch) pairs. The learning rate is used\\n            if the current epoch is less than the specified epoch.\\n        :param batch_size: Batch size.\\n        :param clip_values: The range of the input features to the classifier.\\n        :param verbose: Show progress bars.\\n        :param patching_strategy: Patching strategy to be used for adding trigger, either random/fixed.\\n        :param selection_strategy: Selection strategy for getting the indices of\\n                             poison examples - either random/maximum gradient norm.\\n        :param retraining_factor: The factor for which retraining needs to be applied.\\n        :param model_retrain: True, if retraining has to be applied, else False.\\n        :param model_retraining_epoch: The epochs for which retraining has to be applied.\\n        :param class_source: The source class from which triggers were selected.\\n        :param class_target: The target label to which the poisoned model needs to misclassify.\\n        :param retrain_batch_size: Batch size required for model retraining.\\n        '\n    if isinstance(classifier.preprocessing, (StandardisationMeanStdPyTorch, StandardisationMeanStdTensorFlow)):\n        clip_values_normalised = (classifier.clip_values - classifier.preprocessing.mean) / classifier.preprocessing.std\n        clip_values_normalised = (clip_values_normalised[0], clip_values_normalised[1])\n        epsilon_normalised = epsilon * (clip_values_normalised[1] - clip_values_normalised[0])\n        patch_normalised = (patch - classifier.preprocessing.mean) / classifier.preprocessing.std\n    else:\n        raise ValueError('classifier.preprocessing not an instance of pytorch/tensorflow')\n    super().__init__(classifier, percent_poison, epsilon_normalised, max_trials, max_epochs, learning_rate_schedule, batch_size, clip_values_normalised, verbose)\n    self.indices_target = indices_target\n    self.selection_strategy = selection_strategy\n    self.patching_strategy = patching_strategy\n    self.retraining_factor = retraining_factor\n    self.model_retrain = model_retrain\n    self.model_retraining_epoch = model_retraining_epoch\n    self.indices_poison: np.ndarray\n    self.patch = patch_normalised\n    self.class_target = class_target\n    self.class_source = class_source\n    self.device_name = device_name\n    self.initial_epoch = 0\n    self.retrain_batch_size = retrain_batch_size",
            "def __init__(self, classifier: 'CLASSIFIER_NEURALNETWORK_TYPE', percent_poison: float, patch: np.ndarray, indices_target: List[int], epsilon: float=0.1, max_trials: int=8, max_epochs: int=250, learning_rate_schedule: Tuple[List[float], List[int]]=([0.1, 0.01, 0.001, 0.0001], [100, 150, 200, 220]), batch_size: int=128, clip_values: Tuple[float, float]=(0, 1.0), verbose: int=1, patching_strategy: str='random', selection_strategy: str='random', retraining_factor: int=1, model_retrain: bool=False, model_retraining_epoch: int=1, class_source: int=0, class_target: int=1, device_name: str='cpu', retrain_batch_size: int=128):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Initialize a Sleeper Agent poisoning attack.\\n\\n        :param classifier: The proxy classifier used for the attack.\\n        :param percent_poison: The ratio of samples to poison among x_train, with range [0,1].\\n        :param patch: The patch to be applied as trigger.\\n        :param indices_target: The indices of training data having target label.\\n        :param epsilon: The L-inf perturbation budget.\\n        :param max_trials: The maximum number of restarts to optimize the poison.\\n        :param max_epochs: The maximum number of epochs to optimize the train per trial.\\n        :param learning_rate_schedule: The learning rate schedule to optimize the poison.\\n            A List of (learning rate, epoch) pairs. The learning rate is used\\n            if the current epoch is less than the specified epoch.\\n        :param batch_size: Batch size.\\n        :param clip_values: The range of the input features to the classifier.\\n        :param verbose: Show progress bars.\\n        :param patching_strategy: Patching strategy to be used for adding trigger, either random/fixed.\\n        :param selection_strategy: Selection strategy for getting the indices of\\n                             poison examples - either random/maximum gradient norm.\\n        :param retraining_factor: The factor for which retraining needs to be applied.\\n        :param model_retrain: True, if retraining has to be applied, else False.\\n        :param model_retraining_epoch: The epochs for which retraining has to be applied.\\n        :param class_source: The source class from which triggers were selected.\\n        :param class_target: The target label to which the poisoned model needs to misclassify.\\n        :param retrain_batch_size: Batch size required for model retraining.\\n        '\n    if isinstance(classifier.preprocessing, (StandardisationMeanStdPyTorch, StandardisationMeanStdTensorFlow)):\n        clip_values_normalised = (classifier.clip_values - classifier.preprocessing.mean) / classifier.preprocessing.std\n        clip_values_normalised = (clip_values_normalised[0], clip_values_normalised[1])\n        epsilon_normalised = epsilon * (clip_values_normalised[1] - clip_values_normalised[0])\n        patch_normalised = (patch - classifier.preprocessing.mean) / classifier.preprocessing.std\n    else:\n        raise ValueError('classifier.preprocessing not an instance of pytorch/tensorflow')\n    super().__init__(classifier, percent_poison, epsilon_normalised, max_trials, max_epochs, learning_rate_schedule, batch_size, clip_values_normalised, verbose)\n    self.indices_target = indices_target\n    self.selection_strategy = selection_strategy\n    self.patching_strategy = patching_strategy\n    self.retraining_factor = retraining_factor\n    self.model_retrain = model_retrain\n    self.model_retraining_epoch = model_retraining_epoch\n    self.indices_poison: np.ndarray\n    self.patch = patch_normalised\n    self.class_target = class_target\n    self.class_source = class_source\n    self.device_name = device_name\n    self.initial_epoch = 0\n    self.retrain_batch_size = retrain_batch_size",
            "def __init__(self, classifier: 'CLASSIFIER_NEURALNETWORK_TYPE', percent_poison: float, patch: np.ndarray, indices_target: List[int], epsilon: float=0.1, max_trials: int=8, max_epochs: int=250, learning_rate_schedule: Tuple[List[float], List[int]]=([0.1, 0.01, 0.001, 0.0001], [100, 150, 200, 220]), batch_size: int=128, clip_values: Tuple[float, float]=(0, 1.0), verbose: int=1, patching_strategy: str='random', selection_strategy: str='random', retraining_factor: int=1, model_retrain: bool=False, model_retraining_epoch: int=1, class_source: int=0, class_target: int=1, device_name: str='cpu', retrain_batch_size: int=128):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Initialize a Sleeper Agent poisoning attack.\\n\\n        :param classifier: The proxy classifier used for the attack.\\n        :param percent_poison: The ratio of samples to poison among x_train, with range [0,1].\\n        :param patch: The patch to be applied as trigger.\\n        :param indices_target: The indices of training data having target label.\\n        :param epsilon: The L-inf perturbation budget.\\n        :param max_trials: The maximum number of restarts to optimize the poison.\\n        :param max_epochs: The maximum number of epochs to optimize the train per trial.\\n        :param learning_rate_schedule: The learning rate schedule to optimize the poison.\\n            A List of (learning rate, epoch) pairs. The learning rate is used\\n            if the current epoch is less than the specified epoch.\\n        :param batch_size: Batch size.\\n        :param clip_values: The range of the input features to the classifier.\\n        :param verbose: Show progress bars.\\n        :param patching_strategy: Patching strategy to be used for adding trigger, either random/fixed.\\n        :param selection_strategy: Selection strategy for getting the indices of\\n                             poison examples - either random/maximum gradient norm.\\n        :param retraining_factor: The factor for which retraining needs to be applied.\\n        :param model_retrain: True, if retraining has to be applied, else False.\\n        :param model_retraining_epoch: The epochs for which retraining has to be applied.\\n        :param class_source: The source class from which triggers were selected.\\n        :param class_target: The target label to which the poisoned model needs to misclassify.\\n        :param retrain_batch_size: Batch size required for model retraining.\\n        '\n    if isinstance(classifier.preprocessing, (StandardisationMeanStdPyTorch, StandardisationMeanStdTensorFlow)):\n        clip_values_normalised = (classifier.clip_values - classifier.preprocessing.mean) / classifier.preprocessing.std\n        clip_values_normalised = (clip_values_normalised[0], clip_values_normalised[1])\n        epsilon_normalised = epsilon * (clip_values_normalised[1] - clip_values_normalised[0])\n        patch_normalised = (patch - classifier.preprocessing.mean) / classifier.preprocessing.std\n    else:\n        raise ValueError('classifier.preprocessing not an instance of pytorch/tensorflow')\n    super().__init__(classifier, percent_poison, epsilon_normalised, max_trials, max_epochs, learning_rate_schedule, batch_size, clip_values_normalised, verbose)\n    self.indices_target = indices_target\n    self.selection_strategy = selection_strategy\n    self.patching_strategy = patching_strategy\n    self.retraining_factor = retraining_factor\n    self.model_retrain = model_retrain\n    self.model_retraining_epoch = model_retraining_epoch\n    self.indices_poison: np.ndarray\n    self.patch = patch_normalised\n    self.class_target = class_target\n    self.class_source = class_source\n    self.device_name = device_name\n    self.initial_epoch = 0\n    self.retrain_batch_size = retrain_batch_size"
        ]
    },
    {
        "func_name": "poison",
        "original": "def poison(self, x_trigger: np.ndarray, y_trigger: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, x_test: np.ndarray, y_test: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n        Optimizes a portion of poisoned samples from x_train to make a model classify x_target\n        as y_target by matching the gradients.\n\n        :param x_trigger: A list of samples to use as triggers.\n        :param y_trigger: A list of target classes to classify the triggers into.\n        :param x_train: A list of training data to poison a portion of.\n        :param y_train: A list of labels for x_train.\n        :return: x_train, y_train and indices of poisoned samples.\n                 Here, x_train are the samples selected from target class\n                 in training data.\n        \"\"\"\n    x_train = np.copy(x_train)\n    if isinstance(self.substitute_classifier.preprocessing, (StandardisationMeanStdPyTorch, StandardisationMeanStdTensorFlow)):\n        x_trigger = (x_trigger - self.substitute_classifier.preprocessing.mean) / self.substitute_classifier.preprocessing.std\n        x_train = (x_train - self.substitute_classifier.preprocessing.mean) / self.substitute_classifier.preprocessing.std\n    (x_train_target_samples, y_train_target_samples) = self._select_target_train_samples(x_train, y_train)\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        poisoner = self._poison__pytorch\n        finish_poisoning = self._finish_poison_pytorch\n        initializer = self._initialize_poison_pytorch\n    elif isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        poisoner = self._poison__tensorflow\n        finish_poisoning = self._finish_poison_tensorflow\n        initializer = self._initialize_poison_tensorflow\n    else:\n        raise NotImplementedError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')\n    x_trigger = self._apply_trigger_patch(x_trigger)\n    if len(np.shape(y_trigger)) == 2:\n        classes_target = set(np.argmax(y_trigger, axis=-1))\n    else:\n        classes_target = set(y_trigger)\n    num_poison_samples = int(self.percent_poison * len(x_train_target_samples))\n    best_B = np.finfo(np.float32).max\n    best_x_poisoned: np.ndarray\n    best_indices_poison: np.ndarray\n    if len(np.shape(y_train)) == 2:\n        y_train_classes = np.argmax(y_train_target_samples, axis=-1)\n    else:\n        y_train_classes = y_train_target_samples\n    for _ in trange(self.max_trials):\n        if self.selection_strategy == 'random':\n            self.indices_poison = np.random.permutation(np.where([y in classes_target for y in y_train_classes])[0])[:num_poison_samples]\n        else:\n            self.indices_poison = self._select_poison_indices(self.substitute_classifier, x_train_target_samples, y_train_target_samples, num_poison_samples)\n        x_poison = x_train_target_samples[self.indices_poison]\n        y_poison = y_train_target_samples[self.indices_poison]\n        initializer(x_trigger, y_trigger, x_poison, y_poison)\n        if self.model_retrain:\n            retrain_epochs = self.max_epochs // self.retraining_factor\n            self.max_epochs = retrain_epochs\n            for i in range(self.retraining_factor):\n                if i == self.retraining_factor - 1:\n                    (x_poisoned, B_) = poisoner(x_poison, y_poison)\n                else:\n                    (x_poisoned, B_) = poisoner(x_poison, y_poison)\n                    self._model_retraining(x_poisoned, x_train, y_train, x_test, y_test)\n                self.initial_epoch = self.max_epochs\n                self.max_epochs = self.max_epochs + retrain_epochs\n        else:\n            (x_poisoned, B_) = poisoner(x_poison, y_poison)\n        finish_poisoning()\n        B_ = np.mean(B_)\n        if B_ < best_B:\n            best_B = B_\n            best_x_poisoned = x_poisoned\n            best_indices_poison = self.indices_poison\n    if best_B == np.finfo(np.float32).max:\n        logger.warning('Attack unsuccessful: all loss values were non-finite. Defaulting to final trial.')\n        best_B = B_\n        best_x_poisoned = x_poisoned\n        best_indices_poison = self.indices_poison\n    self.indices_poison = best_indices_poison\n    if isinstance(self.substitute_classifier.preprocessing, (StandardisationMeanStdPyTorch, StandardisationMeanStdTensorFlow)):\n        x_train = x_train * self.substitute_classifier.preprocessing.std + self.substitute_classifier.preprocessing.mean\n        best_x_poisoned = best_x_poisoned * self.substitute_classifier.preprocessing.std + self.substitute_classifier.preprocessing.mean\n    if self.verbose > 0:\n        logger.info('Best B-score: %s', best_B)\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        x_train[self.indices_target[best_indices_poison]] = best_x_poisoned\n    elif isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        x_train[self.indices_target[best_indices_poison]] = best_x_poisoned\n    else:\n        raise NotImplementedError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')\n    return (x_train, y_train)",
        "mutated": [
            "def poison(self, x_trigger: np.ndarray, y_trigger: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, x_test: np.ndarray, y_test: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n    if False:\n        i = 10\n    '\\n        Optimizes a portion of poisoned samples from x_train to make a model classify x_target\\n        as y_target by matching the gradients.\\n\\n        :param x_trigger: A list of samples to use as triggers.\\n        :param y_trigger: A list of target classes to classify the triggers into.\\n        :param x_train: A list of training data to poison a portion of.\\n        :param y_train: A list of labels for x_train.\\n        :return: x_train, y_train and indices of poisoned samples.\\n                 Here, x_train are the samples selected from target class\\n                 in training data.\\n        '\n    x_train = np.copy(x_train)\n    if isinstance(self.substitute_classifier.preprocessing, (StandardisationMeanStdPyTorch, StandardisationMeanStdTensorFlow)):\n        x_trigger = (x_trigger - self.substitute_classifier.preprocessing.mean) / self.substitute_classifier.preprocessing.std\n        x_train = (x_train - self.substitute_classifier.preprocessing.mean) / self.substitute_classifier.preprocessing.std\n    (x_train_target_samples, y_train_target_samples) = self._select_target_train_samples(x_train, y_train)\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        poisoner = self._poison__pytorch\n        finish_poisoning = self._finish_poison_pytorch\n        initializer = self._initialize_poison_pytorch\n    elif isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        poisoner = self._poison__tensorflow\n        finish_poisoning = self._finish_poison_tensorflow\n        initializer = self._initialize_poison_tensorflow\n    else:\n        raise NotImplementedError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')\n    x_trigger = self._apply_trigger_patch(x_trigger)\n    if len(np.shape(y_trigger)) == 2:\n        classes_target = set(np.argmax(y_trigger, axis=-1))\n    else:\n        classes_target = set(y_trigger)\n    num_poison_samples = int(self.percent_poison * len(x_train_target_samples))\n    best_B = np.finfo(np.float32).max\n    best_x_poisoned: np.ndarray\n    best_indices_poison: np.ndarray\n    if len(np.shape(y_train)) == 2:\n        y_train_classes = np.argmax(y_train_target_samples, axis=-1)\n    else:\n        y_train_classes = y_train_target_samples\n    for _ in trange(self.max_trials):\n        if self.selection_strategy == 'random':\n            self.indices_poison = np.random.permutation(np.where([y in classes_target for y in y_train_classes])[0])[:num_poison_samples]\n        else:\n            self.indices_poison = self._select_poison_indices(self.substitute_classifier, x_train_target_samples, y_train_target_samples, num_poison_samples)\n        x_poison = x_train_target_samples[self.indices_poison]\n        y_poison = y_train_target_samples[self.indices_poison]\n        initializer(x_trigger, y_trigger, x_poison, y_poison)\n        if self.model_retrain:\n            retrain_epochs = self.max_epochs // self.retraining_factor\n            self.max_epochs = retrain_epochs\n            for i in range(self.retraining_factor):\n                if i == self.retraining_factor - 1:\n                    (x_poisoned, B_) = poisoner(x_poison, y_poison)\n                else:\n                    (x_poisoned, B_) = poisoner(x_poison, y_poison)\n                    self._model_retraining(x_poisoned, x_train, y_train, x_test, y_test)\n                self.initial_epoch = self.max_epochs\n                self.max_epochs = self.max_epochs + retrain_epochs\n        else:\n            (x_poisoned, B_) = poisoner(x_poison, y_poison)\n        finish_poisoning()\n        B_ = np.mean(B_)\n        if B_ < best_B:\n            best_B = B_\n            best_x_poisoned = x_poisoned\n            best_indices_poison = self.indices_poison\n    if best_B == np.finfo(np.float32).max:\n        logger.warning('Attack unsuccessful: all loss values were non-finite. Defaulting to final trial.')\n        best_B = B_\n        best_x_poisoned = x_poisoned\n        best_indices_poison = self.indices_poison\n    self.indices_poison = best_indices_poison\n    if isinstance(self.substitute_classifier.preprocessing, (StandardisationMeanStdPyTorch, StandardisationMeanStdTensorFlow)):\n        x_train = x_train * self.substitute_classifier.preprocessing.std + self.substitute_classifier.preprocessing.mean\n        best_x_poisoned = best_x_poisoned * self.substitute_classifier.preprocessing.std + self.substitute_classifier.preprocessing.mean\n    if self.verbose > 0:\n        logger.info('Best B-score: %s', best_B)\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        x_train[self.indices_target[best_indices_poison]] = best_x_poisoned\n    elif isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        x_train[self.indices_target[best_indices_poison]] = best_x_poisoned\n    else:\n        raise NotImplementedError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')\n    return (x_train, y_train)",
            "def poison(self, x_trigger: np.ndarray, y_trigger: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, x_test: np.ndarray, y_test: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Optimizes a portion of poisoned samples from x_train to make a model classify x_target\\n        as y_target by matching the gradients.\\n\\n        :param x_trigger: A list of samples to use as triggers.\\n        :param y_trigger: A list of target classes to classify the triggers into.\\n        :param x_train: A list of training data to poison a portion of.\\n        :param y_train: A list of labels for x_train.\\n        :return: x_train, y_train and indices of poisoned samples.\\n                 Here, x_train are the samples selected from target class\\n                 in training data.\\n        '\n    x_train = np.copy(x_train)\n    if isinstance(self.substitute_classifier.preprocessing, (StandardisationMeanStdPyTorch, StandardisationMeanStdTensorFlow)):\n        x_trigger = (x_trigger - self.substitute_classifier.preprocessing.mean) / self.substitute_classifier.preprocessing.std\n        x_train = (x_train - self.substitute_classifier.preprocessing.mean) / self.substitute_classifier.preprocessing.std\n    (x_train_target_samples, y_train_target_samples) = self._select_target_train_samples(x_train, y_train)\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        poisoner = self._poison__pytorch\n        finish_poisoning = self._finish_poison_pytorch\n        initializer = self._initialize_poison_pytorch\n    elif isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        poisoner = self._poison__tensorflow\n        finish_poisoning = self._finish_poison_tensorflow\n        initializer = self._initialize_poison_tensorflow\n    else:\n        raise NotImplementedError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')\n    x_trigger = self._apply_trigger_patch(x_trigger)\n    if len(np.shape(y_trigger)) == 2:\n        classes_target = set(np.argmax(y_trigger, axis=-1))\n    else:\n        classes_target = set(y_trigger)\n    num_poison_samples = int(self.percent_poison * len(x_train_target_samples))\n    best_B = np.finfo(np.float32).max\n    best_x_poisoned: np.ndarray\n    best_indices_poison: np.ndarray\n    if len(np.shape(y_train)) == 2:\n        y_train_classes = np.argmax(y_train_target_samples, axis=-1)\n    else:\n        y_train_classes = y_train_target_samples\n    for _ in trange(self.max_trials):\n        if self.selection_strategy == 'random':\n            self.indices_poison = np.random.permutation(np.where([y in classes_target for y in y_train_classes])[0])[:num_poison_samples]\n        else:\n            self.indices_poison = self._select_poison_indices(self.substitute_classifier, x_train_target_samples, y_train_target_samples, num_poison_samples)\n        x_poison = x_train_target_samples[self.indices_poison]\n        y_poison = y_train_target_samples[self.indices_poison]\n        initializer(x_trigger, y_trigger, x_poison, y_poison)\n        if self.model_retrain:\n            retrain_epochs = self.max_epochs // self.retraining_factor\n            self.max_epochs = retrain_epochs\n            for i in range(self.retraining_factor):\n                if i == self.retraining_factor - 1:\n                    (x_poisoned, B_) = poisoner(x_poison, y_poison)\n                else:\n                    (x_poisoned, B_) = poisoner(x_poison, y_poison)\n                    self._model_retraining(x_poisoned, x_train, y_train, x_test, y_test)\n                self.initial_epoch = self.max_epochs\n                self.max_epochs = self.max_epochs + retrain_epochs\n        else:\n            (x_poisoned, B_) = poisoner(x_poison, y_poison)\n        finish_poisoning()\n        B_ = np.mean(B_)\n        if B_ < best_B:\n            best_B = B_\n            best_x_poisoned = x_poisoned\n            best_indices_poison = self.indices_poison\n    if best_B == np.finfo(np.float32).max:\n        logger.warning('Attack unsuccessful: all loss values were non-finite. Defaulting to final trial.')\n        best_B = B_\n        best_x_poisoned = x_poisoned\n        best_indices_poison = self.indices_poison\n    self.indices_poison = best_indices_poison\n    if isinstance(self.substitute_classifier.preprocessing, (StandardisationMeanStdPyTorch, StandardisationMeanStdTensorFlow)):\n        x_train = x_train * self.substitute_classifier.preprocessing.std + self.substitute_classifier.preprocessing.mean\n        best_x_poisoned = best_x_poisoned * self.substitute_classifier.preprocessing.std + self.substitute_classifier.preprocessing.mean\n    if self.verbose > 0:\n        logger.info('Best B-score: %s', best_B)\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        x_train[self.indices_target[best_indices_poison]] = best_x_poisoned\n    elif isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        x_train[self.indices_target[best_indices_poison]] = best_x_poisoned\n    else:\n        raise NotImplementedError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')\n    return (x_train, y_train)",
            "def poison(self, x_trigger: np.ndarray, y_trigger: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, x_test: np.ndarray, y_test: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Optimizes a portion of poisoned samples from x_train to make a model classify x_target\\n        as y_target by matching the gradients.\\n\\n        :param x_trigger: A list of samples to use as triggers.\\n        :param y_trigger: A list of target classes to classify the triggers into.\\n        :param x_train: A list of training data to poison a portion of.\\n        :param y_train: A list of labels for x_train.\\n        :return: x_train, y_train and indices of poisoned samples.\\n                 Here, x_train are the samples selected from target class\\n                 in training data.\\n        '\n    x_train = np.copy(x_train)\n    if isinstance(self.substitute_classifier.preprocessing, (StandardisationMeanStdPyTorch, StandardisationMeanStdTensorFlow)):\n        x_trigger = (x_trigger - self.substitute_classifier.preprocessing.mean) / self.substitute_classifier.preprocessing.std\n        x_train = (x_train - self.substitute_classifier.preprocessing.mean) / self.substitute_classifier.preprocessing.std\n    (x_train_target_samples, y_train_target_samples) = self._select_target_train_samples(x_train, y_train)\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        poisoner = self._poison__pytorch\n        finish_poisoning = self._finish_poison_pytorch\n        initializer = self._initialize_poison_pytorch\n    elif isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        poisoner = self._poison__tensorflow\n        finish_poisoning = self._finish_poison_tensorflow\n        initializer = self._initialize_poison_tensorflow\n    else:\n        raise NotImplementedError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')\n    x_trigger = self._apply_trigger_patch(x_trigger)\n    if len(np.shape(y_trigger)) == 2:\n        classes_target = set(np.argmax(y_trigger, axis=-1))\n    else:\n        classes_target = set(y_trigger)\n    num_poison_samples = int(self.percent_poison * len(x_train_target_samples))\n    best_B = np.finfo(np.float32).max\n    best_x_poisoned: np.ndarray\n    best_indices_poison: np.ndarray\n    if len(np.shape(y_train)) == 2:\n        y_train_classes = np.argmax(y_train_target_samples, axis=-1)\n    else:\n        y_train_classes = y_train_target_samples\n    for _ in trange(self.max_trials):\n        if self.selection_strategy == 'random':\n            self.indices_poison = np.random.permutation(np.where([y in classes_target for y in y_train_classes])[0])[:num_poison_samples]\n        else:\n            self.indices_poison = self._select_poison_indices(self.substitute_classifier, x_train_target_samples, y_train_target_samples, num_poison_samples)\n        x_poison = x_train_target_samples[self.indices_poison]\n        y_poison = y_train_target_samples[self.indices_poison]\n        initializer(x_trigger, y_trigger, x_poison, y_poison)\n        if self.model_retrain:\n            retrain_epochs = self.max_epochs // self.retraining_factor\n            self.max_epochs = retrain_epochs\n            for i in range(self.retraining_factor):\n                if i == self.retraining_factor - 1:\n                    (x_poisoned, B_) = poisoner(x_poison, y_poison)\n                else:\n                    (x_poisoned, B_) = poisoner(x_poison, y_poison)\n                    self._model_retraining(x_poisoned, x_train, y_train, x_test, y_test)\n                self.initial_epoch = self.max_epochs\n                self.max_epochs = self.max_epochs + retrain_epochs\n        else:\n            (x_poisoned, B_) = poisoner(x_poison, y_poison)\n        finish_poisoning()\n        B_ = np.mean(B_)\n        if B_ < best_B:\n            best_B = B_\n            best_x_poisoned = x_poisoned\n            best_indices_poison = self.indices_poison\n    if best_B == np.finfo(np.float32).max:\n        logger.warning('Attack unsuccessful: all loss values were non-finite. Defaulting to final trial.')\n        best_B = B_\n        best_x_poisoned = x_poisoned\n        best_indices_poison = self.indices_poison\n    self.indices_poison = best_indices_poison\n    if isinstance(self.substitute_classifier.preprocessing, (StandardisationMeanStdPyTorch, StandardisationMeanStdTensorFlow)):\n        x_train = x_train * self.substitute_classifier.preprocessing.std + self.substitute_classifier.preprocessing.mean\n        best_x_poisoned = best_x_poisoned * self.substitute_classifier.preprocessing.std + self.substitute_classifier.preprocessing.mean\n    if self.verbose > 0:\n        logger.info('Best B-score: %s', best_B)\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        x_train[self.indices_target[best_indices_poison]] = best_x_poisoned\n    elif isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        x_train[self.indices_target[best_indices_poison]] = best_x_poisoned\n    else:\n        raise NotImplementedError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')\n    return (x_train, y_train)",
            "def poison(self, x_trigger: np.ndarray, y_trigger: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, x_test: np.ndarray, y_test: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Optimizes a portion of poisoned samples from x_train to make a model classify x_target\\n        as y_target by matching the gradients.\\n\\n        :param x_trigger: A list of samples to use as triggers.\\n        :param y_trigger: A list of target classes to classify the triggers into.\\n        :param x_train: A list of training data to poison a portion of.\\n        :param y_train: A list of labels for x_train.\\n        :return: x_train, y_train and indices of poisoned samples.\\n                 Here, x_train are the samples selected from target class\\n                 in training data.\\n        '\n    x_train = np.copy(x_train)\n    if isinstance(self.substitute_classifier.preprocessing, (StandardisationMeanStdPyTorch, StandardisationMeanStdTensorFlow)):\n        x_trigger = (x_trigger - self.substitute_classifier.preprocessing.mean) / self.substitute_classifier.preprocessing.std\n        x_train = (x_train - self.substitute_classifier.preprocessing.mean) / self.substitute_classifier.preprocessing.std\n    (x_train_target_samples, y_train_target_samples) = self._select_target_train_samples(x_train, y_train)\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        poisoner = self._poison__pytorch\n        finish_poisoning = self._finish_poison_pytorch\n        initializer = self._initialize_poison_pytorch\n    elif isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        poisoner = self._poison__tensorflow\n        finish_poisoning = self._finish_poison_tensorflow\n        initializer = self._initialize_poison_tensorflow\n    else:\n        raise NotImplementedError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')\n    x_trigger = self._apply_trigger_patch(x_trigger)\n    if len(np.shape(y_trigger)) == 2:\n        classes_target = set(np.argmax(y_trigger, axis=-1))\n    else:\n        classes_target = set(y_trigger)\n    num_poison_samples = int(self.percent_poison * len(x_train_target_samples))\n    best_B = np.finfo(np.float32).max\n    best_x_poisoned: np.ndarray\n    best_indices_poison: np.ndarray\n    if len(np.shape(y_train)) == 2:\n        y_train_classes = np.argmax(y_train_target_samples, axis=-1)\n    else:\n        y_train_classes = y_train_target_samples\n    for _ in trange(self.max_trials):\n        if self.selection_strategy == 'random':\n            self.indices_poison = np.random.permutation(np.where([y in classes_target for y in y_train_classes])[0])[:num_poison_samples]\n        else:\n            self.indices_poison = self._select_poison_indices(self.substitute_classifier, x_train_target_samples, y_train_target_samples, num_poison_samples)\n        x_poison = x_train_target_samples[self.indices_poison]\n        y_poison = y_train_target_samples[self.indices_poison]\n        initializer(x_trigger, y_trigger, x_poison, y_poison)\n        if self.model_retrain:\n            retrain_epochs = self.max_epochs // self.retraining_factor\n            self.max_epochs = retrain_epochs\n            for i in range(self.retraining_factor):\n                if i == self.retraining_factor - 1:\n                    (x_poisoned, B_) = poisoner(x_poison, y_poison)\n                else:\n                    (x_poisoned, B_) = poisoner(x_poison, y_poison)\n                    self._model_retraining(x_poisoned, x_train, y_train, x_test, y_test)\n                self.initial_epoch = self.max_epochs\n                self.max_epochs = self.max_epochs + retrain_epochs\n        else:\n            (x_poisoned, B_) = poisoner(x_poison, y_poison)\n        finish_poisoning()\n        B_ = np.mean(B_)\n        if B_ < best_B:\n            best_B = B_\n            best_x_poisoned = x_poisoned\n            best_indices_poison = self.indices_poison\n    if best_B == np.finfo(np.float32).max:\n        logger.warning('Attack unsuccessful: all loss values were non-finite. Defaulting to final trial.')\n        best_B = B_\n        best_x_poisoned = x_poisoned\n        best_indices_poison = self.indices_poison\n    self.indices_poison = best_indices_poison\n    if isinstance(self.substitute_classifier.preprocessing, (StandardisationMeanStdPyTorch, StandardisationMeanStdTensorFlow)):\n        x_train = x_train * self.substitute_classifier.preprocessing.std + self.substitute_classifier.preprocessing.mean\n        best_x_poisoned = best_x_poisoned * self.substitute_classifier.preprocessing.std + self.substitute_classifier.preprocessing.mean\n    if self.verbose > 0:\n        logger.info('Best B-score: %s', best_B)\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        x_train[self.indices_target[best_indices_poison]] = best_x_poisoned\n    elif isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        x_train[self.indices_target[best_indices_poison]] = best_x_poisoned\n    else:\n        raise NotImplementedError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')\n    return (x_train, y_train)",
            "def poison(self, x_trigger: np.ndarray, y_trigger: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, x_test: np.ndarray, y_test: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Optimizes a portion of poisoned samples from x_train to make a model classify x_target\\n        as y_target by matching the gradients.\\n\\n        :param x_trigger: A list of samples to use as triggers.\\n        :param y_trigger: A list of target classes to classify the triggers into.\\n        :param x_train: A list of training data to poison a portion of.\\n        :param y_train: A list of labels for x_train.\\n        :return: x_train, y_train and indices of poisoned samples.\\n                 Here, x_train are the samples selected from target class\\n                 in training data.\\n        '\n    x_train = np.copy(x_train)\n    if isinstance(self.substitute_classifier.preprocessing, (StandardisationMeanStdPyTorch, StandardisationMeanStdTensorFlow)):\n        x_trigger = (x_trigger - self.substitute_classifier.preprocessing.mean) / self.substitute_classifier.preprocessing.std\n        x_train = (x_train - self.substitute_classifier.preprocessing.mean) / self.substitute_classifier.preprocessing.std\n    (x_train_target_samples, y_train_target_samples) = self._select_target_train_samples(x_train, y_train)\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        poisoner = self._poison__pytorch\n        finish_poisoning = self._finish_poison_pytorch\n        initializer = self._initialize_poison_pytorch\n    elif isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        poisoner = self._poison__tensorflow\n        finish_poisoning = self._finish_poison_tensorflow\n        initializer = self._initialize_poison_tensorflow\n    else:\n        raise NotImplementedError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')\n    x_trigger = self._apply_trigger_patch(x_trigger)\n    if len(np.shape(y_trigger)) == 2:\n        classes_target = set(np.argmax(y_trigger, axis=-1))\n    else:\n        classes_target = set(y_trigger)\n    num_poison_samples = int(self.percent_poison * len(x_train_target_samples))\n    best_B = np.finfo(np.float32).max\n    best_x_poisoned: np.ndarray\n    best_indices_poison: np.ndarray\n    if len(np.shape(y_train)) == 2:\n        y_train_classes = np.argmax(y_train_target_samples, axis=-1)\n    else:\n        y_train_classes = y_train_target_samples\n    for _ in trange(self.max_trials):\n        if self.selection_strategy == 'random':\n            self.indices_poison = np.random.permutation(np.where([y in classes_target for y in y_train_classes])[0])[:num_poison_samples]\n        else:\n            self.indices_poison = self._select_poison_indices(self.substitute_classifier, x_train_target_samples, y_train_target_samples, num_poison_samples)\n        x_poison = x_train_target_samples[self.indices_poison]\n        y_poison = y_train_target_samples[self.indices_poison]\n        initializer(x_trigger, y_trigger, x_poison, y_poison)\n        if self.model_retrain:\n            retrain_epochs = self.max_epochs // self.retraining_factor\n            self.max_epochs = retrain_epochs\n            for i in range(self.retraining_factor):\n                if i == self.retraining_factor - 1:\n                    (x_poisoned, B_) = poisoner(x_poison, y_poison)\n                else:\n                    (x_poisoned, B_) = poisoner(x_poison, y_poison)\n                    self._model_retraining(x_poisoned, x_train, y_train, x_test, y_test)\n                self.initial_epoch = self.max_epochs\n                self.max_epochs = self.max_epochs + retrain_epochs\n        else:\n            (x_poisoned, B_) = poisoner(x_poison, y_poison)\n        finish_poisoning()\n        B_ = np.mean(B_)\n        if B_ < best_B:\n            best_B = B_\n            best_x_poisoned = x_poisoned\n            best_indices_poison = self.indices_poison\n    if best_B == np.finfo(np.float32).max:\n        logger.warning('Attack unsuccessful: all loss values were non-finite. Defaulting to final trial.')\n        best_B = B_\n        best_x_poisoned = x_poisoned\n        best_indices_poison = self.indices_poison\n    self.indices_poison = best_indices_poison\n    if isinstance(self.substitute_classifier.preprocessing, (StandardisationMeanStdPyTorch, StandardisationMeanStdTensorFlow)):\n        x_train = x_train * self.substitute_classifier.preprocessing.std + self.substitute_classifier.preprocessing.mean\n        best_x_poisoned = best_x_poisoned * self.substitute_classifier.preprocessing.std + self.substitute_classifier.preprocessing.mean\n    if self.verbose > 0:\n        logger.info('Best B-score: %s', best_B)\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        x_train[self.indices_target[best_indices_poison]] = best_x_poisoned\n    elif isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        x_train[self.indices_target[best_indices_poison]] = best_x_poisoned\n    else:\n        raise NotImplementedError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')\n    return (x_train, y_train)"
        ]
    },
    {
        "func_name": "_select_target_train_samples",
        "original": "def _select_target_train_samples(self, x_train: np.ndarray, y_train: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n        Used for selecting train samples from target class\n        :param x_train: clean training data\n        :param y_train: labels fo clean training data\n        :return x_train_target_samples, y_train_target_samples:\n        samples and labels selected from target class in train data\n        \"\"\"\n    x_train_samples = np.copy(x_train)\n    index_target = np.where(y_train.argmax(axis=1) == self.class_target)[0]\n    x_train_target_samples = x_train_samples[index_target]\n    y_train_target_samples = y_train[index_target]\n    return (x_train_target_samples, y_train_target_samples)",
        "mutated": [
            "def _select_target_train_samples(self, x_train: np.ndarray, y_train: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n    if False:\n        i = 10\n    '\\n        Used for selecting train samples from target class\\n        :param x_train: clean training data\\n        :param y_train: labels fo clean training data\\n        :return x_train_target_samples, y_train_target_samples:\\n        samples and labels selected from target class in train data\\n        '\n    x_train_samples = np.copy(x_train)\n    index_target = np.where(y_train.argmax(axis=1) == self.class_target)[0]\n    x_train_target_samples = x_train_samples[index_target]\n    y_train_target_samples = y_train[index_target]\n    return (x_train_target_samples, y_train_target_samples)",
            "def _select_target_train_samples(self, x_train: np.ndarray, y_train: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Used for selecting train samples from target class\\n        :param x_train: clean training data\\n        :param y_train: labels fo clean training data\\n        :return x_train_target_samples, y_train_target_samples:\\n        samples and labels selected from target class in train data\\n        '\n    x_train_samples = np.copy(x_train)\n    index_target = np.where(y_train.argmax(axis=1) == self.class_target)[0]\n    x_train_target_samples = x_train_samples[index_target]\n    y_train_target_samples = y_train[index_target]\n    return (x_train_target_samples, y_train_target_samples)",
            "def _select_target_train_samples(self, x_train: np.ndarray, y_train: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Used for selecting train samples from target class\\n        :param x_train: clean training data\\n        :param y_train: labels fo clean training data\\n        :return x_train_target_samples, y_train_target_samples:\\n        samples and labels selected from target class in train data\\n        '\n    x_train_samples = np.copy(x_train)\n    index_target = np.where(y_train.argmax(axis=1) == self.class_target)[0]\n    x_train_target_samples = x_train_samples[index_target]\n    y_train_target_samples = y_train[index_target]\n    return (x_train_target_samples, y_train_target_samples)",
            "def _select_target_train_samples(self, x_train: np.ndarray, y_train: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Used for selecting train samples from target class\\n        :param x_train: clean training data\\n        :param y_train: labels fo clean training data\\n        :return x_train_target_samples, y_train_target_samples:\\n        samples and labels selected from target class in train data\\n        '\n    x_train_samples = np.copy(x_train)\n    index_target = np.where(y_train.argmax(axis=1) == self.class_target)[0]\n    x_train_target_samples = x_train_samples[index_target]\n    y_train_target_samples = y_train[index_target]\n    return (x_train_target_samples, y_train_target_samples)",
            "def _select_target_train_samples(self, x_train: np.ndarray, y_train: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Used for selecting train samples from target class\\n        :param x_train: clean training data\\n        :param y_train: labels fo clean training data\\n        :return x_train_target_samples, y_train_target_samples:\\n        samples and labels selected from target class in train data\\n        '\n    x_train_samples = np.copy(x_train)\n    index_target = np.where(y_train.argmax(axis=1) == self.class_target)[0]\n    x_train_target_samples = x_train_samples[index_target]\n    y_train_target_samples = y_train[index_target]\n    return (x_train_target_samples, y_train_target_samples)"
        ]
    },
    {
        "func_name": "get_poison_indices",
        "original": "def get_poison_indices(self) -> np.ndarray:\n    \"\"\"\n        :return: indices of best poison index\n        \"\"\"\n    return self.indices_poison",
        "mutated": [
            "def get_poison_indices(self) -> np.ndarray:\n    if False:\n        i = 10\n    '\\n        :return: indices of best poison index\\n        '\n    return self.indices_poison",
            "def get_poison_indices(self) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :return: indices of best poison index\\n        '\n    return self.indices_poison",
            "def get_poison_indices(self) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :return: indices of best poison index\\n        '\n    return self.indices_poison",
            "def get_poison_indices(self) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :return: indices of best poison index\\n        '\n    return self.indices_poison",
            "def get_poison_indices(self) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :return: indices of best poison index\\n        '\n    return self.indices_poison"
        ]
    },
    {
        "func_name": "_model_retraining",
        "original": "def _model_retraining(self, poisoned_samples: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, x_test: np.ndarray, y_test: np.ndarray):\n    \"\"\"\n        Applies retraining to substitute model\n\n        :param poisoned_samples: poisoned array.\n        :param x_train: clean training data.\n        :param y_train: labels for training data.\n        :param x_test: clean test data.\n        :param y_test: labels for test data.\n        \"\"\"\n    if isinstance(self.substitute_classifier.preprocessing, (StandardisationMeanStdPyTorch, StandardisationMeanStdTensorFlow)):\n        x_train_un = np.copy(x_train)\n        x_train_un[self.indices_target[self.indices_poison]] = poisoned_samples\n        x_train_un = x_train_un * self.substitute_classifier.preprocessing.std\n        x_train_un += self.substitute_classifier.preprocessing.mean\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        check_train = self.substitute_classifier.model.training\n        model_pt = self._create_model(x_train_un, y_train, x_test, y_test, batch_size=self.retrain_batch_size, epochs=self.model_retraining_epoch)\n        self.substitute_classifier = model_pt\n        self.substitute_classifier.model.training = check_train\n    elif isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        check_train = self.substitute_classifier.model.trainable\n        model_tf = self._create_model(x_train_un, y_train, x_test, y_test, batch_size=self.retrain_batch_size, epochs=self.model_retraining_epoch)\n        self.substitute_classifier = model_tf\n        self.substitute_classifier.model.trainable = check_train\n    else:\n        raise NotImplementedError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')",
        "mutated": [
            "def _model_retraining(self, poisoned_samples: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, x_test: np.ndarray, y_test: np.ndarray):\n    if False:\n        i = 10\n    '\\n        Applies retraining to substitute model\\n\\n        :param poisoned_samples: poisoned array.\\n        :param x_train: clean training data.\\n        :param y_train: labels for training data.\\n        :param x_test: clean test data.\\n        :param y_test: labels for test data.\\n        '\n    if isinstance(self.substitute_classifier.preprocessing, (StandardisationMeanStdPyTorch, StandardisationMeanStdTensorFlow)):\n        x_train_un = np.copy(x_train)\n        x_train_un[self.indices_target[self.indices_poison]] = poisoned_samples\n        x_train_un = x_train_un * self.substitute_classifier.preprocessing.std\n        x_train_un += self.substitute_classifier.preprocessing.mean\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        check_train = self.substitute_classifier.model.training\n        model_pt = self._create_model(x_train_un, y_train, x_test, y_test, batch_size=self.retrain_batch_size, epochs=self.model_retraining_epoch)\n        self.substitute_classifier = model_pt\n        self.substitute_classifier.model.training = check_train\n    elif isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        check_train = self.substitute_classifier.model.trainable\n        model_tf = self._create_model(x_train_un, y_train, x_test, y_test, batch_size=self.retrain_batch_size, epochs=self.model_retraining_epoch)\n        self.substitute_classifier = model_tf\n        self.substitute_classifier.model.trainable = check_train\n    else:\n        raise NotImplementedError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')",
            "def _model_retraining(self, poisoned_samples: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, x_test: np.ndarray, y_test: np.ndarray):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Applies retraining to substitute model\\n\\n        :param poisoned_samples: poisoned array.\\n        :param x_train: clean training data.\\n        :param y_train: labels for training data.\\n        :param x_test: clean test data.\\n        :param y_test: labels for test data.\\n        '\n    if isinstance(self.substitute_classifier.preprocessing, (StandardisationMeanStdPyTorch, StandardisationMeanStdTensorFlow)):\n        x_train_un = np.copy(x_train)\n        x_train_un[self.indices_target[self.indices_poison]] = poisoned_samples\n        x_train_un = x_train_un * self.substitute_classifier.preprocessing.std\n        x_train_un += self.substitute_classifier.preprocessing.mean\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        check_train = self.substitute_classifier.model.training\n        model_pt = self._create_model(x_train_un, y_train, x_test, y_test, batch_size=self.retrain_batch_size, epochs=self.model_retraining_epoch)\n        self.substitute_classifier = model_pt\n        self.substitute_classifier.model.training = check_train\n    elif isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        check_train = self.substitute_classifier.model.trainable\n        model_tf = self._create_model(x_train_un, y_train, x_test, y_test, batch_size=self.retrain_batch_size, epochs=self.model_retraining_epoch)\n        self.substitute_classifier = model_tf\n        self.substitute_classifier.model.trainable = check_train\n    else:\n        raise NotImplementedError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')",
            "def _model_retraining(self, poisoned_samples: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, x_test: np.ndarray, y_test: np.ndarray):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Applies retraining to substitute model\\n\\n        :param poisoned_samples: poisoned array.\\n        :param x_train: clean training data.\\n        :param y_train: labels for training data.\\n        :param x_test: clean test data.\\n        :param y_test: labels for test data.\\n        '\n    if isinstance(self.substitute_classifier.preprocessing, (StandardisationMeanStdPyTorch, StandardisationMeanStdTensorFlow)):\n        x_train_un = np.copy(x_train)\n        x_train_un[self.indices_target[self.indices_poison]] = poisoned_samples\n        x_train_un = x_train_un * self.substitute_classifier.preprocessing.std\n        x_train_un += self.substitute_classifier.preprocessing.mean\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        check_train = self.substitute_classifier.model.training\n        model_pt = self._create_model(x_train_un, y_train, x_test, y_test, batch_size=self.retrain_batch_size, epochs=self.model_retraining_epoch)\n        self.substitute_classifier = model_pt\n        self.substitute_classifier.model.training = check_train\n    elif isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        check_train = self.substitute_classifier.model.trainable\n        model_tf = self._create_model(x_train_un, y_train, x_test, y_test, batch_size=self.retrain_batch_size, epochs=self.model_retraining_epoch)\n        self.substitute_classifier = model_tf\n        self.substitute_classifier.model.trainable = check_train\n    else:\n        raise NotImplementedError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')",
            "def _model_retraining(self, poisoned_samples: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, x_test: np.ndarray, y_test: np.ndarray):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Applies retraining to substitute model\\n\\n        :param poisoned_samples: poisoned array.\\n        :param x_train: clean training data.\\n        :param y_train: labels for training data.\\n        :param x_test: clean test data.\\n        :param y_test: labels for test data.\\n        '\n    if isinstance(self.substitute_classifier.preprocessing, (StandardisationMeanStdPyTorch, StandardisationMeanStdTensorFlow)):\n        x_train_un = np.copy(x_train)\n        x_train_un[self.indices_target[self.indices_poison]] = poisoned_samples\n        x_train_un = x_train_un * self.substitute_classifier.preprocessing.std\n        x_train_un += self.substitute_classifier.preprocessing.mean\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        check_train = self.substitute_classifier.model.training\n        model_pt = self._create_model(x_train_un, y_train, x_test, y_test, batch_size=self.retrain_batch_size, epochs=self.model_retraining_epoch)\n        self.substitute_classifier = model_pt\n        self.substitute_classifier.model.training = check_train\n    elif isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        check_train = self.substitute_classifier.model.trainable\n        model_tf = self._create_model(x_train_un, y_train, x_test, y_test, batch_size=self.retrain_batch_size, epochs=self.model_retraining_epoch)\n        self.substitute_classifier = model_tf\n        self.substitute_classifier.model.trainable = check_train\n    else:\n        raise NotImplementedError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')",
            "def _model_retraining(self, poisoned_samples: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, x_test: np.ndarray, y_test: np.ndarray):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Applies retraining to substitute model\\n\\n        :param poisoned_samples: poisoned array.\\n        :param x_train: clean training data.\\n        :param y_train: labels for training data.\\n        :param x_test: clean test data.\\n        :param y_test: labels for test data.\\n        '\n    if isinstance(self.substitute_classifier.preprocessing, (StandardisationMeanStdPyTorch, StandardisationMeanStdTensorFlow)):\n        x_train_un = np.copy(x_train)\n        x_train_un[self.indices_target[self.indices_poison]] = poisoned_samples\n        x_train_un = x_train_un * self.substitute_classifier.preprocessing.std\n        x_train_un += self.substitute_classifier.preprocessing.mean\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        check_train = self.substitute_classifier.model.training\n        model_pt = self._create_model(x_train_un, y_train, x_test, y_test, batch_size=self.retrain_batch_size, epochs=self.model_retraining_epoch)\n        self.substitute_classifier = model_pt\n        self.substitute_classifier.model.training = check_train\n    elif isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        check_train = self.substitute_classifier.model.trainable\n        model_tf = self._create_model(x_train_un, y_train, x_test, y_test, batch_size=self.retrain_batch_size, epochs=self.model_retraining_epoch)\n        self.substitute_classifier = model_tf\n        self.substitute_classifier.model.trainable = check_train\n    else:\n        raise NotImplementedError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')"
        ]
    },
    {
        "func_name": "_create_model",
        "original": "def _create_model(self, x_train: np.ndarray, y_train: np.ndarray, x_test: np.ndarray, y_test: np.ndarray, batch_size: int=128, epochs: int=80) -> Union['TensorFlowV2Classifier', 'PyTorchClassifier']:\n    \"\"\"\n        Creates a new model.\n\n        :param x_train: Samples of train data.\n        :param y_train: Labels of train data.\n        :param x_test: Samples of test data.\n        :param y_test: Labels of test data.\n        :param num_classes: Number of classes of labels in train data.\n        :param batch_size: The size of batch used for training.\n        :param epochs: The number of epochs for which training need to be applied.\n        :return model, loss_fn, optimizer - trained model, loss function used to train the model and optimizer used.\n        \"\"\"\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        model_pt = self.substitute_classifier.clone_for_refitting()\n        for layer in model_pt.model.children():\n            if hasattr(layer, 'reset_parameters'):\n                layer.reset_parameters()\n        model_pt.fit(x_train, y_train, batch_size=batch_size, nb_epochs=epochs, verbose=1)\n        predictions = model_pt.predict(x_test)\n        accuracy = np.sum(np.argmax(predictions, axis=1) == np.argmax(y_test, axis=1)) / len(y_test)\n        logger.info('Accuracy of retrained model : %s', accuracy * 100.0)\n        return model_pt\n    if isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        self.substitute_classifier.model.trainable = True\n        model_tf = self.substitute_classifier.clone_for_refitting()\n        model_tf.fit(x_train, y_train, batch_size=batch_size, nb_epochs=epochs, verbose=0)\n        predictions = model_tf.predict(x_test)\n        accuracy = np.sum(np.argmax(predictions, axis=1) == np.argmax(y_test, axis=1)) / len(y_test)\n        logger.info('Accuracy of retrained model : %s', accuracy * 100.0)\n        return model_tf\n    raise ValueError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')",
        "mutated": [
            "def _create_model(self, x_train: np.ndarray, y_train: np.ndarray, x_test: np.ndarray, y_test: np.ndarray, batch_size: int=128, epochs: int=80) -> Union['TensorFlowV2Classifier', 'PyTorchClassifier']:\n    if False:\n        i = 10\n    '\\n        Creates a new model.\\n\\n        :param x_train: Samples of train data.\\n        :param y_train: Labels of train data.\\n        :param x_test: Samples of test data.\\n        :param y_test: Labels of test data.\\n        :param num_classes: Number of classes of labels in train data.\\n        :param batch_size: The size of batch used for training.\\n        :param epochs: The number of epochs for which training need to be applied.\\n        :return model, loss_fn, optimizer - trained model, loss function used to train the model and optimizer used.\\n        '\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        model_pt = self.substitute_classifier.clone_for_refitting()\n        for layer in model_pt.model.children():\n            if hasattr(layer, 'reset_parameters'):\n                layer.reset_parameters()\n        model_pt.fit(x_train, y_train, batch_size=batch_size, nb_epochs=epochs, verbose=1)\n        predictions = model_pt.predict(x_test)\n        accuracy = np.sum(np.argmax(predictions, axis=1) == np.argmax(y_test, axis=1)) / len(y_test)\n        logger.info('Accuracy of retrained model : %s', accuracy * 100.0)\n        return model_pt\n    if isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        self.substitute_classifier.model.trainable = True\n        model_tf = self.substitute_classifier.clone_for_refitting()\n        model_tf.fit(x_train, y_train, batch_size=batch_size, nb_epochs=epochs, verbose=0)\n        predictions = model_tf.predict(x_test)\n        accuracy = np.sum(np.argmax(predictions, axis=1) == np.argmax(y_test, axis=1)) / len(y_test)\n        logger.info('Accuracy of retrained model : %s', accuracy * 100.0)\n        return model_tf\n    raise ValueError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')",
            "def _create_model(self, x_train: np.ndarray, y_train: np.ndarray, x_test: np.ndarray, y_test: np.ndarray, batch_size: int=128, epochs: int=80) -> Union['TensorFlowV2Classifier', 'PyTorchClassifier']:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Creates a new model.\\n\\n        :param x_train: Samples of train data.\\n        :param y_train: Labels of train data.\\n        :param x_test: Samples of test data.\\n        :param y_test: Labels of test data.\\n        :param num_classes: Number of classes of labels in train data.\\n        :param batch_size: The size of batch used for training.\\n        :param epochs: The number of epochs for which training need to be applied.\\n        :return model, loss_fn, optimizer - trained model, loss function used to train the model and optimizer used.\\n        '\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        model_pt = self.substitute_classifier.clone_for_refitting()\n        for layer in model_pt.model.children():\n            if hasattr(layer, 'reset_parameters'):\n                layer.reset_parameters()\n        model_pt.fit(x_train, y_train, batch_size=batch_size, nb_epochs=epochs, verbose=1)\n        predictions = model_pt.predict(x_test)\n        accuracy = np.sum(np.argmax(predictions, axis=1) == np.argmax(y_test, axis=1)) / len(y_test)\n        logger.info('Accuracy of retrained model : %s', accuracy * 100.0)\n        return model_pt\n    if isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        self.substitute_classifier.model.trainable = True\n        model_tf = self.substitute_classifier.clone_for_refitting()\n        model_tf.fit(x_train, y_train, batch_size=batch_size, nb_epochs=epochs, verbose=0)\n        predictions = model_tf.predict(x_test)\n        accuracy = np.sum(np.argmax(predictions, axis=1) == np.argmax(y_test, axis=1)) / len(y_test)\n        logger.info('Accuracy of retrained model : %s', accuracy * 100.0)\n        return model_tf\n    raise ValueError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')",
            "def _create_model(self, x_train: np.ndarray, y_train: np.ndarray, x_test: np.ndarray, y_test: np.ndarray, batch_size: int=128, epochs: int=80) -> Union['TensorFlowV2Classifier', 'PyTorchClassifier']:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Creates a new model.\\n\\n        :param x_train: Samples of train data.\\n        :param y_train: Labels of train data.\\n        :param x_test: Samples of test data.\\n        :param y_test: Labels of test data.\\n        :param num_classes: Number of classes of labels in train data.\\n        :param batch_size: The size of batch used for training.\\n        :param epochs: The number of epochs for which training need to be applied.\\n        :return model, loss_fn, optimizer - trained model, loss function used to train the model and optimizer used.\\n        '\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        model_pt = self.substitute_classifier.clone_for_refitting()\n        for layer in model_pt.model.children():\n            if hasattr(layer, 'reset_parameters'):\n                layer.reset_parameters()\n        model_pt.fit(x_train, y_train, batch_size=batch_size, nb_epochs=epochs, verbose=1)\n        predictions = model_pt.predict(x_test)\n        accuracy = np.sum(np.argmax(predictions, axis=1) == np.argmax(y_test, axis=1)) / len(y_test)\n        logger.info('Accuracy of retrained model : %s', accuracy * 100.0)\n        return model_pt\n    if isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        self.substitute_classifier.model.trainable = True\n        model_tf = self.substitute_classifier.clone_for_refitting()\n        model_tf.fit(x_train, y_train, batch_size=batch_size, nb_epochs=epochs, verbose=0)\n        predictions = model_tf.predict(x_test)\n        accuracy = np.sum(np.argmax(predictions, axis=1) == np.argmax(y_test, axis=1)) / len(y_test)\n        logger.info('Accuracy of retrained model : %s', accuracy * 100.0)\n        return model_tf\n    raise ValueError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')",
            "def _create_model(self, x_train: np.ndarray, y_train: np.ndarray, x_test: np.ndarray, y_test: np.ndarray, batch_size: int=128, epochs: int=80) -> Union['TensorFlowV2Classifier', 'PyTorchClassifier']:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Creates a new model.\\n\\n        :param x_train: Samples of train data.\\n        :param y_train: Labels of train data.\\n        :param x_test: Samples of test data.\\n        :param y_test: Labels of test data.\\n        :param num_classes: Number of classes of labels in train data.\\n        :param batch_size: The size of batch used for training.\\n        :param epochs: The number of epochs for which training need to be applied.\\n        :return model, loss_fn, optimizer - trained model, loss function used to train the model and optimizer used.\\n        '\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        model_pt = self.substitute_classifier.clone_for_refitting()\n        for layer in model_pt.model.children():\n            if hasattr(layer, 'reset_parameters'):\n                layer.reset_parameters()\n        model_pt.fit(x_train, y_train, batch_size=batch_size, nb_epochs=epochs, verbose=1)\n        predictions = model_pt.predict(x_test)\n        accuracy = np.sum(np.argmax(predictions, axis=1) == np.argmax(y_test, axis=1)) / len(y_test)\n        logger.info('Accuracy of retrained model : %s', accuracy * 100.0)\n        return model_pt\n    if isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        self.substitute_classifier.model.trainable = True\n        model_tf = self.substitute_classifier.clone_for_refitting()\n        model_tf.fit(x_train, y_train, batch_size=batch_size, nb_epochs=epochs, verbose=0)\n        predictions = model_tf.predict(x_test)\n        accuracy = np.sum(np.argmax(predictions, axis=1) == np.argmax(y_test, axis=1)) / len(y_test)\n        logger.info('Accuracy of retrained model : %s', accuracy * 100.0)\n        return model_tf\n    raise ValueError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')",
            "def _create_model(self, x_train: np.ndarray, y_train: np.ndarray, x_test: np.ndarray, y_test: np.ndarray, batch_size: int=128, epochs: int=80) -> Union['TensorFlowV2Classifier', 'PyTorchClassifier']:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Creates a new model.\\n\\n        :param x_train: Samples of train data.\\n        :param y_train: Labels of train data.\\n        :param x_test: Samples of test data.\\n        :param y_test: Labels of test data.\\n        :param num_classes: Number of classes of labels in train data.\\n        :param batch_size: The size of batch used for training.\\n        :param epochs: The number of epochs for which training need to be applied.\\n        :return model, loss_fn, optimizer - trained model, loss function used to train the model and optimizer used.\\n        '\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        model_pt = self.substitute_classifier.clone_for_refitting()\n        for layer in model_pt.model.children():\n            if hasattr(layer, 'reset_parameters'):\n                layer.reset_parameters()\n        model_pt.fit(x_train, y_train, batch_size=batch_size, nb_epochs=epochs, verbose=1)\n        predictions = model_pt.predict(x_test)\n        accuracy = np.sum(np.argmax(predictions, axis=1) == np.argmax(y_test, axis=1)) / len(y_test)\n        logger.info('Accuracy of retrained model : %s', accuracy * 100.0)\n        return model_pt\n    if isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        self.substitute_classifier.model.trainable = True\n        model_tf = self.substitute_classifier.clone_for_refitting()\n        model_tf.fit(x_train, y_train, batch_size=batch_size, nb_epochs=epochs, verbose=0)\n        predictions = model_tf.predict(x_test)\n        accuracy = np.sum(np.argmax(predictions, axis=1) == np.argmax(y_test, axis=1)) / len(y_test)\n        logger.info('Accuracy of retrained model : %s', accuracy * 100.0)\n        return model_tf\n    raise ValueError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')"
        ]
    },
    {
        "func_name": "_select_poison_indices",
        "original": "def _select_poison_indices(self, classifier: 'CLASSIFIER_NEURALNETWORK_TYPE', x_samples: np.ndarray, y_samples: np.ndarray, num_poison: int) -> np.ndarray:\n    \"\"\"\n        Select indices of poisoned samples\n\n        :classifier: Substitute Model.\n        :x_samples: Samples of poison. [x_samples are normalised]\n        :y_samples: Labels of samples of poison.\n        :num_poison: Number of poisoned samples to be selected out of all x_samples.\n        :return indices - Indices of samples to be poisoned.\n        \"\"\"\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        import torch\n        device = torch.device(self.device_name)\n        grad_norms = []\n        criterion = torch.nn.CrossEntropyLoss()\n        model = classifier.model\n        model.eval()\n        differentiable_params = [p for p in classifier.model.parameters() if p.requires_grad]\n        for (x, y) in zip(x_samples, y_samples):\n            image = torch.tensor(x, dtype=torch.float32).float().to(device)\n            label = torch.tensor(y).to(device)\n            loss_pt = criterion(model(image.unsqueeze(0)), label.unsqueeze(0))\n            gradients = list(torch.autograd.grad(loss_pt, differentiable_params, only_inputs=True))\n            grad_norm = torch.tensor(0, dtype=torch.float32).to(device)\n            for grad in gradients:\n                grad_norm += grad.detach().pow(2).sum()\n            grad_norms.append(grad_norm.sqrt())\n    elif isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        import tensorflow as tf\n        model_trainable = classifier.model.trainable\n        classifier.model.trainable = False\n        grad_norms = []\n        for i in range(len(x_samples) - 1):\n            image = tf.constant(x_samples[i:i + 1])\n            label = tf.constant(y_samples[i:i + 1])\n            with tf.GradientTape() as t:\n                t.watch(classifier.model.weights)\n                output = classifier.model(image, training=False)\n                loss_tf = classifier.loss_object(label, output)\n                gradients = list(t.gradient(loss_tf, classifier.model.weights))\n                gradients = [w for w in gradients if w is not None]\n                grad_norm = tf.constant(0, dtype=tf.float32)\n                for grad in gradients:\n                    grad_norm += tf.reduce_sum(tf.math.square(grad))\n                grad_norms.append(tf.math.sqrt(grad_norm))\n        classifier.model.trainable = model_trainable\n    else:\n        raise NotImplementedError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')\n    indices = sorted(range(len(grad_norms)), key=lambda k: grad_norms[k])\n    indices = indices[-num_poison:]\n    return np.array(indices)",
        "mutated": [
            "def _select_poison_indices(self, classifier: 'CLASSIFIER_NEURALNETWORK_TYPE', x_samples: np.ndarray, y_samples: np.ndarray, num_poison: int) -> np.ndarray:\n    if False:\n        i = 10\n    '\\n        Select indices of poisoned samples\\n\\n        :classifier: Substitute Model.\\n        :x_samples: Samples of poison. [x_samples are normalised]\\n        :y_samples: Labels of samples of poison.\\n        :num_poison: Number of poisoned samples to be selected out of all x_samples.\\n        :return indices - Indices of samples to be poisoned.\\n        '\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        import torch\n        device = torch.device(self.device_name)\n        grad_norms = []\n        criterion = torch.nn.CrossEntropyLoss()\n        model = classifier.model\n        model.eval()\n        differentiable_params = [p for p in classifier.model.parameters() if p.requires_grad]\n        for (x, y) in zip(x_samples, y_samples):\n            image = torch.tensor(x, dtype=torch.float32).float().to(device)\n            label = torch.tensor(y).to(device)\n            loss_pt = criterion(model(image.unsqueeze(0)), label.unsqueeze(0))\n            gradients = list(torch.autograd.grad(loss_pt, differentiable_params, only_inputs=True))\n            grad_norm = torch.tensor(0, dtype=torch.float32).to(device)\n            for grad in gradients:\n                grad_norm += grad.detach().pow(2).sum()\n            grad_norms.append(grad_norm.sqrt())\n    elif isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        import tensorflow as tf\n        model_trainable = classifier.model.trainable\n        classifier.model.trainable = False\n        grad_norms = []\n        for i in range(len(x_samples) - 1):\n            image = tf.constant(x_samples[i:i + 1])\n            label = tf.constant(y_samples[i:i + 1])\n            with tf.GradientTape() as t:\n                t.watch(classifier.model.weights)\n                output = classifier.model(image, training=False)\n                loss_tf = classifier.loss_object(label, output)\n                gradients = list(t.gradient(loss_tf, classifier.model.weights))\n                gradients = [w for w in gradients if w is not None]\n                grad_norm = tf.constant(0, dtype=tf.float32)\n                for grad in gradients:\n                    grad_norm += tf.reduce_sum(tf.math.square(grad))\n                grad_norms.append(tf.math.sqrt(grad_norm))\n        classifier.model.trainable = model_trainable\n    else:\n        raise NotImplementedError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')\n    indices = sorted(range(len(grad_norms)), key=lambda k: grad_norms[k])\n    indices = indices[-num_poison:]\n    return np.array(indices)",
            "def _select_poison_indices(self, classifier: 'CLASSIFIER_NEURALNETWORK_TYPE', x_samples: np.ndarray, y_samples: np.ndarray, num_poison: int) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Select indices of poisoned samples\\n\\n        :classifier: Substitute Model.\\n        :x_samples: Samples of poison. [x_samples are normalised]\\n        :y_samples: Labels of samples of poison.\\n        :num_poison: Number of poisoned samples to be selected out of all x_samples.\\n        :return indices - Indices of samples to be poisoned.\\n        '\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        import torch\n        device = torch.device(self.device_name)\n        grad_norms = []\n        criterion = torch.nn.CrossEntropyLoss()\n        model = classifier.model\n        model.eval()\n        differentiable_params = [p for p in classifier.model.parameters() if p.requires_grad]\n        for (x, y) in zip(x_samples, y_samples):\n            image = torch.tensor(x, dtype=torch.float32).float().to(device)\n            label = torch.tensor(y).to(device)\n            loss_pt = criterion(model(image.unsqueeze(0)), label.unsqueeze(0))\n            gradients = list(torch.autograd.grad(loss_pt, differentiable_params, only_inputs=True))\n            grad_norm = torch.tensor(0, dtype=torch.float32).to(device)\n            for grad in gradients:\n                grad_norm += grad.detach().pow(2).sum()\n            grad_norms.append(grad_norm.sqrt())\n    elif isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        import tensorflow as tf\n        model_trainable = classifier.model.trainable\n        classifier.model.trainable = False\n        grad_norms = []\n        for i in range(len(x_samples) - 1):\n            image = tf.constant(x_samples[i:i + 1])\n            label = tf.constant(y_samples[i:i + 1])\n            with tf.GradientTape() as t:\n                t.watch(classifier.model.weights)\n                output = classifier.model(image, training=False)\n                loss_tf = classifier.loss_object(label, output)\n                gradients = list(t.gradient(loss_tf, classifier.model.weights))\n                gradients = [w for w in gradients if w is not None]\n                grad_norm = tf.constant(0, dtype=tf.float32)\n                for grad in gradients:\n                    grad_norm += tf.reduce_sum(tf.math.square(grad))\n                grad_norms.append(tf.math.sqrt(grad_norm))\n        classifier.model.trainable = model_trainable\n    else:\n        raise NotImplementedError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')\n    indices = sorted(range(len(grad_norms)), key=lambda k: grad_norms[k])\n    indices = indices[-num_poison:]\n    return np.array(indices)",
            "def _select_poison_indices(self, classifier: 'CLASSIFIER_NEURALNETWORK_TYPE', x_samples: np.ndarray, y_samples: np.ndarray, num_poison: int) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Select indices of poisoned samples\\n\\n        :classifier: Substitute Model.\\n        :x_samples: Samples of poison. [x_samples are normalised]\\n        :y_samples: Labels of samples of poison.\\n        :num_poison: Number of poisoned samples to be selected out of all x_samples.\\n        :return indices - Indices of samples to be poisoned.\\n        '\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        import torch\n        device = torch.device(self.device_name)\n        grad_norms = []\n        criterion = torch.nn.CrossEntropyLoss()\n        model = classifier.model\n        model.eval()\n        differentiable_params = [p for p in classifier.model.parameters() if p.requires_grad]\n        for (x, y) in zip(x_samples, y_samples):\n            image = torch.tensor(x, dtype=torch.float32).float().to(device)\n            label = torch.tensor(y).to(device)\n            loss_pt = criterion(model(image.unsqueeze(0)), label.unsqueeze(0))\n            gradients = list(torch.autograd.grad(loss_pt, differentiable_params, only_inputs=True))\n            grad_norm = torch.tensor(0, dtype=torch.float32).to(device)\n            for grad in gradients:\n                grad_norm += grad.detach().pow(2).sum()\n            grad_norms.append(grad_norm.sqrt())\n    elif isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        import tensorflow as tf\n        model_trainable = classifier.model.trainable\n        classifier.model.trainable = False\n        grad_norms = []\n        for i in range(len(x_samples) - 1):\n            image = tf.constant(x_samples[i:i + 1])\n            label = tf.constant(y_samples[i:i + 1])\n            with tf.GradientTape() as t:\n                t.watch(classifier.model.weights)\n                output = classifier.model(image, training=False)\n                loss_tf = classifier.loss_object(label, output)\n                gradients = list(t.gradient(loss_tf, classifier.model.weights))\n                gradients = [w for w in gradients if w is not None]\n                grad_norm = tf.constant(0, dtype=tf.float32)\n                for grad in gradients:\n                    grad_norm += tf.reduce_sum(tf.math.square(grad))\n                grad_norms.append(tf.math.sqrt(grad_norm))\n        classifier.model.trainable = model_trainable\n    else:\n        raise NotImplementedError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')\n    indices = sorted(range(len(grad_norms)), key=lambda k: grad_norms[k])\n    indices = indices[-num_poison:]\n    return np.array(indices)",
            "def _select_poison_indices(self, classifier: 'CLASSIFIER_NEURALNETWORK_TYPE', x_samples: np.ndarray, y_samples: np.ndarray, num_poison: int) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Select indices of poisoned samples\\n\\n        :classifier: Substitute Model.\\n        :x_samples: Samples of poison. [x_samples are normalised]\\n        :y_samples: Labels of samples of poison.\\n        :num_poison: Number of poisoned samples to be selected out of all x_samples.\\n        :return indices - Indices of samples to be poisoned.\\n        '\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        import torch\n        device = torch.device(self.device_name)\n        grad_norms = []\n        criterion = torch.nn.CrossEntropyLoss()\n        model = classifier.model\n        model.eval()\n        differentiable_params = [p for p in classifier.model.parameters() if p.requires_grad]\n        for (x, y) in zip(x_samples, y_samples):\n            image = torch.tensor(x, dtype=torch.float32).float().to(device)\n            label = torch.tensor(y).to(device)\n            loss_pt = criterion(model(image.unsqueeze(0)), label.unsqueeze(0))\n            gradients = list(torch.autograd.grad(loss_pt, differentiable_params, only_inputs=True))\n            grad_norm = torch.tensor(0, dtype=torch.float32).to(device)\n            for grad in gradients:\n                grad_norm += grad.detach().pow(2).sum()\n            grad_norms.append(grad_norm.sqrt())\n    elif isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        import tensorflow as tf\n        model_trainable = classifier.model.trainable\n        classifier.model.trainable = False\n        grad_norms = []\n        for i in range(len(x_samples) - 1):\n            image = tf.constant(x_samples[i:i + 1])\n            label = tf.constant(y_samples[i:i + 1])\n            with tf.GradientTape() as t:\n                t.watch(classifier.model.weights)\n                output = classifier.model(image, training=False)\n                loss_tf = classifier.loss_object(label, output)\n                gradients = list(t.gradient(loss_tf, classifier.model.weights))\n                gradients = [w for w in gradients if w is not None]\n                grad_norm = tf.constant(0, dtype=tf.float32)\n                for grad in gradients:\n                    grad_norm += tf.reduce_sum(tf.math.square(grad))\n                grad_norms.append(tf.math.sqrt(grad_norm))\n        classifier.model.trainable = model_trainable\n    else:\n        raise NotImplementedError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')\n    indices = sorted(range(len(grad_norms)), key=lambda k: grad_norms[k])\n    indices = indices[-num_poison:]\n    return np.array(indices)",
            "def _select_poison_indices(self, classifier: 'CLASSIFIER_NEURALNETWORK_TYPE', x_samples: np.ndarray, y_samples: np.ndarray, num_poison: int) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Select indices of poisoned samples\\n\\n        :classifier: Substitute Model.\\n        :x_samples: Samples of poison. [x_samples are normalised]\\n        :y_samples: Labels of samples of poison.\\n        :num_poison: Number of poisoned samples to be selected out of all x_samples.\\n        :return indices - Indices of samples to be poisoned.\\n        '\n    if isinstance(self.substitute_classifier, PyTorchClassifier):\n        import torch\n        device = torch.device(self.device_name)\n        grad_norms = []\n        criterion = torch.nn.CrossEntropyLoss()\n        model = classifier.model\n        model.eval()\n        differentiable_params = [p for p in classifier.model.parameters() if p.requires_grad]\n        for (x, y) in zip(x_samples, y_samples):\n            image = torch.tensor(x, dtype=torch.float32).float().to(device)\n            label = torch.tensor(y).to(device)\n            loss_pt = criterion(model(image.unsqueeze(0)), label.unsqueeze(0))\n            gradients = list(torch.autograd.grad(loss_pt, differentiable_params, only_inputs=True))\n            grad_norm = torch.tensor(0, dtype=torch.float32).to(device)\n            for grad in gradients:\n                grad_norm += grad.detach().pow(2).sum()\n            grad_norms.append(grad_norm.sqrt())\n    elif isinstance(self.substitute_classifier, TensorFlowV2Classifier):\n        import tensorflow as tf\n        model_trainable = classifier.model.trainable\n        classifier.model.trainable = False\n        grad_norms = []\n        for i in range(len(x_samples) - 1):\n            image = tf.constant(x_samples[i:i + 1])\n            label = tf.constant(y_samples[i:i + 1])\n            with tf.GradientTape() as t:\n                t.watch(classifier.model.weights)\n                output = classifier.model(image, training=False)\n                loss_tf = classifier.loss_object(label, output)\n                gradients = list(t.gradient(loss_tf, classifier.model.weights))\n                gradients = [w for w in gradients if w is not None]\n                grad_norm = tf.constant(0, dtype=tf.float32)\n                for grad in gradients:\n                    grad_norm += tf.reduce_sum(tf.math.square(grad))\n                grad_norms.append(tf.math.sqrt(grad_norm))\n        classifier.model.trainable = model_trainable\n    else:\n        raise NotImplementedError('SleeperAgentAttack is currently implemented only for PyTorch and TensorFlowV2.')\n    indices = sorted(range(len(grad_norms)), key=lambda k: grad_norms[k])\n    indices = indices[-num_poison:]\n    return np.array(indices)"
        ]
    },
    {
        "func_name": "_apply_trigger_patch",
        "original": "def _apply_trigger_patch(self, x_trigger: np.ndarray) -> np.ndarray:\n    \"\"\"\n        Select indices of poisoned samples\n\n        :x_trigger: Samples to be used for trigger.\n        :return tensor with applied trigger patches.\n        \"\"\"\n    patch_size = self.patch.shape[1]\n    if self.patching_strategy == 'fixed':\n        if self.estimator.channels_first:\n            x_trigger[:, :, -patch_size:, -patch_size:] = self.patch\n        else:\n            x_trigger[:, -patch_size:, -patch_size:, :] = self.patch\n    else:\n        for x in x_trigger:\n            if self.estimator.channels_first:\n                x_cord = random.randrange(0, x.shape[1] - self.patch.shape[1] + 1)\n                y_cord = random.randrange(0, x.shape[2] - self.patch.shape[2] + 1)\n                x[:, x_cord:x_cord + patch_size, y_cord:y_cord + patch_size] = self.patch\n            else:\n                x_cord = random.randrange(0, x.shape[0] - self.patch.shape[0] + 1)\n                y_cord = random.randrange(0, x.shape[1] - self.patch.shape[1] + 1)\n                x[x_cord:x_cord + patch_size, y_cord:y_cord + patch_size, :] = self.patch\n    return x_trigger",
        "mutated": [
            "def _apply_trigger_patch(self, x_trigger: np.ndarray) -> np.ndarray:\n    if False:\n        i = 10\n    '\\n        Select indices of poisoned samples\\n\\n        :x_trigger: Samples to be used for trigger.\\n        :return tensor with applied trigger patches.\\n        '\n    patch_size = self.patch.shape[1]\n    if self.patching_strategy == 'fixed':\n        if self.estimator.channels_first:\n            x_trigger[:, :, -patch_size:, -patch_size:] = self.patch\n        else:\n            x_trigger[:, -patch_size:, -patch_size:, :] = self.patch\n    else:\n        for x in x_trigger:\n            if self.estimator.channels_first:\n                x_cord = random.randrange(0, x.shape[1] - self.patch.shape[1] + 1)\n                y_cord = random.randrange(0, x.shape[2] - self.patch.shape[2] + 1)\n                x[:, x_cord:x_cord + patch_size, y_cord:y_cord + patch_size] = self.patch\n            else:\n                x_cord = random.randrange(0, x.shape[0] - self.patch.shape[0] + 1)\n                y_cord = random.randrange(0, x.shape[1] - self.patch.shape[1] + 1)\n                x[x_cord:x_cord + patch_size, y_cord:y_cord + patch_size, :] = self.patch\n    return x_trigger",
            "def _apply_trigger_patch(self, x_trigger: np.ndarray) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Select indices of poisoned samples\\n\\n        :x_trigger: Samples to be used for trigger.\\n        :return tensor with applied trigger patches.\\n        '\n    patch_size = self.patch.shape[1]\n    if self.patching_strategy == 'fixed':\n        if self.estimator.channels_first:\n            x_trigger[:, :, -patch_size:, -patch_size:] = self.patch\n        else:\n            x_trigger[:, -patch_size:, -patch_size:, :] = self.patch\n    else:\n        for x in x_trigger:\n            if self.estimator.channels_first:\n                x_cord = random.randrange(0, x.shape[1] - self.patch.shape[1] + 1)\n                y_cord = random.randrange(0, x.shape[2] - self.patch.shape[2] + 1)\n                x[:, x_cord:x_cord + patch_size, y_cord:y_cord + patch_size] = self.patch\n            else:\n                x_cord = random.randrange(0, x.shape[0] - self.patch.shape[0] + 1)\n                y_cord = random.randrange(0, x.shape[1] - self.patch.shape[1] + 1)\n                x[x_cord:x_cord + patch_size, y_cord:y_cord + patch_size, :] = self.patch\n    return x_trigger",
            "def _apply_trigger_patch(self, x_trigger: np.ndarray) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Select indices of poisoned samples\\n\\n        :x_trigger: Samples to be used for trigger.\\n        :return tensor with applied trigger patches.\\n        '\n    patch_size = self.patch.shape[1]\n    if self.patching_strategy == 'fixed':\n        if self.estimator.channels_first:\n            x_trigger[:, :, -patch_size:, -patch_size:] = self.patch\n        else:\n            x_trigger[:, -patch_size:, -patch_size:, :] = self.patch\n    else:\n        for x in x_trigger:\n            if self.estimator.channels_first:\n                x_cord = random.randrange(0, x.shape[1] - self.patch.shape[1] + 1)\n                y_cord = random.randrange(0, x.shape[2] - self.patch.shape[2] + 1)\n                x[:, x_cord:x_cord + patch_size, y_cord:y_cord + patch_size] = self.patch\n            else:\n                x_cord = random.randrange(0, x.shape[0] - self.patch.shape[0] + 1)\n                y_cord = random.randrange(0, x.shape[1] - self.patch.shape[1] + 1)\n                x[x_cord:x_cord + patch_size, y_cord:y_cord + patch_size, :] = self.patch\n    return x_trigger",
            "def _apply_trigger_patch(self, x_trigger: np.ndarray) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Select indices of poisoned samples\\n\\n        :x_trigger: Samples to be used for trigger.\\n        :return tensor with applied trigger patches.\\n        '\n    patch_size = self.patch.shape[1]\n    if self.patching_strategy == 'fixed':\n        if self.estimator.channels_first:\n            x_trigger[:, :, -patch_size:, -patch_size:] = self.patch\n        else:\n            x_trigger[:, -patch_size:, -patch_size:, :] = self.patch\n    else:\n        for x in x_trigger:\n            if self.estimator.channels_first:\n                x_cord = random.randrange(0, x.shape[1] - self.patch.shape[1] + 1)\n                y_cord = random.randrange(0, x.shape[2] - self.patch.shape[2] + 1)\n                x[:, x_cord:x_cord + patch_size, y_cord:y_cord + patch_size] = self.patch\n            else:\n                x_cord = random.randrange(0, x.shape[0] - self.patch.shape[0] + 1)\n                y_cord = random.randrange(0, x.shape[1] - self.patch.shape[1] + 1)\n                x[x_cord:x_cord + patch_size, y_cord:y_cord + patch_size, :] = self.patch\n    return x_trigger",
            "def _apply_trigger_patch(self, x_trigger: np.ndarray) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Select indices of poisoned samples\\n\\n        :x_trigger: Samples to be used for trigger.\\n        :return tensor with applied trigger patches.\\n        '\n    patch_size = self.patch.shape[1]\n    if self.patching_strategy == 'fixed':\n        if self.estimator.channels_first:\n            x_trigger[:, :, -patch_size:, -patch_size:] = self.patch\n        else:\n            x_trigger[:, -patch_size:, -patch_size:, :] = self.patch\n    else:\n        for x in x_trigger:\n            if self.estimator.channels_first:\n                x_cord = random.randrange(0, x.shape[1] - self.patch.shape[1] + 1)\n                y_cord = random.randrange(0, x.shape[2] - self.patch.shape[2] + 1)\n                x[:, x_cord:x_cord + patch_size, y_cord:y_cord + patch_size] = self.patch\n            else:\n                x_cord = random.randrange(0, x.shape[0] - self.patch.shape[0] + 1)\n                y_cord = random.randrange(0, x.shape[1] - self.patch.shape[1] + 1)\n                x[x_cord:x_cord + patch_size, y_cord:y_cord + patch_size, :] = self.patch\n    return x_trigger"
        ]
    }
]