[
    {
        "func_name": "__init__",
        "original": "def __init__(self, *args, **kwargs) -> None:\n    input_args = list(args)\n    self._client = input_args.pop(0) if input_args else kwargs.pop('client')\n    self._config = input_args.pop(0) if input_args else kwargs.pop('config')\n    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')\n    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('deserializer')",
        "mutated": [
            "def __init__(self, *args, **kwargs) -> None:\n    if False:\n        i = 10\n    input_args = list(args)\n    self._client = input_args.pop(0) if input_args else kwargs.pop('client')\n    self._config = input_args.pop(0) if input_args else kwargs.pop('config')\n    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')\n    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('deserializer')",
            "def __init__(self, *args, **kwargs) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    input_args = list(args)\n    self._client = input_args.pop(0) if input_args else kwargs.pop('client')\n    self._config = input_args.pop(0) if input_args else kwargs.pop('config')\n    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')\n    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('deserializer')",
            "def __init__(self, *args, **kwargs) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    input_args = list(args)\n    self._client = input_args.pop(0) if input_args else kwargs.pop('client')\n    self._config = input_args.pop(0) if input_args else kwargs.pop('config')\n    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')\n    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('deserializer')",
            "def __init__(self, *args, **kwargs) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    input_args = list(args)\n    self._client = input_args.pop(0) if input_args else kwargs.pop('client')\n    self._config = input_args.pop(0) if input_args else kwargs.pop('config')\n    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')\n    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('deserializer')",
            "def __init__(self, *args, **kwargs) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    input_args = list(args)\n    self._client = input_args.pop(0) if input_args else kwargs.pop('client')\n    self._config = input_args.pop(0) if input_args else kwargs.pop('config')\n    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')\n    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('deserializer')"
        ]
    },
    {
        "func_name": "prepare_request",
        "original": "def prepare_request(next_link=None):\n    if not next_link:\n        request = build_list_request(billing_account_id=billing_account_id, filter=filter, api_version=api_version, template_url=self.list.metadata['url'], headers=_headers, params=_params)\n        request = _convert_request(request)\n        request.url = self._client.format_url(request.url)\n    else:\n        _parsed_next_link = urllib.parse.urlparse(next_link)\n        _next_request_params = case_insensitive_dict({key: [urllib.parse.quote(v) for v in value] for (key, value) in urllib.parse.parse_qs(_parsed_next_link.query).items()})\n        _next_request_params['api-version'] = self._config.api_version\n        request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)\n        request = _convert_request(request)\n        request.url = self._client.format_url(request.url)\n        request.method = 'GET'\n    return request",
        "mutated": [
            "def prepare_request(next_link=None):\n    if False:\n        i = 10\n    if not next_link:\n        request = build_list_request(billing_account_id=billing_account_id, filter=filter, api_version=api_version, template_url=self.list.metadata['url'], headers=_headers, params=_params)\n        request = _convert_request(request)\n        request.url = self._client.format_url(request.url)\n    else:\n        _parsed_next_link = urllib.parse.urlparse(next_link)\n        _next_request_params = case_insensitive_dict({key: [urllib.parse.quote(v) for v in value] for (key, value) in urllib.parse.parse_qs(_parsed_next_link.query).items()})\n        _next_request_params['api-version'] = self._config.api_version\n        request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)\n        request = _convert_request(request)\n        request.url = self._client.format_url(request.url)\n        request.method = 'GET'\n    return request",
            "def prepare_request(next_link=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not next_link:\n        request = build_list_request(billing_account_id=billing_account_id, filter=filter, api_version=api_version, template_url=self.list.metadata['url'], headers=_headers, params=_params)\n        request = _convert_request(request)\n        request.url = self._client.format_url(request.url)\n    else:\n        _parsed_next_link = urllib.parse.urlparse(next_link)\n        _next_request_params = case_insensitive_dict({key: [urllib.parse.quote(v) for v in value] for (key, value) in urllib.parse.parse_qs(_parsed_next_link.query).items()})\n        _next_request_params['api-version'] = self._config.api_version\n        request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)\n        request = _convert_request(request)\n        request.url = self._client.format_url(request.url)\n        request.method = 'GET'\n    return request",
            "def prepare_request(next_link=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not next_link:\n        request = build_list_request(billing_account_id=billing_account_id, filter=filter, api_version=api_version, template_url=self.list.metadata['url'], headers=_headers, params=_params)\n        request = _convert_request(request)\n        request.url = self._client.format_url(request.url)\n    else:\n        _parsed_next_link = urllib.parse.urlparse(next_link)\n        _next_request_params = case_insensitive_dict({key: [urllib.parse.quote(v) for v in value] for (key, value) in urllib.parse.parse_qs(_parsed_next_link.query).items()})\n        _next_request_params['api-version'] = self._config.api_version\n        request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)\n        request = _convert_request(request)\n        request.url = self._client.format_url(request.url)\n        request.method = 'GET'\n    return request",
            "def prepare_request(next_link=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not next_link:\n        request = build_list_request(billing_account_id=billing_account_id, filter=filter, api_version=api_version, template_url=self.list.metadata['url'], headers=_headers, params=_params)\n        request = _convert_request(request)\n        request.url = self._client.format_url(request.url)\n    else:\n        _parsed_next_link = urllib.parse.urlparse(next_link)\n        _next_request_params = case_insensitive_dict({key: [urllib.parse.quote(v) for v in value] for (key, value) in urllib.parse.parse_qs(_parsed_next_link.query).items()})\n        _next_request_params['api-version'] = self._config.api_version\n        request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)\n        request = _convert_request(request)\n        request.url = self._client.format_url(request.url)\n        request.method = 'GET'\n    return request",
            "def prepare_request(next_link=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not next_link:\n        request = build_list_request(billing_account_id=billing_account_id, filter=filter, api_version=api_version, template_url=self.list.metadata['url'], headers=_headers, params=_params)\n        request = _convert_request(request)\n        request.url = self._client.format_url(request.url)\n    else:\n        _parsed_next_link = urllib.parse.urlparse(next_link)\n        _next_request_params = case_insensitive_dict({key: [urllib.parse.quote(v) for v in value] for (key, value) in urllib.parse.parse_qs(_parsed_next_link.query).items()})\n        _next_request_params['api-version'] = self._config.api_version\n        request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)\n        request = _convert_request(request)\n        request.url = self._client.format_url(request.url)\n        request.method = 'GET'\n    return request"
        ]
    },
    {
        "func_name": "list",
        "original": "@distributed_trace\ndef list(self, billing_account_id: str, filter: Optional[str]=None, **kwargs: Any) -> AsyncIterable['_models.ReservationTransaction']:\n    \"\"\"List of transactions for reserved instances on billing account scope. Note: The refund\n        transactions are posted along with its purchase transaction (i.e. in the purchase billing\n        month). For example, The refund is requested in May 2021. This refund transaction will have\n        event date as May 2021 but the billing month as April 2020 when the reservation purchase was\n        made.\n\n        :param billing_account_id: BillingAccount ID. Required.\n        :type billing_account_id: str\n        :param filter: Filter reservation transactions by date range. The properties/EventDate for\n         start date and end date. The filter supports 'le' and  'ge'. Note: API returns data for the\n         entire start date's and end date's billing month. For example, filter\n         properties/eventDate+ge+2020-01-01+AND+properties/eventDate+le+2020-12-29 will include data for\n         the entire December 2020 month (i.e. will contain records for dates December 30 and 31).\n         Default value is None.\n        :type filter: str\n        :keyword callable cls: A custom type or function that will be passed the direct response\n        :return: An iterator like instance of either ReservationTransaction or the result of\n         cls(response)\n        :rtype:\n         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.consumption.models.ReservationTransaction]\n        :raises ~azure.core.exceptions.HttpResponseError:\n        \"\"\"\n    _headers = kwargs.pop('headers', {}) or {}\n    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})\n    api_version: Literal['2021-10-01'] = kwargs.pop('api_version', _params.pop('api-version', self._config.api_version))\n    cls: ClsType[_models.ReservationTransactionsListResult] = kwargs.pop('cls', None)\n    error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}\n    error_map.update(kwargs.pop('error_map', {}) or {})\n\n    def prepare_request(next_link=None):\n        if not next_link:\n            request = build_list_request(billing_account_id=billing_account_id, filter=filter, api_version=api_version, template_url=self.list.metadata['url'], headers=_headers, params=_params)\n            request = _convert_request(request)\n            request.url = self._client.format_url(request.url)\n        else:\n            _parsed_next_link = urllib.parse.urlparse(next_link)\n            _next_request_params = case_insensitive_dict({key: [urllib.parse.quote(v) for v in value] for (key, value) in urllib.parse.parse_qs(_parsed_next_link.query).items()})\n            _next_request_params['api-version'] = self._config.api_version\n            request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)\n            request = _convert_request(request)\n            request.url = self._client.format_url(request.url)\n            request.method = 'GET'\n        return request\n\n    async def extract_data(pipeline_response):\n        deserialized = self._deserialize('ReservationTransactionsListResult', pipeline_response)\n        list_of_elem = deserialized.value\n        if cls:\n            list_of_elem = cls(list_of_elem)\n        return (deserialized.next_link or None, AsyncList(list_of_elem))\n\n    async def get_next(next_link=None):\n        request = prepare_request(next_link)\n        pipeline_response: PipelineResponse = await self._client._pipeline.run(request, stream=False, **kwargs)\n        response = pipeline_response.http_response\n        if response.status_code not in [200]:\n            map_error(status_code=response.status_code, response=response, error_map=error_map)\n            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)\n            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)\n        return pipeline_response\n    return AsyncItemPaged(get_next, extract_data)",
        "mutated": [
            "@distributed_trace\ndef list(self, billing_account_id: str, filter: Optional[str]=None, **kwargs: Any) -> AsyncIterable['_models.ReservationTransaction']:\n    if False:\n        i = 10\n    \"List of transactions for reserved instances on billing account scope. Note: The refund\\n        transactions are posted along with its purchase transaction (i.e. in the purchase billing\\n        month). For example, The refund is requested in May 2021. This refund transaction will have\\n        event date as May 2021 but the billing month as April 2020 when the reservation purchase was\\n        made.\\n\\n        :param billing_account_id: BillingAccount ID. Required.\\n        :type billing_account_id: str\\n        :param filter: Filter reservation transactions by date range. The properties/EventDate for\\n         start date and end date. The filter supports 'le' and  'ge'. Note: API returns data for the\\n         entire start date's and end date's billing month. For example, filter\\n         properties/eventDate+ge+2020-01-01+AND+properties/eventDate+le+2020-12-29 will include data for\\n         the entire December 2020 month (i.e. will contain records for dates December 30 and 31).\\n         Default value is None.\\n        :type filter: str\\n        :keyword callable cls: A custom type or function that will be passed the direct response\\n        :return: An iterator like instance of either ReservationTransaction or the result of\\n         cls(response)\\n        :rtype:\\n         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.consumption.models.ReservationTransaction]\\n        :raises ~azure.core.exceptions.HttpResponseError:\\n        \"\n    _headers = kwargs.pop('headers', {}) or {}\n    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})\n    api_version: Literal['2021-10-01'] = kwargs.pop('api_version', _params.pop('api-version', self._config.api_version))\n    cls: ClsType[_models.ReservationTransactionsListResult] = kwargs.pop('cls', None)\n    error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}\n    error_map.update(kwargs.pop('error_map', {}) or {})\n\n    def prepare_request(next_link=None):\n        if not next_link:\n            request = build_list_request(billing_account_id=billing_account_id, filter=filter, api_version=api_version, template_url=self.list.metadata['url'], headers=_headers, params=_params)\n            request = _convert_request(request)\n            request.url = self._client.format_url(request.url)\n        else:\n            _parsed_next_link = urllib.parse.urlparse(next_link)\n            _next_request_params = case_insensitive_dict({key: [urllib.parse.quote(v) for v in value] for (key, value) in urllib.parse.parse_qs(_parsed_next_link.query).items()})\n            _next_request_params['api-version'] = self._config.api_version\n            request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)\n            request = _convert_request(request)\n            request.url = self._client.format_url(request.url)\n            request.method = 'GET'\n        return request\n\n    async def extract_data(pipeline_response):\n        deserialized = self._deserialize('ReservationTransactionsListResult', pipeline_response)\n        list_of_elem = deserialized.value\n        if cls:\n            list_of_elem = cls(list_of_elem)\n        return (deserialized.next_link or None, AsyncList(list_of_elem))\n\n    async def get_next(next_link=None):\n        request = prepare_request(next_link)\n        pipeline_response: PipelineResponse = await self._client._pipeline.run(request, stream=False, **kwargs)\n        response = pipeline_response.http_response\n        if response.status_code not in [200]:\n            map_error(status_code=response.status_code, response=response, error_map=error_map)\n            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)\n            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)\n        return pipeline_response\n    return AsyncItemPaged(get_next, extract_data)",
            "@distributed_trace\ndef list(self, billing_account_id: str, filter: Optional[str]=None, **kwargs: Any) -> AsyncIterable['_models.ReservationTransaction']:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"List of transactions for reserved instances on billing account scope. Note: The refund\\n        transactions are posted along with its purchase transaction (i.e. in the purchase billing\\n        month). For example, The refund is requested in May 2021. This refund transaction will have\\n        event date as May 2021 but the billing month as April 2020 when the reservation purchase was\\n        made.\\n\\n        :param billing_account_id: BillingAccount ID. Required.\\n        :type billing_account_id: str\\n        :param filter: Filter reservation transactions by date range. The properties/EventDate for\\n         start date and end date. The filter supports 'le' and  'ge'. Note: API returns data for the\\n         entire start date's and end date's billing month. For example, filter\\n         properties/eventDate+ge+2020-01-01+AND+properties/eventDate+le+2020-12-29 will include data for\\n         the entire December 2020 month (i.e. will contain records for dates December 30 and 31).\\n         Default value is None.\\n        :type filter: str\\n        :keyword callable cls: A custom type or function that will be passed the direct response\\n        :return: An iterator like instance of either ReservationTransaction or the result of\\n         cls(response)\\n        :rtype:\\n         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.consumption.models.ReservationTransaction]\\n        :raises ~azure.core.exceptions.HttpResponseError:\\n        \"\n    _headers = kwargs.pop('headers', {}) or {}\n    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})\n    api_version: Literal['2021-10-01'] = kwargs.pop('api_version', _params.pop('api-version', self._config.api_version))\n    cls: ClsType[_models.ReservationTransactionsListResult] = kwargs.pop('cls', None)\n    error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}\n    error_map.update(kwargs.pop('error_map', {}) or {})\n\n    def prepare_request(next_link=None):\n        if not next_link:\n            request = build_list_request(billing_account_id=billing_account_id, filter=filter, api_version=api_version, template_url=self.list.metadata['url'], headers=_headers, params=_params)\n            request = _convert_request(request)\n            request.url = self._client.format_url(request.url)\n        else:\n            _parsed_next_link = urllib.parse.urlparse(next_link)\n            _next_request_params = case_insensitive_dict({key: [urllib.parse.quote(v) for v in value] for (key, value) in urllib.parse.parse_qs(_parsed_next_link.query).items()})\n            _next_request_params['api-version'] = self._config.api_version\n            request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)\n            request = _convert_request(request)\n            request.url = self._client.format_url(request.url)\n            request.method = 'GET'\n        return request\n\n    async def extract_data(pipeline_response):\n        deserialized = self._deserialize('ReservationTransactionsListResult', pipeline_response)\n        list_of_elem = deserialized.value\n        if cls:\n            list_of_elem = cls(list_of_elem)\n        return (deserialized.next_link or None, AsyncList(list_of_elem))\n\n    async def get_next(next_link=None):\n        request = prepare_request(next_link)\n        pipeline_response: PipelineResponse = await self._client._pipeline.run(request, stream=False, **kwargs)\n        response = pipeline_response.http_response\n        if response.status_code not in [200]:\n            map_error(status_code=response.status_code, response=response, error_map=error_map)\n            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)\n            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)\n        return pipeline_response\n    return AsyncItemPaged(get_next, extract_data)",
            "@distributed_trace\ndef list(self, billing_account_id: str, filter: Optional[str]=None, **kwargs: Any) -> AsyncIterable['_models.ReservationTransaction']:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"List of transactions for reserved instances on billing account scope. Note: The refund\\n        transactions are posted along with its purchase transaction (i.e. in the purchase billing\\n        month). For example, The refund is requested in May 2021. This refund transaction will have\\n        event date as May 2021 but the billing month as April 2020 when the reservation purchase was\\n        made.\\n\\n        :param billing_account_id: BillingAccount ID. Required.\\n        :type billing_account_id: str\\n        :param filter: Filter reservation transactions by date range. The properties/EventDate for\\n         start date and end date. The filter supports 'le' and  'ge'. Note: API returns data for the\\n         entire start date's and end date's billing month. For example, filter\\n         properties/eventDate+ge+2020-01-01+AND+properties/eventDate+le+2020-12-29 will include data for\\n         the entire December 2020 month (i.e. will contain records for dates December 30 and 31).\\n         Default value is None.\\n        :type filter: str\\n        :keyword callable cls: A custom type or function that will be passed the direct response\\n        :return: An iterator like instance of either ReservationTransaction or the result of\\n         cls(response)\\n        :rtype:\\n         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.consumption.models.ReservationTransaction]\\n        :raises ~azure.core.exceptions.HttpResponseError:\\n        \"\n    _headers = kwargs.pop('headers', {}) or {}\n    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})\n    api_version: Literal['2021-10-01'] = kwargs.pop('api_version', _params.pop('api-version', self._config.api_version))\n    cls: ClsType[_models.ReservationTransactionsListResult] = kwargs.pop('cls', None)\n    error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}\n    error_map.update(kwargs.pop('error_map', {}) or {})\n\n    def prepare_request(next_link=None):\n        if not next_link:\n            request = build_list_request(billing_account_id=billing_account_id, filter=filter, api_version=api_version, template_url=self.list.metadata['url'], headers=_headers, params=_params)\n            request = _convert_request(request)\n            request.url = self._client.format_url(request.url)\n        else:\n            _parsed_next_link = urllib.parse.urlparse(next_link)\n            _next_request_params = case_insensitive_dict({key: [urllib.parse.quote(v) for v in value] for (key, value) in urllib.parse.parse_qs(_parsed_next_link.query).items()})\n            _next_request_params['api-version'] = self._config.api_version\n            request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)\n            request = _convert_request(request)\n            request.url = self._client.format_url(request.url)\n            request.method = 'GET'\n        return request\n\n    async def extract_data(pipeline_response):\n        deserialized = self._deserialize('ReservationTransactionsListResult', pipeline_response)\n        list_of_elem = deserialized.value\n        if cls:\n            list_of_elem = cls(list_of_elem)\n        return (deserialized.next_link or None, AsyncList(list_of_elem))\n\n    async def get_next(next_link=None):\n        request = prepare_request(next_link)\n        pipeline_response: PipelineResponse = await self._client._pipeline.run(request, stream=False, **kwargs)\n        response = pipeline_response.http_response\n        if response.status_code not in [200]:\n            map_error(status_code=response.status_code, response=response, error_map=error_map)\n            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)\n            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)\n        return pipeline_response\n    return AsyncItemPaged(get_next, extract_data)",
            "@distributed_trace\ndef list(self, billing_account_id: str, filter: Optional[str]=None, **kwargs: Any) -> AsyncIterable['_models.ReservationTransaction']:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"List of transactions for reserved instances on billing account scope. Note: The refund\\n        transactions are posted along with its purchase transaction (i.e. in the purchase billing\\n        month). For example, The refund is requested in May 2021. This refund transaction will have\\n        event date as May 2021 but the billing month as April 2020 when the reservation purchase was\\n        made.\\n\\n        :param billing_account_id: BillingAccount ID. Required.\\n        :type billing_account_id: str\\n        :param filter: Filter reservation transactions by date range. The properties/EventDate for\\n         start date and end date. The filter supports 'le' and  'ge'. Note: API returns data for the\\n         entire start date's and end date's billing month. For example, filter\\n         properties/eventDate+ge+2020-01-01+AND+properties/eventDate+le+2020-12-29 will include data for\\n         the entire December 2020 month (i.e. will contain records for dates December 30 and 31).\\n         Default value is None.\\n        :type filter: str\\n        :keyword callable cls: A custom type or function that will be passed the direct response\\n        :return: An iterator like instance of either ReservationTransaction or the result of\\n         cls(response)\\n        :rtype:\\n         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.consumption.models.ReservationTransaction]\\n        :raises ~azure.core.exceptions.HttpResponseError:\\n        \"\n    _headers = kwargs.pop('headers', {}) or {}\n    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})\n    api_version: Literal['2021-10-01'] = kwargs.pop('api_version', _params.pop('api-version', self._config.api_version))\n    cls: ClsType[_models.ReservationTransactionsListResult] = kwargs.pop('cls', None)\n    error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}\n    error_map.update(kwargs.pop('error_map', {}) or {})\n\n    def prepare_request(next_link=None):\n        if not next_link:\n            request = build_list_request(billing_account_id=billing_account_id, filter=filter, api_version=api_version, template_url=self.list.metadata['url'], headers=_headers, params=_params)\n            request = _convert_request(request)\n            request.url = self._client.format_url(request.url)\n        else:\n            _parsed_next_link = urllib.parse.urlparse(next_link)\n            _next_request_params = case_insensitive_dict({key: [urllib.parse.quote(v) for v in value] for (key, value) in urllib.parse.parse_qs(_parsed_next_link.query).items()})\n            _next_request_params['api-version'] = self._config.api_version\n            request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)\n            request = _convert_request(request)\n            request.url = self._client.format_url(request.url)\n            request.method = 'GET'\n        return request\n\n    async def extract_data(pipeline_response):\n        deserialized = self._deserialize('ReservationTransactionsListResult', pipeline_response)\n        list_of_elem = deserialized.value\n        if cls:\n            list_of_elem = cls(list_of_elem)\n        return (deserialized.next_link or None, AsyncList(list_of_elem))\n\n    async def get_next(next_link=None):\n        request = prepare_request(next_link)\n        pipeline_response: PipelineResponse = await self._client._pipeline.run(request, stream=False, **kwargs)\n        response = pipeline_response.http_response\n        if response.status_code not in [200]:\n            map_error(status_code=response.status_code, response=response, error_map=error_map)\n            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)\n            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)\n        return pipeline_response\n    return AsyncItemPaged(get_next, extract_data)",
            "@distributed_trace\ndef list(self, billing_account_id: str, filter: Optional[str]=None, **kwargs: Any) -> AsyncIterable['_models.ReservationTransaction']:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"List of transactions for reserved instances on billing account scope. Note: The refund\\n        transactions are posted along with its purchase transaction (i.e. in the purchase billing\\n        month). For example, The refund is requested in May 2021. This refund transaction will have\\n        event date as May 2021 but the billing month as April 2020 when the reservation purchase was\\n        made.\\n\\n        :param billing_account_id: BillingAccount ID. Required.\\n        :type billing_account_id: str\\n        :param filter: Filter reservation transactions by date range. The properties/EventDate for\\n         start date and end date. The filter supports 'le' and  'ge'. Note: API returns data for the\\n         entire start date's and end date's billing month. For example, filter\\n         properties/eventDate+ge+2020-01-01+AND+properties/eventDate+le+2020-12-29 will include data for\\n         the entire December 2020 month (i.e. will contain records for dates December 30 and 31).\\n         Default value is None.\\n        :type filter: str\\n        :keyword callable cls: A custom type or function that will be passed the direct response\\n        :return: An iterator like instance of either ReservationTransaction or the result of\\n         cls(response)\\n        :rtype:\\n         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.consumption.models.ReservationTransaction]\\n        :raises ~azure.core.exceptions.HttpResponseError:\\n        \"\n    _headers = kwargs.pop('headers', {}) or {}\n    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})\n    api_version: Literal['2021-10-01'] = kwargs.pop('api_version', _params.pop('api-version', self._config.api_version))\n    cls: ClsType[_models.ReservationTransactionsListResult] = kwargs.pop('cls', None)\n    error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}\n    error_map.update(kwargs.pop('error_map', {}) or {})\n\n    def prepare_request(next_link=None):\n        if not next_link:\n            request = build_list_request(billing_account_id=billing_account_id, filter=filter, api_version=api_version, template_url=self.list.metadata['url'], headers=_headers, params=_params)\n            request = _convert_request(request)\n            request.url = self._client.format_url(request.url)\n        else:\n            _parsed_next_link = urllib.parse.urlparse(next_link)\n            _next_request_params = case_insensitive_dict({key: [urllib.parse.quote(v) for v in value] for (key, value) in urllib.parse.parse_qs(_parsed_next_link.query).items()})\n            _next_request_params['api-version'] = self._config.api_version\n            request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)\n            request = _convert_request(request)\n            request.url = self._client.format_url(request.url)\n            request.method = 'GET'\n        return request\n\n    async def extract_data(pipeline_response):\n        deserialized = self._deserialize('ReservationTransactionsListResult', pipeline_response)\n        list_of_elem = deserialized.value\n        if cls:\n            list_of_elem = cls(list_of_elem)\n        return (deserialized.next_link or None, AsyncList(list_of_elem))\n\n    async def get_next(next_link=None):\n        request = prepare_request(next_link)\n        pipeline_response: PipelineResponse = await self._client._pipeline.run(request, stream=False, **kwargs)\n        response = pipeline_response.http_response\n        if response.status_code not in [200]:\n            map_error(status_code=response.status_code, response=response, error_map=error_map)\n            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)\n            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)\n        return pipeline_response\n    return AsyncItemPaged(get_next, extract_data)"
        ]
    },
    {
        "func_name": "prepare_request",
        "original": "def prepare_request(next_link=None):\n    if not next_link:\n        request = build_list_by_billing_profile_request(billing_account_id=billing_account_id, billing_profile_id=billing_profile_id, filter=filter, api_version=api_version, template_url=self.list_by_billing_profile.metadata['url'], headers=_headers, params=_params)\n        request = _convert_request(request)\n        request.url = self._client.format_url(request.url)\n    else:\n        _parsed_next_link = urllib.parse.urlparse(next_link)\n        _next_request_params = case_insensitive_dict({key: [urllib.parse.quote(v) for v in value] for (key, value) in urllib.parse.parse_qs(_parsed_next_link.query).items()})\n        _next_request_params['api-version'] = self._config.api_version\n        request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)\n        request = _convert_request(request)\n        request.url = self._client.format_url(request.url)\n        request.method = 'GET'\n    return request",
        "mutated": [
            "def prepare_request(next_link=None):\n    if False:\n        i = 10\n    if not next_link:\n        request = build_list_by_billing_profile_request(billing_account_id=billing_account_id, billing_profile_id=billing_profile_id, filter=filter, api_version=api_version, template_url=self.list_by_billing_profile.metadata['url'], headers=_headers, params=_params)\n        request = _convert_request(request)\n        request.url = self._client.format_url(request.url)\n    else:\n        _parsed_next_link = urllib.parse.urlparse(next_link)\n        _next_request_params = case_insensitive_dict({key: [urllib.parse.quote(v) for v in value] for (key, value) in urllib.parse.parse_qs(_parsed_next_link.query).items()})\n        _next_request_params['api-version'] = self._config.api_version\n        request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)\n        request = _convert_request(request)\n        request.url = self._client.format_url(request.url)\n        request.method = 'GET'\n    return request",
            "def prepare_request(next_link=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not next_link:\n        request = build_list_by_billing_profile_request(billing_account_id=billing_account_id, billing_profile_id=billing_profile_id, filter=filter, api_version=api_version, template_url=self.list_by_billing_profile.metadata['url'], headers=_headers, params=_params)\n        request = _convert_request(request)\n        request.url = self._client.format_url(request.url)\n    else:\n        _parsed_next_link = urllib.parse.urlparse(next_link)\n        _next_request_params = case_insensitive_dict({key: [urllib.parse.quote(v) for v in value] for (key, value) in urllib.parse.parse_qs(_parsed_next_link.query).items()})\n        _next_request_params['api-version'] = self._config.api_version\n        request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)\n        request = _convert_request(request)\n        request.url = self._client.format_url(request.url)\n        request.method = 'GET'\n    return request",
            "def prepare_request(next_link=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not next_link:\n        request = build_list_by_billing_profile_request(billing_account_id=billing_account_id, billing_profile_id=billing_profile_id, filter=filter, api_version=api_version, template_url=self.list_by_billing_profile.metadata['url'], headers=_headers, params=_params)\n        request = _convert_request(request)\n        request.url = self._client.format_url(request.url)\n    else:\n        _parsed_next_link = urllib.parse.urlparse(next_link)\n        _next_request_params = case_insensitive_dict({key: [urllib.parse.quote(v) for v in value] for (key, value) in urllib.parse.parse_qs(_parsed_next_link.query).items()})\n        _next_request_params['api-version'] = self._config.api_version\n        request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)\n        request = _convert_request(request)\n        request.url = self._client.format_url(request.url)\n        request.method = 'GET'\n    return request",
            "def prepare_request(next_link=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not next_link:\n        request = build_list_by_billing_profile_request(billing_account_id=billing_account_id, billing_profile_id=billing_profile_id, filter=filter, api_version=api_version, template_url=self.list_by_billing_profile.metadata['url'], headers=_headers, params=_params)\n        request = _convert_request(request)\n        request.url = self._client.format_url(request.url)\n    else:\n        _parsed_next_link = urllib.parse.urlparse(next_link)\n        _next_request_params = case_insensitive_dict({key: [urllib.parse.quote(v) for v in value] for (key, value) in urllib.parse.parse_qs(_parsed_next_link.query).items()})\n        _next_request_params['api-version'] = self._config.api_version\n        request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)\n        request = _convert_request(request)\n        request.url = self._client.format_url(request.url)\n        request.method = 'GET'\n    return request",
            "def prepare_request(next_link=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not next_link:\n        request = build_list_by_billing_profile_request(billing_account_id=billing_account_id, billing_profile_id=billing_profile_id, filter=filter, api_version=api_version, template_url=self.list_by_billing_profile.metadata['url'], headers=_headers, params=_params)\n        request = _convert_request(request)\n        request.url = self._client.format_url(request.url)\n    else:\n        _parsed_next_link = urllib.parse.urlparse(next_link)\n        _next_request_params = case_insensitive_dict({key: [urllib.parse.quote(v) for v in value] for (key, value) in urllib.parse.parse_qs(_parsed_next_link.query).items()})\n        _next_request_params['api-version'] = self._config.api_version\n        request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)\n        request = _convert_request(request)\n        request.url = self._client.format_url(request.url)\n        request.method = 'GET'\n    return request"
        ]
    },
    {
        "func_name": "list_by_billing_profile",
        "original": "@distributed_trace\ndef list_by_billing_profile(self, billing_account_id: str, billing_profile_id: str, filter: Optional[str]=None, **kwargs: Any) -> AsyncIterable['_models.ModernReservationTransaction']:\n    \"\"\"List of transactions for reserved instances on billing profile scope. The refund transactions\n        are posted along with its purchase transaction (i.e. in the purchase billing month). For\n        example, The refund is requested in May 2021. This refund transaction will have event date as\n        May 2021 but the billing month as April 2020 when the reservation purchase was made.\n\n        :param billing_account_id: BillingAccount ID. Required.\n        :type billing_account_id: str\n        :param billing_profile_id: Azure Billing Profile ID. Required.\n        :type billing_profile_id: str\n        :param filter: Filter reservation transactions by date range. The properties/EventDate for\n         start date and end date. The filter supports 'le' and  'ge'. Note: API returns data for the\n         entire start date's and end date's billing month. For example, filter\n         properties/eventDate+ge+2020-01-01+AND+properties/eventDate+le+2020-12-29 will include data for\n         entire December 2020 month (i.e. will contain records for dates December 30 and 31). Default\n         value is None.\n        :type filter: str\n        :keyword callable cls: A custom type or function that will be passed the direct response\n        :return: An iterator like instance of either ModernReservationTransaction or the result of\n         cls(response)\n        :rtype:\n         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.consumption.models.ModernReservationTransaction]\n        :raises ~azure.core.exceptions.HttpResponseError:\n        \"\"\"\n    _headers = kwargs.pop('headers', {}) or {}\n    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})\n    api_version: Literal['2021-10-01'] = kwargs.pop('api_version', _params.pop('api-version', self._config.api_version))\n    cls: ClsType[_models.ModernReservationTransactionsListResult] = kwargs.pop('cls', None)\n    error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}\n    error_map.update(kwargs.pop('error_map', {}) or {})\n\n    def prepare_request(next_link=None):\n        if not next_link:\n            request = build_list_by_billing_profile_request(billing_account_id=billing_account_id, billing_profile_id=billing_profile_id, filter=filter, api_version=api_version, template_url=self.list_by_billing_profile.metadata['url'], headers=_headers, params=_params)\n            request = _convert_request(request)\n            request.url = self._client.format_url(request.url)\n        else:\n            _parsed_next_link = urllib.parse.urlparse(next_link)\n            _next_request_params = case_insensitive_dict({key: [urllib.parse.quote(v) for v in value] for (key, value) in urllib.parse.parse_qs(_parsed_next_link.query).items()})\n            _next_request_params['api-version'] = self._config.api_version\n            request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)\n            request = _convert_request(request)\n            request.url = self._client.format_url(request.url)\n            request.method = 'GET'\n        return request\n\n    async def extract_data(pipeline_response):\n        deserialized = self._deserialize('ModernReservationTransactionsListResult', pipeline_response)\n        list_of_elem = deserialized.value\n        if cls:\n            list_of_elem = cls(list_of_elem)\n        return (deserialized.next_link or None, AsyncList(list_of_elem))\n\n    async def get_next(next_link=None):\n        request = prepare_request(next_link)\n        pipeline_response: PipelineResponse = await self._client._pipeline.run(request, stream=False, **kwargs)\n        response = pipeline_response.http_response\n        if response.status_code not in [200]:\n            map_error(status_code=response.status_code, response=response, error_map=error_map)\n            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)\n            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)\n        return pipeline_response\n    return AsyncItemPaged(get_next, extract_data)",
        "mutated": [
            "@distributed_trace\ndef list_by_billing_profile(self, billing_account_id: str, billing_profile_id: str, filter: Optional[str]=None, **kwargs: Any) -> AsyncIterable['_models.ModernReservationTransaction']:\n    if False:\n        i = 10\n    \"List of transactions for reserved instances on billing profile scope. The refund transactions\\n        are posted along with its purchase transaction (i.e. in the purchase billing month). For\\n        example, The refund is requested in May 2021. This refund transaction will have event date as\\n        May 2021 but the billing month as April 2020 when the reservation purchase was made.\\n\\n        :param billing_account_id: BillingAccount ID. Required.\\n        :type billing_account_id: str\\n        :param billing_profile_id: Azure Billing Profile ID. Required.\\n        :type billing_profile_id: str\\n        :param filter: Filter reservation transactions by date range. The properties/EventDate for\\n         start date and end date. The filter supports 'le' and  'ge'. Note: API returns data for the\\n         entire start date's and end date's billing month. For example, filter\\n         properties/eventDate+ge+2020-01-01+AND+properties/eventDate+le+2020-12-29 will include data for\\n         entire December 2020 month (i.e. will contain records for dates December 30 and 31). Default\\n         value is None.\\n        :type filter: str\\n        :keyword callable cls: A custom type or function that will be passed the direct response\\n        :return: An iterator like instance of either ModernReservationTransaction or the result of\\n         cls(response)\\n        :rtype:\\n         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.consumption.models.ModernReservationTransaction]\\n        :raises ~azure.core.exceptions.HttpResponseError:\\n        \"\n    _headers = kwargs.pop('headers', {}) or {}\n    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})\n    api_version: Literal['2021-10-01'] = kwargs.pop('api_version', _params.pop('api-version', self._config.api_version))\n    cls: ClsType[_models.ModernReservationTransactionsListResult] = kwargs.pop('cls', None)\n    error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}\n    error_map.update(kwargs.pop('error_map', {}) or {})\n\n    def prepare_request(next_link=None):\n        if not next_link:\n            request = build_list_by_billing_profile_request(billing_account_id=billing_account_id, billing_profile_id=billing_profile_id, filter=filter, api_version=api_version, template_url=self.list_by_billing_profile.metadata['url'], headers=_headers, params=_params)\n            request = _convert_request(request)\n            request.url = self._client.format_url(request.url)\n        else:\n            _parsed_next_link = urllib.parse.urlparse(next_link)\n            _next_request_params = case_insensitive_dict({key: [urllib.parse.quote(v) for v in value] for (key, value) in urllib.parse.parse_qs(_parsed_next_link.query).items()})\n            _next_request_params['api-version'] = self._config.api_version\n            request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)\n            request = _convert_request(request)\n            request.url = self._client.format_url(request.url)\n            request.method = 'GET'\n        return request\n\n    async def extract_data(pipeline_response):\n        deserialized = self._deserialize('ModernReservationTransactionsListResult', pipeline_response)\n        list_of_elem = deserialized.value\n        if cls:\n            list_of_elem = cls(list_of_elem)\n        return (deserialized.next_link or None, AsyncList(list_of_elem))\n\n    async def get_next(next_link=None):\n        request = prepare_request(next_link)\n        pipeline_response: PipelineResponse = await self._client._pipeline.run(request, stream=False, **kwargs)\n        response = pipeline_response.http_response\n        if response.status_code not in [200]:\n            map_error(status_code=response.status_code, response=response, error_map=error_map)\n            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)\n            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)\n        return pipeline_response\n    return AsyncItemPaged(get_next, extract_data)",
            "@distributed_trace\ndef list_by_billing_profile(self, billing_account_id: str, billing_profile_id: str, filter: Optional[str]=None, **kwargs: Any) -> AsyncIterable['_models.ModernReservationTransaction']:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"List of transactions for reserved instances on billing profile scope. The refund transactions\\n        are posted along with its purchase transaction (i.e. in the purchase billing month). For\\n        example, The refund is requested in May 2021. This refund transaction will have event date as\\n        May 2021 but the billing month as April 2020 when the reservation purchase was made.\\n\\n        :param billing_account_id: BillingAccount ID. Required.\\n        :type billing_account_id: str\\n        :param billing_profile_id: Azure Billing Profile ID. Required.\\n        :type billing_profile_id: str\\n        :param filter: Filter reservation transactions by date range. The properties/EventDate for\\n         start date and end date. The filter supports 'le' and  'ge'. Note: API returns data for the\\n         entire start date's and end date's billing month. For example, filter\\n         properties/eventDate+ge+2020-01-01+AND+properties/eventDate+le+2020-12-29 will include data for\\n         entire December 2020 month (i.e. will contain records for dates December 30 and 31). Default\\n         value is None.\\n        :type filter: str\\n        :keyword callable cls: A custom type or function that will be passed the direct response\\n        :return: An iterator like instance of either ModernReservationTransaction or the result of\\n         cls(response)\\n        :rtype:\\n         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.consumption.models.ModernReservationTransaction]\\n        :raises ~azure.core.exceptions.HttpResponseError:\\n        \"\n    _headers = kwargs.pop('headers', {}) or {}\n    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})\n    api_version: Literal['2021-10-01'] = kwargs.pop('api_version', _params.pop('api-version', self._config.api_version))\n    cls: ClsType[_models.ModernReservationTransactionsListResult] = kwargs.pop('cls', None)\n    error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}\n    error_map.update(kwargs.pop('error_map', {}) or {})\n\n    def prepare_request(next_link=None):\n        if not next_link:\n            request = build_list_by_billing_profile_request(billing_account_id=billing_account_id, billing_profile_id=billing_profile_id, filter=filter, api_version=api_version, template_url=self.list_by_billing_profile.metadata['url'], headers=_headers, params=_params)\n            request = _convert_request(request)\n            request.url = self._client.format_url(request.url)\n        else:\n            _parsed_next_link = urllib.parse.urlparse(next_link)\n            _next_request_params = case_insensitive_dict({key: [urllib.parse.quote(v) for v in value] for (key, value) in urllib.parse.parse_qs(_parsed_next_link.query).items()})\n            _next_request_params['api-version'] = self._config.api_version\n            request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)\n            request = _convert_request(request)\n            request.url = self._client.format_url(request.url)\n            request.method = 'GET'\n        return request\n\n    async def extract_data(pipeline_response):\n        deserialized = self._deserialize('ModernReservationTransactionsListResult', pipeline_response)\n        list_of_elem = deserialized.value\n        if cls:\n            list_of_elem = cls(list_of_elem)\n        return (deserialized.next_link or None, AsyncList(list_of_elem))\n\n    async def get_next(next_link=None):\n        request = prepare_request(next_link)\n        pipeline_response: PipelineResponse = await self._client._pipeline.run(request, stream=False, **kwargs)\n        response = pipeline_response.http_response\n        if response.status_code not in [200]:\n            map_error(status_code=response.status_code, response=response, error_map=error_map)\n            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)\n            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)\n        return pipeline_response\n    return AsyncItemPaged(get_next, extract_data)",
            "@distributed_trace\ndef list_by_billing_profile(self, billing_account_id: str, billing_profile_id: str, filter: Optional[str]=None, **kwargs: Any) -> AsyncIterable['_models.ModernReservationTransaction']:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"List of transactions for reserved instances on billing profile scope. The refund transactions\\n        are posted along with its purchase transaction (i.e. in the purchase billing month). For\\n        example, The refund is requested in May 2021. This refund transaction will have event date as\\n        May 2021 but the billing month as April 2020 when the reservation purchase was made.\\n\\n        :param billing_account_id: BillingAccount ID. Required.\\n        :type billing_account_id: str\\n        :param billing_profile_id: Azure Billing Profile ID. Required.\\n        :type billing_profile_id: str\\n        :param filter: Filter reservation transactions by date range. The properties/EventDate for\\n         start date and end date. The filter supports 'le' and  'ge'. Note: API returns data for the\\n         entire start date's and end date's billing month. For example, filter\\n         properties/eventDate+ge+2020-01-01+AND+properties/eventDate+le+2020-12-29 will include data for\\n         entire December 2020 month (i.e. will contain records for dates December 30 and 31). Default\\n         value is None.\\n        :type filter: str\\n        :keyword callable cls: A custom type or function that will be passed the direct response\\n        :return: An iterator like instance of either ModernReservationTransaction or the result of\\n         cls(response)\\n        :rtype:\\n         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.consumption.models.ModernReservationTransaction]\\n        :raises ~azure.core.exceptions.HttpResponseError:\\n        \"\n    _headers = kwargs.pop('headers', {}) or {}\n    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})\n    api_version: Literal['2021-10-01'] = kwargs.pop('api_version', _params.pop('api-version', self._config.api_version))\n    cls: ClsType[_models.ModernReservationTransactionsListResult] = kwargs.pop('cls', None)\n    error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}\n    error_map.update(kwargs.pop('error_map', {}) or {})\n\n    def prepare_request(next_link=None):\n        if not next_link:\n            request = build_list_by_billing_profile_request(billing_account_id=billing_account_id, billing_profile_id=billing_profile_id, filter=filter, api_version=api_version, template_url=self.list_by_billing_profile.metadata['url'], headers=_headers, params=_params)\n            request = _convert_request(request)\n            request.url = self._client.format_url(request.url)\n        else:\n            _parsed_next_link = urllib.parse.urlparse(next_link)\n            _next_request_params = case_insensitive_dict({key: [urllib.parse.quote(v) for v in value] for (key, value) in urllib.parse.parse_qs(_parsed_next_link.query).items()})\n            _next_request_params['api-version'] = self._config.api_version\n            request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)\n            request = _convert_request(request)\n            request.url = self._client.format_url(request.url)\n            request.method = 'GET'\n        return request\n\n    async def extract_data(pipeline_response):\n        deserialized = self._deserialize('ModernReservationTransactionsListResult', pipeline_response)\n        list_of_elem = deserialized.value\n        if cls:\n            list_of_elem = cls(list_of_elem)\n        return (deserialized.next_link or None, AsyncList(list_of_elem))\n\n    async def get_next(next_link=None):\n        request = prepare_request(next_link)\n        pipeline_response: PipelineResponse = await self._client._pipeline.run(request, stream=False, **kwargs)\n        response = pipeline_response.http_response\n        if response.status_code not in [200]:\n            map_error(status_code=response.status_code, response=response, error_map=error_map)\n            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)\n            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)\n        return pipeline_response\n    return AsyncItemPaged(get_next, extract_data)",
            "@distributed_trace\ndef list_by_billing_profile(self, billing_account_id: str, billing_profile_id: str, filter: Optional[str]=None, **kwargs: Any) -> AsyncIterable['_models.ModernReservationTransaction']:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"List of transactions for reserved instances on billing profile scope. The refund transactions\\n        are posted along with its purchase transaction (i.e. in the purchase billing month). For\\n        example, The refund is requested in May 2021. This refund transaction will have event date as\\n        May 2021 but the billing month as April 2020 when the reservation purchase was made.\\n\\n        :param billing_account_id: BillingAccount ID. Required.\\n        :type billing_account_id: str\\n        :param billing_profile_id: Azure Billing Profile ID. Required.\\n        :type billing_profile_id: str\\n        :param filter: Filter reservation transactions by date range. The properties/EventDate for\\n         start date and end date. The filter supports 'le' and  'ge'. Note: API returns data for the\\n         entire start date's and end date's billing month. For example, filter\\n         properties/eventDate+ge+2020-01-01+AND+properties/eventDate+le+2020-12-29 will include data for\\n         entire December 2020 month (i.e. will contain records for dates December 30 and 31). Default\\n         value is None.\\n        :type filter: str\\n        :keyword callable cls: A custom type or function that will be passed the direct response\\n        :return: An iterator like instance of either ModernReservationTransaction or the result of\\n         cls(response)\\n        :rtype:\\n         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.consumption.models.ModernReservationTransaction]\\n        :raises ~azure.core.exceptions.HttpResponseError:\\n        \"\n    _headers = kwargs.pop('headers', {}) or {}\n    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})\n    api_version: Literal['2021-10-01'] = kwargs.pop('api_version', _params.pop('api-version', self._config.api_version))\n    cls: ClsType[_models.ModernReservationTransactionsListResult] = kwargs.pop('cls', None)\n    error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}\n    error_map.update(kwargs.pop('error_map', {}) or {})\n\n    def prepare_request(next_link=None):\n        if not next_link:\n            request = build_list_by_billing_profile_request(billing_account_id=billing_account_id, billing_profile_id=billing_profile_id, filter=filter, api_version=api_version, template_url=self.list_by_billing_profile.metadata['url'], headers=_headers, params=_params)\n            request = _convert_request(request)\n            request.url = self._client.format_url(request.url)\n        else:\n            _parsed_next_link = urllib.parse.urlparse(next_link)\n            _next_request_params = case_insensitive_dict({key: [urllib.parse.quote(v) for v in value] for (key, value) in urllib.parse.parse_qs(_parsed_next_link.query).items()})\n            _next_request_params['api-version'] = self._config.api_version\n            request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)\n            request = _convert_request(request)\n            request.url = self._client.format_url(request.url)\n            request.method = 'GET'\n        return request\n\n    async def extract_data(pipeline_response):\n        deserialized = self._deserialize('ModernReservationTransactionsListResult', pipeline_response)\n        list_of_elem = deserialized.value\n        if cls:\n            list_of_elem = cls(list_of_elem)\n        return (deserialized.next_link or None, AsyncList(list_of_elem))\n\n    async def get_next(next_link=None):\n        request = prepare_request(next_link)\n        pipeline_response: PipelineResponse = await self._client._pipeline.run(request, stream=False, **kwargs)\n        response = pipeline_response.http_response\n        if response.status_code not in [200]:\n            map_error(status_code=response.status_code, response=response, error_map=error_map)\n            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)\n            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)\n        return pipeline_response\n    return AsyncItemPaged(get_next, extract_data)",
            "@distributed_trace\ndef list_by_billing_profile(self, billing_account_id: str, billing_profile_id: str, filter: Optional[str]=None, **kwargs: Any) -> AsyncIterable['_models.ModernReservationTransaction']:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"List of transactions for reserved instances on billing profile scope. The refund transactions\\n        are posted along with its purchase transaction (i.e. in the purchase billing month). For\\n        example, The refund is requested in May 2021. This refund transaction will have event date as\\n        May 2021 but the billing month as April 2020 when the reservation purchase was made.\\n\\n        :param billing_account_id: BillingAccount ID. Required.\\n        :type billing_account_id: str\\n        :param billing_profile_id: Azure Billing Profile ID. Required.\\n        :type billing_profile_id: str\\n        :param filter: Filter reservation transactions by date range. The properties/EventDate for\\n         start date and end date. The filter supports 'le' and  'ge'. Note: API returns data for the\\n         entire start date's and end date's billing month. For example, filter\\n         properties/eventDate+ge+2020-01-01+AND+properties/eventDate+le+2020-12-29 will include data for\\n         entire December 2020 month (i.e. will contain records for dates December 30 and 31). Default\\n         value is None.\\n        :type filter: str\\n        :keyword callable cls: A custom type or function that will be passed the direct response\\n        :return: An iterator like instance of either ModernReservationTransaction or the result of\\n         cls(response)\\n        :rtype:\\n         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.consumption.models.ModernReservationTransaction]\\n        :raises ~azure.core.exceptions.HttpResponseError:\\n        \"\n    _headers = kwargs.pop('headers', {}) or {}\n    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})\n    api_version: Literal['2021-10-01'] = kwargs.pop('api_version', _params.pop('api-version', self._config.api_version))\n    cls: ClsType[_models.ModernReservationTransactionsListResult] = kwargs.pop('cls', None)\n    error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}\n    error_map.update(kwargs.pop('error_map', {}) or {})\n\n    def prepare_request(next_link=None):\n        if not next_link:\n            request = build_list_by_billing_profile_request(billing_account_id=billing_account_id, billing_profile_id=billing_profile_id, filter=filter, api_version=api_version, template_url=self.list_by_billing_profile.metadata['url'], headers=_headers, params=_params)\n            request = _convert_request(request)\n            request.url = self._client.format_url(request.url)\n        else:\n            _parsed_next_link = urllib.parse.urlparse(next_link)\n            _next_request_params = case_insensitive_dict({key: [urllib.parse.quote(v) for v in value] for (key, value) in urllib.parse.parse_qs(_parsed_next_link.query).items()})\n            _next_request_params['api-version'] = self._config.api_version\n            request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)\n            request = _convert_request(request)\n            request.url = self._client.format_url(request.url)\n            request.method = 'GET'\n        return request\n\n    async def extract_data(pipeline_response):\n        deserialized = self._deserialize('ModernReservationTransactionsListResult', pipeline_response)\n        list_of_elem = deserialized.value\n        if cls:\n            list_of_elem = cls(list_of_elem)\n        return (deserialized.next_link or None, AsyncList(list_of_elem))\n\n    async def get_next(next_link=None):\n        request = prepare_request(next_link)\n        pipeline_response: PipelineResponse = await self._client._pipeline.run(request, stream=False, **kwargs)\n        response = pipeline_response.http_response\n        if response.status_code not in [200]:\n            map_error(status_code=response.status_code, response=response, error_map=error_map)\n            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)\n            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)\n        return pipeline_response\n    return AsyncItemPaged(get_next, extract_data)"
        ]
    }
]