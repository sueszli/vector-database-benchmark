[
    {
        "func_name": "rate_limit_events",
        "original": "def rate_limit_events(request: Request, organization_slug=None, *args, **kwargs) -> RateLimitConfig:\n    try:\n        organization = Organization.objects.get_from_cache(slug=organization_slug)\n    except Organization.DoesNotExist:\n        return DEFAULT_EVENTS_RATE_LIMIT_CONFIG\n    if features.has('organizations:discover-events-rate-limit', organization, actor=request.user):\n        return {'GET': {RateLimitCategory.IP: RateLimit(RATE_LIMIT, RATE_LIMIT_WINDOW, CONCURRENT_RATE_LIMIT), RateLimitCategory.USER: RateLimit(RATE_LIMIT, RATE_LIMIT_WINDOW, CONCURRENT_RATE_LIMIT), RateLimitCategory.ORGANIZATION: RateLimit(RATE_LIMIT, RATE_LIMIT_WINDOW, CONCURRENT_RATE_LIMIT)}}\n    return DEFAULT_EVENTS_RATE_LIMIT_CONFIG",
        "mutated": [
            "def rate_limit_events(request: Request, organization_slug=None, *args, **kwargs) -> RateLimitConfig:\n    if False:\n        i = 10\n    try:\n        organization = Organization.objects.get_from_cache(slug=organization_slug)\n    except Organization.DoesNotExist:\n        return DEFAULT_EVENTS_RATE_LIMIT_CONFIG\n    if features.has('organizations:discover-events-rate-limit', organization, actor=request.user):\n        return {'GET': {RateLimitCategory.IP: RateLimit(RATE_LIMIT, RATE_LIMIT_WINDOW, CONCURRENT_RATE_LIMIT), RateLimitCategory.USER: RateLimit(RATE_LIMIT, RATE_LIMIT_WINDOW, CONCURRENT_RATE_LIMIT), RateLimitCategory.ORGANIZATION: RateLimit(RATE_LIMIT, RATE_LIMIT_WINDOW, CONCURRENT_RATE_LIMIT)}}\n    return DEFAULT_EVENTS_RATE_LIMIT_CONFIG",
            "def rate_limit_events(request: Request, organization_slug=None, *args, **kwargs) -> RateLimitConfig:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        organization = Organization.objects.get_from_cache(slug=organization_slug)\n    except Organization.DoesNotExist:\n        return DEFAULT_EVENTS_RATE_LIMIT_CONFIG\n    if features.has('organizations:discover-events-rate-limit', organization, actor=request.user):\n        return {'GET': {RateLimitCategory.IP: RateLimit(RATE_LIMIT, RATE_LIMIT_WINDOW, CONCURRENT_RATE_LIMIT), RateLimitCategory.USER: RateLimit(RATE_LIMIT, RATE_LIMIT_WINDOW, CONCURRENT_RATE_LIMIT), RateLimitCategory.ORGANIZATION: RateLimit(RATE_LIMIT, RATE_LIMIT_WINDOW, CONCURRENT_RATE_LIMIT)}}\n    return DEFAULT_EVENTS_RATE_LIMIT_CONFIG",
            "def rate_limit_events(request: Request, organization_slug=None, *args, **kwargs) -> RateLimitConfig:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        organization = Organization.objects.get_from_cache(slug=organization_slug)\n    except Organization.DoesNotExist:\n        return DEFAULT_EVENTS_RATE_LIMIT_CONFIG\n    if features.has('organizations:discover-events-rate-limit', organization, actor=request.user):\n        return {'GET': {RateLimitCategory.IP: RateLimit(RATE_LIMIT, RATE_LIMIT_WINDOW, CONCURRENT_RATE_LIMIT), RateLimitCategory.USER: RateLimit(RATE_LIMIT, RATE_LIMIT_WINDOW, CONCURRENT_RATE_LIMIT), RateLimitCategory.ORGANIZATION: RateLimit(RATE_LIMIT, RATE_LIMIT_WINDOW, CONCURRENT_RATE_LIMIT)}}\n    return DEFAULT_EVENTS_RATE_LIMIT_CONFIG",
            "def rate_limit_events(request: Request, organization_slug=None, *args, **kwargs) -> RateLimitConfig:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        organization = Organization.objects.get_from_cache(slug=organization_slug)\n    except Organization.DoesNotExist:\n        return DEFAULT_EVENTS_RATE_LIMIT_CONFIG\n    if features.has('organizations:discover-events-rate-limit', organization, actor=request.user):\n        return {'GET': {RateLimitCategory.IP: RateLimit(RATE_LIMIT, RATE_LIMIT_WINDOW, CONCURRENT_RATE_LIMIT), RateLimitCategory.USER: RateLimit(RATE_LIMIT, RATE_LIMIT_WINDOW, CONCURRENT_RATE_LIMIT), RateLimitCategory.ORGANIZATION: RateLimit(RATE_LIMIT, RATE_LIMIT_WINDOW, CONCURRENT_RATE_LIMIT)}}\n    return DEFAULT_EVENTS_RATE_LIMIT_CONFIG",
            "def rate_limit_events(request: Request, organization_slug=None, *args, **kwargs) -> RateLimitConfig:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        organization = Organization.objects.get_from_cache(slug=organization_slug)\n    except Organization.DoesNotExist:\n        return DEFAULT_EVENTS_RATE_LIMIT_CONFIG\n    if features.has('organizations:discover-events-rate-limit', organization, actor=request.user):\n        return {'GET': {RateLimitCategory.IP: RateLimit(RATE_LIMIT, RATE_LIMIT_WINDOW, CONCURRENT_RATE_LIMIT), RateLimitCategory.USER: RateLimit(RATE_LIMIT, RATE_LIMIT_WINDOW, CONCURRENT_RATE_LIMIT), RateLimitCategory.ORGANIZATION: RateLimit(RATE_LIMIT, RATE_LIMIT_WINDOW, CONCURRENT_RATE_LIMIT)}}\n    return DEFAULT_EVENTS_RATE_LIMIT_CONFIG"
        ]
    },
    {
        "func_name": "rate_limits",
        "original": "def rate_limits(*args, **kwargs) -> RateLimitConfig:\n    return rate_limit_events(*args, **kwargs)",
        "mutated": [
            "def rate_limits(*args, **kwargs) -> RateLimitConfig:\n    if False:\n        i = 10\n    return rate_limit_events(*args, **kwargs)",
            "def rate_limits(*args, **kwargs) -> RateLimitConfig:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return rate_limit_events(*args, **kwargs)",
            "def rate_limits(*args, **kwargs) -> RateLimitConfig:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return rate_limit_events(*args, **kwargs)",
            "def rate_limits(*args, **kwargs) -> RateLimitConfig:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return rate_limit_events(*args, **kwargs)",
            "def rate_limits(*args, **kwargs) -> RateLimitConfig:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return rate_limit_events(*args, **kwargs)"
        ]
    },
    {
        "func_name": "get_features",
        "original": "def get_features(self, organization: Organization, request: Request) -> Mapping[str, bool]:\n    feature_names = ['organizations:dashboards-mep', 'organizations:mep-rollout-flag', 'organizations:performance-use-metrics', 'organizations:profiling', 'organizations:dynamic-sampling', 'organizations:use-metrics-layer', 'organizations:starfish-view', 'organizations:on-demand-metrics-extraction', 'organizations:on-demand-metrics-extraction-experimental']\n    batch_features = features.batch_has(feature_names, organization=organization, actor=request.user)\n    all_features = batch_features.get(f'organization:{organization.id}', {}) if batch_features is not None else {}\n    for feature_name in feature_names:\n        if feature_name not in all_features:\n            all_features[feature_name] = features.has(feature_name, organization=organization, actor=request.user)\n    return all_features",
        "mutated": [
            "def get_features(self, organization: Organization, request: Request) -> Mapping[str, bool]:\n    if False:\n        i = 10\n    feature_names = ['organizations:dashboards-mep', 'organizations:mep-rollout-flag', 'organizations:performance-use-metrics', 'organizations:profiling', 'organizations:dynamic-sampling', 'organizations:use-metrics-layer', 'organizations:starfish-view', 'organizations:on-demand-metrics-extraction', 'organizations:on-demand-metrics-extraction-experimental']\n    batch_features = features.batch_has(feature_names, organization=organization, actor=request.user)\n    all_features = batch_features.get(f'organization:{organization.id}', {}) if batch_features is not None else {}\n    for feature_name in feature_names:\n        if feature_name not in all_features:\n            all_features[feature_name] = features.has(feature_name, organization=organization, actor=request.user)\n    return all_features",
            "def get_features(self, organization: Organization, request: Request) -> Mapping[str, bool]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    feature_names = ['organizations:dashboards-mep', 'organizations:mep-rollout-flag', 'organizations:performance-use-metrics', 'organizations:profiling', 'organizations:dynamic-sampling', 'organizations:use-metrics-layer', 'organizations:starfish-view', 'organizations:on-demand-metrics-extraction', 'organizations:on-demand-metrics-extraction-experimental']\n    batch_features = features.batch_has(feature_names, organization=organization, actor=request.user)\n    all_features = batch_features.get(f'organization:{organization.id}', {}) if batch_features is not None else {}\n    for feature_name in feature_names:\n        if feature_name not in all_features:\n            all_features[feature_name] = features.has(feature_name, organization=organization, actor=request.user)\n    return all_features",
            "def get_features(self, organization: Organization, request: Request) -> Mapping[str, bool]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    feature_names = ['organizations:dashboards-mep', 'organizations:mep-rollout-flag', 'organizations:performance-use-metrics', 'organizations:profiling', 'organizations:dynamic-sampling', 'organizations:use-metrics-layer', 'organizations:starfish-view', 'organizations:on-demand-metrics-extraction', 'organizations:on-demand-metrics-extraction-experimental']\n    batch_features = features.batch_has(feature_names, organization=organization, actor=request.user)\n    all_features = batch_features.get(f'organization:{organization.id}', {}) if batch_features is not None else {}\n    for feature_name in feature_names:\n        if feature_name not in all_features:\n            all_features[feature_name] = features.has(feature_name, organization=organization, actor=request.user)\n    return all_features",
            "def get_features(self, organization: Organization, request: Request) -> Mapping[str, bool]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    feature_names = ['organizations:dashboards-mep', 'organizations:mep-rollout-flag', 'organizations:performance-use-metrics', 'organizations:profiling', 'organizations:dynamic-sampling', 'organizations:use-metrics-layer', 'organizations:starfish-view', 'organizations:on-demand-metrics-extraction', 'organizations:on-demand-metrics-extraction-experimental']\n    batch_features = features.batch_has(feature_names, organization=organization, actor=request.user)\n    all_features = batch_features.get(f'organization:{organization.id}', {}) if batch_features is not None else {}\n    for feature_name in feature_names:\n        if feature_name not in all_features:\n            all_features[feature_name] = features.has(feature_name, organization=organization, actor=request.user)\n    return all_features",
            "def get_features(self, organization: Organization, request: Request) -> Mapping[str, bool]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    feature_names = ['organizations:dashboards-mep', 'organizations:mep-rollout-flag', 'organizations:performance-use-metrics', 'organizations:profiling', 'organizations:dynamic-sampling', 'organizations:use-metrics-layer', 'organizations:starfish-view', 'organizations:on-demand-metrics-extraction', 'organizations:on-demand-metrics-extraction-experimental']\n    batch_features = features.batch_has(feature_names, organization=organization, actor=request.user)\n    all_features = batch_features.get(f'organization:{organization.id}', {}) if batch_features is not None else {}\n    for feature_name in feature_names:\n        if feature_name not in all_features:\n            all_features[feature_name] = features.has(feature_name, organization=organization, actor=request.user)\n    return all_features"
        ]
    },
    {
        "func_name": "data_fn",
        "original": "def data_fn(offset, limit):\n    return dataset.query(selected_columns=self.get_field_list(organization, request), query=request.GET.get('query'), params=params, snuba_params=snuba_params, equations=self.get_equation_list(organization, request), orderby=self.get_orderby(request), offset=offset, limit=limit, referrer=referrer, auto_fields=True, auto_aggregations=True, use_aggregate_conditions=True, allow_metric_aggregates=allow_metric_aggregates, transform_alias_to_input_format=True, has_metrics=use_metrics, use_metrics_layer=batch_features.get('organizations:use-metrics-layer', False), on_demand_metrics_enabled=on_demand_metrics_enabled, on_demand_metrics_type=on_demand_metrics_type)",
        "mutated": [
            "def data_fn(offset, limit):\n    if False:\n        i = 10\n    return dataset.query(selected_columns=self.get_field_list(organization, request), query=request.GET.get('query'), params=params, snuba_params=snuba_params, equations=self.get_equation_list(organization, request), orderby=self.get_orderby(request), offset=offset, limit=limit, referrer=referrer, auto_fields=True, auto_aggregations=True, use_aggregate_conditions=True, allow_metric_aggregates=allow_metric_aggregates, transform_alias_to_input_format=True, has_metrics=use_metrics, use_metrics_layer=batch_features.get('organizations:use-metrics-layer', False), on_demand_metrics_enabled=on_demand_metrics_enabled, on_demand_metrics_type=on_demand_metrics_type)",
            "def data_fn(offset, limit):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return dataset.query(selected_columns=self.get_field_list(organization, request), query=request.GET.get('query'), params=params, snuba_params=snuba_params, equations=self.get_equation_list(organization, request), orderby=self.get_orderby(request), offset=offset, limit=limit, referrer=referrer, auto_fields=True, auto_aggregations=True, use_aggregate_conditions=True, allow_metric_aggregates=allow_metric_aggregates, transform_alias_to_input_format=True, has_metrics=use_metrics, use_metrics_layer=batch_features.get('organizations:use-metrics-layer', False), on_demand_metrics_enabled=on_demand_metrics_enabled, on_demand_metrics_type=on_demand_metrics_type)",
            "def data_fn(offset, limit):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return dataset.query(selected_columns=self.get_field_list(organization, request), query=request.GET.get('query'), params=params, snuba_params=snuba_params, equations=self.get_equation_list(organization, request), orderby=self.get_orderby(request), offset=offset, limit=limit, referrer=referrer, auto_fields=True, auto_aggregations=True, use_aggregate_conditions=True, allow_metric_aggregates=allow_metric_aggregates, transform_alias_to_input_format=True, has_metrics=use_metrics, use_metrics_layer=batch_features.get('organizations:use-metrics-layer', False), on_demand_metrics_enabled=on_demand_metrics_enabled, on_demand_metrics_type=on_demand_metrics_type)",
            "def data_fn(offset, limit):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return dataset.query(selected_columns=self.get_field_list(organization, request), query=request.GET.get('query'), params=params, snuba_params=snuba_params, equations=self.get_equation_list(organization, request), orderby=self.get_orderby(request), offset=offset, limit=limit, referrer=referrer, auto_fields=True, auto_aggregations=True, use_aggregate_conditions=True, allow_metric_aggregates=allow_metric_aggregates, transform_alias_to_input_format=True, has_metrics=use_metrics, use_metrics_layer=batch_features.get('organizations:use-metrics-layer', False), on_demand_metrics_enabled=on_demand_metrics_enabled, on_demand_metrics_type=on_demand_metrics_type)",
            "def data_fn(offset, limit):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return dataset.query(selected_columns=self.get_field_list(organization, request), query=request.GET.get('query'), params=params, snuba_params=snuba_params, equations=self.get_equation_list(organization, request), orderby=self.get_orderby(request), offset=offset, limit=limit, referrer=referrer, auto_fields=True, auto_aggregations=True, use_aggregate_conditions=True, allow_metric_aggregates=allow_metric_aggregates, transform_alias_to_input_format=True, has_metrics=use_metrics, use_metrics_layer=batch_features.get('organizations:use-metrics-layer', False), on_demand_metrics_enabled=on_demand_metrics_enabled, on_demand_metrics_type=on_demand_metrics_type)"
        ]
    },
    {
        "func_name": "get",
        "original": "@extend_schema(operation_id='Query Discover Events in Table Format', parameters=[GlobalParams.END, GlobalParams.ENVIRONMENT, GlobalParams.ORG_SLUG, OrganizationParams.PROJECT, GlobalParams.START, GlobalParams.STATS_PERIOD, VisibilityParams.FIELD, VisibilityParams.PER_PAGE, VisibilityParams.QUERY, VisibilityParams.SORT], responses={200: inline_sentry_response_serializer('OrganizationEventsResponseDict', discover.EventsResponse), 400: OpenApiResponse(description='Invalid Query'), 404: api_constants.RESPONSE_NOT_FOUND}, examples=DiscoverAndPerformanceExamples.QUERY_DISCOVER_EVENTS)\ndef get(self, request: Request, organization) -> Response:\n    \"\"\"\n        Retrieves discover (also known as events) data for a given organization.\n\n        **Eventsv2 Deprecation Note**: Users who may be using the `eventsv2` endpoint should update their requests to the `events` endpoint outline in this document.\n        The `eventsv2` endpoint is not a public endpoint and has no guaranteed availability. If you are not making any API calls to `eventsv2`, you can safely ignore this.\n        Changes between `eventsv2` and `events` include:\n        - Field keys in the response now match the keys in the requested `field` param exactly.\n        - The `meta` object in the response now shows types in the nested `field` object.\n\n        Aside from the url change, there are no changes to the request payload itself.\n\n        **Note**: This endpoint is intended to get a table of results, and is not for doing a full export of data sent to\n        Sentry.\n\n        The `field` query parameter determines what fields will be selected in the `data` and `meta` keys of the endpoint response.\n        - The `data` key contains a list of results row by row that match the `query` made\n        - The `meta` key contains information about the response, including the unit or type of the fields requested\n        \"\"\"\n    if not self.has_feature(organization, request):\n        return Response(status=404)\n    try:\n        (snuba_params, params) = self.get_snuba_dataclass(request, organization)\n    except NoProjects:\n        return Response({'data': [], 'meta': {'tips': {'query': 'Need at least one valid project to query.'}}})\n    except InvalidParams as err:\n        raise ParseError(err)\n    referrer = request.GET.get('referrer')\n    batch_features = self.get_features(organization, request)\n    use_metrics = batch_features.get('organizations:mep-rollout-flag', False) and batch_features.get('organizations:dynamic-sampling', False) or batch_features.get('organizations:performance-use-metrics', False) or batch_features.get('organizations:dashboards-mep', False)\n    try:\n        (use_on_demand_metrics, on_demand_metrics_type) = self.handle_on_demand(request)\n    except ValueError:\n        metric_type_values = [e.value for e in MetricSpecType]\n        metric_types = ','.join(metric_type_values)\n        return Response({'detail': f'On demand metric type must be one of: {metric_types}'}, status=400)\n    on_demand_metrics_enabled = batch_features.get('organizations:on-demand-metrics-extraction', False) and use_on_demand_metrics\n    dataset = self.get_dataset(request)\n    metrics_enhanced = dataset in {metrics_performance, metrics_enhanced_performance}\n    sentry_sdk.set_tag('performance.metrics_enhanced', metrics_enhanced)\n    allow_metric_aggregates = request.GET.get('preventMetricAggregates') != '1'\n    if request.auth:\n        referrer = API_TOKEN_REFERRER\n    elif referrer not in ALLOWED_EVENTS_REFERRERS:\n        referrer = Referrer.API_ORGANIZATION_EVENTS.value\n\n    def data_fn(offset, limit):\n        return dataset.query(selected_columns=self.get_field_list(organization, request), query=request.GET.get('query'), params=params, snuba_params=snuba_params, equations=self.get_equation_list(organization, request), orderby=self.get_orderby(request), offset=offset, limit=limit, referrer=referrer, auto_fields=True, auto_aggregations=True, use_aggregate_conditions=True, allow_metric_aggregates=allow_metric_aggregates, transform_alias_to_input_format=True, has_metrics=use_metrics, use_metrics_layer=batch_features.get('organizations:use-metrics-layer', False), on_demand_metrics_enabled=on_demand_metrics_enabled, on_demand_metrics_type=on_demand_metrics_type)\n    with self.handle_query_errors():\n        if request.GET.get('noPagination'):\n            return Response(self.handle_results_with_meta(request, organization, params['project_id'], data_fn(0, self.get_per_page(request)), standard_meta=True, dataset=dataset))\n        else:\n            return self.paginate(request=request, paginator=GenericOffsetPaginator(data_fn=data_fn), on_results=lambda results: self.handle_results_with_meta(request, organization, params['project_id'], results, standard_meta=True, dataset=dataset))",
        "mutated": [
            "@extend_schema(operation_id='Query Discover Events in Table Format', parameters=[GlobalParams.END, GlobalParams.ENVIRONMENT, GlobalParams.ORG_SLUG, OrganizationParams.PROJECT, GlobalParams.START, GlobalParams.STATS_PERIOD, VisibilityParams.FIELD, VisibilityParams.PER_PAGE, VisibilityParams.QUERY, VisibilityParams.SORT], responses={200: inline_sentry_response_serializer('OrganizationEventsResponseDict', discover.EventsResponse), 400: OpenApiResponse(description='Invalid Query'), 404: api_constants.RESPONSE_NOT_FOUND}, examples=DiscoverAndPerformanceExamples.QUERY_DISCOVER_EVENTS)\ndef get(self, request: Request, organization) -> Response:\n    if False:\n        i = 10\n    '\\n        Retrieves discover (also known as events) data for a given organization.\\n\\n        **Eventsv2 Deprecation Note**: Users who may be using the `eventsv2` endpoint should update their requests to the `events` endpoint outline in this document.\\n        The `eventsv2` endpoint is not a public endpoint and has no guaranteed availability. If you are not making any API calls to `eventsv2`, you can safely ignore this.\\n        Changes between `eventsv2` and `events` include:\\n        - Field keys in the response now match the keys in the requested `field` param exactly.\\n        - The `meta` object in the response now shows types in the nested `field` object.\\n\\n        Aside from the url change, there are no changes to the request payload itself.\\n\\n        **Note**: This endpoint is intended to get a table of results, and is not for doing a full export of data sent to\\n        Sentry.\\n\\n        The `field` query parameter determines what fields will be selected in the `data` and `meta` keys of the endpoint response.\\n        - The `data` key contains a list of results row by row that match the `query` made\\n        - The `meta` key contains information about the response, including the unit or type of the fields requested\\n        '\n    if not self.has_feature(organization, request):\n        return Response(status=404)\n    try:\n        (snuba_params, params) = self.get_snuba_dataclass(request, organization)\n    except NoProjects:\n        return Response({'data': [], 'meta': {'tips': {'query': 'Need at least one valid project to query.'}}})\n    except InvalidParams as err:\n        raise ParseError(err)\n    referrer = request.GET.get('referrer')\n    batch_features = self.get_features(organization, request)\n    use_metrics = batch_features.get('organizations:mep-rollout-flag', False) and batch_features.get('organizations:dynamic-sampling', False) or batch_features.get('organizations:performance-use-metrics', False) or batch_features.get('organizations:dashboards-mep', False)\n    try:\n        (use_on_demand_metrics, on_demand_metrics_type) = self.handle_on_demand(request)\n    except ValueError:\n        metric_type_values = [e.value for e in MetricSpecType]\n        metric_types = ','.join(metric_type_values)\n        return Response({'detail': f'On demand metric type must be one of: {metric_types}'}, status=400)\n    on_demand_metrics_enabled = batch_features.get('organizations:on-demand-metrics-extraction', False) and use_on_demand_metrics\n    dataset = self.get_dataset(request)\n    metrics_enhanced = dataset in {metrics_performance, metrics_enhanced_performance}\n    sentry_sdk.set_tag('performance.metrics_enhanced', metrics_enhanced)\n    allow_metric_aggregates = request.GET.get('preventMetricAggregates') != '1'\n    if request.auth:\n        referrer = API_TOKEN_REFERRER\n    elif referrer not in ALLOWED_EVENTS_REFERRERS:\n        referrer = Referrer.API_ORGANIZATION_EVENTS.value\n\n    def data_fn(offset, limit):\n        return dataset.query(selected_columns=self.get_field_list(organization, request), query=request.GET.get('query'), params=params, snuba_params=snuba_params, equations=self.get_equation_list(organization, request), orderby=self.get_orderby(request), offset=offset, limit=limit, referrer=referrer, auto_fields=True, auto_aggregations=True, use_aggregate_conditions=True, allow_metric_aggregates=allow_metric_aggregates, transform_alias_to_input_format=True, has_metrics=use_metrics, use_metrics_layer=batch_features.get('organizations:use-metrics-layer', False), on_demand_metrics_enabled=on_demand_metrics_enabled, on_demand_metrics_type=on_demand_metrics_type)\n    with self.handle_query_errors():\n        if request.GET.get('noPagination'):\n            return Response(self.handle_results_with_meta(request, organization, params['project_id'], data_fn(0, self.get_per_page(request)), standard_meta=True, dataset=dataset))\n        else:\n            return self.paginate(request=request, paginator=GenericOffsetPaginator(data_fn=data_fn), on_results=lambda results: self.handle_results_with_meta(request, organization, params['project_id'], results, standard_meta=True, dataset=dataset))",
            "@extend_schema(operation_id='Query Discover Events in Table Format', parameters=[GlobalParams.END, GlobalParams.ENVIRONMENT, GlobalParams.ORG_SLUG, OrganizationParams.PROJECT, GlobalParams.START, GlobalParams.STATS_PERIOD, VisibilityParams.FIELD, VisibilityParams.PER_PAGE, VisibilityParams.QUERY, VisibilityParams.SORT], responses={200: inline_sentry_response_serializer('OrganizationEventsResponseDict', discover.EventsResponse), 400: OpenApiResponse(description='Invalid Query'), 404: api_constants.RESPONSE_NOT_FOUND}, examples=DiscoverAndPerformanceExamples.QUERY_DISCOVER_EVENTS)\ndef get(self, request: Request, organization) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Retrieves discover (also known as events) data for a given organization.\\n\\n        **Eventsv2 Deprecation Note**: Users who may be using the `eventsv2` endpoint should update their requests to the `events` endpoint outline in this document.\\n        The `eventsv2` endpoint is not a public endpoint and has no guaranteed availability. If you are not making any API calls to `eventsv2`, you can safely ignore this.\\n        Changes between `eventsv2` and `events` include:\\n        - Field keys in the response now match the keys in the requested `field` param exactly.\\n        - The `meta` object in the response now shows types in the nested `field` object.\\n\\n        Aside from the url change, there are no changes to the request payload itself.\\n\\n        **Note**: This endpoint is intended to get a table of results, and is not for doing a full export of data sent to\\n        Sentry.\\n\\n        The `field` query parameter determines what fields will be selected in the `data` and `meta` keys of the endpoint response.\\n        - The `data` key contains a list of results row by row that match the `query` made\\n        - The `meta` key contains information about the response, including the unit or type of the fields requested\\n        '\n    if not self.has_feature(organization, request):\n        return Response(status=404)\n    try:\n        (snuba_params, params) = self.get_snuba_dataclass(request, organization)\n    except NoProjects:\n        return Response({'data': [], 'meta': {'tips': {'query': 'Need at least one valid project to query.'}}})\n    except InvalidParams as err:\n        raise ParseError(err)\n    referrer = request.GET.get('referrer')\n    batch_features = self.get_features(organization, request)\n    use_metrics = batch_features.get('organizations:mep-rollout-flag', False) and batch_features.get('organizations:dynamic-sampling', False) or batch_features.get('organizations:performance-use-metrics', False) or batch_features.get('organizations:dashboards-mep', False)\n    try:\n        (use_on_demand_metrics, on_demand_metrics_type) = self.handle_on_demand(request)\n    except ValueError:\n        metric_type_values = [e.value for e in MetricSpecType]\n        metric_types = ','.join(metric_type_values)\n        return Response({'detail': f'On demand metric type must be one of: {metric_types}'}, status=400)\n    on_demand_metrics_enabled = batch_features.get('organizations:on-demand-metrics-extraction', False) and use_on_demand_metrics\n    dataset = self.get_dataset(request)\n    metrics_enhanced = dataset in {metrics_performance, metrics_enhanced_performance}\n    sentry_sdk.set_tag('performance.metrics_enhanced', metrics_enhanced)\n    allow_metric_aggregates = request.GET.get('preventMetricAggregates') != '1'\n    if request.auth:\n        referrer = API_TOKEN_REFERRER\n    elif referrer not in ALLOWED_EVENTS_REFERRERS:\n        referrer = Referrer.API_ORGANIZATION_EVENTS.value\n\n    def data_fn(offset, limit):\n        return dataset.query(selected_columns=self.get_field_list(organization, request), query=request.GET.get('query'), params=params, snuba_params=snuba_params, equations=self.get_equation_list(organization, request), orderby=self.get_orderby(request), offset=offset, limit=limit, referrer=referrer, auto_fields=True, auto_aggregations=True, use_aggregate_conditions=True, allow_metric_aggregates=allow_metric_aggregates, transform_alias_to_input_format=True, has_metrics=use_metrics, use_metrics_layer=batch_features.get('organizations:use-metrics-layer', False), on_demand_metrics_enabled=on_demand_metrics_enabled, on_demand_metrics_type=on_demand_metrics_type)\n    with self.handle_query_errors():\n        if request.GET.get('noPagination'):\n            return Response(self.handle_results_with_meta(request, organization, params['project_id'], data_fn(0, self.get_per_page(request)), standard_meta=True, dataset=dataset))\n        else:\n            return self.paginate(request=request, paginator=GenericOffsetPaginator(data_fn=data_fn), on_results=lambda results: self.handle_results_with_meta(request, organization, params['project_id'], results, standard_meta=True, dataset=dataset))",
            "@extend_schema(operation_id='Query Discover Events in Table Format', parameters=[GlobalParams.END, GlobalParams.ENVIRONMENT, GlobalParams.ORG_SLUG, OrganizationParams.PROJECT, GlobalParams.START, GlobalParams.STATS_PERIOD, VisibilityParams.FIELD, VisibilityParams.PER_PAGE, VisibilityParams.QUERY, VisibilityParams.SORT], responses={200: inline_sentry_response_serializer('OrganizationEventsResponseDict', discover.EventsResponse), 400: OpenApiResponse(description='Invalid Query'), 404: api_constants.RESPONSE_NOT_FOUND}, examples=DiscoverAndPerformanceExamples.QUERY_DISCOVER_EVENTS)\ndef get(self, request: Request, organization) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Retrieves discover (also known as events) data for a given organization.\\n\\n        **Eventsv2 Deprecation Note**: Users who may be using the `eventsv2` endpoint should update their requests to the `events` endpoint outline in this document.\\n        The `eventsv2` endpoint is not a public endpoint and has no guaranteed availability. If you are not making any API calls to `eventsv2`, you can safely ignore this.\\n        Changes between `eventsv2` and `events` include:\\n        - Field keys in the response now match the keys in the requested `field` param exactly.\\n        - The `meta` object in the response now shows types in the nested `field` object.\\n\\n        Aside from the url change, there are no changes to the request payload itself.\\n\\n        **Note**: This endpoint is intended to get a table of results, and is not for doing a full export of data sent to\\n        Sentry.\\n\\n        The `field` query parameter determines what fields will be selected in the `data` and `meta` keys of the endpoint response.\\n        - The `data` key contains a list of results row by row that match the `query` made\\n        - The `meta` key contains information about the response, including the unit or type of the fields requested\\n        '\n    if not self.has_feature(organization, request):\n        return Response(status=404)\n    try:\n        (snuba_params, params) = self.get_snuba_dataclass(request, organization)\n    except NoProjects:\n        return Response({'data': [], 'meta': {'tips': {'query': 'Need at least one valid project to query.'}}})\n    except InvalidParams as err:\n        raise ParseError(err)\n    referrer = request.GET.get('referrer')\n    batch_features = self.get_features(organization, request)\n    use_metrics = batch_features.get('organizations:mep-rollout-flag', False) and batch_features.get('organizations:dynamic-sampling', False) or batch_features.get('organizations:performance-use-metrics', False) or batch_features.get('organizations:dashboards-mep', False)\n    try:\n        (use_on_demand_metrics, on_demand_metrics_type) = self.handle_on_demand(request)\n    except ValueError:\n        metric_type_values = [e.value for e in MetricSpecType]\n        metric_types = ','.join(metric_type_values)\n        return Response({'detail': f'On demand metric type must be one of: {metric_types}'}, status=400)\n    on_demand_metrics_enabled = batch_features.get('organizations:on-demand-metrics-extraction', False) and use_on_demand_metrics\n    dataset = self.get_dataset(request)\n    metrics_enhanced = dataset in {metrics_performance, metrics_enhanced_performance}\n    sentry_sdk.set_tag('performance.metrics_enhanced', metrics_enhanced)\n    allow_metric_aggregates = request.GET.get('preventMetricAggregates') != '1'\n    if request.auth:\n        referrer = API_TOKEN_REFERRER\n    elif referrer not in ALLOWED_EVENTS_REFERRERS:\n        referrer = Referrer.API_ORGANIZATION_EVENTS.value\n\n    def data_fn(offset, limit):\n        return dataset.query(selected_columns=self.get_field_list(organization, request), query=request.GET.get('query'), params=params, snuba_params=snuba_params, equations=self.get_equation_list(organization, request), orderby=self.get_orderby(request), offset=offset, limit=limit, referrer=referrer, auto_fields=True, auto_aggregations=True, use_aggregate_conditions=True, allow_metric_aggregates=allow_metric_aggregates, transform_alias_to_input_format=True, has_metrics=use_metrics, use_metrics_layer=batch_features.get('organizations:use-metrics-layer', False), on_demand_metrics_enabled=on_demand_metrics_enabled, on_demand_metrics_type=on_demand_metrics_type)\n    with self.handle_query_errors():\n        if request.GET.get('noPagination'):\n            return Response(self.handle_results_with_meta(request, organization, params['project_id'], data_fn(0, self.get_per_page(request)), standard_meta=True, dataset=dataset))\n        else:\n            return self.paginate(request=request, paginator=GenericOffsetPaginator(data_fn=data_fn), on_results=lambda results: self.handle_results_with_meta(request, organization, params['project_id'], results, standard_meta=True, dataset=dataset))",
            "@extend_schema(operation_id='Query Discover Events in Table Format', parameters=[GlobalParams.END, GlobalParams.ENVIRONMENT, GlobalParams.ORG_SLUG, OrganizationParams.PROJECT, GlobalParams.START, GlobalParams.STATS_PERIOD, VisibilityParams.FIELD, VisibilityParams.PER_PAGE, VisibilityParams.QUERY, VisibilityParams.SORT], responses={200: inline_sentry_response_serializer('OrganizationEventsResponseDict', discover.EventsResponse), 400: OpenApiResponse(description='Invalid Query'), 404: api_constants.RESPONSE_NOT_FOUND}, examples=DiscoverAndPerformanceExamples.QUERY_DISCOVER_EVENTS)\ndef get(self, request: Request, organization) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Retrieves discover (also known as events) data for a given organization.\\n\\n        **Eventsv2 Deprecation Note**: Users who may be using the `eventsv2` endpoint should update their requests to the `events` endpoint outline in this document.\\n        The `eventsv2` endpoint is not a public endpoint and has no guaranteed availability. If you are not making any API calls to `eventsv2`, you can safely ignore this.\\n        Changes between `eventsv2` and `events` include:\\n        - Field keys in the response now match the keys in the requested `field` param exactly.\\n        - The `meta` object in the response now shows types in the nested `field` object.\\n\\n        Aside from the url change, there are no changes to the request payload itself.\\n\\n        **Note**: This endpoint is intended to get a table of results, and is not for doing a full export of data sent to\\n        Sentry.\\n\\n        The `field` query parameter determines what fields will be selected in the `data` and `meta` keys of the endpoint response.\\n        - The `data` key contains a list of results row by row that match the `query` made\\n        - The `meta` key contains information about the response, including the unit or type of the fields requested\\n        '\n    if not self.has_feature(organization, request):\n        return Response(status=404)\n    try:\n        (snuba_params, params) = self.get_snuba_dataclass(request, organization)\n    except NoProjects:\n        return Response({'data': [], 'meta': {'tips': {'query': 'Need at least one valid project to query.'}}})\n    except InvalidParams as err:\n        raise ParseError(err)\n    referrer = request.GET.get('referrer')\n    batch_features = self.get_features(organization, request)\n    use_metrics = batch_features.get('organizations:mep-rollout-flag', False) and batch_features.get('organizations:dynamic-sampling', False) or batch_features.get('organizations:performance-use-metrics', False) or batch_features.get('organizations:dashboards-mep', False)\n    try:\n        (use_on_demand_metrics, on_demand_metrics_type) = self.handle_on_demand(request)\n    except ValueError:\n        metric_type_values = [e.value for e in MetricSpecType]\n        metric_types = ','.join(metric_type_values)\n        return Response({'detail': f'On demand metric type must be one of: {metric_types}'}, status=400)\n    on_demand_metrics_enabled = batch_features.get('organizations:on-demand-metrics-extraction', False) and use_on_demand_metrics\n    dataset = self.get_dataset(request)\n    metrics_enhanced = dataset in {metrics_performance, metrics_enhanced_performance}\n    sentry_sdk.set_tag('performance.metrics_enhanced', metrics_enhanced)\n    allow_metric_aggregates = request.GET.get('preventMetricAggregates') != '1'\n    if request.auth:\n        referrer = API_TOKEN_REFERRER\n    elif referrer not in ALLOWED_EVENTS_REFERRERS:\n        referrer = Referrer.API_ORGANIZATION_EVENTS.value\n\n    def data_fn(offset, limit):\n        return dataset.query(selected_columns=self.get_field_list(organization, request), query=request.GET.get('query'), params=params, snuba_params=snuba_params, equations=self.get_equation_list(organization, request), orderby=self.get_orderby(request), offset=offset, limit=limit, referrer=referrer, auto_fields=True, auto_aggregations=True, use_aggregate_conditions=True, allow_metric_aggregates=allow_metric_aggregates, transform_alias_to_input_format=True, has_metrics=use_metrics, use_metrics_layer=batch_features.get('organizations:use-metrics-layer', False), on_demand_metrics_enabled=on_demand_metrics_enabled, on_demand_metrics_type=on_demand_metrics_type)\n    with self.handle_query_errors():\n        if request.GET.get('noPagination'):\n            return Response(self.handle_results_with_meta(request, organization, params['project_id'], data_fn(0, self.get_per_page(request)), standard_meta=True, dataset=dataset))\n        else:\n            return self.paginate(request=request, paginator=GenericOffsetPaginator(data_fn=data_fn), on_results=lambda results: self.handle_results_with_meta(request, organization, params['project_id'], results, standard_meta=True, dataset=dataset))",
            "@extend_schema(operation_id='Query Discover Events in Table Format', parameters=[GlobalParams.END, GlobalParams.ENVIRONMENT, GlobalParams.ORG_SLUG, OrganizationParams.PROJECT, GlobalParams.START, GlobalParams.STATS_PERIOD, VisibilityParams.FIELD, VisibilityParams.PER_PAGE, VisibilityParams.QUERY, VisibilityParams.SORT], responses={200: inline_sentry_response_serializer('OrganizationEventsResponseDict', discover.EventsResponse), 400: OpenApiResponse(description='Invalid Query'), 404: api_constants.RESPONSE_NOT_FOUND}, examples=DiscoverAndPerformanceExamples.QUERY_DISCOVER_EVENTS)\ndef get(self, request: Request, organization) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Retrieves discover (also known as events) data for a given organization.\\n\\n        **Eventsv2 Deprecation Note**: Users who may be using the `eventsv2` endpoint should update their requests to the `events` endpoint outline in this document.\\n        The `eventsv2` endpoint is not a public endpoint and has no guaranteed availability. If you are not making any API calls to `eventsv2`, you can safely ignore this.\\n        Changes between `eventsv2` and `events` include:\\n        - Field keys in the response now match the keys in the requested `field` param exactly.\\n        - The `meta` object in the response now shows types in the nested `field` object.\\n\\n        Aside from the url change, there are no changes to the request payload itself.\\n\\n        **Note**: This endpoint is intended to get a table of results, and is not for doing a full export of data sent to\\n        Sentry.\\n\\n        The `field` query parameter determines what fields will be selected in the `data` and `meta` keys of the endpoint response.\\n        - The `data` key contains a list of results row by row that match the `query` made\\n        - The `meta` key contains information about the response, including the unit or type of the fields requested\\n        '\n    if not self.has_feature(organization, request):\n        return Response(status=404)\n    try:\n        (snuba_params, params) = self.get_snuba_dataclass(request, organization)\n    except NoProjects:\n        return Response({'data': [], 'meta': {'tips': {'query': 'Need at least one valid project to query.'}}})\n    except InvalidParams as err:\n        raise ParseError(err)\n    referrer = request.GET.get('referrer')\n    batch_features = self.get_features(organization, request)\n    use_metrics = batch_features.get('organizations:mep-rollout-flag', False) and batch_features.get('organizations:dynamic-sampling', False) or batch_features.get('organizations:performance-use-metrics', False) or batch_features.get('organizations:dashboards-mep', False)\n    try:\n        (use_on_demand_metrics, on_demand_metrics_type) = self.handle_on_demand(request)\n    except ValueError:\n        metric_type_values = [e.value for e in MetricSpecType]\n        metric_types = ','.join(metric_type_values)\n        return Response({'detail': f'On demand metric type must be one of: {metric_types}'}, status=400)\n    on_demand_metrics_enabled = batch_features.get('organizations:on-demand-metrics-extraction', False) and use_on_demand_metrics\n    dataset = self.get_dataset(request)\n    metrics_enhanced = dataset in {metrics_performance, metrics_enhanced_performance}\n    sentry_sdk.set_tag('performance.metrics_enhanced', metrics_enhanced)\n    allow_metric_aggregates = request.GET.get('preventMetricAggregates') != '1'\n    if request.auth:\n        referrer = API_TOKEN_REFERRER\n    elif referrer not in ALLOWED_EVENTS_REFERRERS:\n        referrer = Referrer.API_ORGANIZATION_EVENTS.value\n\n    def data_fn(offset, limit):\n        return dataset.query(selected_columns=self.get_field_list(organization, request), query=request.GET.get('query'), params=params, snuba_params=snuba_params, equations=self.get_equation_list(organization, request), orderby=self.get_orderby(request), offset=offset, limit=limit, referrer=referrer, auto_fields=True, auto_aggregations=True, use_aggregate_conditions=True, allow_metric_aggregates=allow_metric_aggregates, transform_alias_to_input_format=True, has_metrics=use_metrics, use_metrics_layer=batch_features.get('organizations:use-metrics-layer', False), on_demand_metrics_enabled=on_demand_metrics_enabled, on_demand_metrics_type=on_demand_metrics_type)\n    with self.handle_query_errors():\n        if request.GET.get('noPagination'):\n            return Response(self.handle_results_with_meta(request, organization, params['project_id'], data_fn(0, self.get_per_page(request)), standard_meta=True, dataset=dataset))\n        else:\n            return self.paginate(request=request, paginator=GenericOffsetPaginator(data_fn=data_fn), on_results=lambda results: self.handle_results_with_meta(request, organization, params['project_id'], results, standard_meta=True, dataset=dataset))"
        ]
    }
]