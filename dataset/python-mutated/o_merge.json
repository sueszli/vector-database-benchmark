[
    {
        "func_name": "__init__",
        "original": "def __init__(self, merger):\n    super(merge.PerFileMerger, self).__init__(merger)\n    self.conf = merger.this_branch.get_config_stack()\n    self.po_dirs = self.conf.get('po_merge.po_dirs')\n    self.po_glob = self.conf.get('po_merge.po_glob')\n    self.pot_glob = self.conf.get('po_merge.pot_glob')\n    self.command = self.conf.get('po_merge.command', expand=False)\n    self.pot_file_abspath = None\n    trace.mutter('PoMerger created')",
        "mutated": [
            "def __init__(self, merger):\n    if False:\n        i = 10\n    super(merge.PerFileMerger, self).__init__(merger)\n    self.conf = merger.this_branch.get_config_stack()\n    self.po_dirs = self.conf.get('po_merge.po_dirs')\n    self.po_glob = self.conf.get('po_merge.po_glob')\n    self.pot_glob = self.conf.get('po_merge.pot_glob')\n    self.command = self.conf.get('po_merge.command', expand=False)\n    self.pot_file_abspath = None\n    trace.mutter('PoMerger created')",
            "def __init__(self, merger):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(merge.PerFileMerger, self).__init__(merger)\n    self.conf = merger.this_branch.get_config_stack()\n    self.po_dirs = self.conf.get('po_merge.po_dirs')\n    self.po_glob = self.conf.get('po_merge.po_glob')\n    self.pot_glob = self.conf.get('po_merge.pot_glob')\n    self.command = self.conf.get('po_merge.command', expand=False)\n    self.pot_file_abspath = None\n    trace.mutter('PoMerger created')",
            "def __init__(self, merger):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(merge.PerFileMerger, self).__init__(merger)\n    self.conf = merger.this_branch.get_config_stack()\n    self.po_dirs = self.conf.get('po_merge.po_dirs')\n    self.po_glob = self.conf.get('po_merge.po_glob')\n    self.pot_glob = self.conf.get('po_merge.pot_glob')\n    self.command = self.conf.get('po_merge.command', expand=False)\n    self.pot_file_abspath = None\n    trace.mutter('PoMerger created')",
            "def __init__(self, merger):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(merge.PerFileMerger, self).__init__(merger)\n    self.conf = merger.this_branch.get_config_stack()\n    self.po_dirs = self.conf.get('po_merge.po_dirs')\n    self.po_glob = self.conf.get('po_merge.po_glob')\n    self.pot_glob = self.conf.get('po_merge.pot_glob')\n    self.command = self.conf.get('po_merge.command', expand=False)\n    self.pot_file_abspath = None\n    trace.mutter('PoMerger created')",
            "def __init__(self, merger):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(merge.PerFileMerger, self).__init__(merger)\n    self.conf = merger.this_branch.get_config_stack()\n    self.po_dirs = self.conf.get('po_merge.po_dirs')\n    self.po_glob = self.conf.get('po_merge.po_glob')\n    self.pot_glob = self.conf.get('po_merge.pot_glob')\n    self.command = self.conf.get('po_merge.command', expand=False)\n    self.pot_file_abspath = None\n    trace.mutter('PoMerger created')"
        ]
    },
    {
        "func_name": "file_matches",
        "original": "def file_matches(self, params):\n    \"\"\"Return True if merge_matching should be called on this file.\"\"\"\n    if not self.po_dirs or not self.command:\n        return False\n    po_dir = None\n    po_path = self.get_filepath(params, self.merger.this_tree)\n    for po_dir in self.po_dirs:\n        glob = osutils.pathjoin(po_dir, self.po_glob)\n        if fnmatch.fnmatch(po_path, glob):\n            trace.mutter('po %s matches: %s' % (po_path, glob))\n            break\n    else:\n        trace.mutter('PoMerger did not match for %s and %s' % (self.po_dirs, self.po_glob))\n        return False\n    for inv_entry in self.merger.this_tree.list_files(from_dir=po_dir, recursive=False):\n        trace.mutter('inv_entry: %r' % (inv_entry,))\n        (pot_name, pot_file_id) = (inv_entry[0], inv_entry[3])\n        if fnmatch.fnmatch(pot_name, self.pot_glob):\n            relpath = osutils.pathjoin(po_dir, pot_name)\n            self.pot_file_abspath = self.merger.this_tree.abspath(relpath)\n            trace.mutter('will msgmerge %s using %s' % (po_path, self.pot_file_abspath))\n            return True\n    else:\n        return False",
        "mutated": [
            "def file_matches(self, params):\n    if False:\n        i = 10\n    'Return True if merge_matching should be called on this file.'\n    if not self.po_dirs or not self.command:\n        return False\n    po_dir = None\n    po_path = self.get_filepath(params, self.merger.this_tree)\n    for po_dir in self.po_dirs:\n        glob = osutils.pathjoin(po_dir, self.po_glob)\n        if fnmatch.fnmatch(po_path, glob):\n            trace.mutter('po %s matches: %s' % (po_path, glob))\n            break\n    else:\n        trace.mutter('PoMerger did not match for %s and %s' % (self.po_dirs, self.po_glob))\n        return False\n    for inv_entry in self.merger.this_tree.list_files(from_dir=po_dir, recursive=False):\n        trace.mutter('inv_entry: %r' % (inv_entry,))\n        (pot_name, pot_file_id) = (inv_entry[0], inv_entry[3])\n        if fnmatch.fnmatch(pot_name, self.pot_glob):\n            relpath = osutils.pathjoin(po_dir, pot_name)\n            self.pot_file_abspath = self.merger.this_tree.abspath(relpath)\n            trace.mutter('will msgmerge %s using %s' % (po_path, self.pot_file_abspath))\n            return True\n    else:\n        return False",
            "def file_matches(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return True if merge_matching should be called on this file.'\n    if not self.po_dirs or not self.command:\n        return False\n    po_dir = None\n    po_path = self.get_filepath(params, self.merger.this_tree)\n    for po_dir in self.po_dirs:\n        glob = osutils.pathjoin(po_dir, self.po_glob)\n        if fnmatch.fnmatch(po_path, glob):\n            trace.mutter('po %s matches: %s' % (po_path, glob))\n            break\n    else:\n        trace.mutter('PoMerger did not match for %s and %s' % (self.po_dirs, self.po_glob))\n        return False\n    for inv_entry in self.merger.this_tree.list_files(from_dir=po_dir, recursive=False):\n        trace.mutter('inv_entry: %r' % (inv_entry,))\n        (pot_name, pot_file_id) = (inv_entry[0], inv_entry[3])\n        if fnmatch.fnmatch(pot_name, self.pot_glob):\n            relpath = osutils.pathjoin(po_dir, pot_name)\n            self.pot_file_abspath = self.merger.this_tree.abspath(relpath)\n            trace.mutter('will msgmerge %s using %s' % (po_path, self.pot_file_abspath))\n            return True\n    else:\n        return False",
            "def file_matches(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return True if merge_matching should be called on this file.'\n    if not self.po_dirs or not self.command:\n        return False\n    po_dir = None\n    po_path = self.get_filepath(params, self.merger.this_tree)\n    for po_dir in self.po_dirs:\n        glob = osutils.pathjoin(po_dir, self.po_glob)\n        if fnmatch.fnmatch(po_path, glob):\n            trace.mutter('po %s matches: %s' % (po_path, glob))\n            break\n    else:\n        trace.mutter('PoMerger did not match for %s and %s' % (self.po_dirs, self.po_glob))\n        return False\n    for inv_entry in self.merger.this_tree.list_files(from_dir=po_dir, recursive=False):\n        trace.mutter('inv_entry: %r' % (inv_entry,))\n        (pot_name, pot_file_id) = (inv_entry[0], inv_entry[3])\n        if fnmatch.fnmatch(pot_name, self.pot_glob):\n            relpath = osutils.pathjoin(po_dir, pot_name)\n            self.pot_file_abspath = self.merger.this_tree.abspath(relpath)\n            trace.mutter('will msgmerge %s using %s' % (po_path, self.pot_file_abspath))\n            return True\n    else:\n        return False",
            "def file_matches(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return True if merge_matching should be called on this file.'\n    if not self.po_dirs or not self.command:\n        return False\n    po_dir = None\n    po_path = self.get_filepath(params, self.merger.this_tree)\n    for po_dir in self.po_dirs:\n        glob = osutils.pathjoin(po_dir, self.po_glob)\n        if fnmatch.fnmatch(po_path, glob):\n            trace.mutter('po %s matches: %s' % (po_path, glob))\n            break\n    else:\n        trace.mutter('PoMerger did not match for %s and %s' % (self.po_dirs, self.po_glob))\n        return False\n    for inv_entry in self.merger.this_tree.list_files(from_dir=po_dir, recursive=False):\n        trace.mutter('inv_entry: %r' % (inv_entry,))\n        (pot_name, pot_file_id) = (inv_entry[0], inv_entry[3])\n        if fnmatch.fnmatch(pot_name, self.pot_glob):\n            relpath = osutils.pathjoin(po_dir, pot_name)\n            self.pot_file_abspath = self.merger.this_tree.abspath(relpath)\n            trace.mutter('will msgmerge %s using %s' % (po_path, self.pot_file_abspath))\n            return True\n    else:\n        return False",
            "def file_matches(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return True if merge_matching should be called on this file.'\n    if not self.po_dirs or not self.command:\n        return False\n    po_dir = None\n    po_path = self.get_filepath(params, self.merger.this_tree)\n    for po_dir in self.po_dirs:\n        glob = osutils.pathjoin(po_dir, self.po_glob)\n        if fnmatch.fnmatch(po_path, glob):\n            trace.mutter('po %s matches: %s' % (po_path, glob))\n            break\n    else:\n        trace.mutter('PoMerger did not match for %s and %s' % (self.po_dirs, self.po_glob))\n        return False\n    for inv_entry in self.merger.this_tree.list_files(from_dir=po_dir, recursive=False):\n        trace.mutter('inv_entry: %r' % (inv_entry,))\n        (pot_name, pot_file_id) = (inv_entry[0], inv_entry[3])\n        if fnmatch.fnmatch(pot_name, self.pot_glob):\n            relpath = osutils.pathjoin(po_dir, pot_name)\n            self.pot_file_abspath = self.merger.this_tree.abspath(relpath)\n            trace.mutter('will msgmerge %s using %s' % (po_path, self.pot_file_abspath))\n            return True\n    else:\n        return False"
        ]
    },
    {
        "func_name": "_invoke",
        "original": "def _invoke(self, command):\n    trace.mutter('Will msgmerge: %s' % (command,))\n    proc = subprocess.Popen(cmdline.split(command), stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n    (out, err) = proc.communicate()\n    return (proc.returncode, out, err)",
        "mutated": [
            "def _invoke(self, command):\n    if False:\n        i = 10\n    trace.mutter('Will msgmerge: %s' % (command,))\n    proc = subprocess.Popen(cmdline.split(command), stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n    (out, err) = proc.communicate()\n    return (proc.returncode, out, err)",
            "def _invoke(self, command):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    trace.mutter('Will msgmerge: %s' % (command,))\n    proc = subprocess.Popen(cmdline.split(command), stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n    (out, err) = proc.communicate()\n    return (proc.returncode, out, err)",
            "def _invoke(self, command):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    trace.mutter('Will msgmerge: %s' % (command,))\n    proc = subprocess.Popen(cmdline.split(command), stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n    (out, err) = proc.communicate()\n    return (proc.returncode, out, err)",
            "def _invoke(self, command):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    trace.mutter('Will msgmerge: %s' % (command,))\n    proc = subprocess.Popen(cmdline.split(command), stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n    (out, err) = proc.communicate()\n    return (proc.returncode, out, err)",
            "def _invoke(self, command):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    trace.mutter('Will msgmerge: %s' % (command,))\n    proc = subprocess.Popen(cmdline.split(command), stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n    (out, err) = proc.communicate()\n    return (proc.returncode, out, err)"
        ]
    },
    {
        "func_name": "merge_matching",
        "original": "def merge_matching(self, params):\n    return self.merge_text(params)",
        "mutated": [
            "def merge_matching(self, params):\n    if False:\n        i = 10\n    return self.merge_text(params)",
            "def merge_matching(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.merge_text(params)",
            "def merge_matching(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.merge_text(params)",
            "def merge_matching(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.merge_text(params)",
            "def merge_matching(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.merge_text(params)"
        ]
    },
    {
        "func_name": "merge_text",
        "original": "def merge_text(self, params):\n    \"\"\"Calls msgmerge when .po files conflict.\n\n        This requires a valid .pot file to reconcile both sides.\n        \"\"\"\n    tmpdir = tempfile.mkdtemp(prefix='po_merge')\n    env = {}\n    env['this'] = osutils.pathjoin(tmpdir, 'this')\n    env['other'] = osutils.pathjoin(tmpdir, 'other')\n    env['result'] = osutils.pathjoin(tmpdir, 'result')\n    env['pot_file'] = self.pot_file_abspath\n    try:\n        with osutils.open_file(env['this'], 'wb') as f:\n            f.writelines(params.this_lines)\n        with osutils.open_file(env['other'], 'wb') as f:\n            f.writelines(params.other_lines)\n        command = self.conf.expand_options(self.command, env)\n        (retcode, out, err) = self._invoke(command)\n        with osutils.open_file(env['result']) as f:\n            return ('success', list(f.readlines()))\n    finally:\n        osutils.rmtree(tmpdir)\n    return ('not applicable', [])",
        "mutated": [
            "def merge_text(self, params):\n    if False:\n        i = 10\n    'Calls msgmerge when .po files conflict.\\n\\n        This requires a valid .pot file to reconcile both sides.\\n        '\n    tmpdir = tempfile.mkdtemp(prefix='po_merge')\n    env = {}\n    env['this'] = osutils.pathjoin(tmpdir, 'this')\n    env['other'] = osutils.pathjoin(tmpdir, 'other')\n    env['result'] = osutils.pathjoin(tmpdir, 'result')\n    env['pot_file'] = self.pot_file_abspath\n    try:\n        with osutils.open_file(env['this'], 'wb') as f:\n            f.writelines(params.this_lines)\n        with osutils.open_file(env['other'], 'wb') as f:\n            f.writelines(params.other_lines)\n        command = self.conf.expand_options(self.command, env)\n        (retcode, out, err) = self._invoke(command)\n        with osutils.open_file(env['result']) as f:\n            return ('success', list(f.readlines()))\n    finally:\n        osutils.rmtree(tmpdir)\n    return ('not applicable', [])",
            "def merge_text(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Calls msgmerge when .po files conflict.\\n\\n        This requires a valid .pot file to reconcile both sides.\\n        '\n    tmpdir = tempfile.mkdtemp(prefix='po_merge')\n    env = {}\n    env['this'] = osutils.pathjoin(tmpdir, 'this')\n    env['other'] = osutils.pathjoin(tmpdir, 'other')\n    env['result'] = osutils.pathjoin(tmpdir, 'result')\n    env['pot_file'] = self.pot_file_abspath\n    try:\n        with osutils.open_file(env['this'], 'wb') as f:\n            f.writelines(params.this_lines)\n        with osutils.open_file(env['other'], 'wb') as f:\n            f.writelines(params.other_lines)\n        command = self.conf.expand_options(self.command, env)\n        (retcode, out, err) = self._invoke(command)\n        with osutils.open_file(env['result']) as f:\n            return ('success', list(f.readlines()))\n    finally:\n        osutils.rmtree(tmpdir)\n    return ('not applicable', [])",
            "def merge_text(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Calls msgmerge when .po files conflict.\\n\\n        This requires a valid .pot file to reconcile both sides.\\n        '\n    tmpdir = tempfile.mkdtemp(prefix='po_merge')\n    env = {}\n    env['this'] = osutils.pathjoin(tmpdir, 'this')\n    env['other'] = osutils.pathjoin(tmpdir, 'other')\n    env['result'] = osutils.pathjoin(tmpdir, 'result')\n    env['pot_file'] = self.pot_file_abspath\n    try:\n        with osutils.open_file(env['this'], 'wb') as f:\n            f.writelines(params.this_lines)\n        with osutils.open_file(env['other'], 'wb') as f:\n            f.writelines(params.other_lines)\n        command = self.conf.expand_options(self.command, env)\n        (retcode, out, err) = self._invoke(command)\n        with osutils.open_file(env['result']) as f:\n            return ('success', list(f.readlines()))\n    finally:\n        osutils.rmtree(tmpdir)\n    return ('not applicable', [])",
            "def merge_text(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Calls msgmerge when .po files conflict.\\n\\n        This requires a valid .pot file to reconcile both sides.\\n        '\n    tmpdir = tempfile.mkdtemp(prefix='po_merge')\n    env = {}\n    env['this'] = osutils.pathjoin(tmpdir, 'this')\n    env['other'] = osutils.pathjoin(tmpdir, 'other')\n    env['result'] = osutils.pathjoin(tmpdir, 'result')\n    env['pot_file'] = self.pot_file_abspath\n    try:\n        with osutils.open_file(env['this'], 'wb') as f:\n            f.writelines(params.this_lines)\n        with osutils.open_file(env['other'], 'wb') as f:\n            f.writelines(params.other_lines)\n        command = self.conf.expand_options(self.command, env)\n        (retcode, out, err) = self._invoke(command)\n        with osutils.open_file(env['result']) as f:\n            return ('success', list(f.readlines()))\n    finally:\n        osutils.rmtree(tmpdir)\n    return ('not applicable', [])",
            "def merge_text(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Calls msgmerge when .po files conflict.\\n\\n        This requires a valid .pot file to reconcile both sides.\\n        '\n    tmpdir = tempfile.mkdtemp(prefix='po_merge')\n    env = {}\n    env['this'] = osutils.pathjoin(tmpdir, 'this')\n    env['other'] = osutils.pathjoin(tmpdir, 'other')\n    env['result'] = osutils.pathjoin(tmpdir, 'result')\n    env['pot_file'] = self.pot_file_abspath\n    try:\n        with osutils.open_file(env['this'], 'wb') as f:\n            f.writelines(params.this_lines)\n        with osutils.open_file(env['other'], 'wb') as f:\n            f.writelines(params.other_lines)\n        command = self.conf.expand_options(self.command, env)\n        (retcode, out, err) = self._invoke(command)\n        with osutils.open_file(env['result']) as f:\n            return ('success', list(f.readlines()))\n    finally:\n        osutils.rmtree(tmpdir)\n    return ('not applicable', [])"
        ]
    }
]