[
    {
        "func_name": "basic_rnn_reference",
        "original": "def basic_rnn_reference(input, hidden_initial, i2h_w, i2h_b, gate_w, gate_b, seq_lengths, drop_states, use_sequence_lengths):\n    D = hidden_initial.shape[-1]\n    T = input.shape[0]\n    N = input.shape[1]\n    if seq_lengths is not None:\n        seq_lengths = (np.ones(shape=(N, D)) * seq_lengths.reshape(N, 1)).astype(np.int32)\n    ret = []\n    hidden_prev = hidden_initial\n    for t in range(T):\n        input_fc = np.dot(input[t], i2h_w.T) + i2h_b\n        recur_fc = np.dot(hidden_prev, gate_w.T) + gate_b\n        hidden_t = tanh(input_fc + recur_fc)\n        if seq_lengths is not None:\n            valid = (t < seq_lengths).astype(np.int32)\n            assert valid.shape == (N, D), (valid.shape, (N, D))\n            hidden_t = hidden_t * valid + hidden_prev * (1 - valid) * (1 - drop_states)\n        ret.append(hidden_t)\n        hidden_prev = hidden_t\n    return ret",
        "mutated": [
            "def basic_rnn_reference(input, hidden_initial, i2h_w, i2h_b, gate_w, gate_b, seq_lengths, drop_states, use_sequence_lengths):\n    if False:\n        i = 10\n    D = hidden_initial.shape[-1]\n    T = input.shape[0]\n    N = input.shape[1]\n    if seq_lengths is not None:\n        seq_lengths = (np.ones(shape=(N, D)) * seq_lengths.reshape(N, 1)).astype(np.int32)\n    ret = []\n    hidden_prev = hidden_initial\n    for t in range(T):\n        input_fc = np.dot(input[t], i2h_w.T) + i2h_b\n        recur_fc = np.dot(hidden_prev, gate_w.T) + gate_b\n        hidden_t = tanh(input_fc + recur_fc)\n        if seq_lengths is not None:\n            valid = (t < seq_lengths).astype(np.int32)\n            assert valid.shape == (N, D), (valid.shape, (N, D))\n            hidden_t = hidden_t * valid + hidden_prev * (1 - valid) * (1 - drop_states)\n        ret.append(hidden_t)\n        hidden_prev = hidden_t\n    return ret",
            "def basic_rnn_reference(input, hidden_initial, i2h_w, i2h_b, gate_w, gate_b, seq_lengths, drop_states, use_sequence_lengths):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    D = hidden_initial.shape[-1]\n    T = input.shape[0]\n    N = input.shape[1]\n    if seq_lengths is not None:\n        seq_lengths = (np.ones(shape=(N, D)) * seq_lengths.reshape(N, 1)).astype(np.int32)\n    ret = []\n    hidden_prev = hidden_initial\n    for t in range(T):\n        input_fc = np.dot(input[t], i2h_w.T) + i2h_b\n        recur_fc = np.dot(hidden_prev, gate_w.T) + gate_b\n        hidden_t = tanh(input_fc + recur_fc)\n        if seq_lengths is not None:\n            valid = (t < seq_lengths).astype(np.int32)\n            assert valid.shape == (N, D), (valid.shape, (N, D))\n            hidden_t = hidden_t * valid + hidden_prev * (1 - valid) * (1 - drop_states)\n        ret.append(hidden_t)\n        hidden_prev = hidden_t\n    return ret",
            "def basic_rnn_reference(input, hidden_initial, i2h_w, i2h_b, gate_w, gate_b, seq_lengths, drop_states, use_sequence_lengths):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    D = hidden_initial.shape[-1]\n    T = input.shape[0]\n    N = input.shape[1]\n    if seq_lengths is not None:\n        seq_lengths = (np.ones(shape=(N, D)) * seq_lengths.reshape(N, 1)).astype(np.int32)\n    ret = []\n    hidden_prev = hidden_initial\n    for t in range(T):\n        input_fc = np.dot(input[t], i2h_w.T) + i2h_b\n        recur_fc = np.dot(hidden_prev, gate_w.T) + gate_b\n        hidden_t = tanh(input_fc + recur_fc)\n        if seq_lengths is not None:\n            valid = (t < seq_lengths).astype(np.int32)\n            assert valid.shape == (N, D), (valid.shape, (N, D))\n            hidden_t = hidden_t * valid + hidden_prev * (1 - valid) * (1 - drop_states)\n        ret.append(hidden_t)\n        hidden_prev = hidden_t\n    return ret",
            "def basic_rnn_reference(input, hidden_initial, i2h_w, i2h_b, gate_w, gate_b, seq_lengths, drop_states, use_sequence_lengths):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    D = hidden_initial.shape[-1]\n    T = input.shape[0]\n    N = input.shape[1]\n    if seq_lengths is not None:\n        seq_lengths = (np.ones(shape=(N, D)) * seq_lengths.reshape(N, 1)).astype(np.int32)\n    ret = []\n    hidden_prev = hidden_initial\n    for t in range(T):\n        input_fc = np.dot(input[t], i2h_w.T) + i2h_b\n        recur_fc = np.dot(hidden_prev, gate_w.T) + gate_b\n        hidden_t = tanh(input_fc + recur_fc)\n        if seq_lengths is not None:\n            valid = (t < seq_lengths).astype(np.int32)\n            assert valid.shape == (N, D), (valid.shape, (N, D))\n            hidden_t = hidden_t * valid + hidden_prev * (1 - valid) * (1 - drop_states)\n        ret.append(hidden_t)\n        hidden_prev = hidden_t\n    return ret",
            "def basic_rnn_reference(input, hidden_initial, i2h_w, i2h_b, gate_w, gate_b, seq_lengths, drop_states, use_sequence_lengths):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    D = hidden_initial.shape[-1]\n    T = input.shape[0]\n    N = input.shape[1]\n    if seq_lengths is not None:\n        seq_lengths = (np.ones(shape=(N, D)) * seq_lengths.reshape(N, 1)).astype(np.int32)\n    ret = []\n    hidden_prev = hidden_initial\n    for t in range(T):\n        input_fc = np.dot(input[t], i2h_w.T) + i2h_b\n        recur_fc = np.dot(hidden_prev, gate_w.T) + gate_b\n        hidden_t = tanh(input_fc + recur_fc)\n        if seq_lengths is not None:\n            valid = (t < seq_lengths).astype(np.int32)\n            assert valid.shape == (N, D), (valid.shape, (N, D))\n            hidden_t = hidden_t * valid + hidden_prev * (1 - valid) * (1 - drop_states)\n        ret.append(hidden_t)\n        hidden_prev = hidden_t\n    return ret"
        ]
    },
    {
        "func_name": "test_basic_rnn",
        "original": "@given(seed=st.integers(0, 2 ** 32 - 1), seq_length=st.integers(min_value=1, max_value=5), batch_size=st.integers(min_value=1, max_value=5), input_size=st.integers(min_value=1, max_value=5), hidden_size=st.integers(min_value=1, max_value=5), drop_states=st.booleans(), sequence_lengths=st.booleans(), **hu.gcs)\n@ht_settings(max_examples=15)\ndef test_basic_rnn(self, seed, seq_length, batch_size, input_size, hidden_size, drop_states, sequence_lengths, gc, dc):\n    np.random.seed(seed)\n    seq_lengths_data = np.random.randint(1, seq_length + 1, size=(batch_size,)).astype(np.int32)\n    input_blob_data = np.random.randn(seq_length, batch_size, input_size).astype(np.float32)\n    initial_h_data = np.random.randn(batch_size, hidden_size).astype(np.float32)\n    gates_t_w_data = np.random.randn(hidden_size, hidden_size).astype(np.float32)\n    gates_t_b_data = np.random.randn(hidden_size).astype(np.float32)\n    i2h_w_data = np.random.randn(hidden_size, input_size).astype(np.float32)\n    i2h_b_data = np.random.randn(hidden_size).astype(np.float32)\n    with core.DeviceScope(gc):\n        with hu.temp_workspace():\n            workspace.FeedBlob('input_blob', input_blob_data, device_option=gc)\n            workspace.FeedBlob('seq_lengths', seq_lengths_data, device_option=gc)\n            workspace.FeedBlob('initial_h', initial_h_data, device_option=gc)\n            workspace.FeedBlob('basic_rnn/gates_t_w', gates_t_w_data, device_option=gc)\n            workspace.FeedBlob('basic_rnn/gates_t_b', gates_t_b_data, device_option=gc)\n            workspace.FeedBlob('basic_rnn/i2h_w', i2h_w_data, device_option=gc)\n            workspace.FeedBlob('basic_rnn/i2h_b', i2h_b_data, device_option=gc)\n            model = ModelHelper(name='model')\n            (hidden_t_all, _) = rnn_cell.BasicRNN(model, 'input_blob', 'seq_lengths' if sequence_lengths else None, ['initial_h'], input_size, hidden_size, 'basic_rnn', activation='tanh', forward_only=True, drop_states=drop_states)\n            workspace.RunNetOnce(model.net)\n            result = workspace.FetchBlob(hidden_t_all)\n    reference = basic_rnn_reference(input_blob_data, initial_h_data, i2h_w_data, i2h_b_data, gates_t_w_data, gates_t_b_data, seq_lengths_data if sequence_lengths else None, drop_states=drop_states, use_sequence_lengths=sequence_lengths)\n    np.testing.assert_allclose(result, reference, atol=0.0001, rtol=0.0001)",
        "mutated": [
            "@given(seed=st.integers(0, 2 ** 32 - 1), seq_length=st.integers(min_value=1, max_value=5), batch_size=st.integers(min_value=1, max_value=5), input_size=st.integers(min_value=1, max_value=5), hidden_size=st.integers(min_value=1, max_value=5), drop_states=st.booleans(), sequence_lengths=st.booleans(), **hu.gcs)\n@ht_settings(max_examples=15)\ndef test_basic_rnn(self, seed, seq_length, batch_size, input_size, hidden_size, drop_states, sequence_lengths, gc, dc):\n    if False:\n        i = 10\n    np.random.seed(seed)\n    seq_lengths_data = np.random.randint(1, seq_length + 1, size=(batch_size,)).astype(np.int32)\n    input_blob_data = np.random.randn(seq_length, batch_size, input_size).astype(np.float32)\n    initial_h_data = np.random.randn(batch_size, hidden_size).astype(np.float32)\n    gates_t_w_data = np.random.randn(hidden_size, hidden_size).astype(np.float32)\n    gates_t_b_data = np.random.randn(hidden_size).astype(np.float32)\n    i2h_w_data = np.random.randn(hidden_size, input_size).astype(np.float32)\n    i2h_b_data = np.random.randn(hidden_size).astype(np.float32)\n    with core.DeviceScope(gc):\n        with hu.temp_workspace():\n            workspace.FeedBlob('input_blob', input_blob_data, device_option=gc)\n            workspace.FeedBlob('seq_lengths', seq_lengths_data, device_option=gc)\n            workspace.FeedBlob('initial_h', initial_h_data, device_option=gc)\n            workspace.FeedBlob('basic_rnn/gates_t_w', gates_t_w_data, device_option=gc)\n            workspace.FeedBlob('basic_rnn/gates_t_b', gates_t_b_data, device_option=gc)\n            workspace.FeedBlob('basic_rnn/i2h_w', i2h_w_data, device_option=gc)\n            workspace.FeedBlob('basic_rnn/i2h_b', i2h_b_data, device_option=gc)\n            model = ModelHelper(name='model')\n            (hidden_t_all, _) = rnn_cell.BasicRNN(model, 'input_blob', 'seq_lengths' if sequence_lengths else None, ['initial_h'], input_size, hidden_size, 'basic_rnn', activation='tanh', forward_only=True, drop_states=drop_states)\n            workspace.RunNetOnce(model.net)\n            result = workspace.FetchBlob(hidden_t_all)\n    reference = basic_rnn_reference(input_blob_data, initial_h_data, i2h_w_data, i2h_b_data, gates_t_w_data, gates_t_b_data, seq_lengths_data if sequence_lengths else None, drop_states=drop_states, use_sequence_lengths=sequence_lengths)\n    np.testing.assert_allclose(result, reference, atol=0.0001, rtol=0.0001)",
            "@given(seed=st.integers(0, 2 ** 32 - 1), seq_length=st.integers(min_value=1, max_value=5), batch_size=st.integers(min_value=1, max_value=5), input_size=st.integers(min_value=1, max_value=5), hidden_size=st.integers(min_value=1, max_value=5), drop_states=st.booleans(), sequence_lengths=st.booleans(), **hu.gcs)\n@ht_settings(max_examples=15)\ndef test_basic_rnn(self, seed, seq_length, batch_size, input_size, hidden_size, drop_states, sequence_lengths, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    np.random.seed(seed)\n    seq_lengths_data = np.random.randint(1, seq_length + 1, size=(batch_size,)).astype(np.int32)\n    input_blob_data = np.random.randn(seq_length, batch_size, input_size).astype(np.float32)\n    initial_h_data = np.random.randn(batch_size, hidden_size).astype(np.float32)\n    gates_t_w_data = np.random.randn(hidden_size, hidden_size).astype(np.float32)\n    gates_t_b_data = np.random.randn(hidden_size).astype(np.float32)\n    i2h_w_data = np.random.randn(hidden_size, input_size).astype(np.float32)\n    i2h_b_data = np.random.randn(hidden_size).astype(np.float32)\n    with core.DeviceScope(gc):\n        with hu.temp_workspace():\n            workspace.FeedBlob('input_blob', input_blob_data, device_option=gc)\n            workspace.FeedBlob('seq_lengths', seq_lengths_data, device_option=gc)\n            workspace.FeedBlob('initial_h', initial_h_data, device_option=gc)\n            workspace.FeedBlob('basic_rnn/gates_t_w', gates_t_w_data, device_option=gc)\n            workspace.FeedBlob('basic_rnn/gates_t_b', gates_t_b_data, device_option=gc)\n            workspace.FeedBlob('basic_rnn/i2h_w', i2h_w_data, device_option=gc)\n            workspace.FeedBlob('basic_rnn/i2h_b', i2h_b_data, device_option=gc)\n            model = ModelHelper(name='model')\n            (hidden_t_all, _) = rnn_cell.BasicRNN(model, 'input_blob', 'seq_lengths' if sequence_lengths else None, ['initial_h'], input_size, hidden_size, 'basic_rnn', activation='tanh', forward_only=True, drop_states=drop_states)\n            workspace.RunNetOnce(model.net)\n            result = workspace.FetchBlob(hidden_t_all)\n    reference = basic_rnn_reference(input_blob_data, initial_h_data, i2h_w_data, i2h_b_data, gates_t_w_data, gates_t_b_data, seq_lengths_data if sequence_lengths else None, drop_states=drop_states, use_sequence_lengths=sequence_lengths)\n    np.testing.assert_allclose(result, reference, atol=0.0001, rtol=0.0001)",
            "@given(seed=st.integers(0, 2 ** 32 - 1), seq_length=st.integers(min_value=1, max_value=5), batch_size=st.integers(min_value=1, max_value=5), input_size=st.integers(min_value=1, max_value=5), hidden_size=st.integers(min_value=1, max_value=5), drop_states=st.booleans(), sequence_lengths=st.booleans(), **hu.gcs)\n@ht_settings(max_examples=15)\ndef test_basic_rnn(self, seed, seq_length, batch_size, input_size, hidden_size, drop_states, sequence_lengths, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    np.random.seed(seed)\n    seq_lengths_data = np.random.randint(1, seq_length + 1, size=(batch_size,)).astype(np.int32)\n    input_blob_data = np.random.randn(seq_length, batch_size, input_size).astype(np.float32)\n    initial_h_data = np.random.randn(batch_size, hidden_size).astype(np.float32)\n    gates_t_w_data = np.random.randn(hidden_size, hidden_size).astype(np.float32)\n    gates_t_b_data = np.random.randn(hidden_size).astype(np.float32)\n    i2h_w_data = np.random.randn(hidden_size, input_size).astype(np.float32)\n    i2h_b_data = np.random.randn(hidden_size).astype(np.float32)\n    with core.DeviceScope(gc):\n        with hu.temp_workspace():\n            workspace.FeedBlob('input_blob', input_blob_data, device_option=gc)\n            workspace.FeedBlob('seq_lengths', seq_lengths_data, device_option=gc)\n            workspace.FeedBlob('initial_h', initial_h_data, device_option=gc)\n            workspace.FeedBlob('basic_rnn/gates_t_w', gates_t_w_data, device_option=gc)\n            workspace.FeedBlob('basic_rnn/gates_t_b', gates_t_b_data, device_option=gc)\n            workspace.FeedBlob('basic_rnn/i2h_w', i2h_w_data, device_option=gc)\n            workspace.FeedBlob('basic_rnn/i2h_b', i2h_b_data, device_option=gc)\n            model = ModelHelper(name='model')\n            (hidden_t_all, _) = rnn_cell.BasicRNN(model, 'input_blob', 'seq_lengths' if sequence_lengths else None, ['initial_h'], input_size, hidden_size, 'basic_rnn', activation='tanh', forward_only=True, drop_states=drop_states)\n            workspace.RunNetOnce(model.net)\n            result = workspace.FetchBlob(hidden_t_all)\n    reference = basic_rnn_reference(input_blob_data, initial_h_data, i2h_w_data, i2h_b_data, gates_t_w_data, gates_t_b_data, seq_lengths_data if sequence_lengths else None, drop_states=drop_states, use_sequence_lengths=sequence_lengths)\n    np.testing.assert_allclose(result, reference, atol=0.0001, rtol=0.0001)",
            "@given(seed=st.integers(0, 2 ** 32 - 1), seq_length=st.integers(min_value=1, max_value=5), batch_size=st.integers(min_value=1, max_value=5), input_size=st.integers(min_value=1, max_value=5), hidden_size=st.integers(min_value=1, max_value=5), drop_states=st.booleans(), sequence_lengths=st.booleans(), **hu.gcs)\n@ht_settings(max_examples=15)\ndef test_basic_rnn(self, seed, seq_length, batch_size, input_size, hidden_size, drop_states, sequence_lengths, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    np.random.seed(seed)\n    seq_lengths_data = np.random.randint(1, seq_length + 1, size=(batch_size,)).astype(np.int32)\n    input_blob_data = np.random.randn(seq_length, batch_size, input_size).astype(np.float32)\n    initial_h_data = np.random.randn(batch_size, hidden_size).astype(np.float32)\n    gates_t_w_data = np.random.randn(hidden_size, hidden_size).astype(np.float32)\n    gates_t_b_data = np.random.randn(hidden_size).astype(np.float32)\n    i2h_w_data = np.random.randn(hidden_size, input_size).astype(np.float32)\n    i2h_b_data = np.random.randn(hidden_size).astype(np.float32)\n    with core.DeviceScope(gc):\n        with hu.temp_workspace():\n            workspace.FeedBlob('input_blob', input_blob_data, device_option=gc)\n            workspace.FeedBlob('seq_lengths', seq_lengths_data, device_option=gc)\n            workspace.FeedBlob('initial_h', initial_h_data, device_option=gc)\n            workspace.FeedBlob('basic_rnn/gates_t_w', gates_t_w_data, device_option=gc)\n            workspace.FeedBlob('basic_rnn/gates_t_b', gates_t_b_data, device_option=gc)\n            workspace.FeedBlob('basic_rnn/i2h_w', i2h_w_data, device_option=gc)\n            workspace.FeedBlob('basic_rnn/i2h_b', i2h_b_data, device_option=gc)\n            model = ModelHelper(name='model')\n            (hidden_t_all, _) = rnn_cell.BasicRNN(model, 'input_blob', 'seq_lengths' if sequence_lengths else None, ['initial_h'], input_size, hidden_size, 'basic_rnn', activation='tanh', forward_only=True, drop_states=drop_states)\n            workspace.RunNetOnce(model.net)\n            result = workspace.FetchBlob(hidden_t_all)\n    reference = basic_rnn_reference(input_blob_data, initial_h_data, i2h_w_data, i2h_b_data, gates_t_w_data, gates_t_b_data, seq_lengths_data if sequence_lengths else None, drop_states=drop_states, use_sequence_lengths=sequence_lengths)\n    np.testing.assert_allclose(result, reference, atol=0.0001, rtol=0.0001)",
            "@given(seed=st.integers(0, 2 ** 32 - 1), seq_length=st.integers(min_value=1, max_value=5), batch_size=st.integers(min_value=1, max_value=5), input_size=st.integers(min_value=1, max_value=5), hidden_size=st.integers(min_value=1, max_value=5), drop_states=st.booleans(), sequence_lengths=st.booleans(), **hu.gcs)\n@ht_settings(max_examples=15)\ndef test_basic_rnn(self, seed, seq_length, batch_size, input_size, hidden_size, drop_states, sequence_lengths, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    np.random.seed(seed)\n    seq_lengths_data = np.random.randint(1, seq_length + 1, size=(batch_size,)).astype(np.int32)\n    input_blob_data = np.random.randn(seq_length, batch_size, input_size).astype(np.float32)\n    initial_h_data = np.random.randn(batch_size, hidden_size).astype(np.float32)\n    gates_t_w_data = np.random.randn(hidden_size, hidden_size).astype(np.float32)\n    gates_t_b_data = np.random.randn(hidden_size).astype(np.float32)\n    i2h_w_data = np.random.randn(hidden_size, input_size).astype(np.float32)\n    i2h_b_data = np.random.randn(hidden_size).astype(np.float32)\n    with core.DeviceScope(gc):\n        with hu.temp_workspace():\n            workspace.FeedBlob('input_blob', input_blob_data, device_option=gc)\n            workspace.FeedBlob('seq_lengths', seq_lengths_data, device_option=gc)\n            workspace.FeedBlob('initial_h', initial_h_data, device_option=gc)\n            workspace.FeedBlob('basic_rnn/gates_t_w', gates_t_w_data, device_option=gc)\n            workspace.FeedBlob('basic_rnn/gates_t_b', gates_t_b_data, device_option=gc)\n            workspace.FeedBlob('basic_rnn/i2h_w', i2h_w_data, device_option=gc)\n            workspace.FeedBlob('basic_rnn/i2h_b', i2h_b_data, device_option=gc)\n            model = ModelHelper(name='model')\n            (hidden_t_all, _) = rnn_cell.BasicRNN(model, 'input_blob', 'seq_lengths' if sequence_lengths else None, ['initial_h'], input_size, hidden_size, 'basic_rnn', activation='tanh', forward_only=True, drop_states=drop_states)\n            workspace.RunNetOnce(model.net)\n            result = workspace.FetchBlob(hidden_t_all)\n    reference = basic_rnn_reference(input_blob_data, initial_h_data, i2h_w_data, i2h_b_data, gates_t_w_data, gates_t_b_data, seq_lengths_data if sequence_lengths else None, drop_states=drop_states, use_sequence_lengths=sequence_lengths)\n    np.testing.assert_allclose(result, reference, atol=0.0001, rtol=0.0001)"
        ]
    }
]