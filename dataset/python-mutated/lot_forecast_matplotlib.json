[
    {
        "func_name": "plot",
        "original": "def plot(fcst, quantiles, ax=None, xlabel='ds', ylabel='y', highlight_forecast=None, line_per_origin=False, figsize=(10, 6)):\n    \"\"\"Plot the NeuralProphet forecast.\n\n    Parameters\n    ----------\n        fcst : pd.DataFrame\n            Output of m.predict\n        quantiles: list\n            Quantiles for which the forecasts are to be plotted\n        ax : matplotlib axes\n            Axes to plot on\n        xlabel : str\n            Label name on X-axis\n        ylabel : str\n            Label name on Y-axis\n        highlight_forecast : int\n            i-th step ahead forecast to highlight.\n        line_per_origin : bool\n            Print a line per forecast of one per forecast age\n        figsize : tuple\n            Width, height in inches.\n\n    Returns\n    -------\n        matplotlib.pyplot.figure\n            Figure showing the NeuralProphet forecast\n\n    Examples\n    --------\n        Base usage\n\n        >>> from neuralprophet import NeuralProphet\n        >>> m = NeuralProphet()\n        >>> metrics = m.fit(df, freq=\"D\")\n        >>> future = m.make_future_dataframe(df=df, periods=365)\n        >>> forecast = m.predict(df=future)\n        >>> fig_forecast = m.plot(forecast)\n\n        Additional plot specifications\n\n        >>> m.plot(forecast,\n        >>>    xlabel=\"ds\",\n        >>>    ylabel=\"y\",\n        >>>    highlight_forecast=None,\n        >>>    line_per_origin=False,\n        >>>    figsize=(10, 6)\n        >>>    )\n\n    \"\"\"\n    fcst = fcst.fillna(value=np.nan)\n    if ax is None:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    else:\n        fig = ax.get_figure()\n    ds = fcst['ds'].dt.to_pydatetime()\n    colname = 'yhat'\n    step = 1\n    if line_per_origin:\n        colname = 'origin-'\n        step = 0\n    yhat_col_names = [col_name for col_name in fcst.columns if col_name.startswith(colname) and '%' not in col_name]\n    if highlight_forecast is None or line_per_origin:\n        for (i, name) in enumerate(yhat_col_names):\n            ax.plot(ds, fcst[f'{colname}{(i if line_per_origin else i + 1)}'], ls='-', c='#0072B2', alpha=0.2 + 2.0 / (i + 2.5), label=name)\n        if len(quantiles) > 1:\n            for i in range(1, len(quantiles)):\n                ax.fill_between(ds, fcst[f'{colname}{step}'], fcst[f'{colname}{step} {round(quantiles[i] * 100, 1)}%'], color='#0072B2', alpha=0.2)\n    if highlight_forecast is not None:\n        if line_per_origin:\n            num_forecast_steps = sum(fcst['origin-0'].notna())\n            steps_from_last = num_forecast_steps - highlight_forecast\n            for i in range(len(yhat_col_names)):\n                x = ds[-(1 + i + steps_from_last)]\n                y = fcst[f'origin-{i}'].values[-(1 + i + steps_from_last)]\n                ax.plot(x, y, 'bx')\n        else:\n            ax.plot(ds, fcst[f'yhat{highlight_forecast}'], ls='-', c='b', label=f'yhat{highlight_forecast}')\n            ax.plot(ds, fcst[f'yhat{highlight_forecast}'], 'bx', label=f'yhat{highlight_forecast}')\n            if len(quantiles) > 1:\n                for i in range(1, len(quantiles)):\n                    ax.fill_between(ds, fcst[f'yhat{highlight_forecast}'], fcst[f'yhat{highlight_forecast} {round(quantiles[i] * 100, 1)}%'], color='#0072B2', alpha=0.2)\n    ax.plot(ds, fcst['y'], 'k.', label='actual y')\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(ylabel)\n    (handles, labels) = ax.axes.get_legend_handles_labels()\n    if len(labels) > 10:\n        ax.legend(handles[:10] + [handles[-1]], labels[:10] + [labels[-1]])\n        log.warning('Legend is available only for the ten first handles')\n    else:\n        ax.legend(handles, labels)\n    fig = fig.tight_layout()\n    return fig",
        "mutated": [
            "def plot(fcst, quantiles, ax=None, xlabel='ds', ylabel='y', highlight_forecast=None, line_per_origin=False, figsize=(10, 6)):\n    if False:\n        i = 10\n    'Plot the NeuralProphet forecast.\\n\\n    Parameters\\n    ----------\\n        fcst : pd.DataFrame\\n            Output of m.predict\\n        quantiles: list\\n            Quantiles for which the forecasts are to be plotted\\n        ax : matplotlib axes\\n            Axes to plot on\\n        xlabel : str\\n            Label name on X-axis\\n        ylabel : str\\n            Label name on Y-axis\\n        highlight_forecast : int\\n            i-th step ahead forecast to highlight.\\n        line_per_origin : bool\\n            Print a line per forecast of one per forecast age\\n        figsize : tuple\\n            Width, height in inches.\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the NeuralProphet forecast\\n\\n    Examples\\n    --------\\n        Base usage\\n\\n        >>> from neuralprophet import NeuralProphet\\n        >>> m = NeuralProphet()\\n        >>> metrics = m.fit(df, freq=\"D\")\\n        >>> future = m.make_future_dataframe(df=df, periods=365)\\n        >>> forecast = m.predict(df=future)\\n        >>> fig_forecast = m.plot(forecast)\\n\\n        Additional plot specifications\\n\\n        >>> m.plot(forecast,\\n        >>>    xlabel=\"ds\",\\n        >>>    ylabel=\"y\",\\n        >>>    highlight_forecast=None,\\n        >>>    line_per_origin=False,\\n        >>>    figsize=(10, 6)\\n        >>>    )\\n\\n    '\n    fcst = fcst.fillna(value=np.nan)\n    if ax is None:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    else:\n        fig = ax.get_figure()\n    ds = fcst['ds'].dt.to_pydatetime()\n    colname = 'yhat'\n    step = 1\n    if line_per_origin:\n        colname = 'origin-'\n        step = 0\n    yhat_col_names = [col_name for col_name in fcst.columns if col_name.startswith(colname) and '%' not in col_name]\n    if highlight_forecast is None or line_per_origin:\n        for (i, name) in enumerate(yhat_col_names):\n            ax.plot(ds, fcst[f'{colname}{(i if line_per_origin else i + 1)}'], ls='-', c='#0072B2', alpha=0.2 + 2.0 / (i + 2.5), label=name)\n        if len(quantiles) > 1:\n            for i in range(1, len(quantiles)):\n                ax.fill_between(ds, fcst[f'{colname}{step}'], fcst[f'{colname}{step} {round(quantiles[i] * 100, 1)}%'], color='#0072B2', alpha=0.2)\n    if highlight_forecast is not None:\n        if line_per_origin:\n            num_forecast_steps = sum(fcst['origin-0'].notna())\n            steps_from_last = num_forecast_steps - highlight_forecast\n            for i in range(len(yhat_col_names)):\n                x = ds[-(1 + i + steps_from_last)]\n                y = fcst[f'origin-{i}'].values[-(1 + i + steps_from_last)]\n                ax.plot(x, y, 'bx')\n        else:\n            ax.plot(ds, fcst[f'yhat{highlight_forecast}'], ls='-', c='b', label=f'yhat{highlight_forecast}')\n            ax.plot(ds, fcst[f'yhat{highlight_forecast}'], 'bx', label=f'yhat{highlight_forecast}')\n            if len(quantiles) > 1:\n                for i in range(1, len(quantiles)):\n                    ax.fill_between(ds, fcst[f'yhat{highlight_forecast}'], fcst[f'yhat{highlight_forecast} {round(quantiles[i] * 100, 1)}%'], color='#0072B2', alpha=0.2)\n    ax.plot(ds, fcst['y'], 'k.', label='actual y')\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(ylabel)\n    (handles, labels) = ax.axes.get_legend_handles_labels()\n    if len(labels) > 10:\n        ax.legend(handles[:10] + [handles[-1]], labels[:10] + [labels[-1]])\n        log.warning('Legend is available only for the ten first handles')\n    else:\n        ax.legend(handles, labels)\n    fig = fig.tight_layout()\n    return fig",
            "def plot(fcst, quantiles, ax=None, xlabel='ds', ylabel='y', highlight_forecast=None, line_per_origin=False, figsize=(10, 6)):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Plot the NeuralProphet forecast.\\n\\n    Parameters\\n    ----------\\n        fcst : pd.DataFrame\\n            Output of m.predict\\n        quantiles: list\\n            Quantiles for which the forecasts are to be plotted\\n        ax : matplotlib axes\\n            Axes to plot on\\n        xlabel : str\\n            Label name on X-axis\\n        ylabel : str\\n            Label name on Y-axis\\n        highlight_forecast : int\\n            i-th step ahead forecast to highlight.\\n        line_per_origin : bool\\n            Print a line per forecast of one per forecast age\\n        figsize : tuple\\n            Width, height in inches.\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the NeuralProphet forecast\\n\\n    Examples\\n    --------\\n        Base usage\\n\\n        >>> from neuralprophet import NeuralProphet\\n        >>> m = NeuralProphet()\\n        >>> metrics = m.fit(df, freq=\"D\")\\n        >>> future = m.make_future_dataframe(df=df, periods=365)\\n        >>> forecast = m.predict(df=future)\\n        >>> fig_forecast = m.plot(forecast)\\n\\n        Additional plot specifications\\n\\n        >>> m.plot(forecast,\\n        >>>    xlabel=\"ds\",\\n        >>>    ylabel=\"y\",\\n        >>>    highlight_forecast=None,\\n        >>>    line_per_origin=False,\\n        >>>    figsize=(10, 6)\\n        >>>    )\\n\\n    '\n    fcst = fcst.fillna(value=np.nan)\n    if ax is None:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    else:\n        fig = ax.get_figure()\n    ds = fcst['ds'].dt.to_pydatetime()\n    colname = 'yhat'\n    step = 1\n    if line_per_origin:\n        colname = 'origin-'\n        step = 0\n    yhat_col_names = [col_name for col_name in fcst.columns if col_name.startswith(colname) and '%' not in col_name]\n    if highlight_forecast is None or line_per_origin:\n        for (i, name) in enumerate(yhat_col_names):\n            ax.plot(ds, fcst[f'{colname}{(i if line_per_origin else i + 1)}'], ls='-', c='#0072B2', alpha=0.2 + 2.0 / (i + 2.5), label=name)\n        if len(quantiles) > 1:\n            for i in range(1, len(quantiles)):\n                ax.fill_between(ds, fcst[f'{colname}{step}'], fcst[f'{colname}{step} {round(quantiles[i] * 100, 1)}%'], color='#0072B2', alpha=0.2)\n    if highlight_forecast is not None:\n        if line_per_origin:\n            num_forecast_steps = sum(fcst['origin-0'].notna())\n            steps_from_last = num_forecast_steps - highlight_forecast\n            for i in range(len(yhat_col_names)):\n                x = ds[-(1 + i + steps_from_last)]\n                y = fcst[f'origin-{i}'].values[-(1 + i + steps_from_last)]\n                ax.plot(x, y, 'bx')\n        else:\n            ax.plot(ds, fcst[f'yhat{highlight_forecast}'], ls='-', c='b', label=f'yhat{highlight_forecast}')\n            ax.plot(ds, fcst[f'yhat{highlight_forecast}'], 'bx', label=f'yhat{highlight_forecast}')\n            if len(quantiles) > 1:\n                for i in range(1, len(quantiles)):\n                    ax.fill_between(ds, fcst[f'yhat{highlight_forecast}'], fcst[f'yhat{highlight_forecast} {round(quantiles[i] * 100, 1)}%'], color='#0072B2', alpha=0.2)\n    ax.plot(ds, fcst['y'], 'k.', label='actual y')\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(ylabel)\n    (handles, labels) = ax.axes.get_legend_handles_labels()\n    if len(labels) > 10:\n        ax.legend(handles[:10] + [handles[-1]], labels[:10] + [labels[-1]])\n        log.warning('Legend is available only for the ten first handles')\n    else:\n        ax.legend(handles, labels)\n    fig = fig.tight_layout()\n    return fig",
            "def plot(fcst, quantiles, ax=None, xlabel='ds', ylabel='y', highlight_forecast=None, line_per_origin=False, figsize=(10, 6)):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Plot the NeuralProphet forecast.\\n\\n    Parameters\\n    ----------\\n        fcst : pd.DataFrame\\n            Output of m.predict\\n        quantiles: list\\n            Quantiles for which the forecasts are to be plotted\\n        ax : matplotlib axes\\n            Axes to plot on\\n        xlabel : str\\n            Label name on X-axis\\n        ylabel : str\\n            Label name on Y-axis\\n        highlight_forecast : int\\n            i-th step ahead forecast to highlight.\\n        line_per_origin : bool\\n            Print a line per forecast of one per forecast age\\n        figsize : tuple\\n            Width, height in inches.\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the NeuralProphet forecast\\n\\n    Examples\\n    --------\\n        Base usage\\n\\n        >>> from neuralprophet import NeuralProphet\\n        >>> m = NeuralProphet()\\n        >>> metrics = m.fit(df, freq=\"D\")\\n        >>> future = m.make_future_dataframe(df=df, periods=365)\\n        >>> forecast = m.predict(df=future)\\n        >>> fig_forecast = m.plot(forecast)\\n\\n        Additional plot specifications\\n\\n        >>> m.plot(forecast,\\n        >>>    xlabel=\"ds\",\\n        >>>    ylabel=\"y\",\\n        >>>    highlight_forecast=None,\\n        >>>    line_per_origin=False,\\n        >>>    figsize=(10, 6)\\n        >>>    )\\n\\n    '\n    fcst = fcst.fillna(value=np.nan)\n    if ax is None:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    else:\n        fig = ax.get_figure()\n    ds = fcst['ds'].dt.to_pydatetime()\n    colname = 'yhat'\n    step = 1\n    if line_per_origin:\n        colname = 'origin-'\n        step = 0\n    yhat_col_names = [col_name for col_name in fcst.columns if col_name.startswith(colname) and '%' not in col_name]\n    if highlight_forecast is None or line_per_origin:\n        for (i, name) in enumerate(yhat_col_names):\n            ax.plot(ds, fcst[f'{colname}{(i if line_per_origin else i + 1)}'], ls='-', c='#0072B2', alpha=0.2 + 2.0 / (i + 2.5), label=name)\n        if len(quantiles) > 1:\n            for i in range(1, len(quantiles)):\n                ax.fill_between(ds, fcst[f'{colname}{step}'], fcst[f'{colname}{step} {round(quantiles[i] * 100, 1)}%'], color='#0072B2', alpha=0.2)\n    if highlight_forecast is not None:\n        if line_per_origin:\n            num_forecast_steps = sum(fcst['origin-0'].notna())\n            steps_from_last = num_forecast_steps - highlight_forecast\n            for i in range(len(yhat_col_names)):\n                x = ds[-(1 + i + steps_from_last)]\n                y = fcst[f'origin-{i}'].values[-(1 + i + steps_from_last)]\n                ax.plot(x, y, 'bx')\n        else:\n            ax.plot(ds, fcst[f'yhat{highlight_forecast}'], ls='-', c='b', label=f'yhat{highlight_forecast}')\n            ax.plot(ds, fcst[f'yhat{highlight_forecast}'], 'bx', label=f'yhat{highlight_forecast}')\n            if len(quantiles) > 1:\n                for i in range(1, len(quantiles)):\n                    ax.fill_between(ds, fcst[f'yhat{highlight_forecast}'], fcst[f'yhat{highlight_forecast} {round(quantiles[i] * 100, 1)}%'], color='#0072B2', alpha=0.2)\n    ax.plot(ds, fcst['y'], 'k.', label='actual y')\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(ylabel)\n    (handles, labels) = ax.axes.get_legend_handles_labels()\n    if len(labels) > 10:\n        ax.legend(handles[:10] + [handles[-1]], labels[:10] + [labels[-1]])\n        log.warning('Legend is available only for the ten first handles')\n    else:\n        ax.legend(handles, labels)\n    fig = fig.tight_layout()\n    return fig",
            "def plot(fcst, quantiles, ax=None, xlabel='ds', ylabel='y', highlight_forecast=None, line_per_origin=False, figsize=(10, 6)):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Plot the NeuralProphet forecast.\\n\\n    Parameters\\n    ----------\\n        fcst : pd.DataFrame\\n            Output of m.predict\\n        quantiles: list\\n            Quantiles for which the forecasts are to be plotted\\n        ax : matplotlib axes\\n            Axes to plot on\\n        xlabel : str\\n            Label name on X-axis\\n        ylabel : str\\n            Label name on Y-axis\\n        highlight_forecast : int\\n            i-th step ahead forecast to highlight.\\n        line_per_origin : bool\\n            Print a line per forecast of one per forecast age\\n        figsize : tuple\\n            Width, height in inches.\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the NeuralProphet forecast\\n\\n    Examples\\n    --------\\n        Base usage\\n\\n        >>> from neuralprophet import NeuralProphet\\n        >>> m = NeuralProphet()\\n        >>> metrics = m.fit(df, freq=\"D\")\\n        >>> future = m.make_future_dataframe(df=df, periods=365)\\n        >>> forecast = m.predict(df=future)\\n        >>> fig_forecast = m.plot(forecast)\\n\\n        Additional plot specifications\\n\\n        >>> m.plot(forecast,\\n        >>>    xlabel=\"ds\",\\n        >>>    ylabel=\"y\",\\n        >>>    highlight_forecast=None,\\n        >>>    line_per_origin=False,\\n        >>>    figsize=(10, 6)\\n        >>>    )\\n\\n    '\n    fcst = fcst.fillna(value=np.nan)\n    if ax is None:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    else:\n        fig = ax.get_figure()\n    ds = fcst['ds'].dt.to_pydatetime()\n    colname = 'yhat'\n    step = 1\n    if line_per_origin:\n        colname = 'origin-'\n        step = 0\n    yhat_col_names = [col_name for col_name in fcst.columns if col_name.startswith(colname) and '%' not in col_name]\n    if highlight_forecast is None or line_per_origin:\n        for (i, name) in enumerate(yhat_col_names):\n            ax.plot(ds, fcst[f'{colname}{(i if line_per_origin else i + 1)}'], ls='-', c='#0072B2', alpha=0.2 + 2.0 / (i + 2.5), label=name)\n        if len(quantiles) > 1:\n            for i in range(1, len(quantiles)):\n                ax.fill_between(ds, fcst[f'{colname}{step}'], fcst[f'{colname}{step} {round(quantiles[i] * 100, 1)}%'], color='#0072B2', alpha=0.2)\n    if highlight_forecast is not None:\n        if line_per_origin:\n            num_forecast_steps = sum(fcst['origin-0'].notna())\n            steps_from_last = num_forecast_steps - highlight_forecast\n            for i in range(len(yhat_col_names)):\n                x = ds[-(1 + i + steps_from_last)]\n                y = fcst[f'origin-{i}'].values[-(1 + i + steps_from_last)]\n                ax.plot(x, y, 'bx')\n        else:\n            ax.plot(ds, fcst[f'yhat{highlight_forecast}'], ls='-', c='b', label=f'yhat{highlight_forecast}')\n            ax.plot(ds, fcst[f'yhat{highlight_forecast}'], 'bx', label=f'yhat{highlight_forecast}')\n            if len(quantiles) > 1:\n                for i in range(1, len(quantiles)):\n                    ax.fill_between(ds, fcst[f'yhat{highlight_forecast}'], fcst[f'yhat{highlight_forecast} {round(quantiles[i] * 100, 1)}%'], color='#0072B2', alpha=0.2)\n    ax.plot(ds, fcst['y'], 'k.', label='actual y')\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(ylabel)\n    (handles, labels) = ax.axes.get_legend_handles_labels()\n    if len(labels) > 10:\n        ax.legend(handles[:10] + [handles[-1]], labels[:10] + [labels[-1]])\n        log.warning('Legend is available only for the ten first handles')\n    else:\n        ax.legend(handles, labels)\n    fig = fig.tight_layout()\n    return fig",
            "def plot(fcst, quantiles, ax=None, xlabel='ds', ylabel='y', highlight_forecast=None, line_per_origin=False, figsize=(10, 6)):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Plot the NeuralProphet forecast.\\n\\n    Parameters\\n    ----------\\n        fcst : pd.DataFrame\\n            Output of m.predict\\n        quantiles: list\\n            Quantiles for which the forecasts are to be plotted\\n        ax : matplotlib axes\\n            Axes to plot on\\n        xlabel : str\\n            Label name on X-axis\\n        ylabel : str\\n            Label name on Y-axis\\n        highlight_forecast : int\\n            i-th step ahead forecast to highlight.\\n        line_per_origin : bool\\n            Print a line per forecast of one per forecast age\\n        figsize : tuple\\n            Width, height in inches.\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the NeuralProphet forecast\\n\\n    Examples\\n    --------\\n        Base usage\\n\\n        >>> from neuralprophet import NeuralProphet\\n        >>> m = NeuralProphet()\\n        >>> metrics = m.fit(df, freq=\"D\")\\n        >>> future = m.make_future_dataframe(df=df, periods=365)\\n        >>> forecast = m.predict(df=future)\\n        >>> fig_forecast = m.plot(forecast)\\n\\n        Additional plot specifications\\n\\n        >>> m.plot(forecast,\\n        >>>    xlabel=\"ds\",\\n        >>>    ylabel=\"y\",\\n        >>>    highlight_forecast=None,\\n        >>>    line_per_origin=False,\\n        >>>    figsize=(10, 6)\\n        >>>    )\\n\\n    '\n    fcst = fcst.fillna(value=np.nan)\n    if ax is None:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    else:\n        fig = ax.get_figure()\n    ds = fcst['ds'].dt.to_pydatetime()\n    colname = 'yhat'\n    step = 1\n    if line_per_origin:\n        colname = 'origin-'\n        step = 0\n    yhat_col_names = [col_name for col_name in fcst.columns if col_name.startswith(colname) and '%' not in col_name]\n    if highlight_forecast is None or line_per_origin:\n        for (i, name) in enumerate(yhat_col_names):\n            ax.plot(ds, fcst[f'{colname}{(i if line_per_origin else i + 1)}'], ls='-', c='#0072B2', alpha=0.2 + 2.0 / (i + 2.5), label=name)\n        if len(quantiles) > 1:\n            for i in range(1, len(quantiles)):\n                ax.fill_between(ds, fcst[f'{colname}{step}'], fcst[f'{colname}{step} {round(quantiles[i] * 100, 1)}%'], color='#0072B2', alpha=0.2)\n    if highlight_forecast is not None:\n        if line_per_origin:\n            num_forecast_steps = sum(fcst['origin-0'].notna())\n            steps_from_last = num_forecast_steps - highlight_forecast\n            for i in range(len(yhat_col_names)):\n                x = ds[-(1 + i + steps_from_last)]\n                y = fcst[f'origin-{i}'].values[-(1 + i + steps_from_last)]\n                ax.plot(x, y, 'bx')\n        else:\n            ax.plot(ds, fcst[f'yhat{highlight_forecast}'], ls='-', c='b', label=f'yhat{highlight_forecast}')\n            ax.plot(ds, fcst[f'yhat{highlight_forecast}'], 'bx', label=f'yhat{highlight_forecast}')\n            if len(quantiles) > 1:\n                for i in range(1, len(quantiles)):\n                    ax.fill_between(ds, fcst[f'yhat{highlight_forecast}'], fcst[f'yhat{highlight_forecast} {round(quantiles[i] * 100, 1)}%'], color='#0072B2', alpha=0.2)\n    ax.plot(ds, fcst['y'], 'k.', label='actual y')\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(ylabel)\n    (handles, labels) = ax.axes.get_legend_handles_labels()\n    if len(labels) > 10:\n        ax.legend(handles[:10] + [handles[-1]], labels[:10] + [labels[-1]])\n        log.warning('Legend is available only for the ten first handles')\n    else:\n        ax.legend(handles, labels)\n    fig = fig.tight_layout()\n    return fig"
        ]
    },
    {
        "func_name": "plot_components",
        "original": "def plot_components(m, fcst, plot_configuration, df_name='__df__', quantile=0.5, one_period_per_season=False, figsize=None):\n    \"\"\"Plot the NeuralProphet forecast components.\n\n    Parameters\n    ----------\n        m : NeuralProphet\n            Fitted model\n        fcst : pd.DataFrame\n            Output of m.predict\n        plot_configuration: dict\n            dict of configured components to plot\n        df_name : str\n            ID from time series that should be plotted\n        quantile : float\n            Quantile for which the forecast components are to be plotted\n        one_period_per_season : bool\n            Plot one period per season, instead of the true seasonal components of the forecast.\n        figsize : tuple\n            Width, height in inches.\n\n            Note\n            ----\n            Default value is set to ``None`` ->  automatic ``figsize = (10, 3 * npanel)``\n\n    Returns\n    -------\n        matplotlib.pyplot.figure\n            Figure showing the NeuralProphet forecast components\n    \"\"\"\n    log.debug('Plotting forecast components')\n    fcst = fcst.fillna(value=np.nan)\n    components_to_plot = plot_configuration['components_list']\n    panel_names = list(set((next(iter(dic.values())).lower() for dic in components_to_plot)))\n    panel_order = [x for dic in components_to_plot for x in panel_names if x in dic['plot_name'].lower()]\n    npanel = len(panel_names)\n    figsize = figsize if figsize else (10, 3 * npanel)\n    (fig, axes) = plt.subplots(npanel, 1, facecolor='w', figsize=figsize)\n    if npanel == 1:\n        axes = [axes]\n    multiplicative_axes = []\n    ax = 0\n    for comp in components_to_plot:\n        name = comp['plot_name'].lower()\n        ax = axes[panel_order.index(name)]\n        if name in ['trend'] or ('ar' in name and 'ahead' in name) or ('lagged regressor' in name and 'ahead' in name) or ('uncertainty' in name):\n            plot_forecast_component(fcst=fcst, ax=ax, **comp)\n        elif 'event' in name or 'future regressor' in name:\n            if 'multiplicative' in comp.keys() and comp['multiplicative']:\n                multiplicative_axes.append(ax)\n            plot_forecast_component(fcst=fcst, ax=ax, **comp)\n        elif 'season' in name:\n            if m.config_seasonality.mode == 'multiplicative':\n                multiplicative_axes.append(ax)\n            if one_period_per_season:\n                comp_name = comp['comp_name']\n                if comp_name.lower() == 'weekly' or m.config_seasonality.periods[comp_name].period == 7:\n                    plot_weekly(m=m, ax=ax, quantile=quantile, comp_name=comp_name, df_name=df_name)\n                elif comp_name.lower() == 'yearly' or m.config_seasonality.periods[comp_name].period == 365.25:\n                    plot_yearly(m=m, ax=ax, quantile=quantile, comp_name=comp_name, df_name=df_name)\n                elif comp_name.lower() == 'daily' or m.config_seasonality.periods[comp_name].period == 1:\n                    plot_daily(m=m, ax=ax, quantile=quantile, comp_name=comp_name, df_name=df_name)\n                else:\n                    plot_custom_season(m=m, ax=ax, quantile=quantile, comp_name=comp_name, df_name=df_name)\n            else:\n                comp_name = f\"season_{comp['comp_name']}\"\n                plot_forecast_component(fcst=fcst, ax=ax, comp_name=comp_name, plot_name=comp['plot_name'])\n        elif 'auto-regression' in name or 'lagged regressor' in name:\n            plot_multiforecast_component(fcst=fcst, ax=ax, **comp)\n    fig = fig.tight_layout()\n    for ax in multiplicative_axes:\n        ax = set_y_as_percent(ax)\n    return fig",
        "mutated": [
            "def plot_components(m, fcst, plot_configuration, df_name='__df__', quantile=0.5, one_period_per_season=False, figsize=None):\n    if False:\n        i = 10\n    'Plot the NeuralProphet forecast components.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        fcst : pd.DataFrame\\n            Output of m.predict\\n        plot_configuration: dict\\n            dict of configured components to plot\\n        df_name : str\\n            ID from time series that should be plotted\\n        quantile : float\\n            Quantile for which the forecast components are to be plotted\\n        one_period_per_season : bool\\n            Plot one period per season, instead of the true seasonal components of the forecast.\\n        figsize : tuple\\n            Width, height in inches.\\n\\n            Note\\n            ----\\n            Default value is set to ``None`` ->  automatic ``figsize = (10, 3 * npanel)``\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the NeuralProphet forecast components\\n    '\n    log.debug('Plotting forecast components')\n    fcst = fcst.fillna(value=np.nan)\n    components_to_plot = plot_configuration['components_list']\n    panel_names = list(set((next(iter(dic.values())).lower() for dic in components_to_plot)))\n    panel_order = [x for dic in components_to_plot for x in panel_names if x in dic['plot_name'].lower()]\n    npanel = len(panel_names)\n    figsize = figsize if figsize else (10, 3 * npanel)\n    (fig, axes) = plt.subplots(npanel, 1, facecolor='w', figsize=figsize)\n    if npanel == 1:\n        axes = [axes]\n    multiplicative_axes = []\n    ax = 0\n    for comp in components_to_plot:\n        name = comp['plot_name'].lower()\n        ax = axes[panel_order.index(name)]\n        if name in ['trend'] or ('ar' in name and 'ahead' in name) or ('lagged regressor' in name and 'ahead' in name) or ('uncertainty' in name):\n            plot_forecast_component(fcst=fcst, ax=ax, **comp)\n        elif 'event' in name or 'future regressor' in name:\n            if 'multiplicative' in comp.keys() and comp['multiplicative']:\n                multiplicative_axes.append(ax)\n            plot_forecast_component(fcst=fcst, ax=ax, **comp)\n        elif 'season' in name:\n            if m.config_seasonality.mode == 'multiplicative':\n                multiplicative_axes.append(ax)\n            if one_period_per_season:\n                comp_name = comp['comp_name']\n                if comp_name.lower() == 'weekly' or m.config_seasonality.periods[comp_name].period == 7:\n                    plot_weekly(m=m, ax=ax, quantile=quantile, comp_name=comp_name, df_name=df_name)\n                elif comp_name.lower() == 'yearly' or m.config_seasonality.periods[comp_name].period == 365.25:\n                    plot_yearly(m=m, ax=ax, quantile=quantile, comp_name=comp_name, df_name=df_name)\n                elif comp_name.lower() == 'daily' or m.config_seasonality.periods[comp_name].period == 1:\n                    plot_daily(m=m, ax=ax, quantile=quantile, comp_name=comp_name, df_name=df_name)\n                else:\n                    plot_custom_season(m=m, ax=ax, quantile=quantile, comp_name=comp_name, df_name=df_name)\n            else:\n                comp_name = f\"season_{comp['comp_name']}\"\n                plot_forecast_component(fcst=fcst, ax=ax, comp_name=comp_name, plot_name=comp['plot_name'])\n        elif 'auto-regression' in name or 'lagged regressor' in name:\n            plot_multiforecast_component(fcst=fcst, ax=ax, **comp)\n    fig = fig.tight_layout()\n    for ax in multiplicative_axes:\n        ax = set_y_as_percent(ax)\n    return fig",
            "def plot_components(m, fcst, plot_configuration, df_name='__df__', quantile=0.5, one_period_per_season=False, figsize=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Plot the NeuralProphet forecast components.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        fcst : pd.DataFrame\\n            Output of m.predict\\n        plot_configuration: dict\\n            dict of configured components to plot\\n        df_name : str\\n            ID from time series that should be plotted\\n        quantile : float\\n            Quantile for which the forecast components are to be plotted\\n        one_period_per_season : bool\\n            Plot one period per season, instead of the true seasonal components of the forecast.\\n        figsize : tuple\\n            Width, height in inches.\\n\\n            Note\\n            ----\\n            Default value is set to ``None`` ->  automatic ``figsize = (10, 3 * npanel)``\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the NeuralProphet forecast components\\n    '\n    log.debug('Plotting forecast components')\n    fcst = fcst.fillna(value=np.nan)\n    components_to_plot = plot_configuration['components_list']\n    panel_names = list(set((next(iter(dic.values())).lower() for dic in components_to_plot)))\n    panel_order = [x for dic in components_to_plot for x in panel_names if x in dic['plot_name'].lower()]\n    npanel = len(panel_names)\n    figsize = figsize if figsize else (10, 3 * npanel)\n    (fig, axes) = plt.subplots(npanel, 1, facecolor='w', figsize=figsize)\n    if npanel == 1:\n        axes = [axes]\n    multiplicative_axes = []\n    ax = 0\n    for comp in components_to_plot:\n        name = comp['plot_name'].lower()\n        ax = axes[panel_order.index(name)]\n        if name in ['trend'] or ('ar' in name and 'ahead' in name) or ('lagged regressor' in name and 'ahead' in name) or ('uncertainty' in name):\n            plot_forecast_component(fcst=fcst, ax=ax, **comp)\n        elif 'event' in name or 'future regressor' in name:\n            if 'multiplicative' in comp.keys() and comp['multiplicative']:\n                multiplicative_axes.append(ax)\n            plot_forecast_component(fcst=fcst, ax=ax, **comp)\n        elif 'season' in name:\n            if m.config_seasonality.mode == 'multiplicative':\n                multiplicative_axes.append(ax)\n            if one_period_per_season:\n                comp_name = comp['comp_name']\n                if comp_name.lower() == 'weekly' or m.config_seasonality.periods[comp_name].period == 7:\n                    plot_weekly(m=m, ax=ax, quantile=quantile, comp_name=comp_name, df_name=df_name)\n                elif comp_name.lower() == 'yearly' or m.config_seasonality.periods[comp_name].period == 365.25:\n                    plot_yearly(m=m, ax=ax, quantile=quantile, comp_name=comp_name, df_name=df_name)\n                elif comp_name.lower() == 'daily' or m.config_seasonality.periods[comp_name].period == 1:\n                    plot_daily(m=m, ax=ax, quantile=quantile, comp_name=comp_name, df_name=df_name)\n                else:\n                    plot_custom_season(m=m, ax=ax, quantile=quantile, comp_name=comp_name, df_name=df_name)\n            else:\n                comp_name = f\"season_{comp['comp_name']}\"\n                plot_forecast_component(fcst=fcst, ax=ax, comp_name=comp_name, plot_name=comp['plot_name'])\n        elif 'auto-regression' in name or 'lagged regressor' in name:\n            plot_multiforecast_component(fcst=fcst, ax=ax, **comp)\n    fig = fig.tight_layout()\n    for ax in multiplicative_axes:\n        ax = set_y_as_percent(ax)\n    return fig",
            "def plot_components(m, fcst, plot_configuration, df_name='__df__', quantile=0.5, one_period_per_season=False, figsize=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Plot the NeuralProphet forecast components.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        fcst : pd.DataFrame\\n            Output of m.predict\\n        plot_configuration: dict\\n            dict of configured components to plot\\n        df_name : str\\n            ID from time series that should be plotted\\n        quantile : float\\n            Quantile for which the forecast components are to be plotted\\n        one_period_per_season : bool\\n            Plot one period per season, instead of the true seasonal components of the forecast.\\n        figsize : tuple\\n            Width, height in inches.\\n\\n            Note\\n            ----\\n            Default value is set to ``None`` ->  automatic ``figsize = (10, 3 * npanel)``\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the NeuralProphet forecast components\\n    '\n    log.debug('Plotting forecast components')\n    fcst = fcst.fillna(value=np.nan)\n    components_to_plot = plot_configuration['components_list']\n    panel_names = list(set((next(iter(dic.values())).lower() for dic in components_to_plot)))\n    panel_order = [x for dic in components_to_plot for x in panel_names if x in dic['plot_name'].lower()]\n    npanel = len(panel_names)\n    figsize = figsize if figsize else (10, 3 * npanel)\n    (fig, axes) = plt.subplots(npanel, 1, facecolor='w', figsize=figsize)\n    if npanel == 1:\n        axes = [axes]\n    multiplicative_axes = []\n    ax = 0\n    for comp in components_to_plot:\n        name = comp['plot_name'].lower()\n        ax = axes[panel_order.index(name)]\n        if name in ['trend'] or ('ar' in name and 'ahead' in name) or ('lagged regressor' in name and 'ahead' in name) or ('uncertainty' in name):\n            plot_forecast_component(fcst=fcst, ax=ax, **comp)\n        elif 'event' in name or 'future regressor' in name:\n            if 'multiplicative' in comp.keys() and comp['multiplicative']:\n                multiplicative_axes.append(ax)\n            plot_forecast_component(fcst=fcst, ax=ax, **comp)\n        elif 'season' in name:\n            if m.config_seasonality.mode == 'multiplicative':\n                multiplicative_axes.append(ax)\n            if one_period_per_season:\n                comp_name = comp['comp_name']\n                if comp_name.lower() == 'weekly' or m.config_seasonality.periods[comp_name].period == 7:\n                    plot_weekly(m=m, ax=ax, quantile=quantile, comp_name=comp_name, df_name=df_name)\n                elif comp_name.lower() == 'yearly' or m.config_seasonality.periods[comp_name].period == 365.25:\n                    plot_yearly(m=m, ax=ax, quantile=quantile, comp_name=comp_name, df_name=df_name)\n                elif comp_name.lower() == 'daily' or m.config_seasonality.periods[comp_name].period == 1:\n                    plot_daily(m=m, ax=ax, quantile=quantile, comp_name=comp_name, df_name=df_name)\n                else:\n                    plot_custom_season(m=m, ax=ax, quantile=quantile, comp_name=comp_name, df_name=df_name)\n            else:\n                comp_name = f\"season_{comp['comp_name']}\"\n                plot_forecast_component(fcst=fcst, ax=ax, comp_name=comp_name, plot_name=comp['plot_name'])\n        elif 'auto-regression' in name or 'lagged regressor' in name:\n            plot_multiforecast_component(fcst=fcst, ax=ax, **comp)\n    fig = fig.tight_layout()\n    for ax in multiplicative_axes:\n        ax = set_y_as_percent(ax)\n    return fig",
            "def plot_components(m, fcst, plot_configuration, df_name='__df__', quantile=0.5, one_period_per_season=False, figsize=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Plot the NeuralProphet forecast components.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        fcst : pd.DataFrame\\n            Output of m.predict\\n        plot_configuration: dict\\n            dict of configured components to plot\\n        df_name : str\\n            ID from time series that should be plotted\\n        quantile : float\\n            Quantile for which the forecast components are to be plotted\\n        one_period_per_season : bool\\n            Plot one period per season, instead of the true seasonal components of the forecast.\\n        figsize : tuple\\n            Width, height in inches.\\n\\n            Note\\n            ----\\n            Default value is set to ``None`` ->  automatic ``figsize = (10, 3 * npanel)``\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the NeuralProphet forecast components\\n    '\n    log.debug('Plotting forecast components')\n    fcst = fcst.fillna(value=np.nan)\n    components_to_plot = plot_configuration['components_list']\n    panel_names = list(set((next(iter(dic.values())).lower() for dic in components_to_plot)))\n    panel_order = [x for dic in components_to_plot for x in panel_names if x in dic['plot_name'].lower()]\n    npanel = len(panel_names)\n    figsize = figsize if figsize else (10, 3 * npanel)\n    (fig, axes) = plt.subplots(npanel, 1, facecolor='w', figsize=figsize)\n    if npanel == 1:\n        axes = [axes]\n    multiplicative_axes = []\n    ax = 0\n    for comp in components_to_plot:\n        name = comp['plot_name'].lower()\n        ax = axes[panel_order.index(name)]\n        if name in ['trend'] or ('ar' in name and 'ahead' in name) or ('lagged regressor' in name and 'ahead' in name) or ('uncertainty' in name):\n            plot_forecast_component(fcst=fcst, ax=ax, **comp)\n        elif 'event' in name or 'future regressor' in name:\n            if 'multiplicative' in comp.keys() and comp['multiplicative']:\n                multiplicative_axes.append(ax)\n            plot_forecast_component(fcst=fcst, ax=ax, **comp)\n        elif 'season' in name:\n            if m.config_seasonality.mode == 'multiplicative':\n                multiplicative_axes.append(ax)\n            if one_period_per_season:\n                comp_name = comp['comp_name']\n                if comp_name.lower() == 'weekly' or m.config_seasonality.periods[comp_name].period == 7:\n                    plot_weekly(m=m, ax=ax, quantile=quantile, comp_name=comp_name, df_name=df_name)\n                elif comp_name.lower() == 'yearly' or m.config_seasonality.periods[comp_name].period == 365.25:\n                    plot_yearly(m=m, ax=ax, quantile=quantile, comp_name=comp_name, df_name=df_name)\n                elif comp_name.lower() == 'daily' or m.config_seasonality.periods[comp_name].period == 1:\n                    plot_daily(m=m, ax=ax, quantile=quantile, comp_name=comp_name, df_name=df_name)\n                else:\n                    plot_custom_season(m=m, ax=ax, quantile=quantile, comp_name=comp_name, df_name=df_name)\n            else:\n                comp_name = f\"season_{comp['comp_name']}\"\n                plot_forecast_component(fcst=fcst, ax=ax, comp_name=comp_name, plot_name=comp['plot_name'])\n        elif 'auto-regression' in name or 'lagged regressor' in name:\n            plot_multiforecast_component(fcst=fcst, ax=ax, **comp)\n    fig = fig.tight_layout()\n    for ax in multiplicative_axes:\n        ax = set_y_as_percent(ax)\n    return fig",
            "def plot_components(m, fcst, plot_configuration, df_name='__df__', quantile=0.5, one_period_per_season=False, figsize=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Plot the NeuralProphet forecast components.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        fcst : pd.DataFrame\\n            Output of m.predict\\n        plot_configuration: dict\\n            dict of configured components to plot\\n        df_name : str\\n            ID from time series that should be plotted\\n        quantile : float\\n            Quantile for which the forecast components are to be plotted\\n        one_period_per_season : bool\\n            Plot one period per season, instead of the true seasonal components of the forecast.\\n        figsize : tuple\\n            Width, height in inches.\\n\\n            Note\\n            ----\\n            Default value is set to ``None`` ->  automatic ``figsize = (10, 3 * npanel)``\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the NeuralProphet forecast components\\n    '\n    log.debug('Plotting forecast components')\n    fcst = fcst.fillna(value=np.nan)\n    components_to_plot = plot_configuration['components_list']\n    panel_names = list(set((next(iter(dic.values())).lower() for dic in components_to_plot)))\n    panel_order = [x for dic in components_to_plot for x in panel_names if x in dic['plot_name'].lower()]\n    npanel = len(panel_names)\n    figsize = figsize if figsize else (10, 3 * npanel)\n    (fig, axes) = plt.subplots(npanel, 1, facecolor='w', figsize=figsize)\n    if npanel == 1:\n        axes = [axes]\n    multiplicative_axes = []\n    ax = 0\n    for comp in components_to_plot:\n        name = comp['plot_name'].lower()\n        ax = axes[panel_order.index(name)]\n        if name in ['trend'] or ('ar' in name and 'ahead' in name) or ('lagged regressor' in name and 'ahead' in name) or ('uncertainty' in name):\n            plot_forecast_component(fcst=fcst, ax=ax, **comp)\n        elif 'event' in name or 'future regressor' in name:\n            if 'multiplicative' in comp.keys() and comp['multiplicative']:\n                multiplicative_axes.append(ax)\n            plot_forecast_component(fcst=fcst, ax=ax, **comp)\n        elif 'season' in name:\n            if m.config_seasonality.mode == 'multiplicative':\n                multiplicative_axes.append(ax)\n            if one_period_per_season:\n                comp_name = comp['comp_name']\n                if comp_name.lower() == 'weekly' or m.config_seasonality.periods[comp_name].period == 7:\n                    plot_weekly(m=m, ax=ax, quantile=quantile, comp_name=comp_name, df_name=df_name)\n                elif comp_name.lower() == 'yearly' or m.config_seasonality.periods[comp_name].period == 365.25:\n                    plot_yearly(m=m, ax=ax, quantile=quantile, comp_name=comp_name, df_name=df_name)\n                elif comp_name.lower() == 'daily' or m.config_seasonality.periods[comp_name].period == 1:\n                    plot_daily(m=m, ax=ax, quantile=quantile, comp_name=comp_name, df_name=df_name)\n                else:\n                    plot_custom_season(m=m, ax=ax, quantile=quantile, comp_name=comp_name, df_name=df_name)\n            else:\n                comp_name = f\"season_{comp['comp_name']}\"\n                plot_forecast_component(fcst=fcst, ax=ax, comp_name=comp_name, plot_name=comp['plot_name'])\n        elif 'auto-regression' in name or 'lagged regressor' in name:\n            plot_multiforecast_component(fcst=fcst, ax=ax, **comp)\n    fig = fig.tight_layout()\n    for ax in multiplicative_axes:\n        ax = set_y_as_percent(ax)\n    return fig"
        ]
    },
    {
        "func_name": "plot_forecast_component",
        "original": "def plot_forecast_component(fcst, comp_name, plot_name=None, ax=None, figsize=(10, 6), multiplicative=False, bar=False, rolling=None, add_x=False, fill=False):\n    \"\"\"Plot a particular component of the forecast.\n\n    Parameters\n    ----------\n        fcst : pd.DataFrame\n            Output of m.predict\n        comp_name : str\n            Name of the component to plot\n        plot_name : str\n            Name of the plot Title\n        ax : matplotlib axis\n            Matplotlib Axes to plot on\n        figsize : tuple\n            Width, height in inches. Ignored if ax is not None\n\n            Note\n            ----\n            Default value is set to ``figsize = (10, 6)``\n        multiplicative : bool\n            Set y axis as percentage\n        bar : bool\n            Make barplot\n        rolling : int\n            Rolling average underplot\n        add_x : bool\n            Add x symbols to plotted points\n        fill: bool\n            Add fill between signal and x(y=0) axis\n\n    Returns\n    -------\n        matplotlib.artist.Artist\n            List of Artist objects containing a particular forecast component\n    \"\"\"\n    fcst = fcst.fillna(value=np.nan)\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    fcst_t = fcst['ds'].dt.to_pydatetime()\n    if rolling is not None:\n        rolling_avg = fcst[comp_name].rolling(rolling, min_periods=1, center=True).mean()\n        if bar:\n            artists += ax.bar(fcst_t, rolling_avg, width=1.0, color='#0072B2', alpha=0.5)\n        else:\n            artists += ax.plot(fcst_t, rolling_avg, ls='-', color='#0072B2', alpha=0.5)\n            if add_x:\n                artists += ax.plot(fcst_t, fcst[comp_name], 'bx')\n    if 'uncertainty' in plot_name.lower():\n        y = fcst[comp_name].values - fcst['yhat1'].values\n        label = comp_name\n    else:\n        y = fcst[comp_name].values\n        label = None\n    if bar:\n        artists += ax.bar(fcst_t, y, width=1.0, color='#0072B2')\n    elif 'uncertainty' in plot_name.lower() and fill:\n        ax.fill_between(fcst_t, 0, y, alpha=0.2, label=label, color='#0072B2')\n    else:\n        artists += ax.plot(fcst_t, y, ls='-', c='#0072B2')\n        if add_x or sum(fcst[comp_name].notna()) == 1:\n            artists += ax.plot(fcst_t, y, 'bx')\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel('ds')\n    if plot_name is None:\n        plot_name = comp_name\n    ax.set_ylabel(plot_name)\n    if multiplicative:\n        ax = set_y_as_percent(ax)\n    (handles, labels) = ax.axes.get_legend_handles_labels()\n    ax.legend(handles, labels)\n    return ax",
        "mutated": [
            "def plot_forecast_component(fcst, comp_name, plot_name=None, ax=None, figsize=(10, 6), multiplicative=False, bar=False, rolling=None, add_x=False, fill=False):\n    if False:\n        i = 10\n    'Plot a particular component of the forecast.\\n\\n    Parameters\\n    ----------\\n        fcst : pd.DataFrame\\n            Output of m.predict\\n        comp_name : str\\n            Name of the component to plot\\n        plot_name : str\\n            Name of the plot Title\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches. Ignored if ax is not None\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        multiplicative : bool\\n            Set y axis as percentage\\n        bar : bool\\n            Make barplot\\n        rolling : int\\n            Rolling average underplot\\n        add_x : bool\\n            Add x symbols to plotted points\\n        fill: bool\\n            Add fill between signal and x(y=0) axis\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing a particular forecast component\\n    '\n    fcst = fcst.fillna(value=np.nan)\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    fcst_t = fcst['ds'].dt.to_pydatetime()\n    if rolling is not None:\n        rolling_avg = fcst[comp_name].rolling(rolling, min_periods=1, center=True).mean()\n        if bar:\n            artists += ax.bar(fcst_t, rolling_avg, width=1.0, color='#0072B2', alpha=0.5)\n        else:\n            artists += ax.plot(fcst_t, rolling_avg, ls='-', color='#0072B2', alpha=0.5)\n            if add_x:\n                artists += ax.plot(fcst_t, fcst[comp_name], 'bx')\n    if 'uncertainty' in plot_name.lower():\n        y = fcst[comp_name].values - fcst['yhat1'].values\n        label = comp_name\n    else:\n        y = fcst[comp_name].values\n        label = None\n    if bar:\n        artists += ax.bar(fcst_t, y, width=1.0, color='#0072B2')\n    elif 'uncertainty' in plot_name.lower() and fill:\n        ax.fill_between(fcst_t, 0, y, alpha=0.2, label=label, color='#0072B2')\n    else:\n        artists += ax.plot(fcst_t, y, ls='-', c='#0072B2')\n        if add_x or sum(fcst[comp_name].notna()) == 1:\n            artists += ax.plot(fcst_t, y, 'bx')\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel('ds')\n    if plot_name is None:\n        plot_name = comp_name\n    ax.set_ylabel(plot_name)\n    if multiplicative:\n        ax = set_y_as_percent(ax)\n    (handles, labels) = ax.axes.get_legend_handles_labels()\n    ax.legend(handles, labels)\n    return ax",
            "def plot_forecast_component(fcst, comp_name, plot_name=None, ax=None, figsize=(10, 6), multiplicative=False, bar=False, rolling=None, add_x=False, fill=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Plot a particular component of the forecast.\\n\\n    Parameters\\n    ----------\\n        fcst : pd.DataFrame\\n            Output of m.predict\\n        comp_name : str\\n            Name of the component to plot\\n        plot_name : str\\n            Name of the plot Title\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches. Ignored if ax is not None\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        multiplicative : bool\\n            Set y axis as percentage\\n        bar : bool\\n            Make barplot\\n        rolling : int\\n            Rolling average underplot\\n        add_x : bool\\n            Add x symbols to plotted points\\n        fill: bool\\n            Add fill between signal and x(y=0) axis\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing a particular forecast component\\n    '\n    fcst = fcst.fillna(value=np.nan)\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    fcst_t = fcst['ds'].dt.to_pydatetime()\n    if rolling is not None:\n        rolling_avg = fcst[comp_name].rolling(rolling, min_periods=1, center=True).mean()\n        if bar:\n            artists += ax.bar(fcst_t, rolling_avg, width=1.0, color='#0072B2', alpha=0.5)\n        else:\n            artists += ax.plot(fcst_t, rolling_avg, ls='-', color='#0072B2', alpha=0.5)\n            if add_x:\n                artists += ax.plot(fcst_t, fcst[comp_name], 'bx')\n    if 'uncertainty' in plot_name.lower():\n        y = fcst[comp_name].values - fcst['yhat1'].values\n        label = comp_name\n    else:\n        y = fcst[comp_name].values\n        label = None\n    if bar:\n        artists += ax.bar(fcst_t, y, width=1.0, color='#0072B2')\n    elif 'uncertainty' in plot_name.lower() and fill:\n        ax.fill_between(fcst_t, 0, y, alpha=0.2, label=label, color='#0072B2')\n    else:\n        artists += ax.plot(fcst_t, y, ls='-', c='#0072B2')\n        if add_x or sum(fcst[comp_name].notna()) == 1:\n            artists += ax.plot(fcst_t, y, 'bx')\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel('ds')\n    if plot_name is None:\n        plot_name = comp_name\n    ax.set_ylabel(plot_name)\n    if multiplicative:\n        ax = set_y_as_percent(ax)\n    (handles, labels) = ax.axes.get_legend_handles_labels()\n    ax.legend(handles, labels)\n    return ax",
            "def plot_forecast_component(fcst, comp_name, plot_name=None, ax=None, figsize=(10, 6), multiplicative=False, bar=False, rolling=None, add_x=False, fill=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Plot a particular component of the forecast.\\n\\n    Parameters\\n    ----------\\n        fcst : pd.DataFrame\\n            Output of m.predict\\n        comp_name : str\\n            Name of the component to plot\\n        plot_name : str\\n            Name of the plot Title\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches. Ignored if ax is not None\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        multiplicative : bool\\n            Set y axis as percentage\\n        bar : bool\\n            Make barplot\\n        rolling : int\\n            Rolling average underplot\\n        add_x : bool\\n            Add x symbols to plotted points\\n        fill: bool\\n            Add fill between signal and x(y=0) axis\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing a particular forecast component\\n    '\n    fcst = fcst.fillna(value=np.nan)\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    fcst_t = fcst['ds'].dt.to_pydatetime()\n    if rolling is not None:\n        rolling_avg = fcst[comp_name].rolling(rolling, min_periods=1, center=True).mean()\n        if bar:\n            artists += ax.bar(fcst_t, rolling_avg, width=1.0, color='#0072B2', alpha=0.5)\n        else:\n            artists += ax.plot(fcst_t, rolling_avg, ls='-', color='#0072B2', alpha=0.5)\n            if add_x:\n                artists += ax.plot(fcst_t, fcst[comp_name], 'bx')\n    if 'uncertainty' in plot_name.lower():\n        y = fcst[comp_name].values - fcst['yhat1'].values\n        label = comp_name\n    else:\n        y = fcst[comp_name].values\n        label = None\n    if bar:\n        artists += ax.bar(fcst_t, y, width=1.0, color='#0072B2')\n    elif 'uncertainty' in plot_name.lower() and fill:\n        ax.fill_between(fcst_t, 0, y, alpha=0.2, label=label, color='#0072B2')\n    else:\n        artists += ax.plot(fcst_t, y, ls='-', c='#0072B2')\n        if add_x or sum(fcst[comp_name].notna()) == 1:\n            artists += ax.plot(fcst_t, y, 'bx')\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel('ds')\n    if plot_name is None:\n        plot_name = comp_name\n    ax.set_ylabel(plot_name)\n    if multiplicative:\n        ax = set_y_as_percent(ax)\n    (handles, labels) = ax.axes.get_legend_handles_labels()\n    ax.legend(handles, labels)\n    return ax",
            "def plot_forecast_component(fcst, comp_name, plot_name=None, ax=None, figsize=(10, 6), multiplicative=False, bar=False, rolling=None, add_x=False, fill=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Plot a particular component of the forecast.\\n\\n    Parameters\\n    ----------\\n        fcst : pd.DataFrame\\n            Output of m.predict\\n        comp_name : str\\n            Name of the component to plot\\n        plot_name : str\\n            Name of the plot Title\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches. Ignored if ax is not None\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        multiplicative : bool\\n            Set y axis as percentage\\n        bar : bool\\n            Make barplot\\n        rolling : int\\n            Rolling average underplot\\n        add_x : bool\\n            Add x symbols to plotted points\\n        fill: bool\\n            Add fill between signal and x(y=0) axis\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing a particular forecast component\\n    '\n    fcst = fcst.fillna(value=np.nan)\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    fcst_t = fcst['ds'].dt.to_pydatetime()\n    if rolling is not None:\n        rolling_avg = fcst[comp_name].rolling(rolling, min_periods=1, center=True).mean()\n        if bar:\n            artists += ax.bar(fcst_t, rolling_avg, width=1.0, color='#0072B2', alpha=0.5)\n        else:\n            artists += ax.plot(fcst_t, rolling_avg, ls='-', color='#0072B2', alpha=0.5)\n            if add_x:\n                artists += ax.plot(fcst_t, fcst[comp_name], 'bx')\n    if 'uncertainty' in plot_name.lower():\n        y = fcst[comp_name].values - fcst['yhat1'].values\n        label = comp_name\n    else:\n        y = fcst[comp_name].values\n        label = None\n    if bar:\n        artists += ax.bar(fcst_t, y, width=1.0, color='#0072B2')\n    elif 'uncertainty' in plot_name.lower() and fill:\n        ax.fill_between(fcst_t, 0, y, alpha=0.2, label=label, color='#0072B2')\n    else:\n        artists += ax.plot(fcst_t, y, ls='-', c='#0072B2')\n        if add_x or sum(fcst[comp_name].notna()) == 1:\n            artists += ax.plot(fcst_t, y, 'bx')\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel('ds')\n    if plot_name is None:\n        plot_name = comp_name\n    ax.set_ylabel(plot_name)\n    if multiplicative:\n        ax = set_y_as_percent(ax)\n    (handles, labels) = ax.axes.get_legend_handles_labels()\n    ax.legend(handles, labels)\n    return ax",
            "def plot_forecast_component(fcst, comp_name, plot_name=None, ax=None, figsize=(10, 6), multiplicative=False, bar=False, rolling=None, add_x=False, fill=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Plot a particular component of the forecast.\\n\\n    Parameters\\n    ----------\\n        fcst : pd.DataFrame\\n            Output of m.predict\\n        comp_name : str\\n            Name of the component to plot\\n        plot_name : str\\n            Name of the plot Title\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches. Ignored if ax is not None\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        multiplicative : bool\\n            Set y axis as percentage\\n        bar : bool\\n            Make barplot\\n        rolling : int\\n            Rolling average underplot\\n        add_x : bool\\n            Add x symbols to plotted points\\n        fill: bool\\n            Add fill between signal and x(y=0) axis\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing a particular forecast component\\n    '\n    fcst = fcst.fillna(value=np.nan)\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    fcst_t = fcst['ds'].dt.to_pydatetime()\n    if rolling is not None:\n        rolling_avg = fcst[comp_name].rolling(rolling, min_periods=1, center=True).mean()\n        if bar:\n            artists += ax.bar(fcst_t, rolling_avg, width=1.0, color='#0072B2', alpha=0.5)\n        else:\n            artists += ax.plot(fcst_t, rolling_avg, ls='-', color='#0072B2', alpha=0.5)\n            if add_x:\n                artists += ax.plot(fcst_t, fcst[comp_name], 'bx')\n    if 'uncertainty' in plot_name.lower():\n        y = fcst[comp_name].values - fcst['yhat1'].values\n        label = comp_name\n    else:\n        y = fcst[comp_name].values\n        label = None\n    if bar:\n        artists += ax.bar(fcst_t, y, width=1.0, color='#0072B2')\n    elif 'uncertainty' in plot_name.lower() and fill:\n        ax.fill_between(fcst_t, 0, y, alpha=0.2, label=label, color='#0072B2')\n    else:\n        artists += ax.plot(fcst_t, y, ls='-', c='#0072B2')\n        if add_x or sum(fcst[comp_name].notna()) == 1:\n            artists += ax.plot(fcst_t, y, 'bx')\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel('ds')\n    if plot_name is None:\n        plot_name = comp_name\n    ax.set_ylabel(plot_name)\n    if multiplicative:\n        ax = set_y_as_percent(ax)\n    (handles, labels) = ax.axes.get_legend_handles_labels()\n    ax.legend(handles, labels)\n    return ax"
        ]
    },
    {
        "func_name": "plot_multiforecast_component",
        "original": "def plot_multiforecast_component(fcst, comp_name, plot_name=None, ax=None, figsize=(10, 6), multiplicative=False, bar=False, focus=1, num_overplot=None):\n    \"\"\"Plot a particular component of the forecast.\n\n    Parameters\n    ----------\n        fcst : pd.DataFrame\n            Output of m.predict.\n        comp_name : str\n            Name of the component to plot.\n        plot_name : str\n            Name of the plot Title.\n        ax : matplotlib axis\n            Matplotlib Axes to plot on.\n        figsize : tuple\n            Width, height in inches, ignored if ax is not None.\n\n            Note\n            ----\n            Default value is set to ``figsize = (10, 6)``\n\n        multiplicative : bool\n            Set y axis as percentage\n        bar : bool\n            Make barplot\n        focus : int\n            Forecast number to portray in detail.\n        num_overplot : int\n            Overplot all forecasts up to num\n\n            Note\n            ----\n            Default value is set to ``num_overplot = None`` -> only plot focus\n\n    Returns\n    -------\n        matplotlib.artist.Artist\n            List of Artist objects containing a particular forecast component\n    \"\"\"\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    fcst_t = fcst['ds'].dt.to_pydatetime()\n    col_names = [col_name for col_name in fcst.columns if col_name.startswith(comp_name)]\n    if num_overplot is not None:\n        assert num_overplot <= len(col_names)\n        for i in list(range(num_overplot))[::-1]:\n            y = fcst[f'{comp_name}{i + 1}']\n            y = y.values\n            alpha_min = 0.2\n            alpha_softness = 1.2\n            alpha = alpha_min + alpha_softness * (1.0 - alpha_min) / (i + 1.0 * alpha_softness)\n            y[-1] = 0\n            if bar:\n                artists += ax.bar(fcst_t, y, width=1.0, color='#0072B2', alpha=alpha)\n            else:\n                artists += ax.plot(fcst_t, y, ls='-', color='#0072B2', alpha=alpha)\n    if num_overplot is None or focus > 1:\n        y = fcst[f'{comp_name}{focus}']\n        y = y.values\n        y[-1] = 0\n        if bar:\n            artists += ax.bar(fcst_t, y, width=1.0, color='b')\n        else:\n            artists += ax.plot(fcst_t, y, ls='-', color='b')\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', color='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel('ds')\n    if plot_name is None:\n        plot_name = comp_name\n    ax.set_ylabel(plot_name)\n    if multiplicative:\n        ax = set_y_as_percent(ax)\n    return artists",
        "mutated": [
            "def plot_multiforecast_component(fcst, comp_name, plot_name=None, ax=None, figsize=(10, 6), multiplicative=False, bar=False, focus=1, num_overplot=None):\n    if False:\n        i = 10\n    'Plot a particular component of the forecast.\\n\\n    Parameters\\n    ----------\\n        fcst : pd.DataFrame\\n            Output of m.predict.\\n        comp_name : str\\n            Name of the component to plot.\\n        plot_name : str\\n            Name of the plot Title.\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on.\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n        multiplicative : bool\\n            Set y axis as percentage\\n        bar : bool\\n            Make barplot\\n        focus : int\\n            Forecast number to portray in detail.\\n        num_overplot : int\\n            Overplot all forecasts up to num\\n\\n            Note\\n            ----\\n            Default value is set to ``num_overplot = None`` -> only plot focus\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing a particular forecast component\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    fcst_t = fcst['ds'].dt.to_pydatetime()\n    col_names = [col_name for col_name in fcst.columns if col_name.startswith(comp_name)]\n    if num_overplot is not None:\n        assert num_overplot <= len(col_names)\n        for i in list(range(num_overplot))[::-1]:\n            y = fcst[f'{comp_name}{i + 1}']\n            y = y.values\n            alpha_min = 0.2\n            alpha_softness = 1.2\n            alpha = alpha_min + alpha_softness * (1.0 - alpha_min) / (i + 1.0 * alpha_softness)\n            y[-1] = 0\n            if bar:\n                artists += ax.bar(fcst_t, y, width=1.0, color='#0072B2', alpha=alpha)\n            else:\n                artists += ax.plot(fcst_t, y, ls='-', color='#0072B2', alpha=alpha)\n    if num_overplot is None or focus > 1:\n        y = fcst[f'{comp_name}{focus}']\n        y = y.values\n        y[-1] = 0\n        if bar:\n            artists += ax.bar(fcst_t, y, width=1.0, color='b')\n        else:\n            artists += ax.plot(fcst_t, y, ls='-', color='b')\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', color='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel('ds')\n    if plot_name is None:\n        plot_name = comp_name\n    ax.set_ylabel(plot_name)\n    if multiplicative:\n        ax = set_y_as_percent(ax)\n    return artists",
            "def plot_multiforecast_component(fcst, comp_name, plot_name=None, ax=None, figsize=(10, 6), multiplicative=False, bar=False, focus=1, num_overplot=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Plot a particular component of the forecast.\\n\\n    Parameters\\n    ----------\\n        fcst : pd.DataFrame\\n            Output of m.predict.\\n        comp_name : str\\n            Name of the component to plot.\\n        plot_name : str\\n            Name of the plot Title.\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on.\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n        multiplicative : bool\\n            Set y axis as percentage\\n        bar : bool\\n            Make barplot\\n        focus : int\\n            Forecast number to portray in detail.\\n        num_overplot : int\\n            Overplot all forecasts up to num\\n\\n            Note\\n            ----\\n            Default value is set to ``num_overplot = None`` -> only plot focus\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing a particular forecast component\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    fcst_t = fcst['ds'].dt.to_pydatetime()\n    col_names = [col_name for col_name in fcst.columns if col_name.startswith(comp_name)]\n    if num_overplot is not None:\n        assert num_overplot <= len(col_names)\n        for i in list(range(num_overplot))[::-1]:\n            y = fcst[f'{comp_name}{i + 1}']\n            y = y.values\n            alpha_min = 0.2\n            alpha_softness = 1.2\n            alpha = alpha_min + alpha_softness * (1.0 - alpha_min) / (i + 1.0 * alpha_softness)\n            y[-1] = 0\n            if bar:\n                artists += ax.bar(fcst_t, y, width=1.0, color='#0072B2', alpha=alpha)\n            else:\n                artists += ax.plot(fcst_t, y, ls='-', color='#0072B2', alpha=alpha)\n    if num_overplot is None or focus > 1:\n        y = fcst[f'{comp_name}{focus}']\n        y = y.values\n        y[-1] = 0\n        if bar:\n            artists += ax.bar(fcst_t, y, width=1.0, color='b')\n        else:\n            artists += ax.plot(fcst_t, y, ls='-', color='b')\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', color='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel('ds')\n    if plot_name is None:\n        plot_name = comp_name\n    ax.set_ylabel(plot_name)\n    if multiplicative:\n        ax = set_y_as_percent(ax)\n    return artists",
            "def plot_multiforecast_component(fcst, comp_name, plot_name=None, ax=None, figsize=(10, 6), multiplicative=False, bar=False, focus=1, num_overplot=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Plot a particular component of the forecast.\\n\\n    Parameters\\n    ----------\\n        fcst : pd.DataFrame\\n            Output of m.predict.\\n        comp_name : str\\n            Name of the component to plot.\\n        plot_name : str\\n            Name of the plot Title.\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on.\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n        multiplicative : bool\\n            Set y axis as percentage\\n        bar : bool\\n            Make barplot\\n        focus : int\\n            Forecast number to portray in detail.\\n        num_overplot : int\\n            Overplot all forecasts up to num\\n\\n            Note\\n            ----\\n            Default value is set to ``num_overplot = None`` -> only plot focus\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing a particular forecast component\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    fcst_t = fcst['ds'].dt.to_pydatetime()\n    col_names = [col_name for col_name in fcst.columns if col_name.startswith(comp_name)]\n    if num_overplot is not None:\n        assert num_overplot <= len(col_names)\n        for i in list(range(num_overplot))[::-1]:\n            y = fcst[f'{comp_name}{i + 1}']\n            y = y.values\n            alpha_min = 0.2\n            alpha_softness = 1.2\n            alpha = alpha_min + alpha_softness * (1.0 - alpha_min) / (i + 1.0 * alpha_softness)\n            y[-1] = 0\n            if bar:\n                artists += ax.bar(fcst_t, y, width=1.0, color='#0072B2', alpha=alpha)\n            else:\n                artists += ax.plot(fcst_t, y, ls='-', color='#0072B2', alpha=alpha)\n    if num_overplot is None or focus > 1:\n        y = fcst[f'{comp_name}{focus}']\n        y = y.values\n        y[-1] = 0\n        if bar:\n            artists += ax.bar(fcst_t, y, width=1.0, color='b')\n        else:\n            artists += ax.plot(fcst_t, y, ls='-', color='b')\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', color='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel('ds')\n    if plot_name is None:\n        plot_name = comp_name\n    ax.set_ylabel(plot_name)\n    if multiplicative:\n        ax = set_y_as_percent(ax)\n    return artists",
            "def plot_multiforecast_component(fcst, comp_name, plot_name=None, ax=None, figsize=(10, 6), multiplicative=False, bar=False, focus=1, num_overplot=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Plot a particular component of the forecast.\\n\\n    Parameters\\n    ----------\\n        fcst : pd.DataFrame\\n            Output of m.predict.\\n        comp_name : str\\n            Name of the component to plot.\\n        plot_name : str\\n            Name of the plot Title.\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on.\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n        multiplicative : bool\\n            Set y axis as percentage\\n        bar : bool\\n            Make barplot\\n        focus : int\\n            Forecast number to portray in detail.\\n        num_overplot : int\\n            Overplot all forecasts up to num\\n\\n            Note\\n            ----\\n            Default value is set to ``num_overplot = None`` -> only plot focus\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing a particular forecast component\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    fcst_t = fcst['ds'].dt.to_pydatetime()\n    col_names = [col_name for col_name in fcst.columns if col_name.startswith(comp_name)]\n    if num_overplot is not None:\n        assert num_overplot <= len(col_names)\n        for i in list(range(num_overplot))[::-1]:\n            y = fcst[f'{comp_name}{i + 1}']\n            y = y.values\n            alpha_min = 0.2\n            alpha_softness = 1.2\n            alpha = alpha_min + alpha_softness * (1.0 - alpha_min) / (i + 1.0 * alpha_softness)\n            y[-1] = 0\n            if bar:\n                artists += ax.bar(fcst_t, y, width=1.0, color='#0072B2', alpha=alpha)\n            else:\n                artists += ax.plot(fcst_t, y, ls='-', color='#0072B2', alpha=alpha)\n    if num_overplot is None or focus > 1:\n        y = fcst[f'{comp_name}{focus}']\n        y = y.values\n        y[-1] = 0\n        if bar:\n            artists += ax.bar(fcst_t, y, width=1.0, color='b')\n        else:\n            artists += ax.plot(fcst_t, y, ls='-', color='b')\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', color='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel('ds')\n    if plot_name is None:\n        plot_name = comp_name\n    ax.set_ylabel(plot_name)\n    if multiplicative:\n        ax = set_y_as_percent(ax)\n    return artists",
            "def plot_multiforecast_component(fcst, comp_name, plot_name=None, ax=None, figsize=(10, 6), multiplicative=False, bar=False, focus=1, num_overplot=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Plot a particular component of the forecast.\\n\\n    Parameters\\n    ----------\\n        fcst : pd.DataFrame\\n            Output of m.predict.\\n        comp_name : str\\n            Name of the component to plot.\\n        plot_name : str\\n            Name of the plot Title.\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on.\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n        multiplicative : bool\\n            Set y axis as percentage\\n        bar : bool\\n            Make barplot\\n        focus : int\\n            Forecast number to portray in detail.\\n        num_overplot : int\\n            Overplot all forecasts up to num\\n\\n            Note\\n            ----\\n            Default value is set to ``num_overplot = None`` -> only plot focus\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing a particular forecast component\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    fcst_t = fcst['ds'].dt.to_pydatetime()\n    col_names = [col_name for col_name in fcst.columns if col_name.startswith(comp_name)]\n    if num_overplot is not None:\n        assert num_overplot <= len(col_names)\n        for i in list(range(num_overplot))[::-1]:\n            y = fcst[f'{comp_name}{i + 1}']\n            y = y.values\n            alpha_min = 0.2\n            alpha_softness = 1.2\n            alpha = alpha_min + alpha_softness * (1.0 - alpha_min) / (i + 1.0 * alpha_softness)\n            y[-1] = 0\n            if bar:\n                artists += ax.bar(fcst_t, y, width=1.0, color='#0072B2', alpha=alpha)\n            else:\n                artists += ax.plot(fcst_t, y, ls='-', color='#0072B2', alpha=alpha)\n    if num_overplot is None or focus > 1:\n        y = fcst[f'{comp_name}{focus}']\n        y = y.values\n        y[-1] = 0\n        if bar:\n            artists += ax.bar(fcst_t, y, width=1.0, color='b')\n        else:\n            artists += ax.plot(fcst_t, y, ls='-', color='b')\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', color='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel('ds')\n    if plot_name is None:\n        plot_name = comp_name\n    ax.set_ylabel(plot_name)\n    if multiplicative:\n        ax = set_y_as_percent(ax)\n    return artists"
        ]
    },
    {
        "func_name": "plot_nonconformity_scores",
        "original": "def plot_nonconformity_scores(scores, alpha, q, method):\n    \"\"\"Plot the nonconformity scores as well as the one-sided interval width (q).\n\n    Parameters\n    ----------\n        scores : dict\n            nonconformity scores\n        alpha : float or tuple\n                user-specified significance level of the prediction interval, float if coverage error spread arbitrarily\n                over left and right tails, tuple of two floats for different coverage error over left and right tails\n                respectively\n        q : float or list\n            prediction interval width (or q)\n        method : str\n            name of conformal prediction technique used\n\n            Options\n                * (default) ``naive``: Naive or Absolute Residual\n                * ``cqr``: Conformalized Quantile Regression\n\n    Returns\n    -------\n        matplotlib.pyplot.figure\n            Figure showing the nonconformity score with horizontal line for q-value based on the significance level or\n            alpha\n    \"\"\"\n    if not isinstance(q, list):\n        q_sym = q\n        scores = scores['noncon_scores']\n        confidence_levels = np.arange(len(scores)) / len(scores)\n        (fig, ax) = plt.subplots()\n        ax.plot(confidence_levels, scores, label='score')\n        ax.axvline(x=1 - alpha, color='g', linestyle='-', label=f'(1-alpha) = {1 - alpha}', linewidth=1)\n        ax.axhline(y=q, color='r', linestyle='-', label=f'q1 = {round(q_sym, 2)}', linewidth=1)\n    else:\n        (q_lo, q_hi) = q\n        scores_lo = scores['noncon_scores_lo']\n        scores_hi = scores['noncon_scores_hi']\n        (alpha_lo, alpha_hi) = alpha\n        confidence_levels = np.arange(len(scores_lo)) / len(scores_lo)\n        (fig, ax) = plt.subplots()\n        ax.plot(confidence_levels, scores_lo, label='lower score')\n        ax.plot(confidence_levels, scores_hi, label='upper score')\n        ax.axvline(x=1 - alpha_lo, color='darkgreen', linestyle='-', label=f'(1-alpha_lo) = {round(1.0 - alpha_lo, 10)}', linewidth=1)\n        ax.axvline(x=1 - alpha_hi, color='lightgreen', linestyle='-', label=f'(1-alpha_hi) = {round(1.0 - alpha_hi, 10)}', linewidth=1)\n        ax.axhline(y=q_lo, color='darkred', linestyle='-', label=f'q1 = {round(q_lo, 2)}', linewidth=1)\n        ax.axhline(y=q_hi, color='red', linestyle='-', label=f'q2 = {round(q_hi, 2)}', linewidth=1)\n    ax.set_title(f'{method} One-Sided Interval Width with q')\n    ax.set_xlabel('Confidence Level')\n    ax.set_ylabel('One-Sided Interval Width')\n    ax.legend()\n    return fig",
        "mutated": [
            "def plot_nonconformity_scores(scores, alpha, q, method):\n    if False:\n        i = 10\n    'Plot the nonconformity scores as well as the one-sided interval width (q).\\n\\n    Parameters\\n    ----------\\n        scores : dict\\n            nonconformity scores\\n        alpha : float or tuple\\n                user-specified significance level of the prediction interval, float if coverage error spread arbitrarily\\n                over left and right tails, tuple of two floats for different coverage error over left and right tails\\n                respectively\\n        q : float or list\\n            prediction interval width (or q)\\n        method : str\\n            name of conformal prediction technique used\\n\\n            Options\\n                * (default) ``naive``: Naive or Absolute Residual\\n                * ``cqr``: Conformalized Quantile Regression\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the nonconformity score with horizontal line for q-value based on the significance level or\\n            alpha\\n    '\n    if not isinstance(q, list):\n        q_sym = q\n        scores = scores['noncon_scores']\n        confidence_levels = np.arange(len(scores)) / len(scores)\n        (fig, ax) = plt.subplots()\n        ax.plot(confidence_levels, scores, label='score')\n        ax.axvline(x=1 - alpha, color='g', linestyle='-', label=f'(1-alpha) = {1 - alpha}', linewidth=1)\n        ax.axhline(y=q, color='r', linestyle='-', label=f'q1 = {round(q_sym, 2)}', linewidth=1)\n    else:\n        (q_lo, q_hi) = q\n        scores_lo = scores['noncon_scores_lo']\n        scores_hi = scores['noncon_scores_hi']\n        (alpha_lo, alpha_hi) = alpha\n        confidence_levels = np.arange(len(scores_lo)) / len(scores_lo)\n        (fig, ax) = plt.subplots()\n        ax.plot(confidence_levels, scores_lo, label='lower score')\n        ax.plot(confidence_levels, scores_hi, label='upper score')\n        ax.axvline(x=1 - alpha_lo, color='darkgreen', linestyle='-', label=f'(1-alpha_lo) = {round(1.0 - alpha_lo, 10)}', linewidth=1)\n        ax.axvline(x=1 - alpha_hi, color='lightgreen', linestyle='-', label=f'(1-alpha_hi) = {round(1.0 - alpha_hi, 10)}', linewidth=1)\n        ax.axhline(y=q_lo, color='darkred', linestyle='-', label=f'q1 = {round(q_lo, 2)}', linewidth=1)\n        ax.axhline(y=q_hi, color='red', linestyle='-', label=f'q2 = {round(q_hi, 2)}', linewidth=1)\n    ax.set_title(f'{method} One-Sided Interval Width with q')\n    ax.set_xlabel('Confidence Level')\n    ax.set_ylabel('One-Sided Interval Width')\n    ax.legend()\n    return fig",
            "def plot_nonconformity_scores(scores, alpha, q, method):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Plot the nonconformity scores as well as the one-sided interval width (q).\\n\\n    Parameters\\n    ----------\\n        scores : dict\\n            nonconformity scores\\n        alpha : float or tuple\\n                user-specified significance level of the prediction interval, float if coverage error spread arbitrarily\\n                over left and right tails, tuple of two floats for different coverage error over left and right tails\\n                respectively\\n        q : float or list\\n            prediction interval width (or q)\\n        method : str\\n            name of conformal prediction technique used\\n\\n            Options\\n                * (default) ``naive``: Naive or Absolute Residual\\n                * ``cqr``: Conformalized Quantile Regression\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the nonconformity score with horizontal line for q-value based on the significance level or\\n            alpha\\n    '\n    if not isinstance(q, list):\n        q_sym = q\n        scores = scores['noncon_scores']\n        confidence_levels = np.arange(len(scores)) / len(scores)\n        (fig, ax) = plt.subplots()\n        ax.plot(confidence_levels, scores, label='score')\n        ax.axvline(x=1 - alpha, color='g', linestyle='-', label=f'(1-alpha) = {1 - alpha}', linewidth=1)\n        ax.axhline(y=q, color='r', linestyle='-', label=f'q1 = {round(q_sym, 2)}', linewidth=1)\n    else:\n        (q_lo, q_hi) = q\n        scores_lo = scores['noncon_scores_lo']\n        scores_hi = scores['noncon_scores_hi']\n        (alpha_lo, alpha_hi) = alpha\n        confidence_levels = np.arange(len(scores_lo)) / len(scores_lo)\n        (fig, ax) = plt.subplots()\n        ax.plot(confidence_levels, scores_lo, label='lower score')\n        ax.plot(confidence_levels, scores_hi, label='upper score')\n        ax.axvline(x=1 - alpha_lo, color='darkgreen', linestyle='-', label=f'(1-alpha_lo) = {round(1.0 - alpha_lo, 10)}', linewidth=1)\n        ax.axvline(x=1 - alpha_hi, color='lightgreen', linestyle='-', label=f'(1-alpha_hi) = {round(1.0 - alpha_hi, 10)}', linewidth=1)\n        ax.axhline(y=q_lo, color='darkred', linestyle='-', label=f'q1 = {round(q_lo, 2)}', linewidth=1)\n        ax.axhline(y=q_hi, color='red', linestyle='-', label=f'q2 = {round(q_hi, 2)}', linewidth=1)\n    ax.set_title(f'{method} One-Sided Interval Width with q')\n    ax.set_xlabel('Confidence Level')\n    ax.set_ylabel('One-Sided Interval Width')\n    ax.legend()\n    return fig",
            "def plot_nonconformity_scores(scores, alpha, q, method):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Plot the nonconformity scores as well as the one-sided interval width (q).\\n\\n    Parameters\\n    ----------\\n        scores : dict\\n            nonconformity scores\\n        alpha : float or tuple\\n                user-specified significance level of the prediction interval, float if coverage error spread arbitrarily\\n                over left and right tails, tuple of two floats for different coverage error over left and right tails\\n                respectively\\n        q : float or list\\n            prediction interval width (or q)\\n        method : str\\n            name of conformal prediction technique used\\n\\n            Options\\n                * (default) ``naive``: Naive or Absolute Residual\\n                * ``cqr``: Conformalized Quantile Regression\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the nonconformity score with horizontal line for q-value based on the significance level or\\n            alpha\\n    '\n    if not isinstance(q, list):\n        q_sym = q\n        scores = scores['noncon_scores']\n        confidence_levels = np.arange(len(scores)) / len(scores)\n        (fig, ax) = plt.subplots()\n        ax.plot(confidence_levels, scores, label='score')\n        ax.axvline(x=1 - alpha, color='g', linestyle='-', label=f'(1-alpha) = {1 - alpha}', linewidth=1)\n        ax.axhline(y=q, color='r', linestyle='-', label=f'q1 = {round(q_sym, 2)}', linewidth=1)\n    else:\n        (q_lo, q_hi) = q\n        scores_lo = scores['noncon_scores_lo']\n        scores_hi = scores['noncon_scores_hi']\n        (alpha_lo, alpha_hi) = alpha\n        confidence_levels = np.arange(len(scores_lo)) / len(scores_lo)\n        (fig, ax) = plt.subplots()\n        ax.plot(confidence_levels, scores_lo, label='lower score')\n        ax.plot(confidence_levels, scores_hi, label='upper score')\n        ax.axvline(x=1 - alpha_lo, color='darkgreen', linestyle='-', label=f'(1-alpha_lo) = {round(1.0 - alpha_lo, 10)}', linewidth=1)\n        ax.axvline(x=1 - alpha_hi, color='lightgreen', linestyle='-', label=f'(1-alpha_hi) = {round(1.0 - alpha_hi, 10)}', linewidth=1)\n        ax.axhline(y=q_lo, color='darkred', linestyle='-', label=f'q1 = {round(q_lo, 2)}', linewidth=1)\n        ax.axhline(y=q_hi, color='red', linestyle='-', label=f'q2 = {round(q_hi, 2)}', linewidth=1)\n    ax.set_title(f'{method} One-Sided Interval Width with q')\n    ax.set_xlabel('Confidence Level')\n    ax.set_ylabel('One-Sided Interval Width')\n    ax.legend()\n    return fig",
            "def plot_nonconformity_scores(scores, alpha, q, method):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Plot the nonconformity scores as well as the one-sided interval width (q).\\n\\n    Parameters\\n    ----------\\n        scores : dict\\n            nonconformity scores\\n        alpha : float or tuple\\n                user-specified significance level of the prediction interval, float if coverage error spread arbitrarily\\n                over left and right tails, tuple of two floats for different coverage error over left and right tails\\n                respectively\\n        q : float or list\\n            prediction interval width (or q)\\n        method : str\\n            name of conformal prediction technique used\\n\\n            Options\\n                * (default) ``naive``: Naive or Absolute Residual\\n                * ``cqr``: Conformalized Quantile Regression\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the nonconformity score with horizontal line for q-value based on the significance level or\\n            alpha\\n    '\n    if not isinstance(q, list):\n        q_sym = q\n        scores = scores['noncon_scores']\n        confidence_levels = np.arange(len(scores)) / len(scores)\n        (fig, ax) = plt.subplots()\n        ax.plot(confidence_levels, scores, label='score')\n        ax.axvline(x=1 - alpha, color='g', linestyle='-', label=f'(1-alpha) = {1 - alpha}', linewidth=1)\n        ax.axhline(y=q, color='r', linestyle='-', label=f'q1 = {round(q_sym, 2)}', linewidth=1)\n    else:\n        (q_lo, q_hi) = q\n        scores_lo = scores['noncon_scores_lo']\n        scores_hi = scores['noncon_scores_hi']\n        (alpha_lo, alpha_hi) = alpha\n        confidence_levels = np.arange(len(scores_lo)) / len(scores_lo)\n        (fig, ax) = plt.subplots()\n        ax.plot(confidence_levels, scores_lo, label='lower score')\n        ax.plot(confidence_levels, scores_hi, label='upper score')\n        ax.axvline(x=1 - alpha_lo, color='darkgreen', linestyle='-', label=f'(1-alpha_lo) = {round(1.0 - alpha_lo, 10)}', linewidth=1)\n        ax.axvline(x=1 - alpha_hi, color='lightgreen', linestyle='-', label=f'(1-alpha_hi) = {round(1.0 - alpha_hi, 10)}', linewidth=1)\n        ax.axhline(y=q_lo, color='darkred', linestyle='-', label=f'q1 = {round(q_lo, 2)}', linewidth=1)\n        ax.axhline(y=q_hi, color='red', linestyle='-', label=f'q2 = {round(q_hi, 2)}', linewidth=1)\n    ax.set_title(f'{method} One-Sided Interval Width with q')\n    ax.set_xlabel('Confidence Level')\n    ax.set_ylabel('One-Sided Interval Width')\n    ax.legend()\n    return fig",
            "def plot_nonconformity_scores(scores, alpha, q, method):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Plot the nonconformity scores as well as the one-sided interval width (q).\\n\\n    Parameters\\n    ----------\\n        scores : dict\\n            nonconformity scores\\n        alpha : float or tuple\\n                user-specified significance level of the prediction interval, float if coverage error spread arbitrarily\\n                over left and right tails, tuple of two floats for different coverage error over left and right tails\\n                respectively\\n        q : float or list\\n            prediction interval width (or q)\\n        method : str\\n            name of conformal prediction technique used\\n\\n            Options\\n                * (default) ``naive``: Naive or Absolute Residual\\n                * ``cqr``: Conformalized Quantile Regression\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the nonconformity score with horizontal line for q-value based on the significance level or\\n            alpha\\n    '\n    if not isinstance(q, list):\n        q_sym = q\n        scores = scores['noncon_scores']\n        confidence_levels = np.arange(len(scores)) / len(scores)\n        (fig, ax) = plt.subplots()\n        ax.plot(confidence_levels, scores, label='score')\n        ax.axvline(x=1 - alpha, color='g', linestyle='-', label=f'(1-alpha) = {1 - alpha}', linewidth=1)\n        ax.axhline(y=q, color='r', linestyle='-', label=f'q1 = {round(q_sym, 2)}', linewidth=1)\n    else:\n        (q_lo, q_hi) = q\n        scores_lo = scores['noncon_scores_lo']\n        scores_hi = scores['noncon_scores_hi']\n        (alpha_lo, alpha_hi) = alpha\n        confidence_levels = np.arange(len(scores_lo)) / len(scores_lo)\n        (fig, ax) = plt.subplots()\n        ax.plot(confidence_levels, scores_lo, label='lower score')\n        ax.plot(confidence_levels, scores_hi, label='upper score')\n        ax.axvline(x=1 - alpha_lo, color='darkgreen', linestyle='-', label=f'(1-alpha_lo) = {round(1.0 - alpha_lo, 10)}', linewidth=1)\n        ax.axvline(x=1 - alpha_hi, color='lightgreen', linestyle='-', label=f'(1-alpha_hi) = {round(1.0 - alpha_hi, 10)}', linewidth=1)\n        ax.axhline(y=q_lo, color='darkred', linestyle='-', label=f'q1 = {round(q_lo, 2)}', linewidth=1)\n        ax.axhline(y=q_hi, color='red', linestyle='-', label=f'q2 = {round(q_hi, 2)}', linewidth=1)\n    ax.set_title(f'{method} One-Sided Interval Width with q')\n    ax.set_xlabel('Confidence Level')\n    ax.set_ylabel('One-Sided Interval Width')\n    ax.legend()\n    return fig"
        ]
    },
    {
        "func_name": "plot_interval_width_per_timestep",
        "original": "def plot_interval_width_per_timestep(q_hats, method):\n    \"\"\"Plot the nonconformity scores as well as the one-sided interval width (q).\n\n    Parameters\n    ----------\n        q_hats : dataframe\n            prediction interval widths (or q) for each timestep, contains column ``q_hat_sym`` for symmetric q or\n            ``q_hat_lo`` and ``q_hat_hi`` for asymmetric q\n        method : str\n            name of conformal prediction technique used\n\n            Options\n                * (default) ``naive``: Naive or Absolute Residual\n                * ``cqr``: Conformalized Quantile Regression\n\n    Returns\n    -------\n        matplotlib.pyplot.figure\n            Figure showing the q-values for each timestep\n    \"\"\"\n    (fig, ax) = plt.subplots()\n    if 'q_hat_sym' in q_hats.columns:\n        q_hats_sym = q_hats['q_hat_sym']\n        ax.plot(range(1, len(q_hats_sym) + 1), q_hats_sym)\n    else:\n        q_hats_lo = q_hats['q_hat_lo']\n        q_hats_hi = q_hats['q_hat_hi']\n        ax.plot(range(1, len(q_hats_lo) + 1), q_hats_lo, label='lower q')\n        ax.plot(range(1, len(q_hats_hi) + 1), q_hats_hi, label='upper q')\n    ax.set_title(f'{method} One-Sided Interval Width with q per Timestep')\n    ax.set_xlabel('Timestep Number')\n    ax.set_ylabel('One-Sided Interval Width')\n    ax.set_ylim(bottom=0)\n    return fig",
        "mutated": [
            "def plot_interval_width_per_timestep(q_hats, method):\n    if False:\n        i = 10\n    'Plot the nonconformity scores as well as the one-sided interval width (q).\\n\\n    Parameters\\n    ----------\\n        q_hats : dataframe\\n            prediction interval widths (or q) for each timestep, contains column ``q_hat_sym`` for symmetric q or\\n            ``q_hat_lo`` and ``q_hat_hi`` for asymmetric q\\n        method : str\\n            name of conformal prediction technique used\\n\\n            Options\\n                * (default) ``naive``: Naive or Absolute Residual\\n                * ``cqr``: Conformalized Quantile Regression\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the q-values for each timestep\\n    '\n    (fig, ax) = plt.subplots()\n    if 'q_hat_sym' in q_hats.columns:\n        q_hats_sym = q_hats['q_hat_sym']\n        ax.plot(range(1, len(q_hats_sym) + 1), q_hats_sym)\n    else:\n        q_hats_lo = q_hats['q_hat_lo']\n        q_hats_hi = q_hats['q_hat_hi']\n        ax.plot(range(1, len(q_hats_lo) + 1), q_hats_lo, label='lower q')\n        ax.plot(range(1, len(q_hats_hi) + 1), q_hats_hi, label='upper q')\n    ax.set_title(f'{method} One-Sided Interval Width with q per Timestep')\n    ax.set_xlabel('Timestep Number')\n    ax.set_ylabel('One-Sided Interval Width')\n    ax.set_ylim(bottom=0)\n    return fig",
            "def plot_interval_width_per_timestep(q_hats, method):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Plot the nonconformity scores as well as the one-sided interval width (q).\\n\\n    Parameters\\n    ----------\\n        q_hats : dataframe\\n            prediction interval widths (or q) for each timestep, contains column ``q_hat_sym`` for symmetric q or\\n            ``q_hat_lo`` and ``q_hat_hi`` for asymmetric q\\n        method : str\\n            name of conformal prediction technique used\\n\\n            Options\\n                * (default) ``naive``: Naive or Absolute Residual\\n                * ``cqr``: Conformalized Quantile Regression\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the q-values for each timestep\\n    '\n    (fig, ax) = plt.subplots()\n    if 'q_hat_sym' in q_hats.columns:\n        q_hats_sym = q_hats['q_hat_sym']\n        ax.plot(range(1, len(q_hats_sym) + 1), q_hats_sym)\n    else:\n        q_hats_lo = q_hats['q_hat_lo']\n        q_hats_hi = q_hats['q_hat_hi']\n        ax.plot(range(1, len(q_hats_lo) + 1), q_hats_lo, label='lower q')\n        ax.plot(range(1, len(q_hats_hi) + 1), q_hats_hi, label='upper q')\n    ax.set_title(f'{method} One-Sided Interval Width with q per Timestep')\n    ax.set_xlabel('Timestep Number')\n    ax.set_ylabel('One-Sided Interval Width')\n    ax.set_ylim(bottom=0)\n    return fig",
            "def plot_interval_width_per_timestep(q_hats, method):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Plot the nonconformity scores as well as the one-sided interval width (q).\\n\\n    Parameters\\n    ----------\\n        q_hats : dataframe\\n            prediction interval widths (or q) for each timestep, contains column ``q_hat_sym`` for symmetric q or\\n            ``q_hat_lo`` and ``q_hat_hi`` for asymmetric q\\n        method : str\\n            name of conformal prediction technique used\\n\\n            Options\\n                * (default) ``naive``: Naive or Absolute Residual\\n                * ``cqr``: Conformalized Quantile Regression\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the q-values for each timestep\\n    '\n    (fig, ax) = plt.subplots()\n    if 'q_hat_sym' in q_hats.columns:\n        q_hats_sym = q_hats['q_hat_sym']\n        ax.plot(range(1, len(q_hats_sym) + 1), q_hats_sym)\n    else:\n        q_hats_lo = q_hats['q_hat_lo']\n        q_hats_hi = q_hats['q_hat_hi']\n        ax.plot(range(1, len(q_hats_lo) + 1), q_hats_lo, label='lower q')\n        ax.plot(range(1, len(q_hats_hi) + 1), q_hats_hi, label='upper q')\n    ax.set_title(f'{method} One-Sided Interval Width with q per Timestep')\n    ax.set_xlabel('Timestep Number')\n    ax.set_ylabel('One-Sided Interval Width')\n    ax.set_ylim(bottom=0)\n    return fig",
            "def plot_interval_width_per_timestep(q_hats, method):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Plot the nonconformity scores as well as the one-sided interval width (q).\\n\\n    Parameters\\n    ----------\\n        q_hats : dataframe\\n            prediction interval widths (or q) for each timestep, contains column ``q_hat_sym`` for symmetric q or\\n            ``q_hat_lo`` and ``q_hat_hi`` for asymmetric q\\n        method : str\\n            name of conformal prediction technique used\\n\\n            Options\\n                * (default) ``naive``: Naive or Absolute Residual\\n                * ``cqr``: Conformalized Quantile Regression\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the q-values for each timestep\\n    '\n    (fig, ax) = plt.subplots()\n    if 'q_hat_sym' in q_hats.columns:\n        q_hats_sym = q_hats['q_hat_sym']\n        ax.plot(range(1, len(q_hats_sym) + 1), q_hats_sym)\n    else:\n        q_hats_lo = q_hats['q_hat_lo']\n        q_hats_hi = q_hats['q_hat_hi']\n        ax.plot(range(1, len(q_hats_lo) + 1), q_hats_lo, label='lower q')\n        ax.plot(range(1, len(q_hats_hi) + 1), q_hats_hi, label='upper q')\n    ax.set_title(f'{method} One-Sided Interval Width with q per Timestep')\n    ax.set_xlabel('Timestep Number')\n    ax.set_ylabel('One-Sided Interval Width')\n    ax.set_ylim(bottom=0)\n    return fig",
            "def plot_interval_width_per_timestep(q_hats, method):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Plot the nonconformity scores as well as the one-sided interval width (q).\\n\\n    Parameters\\n    ----------\\n        q_hats : dataframe\\n            prediction interval widths (or q) for each timestep, contains column ``q_hat_sym`` for symmetric q or\\n            ``q_hat_lo`` and ``q_hat_hi`` for asymmetric q\\n        method : str\\n            name of conformal prediction technique used\\n\\n            Options\\n                * (default) ``naive``: Naive or Absolute Residual\\n                * ``cqr``: Conformalized Quantile Regression\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the q-values for each timestep\\n    '\n    (fig, ax) = plt.subplots()\n    if 'q_hat_sym' in q_hats.columns:\n        q_hats_sym = q_hats['q_hat_sym']\n        ax.plot(range(1, len(q_hats_sym) + 1), q_hats_sym)\n    else:\n        q_hats_lo = q_hats['q_hat_lo']\n        q_hats_hi = q_hats['q_hat_hi']\n        ax.plot(range(1, len(q_hats_lo) + 1), q_hats_lo, label='lower q')\n        ax.plot(range(1, len(q_hats_hi) + 1), q_hats_hi, label='upper q')\n    ax.set_title(f'{method} One-Sided Interval Width with q per Timestep')\n    ax.set_xlabel('Timestep Number')\n    ax.set_ylabel('One-Sided Interval Width')\n    ax.set_ylim(bottom=0)\n    return fig"
        ]
    }
]