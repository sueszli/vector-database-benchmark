[
    {
        "func_name": "inbox_search",
        "original": "def inbox_search(projects: Sequence[Project], environments: Optional[Sequence[Environment]]=None, limit: int=100, cursor: Optional[Cursor]=None, count_hits: bool=False, search_filters: Optional[Sequence[SearchFilter]]=None, date_from: Optional[datetime]=None, date_to: Optional[datetime]=None, max_hits: Optional[int]=None, actor: Optional[Any]=None) -> CursorResult:\n    now: datetime = timezone.now()\n    end: Optional[datetime] = None\n    end_params: List[datetime] = [_f for _f in [date_to, get_search_filter(search_filters, 'date', '<')] if _f]\n    if end_params:\n        end = min(end_params)\n    end = end if end else now + ALLOWED_FUTURE_DELTA\n    earliest_date = now - timedelta(days=7)\n    start_params = [date_from, earliest_date, get_search_filter(search_filters, 'date', '>')]\n    start = max((_f for _f in start_params if _f))\n    end = max([earliest_date, end])\n    if start >= end:\n        return Paginator(Group.objects.none()).get_result()\n    invalid_search_terms = [str(sf) for sf in search_filters if sf.key.name not in allowed_inbox_search_terms]\n    if invalid_search_terms:\n        raise InvalidSearchQuery(f\"Invalid search terms for 'inbox' search: {invalid_search_terms}\")\n    if not get_search_filter(search_filters, 'for_review', '='):\n        raise InvalidSearchQuery(\"Sort key 'inbox' only supported for inbox search\")\n    if get_search_filter(search_filters, 'status', '=') != GroupStatus.UNRESOLVED and get_search_filter(search_filters, 'status', 'IN') != [GroupStatus.UNRESOLVED]:\n        raise InvalidSearchQuery(\"Inbox search only works for 'unresolved' status\")\n    qs = GroupInbox.objects.filter(date_added__gte=start, date_added__lte=end, project__in=projects).using_replica()\n    if environments is not None:\n        environment_ids: List[int] = [environment.id for environment in environments]\n        qs = qs.filter(group_id__in=GroupEnvironment.objects.filter(environment_id__in=environment_ids).values_list('group_id', flat=True).distinct())\n    owner_search = get_search_filter(search_filters, 'assigned_or_suggested', 'IN')\n    if owner_search:\n        qs = qs.filter(assigned_or_suggested_filter(owner_search, projects, field_filter='group_id'))\n    paginator = DateTimePaginator(qs.order_by('date_added'), '-date_added')\n    results = paginator.get_result(limit, cursor, count_hits=count_hits, max_hits=max_hits)\n    group_qs = Group.objects.filter(id__in=[r.group_id for r in results.results], project__in=projects, status=GroupStatus.UNRESOLVED)\n    groups: Mapping[int, Group] = {g.id: g for g in group_qs}\n    results.results = [groups[r.group_id] for r in results.results if r.group_id in groups]\n    return results",
        "mutated": [
            "def inbox_search(projects: Sequence[Project], environments: Optional[Sequence[Environment]]=None, limit: int=100, cursor: Optional[Cursor]=None, count_hits: bool=False, search_filters: Optional[Sequence[SearchFilter]]=None, date_from: Optional[datetime]=None, date_to: Optional[datetime]=None, max_hits: Optional[int]=None, actor: Optional[Any]=None) -> CursorResult:\n    if False:\n        i = 10\n    now: datetime = timezone.now()\n    end: Optional[datetime] = None\n    end_params: List[datetime] = [_f for _f in [date_to, get_search_filter(search_filters, 'date', '<')] if _f]\n    if end_params:\n        end = min(end_params)\n    end = end if end else now + ALLOWED_FUTURE_DELTA\n    earliest_date = now - timedelta(days=7)\n    start_params = [date_from, earliest_date, get_search_filter(search_filters, 'date', '>')]\n    start = max((_f for _f in start_params if _f))\n    end = max([earliest_date, end])\n    if start >= end:\n        return Paginator(Group.objects.none()).get_result()\n    invalid_search_terms = [str(sf) for sf in search_filters if sf.key.name not in allowed_inbox_search_terms]\n    if invalid_search_terms:\n        raise InvalidSearchQuery(f\"Invalid search terms for 'inbox' search: {invalid_search_terms}\")\n    if not get_search_filter(search_filters, 'for_review', '='):\n        raise InvalidSearchQuery(\"Sort key 'inbox' only supported for inbox search\")\n    if get_search_filter(search_filters, 'status', '=') != GroupStatus.UNRESOLVED and get_search_filter(search_filters, 'status', 'IN') != [GroupStatus.UNRESOLVED]:\n        raise InvalidSearchQuery(\"Inbox search only works for 'unresolved' status\")\n    qs = GroupInbox.objects.filter(date_added__gte=start, date_added__lte=end, project__in=projects).using_replica()\n    if environments is not None:\n        environment_ids: List[int] = [environment.id for environment in environments]\n        qs = qs.filter(group_id__in=GroupEnvironment.objects.filter(environment_id__in=environment_ids).values_list('group_id', flat=True).distinct())\n    owner_search = get_search_filter(search_filters, 'assigned_or_suggested', 'IN')\n    if owner_search:\n        qs = qs.filter(assigned_or_suggested_filter(owner_search, projects, field_filter='group_id'))\n    paginator = DateTimePaginator(qs.order_by('date_added'), '-date_added')\n    results = paginator.get_result(limit, cursor, count_hits=count_hits, max_hits=max_hits)\n    group_qs = Group.objects.filter(id__in=[r.group_id for r in results.results], project__in=projects, status=GroupStatus.UNRESOLVED)\n    groups: Mapping[int, Group] = {g.id: g for g in group_qs}\n    results.results = [groups[r.group_id] for r in results.results if r.group_id in groups]\n    return results",
            "def inbox_search(projects: Sequence[Project], environments: Optional[Sequence[Environment]]=None, limit: int=100, cursor: Optional[Cursor]=None, count_hits: bool=False, search_filters: Optional[Sequence[SearchFilter]]=None, date_from: Optional[datetime]=None, date_to: Optional[datetime]=None, max_hits: Optional[int]=None, actor: Optional[Any]=None) -> CursorResult:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    now: datetime = timezone.now()\n    end: Optional[datetime] = None\n    end_params: List[datetime] = [_f for _f in [date_to, get_search_filter(search_filters, 'date', '<')] if _f]\n    if end_params:\n        end = min(end_params)\n    end = end if end else now + ALLOWED_FUTURE_DELTA\n    earliest_date = now - timedelta(days=7)\n    start_params = [date_from, earliest_date, get_search_filter(search_filters, 'date', '>')]\n    start = max((_f for _f in start_params if _f))\n    end = max([earliest_date, end])\n    if start >= end:\n        return Paginator(Group.objects.none()).get_result()\n    invalid_search_terms = [str(sf) for sf in search_filters if sf.key.name not in allowed_inbox_search_terms]\n    if invalid_search_terms:\n        raise InvalidSearchQuery(f\"Invalid search terms for 'inbox' search: {invalid_search_terms}\")\n    if not get_search_filter(search_filters, 'for_review', '='):\n        raise InvalidSearchQuery(\"Sort key 'inbox' only supported for inbox search\")\n    if get_search_filter(search_filters, 'status', '=') != GroupStatus.UNRESOLVED and get_search_filter(search_filters, 'status', 'IN') != [GroupStatus.UNRESOLVED]:\n        raise InvalidSearchQuery(\"Inbox search only works for 'unresolved' status\")\n    qs = GroupInbox.objects.filter(date_added__gte=start, date_added__lte=end, project__in=projects).using_replica()\n    if environments is not None:\n        environment_ids: List[int] = [environment.id for environment in environments]\n        qs = qs.filter(group_id__in=GroupEnvironment.objects.filter(environment_id__in=environment_ids).values_list('group_id', flat=True).distinct())\n    owner_search = get_search_filter(search_filters, 'assigned_or_suggested', 'IN')\n    if owner_search:\n        qs = qs.filter(assigned_or_suggested_filter(owner_search, projects, field_filter='group_id'))\n    paginator = DateTimePaginator(qs.order_by('date_added'), '-date_added')\n    results = paginator.get_result(limit, cursor, count_hits=count_hits, max_hits=max_hits)\n    group_qs = Group.objects.filter(id__in=[r.group_id for r in results.results], project__in=projects, status=GroupStatus.UNRESOLVED)\n    groups: Mapping[int, Group] = {g.id: g for g in group_qs}\n    results.results = [groups[r.group_id] for r in results.results if r.group_id in groups]\n    return results",
            "def inbox_search(projects: Sequence[Project], environments: Optional[Sequence[Environment]]=None, limit: int=100, cursor: Optional[Cursor]=None, count_hits: bool=False, search_filters: Optional[Sequence[SearchFilter]]=None, date_from: Optional[datetime]=None, date_to: Optional[datetime]=None, max_hits: Optional[int]=None, actor: Optional[Any]=None) -> CursorResult:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    now: datetime = timezone.now()\n    end: Optional[datetime] = None\n    end_params: List[datetime] = [_f for _f in [date_to, get_search_filter(search_filters, 'date', '<')] if _f]\n    if end_params:\n        end = min(end_params)\n    end = end if end else now + ALLOWED_FUTURE_DELTA\n    earliest_date = now - timedelta(days=7)\n    start_params = [date_from, earliest_date, get_search_filter(search_filters, 'date', '>')]\n    start = max((_f for _f in start_params if _f))\n    end = max([earliest_date, end])\n    if start >= end:\n        return Paginator(Group.objects.none()).get_result()\n    invalid_search_terms = [str(sf) for sf in search_filters if sf.key.name not in allowed_inbox_search_terms]\n    if invalid_search_terms:\n        raise InvalidSearchQuery(f\"Invalid search terms for 'inbox' search: {invalid_search_terms}\")\n    if not get_search_filter(search_filters, 'for_review', '='):\n        raise InvalidSearchQuery(\"Sort key 'inbox' only supported for inbox search\")\n    if get_search_filter(search_filters, 'status', '=') != GroupStatus.UNRESOLVED and get_search_filter(search_filters, 'status', 'IN') != [GroupStatus.UNRESOLVED]:\n        raise InvalidSearchQuery(\"Inbox search only works for 'unresolved' status\")\n    qs = GroupInbox.objects.filter(date_added__gte=start, date_added__lte=end, project__in=projects).using_replica()\n    if environments is not None:\n        environment_ids: List[int] = [environment.id for environment in environments]\n        qs = qs.filter(group_id__in=GroupEnvironment.objects.filter(environment_id__in=environment_ids).values_list('group_id', flat=True).distinct())\n    owner_search = get_search_filter(search_filters, 'assigned_or_suggested', 'IN')\n    if owner_search:\n        qs = qs.filter(assigned_or_suggested_filter(owner_search, projects, field_filter='group_id'))\n    paginator = DateTimePaginator(qs.order_by('date_added'), '-date_added')\n    results = paginator.get_result(limit, cursor, count_hits=count_hits, max_hits=max_hits)\n    group_qs = Group.objects.filter(id__in=[r.group_id for r in results.results], project__in=projects, status=GroupStatus.UNRESOLVED)\n    groups: Mapping[int, Group] = {g.id: g for g in group_qs}\n    results.results = [groups[r.group_id] for r in results.results if r.group_id in groups]\n    return results",
            "def inbox_search(projects: Sequence[Project], environments: Optional[Sequence[Environment]]=None, limit: int=100, cursor: Optional[Cursor]=None, count_hits: bool=False, search_filters: Optional[Sequence[SearchFilter]]=None, date_from: Optional[datetime]=None, date_to: Optional[datetime]=None, max_hits: Optional[int]=None, actor: Optional[Any]=None) -> CursorResult:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    now: datetime = timezone.now()\n    end: Optional[datetime] = None\n    end_params: List[datetime] = [_f for _f in [date_to, get_search_filter(search_filters, 'date', '<')] if _f]\n    if end_params:\n        end = min(end_params)\n    end = end if end else now + ALLOWED_FUTURE_DELTA\n    earliest_date = now - timedelta(days=7)\n    start_params = [date_from, earliest_date, get_search_filter(search_filters, 'date', '>')]\n    start = max((_f for _f in start_params if _f))\n    end = max([earliest_date, end])\n    if start >= end:\n        return Paginator(Group.objects.none()).get_result()\n    invalid_search_terms = [str(sf) for sf in search_filters if sf.key.name not in allowed_inbox_search_terms]\n    if invalid_search_terms:\n        raise InvalidSearchQuery(f\"Invalid search terms for 'inbox' search: {invalid_search_terms}\")\n    if not get_search_filter(search_filters, 'for_review', '='):\n        raise InvalidSearchQuery(\"Sort key 'inbox' only supported for inbox search\")\n    if get_search_filter(search_filters, 'status', '=') != GroupStatus.UNRESOLVED and get_search_filter(search_filters, 'status', 'IN') != [GroupStatus.UNRESOLVED]:\n        raise InvalidSearchQuery(\"Inbox search only works for 'unresolved' status\")\n    qs = GroupInbox.objects.filter(date_added__gte=start, date_added__lte=end, project__in=projects).using_replica()\n    if environments is not None:\n        environment_ids: List[int] = [environment.id for environment in environments]\n        qs = qs.filter(group_id__in=GroupEnvironment.objects.filter(environment_id__in=environment_ids).values_list('group_id', flat=True).distinct())\n    owner_search = get_search_filter(search_filters, 'assigned_or_suggested', 'IN')\n    if owner_search:\n        qs = qs.filter(assigned_or_suggested_filter(owner_search, projects, field_filter='group_id'))\n    paginator = DateTimePaginator(qs.order_by('date_added'), '-date_added')\n    results = paginator.get_result(limit, cursor, count_hits=count_hits, max_hits=max_hits)\n    group_qs = Group.objects.filter(id__in=[r.group_id for r in results.results], project__in=projects, status=GroupStatus.UNRESOLVED)\n    groups: Mapping[int, Group] = {g.id: g for g in group_qs}\n    results.results = [groups[r.group_id] for r in results.results if r.group_id in groups]\n    return results",
            "def inbox_search(projects: Sequence[Project], environments: Optional[Sequence[Environment]]=None, limit: int=100, cursor: Optional[Cursor]=None, count_hits: bool=False, search_filters: Optional[Sequence[SearchFilter]]=None, date_from: Optional[datetime]=None, date_to: Optional[datetime]=None, max_hits: Optional[int]=None, actor: Optional[Any]=None) -> CursorResult:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    now: datetime = timezone.now()\n    end: Optional[datetime] = None\n    end_params: List[datetime] = [_f for _f in [date_to, get_search_filter(search_filters, 'date', '<')] if _f]\n    if end_params:\n        end = min(end_params)\n    end = end if end else now + ALLOWED_FUTURE_DELTA\n    earliest_date = now - timedelta(days=7)\n    start_params = [date_from, earliest_date, get_search_filter(search_filters, 'date', '>')]\n    start = max((_f for _f in start_params if _f))\n    end = max([earliest_date, end])\n    if start >= end:\n        return Paginator(Group.objects.none()).get_result()\n    invalid_search_terms = [str(sf) for sf in search_filters if sf.key.name not in allowed_inbox_search_terms]\n    if invalid_search_terms:\n        raise InvalidSearchQuery(f\"Invalid search terms for 'inbox' search: {invalid_search_terms}\")\n    if not get_search_filter(search_filters, 'for_review', '='):\n        raise InvalidSearchQuery(\"Sort key 'inbox' only supported for inbox search\")\n    if get_search_filter(search_filters, 'status', '=') != GroupStatus.UNRESOLVED and get_search_filter(search_filters, 'status', 'IN') != [GroupStatus.UNRESOLVED]:\n        raise InvalidSearchQuery(\"Inbox search only works for 'unresolved' status\")\n    qs = GroupInbox.objects.filter(date_added__gte=start, date_added__lte=end, project__in=projects).using_replica()\n    if environments is not None:\n        environment_ids: List[int] = [environment.id for environment in environments]\n        qs = qs.filter(group_id__in=GroupEnvironment.objects.filter(environment_id__in=environment_ids).values_list('group_id', flat=True).distinct())\n    owner_search = get_search_filter(search_filters, 'assigned_or_suggested', 'IN')\n    if owner_search:\n        qs = qs.filter(assigned_or_suggested_filter(owner_search, projects, field_filter='group_id'))\n    paginator = DateTimePaginator(qs.order_by('date_added'), '-date_added')\n    results = paginator.get_result(limit, cursor, count_hits=count_hits, max_hits=max_hits)\n    group_qs = Group.objects.filter(id__in=[r.group_id for r in results.results], project__in=projects, status=GroupStatus.UNRESOLVED)\n    groups: Mapping[int, Group] = {g.id: g for g in group_qs}\n    results.results = [groups[r.group_id] for r in results.results if r.group_id in groups]\n    return results"
        ]
    },
    {
        "func_name": "_search",
        "original": "def _search(self, request: Request, organization, projects, environments, extra_query_kwargs=None):\n    with start_span(op='_search'):\n        query_kwargs = build_query_params_from_request(request, organization, projects, environments)\n        if extra_query_kwargs is not None:\n            assert 'environment' not in extra_query_kwargs\n            query_kwargs.update(extra_query_kwargs)\n        query_kwargs['environments'] = environments if environments else None\n        query_kwargs['actor'] = request.user\n        if query_kwargs['sort_by'] == 'inbox':\n            query_kwargs.pop('sort_by')\n            result = inbox_search(**query_kwargs)\n        else:\n            query_kwargs['referrer'] = 'search.group_index'\n            result = search.query(**query_kwargs)\n        return (result, query_kwargs)",
        "mutated": [
            "def _search(self, request: Request, organization, projects, environments, extra_query_kwargs=None):\n    if False:\n        i = 10\n    with start_span(op='_search'):\n        query_kwargs = build_query_params_from_request(request, organization, projects, environments)\n        if extra_query_kwargs is not None:\n            assert 'environment' not in extra_query_kwargs\n            query_kwargs.update(extra_query_kwargs)\n        query_kwargs['environments'] = environments if environments else None\n        query_kwargs['actor'] = request.user\n        if query_kwargs['sort_by'] == 'inbox':\n            query_kwargs.pop('sort_by')\n            result = inbox_search(**query_kwargs)\n        else:\n            query_kwargs['referrer'] = 'search.group_index'\n            result = search.query(**query_kwargs)\n        return (result, query_kwargs)",
            "def _search(self, request: Request, organization, projects, environments, extra_query_kwargs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with start_span(op='_search'):\n        query_kwargs = build_query_params_from_request(request, organization, projects, environments)\n        if extra_query_kwargs is not None:\n            assert 'environment' not in extra_query_kwargs\n            query_kwargs.update(extra_query_kwargs)\n        query_kwargs['environments'] = environments if environments else None\n        query_kwargs['actor'] = request.user\n        if query_kwargs['sort_by'] == 'inbox':\n            query_kwargs.pop('sort_by')\n            result = inbox_search(**query_kwargs)\n        else:\n            query_kwargs['referrer'] = 'search.group_index'\n            result = search.query(**query_kwargs)\n        return (result, query_kwargs)",
            "def _search(self, request: Request, organization, projects, environments, extra_query_kwargs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with start_span(op='_search'):\n        query_kwargs = build_query_params_from_request(request, organization, projects, environments)\n        if extra_query_kwargs is not None:\n            assert 'environment' not in extra_query_kwargs\n            query_kwargs.update(extra_query_kwargs)\n        query_kwargs['environments'] = environments if environments else None\n        query_kwargs['actor'] = request.user\n        if query_kwargs['sort_by'] == 'inbox':\n            query_kwargs.pop('sort_by')\n            result = inbox_search(**query_kwargs)\n        else:\n            query_kwargs['referrer'] = 'search.group_index'\n            result = search.query(**query_kwargs)\n        return (result, query_kwargs)",
            "def _search(self, request: Request, organization, projects, environments, extra_query_kwargs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with start_span(op='_search'):\n        query_kwargs = build_query_params_from_request(request, organization, projects, environments)\n        if extra_query_kwargs is not None:\n            assert 'environment' not in extra_query_kwargs\n            query_kwargs.update(extra_query_kwargs)\n        query_kwargs['environments'] = environments if environments else None\n        query_kwargs['actor'] = request.user\n        if query_kwargs['sort_by'] == 'inbox':\n            query_kwargs.pop('sort_by')\n            result = inbox_search(**query_kwargs)\n        else:\n            query_kwargs['referrer'] = 'search.group_index'\n            result = search.query(**query_kwargs)\n        return (result, query_kwargs)",
            "def _search(self, request: Request, organization, projects, environments, extra_query_kwargs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with start_span(op='_search'):\n        query_kwargs = build_query_params_from_request(request, organization, projects, environments)\n        if extra_query_kwargs is not None:\n            assert 'environment' not in extra_query_kwargs\n            query_kwargs.update(extra_query_kwargs)\n        query_kwargs['environments'] = environments if environments else None\n        query_kwargs['actor'] = request.user\n        if query_kwargs['sort_by'] == 'inbox':\n            query_kwargs.pop('sort_by')\n            result = inbox_search(**query_kwargs)\n        else:\n            query_kwargs['referrer'] = 'search.group_index'\n            result = search.query(**query_kwargs)\n        return (result, query_kwargs)"
        ]
    },
    {
        "func_name": "get",
        "original": "@track_slo_response('workflow')\ndef get(self, request: Request, organization) -> Response:\n    \"\"\"\n        List an Organization's Issues\n        `````````````````````````````\n\n        Return a list of issues (groups) bound to an organization.  All parameters are\n        supplied as query string parameters.\n\n        A default query of ``is:unresolved`` is applied. To return results\n        with other statuses send an new query value (i.e. ``?query=`` for all\n        results).\n\n        The ``groupStatsPeriod`` parameter can be used to select the timeline\n        stats which should be present. Possible values are: '' (disable),\n        '24h', '14d'\n\n        The ``statsPeriod`` parameter can be used to select a date window starting\n        from now. Ex. ``14d``.\n\n        The ``start`` and ``end`` parameters can be used to select an absolute\n        date period to fetch issues from.\n\n        :qparam string statsPeriod: an optional stat period (can be one of\n                                    ``\"24h\"``, ``\"14d\"``, and ``\"\"``).\n        :qparam string groupStatsPeriod: an optional stat period (can be one of\n                                    ``\"24h\"``, ``\"14d\"``, and ``\"\"``).\n        :qparam string start:       Beginning date. You must also provide ``end``.\n        :qparam string end:         End date. You must also provide ``start``.\n        :qparam bool shortIdLookup: if this is set to true then short IDs are\n                                    looked up by this function as well.  This\n                                    can cause the return value of the function\n                                    to return an event issue of a different\n                                    project which is why this is an opt-in.\n                                    Set to `1` to enable.\n        :qparam querystring query: an optional Sentry structured search\n                                   query.  If not provided an implied\n                                   ``\"is:unresolved\"`` is assumed.)\n        :qparam bool savedSearch:  if this is set to False, then we are making the request without\n                                   a saved search and will look for the default search from this endpoint.\n        :qparam string searchId:   if passed in, this is the selected search\n        :pparam string organization_slug: the slug of the organization the\n                                          issues belong to.\n        :auth: required\n        :qparam list expand: an optional list of strings to opt in to additional data. Supports `inbox`\n        :qparam list collapse: an optional list of strings to opt out of certain pieces of data. Supports `stats`, `lifetime`, `base`, `unhandled`\n        \"\"\"\n    stats_period = request.GET.get('groupStatsPeriod')\n    try:\n        (start, end) = get_date_range_from_stats_period(request.GET)\n    except InvalidParams as e:\n        raise ParseError(detail=str(e))\n    expand = request.GET.getlist('expand', [])\n    collapse = request.GET.getlist('collapse', [])\n    if stats_period not in (None, '', '24h', '14d', 'auto'):\n        return Response({'detail': ERR_INVALID_STATS_PERIOD}, status=400)\n    (stats_period, stats_period_start, stats_period_end) = calculate_stats_period(stats_period, start, end)\n    environments = self.get_environments(request, organization)\n    projects = self.get_projects(request, organization)\n    project_ids = [p.id for p in projects]\n    if not projects:\n        return Response([])\n    is_fetching_replay_data = request.headers.get('X-Sentry-Replay-Request') == '1'\n    if len(projects) > 1 and (not features.has('organizations:global-views', organization, actor=request.user)) and (not is_fetching_replay_data):\n        return Response({'detail': 'You do not have the multi project stream feature enabled'}, status=400)\n    serializer = functools.partial(StreamGroupSerializerSnuba, environment_ids=[env.id for env in environments], stats_period=stats_period, stats_period_start=stats_period_start, stats_period_end=stats_period_end, expand=expand, collapse=collapse, project_ids=project_ids, organization_id=organization.id)\n    query = request.GET.get('query', '').strip()\n    if query:\n        event_id = normalize_event_id(query)\n        if event_id:\n            direct_hit_projects = set(project_ids) | request.access.project_ids_with_team_membership\n            groups = list(Group.objects.filter_by_event_id(direct_hit_projects, event_id, tenant_ids={'organization_id': organization.id}))\n            if len(groups) == 1:\n                serialized_groups = serialize(groups, request.user, serializer())\n                if event_id:\n                    serialized_groups[0]['matchingEventId'] = event_id\n                response = Response(serialized_groups)\n                response['X-Sentry-Direct-Hit'] = '1'\n                return response\n            if groups:\n                return Response(serialize(groups, request.user, serializer()))\n        group = get_by_short_id(organization.id, request.GET.get('shortIdLookup'), query)\n        if group is not None:\n            if request.access.has_project_access(group.project):\n                response = Response(serialize([group], request.user, serializer()))\n                response['X-Sentry-Direct-Hit'] = '1'\n                return response\n    try:\n        group_ids = set(map(int, request.GET.getlist('group')))\n    except ValueError:\n        return Response({'detail': 'Group ids must be integers'}, status=400)\n    if group_ids:\n        groups = list(Group.objects.filter(id__in=group_ids, project_id__in=project_ids))\n        if any((g for g in groups if not request.access.has_project_access(g.project))):\n            raise PermissionDenied\n        return Response(serialize(groups, request.user, serializer()))\n    try:\n        (cursor_result, query_kwargs) = self._search(request, organization, projects, environments, {'count_hits': True, 'date_to': end, 'date_from': start})\n    except (ValidationError, discover.InvalidSearchQuery) as exc:\n        return Response({'detail': str(exc)}, status=400)\n    results = list(cursor_result)\n    context = serialize(results, request.user, serializer(start=start, end=end, search_filters=query_kwargs['search_filters'] if 'search_filters' in query_kwargs else None, organization_id=organization.id))\n    status = [search_filter for search_filter in query_kwargs.get('search_filters', []) if search_filter.key.name == 'status' and search_filter.operator in EQUALITY_OPERATORS]\n    if status and GroupStatus.UNRESOLVED in status[0].value.raw_value:\n        status_labels = {QUERY_STATUS_LOOKUP[s] for s in status[0].value.raw_value}\n        context = [r for r in context if 'status' not in r or r['status'] in status_labels]\n    response = Response(context)\n    self.add_cursor_headers(request, response, cursor_result)\n    return response",
        "mutated": [
            "@track_slo_response('workflow')\ndef get(self, request: Request, organization) -> Response:\n    if False:\n        i = 10\n    '\\n        List an Organization\\'s Issues\\n        `````````````````````````````\\n\\n        Return a list of issues (groups) bound to an organization.  All parameters are\\n        supplied as query string parameters.\\n\\n        A default query of ``is:unresolved`` is applied. To return results\\n        with other statuses send an new query value (i.e. ``?query=`` for all\\n        results).\\n\\n        The ``groupStatsPeriod`` parameter can be used to select the timeline\\n        stats which should be present. Possible values are: \\'\\' (disable),\\n        \\'24h\\', \\'14d\\'\\n\\n        The ``statsPeriod`` parameter can be used to select a date window starting\\n        from now. Ex. ``14d``.\\n\\n        The ``start`` and ``end`` parameters can be used to select an absolute\\n        date period to fetch issues from.\\n\\n        :qparam string statsPeriod: an optional stat period (can be one of\\n                                    ``\"24h\"``, ``\"14d\"``, and ``\"\"``).\\n        :qparam string groupStatsPeriod: an optional stat period (can be one of\\n                                    ``\"24h\"``, ``\"14d\"``, and ``\"\"``).\\n        :qparam string start:       Beginning date. You must also provide ``end``.\\n        :qparam string end:         End date. You must also provide ``start``.\\n        :qparam bool shortIdLookup: if this is set to true then short IDs are\\n                                    looked up by this function as well.  This\\n                                    can cause the return value of the function\\n                                    to return an event issue of a different\\n                                    project which is why this is an opt-in.\\n                                    Set to `1` to enable.\\n        :qparam querystring query: an optional Sentry structured search\\n                                   query.  If not provided an implied\\n                                   ``\"is:unresolved\"`` is assumed.)\\n        :qparam bool savedSearch:  if this is set to False, then we are making the request without\\n                                   a saved search and will look for the default search from this endpoint.\\n        :qparam string searchId:   if passed in, this is the selected search\\n        :pparam string organization_slug: the slug of the organization the\\n                                          issues belong to.\\n        :auth: required\\n        :qparam list expand: an optional list of strings to opt in to additional data. Supports `inbox`\\n        :qparam list collapse: an optional list of strings to opt out of certain pieces of data. Supports `stats`, `lifetime`, `base`, `unhandled`\\n        '\n    stats_period = request.GET.get('groupStatsPeriod')\n    try:\n        (start, end) = get_date_range_from_stats_period(request.GET)\n    except InvalidParams as e:\n        raise ParseError(detail=str(e))\n    expand = request.GET.getlist('expand', [])\n    collapse = request.GET.getlist('collapse', [])\n    if stats_period not in (None, '', '24h', '14d', 'auto'):\n        return Response({'detail': ERR_INVALID_STATS_PERIOD}, status=400)\n    (stats_period, stats_period_start, stats_period_end) = calculate_stats_period(stats_period, start, end)\n    environments = self.get_environments(request, organization)\n    projects = self.get_projects(request, organization)\n    project_ids = [p.id for p in projects]\n    if not projects:\n        return Response([])\n    is_fetching_replay_data = request.headers.get('X-Sentry-Replay-Request') == '1'\n    if len(projects) > 1 and (not features.has('organizations:global-views', organization, actor=request.user)) and (not is_fetching_replay_data):\n        return Response({'detail': 'You do not have the multi project stream feature enabled'}, status=400)\n    serializer = functools.partial(StreamGroupSerializerSnuba, environment_ids=[env.id for env in environments], stats_period=stats_period, stats_period_start=stats_period_start, stats_period_end=stats_period_end, expand=expand, collapse=collapse, project_ids=project_ids, organization_id=organization.id)\n    query = request.GET.get('query', '').strip()\n    if query:\n        event_id = normalize_event_id(query)\n        if event_id:\n            direct_hit_projects = set(project_ids) | request.access.project_ids_with_team_membership\n            groups = list(Group.objects.filter_by_event_id(direct_hit_projects, event_id, tenant_ids={'organization_id': organization.id}))\n            if len(groups) == 1:\n                serialized_groups = serialize(groups, request.user, serializer())\n                if event_id:\n                    serialized_groups[0]['matchingEventId'] = event_id\n                response = Response(serialized_groups)\n                response['X-Sentry-Direct-Hit'] = '1'\n                return response\n            if groups:\n                return Response(serialize(groups, request.user, serializer()))\n        group = get_by_short_id(organization.id, request.GET.get('shortIdLookup'), query)\n        if group is not None:\n            if request.access.has_project_access(group.project):\n                response = Response(serialize([group], request.user, serializer()))\n                response['X-Sentry-Direct-Hit'] = '1'\n                return response\n    try:\n        group_ids = set(map(int, request.GET.getlist('group')))\n    except ValueError:\n        return Response({'detail': 'Group ids must be integers'}, status=400)\n    if group_ids:\n        groups = list(Group.objects.filter(id__in=group_ids, project_id__in=project_ids))\n        if any((g for g in groups if not request.access.has_project_access(g.project))):\n            raise PermissionDenied\n        return Response(serialize(groups, request.user, serializer()))\n    try:\n        (cursor_result, query_kwargs) = self._search(request, organization, projects, environments, {'count_hits': True, 'date_to': end, 'date_from': start})\n    except (ValidationError, discover.InvalidSearchQuery) as exc:\n        return Response({'detail': str(exc)}, status=400)\n    results = list(cursor_result)\n    context = serialize(results, request.user, serializer(start=start, end=end, search_filters=query_kwargs['search_filters'] if 'search_filters' in query_kwargs else None, organization_id=organization.id))\n    status = [search_filter for search_filter in query_kwargs.get('search_filters', []) if search_filter.key.name == 'status' and search_filter.operator in EQUALITY_OPERATORS]\n    if status and GroupStatus.UNRESOLVED in status[0].value.raw_value:\n        status_labels = {QUERY_STATUS_LOOKUP[s] for s in status[0].value.raw_value}\n        context = [r for r in context if 'status' not in r or r['status'] in status_labels]\n    response = Response(context)\n    self.add_cursor_headers(request, response, cursor_result)\n    return response",
            "@track_slo_response('workflow')\ndef get(self, request: Request, organization) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        List an Organization\\'s Issues\\n        `````````````````````````````\\n\\n        Return a list of issues (groups) bound to an organization.  All parameters are\\n        supplied as query string parameters.\\n\\n        A default query of ``is:unresolved`` is applied. To return results\\n        with other statuses send an new query value (i.e. ``?query=`` for all\\n        results).\\n\\n        The ``groupStatsPeriod`` parameter can be used to select the timeline\\n        stats which should be present. Possible values are: \\'\\' (disable),\\n        \\'24h\\', \\'14d\\'\\n\\n        The ``statsPeriod`` parameter can be used to select a date window starting\\n        from now. Ex. ``14d``.\\n\\n        The ``start`` and ``end`` parameters can be used to select an absolute\\n        date period to fetch issues from.\\n\\n        :qparam string statsPeriod: an optional stat period (can be one of\\n                                    ``\"24h\"``, ``\"14d\"``, and ``\"\"``).\\n        :qparam string groupStatsPeriod: an optional stat period (can be one of\\n                                    ``\"24h\"``, ``\"14d\"``, and ``\"\"``).\\n        :qparam string start:       Beginning date. You must also provide ``end``.\\n        :qparam string end:         End date. You must also provide ``start``.\\n        :qparam bool shortIdLookup: if this is set to true then short IDs are\\n                                    looked up by this function as well.  This\\n                                    can cause the return value of the function\\n                                    to return an event issue of a different\\n                                    project which is why this is an opt-in.\\n                                    Set to `1` to enable.\\n        :qparam querystring query: an optional Sentry structured search\\n                                   query.  If not provided an implied\\n                                   ``\"is:unresolved\"`` is assumed.)\\n        :qparam bool savedSearch:  if this is set to False, then we are making the request without\\n                                   a saved search and will look for the default search from this endpoint.\\n        :qparam string searchId:   if passed in, this is the selected search\\n        :pparam string organization_slug: the slug of the organization the\\n                                          issues belong to.\\n        :auth: required\\n        :qparam list expand: an optional list of strings to opt in to additional data. Supports `inbox`\\n        :qparam list collapse: an optional list of strings to opt out of certain pieces of data. Supports `stats`, `lifetime`, `base`, `unhandled`\\n        '\n    stats_period = request.GET.get('groupStatsPeriod')\n    try:\n        (start, end) = get_date_range_from_stats_period(request.GET)\n    except InvalidParams as e:\n        raise ParseError(detail=str(e))\n    expand = request.GET.getlist('expand', [])\n    collapse = request.GET.getlist('collapse', [])\n    if stats_period not in (None, '', '24h', '14d', 'auto'):\n        return Response({'detail': ERR_INVALID_STATS_PERIOD}, status=400)\n    (stats_period, stats_period_start, stats_period_end) = calculate_stats_period(stats_period, start, end)\n    environments = self.get_environments(request, organization)\n    projects = self.get_projects(request, organization)\n    project_ids = [p.id for p in projects]\n    if not projects:\n        return Response([])\n    is_fetching_replay_data = request.headers.get('X-Sentry-Replay-Request') == '1'\n    if len(projects) > 1 and (not features.has('organizations:global-views', organization, actor=request.user)) and (not is_fetching_replay_data):\n        return Response({'detail': 'You do not have the multi project stream feature enabled'}, status=400)\n    serializer = functools.partial(StreamGroupSerializerSnuba, environment_ids=[env.id for env in environments], stats_period=stats_period, stats_period_start=stats_period_start, stats_period_end=stats_period_end, expand=expand, collapse=collapse, project_ids=project_ids, organization_id=organization.id)\n    query = request.GET.get('query', '').strip()\n    if query:\n        event_id = normalize_event_id(query)\n        if event_id:\n            direct_hit_projects = set(project_ids) | request.access.project_ids_with_team_membership\n            groups = list(Group.objects.filter_by_event_id(direct_hit_projects, event_id, tenant_ids={'organization_id': organization.id}))\n            if len(groups) == 1:\n                serialized_groups = serialize(groups, request.user, serializer())\n                if event_id:\n                    serialized_groups[0]['matchingEventId'] = event_id\n                response = Response(serialized_groups)\n                response['X-Sentry-Direct-Hit'] = '1'\n                return response\n            if groups:\n                return Response(serialize(groups, request.user, serializer()))\n        group = get_by_short_id(organization.id, request.GET.get('shortIdLookup'), query)\n        if group is not None:\n            if request.access.has_project_access(group.project):\n                response = Response(serialize([group], request.user, serializer()))\n                response['X-Sentry-Direct-Hit'] = '1'\n                return response\n    try:\n        group_ids = set(map(int, request.GET.getlist('group')))\n    except ValueError:\n        return Response({'detail': 'Group ids must be integers'}, status=400)\n    if group_ids:\n        groups = list(Group.objects.filter(id__in=group_ids, project_id__in=project_ids))\n        if any((g for g in groups if not request.access.has_project_access(g.project))):\n            raise PermissionDenied\n        return Response(serialize(groups, request.user, serializer()))\n    try:\n        (cursor_result, query_kwargs) = self._search(request, organization, projects, environments, {'count_hits': True, 'date_to': end, 'date_from': start})\n    except (ValidationError, discover.InvalidSearchQuery) as exc:\n        return Response({'detail': str(exc)}, status=400)\n    results = list(cursor_result)\n    context = serialize(results, request.user, serializer(start=start, end=end, search_filters=query_kwargs['search_filters'] if 'search_filters' in query_kwargs else None, organization_id=organization.id))\n    status = [search_filter for search_filter in query_kwargs.get('search_filters', []) if search_filter.key.name == 'status' and search_filter.operator in EQUALITY_OPERATORS]\n    if status and GroupStatus.UNRESOLVED in status[0].value.raw_value:\n        status_labels = {QUERY_STATUS_LOOKUP[s] for s in status[0].value.raw_value}\n        context = [r for r in context if 'status' not in r or r['status'] in status_labels]\n    response = Response(context)\n    self.add_cursor_headers(request, response, cursor_result)\n    return response",
            "@track_slo_response('workflow')\ndef get(self, request: Request, organization) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        List an Organization\\'s Issues\\n        `````````````````````````````\\n\\n        Return a list of issues (groups) bound to an organization.  All parameters are\\n        supplied as query string parameters.\\n\\n        A default query of ``is:unresolved`` is applied. To return results\\n        with other statuses send an new query value (i.e. ``?query=`` for all\\n        results).\\n\\n        The ``groupStatsPeriod`` parameter can be used to select the timeline\\n        stats which should be present. Possible values are: \\'\\' (disable),\\n        \\'24h\\', \\'14d\\'\\n\\n        The ``statsPeriod`` parameter can be used to select a date window starting\\n        from now. Ex. ``14d``.\\n\\n        The ``start`` and ``end`` parameters can be used to select an absolute\\n        date period to fetch issues from.\\n\\n        :qparam string statsPeriod: an optional stat period (can be one of\\n                                    ``\"24h\"``, ``\"14d\"``, and ``\"\"``).\\n        :qparam string groupStatsPeriod: an optional stat period (can be one of\\n                                    ``\"24h\"``, ``\"14d\"``, and ``\"\"``).\\n        :qparam string start:       Beginning date. You must also provide ``end``.\\n        :qparam string end:         End date. You must also provide ``start``.\\n        :qparam bool shortIdLookup: if this is set to true then short IDs are\\n                                    looked up by this function as well.  This\\n                                    can cause the return value of the function\\n                                    to return an event issue of a different\\n                                    project which is why this is an opt-in.\\n                                    Set to `1` to enable.\\n        :qparam querystring query: an optional Sentry structured search\\n                                   query.  If not provided an implied\\n                                   ``\"is:unresolved\"`` is assumed.)\\n        :qparam bool savedSearch:  if this is set to False, then we are making the request without\\n                                   a saved search and will look for the default search from this endpoint.\\n        :qparam string searchId:   if passed in, this is the selected search\\n        :pparam string organization_slug: the slug of the organization the\\n                                          issues belong to.\\n        :auth: required\\n        :qparam list expand: an optional list of strings to opt in to additional data. Supports `inbox`\\n        :qparam list collapse: an optional list of strings to opt out of certain pieces of data. Supports `stats`, `lifetime`, `base`, `unhandled`\\n        '\n    stats_period = request.GET.get('groupStatsPeriod')\n    try:\n        (start, end) = get_date_range_from_stats_period(request.GET)\n    except InvalidParams as e:\n        raise ParseError(detail=str(e))\n    expand = request.GET.getlist('expand', [])\n    collapse = request.GET.getlist('collapse', [])\n    if stats_period not in (None, '', '24h', '14d', 'auto'):\n        return Response({'detail': ERR_INVALID_STATS_PERIOD}, status=400)\n    (stats_period, stats_period_start, stats_period_end) = calculate_stats_period(stats_period, start, end)\n    environments = self.get_environments(request, organization)\n    projects = self.get_projects(request, organization)\n    project_ids = [p.id for p in projects]\n    if not projects:\n        return Response([])\n    is_fetching_replay_data = request.headers.get('X-Sentry-Replay-Request') == '1'\n    if len(projects) > 1 and (not features.has('organizations:global-views', organization, actor=request.user)) and (not is_fetching_replay_data):\n        return Response({'detail': 'You do not have the multi project stream feature enabled'}, status=400)\n    serializer = functools.partial(StreamGroupSerializerSnuba, environment_ids=[env.id for env in environments], stats_period=stats_period, stats_period_start=stats_period_start, stats_period_end=stats_period_end, expand=expand, collapse=collapse, project_ids=project_ids, organization_id=organization.id)\n    query = request.GET.get('query', '').strip()\n    if query:\n        event_id = normalize_event_id(query)\n        if event_id:\n            direct_hit_projects = set(project_ids) | request.access.project_ids_with_team_membership\n            groups = list(Group.objects.filter_by_event_id(direct_hit_projects, event_id, tenant_ids={'organization_id': organization.id}))\n            if len(groups) == 1:\n                serialized_groups = serialize(groups, request.user, serializer())\n                if event_id:\n                    serialized_groups[0]['matchingEventId'] = event_id\n                response = Response(serialized_groups)\n                response['X-Sentry-Direct-Hit'] = '1'\n                return response\n            if groups:\n                return Response(serialize(groups, request.user, serializer()))\n        group = get_by_short_id(organization.id, request.GET.get('shortIdLookup'), query)\n        if group is not None:\n            if request.access.has_project_access(group.project):\n                response = Response(serialize([group], request.user, serializer()))\n                response['X-Sentry-Direct-Hit'] = '1'\n                return response\n    try:\n        group_ids = set(map(int, request.GET.getlist('group')))\n    except ValueError:\n        return Response({'detail': 'Group ids must be integers'}, status=400)\n    if group_ids:\n        groups = list(Group.objects.filter(id__in=group_ids, project_id__in=project_ids))\n        if any((g for g in groups if not request.access.has_project_access(g.project))):\n            raise PermissionDenied\n        return Response(serialize(groups, request.user, serializer()))\n    try:\n        (cursor_result, query_kwargs) = self._search(request, organization, projects, environments, {'count_hits': True, 'date_to': end, 'date_from': start})\n    except (ValidationError, discover.InvalidSearchQuery) as exc:\n        return Response({'detail': str(exc)}, status=400)\n    results = list(cursor_result)\n    context = serialize(results, request.user, serializer(start=start, end=end, search_filters=query_kwargs['search_filters'] if 'search_filters' in query_kwargs else None, organization_id=organization.id))\n    status = [search_filter for search_filter in query_kwargs.get('search_filters', []) if search_filter.key.name == 'status' and search_filter.operator in EQUALITY_OPERATORS]\n    if status and GroupStatus.UNRESOLVED in status[0].value.raw_value:\n        status_labels = {QUERY_STATUS_LOOKUP[s] for s in status[0].value.raw_value}\n        context = [r for r in context if 'status' not in r or r['status'] in status_labels]\n    response = Response(context)\n    self.add_cursor_headers(request, response, cursor_result)\n    return response",
            "@track_slo_response('workflow')\ndef get(self, request: Request, organization) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        List an Organization\\'s Issues\\n        `````````````````````````````\\n\\n        Return a list of issues (groups) bound to an organization.  All parameters are\\n        supplied as query string parameters.\\n\\n        A default query of ``is:unresolved`` is applied. To return results\\n        with other statuses send an new query value (i.e. ``?query=`` for all\\n        results).\\n\\n        The ``groupStatsPeriod`` parameter can be used to select the timeline\\n        stats which should be present. Possible values are: \\'\\' (disable),\\n        \\'24h\\', \\'14d\\'\\n\\n        The ``statsPeriod`` parameter can be used to select a date window starting\\n        from now. Ex. ``14d``.\\n\\n        The ``start`` and ``end`` parameters can be used to select an absolute\\n        date period to fetch issues from.\\n\\n        :qparam string statsPeriod: an optional stat period (can be one of\\n                                    ``\"24h\"``, ``\"14d\"``, and ``\"\"``).\\n        :qparam string groupStatsPeriod: an optional stat period (can be one of\\n                                    ``\"24h\"``, ``\"14d\"``, and ``\"\"``).\\n        :qparam string start:       Beginning date. You must also provide ``end``.\\n        :qparam string end:         End date. You must also provide ``start``.\\n        :qparam bool shortIdLookup: if this is set to true then short IDs are\\n                                    looked up by this function as well.  This\\n                                    can cause the return value of the function\\n                                    to return an event issue of a different\\n                                    project which is why this is an opt-in.\\n                                    Set to `1` to enable.\\n        :qparam querystring query: an optional Sentry structured search\\n                                   query.  If not provided an implied\\n                                   ``\"is:unresolved\"`` is assumed.)\\n        :qparam bool savedSearch:  if this is set to False, then we are making the request without\\n                                   a saved search and will look for the default search from this endpoint.\\n        :qparam string searchId:   if passed in, this is the selected search\\n        :pparam string organization_slug: the slug of the organization the\\n                                          issues belong to.\\n        :auth: required\\n        :qparam list expand: an optional list of strings to opt in to additional data. Supports `inbox`\\n        :qparam list collapse: an optional list of strings to opt out of certain pieces of data. Supports `stats`, `lifetime`, `base`, `unhandled`\\n        '\n    stats_period = request.GET.get('groupStatsPeriod')\n    try:\n        (start, end) = get_date_range_from_stats_period(request.GET)\n    except InvalidParams as e:\n        raise ParseError(detail=str(e))\n    expand = request.GET.getlist('expand', [])\n    collapse = request.GET.getlist('collapse', [])\n    if stats_period not in (None, '', '24h', '14d', 'auto'):\n        return Response({'detail': ERR_INVALID_STATS_PERIOD}, status=400)\n    (stats_period, stats_period_start, stats_period_end) = calculate_stats_period(stats_period, start, end)\n    environments = self.get_environments(request, organization)\n    projects = self.get_projects(request, organization)\n    project_ids = [p.id for p in projects]\n    if not projects:\n        return Response([])\n    is_fetching_replay_data = request.headers.get('X-Sentry-Replay-Request') == '1'\n    if len(projects) > 1 and (not features.has('organizations:global-views', organization, actor=request.user)) and (not is_fetching_replay_data):\n        return Response({'detail': 'You do not have the multi project stream feature enabled'}, status=400)\n    serializer = functools.partial(StreamGroupSerializerSnuba, environment_ids=[env.id for env in environments], stats_period=stats_period, stats_period_start=stats_period_start, stats_period_end=stats_period_end, expand=expand, collapse=collapse, project_ids=project_ids, organization_id=organization.id)\n    query = request.GET.get('query', '').strip()\n    if query:\n        event_id = normalize_event_id(query)\n        if event_id:\n            direct_hit_projects = set(project_ids) | request.access.project_ids_with_team_membership\n            groups = list(Group.objects.filter_by_event_id(direct_hit_projects, event_id, tenant_ids={'organization_id': organization.id}))\n            if len(groups) == 1:\n                serialized_groups = serialize(groups, request.user, serializer())\n                if event_id:\n                    serialized_groups[0]['matchingEventId'] = event_id\n                response = Response(serialized_groups)\n                response['X-Sentry-Direct-Hit'] = '1'\n                return response\n            if groups:\n                return Response(serialize(groups, request.user, serializer()))\n        group = get_by_short_id(organization.id, request.GET.get('shortIdLookup'), query)\n        if group is not None:\n            if request.access.has_project_access(group.project):\n                response = Response(serialize([group], request.user, serializer()))\n                response['X-Sentry-Direct-Hit'] = '1'\n                return response\n    try:\n        group_ids = set(map(int, request.GET.getlist('group')))\n    except ValueError:\n        return Response({'detail': 'Group ids must be integers'}, status=400)\n    if group_ids:\n        groups = list(Group.objects.filter(id__in=group_ids, project_id__in=project_ids))\n        if any((g for g in groups if not request.access.has_project_access(g.project))):\n            raise PermissionDenied\n        return Response(serialize(groups, request.user, serializer()))\n    try:\n        (cursor_result, query_kwargs) = self._search(request, organization, projects, environments, {'count_hits': True, 'date_to': end, 'date_from': start})\n    except (ValidationError, discover.InvalidSearchQuery) as exc:\n        return Response({'detail': str(exc)}, status=400)\n    results = list(cursor_result)\n    context = serialize(results, request.user, serializer(start=start, end=end, search_filters=query_kwargs['search_filters'] if 'search_filters' in query_kwargs else None, organization_id=organization.id))\n    status = [search_filter for search_filter in query_kwargs.get('search_filters', []) if search_filter.key.name == 'status' and search_filter.operator in EQUALITY_OPERATORS]\n    if status and GroupStatus.UNRESOLVED in status[0].value.raw_value:\n        status_labels = {QUERY_STATUS_LOOKUP[s] for s in status[0].value.raw_value}\n        context = [r for r in context if 'status' not in r or r['status'] in status_labels]\n    response = Response(context)\n    self.add_cursor_headers(request, response, cursor_result)\n    return response",
            "@track_slo_response('workflow')\ndef get(self, request: Request, organization) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        List an Organization\\'s Issues\\n        `````````````````````````````\\n\\n        Return a list of issues (groups) bound to an organization.  All parameters are\\n        supplied as query string parameters.\\n\\n        A default query of ``is:unresolved`` is applied. To return results\\n        with other statuses send an new query value (i.e. ``?query=`` for all\\n        results).\\n\\n        The ``groupStatsPeriod`` parameter can be used to select the timeline\\n        stats which should be present. Possible values are: \\'\\' (disable),\\n        \\'24h\\', \\'14d\\'\\n\\n        The ``statsPeriod`` parameter can be used to select a date window starting\\n        from now. Ex. ``14d``.\\n\\n        The ``start`` and ``end`` parameters can be used to select an absolute\\n        date period to fetch issues from.\\n\\n        :qparam string statsPeriod: an optional stat period (can be one of\\n                                    ``\"24h\"``, ``\"14d\"``, and ``\"\"``).\\n        :qparam string groupStatsPeriod: an optional stat period (can be one of\\n                                    ``\"24h\"``, ``\"14d\"``, and ``\"\"``).\\n        :qparam string start:       Beginning date. You must also provide ``end``.\\n        :qparam string end:         End date. You must also provide ``start``.\\n        :qparam bool shortIdLookup: if this is set to true then short IDs are\\n                                    looked up by this function as well.  This\\n                                    can cause the return value of the function\\n                                    to return an event issue of a different\\n                                    project which is why this is an opt-in.\\n                                    Set to `1` to enable.\\n        :qparam querystring query: an optional Sentry structured search\\n                                   query.  If not provided an implied\\n                                   ``\"is:unresolved\"`` is assumed.)\\n        :qparam bool savedSearch:  if this is set to False, then we are making the request without\\n                                   a saved search and will look for the default search from this endpoint.\\n        :qparam string searchId:   if passed in, this is the selected search\\n        :pparam string organization_slug: the slug of the organization the\\n                                          issues belong to.\\n        :auth: required\\n        :qparam list expand: an optional list of strings to opt in to additional data. Supports `inbox`\\n        :qparam list collapse: an optional list of strings to opt out of certain pieces of data. Supports `stats`, `lifetime`, `base`, `unhandled`\\n        '\n    stats_period = request.GET.get('groupStatsPeriod')\n    try:\n        (start, end) = get_date_range_from_stats_period(request.GET)\n    except InvalidParams as e:\n        raise ParseError(detail=str(e))\n    expand = request.GET.getlist('expand', [])\n    collapse = request.GET.getlist('collapse', [])\n    if stats_period not in (None, '', '24h', '14d', 'auto'):\n        return Response({'detail': ERR_INVALID_STATS_PERIOD}, status=400)\n    (stats_period, stats_period_start, stats_period_end) = calculate_stats_period(stats_period, start, end)\n    environments = self.get_environments(request, organization)\n    projects = self.get_projects(request, organization)\n    project_ids = [p.id for p in projects]\n    if not projects:\n        return Response([])\n    is_fetching_replay_data = request.headers.get('X-Sentry-Replay-Request') == '1'\n    if len(projects) > 1 and (not features.has('organizations:global-views', organization, actor=request.user)) and (not is_fetching_replay_data):\n        return Response({'detail': 'You do not have the multi project stream feature enabled'}, status=400)\n    serializer = functools.partial(StreamGroupSerializerSnuba, environment_ids=[env.id for env in environments], stats_period=stats_period, stats_period_start=stats_period_start, stats_period_end=stats_period_end, expand=expand, collapse=collapse, project_ids=project_ids, organization_id=organization.id)\n    query = request.GET.get('query', '').strip()\n    if query:\n        event_id = normalize_event_id(query)\n        if event_id:\n            direct_hit_projects = set(project_ids) | request.access.project_ids_with_team_membership\n            groups = list(Group.objects.filter_by_event_id(direct_hit_projects, event_id, tenant_ids={'organization_id': organization.id}))\n            if len(groups) == 1:\n                serialized_groups = serialize(groups, request.user, serializer())\n                if event_id:\n                    serialized_groups[0]['matchingEventId'] = event_id\n                response = Response(serialized_groups)\n                response['X-Sentry-Direct-Hit'] = '1'\n                return response\n            if groups:\n                return Response(serialize(groups, request.user, serializer()))\n        group = get_by_short_id(organization.id, request.GET.get('shortIdLookup'), query)\n        if group is not None:\n            if request.access.has_project_access(group.project):\n                response = Response(serialize([group], request.user, serializer()))\n                response['X-Sentry-Direct-Hit'] = '1'\n                return response\n    try:\n        group_ids = set(map(int, request.GET.getlist('group')))\n    except ValueError:\n        return Response({'detail': 'Group ids must be integers'}, status=400)\n    if group_ids:\n        groups = list(Group.objects.filter(id__in=group_ids, project_id__in=project_ids))\n        if any((g for g in groups if not request.access.has_project_access(g.project))):\n            raise PermissionDenied\n        return Response(serialize(groups, request.user, serializer()))\n    try:\n        (cursor_result, query_kwargs) = self._search(request, organization, projects, environments, {'count_hits': True, 'date_to': end, 'date_from': start})\n    except (ValidationError, discover.InvalidSearchQuery) as exc:\n        return Response({'detail': str(exc)}, status=400)\n    results = list(cursor_result)\n    context = serialize(results, request.user, serializer(start=start, end=end, search_filters=query_kwargs['search_filters'] if 'search_filters' in query_kwargs else None, organization_id=organization.id))\n    status = [search_filter for search_filter in query_kwargs.get('search_filters', []) if search_filter.key.name == 'status' and search_filter.operator in EQUALITY_OPERATORS]\n    if status and GroupStatus.UNRESOLVED in status[0].value.raw_value:\n        status_labels = {QUERY_STATUS_LOOKUP[s] for s in status[0].value.raw_value}\n        context = [r for r in context if 'status' not in r or r['status'] in status_labels]\n    response = Response(context)\n    self.add_cursor_headers(request, response, cursor_result)\n    return response"
        ]
    },
    {
        "func_name": "put",
        "original": "@track_slo_response('workflow')\ndef put(self, request: Request, organization) -> Response:\n    \"\"\"\n        Bulk Mutate a List of Issues\n        ````````````````````````````\n\n        Bulk mutate various attributes on issues.  The list of issues\n        to modify is given through the `id` query parameter.  It is repeated\n        for each issue that should be modified.\n\n        - For non-status updates, the `id` query parameter is required.\n        - For status updates, the `id` query parameter may be omitted\n          for a batch \"update all\" query.\n        - An optional `status` query parameter may be used to restrict\n          mutations to only events with the given status.\n\n        The following attributes can be modified and are supplied as\n        JSON object in the body:\n\n        If any ids are out of scope this operation will succeed without\n        any data mutation.\n\n        :qparam int id: a list of IDs of the issues to be mutated.  This\n                        parameter shall be repeated for each issue.  It\n                        is optional only if a status is mutated in which\n                        case an implicit `update all` is assumed.\n        :qparam string status: optionally limits the query to issues of the\n                               specified status.  Valid values are\n                               ``\"resolved\"``, ``\"unresolved\"`` and\n                               ``\"ignored\"``.\n        :pparam string organization_slug: the slug of the organization the\n                                          issues belong to.\n        :param string status: the new status for the issues.  Valid values\n                              are ``\"resolved\"``, ``\"resolvedInNextRelease\"``,\n                              ``\"unresolved\"``, and ``\"ignored\"``. Status\n                              updates that include release data are only allowed\n                              for groups within a single project.\n        :param map statusDetails: additional details about the resolution.\n                                  Valid values are ``\"inRelease\"``, ``\"inNextRelease\"``,\n                                  ``\"inCommit\"``,  ``\"ignoreDuration\"``, ``\"ignoreCount\"``,\n                                  ``\"ignoreWindow\"``, ``\"ignoreUserCount\"``, and\n                                  ``\"ignoreUserWindow\"``. Status detail\n                                  updates that include release data are only allowed\n                                  for groups within a single project.\n        :param int ignoreDuration: the number of minutes to ignore this issue.\n        :param boolean isPublic: sets the issue to public or private.\n        :param boolean merge: allows to merge or unmerge different issues.\n        :param string assignedTo: the user or team that should be assigned to\n                                  these issues. Can be of the form ``\"<user_id>\"``,\n                                  ``\"user:<user_id>\"``, ``\"<username>\"``,\n                                  ``\"<user_primary_email>\"``, or ``\"team:<team_id>\"``.\n                                  Bulk assigning issues is limited to groups\n                                  within a single project.\n        :param boolean hasSeen: in case this API call is invoked with a user\n                                context this allows changing of the flag\n                                that indicates if the user has seen the\n                                event.\n        :param boolean isBookmarked: in case this API call is invoked with a\n                                     user context this allows changing of\n                                     the bookmark flag.\n        :param string substatus: the new substatus for the issues. Valid values\n                                 defined in GroupSubStatus.\n        :auth: required\n        \"\"\"\n    projects = self.get_projects(request, organization)\n    is_fetching_replay_data = request.headers.get('X-Sentry-Replay-Request') == '1'\n    if len(projects) > 1 and (not features.has('organizations:global-views', organization, actor=request.user)) and (not is_fetching_replay_data):\n        return Response({'detail': 'You do not have the multi project stream feature enabled'}, status=400)\n    search_fn = functools.partial(self._search, request, organization, projects, self.get_environments(request, organization))\n    return update_groups(request, request.GET.getlist('id'), projects, organization.id, search_fn)",
        "mutated": [
            "@track_slo_response('workflow')\ndef put(self, request: Request, organization) -> Response:\n    if False:\n        i = 10\n    '\\n        Bulk Mutate a List of Issues\\n        ````````````````````````````\\n\\n        Bulk mutate various attributes on issues.  The list of issues\\n        to modify is given through the `id` query parameter.  It is repeated\\n        for each issue that should be modified.\\n\\n        - For non-status updates, the `id` query parameter is required.\\n        - For status updates, the `id` query parameter may be omitted\\n          for a batch \"update all\" query.\\n        - An optional `status` query parameter may be used to restrict\\n          mutations to only events with the given status.\\n\\n        The following attributes can be modified and are supplied as\\n        JSON object in the body:\\n\\n        If any ids are out of scope this operation will succeed without\\n        any data mutation.\\n\\n        :qparam int id: a list of IDs of the issues to be mutated.  This\\n                        parameter shall be repeated for each issue.  It\\n                        is optional only if a status is mutated in which\\n                        case an implicit `update all` is assumed.\\n        :qparam string status: optionally limits the query to issues of the\\n                               specified status.  Valid values are\\n                               ``\"resolved\"``, ``\"unresolved\"`` and\\n                               ``\"ignored\"``.\\n        :pparam string organization_slug: the slug of the organization the\\n                                          issues belong to.\\n        :param string status: the new status for the issues.  Valid values\\n                              are ``\"resolved\"``, ``\"resolvedInNextRelease\"``,\\n                              ``\"unresolved\"``, and ``\"ignored\"``. Status\\n                              updates that include release data are only allowed\\n                              for groups within a single project.\\n        :param map statusDetails: additional details about the resolution.\\n                                  Valid values are ``\"inRelease\"``, ``\"inNextRelease\"``,\\n                                  ``\"inCommit\"``,  ``\"ignoreDuration\"``, ``\"ignoreCount\"``,\\n                                  ``\"ignoreWindow\"``, ``\"ignoreUserCount\"``, and\\n                                  ``\"ignoreUserWindow\"``. Status detail\\n                                  updates that include release data are only allowed\\n                                  for groups within a single project.\\n        :param int ignoreDuration: the number of minutes to ignore this issue.\\n        :param boolean isPublic: sets the issue to public or private.\\n        :param boolean merge: allows to merge or unmerge different issues.\\n        :param string assignedTo: the user or team that should be assigned to\\n                                  these issues. Can be of the form ``\"<user_id>\"``,\\n                                  ``\"user:<user_id>\"``, ``\"<username>\"``,\\n                                  ``\"<user_primary_email>\"``, or ``\"team:<team_id>\"``.\\n                                  Bulk assigning issues is limited to groups\\n                                  within a single project.\\n        :param boolean hasSeen: in case this API call is invoked with a user\\n                                context this allows changing of the flag\\n                                that indicates if the user has seen the\\n                                event.\\n        :param boolean isBookmarked: in case this API call is invoked with a\\n                                     user context this allows changing of\\n                                     the bookmark flag.\\n        :param string substatus: the new substatus for the issues. Valid values\\n                                 defined in GroupSubStatus.\\n        :auth: required\\n        '\n    projects = self.get_projects(request, organization)\n    is_fetching_replay_data = request.headers.get('X-Sentry-Replay-Request') == '1'\n    if len(projects) > 1 and (not features.has('organizations:global-views', organization, actor=request.user)) and (not is_fetching_replay_data):\n        return Response({'detail': 'You do not have the multi project stream feature enabled'}, status=400)\n    search_fn = functools.partial(self._search, request, organization, projects, self.get_environments(request, organization))\n    return update_groups(request, request.GET.getlist('id'), projects, organization.id, search_fn)",
            "@track_slo_response('workflow')\ndef put(self, request: Request, organization) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Bulk Mutate a List of Issues\\n        ````````````````````````````\\n\\n        Bulk mutate various attributes on issues.  The list of issues\\n        to modify is given through the `id` query parameter.  It is repeated\\n        for each issue that should be modified.\\n\\n        - For non-status updates, the `id` query parameter is required.\\n        - For status updates, the `id` query parameter may be omitted\\n          for a batch \"update all\" query.\\n        - An optional `status` query parameter may be used to restrict\\n          mutations to only events with the given status.\\n\\n        The following attributes can be modified and are supplied as\\n        JSON object in the body:\\n\\n        If any ids are out of scope this operation will succeed without\\n        any data mutation.\\n\\n        :qparam int id: a list of IDs of the issues to be mutated.  This\\n                        parameter shall be repeated for each issue.  It\\n                        is optional only if a status is mutated in which\\n                        case an implicit `update all` is assumed.\\n        :qparam string status: optionally limits the query to issues of the\\n                               specified status.  Valid values are\\n                               ``\"resolved\"``, ``\"unresolved\"`` and\\n                               ``\"ignored\"``.\\n        :pparam string organization_slug: the slug of the organization the\\n                                          issues belong to.\\n        :param string status: the new status for the issues.  Valid values\\n                              are ``\"resolved\"``, ``\"resolvedInNextRelease\"``,\\n                              ``\"unresolved\"``, and ``\"ignored\"``. Status\\n                              updates that include release data are only allowed\\n                              for groups within a single project.\\n        :param map statusDetails: additional details about the resolution.\\n                                  Valid values are ``\"inRelease\"``, ``\"inNextRelease\"``,\\n                                  ``\"inCommit\"``,  ``\"ignoreDuration\"``, ``\"ignoreCount\"``,\\n                                  ``\"ignoreWindow\"``, ``\"ignoreUserCount\"``, and\\n                                  ``\"ignoreUserWindow\"``. Status detail\\n                                  updates that include release data are only allowed\\n                                  for groups within a single project.\\n        :param int ignoreDuration: the number of minutes to ignore this issue.\\n        :param boolean isPublic: sets the issue to public or private.\\n        :param boolean merge: allows to merge or unmerge different issues.\\n        :param string assignedTo: the user or team that should be assigned to\\n                                  these issues. Can be of the form ``\"<user_id>\"``,\\n                                  ``\"user:<user_id>\"``, ``\"<username>\"``,\\n                                  ``\"<user_primary_email>\"``, or ``\"team:<team_id>\"``.\\n                                  Bulk assigning issues is limited to groups\\n                                  within a single project.\\n        :param boolean hasSeen: in case this API call is invoked with a user\\n                                context this allows changing of the flag\\n                                that indicates if the user has seen the\\n                                event.\\n        :param boolean isBookmarked: in case this API call is invoked with a\\n                                     user context this allows changing of\\n                                     the bookmark flag.\\n        :param string substatus: the new substatus for the issues. Valid values\\n                                 defined in GroupSubStatus.\\n        :auth: required\\n        '\n    projects = self.get_projects(request, organization)\n    is_fetching_replay_data = request.headers.get('X-Sentry-Replay-Request') == '1'\n    if len(projects) > 1 and (not features.has('organizations:global-views', organization, actor=request.user)) and (not is_fetching_replay_data):\n        return Response({'detail': 'You do not have the multi project stream feature enabled'}, status=400)\n    search_fn = functools.partial(self._search, request, organization, projects, self.get_environments(request, organization))\n    return update_groups(request, request.GET.getlist('id'), projects, organization.id, search_fn)",
            "@track_slo_response('workflow')\ndef put(self, request: Request, organization) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Bulk Mutate a List of Issues\\n        ````````````````````````````\\n\\n        Bulk mutate various attributes on issues.  The list of issues\\n        to modify is given through the `id` query parameter.  It is repeated\\n        for each issue that should be modified.\\n\\n        - For non-status updates, the `id` query parameter is required.\\n        - For status updates, the `id` query parameter may be omitted\\n          for a batch \"update all\" query.\\n        - An optional `status` query parameter may be used to restrict\\n          mutations to only events with the given status.\\n\\n        The following attributes can be modified and are supplied as\\n        JSON object in the body:\\n\\n        If any ids are out of scope this operation will succeed without\\n        any data mutation.\\n\\n        :qparam int id: a list of IDs of the issues to be mutated.  This\\n                        parameter shall be repeated for each issue.  It\\n                        is optional only if a status is mutated in which\\n                        case an implicit `update all` is assumed.\\n        :qparam string status: optionally limits the query to issues of the\\n                               specified status.  Valid values are\\n                               ``\"resolved\"``, ``\"unresolved\"`` and\\n                               ``\"ignored\"``.\\n        :pparam string organization_slug: the slug of the organization the\\n                                          issues belong to.\\n        :param string status: the new status for the issues.  Valid values\\n                              are ``\"resolved\"``, ``\"resolvedInNextRelease\"``,\\n                              ``\"unresolved\"``, and ``\"ignored\"``. Status\\n                              updates that include release data are only allowed\\n                              for groups within a single project.\\n        :param map statusDetails: additional details about the resolution.\\n                                  Valid values are ``\"inRelease\"``, ``\"inNextRelease\"``,\\n                                  ``\"inCommit\"``,  ``\"ignoreDuration\"``, ``\"ignoreCount\"``,\\n                                  ``\"ignoreWindow\"``, ``\"ignoreUserCount\"``, and\\n                                  ``\"ignoreUserWindow\"``. Status detail\\n                                  updates that include release data are only allowed\\n                                  for groups within a single project.\\n        :param int ignoreDuration: the number of minutes to ignore this issue.\\n        :param boolean isPublic: sets the issue to public or private.\\n        :param boolean merge: allows to merge or unmerge different issues.\\n        :param string assignedTo: the user or team that should be assigned to\\n                                  these issues. Can be of the form ``\"<user_id>\"``,\\n                                  ``\"user:<user_id>\"``, ``\"<username>\"``,\\n                                  ``\"<user_primary_email>\"``, or ``\"team:<team_id>\"``.\\n                                  Bulk assigning issues is limited to groups\\n                                  within a single project.\\n        :param boolean hasSeen: in case this API call is invoked with a user\\n                                context this allows changing of the flag\\n                                that indicates if the user has seen the\\n                                event.\\n        :param boolean isBookmarked: in case this API call is invoked with a\\n                                     user context this allows changing of\\n                                     the bookmark flag.\\n        :param string substatus: the new substatus for the issues. Valid values\\n                                 defined in GroupSubStatus.\\n        :auth: required\\n        '\n    projects = self.get_projects(request, organization)\n    is_fetching_replay_data = request.headers.get('X-Sentry-Replay-Request') == '1'\n    if len(projects) > 1 and (not features.has('organizations:global-views', organization, actor=request.user)) and (not is_fetching_replay_data):\n        return Response({'detail': 'You do not have the multi project stream feature enabled'}, status=400)\n    search_fn = functools.partial(self._search, request, organization, projects, self.get_environments(request, organization))\n    return update_groups(request, request.GET.getlist('id'), projects, organization.id, search_fn)",
            "@track_slo_response('workflow')\ndef put(self, request: Request, organization) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Bulk Mutate a List of Issues\\n        ````````````````````````````\\n\\n        Bulk mutate various attributes on issues.  The list of issues\\n        to modify is given through the `id` query parameter.  It is repeated\\n        for each issue that should be modified.\\n\\n        - For non-status updates, the `id` query parameter is required.\\n        - For status updates, the `id` query parameter may be omitted\\n          for a batch \"update all\" query.\\n        - An optional `status` query parameter may be used to restrict\\n          mutations to only events with the given status.\\n\\n        The following attributes can be modified and are supplied as\\n        JSON object in the body:\\n\\n        If any ids are out of scope this operation will succeed without\\n        any data mutation.\\n\\n        :qparam int id: a list of IDs of the issues to be mutated.  This\\n                        parameter shall be repeated for each issue.  It\\n                        is optional only if a status is mutated in which\\n                        case an implicit `update all` is assumed.\\n        :qparam string status: optionally limits the query to issues of the\\n                               specified status.  Valid values are\\n                               ``\"resolved\"``, ``\"unresolved\"`` and\\n                               ``\"ignored\"``.\\n        :pparam string organization_slug: the slug of the organization the\\n                                          issues belong to.\\n        :param string status: the new status for the issues.  Valid values\\n                              are ``\"resolved\"``, ``\"resolvedInNextRelease\"``,\\n                              ``\"unresolved\"``, and ``\"ignored\"``. Status\\n                              updates that include release data are only allowed\\n                              for groups within a single project.\\n        :param map statusDetails: additional details about the resolution.\\n                                  Valid values are ``\"inRelease\"``, ``\"inNextRelease\"``,\\n                                  ``\"inCommit\"``,  ``\"ignoreDuration\"``, ``\"ignoreCount\"``,\\n                                  ``\"ignoreWindow\"``, ``\"ignoreUserCount\"``, and\\n                                  ``\"ignoreUserWindow\"``. Status detail\\n                                  updates that include release data are only allowed\\n                                  for groups within a single project.\\n        :param int ignoreDuration: the number of minutes to ignore this issue.\\n        :param boolean isPublic: sets the issue to public or private.\\n        :param boolean merge: allows to merge or unmerge different issues.\\n        :param string assignedTo: the user or team that should be assigned to\\n                                  these issues. Can be of the form ``\"<user_id>\"``,\\n                                  ``\"user:<user_id>\"``, ``\"<username>\"``,\\n                                  ``\"<user_primary_email>\"``, or ``\"team:<team_id>\"``.\\n                                  Bulk assigning issues is limited to groups\\n                                  within a single project.\\n        :param boolean hasSeen: in case this API call is invoked with a user\\n                                context this allows changing of the flag\\n                                that indicates if the user has seen the\\n                                event.\\n        :param boolean isBookmarked: in case this API call is invoked with a\\n                                     user context this allows changing of\\n                                     the bookmark flag.\\n        :param string substatus: the new substatus for the issues. Valid values\\n                                 defined in GroupSubStatus.\\n        :auth: required\\n        '\n    projects = self.get_projects(request, organization)\n    is_fetching_replay_data = request.headers.get('X-Sentry-Replay-Request') == '1'\n    if len(projects) > 1 and (not features.has('organizations:global-views', organization, actor=request.user)) and (not is_fetching_replay_data):\n        return Response({'detail': 'You do not have the multi project stream feature enabled'}, status=400)\n    search_fn = functools.partial(self._search, request, organization, projects, self.get_environments(request, organization))\n    return update_groups(request, request.GET.getlist('id'), projects, organization.id, search_fn)",
            "@track_slo_response('workflow')\ndef put(self, request: Request, organization) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Bulk Mutate a List of Issues\\n        ````````````````````````````\\n\\n        Bulk mutate various attributes on issues.  The list of issues\\n        to modify is given through the `id` query parameter.  It is repeated\\n        for each issue that should be modified.\\n\\n        - For non-status updates, the `id` query parameter is required.\\n        - For status updates, the `id` query parameter may be omitted\\n          for a batch \"update all\" query.\\n        - An optional `status` query parameter may be used to restrict\\n          mutations to only events with the given status.\\n\\n        The following attributes can be modified and are supplied as\\n        JSON object in the body:\\n\\n        If any ids are out of scope this operation will succeed without\\n        any data mutation.\\n\\n        :qparam int id: a list of IDs of the issues to be mutated.  This\\n                        parameter shall be repeated for each issue.  It\\n                        is optional only if a status is mutated in which\\n                        case an implicit `update all` is assumed.\\n        :qparam string status: optionally limits the query to issues of the\\n                               specified status.  Valid values are\\n                               ``\"resolved\"``, ``\"unresolved\"`` and\\n                               ``\"ignored\"``.\\n        :pparam string organization_slug: the slug of the organization the\\n                                          issues belong to.\\n        :param string status: the new status for the issues.  Valid values\\n                              are ``\"resolved\"``, ``\"resolvedInNextRelease\"``,\\n                              ``\"unresolved\"``, and ``\"ignored\"``. Status\\n                              updates that include release data are only allowed\\n                              for groups within a single project.\\n        :param map statusDetails: additional details about the resolution.\\n                                  Valid values are ``\"inRelease\"``, ``\"inNextRelease\"``,\\n                                  ``\"inCommit\"``,  ``\"ignoreDuration\"``, ``\"ignoreCount\"``,\\n                                  ``\"ignoreWindow\"``, ``\"ignoreUserCount\"``, and\\n                                  ``\"ignoreUserWindow\"``. Status detail\\n                                  updates that include release data are only allowed\\n                                  for groups within a single project.\\n        :param int ignoreDuration: the number of minutes to ignore this issue.\\n        :param boolean isPublic: sets the issue to public or private.\\n        :param boolean merge: allows to merge or unmerge different issues.\\n        :param string assignedTo: the user or team that should be assigned to\\n                                  these issues. Can be of the form ``\"<user_id>\"``,\\n                                  ``\"user:<user_id>\"``, ``\"<username>\"``,\\n                                  ``\"<user_primary_email>\"``, or ``\"team:<team_id>\"``.\\n                                  Bulk assigning issues is limited to groups\\n                                  within a single project.\\n        :param boolean hasSeen: in case this API call is invoked with a user\\n                                context this allows changing of the flag\\n                                that indicates if the user has seen the\\n                                event.\\n        :param boolean isBookmarked: in case this API call is invoked with a\\n                                     user context this allows changing of\\n                                     the bookmark flag.\\n        :param string substatus: the new substatus for the issues. Valid values\\n                                 defined in GroupSubStatus.\\n        :auth: required\\n        '\n    projects = self.get_projects(request, organization)\n    is_fetching_replay_data = request.headers.get('X-Sentry-Replay-Request') == '1'\n    if len(projects) > 1 and (not features.has('organizations:global-views', organization, actor=request.user)) and (not is_fetching_replay_data):\n        return Response({'detail': 'You do not have the multi project stream feature enabled'}, status=400)\n    search_fn = functools.partial(self._search, request, organization, projects, self.get_environments(request, organization))\n    return update_groups(request, request.GET.getlist('id'), projects, organization.id, search_fn)"
        ]
    },
    {
        "func_name": "delete",
        "original": "@track_slo_response('workflow')\ndef delete(self, request: Request, organization) -> Response:\n    \"\"\"\n        Bulk Remove a List of Issues\n        ````````````````````````````\n\n        Permanently remove the given issues. The list of issues to\n        modify is given through the `id` query parameter.  It is repeated\n        for each issue that should be removed.\n\n        Only queries by 'id' are accepted.\n\n        If any IDs are out of scope this operation will succeed without\n        any data mutation.\n\n        :qparam int id: a list of IDs of the issues to be removed.  This\n                        parameter shall be repeated for each issue, e.g.\n                        `?id=1&id=2&id=3`. If this parameter is not provided,\n                        it will attempt to remove the first 1000 issues.\n        :pparam string organization_slug: the slug of the organization the\n                                          issues belong to.\n        :auth: required\n        \"\"\"\n    projects = self.get_projects(request, organization)\n    is_fetching_replay_data = request.headers.get('X-Sentry-Replay-Request') == '1'\n    if len(projects) > 1 and (not features.has('organizations:global-views', organization, actor=request.user)) and (not is_fetching_replay_data):\n        return Response({'detail': 'You do not have the multi project stream feature enabled'}, status=400)\n    search_fn = functools.partial(self._search, request, organization, projects, self.get_environments(request, organization))\n    return delete_groups(request, projects, organization.id, search_fn)",
        "mutated": [
            "@track_slo_response('workflow')\ndef delete(self, request: Request, organization) -> Response:\n    if False:\n        i = 10\n    \"\\n        Bulk Remove a List of Issues\\n        ````````````````````````````\\n\\n        Permanently remove the given issues. The list of issues to\\n        modify is given through the `id` query parameter.  It is repeated\\n        for each issue that should be removed.\\n\\n        Only queries by 'id' are accepted.\\n\\n        If any IDs are out of scope this operation will succeed without\\n        any data mutation.\\n\\n        :qparam int id: a list of IDs of the issues to be removed.  This\\n                        parameter shall be repeated for each issue, e.g.\\n                        `?id=1&id=2&id=3`. If this parameter is not provided,\\n                        it will attempt to remove the first 1000 issues.\\n        :pparam string organization_slug: the slug of the organization the\\n                                          issues belong to.\\n        :auth: required\\n        \"\n    projects = self.get_projects(request, organization)\n    is_fetching_replay_data = request.headers.get('X-Sentry-Replay-Request') == '1'\n    if len(projects) > 1 and (not features.has('organizations:global-views', organization, actor=request.user)) and (not is_fetching_replay_data):\n        return Response({'detail': 'You do not have the multi project stream feature enabled'}, status=400)\n    search_fn = functools.partial(self._search, request, organization, projects, self.get_environments(request, organization))\n    return delete_groups(request, projects, organization.id, search_fn)",
            "@track_slo_response('workflow')\ndef delete(self, request: Request, organization) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Bulk Remove a List of Issues\\n        ````````````````````````````\\n\\n        Permanently remove the given issues. The list of issues to\\n        modify is given through the `id` query parameter.  It is repeated\\n        for each issue that should be removed.\\n\\n        Only queries by 'id' are accepted.\\n\\n        If any IDs are out of scope this operation will succeed without\\n        any data mutation.\\n\\n        :qparam int id: a list of IDs of the issues to be removed.  This\\n                        parameter shall be repeated for each issue, e.g.\\n                        `?id=1&id=2&id=3`. If this parameter is not provided,\\n                        it will attempt to remove the first 1000 issues.\\n        :pparam string organization_slug: the slug of the organization the\\n                                          issues belong to.\\n        :auth: required\\n        \"\n    projects = self.get_projects(request, organization)\n    is_fetching_replay_data = request.headers.get('X-Sentry-Replay-Request') == '1'\n    if len(projects) > 1 and (not features.has('organizations:global-views', organization, actor=request.user)) and (not is_fetching_replay_data):\n        return Response({'detail': 'You do not have the multi project stream feature enabled'}, status=400)\n    search_fn = functools.partial(self._search, request, organization, projects, self.get_environments(request, organization))\n    return delete_groups(request, projects, organization.id, search_fn)",
            "@track_slo_response('workflow')\ndef delete(self, request: Request, organization) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Bulk Remove a List of Issues\\n        ````````````````````````````\\n\\n        Permanently remove the given issues. The list of issues to\\n        modify is given through the `id` query parameter.  It is repeated\\n        for each issue that should be removed.\\n\\n        Only queries by 'id' are accepted.\\n\\n        If any IDs are out of scope this operation will succeed without\\n        any data mutation.\\n\\n        :qparam int id: a list of IDs of the issues to be removed.  This\\n                        parameter shall be repeated for each issue, e.g.\\n                        `?id=1&id=2&id=3`. If this parameter is not provided,\\n                        it will attempt to remove the first 1000 issues.\\n        :pparam string organization_slug: the slug of the organization the\\n                                          issues belong to.\\n        :auth: required\\n        \"\n    projects = self.get_projects(request, organization)\n    is_fetching_replay_data = request.headers.get('X-Sentry-Replay-Request') == '1'\n    if len(projects) > 1 and (not features.has('organizations:global-views', organization, actor=request.user)) and (not is_fetching_replay_data):\n        return Response({'detail': 'You do not have the multi project stream feature enabled'}, status=400)\n    search_fn = functools.partial(self._search, request, organization, projects, self.get_environments(request, organization))\n    return delete_groups(request, projects, organization.id, search_fn)",
            "@track_slo_response('workflow')\ndef delete(self, request: Request, organization) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Bulk Remove a List of Issues\\n        ````````````````````````````\\n\\n        Permanently remove the given issues. The list of issues to\\n        modify is given through the `id` query parameter.  It is repeated\\n        for each issue that should be removed.\\n\\n        Only queries by 'id' are accepted.\\n\\n        If any IDs are out of scope this operation will succeed without\\n        any data mutation.\\n\\n        :qparam int id: a list of IDs of the issues to be removed.  This\\n                        parameter shall be repeated for each issue, e.g.\\n                        `?id=1&id=2&id=3`. If this parameter is not provided,\\n                        it will attempt to remove the first 1000 issues.\\n        :pparam string organization_slug: the slug of the organization the\\n                                          issues belong to.\\n        :auth: required\\n        \"\n    projects = self.get_projects(request, organization)\n    is_fetching_replay_data = request.headers.get('X-Sentry-Replay-Request') == '1'\n    if len(projects) > 1 and (not features.has('organizations:global-views', organization, actor=request.user)) and (not is_fetching_replay_data):\n        return Response({'detail': 'You do not have the multi project stream feature enabled'}, status=400)\n    search_fn = functools.partial(self._search, request, organization, projects, self.get_environments(request, organization))\n    return delete_groups(request, projects, organization.id, search_fn)",
            "@track_slo_response('workflow')\ndef delete(self, request: Request, organization) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Bulk Remove a List of Issues\\n        ````````````````````````````\\n\\n        Permanently remove the given issues. The list of issues to\\n        modify is given through the `id` query parameter.  It is repeated\\n        for each issue that should be removed.\\n\\n        Only queries by 'id' are accepted.\\n\\n        If any IDs are out of scope this operation will succeed without\\n        any data mutation.\\n\\n        :qparam int id: a list of IDs of the issues to be removed.  This\\n                        parameter shall be repeated for each issue, e.g.\\n                        `?id=1&id=2&id=3`. If this parameter is not provided,\\n                        it will attempt to remove the first 1000 issues.\\n        :pparam string organization_slug: the slug of the organization the\\n                                          issues belong to.\\n        :auth: required\\n        \"\n    projects = self.get_projects(request, organization)\n    is_fetching_replay_data = request.headers.get('X-Sentry-Replay-Request') == '1'\n    if len(projects) > 1 and (not features.has('organizations:global-views', organization, actor=request.user)) and (not is_fetching_replay_data):\n        return Response({'detail': 'You do not have the multi project stream feature enabled'}, status=400)\n    search_fn = functools.partial(self._search, request, organization, projects, self.get_environments(request, organization))\n    return delete_groups(request, projects, organization.id, search_fn)"
        ]
    }
]