"""
A set of functions used to interface with the external megam_ maxent
optimization package. Before megam can be used, you should tell NLTK where it
can find the megam binary, using the ``config_megam()`` function. Typical
usage:

    >>> from nltk.classify import megam
    >>> megam.config_megam() # pass path to megam if not found in PATH # doctest: +SKIP
    [Found megam: ...]

Use with MaxentClassifier. Example below, see MaxentClassifier documentation
for details.

    nltk.classify.MaxentClassifier.train(corpus, 'megam')

.. _megam: https://www.umiacs.umd.edu/~hal/megam/index.html
"""
import subprocess
from nltk.internals import find_binary
try:
    import numpy
except ImportError:
    numpy = None
_megam_bin = None

def config_megam(bin=None):
    if False:
        for i in range(10):
            print('nop')
    "\n    Configure NLTK's interface to the ``megam`` maxent optimization\n    package.\n\n    :param bin: The full path to the ``megam`` binary.  If not specified,\n        then nltk will search the system for a ``megam`` binary; and if\n        one is not found, it will raise a ``LookupError`` exception.\n    :type bin: str\n    "
    global _megam_bin
    _megam_bin = find_binary('megam', bin, env_vars=['MEGAM'], binary_names=['megam.opt', 'megam', 'megam_686', 'megam_i686.opt'], url='https://www.umiacs.umd.edu/~hal/megam/index.html')

def write_megam_file(train_toks, encoding, stream, bernoulli=True, explicit=True):
    if False:
        i = 10
        return i + 15
    "\n    Generate an input file for ``megam`` based on the given corpus of\n    classified tokens.\n\n    :type train_toks: list(tuple(dict, str))\n    :param train_toks: Training data, represented as a list of\n        pairs, the first member of which is a feature dictionary,\n        and the second of which is a classification label.\n\n    :type encoding: MaxentFeatureEncodingI\n    :param encoding: A feature encoding, used to convert featuresets\n        into feature vectors. May optionally implement a cost() method\n        in order to assign different costs to different class predictions.\n\n    :type stream: stream\n    :param stream: The stream to which the megam input file should be\n        written.\n\n    :param bernoulli: If true, then use the 'bernoulli' format.  I.e.,\n        all joint features have binary values, and are listed iff they\n        are true.  Otherwise, list feature values explicitly.  If\n        ``bernoulli=False``, then you must call ``megam`` with the\n        ``-fvals`` option.\n\n    :param explicit: If true, then use the 'explicit' format.  I.e.,\n        list the features that would fire for any of the possible\n        labels, for each token.  If ``explicit=True``, then you must\n        call ``megam`` with the ``-explicit`` option.\n    "
    labels = encoding.labels()
    labelnum = {label: i for (i, label) in enumerate(labels)}
    for (featureset, label) in train_toks:
        if hasattr(encoding, 'cost'):
            stream.write(':'.join((str(encoding.cost(featureset, label, l)) for l in labels)))
        else:
            stream.write('%d' % labelnum[label])
        if not explicit:
            _write_megam_features(encoding.encode(featureset, label), stream, bernoulli)
        else:
            for l in labels:
                stream.write(' #')
                _write_megam_features(encoding.encode(featureset, l), stream, bernoulli)
        stream.write('\n')

def parse_megam_weights(s, features_count, explicit=True):
    if False:
        i = 10
        return i + 15
    '\n    Given the stdout output generated by ``megam`` when training a\n    model, return a ``numpy`` array containing the corresponding weight\n    vector.  This function does not currently handle bias features.\n    '
    if numpy is None:
        raise ValueError('This function requires that numpy be installed')
    assert explicit, 'non-explicit not supported yet'
    lines = s.strip().split('\n')
    weights = numpy.zeros(features_count, 'd')
    for line in lines:
        if line.strip():
            (fid, weight) = line.split()
            weights[int(fid)] = float(weight)
    return weights

def _write_megam_features(vector, stream, bernoulli):
    if False:
        while True:
            i = 10
    if not vector:
        raise ValueError('MEGAM classifier requires the use of an always-on feature.')
    for (fid, fval) in vector:
        if bernoulli:
            if fval == 1:
                stream.write(' %s' % fid)
            elif fval != 0:
                raise ValueError('If bernoulli=True, then allfeatures must be binary.')
        else:
            stream.write(f' {fid} {fval}')

def call_megam(args):
    if False:
        return 10
    '\n    Call the ``megam`` binary with the given arguments.\n    '
    if isinstance(args, str):
        raise TypeError('args should be a list of strings')
    if _megam_bin is None:
        config_megam()
    cmd = [_megam_bin] + args
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    (stdout, stderr) = p.communicate()
    if p.returncode != 0:
        print()
        print(stderr)
        raise OSError('megam command failed!')
    if isinstance(stdout, str):
        return stdout
    else:
        return stdout.decode('utf-8')