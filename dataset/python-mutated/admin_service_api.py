"""
    flyteidl/service/admin.proto

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: version not set
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""
from __future__ import absolute_import
import re
import six
from flyteadmin.api_client import ApiClient

class AdminServiceApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if False:
            return 10
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_execution(self, body, **kwargs):
        if False:
            print('Hello World!')
        'Triggers the creation of a :ref:`ref_flyteidl.admin.Execution`  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.create_execution(body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param AdminExecutionCreateRequest body: (required)\n        :return: AdminExecutionCreateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_execution_with_http_info(body, **kwargs)
        else:
            data = self.create_execution_with_http_info(body, **kwargs)
            return data

    def create_execution_with_http_info(self, body, **kwargs):
        if False:
            return 10
        'Triggers the creation of a :ref:`ref_flyteidl.admin.Execution`  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.create_execution_with_http_info(body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param AdminExecutionCreateRequest body: (required)\n        :return: AdminExecutionCreateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['body']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method create_execution" % key)
            params[key] = val
        del params['kwargs']
        if 'body' not in params or params['body'] is None:
            raise ValueError('Missing the required parameter `body` when calling `create_execution`')
        collection_formats = {}
        path_params = {}
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        if 'body' in params:
            body_params = params['body']
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/executions', 'POST', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminExecutionCreateResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def create_launch_plan(self, body, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        'Create and upload a :ref:`ref_flyteidl.admin.LaunchPlan` definition  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.create_launch_plan(body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param AdminLaunchPlanCreateRequest body: (required)\n        :return: AdminLaunchPlanCreateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_launch_plan_with_http_info(body, **kwargs)
        else:
            data = self.create_launch_plan_with_http_info(body, **kwargs)
            return data

    def create_launch_plan_with_http_info(self, body, **kwargs):
        if False:
            return 10
        'Create and upload a :ref:`ref_flyteidl.admin.LaunchPlan` definition  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.create_launch_plan_with_http_info(body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param AdminLaunchPlanCreateRequest body: (required)\n        :return: AdminLaunchPlanCreateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['body']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method create_launch_plan" % key)
            params[key] = val
        del params['kwargs']
        if 'body' not in params or params['body'] is None:
            raise ValueError('Missing the required parameter `body` when calling `create_launch_plan`')
        collection_formats = {}
        path_params = {}
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        if 'body' in params:
            body_params = params['body']
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/launch_plans', 'POST', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminLaunchPlanCreateResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def create_node_event(self, body, **kwargs):
        if False:
            print('Hello World!')
        'Indicates a :ref:`ref_flyteidl.event.NodeExecutionEvent` has occurred.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.create_node_event(body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param AdminNodeExecutionEventRequest body: (required)\n        :return: AdminNodeExecutionEventResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_node_event_with_http_info(body, **kwargs)
        else:
            data = self.create_node_event_with_http_info(body, **kwargs)
            return data

    def create_node_event_with_http_info(self, body, **kwargs):
        if False:
            i = 10
            return i + 15
        'Indicates a :ref:`ref_flyteidl.event.NodeExecutionEvent` has occurred.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.create_node_event_with_http_info(body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param AdminNodeExecutionEventRequest body: (required)\n        :return: AdminNodeExecutionEventResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['body']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method create_node_event" % key)
            params[key] = val
        del params['kwargs']
        if 'body' not in params or params['body'] is None:
            raise ValueError('Missing the required parameter `body` when calling `create_node_event`')
        collection_formats = {}
        path_params = {}
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        if 'body' in params:
            body_params = params['body']
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/events/nodes', 'POST', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminNodeExecutionEventResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def create_task(self, body, **kwargs):
        if False:
            return 10
        'Create and upload a :ref:`ref_flyteidl.admin.Task` definition  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.create_task(body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param FlyteidladminTaskCreateRequest body: (required)\n        :return: FlyteidladminTaskCreateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_task_with_http_info(body, **kwargs)
        else:
            data = self.create_task_with_http_info(body, **kwargs)
            return data

    def create_task_with_http_info(self, body, **kwargs):
        if False:
            while True:
                i = 10
        'Create and upload a :ref:`ref_flyteidl.admin.Task` definition  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.create_task_with_http_info(body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param FlyteidladminTaskCreateRequest body: (required)\n        :return: FlyteidladminTaskCreateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['body']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method create_task" % key)
            params[key] = val
        del params['kwargs']
        if 'body' not in params or params['body'] is None:
            raise ValueError('Missing the required parameter `body` when calling `create_task`')
        collection_formats = {}
        path_params = {}
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        if 'body' in params:
            body_params = params['body']
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/tasks', 'POST', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='FlyteidladminTaskCreateResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def create_task_event(self, body, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        'Indicates a :ref:`ref_flyteidl.event.TaskExecutionEvent` has occurred.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.create_task_event(body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param AdminTaskExecutionEventRequest body: (required)\n        :return: AdminTaskExecutionEventResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_task_event_with_http_info(body, **kwargs)
        else:
            data = self.create_task_event_with_http_info(body, **kwargs)
            return data

    def create_task_event_with_http_info(self, body, **kwargs):
        if False:
            i = 10
            return i + 15
        'Indicates a :ref:`ref_flyteidl.event.TaskExecutionEvent` has occurred.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.create_task_event_with_http_info(body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param AdminTaskExecutionEventRequest body: (required)\n        :return: AdminTaskExecutionEventResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['body']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method create_task_event" % key)
            params[key] = val
        del params['kwargs']
        if 'body' not in params or params['body'] is None:
            raise ValueError('Missing the required parameter `body` when calling `create_task_event`')
        collection_formats = {}
        path_params = {}
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        if 'body' in params:
            body_params = params['body']
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/events/tasks', 'POST', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminTaskExecutionEventResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def create_workflow(self, body, **kwargs):
        if False:
            return 10
        'Create and upload a :ref:`ref_flyteidl.admin.Workflow` definition  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.create_workflow(body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param AdminWorkflowCreateRequest body: (required)\n        :return: AdminWorkflowCreateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_workflow_with_http_info(body, **kwargs)
        else:
            data = self.create_workflow_with_http_info(body, **kwargs)
            return data

    def create_workflow_with_http_info(self, body, **kwargs):
        if False:
            print('Hello World!')
        'Create and upload a :ref:`ref_flyteidl.admin.Workflow` definition  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.create_workflow_with_http_info(body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param AdminWorkflowCreateRequest body: (required)\n        :return: AdminWorkflowCreateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['body']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method create_workflow" % key)
            params[key] = val
        del params['kwargs']
        if 'body' not in params or params['body'] is None:
            raise ValueError('Missing the required parameter `body` when calling `create_workflow`')
        collection_formats = {}
        path_params = {}
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        if 'body' in params:
            body_params = params['body']
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/workflows', 'POST', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminWorkflowCreateResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def create_workflow_event(self, body, **kwargs):
        if False:
            print('Hello World!')
        'Indicates a :ref:`ref_flyteidl.event.WorkflowExecutionEvent` has occurred.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.create_workflow_event(body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param AdminWorkflowExecutionEventRequest body: (required)\n        :return: AdminWorkflowExecutionEventResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_workflow_event_with_http_info(body, **kwargs)
        else:
            data = self.create_workflow_event_with_http_info(body, **kwargs)
            return data

    def create_workflow_event_with_http_info(self, body, **kwargs):
        if False:
            print('Hello World!')
        'Indicates a :ref:`ref_flyteidl.event.WorkflowExecutionEvent` has occurred.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.create_workflow_event_with_http_info(body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param AdminWorkflowExecutionEventRequest body: (required)\n        :return: AdminWorkflowExecutionEventResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['body']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method create_workflow_event" % key)
            params[key] = val
        del params['kwargs']
        if 'body' not in params or params['body'] is None:
            raise ValueError('Missing the required parameter `body` when calling `create_workflow_event`')
        collection_formats = {}
        path_params = {}
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        if 'body' in params:
            body_params = params['body']
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/events/workflows', 'POST', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminWorkflowExecutionEventResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def delete_project_attributes(self, project, body, **kwargs):
        if False:
            return 10
        'Deletes custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.delete_project_attributes(project, body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str project: Unique project id which this set of attributes references. +required (required)\n        :param AdminProjectAttributesDeleteRequest body: (required)\n        :return: AdminProjectAttributesDeleteResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_project_attributes_with_http_info(project, body, **kwargs)
        else:
            data = self.delete_project_attributes_with_http_info(project, body, **kwargs)
            return data

    def delete_project_attributes_with_http_info(self, project, body, **kwargs):
        if False:
            print('Hello World!')
        'Deletes custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.delete_project_attributes_with_http_info(project, body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str project: Unique project id which this set of attributes references. +required (required)\n        :param AdminProjectAttributesDeleteRequest body: (required)\n        :return: AdminProjectAttributesDeleteResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['project', 'body']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method delete_project_attributes" % key)
            params[key] = val
        del params['kwargs']
        if 'project' not in params or params['project'] is None:
            raise ValueError('Missing the required parameter `project` when calling `delete_project_attributes`')
        if 'body' not in params or params['body'] is None:
            raise ValueError('Missing the required parameter `body` when calling `delete_project_attributes`')
        collection_formats = {}
        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        if 'body' in params:
            body_params = params['body']
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/project_attributes/{project}', 'DELETE', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminProjectAttributesDeleteResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def delete_project_domain_attributes(self, project, domain, body, **kwargs):
        if False:
            i = 10
            return i + 15
        'Deletes custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.delete_project_domain_attributes(project, domain, body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str project: Unique project id which this set of attributes references. +required (required)\n        :param str domain: Unique domain id which this set of attributes references. +required (required)\n        :param AdminProjectDomainAttributesDeleteRequest body: (required)\n        :return: AdminProjectDomainAttributesDeleteResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_project_domain_attributes_with_http_info(project, domain, body, **kwargs)
        else:
            data = self.delete_project_domain_attributes_with_http_info(project, domain, body, **kwargs)
            return data

    def delete_project_domain_attributes_with_http_info(self, project, domain, body, **kwargs):
        if False:
            i = 10
            return i + 15
        'Deletes custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.delete_project_domain_attributes_with_http_info(project, domain, body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str project: Unique project id which this set of attributes references. +required (required)\n        :param str domain: Unique domain id which this set of attributes references. +required (required)\n        :param AdminProjectDomainAttributesDeleteRequest body: (required)\n        :return: AdminProjectDomainAttributesDeleteResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['project', 'domain', 'body']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method delete_project_domain_attributes" % key)
            params[key] = val
        del params['kwargs']
        if 'project' not in params or params['project'] is None:
            raise ValueError('Missing the required parameter `project` when calling `delete_project_domain_attributes`')
        if 'domain' not in params or params['domain'] is None:
            raise ValueError('Missing the required parameter `domain` when calling `delete_project_domain_attributes`')
        if 'body' not in params or params['body'] is None:
            raise ValueError('Missing the required parameter `body` when calling `delete_project_domain_attributes`')
        collection_formats = {}
        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'domain' in params:
            path_params['domain'] = params['domain']
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        if 'body' in params:
            body_params = params['body']
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/project_domain_attributes/{project}/{domain}', 'DELETE', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminProjectDomainAttributesDeleteResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def delete_workflow_attributes(self, project, domain, workflow, body, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        'Deletes custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.delete_workflow_attributes(project, domain, workflow, body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str project: Unique project id which this set of attributes references. +required (required)\n        :param str domain: Unique domain id which this set of attributes references. +required (required)\n        :param str workflow: Workflow name which this set of attributes references. +required (required)\n        :param AdminWorkflowAttributesDeleteRequest body: (required)\n        :return: AdminWorkflowAttributesDeleteResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_workflow_attributes_with_http_info(project, domain, workflow, body, **kwargs)
        else:
            data = self.delete_workflow_attributes_with_http_info(project, domain, workflow, body, **kwargs)
            return data

    def delete_workflow_attributes_with_http_info(self, project, domain, workflow, body, **kwargs):
        if False:
            i = 10
            return i + 15
        'Deletes custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.delete_workflow_attributes_with_http_info(project, domain, workflow, body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str project: Unique project id which this set of attributes references. +required (required)\n        :param str domain: Unique domain id which this set of attributes references. +required (required)\n        :param str workflow: Workflow name which this set of attributes references. +required (required)\n        :param AdminWorkflowAttributesDeleteRequest body: (required)\n        :return: AdminWorkflowAttributesDeleteResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['project', 'domain', 'workflow', 'body']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method delete_workflow_attributes" % key)
            params[key] = val
        del params['kwargs']
        if 'project' not in params or params['project'] is None:
            raise ValueError('Missing the required parameter `project` when calling `delete_workflow_attributes`')
        if 'domain' not in params or params['domain'] is None:
            raise ValueError('Missing the required parameter `domain` when calling `delete_workflow_attributes`')
        if 'workflow' not in params or params['workflow'] is None:
            raise ValueError('Missing the required parameter `workflow` when calling `delete_workflow_attributes`')
        if 'body' not in params or params['body'] is None:
            raise ValueError('Missing the required parameter `body` when calling `delete_workflow_attributes`')
        collection_formats = {}
        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'domain' in params:
            path_params['domain'] = params['domain']
        if 'workflow' in params:
            path_params['workflow'] = params['workflow']
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        if 'body' in params:
            body_params = params['body']
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/workflow_attributes/{project}/{domain}/{workflow}', 'DELETE', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminWorkflowAttributesDeleteResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def get_active_launch_plan(self, id_project, id_domain, id_name, **kwargs):
        if False:
            while True:
                i = 10
        "Fetch the active version of a :ref:`ref_flyteidl.admin.LaunchPlan`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_active_launch_plan(id_project, id_domain, id_name, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like 'List API', 'Launch plans' (required)\n        :return: AdminLaunchPlan\n                 If the method is called asynchronously,\n                 returns the request thread.\n        "
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_active_launch_plan_with_http_info(id_project, id_domain, id_name, **kwargs)
        else:
            data = self.get_active_launch_plan_with_http_info(id_project, id_domain, id_name, **kwargs)
            return data

    def get_active_launch_plan_with_http_info(self, id_project, id_domain, id_name, **kwargs):
        if False:
            print('Hello World!')
        "Fetch the active version of a :ref:`ref_flyteidl.admin.LaunchPlan`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_active_launch_plan_with_http_info(id_project, id_domain, id_name, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like 'List API', 'Launch plans' (required)\n        :return: AdminLaunchPlan\n                 If the method is called asynchronously,\n                 returns the request thread.\n        "
        all_params = ['id_project', 'id_domain', 'id_name']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method get_active_launch_plan" % key)
            params[key] = val
        del params['kwargs']
        if 'id_project' not in params or params['id_project'] is None:
            raise ValueError('Missing the required parameter `id_project` when calling `get_active_launch_plan`')
        if 'id_domain' not in params or params['id_domain'] is None:
            raise ValueError('Missing the required parameter `id_domain` when calling `get_active_launch_plan`')
        if 'id_name' not in params or params['id_name'] is None:
            raise ValueError('Missing the required parameter `id_name` when calling `get_active_launch_plan`')
        collection_formats = {}
        path_params = {}
        if 'id_project' in params:
            path_params['id.project'] = params['id_project']
        if 'id_domain' in params:
            path_params['id.domain'] = params['id_domain']
        if 'id_name' in params:
            path_params['id.name'] = params['id_name']
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/active_launch_plans/{id.project}/{id.domain}/{id.name}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminLaunchPlan', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def get_description_entity(self, id_resource_type, id_project, id_domain, id_name, id_version, **kwargs):
        if False:
            i = 10
            return i + 15
        'Fetch a :ref:`ref_flyteidl.admin.DescriptionEntity` object.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_description_entity(id_resource_type, id_project, id_domain, id_name, id_version, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_resource_type: Identifies the specific type of resource that this identifier corresponds to. (required)\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. (required)\n        :param str id_version: Specific version of the resource. (required)\n        :return: AdminDescriptionEntity\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_description_entity_with_http_info(id_resource_type, id_project, id_domain, id_name, id_version, **kwargs)
        else:
            data = self.get_description_entity_with_http_info(id_resource_type, id_project, id_domain, id_name, id_version, **kwargs)
            return data

    def get_description_entity_with_http_info(self, id_resource_type, id_project, id_domain, id_name, id_version, **kwargs):
        if False:
            return 10
        'Fetch a :ref:`ref_flyteidl.admin.DescriptionEntity` object.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_description_entity_with_http_info(id_resource_type, id_project, id_domain, id_name, id_version, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_resource_type: Identifies the specific type of resource that this identifier corresponds to. (required)\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. (required)\n        :param str id_version: Specific version of the resource. (required)\n        :return: AdminDescriptionEntity\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['id_resource_type', 'id_project', 'id_domain', 'id_name', 'id_version']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method get_description_entity" % key)
            params[key] = val
        del params['kwargs']
        if 'id_resource_type' not in params or params['id_resource_type'] is None:
            raise ValueError('Missing the required parameter `id_resource_type` when calling `get_description_entity`')
        if 'id_project' not in params or params['id_project'] is None:
            raise ValueError('Missing the required parameter `id_project` when calling `get_description_entity`')
        if 'id_domain' not in params or params['id_domain'] is None:
            raise ValueError('Missing the required parameter `id_domain` when calling `get_description_entity`')
        if 'id_name' not in params or params['id_name'] is None:
            raise ValueError('Missing the required parameter `id_name` when calling `get_description_entity`')
        if 'id_version' not in params or params['id_version'] is None:
            raise ValueError('Missing the required parameter `id_version` when calling `get_description_entity`')
        collection_formats = {}
        path_params = {}
        if 'id_resource_type' in params:
            path_params['id.resource_type'] = params['id_resource_type']
        if 'id_project' in params:
            path_params['id.project'] = params['id_project']
        if 'id_domain' in params:
            path_params['id.domain'] = params['id_domain']
        if 'id_name' in params:
            path_params['id.name'] = params['id_name']
        if 'id_version' in params:
            path_params['id.version'] = params['id_version']
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/description_entities/{id.resource_type}/{id.project}/{id.domain}/{id.name}/{id.version}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminDescriptionEntity', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def get_execution(self, id_project, id_domain, id_name, **kwargs):
        if False:
            print('Hello World!')
        'Fetches a :ref:`ref_flyteidl.admin.Execution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_execution(id_project, id_domain, id_name, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User or system provided value for the resource. (required)\n        :return: AdminExecution\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_execution_with_http_info(id_project, id_domain, id_name, **kwargs)
        else:
            data = self.get_execution_with_http_info(id_project, id_domain, id_name, **kwargs)
            return data

    def get_execution_with_http_info(self, id_project, id_domain, id_name, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        'Fetches a :ref:`ref_flyteidl.admin.Execution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_execution_with_http_info(id_project, id_domain, id_name, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User or system provided value for the resource. (required)\n        :return: AdminExecution\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['id_project', 'id_domain', 'id_name']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method get_execution" % key)
            params[key] = val
        del params['kwargs']
        if 'id_project' not in params or params['id_project'] is None:
            raise ValueError('Missing the required parameter `id_project` when calling `get_execution`')
        if 'id_domain' not in params or params['id_domain'] is None:
            raise ValueError('Missing the required parameter `id_domain` when calling `get_execution`')
        if 'id_name' not in params or params['id_name'] is None:
            raise ValueError('Missing the required parameter `id_name` when calling `get_execution`')
        collection_formats = {}
        path_params = {}
        if 'id_project' in params:
            path_params['id.project'] = params['id_project']
        if 'id_domain' in params:
            path_params['id.domain'] = params['id_domain']
        if 'id_name' in params:
            path_params['id.name'] = params['id_name']
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/executions/{id.project}/{id.domain}/{id.name}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminExecution', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def get_execution_data(self, id_project, id_domain, id_name, **kwargs):
        if False:
            i = 10
            return i + 15
        'Fetches input and output data for a :ref:`ref_flyteidl.admin.Execution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_execution_data(id_project, id_domain, id_name, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User or system provided value for the resource. (required)\n        :return: AdminWorkflowExecutionGetDataResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_execution_data_with_http_info(id_project, id_domain, id_name, **kwargs)
        else:
            data = self.get_execution_data_with_http_info(id_project, id_domain, id_name, **kwargs)
            return data

    def get_execution_data_with_http_info(self, id_project, id_domain, id_name, **kwargs):
        if False:
            while True:
                i = 10
        'Fetches input and output data for a :ref:`ref_flyteidl.admin.Execution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_execution_data_with_http_info(id_project, id_domain, id_name, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User or system provided value for the resource. (required)\n        :return: AdminWorkflowExecutionGetDataResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['id_project', 'id_domain', 'id_name']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method get_execution_data" % key)
            params[key] = val
        del params['kwargs']
        if 'id_project' not in params or params['id_project'] is None:
            raise ValueError('Missing the required parameter `id_project` when calling `get_execution_data`')
        if 'id_domain' not in params or params['id_domain'] is None:
            raise ValueError('Missing the required parameter `id_domain` when calling `get_execution_data`')
        if 'id_name' not in params or params['id_name'] is None:
            raise ValueError('Missing the required parameter `id_name` when calling `get_execution_data`')
        collection_formats = {}
        path_params = {}
        if 'id_project' in params:
            path_params['id.project'] = params['id_project']
        if 'id_domain' in params:
            path_params['id.domain'] = params['id_domain']
        if 'id_name' in params:
            path_params['id.name'] = params['id_name']
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/data/executions/{id.project}/{id.domain}/{id.name}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminWorkflowExecutionGetDataResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def get_execution_metrics(self, id_project, id_domain, id_name, **kwargs):
        if False:
            while True:
                i = 10
        'Fetches runtime metrics for a :ref:`ref_flyteidl.admin.Execution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_execution_metrics(id_project, id_domain, id_name, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User or system provided value for the resource. (required)\n        :param int depth: depth defines the number of Flyte entity levels to traverse when breaking down execution details.\n        :return: AdminWorkflowExecutionGetMetricsResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_execution_metrics_with_http_info(id_project, id_domain, id_name, **kwargs)
        else:
            data = self.get_execution_metrics_with_http_info(id_project, id_domain, id_name, **kwargs)
            return data

    def get_execution_metrics_with_http_info(self, id_project, id_domain, id_name, **kwargs):
        if False:
            while True:
                i = 10
        'Fetches runtime metrics for a :ref:`ref_flyteidl.admin.Execution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_execution_metrics_with_http_info(id_project, id_domain, id_name, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User or system provided value for the resource. (required)\n        :param int depth: depth defines the number of Flyte entity levels to traverse when breaking down execution details.\n        :return: AdminWorkflowExecutionGetMetricsResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['id_project', 'id_domain', 'id_name', 'depth']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method get_execution_metrics" % key)
            params[key] = val
        del params['kwargs']
        if 'id_project' not in params or params['id_project'] is None:
            raise ValueError('Missing the required parameter `id_project` when calling `get_execution_metrics`')
        if 'id_domain' not in params or params['id_domain'] is None:
            raise ValueError('Missing the required parameter `id_domain` when calling `get_execution_metrics`')
        if 'id_name' not in params or params['id_name'] is None:
            raise ValueError('Missing the required parameter `id_name` when calling `get_execution_metrics`')
        collection_formats = {}
        path_params = {}
        if 'id_project' in params:
            path_params['id.project'] = params['id_project']
        if 'id_domain' in params:
            path_params['id.domain'] = params['id_domain']
        if 'id_name' in params:
            path_params['id.name'] = params['id_name']
        query_params = []
        if 'depth' in params:
            query_params.append(('depth', params['depth']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/metrics/executions/{id.project}/{id.domain}/{id.name}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminWorkflowExecutionGetMetricsResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def get_launch_plan(self, id_project, id_domain, id_name, id_version, **kwargs):
        if False:
            while True:
                i = 10
        'Fetch a :ref:`ref_flyteidl.admin.LaunchPlan` definition.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_launch_plan(id_project, id_domain, id_name, id_version, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. (required)\n        :param str id_version: Specific version of the resource. (required)\n        :param str id_resource_type: Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects\n        :return: AdminLaunchPlan\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_launch_plan_with_http_info(id_project, id_domain, id_name, id_version, **kwargs)
        else:
            data = self.get_launch_plan_with_http_info(id_project, id_domain, id_name, id_version, **kwargs)
            return data

    def get_launch_plan_with_http_info(self, id_project, id_domain, id_name, id_version, **kwargs):
        if False:
            return 10
        'Fetch a :ref:`ref_flyteidl.admin.LaunchPlan` definition.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_launch_plan_with_http_info(id_project, id_domain, id_name, id_version, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. (required)\n        :param str id_version: Specific version of the resource. (required)\n        :param str id_resource_type: Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects\n        :return: AdminLaunchPlan\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['id_project', 'id_domain', 'id_name', 'id_version', 'id_resource_type']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method get_launch_plan" % key)
            params[key] = val
        del params['kwargs']
        if 'id_project' not in params or params['id_project'] is None:
            raise ValueError('Missing the required parameter `id_project` when calling `get_launch_plan`')
        if 'id_domain' not in params or params['id_domain'] is None:
            raise ValueError('Missing the required parameter `id_domain` when calling `get_launch_plan`')
        if 'id_name' not in params or params['id_name'] is None:
            raise ValueError('Missing the required parameter `id_name` when calling `get_launch_plan`')
        if 'id_version' not in params or params['id_version'] is None:
            raise ValueError('Missing the required parameter `id_version` when calling `get_launch_plan`')
        collection_formats = {}
        path_params = {}
        if 'id_project' in params:
            path_params['id.project'] = params['id_project']
        if 'id_domain' in params:
            path_params['id.domain'] = params['id_domain']
        if 'id_name' in params:
            path_params['id.name'] = params['id_name']
        if 'id_version' in params:
            path_params['id.version'] = params['id_version']
        query_params = []
        if 'id_resource_type' in params:
            query_params.append(('id.resource_type', params['id_resource_type']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/launch_plans/{id.project}/{id.domain}/{id.name}/{id.version}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminLaunchPlan', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def get_named_entity(self, resource_type, id_project, id_domain, id_name, **kwargs):
        if False:
            i = 10
            return i + 15
        "Returns a :ref:`ref_flyteidl.admin.NamedEntity` object.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_named_entity(resource_type, id_project, id_domain, id_name, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str resource_type: Resource type of the metadata to get. One of Task, Workflow or LaunchPlan. +required (required)\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like 'List API', 'Launch plans' (required)\n        :return: AdminNamedEntity\n                 If the method is called asynchronously,\n                 returns the request thread.\n        "
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_named_entity_with_http_info(resource_type, id_project, id_domain, id_name, **kwargs)
        else:
            data = self.get_named_entity_with_http_info(resource_type, id_project, id_domain, id_name, **kwargs)
            return data

    def get_named_entity_with_http_info(self, resource_type, id_project, id_domain, id_name, **kwargs):
        if False:
            print('Hello World!')
        "Returns a :ref:`ref_flyteidl.admin.NamedEntity` object.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_named_entity_with_http_info(resource_type, id_project, id_domain, id_name, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str resource_type: Resource type of the metadata to get. One of Task, Workflow or LaunchPlan. +required (required)\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like 'List API', 'Launch plans' (required)\n        :return: AdminNamedEntity\n                 If the method is called asynchronously,\n                 returns the request thread.\n        "
        all_params = ['resource_type', 'id_project', 'id_domain', 'id_name']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method get_named_entity" % key)
            params[key] = val
        del params['kwargs']
        if 'resource_type' not in params or params['resource_type'] is None:
            raise ValueError('Missing the required parameter `resource_type` when calling `get_named_entity`')
        if 'id_project' not in params or params['id_project'] is None:
            raise ValueError('Missing the required parameter `id_project` when calling `get_named_entity`')
        if 'id_domain' not in params or params['id_domain'] is None:
            raise ValueError('Missing the required parameter `id_domain` when calling `get_named_entity`')
        if 'id_name' not in params or params['id_name'] is None:
            raise ValueError('Missing the required parameter `id_name` when calling `get_named_entity`')
        collection_formats = {}
        path_params = {}
        if 'resource_type' in params:
            path_params['resource_type'] = params['resource_type']
        if 'id_project' in params:
            path_params['id.project'] = params['id_project']
        if 'id_domain' in params:
            path_params['id.domain'] = params['id_domain']
        if 'id_name' in params:
            path_params['id.name'] = params['id_name']
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/named_entities/{resource_type}/{id.project}/{id.domain}/{id.name}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminNamedEntity', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def get_node_execution(self, id_execution_id_project, id_execution_id_domain, id_execution_id_name, id_node_id, **kwargs):
        if False:
            while True:
                i = 10
        'Fetches a :ref:`ref_flyteidl.admin.NodeExecution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_node_execution(id_execution_id_project, id_execution_id_domain, id_execution_id_name, id_node_id, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_execution_id_project: Name of the project the resource belongs to. (required)\n        :param str id_execution_id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_execution_id_name: User or system provided value for the resource. (required)\n        :param str id_node_id: (required)\n        :return: FlyteidladminNodeExecution\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_node_execution_with_http_info(id_execution_id_project, id_execution_id_domain, id_execution_id_name, id_node_id, **kwargs)
        else:
            data = self.get_node_execution_with_http_info(id_execution_id_project, id_execution_id_domain, id_execution_id_name, id_node_id, **kwargs)
            return data

    def get_node_execution_with_http_info(self, id_execution_id_project, id_execution_id_domain, id_execution_id_name, id_node_id, **kwargs):
        if False:
            while True:
                i = 10
        'Fetches a :ref:`ref_flyteidl.admin.NodeExecution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_node_execution_with_http_info(id_execution_id_project, id_execution_id_domain, id_execution_id_name, id_node_id, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_execution_id_project: Name of the project the resource belongs to. (required)\n        :param str id_execution_id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_execution_id_name: User or system provided value for the resource. (required)\n        :param str id_node_id: (required)\n        :return: FlyteidladminNodeExecution\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['id_execution_id_project', 'id_execution_id_domain', 'id_execution_id_name', 'id_node_id']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method get_node_execution" % key)
            params[key] = val
        del params['kwargs']
        if 'id_execution_id_project' not in params or params['id_execution_id_project'] is None:
            raise ValueError('Missing the required parameter `id_execution_id_project` when calling `get_node_execution`')
        if 'id_execution_id_domain' not in params or params['id_execution_id_domain'] is None:
            raise ValueError('Missing the required parameter `id_execution_id_domain` when calling `get_node_execution`')
        if 'id_execution_id_name' not in params or params['id_execution_id_name'] is None:
            raise ValueError('Missing the required parameter `id_execution_id_name` when calling `get_node_execution`')
        if 'id_node_id' not in params or params['id_node_id'] is None:
            raise ValueError('Missing the required parameter `id_node_id` when calling `get_node_execution`')
        collection_formats = {}
        path_params = {}
        if 'id_execution_id_project' in params:
            path_params['id.execution_id.project'] = params['id_execution_id_project']
        if 'id_execution_id_domain' in params:
            path_params['id.execution_id.domain'] = params['id_execution_id_domain']
        if 'id_execution_id_name' in params:
            path_params['id.execution_id.name'] = params['id_execution_id_name']
        if 'id_node_id' in params:
            path_params['id.node_id'] = params['id_node_id']
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/node_executions/{id.execution_id.project}/{id.execution_id.domain}/{id.execution_id.name}/{id.node_id}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='FlyteidladminNodeExecution', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def get_node_execution_data(self, id_execution_id_project, id_execution_id_domain, id_execution_id_name, id_node_id, **kwargs):
        if False:
            print('Hello World!')
        'Fetches input and output data for a :ref:`ref_flyteidl.admin.NodeExecution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_node_execution_data(id_execution_id_project, id_execution_id_domain, id_execution_id_name, id_node_id, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_execution_id_project: Name of the project the resource belongs to. (required)\n        :param str id_execution_id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_execution_id_name: User or system provided value for the resource. (required)\n        :param str id_node_id: (required)\n        :return: AdminNodeExecutionGetDataResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_node_execution_data_with_http_info(id_execution_id_project, id_execution_id_domain, id_execution_id_name, id_node_id, **kwargs)
        else:
            data = self.get_node_execution_data_with_http_info(id_execution_id_project, id_execution_id_domain, id_execution_id_name, id_node_id, **kwargs)
            return data

    def get_node_execution_data_with_http_info(self, id_execution_id_project, id_execution_id_domain, id_execution_id_name, id_node_id, **kwargs):
        if False:
            i = 10
            return i + 15
        'Fetches input and output data for a :ref:`ref_flyteidl.admin.NodeExecution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_node_execution_data_with_http_info(id_execution_id_project, id_execution_id_domain, id_execution_id_name, id_node_id, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_execution_id_project: Name of the project the resource belongs to. (required)\n        :param str id_execution_id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_execution_id_name: User or system provided value for the resource. (required)\n        :param str id_node_id: (required)\n        :return: AdminNodeExecutionGetDataResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['id_execution_id_project', 'id_execution_id_domain', 'id_execution_id_name', 'id_node_id']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method get_node_execution_data" % key)
            params[key] = val
        del params['kwargs']
        if 'id_execution_id_project' not in params or params['id_execution_id_project'] is None:
            raise ValueError('Missing the required parameter `id_execution_id_project` when calling `get_node_execution_data`')
        if 'id_execution_id_domain' not in params or params['id_execution_id_domain'] is None:
            raise ValueError('Missing the required parameter `id_execution_id_domain` when calling `get_node_execution_data`')
        if 'id_execution_id_name' not in params or params['id_execution_id_name'] is None:
            raise ValueError('Missing the required parameter `id_execution_id_name` when calling `get_node_execution_data`')
        if 'id_node_id' not in params or params['id_node_id'] is None:
            raise ValueError('Missing the required parameter `id_node_id` when calling `get_node_execution_data`')
        collection_formats = {}
        path_params = {}
        if 'id_execution_id_project' in params:
            path_params['id.execution_id.project'] = params['id_execution_id_project']
        if 'id_execution_id_domain' in params:
            path_params['id.execution_id.domain'] = params['id_execution_id_domain']
        if 'id_execution_id_name' in params:
            path_params['id.execution_id.name'] = params['id_execution_id_name']
        if 'id_node_id' in params:
            path_params['id.node_id'] = params['id_node_id']
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/data/node_executions/{id.execution_id.project}/{id.execution_id.domain}/{id.execution_id.name}/{id.node_id}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminNodeExecutionGetDataResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def get_project_attributes(self, project, **kwargs):
        if False:
            i = 10
            return i + 15
        'Fetches custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_project_attributes(project, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str project: Unique project id which this set of attributes references. +required (required)\n        :param str resource_type: Which type of matchable attributes to return. +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.\n        :return: AdminProjectAttributesGetResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_project_attributes_with_http_info(project, **kwargs)
        else:
            data = self.get_project_attributes_with_http_info(project, **kwargs)
            return data

    def get_project_attributes_with_http_info(self, project, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        'Fetches custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_project_attributes_with_http_info(project, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str project: Unique project id which this set of attributes references. +required (required)\n        :param str resource_type: Which type of matchable attributes to return. +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.\n        :return: AdminProjectAttributesGetResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['project', 'resource_type']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method get_project_attributes" % key)
            params[key] = val
        del params['kwargs']
        if 'project' not in params or params['project'] is None:
            raise ValueError('Missing the required parameter `project` when calling `get_project_attributes`')
        collection_formats = {}
        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        query_params = []
        if 'resource_type' in params:
            query_params.append(('resource_type', params['resource_type']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/project_attributes/{project}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminProjectAttributesGetResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def get_project_domain_attributes(self, project, domain, **kwargs):
        if False:
            while True:
                i = 10
        'Fetches custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_project_domain_attributes(project, domain, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str project: Unique project id which this set of attributes references. +required (required)\n        :param str domain: Unique domain id which this set of attributes references. +required (required)\n        :param str resource_type: Which type of matchable attributes to return. +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.\n        :return: AdminProjectDomainAttributesGetResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_project_domain_attributes_with_http_info(project, domain, **kwargs)
        else:
            data = self.get_project_domain_attributes_with_http_info(project, domain, **kwargs)
            return data

    def get_project_domain_attributes_with_http_info(self, project, domain, **kwargs):
        if False:
            return 10
        'Fetches custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_project_domain_attributes_with_http_info(project, domain, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str project: Unique project id which this set of attributes references. +required (required)\n        :param str domain: Unique domain id which this set of attributes references. +required (required)\n        :param str resource_type: Which type of matchable attributes to return. +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.\n        :return: AdminProjectDomainAttributesGetResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['project', 'domain', 'resource_type']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method get_project_domain_attributes" % key)
            params[key] = val
        del params['kwargs']
        if 'project' not in params or params['project'] is None:
            raise ValueError('Missing the required parameter `project` when calling `get_project_domain_attributes`')
        if 'domain' not in params or params['domain'] is None:
            raise ValueError('Missing the required parameter `domain` when calling `get_project_domain_attributes`')
        collection_formats = {}
        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'domain' in params:
            path_params['domain'] = params['domain']
        query_params = []
        if 'resource_type' in params:
            query_params.append(('resource_type', params['resource_type']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/project_domain_attributes/{project}/{domain}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminProjectDomainAttributesGetResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def get_task(self, id_project, id_domain, id_name, id_version, **kwargs):
        if False:
            while True:
                i = 10
        'Fetch a :ref:`ref_flyteidl.admin.Task` definition.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_task(id_project, id_domain, id_name, id_version, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. (required)\n        :param str id_version: Specific version of the resource. (required)\n        :param str id_resource_type: Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects\n        :return: AdminTask\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_task_with_http_info(id_project, id_domain, id_name, id_version, **kwargs)
        else:
            data = self.get_task_with_http_info(id_project, id_domain, id_name, id_version, **kwargs)
            return data

    def get_task_with_http_info(self, id_project, id_domain, id_name, id_version, **kwargs):
        if False:
            i = 10
            return i + 15
        'Fetch a :ref:`ref_flyteidl.admin.Task` definition.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_task_with_http_info(id_project, id_domain, id_name, id_version, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. (required)\n        :param str id_version: Specific version of the resource. (required)\n        :param str id_resource_type: Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects\n        :return: AdminTask\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['id_project', 'id_domain', 'id_name', 'id_version', 'id_resource_type']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method get_task" % key)
            params[key] = val
        del params['kwargs']
        if 'id_project' not in params or params['id_project'] is None:
            raise ValueError('Missing the required parameter `id_project` when calling `get_task`')
        if 'id_domain' not in params or params['id_domain'] is None:
            raise ValueError('Missing the required parameter `id_domain` when calling `get_task`')
        if 'id_name' not in params or params['id_name'] is None:
            raise ValueError('Missing the required parameter `id_name` when calling `get_task`')
        if 'id_version' not in params or params['id_version'] is None:
            raise ValueError('Missing the required parameter `id_version` when calling `get_task`')
        collection_formats = {}
        path_params = {}
        if 'id_project' in params:
            path_params['id.project'] = params['id_project']
        if 'id_domain' in params:
            path_params['id.domain'] = params['id_domain']
        if 'id_name' in params:
            path_params['id.name'] = params['id_name']
        if 'id_version' in params:
            path_params['id.version'] = params['id_version']
        query_params = []
        if 'id_resource_type' in params:
            query_params.append(('id.resource_type', params['id_resource_type']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/tasks/{id.project}/{id.domain}/{id.name}/{id.version}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminTask', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def get_task_execution(self, id_node_execution_id_execution_id_project, id_node_execution_id_execution_id_domain, id_node_execution_id_execution_id_name, id_node_execution_id_node_id, id_task_id_project, id_task_id_domain, id_task_id_name, id_task_id_version, id_retry_attempt, **kwargs):
        if False:
            return 10
        'Fetches a :ref:`ref_flyteidl.admin.TaskExecution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_task_execution(id_node_execution_id_execution_id_project, id_node_execution_id_execution_id_domain, id_node_execution_id_execution_id_name, id_node_execution_id_node_id, id_task_id_project, id_task_id_domain, id_task_id_name, id_task_id_version, id_retry_attempt, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_node_execution_id_execution_id_project: Name of the project the resource belongs to. (required)\n        :param str id_node_execution_id_execution_id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_node_execution_id_execution_id_name: User or system provided value for the resource. (required)\n        :param str id_node_execution_id_node_id: (required)\n        :param str id_task_id_project: Name of the project the resource belongs to. (required)\n        :param str id_task_id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_task_id_name: User provided value for the resource. (required)\n        :param str id_task_id_version: Specific version of the resource. (required)\n        :param int id_retry_attempt: (required)\n        :param str id_task_id_resource_type: Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects\n        :return: FlyteidladminTaskExecution\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_task_execution_with_http_info(id_node_execution_id_execution_id_project, id_node_execution_id_execution_id_domain, id_node_execution_id_execution_id_name, id_node_execution_id_node_id, id_task_id_project, id_task_id_domain, id_task_id_name, id_task_id_version, id_retry_attempt, **kwargs)
        else:
            data = self.get_task_execution_with_http_info(id_node_execution_id_execution_id_project, id_node_execution_id_execution_id_domain, id_node_execution_id_execution_id_name, id_node_execution_id_node_id, id_task_id_project, id_task_id_domain, id_task_id_name, id_task_id_version, id_retry_attempt, **kwargs)
            return data

    def get_task_execution_with_http_info(self, id_node_execution_id_execution_id_project, id_node_execution_id_execution_id_domain, id_node_execution_id_execution_id_name, id_node_execution_id_node_id, id_task_id_project, id_task_id_domain, id_task_id_name, id_task_id_version, id_retry_attempt, **kwargs):
        if False:
            while True:
                i = 10
        'Fetches a :ref:`ref_flyteidl.admin.TaskExecution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_task_execution_with_http_info(id_node_execution_id_execution_id_project, id_node_execution_id_execution_id_domain, id_node_execution_id_execution_id_name, id_node_execution_id_node_id, id_task_id_project, id_task_id_domain, id_task_id_name, id_task_id_version, id_retry_attempt, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_node_execution_id_execution_id_project: Name of the project the resource belongs to. (required)\n        :param str id_node_execution_id_execution_id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_node_execution_id_execution_id_name: User or system provided value for the resource. (required)\n        :param str id_node_execution_id_node_id: (required)\n        :param str id_task_id_project: Name of the project the resource belongs to. (required)\n        :param str id_task_id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_task_id_name: User provided value for the resource. (required)\n        :param str id_task_id_version: Specific version of the resource. (required)\n        :param int id_retry_attempt: (required)\n        :param str id_task_id_resource_type: Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects\n        :return: FlyteidladminTaskExecution\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['id_node_execution_id_execution_id_project', 'id_node_execution_id_execution_id_domain', 'id_node_execution_id_execution_id_name', 'id_node_execution_id_node_id', 'id_task_id_project', 'id_task_id_domain', 'id_task_id_name', 'id_task_id_version', 'id_retry_attempt', 'id_task_id_resource_type']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method get_task_execution" % key)
            params[key] = val
        del params['kwargs']
        if 'id_node_execution_id_execution_id_project' not in params or params['id_node_execution_id_execution_id_project'] is None:
            raise ValueError('Missing the required parameter `id_node_execution_id_execution_id_project` when calling `get_task_execution`')
        if 'id_node_execution_id_execution_id_domain' not in params or params['id_node_execution_id_execution_id_domain'] is None:
            raise ValueError('Missing the required parameter `id_node_execution_id_execution_id_domain` when calling `get_task_execution`')
        if 'id_node_execution_id_execution_id_name' not in params or params['id_node_execution_id_execution_id_name'] is None:
            raise ValueError('Missing the required parameter `id_node_execution_id_execution_id_name` when calling `get_task_execution`')
        if 'id_node_execution_id_node_id' not in params or params['id_node_execution_id_node_id'] is None:
            raise ValueError('Missing the required parameter `id_node_execution_id_node_id` when calling `get_task_execution`')
        if 'id_task_id_project' not in params or params['id_task_id_project'] is None:
            raise ValueError('Missing the required parameter `id_task_id_project` when calling `get_task_execution`')
        if 'id_task_id_domain' not in params or params['id_task_id_domain'] is None:
            raise ValueError('Missing the required parameter `id_task_id_domain` when calling `get_task_execution`')
        if 'id_task_id_name' not in params or params['id_task_id_name'] is None:
            raise ValueError('Missing the required parameter `id_task_id_name` when calling `get_task_execution`')
        if 'id_task_id_version' not in params or params['id_task_id_version'] is None:
            raise ValueError('Missing the required parameter `id_task_id_version` when calling `get_task_execution`')
        if 'id_retry_attempt' not in params or params['id_retry_attempt'] is None:
            raise ValueError('Missing the required parameter `id_retry_attempt` when calling `get_task_execution`')
        collection_formats = {}
        path_params = {}
        if 'id_node_execution_id_execution_id_project' in params:
            path_params['id.node_execution_id.execution_id.project'] = params['id_node_execution_id_execution_id_project']
        if 'id_node_execution_id_execution_id_domain' in params:
            path_params['id.node_execution_id.execution_id.domain'] = params['id_node_execution_id_execution_id_domain']
        if 'id_node_execution_id_execution_id_name' in params:
            path_params['id.node_execution_id.execution_id.name'] = params['id_node_execution_id_execution_id_name']
        if 'id_node_execution_id_node_id' in params:
            path_params['id.node_execution_id.node_id'] = params['id_node_execution_id_node_id']
        if 'id_task_id_project' in params:
            path_params['id.task_id.project'] = params['id_task_id_project']
        if 'id_task_id_domain' in params:
            path_params['id.task_id.domain'] = params['id_task_id_domain']
        if 'id_task_id_name' in params:
            path_params['id.task_id.name'] = params['id_task_id_name']
        if 'id_task_id_version' in params:
            path_params['id.task_id.version'] = params['id_task_id_version']
        if 'id_retry_attempt' in params:
            path_params['id.retry_attempt'] = params['id_retry_attempt']
        query_params = []
        if 'id_task_id_resource_type' in params:
            query_params.append(('id.task_id.resource_type', params['id_task_id_resource_type']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/task_executions/{id.node_execution_id.execution_id.project}/{id.node_execution_id.execution_id.domain}/{id.node_execution_id.execution_id.name}/{id.node_execution_id.node_id}/{id.task_id.project}/{id.task_id.domain}/{id.task_id.name}/{id.task_id.version}/{id.retry_attempt}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='FlyteidladminTaskExecution', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def get_task_execution_data(self, id_node_execution_id_execution_id_project, id_node_execution_id_execution_id_domain, id_node_execution_id_execution_id_name, id_node_execution_id_node_id, id_task_id_project, id_task_id_domain, id_task_id_name, id_task_id_version, id_retry_attempt, **kwargs):
        if False:
            print('Hello World!')
        'Fetches input and output data for a :ref:`ref_flyteidl.admin.TaskExecution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_task_execution_data(id_node_execution_id_execution_id_project, id_node_execution_id_execution_id_domain, id_node_execution_id_execution_id_name, id_node_execution_id_node_id, id_task_id_project, id_task_id_domain, id_task_id_name, id_task_id_version, id_retry_attempt, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_node_execution_id_execution_id_project: Name of the project the resource belongs to. (required)\n        :param str id_node_execution_id_execution_id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_node_execution_id_execution_id_name: User or system provided value for the resource. (required)\n        :param str id_node_execution_id_node_id: (required)\n        :param str id_task_id_project: Name of the project the resource belongs to. (required)\n        :param str id_task_id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_task_id_name: User provided value for the resource. (required)\n        :param str id_task_id_version: Specific version of the resource. (required)\n        :param int id_retry_attempt: (required)\n        :param str id_task_id_resource_type: Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects\n        :return: AdminTaskExecutionGetDataResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_task_execution_data_with_http_info(id_node_execution_id_execution_id_project, id_node_execution_id_execution_id_domain, id_node_execution_id_execution_id_name, id_node_execution_id_node_id, id_task_id_project, id_task_id_domain, id_task_id_name, id_task_id_version, id_retry_attempt, **kwargs)
        else:
            data = self.get_task_execution_data_with_http_info(id_node_execution_id_execution_id_project, id_node_execution_id_execution_id_domain, id_node_execution_id_execution_id_name, id_node_execution_id_node_id, id_task_id_project, id_task_id_domain, id_task_id_name, id_task_id_version, id_retry_attempt, **kwargs)
            return data

    def get_task_execution_data_with_http_info(self, id_node_execution_id_execution_id_project, id_node_execution_id_execution_id_domain, id_node_execution_id_execution_id_name, id_node_execution_id_node_id, id_task_id_project, id_task_id_domain, id_task_id_name, id_task_id_version, id_retry_attempt, **kwargs):
        if False:
            while True:
                i = 10
        'Fetches input and output data for a :ref:`ref_flyteidl.admin.TaskExecution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_task_execution_data_with_http_info(id_node_execution_id_execution_id_project, id_node_execution_id_execution_id_domain, id_node_execution_id_execution_id_name, id_node_execution_id_node_id, id_task_id_project, id_task_id_domain, id_task_id_name, id_task_id_version, id_retry_attempt, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_node_execution_id_execution_id_project: Name of the project the resource belongs to. (required)\n        :param str id_node_execution_id_execution_id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_node_execution_id_execution_id_name: User or system provided value for the resource. (required)\n        :param str id_node_execution_id_node_id: (required)\n        :param str id_task_id_project: Name of the project the resource belongs to. (required)\n        :param str id_task_id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_task_id_name: User provided value for the resource. (required)\n        :param str id_task_id_version: Specific version of the resource. (required)\n        :param int id_retry_attempt: (required)\n        :param str id_task_id_resource_type: Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects\n        :return: AdminTaskExecutionGetDataResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['id_node_execution_id_execution_id_project', 'id_node_execution_id_execution_id_domain', 'id_node_execution_id_execution_id_name', 'id_node_execution_id_node_id', 'id_task_id_project', 'id_task_id_domain', 'id_task_id_name', 'id_task_id_version', 'id_retry_attempt', 'id_task_id_resource_type']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method get_task_execution_data" % key)
            params[key] = val
        del params['kwargs']
        if 'id_node_execution_id_execution_id_project' not in params or params['id_node_execution_id_execution_id_project'] is None:
            raise ValueError('Missing the required parameter `id_node_execution_id_execution_id_project` when calling `get_task_execution_data`')
        if 'id_node_execution_id_execution_id_domain' not in params or params['id_node_execution_id_execution_id_domain'] is None:
            raise ValueError('Missing the required parameter `id_node_execution_id_execution_id_domain` when calling `get_task_execution_data`')
        if 'id_node_execution_id_execution_id_name' not in params or params['id_node_execution_id_execution_id_name'] is None:
            raise ValueError('Missing the required parameter `id_node_execution_id_execution_id_name` when calling `get_task_execution_data`')
        if 'id_node_execution_id_node_id' not in params or params['id_node_execution_id_node_id'] is None:
            raise ValueError('Missing the required parameter `id_node_execution_id_node_id` when calling `get_task_execution_data`')
        if 'id_task_id_project' not in params or params['id_task_id_project'] is None:
            raise ValueError('Missing the required parameter `id_task_id_project` when calling `get_task_execution_data`')
        if 'id_task_id_domain' not in params or params['id_task_id_domain'] is None:
            raise ValueError('Missing the required parameter `id_task_id_domain` when calling `get_task_execution_data`')
        if 'id_task_id_name' not in params or params['id_task_id_name'] is None:
            raise ValueError('Missing the required parameter `id_task_id_name` when calling `get_task_execution_data`')
        if 'id_task_id_version' not in params or params['id_task_id_version'] is None:
            raise ValueError('Missing the required parameter `id_task_id_version` when calling `get_task_execution_data`')
        if 'id_retry_attempt' not in params or params['id_retry_attempt'] is None:
            raise ValueError('Missing the required parameter `id_retry_attempt` when calling `get_task_execution_data`')
        collection_formats = {}
        path_params = {}
        if 'id_node_execution_id_execution_id_project' in params:
            path_params['id.node_execution_id.execution_id.project'] = params['id_node_execution_id_execution_id_project']
        if 'id_node_execution_id_execution_id_domain' in params:
            path_params['id.node_execution_id.execution_id.domain'] = params['id_node_execution_id_execution_id_domain']
        if 'id_node_execution_id_execution_id_name' in params:
            path_params['id.node_execution_id.execution_id.name'] = params['id_node_execution_id_execution_id_name']
        if 'id_node_execution_id_node_id' in params:
            path_params['id.node_execution_id.node_id'] = params['id_node_execution_id_node_id']
        if 'id_task_id_project' in params:
            path_params['id.task_id.project'] = params['id_task_id_project']
        if 'id_task_id_domain' in params:
            path_params['id.task_id.domain'] = params['id_task_id_domain']
        if 'id_task_id_name' in params:
            path_params['id.task_id.name'] = params['id_task_id_name']
        if 'id_task_id_version' in params:
            path_params['id.task_id.version'] = params['id_task_id_version']
        if 'id_retry_attempt' in params:
            path_params['id.retry_attempt'] = params['id_retry_attempt']
        query_params = []
        if 'id_task_id_resource_type' in params:
            query_params.append(('id.task_id.resource_type', params['id_task_id_resource_type']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/data/task_executions/{id.node_execution_id.execution_id.project}/{id.node_execution_id.execution_id.domain}/{id.node_execution_id.execution_id.name}/{id.node_execution_id.node_id}/{id.task_id.project}/{id.task_id.domain}/{id.task_id.name}/{id.task_id.version}/{id.retry_attempt}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminTaskExecutionGetDataResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def get_version(self, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        'get_version  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_version(async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :return: AdminGetVersionResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_version_with_http_info(**kwargs)
        else:
            data = self.get_version_with_http_info(**kwargs)
            return data

    def get_version_with_http_info(self, **kwargs):
        if False:
            print('Hello World!')
        'get_version  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_version_with_http_info(async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :return: AdminGetVersionResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = []
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method get_version" % key)
            params[key] = val
        del params['kwargs']
        collection_formats = {}
        path_params = {}
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/version', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminGetVersionResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def get_workflow(self, id_project, id_domain, id_name, id_version, **kwargs):
        if False:
            return 10
        'Fetch a :ref:`ref_flyteidl.admin.Workflow` definition.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_workflow(id_project, id_domain, id_name, id_version, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. (required)\n        :param str id_version: Specific version of the resource. (required)\n        :param str id_resource_type: Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects\n        :return: AdminWorkflow\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_workflow_with_http_info(id_project, id_domain, id_name, id_version, **kwargs)
        else:
            data = self.get_workflow_with_http_info(id_project, id_domain, id_name, id_version, **kwargs)
            return data

    def get_workflow_with_http_info(self, id_project, id_domain, id_name, id_version, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        'Fetch a :ref:`ref_flyteidl.admin.Workflow` definition.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_workflow_with_http_info(id_project, id_domain, id_name, id_version, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. (required)\n        :param str id_version: Specific version of the resource. (required)\n        :param str id_resource_type: Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects\n        :return: AdminWorkflow\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['id_project', 'id_domain', 'id_name', 'id_version', 'id_resource_type']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method get_workflow" % key)
            params[key] = val
        del params['kwargs']
        if 'id_project' not in params or params['id_project'] is None:
            raise ValueError('Missing the required parameter `id_project` when calling `get_workflow`')
        if 'id_domain' not in params or params['id_domain'] is None:
            raise ValueError('Missing the required parameter `id_domain` when calling `get_workflow`')
        if 'id_name' not in params or params['id_name'] is None:
            raise ValueError('Missing the required parameter `id_name` when calling `get_workflow`')
        if 'id_version' not in params or params['id_version'] is None:
            raise ValueError('Missing the required parameter `id_version` when calling `get_workflow`')
        collection_formats = {}
        path_params = {}
        if 'id_project' in params:
            path_params['id.project'] = params['id_project']
        if 'id_domain' in params:
            path_params['id.domain'] = params['id_domain']
        if 'id_name' in params:
            path_params['id.name'] = params['id_name']
        if 'id_version' in params:
            path_params['id.version'] = params['id_version']
        query_params = []
        if 'id_resource_type' in params:
            query_params.append(('id.resource_type', params['id_resource_type']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/workflows/{id.project}/{id.domain}/{id.name}/{id.version}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminWorkflow', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def get_workflow_attributes(self, project, domain, workflow, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        'Fetches custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_workflow_attributes(project, domain, workflow, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str project: Unique project id which this set of attributes references. +required (required)\n        :param str domain: Unique domain id which this set of attributes references. +required (required)\n        :param str workflow: Workflow name which this set of attributes references. +required (required)\n        :param str resource_type: Which type of matchable attributes to return. +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.\n        :return: AdminWorkflowAttributesGetResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_workflow_attributes_with_http_info(project, domain, workflow, **kwargs)
        else:
            data = self.get_workflow_attributes_with_http_info(project, domain, workflow, **kwargs)
            return data

    def get_workflow_attributes_with_http_info(self, project, domain, workflow, **kwargs):
        if False:
            print('Hello World!')
        'Fetches custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_workflow_attributes_with_http_info(project, domain, workflow, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str project: Unique project id which this set of attributes references. +required (required)\n        :param str domain: Unique domain id which this set of attributes references. +required (required)\n        :param str workflow: Workflow name which this set of attributes references. +required (required)\n        :param str resource_type: Which type of matchable attributes to return. +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.\n        :return: AdminWorkflowAttributesGetResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['project', 'domain', 'workflow', 'resource_type']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method get_workflow_attributes" % key)
            params[key] = val
        del params['kwargs']
        if 'project' not in params or params['project'] is None:
            raise ValueError('Missing the required parameter `project` when calling `get_workflow_attributes`')
        if 'domain' not in params or params['domain'] is None:
            raise ValueError('Missing the required parameter `domain` when calling `get_workflow_attributes`')
        if 'workflow' not in params or params['workflow'] is None:
            raise ValueError('Missing the required parameter `workflow` when calling `get_workflow_attributes`')
        collection_formats = {}
        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'domain' in params:
            path_params['domain'] = params['domain']
        if 'workflow' in params:
            path_params['workflow'] = params['workflow']
        query_params = []
        if 'resource_type' in params:
            query_params.append(('resource_type', params['resource_type']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/workflow_attributes/{project}/{domain}/{workflow}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminWorkflowAttributesGetResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def list_active_launch_plans(self, project, domain, **kwargs):
        if False:
            return 10
        'List active versions of :ref:`ref_flyteidl.admin.LaunchPlan`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_active_launch_plans(project, domain, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str project: Name of the project that contains the identifiers. +required. (required)\n        :param str domain: Name of the domain the identifiers belongs to within the project. +required. (required)\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminLaunchPlanList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_active_launch_plans_with_http_info(project, domain, **kwargs)
        else:
            data = self.list_active_launch_plans_with_http_info(project, domain, **kwargs)
            return data

    def list_active_launch_plans_with_http_info(self, project, domain, **kwargs):
        if False:
            return 10
        'List active versions of :ref:`ref_flyteidl.admin.LaunchPlan`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_active_launch_plans_with_http_info(project, domain, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str project: Name of the project that contains the identifiers. +required. (required)\n        :param str domain: Name of the domain the identifiers belongs to within the project. +required. (required)\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminLaunchPlanList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['project', 'domain', 'limit', 'token', 'sort_by_key', 'sort_by_direction']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method list_active_launch_plans" % key)
            params[key] = val
        del params['kwargs']
        if 'project' not in params or params['project'] is None:
            raise ValueError('Missing the required parameter `project` when calling `list_active_launch_plans`')
        if 'domain' not in params or params['domain'] is None:
            raise ValueError('Missing the required parameter `domain` when calling `list_active_launch_plans`')
        collection_formats = {}
        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'domain' in params:
            path_params['domain'] = params['domain']
        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'token' in params:
            query_params.append(('token', params['token']))
        if 'sort_by_key' in params:
            query_params.append(('sort_by.key', params['sort_by_key']))
        if 'sort_by_direction' in params:
            query_params.append(('sort_by.direction', params['sort_by_direction']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/active_launch_plans/{project}/{domain}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminLaunchPlanList', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def list_description_entities(self, resource_type, id_project, id_domain, id_name, **kwargs):
        if False:
            print('Hello World!')
        "Fetch a list of :ref:`ref_flyteidl.admin.DescriptionEntity` definitions.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_description_entities(resource_type, id_project, id_domain, id_name, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str resource_type: Identifies the specific type of resource that this identifier corresponds to. (required)\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like 'List API', 'Launch plans' (required)\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminDescriptionEntityList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        "
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_description_entities_with_http_info(resource_type, id_project, id_domain, id_name, **kwargs)
        else:
            data = self.list_description_entities_with_http_info(resource_type, id_project, id_domain, id_name, **kwargs)
            return data

    def list_description_entities_with_http_info(self, resource_type, id_project, id_domain, id_name, **kwargs):
        if False:
            print('Hello World!')
        "Fetch a list of :ref:`ref_flyteidl.admin.DescriptionEntity` definitions.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_description_entities_with_http_info(resource_type, id_project, id_domain, id_name, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str resource_type: Identifies the specific type of resource that this identifier corresponds to. (required)\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like 'List API', 'Launch plans' (required)\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminDescriptionEntityList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        "
        all_params = ['resource_type', 'id_project', 'id_domain', 'id_name', 'limit', 'token', 'filters', 'sort_by_key', 'sort_by_direction']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method list_description_entities" % key)
            params[key] = val
        del params['kwargs']
        if 'resource_type' not in params or params['resource_type'] is None:
            raise ValueError('Missing the required parameter `resource_type` when calling `list_description_entities`')
        if 'id_project' not in params or params['id_project'] is None:
            raise ValueError('Missing the required parameter `id_project` when calling `list_description_entities`')
        if 'id_domain' not in params or params['id_domain'] is None:
            raise ValueError('Missing the required parameter `id_domain` when calling `list_description_entities`')
        if 'id_name' not in params or params['id_name'] is None:
            raise ValueError('Missing the required parameter `id_name` when calling `list_description_entities`')
        collection_formats = {}
        path_params = {}
        if 'resource_type' in params:
            path_params['resource_type'] = params['resource_type']
        if 'id_project' in params:
            path_params['id.project'] = params['id_project']
        if 'id_domain' in params:
            path_params['id.domain'] = params['id_domain']
        if 'id_name' in params:
            path_params['id.name'] = params['id_name']
        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'token' in params:
            query_params.append(('token', params['token']))
        if 'filters' in params:
            query_params.append(('filters', params['filters']))
        if 'sort_by_key' in params:
            query_params.append(('sort_by.key', params['sort_by_key']))
        if 'sort_by_direction' in params:
            query_params.append(('sort_by.direction', params['sort_by_direction']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/description_entities/{resource_type}/{id.project}/{id.domain}/{id.name}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminDescriptionEntityList', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def list_description_entities2(self, resource_type, id_project, id_domain, **kwargs):
        if False:
            return 10
        "Fetch a list of :ref:`ref_flyteidl.admin.DescriptionEntity` definitions.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_description_entities2(resource_type, id_project, id_domain, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str resource_type: Identifies the specific type of resource that this identifier corresponds to. (required)\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like 'List API', 'Launch plans'.\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminDescriptionEntityList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        "
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_description_entities2_with_http_info(resource_type, id_project, id_domain, **kwargs)
        else:
            data = self.list_description_entities2_with_http_info(resource_type, id_project, id_domain, **kwargs)
            return data

    def list_description_entities2_with_http_info(self, resource_type, id_project, id_domain, **kwargs):
        if False:
            while True:
                i = 10
        "Fetch a list of :ref:`ref_flyteidl.admin.DescriptionEntity` definitions.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_description_entities2_with_http_info(resource_type, id_project, id_domain, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str resource_type: Identifies the specific type of resource that this identifier corresponds to. (required)\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like 'List API', 'Launch plans'.\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminDescriptionEntityList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        "
        all_params = ['resource_type', 'id_project', 'id_domain', 'id_name', 'limit', 'token', 'filters', 'sort_by_key', 'sort_by_direction']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method list_description_entities2" % key)
            params[key] = val
        del params['kwargs']
        if 'resource_type' not in params or params['resource_type'] is None:
            raise ValueError('Missing the required parameter `resource_type` when calling `list_description_entities2`')
        if 'id_project' not in params or params['id_project'] is None:
            raise ValueError('Missing the required parameter `id_project` when calling `list_description_entities2`')
        if 'id_domain' not in params or params['id_domain'] is None:
            raise ValueError('Missing the required parameter `id_domain` when calling `list_description_entities2`')
        collection_formats = {}
        path_params = {}
        if 'resource_type' in params:
            path_params['resource_type'] = params['resource_type']
        if 'id_project' in params:
            path_params['id.project'] = params['id_project']
        if 'id_domain' in params:
            path_params['id.domain'] = params['id_domain']
        query_params = []
        if 'id_name' in params:
            query_params.append(('id.name', params['id_name']))
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'token' in params:
            query_params.append(('token', params['token']))
        if 'filters' in params:
            query_params.append(('filters', params['filters']))
        if 'sort_by_key' in params:
            query_params.append(('sort_by.key', params['sort_by_key']))
        if 'sort_by_direction' in params:
            query_params.append(('sort_by.direction', params['sort_by_direction']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/description_entities/{resource_type}/{id.project}/{id.domain}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminDescriptionEntityList', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def list_executions(self, id_project, id_domain, **kwargs):
        if False:
            print('Hello World!')
        "Fetch a list of :ref:`ref_flyteidl.admin.Execution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_executions(id_project, id_domain, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like 'List API', 'Launch plans'.\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminExecutionList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        "
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_executions_with_http_info(id_project, id_domain, **kwargs)
        else:
            data = self.list_executions_with_http_info(id_project, id_domain, **kwargs)
            return data

    def list_executions_with_http_info(self, id_project, id_domain, **kwargs):
        if False:
            while True:
                i = 10
        "Fetch a list of :ref:`ref_flyteidl.admin.Execution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_executions_with_http_info(id_project, id_domain, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like 'List API', 'Launch plans'.\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminExecutionList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        "
        all_params = ['id_project', 'id_domain', 'id_name', 'limit', 'token', 'filters', 'sort_by_key', 'sort_by_direction']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method list_executions" % key)
            params[key] = val
        del params['kwargs']
        if 'id_project' not in params or params['id_project'] is None:
            raise ValueError('Missing the required parameter `id_project` when calling `list_executions`')
        if 'id_domain' not in params or params['id_domain'] is None:
            raise ValueError('Missing the required parameter `id_domain` when calling `list_executions`')
        collection_formats = {}
        path_params = {}
        if 'id_project' in params:
            path_params['id.project'] = params['id_project']
        if 'id_domain' in params:
            path_params['id.domain'] = params['id_domain']
        query_params = []
        if 'id_name' in params:
            query_params.append(('id.name', params['id_name']))
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'token' in params:
            query_params.append(('token', params['token']))
        if 'filters' in params:
            query_params.append(('filters', params['filters']))
        if 'sort_by_key' in params:
            query_params.append(('sort_by.key', params['sort_by_key']))
        if 'sort_by_direction' in params:
            query_params.append(('sort_by.direction', params['sort_by_direction']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/executions/{id.project}/{id.domain}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminExecutionList', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def list_launch_plan_ids(self, project, domain, **kwargs):
        if False:
            i = 10
            return i + 15
        'Fetch a list of :ref:`ref_flyteidl.admin.NamedEntityIdentifier` of launch plan objects.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_launch_plan_ids(project, domain, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str project: Name of the project that contains the identifiers. +required (required)\n        :param str domain: Name of the domain the identifiers belongs to within the project. +required (required)\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :param str filters: Indicates a list of filters passed as string. +optional.\n        :return: AdminNamedEntityIdentifierList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_launch_plan_ids_with_http_info(project, domain, **kwargs)
        else:
            data = self.list_launch_plan_ids_with_http_info(project, domain, **kwargs)
            return data

    def list_launch_plan_ids_with_http_info(self, project, domain, **kwargs):
        if False:
            print('Hello World!')
        'Fetch a list of :ref:`ref_flyteidl.admin.NamedEntityIdentifier` of launch plan objects.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_launch_plan_ids_with_http_info(project, domain, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str project: Name of the project that contains the identifiers. +required (required)\n        :param str domain: Name of the domain the identifiers belongs to within the project. +required (required)\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :param str filters: Indicates a list of filters passed as string. +optional.\n        :return: AdminNamedEntityIdentifierList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['project', 'domain', 'limit', 'token', 'sort_by_key', 'sort_by_direction', 'filters']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method list_launch_plan_ids" % key)
            params[key] = val
        del params['kwargs']
        if 'project' not in params or params['project'] is None:
            raise ValueError('Missing the required parameter `project` when calling `list_launch_plan_ids`')
        if 'domain' not in params or params['domain'] is None:
            raise ValueError('Missing the required parameter `domain` when calling `list_launch_plan_ids`')
        collection_formats = {}
        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'domain' in params:
            path_params['domain'] = params['domain']
        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'token' in params:
            query_params.append(('token', params['token']))
        if 'sort_by_key' in params:
            query_params.append(('sort_by.key', params['sort_by_key']))
        if 'sort_by_direction' in params:
            query_params.append(('sort_by.direction', params['sort_by_direction']))
        if 'filters' in params:
            query_params.append(('filters', params['filters']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/launch_plan_ids/{project}/{domain}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminNamedEntityIdentifierList', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def list_launch_plans(self, id_project, id_domain, id_name, **kwargs):
        if False:
            i = 10
            return i + 15
        "Fetch a list of :ref:`ref_flyteidl.admin.LaunchPlan` definitions.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_launch_plans(id_project, id_domain, id_name, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like 'List API', 'Launch plans' (required)\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminLaunchPlanList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        "
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_launch_plans_with_http_info(id_project, id_domain, id_name, **kwargs)
        else:
            data = self.list_launch_plans_with_http_info(id_project, id_domain, id_name, **kwargs)
            return data

    def list_launch_plans_with_http_info(self, id_project, id_domain, id_name, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        "Fetch a list of :ref:`ref_flyteidl.admin.LaunchPlan` definitions.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_launch_plans_with_http_info(id_project, id_domain, id_name, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like 'List API', 'Launch plans' (required)\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminLaunchPlanList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        "
        all_params = ['id_project', 'id_domain', 'id_name', 'limit', 'token', 'filters', 'sort_by_key', 'sort_by_direction']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method list_launch_plans" % key)
            params[key] = val
        del params['kwargs']
        if 'id_project' not in params or params['id_project'] is None:
            raise ValueError('Missing the required parameter `id_project` when calling `list_launch_plans`')
        if 'id_domain' not in params or params['id_domain'] is None:
            raise ValueError('Missing the required parameter `id_domain` when calling `list_launch_plans`')
        if 'id_name' not in params or params['id_name'] is None:
            raise ValueError('Missing the required parameter `id_name` when calling `list_launch_plans`')
        collection_formats = {}
        path_params = {}
        if 'id_project' in params:
            path_params['id.project'] = params['id_project']
        if 'id_domain' in params:
            path_params['id.domain'] = params['id_domain']
        if 'id_name' in params:
            path_params['id.name'] = params['id_name']
        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'token' in params:
            query_params.append(('token', params['token']))
        if 'filters' in params:
            query_params.append(('filters', params['filters']))
        if 'sort_by_key' in params:
            query_params.append(('sort_by.key', params['sort_by_key']))
        if 'sort_by_direction' in params:
            query_params.append(('sort_by.direction', params['sort_by_direction']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/launch_plans/{id.project}/{id.domain}/{id.name}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminLaunchPlanList', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def list_launch_plans2(self, id_project, id_domain, **kwargs):
        if False:
            while True:
                i = 10
        "Fetch a list of :ref:`ref_flyteidl.admin.LaunchPlan` definitions.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_launch_plans2(id_project, id_domain, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like 'List API', 'Launch plans'.\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminLaunchPlanList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        "
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_launch_plans2_with_http_info(id_project, id_domain, **kwargs)
        else:
            data = self.list_launch_plans2_with_http_info(id_project, id_domain, **kwargs)
            return data

    def list_launch_plans2_with_http_info(self, id_project, id_domain, **kwargs):
        if False:
            while True:
                i = 10
        "Fetch a list of :ref:`ref_flyteidl.admin.LaunchPlan` definitions.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_launch_plans2_with_http_info(id_project, id_domain, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like 'List API', 'Launch plans'.\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminLaunchPlanList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        "
        all_params = ['id_project', 'id_domain', 'id_name', 'limit', 'token', 'filters', 'sort_by_key', 'sort_by_direction']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method list_launch_plans2" % key)
            params[key] = val
        del params['kwargs']
        if 'id_project' not in params or params['id_project'] is None:
            raise ValueError('Missing the required parameter `id_project` when calling `list_launch_plans2`')
        if 'id_domain' not in params or params['id_domain'] is None:
            raise ValueError('Missing the required parameter `id_domain` when calling `list_launch_plans2`')
        collection_formats = {}
        path_params = {}
        if 'id_project' in params:
            path_params['id.project'] = params['id_project']
        if 'id_domain' in params:
            path_params['id.domain'] = params['id_domain']
        query_params = []
        if 'id_name' in params:
            query_params.append(('id.name', params['id_name']))
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'token' in params:
            query_params.append(('token', params['token']))
        if 'filters' in params:
            query_params.append(('filters', params['filters']))
        if 'sort_by_key' in params:
            query_params.append(('sort_by.key', params['sort_by_key']))
        if 'sort_by_direction' in params:
            query_params.append(('sort_by.direction', params['sort_by_direction']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/launch_plans/{id.project}/{id.domain}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminLaunchPlanList', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def list_matchable_attributes(self, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        'Lists custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a specific resource type.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_matchable_attributes(async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str resource_type: +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.\n        :return: AdminListMatchableAttributesResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_matchable_attributes_with_http_info(**kwargs)
        else:
            data = self.list_matchable_attributes_with_http_info(**kwargs)
            return data

    def list_matchable_attributes_with_http_info(self, **kwargs):
        if False:
            return 10
        'Lists custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a specific resource type.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_matchable_attributes_with_http_info(async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str resource_type: +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.\n        :return: AdminListMatchableAttributesResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['resource_type']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method list_matchable_attributes" % key)
            params[key] = val
        del params['kwargs']
        collection_formats = {}
        path_params = {}
        query_params = []
        if 'resource_type' in params:
            query_params.append(('resource_type', params['resource_type']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/matchable_attributes', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminListMatchableAttributesResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def list_named_entities(self, resource_type, project, domain, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        'Returns a list of :ref:`ref_flyteidl.admin.NamedEntity` objects.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_named_entities(resource_type, project, domain, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str resource_type: Resource type of the metadata to query. One of Task, Workflow or LaunchPlan. +required (required)\n        :param str project: Name of the project that contains the identifiers. +required (required)\n        :param str domain: Name of the domain the identifiers belongs to within the project. (required)\n        :param int limit: Indicates the number of resources to be returned.\n        :param str token: In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :param str filters: Indicates a list of filters passed as string. +optional.\n        :return: AdminNamedEntityList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_named_entities_with_http_info(resource_type, project, domain, **kwargs)
        else:
            data = self.list_named_entities_with_http_info(resource_type, project, domain, **kwargs)
            return data

    def list_named_entities_with_http_info(self, resource_type, project, domain, **kwargs):
        if False:
            print('Hello World!')
        'Returns a list of :ref:`ref_flyteidl.admin.NamedEntity` objects.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_named_entities_with_http_info(resource_type, project, domain, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str resource_type: Resource type of the metadata to query. One of Task, Workflow or LaunchPlan. +required (required)\n        :param str project: Name of the project that contains the identifiers. +required (required)\n        :param str domain: Name of the domain the identifiers belongs to within the project. (required)\n        :param int limit: Indicates the number of resources to be returned.\n        :param str token: In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :param str filters: Indicates a list of filters passed as string. +optional.\n        :return: AdminNamedEntityList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['resource_type', 'project', 'domain', 'limit', 'token', 'sort_by_key', 'sort_by_direction', 'filters']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method list_named_entities" % key)
            params[key] = val
        del params['kwargs']
        if 'resource_type' not in params or params['resource_type'] is None:
            raise ValueError('Missing the required parameter `resource_type` when calling `list_named_entities`')
        if 'project' not in params or params['project'] is None:
            raise ValueError('Missing the required parameter `project` when calling `list_named_entities`')
        if 'domain' not in params or params['domain'] is None:
            raise ValueError('Missing the required parameter `domain` when calling `list_named_entities`')
        collection_formats = {}
        path_params = {}
        if 'resource_type' in params:
            path_params['resource_type'] = params['resource_type']
        if 'project' in params:
            path_params['project'] = params['project']
        if 'domain' in params:
            path_params['domain'] = params['domain']
        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'token' in params:
            query_params.append(('token', params['token']))
        if 'sort_by_key' in params:
            query_params.append(('sort_by.key', params['sort_by_key']))
        if 'sort_by_direction' in params:
            query_params.append(('sort_by.direction', params['sort_by_direction']))
        if 'filters' in params:
            query_params.append(('filters', params['filters']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/named_entities/{resource_type}/{project}/{domain}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminNamedEntityList', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def list_node_executions(self, workflow_execution_id_project, workflow_execution_id_domain, workflow_execution_id_name, **kwargs):
        if False:
            return 10
        'Fetch a list of :ref:`ref_flyteidl.admin.NodeExecution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_node_executions(workflow_execution_id_project, workflow_execution_id_domain, workflow_execution_id_name, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str workflow_execution_id_project: Name of the project the resource belongs to. (required)\n        :param str workflow_execution_id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str workflow_execution_id_name: User or system provided value for the resource. (required)\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token:\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :param str unique_parent_id: Unique identifier of the parent node in the execution +optional.\n        :return: AdminNodeExecutionList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_node_executions_with_http_info(workflow_execution_id_project, workflow_execution_id_domain, workflow_execution_id_name, **kwargs)
        else:
            data = self.list_node_executions_with_http_info(workflow_execution_id_project, workflow_execution_id_domain, workflow_execution_id_name, **kwargs)
            return data

    def list_node_executions_with_http_info(self, workflow_execution_id_project, workflow_execution_id_domain, workflow_execution_id_name, **kwargs):
        if False:
            print('Hello World!')
        'Fetch a list of :ref:`ref_flyteidl.admin.NodeExecution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_node_executions_with_http_info(workflow_execution_id_project, workflow_execution_id_domain, workflow_execution_id_name, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str workflow_execution_id_project: Name of the project the resource belongs to. (required)\n        :param str workflow_execution_id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str workflow_execution_id_name: User or system provided value for the resource. (required)\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token:\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :param str unique_parent_id: Unique identifier of the parent node in the execution +optional.\n        :return: AdminNodeExecutionList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['workflow_execution_id_project', 'workflow_execution_id_domain', 'workflow_execution_id_name', 'limit', 'token', 'filters', 'sort_by_key', 'sort_by_direction', 'unique_parent_id']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method list_node_executions" % key)
            params[key] = val
        del params['kwargs']
        if 'workflow_execution_id_project' not in params or params['workflow_execution_id_project'] is None:
            raise ValueError('Missing the required parameter `workflow_execution_id_project` when calling `list_node_executions`')
        if 'workflow_execution_id_domain' not in params or params['workflow_execution_id_domain'] is None:
            raise ValueError('Missing the required parameter `workflow_execution_id_domain` when calling `list_node_executions`')
        if 'workflow_execution_id_name' not in params or params['workflow_execution_id_name'] is None:
            raise ValueError('Missing the required parameter `workflow_execution_id_name` when calling `list_node_executions`')
        collection_formats = {}
        path_params = {}
        if 'workflow_execution_id_project' in params:
            path_params['workflow_execution_id.project'] = params['workflow_execution_id_project']
        if 'workflow_execution_id_domain' in params:
            path_params['workflow_execution_id.domain'] = params['workflow_execution_id_domain']
        if 'workflow_execution_id_name' in params:
            path_params['workflow_execution_id.name'] = params['workflow_execution_id_name']
        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'token' in params:
            query_params.append(('token', params['token']))
        if 'filters' in params:
            query_params.append(('filters', params['filters']))
        if 'sort_by_key' in params:
            query_params.append(('sort_by.key', params['sort_by_key']))
        if 'sort_by_direction' in params:
            query_params.append(('sort_by.direction', params['sort_by_direction']))
        if 'unique_parent_id' in params:
            query_params.append(('unique_parent_id', params['unique_parent_id']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/node_executions/{workflow_execution_id.project}/{workflow_execution_id.domain}/{workflow_execution_id.name}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminNodeExecutionList', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def list_node_executions_for_task(self, task_execution_id_node_execution_id_execution_id_project, task_execution_id_node_execution_id_execution_id_domain, task_execution_id_node_execution_id_execution_id_name, task_execution_id_node_execution_id_node_id, task_execution_id_task_id_project, task_execution_id_task_id_domain, task_execution_id_task_id_name, task_execution_id_task_id_version, task_execution_id_retry_attempt, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        'Fetch a list of :ref:`ref_flyteidl.admin.NodeExecution` launched by the reference :ref:`ref_flyteidl.admin.TaskExecution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_node_executions_for_task(task_execution_id_node_execution_id_execution_id_project, task_execution_id_node_execution_id_execution_id_domain, task_execution_id_node_execution_id_execution_id_name, task_execution_id_node_execution_id_node_id, task_execution_id_task_id_project, task_execution_id_task_id_domain, task_execution_id_task_id_name, task_execution_id_task_id_version, task_execution_id_retry_attempt, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str task_execution_id_node_execution_id_execution_id_project: Name of the project the resource belongs to. (required)\n        :param str task_execution_id_node_execution_id_execution_id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str task_execution_id_node_execution_id_execution_id_name: User or system provided value for the resource. (required)\n        :param str task_execution_id_node_execution_id_node_id: (required)\n        :param str task_execution_id_task_id_project: Name of the project the resource belongs to. (required)\n        :param str task_execution_id_task_id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str task_execution_id_task_id_name: User provided value for the resource. (required)\n        :param str task_execution_id_task_id_version: Specific version of the resource. (required)\n        :param int task_execution_id_retry_attempt: (required)\n        :param str task_execution_id_task_id_resource_type: Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, the, server-provided token can be used to fetch the next page in a query. +optional.\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminNodeExecutionList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_node_executions_for_task_with_http_info(task_execution_id_node_execution_id_execution_id_project, task_execution_id_node_execution_id_execution_id_domain, task_execution_id_node_execution_id_execution_id_name, task_execution_id_node_execution_id_node_id, task_execution_id_task_id_project, task_execution_id_task_id_domain, task_execution_id_task_id_name, task_execution_id_task_id_version, task_execution_id_retry_attempt, **kwargs)
        else:
            data = self.list_node_executions_for_task_with_http_info(task_execution_id_node_execution_id_execution_id_project, task_execution_id_node_execution_id_execution_id_domain, task_execution_id_node_execution_id_execution_id_name, task_execution_id_node_execution_id_node_id, task_execution_id_task_id_project, task_execution_id_task_id_domain, task_execution_id_task_id_name, task_execution_id_task_id_version, task_execution_id_retry_attempt, **kwargs)
            return data

    def list_node_executions_for_task_with_http_info(self, task_execution_id_node_execution_id_execution_id_project, task_execution_id_node_execution_id_execution_id_domain, task_execution_id_node_execution_id_execution_id_name, task_execution_id_node_execution_id_node_id, task_execution_id_task_id_project, task_execution_id_task_id_domain, task_execution_id_task_id_name, task_execution_id_task_id_version, task_execution_id_retry_attempt, **kwargs):
        if False:
            i = 10
            return i + 15
        'Fetch a list of :ref:`ref_flyteidl.admin.NodeExecution` launched by the reference :ref:`ref_flyteidl.admin.TaskExecution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_node_executions_for_task_with_http_info(task_execution_id_node_execution_id_execution_id_project, task_execution_id_node_execution_id_execution_id_domain, task_execution_id_node_execution_id_execution_id_name, task_execution_id_node_execution_id_node_id, task_execution_id_task_id_project, task_execution_id_task_id_domain, task_execution_id_task_id_name, task_execution_id_task_id_version, task_execution_id_retry_attempt, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str task_execution_id_node_execution_id_execution_id_project: Name of the project the resource belongs to. (required)\n        :param str task_execution_id_node_execution_id_execution_id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str task_execution_id_node_execution_id_execution_id_name: User or system provided value for the resource. (required)\n        :param str task_execution_id_node_execution_id_node_id: (required)\n        :param str task_execution_id_task_id_project: Name of the project the resource belongs to. (required)\n        :param str task_execution_id_task_id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str task_execution_id_task_id_name: User provided value for the resource. (required)\n        :param str task_execution_id_task_id_version: Specific version of the resource. (required)\n        :param int task_execution_id_retry_attempt: (required)\n        :param str task_execution_id_task_id_resource_type: Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, the, server-provided token can be used to fetch the next page in a query. +optional.\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminNodeExecutionList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['task_execution_id_node_execution_id_execution_id_project', 'task_execution_id_node_execution_id_execution_id_domain', 'task_execution_id_node_execution_id_execution_id_name', 'task_execution_id_node_execution_id_node_id', 'task_execution_id_task_id_project', 'task_execution_id_task_id_domain', 'task_execution_id_task_id_name', 'task_execution_id_task_id_version', 'task_execution_id_retry_attempt', 'task_execution_id_task_id_resource_type', 'limit', 'token', 'filters', 'sort_by_key', 'sort_by_direction']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method list_node_executions_for_task" % key)
            params[key] = val
        del params['kwargs']
        if 'task_execution_id_node_execution_id_execution_id_project' not in params or params['task_execution_id_node_execution_id_execution_id_project'] is None:
            raise ValueError('Missing the required parameter `task_execution_id_node_execution_id_execution_id_project` when calling `list_node_executions_for_task`')
        if 'task_execution_id_node_execution_id_execution_id_domain' not in params or params['task_execution_id_node_execution_id_execution_id_domain'] is None:
            raise ValueError('Missing the required parameter `task_execution_id_node_execution_id_execution_id_domain` when calling `list_node_executions_for_task`')
        if 'task_execution_id_node_execution_id_execution_id_name' not in params or params['task_execution_id_node_execution_id_execution_id_name'] is None:
            raise ValueError('Missing the required parameter `task_execution_id_node_execution_id_execution_id_name` when calling `list_node_executions_for_task`')
        if 'task_execution_id_node_execution_id_node_id' not in params or params['task_execution_id_node_execution_id_node_id'] is None:
            raise ValueError('Missing the required parameter `task_execution_id_node_execution_id_node_id` when calling `list_node_executions_for_task`')
        if 'task_execution_id_task_id_project' not in params or params['task_execution_id_task_id_project'] is None:
            raise ValueError('Missing the required parameter `task_execution_id_task_id_project` when calling `list_node_executions_for_task`')
        if 'task_execution_id_task_id_domain' not in params or params['task_execution_id_task_id_domain'] is None:
            raise ValueError('Missing the required parameter `task_execution_id_task_id_domain` when calling `list_node_executions_for_task`')
        if 'task_execution_id_task_id_name' not in params or params['task_execution_id_task_id_name'] is None:
            raise ValueError('Missing the required parameter `task_execution_id_task_id_name` when calling `list_node_executions_for_task`')
        if 'task_execution_id_task_id_version' not in params or params['task_execution_id_task_id_version'] is None:
            raise ValueError('Missing the required parameter `task_execution_id_task_id_version` when calling `list_node_executions_for_task`')
        if 'task_execution_id_retry_attempt' not in params or params['task_execution_id_retry_attempt'] is None:
            raise ValueError('Missing the required parameter `task_execution_id_retry_attempt` when calling `list_node_executions_for_task`')
        collection_formats = {}
        path_params = {}
        if 'task_execution_id_node_execution_id_execution_id_project' in params:
            path_params['task_execution_id.node_execution_id.execution_id.project'] = params['task_execution_id_node_execution_id_execution_id_project']
        if 'task_execution_id_node_execution_id_execution_id_domain' in params:
            path_params['task_execution_id.node_execution_id.execution_id.domain'] = params['task_execution_id_node_execution_id_execution_id_domain']
        if 'task_execution_id_node_execution_id_execution_id_name' in params:
            path_params['task_execution_id.node_execution_id.execution_id.name'] = params['task_execution_id_node_execution_id_execution_id_name']
        if 'task_execution_id_node_execution_id_node_id' in params:
            path_params['task_execution_id.node_execution_id.node_id'] = params['task_execution_id_node_execution_id_node_id']
        if 'task_execution_id_task_id_project' in params:
            path_params['task_execution_id.task_id.project'] = params['task_execution_id_task_id_project']
        if 'task_execution_id_task_id_domain' in params:
            path_params['task_execution_id.task_id.domain'] = params['task_execution_id_task_id_domain']
        if 'task_execution_id_task_id_name' in params:
            path_params['task_execution_id.task_id.name'] = params['task_execution_id_task_id_name']
        if 'task_execution_id_task_id_version' in params:
            path_params['task_execution_id.task_id.version'] = params['task_execution_id_task_id_version']
        if 'task_execution_id_retry_attempt' in params:
            path_params['task_execution_id.retry_attempt'] = params['task_execution_id_retry_attempt']
        query_params = []
        if 'task_execution_id_task_id_resource_type' in params:
            query_params.append(('task_execution_id.task_id.resource_type', params['task_execution_id_task_id_resource_type']))
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'token' in params:
            query_params.append(('token', params['token']))
        if 'filters' in params:
            query_params.append(('filters', params['filters']))
        if 'sort_by_key' in params:
            query_params.append(('sort_by.key', params['sort_by_key']))
        if 'sort_by_direction' in params:
            query_params.append(('sort_by.direction', params['sort_by_direction']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/children/task_executions/{task_execution_id.node_execution_id.execution_id.project}/{task_execution_id.node_execution_id.execution_id.domain}/{task_execution_id.node_execution_id.execution_id.name}/{task_execution_id.node_execution_id.node_id}/{task_execution_id.task_id.project}/{task_execution_id.task_id.domain}/{task_execution_id.task_id.name}/{task_execution_id.task_id.version}/{task_execution_id.retry_attempt}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminNodeExecutionList', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def list_projects(self, **kwargs):
        if False:
            while True:
                i = 10
        'Fetches a list of :ref:`ref_flyteidl.admin.Project`  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_projects(async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param int limit: Indicates the number of projects to be returned. +required.\n        :param str token: In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminProjects\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_projects_with_http_info(**kwargs)
        else:
            data = self.list_projects_with_http_info(**kwargs)
            return data

    def list_projects_with_http_info(self, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        'Fetches a list of :ref:`ref_flyteidl.admin.Project`  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_projects_with_http_info(async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param int limit: Indicates the number of projects to be returned. +required.\n        :param str token: In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminProjects\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['limit', 'token', 'filters', 'sort_by_key', 'sort_by_direction']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method list_projects" % key)
            params[key] = val
        del params['kwargs']
        collection_formats = {}
        path_params = {}
        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'token' in params:
            query_params.append(('token', params['token']))
        if 'filters' in params:
            query_params.append(('filters', params['filters']))
        if 'sort_by_key' in params:
            query_params.append(('sort_by.key', params['sort_by_key']))
        if 'sort_by_direction' in params:
            query_params.append(('sort_by.direction', params['sort_by_direction']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/projects', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminProjects', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def list_task_executions(self, node_execution_id_execution_id_project, node_execution_id_execution_id_domain, node_execution_id_execution_id_name, node_execution_id_node_id, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        'Fetches a list of :ref:`ref_flyteidl.admin.TaskExecution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_task_executions(node_execution_id_execution_id_project, node_execution_id_execution_id_domain, node_execution_id_execution_id_name, node_execution_id_node_id, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str node_execution_id_execution_id_project: Name of the project the resource belongs to. (required)\n        :param str node_execution_id_execution_id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str node_execution_id_execution_id_name: User or system provided value for the resource. (required)\n        :param str node_execution_id_node_id: (required)\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminTaskExecutionList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_task_executions_with_http_info(node_execution_id_execution_id_project, node_execution_id_execution_id_domain, node_execution_id_execution_id_name, node_execution_id_node_id, **kwargs)
        else:
            data = self.list_task_executions_with_http_info(node_execution_id_execution_id_project, node_execution_id_execution_id_domain, node_execution_id_execution_id_name, node_execution_id_node_id, **kwargs)
            return data

    def list_task_executions_with_http_info(self, node_execution_id_execution_id_project, node_execution_id_execution_id_domain, node_execution_id_execution_id_name, node_execution_id_node_id, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        'Fetches a list of :ref:`ref_flyteidl.admin.TaskExecution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_task_executions_with_http_info(node_execution_id_execution_id_project, node_execution_id_execution_id_domain, node_execution_id_execution_id_name, node_execution_id_node_id, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str node_execution_id_execution_id_project: Name of the project the resource belongs to. (required)\n        :param str node_execution_id_execution_id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str node_execution_id_execution_id_name: User or system provided value for the resource. (required)\n        :param str node_execution_id_node_id: (required)\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminTaskExecutionList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['node_execution_id_execution_id_project', 'node_execution_id_execution_id_domain', 'node_execution_id_execution_id_name', 'node_execution_id_node_id', 'limit', 'token', 'filters', 'sort_by_key', 'sort_by_direction']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method list_task_executions" % key)
            params[key] = val
        del params['kwargs']
        if 'node_execution_id_execution_id_project' not in params or params['node_execution_id_execution_id_project'] is None:
            raise ValueError('Missing the required parameter `node_execution_id_execution_id_project` when calling `list_task_executions`')
        if 'node_execution_id_execution_id_domain' not in params or params['node_execution_id_execution_id_domain'] is None:
            raise ValueError('Missing the required parameter `node_execution_id_execution_id_domain` when calling `list_task_executions`')
        if 'node_execution_id_execution_id_name' not in params or params['node_execution_id_execution_id_name'] is None:
            raise ValueError('Missing the required parameter `node_execution_id_execution_id_name` when calling `list_task_executions`')
        if 'node_execution_id_node_id' not in params or params['node_execution_id_node_id'] is None:
            raise ValueError('Missing the required parameter `node_execution_id_node_id` when calling `list_task_executions`')
        collection_formats = {}
        path_params = {}
        if 'node_execution_id_execution_id_project' in params:
            path_params['node_execution_id.execution_id.project'] = params['node_execution_id_execution_id_project']
        if 'node_execution_id_execution_id_domain' in params:
            path_params['node_execution_id.execution_id.domain'] = params['node_execution_id_execution_id_domain']
        if 'node_execution_id_execution_id_name' in params:
            path_params['node_execution_id.execution_id.name'] = params['node_execution_id_execution_id_name']
        if 'node_execution_id_node_id' in params:
            path_params['node_execution_id.node_id'] = params['node_execution_id_node_id']
        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'token' in params:
            query_params.append(('token', params['token']))
        if 'filters' in params:
            query_params.append(('filters', params['filters']))
        if 'sort_by_key' in params:
            query_params.append(('sort_by.key', params['sort_by_key']))
        if 'sort_by_direction' in params:
            query_params.append(('sort_by.direction', params['sort_by_direction']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/task_executions/{node_execution_id.execution_id.project}/{node_execution_id.execution_id.domain}/{node_execution_id.execution_id.name}/{node_execution_id.node_id}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminTaskExecutionList', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def list_task_ids(self, project, domain, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        'Fetch a list of :ref:`ref_flyteidl.admin.NamedEntityIdentifier` of task objects.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_task_ids(project, domain, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str project: Name of the project that contains the identifiers. +required (required)\n        :param str domain: Name of the domain the identifiers belongs to within the project. +required (required)\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :param str filters: Indicates a list of filters passed as string. +optional.\n        :return: AdminNamedEntityIdentifierList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_task_ids_with_http_info(project, domain, **kwargs)
        else:
            data = self.list_task_ids_with_http_info(project, domain, **kwargs)
            return data

    def list_task_ids_with_http_info(self, project, domain, **kwargs):
        if False:
            return 10
        'Fetch a list of :ref:`ref_flyteidl.admin.NamedEntityIdentifier` of task objects.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_task_ids_with_http_info(project, domain, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str project: Name of the project that contains the identifiers. +required (required)\n        :param str domain: Name of the domain the identifiers belongs to within the project. +required (required)\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :param str filters: Indicates a list of filters passed as string. +optional.\n        :return: AdminNamedEntityIdentifierList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['project', 'domain', 'limit', 'token', 'sort_by_key', 'sort_by_direction', 'filters']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method list_task_ids" % key)
            params[key] = val
        del params['kwargs']
        if 'project' not in params or params['project'] is None:
            raise ValueError('Missing the required parameter `project` when calling `list_task_ids`')
        if 'domain' not in params or params['domain'] is None:
            raise ValueError('Missing the required parameter `domain` when calling `list_task_ids`')
        collection_formats = {}
        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'domain' in params:
            path_params['domain'] = params['domain']
        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'token' in params:
            query_params.append(('token', params['token']))
        if 'sort_by_key' in params:
            query_params.append(('sort_by.key', params['sort_by_key']))
        if 'sort_by_direction' in params:
            query_params.append(('sort_by.direction', params['sort_by_direction']))
        if 'filters' in params:
            query_params.append(('filters', params['filters']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/task_ids/{project}/{domain}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminNamedEntityIdentifierList', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def list_tasks(self, id_project, id_domain, id_name, **kwargs):
        if False:
            i = 10
            return i + 15
        "Fetch a list of :ref:`ref_flyteidl.admin.Task` definitions.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_tasks(id_project, id_domain, id_name, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like 'List API', 'Launch plans' (required)\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminTaskList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        "
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_tasks_with_http_info(id_project, id_domain, id_name, **kwargs)
        else:
            data = self.list_tasks_with_http_info(id_project, id_domain, id_name, **kwargs)
            return data

    def list_tasks_with_http_info(self, id_project, id_domain, id_name, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        "Fetch a list of :ref:`ref_flyteidl.admin.Task` definitions.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_tasks_with_http_info(id_project, id_domain, id_name, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like 'List API', 'Launch plans' (required)\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminTaskList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        "
        all_params = ['id_project', 'id_domain', 'id_name', 'limit', 'token', 'filters', 'sort_by_key', 'sort_by_direction']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method list_tasks" % key)
            params[key] = val
        del params['kwargs']
        if 'id_project' not in params or params['id_project'] is None:
            raise ValueError('Missing the required parameter `id_project` when calling `list_tasks`')
        if 'id_domain' not in params or params['id_domain'] is None:
            raise ValueError('Missing the required parameter `id_domain` when calling `list_tasks`')
        if 'id_name' not in params or params['id_name'] is None:
            raise ValueError('Missing the required parameter `id_name` when calling `list_tasks`')
        collection_formats = {}
        path_params = {}
        if 'id_project' in params:
            path_params['id.project'] = params['id_project']
        if 'id_domain' in params:
            path_params['id.domain'] = params['id_domain']
        if 'id_name' in params:
            path_params['id.name'] = params['id_name']
        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'token' in params:
            query_params.append(('token', params['token']))
        if 'filters' in params:
            query_params.append(('filters', params['filters']))
        if 'sort_by_key' in params:
            query_params.append(('sort_by.key', params['sort_by_key']))
        if 'sort_by_direction' in params:
            query_params.append(('sort_by.direction', params['sort_by_direction']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/tasks/{id.project}/{id.domain}/{id.name}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminTaskList', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def list_tasks2(self, id_project, id_domain, **kwargs):
        if False:
            return 10
        "Fetch a list of :ref:`ref_flyteidl.admin.Task` definitions.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_tasks2(id_project, id_domain, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like 'List API', 'Launch plans'.\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminTaskList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        "
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_tasks2_with_http_info(id_project, id_domain, **kwargs)
        else:
            data = self.list_tasks2_with_http_info(id_project, id_domain, **kwargs)
            return data

    def list_tasks2_with_http_info(self, id_project, id_domain, **kwargs):
        if False:
            return 10
        "Fetch a list of :ref:`ref_flyteidl.admin.Task` definitions.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_tasks2_with_http_info(id_project, id_domain, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like 'List API', 'Launch plans'.\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminTaskList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        "
        all_params = ['id_project', 'id_domain', 'id_name', 'limit', 'token', 'filters', 'sort_by_key', 'sort_by_direction']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method list_tasks2" % key)
            params[key] = val
        del params['kwargs']
        if 'id_project' not in params or params['id_project'] is None:
            raise ValueError('Missing the required parameter `id_project` when calling `list_tasks2`')
        if 'id_domain' not in params or params['id_domain'] is None:
            raise ValueError('Missing the required parameter `id_domain` when calling `list_tasks2`')
        collection_formats = {}
        path_params = {}
        if 'id_project' in params:
            path_params['id.project'] = params['id_project']
        if 'id_domain' in params:
            path_params['id.domain'] = params['id_domain']
        query_params = []
        if 'id_name' in params:
            query_params.append(('id.name', params['id_name']))
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'token' in params:
            query_params.append(('token', params['token']))
        if 'filters' in params:
            query_params.append(('filters', params['filters']))
        if 'sort_by_key' in params:
            query_params.append(('sort_by.key', params['sort_by_key']))
        if 'sort_by_direction' in params:
            query_params.append(('sort_by.direction', params['sort_by_direction']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/tasks/{id.project}/{id.domain}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminTaskList', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def list_workflow_ids(self, project, domain, **kwargs):
        if False:
            return 10
        'Fetch a list of :ref:`ref_flyteidl.admin.NamedEntityIdentifier` of workflow objects.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_workflow_ids(project, domain, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str project: Name of the project that contains the identifiers. +required (required)\n        :param str domain: Name of the domain the identifiers belongs to within the project. +required (required)\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :param str filters: Indicates a list of filters passed as string. +optional.\n        :return: AdminNamedEntityIdentifierList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_workflow_ids_with_http_info(project, domain, **kwargs)
        else:
            data = self.list_workflow_ids_with_http_info(project, domain, **kwargs)
            return data

    def list_workflow_ids_with_http_info(self, project, domain, **kwargs):
        if False:
            while True:
                i = 10
        'Fetch a list of :ref:`ref_flyteidl.admin.NamedEntityIdentifier` of workflow objects.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_workflow_ids_with_http_info(project, domain, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str project: Name of the project that contains the identifiers. +required (required)\n        :param str domain: Name of the domain the identifiers belongs to within the project. +required (required)\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :param str filters: Indicates a list of filters passed as string. +optional.\n        :return: AdminNamedEntityIdentifierList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['project', 'domain', 'limit', 'token', 'sort_by_key', 'sort_by_direction', 'filters']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method list_workflow_ids" % key)
            params[key] = val
        del params['kwargs']
        if 'project' not in params or params['project'] is None:
            raise ValueError('Missing the required parameter `project` when calling `list_workflow_ids`')
        if 'domain' not in params or params['domain'] is None:
            raise ValueError('Missing the required parameter `domain` when calling `list_workflow_ids`')
        collection_formats = {}
        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'domain' in params:
            path_params['domain'] = params['domain']
        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'token' in params:
            query_params.append(('token', params['token']))
        if 'sort_by_key' in params:
            query_params.append(('sort_by.key', params['sort_by_key']))
        if 'sort_by_direction' in params:
            query_params.append(('sort_by.direction', params['sort_by_direction']))
        if 'filters' in params:
            query_params.append(('filters', params['filters']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/workflow_ids/{project}/{domain}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminNamedEntityIdentifierList', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def list_workflows(self, id_project, id_domain, id_name, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        "Fetch a list of :ref:`ref_flyteidl.admin.Workflow` definitions.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_workflows(id_project, id_domain, id_name, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like 'List API', 'Launch plans' (required)\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminWorkflowList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        "
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_workflows_with_http_info(id_project, id_domain, id_name, **kwargs)
        else:
            data = self.list_workflows_with_http_info(id_project, id_domain, id_name, **kwargs)
            return data

    def list_workflows_with_http_info(self, id_project, id_domain, id_name, **kwargs):
        if False:
            while True:
                i = 10
        "Fetch a list of :ref:`ref_flyteidl.admin.Workflow` definitions.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_workflows_with_http_info(id_project, id_domain, id_name, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like 'List API', 'Launch plans' (required)\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminWorkflowList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        "
        all_params = ['id_project', 'id_domain', 'id_name', 'limit', 'token', 'filters', 'sort_by_key', 'sort_by_direction']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method list_workflows" % key)
            params[key] = val
        del params['kwargs']
        if 'id_project' not in params or params['id_project'] is None:
            raise ValueError('Missing the required parameter `id_project` when calling `list_workflows`')
        if 'id_domain' not in params or params['id_domain'] is None:
            raise ValueError('Missing the required parameter `id_domain` when calling `list_workflows`')
        if 'id_name' not in params or params['id_name'] is None:
            raise ValueError('Missing the required parameter `id_name` when calling `list_workflows`')
        collection_formats = {}
        path_params = {}
        if 'id_project' in params:
            path_params['id.project'] = params['id_project']
        if 'id_domain' in params:
            path_params['id.domain'] = params['id_domain']
        if 'id_name' in params:
            path_params['id.name'] = params['id_name']
        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'token' in params:
            query_params.append(('token', params['token']))
        if 'filters' in params:
            query_params.append(('filters', params['filters']))
        if 'sort_by_key' in params:
            query_params.append(('sort_by.key', params['sort_by_key']))
        if 'sort_by_direction' in params:
            query_params.append(('sort_by.direction', params['sort_by_direction']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/workflows/{id.project}/{id.domain}/{id.name}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminWorkflowList', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def list_workflows2(self, id_project, id_domain, **kwargs):
        if False:
            return 10
        "Fetch a list of :ref:`ref_flyteidl.admin.Workflow` definitions.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_workflows2(id_project, id_domain, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like 'List API', 'Launch plans'.\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminWorkflowList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        "
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_workflows2_with_http_info(id_project, id_domain, **kwargs)
        else:
            data = self.list_workflows2_with_http_info(id_project, id_domain, **kwargs)
            return data

    def list_workflows2_with_http_info(self, id_project, id_domain, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        "Fetch a list of :ref:`ref_flyteidl.admin.Workflow` definitions.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.list_workflows2_with_http_info(id_project, id_domain, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like 'List API', 'Launch plans'.\n        :param int limit: Indicates the number of resources to be returned. +required.\n        :param str token: In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.\n        :param str filters: Indicates a list of filters passed as string. More info on constructing filters : <Link> +optional.\n        :param str sort_by_key: Indicates an attribute to sort the response values. +required.\n        :param str sort_by_direction: Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.\n        :return: AdminWorkflowList\n                 If the method is called asynchronously,\n                 returns the request thread.\n        "
        all_params = ['id_project', 'id_domain', 'id_name', 'limit', 'token', 'filters', 'sort_by_key', 'sort_by_direction']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method list_workflows2" % key)
            params[key] = val
        del params['kwargs']
        if 'id_project' not in params or params['id_project'] is None:
            raise ValueError('Missing the required parameter `id_project` when calling `list_workflows2`')
        if 'id_domain' not in params or params['id_domain'] is None:
            raise ValueError('Missing the required parameter `id_domain` when calling `list_workflows2`')
        collection_formats = {}
        path_params = {}
        if 'id_project' in params:
            path_params['id.project'] = params['id_project']
        if 'id_domain' in params:
            path_params['id.domain'] = params['id_domain']
        query_params = []
        if 'id_name' in params:
            query_params.append(('id.name', params['id_name']))
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'token' in params:
            query_params.append(('token', params['token']))
        if 'filters' in params:
            query_params.append(('filters', params['filters']))
        if 'sort_by_key' in params:
            query_params.append(('sort_by.key', params['sort_by_key']))
        if 'sort_by_direction' in params:
            query_params.append(('sort_by.direction', params['sort_by_direction']))
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/workflows/{id.project}/{id.domain}', 'GET', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminWorkflowList', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def recover_execution(self, body, **kwargs):
        if False:
            i = 10
            return i + 15
        'Recreates a previously-run workflow execution that will only start executing from the last known failure point. In Recover mode, users cannot change any input parameters or update the version of the execution. This is extremely useful to recover from system errors and byzantine faults like - Loss of K8s cluster, bugs in platform or instability, machine failures, downstream system failures (downstream services), or simply to recover executions that failed because of retry exhaustion and should complete if tried again. See :ref:`ref_flyteidl.admin.ExecutionRecoverRequest` for more details.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.recover_execution(body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param AdminExecutionRecoverRequest body: (required)\n        :return: AdminExecutionCreateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.recover_execution_with_http_info(body, **kwargs)
        else:
            data = self.recover_execution_with_http_info(body, **kwargs)
            return data

    def recover_execution_with_http_info(self, body, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        'Recreates a previously-run workflow execution that will only start executing from the last known failure point. In Recover mode, users cannot change any input parameters or update the version of the execution. This is extremely useful to recover from system errors and byzantine faults like - Loss of K8s cluster, bugs in platform or instability, machine failures, downstream system failures (downstream services), or simply to recover executions that failed because of retry exhaustion and should complete if tried again. See :ref:`ref_flyteidl.admin.ExecutionRecoverRequest` for more details.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.recover_execution_with_http_info(body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param AdminExecutionRecoverRequest body: (required)\n        :return: AdminExecutionCreateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['body']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method recover_execution" % key)
            params[key] = val
        del params['kwargs']
        if 'body' not in params or params['body'] is None:
            raise ValueError('Missing the required parameter `body` when calling `recover_execution`')
        collection_formats = {}
        path_params = {}
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        if 'body' in params:
            body_params = params['body']
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/executions/recover', 'POST', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminExecutionCreateResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def register_project(self, body, **kwargs):
        if False:
            i = 10
            return i + 15
        'Registers a :ref:`ref_flyteidl.admin.Project` with the Flyte deployment.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.register_project(body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param AdminProjectRegisterRequest body: (required)\n        :return: AdminProjectRegisterResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.register_project_with_http_info(body, **kwargs)
        else:
            data = self.register_project_with_http_info(body, **kwargs)
            return data

    def register_project_with_http_info(self, body, **kwargs):
        if False:
            return 10
        'Registers a :ref:`ref_flyteidl.admin.Project` with the Flyte deployment.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.register_project_with_http_info(body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param AdminProjectRegisterRequest body: (required)\n        :return: AdminProjectRegisterResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['body']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method register_project" % key)
            params[key] = val
        del params['kwargs']
        if 'body' not in params or params['body'] is None:
            raise ValueError('Missing the required parameter `body` when calling `register_project`')
        collection_formats = {}
        path_params = {}
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        if 'body' in params:
            body_params = params['body']
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/projects', 'POST', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminProjectRegisterResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def relaunch_execution(self, body, **kwargs):
        if False:
            print('Hello World!')
        'Triggers the creation of an identical :ref:`ref_flyteidl.admin.Execution`  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.relaunch_execution(body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param AdminExecutionRelaunchRequest body: (required)\n        :return: AdminExecutionCreateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.relaunch_execution_with_http_info(body, **kwargs)
        else:
            data = self.relaunch_execution_with_http_info(body, **kwargs)
            return data

    def relaunch_execution_with_http_info(self, body, **kwargs):
        if False:
            while True:
                i = 10
        'Triggers the creation of an identical :ref:`ref_flyteidl.admin.Execution`  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.relaunch_execution_with_http_info(body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param AdminExecutionRelaunchRequest body: (required)\n        :return: AdminExecutionCreateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['body']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method relaunch_execution" % key)
            params[key] = val
        del params['kwargs']
        if 'body' not in params or params['body'] is None:
            raise ValueError('Missing the required parameter `body` when calling `relaunch_execution`')
        collection_formats = {}
        path_params = {}
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        if 'body' in params:
            body_params = params['body']
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/executions/relaunch', 'POST', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminExecutionCreateResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def terminate_execution(self, id_project, id_domain, id_name, body, **kwargs):
        if False:
            while True:
                i = 10
        'Terminates an in-progress :ref:`ref_flyteidl.admin.Execution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.terminate_execution(id_project, id_domain, id_name, body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User or system provided value for the resource. (required)\n        :param AdminExecutionTerminateRequest body: (required)\n        :return: AdminExecutionTerminateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.terminate_execution_with_http_info(id_project, id_domain, id_name, body, **kwargs)
        else:
            data = self.terminate_execution_with_http_info(id_project, id_domain, id_name, body, **kwargs)
            return data

    def terminate_execution_with_http_info(self, id_project, id_domain, id_name, body, **kwargs):
        if False:
            i = 10
            return i + 15
        'Terminates an in-progress :ref:`ref_flyteidl.admin.Execution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.terminate_execution_with_http_info(id_project, id_domain, id_name, body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User or system provided value for the resource. (required)\n        :param AdminExecutionTerminateRequest body: (required)\n        :return: AdminExecutionTerminateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['id_project', 'id_domain', 'id_name', 'body']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method terminate_execution" % key)
            params[key] = val
        del params['kwargs']
        if 'id_project' not in params or params['id_project'] is None:
            raise ValueError('Missing the required parameter `id_project` when calling `terminate_execution`')
        if 'id_domain' not in params or params['id_domain'] is None:
            raise ValueError('Missing the required parameter `id_domain` when calling `terminate_execution`')
        if 'id_name' not in params or params['id_name'] is None:
            raise ValueError('Missing the required parameter `id_name` when calling `terminate_execution`')
        if 'body' not in params or params['body'] is None:
            raise ValueError('Missing the required parameter `body` when calling `terminate_execution`')
        collection_formats = {}
        path_params = {}
        if 'id_project' in params:
            path_params['id.project'] = params['id_project']
        if 'id_domain' in params:
            path_params['id.domain'] = params['id_domain']
        if 'id_name' in params:
            path_params['id.name'] = params['id_name']
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        if 'body' in params:
            body_params = params['body']
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/executions/{id.project}/{id.domain}/{id.name}', 'DELETE', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminExecutionTerminateResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def update_execution(self, id_project, id_domain, id_name, body, **kwargs):
        if False:
            while True:
                i = 10
        'Update execution belonging to project domain :ref:`ref_flyteidl.admin.Execution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.update_execution(id_project, id_domain, id_name, body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User or system provided value for the resource. (required)\n        :param AdminExecutionUpdateRequest body: (required)\n        :return: AdminExecutionUpdateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_execution_with_http_info(id_project, id_domain, id_name, body, **kwargs)
        else:
            data = self.update_execution_with_http_info(id_project, id_domain, id_name, body, **kwargs)
            return data

    def update_execution_with_http_info(self, id_project, id_domain, id_name, body, **kwargs):
        if False:
            return 10
        'Update execution belonging to project domain :ref:`ref_flyteidl.admin.Execution`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.update_execution_with_http_info(id_project, id_domain, id_name, body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User or system provided value for the resource. (required)\n        :param AdminExecutionUpdateRequest body: (required)\n        :return: AdminExecutionUpdateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['id_project', 'id_domain', 'id_name', 'body']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method update_execution" % key)
            params[key] = val
        del params['kwargs']
        if 'id_project' not in params or params['id_project'] is None:
            raise ValueError('Missing the required parameter `id_project` when calling `update_execution`')
        if 'id_domain' not in params or params['id_domain'] is None:
            raise ValueError('Missing the required parameter `id_domain` when calling `update_execution`')
        if 'id_name' not in params or params['id_name'] is None:
            raise ValueError('Missing the required parameter `id_name` when calling `update_execution`')
        if 'body' not in params or params['body'] is None:
            raise ValueError('Missing the required parameter `body` when calling `update_execution`')
        collection_formats = {}
        path_params = {}
        if 'id_project' in params:
            path_params['id.project'] = params['id_project']
        if 'id_domain' in params:
            path_params['id.domain'] = params['id_domain']
        if 'id_name' in params:
            path_params['id.name'] = params['id_name']
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        if 'body' in params:
            body_params = params['body']
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/executions/{id.project}/{id.domain}/{id.name}', 'PUT', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminExecutionUpdateResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def update_launch_plan(self, id_project, id_domain, id_name, id_version, body, **kwargs):
        if False:
            return 10
        'Updates the status of a registered :ref:`ref_flyteidl.admin.LaunchPlan`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.update_launch_plan(id_project, id_domain, id_name, id_version, body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. (required)\n        :param str id_version: Specific version of the resource. (required)\n        :param AdminLaunchPlanUpdateRequest body: (required)\n        :return: AdminLaunchPlanUpdateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_launch_plan_with_http_info(id_project, id_domain, id_name, id_version, body, **kwargs)
        else:
            data = self.update_launch_plan_with_http_info(id_project, id_domain, id_name, id_version, body, **kwargs)
            return data

    def update_launch_plan_with_http_info(self, id_project, id_domain, id_name, id_version, body, **kwargs):
        if False:
            print('Hello World!')
        'Updates the status of a registered :ref:`ref_flyteidl.admin.LaunchPlan`.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.update_launch_plan_with_http_info(id_project, id_domain, id_name, id_version, body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. (required)\n        :param str id_version: Specific version of the resource. (required)\n        :param AdminLaunchPlanUpdateRequest body: (required)\n        :return: AdminLaunchPlanUpdateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['id_project', 'id_domain', 'id_name', 'id_version', 'body']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method update_launch_plan" % key)
            params[key] = val
        del params['kwargs']
        if 'id_project' not in params or params['id_project'] is None:
            raise ValueError('Missing the required parameter `id_project` when calling `update_launch_plan`')
        if 'id_domain' not in params or params['id_domain'] is None:
            raise ValueError('Missing the required parameter `id_domain` when calling `update_launch_plan`')
        if 'id_name' not in params or params['id_name'] is None:
            raise ValueError('Missing the required parameter `id_name` when calling `update_launch_plan`')
        if 'id_version' not in params or params['id_version'] is None:
            raise ValueError('Missing the required parameter `id_version` when calling `update_launch_plan`')
        if 'body' not in params or params['body'] is None:
            raise ValueError('Missing the required parameter `body` when calling `update_launch_plan`')
        collection_formats = {}
        path_params = {}
        if 'id_project' in params:
            path_params['id.project'] = params['id_project']
        if 'id_domain' in params:
            path_params['id.domain'] = params['id_domain']
        if 'id_name' in params:
            path_params['id.name'] = params['id_name']
        if 'id_version' in params:
            path_params['id.version'] = params['id_version']
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        if 'body' in params:
            body_params = params['body']
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/launch_plans/{id.project}/{id.domain}/{id.name}/{id.version}', 'PUT', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminLaunchPlanUpdateResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def update_named_entity(self, resource_type, id_project, id_domain, id_name, body, **kwargs):
        if False:
            return 10
        "Updates a :ref:`ref_flyteidl.admin.NamedEntity` object.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.update_named_entity(resource_type, id_project, id_domain, id_name, body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str resource_type: Resource type of the metadata to update +required (required)\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like 'List API', 'Launch plans' (required)\n        :param AdminNamedEntityUpdateRequest body: (required)\n        :return: AdminNamedEntityUpdateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        "
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_named_entity_with_http_info(resource_type, id_project, id_domain, id_name, body, **kwargs)
        else:
            data = self.update_named_entity_with_http_info(resource_type, id_project, id_domain, id_name, body, **kwargs)
            return data

    def update_named_entity_with_http_info(self, resource_type, id_project, id_domain, id_name, body, **kwargs):
        if False:
            return 10
        "Updates a :ref:`ref_flyteidl.admin.NamedEntity` object.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.update_named_entity_with_http_info(resource_type, id_project, id_domain, id_name, body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str resource_type: Resource type of the metadata to update +required (required)\n        :param str id_project: Name of the project the resource belongs to. (required)\n        :param str id_domain: Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project. (required)\n        :param str id_name: User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like 'List API', 'Launch plans' (required)\n        :param AdminNamedEntityUpdateRequest body: (required)\n        :return: AdminNamedEntityUpdateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        "
        all_params = ['resource_type', 'id_project', 'id_domain', 'id_name', 'body']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method update_named_entity" % key)
            params[key] = val
        del params['kwargs']
        if 'resource_type' not in params or params['resource_type'] is None:
            raise ValueError('Missing the required parameter `resource_type` when calling `update_named_entity`')
        if 'id_project' not in params or params['id_project'] is None:
            raise ValueError('Missing the required parameter `id_project` when calling `update_named_entity`')
        if 'id_domain' not in params or params['id_domain'] is None:
            raise ValueError('Missing the required parameter `id_domain` when calling `update_named_entity`')
        if 'id_name' not in params or params['id_name'] is None:
            raise ValueError('Missing the required parameter `id_name` when calling `update_named_entity`')
        if 'body' not in params or params['body'] is None:
            raise ValueError('Missing the required parameter `body` when calling `update_named_entity`')
        collection_formats = {}
        path_params = {}
        if 'resource_type' in params:
            path_params['resource_type'] = params['resource_type']
        if 'id_project' in params:
            path_params['id.project'] = params['id_project']
        if 'id_domain' in params:
            path_params['id.domain'] = params['id_domain']
        if 'id_name' in params:
            path_params['id.name'] = params['id_name']
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        if 'body' in params:
            body_params = params['body']
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/named_entities/{resource_type}/{id.project}/{id.domain}/{id.name}', 'PUT', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminNamedEntityUpdateResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def update_project(self, id, body, **kwargs):
        if False:
            return 10
        'Updates an existing :ref:`ref_flyteidl.admin.Project`  flyteidl.admin.Project should be passed but the domains property should be empty; it will be ignored in the handler as domains cannot be updated via this API.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.update_project(id, body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id: Globally unique project name. (required)\n        :param AdminProject body: (required)\n        :return: AdminProjectUpdateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_project_with_http_info(id, body, **kwargs)
        else:
            data = self.update_project_with_http_info(id, body, **kwargs)
            return data

    def update_project_with_http_info(self, id, body, **kwargs):
        if False:
            i = 10
            return i + 15
        'Updates an existing :ref:`ref_flyteidl.admin.Project`  flyteidl.admin.Project should be passed but the domains property should be empty; it will be ignored in the handler as domains cannot be updated via this API.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.update_project_with_http_info(id, body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str id: Globally unique project name. (required)\n        :param AdminProject body: (required)\n        :return: AdminProjectUpdateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['id', 'body']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method update_project" % key)
            params[key] = val
        del params['kwargs']
        if 'id' not in params or params['id'] is None:
            raise ValueError('Missing the required parameter `id` when calling `update_project`')
        if 'body' not in params or params['body'] is None:
            raise ValueError('Missing the required parameter `body` when calling `update_project`')
        collection_formats = {}
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        if 'body' in params:
            body_params = params['body']
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/projects/{id}', 'PUT', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminProjectUpdateResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def update_project_attributes(self, attributes_project, body, **kwargs):
        if False:
            return 10
        'Creates or updates custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` at the project level  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.update_project_attributes(attributes_project, body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str attributes_project: Unique project id for which this set of attributes will be applied. (required)\n        :param AdminProjectAttributesUpdateRequest body: (required)\n        :return: AdminProjectAttributesUpdateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_project_attributes_with_http_info(attributes_project, body, **kwargs)
        else:
            data = self.update_project_attributes_with_http_info(attributes_project, body, **kwargs)
            return data

    def update_project_attributes_with_http_info(self, attributes_project, body, **kwargs):
        if False:
            while True:
                i = 10
        'Creates or updates custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` at the project level  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.update_project_attributes_with_http_info(attributes_project, body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str attributes_project: Unique project id for which this set of attributes will be applied. (required)\n        :param AdminProjectAttributesUpdateRequest body: (required)\n        :return: AdminProjectAttributesUpdateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['attributes_project', 'body']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method update_project_attributes" % key)
            params[key] = val
        del params['kwargs']
        if 'attributes_project' not in params or params['attributes_project'] is None:
            raise ValueError('Missing the required parameter `attributes_project` when calling `update_project_attributes`')
        if 'body' not in params or params['body'] is None:
            raise ValueError('Missing the required parameter `body` when calling `update_project_attributes`')
        collection_formats = {}
        path_params = {}
        if 'attributes_project' in params:
            path_params['attributes.project'] = params['attributes_project']
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        if 'body' in params:
            body_params = params['body']
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/project_attributes/{attributes.project}', 'PUT', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminProjectAttributesUpdateResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def update_project_domain_attributes(self, attributes_project, attributes_domain, body, **kwargs):
        if False:
            while True:
                i = 10
        'Creates or updates custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.update_project_domain_attributes(attributes_project, attributes_domain, body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str attributes_project: Unique project id for which this set of attributes will be applied. (required)\n        :param str attributes_domain: Unique domain id for which this set of attributes will be applied. (required)\n        :param AdminProjectDomainAttributesUpdateRequest body: (required)\n        :return: AdminProjectDomainAttributesUpdateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_project_domain_attributes_with_http_info(attributes_project, attributes_domain, body, **kwargs)
        else:
            data = self.update_project_domain_attributes_with_http_info(attributes_project, attributes_domain, body, **kwargs)
            return data

    def update_project_domain_attributes_with_http_info(self, attributes_project, attributes_domain, body, **kwargs):
        if False:
            i = 10
            return i + 15
        'Creates or updates custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.update_project_domain_attributes_with_http_info(attributes_project, attributes_domain, body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str attributes_project: Unique project id for which this set of attributes will be applied. (required)\n        :param str attributes_domain: Unique domain id for which this set of attributes will be applied. (required)\n        :param AdminProjectDomainAttributesUpdateRequest body: (required)\n        :return: AdminProjectDomainAttributesUpdateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['attributes_project', 'attributes_domain', 'body']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method update_project_domain_attributes" % key)
            params[key] = val
        del params['kwargs']
        if 'attributes_project' not in params or params['attributes_project'] is None:
            raise ValueError('Missing the required parameter `attributes_project` when calling `update_project_domain_attributes`')
        if 'attributes_domain' not in params or params['attributes_domain'] is None:
            raise ValueError('Missing the required parameter `attributes_domain` when calling `update_project_domain_attributes`')
        if 'body' not in params or params['body'] is None:
            raise ValueError('Missing the required parameter `body` when calling `update_project_domain_attributes`')
        collection_formats = {}
        path_params = {}
        if 'attributes_project' in params:
            path_params['attributes.project'] = params['attributes_project']
        if 'attributes_domain' in params:
            path_params['attributes.domain'] = params['attributes_domain']
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        if 'body' in params:
            body_params = params['body']
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/project_domain_attributes/{attributes.project}/{attributes.domain}', 'PUT', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminProjectDomainAttributesUpdateResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)

    def update_workflow_attributes(self, attributes_project, attributes_domain, attributes_workflow, body, **kwargs):
        if False:
            while True:
                i = 10
        'Creates or updates custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.update_workflow_attributes(attributes_project, attributes_domain, attributes_workflow, body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str attributes_project: Unique project id for which this set of attributes will be applied. (required)\n        :param str attributes_domain: Unique domain id for which this set of attributes will be applied. (required)\n        :param str attributes_workflow: Workflow name for which this set of attributes will be applied. (required)\n        :param AdminWorkflowAttributesUpdateRequest body: (required)\n        :return: AdminWorkflowAttributesUpdateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_workflow_attributes_with_http_info(attributes_project, attributes_domain, attributes_workflow, body, **kwargs)
        else:
            data = self.update_workflow_attributes_with_http_info(attributes_project, attributes_domain, attributes_workflow, body, **kwargs)
            return data

    def update_workflow_attributes_with_http_info(self, attributes_project, attributes_domain, attributes_workflow, body, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        'Creates or updates custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.update_workflow_attributes_with_http_info(attributes_project, attributes_domain, attributes_workflow, body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str attributes_project: Unique project id for which this set of attributes will be applied. (required)\n        :param str attributes_domain: Unique domain id for which this set of attributes will be applied. (required)\n        :param str attributes_workflow: Workflow name for which this set of attributes will be applied. (required)\n        :param AdminWorkflowAttributesUpdateRequest body: (required)\n        :return: AdminWorkflowAttributesUpdateResponse\n                 If the method is called asynchronously,\n                 returns the request thread.\n        '
        all_params = ['attributes_project', 'attributes_domain', 'attributes_workflow', 'body']
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        params = locals()
        for (key, val) in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s' to method update_workflow_attributes" % key)
            params[key] = val
        del params['kwargs']
        if 'attributes_project' not in params or params['attributes_project'] is None:
            raise ValueError('Missing the required parameter `attributes_project` when calling `update_workflow_attributes`')
        if 'attributes_domain' not in params or params['attributes_domain'] is None:
            raise ValueError('Missing the required parameter `attributes_domain` when calling `update_workflow_attributes`')
        if 'attributes_workflow' not in params or params['attributes_workflow'] is None:
            raise ValueError('Missing the required parameter `attributes_workflow` when calling `update_workflow_attributes`')
        if 'body' not in params or params['body'] is None:
            raise ValueError('Missing the required parameter `body` when calling `update_workflow_attributes`')
        collection_formats = {}
        path_params = {}
        if 'attributes_project' in params:
            path_params['attributes.project'] = params['attributes_project']
        if 'attributes_domain' in params:
            path_params['attributes.domain'] = params['attributes_domain']
        if 'attributes_workflow' in params:
            path_params['attributes.workflow'] = params['attributes_workflow']
        query_params = []
        header_params = {}
        form_params = []
        local_var_files = {}
        body_params = None
        if 'body' in params:
            body_params = params['body']
        header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
        header_params['Content-Type'] = self.api_client.select_header_content_type(['application/json'])
        auth_settings = []
        return self.api_client.call_api('/api/v1/workflow_attributes/{attributes.project}/{attributes.domain}/{attributes.workflow}', 'PUT', path_params, query_params, header_params, body=body_params, post_params=form_params, files=local_var_files, response_type='AdminWorkflowAttributesUpdateResponse', auth_settings=auth_settings, async_req=params.get('async_req'), _return_http_data_only=params.get('_return_http_data_only'), _preload_content=params.get('_preload_content', True), _request_timeout=params.get('_request_timeout'), collection_formats=collection_formats)