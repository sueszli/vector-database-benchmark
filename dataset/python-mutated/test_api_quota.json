[
    {
        "func_name": "expected_quota_list",
        "original": "@pytest.fixture(name='expected_quota_list')\ndef expected_quota_list():\n    \"\"\"The Quota were currently handle\"\"\"\n    return ['concurrentRequests', 'tokensPerProjectPerHour', 'potentiallyThresholdedRequestsPerHour']",
        "mutated": [
            "@pytest.fixture(name='expected_quota_list')\ndef expected_quota_list():\n    if False:\n        i = 10\n    'The Quota were currently handle'\n    return ['concurrentRequests', 'tokensPerProjectPerHour', 'potentiallyThresholdedRequestsPerHour']",
            "@pytest.fixture(name='expected_quota_list')\ndef expected_quota_list():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'The Quota were currently handle'\n    return ['concurrentRequests', 'tokensPerProjectPerHour', 'potentiallyThresholdedRequestsPerHour']",
            "@pytest.fixture(name='expected_quota_list')\ndef expected_quota_list():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'The Quota were currently handle'\n    return ['concurrentRequests', 'tokensPerProjectPerHour', 'potentiallyThresholdedRequestsPerHour']",
            "@pytest.fixture(name='expected_quota_list')\ndef expected_quota_list():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'The Quota were currently handle'\n    return ['concurrentRequests', 'tokensPerProjectPerHour', 'potentiallyThresholdedRequestsPerHour']",
            "@pytest.fixture(name='expected_quota_list')\ndef expected_quota_list():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'The Quota were currently handle'\n    return ['concurrentRequests', 'tokensPerProjectPerHour', 'potentiallyThresholdedRequestsPerHour']"
        ]
    },
    {
        "func_name": "test_check_initial_quota_is_empty",
        "original": "def test_check_initial_quota_is_empty():\n    \"\"\"\n    Check the initial quota property is empty (== None), but ready to be fullfield.\n    \"\"\"\n    assert not TEST_QUOTA_INSTANCE.initial_quota",
        "mutated": [
            "def test_check_initial_quota_is_empty():\n    if False:\n        i = 10\n    '\\n    Check the initial quota property is empty (== None), but ready to be fullfield.\\n    '\n    assert not TEST_QUOTA_INSTANCE.initial_quota",
            "def test_check_initial_quota_is_empty():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Check the initial quota property is empty (== None), but ready to be fullfield.\\n    '\n    assert not TEST_QUOTA_INSTANCE.initial_quota",
            "def test_check_initial_quota_is_empty():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Check the initial quota property is empty (== None), but ready to be fullfield.\\n    '\n    assert not TEST_QUOTA_INSTANCE.initial_quota",
            "def test_check_initial_quota_is_empty():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Check the initial quota property is empty (== None), but ready to be fullfield.\\n    '\n    assert not TEST_QUOTA_INSTANCE.initial_quota",
            "def test_check_initial_quota_is_empty():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Check the initial quota property is empty (== None), but ready to be fullfield.\\n    '\n    assert not TEST_QUOTA_INSTANCE.initial_quota"
        ]
    },
    {
        "func_name": "test_check_full_quota",
        "original": "@pytest.mark.parametrize(('response_quota', 'partial_quota', 'should_retry_exp', 'backoff_time_exp', 'raise_on_http_errors_exp', 'stop_iter_exp'), [({'propertyQuota': {'concurrentRequests': {'consumed': 0, 'remaining': 10}, 'tokensPerProjectPerHour': {'consumed': 1, 'remaining': 1735}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 1, 'remaining': 26}}}, False, True, None, True, False), ({'propertyQuota': {'concurrentRequests': {'consumed': 0, 'remaining': 10}, 'tokensPerProjectPerHour': {'consumed': 5, 'remaining': 955}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 3, 'remaining': 26}}}, True, True, None, True, False), ({'propertyQuota': {'concurrentRequests': {'consumed': 2, 'remaining': 8}, 'tokensPerProjectPerHour': {'consumed': 5, 'remaining': 172}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 3, 'remaining': 26}}}, True, True, 1800, False, False), ({'propertyQuota': {'concurrentRequests': {'consumed': 9, 'remaining': 1}, 'tokensPerProjectPerHour': {'consumed': 5, 'remaining': 935}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 1, 'remaining': 26}}}, True, True, 30, False, False), ({'propertyQuota': {'concurrentRequests': {'consumed': 1, 'remaining': 9}, 'tokensPerProjectPerHour': {'consumed': 5, 'remaining': 935}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 26, 'remaining': 2}}}, True, True, 1800, False, False)], ids=['Full', 'Partial', 'Running out tokensPerProjectPerHour', 'Running out concurrentRequests', 'Running out potentiallyThresholdedRequestsPerHour'])\ndef test_check_full_quota(requests_mock, expected_quota_list, response_quota, partial_quota, should_retry_exp, backoff_time_exp, raise_on_http_errors_exp, stop_iter_exp):\n    \"\"\"\n    Check the quota and prepare the initial values for subsequent comparison with subsequent response calls.\n    The default values for the scenario are expected when the quota is full.\n    \"\"\"\n    url = 'https://analyticsdata.googleapis.com/v1beta/'\n    payload = response_quota\n    requests_mock.post(url, json=payload)\n    response = requests.post(url)\n    TEST_QUOTA_INSTANCE._check_quota(response)\n    assert [quota in expected_quota_list for quota in TEST_QUOTA_INSTANCE.initial_quota.keys()]\n    if partial_quota:\n        current_quota = TEST_QUOTA_INSTANCE._get_known_quota_from_response(response.json().get('propertyQuota'))\n        assert not current_quota == TEST_QUOTA_INSTANCE.initial_quota\n    assert TEST_QUOTA_INSTANCE.should_retry is should_retry_exp\n    assert TEST_QUOTA_INSTANCE.backoff_time == backoff_time_exp\n    assert TEST_QUOTA_INSTANCE.raise_on_http_errors is raise_on_http_errors_exp\n    assert TEST_QUOTA_INSTANCE.stop_iter is stop_iter_exp",
        "mutated": [
            "@pytest.mark.parametrize(('response_quota', 'partial_quota', 'should_retry_exp', 'backoff_time_exp', 'raise_on_http_errors_exp', 'stop_iter_exp'), [({'propertyQuota': {'concurrentRequests': {'consumed': 0, 'remaining': 10}, 'tokensPerProjectPerHour': {'consumed': 1, 'remaining': 1735}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 1, 'remaining': 26}}}, False, True, None, True, False), ({'propertyQuota': {'concurrentRequests': {'consumed': 0, 'remaining': 10}, 'tokensPerProjectPerHour': {'consumed': 5, 'remaining': 955}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 3, 'remaining': 26}}}, True, True, None, True, False), ({'propertyQuota': {'concurrentRequests': {'consumed': 2, 'remaining': 8}, 'tokensPerProjectPerHour': {'consumed': 5, 'remaining': 172}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 3, 'remaining': 26}}}, True, True, 1800, False, False), ({'propertyQuota': {'concurrentRequests': {'consumed': 9, 'remaining': 1}, 'tokensPerProjectPerHour': {'consumed': 5, 'remaining': 935}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 1, 'remaining': 26}}}, True, True, 30, False, False), ({'propertyQuota': {'concurrentRequests': {'consumed': 1, 'remaining': 9}, 'tokensPerProjectPerHour': {'consumed': 5, 'remaining': 935}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 26, 'remaining': 2}}}, True, True, 1800, False, False)], ids=['Full', 'Partial', 'Running out tokensPerProjectPerHour', 'Running out concurrentRequests', 'Running out potentiallyThresholdedRequestsPerHour'])\ndef test_check_full_quota(requests_mock, expected_quota_list, response_quota, partial_quota, should_retry_exp, backoff_time_exp, raise_on_http_errors_exp, stop_iter_exp):\n    if False:\n        i = 10\n    '\\n    Check the quota and prepare the initial values for subsequent comparison with subsequent response calls.\\n    The default values for the scenario are expected when the quota is full.\\n    '\n    url = 'https://analyticsdata.googleapis.com/v1beta/'\n    payload = response_quota\n    requests_mock.post(url, json=payload)\n    response = requests.post(url)\n    TEST_QUOTA_INSTANCE._check_quota(response)\n    assert [quota in expected_quota_list for quota in TEST_QUOTA_INSTANCE.initial_quota.keys()]\n    if partial_quota:\n        current_quota = TEST_QUOTA_INSTANCE._get_known_quota_from_response(response.json().get('propertyQuota'))\n        assert not current_quota == TEST_QUOTA_INSTANCE.initial_quota\n    assert TEST_QUOTA_INSTANCE.should_retry is should_retry_exp\n    assert TEST_QUOTA_INSTANCE.backoff_time == backoff_time_exp\n    assert TEST_QUOTA_INSTANCE.raise_on_http_errors is raise_on_http_errors_exp\n    assert TEST_QUOTA_INSTANCE.stop_iter is stop_iter_exp",
            "@pytest.mark.parametrize(('response_quota', 'partial_quota', 'should_retry_exp', 'backoff_time_exp', 'raise_on_http_errors_exp', 'stop_iter_exp'), [({'propertyQuota': {'concurrentRequests': {'consumed': 0, 'remaining': 10}, 'tokensPerProjectPerHour': {'consumed': 1, 'remaining': 1735}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 1, 'remaining': 26}}}, False, True, None, True, False), ({'propertyQuota': {'concurrentRequests': {'consumed': 0, 'remaining': 10}, 'tokensPerProjectPerHour': {'consumed': 5, 'remaining': 955}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 3, 'remaining': 26}}}, True, True, None, True, False), ({'propertyQuota': {'concurrentRequests': {'consumed': 2, 'remaining': 8}, 'tokensPerProjectPerHour': {'consumed': 5, 'remaining': 172}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 3, 'remaining': 26}}}, True, True, 1800, False, False), ({'propertyQuota': {'concurrentRequests': {'consumed': 9, 'remaining': 1}, 'tokensPerProjectPerHour': {'consumed': 5, 'remaining': 935}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 1, 'remaining': 26}}}, True, True, 30, False, False), ({'propertyQuota': {'concurrentRequests': {'consumed': 1, 'remaining': 9}, 'tokensPerProjectPerHour': {'consumed': 5, 'remaining': 935}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 26, 'remaining': 2}}}, True, True, 1800, False, False)], ids=['Full', 'Partial', 'Running out tokensPerProjectPerHour', 'Running out concurrentRequests', 'Running out potentiallyThresholdedRequestsPerHour'])\ndef test_check_full_quota(requests_mock, expected_quota_list, response_quota, partial_quota, should_retry_exp, backoff_time_exp, raise_on_http_errors_exp, stop_iter_exp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Check the quota and prepare the initial values for subsequent comparison with subsequent response calls.\\n    The default values for the scenario are expected when the quota is full.\\n    '\n    url = 'https://analyticsdata.googleapis.com/v1beta/'\n    payload = response_quota\n    requests_mock.post(url, json=payload)\n    response = requests.post(url)\n    TEST_QUOTA_INSTANCE._check_quota(response)\n    assert [quota in expected_quota_list for quota in TEST_QUOTA_INSTANCE.initial_quota.keys()]\n    if partial_quota:\n        current_quota = TEST_QUOTA_INSTANCE._get_known_quota_from_response(response.json().get('propertyQuota'))\n        assert not current_quota == TEST_QUOTA_INSTANCE.initial_quota\n    assert TEST_QUOTA_INSTANCE.should_retry is should_retry_exp\n    assert TEST_QUOTA_INSTANCE.backoff_time == backoff_time_exp\n    assert TEST_QUOTA_INSTANCE.raise_on_http_errors is raise_on_http_errors_exp\n    assert TEST_QUOTA_INSTANCE.stop_iter is stop_iter_exp",
            "@pytest.mark.parametrize(('response_quota', 'partial_quota', 'should_retry_exp', 'backoff_time_exp', 'raise_on_http_errors_exp', 'stop_iter_exp'), [({'propertyQuota': {'concurrentRequests': {'consumed': 0, 'remaining': 10}, 'tokensPerProjectPerHour': {'consumed': 1, 'remaining': 1735}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 1, 'remaining': 26}}}, False, True, None, True, False), ({'propertyQuota': {'concurrentRequests': {'consumed': 0, 'remaining': 10}, 'tokensPerProjectPerHour': {'consumed': 5, 'remaining': 955}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 3, 'remaining': 26}}}, True, True, None, True, False), ({'propertyQuota': {'concurrentRequests': {'consumed': 2, 'remaining': 8}, 'tokensPerProjectPerHour': {'consumed': 5, 'remaining': 172}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 3, 'remaining': 26}}}, True, True, 1800, False, False), ({'propertyQuota': {'concurrentRequests': {'consumed': 9, 'remaining': 1}, 'tokensPerProjectPerHour': {'consumed': 5, 'remaining': 935}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 1, 'remaining': 26}}}, True, True, 30, False, False), ({'propertyQuota': {'concurrentRequests': {'consumed': 1, 'remaining': 9}, 'tokensPerProjectPerHour': {'consumed': 5, 'remaining': 935}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 26, 'remaining': 2}}}, True, True, 1800, False, False)], ids=['Full', 'Partial', 'Running out tokensPerProjectPerHour', 'Running out concurrentRequests', 'Running out potentiallyThresholdedRequestsPerHour'])\ndef test_check_full_quota(requests_mock, expected_quota_list, response_quota, partial_quota, should_retry_exp, backoff_time_exp, raise_on_http_errors_exp, stop_iter_exp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Check the quota and prepare the initial values for subsequent comparison with subsequent response calls.\\n    The default values for the scenario are expected when the quota is full.\\n    '\n    url = 'https://analyticsdata.googleapis.com/v1beta/'\n    payload = response_quota\n    requests_mock.post(url, json=payload)\n    response = requests.post(url)\n    TEST_QUOTA_INSTANCE._check_quota(response)\n    assert [quota in expected_quota_list for quota in TEST_QUOTA_INSTANCE.initial_quota.keys()]\n    if partial_quota:\n        current_quota = TEST_QUOTA_INSTANCE._get_known_quota_from_response(response.json().get('propertyQuota'))\n        assert not current_quota == TEST_QUOTA_INSTANCE.initial_quota\n    assert TEST_QUOTA_INSTANCE.should_retry is should_retry_exp\n    assert TEST_QUOTA_INSTANCE.backoff_time == backoff_time_exp\n    assert TEST_QUOTA_INSTANCE.raise_on_http_errors is raise_on_http_errors_exp\n    assert TEST_QUOTA_INSTANCE.stop_iter is stop_iter_exp",
            "@pytest.mark.parametrize(('response_quota', 'partial_quota', 'should_retry_exp', 'backoff_time_exp', 'raise_on_http_errors_exp', 'stop_iter_exp'), [({'propertyQuota': {'concurrentRequests': {'consumed': 0, 'remaining': 10}, 'tokensPerProjectPerHour': {'consumed': 1, 'remaining': 1735}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 1, 'remaining': 26}}}, False, True, None, True, False), ({'propertyQuota': {'concurrentRequests': {'consumed': 0, 'remaining': 10}, 'tokensPerProjectPerHour': {'consumed': 5, 'remaining': 955}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 3, 'remaining': 26}}}, True, True, None, True, False), ({'propertyQuota': {'concurrentRequests': {'consumed': 2, 'remaining': 8}, 'tokensPerProjectPerHour': {'consumed': 5, 'remaining': 172}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 3, 'remaining': 26}}}, True, True, 1800, False, False), ({'propertyQuota': {'concurrentRequests': {'consumed': 9, 'remaining': 1}, 'tokensPerProjectPerHour': {'consumed': 5, 'remaining': 935}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 1, 'remaining': 26}}}, True, True, 30, False, False), ({'propertyQuota': {'concurrentRequests': {'consumed': 1, 'remaining': 9}, 'tokensPerProjectPerHour': {'consumed': 5, 'remaining': 935}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 26, 'remaining': 2}}}, True, True, 1800, False, False)], ids=['Full', 'Partial', 'Running out tokensPerProjectPerHour', 'Running out concurrentRequests', 'Running out potentiallyThresholdedRequestsPerHour'])\ndef test_check_full_quota(requests_mock, expected_quota_list, response_quota, partial_quota, should_retry_exp, backoff_time_exp, raise_on_http_errors_exp, stop_iter_exp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Check the quota and prepare the initial values for subsequent comparison with subsequent response calls.\\n    The default values for the scenario are expected when the quota is full.\\n    '\n    url = 'https://analyticsdata.googleapis.com/v1beta/'\n    payload = response_quota\n    requests_mock.post(url, json=payload)\n    response = requests.post(url)\n    TEST_QUOTA_INSTANCE._check_quota(response)\n    assert [quota in expected_quota_list for quota in TEST_QUOTA_INSTANCE.initial_quota.keys()]\n    if partial_quota:\n        current_quota = TEST_QUOTA_INSTANCE._get_known_quota_from_response(response.json().get('propertyQuota'))\n        assert not current_quota == TEST_QUOTA_INSTANCE.initial_quota\n    assert TEST_QUOTA_INSTANCE.should_retry is should_retry_exp\n    assert TEST_QUOTA_INSTANCE.backoff_time == backoff_time_exp\n    assert TEST_QUOTA_INSTANCE.raise_on_http_errors is raise_on_http_errors_exp\n    assert TEST_QUOTA_INSTANCE.stop_iter is stop_iter_exp",
            "@pytest.mark.parametrize(('response_quota', 'partial_quota', 'should_retry_exp', 'backoff_time_exp', 'raise_on_http_errors_exp', 'stop_iter_exp'), [({'propertyQuota': {'concurrentRequests': {'consumed': 0, 'remaining': 10}, 'tokensPerProjectPerHour': {'consumed': 1, 'remaining': 1735}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 1, 'remaining': 26}}}, False, True, None, True, False), ({'propertyQuota': {'concurrentRequests': {'consumed': 0, 'remaining': 10}, 'tokensPerProjectPerHour': {'consumed': 5, 'remaining': 955}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 3, 'remaining': 26}}}, True, True, None, True, False), ({'propertyQuota': {'concurrentRequests': {'consumed': 2, 'remaining': 8}, 'tokensPerProjectPerHour': {'consumed': 5, 'remaining': 172}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 3, 'remaining': 26}}}, True, True, 1800, False, False), ({'propertyQuota': {'concurrentRequests': {'consumed': 9, 'remaining': 1}, 'tokensPerProjectPerHour': {'consumed': 5, 'remaining': 935}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 1, 'remaining': 26}}}, True, True, 30, False, False), ({'propertyQuota': {'concurrentRequests': {'consumed': 1, 'remaining': 9}, 'tokensPerProjectPerHour': {'consumed': 5, 'remaining': 935}, 'potentiallyThresholdedRequestsPerHour': {'consumed': 26, 'remaining': 2}}}, True, True, 1800, False, False)], ids=['Full', 'Partial', 'Running out tokensPerProjectPerHour', 'Running out concurrentRequests', 'Running out potentiallyThresholdedRequestsPerHour'])\ndef test_check_full_quota(requests_mock, expected_quota_list, response_quota, partial_quota, should_retry_exp, backoff_time_exp, raise_on_http_errors_exp, stop_iter_exp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Check the quota and prepare the initial values for subsequent comparison with subsequent response calls.\\n    The default values for the scenario are expected when the quota is full.\\n    '\n    url = 'https://analyticsdata.googleapis.com/v1beta/'\n    payload = response_quota\n    requests_mock.post(url, json=payload)\n    response = requests.post(url)\n    TEST_QUOTA_INSTANCE._check_quota(response)\n    assert [quota in expected_quota_list for quota in TEST_QUOTA_INSTANCE.initial_quota.keys()]\n    if partial_quota:\n        current_quota = TEST_QUOTA_INSTANCE._get_known_quota_from_response(response.json().get('propertyQuota'))\n        assert not current_quota == TEST_QUOTA_INSTANCE.initial_quota\n    assert TEST_QUOTA_INSTANCE.should_retry is should_retry_exp\n    assert TEST_QUOTA_INSTANCE.backoff_time == backoff_time_exp\n    assert TEST_QUOTA_INSTANCE.raise_on_http_errors is raise_on_http_errors_exp\n    assert TEST_QUOTA_INSTANCE.stop_iter is stop_iter_exp"
        ]
    }
]