[
    {
        "func_name": "pytest_generate_tests",
        "original": "def pytest_generate_tests(metafunc):\n    bsz_rng = [1, 4]\n    if 'fargs' in metafunc.fixturenames:\n        fargs = []\n        if metafunc.config.option.all:\n            seq_rng = [2, 3, 4]\n            inp_rng = [3, 5, 10]\n            out_rng = [3, 5, 10, 1152]\n        else:\n            seq_rng = [3]\n            inp_rng = [5]\n            out_rng = [10, 1152]\n        fargs = itt.product(seq_rng, inp_rng, out_rng, bsz_rng)\n        metafunc.parametrize('fargs', fargs)",
        "mutated": [
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n    bsz_rng = [1, 4]\n    if 'fargs' in metafunc.fixturenames:\n        fargs = []\n        if metafunc.config.option.all:\n            seq_rng = [2, 3, 4]\n            inp_rng = [3, 5, 10]\n            out_rng = [3, 5, 10, 1152]\n        else:\n            seq_rng = [3]\n            inp_rng = [5]\n            out_rng = [10, 1152]\n        fargs = itt.product(seq_rng, inp_rng, out_rng, bsz_rng)\n        metafunc.parametrize('fargs', fargs)",
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    bsz_rng = [1, 4]\n    if 'fargs' in metafunc.fixturenames:\n        fargs = []\n        if metafunc.config.option.all:\n            seq_rng = [2, 3, 4]\n            inp_rng = [3, 5, 10]\n            out_rng = [3, 5, 10, 1152]\n        else:\n            seq_rng = [3]\n            inp_rng = [5]\n            out_rng = [10, 1152]\n        fargs = itt.product(seq_rng, inp_rng, out_rng, bsz_rng)\n        metafunc.parametrize('fargs', fargs)",
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    bsz_rng = [1, 4]\n    if 'fargs' in metafunc.fixturenames:\n        fargs = []\n        if metafunc.config.option.all:\n            seq_rng = [2, 3, 4]\n            inp_rng = [3, 5, 10]\n            out_rng = [3, 5, 10, 1152]\n        else:\n            seq_rng = [3]\n            inp_rng = [5]\n            out_rng = [10, 1152]\n        fargs = itt.product(seq_rng, inp_rng, out_rng, bsz_rng)\n        metafunc.parametrize('fargs', fargs)",
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    bsz_rng = [1, 4]\n    if 'fargs' in metafunc.fixturenames:\n        fargs = []\n        if metafunc.config.option.all:\n            seq_rng = [2, 3, 4]\n            inp_rng = [3, 5, 10]\n            out_rng = [3, 5, 10, 1152]\n        else:\n            seq_rng = [3]\n            inp_rng = [5]\n            out_rng = [10, 1152]\n        fargs = itt.product(seq_rng, inp_rng, out_rng, bsz_rng)\n        metafunc.parametrize('fargs', fargs)",
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    bsz_rng = [1, 4]\n    if 'fargs' in metafunc.fixturenames:\n        fargs = []\n        if metafunc.config.option.all:\n            seq_rng = [2, 3, 4]\n            inp_rng = [3, 5, 10]\n            out_rng = [3, 5, 10, 1152]\n        else:\n            seq_rng = [3]\n            inp_rng = [5]\n            out_rng = [10, 1152]\n        fargs = itt.product(seq_rng, inp_rng, out_rng, bsz_rng)\n        metafunc.parametrize('fargs', fargs)"
        ]
    },
    {
        "func_name": "test_biRNN_fprop_rnn",
        "original": "def test_biRNN_fprop_rnn(backend_default, fargs, deltas_buffer):\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    in_shape = (input_size, seq_len)\n    out_shape = (hidden_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    init_glorot = GlorotUniform()\n    birnn = BiRNN(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    birnn.configure(in_shape)\n    birnn.prev_layer = True\n    birnn.allocate()\n    init_glorot = GlorotUniform()\n    rnn = Recurrent(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    rnn.configure(in_shape)\n    rnn.prev_layer = True\n    rnn.allocate()\n    nout = hidden_size\n    birnn.W_input_b[:] = birnn.W_input_f\n    birnn.W_recur_b[:] = birnn.W_recur_f\n    birnn.b_b[:] = birnn.b_f\n    birnn.dW[:] = 0\n    rnn.W_input[:] = birnn.W_input_f\n    rnn.W_recur[:] = birnn.W_recur_f\n    rnn.b[:] = birnn.b_f\n    rnn.dW[:] = 0\n    lr = np.random.random((input_size, seq_len * batch_size))\n    lr_rev = list(reversed(get_steps(lr.copy(), in_shape)))\n    rl = con(lr_rev, axis=1)\n    inp_lr = birnn.be.array(lr)\n    inp_rl = birnn.be.array(rl)\n    inp_rnn = rnn.be.array(lr)\n    out_lr = birnn.fprop(inp_lr).get().copy()\n    birnn.h_buffer[:] = 0\n    out_rl = birnn.fprop(inp_rl).get()\n    out_rnn = rnn.fprop(inp_rnn).get().copy()\n    out_lr_f_s = get_steps(out_lr[:nout], out_shape)\n    out_lr_b_s = get_steps(out_lr[nout:], out_shape)\n    out_rl_f_s = get_steps(out_rl[:nout], out_shape)\n    out_rl_b_s = get_steps(out_rl[nout:], out_shape)\n    out_rnn_s = get_steps(out_rnn, out_shape)\n    for (x_rnn, x_f, x_b, y_f, y_b) in zip(out_rnn_s, out_lr_f_s, out_lr_b_s, reversed(out_rl_f_s), reversed(out_rl_b_s)):\n        assert allclose_with_out(x_f, y_b, rtol=0.0, atol=1e-05)\n        assert allclose_with_out(x_b, y_f, rtol=0.0, atol=1e-05)\n        assert allclose_with_out(x_rnn, x_f, rtol=0.0, atol=1e-05)\n        assert allclose_with_out(x_rnn, y_b, rtol=0.0, atol=1e-05)",
        "mutated": [
            "def test_biRNN_fprop_rnn(backend_default, fargs, deltas_buffer):\n    if False:\n        i = 10\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    in_shape = (input_size, seq_len)\n    out_shape = (hidden_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    init_glorot = GlorotUniform()\n    birnn = BiRNN(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    birnn.configure(in_shape)\n    birnn.prev_layer = True\n    birnn.allocate()\n    init_glorot = GlorotUniform()\n    rnn = Recurrent(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    rnn.configure(in_shape)\n    rnn.prev_layer = True\n    rnn.allocate()\n    nout = hidden_size\n    birnn.W_input_b[:] = birnn.W_input_f\n    birnn.W_recur_b[:] = birnn.W_recur_f\n    birnn.b_b[:] = birnn.b_f\n    birnn.dW[:] = 0\n    rnn.W_input[:] = birnn.W_input_f\n    rnn.W_recur[:] = birnn.W_recur_f\n    rnn.b[:] = birnn.b_f\n    rnn.dW[:] = 0\n    lr = np.random.random((input_size, seq_len * batch_size))\n    lr_rev = list(reversed(get_steps(lr.copy(), in_shape)))\n    rl = con(lr_rev, axis=1)\n    inp_lr = birnn.be.array(lr)\n    inp_rl = birnn.be.array(rl)\n    inp_rnn = rnn.be.array(lr)\n    out_lr = birnn.fprop(inp_lr).get().copy()\n    birnn.h_buffer[:] = 0\n    out_rl = birnn.fprop(inp_rl).get()\n    out_rnn = rnn.fprop(inp_rnn).get().copy()\n    out_lr_f_s = get_steps(out_lr[:nout], out_shape)\n    out_lr_b_s = get_steps(out_lr[nout:], out_shape)\n    out_rl_f_s = get_steps(out_rl[:nout], out_shape)\n    out_rl_b_s = get_steps(out_rl[nout:], out_shape)\n    out_rnn_s = get_steps(out_rnn, out_shape)\n    for (x_rnn, x_f, x_b, y_f, y_b) in zip(out_rnn_s, out_lr_f_s, out_lr_b_s, reversed(out_rl_f_s), reversed(out_rl_b_s)):\n        assert allclose_with_out(x_f, y_b, rtol=0.0, atol=1e-05)\n        assert allclose_with_out(x_b, y_f, rtol=0.0, atol=1e-05)\n        assert allclose_with_out(x_rnn, x_f, rtol=0.0, atol=1e-05)\n        assert allclose_with_out(x_rnn, y_b, rtol=0.0, atol=1e-05)",
            "def test_biRNN_fprop_rnn(backend_default, fargs, deltas_buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    in_shape = (input_size, seq_len)\n    out_shape = (hidden_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    init_glorot = GlorotUniform()\n    birnn = BiRNN(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    birnn.configure(in_shape)\n    birnn.prev_layer = True\n    birnn.allocate()\n    init_glorot = GlorotUniform()\n    rnn = Recurrent(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    rnn.configure(in_shape)\n    rnn.prev_layer = True\n    rnn.allocate()\n    nout = hidden_size\n    birnn.W_input_b[:] = birnn.W_input_f\n    birnn.W_recur_b[:] = birnn.W_recur_f\n    birnn.b_b[:] = birnn.b_f\n    birnn.dW[:] = 0\n    rnn.W_input[:] = birnn.W_input_f\n    rnn.W_recur[:] = birnn.W_recur_f\n    rnn.b[:] = birnn.b_f\n    rnn.dW[:] = 0\n    lr = np.random.random((input_size, seq_len * batch_size))\n    lr_rev = list(reversed(get_steps(lr.copy(), in_shape)))\n    rl = con(lr_rev, axis=1)\n    inp_lr = birnn.be.array(lr)\n    inp_rl = birnn.be.array(rl)\n    inp_rnn = rnn.be.array(lr)\n    out_lr = birnn.fprop(inp_lr).get().copy()\n    birnn.h_buffer[:] = 0\n    out_rl = birnn.fprop(inp_rl).get()\n    out_rnn = rnn.fprop(inp_rnn).get().copy()\n    out_lr_f_s = get_steps(out_lr[:nout], out_shape)\n    out_lr_b_s = get_steps(out_lr[nout:], out_shape)\n    out_rl_f_s = get_steps(out_rl[:nout], out_shape)\n    out_rl_b_s = get_steps(out_rl[nout:], out_shape)\n    out_rnn_s = get_steps(out_rnn, out_shape)\n    for (x_rnn, x_f, x_b, y_f, y_b) in zip(out_rnn_s, out_lr_f_s, out_lr_b_s, reversed(out_rl_f_s), reversed(out_rl_b_s)):\n        assert allclose_with_out(x_f, y_b, rtol=0.0, atol=1e-05)\n        assert allclose_with_out(x_b, y_f, rtol=0.0, atol=1e-05)\n        assert allclose_with_out(x_rnn, x_f, rtol=0.0, atol=1e-05)\n        assert allclose_with_out(x_rnn, y_b, rtol=0.0, atol=1e-05)",
            "def test_biRNN_fprop_rnn(backend_default, fargs, deltas_buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    in_shape = (input_size, seq_len)\n    out_shape = (hidden_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    init_glorot = GlorotUniform()\n    birnn = BiRNN(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    birnn.configure(in_shape)\n    birnn.prev_layer = True\n    birnn.allocate()\n    init_glorot = GlorotUniform()\n    rnn = Recurrent(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    rnn.configure(in_shape)\n    rnn.prev_layer = True\n    rnn.allocate()\n    nout = hidden_size\n    birnn.W_input_b[:] = birnn.W_input_f\n    birnn.W_recur_b[:] = birnn.W_recur_f\n    birnn.b_b[:] = birnn.b_f\n    birnn.dW[:] = 0\n    rnn.W_input[:] = birnn.W_input_f\n    rnn.W_recur[:] = birnn.W_recur_f\n    rnn.b[:] = birnn.b_f\n    rnn.dW[:] = 0\n    lr = np.random.random((input_size, seq_len * batch_size))\n    lr_rev = list(reversed(get_steps(lr.copy(), in_shape)))\n    rl = con(lr_rev, axis=1)\n    inp_lr = birnn.be.array(lr)\n    inp_rl = birnn.be.array(rl)\n    inp_rnn = rnn.be.array(lr)\n    out_lr = birnn.fprop(inp_lr).get().copy()\n    birnn.h_buffer[:] = 0\n    out_rl = birnn.fprop(inp_rl).get()\n    out_rnn = rnn.fprop(inp_rnn).get().copy()\n    out_lr_f_s = get_steps(out_lr[:nout], out_shape)\n    out_lr_b_s = get_steps(out_lr[nout:], out_shape)\n    out_rl_f_s = get_steps(out_rl[:nout], out_shape)\n    out_rl_b_s = get_steps(out_rl[nout:], out_shape)\n    out_rnn_s = get_steps(out_rnn, out_shape)\n    for (x_rnn, x_f, x_b, y_f, y_b) in zip(out_rnn_s, out_lr_f_s, out_lr_b_s, reversed(out_rl_f_s), reversed(out_rl_b_s)):\n        assert allclose_with_out(x_f, y_b, rtol=0.0, atol=1e-05)\n        assert allclose_with_out(x_b, y_f, rtol=0.0, atol=1e-05)\n        assert allclose_with_out(x_rnn, x_f, rtol=0.0, atol=1e-05)\n        assert allclose_with_out(x_rnn, y_b, rtol=0.0, atol=1e-05)",
            "def test_biRNN_fprop_rnn(backend_default, fargs, deltas_buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    in_shape = (input_size, seq_len)\n    out_shape = (hidden_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    init_glorot = GlorotUniform()\n    birnn = BiRNN(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    birnn.configure(in_shape)\n    birnn.prev_layer = True\n    birnn.allocate()\n    init_glorot = GlorotUniform()\n    rnn = Recurrent(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    rnn.configure(in_shape)\n    rnn.prev_layer = True\n    rnn.allocate()\n    nout = hidden_size\n    birnn.W_input_b[:] = birnn.W_input_f\n    birnn.W_recur_b[:] = birnn.W_recur_f\n    birnn.b_b[:] = birnn.b_f\n    birnn.dW[:] = 0\n    rnn.W_input[:] = birnn.W_input_f\n    rnn.W_recur[:] = birnn.W_recur_f\n    rnn.b[:] = birnn.b_f\n    rnn.dW[:] = 0\n    lr = np.random.random((input_size, seq_len * batch_size))\n    lr_rev = list(reversed(get_steps(lr.copy(), in_shape)))\n    rl = con(lr_rev, axis=1)\n    inp_lr = birnn.be.array(lr)\n    inp_rl = birnn.be.array(rl)\n    inp_rnn = rnn.be.array(lr)\n    out_lr = birnn.fprop(inp_lr).get().copy()\n    birnn.h_buffer[:] = 0\n    out_rl = birnn.fprop(inp_rl).get()\n    out_rnn = rnn.fprop(inp_rnn).get().copy()\n    out_lr_f_s = get_steps(out_lr[:nout], out_shape)\n    out_lr_b_s = get_steps(out_lr[nout:], out_shape)\n    out_rl_f_s = get_steps(out_rl[:nout], out_shape)\n    out_rl_b_s = get_steps(out_rl[nout:], out_shape)\n    out_rnn_s = get_steps(out_rnn, out_shape)\n    for (x_rnn, x_f, x_b, y_f, y_b) in zip(out_rnn_s, out_lr_f_s, out_lr_b_s, reversed(out_rl_f_s), reversed(out_rl_b_s)):\n        assert allclose_with_out(x_f, y_b, rtol=0.0, atol=1e-05)\n        assert allclose_with_out(x_b, y_f, rtol=0.0, atol=1e-05)\n        assert allclose_with_out(x_rnn, x_f, rtol=0.0, atol=1e-05)\n        assert allclose_with_out(x_rnn, y_b, rtol=0.0, atol=1e-05)",
            "def test_biRNN_fprop_rnn(backend_default, fargs, deltas_buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    in_shape = (input_size, seq_len)\n    out_shape = (hidden_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    init_glorot = GlorotUniform()\n    birnn = BiRNN(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    birnn.configure(in_shape)\n    birnn.prev_layer = True\n    birnn.allocate()\n    init_glorot = GlorotUniform()\n    rnn = Recurrent(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    rnn.configure(in_shape)\n    rnn.prev_layer = True\n    rnn.allocate()\n    nout = hidden_size\n    birnn.W_input_b[:] = birnn.W_input_f\n    birnn.W_recur_b[:] = birnn.W_recur_f\n    birnn.b_b[:] = birnn.b_f\n    birnn.dW[:] = 0\n    rnn.W_input[:] = birnn.W_input_f\n    rnn.W_recur[:] = birnn.W_recur_f\n    rnn.b[:] = birnn.b_f\n    rnn.dW[:] = 0\n    lr = np.random.random((input_size, seq_len * batch_size))\n    lr_rev = list(reversed(get_steps(lr.copy(), in_shape)))\n    rl = con(lr_rev, axis=1)\n    inp_lr = birnn.be.array(lr)\n    inp_rl = birnn.be.array(rl)\n    inp_rnn = rnn.be.array(lr)\n    out_lr = birnn.fprop(inp_lr).get().copy()\n    birnn.h_buffer[:] = 0\n    out_rl = birnn.fprop(inp_rl).get()\n    out_rnn = rnn.fprop(inp_rnn).get().copy()\n    out_lr_f_s = get_steps(out_lr[:nout], out_shape)\n    out_lr_b_s = get_steps(out_lr[nout:], out_shape)\n    out_rl_f_s = get_steps(out_rl[:nout], out_shape)\n    out_rl_b_s = get_steps(out_rl[nout:], out_shape)\n    out_rnn_s = get_steps(out_rnn, out_shape)\n    for (x_rnn, x_f, x_b, y_f, y_b) in zip(out_rnn_s, out_lr_f_s, out_lr_b_s, reversed(out_rl_f_s), reversed(out_rl_b_s)):\n        assert allclose_with_out(x_f, y_b, rtol=0.0, atol=1e-05)\n        assert allclose_with_out(x_b, y_f, rtol=0.0, atol=1e-05)\n        assert allclose_with_out(x_rnn, x_f, rtol=0.0, atol=1e-05)\n        assert allclose_with_out(x_rnn, y_b, rtol=0.0, atol=1e-05)"
        ]
    },
    {
        "func_name": "test_biRNN_fprop",
        "original": "def test_biRNN_fprop(backend_default, fargs):\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    in_shape = (input_size, seq_len)\n    out_shape = (hidden_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    init_glorot = GlorotUniform()\n    birnn = BiRNN(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    birnn.configure(in_shape)\n    birnn.prev_layer = True\n    birnn.allocate()\n    nout = hidden_size\n    birnn.W_input_b[:] = birnn.W_input_f\n    birnn.W_recur_b[:] = birnn.W_recur_f\n    birnn.b_b[:] = birnn.b_f\n    birnn.dW[:] = 0\n    lr = np.random.random((input_size, seq_len * batch_size))\n    lr_rev = list(reversed(get_steps(lr.copy(), in_shape)))\n    rl = con(lr_rev, axis=1)\n    inp_lr = birnn.be.array(lr)\n    inp_rl = birnn.be.array(rl)\n    out_lr = birnn.fprop(inp_lr).get().copy()\n    birnn.h_buffer[:] = 0\n    out_rl = birnn.fprop(inp_rl).get().copy()\n    out_lr_f_s = get_steps(out_lr[:nout], out_shape)\n    out_lr_b_s = get_steps(out_lr[nout:], out_shape)\n    out_rl_f_s = get_steps(out_rl[:nout], out_shape)\n    out_rl_b_s = get_steps(out_rl[nout:], out_shape)\n    for (x_f, x_b, y_f, y_b) in zip(out_lr_f_s, out_lr_b_s, reversed(out_rl_f_s), reversed(out_rl_b_s)):\n        assert allclose_with_out(x_f, y_b, rtol=0.0, atol=1e-05)\n        assert allclose_with_out(x_b, y_f, rtol=0.0, atol=1e-05)",
        "mutated": [
            "def test_biRNN_fprop(backend_default, fargs):\n    if False:\n        i = 10\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    in_shape = (input_size, seq_len)\n    out_shape = (hidden_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    init_glorot = GlorotUniform()\n    birnn = BiRNN(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    birnn.configure(in_shape)\n    birnn.prev_layer = True\n    birnn.allocate()\n    nout = hidden_size\n    birnn.W_input_b[:] = birnn.W_input_f\n    birnn.W_recur_b[:] = birnn.W_recur_f\n    birnn.b_b[:] = birnn.b_f\n    birnn.dW[:] = 0\n    lr = np.random.random((input_size, seq_len * batch_size))\n    lr_rev = list(reversed(get_steps(lr.copy(), in_shape)))\n    rl = con(lr_rev, axis=1)\n    inp_lr = birnn.be.array(lr)\n    inp_rl = birnn.be.array(rl)\n    out_lr = birnn.fprop(inp_lr).get().copy()\n    birnn.h_buffer[:] = 0\n    out_rl = birnn.fprop(inp_rl).get().copy()\n    out_lr_f_s = get_steps(out_lr[:nout], out_shape)\n    out_lr_b_s = get_steps(out_lr[nout:], out_shape)\n    out_rl_f_s = get_steps(out_rl[:nout], out_shape)\n    out_rl_b_s = get_steps(out_rl[nout:], out_shape)\n    for (x_f, x_b, y_f, y_b) in zip(out_lr_f_s, out_lr_b_s, reversed(out_rl_f_s), reversed(out_rl_b_s)):\n        assert allclose_with_out(x_f, y_b, rtol=0.0, atol=1e-05)\n        assert allclose_with_out(x_b, y_f, rtol=0.0, atol=1e-05)",
            "def test_biRNN_fprop(backend_default, fargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    in_shape = (input_size, seq_len)\n    out_shape = (hidden_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    init_glorot = GlorotUniform()\n    birnn = BiRNN(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    birnn.configure(in_shape)\n    birnn.prev_layer = True\n    birnn.allocate()\n    nout = hidden_size\n    birnn.W_input_b[:] = birnn.W_input_f\n    birnn.W_recur_b[:] = birnn.W_recur_f\n    birnn.b_b[:] = birnn.b_f\n    birnn.dW[:] = 0\n    lr = np.random.random((input_size, seq_len * batch_size))\n    lr_rev = list(reversed(get_steps(lr.copy(), in_shape)))\n    rl = con(lr_rev, axis=1)\n    inp_lr = birnn.be.array(lr)\n    inp_rl = birnn.be.array(rl)\n    out_lr = birnn.fprop(inp_lr).get().copy()\n    birnn.h_buffer[:] = 0\n    out_rl = birnn.fprop(inp_rl).get().copy()\n    out_lr_f_s = get_steps(out_lr[:nout], out_shape)\n    out_lr_b_s = get_steps(out_lr[nout:], out_shape)\n    out_rl_f_s = get_steps(out_rl[:nout], out_shape)\n    out_rl_b_s = get_steps(out_rl[nout:], out_shape)\n    for (x_f, x_b, y_f, y_b) in zip(out_lr_f_s, out_lr_b_s, reversed(out_rl_f_s), reversed(out_rl_b_s)):\n        assert allclose_with_out(x_f, y_b, rtol=0.0, atol=1e-05)\n        assert allclose_with_out(x_b, y_f, rtol=0.0, atol=1e-05)",
            "def test_biRNN_fprop(backend_default, fargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    in_shape = (input_size, seq_len)\n    out_shape = (hidden_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    init_glorot = GlorotUniform()\n    birnn = BiRNN(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    birnn.configure(in_shape)\n    birnn.prev_layer = True\n    birnn.allocate()\n    nout = hidden_size\n    birnn.W_input_b[:] = birnn.W_input_f\n    birnn.W_recur_b[:] = birnn.W_recur_f\n    birnn.b_b[:] = birnn.b_f\n    birnn.dW[:] = 0\n    lr = np.random.random((input_size, seq_len * batch_size))\n    lr_rev = list(reversed(get_steps(lr.copy(), in_shape)))\n    rl = con(lr_rev, axis=1)\n    inp_lr = birnn.be.array(lr)\n    inp_rl = birnn.be.array(rl)\n    out_lr = birnn.fprop(inp_lr).get().copy()\n    birnn.h_buffer[:] = 0\n    out_rl = birnn.fprop(inp_rl).get().copy()\n    out_lr_f_s = get_steps(out_lr[:nout], out_shape)\n    out_lr_b_s = get_steps(out_lr[nout:], out_shape)\n    out_rl_f_s = get_steps(out_rl[:nout], out_shape)\n    out_rl_b_s = get_steps(out_rl[nout:], out_shape)\n    for (x_f, x_b, y_f, y_b) in zip(out_lr_f_s, out_lr_b_s, reversed(out_rl_f_s), reversed(out_rl_b_s)):\n        assert allclose_with_out(x_f, y_b, rtol=0.0, atol=1e-05)\n        assert allclose_with_out(x_b, y_f, rtol=0.0, atol=1e-05)",
            "def test_biRNN_fprop(backend_default, fargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    in_shape = (input_size, seq_len)\n    out_shape = (hidden_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    init_glorot = GlorotUniform()\n    birnn = BiRNN(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    birnn.configure(in_shape)\n    birnn.prev_layer = True\n    birnn.allocate()\n    nout = hidden_size\n    birnn.W_input_b[:] = birnn.W_input_f\n    birnn.W_recur_b[:] = birnn.W_recur_f\n    birnn.b_b[:] = birnn.b_f\n    birnn.dW[:] = 0\n    lr = np.random.random((input_size, seq_len * batch_size))\n    lr_rev = list(reversed(get_steps(lr.copy(), in_shape)))\n    rl = con(lr_rev, axis=1)\n    inp_lr = birnn.be.array(lr)\n    inp_rl = birnn.be.array(rl)\n    out_lr = birnn.fprop(inp_lr).get().copy()\n    birnn.h_buffer[:] = 0\n    out_rl = birnn.fprop(inp_rl).get().copy()\n    out_lr_f_s = get_steps(out_lr[:nout], out_shape)\n    out_lr_b_s = get_steps(out_lr[nout:], out_shape)\n    out_rl_f_s = get_steps(out_rl[:nout], out_shape)\n    out_rl_b_s = get_steps(out_rl[nout:], out_shape)\n    for (x_f, x_b, y_f, y_b) in zip(out_lr_f_s, out_lr_b_s, reversed(out_rl_f_s), reversed(out_rl_b_s)):\n        assert allclose_with_out(x_f, y_b, rtol=0.0, atol=1e-05)\n        assert allclose_with_out(x_b, y_f, rtol=0.0, atol=1e-05)",
            "def test_biRNN_fprop(backend_default, fargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    in_shape = (input_size, seq_len)\n    out_shape = (hidden_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    init_glorot = GlorotUniform()\n    birnn = BiRNN(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    birnn.configure(in_shape)\n    birnn.prev_layer = True\n    birnn.allocate()\n    nout = hidden_size\n    birnn.W_input_b[:] = birnn.W_input_f\n    birnn.W_recur_b[:] = birnn.W_recur_f\n    birnn.b_b[:] = birnn.b_f\n    birnn.dW[:] = 0\n    lr = np.random.random((input_size, seq_len * batch_size))\n    lr_rev = list(reversed(get_steps(lr.copy(), in_shape)))\n    rl = con(lr_rev, axis=1)\n    inp_lr = birnn.be.array(lr)\n    inp_rl = birnn.be.array(rl)\n    out_lr = birnn.fprop(inp_lr).get().copy()\n    birnn.h_buffer[:] = 0\n    out_rl = birnn.fprop(inp_rl).get().copy()\n    out_lr_f_s = get_steps(out_lr[:nout], out_shape)\n    out_lr_b_s = get_steps(out_lr[nout:], out_shape)\n    out_rl_f_s = get_steps(out_rl[:nout], out_shape)\n    out_rl_b_s = get_steps(out_rl[nout:], out_shape)\n    for (x_f, x_b, y_f, y_b) in zip(out_lr_f_s, out_lr_b_s, reversed(out_rl_f_s), reversed(out_rl_b_s)):\n        assert allclose_with_out(x_f, y_b, rtol=0.0, atol=1e-05)\n        assert allclose_with_out(x_b, y_f, rtol=0.0, atol=1e-05)"
        ]
    },
    {
        "func_name": "test_biRNN_bprop",
        "original": "def test_biRNN_bprop(backend_default, fargs, deltas_buffer):\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    in_shape = (input_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    init_glorot = GlorotUniform()\n    birnn = BiRNN(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    birnn.configure(in_shape)\n    birnn.prev_layer = True\n    birnn.allocate()\n    birnn.allocate_deltas(deltas_buffer)\n    deltas_buffer.allocate_buffers()\n    birnn.set_deltas(deltas_buffer)\n    birnn.W_input_b[:] = birnn.W_input_f\n    birnn.W_recur_b[:] = birnn.W_recur_f\n    birnn.b_b[:] = birnn.b_f\n    birnn.dW[:] = 0\n    init_glorot = GlorotUniform()\n    rnn = Recurrent(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    rnn.configure(in_shape)\n    rnn.prev_layer = True\n    rnn.allocate()\n    rnn.allocate_deltas(deltas_buffer)\n    deltas_buffer.allocate_buffers()\n    rnn.set_deltas(deltas_buffer)\n    lr = np.random.random((input_size, seq_len * batch_size))\n    lr_rev = list(reversed(get_steps(lr.copy(), in_shape)))\n    rl = con(lr_rev, axis=1)\n    inp_lr = birnn.be.array(lr)\n    inp_rl = birnn.be.array(rl)\n    out_lr_g = birnn.fprop(inp_lr)\n    del_lr = birnn.bprop(out_lr_g).get().copy()\n    birnn.h_buffer[:] = 0\n    out_rl_g = birnn.fprop(inp_rl)\n    del_rl = birnn.bprop(out_rl_g).get().copy()\n    del_lr_s = get_steps(del_lr, in_shape)\n    del_rl_s = get_steps(del_rl, in_shape)\n    for (x, y) in zip(del_lr_s, reversed(del_rl_s)):\n        assert allclose_with_out(x, y, rtol=0.0, atol=1e-05)",
        "mutated": [
            "def test_biRNN_bprop(backend_default, fargs, deltas_buffer):\n    if False:\n        i = 10\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    in_shape = (input_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    init_glorot = GlorotUniform()\n    birnn = BiRNN(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    birnn.configure(in_shape)\n    birnn.prev_layer = True\n    birnn.allocate()\n    birnn.allocate_deltas(deltas_buffer)\n    deltas_buffer.allocate_buffers()\n    birnn.set_deltas(deltas_buffer)\n    birnn.W_input_b[:] = birnn.W_input_f\n    birnn.W_recur_b[:] = birnn.W_recur_f\n    birnn.b_b[:] = birnn.b_f\n    birnn.dW[:] = 0\n    init_glorot = GlorotUniform()\n    rnn = Recurrent(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    rnn.configure(in_shape)\n    rnn.prev_layer = True\n    rnn.allocate()\n    rnn.allocate_deltas(deltas_buffer)\n    deltas_buffer.allocate_buffers()\n    rnn.set_deltas(deltas_buffer)\n    lr = np.random.random((input_size, seq_len * batch_size))\n    lr_rev = list(reversed(get_steps(lr.copy(), in_shape)))\n    rl = con(lr_rev, axis=1)\n    inp_lr = birnn.be.array(lr)\n    inp_rl = birnn.be.array(rl)\n    out_lr_g = birnn.fprop(inp_lr)\n    del_lr = birnn.bprop(out_lr_g).get().copy()\n    birnn.h_buffer[:] = 0\n    out_rl_g = birnn.fprop(inp_rl)\n    del_rl = birnn.bprop(out_rl_g).get().copy()\n    del_lr_s = get_steps(del_lr, in_shape)\n    del_rl_s = get_steps(del_rl, in_shape)\n    for (x, y) in zip(del_lr_s, reversed(del_rl_s)):\n        assert allclose_with_out(x, y, rtol=0.0, atol=1e-05)",
            "def test_biRNN_bprop(backend_default, fargs, deltas_buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    in_shape = (input_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    init_glorot = GlorotUniform()\n    birnn = BiRNN(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    birnn.configure(in_shape)\n    birnn.prev_layer = True\n    birnn.allocate()\n    birnn.allocate_deltas(deltas_buffer)\n    deltas_buffer.allocate_buffers()\n    birnn.set_deltas(deltas_buffer)\n    birnn.W_input_b[:] = birnn.W_input_f\n    birnn.W_recur_b[:] = birnn.W_recur_f\n    birnn.b_b[:] = birnn.b_f\n    birnn.dW[:] = 0\n    init_glorot = GlorotUniform()\n    rnn = Recurrent(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    rnn.configure(in_shape)\n    rnn.prev_layer = True\n    rnn.allocate()\n    rnn.allocate_deltas(deltas_buffer)\n    deltas_buffer.allocate_buffers()\n    rnn.set_deltas(deltas_buffer)\n    lr = np.random.random((input_size, seq_len * batch_size))\n    lr_rev = list(reversed(get_steps(lr.copy(), in_shape)))\n    rl = con(lr_rev, axis=1)\n    inp_lr = birnn.be.array(lr)\n    inp_rl = birnn.be.array(rl)\n    out_lr_g = birnn.fprop(inp_lr)\n    del_lr = birnn.bprop(out_lr_g).get().copy()\n    birnn.h_buffer[:] = 0\n    out_rl_g = birnn.fprop(inp_rl)\n    del_rl = birnn.bprop(out_rl_g).get().copy()\n    del_lr_s = get_steps(del_lr, in_shape)\n    del_rl_s = get_steps(del_rl, in_shape)\n    for (x, y) in zip(del_lr_s, reversed(del_rl_s)):\n        assert allclose_with_out(x, y, rtol=0.0, atol=1e-05)",
            "def test_biRNN_bprop(backend_default, fargs, deltas_buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    in_shape = (input_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    init_glorot = GlorotUniform()\n    birnn = BiRNN(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    birnn.configure(in_shape)\n    birnn.prev_layer = True\n    birnn.allocate()\n    birnn.allocate_deltas(deltas_buffer)\n    deltas_buffer.allocate_buffers()\n    birnn.set_deltas(deltas_buffer)\n    birnn.W_input_b[:] = birnn.W_input_f\n    birnn.W_recur_b[:] = birnn.W_recur_f\n    birnn.b_b[:] = birnn.b_f\n    birnn.dW[:] = 0\n    init_glorot = GlorotUniform()\n    rnn = Recurrent(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    rnn.configure(in_shape)\n    rnn.prev_layer = True\n    rnn.allocate()\n    rnn.allocate_deltas(deltas_buffer)\n    deltas_buffer.allocate_buffers()\n    rnn.set_deltas(deltas_buffer)\n    lr = np.random.random((input_size, seq_len * batch_size))\n    lr_rev = list(reversed(get_steps(lr.copy(), in_shape)))\n    rl = con(lr_rev, axis=1)\n    inp_lr = birnn.be.array(lr)\n    inp_rl = birnn.be.array(rl)\n    out_lr_g = birnn.fprop(inp_lr)\n    del_lr = birnn.bprop(out_lr_g).get().copy()\n    birnn.h_buffer[:] = 0\n    out_rl_g = birnn.fprop(inp_rl)\n    del_rl = birnn.bprop(out_rl_g).get().copy()\n    del_lr_s = get_steps(del_lr, in_shape)\n    del_rl_s = get_steps(del_rl, in_shape)\n    for (x, y) in zip(del_lr_s, reversed(del_rl_s)):\n        assert allclose_with_out(x, y, rtol=0.0, atol=1e-05)",
            "def test_biRNN_bprop(backend_default, fargs, deltas_buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    in_shape = (input_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    init_glorot = GlorotUniform()\n    birnn = BiRNN(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    birnn.configure(in_shape)\n    birnn.prev_layer = True\n    birnn.allocate()\n    birnn.allocate_deltas(deltas_buffer)\n    deltas_buffer.allocate_buffers()\n    birnn.set_deltas(deltas_buffer)\n    birnn.W_input_b[:] = birnn.W_input_f\n    birnn.W_recur_b[:] = birnn.W_recur_f\n    birnn.b_b[:] = birnn.b_f\n    birnn.dW[:] = 0\n    init_glorot = GlorotUniform()\n    rnn = Recurrent(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    rnn.configure(in_shape)\n    rnn.prev_layer = True\n    rnn.allocate()\n    rnn.allocate_deltas(deltas_buffer)\n    deltas_buffer.allocate_buffers()\n    rnn.set_deltas(deltas_buffer)\n    lr = np.random.random((input_size, seq_len * batch_size))\n    lr_rev = list(reversed(get_steps(lr.copy(), in_shape)))\n    rl = con(lr_rev, axis=1)\n    inp_lr = birnn.be.array(lr)\n    inp_rl = birnn.be.array(rl)\n    out_lr_g = birnn.fprop(inp_lr)\n    del_lr = birnn.bprop(out_lr_g).get().copy()\n    birnn.h_buffer[:] = 0\n    out_rl_g = birnn.fprop(inp_rl)\n    del_rl = birnn.bprop(out_rl_g).get().copy()\n    del_lr_s = get_steps(del_lr, in_shape)\n    del_rl_s = get_steps(del_rl, in_shape)\n    for (x, y) in zip(del_lr_s, reversed(del_rl_s)):\n        assert allclose_with_out(x, y, rtol=0.0, atol=1e-05)",
            "def test_biRNN_bprop(backend_default, fargs, deltas_buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    in_shape = (input_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    init_glorot = GlorotUniform()\n    birnn = BiRNN(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    birnn.configure(in_shape)\n    birnn.prev_layer = True\n    birnn.allocate()\n    birnn.allocate_deltas(deltas_buffer)\n    deltas_buffer.allocate_buffers()\n    birnn.set_deltas(deltas_buffer)\n    birnn.W_input_b[:] = birnn.W_input_f\n    birnn.W_recur_b[:] = birnn.W_recur_f\n    birnn.b_b[:] = birnn.b_f\n    birnn.dW[:] = 0\n    init_glorot = GlorotUniform()\n    rnn = Recurrent(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    rnn.configure(in_shape)\n    rnn.prev_layer = True\n    rnn.allocate()\n    rnn.allocate_deltas(deltas_buffer)\n    deltas_buffer.allocate_buffers()\n    rnn.set_deltas(deltas_buffer)\n    lr = np.random.random((input_size, seq_len * batch_size))\n    lr_rev = list(reversed(get_steps(lr.copy(), in_shape)))\n    rl = con(lr_rev, axis=1)\n    inp_lr = birnn.be.array(lr)\n    inp_rl = birnn.be.array(rl)\n    out_lr_g = birnn.fprop(inp_lr)\n    del_lr = birnn.bprop(out_lr_g).get().copy()\n    birnn.h_buffer[:] = 0\n    out_rl_g = birnn.fprop(inp_rl)\n    del_rl = birnn.bprop(out_rl_g).get().copy()\n    del_lr_s = get_steps(del_lr, in_shape)\n    del_rl_s = get_steps(del_rl, in_shape)\n    for (x, y) in zip(del_lr_s, reversed(del_rl_s)):\n        assert allclose_with_out(x, y, rtol=0.0, atol=1e-05)"
        ]
    },
    {
        "func_name": "test_biSum",
        "original": "def test_biSum(backend_default, fargs, deltas_buffer):\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    input_size *= 2\n    in_shape = (input_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    bisum = BiSum()\n    bisum.configure(in_shape)\n    bisum.prev_layer = True\n    bisum.allocate()\n    bisum.allocate_deltas(deltas_buffer)\n    deltas_buffer.allocate_buffers()\n    bisum.set_deltas(deltas_buffer)\n    inp_np = np.random.random((input_size, seq_len * batch_size))\n    inp_be = bisum.be.array(inp_np)\n    out_be = bisum.fprop(inp_be)\n    del_be = bisum.bprop(out_be)\n    out_ref = bisum.be.empty_like(out_be)\n    out_ref[:] = inp_be[:input_size // 2] + inp_be[input_size // 2:]\n    assert out_be.shape[0] * 2 == inp_be.shape[0]\n    assert allclose_with_out(out_be.get(), out_ref.get(), rtol=0.0, atol=1e-05)\n    assert allclose_with_out(del_be[:input_size // 2].get(), out_be.get(), rtol=0.0, atol=1e-05)\n    assert allclose_with_out(del_be[input_size // 2:].get(), out_be.get(), rtol=0.0, atol=1e-05)",
        "mutated": [
            "def test_biSum(backend_default, fargs, deltas_buffer):\n    if False:\n        i = 10\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    input_size *= 2\n    in_shape = (input_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    bisum = BiSum()\n    bisum.configure(in_shape)\n    bisum.prev_layer = True\n    bisum.allocate()\n    bisum.allocate_deltas(deltas_buffer)\n    deltas_buffer.allocate_buffers()\n    bisum.set_deltas(deltas_buffer)\n    inp_np = np.random.random((input_size, seq_len * batch_size))\n    inp_be = bisum.be.array(inp_np)\n    out_be = bisum.fprop(inp_be)\n    del_be = bisum.bprop(out_be)\n    out_ref = bisum.be.empty_like(out_be)\n    out_ref[:] = inp_be[:input_size // 2] + inp_be[input_size // 2:]\n    assert out_be.shape[0] * 2 == inp_be.shape[0]\n    assert allclose_with_out(out_be.get(), out_ref.get(), rtol=0.0, atol=1e-05)\n    assert allclose_with_out(del_be[:input_size // 2].get(), out_be.get(), rtol=0.0, atol=1e-05)\n    assert allclose_with_out(del_be[input_size // 2:].get(), out_be.get(), rtol=0.0, atol=1e-05)",
            "def test_biSum(backend_default, fargs, deltas_buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    input_size *= 2\n    in_shape = (input_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    bisum = BiSum()\n    bisum.configure(in_shape)\n    bisum.prev_layer = True\n    bisum.allocate()\n    bisum.allocate_deltas(deltas_buffer)\n    deltas_buffer.allocate_buffers()\n    bisum.set_deltas(deltas_buffer)\n    inp_np = np.random.random((input_size, seq_len * batch_size))\n    inp_be = bisum.be.array(inp_np)\n    out_be = bisum.fprop(inp_be)\n    del_be = bisum.bprop(out_be)\n    out_ref = bisum.be.empty_like(out_be)\n    out_ref[:] = inp_be[:input_size // 2] + inp_be[input_size // 2:]\n    assert out_be.shape[0] * 2 == inp_be.shape[0]\n    assert allclose_with_out(out_be.get(), out_ref.get(), rtol=0.0, atol=1e-05)\n    assert allclose_with_out(del_be[:input_size // 2].get(), out_be.get(), rtol=0.0, atol=1e-05)\n    assert allclose_with_out(del_be[input_size // 2:].get(), out_be.get(), rtol=0.0, atol=1e-05)",
            "def test_biSum(backend_default, fargs, deltas_buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    input_size *= 2\n    in_shape = (input_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    bisum = BiSum()\n    bisum.configure(in_shape)\n    bisum.prev_layer = True\n    bisum.allocate()\n    bisum.allocate_deltas(deltas_buffer)\n    deltas_buffer.allocate_buffers()\n    bisum.set_deltas(deltas_buffer)\n    inp_np = np.random.random((input_size, seq_len * batch_size))\n    inp_be = bisum.be.array(inp_np)\n    out_be = bisum.fprop(inp_be)\n    del_be = bisum.bprop(out_be)\n    out_ref = bisum.be.empty_like(out_be)\n    out_ref[:] = inp_be[:input_size // 2] + inp_be[input_size // 2:]\n    assert out_be.shape[0] * 2 == inp_be.shape[0]\n    assert allclose_with_out(out_be.get(), out_ref.get(), rtol=0.0, atol=1e-05)\n    assert allclose_with_out(del_be[:input_size // 2].get(), out_be.get(), rtol=0.0, atol=1e-05)\n    assert allclose_with_out(del_be[input_size // 2:].get(), out_be.get(), rtol=0.0, atol=1e-05)",
            "def test_biSum(backend_default, fargs, deltas_buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    input_size *= 2\n    in_shape = (input_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    bisum = BiSum()\n    bisum.configure(in_shape)\n    bisum.prev_layer = True\n    bisum.allocate()\n    bisum.allocate_deltas(deltas_buffer)\n    deltas_buffer.allocate_buffers()\n    bisum.set_deltas(deltas_buffer)\n    inp_np = np.random.random((input_size, seq_len * batch_size))\n    inp_be = bisum.be.array(inp_np)\n    out_be = bisum.fprop(inp_be)\n    del_be = bisum.bprop(out_be)\n    out_ref = bisum.be.empty_like(out_be)\n    out_ref[:] = inp_be[:input_size // 2] + inp_be[input_size // 2:]\n    assert out_be.shape[0] * 2 == inp_be.shape[0]\n    assert allclose_with_out(out_be.get(), out_ref.get(), rtol=0.0, atol=1e-05)\n    assert allclose_with_out(del_be[:input_size // 2].get(), out_be.get(), rtol=0.0, atol=1e-05)\n    assert allclose_with_out(del_be[input_size // 2:].get(), out_be.get(), rtol=0.0, atol=1e-05)",
            "def test_biSum(backend_default, fargs, deltas_buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    input_size *= 2\n    in_shape = (input_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    bisum = BiSum()\n    bisum.configure(in_shape)\n    bisum.prev_layer = True\n    bisum.allocate()\n    bisum.allocate_deltas(deltas_buffer)\n    deltas_buffer.allocate_buffers()\n    bisum.set_deltas(deltas_buffer)\n    inp_np = np.random.random((input_size, seq_len * batch_size))\n    inp_be = bisum.be.array(inp_np)\n    out_be = bisum.fprop(inp_be)\n    del_be = bisum.bprop(out_be)\n    out_ref = bisum.be.empty_like(out_be)\n    out_ref[:] = inp_be[:input_size // 2] + inp_be[input_size // 2:]\n    assert out_be.shape[0] * 2 == inp_be.shape[0]\n    assert allclose_with_out(out_be.get(), out_ref.get(), rtol=0.0, atol=1e-05)\n    assert allclose_with_out(del_be[:input_size // 2].get(), out_be.get(), rtol=0.0, atol=1e-05)\n    assert allclose_with_out(del_be[input_size // 2:].get(), out_be.get(), rtol=0.0, atol=1e-05)"
        ]
    },
    {
        "func_name": "test_bibn",
        "original": "def test_bibn(backend_default, fargs, deltas_buffer):\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    in_shape = (input_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    hidden_size = min(10, hidden_size)\n    init_glorot = GlorotUniform()\n    birnn = BiBNRNN(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    birnn.configure(in_shape)\n    birnn.prev_layer = True\n    birnn.allocate()\n    birnn.allocate_deltas(deltas_buffer)\n    deltas_buffer.allocate_buffers()\n    birnn.set_deltas(deltas_buffer)\n    inp_np = np.random.random(birnn.h_ff_buffer.shape)\n    inp_be = birnn.be.array(inp_np)\n    birnn.h_ff_buffer[:] = inp_np\n    xsum = birnn.be.zeros_like(birnn.xmean)\n    xvar = birnn.be.zeros_like(birnn.xvar)\n    gmean = birnn.be.zeros_like(birnn.gmean)\n    gvar = birnn.be.zeros_like(birnn.gvar)\n    gamma = birnn.be.ones(birnn.gamma.shape)\n    beta = birnn.be.zeros_like(birnn.beta)\n    grad_gamma = birnn.be.zeros_like(gamma)\n    grad_beta = birnn.be.zeros_like(beta)\n    out_ref = birnn.be.zeros_like(birnn.h_ff_buffer)\n    xsum[:] = birnn.be.sum(birnn.h_ff_buffer, axis=1)\n    birnn.be.compound_fprop_bn(birnn.h_ff_buffer, xsum, xvar, gmean, gvar, gamma, beta, out_ref, birnn.eps, birnn.rho, False, accumbeta=0, relu=False)\n    out_bn = birnn._fprop_bn(birnn.h_ff_buffer, inference=False)\n    assert allclose_with_out(out_bn.get(), out_ref.get(), rtol=0.0, atol=1e-05)\n    err_np = np.random.random(birnn.h_ff_buffer.shape)\n    err_be = birnn.be.array(err_np)\n    err_out_ref = birnn.be.empty_like(err_be)\n    birnn.be.compound_bprop_bn(err_out_ref, grad_gamma, grad_beta, err_be, inp_be, xsum, xvar, gamma, birnn.eps)\n    err_out_bn = birnn._bprop_bn(err_be, out_bn)\n    assert allclose_with_out(err_out_bn.get(), err_out_ref.get(), rtol=0.0, atol=2.5e-05)",
        "mutated": [
            "def test_bibn(backend_default, fargs, deltas_buffer):\n    if False:\n        i = 10\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    in_shape = (input_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    hidden_size = min(10, hidden_size)\n    init_glorot = GlorotUniform()\n    birnn = BiBNRNN(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    birnn.configure(in_shape)\n    birnn.prev_layer = True\n    birnn.allocate()\n    birnn.allocate_deltas(deltas_buffer)\n    deltas_buffer.allocate_buffers()\n    birnn.set_deltas(deltas_buffer)\n    inp_np = np.random.random(birnn.h_ff_buffer.shape)\n    inp_be = birnn.be.array(inp_np)\n    birnn.h_ff_buffer[:] = inp_np\n    xsum = birnn.be.zeros_like(birnn.xmean)\n    xvar = birnn.be.zeros_like(birnn.xvar)\n    gmean = birnn.be.zeros_like(birnn.gmean)\n    gvar = birnn.be.zeros_like(birnn.gvar)\n    gamma = birnn.be.ones(birnn.gamma.shape)\n    beta = birnn.be.zeros_like(birnn.beta)\n    grad_gamma = birnn.be.zeros_like(gamma)\n    grad_beta = birnn.be.zeros_like(beta)\n    out_ref = birnn.be.zeros_like(birnn.h_ff_buffer)\n    xsum[:] = birnn.be.sum(birnn.h_ff_buffer, axis=1)\n    birnn.be.compound_fprop_bn(birnn.h_ff_buffer, xsum, xvar, gmean, gvar, gamma, beta, out_ref, birnn.eps, birnn.rho, False, accumbeta=0, relu=False)\n    out_bn = birnn._fprop_bn(birnn.h_ff_buffer, inference=False)\n    assert allclose_with_out(out_bn.get(), out_ref.get(), rtol=0.0, atol=1e-05)\n    err_np = np.random.random(birnn.h_ff_buffer.shape)\n    err_be = birnn.be.array(err_np)\n    err_out_ref = birnn.be.empty_like(err_be)\n    birnn.be.compound_bprop_bn(err_out_ref, grad_gamma, grad_beta, err_be, inp_be, xsum, xvar, gamma, birnn.eps)\n    err_out_bn = birnn._bprop_bn(err_be, out_bn)\n    assert allclose_with_out(err_out_bn.get(), err_out_ref.get(), rtol=0.0, atol=2.5e-05)",
            "def test_bibn(backend_default, fargs, deltas_buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    in_shape = (input_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    hidden_size = min(10, hidden_size)\n    init_glorot = GlorotUniform()\n    birnn = BiBNRNN(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    birnn.configure(in_shape)\n    birnn.prev_layer = True\n    birnn.allocate()\n    birnn.allocate_deltas(deltas_buffer)\n    deltas_buffer.allocate_buffers()\n    birnn.set_deltas(deltas_buffer)\n    inp_np = np.random.random(birnn.h_ff_buffer.shape)\n    inp_be = birnn.be.array(inp_np)\n    birnn.h_ff_buffer[:] = inp_np\n    xsum = birnn.be.zeros_like(birnn.xmean)\n    xvar = birnn.be.zeros_like(birnn.xvar)\n    gmean = birnn.be.zeros_like(birnn.gmean)\n    gvar = birnn.be.zeros_like(birnn.gvar)\n    gamma = birnn.be.ones(birnn.gamma.shape)\n    beta = birnn.be.zeros_like(birnn.beta)\n    grad_gamma = birnn.be.zeros_like(gamma)\n    grad_beta = birnn.be.zeros_like(beta)\n    out_ref = birnn.be.zeros_like(birnn.h_ff_buffer)\n    xsum[:] = birnn.be.sum(birnn.h_ff_buffer, axis=1)\n    birnn.be.compound_fprop_bn(birnn.h_ff_buffer, xsum, xvar, gmean, gvar, gamma, beta, out_ref, birnn.eps, birnn.rho, False, accumbeta=0, relu=False)\n    out_bn = birnn._fprop_bn(birnn.h_ff_buffer, inference=False)\n    assert allclose_with_out(out_bn.get(), out_ref.get(), rtol=0.0, atol=1e-05)\n    err_np = np.random.random(birnn.h_ff_buffer.shape)\n    err_be = birnn.be.array(err_np)\n    err_out_ref = birnn.be.empty_like(err_be)\n    birnn.be.compound_bprop_bn(err_out_ref, grad_gamma, grad_beta, err_be, inp_be, xsum, xvar, gamma, birnn.eps)\n    err_out_bn = birnn._bprop_bn(err_be, out_bn)\n    assert allclose_with_out(err_out_bn.get(), err_out_ref.get(), rtol=0.0, atol=2.5e-05)",
            "def test_bibn(backend_default, fargs, deltas_buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    in_shape = (input_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    hidden_size = min(10, hidden_size)\n    init_glorot = GlorotUniform()\n    birnn = BiBNRNN(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    birnn.configure(in_shape)\n    birnn.prev_layer = True\n    birnn.allocate()\n    birnn.allocate_deltas(deltas_buffer)\n    deltas_buffer.allocate_buffers()\n    birnn.set_deltas(deltas_buffer)\n    inp_np = np.random.random(birnn.h_ff_buffer.shape)\n    inp_be = birnn.be.array(inp_np)\n    birnn.h_ff_buffer[:] = inp_np\n    xsum = birnn.be.zeros_like(birnn.xmean)\n    xvar = birnn.be.zeros_like(birnn.xvar)\n    gmean = birnn.be.zeros_like(birnn.gmean)\n    gvar = birnn.be.zeros_like(birnn.gvar)\n    gamma = birnn.be.ones(birnn.gamma.shape)\n    beta = birnn.be.zeros_like(birnn.beta)\n    grad_gamma = birnn.be.zeros_like(gamma)\n    grad_beta = birnn.be.zeros_like(beta)\n    out_ref = birnn.be.zeros_like(birnn.h_ff_buffer)\n    xsum[:] = birnn.be.sum(birnn.h_ff_buffer, axis=1)\n    birnn.be.compound_fprop_bn(birnn.h_ff_buffer, xsum, xvar, gmean, gvar, gamma, beta, out_ref, birnn.eps, birnn.rho, False, accumbeta=0, relu=False)\n    out_bn = birnn._fprop_bn(birnn.h_ff_buffer, inference=False)\n    assert allclose_with_out(out_bn.get(), out_ref.get(), rtol=0.0, atol=1e-05)\n    err_np = np.random.random(birnn.h_ff_buffer.shape)\n    err_be = birnn.be.array(err_np)\n    err_out_ref = birnn.be.empty_like(err_be)\n    birnn.be.compound_bprop_bn(err_out_ref, grad_gamma, grad_beta, err_be, inp_be, xsum, xvar, gamma, birnn.eps)\n    err_out_bn = birnn._bprop_bn(err_be, out_bn)\n    assert allclose_with_out(err_out_bn.get(), err_out_ref.get(), rtol=0.0, atol=2.5e-05)",
            "def test_bibn(backend_default, fargs, deltas_buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    in_shape = (input_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    hidden_size = min(10, hidden_size)\n    init_glorot = GlorotUniform()\n    birnn = BiBNRNN(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    birnn.configure(in_shape)\n    birnn.prev_layer = True\n    birnn.allocate()\n    birnn.allocate_deltas(deltas_buffer)\n    deltas_buffer.allocate_buffers()\n    birnn.set_deltas(deltas_buffer)\n    inp_np = np.random.random(birnn.h_ff_buffer.shape)\n    inp_be = birnn.be.array(inp_np)\n    birnn.h_ff_buffer[:] = inp_np\n    xsum = birnn.be.zeros_like(birnn.xmean)\n    xvar = birnn.be.zeros_like(birnn.xvar)\n    gmean = birnn.be.zeros_like(birnn.gmean)\n    gvar = birnn.be.zeros_like(birnn.gvar)\n    gamma = birnn.be.ones(birnn.gamma.shape)\n    beta = birnn.be.zeros_like(birnn.beta)\n    grad_gamma = birnn.be.zeros_like(gamma)\n    grad_beta = birnn.be.zeros_like(beta)\n    out_ref = birnn.be.zeros_like(birnn.h_ff_buffer)\n    xsum[:] = birnn.be.sum(birnn.h_ff_buffer, axis=1)\n    birnn.be.compound_fprop_bn(birnn.h_ff_buffer, xsum, xvar, gmean, gvar, gamma, beta, out_ref, birnn.eps, birnn.rho, False, accumbeta=0, relu=False)\n    out_bn = birnn._fprop_bn(birnn.h_ff_buffer, inference=False)\n    assert allclose_with_out(out_bn.get(), out_ref.get(), rtol=0.0, atol=1e-05)\n    err_np = np.random.random(birnn.h_ff_buffer.shape)\n    err_be = birnn.be.array(err_np)\n    err_out_ref = birnn.be.empty_like(err_be)\n    birnn.be.compound_bprop_bn(err_out_ref, grad_gamma, grad_beta, err_be, inp_be, xsum, xvar, gamma, birnn.eps)\n    err_out_bn = birnn._bprop_bn(err_be, out_bn)\n    assert allclose_with_out(err_out_bn.get(), err_out_ref.get(), rtol=0.0, atol=2.5e-05)",
            "def test_bibn(backend_default, fargs, deltas_buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (seq_len, input_size, hidden_size, batch_size) = fargs\n    in_shape = (input_size, seq_len)\n    NervanaObject.be.bsz = batch_size\n    hidden_size = min(10, hidden_size)\n    init_glorot = GlorotUniform()\n    birnn = BiBNRNN(hidden_size, activation=Rectlinclip(slope=0), init=init_glorot)\n    birnn.configure(in_shape)\n    birnn.prev_layer = True\n    birnn.allocate()\n    birnn.allocate_deltas(deltas_buffer)\n    deltas_buffer.allocate_buffers()\n    birnn.set_deltas(deltas_buffer)\n    inp_np = np.random.random(birnn.h_ff_buffer.shape)\n    inp_be = birnn.be.array(inp_np)\n    birnn.h_ff_buffer[:] = inp_np\n    xsum = birnn.be.zeros_like(birnn.xmean)\n    xvar = birnn.be.zeros_like(birnn.xvar)\n    gmean = birnn.be.zeros_like(birnn.gmean)\n    gvar = birnn.be.zeros_like(birnn.gvar)\n    gamma = birnn.be.ones(birnn.gamma.shape)\n    beta = birnn.be.zeros_like(birnn.beta)\n    grad_gamma = birnn.be.zeros_like(gamma)\n    grad_beta = birnn.be.zeros_like(beta)\n    out_ref = birnn.be.zeros_like(birnn.h_ff_buffer)\n    xsum[:] = birnn.be.sum(birnn.h_ff_buffer, axis=1)\n    birnn.be.compound_fprop_bn(birnn.h_ff_buffer, xsum, xvar, gmean, gvar, gamma, beta, out_ref, birnn.eps, birnn.rho, False, accumbeta=0, relu=False)\n    out_bn = birnn._fprop_bn(birnn.h_ff_buffer, inference=False)\n    assert allclose_with_out(out_bn.get(), out_ref.get(), rtol=0.0, atol=1e-05)\n    err_np = np.random.random(birnn.h_ff_buffer.shape)\n    err_be = birnn.be.array(err_np)\n    err_out_ref = birnn.be.empty_like(err_be)\n    birnn.be.compound_bprop_bn(err_out_ref, grad_gamma, grad_beta, err_be, inp_be, xsum, xvar, gamma, birnn.eps)\n    err_out_bn = birnn._bprop_bn(err_be, out_bn)\n    assert allclose_with_out(err_out_bn.get(), err_out_ref.get(), rtol=0.0, atol=2.5e-05)"
        ]
    }
]