[
    {
        "func_name": "save_pointcloud_ply",
        "original": "def save_pointcloud_ply(filename: str, pointcloud: torch.Tensor) -> None:\n    \"\"\"Utility function to save to disk a pointcloud in PLY format.\n\n    Args:\n        filename: the path to save the pointcloud.\n        pointcloud: tensor containing the pointcloud to save.\n          The tensor must be in the shape of :math:`(*, 3)` where the last\n          component is assumed to be a 3d point coordinate :math:`(X, Y, Z)`.\n    \"\"\"\n    if not isinstance(filename, str) and filename[-3:] == '.ply':\n        raise TypeError(f'Input filename must be a string in with the .ply  extension. Got {filename}')\n    if not torch.is_tensor(pointcloud):\n        raise TypeError(f'Input pointcloud type is not a torch.Tensor. Got {type(pointcloud)}')\n    if not len(pointcloud.shape) >= 2 and pointcloud.shape[-1] == 3:\n        raise TypeError(f'Input pointcloud must be in the following shape HxWx3. Got {pointcloud.shape}.')\n    xyz_vec: torch.Tensor = pointcloud.reshape(-1, 3)\n    with open(filename, 'w') as f:\n        data_str: str = ''\n        num_points: int = xyz_vec.shape[0]\n        for idx in range(num_points):\n            xyz = xyz_vec[idx]\n            if not bool(torch.isfinite(xyz).any()):\n                num_points -= 1\n                continue\n            x: float = float(xyz[0])\n            y: float = float(xyz[1])\n            z: float = float(xyz[2])\n            data_str += f'{x} {y} {z}\\n'\n        f.write('ply\\n')\n        f.write('format ascii 1.0\\n')\n        f.write('comment arraiy generated\\n')\n        f.write('element vertex %d\\n' % num_points)\n        f.write('property double x\\n')\n        f.write('property double y\\n')\n        f.write('property double z\\n')\n        f.write('end_header\\n')\n        f.write(data_str)",
        "mutated": [
            "def save_pointcloud_ply(filename: str, pointcloud: torch.Tensor) -> None:\n    if False:\n        i = 10\n    'Utility function to save to disk a pointcloud in PLY format.\\n\\n    Args:\\n        filename: the path to save the pointcloud.\\n        pointcloud: tensor containing the pointcloud to save.\\n          The tensor must be in the shape of :math:`(*, 3)` where the last\\n          component is assumed to be a 3d point coordinate :math:`(X, Y, Z)`.\\n    '\n    if not isinstance(filename, str) and filename[-3:] == '.ply':\n        raise TypeError(f'Input filename must be a string in with the .ply  extension. Got {filename}')\n    if not torch.is_tensor(pointcloud):\n        raise TypeError(f'Input pointcloud type is not a torch.Tensor. Got {type(pointcloud)}')\n    if not len(pointcloud.shape) >= 2 and pointcloud.shape[-1] == 3:\n        raise TypeError(f'Input pointcloud must be in the following shape HxWx3. Got {pointcloud.shape}.')\n    xyz_vec: torch.Tensor = pointcloud.reshape(-1, 3)\n    with open(filename, 'w') as f:\n        data_str: str = ''\n        num_points: int = xyz_vec.shape[0]\n        for idx in range(num_points):\n            xyz = xyz_vec[idx]\n            if not bool(torch.isfinite(xyz).any()):\n                num_points -= 1\n                continue\n            x: float = float(xyz[0])\n            y: float = float(xyz[1])\n            z: float = float(xyz[2])\n            data_str += f'{x} {y} {z}\\n'\n        f.write('ply\\n')\n        f.write('format ascii 1.0\\n')\n        f.write('comment arraiy generated\\n')\n        f.write('element vertex %d\\n' % num_points)\n        f.write('property double x\\n')\n        f.write('property double y\\n')\n        f.write('property double z\\n')\n        f.write('end_header\\n')\n        f.write(data_str)",
            "def save_pointcloud_ply(filename: str, pointcloud: torch.Tensor) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Utility function to save to disk a pointcloud in PLY format.\\n\\n    Args:\\n        filename: the path to save the pointcloud.\\n        pointcloud: tensor containing the pointcloud to save.\\n          The tensor must be in the shape of :math:`(*, 3)` where the last\\n          component is assumed to be a 3d point coordinate :math:`(X, Y, Z)`.\\n    '\n    if not isinstance(filename, str) and filename[-3:] == '.ply':\n        raise TypeError(f'Input filename must be a string in with the .ply  extension. Got {filename}')\n    if not torch.is_tensor(pointcloud):\n        raise TypeError(f'Input pointcloud type is not a torch.Tensor. Got {type(pointcloud)}')\n    if not len(pointcloud.shape) >= 2 and pointcloud.shape[-1] == 3:\n        raise TypeError(f'Input pointcloud must be in the following shape HxWx3. Got {pointcloud.shape}.')\n    xyz_vec: torch.Tensor = pointcloud.reshape(-1, 3)\n    with open(filename, 'w') as f:\n        data_str: str = ''\n        num_points: int = xyz_vec.shape[0]\n        for idx in range(num_points):\n            xyz = xyz_vec[idx]\n            if not bool(torch.isfinite(xyz).any()):\n                num_points -= 1\n                continue\n            x: float = float(xyz[0])\n            y: float = float(xyz[1])\n            z: float = float(xyz[2])\n            data_str += f'{x} {y} {z}\\n'\n        f.write('ply\\n')\n        f.write('format ascii 1.0\\n')\n        f.write('comment arraiy generated\\n')\n        f.write('element vertex %d\\n' % num_points)\n        f.write('property double x\\n')\n        f.write('property double y\\n')\n        f.write('property double z\\n')\n        f.write('end_header\\n')\n        f.write(data_str)",
            "def save_pointcloud_ply(filename: str, pointcloud: torch.Tensor) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Utility function to save to disk a pointcloud in PLY format.\\n\\n    Args:\\n        filename: the path to save the pointcloud.\\n        pointcloud: tensor containing the pointcloud to save.\\n          The tensor must be in the shape of :math:`(*, 3)` where the last\\n          component is assumed to be a 3d point coordinate :math:`(X, Y, Z)`.\\n    '\n    if not isinstance(filename, str) and filename[-3:] == '.ply':\n        raise TypeError(f'Input filename must be a string in with the .ply  extension. Got {filename}')\n    if not torch.is_tensor(pointcloud):\n        raise TypeError(f'Input pointcloud type is not a torch.Tensor. Got {type(pointcloud)}')\n    if not len(pointcloud.shape) >= 2 and pointcloud.shape[-1] == 3:\n        raise TypeError(f'Input pointcloud must be in the following shape HxWx3. Got {pointcloud.shape}.')\n    xyz_vec: torch.Tensor = pointcloud.reshape(-1, 3)\n    with open(filename, 'w') as f:\n        data_str: str = ''\n        num_points: int = xyz_vec.shape[0]\n        for idx in range(num_points):\n            xyz = xyz_vec[idx]\n            if not bool(torch.isfinite(xyz).any()):\n                num_points -= 1\n                continue\n            x: float = float(xyz[0])\n            y: float = float(xyz[1])\n            z: float = float(xyz[2])\n            data_str += f'{x} {y} {z}\\n'\n        f.write('ply\\n')\n        f.write('format ascii 1.0\\n')\n        f.write('comment arraiy generated\\n')\n        f.write('element vertex %d\\n' % num_points)\n        f.write('property double x\\n')\n        f.write('property double y\\n')\n        f.write('property double z\\n')\n        f.write('end_header\\n')\n        f.write(data_str)",
            "def save_pointcloud_ply(filename: str, pointcloud: torch.Tensor) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Utility function to save to disk a pointcloud in PLY format.\\n\\n    Args:\\n        filename: the path to save the pointcloud.\\n        pointcloud: tensor containing the pointcloud to save.\\n          The tensor must be in the shape of :math:`(*, 3)` where the last\\n          component is assumed to be a 3d point coordinate :math:`(X, Y, Z)`.\\n    '\n    if not isinstance(filename, str) and filename[-3:] == '.ply':\n        raise TypeError(f'Input filename must be a string in with the .ply  extension. Got {filename}')\n    if not torch.is_tensor(pointcloud):\n        raise TypeError(f'Input pointcloud type is not a torch.Tensor. Got {type(pointcloud)}')\n    if not len(pointcloud.shape) >= 2 and pointcloud.shape[-1] == 3:\n        raise TypeError(f'Input pointcloud must be in the following shape HxWx3. Got {pointcloud.shape}.')\n    xyz_vec: torch.Tensor = pointcloud.reshape(-1, 3)\n    with open(filename, 'w') as f:\n        data_str: str = ''\n        num_points: int = xyz_vec.shape[0]\n        for idx in range(num_points):\n            xyz = xyz_vec[idx]\n            if not bool(torch.isfinite(xyz).any()):\n                num_points -= 1\n                continue\n            x: float = float(xyz[0])\n            y: float = float(xyz[1])\n            z: float = float(xyz[2])\n            data_str += f'{x} {y} {z}\\n'\n        f.write('ply\\n')\n        f.write('format ascii 1.0\\n')\n        f.write('comment arraiy generated\\n')\n        f.write('element vertex %d\\n' % num_points)\n        f.write('property double x\\n')\n        f.write('property double y\\n')\n        f.write('property double z\\n')\n        f.write('end_header\\n')\n        f.write(data_str)",
            "def save_pointcloud_ply(filename: str, pointcloud: torch.Tensor) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Utility function to save to disk a pointcloud in PLY format.\\n\\n    Args:\\n        filename: the path to save the pointcloud.\\n        pointcloud: tensor containing the pointcloud to save.\\n          The tensor must be in the shape of :math:`(*, 3)` where the last\\n          component is assumed to be a 3d point coordinate :math:`(X, Y, Z)`.\\n    '\n    if not isinstance(filename, str) and filename[-3:] == '.ply':\n        raise TypeError(f'Input filename must be a string in with the .ply  extension. Got {filename}')\n    if not torch.is_tensor(pointcloud):\n        raise TypeError(f'Input pointcloud type is not a torch.Tensor. Got {type(pointcloud)}')\n    if not len(pointcloud.shape) >= 2 and pointcloud.shape[-1] == 3:\n        raise TypeError(f'Input pointcloud must be in the following shape HxWx3. Got {pointcloud.shape}.')\n    xyz_vec: torch.Tensor = pointcloud.reshape(-1, 3)\n    with open(filename, 'w') as f:\n        data_str: str = ''\n        num_points: int = xyz_vec.shape[0]\n        for idx in range(num_points):\n            xyz = xyz_vec[idx]\n            if not bool(torch.isfinite(xyz).any()):\n                num_points -= 1\n                continue\n            x: float = float(xyz[0])\n            y: float = float(xyz[1])\n            z: float = float(xyz[2])\n            data_str += f'{x} {y} {z}\\n'\n        f.write('ply\\n')\n        f.write('format ascii 1.0\\n')\n        f.write('comment arraiy generated\\n')\n        f.write('element vertex %d\\n' % num_points)\n        f.write('property double x\\n')\n        f.write('property double y\\n')\n        f.write('property double z\\n')\n        f.write('end_header\\n')\n        f.write(data_str)"
        ]
    },
    {
        "func_name": "load_pointcloud_ply",
        "original": "def load_pointcloud_ply(filename: str, header_size: int=8) -> torch.Tensor:\n    \"\"\"Utility function to load from disk a pointcloud in PLY format.\n\n    Args:\n        filename: the path to the pointcloud.\n        header_size: the size of the ply file header that will\n          be skipped during loading.\n\n    Return:\n        tensor containing the loaded point with shape :math:`(*, 3)` where\n        :math:`*` represents the number of points.\n    \"\"\"\n    if not isinstance(filename, str) and filename[-3:] == '.ply':\n        raise TypeError(f'Input filename must be a string in with the .ply  extension. Got {filename}')\n    if not os.path.isfile(filename):\n        raise ValueError('Input filename is not an existing file.')\n    if not (isinstance(header_size, int) and header_size > 0):\n        raise TypeError(f'Input header_size must be a positive integer. Got {header_size}.')\n    with open(filename) as f:\n        points = []\n        lines = f.readlines()[header_size:]\n        for line in lines:\n            (x_str, y_str, z_str) = line.split()\n            points.append((torch.tensor(float(x_str)), torch.tensor(float(y_str)), torch.tensor(float(z_str))))\n        pointcloud: torch.Tensor = torch.tensor(points)\n        return pointcloud",
        "mutated": [
            "def load_pointcloud_ply(filename: str, header_size: int=8) -> torch.Tensor:\n    if False:\n        i = 10\n    'Utility function to load from disk a pointcloud in PLY format.\\n\\n    Args:\\n        filename: the path to the pointcloud.\\n        header_size: the size of the ply file header that will\\n          be skipped during loading.\\n\\n    Return:\\n        tensor containing the loaded point with shape :math:`(*, 3)` where\\n        :math:`*` represents the number of points.\\n    '\n    if not isinstance(filename, str) and filename[-3:] == '.ply':\n        raise TypeError(f'Input filename must be a string in with the .ply  extension. Got {filename}')\n    if not os.path.isfile(filename):\n        raise ValueError('Input filename is not an existing file.')\n    if not (isinstance(header_size, int) and header_size > 0):\n        raise TypeError(f'Input header_size must be a positive integer. Got {header_size}.')\n    with open(filename) as f:\n        points = []\n        lines = f.readlines()[header_size:]\n        for line in lines:\n            (x_str, y_str, z_str) = line.split()\n            points.append((torch.tensor(float(x_str)), torch.tensor(float(y_str)), torch.tensor(float(z_str))))\n        pointcloud: torch.Tensor = torch.tensor(points)\n        return pointcloud",
            "def load_pointcloud_ply(filename: str, header_size: int=8) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Utility function to load from disk a pointcloud in PLY format.\\n\\n    Args:\\n        filename: the path to the pointcloud.\\n        header_size: the size of the ply file header that will\\n          be skipped during loading.\\n\\n    Return:\\n        tensor containing the loaded point with shape :math:`(*, 3)` where\\n        :math:`*` represents the number of points.\\n    '\n    if not isinstance(filename, str) and filename[-3:] == '.ply':\n        raise TypeError(f'Input filename must be a string in with the .ply  extension. Got {filename}')\n    if not os.path.isfile(filename):\n        raise ValueError('Input filename is not an existing file.')\n    if not (isinstance(header_size, int) and header_size > 0):\n        raise TypeError(f'Input header_size must be a positive integer. Got {header_size}.')\n    with open(filename) as f:\n        points = []\n        lines = f.readlines()[header_size:]\n        for line in lines:\n            (x_str, y_str, z_str) = line.split()\n            points.append((torch.tensor(float(x_str)), torch.tensor(float(y_str)), torch.tensor(float(z_str))))\n        pointcloud: torch.Tensor = torch.tensor(points)\n        return pointcloud",
            "def load_pointcloud_ply(filename: str, header_size: int=8) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Utility function to load from disk a pointcloud in PLY format.\\n\\n    Args:\\n        filename: the path to the pointcloud.\\n        header_size: the size of the ply file header that will\\n          be skipped during loading.\\n\\n    Return:\\n        tensor containing the loaded point with shape :math:`(*, 3)` where\\n        :math:`*` represents the number of points.\\n    '\n    if not isinstance(filename, str) and filename[-3:] == '.ply':\n        raise TypeError(f'Input filename must be a string in with the .ply  extension. Got {filename}')\n    if not os.path.isfile(filename):\n        raise ValueError('Input filename is not an existing file.')\n    if not (isinstance(header_size, int) and header_size > 0):\n        raise TypeError(f'Input header_size must be a positive integer. Got {header_size}.')\n    with open(filename) as f:\n        points = []\n        lines = f.readlines()[header_size:]\n        for line in lines:\n            (x_str, y_str, z_str) = line.split()\n            points.append((torch.tensor(float(x_str)), torch.tensor(float(y_str)), torch.tensor(float(z_str))))\n        pointcloud: torch.Tensor = torch.tensor(points)\n        return pointcloud",
            "def load_pointcloud_ply(filename: str, header_size: int=8) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Utility function to load from disk a pointcloud in PLY format.\\n\\n    Args:\\n        filename: the path to the pointcloud.\\n        header_size: the size of the ply file header that will\\n          be skipped during loading.\\n\\n    Return:\\n        tensor containing the loaded point with shape :math:`(*, 3)` where\\n        :math:`*` represents the number of points.\\n    '\n    if not isinstance(filename, str) and filename[-3:] == '.ply':\n        raise TypeError(f'Input filename must be a string in with the .ply  extension. Got {filename}')\n    if not os.path.isfile(filename):\n        raise ValueError('Input filename is not an existing file.')\n    if not (isinstance(header_size, int) and header_size > 0):\n        raise TypeError(f'Input header_size must be a positive integer. Got {header_size}.')\n    with open(filename) as f:\n        points = []\n        lines = f.readlines()[header_size:]\n        for line in lines:\n            (x_str, y_str, z_str) = line.split()\n            points.append((torch.tensor(float(x_str)), torch.tensor(float(y_str)), torch.tensor(float(z_str))))\n        pointcloud: torch.Tensor = torch.tensor(points)\n        return pointcloud",
            "def load_pointcloud_ply(filename: str, header_size: int=8) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Utility function to load from disk a pointcloud in PLY format.\\n\\n    Args:\\n        filename: the path to the pointcloud.\\n        header_size: the size of the ply file header that will\\n          be skipped during loading.\\n\\n    Return:\\n        tensor containing the loaded point with shape :math:`(*, 3)` where\\n        :math:`*` represents the number of points.\\n    '\n    if not isinstance(filename, str) and filename[-3:] == '.ply':\n        raise TypeError(f'Input filename must be a string in with the .ply  extension. Got {filename}')\n    if not os.path.isfile(filename):\n        raise ValueError('Input filename is not an existing file.')\n    if not (isinstance(header_size, int) and header_size > 0):\n        raise TypeError(f'Input header_size must be a positive integer. Got {header_size}.')\n    with open(filename) as f:\n        points = []\n        lines = f.readlines()[header_size:]\n        for line in lines:\n            (x_str, y_str, z_str) = line.split()\n            points.append((torch.tensor(float(x_str)), torch.tensor(float(y_str)), torch.tensor(float(z_str))))\n        pointcloud: torch.Tensor = torch.tensor(points)\n        return pointcloud"
        ]
    }
]