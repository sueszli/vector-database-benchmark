[
    {
        "func_name": "__init__",
        "original": "def __init__(self, circuit_dag_dep, template_dag_dep, heuristics_qubits_param=None, heuristics_backward_param=None):\n    \"\"\"\n        Create a TemplateMatching object with necessary arguments.\n        Args:\n            circuit_dag_dep (QuantumCircuit): circuit.\n            template_dag_dep (QuantumCircuit): template.\n            heuristics_backward_param (list[int]): [length, survivor]\n            heuristics_qubits_param (list[int]): [length]\n        \"\"\"\n    self.circuit_dag_dep = circuit_dag_dep\n    self.template_dag_dep = template_dag_dep\n    self.match_list = []\n    self.heuristics_qubits_param = heuristics_qubits_param if heuristics_qubits_param is not None else []\n    self.heuristics_backward_param = heuristics_backward_param if heuristics_backward_param is not None else []",
        "mutated": [
            "def __init__(self, circuit_dag_dep, template_dag_dep, heuristics_qubits_param=None, heuristics_backward_param=None):\n    if False:\n        i = 10\n    '\\n        Create a TemplateMatching object with necessary arguments.\\n        Args:\\n            circuit_dag_dep (QuantumCircuit): circuit.\\n            template_dag_dep (QuantumCircuit): template.\\n            heuristics_backward_param (list[int]): [length, survivor]\\n            heuristics_qubits_param (list[int]): [length]\\n        '\n    self.circuit_dag_dep = circuit_dag_dep\n    self.template_dag_dep = template_dag_dep\n    self.match_list = []\n    self.heuristics_qubits_param = heuristics_qubits_param if heuristics_qubits_param is not None else []\n    self.heuristics_backward_param = heuristics_backward_param if heuristics_backward_param is not None else []",
            "def __init__(self, circuit_dag_dep, template_dag_dep, heuristics_qubits_param=None, heuristics_backward_param=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Create a TemplateMatching object with necessary arguments.\\n        Args:\\n            circuit_dag_dep (QuantumCircuit): circuit.\\n            template_dag_dep (QuantumCircuit): template.\\n            heuristics_backward_param (list[int]): [length, survivor]\\n            heuristics_qubits_param (list[int]): [length]\\n        '\n    self.circuit_dag_dep = circuit_dag_dep\n    self.template_dag_dep = template_dag_dep\n    self.match_list = []\n    self.heuristics_qubits_param = heuristics_qubits_param if heuristics_qubits_param is not None else []\n    self.heuristics_backward_param = heuristics_backward_param if heuristics_backward_param is not None else []",
            "def __init__(self, circuit_dag_dep, template_dag_dep, heuristics_qubits_param=None, heuristics_backward_param=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Create a TemplateMatching object with necessary arguments.\\n        Args:\\n            circuit_dag_dep (QuantumCircuit): circuit.\\n            template_dag_dep (QuantumCircuit): template.\\n            heuristics_backward_param (list[int]): [length, survivor]\\n            heuristics_qubits_param (list[int]): [length]\\n        '\n    self.circuit_dag_dep = circuit_dag_dep\n    self.template_dag_dep = template_dag_dep\n    self.match_list = []\n    self.heuristics_qubits_param = heuristics_qubits_param if heuristics_qubits_param is not None else []\n    self.heuristics_backward_param = heuristics_backward_param if heuristics_backward_param is not None else []",
            "def __init__(self, circuit_dag_dep, template_dag_dep, heuristics_qubits_param=None, heuristics_backward_param=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Create a TemplateMatching object with necessary arguments.\\n        Args:\\n            circuit_dag_dep (QuantumCircuit): circuit.\\n            template_dag_dep (QuantumCircuit): template.\\n            heuristics_backward_param (list[int]): [length, survivor]\\n            heuristics_qubits_param (list[int]): [length]\\n        '\n    self.circuit_dag_dep = circuit_dag_dep\n    self.template_dag_dep = template_dag_dep\n    self.match_list = []\n    self.heuristics_qubits_param = heuristics_qubits_param if heuristics_qubits_param is not None else []\n    self.heuristics_backward_param = heuristics_backward_param if heuristics_backward_param is not None else []",
            "def __init__(self, circuit_dag_dep, template_dag_dep, heuristics_qubits_param=None, heuristics_backward_param=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Create a TemplateMatching object with necessary arguments.\\n        Args:\\n            circuit_dag_dep (QuantumCircuit): circuit.\\n            template_dag_dep (QuantumCircuit): template.\\n            heuristics_backward_param (list[int]): [length, survivor]\\n            heuristics_qubits_param (list[int]): [length]\\n        '\n    self.circuit_dag_dep = circuit_dag_dep\n    self.template_dag_dep = template_dag_dep\n    self.match_list = []\n    self.heuristics_qubits_param = heuristics_qubits_param if heuristics_qubits_param is not None else []\n    self.heuristics_backward_param = heuristics_backward_param if heuristics_backward_param is not None else []"
        ]
    },
    {
        "func_name": "_list_first_match_new",
        "original": "def _list_first_match_new(self, node_circuit, node_template, n_qubits_t, n_clbits_t):\n    \"\"\"\n        Returns the list of qubit for circuit given the first match, the unknown qubit are\n        replaced by -1.\n        Args:\n            node_circuit (DAGDepNode): First match node in the circuit.\n            node_template (DAGDepNode): First match node in the template.\n            n_qubits_t (int): number of qubit in the template.\n            n_clbits_t (int): number of classical bit in the template.\n        Returns:\n            list: list of qubits to consider in circuit (with specific order).\n        \"\"\"\n    l_q = []\n    if isinstance(node_circuit.op, ControlledGate) and node_template.op.num_ctrl_qubits > 1:\n        control = node_template.op.num_ctrl_qubits\n        control_qubits_circuit = node_circuit.qindices[:control]\n        not_control_qubits_circuit = node_circuit.qindices[control:]\n        if node_template.op.base_gate.name not in ['rxx', 'ryy', 'rzz', 'swap', 'iswap', 'ms']:\n            for control_perm_q in itertools.permutations(control_qubits_circuit):\n                control_perm_q = list(control_perm_q)\n                l_q_sub = [-1] * n_qubits_t\n                for q in node_template.qindices:\n                    node_circuit_perm = control_perm_q + not_control_qubits_circuit\n                    l_q_sub[q] = node_circuit_perm[node_template.qindices.index(q)]\n                l_q.append(l_q_sub)\n        else:\n            for control_perm_q in itertools.permutations(control_qubits_circuit):\n                control_perm_q = list(control_perm_q)\n                for not_control_perm_q in itertools.permutations(not_control_qubits_circuit):\n                    not_control_perm_q = list(not_control_perm_q)\n                    l_q_sub = [-1] * n_qubits_t\n                    for q in node_template.qindices:\n                        node_circuit_perm = control_perm_q + not_control_perm_q\n                        l_q_sub[q] = node_circuit_perm[node_template.qindices.index(q)]\n                    l_q.append(l_q_sub)\n    elif node_template.op.name not in ['rxx', 'ryy', 'rzz', 'swap', 'iswap', 'ms']:\n        l_q_sub = [-1] * n_qubits_t\n        for q in node_template.qindices:\n            l_q_sub[q] = node_circuit.qindices[node_template.qindices.index(q)]\n        l_q.append(l_q_sub)\n    else:\n        for perm_q in itertools.permutations(node_circuit.qindices):\n            l_q_sub = [-1] * n_qubits_t\n            for q in node_template.qindices:\n                l_q_sub[q] = perm_q[node_template.qindices.index(q)]\n            l_q.append(l_q_sub)\n    if not node_template.cindices or not node_circuit.cindices:\n        l_c = []\n    else:\n        l_c = [-1] * n_clbits_t\n        for c in node_template.cindices:\n            l_c[c] = node_circuit[node_template.cindices.index(c)]\n    return (l_q, l_c)",
        "mutated": [
            "def _list_first_match_new(self, node_circuit, node_template, n_qubits_t, n_clbits_t):\n    if False:\n        i = 10\n    '\\n        Returns the list of qubit for circuit given the first match, the unknown qubit are\\n        replaced by -1.\\n        Args:\\n            node_circuit (DAGDepNode): First match node in the circuit.\\n            node_template (DAGDepNode): First match node in the template.\\n            n_qubits_t (int): number of qubit in the template.\\n            n_clbits_t (int): number of classical bit in the template.\\n        Returns:\\n            list: list of qubits to consider in circuit (with specific order).\\n        '\n    l_q = []\n    if isinstance(node_circuit.op, ControlledGate) and node_template.op.num_ctrl_qubits > 1:\n        control = node_template.op.num_ctrl_qubits\n        control_qubits_circuit = node_circuit.qindices[:control]\n        not_control_qubits_circuit = node_circuit.qindices[control:]\n        if node_template.op.base_gate.name not in ['rxx', 'ryy', 'rzz', 'swap', 'iswap', 'ms']:\n            for control_perm_q in itertools.permutations(control_qubits_circuit):\n                control_perm_q = list(control_perm_q)\n                l_q_sub = [-1] * n_qubits_t\n                for q in node_template.qindices:\n                    node_circuit_perm = control_perm_q + not_control_qubits_circuit\n                    l_q_sub[q] = node_circuit_perm[node_template.qindices.index(q)]\n                l_q.append(l_q_sub)\n        else:\n            for control_perm_q in itertools.permutations(control_qubits_circuit):\n                control_perm_q = list(control_perm_q)\n                for not_control_perm_q in itertools.permutations(not_control_qubits_circuit):\n                    not_control_perm_q = list(not_control_perm_q)\n                    l_q_sub = [-1] * n_qubits_t\n                    for q in node_template.qindices:\n                        node_circuit_perm = control_perm_q + not_control_perm_q\n                        l_q_sub[q] = node_circuit_perm[node_template.qindices.index(q)]\n                    l_q.append(l_q_sub)\n    elif node_template.op.name not in ['rxx', 'ryy', 'rzz', 'swap', 'iswap', 'ms']:\n        l_q_sub = [-1] * n_qubits_t\n        for q in node_template.qindices:\n            l_q_sub[q] = node_circuit.qindices[node_template.qindices.index(q)]\n        l_q.append(l_q_sub)\n    else:\n        for perm_q in itertools.permutations(node_circuit.qindices):\n            l_q_sub = [-1] * n_qubits_t\n            for q in node_template.qindices:\n                l_q_sub[q] = perm_q[node_template.qindices.index(q)]\n            l_q.append(l_q_sub)\n    if not node_template.cindices or not node_circuit.cindices:\n        l_c = []\n    else:\n        l_c = [-1] * n_clbits_t\n        for c in node_template.cindices:\n            l_c[c] = node_circuit[node_template.cindices.index(c)]\n    return (l_q, l_c)",
            "def _list_first_match_new(self, node_circuit, node_template, n_qubits_t, n_clbits_t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Returns the list of qubit for circuit given the first match, the unknown qubit are\\n        replaced by -1.\\n        Args:\\n            node_circuit (DAGDepNode): First match node in the circuit.\\n            node_template (DAGDepNode): First match node in the template.\\n            n_qubits_t (int): number of qubit in the template.\\n            n_clbits_t (int): number of classical bit in the template.\\n        Returns:\\n            list: list of qubits to consider in circuit (with specific order).\\n        '\n    l_q = []\n    if isinstance(node_circuit.op, ControlledGate) and node_template.op.num_ctrl_qubits > 1:\n        control = node_template.op.num_ctrl_qubits\n        control_qubits_circuit = node_circuit.qindices[:control]\n        not_control_qubits_circuit = node_circuit.qindices[control:]\n        if node_template.op.base_gate.name not in ['rxx', 'ryy', 'rzz', 'swap', 'iswap', 'ms']:\n            for control_perm_q in itertools.permutations(control_qubits_circuit):\n                control_perm_q = list(control_perm_q)\n                l_q_sub = [-1] * n_qubits_t\n                for q in node_template.qindices:\n                    node_circuit_perm = control_perm_q + not_control_qubits_circuit\n                    l_q_sub[q] = node_circuit_perm[node_template.qindices.index(q)]\n                l_q.append(l_q_sub)\n        else:\n            for control_perm_q in itertools.permutations(control_qubits_circuit):\n                control_perm_q = list(control_perm_q)\n                for not_control_perm_q in itertools.permutations(not_control_qubits_circuit):\n                    not_control_perm_q = list(not_control_perm_q)\n                    l_q_sub = [-1] * n_qubits_t\n                    for q in node_template.qindices:\n                        node_circuit_perm = control_perm_q + not_control_perm_q\n                        l_q_sub[q] = node_circuit_perm[node_template.qindices.index(q)]\n                    l_q.append(l_q_sub)\n    elif node_template.op.name not in ['rxx', 'ryy', 'rzz', 'swap', 'iswap', 'ms']:\n        l_q_sub = [-1] * n_qubits_t\n        for q in node_template.qindices:\n            l_q_sub[q] = node_circuit.qindices[node_template.qindices.index(q)]\n        l_q.append(l_q_sub)\n    else:\n        for perm_q in itertools.permutations(node_circuit.qindices):\n            l_q_sub = [-1] * n_qubits_t\n            for q in node_template.qindices:\n                l_q_sub[q] = perm_q[node_template.qindices.index(q)]\n            l_q.append(l_q_sub)\n    if not node_template.cindices or not node_circuit.cindices:\n        l_c = []\n    else:\n        l_c = [-1] * n_clbits_t\n        for c in node_template.cindices:\n            l_c[c] = node_circuit[node_template.cindices.index(c)]\n    return (l_q, l_c)",
            "def _list_first_match_new(self, node_circuit, node_template, n_qubits_t, n_clbits_t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Returns the list of qubit for circuit given the first match, the unknown qubit are\\n        replaced by -1.\\n        Args:\\n            node_circuit (DAGDepNode): First match node in the circuit.\\n            node_template (DAGDepNode): First match node in the template.\\n            n_qubits_t (int): number of qubit in the template.\\n            n_clbits_t (int): number of classical bit in the template.\\n        Returns:\\n            list: list of qubits to consider in circuit (with specific order).\\n        '\n    l_q = []\n    if isinstance(node_circuit.op, ControlledGate) and node_template.op.num_ctrl_qubits > 1:\n        control = node_template.op.num_ctrl_qubits\n        control_qubits_circuit = node_circuit.qindices[:control]\n        not_control_qubits_circuit = node_circuit.qindices[control:]\n        if node_template.op.base_gate.name not in ['rxx', 'ryy', 'rzz', 'swap', 'iswap', 'ms']:\n            for control_perm_q in itertools.permutations(control_qubits_circuit):\n                control_perm_q = list(control_perm_q)\n                l_q_sub = [-1] * n_qubits_t\n                for q in node_template.qindices:\n                    node_circuit_perm = control_perm_q + not_control_qubits_circuit\n                    l_q_sub[q] = node_circuit_perm[node_template.qindices.index(q)]\n                l_q.append(l_q_sub)\n        else:\n            for control_perm_q in itertools.permutations(control_qubits_circuit):\n                control_perm_q = list(control_perm_q)\n                for not_control_perm_q in itertools.permutations(not_control_qubits_circuit):\n                    not_control_perm_q = list(not_control_perm_q)\n                    l_q_sub = [-1] * n_qubits_t\n                    for q in node_template.qindices:\n                        node_circuit_perm = control_perm_q + not_control_perm_q\n                        l_q_sub[q] = node_circuit_perm[node_template.qindices.index(q)]\n                    l_q.append(l_q_sub)\n    elif node_template.op.name not in ['rxx', 'ryy', 'rzz', 'swap', 'iswap', 'ms']:\n        l_q_sub = [-1] * n_qubits_t\n        for q in node_template.qindices:\n            l_q_sub[q] = node_circuit.qindices[node_template.qindices.index(q)]\n        l_q.append(l_q_sub)\n    else:\n        for perm_q in itertools.permutations(node_circuit.qindices):\n            l_q_sub = [-1] * n_qubits_t\n            for q in node_template.qindices:\n                l_q_sub[q] = perm_q[node_template.qindices.index(q)]\n            l_q.append(l_q_sub)\n    if not node_template.cindices or not node_circuit.cindices:\n        l_c = []\n    else:\n        l_c = [-1] * n_clbits_t\n        for c in node_template.cindices:\n            l_c[c] = node_circuit[node_template.cindices.index(c)]\n    return (l_q, l_c)",
            "def _list_first_match_new(self, node_circuit, node_template, n_qubits_t, n_clbits_t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Returns the list of qubit for circuit given the first match, the unknown qubit are\\n        replaced by -1.\\n        Args:\\n            node_circuit (DAGDepNode): First match node in the circuit.\\n            node_template (DAGDepNode): First match node in the template.\\n            n_qubits_t (int): number of qubit in the template.\\n            n_clbits_t (int): number of classical bit in the template.\\n        Returns:\\n            list: list of qubits to consider in circuit (with specific order).\\n        '\n    l_q = []\n    if isinstance(node_circuit.op, ControlledGate) and node_template.op.num_ctrl_qubits > 1:\n        control = node_template.op.num_ctrl_qubits\n        control_qubits_circuit = node_circuit.qindices[:control]\n        not_control_qubits_circuit = node_circuit.qindices[control:]\n        if node_template.op.base_gate.name not in ['rxx', 'ryy', 'rzz', 'swap', 'iswap', 'ms']:\n            for control_perm_q in itertools.permutations(control_qubits_circuit):\n                control_perm_q = list(control_perm_q)\n                l_q_sub = [-1] * n_qubits_t\n                for q in node_template.qindices:\n                    node_circuit_perm = control_perm_q + not_control_qubits_circuit\n                    l_q_sub[q] = node_circuit_perm[node_template.qindices.index(q)]\n                l_q.append(l_q_sub)\n        else:\n            for control_perm_q in itertools.permutations(control_qubits_circuit):\n                control_perm_q = list(control_perm_q)\n                for not_control_perm_q in itertools.permutations(not_control_qubits_circuit):\n                    not_control_perm_q = list(not_control_perm_q)\n                    l_q_sub = [-1] * n_qubits_t\n                    for q in node_template.qindices:\n                        node_circuit_perm = control_perm_q + not_control_perm_q\n                        l_q_sub[q] = node_circuit_perm[node_template.qindices.index(q)]\n                    l_q.append(l_q_sub)\n    elif node_template.op.name not in ['rxx', 'ryy', 'rzz', 'swap', 'iswap', 'ms']:\n        l_q_sub = [-1] * n_qubits_t\n        for q in node_template.qindices:\n            l_q_sub[q] = node_circuit.qindices[node_template.qindices.index(q)]\n        l_q.append(l_q_sub)\n    else:\n        for perm_q in itertools.permutations(node_circuit.qindices):\n            l_q_sub = [-1] * n_qubits_t\n            for q in node_template.qindices:\n                l_q_sub[q] = perm_q[node_template.qindices.index(q)]\n            l_q.append(l_q_sub)\n    if not node_template.cindices or not node_circuit.cindices:\n        l_c = []\n    else:\n        l_c = [-1] * n_clbits_t\n        for c in node_template.cindices:\n            l_c[c] = node_circuit[node_template.cindices.index(c)]\n    return (l_q, l_c)",
            "def _list_first_match_new(self, node_circuit, node_template, n_qubits_t, n_clbits_t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Returns the list of qubit for circuit given the first match, the unknown qubit are\\n        replaced by -1.\\n        Args:\\n            node_circuit (DAGDepNode): First match node in the circuit.\\n            node_template (DAGDepNode): First match node in the template.\\n            n_qubits_t (int): number of qubit in the template.\\n            n_clbits_t (int): number of classical bit in the template.\\n        Returns:\\n            list: list of qubits to consider in circuit (with specific order).\\n        '\n    l_q = []\n    if isinstance(node_circuit.op, ControlledGate) and node_template.op.num_ctrl_qubits > 1:\n        control = node_template.op.num_ctrl_qubits\n        control_qubits_circuit = node_circuit.qindices[:control]\n        not_control_qubits_circuit = node_circuit.qindices[control:]\n        if node_template.op.base_gate.name not in ['rxx', 'ryy', 'rzz', 'swap', 'iswap', 'ms']:\n            for control_perm_q in itertools.permutations(control_qubits_circuit):\n                control_perm_q = list(control_perm_q)\n                l_q_sub = [-1] * n_qubits_t\n                for q in node_template.qindices:\n                    node_circuit_perm = control_perm_q + not_control_qubits_circuit\n                    l_q_sub[q] = node_circuit_perm[node_template.qindices.index(q)]\n                l_q.append(l_q_sub)\n        else:\n            for control_perm_q in itertools.permutations(control_qubits_circuit):\n                control_perm_q = list(control_perm_q)\n                for not_control_perm_q in itertools.permutations(not_control_qubits_circuit):\n                    not_control_perm_q = list(not_control_perm_q)\n                    l_q_sub = [-1] * n_qubits_t\n                    for q in node_template.qindices:\n                        node_circuit_perm = control_perm_q + not_control_perm_q\n                        l_q_sub[q] = node_circuit_perm[node_template.qindices.index(q)]\n                    l_q.append(l_q_sub)\n    elif node_template.op.name not in ['rxx', 'ryy', 'rzz', 'swap', 'iswap', 'ms']:\n        l_q_sub = [-1] * n_qubits_t\n        for q in node_template.qindices:\n            l_q_sub[q] = node_circuit.qindices[node_template.qindices.index(q)]\n        l_q.append(l_q_sub)\n    else:\n        for perm_q in itertools.permutations(node_circuit.qindices):\n            l_q_sub = [-1] * n_qubits_t\n            for q in node_template.qindices:\n                l_q_sub[q] = perm_q[node_template.qindices.index(q)]\n            l_q.append(l_q_sub)\n    if not node_template.cindices or not node_circuit.cindices:\n        l_c = []\n    else:\n        l_c = [-1] * n_clbits_t\n        for c in node_template.cindices:\n            l_c[c] = node_circuit[node_template.cindices.index(c)]\n    return (l_q, l_c)"
        ]
    },
    {
        "func_name": "_sublist",
        "original": "def _sublist(self, lst, exclude, length):\n    \"\"\"\n        Function that returns all possible combinations of a given length, considering an\n        excluded list of elements.\n        Args:\n            lst (list): list of qubits indices from the circuit.\n            exclude (list): list of qubits from the first matched circuit gate.\n            length (int): length of the list to be returned (number of template qubit -\n            number of qubit from the first matched template gate).\n        Yield:\n            iterator: Iterator of the possible lists.\n        \"\"\"\n    for sublist in itertools.combinations([e for e in lst if e not in exclude], length):\n        yield list(sublist)",
        "mutated": [
            "def _sublist(self, lst, exclude, length):\n    if False:\n        i = 10\n    '\\n        Function that returns all possible combinations of a given length, considering an\\n        excluded list of elements.\\n        Args:\\n            lst (list): list of qubits indices from the circuit.\\n            exclude (list): list of qubits from the first matched circuit gate.\\n            length (int): length of the list to be returned (number of template qubit -\\n            number of qubit from the first matched template gate).\\n        Yield:\\n            iterator: Iterator of the possible lists.\\n        '\n    for sublist in itertools.combinations([e for e in lst if e not in exclude], length):\n        yield list(sublist)",
            "def _sublist(self, lst, exclude, length):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Function that returns all possible combinations of a given length, considering an\\n        excluded list of elements.\\n        Args:\\n            lst (list): list of qubits indices from the circuit.\\n            exclude (list): list of qubits from the first matched circuit gate.\\n            length (int): length of the list to be returned (number of template qubit -\\n            number of qubit from the first matched template gate).\\n        Yield:\\n            iterator: Iterator of the possible lists.\\n        '\n    for sublist in itertools.combinations([e for e in lst if e not in exclude], length):\n        yield list(sublist)",
            "def _sublist(self, lst, exclude, length):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Function that returns all possible combinations of a given length, considering an\\n        excluded list of elements.\\n        Args:\\n            lst (list): list of qubits indices from the circuit.\\n            exclude (list): list of qubits from the first matched circuit gate.\\n            length (int): length of the list to be returned (number of template qubit -\\n            number of qubit from the first matched template gate).\\n        Yield:\\n            iterator: Iterator of the possible lists.\\n        '\n    for sublist in itertools.combinations([e for e in lst if e not in exclude], length):\n        yield list(sublist)",
            "def _sublist(self, lst, exclude, length):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Function that returns all possible combinations of a given length, considering an\\n        excluded list of elements.\\n        Args:\\n            lst (list): list of qubits indices from the circuit.\\n            exclude (list): list of qubits from the first matched circuit gate.\\n            length (int): length of the list to be returned (number of template qubit -\\n            number of qubit from the first matched template gate).\\n        Yield:\\n            iterator: Iterator of the possible lists.\\n        '\n    for sublist in itertools.combinations([e for e in lst if e not in exclude], length):\n        yield list(sublist)",
            "def _sublist(self, lst, exclude, length):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Function that returns all possible combinations of a given length, considering an\\n        excluded list of elements.\\n        Args:\\n            lst (list): list of qubits indices from the circuit.\\n            exclude (list): list of qubits from the first matched circuit gate.\\n            length (int): length of the list to be returned (number of template qubit -\\n            number of qubit from the first matched template gate).\\n        Yield:\\n            iterator: Iterator of the possible lists.\\n        '\n    for sublist in itertools.combinations([e for e in lst if e not in exclude], length):\n        yield list(sublist)"
        ]
    },
    {
        "func_name": "_list_qubit_clbit_circuit",
        "original": "def _list_qubit_clbit_circuit(self, list_first_match, permutation):\n    \"\"\"\n        Function that returns the list of the circuit qubits and clbits give a permutation\n        and an initial match.\n        Args:\n            list_first_match (list): list of qubits indices for the initial match.\n            permutation (list): possible permutation for the circuit qubit.\n        Returns:\n            list: list of circuit qubit for the given permutation and initial match.\n        \"\"\"\n    list_circuit = []\n    counter = 0\n    for elem in list_first_match:\n        if elem == -1:\n            list_circuit.append(permutation[counter])\n            counter = counter + 1\n        else:\n            list_circuit.append(elem)\n    return list_circuit",
        "mutated": [
            "def _list_qubit_clbit_circuit(self, list_first_match, permutation):\n    if False:\n        i = 10\n    '\\n        Function that returns the list of the circuit qubits and clbits give a permutation\\n        and an initial match.\\n        Args:\\n            list_first_match (list): list of qubits indices for the initial match.\\n            permutation (list): possible permutation for the circuit qubit.\\n        Returns:\\n            list: list of circuit qubit for the given permutation and initial match.\\n        '\n    list_circuit = []\n    counter = 0\n    for elem in list_first_match:\n        if elem == -1:\n            list_circuit.append(permutation[counter])\n            counter = counter + 1\n        else:\n            list_circuit.append(elem)\n    return list_circuit",
            "def _list_qubit_clbit_circuit(self, list_first_match, permutation):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Function that returns the list of the circuit qubits and clbits give a permutation\\n        and an initial match.\\n        Args:\\n            list_first_match (list): list of qubits indices for the initial match.\\n            permutation (list): possible permutation for the circuit qubit.\\n        Returns:\\n            list: list of circuit qubit for the given permutation and initial match.\\n        '\n    list_circuit = []\n    counter = 0\n    for elem in list_first_match:\n        if elem == -1:\n            list_circuit.append(permutation[counter])\n            counter = counter + 1\n        else:\n            list_circuit.append(elem)\n    return list_circuit",
            "def _list_qubit_clbit_circuit(self, list_first_match, permutation):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Function that returns the list of the circuit qubits and clbits give a permutation\\n        and an initial match.\\n        Args:\\n            list_first_match (list): list of qubits indices for the initial match.\\n            permutation (list): possible permutation for the circuit qubit.\\n        Returns:\\n            list: list of circuit qubit for the given permutation and initial match.\\n        '\n    list_circuit = []\n    counter = 0\n    for elem in list_first_match:\n        if elem == -1:\n            list_circuit.append(permutation[counter])\n            counter = counter + 1\n        else:\n            list_circuit.append(elem)\n    return list_circuit",
            "def _list_qubit_clbit_circuit(self, list_first_match, permutation):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Function that returns the list of the circuit qubits and clbits give a permutation\\n        and an initial match.\\n        Args:\\n            list_first_match (list): list of qubits indices for the initial match.\\n            permutation (list): possible permutation for the circuit qubit.\\n        Returns:\\n            list: list of circuit qubit for the given permutation and initial match.\\n        '\n    list_circuit = []\n    counter = 0\n    for elem in list_first_match:\n        if elem == -1:\n            list_circuit.append(permutation[counter])\n            counter = counter + 1\n        else:\n            list_circuit.append(elem)\n    return list_circuit",
            "def _list_qubit_clbit_circuit(self, list_first_match, permutation):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Function that returns the list of the circuit qubits and clbits give a permutation\\n        and an initial match.\\n        Args:\\n            list_first_match (list): list of qubits indices for the initial match.\\n            permutation (list): possible permutation for the circuit qubit.\\n        Returns:\\n            list: list of circuit qubit for the given permutation and initial match.\\n        '\n    list_circuit = []\n    counter = 0\n    for elem in list_first_match:\n        if elem == -1:\n            list_circuit.append(permutation[counter])\n            counter = counter + 1\n        else:\n            list_circuit.append(elem)\n    return list_circuit"
        ]
    },
    {
        "func_name": "_add_match",
        "original": "def _add_match(self, backward_match_list):\n    \"\"\"\n        Method to add a match in list only if it is not already in it.\n        If the match is already in the list, the qubit configuration\n        is append to the existing match.\n        Args:\n            backward_match_list (list): match from the backward part of the\n            algorithm.\n        \"\"\"\n    already_in = False\n    for b_match in backward_match_list:\n        for l_match in self.match_list:\n            if b_match.match == l_match.match:\n                index = self.match_list.index(l_match)\n                self.match_list[index].qubit.append(b_match.qubit[0])\n                already_in = True\n        if not already_in:\n            self.match_list.append(b_match)",
        "mutated": [
            "def _add_match(self, backward_match_list):\n    if False:\n        i = 10\n    '\\n        Method to add a match in list only if it is not already in it.\\n        If the match is already in the list, the qubit configuration\\n        is append to the existing match.\\n        Args:\\n            backward_match_list (list): match from the backward part of the\\n            algorithm.\\n        '\n    already_in = False\n    for b_match in backward_match_list:\n        for l_match in self.match_list:\n            if b_match.match == l_match.match:\n                index = self.match_list.index(l_match)\n                self.match_list[index].qubit.append(b_match.qubit[0])\n                already_in = True\n        if not already_in:\n            self.match_list.append(b_match)",
            "def _add_match(self, backward_match_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Method to add a match in list only if it is not already in it.\\n        If the match is already in the list, the qubit configuration\\n        is append to the existing match.\\n        Args:\\n            backward_match_list (list): match from the backward part of the\\n            algorithm.\\n        '\n    already_in = False\n    for b_match in backward_match_list:\n        for l_match in self.match_list:\n            if b_match.match == l_match.match:\n                index = self.match_list.index(l_match)\n                self.match_list[index].qubit.append(b_match.qubit[0])\n                already_in = True\n        if not already_in:\n            self.match_list.append(b_match)",
            "def _add_match(self, backward_match_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Method to add a match in list only if it is not already in it.\\n        If the match is already in the list, the qubit configuration\\n        is append to the existing match.\\n        Args:\\n            backward_match_list (list): match from the backward part of the\\n            algorithm.\\n        '\n    already_in = False\n    for b_match in backward_match_list:\n        for l_match in self.match_list:\n            if b_match.match == l_match.match:\n                index = self.match_list.index(l_match)\n                self.match_list[index].qubit.append(b_match.qubit[0])\n                already_in = True\n        if not already_in:\n            self.match_list.append(b_match)",
            "def _add_match(self, backward_match_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Method to add a match in list only if it is not already in it.\\n        If the match is already in the list, the qubit configuration\\n        is append to the existing match.\\n        Args:\\n            backward_match_list (list): match from the backward part of the\\n            algorithm.\\n        '\n    already_in = False\n    for b_match in backward_match_list:\n        for l_match in self.match_list:\n            if b_match.match == l_match.match:\n                index = self.match_list.index(l_match)\n                self.match_list[index].qubit.append(b_match.qubit[0])\n                already_in = True\n        if not already_in:\n            self.match_list.append(b_match)",
            "def _add_match(self, backward_match_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Method to add a match in list only if it is not already in it.\\n        If the match is already in the list, the qubit configuration\\n        is append to the existing match.\\n        Args:\\n            backward_match_list (list): match from the backward part of the\\n            algorithm.\\n        '\n    already_in = False\n    for b_match in backward_match_list:\n        for l_match in self.match_list:\n            if b_match.match == l_match.match:\n                index = self.match_list.index(l_match)\n                self.match_list[index].qubit.append(b_match.qubit[0])\n                already_in = True\n        if not already_in:\n            self.match_list.append(b_match)"
        ]
    },
    {
        "func_name": "_explore_circuit",
        "original": "def _explore_circuit(self, node_id_c, node_id_t, n_qubits_t, length):\n    \"\"\"\n        Explore the successors of the node_id_c (up to the given length).\n        Args:\n            node_id_c (int): first match id in the circuit.\n            node_id_t (int): first match id in the template.\n            n_qubits_t (int): number of qubits in the template.\n            length (int): length for exploration of the successors.\n        Returns:\n            list: qubits configuration for the 'length' successors of node_id_c.\n        \"\"\"\n    template_nodes = range(node_id_t + 1, self.template_dag_dep.size())\n    circuit_nodes = range(0, self.circuit_dag_dep.size())\n    successors_template = self.template_dag_dep.get_node(node_id_t).successors\n    counter = 1\n    qubit_set = set(self.circuit_dag_dep.get_node(node_id_c).qindices)\n    if 2 * len(successors_template) > len(template_nodes):\n        successors = self.circuit_dag_dep.get_node(node_id_c).successors\n        for succ in successors:\n            qarg = self.circuit_dag_dep.get_node(succ).qindices\n            if len(qubit_set | set(qarg)) <= n_qubits_t and counter <= length:\n                qubit_set = qubit_set | set(qarg)\n                counter += 1\n            elif len(qubit_set | set(qarg)) > n_qubits_t:\n                return list(qubit_set)\n        return list(qubit_set)\n    else:\n        not_successors = list(set(circuit_nodes) - set(self.circuit_dag_dep.get_node(node_id_c).successors))\n        candidate = [not_successors[j] for j in range(len(not_successors) - 1, len(not_successors) - 1 - length, -1)]\n        for not_succ in candidate:\n            qarg = self.circuit_dag_dep.get_node(not_succ).qindices\n            if counter <= length and len(qubit_set | set(qarg)) <= n_qubits_t:\n                qubit_set = qubit_set | set(qarg)\n                counter += 1\n            elif len(qubit_set | set(qarg)) > n_qubits_t:\n                return list(qubit_set)\n        return list(qubit_set)",
        "mutated": [
            "def _explore_circuit(self, node_id_c, node_id_t, n_qubits_t, length):\n    if False:\n        i = 10\n    \"\\n        Explore the successors of the node_id_c (up to the given length).\\n        Args:\\n            node_id_c (int): first match id in the circuit.\\n            node_id_t (int): first match id in the template.\\n            n_qubits_t (int): number of qubits in the template.\\n            length (int): length for exploration of the successors.\\n        Returns:\\n            list: qubits configuration for the 'length' successors of node_id_c.\\n        \"\n    template_nodes = range(node_id_t + 1, self.template_dag_dep.size())\n    circuit_nodes = range(0, self.circuit_dag_dep.size())\n    successors_template = self.template_dag_dep.get_node(node_id_t).successors\n    counter = 1\n    qubit_set = set(self.circuit_dag_dep.get_node(node_id_c).qindices)\n    if 2 * len(successors_template) > len(template_nodes):\n        successors = self.circuit_dag_dep.get_node(node_id_c).successors\n        for succ in successors:\n            qarg = self.circuit_dag_dep.get_node(succ).qindices\n            if len(qubit_set | set(qarg)) <= n_qubits_t and counter <= length:\n                qubit_set = qubit_set | set(qarg)\n                counter += 1\n            elif len(qubit_set | set(qarg)) > n_qubits_t:\n                return list(qubit_set)\n        return list(qubit_set)\n    else:\n        not_successors = list(set(circuit_nodes) - set(self.circuit_dag_dep.get_node(node_id_c).successors))\n        candidate = [not_successors[j] for j in range(len(not_successors) - 1, len(not_successors) - 1 - length, -1)]\n        for not_succ in candidate:\n            qarg = self.circuit_dag_dep.get_node(not_succ).qindices\n            if counter <= length and len(qubit_set | set(qarg)) <= n_qubits_t:\n                qubit_set = qubit_set | set(qarg)\n                counter += 1\n            elif len(qubit_set | set(qarg)) > n_qubits_t:\n                return list(qubit_set)\n        return list(qubit_set)",
            "def _explore_circuit(self, node_id_c, node_id_t, n_qubits_t, length):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Explore the successors of the node_id_c (up to the given length).\\n        Args:\\n            node_id_c (int): first match id in the circuit.\\n            node_id_t (int): first match id in the template.\\n            n_qubits_t (int): number of qubits in the template.\\n            length (int): length for exploration of the successors.\\n        Returns:\\n            list: qubits configuration for the 'length' successors of node_id_c.\\n        \"\n    template_nodes = range(node_id_t + 1, self.template_dag_dep.size())\n    circuit_nodes = range(0, self.circuit_dag_dep.size())\n    successors_template = self.template_dag_dep.get_node(node_id_t).successors\n    counter = 1\n    qubit_set = set(self.circuit_dag_dep.get_node(node_id_c).qindices)\n    if 2 * len(successors_template) > len(template_nodes):\n        successors = self.circuit_dag_dep.get_node(node_id_c).successors\n        for succ in successors:\n            qarg = self.circuit_dag_dep.get_node(succ).qindices\n            if len(qubit_set | set(qarg)) <= n_qubits_t and counter <= length:\n                qubit_set = qubit_set | set(qarg)\n                counter += 1\n            elif len(qubit_set | set(qarg)) > n_qubits_t:\n                return list(qubit_set)\n        return list(qubit_set)\n    else:\n        not_successors = list(set(circuit_nodes) - set(self.circuit_dag_dep.get_node(node_id_c).successors))\n        candidate = [not_successors[j] for j in range(len(not_successors) - 1, len(not_successors) - 1 - length, -1)]\n        for not_succ in candidate:\n            qarg = self.circuit_dag_dep.get_node(not_succ).qindices\n            if counter <= length and len(qubit_set | set(qarg)) <= n_qubits_t:\n                qubit_set = qubit_set | set(qarg)\n                counter += 1\n            elif len(qubit_set | set(qarg)) > n_qubits_t:\n                return list(qubit_set)\n        return list(qubit_set)",
            "def _explore_circuit(self, node_id_c, node_id_t, n_qubits_t, length):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Explore the successors of the node_id_c (up to the given length).\\n        Args:\\n            node_id_c (int): first match id in the circuit.\\n            node_id_t (int): first match id in the template.\\n            n_qubits_t (int): number of qubits in the template.\\n            length (int): length for exploration of the successors.\\n        Returns:\\n            list: qubits configuration for the 'length' successors of node_id_c.\\n        \"\n    template_nodes = range(node_id_t + 1, self.template_dag_dep.size())\n    circuit_nodes = range(0, self.circuit_dag_dep.size())\n    successors_template = self.template_dag_dep.get_node(node_id_t).successors\n    counter = 1\n    qubit_set = set(self.circuit_dag_dep.get_node(node_id_c).qindices)\n    if 2 * len(successors_template) > len(template_nodes):\n        successors = self.circuit_dag_dep.get_node(node_id_c).successors\n        for succ in successors:\n            qarg = self.circuit_dag_dep.get_node(succ).qindices\n            if len(qubit_set | set(qarg)) <= n_qubits_t and counter <= length:\n                qubit_set = qubit_set | set(qarg)\n                counter += 1\n            elif len(qubit_set | set(qarg)) > n_qubits_t:\n                return list(qubit_set)\n        return list(qubit_set)\n    else:\n        not_successors = list(set(circuit_nodes) - set(self.circuit_dag_dep.get_node(node_id_c).successors))\n        candidate = [not_successors[j] for j in range(len(not_successors) - 1, len(not_successors) - 1 - length, -1)]\n        for not_succ in candidate:\n            qarg = self.circuit_dag_dep.get_node(not_succ).qindices\n            if counter <= length and len(qubit_set | set(qarg)) <= n_qubits_t:\n                qubit_set = qubit_set | set(qarg)\n                counter += 1\n            elif len(qubit_set | set(qarg)) > n_qubits_t:\n                return list(qubit_set)\n        return list(qubit_set)",
            "def _explore_circuit(self, node_id_c, node_id_t, n_qubits_t, length):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Explore the successors of the node_id_c (up to the given length).\\n        Args:\\n            node_id_c (int): first match id in the circuit.\\n            node_id_t (int): first match id in the template.\\n            n_qubits_t (int): number of qubits in the template.\\n            length (int): length for exploration of the successors.\\n        Returns:\\n            list: qubits configuration for the 'length' successors of node_id_c.\\n        \"\n    template_nodes = range(node_id_t + 1, self.template_dag_dep.size())\n    circuit_nodes = range(0, self.circuit_dag_dep.size())\n    successors_template = self.template_dag_dep.get_node(node_id_t).successors\n    counter = 1\n    qubit_set = set(self.circuit_dag_dep.get_node(node_id_c).qindices)\n    if 2 * len(successors_template) > len(template_nodes):\n        successors = self.circuit_dag_dep.get_node(node_id_c).successors\n        for succ in successors:\n            qarg = self.circuit_dag_dep.get_node(succ).qindices\n            if len(qubit_set | set(qarg)) <= n_qubits_t and counter <= length:\n                qubit_set = qubit_set | set(qarg)\n                counter += 1\n            elif len(qubit_set | set(qarg)) > n_qubits_t:\n                return list(qubit_set)\n        return list(qubit_set)\n    else:\n        not_successors = list(set(circuit_nodes) - set(self.circuit_dag_dep.get_node(node_id_c).successors))\n        candidate = [not_successors[j] for j in range(len(not_successors) - 1, len(not_successors) - 1 - length, -1)]\n        for not_succ in candidate:\n            qarg = self.circuit_dag_dep.get_node(not_succ).qindices\n            if counter <= length and len(qubit_set | set(qarg)) <= n_qubits_t:\n                qubit_set = qubit_set | set(qarg)\n                counter += 1\n            elif len(qubit_set | set(qarg)) > n_qubits_t:\n                return list(qubit_set)\n        return list(qubit_set)",
            "def _explore_circuit(self, node_id_c, node_id_t, n_qubits_t, length):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Explore the successors of the node_id_c (up to the given length).\\n        Args:\\n            node_id_c (int): first match id in the circuit.\\n            node_id_t (int): first match id in the template.\\n            n_qubits_t (int): number of qubits in the template.\\n            length (int): length for exploration of the successors.\\n        Returns:\\n            list: qubits configuration for the 'length' successors of node_id_c.\\n        \"\n    template_nodes = range(node_id_t + 1, self.template_dag_dep.size())\n    circuit_nodes = range(0, self.circuit_dag_dep.size())\n    successors_template = self.template_dag_dep.get_node(node_id_t).successors\n    counter = 1\n    qubit_set = set(self.circuit_dag_dep.get_node(node_id_c).qindices)\n    if 2 * len(successors_template) > len(template_nodes):\n        successors = self.circuit_dag_dep.get_node(node_id_c).successors\n        for succ in successors:\n            qarg = self.circuit_dag_dep.get_node(succ).qindices\n            if len(qubit_set | set(qarg)) <= n_qubits_t and counter <= length:\n                qubit_set = qubit_set | set(qarg)\n                counter += 1\n            elif len(qubit_set | set(qarg)) > n_qubits_t:\n                return list(qubit_set)\n        return list(qubit_set)\n    else:\n        not_successors = list(set(circuit_nodes) - set(self.circuit_dag_dep.get_node(node_id_c).successors))\n        candidate = [not_successors[j] for j in range(len(not_successors) - 1, len(not_successors) - 1 - length, -1)]\n        for not_succ in candidate:\n            qarg = self.circuit_dag_dep.get_node(not_succ).qindices\n            if counter <= length and len(qubit_set | set(qarg)) <= n_qubits_t:\n                qubit_set = qubit_set | set(qarg)\n                counter += 1\n            elif len(qubit_set | set(qarg)) > n_qubits_t:\n                return list(qubit_set)\n        return list(qubit_set)"
        ]
    },
    {
        "func_name": "run_template_matching",
        "original": "def run_template_matching(self):\n    \"\"\"\n        Run the complete algorithm for finding all maximal matches for the given template and\n        circuit. First it fixes the configuration of the circuit due to the first match.\n        Then it explores all compatible qubit configurations of the circuit. For each\n        qubit configurations, we apply first the Forward part of the algorithm  and then\n        the Backward part of the algorithm. The longest matches for the given configuration\n        are stored. Finally, the list of stored matches is sorted.\n        \"\"\"\n    n_qubits_c = len(self.circuit_dag_dep.qubits)\n    n_clbits_c = len(self.circuit_dag_dep.clbits)\n    n_qubits_t = len(self.template_dag_dep.qubits)\n    n_clbits_t = len(self.template_dag_dep.clbits)\n    for template_index in range(0, self.template_dag_dep.size()):\n        for circuit_index in range(0, self.circuit_dag_dep.size()):\n            if self.circuit_dag_dep.get_node(circuit_index).op.soft_compare(self.template_dag_dep.get_node(template_index).op):\n                qarg_c = self.circuit_dag_dep.get_node(circuit_index).qindices\n                carg_c = self.circuit_dag_dep.get_node(circuit_index).cindices\n                qarg_t = self.template_dag_dep.get_node(template_index).qindices\n                carg_t = self.template_dag_dep.get_node(template_index).cindices\n                node_id_c = circuit_index\n                node_id_t = template_index\n                (all_list_first_match_q, list_first_match_c) = self._list_first_match_new(self.circuit_dag_dep.get_node(circuit_index), self.template_dag_dep.get_node(template_index), n_qubits_t, n_clbits_t)\n                list_circuit_q = list(range(0, n_qubits_c))\n                list_circuit_c = list(range(0, n_clbits_c))\n                if self.heuristics_qubits_param:\n                    heuristics_qubits = self._explore_circuit(node_id_c, node_id_t, n_qubits_t, self.heuristics_qubits_param[0])\n                else:\n                    heuristics_qubits = []\n                for sub_q in self._sublist(list_circuit_q, qarg_c, n_qubits_t - len(qarg_t)):\n                    if set(heuristics_qubits).issubset(set(sub_q) | set(qarg_c)):\n                        for perm_q in itertools.permutations(sub_q):\n                            perm_q = list(perm_q)\n                            for list_first_match_q in all_list_first_match_q:\n                                list_qubit_circuit = self._list_qubit_clbit_circuit(list_first_match_q, perm_q)\n                                if list_circuit_c:\n                                    for sub_c in self._sublist(list_circuit_c, carg_c, n_clbits_t - len(carg_t)):\n                                        for perm_c in itertools.permutations(sub_c):\n                                            perm_c = list(perm_c)\n                                            list_clbit_circuit = self._list_qubit_clbit_circuit(list_first_match_c, perm_c)\n                                            forward = ForwardMatch(self.circuit_dag_dep, self.template_dag_dep, node_id_c, node_id_t, list_qubit_circuit, list_clbit_circuit)\n                                            forward.run_forward_match()\n                                            backward = BackwardMatch(forward.circuit_dag_dep, forward.template_dag_dep, forward.match, node_id_c, node_id_t, list_qubit_circuit, list_clbit_circuit, self.heuristics_backward_param)\n                                            backward.run_backward_match()\n                                            self._add_match(backward.match_final)\n                                else:\n                                    forward = ForwardMatch(self.circuit_dag_dep, self.template_dag_dep, node_id_c, node_id_t, list_qubit_circuit)\n                                    forward.run_forward_match()\n                                    backward = BackwardMatch(forward.circuit_dag_dep, forward.template_dag_dep, forward.match, node_id_c, node_id_t, list_qubit_circuit, [], self.heuristics_backward_param)\n                                    backward.run_backward_match()\n                                    self._add_match(backward.match_final)\n    self.match_list.sort(key=lambda x: len(x.match), reverse=True)",
        "mutated": [
            "def run_template_matching(self):\n    if False:\n        i = 10\n    '\\n        Run the complete algorithm for finding all maximal matches for the given template and\\n        circuit. First it fixes the configuration of the circuit due to the first match.\\n        Then it explores all compatible qubit configurations of the circuit. For each\\n        qubit configurations, we apply first the Forward part of the algorithm  and then\\n        the Backward part of the algorithm. The longest matches for the given configuration\\n        are stored. Finally, the list of stored matches is sorted.\\n        '\n    n_qubits_c = len(self.circuit_dag_dep.qubits)\n    n_clbits_c = len(self.circuit_dag_dep.clbits)\n    n_qubits_t = len(self.template_dag_dep.qubits)\n    n_clbits_t = len(self.template_dag_dep.clbits)\n    for template_index in range(0, self.template_dag_dep.size()):\n        for circuit_index in range(0, self.circuit_dag_dep.size()):\n            if self.circuit_dag_dep.get_node(circuit_index).op.soft_compare(self.template_dag_dep.get_node(template_index).op):\n                qarg_c = self.circuit_dag_dep.get_node(circuit_index).qindices\n                carg_c = self.circuit_dag_dep.get_node(circuit_index).cindices\n                qarg_t = self.template_dag_dep.get_node(template_index).qindices\n                carg_t = self.template_dag_dep.get_node(template_index).cindices\n                node_id_c = circuit_index\n                node_id_t = template_index\n                (all_list_first_match_q, list_first_match_c) = self._list_first_match_new(self.circuit_dag_dep.get_node(circuit_index), self.template_dag_dep.get_node(template_index), n_qubits_t, n_clbits_t)\n                list_circuit_q = list(range(0, n_qubits_c))\n                list_circuit_c = list(range(0, n_clbits_c))\n                if self.heuristics_qubits_param:\n                    heuristics_qubits = self._explore_circuit(node_id_c, node_id_t, n_qubits_t, self.heuristics_qubits_param[0])\n                else:\n                    heuristics_qubits = []\n                for sub_q in self._sublist(list_circuit_q, qarg_c, n_qubits_t - len(qarg_t)):\n                    if set(heuristics_qubits).issubset(set(sub_q) | set(qarg_c)):\n                        for perm_q in itertools.permutations(sub_q):\n                            perm_q = list(perm_q)\n                            for list_first_match_q in all_list_first_match_q:\n                                list_qubit_circuit = self._list_qubit_clbit_circuit(list_first_match_q, perm_q)\n                                if list_circuit_c:\n                                    for sub_c in self._sublist(list_circuit_c, carg_c, n_clbits_t - len(carg_t)):\n                                        for perm_c in itertools.permutations(sub_c):\n                                            perm_c = list(perm_c)\n                                            list_clbit_circuit = self._list_qubit_clbit_circuit(list_first_match_c, perm_c)\n                                            forward = ForwardMatch(self.circuit_dag_dep, self.template_dag_dep, node_id_c, node_id_t, list_qubit_circuit, list_clbit_circuit)\n                                            forward.run_forward_match()\n                                            backward = BackwardMatch(forward.circuit_dag_dep, forward.template_dag_dep, forward.match, node_id_c, node_id_t, list_qubit_circuit, list_clbit_circuit, self.heuristics_backward_param)\n                                            backward.run_backward_match()\n                                            self._add_match(backward.match_final)\n                                else:\n                                    forward = ForwardMatch(self.circuit_dag_dep, self.template_dag_dep, node_id_c, node_id_t, list_qubit_circuit)\n                                    forward.run_forward_match()\n                                    backward = BackwardMatch(forward.circuit_dag_dep, forward.template_dag_dep, forward.match, node_id_c, node_id_t, list_qubit_circuit, [], self.heuristics_backward_param)\n                                    backward.run_backward_match()\n                                    self._add_match(backward.match_final)\n    self.match_list.sort(key=lambda x: len(x.match), reverse=True)",
            "def run_template_matching(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Run the complete algorithm for finding all maximal matches for the given template and\\n        circuit. First it fixes the configuration of the circuit due to the first match.\\n        Then it explores all compatible qubit configurations of the circuit. For each\\n        qubit configurations, we apply first the Forward part of the algorithm  and then\\n        the Backward part of the algorithm. The longest matches for the given configuration\\n        are stored. Finally, the list of stored matches is sorted.\\n        '\n    n_qubits_c = len(self.circuit_dag_dep.qubits)\n    n_clbits_c = len(self.circuit_dag_dep.clbits)\n    n_qubits_t = len(self.template_dag_dep.qubits)\n    n_clbits_t = len(self.template_dag_dep.clbits)\n    for template_index in range(0, self.template_dag_dep.size()):\n        for circuit_index in range(0, self.circuit_dag_dep.size()):\n            if self.circuit_dag_dep.get_node(circuit_index).op.soft_compare(self.template_dag_dep.get_node(template_index).op):\n                qarg_c = self.circuit_dag_dep.get_node(circuit_index).qindices\n                carg_c = self.circuit_dag_dep.get_node(circuit_index).cindices\n                qarg_t = self.template_dag_dep.get_node(template_index).qindices\n                carg_t = self.template_dag_dep.get_node(template_index).cindices\n                node_id_c = circuit_index\n                node_id_t = template_index\n                (all_list_first_match_q, list_first_match_c) = self._list_first_match_new(self.circuit_dag_dep.get_node(circuit_index), self.template_dag_dep.get_node(template_index), n_qubits_t, n_clbits_t)\n                list_circuit_q = list(range(0, n_qubits_c))\n                list_circuit_c = list(range(0, n_clbits_c))\n                if self.heuristics_qubits_param:\n                    heuristics_qubits = self._explore_circuit(node_id_c, node_id_t, n_qubits_t, self.heuristics_qubits_param[0])\n                else:\n                    heuristics_qubits = []\n                for sub_q in self._sublist(list_circuit_q, qarg_c, n_qubits_t - len(qarg_t)):\n                    if set(heuristics_qubits).issubset(set(sub_q) | set(qarg_c)):\n                        for perm_q in itertools.permutations(sub_q):\n                            perm_q = list(perm_q)\n                            for list_first_match_q in all_list_first_match_q:\n                                list_qubit_circuit = self._list_qubit_clbit_circuit(list_first_match_q, perm_q)\n                                if list_circuit_c:\n                                    for sub_c in self._sublist(list_circuit_c, carg_c, n_clbits_t - len(carg_t)):\n                                        for perm_c in itertools.permutations(sub_c):\n                                            perm_c = list(perm_c)\n                                            list_clbit_circuit = self._list_qubit_clbit_circuit(list_first_match_c, perm_c)\n                                            forward = ForwardMatch(self.circuit_dag_dep, self.template_dag_dep, node_id_c, node_id_t, list_qubit_circuit, list_clbit_circuit)\n                                            forward.run_forward_match()\n                                            backward = BackwardMatch(forward.circuit_dag_dep, forward.template_dag_dep, forward.match, node_id_c, node_id_t, list_qubit_circuit, list_clbit_circuit, self.heuristics_backward_param)\n                                            backward.run_backward_match()\n                                            self._add_match(backward.match_final)\n                                else:\n                                    forward = ForwardMatch(self.circuit_dag_dep, self.template_dag_dep, node_id_c, node_id_t, list_qubit_circuit)\n                                    forward.run_forward_match()\n                                    backward = BackwardMatch(forward.circuit_dag_dep, forward.template_dag_dep, forward.match, node_id_c, node_id_t, list_qubit_circuit, [], self.heuristics_backward_param)\n                                    backward.run_backward_match()\n                                    self._add_match(backward.match_final)\n    self.match_list.sort(key=lambda x: len(x.match), reverse=True)",
            "def run_template_matching(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Run the complete algorithm for finding all maximal matches for the given template and\\n        circuit. First it fixes the configuration of the circuit due to the first match.\\n        Then it explores all compatible qubit configurations of the circuit. For each\\n        qubit configurations, we apply first the Forward part of the algorithm  and then\\n        the Backward part of the algorithm. The longest matches for the given configuration\\n        are stored. Finally, the list of stored matches is sorted.\\n        '\n    n_qubits_c = len(self.circuit_dag_dep.qubits)\n    n_clbits_c = len(self.circuit_dag_dep.clbits)\n    n_qubits_t = len(self.template_dag_dep.qubits)\n    n_clbits_t = len(self.template_dag_dep.clbits)\n    for template_index in range(0, self.template_dag_dep.size()):\n        for circuit_index in range(0, self.circuit_dag_dep.size()):\n            if self.circuit_dag_dep.get_node(circuit_index).op.soft_compare(self.template_dag_dep.get_node(template_index).op):\n                qarg_c = self.circuit_dag_dep.get_node(circuit_index).qindices\n                carg_c = self.circuit_dag_dep.get_node(circuit_index).cindices\n                qarg_t = self.template_dag_dep.get_node(template_index).qindices\n                carg_t = self.template_dag_dep.get_node(template_index).cindices\n                node_id_c = circuit_index\n                node_id_t = template_index\n                (all_list_first_match_q, list_first_match_c) = self._list_first_match_new(self.circuit_dag_dep.get_node(circuit_index), self.template_dag_dep.get_node(template_index), n_qubits_t, n_clbits_t)\n                list_circuit_q = list(range(0, n_qubits_c))\n                list_circuit_c = list(range(0, n_clbits_c))\n                if self.heuristics_qubits_param:\n                    heuristics_qubits = self._explore_circuit(node_id_c, node_id_t, n_qubits_t, self.heuristics_qubits_param[0])\n                else:\n                    heuristics_qubits = []\n                for sub_q in self._sublist(list_circuit_q, qarg_c, n_qubits_t - len(qarg_t)):\n                    if set(heuristics_qubits).issubset(set(sub_q) | set(qarg_c)):\n                        for perm_q in itertools.permutations(sub_q):\n                            perm_q = list(perm_q)\n                            for list_first_match_q in all_list_first_match_q:\n                                list_qubit_circuit = self._list_qubit_clbit_circuit(list_first_match_q, perm_q)\n                                if list_circuit_c:\n                                    for sub_c in self._sublist(list_circuit_c, carg_c, n_clbits_t - len(carg_t)):\n                                        for perm_c in itertools.permutations(sub_c):\n                                            perm_c = list(perm_c)\n                                            list_clbit_circuit = self._list_qubit_clbit_circuit(list_first_match_c, perm_c)\n                                            forward = ForwardMatch(self.circuit_dag_dep, self.template_dag_dep, node_id_c, node_id_t, list_qubit_circuit, list_clbit_circuit)\n                                            forward.run_forward_match()\n                                            backward = BackwardMatch(forward.circuit_dag_dep, forward.template_dag_dep, forward.match, node_id_c, node_id_t, list_qubit_circuit, list_clbit_circuit, self.heuristics_backward_param)\n                                            backward.run_backward_match()\n                                            self._add_match(backward.match_final)\n                                else:\n                                    forward = ForwardMatch(self.circuit_dag_dep, self.template_dag_dep, node_id_c, node_id_t, list_qubit_circuit)\n                                    forward.run_forward_match()\n                                    backward = BackwardMatch(forward.circuit_dag_dep, forward.template_dag_dep, forward.match, node_id_c, node_id_t, list_qubit_circuit, [], self.heuristics_backward_param)\n                                    backward.run_backward_match()\n                                    self._add_match(backward.match_final)\n    self.match_list.sort(key=lambda x: len(x.match), reverse=True)",
            "def run_template_matching(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Run the complete algorithm for finding all maximal matches for the given template and\\n        circuit. First it fixes the configuration of the circuit due to the first match.\\n        Then it explores all compatible qubit configurations of the circuit. For each\\n        qubit configurations, we apply first the Forward part of the algorithm  and then\\n        the Backward part of the algorithm. The longest matches for the given configuration\\n        are stored. Finally, the list of stored matches is sorted.\\n        '\n    n_qubits_c = len(self.circuit_dag_dep.qubits)\n    n_clbits_c = len(self.circuit_dag_dep.clbits)\n    n_qubits_t = len(self.template_dag_dep.qubits)\n    n_clbits_t = len(self.template_dag_dep.clbits)\n    for template_index in range(0, self.template_dag_dep.size()):\n        for circuit_index in range(0, self.circuit_dag_dep.size()):\n            if self.circuit_dag_dep.get_node(circuit_index).op.soft_compare(self.template_dag_dep.get_node(template_index).op):\n                qarg_c = self.circuit_dag_dep.get_node(circuit_index).qindices\n                carg_c = self.circuit_dag_dep.get_node(circuit_index).cindices\n                qarg_t = self.template_dag_dep.get_node(template_index).qindices\n                carg_t = self.template_dag_dep.get_node(template_index).cindices\n                node_id_c = circuit_index\n                node_id_t = template_index\n                (all_list_first_match_q, list_first_match_c) = self._list_first_match_new(self.circuit_dag_dep.get_node(circuit_index), self.template_dag_dep.get_node(template_index), n_qubits_t, n_clbits_t)\n                list_circuit_q = list(range(0, n_qubits_c))\n                list_circuit_c = list(range(0, n_clbits_c))\n                if self.heuristics_qubits_param:\n                    heuristics_qubits = self._explore_circuit(node_id_c, node_id_t, n_qubits_t, self.heuristics_qubits_param[0])\n                else:\n                    heuristics_qubits = []\n                for sub_q in self._sublist(list_circuit_q, qarg_c, n_qubits_t - len(qarg_t)):\n                    if set(heuristics_qubits).issubset(set(sub_q) | set(qarg_c)):\n                        for perm_q in itertools.permutations(sub_q):\n                            perm_q = list(perm_q)\n                            for list_first_match_q in all_list_first_match_q:\n                                list_qubit_circuit = self._list_qubit_clbit_circuit(list_first_match_q, perm_q)\n                                if list_circuit_c:\n                                    for sub_c in self._sublist(list_circuit_c, carg_c, n_clbits_t - len(carg_t)):\n                                        for perm_c in itertools.permutations(sub_c):\n                                            perm_c = list(perm_c)\n                                            list_clbit_circuit = self._list_qubit_clbit_circuit(list_first_match_c, perm_c)\n                                            forward = ForwardMatch(self.circuit_dag_dep, self.template_dag_dep, node_id_c, node_id_t, list_qubit_circuit, list_clbit_circuit)\n                                            forward.run_forward_match()\n                                            backward = BackwardMatch(forward.circuit_dag_dep, forward.template_dag_dep, forward.match, node_id_c, node_id_t, list_qubit_circuit, list_clbit_circuit, self.heuristics_backward_param)\n                                            backward.run_backward_match()\n                                            self._add_match(backward.match_final)\n                                else:\n                                    forward = ForwardMatch(self.circuit_dag_dep, self.template_dag_dep, node_id_c, node_id_t, list_qubit_circuit)\n                                    forward.run_forward_match()\n                                    backward = BackwardMatch(forward.circuit_dag_dep, forward.template_dag_dep, forward.match, node_id_c, node_id_t, list_qubit_circuit, [], self.heuristics_backward_param)\n                                    backward.run_backward_match()\n                                    self._add_match(backward.match_final)\n    self.match_list.sort(key=lambda x: len(x.match), reverse=True)",
            "def run_template_matching(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Run the complete algorithm for finding all maximal matches for the given template and\\n        circuit. First it fixes the configuration of the circuit due to the first match.\\n        Then it explores all compatible qubit configurations of the circuit. For each\\n        qubit configurations, we apply first the Forward part of the algorithm  and then\\n        the Backward part of the algorithm. The longest matches for the given configuration\\n        are stored. Finally, the list of stored matches is sorted.\\n        '\n    n_qubits_c = len(self.circuit_dag_dep.qubits)\n    n_clbits_c = len(self.circuit_dag_dep.clbits)\n    n_qubits_t = len(self.template_dag_dep.qubits)\n    n_clbits_t = len(self.template_dag_dep.clbits)\n    for template_index in range(0, self.template_dag_dep.size()):\n        for circuit_index in range(0, self.circuit_dag_dep.size()):\n            if self.circuit_dag_dep.get_node(circuit_index).op.soft_compare(self.template_dag_dep.get_node(template_index).op):\n                qarg_c = self.circuit_dag_dep.get_node(circuit_index).qindices\n                carg_c = self.circuit_dag_dep.get_node(circuit_index).cindices\n                qarg_t = self.template_dag_dep.get_node(template_index).qindices\n                carg_t = self.template_dag_dep.get_node(template_index).cindices\n                node_id_c = circuit_index\n                node_id_t = template_index\n                (all_list_first_match_q, list_first_match_c) = self._list_first_match_new(self.circuit_dag_dep.get_node(circuit_index), self.template_dag_dep.get_node(template_index), n_qubits_t, n_clbits_t)\n                list_circuit_q = list(range(0, n_qubits_c))\n                list_circuit_c = list(range(0, n_clbits_c))\n                if self.heuristics_qubits_param:\n                    heuristics_qubits = self._explore_circuit(node_id_c, node_id_t, n_qubits_t, self.heuristics_qubits_param[0])\n                else:\n                    heuristics_qubits = []\n                for sub_q in self._sublist(list_circuit_q, qarg_c, n_qubits_t - len(qarg_t)):\n                    if set(heuristics_qubits).issubset(set(sub_q) | set(qarg_c)):\n                        for perm_q in itertools.permutations(sub_q):\n                            perm_q = list(perm_q)\n                            for list_first_match_q in all_list_first_match_q:\n                                list_qubit_circuit = self._list_qubit_clbit_circuit(list_first_match_q, perm_q)\n                                if list_circuit_c:\n                                    for sub_c in self._sublist(list_circuit_c, carg_c, n_clbits_t - len(carg_t)):\n                                        for perm_c in itertools.permutations(sub_c):\n                                            perm_c = list(perm_c)\n                                            list_clbit_circuit = self._list_qubit_clbit_circuit(list_first_match_c, perm_c)\n                                            forward = ForwardMatch(self.circuit_dag_dep, self.template_dag_dep, node_id_c, node_id_t, list_qubit_circuit, list_clbit_circuit)\n                                            forward.run_forward_match()\n                                            backward = BackwardMatch(forward.circuit_dag_dep, forward.template_dag_dep, forward.match, node_id_c, node_id_t, list_qubit_circuit, list_clbit_circuit, self.heuristics_backward_param)\n                                            backward.run_backward_match()\n                                            self._add_match(backward.match_final)\n                                else:\n                                    forward = ForwardMatch(self.circuit_dag_dep, self.template_dag_dep, node_id_c, node_id_t, list_qubit_circuit)\n                                    forward.run_forward_match()\n                                    backward = BackwardMatch(forward.circuit_dag_dep, forward.template_dag_dep, forward.match, node_id_c, node_id_t, list_qubit_circuit, [], self.heuristics_backward_param)\n                                    backward.run_backward_match()\n                                    self._add_match(backward.match_final)\n    self.match_list.sort(key=lambda x: len(x.match), reverse=True)"
        ]
    }
]