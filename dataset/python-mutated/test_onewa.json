[
    {
        "func_name": "test_oneway_effectsize",
        "original": "def test_oneway_effectsize():\n    F = 5\n    df1 = 3\n    df2 = 76\n    nobs = 80\n    ci = confint_noncentrality(F, (df1, df2), alpha=0.05, alternative='two-sided')\n    ci_es = confint_effectsize_oneway(F, (df1, df2), alpha=0.05)\n    ci_steiger = ci_es.ci_f * np.sqrt(4 / 3)\n    res_ci_steiger = [0.1764, 0.7367]\n    res_ci_nc = np.asarray([1.8666, 32.563])\n    assert_allclose(ci, res_ci_nc, atol=0.0001)\n    assert_allclose(ci_es.ci_f_corrected, res_ci_steiger, atol=6e-05)\n    assert_allclose(ci_steiger, res_ci_steiger, atol=6e-05)\n    assert_allclose(ci_es.ci_f ** 2, res_ci_nc / nobs, atol=6e-05)\n    assert_allclose(ci_es.ci_nc, res_ci_nc, atol=0.0001)",
        "mutated": [
            "def test_oneway_effectsize():\n    if False:\n        i = 10\n    F = 5\n    df1 = 3\n    df2 = 76\n    nobs = 80\n    ci = confint_noncentrality(F, (df1, df2), alpha=0.05, alternative='two-sided')\n    ci_es = confint_effectsize_oneway(F, (df1, df2), alpha=0.05)\n    ci_steiger = ci_es.ci_f * np.sqrt(4 / 3)\n    res_ci_steiger = [0.1764, 0.7367]\n    res_ci_nc = np.asarray([1.8666, 32.563])\n    assert_allclose(ci, res_ci_nc, atol=0.0001)\n    assert_allclose(ci_es.ci_f_corrected, res_ci_steiger, atol=6e-05)\n    assert_allclose(ci_steiger, res_ci_steiger, atol=6e-05)\n    assert_allclose(ci_es.ci_f ** 2, res_ci_nc / nobs, atol=6e-05)\n    assert_allclose(ci_es.ci_nc, res_ci_nc, atol=0.0001)",
            "def test_oneway_effectsize():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    F = 5\n    df1 = 3\n    df2 = 76\n    nobs = 80\n    ci = confint_noncentrality(F, (df1, df2), alpha=0.05, alternative='two-sided')\n    ci_es = confint_effectsize_oneway(F, (df1, df2), alpha=0.05)\n    ci_steiger = ci_es.ci_f * np.sqrt(4 / 3)\n    res_ci_steiger = [0.1764, 0.7367]\n    res_ci_nc = np.asarray([1.8666, 32.563])\n    assert_allclose(ci, res_ci_nc, atol=0.0001)\n    assert_allclose(ci_es.ci_f_corrected, res_ci_steiger, atol=6e-05)\n    assert_allclose(ci_steiger, res_ci_steiger, atol=6e-05)\n    assert_allclose(ci_es.ci_f ** 2, res_ci_nc / nobs, atol=6e-05)\n    assert_allclose(ci_es.ci_nc, res_ci_nc, atol=0.0001)",
            "def test_oneway_effectsize():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    F = 5\n    df1 = 3\n    df2 = 76\n    nobs = 80\n    ci = confint_noncentrality(F, (df1, df2), alpha=0.05, alternative='two-sided')\n    ci_es = confint_effectsize_oneway(F, (df1, df2), alpha=0.05)\n    ci_steiger = ci_es.ci_f * np.sqrt(4 / 3)\n    res_ci_steiger = [0.1764, 0.7367]\n    res_ci_nc = np.asarray([1.8666, 32.563])\n    assert_allclose(ci, res_ci_nc, atol=0.0001)\n    assert_allclose(ci_es.ci_f_corrected, res_ci_steiger, atol=6e-05)\n    assert_allclose(ci_steiger, res_ci_steiger, atol=6e-05)\n    assert_allclose(ci_es.ci_f ** 2, res_ci_nc / nobs, atol=6e-05)\n    assert_allclose(ci_es.ci_nc, res_ci_nc, atol=0.0001)",
            "def test_oneway_effectsize():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    F = 5\n    df1 = 3\n    df2 = 76\n    nobs = 80\n    ci = confint_noncentrality(F, (df1, df2), alpha=0.05, alternative='two-sided')\n    ci_es = confint_effectsize_oneway(F, (df1, df2), alpha=0.05)\n    ci_steiger = ci_es.ci_f * np.sqrt(4 / 3)\n    res_ci_steiger = [0.1764, 0.7367]\n    res_ci_nc = np.asarray([1.8666, 32.563])\n    assert_allclose(ci, res_ci_nc, atol=0.0001)\n    assert_allclose(ci_es.ci_f_corrected, res_ci_steiger, atol=6e-05)\n    assert_allclose(ci_steiger, res_ci_steiger, atol=6e-05)\n    assert_allclose(ci_es.ci_f ** 2, res_ci_nc / nobs, atol=6e-05)\n    assert_allclose(ci_es.ci_nc, res_ci_nc, atol=0.0001)",
            "def test_oneway_effectsize():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    F = 5\n    df1 = 3\n    df2 = 76\n    nobs = 80\n    ci = confint_noncentrality(F, (df1, df2), alpha=0.05, alternative='two-sided')\n    ci_es = confint_effectsize_oneway(F, (df1, df2), alpha=0.05)\n    ci_steiger = ci_es.ci_f * np.sqrt(4 / 3)\n    res_ci_steiger = [0.1764, 0.7367]\n    res_ci_nc = np.asarray([1.8666, 32.563])\n    assert_allclose(ci, res_ci_nc, atol=0.0001)\n    assert_allclose(ci_es.ci_f_corrected, res_ci_steiger, atol=6e-05)\n    assert_allclose(ci_steiger, res_ci_steiger, atol=6e-05)\n    assert_allclose(ci_es.ci_f ** 2, res_ci_nc / nobs, atol=6e-05)\n    assert_allclose(ci_es.ci_nc, res_ci_nc, atol=0.0001)"
        ]
    },
    {
        "func_name": "test_effectsize_power",
        "original": "def test_effectsize_power():\n    n_groups = 3\n    means = [527.86, 660.43, 649.14]\n    vars_ = 107.4304 ** 2\n    nobs = 12\n    es = effectsize_oneway(means, vars_, nobs, use_var='equal', ddof_between=0)\n    es = np.sqrt(es)\n    alpha = 0.05\n    power = 0.8\n    nobs_t = nobs * n_groups\n    kwds = {'effect_size': es, 'nobs': nobs_t, 'alpha': alpha, 'power': power, 'k_groups': n_groups}\n    from statsmodels.stats.power import FTestAnovaPower\n    res_pow = 0.8251\n    res_es = 0.559\n    kwds_ = kwds.copy()\n    del kwds_['power']\n    p = FTestAnovaPower().power(**kwds_)\n    assert_allclose(p, res_pow, atol=0.0001)\n    assert_allclose(es, res_es, atol=0.0006)\n    nobs = np.array([15, 9, 9])\n    kwds['nobs'] = nobs\n    es = effectsize_oneway(means, vars_, nobs, use_var='equal', ddof_between=0)\n    es = np.sqrt(es)\n    kwds['effect_size'] = es\n    p = FTestAnovaPower().power(**kwds_)\n    res_pow = 0.8297\n    res_es = 0.59\n    assert_allclose(p, res_pow, atol=0.005)\n    assert_allclose(es, res_es, atol=0.0006)",
        "mutated": [
            "def test_effectsize_power():\n    if False:\n        i = 10\n    n_groups = 3\n    means = [527.86, 660.43, 649.14]\n    vars_ = 107.4304 ** 2\n    nobs = 12\n    es = effectsize_oneway(means, vars_, nobs, use_var='equal', ddof_between=0)\n    es = np.sqrt(es)\n    alpha = 0.05\n    power = 0.8\n    nobs_t = nobs * n_groups\n    kwds = {'effect_size': es, 'nobs': nobs_t, 'alpha': alpha, 'power': power, 'k_groups': n_groups}\n    from statsmodels.stats.power import FTestAnovaPower\n    res_pow = 0.8251\n    res_es = 0.559\n    kwds_ = kwds.copy()\n    del kwds_['power']\n    p = FTestAnovaPower().power(**kwds_)\n    assert_allclose(p, res_pow, atol=0.0001)\n    assert_allclose(es, res_es, atol=0.0006)\n    nobs = np.array([15, 9, 9])\n    kwds['nobs'] = nobs\n    es = effectsize_oneway(means, vars_, nobs, use_var='equal', ddof_between=0)\n    es = np.sqrt(es)\n    kwds['effect_size'] = es\n    p = FTestAnovaPower().power(**kwds_)\n    res_pow = 0.8297\n    res_es = 0.59\n    assert_allclose(p, res_pow, atol=0.005)\n    assert_allclose(es, res_es, atol=0.0006)",
            "def test_effectsize_power():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    n_groups = 3\n    means = [527.86, 660.43, 649.14]\n    vars_ = 107.4304 ** 2\n    nobs = 12\n    es = effectsize_oneway(means, vars_, nobs, use_var='equal', ddof_between=0)\n    es = np.sqrt(es)\n    alpha = 0.05\n    power = 0.8\n    nobs_t = nobs * n_groups\n    kwds = {'effect_size': es, 'nobs': nobs_t, 'alpha': alpha, 'power': power, 'k_groups': n_groups}\n    from statsmodels.stats.power import FTestAnovaPower\n    res_pow = 0.8251\n    res_es = 0.559\n    kwds_ = kwds.copy()\n    del kwds_['power']\n    p = FTestAnovaPower().power(**kwds_)\n    assert_allclose(p, res_pow, atol=0.0001)\n    assert_allclose(es, res_es, atol=0.0006)\n    nobs = np.array([15, 9, 9])\n    kwds['nobs'] = nobs\n    es = effectsize_oneway(means, vars_, nobs, use_var='equal', ddof_between=0)\n    es = np.sqrt(es)\n    kwds['effect_size'] = es\n    p = FTestAnovaPower().power(**kwds_)\n    res_pow = 0.8297\n    res_es = 0.59\n    assert_allclose(p, res_pow, atol=0.005)\n    assert_allclose(es, res_es, atol=0.0006)",
            "def test_effectsize_power():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    n_groups = 3\n    means = [527.86, 660.43, 649.14]\n    vars_ = 107.4304 ** 2\n    nobs = 12\n    es = effectsize_oneway(means, vars_, nobs, use_var='equal', ddof_between=0)\n    es = np.sqrt(es)\n    alpha = 0.05\n    power = 0.8\n    nobs_t = nobs * n_groups\n    kwds = {'effect_size': es, 'nobs': nobs_t, 'alpha': alpha, 'power': power, 'k_groups': n_groups}\n    from statsmodels.stats.power import FTestAnovaPower\n    res_pow = 0.8251\n    res_es = 0.559\n    kwds_ = kwds.copy()\n    del kwds_['power']\n    p = FTestAnovaPower().power(**kwds_)\n    assert_allclose(p, res_pow, atol=0.0001)\n    assert_allclose(es, res_es, atol=0.0006)\n    nobs = np.array([15, 9, 9])\n    kwds['nobs'] = nobs\n    es = effectsize_oneway(means, vars_, nobs, use_var='equal', ddof_between=0)\n    es = np.sqrt(es)\n    kwds['effect_size'] = es\n    p = FTestAnovaPower().power(**kwds_)\n    res_pow = 0.8297\n    res_es = 0.59\n    assert_allclose(p, res_pow, atol=0.005)\n    assert_allclose(es, res_es, atol=0.0006)",
            "def test_effectsize_power():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    n_groups = 3\n    means = [527.86, 660.43, 649.14]\n    vars_ = 107.4304 ** 2\n    nobs = 12\n    es = effectsize_oneway(means, vars_, nobs, use_var='equal', ddof_between=0)\n    es = np.sqrt(es)\n    alpha = 0.05\n    power = 0.8\n    nobs_t = nobs * n_groups\n    kwds = {'effect_size': es, 'nobs': nobs_t, 'alpha': alpha, 'power': power, 'k_groups': n_groups}\n    from statsmodels.stats.power import FTestAnovaPower\n    res_pow = 0.8251\n    res_es = 0.559\n    kwds_ = kwds.copy()\n    del kwds_['power']\n    p = FTestAnovaPower().power(**kwds_)\n    assert_allclose(p, res_pow, atol=0.0001)\n    assert_allclose(es, res_es, atol=0.0006)\n    nobs = np.array([15, 9, 9])\n    kwds['nobs'] = nobs\n    es = effectsize_oneway(means, vars_, nobs, use_var='equal', ddof_between=0)\n    es = np.sqrt(es)\n    kwds['effect_size'] = es\n    p = FTestAnovaPower().power(**kwds_)\n    res_pow = 0.8297\n    res_es = 0.59\n    assert_allclose(p, res_pow, atol=0.005)\n    assert_allclose(es, res_es, atol=0.0006)",
            "def test_effectsize_power():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    n_groups = 3\n    means = [527.86, 660.43, 649.14]\n    vars_ = 107.4304 ** 2\n    nobs = 12\n    es = effectsize_oneway(means, vars_, nobs, use_var='equal', ddof_between=0)\n    es = np.sqrt(es)\n    alpha = 0.05\n    power = 0.8\n    nobs_t = nobs * n_groups\n    kwds = {'effect_size': es, 'nobs': nobs_t, 'alpha': alpha, 'power': power, 'k_groups': n_groups}\n    from statsmodels.stats.power import FTestAnovaPower\n    res_pow = 0.8251\n    res_es = 0.559\n    kwds_ = kwds.copy()\n    del kwds_['power']\n    p = FTestAnovaPower().power(**kwds_)\n    assert_allclose(p, res_pow, atol=0.0001)\n    assert_allclose(es, res_es, atol=0.0006)\n    nobs = np.array([15, 9, 9])\n    kwds['nobs'] = nobs\n    es = effectsize_oneway(means, vars_, nobs, use_var='equal', ddof_between=0)\n    es = np.sqrt(es)\n    kwds['effect_size'] = es\n    p = FTestAnovaPower().power(**kwds_)\n    res_pow = 0.8297\n    res_es = 0.59\n    assert_allclose(p, res_pow, atol=0.005)\n    assert_allclose(es, res_es, atol=0.0006)"
        ]
    },
    {
        "func_name": "test_effectsize_fstat",
        "original": "def test_effectsize_fstat():\n    Eta_Sq_partial = 0.796983758700696\n    CI_eta2 = (0.685670133284926, 0.855981325777856)\n    Epsilon_Sq_partial = 0.779582366589327\n    CI_eps2 = (0.658727573280777, 0.843636867987386)\n    Omega_Sq_partial = 0.775086505190311\n    CI_omega2 = (0.65286429480169, 0.840179680453464)\n    Cohens_f_partial = 1.98134153686695\n    CI_f = (1.47694659580859, 2.43793847155554)\n    (f_stat, df1, df2) = (45.8, 3, 35)\n    fes = smo._fstat2effectsize(f_stat, (df1, df2))\n    assert_allclose(np.sqrt(fes.f2), Cohens_f_partial, rtol=1e-13)\n    assert_allclose(fes.eta2, Eta_Sq_partial, rtol=1e-13)\n    assert_allclose(fes.eps2, Epsilon_Sq_partial, rtol=1e-13)\n    assert_allclose(fes.omega2, Omega_Sq_partial, rtol=1e-13)\n    ci_nc = confint_noncentrality(f_stat, (df1, df2), alpha=0.1)\n    ci_es = smo._fstat2effectsize(ci_nc / df1, (df1, df2))\n    assert_allclose(ci_es.eta2, CI_eta2, rtol=0.0002)\n    assert_allclose(ci_es.eps2, CI_eps2, rtol=0.0002)\n    assert_allclose(ci_es.omega2, CI_omega2, rtol=0.0002)\n    assert_allclose(np.sqrt(ci_es.f2), CI_f, rtol=0.0002)",
        "mutated": [
            "def test_effectsize_fstat():\n    if False:\n        i = 10\n    Eta_Sq_partial = 0.796983758700696\n    CI_eta2 = (0.685670133284926, 0.855981325777856)\n    Epsilon_Sq_partial = 0.779582366589327\n    CI_eps2 = (0.658727573280777, 0.843636867987386)\n    Omega_Sq_partial = 0.775086505190311\n    CI_omega2 = (0.65286429480169, 0.840179680453464)\n    Cohens_f_partial = 1.98134153686695\n    CI_f = (1.47694659580859, 2.43793847155554)\n    (f_stat, df1, df2) = (45.8, 3, 35)\n    fes = smo._fstat2effectsize(f_stat, (df1, df2))\n    assert_allclose(np.sqrt(fes.f2), Cohens_f_partial, rtol=1e-13)\n    assert_allclose(fes.eta2, Eta_Sq_partial, rtol=1e-13)\n    assert_allclose(fes.eps2, Epsilon_Sq_partial, rtol=1e-13)\n    assert_allclose(fes.omega2, Omega_Sq_partial, rtol=1e-13)\n    ci_nc = confint_noncentrality(f_stat, (df1, df2), alpha=0.1)\n    ci_es = smo._fstat2effectsize(ci_nc / df1, (df1, df2))\n    assert_allclose(ci_es.eta2, CI_eta2, rtol=0.0002)\n    assert_allclose(ci_es.eps2, CI_eps2, rtol=0.0002)\n    assert_allclose(ci_es.omega2, CI_omega2, rtol=0.0002)\n    assert_allclose(np.sqrt(ci_es.f2), CI_f, rtol=0.0002)",
            "def test_effectsize_fstat():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Eta_Sq_partial = 0.796983758700696\n    CI_eta2 = (0.685670133284926, 0.855981325777856)\n    Epsilon_Sq_partial = 0.779582366589327\n    CI_eps2 = (0.658727573280777, 0.843636867987386)\n    Omega_Sq_partial = 0.775086505190311\n    CI_omega2 = (0.65286429480169, 0.840179680453464)\n    Cohens_f_partial = 1.98134153686695\n    CI_f = (1.47694659580859, 2.43793847155554)\n    (f_stat, df1, df2) = (45.8, 3, 35)\n    fes = smo._fstat2effectsize(f_stat, (df1, df2))\n    assert_allclose(np.sqrt(fes.f2), Cohens_f_partial, rtol=1e-13)\n    assert_allclose(fes.eta2, Eta_Sq_partial, rtol=1e-13)\n    assert_allclose(fes.eps2, Epsilon_Sq_partial, rtol=1e-13)\n    assert_allclose(fes.omega2, Omega_Sq_partial, rtol=1e-13)\n    ci_nc = confint_noncentrality(f_stat, (df1, df2), alpha=0.1)\n    ci_es = smo._fstat2effectsize(ci_nc / df1, (df1, df2))\n    assert_allclose(ci_es.eta2, CI_eta2, rtol=0.0002)\n    assert_allclose(ci_es.eps2, CI_eps2, rtol=0.0002)\n    assert_allclose(ci_es.omega2, CI_omega2, rtol=0.0002)\n    assert_allclose(np.sqrt(ci_es.f2), CI_f, rtol=0.0002)",
            "def test_effectsize_fstat():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Eta_Sq_partial = 0.796983758700696\n    CI_eta2 = (0.685670133284926, 0.855981325777856)\n    Epsilon_Sq_partial = 0.779582366589327\n    CI_eps2 = (0.658727573280777, 0.843636867987386)\n    Omega_Sq_partial = 0.775086505190311\n    CI_omega2 = (0.65286429480169, 0.840179680453464)\n    Cohens_f_partial = 1.98134153686695\n    CI_f = (1.47694659580859, 2.43793847155554)\n    (f_stat, df1, df2) = (45.8, 3, 35)\n    fes = smo._fstat2effectsize(f_stat, (df1, df2))\n    assert_allclose(np.sqrt(fes.f2), Cohens_f_partial, rtol=1e-13)\n    assert_allclose(fes.eta2, Eta_Sq_partial, rtol=1e-13)\n    assert_allclose(fes.eps2, Epsilon_Sq_partial, rtol=1e-13)\n    assert_allclose(fes.omega2, Omega_Sq_partial, rtol=1e-13)\n    ci_nc = confint_noncentrality(f_stat, (df1, df2), alpha=0.1)\n    ci_es = smo._fstat2effectsize(ci_nc / df1, (df1, df2))\n    assert_allclose(ci_es.eta2, CI_eta2, rtol=0.0002)\n    assert_allclose(ci_es.eps2, CI_eps2, rtol=0.0002)\n    assert_allclose(ci_es.omega2, CI_omega2, rtol=0.0002)\n    assert_allclose(np.sqrt(ci_es.f2), CI_f, rtol=0.0002)",
            "def test_effectsize_fstat():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Eta_Sq_partial = 0.796983758700696\n    CI_eta2 = (0.685670133284926, 0.855981325777856)\n    Epsilon_Sq_partial = 0.779582366589327\n    CI_eps2 = (0.658727573280777, 0.843636867987386)\n    Omega_Sq_partial = 0.775086505190311\n    CI_omega2 = (0.65286429480169, 0.840179680453464)\n    Cohens_f_partial = 1.98134153686695\n    CI_f = (1.47694659580859, 2.43793847155554)\n    (f_stat, df1, df2) = (45.8, 3, 35)\n    fes = smo._fstat2effectsize(f_stat, (df1, df2))\n    assert_allclose(np.sqrt(fes.f2), Cohens_f_partial, rtol=1e-13)\n    assert_allclose(fes.eta2, Eta_Sq_partial, rtol=1e-13)\n    assert_allclose(fes.eps2, Epsilon_Sq_partial, rtol=1e-13)\n    assert_allclose(fes.omega2, Omega_Sq_partial, rtol=1e-13)\n    ci_nc = confint_noncentrality(f_stat, (df1, df2), alpha=0.1)\n    ci_es = smo._fstat2effectsize(ci_nc / df1, (df1, df2))\n    assert_allclose(ci_es.eta2, CI_eta2, rtol=0.0002)\n    assert_allclose(ci_es.eps2, CI_eps2, rtol=0.0002)\n    assert_allclose(ci_es.omega2, CI_omega2, rtol=0.0002)\n    assert_allclose(np.sqrt(ci_es.f2), CI_f, rtol=0.0002)",
            "def test_effectsize_fstat():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Eta_Sq_partial = 0.796983758700696\n    CI_eta2 = (0.685670133284926, 0.855981325777856)\n    Epsilon_Sq_partial = 0.779582366589327\n    CI_eps2 = (0.658727573280777, 0.843636867987386)\n    Omega_Sq_partial = 0.775086505190311\n    CI_omega2 = (0.65286429480169, 0.840179680453464)\n    Cohens_f_partial = 1.98134153686695\n    CI_f = (1.47694659580859, 2.43793847155554)\n    (f_stat, df1, df2) = (45.8, 3, 35)\n    fes = smo._fstat2effectsize(f_stat, (df1, df2))\n    assert_allclose(np.sqrt(fes.f2), Cohens_f_partial, rtol=1e-13)\n    assert_allclose(fes.eta2, Eta_Sq_partial, rtol=1e-13)\n    assert_allclose(fes.eps2, Epsilon_Sq_partial, rtol=1e-13)\n    assert_allclose(fes.omega2, Omega_Sq_partial, rtol=1e-13)\n    ci_nc = confint_noncentrality(f_stat, (df1, df2), alpha=0.1)\n    ci_es = smo._fstat2effectsize(ci_nc / df1, (df1, df2))\n    assert_allclose(ci_es.eta2, CI_eta2, rtol=0.0002)\n    assert_allclose(ci_es.eps2, CI_eps2, rtol=0.0002)\n    assert_allclose(ci_es.omega2, CI_omega2, rtol=0.0002)\n    assert_allclose(np.sqrt(ci_es.f2), CI_f, rtol=0.0002)"
        ]
    },
    {
        "func_name": "test_effectsize_fstat_stata",
        "original": "def test_effectsize_fstat_stata():\n    eta2 = 0.2720398648288652\n    lb_eta2 = 0.0742092468714613\n    ub_eta2 = 0.4156116886974804\n    omega2 = 0.2356418580703085\n    lb_omega2 = 0.0279197092150344\n    ub_omega2 = 0.3863922731323545\n    (f_stat, df1, df2) = (7.47403193349075, 2, 40)\n    fes = smo._fstat2effectsize(f_stat, (df1, df2))\n    assert_allclose(fes.eta2, eta2, rtol=1e-13)\n    assert_allclose(fes.omega2, omega2, rtol=0.02)\n    ci_es = smo.confint_effectsize_oneway(f_stat, (df1, df2), alpha=0.1)\n    assert_allclose(ci_es.eta2, (lb_eta2, ub_eta2), rtol=0.0001)\n    assert_allclose(ci_es.ci_omega2, (lb_omega2, ub_omega2), rtol=0.025)",
        "mutated": [
            "def test_effectsize_fstat_stata():\n    if False:\n        i = 10\n    eta2 = 0.2720398648288652\n    lb_eta2 = 0.0742092468714613\n    ub_eta2 = 0.4156116886974804\n    omega2 = 0.2356418580703085\n    lb_omega2 = 0.0279197092150344\n    ub_omega2 = 0.3863922731323545\n    (f_stat, df1, df2) = (7.47403193349075, 2, 40)\n    fes = smo._fstat2effectsize(f_stat, (df1, df2))\n    assert_allclose(fes.eta2, eta2, rtol=1e-13)\n    assert_allclose(fes.omega2, omega2, rtol=0.02)\n    ci_es = smo.confint_effectsize_oneway(f_stat, (df1, df2), alpha=0.1)\n    assert_allclose(ci_es.eta2, (lb_eta2, ub_eta2), rtol=0.0001)\n    assert_allclose(ci_es.ci_omega2, (lb_omega2, ub_omega2), rtol=0.025)",
            "def test_effectsize_fstat_stata():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    eta2 = 0.2720398648288652\n    lb_eta2 = 0.0742092468714613\n    ub_eta2 = 0.4156116886974804\n    omega2 = 0.2356418580703085\n    lb_omega2 = 0.0279197092150344\n    ub_omega2 = 0.3863922731323545\n    (f_stat, df1, df2) = (7.47403193349075, 2, 40)\n    fes = smo._fstat2effectsize(f_stat, (df1, df2))\n    assert_allclose(fes.eta2, eta2, rtol=1e-13)\n    assert_allclose(fes.omega2, omega2, rtol=0.02)\n    ci_es = smo.confint_effectsize_oneway(f_stat, (df1, df2), alpha=0.1)\n    assert_allclose(ci_es.eta2, (lb_eta2, ub_eta2), rtol=0.0001)\n    assert_allclose(ci_es.ci_omega2, (lb_omega2, ub_omega2), rtol=0.025)",
            "def test_effectsize_fstat_stata():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    eta2 = 0.2720398648288652\n    lb_eta2 = 0.0742092468714613\n    ub_eta2 = 0.4156116886974804\n    omega2 = 0.2356418580703085\n    lb_omega2 = 0.0279197092150344\n    ub_omega2 = 0.3863922731323545\n    (f_stat, df1, df2) = (7.47403193349075, 2, 40)\n    fes = smo._fstat2effectsize(f_stat, (df1, df2))\n    assert_allclose(fes.eta2, eta2, rtol=1e-13)\n    assert_allclose(fes.omega2, omega2, rtol=0.02)\n    ci_es = smo.confint_effectsize_oneway(f_stat, (df1, df2), alpha=0.1)\n    assert_allclose(ci_es.eta2, (lb_eta2, ub_eta2), rtol=0.0001)\n    assert_allclose(ci_es.ci_omega2, (lb_omega2, ub_omega2), rtol=0.025)",
            "def test_effectsize_fstat_stata():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    eta2 = 0.2720398648288652\n    lb_eta2 = 0.0742092468714613\n    ub_eta2 = 0.4156116886974804\n    omega2 = 0.2356418580703085\n    lb_omega2 = 0.0279197092150344\n    ub_omega2 = 0.3863922731323545\n    (f_stat, df1, df2) = (7.47403193349075, 2, 40)\n    fes = smo._fstat2effectsize(f_stat, (df1, df2))\n    assert_allclose(fes.eta2, eta2, rtol=1e-13)\n    assert_allclose(fes.omega2, omega2, rtol=0.02)\n    ci_es = smo.confint_effectsize_oneway(f_stat, (df1, df2), alpha=0.1)\n    assert_allclose(ci_es.eta2, (lb_eta2, ub_eta2), rtol=0.0001)\n    assert_allclose(ci_es.ci_omega2, (lb_omega2, ub_omega2), rtol=0.025)",
            "def test_effectsize_fstat_stata():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    eta2 = 0.2720398648288652\n    lb_eta2 = 0.0742092468714613\n    ub_eta2 = 0.4156116886974804\n    omega2 = 0.2356418580703085\n    lb_omega2 = 0.0279197092150344\n    ub_omega2 = 0.3863922731323545\n    (f_stat, df1, df2) = (7.47403193349075, 2, 40)\n    fes = smo._fstat2effectsize(f_stat, (df1, df2))\n    assert_allclose(fes.eta2, eta2, rtol=1e-13)\n    assert_allclose(fes.omega2, omega2, rtol=0.02)\n    ci_es = smo.confint_effectsize_oneway(f_stat, (df1, df2), alpha=0.1)\n    assert_allclose(ci_es.eta2, (lb_eta2, ub_eta2), rtol=0.0001)\n    assert_allclose(ci_es.ci_omega2, (lb_omega2, ub_omega2), rtol=0.025)"
        ]
    },
    {
        "func_name": "test_scale_transform",
        "original": "@pytest.mark.parametrize('center', ['median', 'mean', 'trimmed'])\ndef test_scale_transform(center):\n    x = np.random.randn(5, 3)\n    xt = scale_transform(x, center=center, transform='abs', trim_frac=0.2, axis=0)\n    xtt = scale_transform(x.T, center=center, transform='abs', trim_frac=0.2, axis=1)\n    assert_allclose(xt.T, xtt, rtol=1e-13)\n    xt0 = scale_transform(x[:, 0], center=center, transform='abs', trim_frac=0.2)\n    assert_allclose(xt0, xt[:, 0], rtol=1e-13)\n    assert_allclose(xt0, xtt[0, :], rtol=1e-13)",
        "mutated": [
            "@pytest.mark.parametrize('center', ['median', 'mean', 'trimmed'])\ndef test_scale_transform(center):\n    if False:\n        i = 10\n    x = np.random.randn(5, 3)\n    xt = scale_transform(x, center=center, transform='abs', trim_frac=0.2, axis=0)\n    xtt = scale_transform(x.T, center=center, transform='abs', trim_frac=0.2, axis=1)\n    assert_allclose(xt.T, xtt, rtol=1e-13)\n    xt0 = scale_transform(x[:, 0], center=center, transform='abs', trim_frac=0.2)\n    assert_allclose(xt0, xt[:, 0], rtol=1e-13)\n    assert_allclose(xt0, xtt[0, :], rtol=1e-13)",
            "@pytest.mark.parametrize('center', ['median', 'mean', 'trimmed'])\ndef test_scale_transform(center):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    x = np.random.randn(5, 3)\n    xt = scale_transform(x, center=center, transform='abs', trim_frac=0.2, axis=0)\n    xtt = scale_transform(x.T, center=center, transform='abs', trim_frac=0.2, axis=1)\n    assert_allclose(xt.T, xtt, rtol=1e-13)\n    xt0 = scale_transform(x[:, 0], center=center, transform='abs', trim_frac=0.2)\n    assert_allclose(xt0, xt[:, 0], rtol=1e-13)\n    assert_allclose(xt0, xtt[0, :], rtol=1e-13)",
            "@pytest.mark.parametrize('center', ['median', 'mean', 'trimmed'])\ndef test_scale_transform(center):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    x = np.random.randn(5, 3)\n    xt = scale_transform(x, center=center, transform='abs', trim_frac=0.2, axis=0)\n    xtt = scale_transform(x.T, center=center, transform='abs', trim_frac=0.2, axis=1)\n    assert_allclose(xt.T, xtt, rtol=1e-13)\n    xt0 = scale_transform(x[:, 0], center=center, transform='abs', trim_frac=0.2)\n    assert_allclose(xt0, xt[:, 0], rtol=1e-13)\n    assert_allclose(xt0, xtt[0, :], rtol=1e-13)",
            "@pytest.mark.parametrize('center', ['median', 'mean', 'trimmed'])\ndef test_scale_transform(center):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    x = np.random.randn(5, 3)\n    xt = scale_transform(x, center=center, transform='abs', trim_frac=0.2, axis=0)\n    xtt = scale_transform(x.T, center=center, transform='abs', trim_frac=0.2, axis=1)\n    assert_allclose(xt.T, xtt, rtol=1e-13)\n    xt0 = scale_transform(x[:, 0], center=center, transform='abs', trim_frac=0.2)\n    assert_allclose(xt0, xt[:, 0], rtol=1e-13)\n    assert_allclose(xt0, xtt[0, :], rtol=1e-13)",
            "@pytest.mark.parametrize('center', ['median', 'mean', 'trimmed'])\ndef test_scale_transform(center):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    x = np.random.randn(5, 3)\n    xt = scale_transform(x, center=center, transform='abs', trim_frac=0.2, axis=0)\n    xtt = scale_transform(x.T, center=center, transform='abs', trim_frac=0.2, axis=1)\n    assert_allclose(xt.T, xtt, rtol=1e-13)\n    xt0 = scale_transform(x[:, 0], center=center, transform='abs', trim_frac=0.2)\n    assert_allclose(xt0, xt[:, 0], rtol=1e-13)\n    assert_allclose(xt0, xtt[0, :], rtol=1e-13)"
        ]
    },
    {
        "func_name": "setup_class",
        "original": "@classmethod\ndef setup_class(cls):\n    y0 = [112.488, 103.738, 86.344, 101.708, 95.108, 105.931, 95.815, 91.864, 102.479, 102.644]\n    y1 = [100.421, 101.966, 99.636, 105.983, 88.377, 102.618, 105.486, 98.662, 94.137, 98.626, 89.367, 106.204]\n    y2 = [84.846, 100.488, 119.763, 103.736, 93.141, 108.254, 99.51, 89.005, 108.2, 82.209, 100.104, 103.706, 107.067]\n    y3 = [100.825, 100.255, 103.363, 93.23, 95.325, 100.288, 94.75, 107.129, 98.246, 96.365, 99.74, 106.049, 92.691, 93.111, 98.243]\n    n_groups = 4\n    arrs_w = [np.asarray(yi) for yi in [y0, y1, y2, y3]]\n    nobs = np.asarray([len(yi) for yi in arrs_w])\n    nobs_mean = np.mean(nobs)\n    means = np.asarray([yi.mean() for yi in arrs_w])\n    stds = np.asarray([yi.std(ddof=1) for yi in arrs_w])\n    cls.data = arrs_w\n    cls.means = means\n    cls.nobs = nobs\n    cls.stds = stds\n    cls.n_groups = n_groups\n    cls.nobs_mean = nobs_mean",
        "mutated": [
            "@classmethod\ndef setup_class(cls):\n    if False:\n        i = 10\n    y0 = [112.488, 103.738, 86.344, 101.708, 95.108, 105.931, 95.815, 91.864, 102.479, 102.644]\n    y1 = [100.421, 101.966, 99.636, 105.983, 88.377, 102.618, 105.486, 98.662, 94.137, 98.626, 89.367, 106.204]\n    y2 = [84.846, 100.488, 119.763, 103.736, 93.141, 108.254, 99.51, 89.005, 108.2, 82.209, 100.104, 103.706, 107.067]\n    y3 = [100.825, 100.255, 103.363, 93.23, 95.325, 100.288, 94.75, 107.129, 98.246, 96.365, 99.74, 106.049, 92.691, 93.111, 98.243]\n    n_groups = 4\n    arrs_w = [np.asarray(yi) for yi in [y0, y1, y2, y3]]\n    nobs = np.asarray([len(yi) for yi in arrs_w])\n    nobs_mean = np.mean(nobs)\n    means = np.asarray([yi.mean() for yi in arrs_w])\n    stds = np.asarray([yi.std(ddof=1) for yi in arrs_w])\n    cls.data = arrs_w\n    cls.means = means\n    cls.nobs = nobs\n    cls.stds = stds\n    cls.n_groups = n_groups\n    cls.nobs_mean = nobs_mean",
            "@classmethod\ndef setup_class(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    y0 = [112.488, 103.738, 86.344, 101.708, 95.108, 105.931, 95.815, 91.864, 102.479, 102.644]\n    y1 = [100.421, 101.966, 99.636, 105.983, 88.377, 102.618, 105.486, 98.662, 94.137, 98.626, 89.367, 106.204]\n    y2 = [84.846, 100.488, 119.763, 103.736, 93.141, 108.254, 99.51, 89.005, 108.2, 82.209, 100.104, 103.706, 107.067]\n    y3 = [100.825, 100.255, 103.363, 93.23, 95.325, 100.288, 94.75, 107.129, 98.246, 96.365, 99.74, 106.049, 92.691, 93.111, 98.243]\n    n_groups = 4\n    arrs_w = [np.asarray(yi) for yi in [y0, y1, y2, y3]]\n    nobs = np.asarray([len(yi) for yi in arrs_w])\n    nobs_mean = np.mean(nobs)\n    means = np.asarray([yi.mean() for yi in arrs_w])\n    stds = np.asarray([yi.std(ddof=1) for yi in arrs_w])\n    cls.data = arrs_w\n    cls.means = means\n    cls.nobs = nobs\n    cls.stds = stds\n    cls.n_groups = n_groups\n    cls.nobs_mean = nobs_mean",
            "@classmethod\ndef setup_class(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    y0 = [112.488, 103.738, 86.344, 101.708, 95.108, 105.931, 95.815, 91.864, 102.479, 102.644]\n    y1 = [100.421, 101.966, 99.636, 105.983, 88.377, 102.618, 105.486, 98.662, 94.137, 98.626, 89.367, 106.204]\n    y2 = [84.846, 100.488, 119.763, 103.736, 93.141, 108.254, 99.51, 89.005, 108.2, 82.209, 100.104, 103.706, 107.067]\n    y3 = [100.825, 100.255, 103.363, 93.23, 95.325, 100.288, 94.75, 107.129, 98.246, 96.365, 99.74, 106.049, 92.691, 93.111, 98.243]\n    n_groups = 4\n    arrs_w = [np.asarray(yi) for yi in [y0, y1, y2, y3]]\n    nobs = np.asarray([len(yi) for yi in arrs_w])\n    nobs_mean = np.mean(nobs)\n    means = np.asarray([yi.mean() for yi in arrs_w])\n    stds = np.asarray([yi.std(ddof=1) for yi in arrs_w])\n    cls.data = arrs_w\n    cls.means = means\n    cls.nobs = nobs\n    cls.stds = stds\n    cls.n_groups = n_groups\n    cls.nobs_mean = nobs_mean",
            "@classmethod\ndef setup_class(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    y0 = [112.488, 103.738, 86.344, 101.708, 95.108, 105.931, 95.815, 91.864, 102.479, 102.644]\n    y1 = [100.421, 101.966, 99.636, 105.983, 88.377, 102.618, 105.486, 98.662, 94.137, 98.626, 89.367, 106.204]\n    y2 = [84.846, 100.488, 119.763, 103.736, 93.141, 108.254, 99.51, 89.005, 108.2, 82.209, 100.104, 103.706, 107.067]\n    y3 = [100.825, 100.255, 103.363, 93.23, 95.325, 100.288, 94.75, 107.129, 98.246, 96.365, 99.74, 106.049, 92.691, 93.111, 98.243]\n    n_groups = 4\n    arrs_w = [np.asarray(yi) for yi in [y0, y1, y2, y3]]\n    nobs = np.asarray([len(yi) for yi in arrs_w])\n    nobs_mean = np.mean(nobs)\n    means = np.asarray([yi.mean() for yi in arrs_w])\n    stds = np.asarray([yi.std(ddof=1) for yi in arrs_w])\n    cls.data = arrs_w\n    cls.means = means\n    cls.nobs = nobs\n    cls.stds = stds\n    cls.n_groups = n_groups\n    cls.nobs_mean = nobs_mean",
            "@classmethod\ndef setup_class(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    y0 = [112.488, 103.738, 86.344, 101.708, 95.108, 105.931, 95.815, 91.864, 102.479, 102.644]\n    y1 = [100.421, 101.966, 99.636, 105.983, 88.377, 102.618, 105.486, 98.662, 94.137, 98.626, 89.367, 106.204]\n    y2 = [84.846, 100.488, 119.763, 103.736, 93.141, 108.254, 99.51, 89.005, 108.2, 82.209, 100.104, 103.706, 107.067]\n    y3 = [100.825, 100.255, 103.363, 93.23, 95.325, 100.288, 94.75, 107.129, 98.246, 96.365, 99.74, 106.049, 92.691, 93.111, 98.243]\n    n_groups = 4\n    arrs_w = [np.asarray(yi) for yi in [y0, y1, y2, y3]]\n    nobs = np.asarray([len(yi) for yi in arrs_w])\n    nobs_mean = np.mean(nobs)\n    means = np.asarray([yi.mean() for yi in arrs_w])\n    stds = np.asarray([yi.std(ddof=1) for yi in arrs_w])\n    cls.data = arrs_w\n    cls.means = means\n    cls.nobs = nobs\n    cls.stds = stds\n    cls.n_groups = n_groups\n    cls.nobs_mean = nobs_mean"
        ]
    },
    {
        "func_name": "test_equivalence_equal",
        "original": "def test_equivalence_equal(self):\n    means = self.means\n    nobs = self.nobs\n    stds = self.stds\n    n_groups = self.n_groups\n    eps = 0.5\n    res0 = anova_generic(means, stds ** 2, nobs, use_var='equal')\n    f = res0.statistic\n    res = equivalence_oneway_generic(f, n_groups, nobs.sum(), eps, res0.df, alpha=0.05, margin_type='wellek')\n    assert_allclose(res.pvalue, 0.0083, atol=0.001)\n    assert_equal(res.df, [3, 46])\n    assert_allclose(f, 0.0926, atol=0.0006)\n    res = equivalence_oneway(self.data, eps, use_var='equal', margin_type='wellek')\n    assert_allclose(res.pvalue, 0.0083, atol=0.001)\n    assert_equal(res.df, [3, 46])",
        "mutated": [
            "def test_equivalence_equal(self):\n    if False:\n        i = 10\n    means = self.means\n    nobs = self.nobs\n    stds = self.stds\n    n_groups = self.n_groups\n    eps = 0.5\n    res0 = anova_generic(means, stds ** 2, nobs, use_var='equal')\n    f = res0.statistic\n    res = equivalence_oneway_generic(f, n_groups, nobs.sum(), eps, res0.df, alpha=0.05, margin_type='wellek')\n    assert_allclose(res.pvalue, 0.0083, atol=0.001)\n    assert_equal(res.df, [3, 46])\n    assert_allclose(f, 0.0926, atol=0.0006)\n    res = equivalence_oneway(self.data, eps, use_var='equal', margin_type='wellek')\n    assert_allclose(res.pvalue, 0.0083, atol=0.001)\n    assert_equal(res.df, [3, 46])",
            "def test_equivalence_equal(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    means = self.means\n    nobs = self.nobs\n    stds = self.stds\n    n_groups = self.n_groups\n    eps = 0.5\n    res0 = anova_generic(means, stds ** 2, nobs, use_var='equal')\n    f = res0.statistic\n    res = equivalence_oneway_generic(f, n_groups, nobs.sum(), eps, res0.df, alpha=0.05, margin_type='wellek')\n    assert_allclose(res.pvalue, 0.0083, atol=0.001)\n    assert_equal(res.df, [3, 46])\n    assert_allclose(f, 0.0926, atol=0.0006)\n    res = equivalence_oneway(self.data, eps, use_var='equal', margin_type='wellek')\n    assert_allclose(res.pvalue, 0.0083, atol=0.001)\n    assert_equal(res.df, [3, 46])",
            "def test_equivalence_equal(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    means = self.means\n    nobs = self.nobs\n    stds = self.stds\n    n_groups = self.n_groups\n    eps = 0.5\n    res0 = anova_generic(means, stds ** 2, nobs, use_var='equal')\n    f = res0.statistic\n    res = equivalence_oneway_generic(f, n_groups, nobs.sum(), eps, res0.df, alpha=0.05, margin_type='wellek')\n    assert_allclose(res.pvalue, 0.0083, atol=0.001)\n    assert_equal(res.df, [3, 46])\n    assert_allclose(f, 0.0926, atol=0.0006)\n    res = equivalence_oneway(self.data, eps, use_var='equal', margin_type='wellek')\n    assert_allclose(res.pvalue, 0.0083, atol=0.001)\n    assert_equal(res.df, [3, 46])",
            "def test_equivalence_equal(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    means = self.means\n    nobs = self.nobs\n    stds = self.stds\n    n_groups = self.n_groups\n    eps = 0.5\n    res0 = anova_generic(means, stds ** 2, nobs, use_var='equal')\n    f = res0.statistic\n    res = equivalence_oneway_generic(f, n_groups, nobs.sum(), eps, res0.df, alpha=0.05, margin_type='wellek')\n    assert_allclose(res.pvalue, 0.0083, atol=0.001)\n    assert_equal(res.df, [3, 46])\n    assert_allclose(f, 0.0926, atol=0.0006)\n    res = equivalence_oneway(self.data, eps, use_var='equal', margin_type='wellek')\n    assert_allclose(res.pvalue, 0.0083, atol=0.001)\n    assert_equal(res.df, [3, 46])",
            "def test_equivalence_equal(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    means = self.means\n    nobs = self.nobs\n    stds = self.stds\n    n_groups = self.n_groups\n    eps = 0.5\n    res0 = anova_generic(means, stds ** 2, nobs, use_var='equal')\n    f = res0.statistic\n    res = equivalence_oneway_generic(f, n_groups, nobs.sum(), eps, res0.df, alpha=0.05, margin_type='wellek')\n    assert_allclose(res.pvalue, 0.0083, atol=0.001)\n    assert_equal(res.df, [3, 46])\n    assert_allclose(f, 0.0926, atol=0.0006)\n    res = equivalence_oneway(self.data, eps, use_var='equal', margin_type='wellek')\n    assert_allclose(res.pvalue, 0.0083, atol=0.001)\n    assert_equal(res.df, [3, 46])"
        ]
    },
    {
        "func_name": "test_equivalence_welch",
        "original": "def test_equivalence_welch(self):\n    means = self.means\n    nobs = self.nobs\n    stds = self.stds\n    n_groups = self.n_groups\n    vars_ = stds ** 2\n    eps = 0.5\n    res0 = anova_generic(means, vars_, nobs, use_var='unequal', welch_correction=False)\n    f_stat = res0.statistic\n    res = equivalence_oneway_generic(f_stat, n_groups, nobs.sum(), eps, res0.df, alpha=0.05, margin_type='wellek')\n    assert_allclose(res.pvalue, 0.011, atol=0.001)\n    assert_allclose(res.df, [3.0, 22.6536], atol=0.0006)\n    assert_allclose(f_stat, 0.1102, atol=0.007)\n    res = equivalence_oneway(self.data, eps, use_var='unequal', margin_type='wellek')\n    assert_allclose(res.pvalue, 0.011, atol=0.0001)\n    assert_allclose(res.df, [3.0, 22.6536], atol=0.0006)\n    assert_allclose(res.f_stat, 0.1102, atol=0.0001)\n    pow_ = _power_equivalence_oneway_emp(f_stat, n_groups, nobs, eps, res0.df)\n    assert_allclose(pow_, 0.1552, atol=0.007)\n    pow_ = power_equivalence_oneway(eps, eps, nobs.sum(), n_groups=n_groups, df=None, alpha=0.05, margin_type='wellek')\n    assert_allclose(pow_, 0.05, atol=1e-13)\n    nobs_t = nobs.sum()\n    es = effectsize_oneway(means, vars_, nobs, use_var='unequal')\n    es = np.sqrt(es)\n    es_w0 = f2_to_wellek(es ** 2, n_groups)\n    es_w = np.sqrt(fstat_to_wellek(f_stat, n_groups, nobs_t / n_groups))\n    pow_ = power_equivalence_oneway(es_w, eps, nobs_t, n_groups=n_groups, df=None, alpha=0.05, margin_type='wellek')\n    assert_allclose(pow_, 0.1552, atol=0.007)\n    assert_allclose(es_w0, es_w, atol=0.007)\n    margin = wellek_to_f2(eps, n_groups)\n    pow_ = power_equivalence_oneway(es ** 2, margin, nobs_t, n_groups=n_groups, df=None, alpha=0.05, margin_type='f2')\n    assert_allclose(pow_, 0.1552, atol=0.007)",
        "mutated": [
            "def test_equivalence_welch(self):\n    if False:\n        i = 10\n    means = self.means\n    nobs = self.nobs\n    stds = self.stds\n    n_groups = self.n_groups\n    vars_ = stds ** 2\n    eps = 0.5\n    res0 = anova_generic(means, vars_, nobs, use_var='unequal', welch_correction=False)\n    f_stat = res0.statistic\n    res = equivalence_oneway_generic(f_stat, n_groups, nobs.sum(), eps, res0.df, alpha=0.05, margin_type='wellek')\n    assert_allclose(res.pvalue, 0.011, atol=0.001)\n    assert_allclose(res.df, [3.0, 22.6536], atol=0.0006)\n    assert_allclose(f_stat, 0.1102, atol=0.007)\n    res = equivalence_oneway(self.data, eps, use_var='unequal', margin_type='wellek')\n    assert_allclose(res.pvalue, 0.011, atol=0.0001)\n    assert_allclose(res.df, [3.0, 22.6536], atol=0.0006)\n    assert_allclose(res.f_stat, 0.1102, atol=0.0001)\n    pow_ = _power_equivalence_oneway_emp(f_stat, n_groups, nobs, eps, res0.df)\n    assert_allclose(pow_, 0.1552, atol=0.007)\n    pow_ = power_equivalence_oneway(eps, eps, nobs.sum(), n_groups=n_groups, df=None, alpha=0.05, margin_type='wellek')\n    assert_allclose(pow_, 0.05, atol=1e-13)\n    nobs_t = nobs.sum()\n    es = effectsize_oneway(means, vars_, nobs, use_var='unequal')\n    es = np.sqrt(es)\n    es_w0 = f2_to_wellek(es ** 2, n_groups)\n    es_w = np.sqrt(fstat_to_wellek(f_stat, n_groups, nobs_t / n_groups))\n    pow_ = power_equivalence_oneway(es_w, eps, nobs_t, n_groups=n_groups, df=None, alpha=0.05, margin_type='wellek')\n    assert_allclose(pow_, 0.1552, atol=0.007)\n    assert_allclose(es_w0, es_w, atol=0.007)\n    margin = wellek_to_f2(eps, n_groups)\n    pow_ = power_equivalence_oneway(es ** 2, margin, nobs_t, n_groups=n_groups, df=None, alpha=0.05, margin_type='f2')\n    assert_allclose(pow_, 0.1552, atol=0.007)",
            "def test_equivalence_welch(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    means = self.means\n    nobs = self.nobs\n    stds = self.stds\n    n_groups = self.n_groups\n    vars_ = stds ** 2\n    eps = 0.5\n    res0 = anova_generic(means, vars_, nobs, use_var='unequal', welch_correction=False)\n    f_stat = res0.statistic\n    res = equivalence_oneway_generic(f_stat, n_groups, nobs.sum(), eps, res0.df, alpha=0.05, margin_type='wellek')\n    assert_allclose(res.pvalue, 0.011, atol=0.001)\n    assert_allclose(res.df, [3.0, 22.6536], atol=0.0006)\n    assert_allclose(f_stat, 0.1102, atol=0.007)\n    res = equivalence_oneway(self.data, eps, use_var='unequal', margin_type='wellek')\n    assert_allclose(res.pvalue, 0.011, atol=0.0001)\n    assert_allclose(res.df, [3.0, 22.6536], atol=0.0006)\n    assert_allclose(res.f_stat, 0.1102, atol=0.0001)\n    pow_ = _power_equivalence_oneway_emp(f_stat, n_groups, nobs, eps, res0.df)\n    assert_allclose(pow_, 0.1552, atol=0.007)\n    pow_ = power_equivalence_oneway(eps, eps, nobs.sum(), n_groups=n_groups, df=None, alpha=0.05, margin_type='wellek')\n    assert_allclose(pow_, 0.05, atol=1e-13)\n    nobs_t = nobs.sum()\n    es = effectsize_oneway(means, vars_, nobs, use_var='unequal')\n    es = np.sqrt(es)\n    es_w0 = f2_to_wellek(es ** 2, n_groups)\n    es_w = np.sqrt(fstat_to_wellek(f_stat, n_groups, nobs_t / n_groups))\n    pow_ = power_equivalence_oneway(es_w, eps, nobs_t, n_groups=n_groups, df=None, alpha=0.05, margin_type='wellek')\n    assert_allclose(pow_, 0.1552, atol=0.007)\n    assert_allclose(es_w0, es_w, atol=0.007)\n    margin = wellek_to_f2(eps, n_groups)\n    pow_ = power_equivalence_oneway(es ** 2, margin, nobs_t, n_groups=n_groups, df=None, alpha=0.05, margin_type='f2')\n    assert_allclose(pow_, 0.1552, atol=0.007)",
            "def test_equivalence_welch(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    means = self.means\n    nobs = self.nobs\n    stds = self.stds\n    n_groups = self.n_groups\n    vars_ = stds ** 2\n    eps = 0.5\n    res0 = anova_generic(means, vars_, nobs, use_var='unequal', welch_correction=False)\n    f_stat = res0.statistic\n    res = equivalence_oneway_generic(f_stat, n_groups, nobs.sum(), eps, res0.df, alpha=0.05, margin_type='wellek')\n    assert_allclose(res.pvalue, 0.011, atol=0.001)\n    assert_allclose(res.df, [3.0, 22.6536], atol=0.0006)\n    assert_allclose(f_stat, 0.1102, atol=0.007)\n    res = equivalence_oneway(self.data, eps, use_var='unequal', margin_type='wellek')\n    assert_allclose(res.pvalue, 0.011, atol=0.0001)\n    assert_allclose(res.df, [3.0, 22.6536], atol=0.0006)\n    assert_allclose(res.f_stat, 0.1102, atol=0.0001)\n    pow_ = _power_equivalence_oneway_emp(f_stat, n_groups, nobs, eps, res0.df)\n    assert_allclose(pow_, 0.1552, atol=0.007)\n    pow_ = power_equivalence_oneway(eps, eps, nobs.sum(), n_groups=n_groups, df=None, alpha=0.05, margin_type='wellek')\n    assert_allclose(pow_, 0.05, atol=1e-13)\n    nobs_t = nobs.sum()\n    es = effectsize_oneway(means, vars_, nobs, use_var='unequal')\n    es = np.sqrt(es)\n    es_w0 = f2_to_wellek(es ** 2, n_groups)\n    es_w = np.sqrt(fstat_to_wellek(f_stat, n_groups, nobs_t / n_groups))\n    pow_ = power_equivalence_oneway(es_w, eps, nobs_t, n_groups=n_groups, df=None, alpha=0.05, margin_type='wellek')\n    assert_allclose(pow_, 0.1552, atol=0.007)\n    assert_allclose(es_w0, es_w, atol=0.007)\n    margin = wellek_to_f2(eps, n_groups)\n    pow_ = power_equivalence_oneway(es ** 2, margin, nobs_t, n_groups=n_groups, df=None, alpha=0.05, margin_type='f2')\n    assert_allclose(pow_, 0.1552, atol=0.007)",
            "def test_equivalence_welch(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    means = self.means\n    nobs = self.nobs\n    stds = self.stds\n    n_groups = self.n_groups\n    vars_ = stds ** 2\n    eps = 0.5\n    res0 = anova_generic(means, vars_, nobs, use_var='unequal', welch_correction=False)\n    f_stat = res0.statistic\n    res = equivalence_oneway_generic(f_stat, n_groups, nobs.sum(), eps, res0.df, alpha=0.05, margin_type='wellek')\n    assert_allclose(res.pvalue, 0.011, atol=0.001)\n    assert_allclose(res.df, [3.0, 22.6536], atol=0.0006)\n    assert_allclose(f_stat, 0.1102, atol=0.007)\n    res = equivalence_oneway(self.data, eps, use_var='unequal', margin_type='wellek')\n    assert_allclose(res.pvalue, 0.011, atol=0.0001)\n    assert_allclose(res.df, [3.0, 22.6536], atol=0.0006)\n    assert_allclose(res.f_stat, 0.1102, atol=0.0001)\n    pow_ = _power_equivalence_oneway_emp(f_stat, n_groups, nobs, eps, res0.df)\n    assert_allclose(pow_, 0.1552, atol=0.007)\n    pow_ = power_equivalence_oneway(eps, eps, nobs.sum(), n_groups=n_groups, df=None, alpha=0.05, margin_type='wellek')\n    assert_allclose(pow_, 0.05, atol=1e-13)\n    nobs_t = nobs.sum()\n    es = effectsize_oneway(means, vars_, nobs, use_var='unequal')\n    es = np.sqrt(es)\n    es_w0 = f2_to_wellek(es ** 2, n_groups)\n    es_w = np.sqrt(fstat_to_wellek(f_stat, n_groups, nobs_t / n_groups))\n    pow_ = power_equivalence_oneway(es_w, eps, nobs_t, n_groups=n_groups, df=None, alpha=0.05, margin_type='wellek')\n    assert_allclose(pow_, 0.1552, atol=0.007)\n    assert_allclose(es_w0, es_w, atol=0.007)\n    margin = wellek_to_f2(eps, n_groups)\n    pow_ = power_equivalence_oneway(es ** 2, margin, nobs_t, n_groups=n_groups, df=None, alpha=0.05, margin_type='f2')\n    assert_allclose(pow_, 0.1552, atol=0.007)",
            "def test_equivalence_welch(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    means = self.means\n    nobs = self.nobs\n    stds = self.stds\n    n_groups = self.n_groups\n    vars_ = stds ** 2\n    eps = 0.5\n    res0 = anova_generic(means, vars_, nobs, use_var='unequal', welch_correction=False)\n    f_stat = res0.statistic\n    res = equivalence_oneway_generic(f_stat, n_groups, nobs.sum(), eps, res0.df, alpha=0.05, margin_type='wellek')\n    assert_allclose(res.pvalue, 0.011, atol=0.001)\n    assert_allclose(res.df, [3.0, 22.6536], atol=0.0006)\n    assert_allclose(f_stat, 0.1102, atol=0.007)\n    res = equivalence_oneway(self.data, eps, use_var='unequal', margin_type='wellek')\n    assert_allclose(res.pvalue, 0.011, atol=0.0001)\n    assert_allclose(res.df, [3.0, 22.6536], atol=0.0006)\n    assert_allclose(res.f_stat, 0.1102, atol=0.0001)\n    pow_ = _power_equivalence_oneway_emp(f_stat, n_groups, nobs, eps, res0.df)\n    assert_allclose(pow_, 0.1552, atol=0.007)\n    pow_ = power_equivalence_oneway(eps, eps, nobs.sum(), n_groups=n_groups, df=None, alpha=0.05, margin_type='wellek')\n    assert_allclose(pow_, 0.05, atol=1e-13)\n    nobs_t = nobs.sum()\n    es = effectsize_oneway(means, vars_, nobs, use_var='unequal')\n    es = np.sqrt(es)\n    es_w0 = f2_to_wellek(es ** 2, n_groups)\n    es_w = np.sqrt(fstat_to_wellek(f_stat, n_groups, nobs_t / n_groups))\n    pow_ = power_equivalence_oneway(es_w, eps, nobs_t, n_groups=n_groups, df=None, alpha=0.05, margin_type='wellek')\n    assert_allclose(pow_, 0.1552, atol=0.007)\n    assert_allclose(es_w0, es_w, atol=0.007)\n    margin = wellek_to_f2(eps, n_groups)\n    pow_ = power_equivalence_oneway(es ** 2, margin, nobs_t, n_groups=n_groups, df=None, alpha=0.05, margin_type='f2')\n    assert_allclose(pow_, 0.1552, atol=0.007)"
        ]
    },
    {
        "func_name": "setup_class",
        "original": "@classmethod\ndef setup_class(cls):\n    yt0 = np.array([102.0, 320.0, 0.0, 107.0, 198.0, 200.0, 4.0, 20.0, 110.0, 128.0, 7.0, 119.0, 309.0])\n    yt1 = np.array([0.0, 1.0, 228.0, 81.0, 87.0, 119.0, 79.0, 181.0, 43.0, 12.0, 90.0, 105.0, 108.0, 119.0, 0.0, 9.0])\n    yt2 = np.array([33.0, 294.0, 134.0, 216.0, 83.0, 105.0, 69.0, 20.0, 20.0, 63.0, 98.0, 155.0, 78.0, 75.0])\n    y0 = np.array([452.0, 874.0, 554.0, 447.0, 356.0, 754.0, 558.0, 574.0, 664.0, 682.0, 547.0, 435.0, 245.0])\n    y1 = np.array([546.0, 547.0, 774.0, 465.0, 459.0, 665.0, 467.0, 365.0, 589.0, 534.0, 456.0, 651.0, 654.0, 665.0, 546.0, 537.0])\n    y2 = np.array([785.0, 458.0, 886.0, 536.0, 669.0, 857.0, 821.0, 772.0, 732.0, 689.0, 654.0, 597.0, 830.0, 827.0])\n    n_groups = 3\n    data = [y0, y1, y2]\n    nobs = np.asarray([len(yi) for yi in data])\n    nobs_mean = np.mean(nobs)\n    means = np.asarray([yi.mean() for yi in data])\n    stds = np.asarray([yi.std(ddof=1) for yi in data])\n    cls.data = data\n    cls.data_transformed = [yt0, yt1, yt2]\n    cls.means = means\n    cls.nobs = nobs\n    cls.stds = stds\n    cls.n_groups = n_groups\n    cls.nobs_mean = nobs_mean",
        "mutated": [
            "@classmethod\ndef setup_class(cls):\n    if False:\n        i = 10\n    yt0 = np.array([102.0, 320.0, 0.0, 107.0, 198.0, 200.0, 4.0, 20.0, 110.0, 128.0, 7.0, 119.0, 309.0])\n    yt1 = np.array([0.0, 1.0, 228.0, 81.0, 87.0, 119.0, 79.0, 181.0, 43.0, 12.0, 90.0, 105.0, 108.0, 119.0, 0.0, 9.0])\n    yt2 = np.array([33.0, 294.0, 134.0, 216.0, 83.0, 105.0, 69.0, 20.0, 20.0, 63.0, 98.0, 155.0, 78.0, 75.0])\n    y0 = np.array([452.0, 874.0, 554.0, 447.0, 356.0, 754.0, 558.0, 574.0, 664.0, 682.0, 547.0, 435.0, 245.0])\n    y1 = np.array([546.0, 547.0, 774.0, 465.0, 459.0, 665.0, 467.0, 365.0, 589.0, 534.0, 456.0, 651.0, 654.0, 665.0, 546.0, 537.0])\n    y2 = np.array([785.0, 458.0, 886.0, 536.0, 669.0, 857.0, 821.0, 772.0, 732.0, 689.0, 654.0, 597.0, 830.0, 827.0])\n    n_groups = 3\n    data = [y0, y1, y2]\n    nobs = np.asarray([len(yi) for yi in data])\n    nobs_mean = np.mean(nobs)\n    means = np.asarray([yi.mean() for yi in data])\n    stds = np.asarray([yi.std(ddof=1) for yi in data])\n    cls.data = data\n    cls.data_transformed = [yt0, yt1, yt2]\n    cls.means = means\n    cls.nobs = nobs\n    cls.stds = stds\n    cls.n_groups = n_groups\n    cls.nobs_mean = nobs_mean",
            "@classmethod\ndef setup_class(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    yt0 = np.array([102.0, 320.0, 0.0, 107.0, 198.0, 200.0, 4.0, 20.0, 110.0, 128.0, 7.0, 119.0, 309.0])\n    yt1 = np.array([0.0, 1.0, 228.0, 81.0, 87.0, 119.0, 79.0, 181.0, 43.0, 12.0, 90.0, 105.0, 108.0, 119.0, 0.0, 9.0])\n    yt2 = np.array([33.0, 294.0, 134.0, 216.0, 83.0, 105.0, 69.0, 20.0, 20.0, 63.0, 98.0, 155.0, 78.0, 75.0])\n    y0 = np.array([452.0, 874.0, 554.0, 447.0, 356.0, 754.0, 558.0, 574.0, 664.0, 682.0, 547.0, 435.0, 245.0])\n    y1 = np.array([546.0, 547.0, 774.0, 465.0, 459.0, 665.0, 467.0, 365.0, 589.0, 534.0, 456.0, 651.0, 654.0, 665.0, 546.0, 537.0])\n    y2 = np.array([785.0, 458.0, 886.0, 536.0, 669.0, 857.0, 821.0, 772.0, 732.0, 689.0, 654.0, 597.0, 830.0, 827.0])\n    n_groups = 3\n    data = [y0, y1, y2]\n    nobs = np.asarray([len(yi) for yi in data])\n    nobs_mean = np.mean(nobs)\n    means = np.asarray([yi.mean() for yi in data])\n    stds = np.asarray([yi.std(ddof=1) for yi in data])\n    cls.data = data\n    cls.data_transformed = [yt0, yt1, yt2]\n    cls.means = means\n    cls.nobs = nobs\n    cls.stds = stds\n    cls.n_groups = n_groups\n    cls.nobs_mean = nobs_mean",
            "@classmethod\ndef setup_class(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    yt0 = np.array([102.0, 320.0, 0.0, 107.0, 198.0, 200.0, 4.0, 20.0, 110.0, 128.0, 7.0, 119.0, 309.0])\n    yt1 = np.array([0.0, 1.0, 228.0, 81.0, 87.0, 119.0, 79.0, 181.0, 43.0, 12.0, 90.0, 105.0, 108.0, 119.0, 0.0, 9.0])\n    yt2 = np.array([33.0, 294.0, 134.0, 216.0, 83.0, 105.0, 69.0, 20.0, 20.0, 63.0, 98.0, 155.0, 78.0, 75.0])\n    y0 = np.array([452.0, 874.0, 554.0, 447.0, 356.0, 754.0, 558.0, 574.0, 664.0, 682.0, 547.0, 435.0, 245.0])\n    y1 = np.array([546.0, 547.0, 774.0, 465.0, 459.0, 665.0, 467.0, 365.0, 589.0, 534.0, 456.0, 651.0, 654.0, 665.0, 546.0, 537.0])\n    y2 = np.array([785.0, 458.0, 886.0, 536.0, 669.0, 857.0, 821.0, 772.0, 732.0, 689.0, 654.0, 597.0, 830.0, 827.0])\n    n_groups = 3\n    data = [y0, y1, y2]\n    nobs = np.asarray([len(yi) for yi in data])\n    nobs_mean = np.mean(nobs)\n    means = np.asarray([yi.mean() for yi in data])\n    stds = np.asarray([yi.std(ddof=1) for yi in data])\n    cls.data = data\n    cls.data_transformed = [yt0, yt1, yt2]\n    cls.means = means\n    cls.nobs = nobs\n    cls.stds = stds\n    cls.n_groups = n_groups\n    cls.nobs_mean = nobs_mean",
            "@classmethod\ndef setup_class(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    yt0 = np.array([102.0, 320.0, 0.0, 107.0, 198.0, 200.0, 4.0, 20.0, 110.0, 128.0, 7.0, 119.0, 309.0])\n    yt1 = np.array([0.0, 1.0, 228.0, 81.0, 87.0, 119.0, 79.0, 181.0, 43.0, 12.0, 90.0, 105.0, 108.0, 119.0, 0.0, 9.0])\n    yt2 = np.array([33.0, 294.0, 134.0, 216.0, 83.0, 105.0, 69.0, 20.0, 20.0, 63.0, 98.0, 155.0, 78.0, 75.0])\n    y0 = np.array([452.0, 874.0, 554.0, 447.0, 356.0, 754.0, 558.0, 574.0, 664.0, 682.0, 547.0, 435.0, 245.0])\n    y1 = np.array([546.0, 547.0, 774.0, 465.0, 459.0, 665.0, 467.0, 365.0, 589.0, 534.0, 456.0, 651.0, 654.0, 665.0, 546.0, 537.0])\n    y2 = np.array([785.0, 458.0, 886.0, 536.0, 669.0, 857.0, 821.0, 772.0, 732.0, 689.0, 654.0, 597.0, 830.0, 827.0])\n    n_groups = 3\n    data = [y0, y1, y2]\n    nobs = np.asarray([len(yi) for yi in data])\n    nobs_mean = np.mean(nobs)\n    means = np.asarray([yi.mean() for yi in data])\n    stds = np.asarray([yi.std(ddof=1) for yi in data])\n    cls.data = data\n    cls.data_transformed = [yt0, yt1, yt2]\n    cls.means = means\n    cls.nobs = nobs\n    cls.stds = stds\n    cls.n_groups = n_groups\n    cls.nobs_mean = nobs_mean",
            "@classmethod\ndef setup_class(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    yt0 = np.array([102.0, 320.0, 0.0, 107.0, 198.0, 200.0, 4.0, 20.0, 110.0, 128.0, 7.0, 119.0, 309.0])\n    yt1 = np.array([0.0, 1.0, 228.0, 81.0, 87.0, 119.0, 79.0, 181.0, 43.0, 12.0, 90.0, 105.0, 108.0, 119.0, 0.0, 9.0])\n    yt2 = np.array([33.0, 294.0, 134.0, 216.0, 83.0, 105.0, 69.0, 20.0, 20.0, 63.0, 98.0, 155.0, 78.0, 75.0])\n    y0 = np.array([452.0, 874.0, 554.0, 447.0, 356.0, 754.0, 558.0, 574.0, 664.0, 682.0, 547.0, 435.0, 245.0])\n    y1 = np.array([546.0, 547.0, 774.0, 465.0, 459.0, 665.0, 467.0, 365.0, 589.0, 534.0, 456.0, 651.0, 654.0, 665.0, 546.0, 537.0])\n    y2 = np.array([785.0, 458.0, 886.0, 536.0, 669.0, 857.0, 821.0, 772.0, 732.0, 689.0, 654.0, 597.0, 830.0, 827.0])\n    n_groups = 3\n    data = [y0, y1, y2]\n    nobs = np.asarray([len(yi) for yi in data])\n    nobs_mean = np.mean(nobs)\n    means = np.asarray([yi.mean() for yi in data])\n    stds = np.asarray([yi.std(ddof=1) for yi in data])\n    cls.data = data\n    cls.data_transformed = [yt0, yt1, yt2]\n    cls.means = means\n    cls.nobs = nobs\n    cls.stds = stds\n    cls.n_groups = n_groups\n    cls.nobs_mean = nobs_mean"
        ]
    },
    {
        "func_name": "test_means",
        "original": "def test_means(self):\n    statistic = 7.10900606421182\n    parameter = [2, 31.4207256105052]\n    p_value = 0.00283841965791224\n    res = anova_oneway(self.data, use_var='bf')\n    assert_allclose(res.pvalue2, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_allclose([res.df_num2, res.df_denom], parameter)",
        "mutated": [
            "def test_means(self):\n    if False:\n        i = 10\n    statistic = 7.10900606421182\n    parameter = [2, 31.4207256105052]\n    p_value = 0.00283841965791224\n    res = anova_oneway(self.data, use_var='bf')\n    assert_allclose(res.pvalue2, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_allclose([res.df_num2, res.df_denom], parameter)",
            "def test_means(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    statistic = 7.10900606421182\n    parameter = [2, 31.4207256105052]\n    p_value = 0.00283841965791224\n    res = anova_oneway(self.data, use_var='bf')\n    assert_allclose(res.pvalue2, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_allclose([res.df_num2, res.df_denom], parameter)",
            "def test_means(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    statistic = 7.10900606421182\n    parameter = [2, 31.4207256105052]\n    p_value = 0.00283841965791224\n    res = anova_oneway(self.data, use_var='bf')\n    assert_allclose(res.pvalue2, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_allclose([res.df_num2, res.df_denom], parameter)",
            "def test_means(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    statistic = 7.10900606421182\n    parameter = [2, 31.4207256105052]\n    p_value = 0.00283841965791224\n    res = anova_oneway(self.data, use_var='bf')\n    assert_allclose(res.pvalue2, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_allclose([res.df_num2, res.df_denom], parameter)",
            "def test_means(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    statistic = 7.10900606421182\n    parameter = [2, 31.4207256105052]\n    p_value = 0.00283841965791224\n    res = anova_oneway(self.data, use_var='bf')\n    assert_allclose(res.pvalue2, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_allclose([res.df_num2, res.df_denom], parameter)"
        ]
    },
    {
        "func_name": "test_levene",
        "original": "def test_levene(self):\n    data = self.data\n    statistic = 1.0866123063642\n    p_value = 0.3471072204516\n    res0 = smo.test_scale_oneway(data, method='equal', center='median', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res0.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res0.statistic, statistic, rtol=1e-13)\n    statistic = 1.10732113109744\n    p_value = 0.340359251994645\n    df = [2, 40]\n    res0 = smo.test_scale_oneway(data, method='equal', center='trimmed', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res0.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res0.statistic, statistic, rtol=1e-13)\n    assert_allclose(res0.df, df)\n    statistic = 1.07894485177512\n    parameter = [2, 40]\n    p_value = 0.349641166869223\n    res0 = smo.test_scale_oneway(data, method='equal', center='mean', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res0.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res0.statistic, statistic, rtol=1e-13)\n    assert_allclose(res0.df, parameter)\n    statistic = 3.01982414477323\n    p_value = 0.220929402900495\n    from scipy import stats\n    (stat, pv) = stats.bartlett(*data)\n    assert_allclose(pv, p_value, rtol=1e-13)\n    assert_allclose(stat, statistic, rtol=1e-13)",
        "mutated": [
            "def test_levene(self):\n    if False:\n        i = 10\n    data = self.data\n    statistic = 1.0866123063642\n    p_value = 0.3471072204516\n    res0 = smo.test_scale_oneway(data, method='equal', center='median', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res0.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res0.statistic, statistic, rtol=1e-13)\n    statistic = 1.10732113109744\n    p_value = 0.340359251994645\n    df = [2, 40]\n    res0 = smo.test_scale_oneway(data, method='equal', center='trimmed', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res0.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res0.statistic, statistic, rtol=1e-13)\n    assert_allclose(res0.df, df)\n    statistic = 1.07894485177512\n    parameter = [2, 40]\n    p_value = 0.349641166869223\n    res0 = smo.test_scale_oneway(data, method='equal', center='mean', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res0.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res0.statistic, statistic, rtol=1e-13)\n    assert_allclose(res0.df, parameter)\n    statistic = 3.01982414477323\n    p_value = 0.220929402900495\n    from scipy import stats\n    (stat, pv) = stats.bartlett(*data)\n    assert_allclose(pv, p_value, rtol=1e-13)\n    assert_allclose(stat, statistic, rtol=1e-13)",
            "def test_levene(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    data = self.data\n    statistic = 1.0866123063642\n    p_value = 0.3471072204516\n    res0 = smo.test_scale_oneway(data, method='equal', center='median', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res0.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res0.statistic, statistic, rtol=1e-13)\n    statistic = 1.10732113109744\n    p_value = 0.340359251994645\n    df = [2, 40]\n    res0 = smo.test_scale_oneway(data, method='equal', center='trimmed', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res0.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res0.statistic, statistic, rtol=1e-13)\n    assert_allclose(res0.df, df)\n    statistic = 1.07894485177512\n    parameter = [2, 40]\n    p_value = 0.349641166869223\n    res0 = smo.test_scale_oneway(data, method='equal', center='mean', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res0.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res0.statistic, statistic, rtol=1e-13)\n    assert_allclose(res0.df, parameter)\n    statistic = 3.01982414477323\n    p_value = 0.220929402900495\n    from scipy import stats\n    (stat, pv) = stats.bartlett(*data)\n    assert_allclose(pv, p_value, rtol=1e-13)\n    assert_allclose(stat, statistic, rtol=1e-13)",
            "def test_levene(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    data = self.data\n    statistic = 1.0866123063642\n    p_value = 0.3471072204516\n    res0 = smo.test_scale_oneway(data, method='equal', center='median', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res0.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res0.statistic, statistic, rtol=1e-13)\n    statistic = 1.10732113109744\n    p_value = 0.340359251994645\n    df = [2, 40]\n    res0 = smo.test_scale_oneway(data, method='equal', center='trimmed', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res0.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res0.statistic, statistic, rtol=1e-13)\n    assert_allclose(res0.df, df)\n    statistic = 1.07894485177512\n    parameter = [2, 40]\n    p_value = 0.349641166869223\n    res0 = smo.test_scale_oneway(data, method='equal', center='mean', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res0.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res0.statistic, statistic, rtol=1e-13)\n    assert_allclose(res0.df, parameter)\n    statistic = 3.01982414477323\n    p_value = 0.220929402900495\n    from scipy import stats\n    (stat, pv) = stats.bartlett(*data)\n    assert_allclose(pv, p_value, rtol=1e-13)\n    assert_allclose(stat, statistic, rtol=1e-13)",
            "def test_levene(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    data = self.data\n    statistic = 1.0866123063642\n    p_value = 0.3471072204516\n    res0 = smo.test_scale_oneway(data, method='equal', center='median', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res0.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res0.statistic, statistic, rtol=1e-13)\n    statistic = 1.10732113109744\n    p_value = 0.340359251994645\n    df = [2, 40]\n    res0 = smo.test_scale_oneway(data, method='equal', center='trimmed', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res0.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res0.statistic, statistic, rtol=1e-13)\n    assert_allclose(res0.df, df)\n    statistic = 1.07894485177512\n    parameter = [2, 40]\n    p_value = 0.349641166869223\n    res0 = smo.test_scale_oneway(data, method='equal', center='mean', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res0.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res0.statistic, statistic, rtol=1e-13)\n    assert_allclose(res0.df, parameter)\n    statistic = 3.01982414477323\n    p_value = 0.220929402900495\n    from scipy import stats\n    (stat, pv) = stats.bartlett(*data)\n    assert_allclose(pv, p_value, rtol=1e-13)\n    assert_allclose(stat, statistic, rtol=1e-13)",
            "def test_levene(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    data = self.data\n    statistic = 1.0866123063642\n    p_value = 0.3471072204516\n    res0 = smo.test_scale_oneway(data, method='equal', center='median', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res0.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res0.statistic, statistic, rtol=1e-13)\n    statistic = 1.10732113109744\n    p_value = 0.340359251994645\n    df = [2, 40]\n    res0 = smo.test_scale_oneway(data, method='equal', center='trimmed', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res0.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res0.statistic, statistic, rtol=1e-13)\n    assert_allclose(res0.df, df)\n    statistic = 1.07894485177512\n    parameter = [2, 40]\n    p_value = 0.349641166869223\n    res0 = smo.test_scale_oneway(data, method='equal', center='mean', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res0.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res0.statistic, statistic, rtol=1e-13)\n    assert_allclose(res0.df, parameter)\n    statistic = 3.01982414477323\n    p_value = 0.220929402900495\n    from scipy import stats\n    (stat, pv) = stats.bartlett(*data)\n    assert_allclose(pv, p_value, rtol=1e-13)\n    assert_allclose(stat, statistic, rtol=1e-13)"
        ]
    },
    {
        "func_name": "test_options",
        "original": "def test_options(self):\n    data = self.data\n    (statistic, p_value) = (1.0173464626246675, 0.3763806150460239)\n    df = (2.0, 24.40374758005409)\n    res = smo.test_scale_oneway(data, method='unequal', center='median', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_allclose(res.df, df)\n    (statistic, p_value) = (1.0329722145270606, 0.3622778213868562)\n    df = (1.83153791573948, 30.6733640949525)\n    p_value2 = 0.3679999679787619\n    df2 = (2, 30.6733640949525)\n    res = smo.test_scale_oneway(data, method='bf', center='median', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_allclose(res.df, df)\n    assert_allclose(res.pvalue2, p_value2, rtol=1e-13)\n    assert_allclose(res.df2, df2)\n    (statistic, p_value) = (1.7252431333701745, 0.19112038168209514)\n    df = (2.0, 40.0)\n    res = smo.test_scale_oneway(data, method='equal', center='mean', transform='square', trim_frac_mean=0.2)\n    assert_allclose(res.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_equal(res.df, df)\n    (statistic, p_value) = (0.4129696057329463, 0.6644711582864451)\n    df = (2.0, 40.0)\n    res = smo.test_scale_oneway(data, method='equal', center='mean', transform=lambda x: np.log(x * x), trim_frac_mean=0.2)\n    assert_allclose(res.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_allclose(res.df, df)\n    res = smo.test_scale_oneway(data, method='unequal', center=0, transform='identity', trim_frac_mean=0.2)\n    res2 = anova_oneway(self.data, use_var='unequal')\n    assert_allclose(res.pvalue, res2.pvalue, rtol=1e-13)\n    assert_allclose(res.statistic, res2.statistic, rtol=1e-13)\n    assert_allclose(res.df, res2.df)",
        "mutated": [
            "def test_options(self):\n    if False:\n        i = 10\n    data = self.data\n    (statistic, p_value) = (1.0173464626246675, 0.3763806150460239)\n    df = (2.0, 24.40374758005409)\n    res = smo.test_scale_oneway(data, method='unequal', center='median', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_allclose(res.df, df)\n    (statistic, p_value) = (1.0329722145270606, 0.3622778213868562)\n    df = (1.83153791573948, 30.6733640949525)\n    p_value2 = 0.3679999679787619\n    df2 = (2, 30.6733640949525)\n    res = smo.test_scale_oneway(data, method='bf', center='median', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_allclose(res.df, df)\n    assert_allclose(res.pvalue2, p_value2, rtol=1e-13)\n    assert_allclose(res.df2, df2)\n    (statistic, p_value) = (1.7252431333701745, 0.19112038168209514)\n    df = (2.0, 40.0)\n    res = smo.test_scale_oneway(data, method='equal', center='mean', transform='square', trim_frac_mean=0.2)\n    assert_allclose(res.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_equal(res.df, df)\n    (statistic, p_value) = (0.4129696057329463, 0.6644711582864451)\n    df = (2.0, 40.0)\n    res = smo.test_scale_oneway(data, method='equal', center='mean', transform=lambda x: np.log(x * x), trim_frac_mean=0.2)\n    assert_allclose(res.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_allclose(res.df, df)\n    res = smo.test_scale_oneway(data, method='unequal', center=0, transform='identity', trim_frac_mean=0.2)\n    res2 = anova_oneway(self.data, use_var='unequal')\n    assert_allclose(res.pvalue, res2.pvalue, rtol=1e-13)\n    assert_allclose(res.statistic, res2.statistic, rtol=1e-13)\n    assert_allclose(res.df, res2.df)",
            "def test_options(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    data = self.data\n    (statistic, p_value) = (1.0173464626246675, 0.3763806150460239)\n    df = (2.0, 24.40374758005409)\n    res = smo.test_scale_oneway(data, method='unequal', center='median', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_allclose(res.df, df)\n    (statistic, p_value) = (1.0329722145270606, 0.3622778213868562)\n    df = (1.83153791573948, 30.6733640949525)\n    p_value2 = 0.3679999679787619\n    df2 = (2, 30.6733640949525)\n    res = smo.test_scale_oneway(data, method='bf', center='median', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_allclose(res.df, df)\n    assert_allclose(res.pvalue2, p_value2, rtol=1e-13)\n    assert_allclose(res.df2, df2)\n    (statistic, p_value) = (1.7252431333701745, 0.19112038168209514)\n    df = (2.0, 40.0)\n    res = smo.test_scale_oneway(data, method='equal', center='mean', transform='square', trim_frac_mean=0.2)\n    assert_allclose(res.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_equal(res.df, df)\n    (statistic, p_value) = (0.4129696057329463, 0.6644711582864451)\n    df = (2.0, 40.0)\n    res = smo.test_scale_oneway(data, method='equal', center='mean', transform=lambda x: np.log(x * x), trim_frac_mean=0.2)\n    assert_allclose(res.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_allclose(res.df, df)\n    res = smo.test_scale_oneway(data, method='unequal', center=0, transform='identity', trim_frac_mean=0.2)\n    res2 = anova_oneway(self.data, use_var='unequal')\n    assert_allclose(res.pvalue, res2.pvalue, rtol=1e-13)\n    assert_allclose(res.statistic, res2.statistic, rtol=1e-13)\n    assert_allclose(res.df, res2.df)",
            "def test_options(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    data = self.data\n    (statistic, p_value) = (1.0173464626246675, 0.3763806150460239)\n    df = (2.0, 24.40374758005409)\n    res = smo.test_scale_oneway(data, method='unequal', center='median', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_allclose(res.df, df)\n    (statistic, p_value) = (1.0329722145270606, 0.3622778213868562)\n    df = (1.83153791573948, 30.6733640949525)\n    p_value2 = 0.3679999679787619\n    df2 = (2, 30.6733640949525)\n    res = smo.test_scale_oneway(data, method='bf', center='median', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_allclose(res.df, df)\n    assert_allclose(res.pvalue2, p_value2, rtol=1e-13)\n    assert_allclose(res.df2, df2)\n    (statistic, p_value) = (1.7252431333701745, 0.19112038168209514)\n    df = (2.0, 40.0)\n    res = smo.test_scale_oneway(data, method='equal', center='mean', transform='square', trim_frac_mean=0.2)\n    assert_allclose(res.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_equal(res.df, df)\n    (statistic, p_value) = (0.4129696057329463, 0.6644711582864451)\n    df = (2.0, 40.0)\n    res = smo.test_scale_oneway(data, method='equal', center='mean', transform=lambda x: np.log(x * x), trim_frac_mean=0.2)\n    assert_allclose(res.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_allclose(res.df, df)\n    res = smo.test_scale_oneway(data, method='unequal', center=0, transform='identity', trim_frac_mean=0.2)\n    res2 = anova_oneway(self.data, use_var='unequal')\n    assert_allclose(res.pvalue, res2.pvalue, rtol=1e-13)\n    assert_allclose(res.statistic, res2.statistic, rtol=1e-13)\n    assert_allclose(res.df, res2.df)",
            "def test_options(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    data = self.data\n    (statistic, p_value) = (1.0173464626246675, 0.3763806150460239)\n    df = (2.0, 24.40374758005409)\n    res = smo.test_scale_oneway(data, method='unequal', center='median', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_allclose(res.df, df)\n    (statistic, p_value) = (1.0329722145270606, 0.3622778213868562)\n    df = (1.83153791573948, 30.6733640949525)\n    p_value2 = 0.3679999679787619\n    df2 = (2, 30.6733640949525)\n    res = smo.test_scale_oneway(data, method='bf', center='median', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_allclose(res.df, df)\n    assert_allclose(res.pvalue2, p_value2, rtol=1e-13)\n    assert_allclose(res.df2, df2)\n    (statistic, p_value) = (1.7252431333701745, 0.19112038168209514)\n    df = (2.0, 40.0)\n    res = smo.test_scale_oneway(data, method='equal', center='mean', transform='square', trim_frac_mean=0.2)\n    assert_allclose(res.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_equal(res.df, df)\n    (statistic, p_value) = (0.4129696057329463, 0.6644711582864451)\n    df = (2.0, 40.0)\n    res = smo.test_scale_oneway(data, method='equal', center='mean', transform=lambda x: np.log(x * x), trim_frac_mean=0.2)\n    assert_allclose(res.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_allclose(res.df, df)\n    res = smo.test_scale_oneway(data, method='unequal', center=0, transform='identity', trim_frac_mean=0.2)\n    res2 = anova_oneway(self.data, use_var='unequal')\n    assert_allclose(res.pvalue, res2.pvalue, rtol=1e-13)\n    assert_allclose(res.statistic, res2.statistic, rtol=1e-13)\n    assert_allclose(res.df, res2.df)",
            "def test_options(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    data = self.data\n    (statistic, p_value) = (1.0173464626246675, 0.3763806150460239)\n    df = (2.0, 24.40374758005409)\n    res = smo.test_scale_oneway(data, method='unequal', center='median', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_allclose(res.df, df)\n    (statistic, p_value) = (1.0329722145270606, 0.3622778213868562)\n    df = (1.83153791573948, 30.6733640949525)\n    p_value2 = 0.3679999679787619\n    df2 = (2, 30.6733640949525)\n    res = smo.test_scale_oneway(data, method='bf', center='median', transform='abs', trim_frac_mean=0.2)\n    assert_allclose(res.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_allclose(res.df, df)\n    assert_allclose(res.pvalue2, p_value2, rtol=1e-13)\n    assert_allclose(res.df2, df2)\n    (statistic, p_value) = (1.7252431333701745, 0.19112038168209514)\n    df = (2.0, 40.0)\n    res = smo.test_scale_oneway(data, method='equal', center='mean', transform='square', trim_frac_mean=0.2)\n    assert_allclose(res.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_equal(res.df, df)\n    (statistic, p_value) = (0.4129696057329463, 0.6644711582864451)\n    df = (2.0, 40.0)\n    res = smo.test_scale_oneway(data, method='equal', center='mean', transform=lambda x: np.log(x * x), trim_frac_mean=0.2)\n    assert_allclose(res.pvalue, p_value, rtol=1e-13)\n    assert_allclose(res.statistic, statistic, rtol=1e-13)\n    assert_allclose(res.df, df)\n    res = smo.test_scale_oneway(data, method='unequal', center=0, transform='identity', trim_frac_mean=0.2)\n    res2 = anova_oneway(self.data, use_var='unequal')\n    assert_allclose(res.pvalue, res2.pvalue, rtol=1e-13)\n    assert_allclose(res.statistic, res2.statistic, rtol=1e-13)\n    assert_allclose(res.df, res2.df)"
        ]
    },
    {
        "func_name": "test_equivalence",
        "original": "def test_equivalence(self):\n    data = self.data\n    res = smo.equivalence_scale_oneway(data, 0.5, method='unequal', center=0, transform='identity')\n    res2 = equivalence_oneway(self.data, 0.5, use_var='unequal')\n    assert_allclose(res.pvalue, res2.pvalue, rtol=1e-13)\n    assert_allclose(res.statistic, res2.statistic, rtol=1e-13)\n    assert_allclose(res.df, res2.df)\n    res = smo.equivalence_scale_oneway(data, 0.5, method='bf', center=0, transform='identity')\n    res2 = equivalence_oneway(self.data, 0.5, use_var='bf')\n    assert_allclose(res.pvalue, res2.pvalue, rtol=1e-13)\n    assert_allclose(res.statistic, res2.statistic, rtol=1e-13)\n    assert_allclose(res.df, res2.df)",
        "mutated": [
            "def test_equivalence(self):\n    if False:\n        i = 10\n    data = self.data\n    res = smo.equivalence_scale_oneway(data, 0.5, method='unequal', center=0, transform='identity')\n    res2 = equivalence_oneway(self.data, 0.5, use_var='unequal')\n    assert_allclose(res.pvalue, res2.pvalue, rtol=1e-13)\n    assert_allclose(res.statistic, res2.statistic, rtol=1e-13)\n    assert_allclose(res.df, res2.df)\n    res = smo.equivalence_scale_oneway(data, 0.5, method='bf', center=0, transform='identity')\n    res2 = equivalence_oneway(self.data, 0.5, use_var='bf')\n    assert_allclose(res.pvalue, res2.pvalue, rtol=1e-13)\n    assert_allclose(res.statistic, res2.statistic, rtol=1e-13)\n    assert_allclose(res.df, res2.df)",
            "def test_equivalence(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    data = self.data\n    res = smo.equivalence_scale_oneway(data, 0.5, method='unequal', center=0, transform='identity')\n    res2 = equivalence_oneway(self.data, 0.5, use_var='unequal')\n    assert_allclose(res.pvalue, res2.pvalue, rtol=1e-13)\n    assert_allclose(res.statistic, res2.statistic, rtol=1e-13)\n    assert_allclose(res.df, res2.df)\n    res = smo.equivalence_scale_oneway(data, 0.5, method='bf', center=0, transform='identity')\n    res2 = equivalence_oneway(self.data, 0.5, use_var='bf')\n    assert_allclose(res.pvalue, res2.pvalue, rtol=1e-13)\n    assert_allclose(res.statistic, res2.statistic, rtol=1e-13)\n    assert_allclose(res.df, res2.df)",
            "def test_equivalence(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    data = self.data\n    res = smo.equivalence_scale_oneway(data, 0.5, method='unequal', center=0, transform='identity')\n    res2 = equivalence_oneway(self.data, 0.5, use_var='unequal')\n    assert_allclose(res.pvalue, res2.pvalue, rtol=1e-13)\n    assert_allclose(res.statistic, res2.statistic, rtol=1e-13)\n    assert_allclose(res.df, res2.df)\n    res = smo.equivalence_scale_oneway(data, 0.5, method='bf', center=0, transform='identity')\n    res2 = equivalence_oneway(self.data, 0.5, use_var='bf')\n    assert_allclose(res.pvalue, res2.pvalue, rtol=1e-13)\n    assert_allclose(res.statistic, res2.statistic, rtol=1e-13)\n    assert_allclose(res.df, res2.df)",
            "def test_equivalence(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    data = self.data\n    res = smo.equivalence_scale_oneway(data, 0.5, method='unequal', center=0, transform='identity')\n    res2 = equivalence_oneway(self.data, 0.5, use_var='unequal')\n    assert_allclose(res.pvalue, res2.pvalue, rtol=1e-13)\n    assert_allclose(res.statistic, res2.statistic, rtol=1e-13)\n    assert_allclose(res.df, res2.df)\n    res = smo.equivalence_scale_oneway(data, 0.5, method='bf', center=0, transform='identity')\n    res2 = equivalence_oneway(self.data, 0.5, use_var='bf')\n    assert_allclose(res.pvalue, res2.pvalue, rtol=1e-13)\n    assert_allclose(res.statistic, res2.statistic, rtol=1e-13)\n    assert_allclose(res.df, res2.df)",
            "def test_equivalence(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    data = self.data\n    res = smo.equivalence_scale_oneway(data, 0.5, method='unequal', center=0, transform='identity')\n    res2 = equivalence_oneway(self.data, 0.5, use_var='unequal')\n    assert_allclose(res.pvalue, res2.pvalue, rtol=1e-13)\n    assert_allclose(res.statistic, res2.statistic, rtol=1e-13)\n    assert_allclose(res.df, res2.df)\n    res = smo.equivalence_scale_oneway(data, 0.5, method='bf', center=0, transform='identity')\n    res2 = equivalence_oneway(self.data, 0.5, use_var='bf')\n    assert_allclose(res.pvalue, res2.pvalue, rtol=1e-13)\n    assert_allclose(res.statistic, res2.statistic, rtol=1e-13)\n    assert_allclose(res.df, res2.df)"
        ]
    },
    {
        "func_name": "setup_class",
        "original": "@classmethod\ndef setup_class(cls):\n    y0 = [112.488, 103.738, 86.344, 101.708, 95.108, 105.931, 95.815, 91.864, 102.479, 102.644]\n    y1 = [100.421, 101.966, 99.636, 105.983, 88.377, 102.618, 105.486, 98.662, 94.137, 98.626, 89.367, 106.204]\n    y2 = [84.846, 100.488, 119.763, 103.736, 93.141, 108.254, 99.51, 89.005, 108.2, 82.209, 100.104, 103.706, 107.067]\n    y3 = [100.825, 100.255, 103.363, 93.23, 95.325, 100.288, 94.75, 107.129, 98.246, 96.365, 99.74, 106.049, 92.691, 93.111, 98.243]\n    cls.k_groups = k = 4\n    cls.data = data = [y0, y1, y2, y3]\n    cls.nobs = nobs = np.asarray([len(yi) for yi in data])\n    groups = np.repeat(np.arange(k), nobs)\n    cls.ex = (groups[:, None] == np.arange(k)).astype(np.int64)\n    cls.y = np.concatenate(data)",
        "mutated": [
            "@classmethod\ndef setup_class(cls):\n    if False:\n        i = 10\n    y0 = [112.488, 103.738, 86.344, 101.708, 95.108, 105.931, 95.815, 91.864, 102.479, 102.644]\n    y1 = [100.421, 101.966, 99.636, 105.983, 88.377, 102.618, 105.486, 98.662, 94.137, 98.626, 89.367, 106.204]\n    y2 = [84.846, 100.488, 119.763, 103.736, 93.141, 108.254, 99.51, 89.005, 108.2, 82.209, 100.104, 103.706, 107.067]\n    y3 = [100.825, 100.255, 103.363, 93.23, 95.325, 100.288, 94.75, 107.129, 98.246, 96.365, 99.74, 106.049, 92.691, 93.111, 98.243]\n    cls.k_groups = k = 4\n    cls.data = data = [y0, y1, y2, y3]\n    cls.nobs = nobs = np.asarray([len(yi) for yi in data])\n    groups = np.repeat(np.arange(k), nobs)\n    cls.ex = (groups[:, None] == np.arange(k)).astype(np.int64)\n    cls.y = np.concatenate(data)",
            "@classmethod\ndef setup_class(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    y0 = [112.488, 103.738, 86.344, 101.708, 95.108, 105.931, 95.815, 91.864, 102.479, 102.644]\n    y1 = [100.421, 101.966, 99.636, 105.983, 88.377, 102.618, 105.486, 98.662, 94.137, 98.626, 89.367, 106.204]\n    y2 = [84.846, 100.488, 119.763, 103.736, 93.141, 108.254, 99.51, 89.005, 108.2, 82.209, 100.104, 103.706, 107.067]\n    y3 = [100.825, 100.255, 103.363, 93.23, 95.325, 100.288, 94.75, 107.129, 98.246, 96.365, 99.74, 106.049, 92.691, 93.111, 98.243]\n    cls.k_groups = k = 4\n    cls.data = data = [y0, y1, y2, y3]\n    cls.nobs = nobs = np.asarray([len(yi) for yi in data])\n    groups = np.repeat(np.arange(k), nobs)\n    cls.ex = (groups[:, None] == np.arange(k)).astype(np.int64)\n    cls.y = np.concatenate(data)",
            "@classmethod\ndef setup_class(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    y0 = [112.488, 103.738, 86.344, 101.708, 95.108, 105.931, 95.815, 91.864, 102.479, 102.644]\n    y1 = [100.421, 101.966, 99.636, 105.983, 88.377, 102.618, 105.486, 98.662, 94.137, 98.626, 89.367, 106.204]\n    y2 = [84.846, 100.488, 119.763, 103.736, 93.141, 108.254, 99.51, 89.005, 108.2, 82.209, 100.104, 103.706, 107.067]\n    y3 = [100.825, 100.255, 103.363, 93.23, 95.325, 100.288, 94.75, 107.129, 98.246, 96.365, 99.74, 106.049, 92.691, 93.111, 98.243]\n    cls.k_groups = k = 4\n    cls.data = data = [y0, y1, y2, y3]\n    cls.nobs = nobs = np.asarray([len(yi) for yi in data])\n    groups = np.repeat(np.arange(k), nobs)\n    cls.ex = (groups[:, None] == np.arange(k)).astype(np.int64)\n    cls.y = np.concatenate(data)",
            "@classmethod\ndef setup_class(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    y0 = [112.488, 103.738, 86.344, 101.708, 95.108, 105.931, 95.815, 91.864, 102.479, 102.644]\n    y1 = [100.421, 101.966, 99.636, 105.983, 88.377, 102.618, 105.486, 98.662, 94.137, 98.626, 89.367, 106.204]\n    y2 = [84.846, 100.488, 119.763, 103.736, 93.141, 108.254, 99.51, 89.005, 108.2, 82.209, 100.104, 103.706, 107.067]\n    y3 = [100.825, 100.255, 103.363, 93.23, 95.325, 100.288, 94.75, 107.129, 98.246, 96.365, 99.74, 106.049, 92.691, 93.111, 98.243]\n    cls.k_groups = k = 4\n    cls.data = data = [y0, y1, y2, y3]\n    cls.nobs = nobs = np.asarray([len(yi) for yi in data])\n    groups = np.repeat(np.arange(k), nobs)\n    cls.ex = (groups[:, None] == np.arange(k)).astype(np.int64)\n    cls.y = np.concatenate(data)",
            "@classmethod\ndef setup_class(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    y0 = [112.488, 103.738, 86.344, 101.708, 95.108, 105.931, 95.815, 91.864, 102.479, 102.644]\n    y1 = [100.421, 101.966, 99.636, 105.983, 88.377, 102.618, 105.486, 98.662, 94.137, 98.626, 89.367, 106.204]\n    y2 = [84.846, 100.488, 119.763, 103.736, 93.141, 108.254, 99.51, 89.005, 108.2, 82.209, 100.104, 103.706, 107.067]\n    y3 = [100.825, 100.255, 103.363, 93.23, 95.325, 100.288, 94.75, 107.129, 98.246, 96.365, 99.74, 106.049, 92.691, 93.111, 98.243]\n    cls.k_groups = k = 4\n    cls.data = data = [y0, y1, y2, y3]\n    cls.nobs = nobs = np.asarray([len(yi) for yi in data])\n    groups = np.repeat(np.arange(k), nobs)\n    cls.ex = (groups[:, None] == np.arange(k)).astype(np.int64)\n    cls.y = np.concatenate(data)"
        ]
    },
    {
        "func_name": "test_ols_noncentrality",
        "original": "def test_ols_noncentrality(self):\n    k = self.k_groups\n    res_ols = OLS(self.y, self.ex).fit()\n    nobs_t = res_ols.model.nobs\n    c_equal = -np.eye(k)[1:]\n    c_equal[:, 0] = 1\n    v = np.zeros(c_equal.shape[0])\n    wt = res_ols.wald_test(c_equal, scalar=True)\n    (df_num, df_denom) = (wt.df_num, wt.df_denom)\n    cov_p = res_ols.cov_params()\n    nc_wt = wald_test_noncent_generic(res_ols.params, c_equal, v, cov_p, diff=None, joint=True)\n    assert_allclose(nc_wt, wt.statistic * wt.df_num, rtol=1e-13)\n    nc_wt2 = wald_test_noncent(res_ols.params, c_equal, v, res_ols, diff=None, joint=True)\n    assert_allclose(nc_wt2, nc_wt, rtol=1e-13)\n    es_ols = nc_wt / nobs_t\n    es_oneway = smo.effectsize_oneway(res_ols.params, res_ols.scale, self.nobs, use_var='equal')\n    assert_allclose(es_ols, es_oneway, rtol=1e-13)\n    alpha = 0.05\n    pow_ols = smpwr.ftest_power(np.sqrt(es_ols), df_denom, df_num, alpha, ncc=1)\n    pow_oneway = smpwr.ftest_anova_power(np.sqrt(es_oneway), nobs_t, alpha, k_groups=k, df=None)\n    assert_allclose(pow_ols, pow_oneway, rtol=1e-13)\n    params_alt = res_ols.params * 0.75\n    v_off = _offset_constraint(c_equal, res_ols.params, params_alt)\n    wt_off = res_ols.wald_test((c_equal, v + v_off), scalar=True)\n    nc_wt_off = wald_test_noncent_generic(params_alt, c_equal, v, cov_p, diff=None, joint=True)\n    assert_allclose(nc_wt_off, wt_off.statistic * wt_off.df_num, rtol=1e-13)\n    nc_wt_vec = wald_test_noncent_generic(params_alt, c_equal, v, cov_p, diff=None, joint=False)\n    for i in range(c_equal.shape[0]):\n        nc_wt_i = wald_test_noncent_generic(params_alt, c_equal[i:i + 1], v[i:i + 1], cov_p, diff=None, joint=False)\n        assert_allclose(nc_wt_vec[i], nc_wt_i, rtol=1e-13)",
        "mutated": [
            "def test_ols_noncentrality(self):\n    if False:\n        i = 10\n    k = self.k_groups\n    res_ols = OLS(self.y, self.ex).fit()\n    nobs_t = res_ols.model.nobs\n    c_equal = -np.eye(k)[1:]\n    c_equal[:, 0] = 1\n    v = np.zeros(c_equal.shape[0])\n    wt = res_ols.wald_test(c_equal, scalar=True)\n    (df_num, df_denom) = (wt.df_num, wt.df_denom)\n    cov_p = res_ols.cov_params()\n    nc_wt = wald_test_noncent_generic(res_ols.params, c_equal, v, cov_p, diff=None, joint=True)\n    assert_allclose(nc_wt, wt.statistic * wt.df_num, rtol=1e-13)\n    nc_wt2 = wald_test_noncent(res_ols.params, c_equal, v, res_ols, diff=None, joint=True)\n    assert_allclose(nc_wt2, nc_wt, rtol=1e-13)\n    es_ols = nc_wt / nobs_t\n    es_oneway = smo.effectsize_oneway(res_ols.params, res_ols.scale, self.nobs, use_var='equal')\n    assert_allclose(es_ols, es_oneway, rtol=1e-13)\n    alpha = 0.05\n    pow_ols = smpwr.ftest_power(np.sqrt(es_ols), df_denom, df_num, alpha, ncc=1)\n    pow_oneway = smpwr.ftest_anova_power(np.sqrt(es_oneway), nobs_t, alpha, k_groups=k, df=None)\n    assert_allclose(pow_ols, pow_oneway, rtol=1e-13)\n    params_alt = res_ols.params * 0.75\n    v_off = _offset_constraint(c_equal, res_ols.params, params_alt)\n    wt_off = res_ols.wald_test((c_equal, v + v_off), scalar=True)\n    nc_wt_off = wald_test_noncent_generic(params_alt, c_equal, v, cov_p, diff=None, joint=True)\n    assert_allclose(nc_wt_off, wt_off.statistic * wt_off.df_num, rtol=1e-13)\n    nc_wt_vec = wald_test_noncent_generic(params_alt, c_equal, v, cov_p, diff=None, joint=False)\n    for i in range(c_equal.shape[0]):\n        nc_wt_i = wald_test_noncent_generic(params_alt, c_equal[i:i + 1], v[i:i + 1], cov_p, diff=None, joint=False)\n        assert_allclose(nc_wt_vec[i], nc_wt_i, rtol=1e-13)",
            "def test_ols_noncentrality(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    k = self.k_groups\n    res_ols = OLS(self.y, self.ex).fit()\n    nobs_t = res_ols.model.nobs\n    c_equal = -np.eye(k)[1:]\n    c_equal[:, 0] = 1\n    v = np.zeros(c_equal.shape[0])\n    wt = res_ols.wald_test(c_equal, scalar=True)\n    (df_num, df_denom) = (wt.df_num, wt.df_denom)\n    cov_p = res_ols.cov_params()\n    nc_wt = wald_test_noncent_generic(res_ols.params, c_equal, v, cov_p, diff=None, joint=True)\n    assert_allclose(nc_wt, wt.statistic * wt.df_num, rtol=1e-13)\n    nc_wt2 = wald_test_noncent(res_ols.params, c_equal, v, res_ols, diff=None, joint=True)\n    assert_allclose(nc_wt2, nc_wt, rtol=1e-13)\n    es_ols = nc_wt / nobs_t\n    es_oneway = smo.effectsize_oneway(res_ols.params, res_ols.scale, self.nobs, use_var='equal')\n    assert_allclose(es_ols, es_oneway, rtol=1e-13)\n    alpha = 0.05\n    pow_ols = smpwr.ftest_power(np.sqrt(es_ols), df_denom, df_num, alpha, ncc=1)\n    pow_oneway = smpwr.ftest_anova_power(np.sqrt(es_oneway), nobs_t, alpha, k_groups=k, df=None)\n    assert_allclose(pow_ols, pow_oneway, rtol=1e-13)\n    params_alt = res_ols.params * 0.75\n    v_off = _offset_constraint(c_equal, res_ols.params, params_alt)\n    wt_off = res_ols.wald_test((c_equal, v + v_off), scalar=True)\n    nc_wt_off = wald_test_noncent_generic(params_alt, c_equal, v, cov_p, diff=None, joint=True)\n    assert_allclose(nc_wt_off, wt_off.statistic * wt_off.df_num, rtol=1e-13)\n    nc_wt_vec = wald_test_noncent_generic(params_alt, c_equal, v, cov_p, diff=None, joint=False)\n    for i in range(c_equal.shape[0]):\n        nc_wt_i = wald_test_noncent_generic(params_alt, c_equal[i:i + 1], v[i:i + 1], cov_p, diff=None, joint=False)\n        assert_allclose(nc_wt_vec[i], nc_wt_i, rtol=1e-13)",
            "def test_ols_noncentrality(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    k = self.k_groups\n    res_ols = OLS(self.y, self.ex).fit()\n    nobs_t = res_ols.model.nobs\n    c_equal = -np.eye(k)[1:]\n    c_equal[:, 0] = 1\n    v = np.zeros(c_equal.shape[0])\n    wt = res_ols.wald_test(c_equal, scalar=True)\n    (df_num, df_denom) = (wt.df_num, wt.df_denom)\n    cov_p = res_ols.cov_params()\n    nc_wt = wald_test_noncent_generic(res_ols.params, c_equal, v, cov_p, diff=None, joint=True)\n    assert_allclose(nc_wt, wt.statistic * wt.df_num, rtol=1e-13)\n    nc_wt2 = wald_test_noncent(res_ols.params, c_equal, v, res_ols, diff=None, joint=True)\n    assert_allclose(nc_wt2, nc_wt, rtol=1e-13)\n    es_ols = nc_wt / nobs_t\n    es_oneway = smo.effectsize_oneway(res_ols.params, res_ols.scale, self.nobs, use_var='equal')\n    assert_allclose(es_ols, es_oneway, rtol=1e-13)\n    alpha = 0.05\n    pow_ols = smpwr.ftest_power(np.sqrt(es_ols), df_denom, df_num, alpha, ncc=1)\n    pow_oneway = smpwr.ftest_anova_power(np.sqrt(es_oneway), nobs_t, alpha, k_groups=k, df=None)\n    assert_allclose(pow_ols, pow_oneway, rtol=1e-13)\n    params_alt = res_ols.params * 0.75\n    v_off = _offset_constraint(c_equal, res_ols.params, params_alt)\n    wt_off = res_ols.wald_test((c_equal, v + v_off), scalar=True)\n    nc_wt_off = wald_test_noncent_generic(params_alt, c_equal, v, cov_p, diff=None, joint=True)\n    assert_allclose(nc_wt_off, wt_off.statistic * wt_off.df_num, rtol=1e-13)\n    nc_wt_vec = wald_test_noncent_generic(params_alt, c_equal, v, cov_p, diff=None, joint=False)\n    for i in range(c_equal.shape[0]):\n        nc_wt_i = wald_test_noncent_generic(params_alt, c_equal[i:i + 1], v[i:i + 1], cov_p, diff=None, joint=False)\n        assert_allclose(nc_wt_vec[i], nc_wt_i, rtol=1e-13)",
            "def test_ols_noncentrality(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    k = self.k_groups\n    res_ols = OLS(self.y, self.ex).fit()\n    nobs_t = res_ols.model.nobs\n    c_equal = -np.eye(k)[1:]\n    c_equal[:, 0] = 1\n    v = np.zeros(c_equal.shape[0])\n    wt = res_ols.wald_test(c_equal, scalar=True)\n    (df_num, df_denom) = (wt.df_num, wt.df_denom)\n    cov_p = res_ols.cov_params()\n    nc_wt = wald_test_noncent_generic(res_ols.params, c_equal, v, cov_p, diff=None, joint=True)\n    assert_allclose(nc_wt, wt.statistic * wt.df_num, rtol=1e-13)\n    nc_wt2 = wald_test_noncent(res_ols.params, c_equal, v, res_ols, diff=None, joint=True)\n    assert_allclose(nc_wt2, nc_wt, rtol=1e-13)\n    es_ols = nc_wt / nobs_t\n    es_oneway = smo.effectsize_oneway(res_ols.params, res_ols.scale, self.nobs, use_var='equal')\n    assert_allclose(es_ols, es_oneway, rtol=1e-13)\n    alpha = 0.05\n    pow_ols = smpwr.ftest_power(np.sqrt(es_ols), df_denom, df_num, alpha, ncc=1)\n    pow_oneway = smpwr.ftest_anova_power(np.sqrt(es_oneway), nobs_t, alpha, k_groups=k, df=None)\n    assert_allclose(pow_ols, pow_oneway, rtol=1e-13)\n    params_alt = res_ols.params * 0.75\n    v_off = _offset_constraint(c_equal, res_ols.params, params_alt)\n    wt_off = res_ols.wald_test((c_equal, v + v_off), scalar=True)\n    nc_wt_off = wald_test_noncent_generic(params_alt, c_equal, v, cov_p, diff=None, joint=True)\n    assert_allclose(nc_wt_off, wt_off.statistic * wt_off.df_num, rtol=1e-13)\n    nc_wt_vec = wald_test_noncent_generic(params_alt, c_equal, v, cov_p, diff=None, joint=False)\n    for i in range(c_equal.shape[0]):\n        nc_wt_i = wald_test_noncent_generic(params_alt, c_equal[i:i + 1], v[i:i + 1], cov_p, diff=None, joint=False)\n        assert_allclose(nc_wt_vec[i], nc_wt_i, rtol=1e-13)",
            "def test_ols_noncentrality(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    k = self.k_groups\n    res_ols = OLS(self.y, self.ex).fit()\n    nobs_t = res_ols.model.nobs\n    c_equal = -np.eye(k)[1:]\n    c_equal[:, 0] = 1\n    v = np.zeros(c_equal.shape[0])\n    wt = res_ols.wald_test(c_equal, scalar=True)\n    (df_num, df_denom) = (wt.df_num, wt.df_denom)\n    cov_p = res_ols.cov_params()\n    nc_wt = wald_test_noncent_generic(res_ols.params, c_equal, v, cov_p, diff=None, joint=True)\n    assert_allclose(nc_wt, wt.statistic * wt.df_num, rtol=1e-13)\n    nc_wt2 = wald_test_noncent(res_ols.params, c_equal, v, res_ols, diff=None, joint=True)\n    assert_allclose(nc_wt2, nc_wt, rtol=1e-13)\n    es_ols = nc_wt / nobs_t\n    es_oneway = smo.effectsize_oneway(res_ols.params, res_ols.scale, self.nobs, use_var='equal')\n    assert_allclose(es_ols, es_oneway, rtol=1e-13)\n    alpha = 0.05\n    pow_ols = smpwr.ftest_power(np.sqrt(es_ols), df_denom, df_num, alpha, ncc=1)\n    pow_oneway = smpwr.ftest_anova_power(np.sqrt(es_oneway), nobs_t, alpha, k_groups=k, df=None)\n    assert_allclose(pow_ols, pow_oneway, rtol=1e-13)\n    params_alt = res_ols.params * 0.75\n    v_off = _offset_constraint(c_equal, res_ols.params, params_alt)\n    wt_off = res_ols.wald_test((c_equal, v + v_off), scalar=True)\n    nc_wt_off = wald_test_noncent_generic(params_alt, c_equal, v, cov_p, diff=None, joint=True)\n    assert_allclose(nc_wt_off, wt_off.statistic * wt_off.df_num, rtol=1e-13)\n    nc_wt_vec = wald_test_noncent_generic(params_alt, c_equal, v, cov_p, diff=None, joint=False)\n    for i in range(c_equal.shape[0]):\n        nc_wt_i = wald_test_noncent_generic(params_alt, c_equal[i:i + 1], v[i:i + 1], cov_p, diff=None, joint=False)\n        assert_allclose(nc_wt_vec[i], nc_wt_i, rtol=1e-13)"
        ]
    },
    {
        "func_name": "test_simulate_equivalence",
        "original": "def test_simulate_equivalence():\n    k_groups = 4\n    k_repl = 10\n    nobs = np.array([10, 12, 13, 15]) * k_repl\n    means = np.array([-1, 0, 0, 1]) * 0.12\n    vars_ = np.array([1, 2, 3, 4])\n    nobs_t = nobs.sum()\n    eps = 0.0191 * 10\n    opt_var = ['unequal', 'equal', 'bf']\n    k_mc = 100\n    np.random.seed(987126)\n    res_mc = smo.simulate_power_equivalence_oneway(means, nobs, eps, vars_=vars_, k_mc=k_mc, trim_frac=0.1, options_var=opt_var, margin_type='wellek')\n    frac_reject = (res_mc.pvalue <= 0.05).sum(0) / k_mc\n    assert_allclose(frac_reject, [0.17, 0.18, 0.14], atol=0.001)\n    es_alt_li = []\n    for uv in opt_var:\n        es = effectsize_oneway(means, vars_, nobs, use_var=uv)\n        es_alt_li.append(es)\n    margin = wellek_to_f2(eps, k_groups)\n    pow_ = [power_equivalence_oneway(es_, margin, nobs_t, n_groups=k_groups, df=None, alpha=0.05, margin_type='f2') for es_ in es_alt_li]\n    assert_allclose(pow_, [0.147749, 0.173358, 0.177412], atol=0.007)",
        "mutated": [
            "def test_simulate_equivalence():\n    if False:\n        i = 10\n    k_groups = 4\n    k_repl = 10\n    nobs = np.array([10, 12, 13, 15]) * k_repl\n    means = np.array([-1, 0, 0, 1]) * 0.12\n    vars_ = np.array([1, 2, 3, 4])\n    nobs_t = nobs.sum()\n    eps = 0.0191 * 10\n    opt_var = ['unequal', 'equal', 'bf']\n    k_mc = 100\n    np.random.seed(987126)\n    res_mc = smo.simulate_power_equivalence_oneway(means, nobs, eps, vars_=vars_, k_mc=k_mc, trim_frac=0.1, options_var=opt_var, margin_type='wellek')\n    frac_reject = (res_mc.pvalue <= 0.05).sum(0) / k_mc\n    assert_allclose(frac_reject, [0.17, 0.18, 0.14], atol=0.001)\n    es_alt_li = []\n    for uv in opt_var:\n        es = effectsize_oneway(means, vars_, nobs, use_var=uv)\n        es_alt_li.append(es)\n    margin = wellek_to_f2(eps, k_groups)\n    pow_ = [power_equivalence_oneway(es_, margin, nobs_t, n_groups=k_groups, df=None, alpha=0.05, margin_type='f2') for es_ in es_alt_li]\n    assert_allclose(pow_, [0.147749, 0.173358, 0.177412], atol=0.007)",
            "def test_simulate_equivalence():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    k_groups = 4\n    k_repl = 10\n    nobs = np.array([10, 12, 13, 15]) * k_repl\n    means = np.array([-1, 0, 0, 1]) * 0.12\n    vars_ = np.array([1, 2, 3, 4])\n    nobs_t = nobs.sum()\n    eps = 0.0191 * 10\n    opt_var = ['unequal', 'equal', 'bf']\n    k_mc = 100\n    np.random.seed(987126)\n    res_mc = smo.simulate_power_equivalence_oneway(means, nobs, eps, vars_=vars_, k_mc=k_mc, trim_frac=0.1, options_var=opt_var, margin_type='wellek')\n    frac_reject = (res_mc.pvalue <= 0.05).sum(0) / k_mc\n    assert_allclose(frac_reject, [0.17, 0.18, 0.14], atol=0.001)\n    es_alt_li = []\n    for uv in opt_var:\n        es = effectsize_oneway(means, vars_, nobs, use_var=uv)\n        es_alt_li.append(es)\n    margin = wellek_to_f2(eps, k_groups)\n    pow_ = [power_equivalence_oneway(es_, margin, nobs_t, n_groups=k_groups, df=None, alpha=0.05, margin_type='f2') for es_ in es_alt_li]\n    assert_allclose(pow_, [0.147749, 0.173358, 0.177412], atol=0.007)",
            "def test_simulate_equivalence():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    k_groups = 4\n    k_repl = 10\n    nobs = np.array([10, 12, 13, 15]) * k_repl\n    means = np.array([-1, 0, 0, 1]) * 0.12\n    vars_ = np.array([1, 2, 3, 4])\n    nobs_t = nobs.sum()\n    eps = 0.0191 * 10\n    opt_var = ['unequal', 'equal', 'bf']\n    k_mc = 100\n    np.random.seed(987126)\n    res_mc = smo.simulate_power_equivalence_oneway(means, nobs, eps, vars_=vars_, k_mc=k_mc, trim_frac=0.1, options_var=opt_var, margin_type='wellek')\n    frac_reject = (res_mc.pvalue <= 0.05).sum(0) / k_mc\n    assert_allclose(frac_reject, [0.17, 0.18, 0.14], atol=0.001)\n    es_alt_li = []\n    for uv in opt_var:\n        es = effectsize_oneway(means, vars_, nobs, use_var=uv)\n        es_alt_li.append(es)\n    margin = wellek_to_f2(eps, k_groups)\n    pow_ = [power_equivalence_oneway(es_, margin, nobs_t, n_groups=k_groups, df=None, alpha=0.05, margin_type='f2') for es_ in es_alt_li]\n    assert_allclose(pow_, [0.147749, 0.173358, 0.177412], atol=0.007)",
            "def test_simulate_equivalence():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    k_groups = 4\n    k_repl = 10\n    nobs = np.array([10, 12, 13, 15]) * k_repl\n    means = np.array([-1, 0, 0, 1]) * 0.12\n    vars_ = np.array([1, 2, 3, 4])\n    nobs_t = nobs.sum()\n    eps = 0.0191 * 10\n    opt_var = ['unequal', 'equal', 'bf']\n    k_mc = 100\n    np.random.seed(987126)\n    res_mc = smo.simulate_power_equivalence_oneway(means, nobs, eps, vars_=vars_, k_mc=k_mc, trim_frac=0.1, options_var=opt_var, margin_type='wellek')\n    frac_reject = (res_mc.pvalue <= 0.05).sum(0) / k_mc\n    assert_allclose(frac_reject, [0.17, 0.18, 0.14], atol=0.001)\n    es_alt_li = []\n    for uv in opt_var:\n        es = effectsize_oneway(means, vars_, nobs, use_var=uv)\n        es_alt_li.append(es)\n    margin = wellek_to_f2(eps, k_groups)\n    pow_ = [power_equivalence_oneway(es_, margin, nobs_t, n_groups=k_groups, df=None, alpha=0.05, margin_type='f2') for es_ in es_alt_li]\n    assert_allclose(pow_, [0.147749, 0.173358, 0.177412], atol=0.007)",
            "def test_simulate_equivalence():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    k_groups = 4\n    k_repl = 10\n    nobs = np.array([10, 12, 13, 15]) * k_repl\n    means = np.array([-1, 0, 0, 1]) * 0.12\n    vars_ = np.array([1, 2, 3, 4])\n    nobs_t = nobs.sum()\n    eps = 0.0191 * 10\n    opt_var = ['unequal', 'equal', 'bf']\n    k_mc = 100\n    np.random.seed(987126)\n    res_mc = smo.simulate_power_equivalence_oneway(means, nobs, eps, vars_=vars_, k_mc=k_mc, trim_frac=0.1, options_var=opt_var, margin_type='wellek')\n    frac_reject = (res_mc.pvalue <= 0.05).sum(0) / k_mc\n    assert_allclose(frac_reject, [0.17, 0.18, 0.14], atol=0.001)\n    es_alt_li = []\n    for uv in opt_var:\n        es = effectsize_oneway(means, vars_, nobs, use_var=uv)\n        es_alt_li.append(es)\n    margin = wellek_to_f2(eps, k_groups)\n    pow_ = [power_equivalence_oneway(es_, margin, nobs_t, n_groups=k_groups, df=None, alpha=0.05, margin_type='f2') for es_ in es_alt_li]\n    assert_allclose(pow_, [0.147749, 0.173358, 0.177412], atol=0.007)"
        ]
    }
]