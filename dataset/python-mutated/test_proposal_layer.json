[
    {
        "func_name": "pytest_generate_tests",
        "original": "def pytest_generate_tests(metafunc):\n    if 'fargs' in metafunc.fixturenames:\n        if metafunc.config.option.all:\n            _conv_size = [62, 63]\n            im_shape = [[800, 600], [460, 1000]]\n            SCALE = [1.6, 2.0]\n            pre_nms_topN = [12000, 6000]\n            post_nms_topN = [2000, 300]\n            nms_thresh = [0.7]\n            min_size = [16]\n        else:\n            _conv_size = [63]\n            im_shape = [[800, 600]]\n            SCALE = [1.6, 2.5]\n            pre_nms_topN = [12000]\n            post_nms_topN = [2000]\n            nms_thresh = [0.7]\n            min_size = [16]\n        fargs = itt.product(_conv_size, im_shape, SCALE, pre_nms_topN, post_nms_topN, nms_thresh, min_size)\n        metafunc.parametrize('fargs', fargs)",
        "mutated": [
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n    if 'fargs' in metafunc.fixturenames:\n        if metafunc.config.option.all:\n            _conv_size = [62, 63]\n            im_shape = [[800, 600], [460, 1000]]\n            SCALE = [1.6, 2.0]\n            pre_nms_topN = [12000, 6000]\n            post_nms_topN = [2000, 300]\n            nms_thresh = [0.7]\n            min_size = [16]\n        else:\n            _conv_size = [63]\n            im_shape = [[800, 600]]\n            SCALE = [1.6, 2.5]\n            pre_nms_topN = [12000]\n            post_nms_topN = [2000]\n            nms_thresh = [0.7]\n            min_size = [16]\n        fargs = itt.product(_conv_size, im_shape, SCALE, pre_nms_topN, post_nms_topN, nms_thresh, min_size)\n        metafunc.parametrize('fargs', fargs)",
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if 'fargs' in metafunc.fixturenames:\n        if metafunc.config.option.all:\n            _conv_size = [62, 63]\n            im_shape = [[800, 600], [460, 1000]]\n            SCALE = [1.6, 2.0]\n            pre_nms_topN = [12000, 6000]\n            post_nms_topN = [2000, 300]\n            nms_thresh = [0.7]\n            min_size = [16]\n        else:\n            _conv_size = [63]\n            im_shape = [[800, 600]]\n            SCALE = [1.6, 2.5]\n            pre_nms_topN = [12000]\n            post_nms_topN = [2000]\n            nms_thresh = [0.7]\n            min_size = [16]\n        fargs = itt.product(_conv_size, im_shape, SCALE, pre_nms_topN, post_nms_topN, nms_thresh, min_size)\n        metafunc.parametrize('fargs', fargs)",
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if 'fargs' in metafunc.fixturenames:\n        if metafunc.config.option.all:\n            _conv_size = [62, 63]\n            im_shape = [[800, 600], [460, 1000]]\n            SCALE = [1.6, 2.0]\n            pre_nms_topN = [12000, 6000]\n            post_nms_topN = [2000, 300]\n            nms_thresh = [0.7]\n            min_size = [16]\n        else:\n            _conv_size = [63]\n            im_shape = [[800, 600]]\n            SCALE = [1.6, 2.5]\n            pre_nms_topN = [12000]\n            post_nms_topN = [2000]\n            nms_thresh = [0.7]\n            min_size = [16]\n        fargs = itt.product(_conv_size, im_shape, SCALE, pre_nms_topN, post_nms_topN, nms_thresh, min_size)\n        metafunc.parametrize('fargs', fargs)",
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if 'fargs' in metafunc.fixturenames:\n        if metafunc.config.option.all:\n            _conv_size = [62, 63]\n            im_shape = [[800, 600], [460, 1000]]\n            SCALE = [1.6, 2.0]\n            pre_nms_topN = [12000, 6000]\n            post_nms_topN = [2000, 300]\n            nms_thresh = [0.7]\n            min_size = [16]\n        else:\n            _conv_size = [63]\n            im_shape = [[800, 600]]\n            SCALE = [1.6, 2.5]\n            pre_nms_topN = [12000]\n            post_nms_topN = [2000]\n            nms_thresh = [0.7]\n            min_size = [16]\n        fargs = itt.product(_conv_size, im_shape, SCALE, pre_nms_topN, post_nms_topN, nms_thresh, min_size)\n        metafunc.parametrize('fargs', fargs)",
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if 'fargs' in metafunc.fixturenames:\n        if metafunc.config.option.all:\n            _conv_size = [62, 63]\n            im_shape = [[800, 600], [460, 1000]]\n            SCALE = [1.6, 2.0]\n            pre_nms_topN = [12000, 6000]\n            post_nms_topN = [2000, 300]\n            nms_thresh = [0.7]\n            min_size = [16]\n        else:\n            _conv_size = [63]\n            im_shape = [[800, 600]]\n            SCALE = [1.6, 2.5]\n            pre_nms_topN = [12000]\n            post_nms_topN = [2000]\n            nms_thresh = [0.7]\n            min_size = [16]\n        fargs = itt.product(_conv_size, im_shape, SCALE, pre_nms_topN, post_nms_topN, nms_thresh, min_size)\n        metafunc.parametrize('fargs', fargs)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, out):\n    self.outputs = out\n    self.out_shape = (1, 1)\n    self.shape = (1, 1)\n    self.parallelism = False",
        "mutated": [
            "def __init__(self, out):\n    if False:\n        i = 10\n    self.outputs = out\n    self.out_shape = (1, 1)\n    self.shape = (1, 1)\n    self.parallelism = False",
            "def __init__(self, out):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.outputs = out\n    self.out_shape = (1, 1)\n    self.shape = (1, 1)\n    self.parallelism = False",
            "def __init__(self, out):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.outputs = out\n    self.out_shape = (1, 1)\n    self.shape = (1, 1)\n    self.parallelism = False",
            "def __init__(self, out):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.outputs = out\n    self.out_shape = (1, 1)\n    self.shape = (1, 1)\n    self.parallelism = False",
            "def __init__(self, out):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.outputs = out\n    self.out_shape = (1, 1)\n    self.shape = (1, 1)\n    self.parallelism = False"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, conv_size, conv_scale, im_shape, SCALE, gt_boxes, gt_classes, num_gt_boxes, frcn_labels, frcn_labels_mask, frcn_bbtargets, frcn_bbmask):\n    self.im_shape = im_shape\n    self.im_scale = SCALE\n    self.gt_boxes = gt_boxes\n    self.gt_classes = gt_classes\n    self.num_gt_boxes = num_gt_boxes\n    self.frcn_labels = frcn_labels\n    self.frcn_labels_mask = frcn_labels_mask\n    self.frcn_bbtargets = frcn_bbtargets\n    self.frcn_bbmask = frcn_bbmask\n    self.conv_height = conv_size\n    self.conv_width = conv_size\n    self.conv_scale = conv_scale.get()\n    self.num_classes = 21",
        "mutated": [
            "def __init__(self, conv_size, conv_scale, im_shape, SCALE, gt_boxes, gt_classes, num_gt_boxes, frcn_labels, frcn_labels_mask, frcn_bbtargets, frcn_bbmask):\n    if False:\n        i = 10\n    self.im_shape = im_shape\n    self.im_scale = SCALE\n    self.gt_boxes = gt_boxes\n    self.gt_classes = gt_classes\n    self.num_gt_boxes = num_gt_boxes\n    self.frcn_labels = frcn_labels\n    self.frcn_labels_mask = frcn_labels_mask\n    self.frcn_bbtargets = frcn_bbtargets\n    self.frcn_bbmask = frcn_bbmask\n    self.conv_height = conv_size\n    self.conv_width = conv_size\n    self.conv_scale = conv_scale.get()\n    self.num_classes = 21",
            "def __init__(self, conv_size, conv_scale, im_shape, SCALE, gt_boxes, gt_classes, num_gt_boxes, frcn_labels, frcn_labels_mask, frcn_bbtargets, frcn_bbmask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.im_shape = im_shape\n    self.im_scale = SCALE\n    self.gt_boxes = gt_boxes\n    self.gt_classes = gt_classes\n    self.num_gt_boxes = num_gt_boxes\n    self.frcn_labels = frcn_labels\n    self.frcn_labels_mask = frcn_labels_mask\n    self.frcn_bbtargets = frcn_bbtargets\n    self.frcn_bbmask = frcn_bbmask\n    self.conv_height = conv_size\n    self.conv_width = conv_size\n    self.conv_scale = conv_scale.get()\n    self.num_classes = 21",
            "def __init__(self, conv_size, conv_scale, im_shape, SCALE, gt_boxes, gt_classes, num_gt_boxes, frcn_labels, frcn_labels_mask, frcn_bbtargets, frcn_bbmask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.im_shape = im_shape\n    self.im_scale = SCALE\n    self.gt_boxes = gt_boxes\n    self.gt_classes = gt_classes\n    self.num_gt_boxes = num_gt_boxes\n    self.frcn_labels = frcn_labels\n    self.frcn_labels_mask = frcn_labels_mask\n    self.frcn_bbtargets = frcn_bbtargets\n    self.frcn_bbmask = frcn_bbmask\n    self.conv_height = conv_size\n    self.conv_width = conv_size\n    self.conv_scale = conv_scale.get()\n    self.num_classes = 21",
            "def __init__(self, conv_size, conv_scale, im_shape, SCALE, gt_boxes, gt_classes, num_gt_boxes, frcn_labels, frcn_labels_mask, frcn_bbtargets, frcn_bbmask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.im_shape = im_shape\n    self.im_scale = SCALE\n    self.gt_boxes = gt_boxes\n    self.gt_classes = gt_classes\n    self.num_gt_boxes = num_gt_boxes\n    self.frcn_labels = frcn_labels\n    self.frcn_labels_mask = frcn_labels_mask\n    self.frcn_bbtargets = frcn_bbtargets\n    self.frcn_bbmask = frcn_bbmask\n    self.conv_height = conv_size\n    self.conv_width = conv_size\n    self.conv_scale = conv_scale.get()\n    self.num_classes = 21",
            "def __init__(self, conv_size, conv_scale, im_shape, SCALE, gt_boxes, gt_classes, num_gt_boxes, frcn_labels, frcn_labels_mask, frcn_bbtargets, frcn_bbmask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.im_shape = im_shape\n    self.im_scale = SCALE\n    self.gt_boxes = gt_boxes\n    self.gt_classes = gt_classes\n    self.num_gt_boxes = num_gt_boxes\n    self.frcn_labels = frcn_labels\n    self.frcn_labels_mask = frcn_labels_mask\n    self.frcn_bbtargets = frcn_bbtargets\n    self.frcn_bbmask = frcn_bbmask\n    self.conv_height = conv_size\n    self.conv_width = conv_size\n    self.conv_scale = conv_scale.get()\n    self.num_classes = 21"
        ]
    },
    {
        "func_name": "get_metadata_buffers",
        "original": "def get_metadata_buffers(self):\n    return (self.im_shape, self.im_scale, self.gt_boxes, self.gt_classes, self.num_gt_boxes, None)",
        "mutated": [
            "def get_metadata_buffers(self):\n    if False:\n        i = 10\n    return (self.im_shape, self.im_scale, self.gt_boxes, self.gt_classes, self.num_gt_boxes, None)",
            "def get_metadata_buffers(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return (self.im_shape, self.im_scale, self.gt_boxes, self.gt_classes, self.num_gt_boxes, None)",
            "def get_metadata_buffers(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return (self.im_shape, self.im_scale, self.gt_boxes, self.gt_classes, self.num_gt_boxes, None)",
            "def get_metadata_buffers(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return (self.im_shape, self.im_scale, self.gt_boxes, self.gt_classes, self.num_gt_boxes, None)",
            "def get_metadata_buffers(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return (self.im_shape, self.im_scale, self.gt_boxes, self.gt_classes, self.num_gt_boxes, None)"
        ]
    },
    {
        "func_name": "get_target_buffers",
        "original": "def get_target_buffers(self):\n    return ((self.frcn_labels, self.frcn_labels_mask), (self.frcn_bbtargets, self.frcn_bbmask))",
        "mutated": [
            "def get_target_buffers(self):\n    if False:\n        i = 10\n    return ((self.frcn_labels, self.frcn_labels_mask), (self.frcn_bbtargets, self.frcn_bbmask))",
            "def get_target_buffers(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return ((self.frcn_labels, self.frcn_labels_mask), (self.frcn_bbtargets, self.frcn_bbmask))",
            "def get_target_buffers(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return ((self.frcn_labels, self.frcn_labels_mask), (self.frcn_bbtargets, self.frcn_bbmask))",
            "def get_target_buffers(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return ((self.frcn_labels, self.frcn_labels_mask), (self.frcn_bbtargets, self.frcn_bbmask))",
            "def get_target_buffers(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return ((self.frcn_labels, self.frcn_labels_mask), (self.frcn_bbtargets, self.frcn_bbmask))"
        ]
    },
    {
        "func_name": "test_proposal_layer",
        "original": "def test_proposal_layer(backend_default, fargs):\n    np.random.seed(seed=0)\n    be = backend_default\n    be.bsz = 1\n    (_conv_size, im_shape_arr, SCALE, pre_nms_topN, post_nms_topN, nms_thresh, min_size) = fargs\n    im_shape = be.zeros((2, 1), dtype=np.float32)\n    im_shape[:] = np.array(im_shape_arr)\n    im_scale = be.ones((1, 1), dtype=np.float32).fill(1.0 / 16.0)\n    SCALE = be.ones((1, 1), dtype=np.float32).fill(SCALE)\n    real_H = np.round(im_shape.get()[1] * im_scale.get()).astype(int).reshape((1,))[0]\n    real_W = np.round(im_shape.get()[0] * im_scale.get()).astype(int).reshape((1,))[0]\n    frcn_labels = be.zeros((21, 128), dtype=np.int32)\n    frcn_labels_mask = be.zeros(frcn_labels.shape, dtype=np.int32)\n    frcn_bbtargets = be.zeros((21 * 4, 128), dtype=np.float32)\n    frcn_bbmask = be.zeros(frcn_bbtargets.shape, dtype=np.float32)\n    gt_boxes = be.zeros((64, 4), dtype=np.float32)\n    gt_boxes[:3, :] = np.array([[262, 210, 323, 338], [164, 263, 252, 371], [240, 193, 294, 298]])\n    gt_classes = be.zeros((64, 1), dtype=np.int32)\n    gt_classes[:3, :] = np.array([[9], [9], [9]])\n    num_gt_boxes = be.zeros((1, 1), dtype=np.int32).fill(3)\n    num_scores = 2 * 9 * _conv_size * _conv_size\n    rpn_obj_scores_dev = be.array(np.random.choice(num_scores * 2, size=num_scores, replace=False) / float(num_scores * 2.0))\n    rpn_bbox_deltas_dev = be.array(np.random.random((4 * 9 * _conv_size * _conv_size, 1)))\n    RPN_1x1_obj = mock_layer(rpn_obj_scores_dev)\n    RPN_1x1_bbox = mock_layer(rpn_bbox_deltas_dev)\n    mock_loader = mock_dataloader(_conv_size, im_scale, im_shape, SCALE, gt_boxes, gt_classes, num_gt_boxes, frcn_labels, frcn_labels_mask, frcn_bbtargets, frcn_bbmask)\n    prop_layer = ProposalLayer([[RPN_1x1_obj], [RPN_1x1_bbox]], mock_loader, pre_nms_N=pre_nms_topN, post_nms_N=post_nms_topN, nms_thresh=nms_thresh, min_bbox_size=min_size, num_rois=128, deterministic=True, inference=False, debug=True)\n    prop_layer.configure(mock_layer([]))\n    prop_layer.allocate()\n    inputs = []\n    (inputs, dev_proposals) = prop_layer.fprop(inputs, inference=False)\n    target_proposals = prop_layer.proposals\n    target_scores = prop_layer.scores\n    prop_layer_ref = PyCaffeProposalLayer()\n    rpn_obj_scores = rpn_obj_scores_dev.get()\n    rpn_bbox_deltas = rpn_bbox_deltas_dev.get()\n    rpn_bbox_deltas = rpn_bbox_deltas.reshape((4, -1, _conv_size, _conv_size))\n    rpn_bbox_deltas = rpn_bbox_deltas[:, :, :real_H, :real_W].reshape((4, -1)).T\n    rpn_obj_scores = rpn_obj_scores.reshape((2, -1, _conv_size, _conv_size))\n    rpn_obj_scores = rpn_obj_scores[:, :, :real_H, :real_W].transpose((0, 1, 2, 3))\n    rpn_obj_scores = rpn_obj_scores.reshape((1, -1, real_H, real_W))\n    bottom = [None, None, None]\n    bottom[0] = rpn_obj_scores\n    bottom[1] = rpn_bbox_deltas\n    bottom[2] = [im_shape[1], im_shape[0], SCALE]\n    top = [None, None]\n    prop_layer_ref.setup(bottom, top, pre_nms_topN=pre_nms_topN, post_nms_topN=post_nms_topN, nms_thresh=nms_thresh, min_size=min_size)\n    prop_layer_ref.forward(bottom, top)\n    assert np.allclose(top[0][:, 1:], target_proposals, atol=1e-05, rtol=0.0001)\n    assert np.allclose(top[1], target_scores, atol=1e-05, rtol=0.0001)\n    t_bottom = [0, 1]\n    zeros = np.zeros((target_proposals.shape[0], 1), dtype=target_proposals.dtype)\n    t_bottom[0] = np.hstack((zeros, target_proposals))\n    t_bottom[1] = np.hstack((prop_layer.gt_boxes.get(), prop_layer.gt_classes.get()))[:prop_layer.num_gt_boxes.get()[0][0]]\n    t_top = [None, None, None, None, None]\n    prop_target_layer_ref = PyCaffeProposalTargetLayer()\n    prop_target_layer_ref.setup(t_bottom, t_top, deterministic=True)\n    prop_target_layer_ref.forward(t_bottom, t_top)\n    frcn_bbtargets_reference = np.zeros(frcn_bbtargets.shape, dtype=np.float32)\n    frcn_bbmask_reference = np.zeros(frcn_bbmask.shape, dtype=np.float32)\n    frcn_bbtargets_reference[:t_top[2].shape[0]] = t_top[2].T\n    frcn_bbmask_reference[:t_top[3].shape[0]] = t_top[3].T\n    neon_labels = np.zeros((frcn_labels.shape[1],))\n    label_mat = frcn_labels.get() * frcn_labels_mask.get()\n    for cls in range(frcn_labels.shape[0]):\n        for (idx, elem) in enumerate(label_mat[cls]):\n            if elem != 0:\n                neon_labels[idx] = cls\n    assert np.alltrue(t_top[1] == neon_labels)\n    assert np.allclose(frcn_bbtargets_reference, frcn_bbtargets.get(), atol=0.0001)\n    assert np.alltrue(frcn_bbmask_reference == frcn_bbmask.get())",
        "mutated": [
            "def test_proposal_layer(backend_default, fargs):\n    if False:\n        i = 10\n    np.random.seed(seed=0)\n    be = backend_default\n    be.bsz = 1\n    (_conv_size, im_shape_arr, SCALE, pre_nms_topN, post_nms_topN, nms_thresh, min_size) = fargs\n    im_shape = be.zeros((2, 1), dtype=np.float32)\n    im_shape[:] = np.array(im_shape_arr)\n    im_scale = be.ones((1, 1), dtype=np.float32).fill(1.0 / 16.0)\n    SCALE = be.ones((1, 1), dtype=np.float32).fill(SCALE)\n    real_H = np.round(im_shape.get()[1] * im_scale.get()).astype(int).reshape((1,))[0]\n    real_W = np.round(im_shape.get()[0] * im_scale.get()).astype(int).reshape((1,))[0]\n    frcn_labels = be.zeros((21, 128), dtype=np.int32)\n    frcn_labels_mask = be.zeros(frcn_labels.shape, dtype=np.int32)\n    frcn_bbtargets = be.zeros((21 * 4, 128), dtype=np.float32)\n    frcn_bbmask = be.zeros(frcn_bbtargets.shape, dtype=np.float32)\n    gt_boxes = be.zeros((64, 4), dtype=np.float32)\n    gt_boxes[:3, :] = np.array([[262, 210, 323, 338], [164, 263, 252, 371], [240, 193, 294, 298]])\n    gt_classes = be.zeros((64, 1), dtype=np.int32)\n    gt_classes[:3, :] = np.array([[9], [9], [9]])\n    num_gt_boxes = be.zeros((1, 1), dtype=np.int32).fill(3)\n    num_scores = 2 * 9 * _conv_size * _conv_size\n    rpn_obj_scores_dev = be.array(np.random.choice(num_scores * 2, size=num_scores, replace=False) / float(num_scores * 2.0))\n    rpn_bbox_deltas_dev = be.array(np.random.random((4 * 9 * _conv_size * _conv_size, 1)))\n    RPN_1x1_obj = mock_layer(rpn_obj_scores_dev)\n    RPN_1x1_bbox = mock_layer(rpn_bbox_deltas_dev)\n    mock_loader = mock_dataloader(_conv_size, im_scale, im_shape, SCALE, gt_boxes, gt_classes, num_gt_boxes, frcn_labels, frcn_labels_mask, frcn_bbtargets, frcn_bbmask)\n    prop_layer = ProposalLayer([[RPN_1x1_obj], [RPN_1x1_bbox]], mock_loader, pre_nms_N=pre_nms_topN, post_nms_N=post_nms_topN, nms_thresh=nms_thresh, min_bbox_size=min_size, num_rois=128, deterministic=True, inference=False, debug=True)\n    prop_layer.configure(mock_layer([]))\n    prop_layer.allocate()\n    inputs = []\n    (inputs, dev_proposals) = prop_layer.fprop(inputs, inference=False)\n    target_proposals = prop_layer.proposals\n    target_scores = prop_layer.scores\n    prop_layer_ref = PyCaffeProposalLayer()\n    rpn_obj_scores = rpn_obj_scores_dev.get()\n    rpn_bbox_deltas = rpn_bbox_deltas_dev.get()\n    rpn_bbox_deltas = rpn_bbox_deltas.reshape((4, -1, _conv_size, _conv_size))\n    rpn_bbox_deltas = rpn_bbox_deltas[:, :, :real_H, :real_W].reshape((4, -1)).T\n    rpn_obj_scores = rpn_obj_scores.reshape((2, -1, _conv_size, _conv_size))\n    rpn_obj_scores = rpn_obj_scores[:, :, :real_H, :real_W].transpose((0, 1, 2, 3))\n    rpn_obj_scores = rpn_obj_scores.reshape((1, -1, real_H, real_W))\n    bottom = [None, None, None]\n    bottom[0] = rpn_obj_scores\n    bottom[1] = rpn_bbox_deltas\n    bottom[2] = [im_shape[1], im_shape[0], SCALE]\n    top = [None, None]\n    prop_layer_ref.setup(bottom, top, pre_nms_topN=pre_nms_topN, post_nms_topN=post_nms_topN, nms_thresh=nms_thresh, min_size=min_size)\n    prop_layer_ref.forward(bottom, top)\n    assert np.allclose(top[0][:, 1:], target_proposals, atol=1e-05, rtol=0.0001)\n    assert np.allclose(top[1], target_scores, atol=1e-05, rtol=0.0001)\n    t_bottom = [0, 1]\n    zeros = np.zeros((target_proposals.shape[0], 1), dtype=target_proposals.dtype)\n    t_bottom[0] = np.hstack((zeros, target_proposals))\n    t_bottom[1] = np.hstack((prop_layer.gt_boxes.get(), prop_layer.gt_classes.get()))[:prop_layer.num_gt_boxes.get()[0][0]]\n    t_top = [None, None, None, None, None]\n    prop_target_layer_ref = PyCaffeProposalTargetLayer()\n    prop_target_layer_ref.setup(t_bottom, t_top, deterministic=True)\n    prop_target_layer_ref.forward(t_bottom, t_top)\n    frcn_bbtargets_reference = np.zeros(frcn_bbtargets.shape, dtype=np.float32)\n    frcn_bbmask_reference = np.zeros(frcn_bbmask.shape, dtype=np.float32)\n    frcn_bbtargets_reference[:t_top[2].shape[0]] = t_top[2].T\n    frcn_bbmask_reference[:t_top[3].shape[0]] = t_top[3].T\n    neon_labels = np.zeros((frcn_labels.shape[1],))\n    label_mat = frcn_labels.get() * frcn_labels_mask.get()\n    for cls in range(frcn_labels.shape[0]):\n        for (idx, elem) in enumerate(label_mat[cls]):\n            if elem != 0:\n                neon_labels[idx] = cls\n    assert np.alltrue(t_top[1] == neon_labels)\n    assert np.allclose(frcn_bbtargets_reference, frcn_bbtargets.get(), atol=0.0001)\n    assert np.alltrue(frcn_bbmask_reference == frcn_bbmask.get())",
            "def test_proposal_layer(backend_default, fargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    np.random.seed(seed=0)\n    be = backend_default\n    be.bsz = 1\n    (_conv_size, im_shape_arr, SCALE, pre_nms_topN, post_nms_topN, nms_thresh, min_size) = fargs\n    im_shape = be.zeros((2, 1), dtype=np.float32)\n    im_shape[:] = np.array(im_shape_arr)\n    im_scale = be.ones((1, 1), dtype=np.float32).fill(1.0 / 16.0)\n    SCALE = be.ones((1, 1), dtype=np.float32).fill(SCALE)\n    real_H = np.round(im_shape.get()[1] * im_scale.get()).astype(int).reshape((1,))[0]\n    real_W = np.round(im_shape.get()[0] * im_scale.get()).astype(int).reshape((1,))[0]\n    frcn_labels = be.zeros((21, 128), dtype=np.int32)\n    frcn_labels_mask = be.zeros(frcn_labels.shape, dtype=np.int32)\n    frcn_bbtargets = be.zeros((21 * 4, 128), dtype=np.float32)\n    frcn_bbmask = be.zeros(frcn_bbtargets.shape, dtype=np.float32)\n    gt_boxes = be.zeros((64, 4), dtype=np.float32)\n    gt_boxes[:3, :] = np.array([[262, 210, 323, 338], [164, 263, 252, 371], [240, 193, 294, 298]])\n    gt_classes = be.zeros((64, 1), dtype=np.int32)\n    gt_classes[:3, :] = np.array([[9], [9], [9]])\n    num_gt_boxes = be.zeros((1, 1), dtype=np.int32).fill(3)\n    num_scores = 2 * 9 * _conv_size * _conv_size\n    rpn_obj_scores_dev = be.array(np.random.choice(num_scores * 2, size=num_scores, replace=False) / float(num_scores * 2.0))\n    rpn_bbox_deltas_dev = be.array(np.random.random((4 * 9 * _conv_size * _conv_size, 1)))\n    RPN_1x1_obj = mock_layer(rpn_obj_scores_dev)\n    RPN_1x1_bbox = mock_layer(rpn_bbox_deltas_dev)\n    mock_loader = mock_dataloader(_conv_size, im_scale, im_shape, SCALE, gt_boxes, gt_classes, num_gt_boxes, frcn_labels, frcn_labels_mask, frcn_bbtargets, frcn_bbmask)\n    prop_layer = ProposalLayer([[RPN_1x1_obj], [RPN_1x1_bbox]], mock_loader, pre_nms_N=pre_nms_topN, post_nms_N=post_nms_topN, nms_thresh=nms_thresh, min_bbox_size=min_size, num_rois=128, deterministic=True, inference=False, debug=True)\n    prop_layer.configure(mock_layer([]))\n    prop_layer.allocate()\n    inputs = []\n    (inputs, dev_proposals) = prop_layer.fprop(inputs, inference=False)\n    target_proposals = prop_layer.proposals\n    target_scores = prop_layer.scores\n    prop_layer_ref = PyCaffeProposalLayer()\n    rpn_obj_scores = rpn_obj_scores_dev.get()\n    rpn_bbox_deltas = rpn_bbox_deltas_dev.get()\n    rpn_bbox_deltas = rpn_bbox_deltas.reshape((4, -1, _conv_size, _conv_size))\n    rpn_bbox_deltas = rpn_bbox_deltas[:, :, :real_H, :real_W].reshape((4, -1)).T\n    rpn_obj_scores = rpn_obj_scores.reshape((2, -1, _conv_size, _conv_size))\n    rpn_obj_scores = rpn_obj_scores[:, :, :real_H, :real_W].transpose((0, 1, 2, 3))\n    rpn_obj_scores = rpn_obj_scores.reshape((1, -1, real_H, real_W))\n    bottom = [None, None, None]\n    bottom[0] = rpn_obj_scores\n    bottom[1] = rpn_bbox_deltas\n    bottom[2] = [im_shape[1], im_shape[0], SCALE]\n    top = [None, None]\n    prop_layer_ref.setup(bottom, top, pre_nms_topN=pre_nms_topN, post_nms_topN=post_nms_topN, nms_thresh=nms_thresh, min_size=min_size)\n    prop_layer_ref.forward(bottom, top)\n    assert np.allclose(top[0][:, 1:], target_proposals, atol=1e-05, rtol=0.0001)\n    assert np.allclose(top[1], target_scores, atol=1e-05, rtol=0.0001)\n    t_bottom = [0, 1]\n    zeros = np.zeros((target_proposals.shape[0], 1), dtype=target_proposals.dtype)\n    t_bottom[0] = np.hstack((zeros, target_proposals))\n    t_bottom[1] = np.hstack((prop_layer.gt_boxes.get(), prop_layer.gt_classes.get()))[:prop_layer.num_gt_boxes.get()[0][0]]\n    t_top = [None, None, None, None, None]\n    prop_target_layer_ref = PyCaffeProposalTargetLayer()\n    prop_target_layer_ref.setup(t_bottom, t_top, deterministic=True)\n    prop_target_layer_ref.forward(t_bottom, t_top)\n    frcn_bbtargets_reference = np.zeros(frcn_bbtargets.shape, dtype=np.float32)\n    frcn_bbmask_reference = np.zeros(frcn_bbmask.shape, dtype=np.float32)\n    frcn_bbtargets_reference[:t_top[2].shape[0]] = t_top[2].T\n    frcn_bbmask_reference[:t_top[3].shape[0]] = t_top[3].T\n    neon_labels = np.zeros((frcn_labels.shape[1],))\n    label_mat = frcn_labels.get() * frcn_labels_mask.get()\n    for cls in range(frcn_labels.shape[0]):\n        for (idx, elem) in enumerate(label_mat[cls]):\n            if elem != 0:\n                neon_labels[idx] = cls\n    assert np.alltrue(t_top[1] == neon_labels)\n    assert np.allclose(frcn_bbtargets_reference, frcn_bbtargets.get(), atol=0.0001)\n    assert np.alltrue(frcn_bbmask_reference == frcn_bbmask.get())",
            "def test_proposal_layer(backend_default, fargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    np.random.seed(seed=0)\n    be = backend_default\n    be.bsz = 1\n    (_conv_size, im_shape_arr, SCALE, pre_nms_topN, post_nms_topN, nms_thresh, min_size) = fargs\n    im_shape = be.zeros((2, 1), dtype=np.float32)\n    im_shape[:] = np.array(im_shape_arr)\n    im_scale = be.ones((1, 1), dtype=np.float32).fill(1.0 / 16.0)\n    SCALE = be.ones((1, 1), dtype=np.float32).fill(SCALE)\n    real_H = np.round(im_shape.get()[1] * im_scale.get()).astype(int).reshape((1,))[0]\n    real_W = np.round(im_shape.get()[0] * im_scale.get()).astype(int).reshape((1,))[0]\n    frcn_labels = be.zeros((21, 128), dtype=np.int32)\n    frcn_labels_mask = be.zeros(frcn_labels.shape, dtype=np.int32)\n    frcn_bbtargets = be.zeros((21 * 4, 128), dtype=np.float32)\n    frcn_bbmask = be.zeros(frcn_bbtargets.shape, dtype=np.float32)\n    gt_boxes = be.zeros((64, 4), dtype=np.float32)\n    gt_boxes[:3, :] = np.array([[262, 210, 323, 338], [164, 263, 252, 371], [240, 193, 294, 298]])\n    gt_classes = be.zeros((64, 1), dtype=np.int32)\n    gt_classes[:3, :] = np.array([[9], [9], [9]])\n    num_gt_boxes = be.zeros((1, 1), dtype=np.int32).fill(3)\n    num_scores = 2 * 9 * _conv_size * _conv_size\n    rpn_obj_scores_dev = be.array(np.random.choice(num_scores * 2, size=num_scores, replace=False) / float(num_scores * 2.0))\n    rpn_bbox_deltas_dev = be.array(np.random.random((4 * 9 * _conv_size * _conv_size, 1)))\n    RPN_1x1_obj = mock_layer(rpn_obj_scores_dev)\n    RPN_1x1_bbox = mock_layer(rpn_bbox_deltas_dev)\n    mock_loader = mock_dataloader(_conv_size, im_scale, im_shape, SCALE, gt_boxes, gt_classes, num_gt_boxes, frcn_labels, frcn_labels_mask, frcn_bbtargets, frcn_bbmask)\n    prop_layer = ProposalLayer([[RPN_1x1_obj], [RPN_1x1_bbox]], mock_loader, pre_nms_N=pre_nms_topN, post_nms_N=post_nms_topN, nms_thresh=nms_thresh, min_bbox_size=min_size, num_rois=128, deterministic=True, inference=False, debug=True)\n    prop_layer.configure(mock_layer([]))\n    prop_layer.allocate()\n    inputs = []\n    (inputs, dev_proposals) = prop_layer.fprop(inputs, inference=False)\n    target_proposals = prop_layer.proposals\n    target_scores = prop_layer.scores\n    prop_layer_ref = PyCaffeProposalLayer()\n    rpn_obj_scores = rpn_obj_scores_dev.get()\n    rpn_bbox_deltas = rpn_bbox_deltas_dev.get()\n    rpn_bbox_deltas = rpn_bbox_deltas.reshape((4, -1, _conv_size, _conv_size))\n    rpn_bbox_deltas = rpn_bbox_deltas[:, :, :real_H, :real_W].reshape((4, -1)).T\n    rpn_obj_scores = rpn_obj_scores.reshape((2, -1, _conv_size, _conv_size))\n    rpn_obj_scores = rpn_obj_scores[:, :, :real_H, :real_W].transpose((0, 1, 2, 3))\n    rpn_obj_scores = rpn_obj_scores.reshape((1, -1, real_H, real_W))\n    bottom = [None, None, None]\n    bottom[0] = rpn_obj_scores\n    bottom[1] = rpn_bbox_deltas\n    bottom[2] = [im_shape[1], im_shape[0], SCALE]\n    top = [None, None]\n    prop_layer_ref.setup(bottom, top, pre_nms_topN=pre_nms_topN, post_nms_topN=post_nms_topN, nms_thresh=nms_thresh, min_size=min_size)\n    prop_layer_ref.forward(bottom, top)\n    assert np.allclose(top[0][:, 1:], target_proposals, atol=1e-05, rtol=0.0001)\n    assert np.allclose(top[1], target_scores, atol=1e-05, rtol=0.0001)\n    t_bottom = [0, 1]\n    zeros = np.zeros((target_proposals.shape[0], 1), dtype=target_proposals.dtype)\n    t_bottom[0] = np.hstack((zeros, target_proposals))\n    t_bottom[1] = np.hstack((prop_layer.gt_boxes.get(), prop_layer.gt_classes.get()))[:prop_layer.num_gt_boxes.get()[0][0]]\n    t_top = [None, None, None, None, None]\n    prop_target_layer_ref = PyCaffeProposalTargetLayer()\n    prop_target_layer_ref.setup(t_bottom, t_top, deterministic=True)\n    prop_target_layer_ref.forward(t_bottom, t_top)\n    frcn_bbtargets_reference = np.zeros(frcn_bbtargets.shape, dtype=np.float32)\n    frcn_bbmask_reference = np.zeros(frcn_bbmask.shape, dtype=np.float32)\n    frcn_bbtargets_reference[:t_top[2].shape[0]] = t_top[2].T\n    frcn_bbmask_reference[:t_top[3].shape[0]] = t_top[3].T\n    neon_labels = np.zeros((frcn_labels.shape[1],))\n    label_mat = frcn_labels.get() * frcn_labels_mask.get()\n    for cls in range(frcn_labels.shape[0]):\n        for (idx, elem) in enumerate(label_mat[cls]):\n            if elem != 0:\n                neon_labels[idx] = cls\n    assert np.alltrue(t_top[1] == neon_labels)\n    assert np.allclose(frcn_bbtargets_reference, frcn_bbtargets.get(), atol=0.0001)\n    assert np.alltrue(frcn_bbmask_reference == frcn_bbmask.get())",
            "def test_proposal_layer(backend_default, fargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    np.random.seed(seed=0)\n    be = backend_default\n    be.bsz = 1\n    (_conv_size, im_shape_arr, SCALE, pre_nms_topN, post_nms_topN, nms_thresh, min_size) = fargs\n    im_shape = be.zeros((2, 1), dtype=np.float32)\n    im_shape[:] = np.array(im_shape_arr)\n    im_scale = be.ones((1, 1), dtype=np.float32).fill(1.0 / 16.0)\n    SCALE = be.ones((1, 1), dtype=np.float32).fill(SCALE)\n    real_H = np.round(im_shape.get()[1] * im_scale.get()).astype(int).reshape((1,))[0]\n    real_W = np.round(im_shape.get()[0] * im_scale.get()).astype(int).reshape((1,))[0]\n    frcn_labels = be.zeros((21, 128), dtype=np.int32)\n    frcn_labels_mask = be.zeros(frcn_labels.shape, dtype=np.int32)\n    frcn_bbtargets = be.zeros((21 * 4, 128), dtype=np.float32)\n    frcn_bbmask = be.zeros(frcn_bbtargets.shape, dtype=np.float32)\n    gt_boxes = be.zeros((64, 4), dtype=np.float32)\n    gt_boxes[:3, :] = np.array([[262, 210, 323, 338], [164, 263, 252, 371], [240, 193, 294, 298]])\n    gt_classes = be.zeros((64, 1), dtype=np.int32)\n    gt_classes[:3, :] = np.array([[9], [9], [9]])\n    num_gt_boxes = be.zeros((1, 1), dtype=np.int32).fill(3)\n    num_scores = 2 * 9 * _conv_size * _conv_size\n    rpn_obj_scores_dev = be.array(np.random.choice(num_scores * 2, size=num_scores, replace=False) / float(num_scores * 2.0))\n    rpn_bbox_deltas_dev = be.array(np.random.random((4 * 9 * _conv_size * _conv_size, 1)))\n    RPN_1x1_obj = mock_layer(rpn_obj_scores_dev)\n    RPN_1x1_bbox = mock_layer(rpn_bbox_deltas_dev)\n    mock_loader = mock_dataloader(_conv_size, im_scale, im_shape, SCALE, gt_boxes, gt_classes, num_gt_boxes, frcn_labels, frcn_labels_mask, frcn_bbtargets, frcn_bbmask)\n    prop_layer = ProposalLayer([[RPN_1x1_obj], [RPN_1x1_bbox]], mock_loader, pre_nms_N=pre_nms_topN, post_nms_N=post_nms_topN, nms_thresh=nms_thresh, min_bbox_size=min_size, num_rois=128, deterministic=True, inference=False, debug=True)\n    prop_layer.configure(mock_layer([]))\n    prop_layer.allocate()\n    inputs = []\n    (inputs, dev_proposals) = prop_layer.fprop(inputs, inference=False)\n    target_proposals = prop_layer.proposals\n    target_scores = prop_layer.scores\n    prop_layer_ref = PyCaffeProposalLayer()\n    rpn_obj_scores = rpn_obj_scores_dev.get()\n    rpn_bbox_deltas = rpn_bbox_deltas_dev.get()\n    rpn_bbox_deltas = rpn_bbox_deltas.reshape((4, -1, _conv_size, _conv_size))\n    rpn_bbox_deltas = rpn_bbox_deltas[:, :, :real_H, :real_W].reshape((4, -1)).T\n    rpn_obj_scores = rpn_obj_scores.reshape((2, -1, _conv_size, _conv_size))\n    rpn_obj_scores = rpn_obj_scores[:, :, :real_H, :real_W].transpose((0, 1, 2, 3))\n    rpn_obj_scores = rpn_obj_scores.reshape((1, -1, real_H, real_W))\n    bottom = [None, None, None]\n    bottom[0] = rpn_obj_scores\n    bottom[1] = rpn_bbox_deltas\n    bottom[2] = [im_shape[1], im_shape[0], SCALE]\n    top = [None, None]\n    prop_layer_ref.setup(bottom, top, pre_nms_topN=pre_nms_topN, post_nms_topN=post_nms_topN, nms_thresh=nms_thresh, min_size=min_size)\n    prop_layer_ref.forward(bottom, top)\n    assert np.allclose(top[0][:, 1:], target_proposals, atol=1e-05, rtol=0.0001)\n    assert np.allclose(top[1], target_scores, atol=1e-05, rtol=0.0001)\n    t_bottom = [0, 1]\n    zeros = np.zeros((target_proposals.shape[0], 1), dtype=target_proposals.dtype)\n    t_bottom[0] = np.hstack((zeros, target_proposals))\n    t_bottom[1] = np.hstack((prop_layer.gt_boxes.get(), prop_layer.gt_classes.get()))[:prop_layer.num_gt_boxes.get()[0][0]]\n    t_top = [None, None, None, None, None]\n    prop_target_layer_ref = PyCaffeProposalTargetLayer()\n    prop_target_layer_ref.setup(t_bottom, t_top, deterministic=True)\n    prop_target_layer_ref.forward(t_bottom, t_top)\n    frcn_bbtargets_reference = np.zeros(frcn_bbtargets.shape, dtype=np.float32)\n    frcn_bbmask_reference = np.zeros(frcn_bbmask.shape, dtype=np.float32)\n    frcn_bbtargets_reference[:t_top[2].shape[0]] = t_top[2].T\n    frcn_bbmask_reference[:t_top[3].shape[0]] = t_top[3].T\n    neon_labels = np.zeros((frcn_labels.shape[1],))\n    label_mat = frcn_labels.get() * frcn_labels_mask.get()\n    for cls in range(frcn_labels.shape[0]):\n        for (idx, elem) in enumerate(label_mat[cls]):\n            if elem != 0:\n                neon_labels[idx] = cls\n    assert np.alltrue(t_top[1] == neon_labels)\n    assert np.allclose(frcn_bbtargets_reference, frcn_bbtargets.get(), atol=0.0001)\n    assert np.alltrue(frcn_bbmask_reference == frcn_bbmask.get())",
            "def test_proposal_layer(backend_default, fargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    np.random.seed(seed=0)\n    be = backend_default\n    be.bsz = 1\n    (_conv_size, im_shape_arr, SCALE, pre_nms_topN, post_nms_topN, nms_thresh, min_size) = fargs\n    im_shape = be.zeros((2, 1), dtype=np.float32)\n    im_shape[:] = np.array(im_shape_arr)\n    im_scale = be.ones((1, 1), dtype=np.float32).fill(1.0 / 16.0)\n    SCALE = be.ones((1, 1), dtype=np.float32).fill(SCALE)\n    real_H = np.round(im_shape.get()[1] * im_scale.get()).astype(int).reshape((1,))[0]\n    real_W = np.round(im_shape.get()[0] * im_scale.get()).astype(int).reshape((1,))[0]\n    frcn_labels = be.zeros((21, 128), dtype=np.int32)\n    frcn_labels_mask = be.zeros(frcn_labels.shape, dtype=np.int32)\n    frcn_bbtargets = be.zeros((21 * 4, 128), dtype=np.float32)\n    frcn_bbmask = be.zeros(frcn_bbtargets.shape, dtype=np.float32)\n    gt_boxes = be.zeros((64, 4), dtype=np.float32)\n    gt_boxes[:3, :] = np.array([[262, 210, 323, 338], [164, 263, 252, 371], [240, 193, 294, 298]])\n    gt_classes = be.zeros((64, 1), dtype=np.int32)\n    gt_classes[:3, :] = np.array([[9], [9], [9]])\n    num_gt_boxes = be.zeros((1, 1), dtype=np.int32).fill(3)\n    num_scores = 2 * 9 * _conv_size * _conv_size\n    rpn_obj_scores_dev = be.array(np.random.choice(num_scores * 2, size=num_scores, replace=False) / float(num_scores * 2.0))\n    rpn_bbox_deltas_dev = be.array(np.random.random((4 * 9 * _conv_size * _conv_size, 1)))\n    RPN_1x1_obj = mock_layer(rpn_obj_scores_dev)\n    RPN_1x1_bbox = mock_layer(rpn_bbox_deltas_dev)\n    mock_loader = mock_dataloader(_conv_size, im_scale, im_shape, SCALE, gt_boxes, gt_classes, num_gt_boxes, frcn_labels, frcn_labels_mask, frcn_bbtargets, frcn_bbmask)\n    prop_layer = ProposalLayer([[RPN_1x1_obj], [RPN_1x1_bbox]], mock_loader, pre_nms_N=pre_nms_topN, post_nms_N=post_nms_topN, nms_thresh=nms_thresh, min_bbox_size=min_size, num_rois=128, deterministic=True, inference=False, debug=True)\n    prop_layer.configure(mock_layer([]))\n    prop_layer.allocate()\n    inputs = []\n    (inputs, dev_proposals) = prop_layer.fprop(inputs, inference=False)\n    target_proposals = prop_layer.proposals\n    target_scores = prop_layer.scores\n    prop_layer_ref = PyCaffeProposalLayer()\n    rpn_obj_scores = rpn_obj_scores_dev.get()\n    rpn_bbox_deltas = rpn_bbox_deltas_dev.get()\n    rpn_bbox_deltas = rpn_bbox_deltas.reshape((4, -1, _conv_size, _conv_size))\n    rpn_bbox_deltas = rpn_bbox_deltas[:, :, :real_H, :real_W].reshape((4, -1)).T\n    rpn_obj_scores = rpn_obj_scores.reshape((2, -1, _conv_size, _conv_size))\n    rpn_obj_scores = rpn_obj_scores[:, :, :real_H, :real_W].transpose((0, 1, 2, 3))\n    rpn_obj_scores = rpn_obj_scores.reshape((1, -1, real_H, real_W))\n    bottom = [None, None, None]\n    bottom[0] = rpn_obj_scores\n    bottom[1] = rpn_bbox_deltas\n    bottom[2] = [im_shape[1], im_shape[0], SCALE]\n    top = [None, None]\n    prop_layer_ref.setup(bottom, top, pre_nms_topN=pre_nms_topN, post_nms_topN=post_nms_topN, nms_thresh=nms_thresh, min_size=min_size)\n    prop_layer_ref.forward(bottom, top)\n    assert np.allclose(top[0][:, 1:], target_proposals, atol=1e-05, rtol=0.0001)\n    assert np.allclose(top[1], target_scores, atol=1e-05, rtol=0.0001)\n    t_bottom = [0, 1]\n    zeros = np.zeros((target_proposals.shape[0], 1), dtype=target_proposals.dtype)\n    t_bottom[0] = np.hstack((zeros, target_proposals))\n    t_bottom[1] = np.hstack((prop_layer.gt_boxes.get(), prop_layer.gt_classes.get()))[:prop_layer.num_gt_boxes.get()[0][0]]\n    t_top = [None, None, None, None, None]\n    prop_target_layer_ref = PyCaffeProposalTargetLayer()\n    prop_target_layer_ref.setup(t_bottom, t_top, deterministic=True)\n    prop_target_layer_ref.forward(t_bottom, t_top)\n    frcn_bbtargets_reference = np.zeros(frcn_bbtargets.shape, dtype=np.float32)\n    frcn_bbmask_reference = np.zeros(frcn_bbmask.shape, dtype=np.float32)\n    frcn_bbtargets_reference[:t_top[2].shape[0]] = t_top[2].T\n    frcn_bbmask_reference[:t_top[3].shape[0]] = t_top[3].T\n    neon_labels = np.zeros((frcn_labels.shape[1],))\n    label_mat = frcn_labels.get() * frcn_labels_mask.get()\n    for cls in range(frcn_labels.shape[0]):\n        for (idx, elem) in enumerate(label_mat[cls]):\n            if elem != 0:\n                neon_labels[idx] = cls\n    assert np.alltrue(t_top[1] == neon_labels)\n    assert np.allclose(frcn_bbtargets_reference, frcn_bbtargets.get(), atol=0.0001)\n    assert np.alltrue(frcn_bbmask_reference == frcn_bbmask.get())"
        ]
    }
]