from h2o.utils.compatibility import *
from h2o.model import ModelBase
from h2o.utils.metaclass import deprecated_params_order
_old_sig = ['train', 'valid', 'metric']

def _is_called_with_old_sig(*args, **kwargs):
    if False:
        return 10
    return len(args) > 0 and isinstance(args[0], bool)

class H2OBinomialUpliftModel(ModelBase):

    @deprecated_params_order(old_sig=_old_sig, is_called_with_old_sig=_is_called_with_old_sig)
    def auuc(self, metric=None, train=False, valid=False):
        if False:
            while True:
                i = 10
        '\n        Retrieve area under uplift curve (AUUC) value for the specified metrics in model params.\n        \n        If all are ``False`` (default), then return the training metric AUUC value.\n        If more than one option is set to ``True``, then return a dictionary of metrics where the \n        keys are "train" and "valid".\n\n        :param bool train: If ``True``, return the AUUC value for the training data.\n        :param bool valid: If ``True``, return the AUUC value for the validation data.\n        :param metric: AUUC metric type. One of:\n\n            - "qini"\n            - "lift"\n            - "gain"\n            - "None" (default; metric set in parameters)     \n        \n        :returns: AUUC value for the specified key(s).\n\n        :examples:\n        \n        >>> from h2o.estimators import H2OUpliftRandomForestEstimator\n        >>> train = h2o.import_file("https://s3.amazonaws.com/h2o-public-test-data/smalldata/uplift/criteo_uplift_13k.csv")\n        >>> treatment_column = "treatment"\n        >>> response_column = "conversion"\n        >>> train[treatment_column] = train[treatment_column].asfactor()\n        >>> train[response_column] = train[response_column].asfactor()\n        >>> predictors = ["f1", "f2", "f3", "f4", "f5", "f6"]\n        >>>\n        >>> uplift_model = H2OUpliftRandomForestEstimator(ntrees=10, \n        ...                                               max_depth=5,\n        ...                                               treatment_column=treatment_column,\n        ...                                               uplift_metric="kl",\n        ...                                               distribution="bernoulli",\n        ...                                               min_rows=10,\n        ...                                               auuc_type="gain")\n        >>> uplift_model.train(y=response_column, x=predictors, training_frame=train)\n        >>> uplift_model.auuc() # <- Default: return training metric value\n        >>> uplift_model.auuc(train=True,  valid=True)\n        '
        assert metric in [None, 'qini', 'lift', 'gain'], 'AUUC metric ' + metric + " should be None, 'qini','lift' or 'gain'."
        return self._delegate_to_metrics(metric=metric, method='auuc', train=train, valid=valid)

    @deprecated_params_order(old_sig=_old_sig, is_called_with_old_sig=_is_called_with_old_sig)
    def auuc_normalized(self, metric=None, train=False, valid=False):
        if False:
            return 10
        '\n        Retrieve normalized area under uplift curve (AUUC) value for the specified metrics in model params.\n\n        If all are ``False`` (default), then return the training metric normalized AUUC value.\n        If more than one options is set to ``True``, then return a dictionary of metrics where the \n        keys are "train" and "valid".\n\n        :param metric: AUUC metric type ("qini", "lift", "gain", default is None which means metric set in parameters)\n        :param bool train: If True, return the AUUC value for the training data.\n        :param bool valid: If True, return the AUUC value for the validation data.\n        :param metric: AUUC metric type. One of:\n\n            - "qini"\n            - "lift"\n            - "gain"\n            - "None" (default; metric set in parameters)\n\n        :returns: Normalized AUUC value for the specified key(s).\n\n        :examples:\n\n        >>> from h2o.estimators import H2OUpliftRandomForestEstimator\n        >>> train = h2o.import_file("https://s3.amazonaws.com/h2o-public-test-data/smalldata/uplift/criteo_uplift_13k.csv")\n        >>> treatment_column = "treatment"\n        >>> response_column = "conversion"\n        >>> train[treatment_column] = train[treatment_column].asfactor()\n        >>> train[response_column] = train[response_column].asfactor()\n        >>> predictors = ["f1", "f2", "f3", "f4", "f5", "f6"]\n        >>>\n        >>> uplift_model = H2OUpliftRandomForestEstimator(ntrees=10,\n        ...                                               max_depth=5,\n        ...                                               treatment_column=treatment_column,\n        ...                                               uplift_metric="kl",\n        ...                                               distribution="bernoulli",\n        ...                                               min_rows=10,\n        ...                                               auuc_type="gain")\n        >>> uplift_model.train(y=response_column, x=predictors, training_frame=train)\n        >>> uplift_model.auuc_normalized() # <- Default: return training metric value\n        >>> uplift_model.auuc_normalized(train=True,  valid=True)\n        '
        assert metric in [None, 'qini', 'lift', 'gain'], 'AUUC metric ' + metric + " should be None, 'qini','lift' or 'gain'."
        return self._delegate_to_metrics(metric=metric, method='auuc_normalized', train=train, valid=valid)

    @deprecated_params_order(old_sig=_old_sig, is_called_with_old_sig=_is_called_with_old_sig)
    def uplift(self, metric='qini', train=False, valid=False):
        if False:
            print('Hello World!')
        '\n        Retrieve uplift values for the specified metrics. \n        \n        If all are ``False`` (default), then return the training metric uplift values.\n        If more than one option is set to ``True``, then return a dictionary of metrics where the \n        keys are "train" and "valid".\n        \n        :param bool train: If ``True``, return the uplift values for the training data.\n        :param bool valid: If ``True``, return the uplift values for the validation data.\n        :param metric: Uplift metric type. One of:\n\n            - "qini" (default)\n            - "lift"\n            - "gain"\n            \n        :param metric: Uplift metric type ("qini", "lift", "gain", default is "qini")\n        :param bool train: If True, return the uplift values for the training data.\n        :param bool valid: If True, return the uplift values for the validation data.\n        \n        :returns: a list of uplift values for the specified key(s).\n\n        :examples:\n        \n        >>> from h2o.estimators import H2OUpliftRandomForestEstimator\n        >>> train = h2o.import_file("https://s3.amazonaws.com/h2o-public-test-data/smalldata/uplift/criteo_uplift_13k.csv")\n        >>> treatment_column = "treatment"\n        >>> response_column = "conversion"\n        >>> train[treatment_column] = train[treatment_column].asfactor()\n        >>> train[response_column] = train[response_column].asfactor()\n        >>> predictors = ["f1", "f2", "f3", "f4", "f5", "f6"]\n        >>>\n        >>> uplift_model = H2OUpliftRandomForestEstimator(ntrees=10, \n        ...                                               max_depth=5,\n        ...                                               treatment_column=treatment_column,\n        ...                                               uplift_metric="kl",\n        ...                                               distribution="bernoulli",\n        ...                                               min_rows=10,\n        ...                                               auuc_type="gain")\n        >>> uplift_model.train(y=response_column, x=predictors, training_frame=train)\n        >>> uplift_model.uplift() # <- Default: return training metric value\n        >>> uplift_model.uplift(train=True, metric="gain")\n        '
        assert metric in ['qini', 'lift', 'gain'], 'Uplift metric ' + metric + " should be 'qini','lift' or 'gain'."
        return self._delegate_to_metrics(metric=metric, method='uplift', train=train, valid=valid)

    @deprecated_params_order(old_sig=_old_sig, is_called_with_old_sig=_is_called_with_old_sig)
    def uplift_normalized(self, metric='qini', train=False, valid=False):
        if False:
            for i in range(10):
                print('nop')
        '\n        Retrieve normalized uplift values for the specified metrics. \n        \n        If all are ``False`` (default), then return the training metric normalized uplift values.\n        If more than one option is set to ``True``, then return a dictionary of metrics where the \n        keys are "train" and "valid".\n        \n        :param bool train: If ``True``, return the uplift values for the training data.\n        :param bool valid: If ``True``, return the uplift values for the validation data.\n        :param metric: Uplift metric type. One of:\n\n            - "qini" (default)\n            - "lift"\n            - "gain"\n        \n        :returns: a list of normalized uplift values for the specified key(s).\n\n        :examples:\n        \n        >>> from h2o.estimators import H2OUpliftRandomForestEstimator\n        >>> train = h2o.import_file("https://s3.amazonaws.com/h2o-public-test-data/smalldata/uplift/criteo_uplift_13k.csv")\n        >>> treatment_column = "treatment"\n        >>> response_column = "conversion"\n        >>> train[treatment_column] = train[treatment_column].asfactor()\n        >>> train[response_column] = train[response_column].asfactor()\n        >>> predictors = ["f1", "f2", "f3", "f4", "f5", "f6"]\n        >>>\n        >>> uplift_model = H2OUpliftRandomForestEstimator(ntrees=10, \n        ...                                               max_depth=5,\n        ...                                               treatment_column=treatment_column,\n        ...                                               uplift_metric="kl",\n        ...                                               distribution="bernoulli",\n        ...                                               min_rows=10,\n        ...                                               auuc_type="gain")\n        >>> uplift_model.train(y=response_column, x=predictors, training_frame=train)\n        >>> uplift_model.uplift_normalized() # <- Default: return training metric value\n        >>> uplift_model.uplift_normalized(train=True, metric="gain")\n        '
        assert metric in ['qini', 'lift', 'gain'], 'Uplift metric ' + metric + " should be 'qini','lift' or 'gain'."
        return self._delegate_to_metrics(metric=metric, method='uplift_normalized', train=train, valid=valid)

    def n(self, train=False, valid=False):
        if False:
            print('Hello World!')
        '\n        Retrieve numbers of observations.\n        \n        If all are ``False`` (default), then return the training metric number of observations.\n        If more than one option is set to ``True``, then return a dictionary of metrics where the \n        keys are "train" and "valid".\n        \n        :param bool train: If ``True``, return the number of observations for the training data.\n        :param bool valid: If ``True``, return the number of observations for the validation data.\n        \n        :returns: a list of numbers of observation for the specified key(s).\n\n        :examples:\n        \n        >>> from h2o.estimators import H2OUpliftRandomForestEstimator\n        >>> train = h2o.import_file("https://s3.amazonaws.com/h2o-public-test-data/smalldata/uplift/criteo_uplift_13k.csv")\n        >>> treatment_column = "treatment"\n        >>> response_column = "conversion"\n        >>> train[treatment_column] = train[treatment_column].asfactor()\n        >>> train[response_column] = train[response_column].asfactor()\n        >>> predictors = ["f1", "f2", "f3", "f4", "f5", "f6"]\n        >>>\n        >>> uplift_model = H2OUpliftRandomForestEstimator(ntrees=10, \n        ...                                               max_depth=5,\n        ...                                               treatment_column=treatment_column,\n        ...                                               uplift_metric="kl",\n        ...                                               distribution="bernoulli",\n        ...                                               min_rows=10,\n        ...                                               auuc_type="gain")\n        >>> uplift_model.train(y=response_column, x=predictors, training_frame=train)\n        >>> uplift_model.n()  # <- Default: return training metric value\n        >>> uplift_model.n(train=True)\n        '
        return self._delegate_to_metrics(method='n', train=train, valid=valid)

    def thresholds(self, train=False, valid=False):
        if False:
            return 10
        '\n        Retrieve prediction thresholds for the specified metrics. \n        \n        If all are ``False`` (default), then return the training metric prediction thresholds.\n        If more than one option is set to ``True``, then return a dictionary of metrics where the \n        keys are "train" and "valid".\n        \n        :param bool train: If ``True``, return the prediction thresholds for the training data.\n        :param bool valid: If ``True``, return the prediction thresholds for the validation data.\n        \n        :returns: a list of numbers of observation for the specified key(s).\n        \n        :examples:\n        \n        >>> from h2o.estimators import H2OUpliftRandomForestEstimator\n        >>> train = h2o.import_file("https://s3.amazonaws.com/h2o-public-test-data/smalldata/uplift/criteo_uplift_13k.csv")\n        >>> treatment_column = "treatment"\n        >>> response_column = "conversion"\n        >>> train[treatment_column] = train[treatment_column].asfactor()\n        >>> train[response_column] = train[response_column].asfactor()\n        >>> predictors = ["f1", "f2", "f3", "f4", "f5", "f6"]\n        >>>\n        >>> uplift_model = H2OUpliftRandomForestEstimator(ntrees=10, \n        ...                                               max_depth=5,\n        ...                                               treatment_column=treatment_column,\n        ...                                               uplift_metric="kl",\n        ...                                               distribution="bernoulli",\n        ...                                               min_rows=10,\n        ...                                               auuc_type="gain")\n        >>> uplift_model.train(y=response_column, x=predictors, training_frame=train)\n        >>> uplift_model.thresholds()  # <- Default: return training metric value\n        >>> uplift_model.thresholds(train=True)\n        '
        return self._delegate_to_metrics(method='thresholds', train=train, valid=valid)

    def thresholds_and_metric_scores(self, train=False, valid=False):
        if False:
            return 10
        '\n        Retrieve thresholds and metric scores table for the specified metrics. \n        \n        If all are ``False`` (default), then return the training metric thresholds and metric scores table.\n        If more than one option is set to ``True``, then return a dictionary of metrics where the \n        keys are "train" and "valid".\n        \n        :param bool train: If ``True``, return the thresholds and metric scores table for the training data.\n        :param bool valid: If ``True``, return the thresholds and metric scores table for the validation data.\n        \n        :returns: the thresholds and metric scores table for the specified key(s).\n        \n        :examples:\n        \n        >>> from h2o.estimators import H2OUpliftRandomForestEstimator\n        >>> train = h2o.import_file("https://s3.amazonaws.com/h2o-public-test-data/smalldata/uplift/criteo_uplift_13k.csv")\n        >>> treatment_column = "treatment"\n        >>> response_column = "conversion"\n        >>> train[treatment_column] = train[treatment_column].asfactor()\n        >>> train[response_column] = train[response_column].asfactor()\n        >>> predictors = ["f1", "f2", "f3", "f4", "f5", "f6"]\n        >>>\n        >>> uplift_model = H2OUpliftRandomForestEstimator(ntrees=10, \n        ...                                               max_depth=5,\n        ...                                               treatment_column=treatment_column,\n        ...                                               uplift_metric="kl",\n        ...                                               distribution="bernoulli",\n        ...                                               min_rows=10,\n        ...                                               auuc_type="gain")\n        >>> uplift_model.train(y=response_column, x=predictors, training_frame=train)\n        >>> uplift_model.thresholds_and_metric_scores()  # <- Default: return training metric value\n        >>> uplift_model.thresholds_and_metric_scores(train=True)\n        '
        return self._delegate_to_metrics(method='thresholds_and_metric_scores', train=train, valid=valid)

    def auuc_table(self, train=False, valid=False):
        if False:
            i = 10
            return i + 15
        '\n        Retrieve all types of AUUC in a table.\n        \n        If all are ``False`` (default), then return the training metric AUUC table.\n        If more than one option is set to ``True``, then return a dictionary of metrics where the \n        keys are "train" and "valid".\n        \n        :param bool train: If ``True``, return the AUUC table for the training data.\n        :param bool valid: If ``True``, return the AUUC table for the validation data.\n         \n        :returns: the AUUC table for the specified key(s).\n    \n        :examples:\n         \n        >>> from h2o.estimators import H2OUpliftRandomForestEstimator\n        >>> train = h2o.import_file("https://s3.amazonaws.com/h2o-public-test-data/smalldata/uplift/criteo_uplift_13k.csv")\n        >>> treatment_column = "treatment"\n        >>> response_column = "conversion"\n        >>> train[treatment_column] = train[treatment_column].asfactor()\n        >>> train[response_column] = train[response_column].asfactor()\n        >>> predictors = ["f1", "f2", "f3", "f4", "f5", "f6"]\n        >>>\n        >>> uplift_model = H2OUpliftRandomForestEstimator(ntrees=10, \n        ...                                               max_depth=5,\n        ...                                               treatment_column=treatment_column,\n        ...                                               uplift_metric="kl",\n        ...                                               distribution="bernoulli",\n        ...                                               min_rows=10,\n        ...                                               auuc_type="gain")\n        >>> uplift_model.train(y=response_column, x=predictors, training_frame=train)\n        >>> uplift_model.auuc_table() # <- Default: return training metric value\n        >>> uplift_model.auuc_table(train=True)\n        '
        return self._delegate_to_metrics(method='auuc_table', train=train, valid=valid)

    def qini(self, train=False, valid=False):
        if False:
            print('Hello World!')
        '\n        Retrieve Qini value (area between Qini cumulative uplift curve and random curve)\n\n        If all are False (default), then return the training metric AUUC table.\n        If more than one options is set to True, then return a dictionary of metrics where the \n        keys are "train" and "valid".\n\n        :param bool train: If True, return the Qini value for the training data.\n        :param bool valid: If True, return the Qini value for the validation data.\n\n        :returns: the Qini value for the specified key(s).\n\n        :examples:\n\n        >>> from h2o.estimators import H2OUpliftRandomForestEstimator\n        >>> train = h2o.import_file("https://s3.amazonaws.com/h2o-public-test-data/smalldata/uplift/criteo_uplift_13k.csv")\n        >>> treatment_column = "treatment"\n        >>> response_column = "conversion"\n        >>> train[treatment_column] = train[treatment_column].asfactor()\n        >>> train[response_column] = train[response_column].asfactor()\n        >>> predictors = ["f1", "f2", "f3", "f4", "f5", "f6"]\n        >>>\n        >>> uplift_model = H2OUpliftRandomForestEstimator(ntrees=10,\n        ...                                               max_depth=5,\n        ...                                               treatment_column=treatment_column,\n        ...                                               uplift_metric="kl",\n        ...                                               distribution="bernoulli",\n        ...                                               min_rows=10,\n        ...                                               auuc_type="gain")\n        >>> uplift_model.train(y=response_column, x=predictors, training_frame=train)\n        >>> uplift_model.qini() # <- Default: return training metric value\n        >>> uplift_model.qini(train=True)\n        '
        return self._delegate_to_metrics(method='qini', train=train, valid=valid)

    def default_auuc_thresholds(self):
        if False:
            while True:
                i = 10
        return self._model_json['output']['default_auuc_thresholds']

    def ate(self, train=False, valid=False):
        if False:
            return 10
        '\n        Retrieve Average Treatment Effect\n\n        If all are False (default), then return the training ATE metric.\n        If more than one options is set to True, then return a dictionary of metrics where the \n        keys are "train" and "valid".\n\n        :param bool train: If True, return the ATE value for the training data.\n        :param bool valid: If True, return the ATE value for the validation data.\n\n        :returns: the ATE value for the specified key(s).\n\n        :examples:\n\n        >>> from h2o.estimators import H2OUpliftRandomForestEstimator\n        >>> train = h2o.import_file("https://s3.amazonaws.com/h2o-public-test-data/smalldata/uplift/criteo_uplift_13k.csv")\n        >>> treatment_column = "treatment"\n        >>> response_column = "conversion"\n        >>> train[treatment_column] = train[treatment_column].asfactor()\n        >>> train[response_column] = train[response_column].asfactor()\n        >>> predictors = ["f1", "f2", "f3", "f4", "f5", "f6"]\n        >>>\n        >>> uplift_model = H2OUpliftRandomForestEstimator(ntrees=10,\n        ...                                               max_depth=5,\n        ...                                               treatment_column=treatment_column,\n        ...                                               uplift_metric="kl",\n        ...                                               distribution="bernoulli",\n        ...                                               min_rows=10,\n        ...                                               auuc_type="gain")\n        >>> uplift_model.train(y=response_column, x=predictors, training_frame=train)\n        >>> uplift_model.ate() # <- Default: return training metric value\n        >>> uplift_model.ate(train=True)\n        '
        return self._delegate_to_metrics(method='ate', train=train, valid=valid)

    def att(self, train=False, valid=False):
        if False:
            print('Hello World!')
        '\n        Retrieve Average Treatment Effect on the Treated\n\n        If all are False (default), then return the training ATT metric.\n        If more than one options is set to True, then return a dictionary of metrics where the \n        keys are "train" and "valid".\n\n        :param bool train: If True, return the ATT value for the training data.\n        :param bool valid: If True, return the ATT value for the validation data.\n\n        :returns: the ATT value for the specified key(s).\n\n        :examples:\n\n        >>> from h2o.estimators import H2OUpliftRandomForestEstimator\n        >>> train = h2o.import_file("https://s3.amazonaws.com/h2o-public-test-data/smalldata/uplift/criteo_uplift_13k.csv")\n        >>> treatment_column = "treatment"\n        >>> response_column = "conversion"\n        >>> train[treatment_column] = train[treatment_column].asfactor()\n        >>> train[response_column] = train[response_column].asfactor()\n        >>> predictors = ["f1", "f2", "f3", "f4", "f5", "f6"]\n        >>>\n        >>> uplift_model = H2OUpliftRandomForestEstimator(ntrees=10,\n        ...                                               max_depth=5,\n        ...                                               treatment_column=treatment_column,\n        ...                                               uplift_metric="kl",\n        ...                                               distribution="bernoulli",\n        ...                                               min_rows=10,\n        ...                                               auuc_type="gain")\n        >>> uplift_model.train(y=response_column, x=predictors, training_frame=train)\n        >>> uplift_model.att() # <- Default: return training metric value\n        >>> uplift_model.att(train=True)\n        '
        return self._delegate_to_metrics(method='att', train=train, valid=valid)

    def atc(self, train=False, valid=False):
        if False:
            while True:
                i = 10
        '\n        Retrieve Average Treatment Effect on the Control\n\n        If all are False (default), then return the training ATC metric.\n        If more than one options is set to True, then return a dictionary of metrics where the \n        keys are "train" and "valid".\n\n        :param bool train: If True, return the ATC value for the training data.\n        :param bool valid: If True, return the ATC value for the validation data.\n\n        :returns: the ATC value for the specified key(s).\n\n        :examples:\n\n        >>> from h2o.estimators import H2OUpliftRandomForestEstimator\n        >>> train = h2o.import_file("https://s3.amazonaws.com/h2o-public-test-data/smalldata/uplift/criteo_uplift_13k.csv")\n        >>> treatment_column = "treatment"\n        >>> response_column = "conversion"\n        >>> train[treatment_column] = train[treatment_column].asfactor()\n        >>> train[response_column] = train[response_column].asfactor()\n        >>> predictors = ["f1", "f2", "f3", "f4", "f5", "f6"]\n        >>>\n        >>> uplift_model = H2OUpliftRandomForestEstimator(ntrees=10,\n        ...                                               max_depth=5,\n        ...                                               treatment_column=treatment_column,\n        ...                                               uplift_metric="kl",\n        ...                                               distribution="bernoulli",\n        ...                                               min_rows=10,\n        ...                                               auuc_type="gain")\n        >>> uplift_model.train(y=response_column, x=predictors, training_frame=train)\n        >>> uplift_model.atc() # <- Default: return training metric value\n        >>> uplift_model.atc(train=True)\n        '
        return self._delegate_to_metrics(method='atc', train=train, valid=valid)

    def _delegate_to_metrics(self, method, train=False, valid=False, **kwargs):
        if False:
            print('Hello World!')
        tm = ModelBase._get_metrics(self, train, valid, xval=None)
        m = {}
        for (k, v) in tm.items():
            if v is None:
                m[k] = None
            elif hasattr(v, method) and callable(getattr(v, method)):
                m[k] = getattr(v, method)(**kwargs)
            else:
                raise ValueError('no method {} in {}'.format(method, type(v)))
        return list(m.values())[0] if len(m) == 1 else m