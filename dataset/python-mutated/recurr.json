[
    {
        "func_name": "_zero_vector",
        "original": "def _zero_vector(k):\n    return [S.Zero] * k",
        "mutated": [
            "def _zero_vector(k):\n    if False:\n        i = 10\n    return [S.Zero] * k",
            "def _zero_vector(k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return [S.Zero] * k",
            "def _zero_vector(k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return [S.Zero] * k",
            "def _zero_vector(k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return [S.Zero] * k",
            "def _zero_vector(k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return [S.Zero] * k"
        ]
    },
    {
        "func_name": "_one_vector",
        "original": "def _one_vector(k):\n    return [S.One] * k",
        "mutated": [
            "def _one_vector(k):\n    if False:\n        i = 10\n    return [S.One] * k",
            "def _one_vector(k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return [S.One] * k",
            "def _one_vector(k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return [S.One] * k",
            "def _one_vector(k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return [S.One] * k",
            "def _one_vector(k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return [S.One] * k"
        ]
    },
    {
        "func_name": "_delta",
        "original": "def _delta(p, k):\n    B = S.One\n    D = p.subs(n, a + k)\n    for i in range(1, k + 1):\n        B *= Rational(i - k - 1, i)\n        D += B * p.subs(n, a + k - i)\n    return D",
        "mutated": [
            "def _delta(p, k):\n    if False:\n        i = 10\n    B = S.One\n    D = p.subs(n, a + k)\n    for i in range(1, k + 1):\n        B *= Rational(i - k - 1, i)\n        D += B * p.subs(n, a + k - i)\n    return D",
            "def _delta(p, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    B = S.One\n    D = p.subs(n, a + k)\n    for i in range(1, k + 1):\n        B *= Rational(i - k - 1, i)\n        D += B * p.subs(n, a + k - i)\n    return D",
            "def _delta(p, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    B = S.One\n    D = p.subs(n, a + k)\n    for i in range(1, k + 1):\n        B *= Rational(i - k - 1, i)\n        D += B * p.subs(n, a + k - i)\n    return D",
            "def _delta(p, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    B = S.One\n    D = p.subs(n, a + k)\n    for i in range(1, k + 1):\n        B *= Rational(i - k - 1, i)\n        D += B * p.subs(n, a + k - i)\n    return D",
            "def _delta(p, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    B = S.One\n    D = p.subs(n, a + k)\n    for i in range(1, k + 1):\n        B *= Rational(i - k - 1, i)\n        D += B * p.subs(n, a + k - i)\n    return D"
        ]
    },
    {
        "func_name": "rsolve_poly",
        "original": "def rsolve_poly(coeffs, f, n, shift=0, **hints):\n    \"\"\"\n    Given linear recurrence operator `\\\\operatorname{L}` of order\n    `k` with polynomial coefficients and inhomogeneous equation\n    `\\\\operatorname{L} y = f`, where `f` is a polynomial, we seek for\n    all polynomial solutions over field `K` of characteristic zero.\n\n    The algorithm performs two basic steps:\n\n        (1) Compute degree `N` of the general polynomial solution.\n        (2) Find all polynomials of degree `N` or less\n            of `\\\\operatorname{L} y = f`.\n\n    There are two methods for computing the polynomial solutions.\n    If the degree bound is relatively small, i.e. it's smaller than\n    or equal to the order of the recurrence, then naive method of\n    undetermined coefficients is being used. This gives a system\n    of algebraic equations with `N+1` unknowns.\n\n    In the other case, the algorithm performs transformation of the\n    initial equation to an equivalent one for which the system of\n    algebraic equations has only `r` indeterminates. This method is\n    quite sophisticated (in comparison with the naive one) and was\n    invented together by Abramov, Bronstein and Petkovsek.\n\n    It is possible to generalize the algorithm implemented here to\n    the case of linear q-difference and differential equations.\n\n    Lets say that we would like to compute `m`-th Bernoulli polynomial\n    up to a constant. For this we can use `b(n+1) - b(n) = m n^{m-1}`\n    recurrence, which has solution `b(n) = B_m + C`. For example:\n\n    >>> from sympy import Symbol, rsolve_poly\n    >>> n = Symbol('n', integer=True)\n\n    >>> rsolve_poly([-1, 1], 4*n**3, n)\n    C0 + n**4 - 2*n**3 + n**2\n\n    References\n    ==========\n\n    .. [1] S. A. Abramov, M. Bronstein and M. Petkovsek, On polynomial\n           solutions of linear operator equations, in: T. Levelt, ed.,\n           Proc. ISSAC '95, ACM Press, New York, 1995, 290-296.\n\n    .. [2] M. Petkovsek, Hypergeometric solutions of linear recurrences\n           with polynomial coefficients, J. Symbolic Computation,\n           14 (1992), 243-264.\n\n    .. [3] M. Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.\n\n    \"\"\"\n    f = sympify(f)\n    if not f.is_polynomial(n):\n        return None\n    homogeneous = f.is_zero\n    r = len(coeffs) - 1\n    coeffs = [Poly(coeff, n) for coeff in coeffs]\n    polys = [Poly(0, n)] * (r + 1)\n    terms = [(S.Zero, S.NegativeInfinity)] * (r + 1)\n    for i in range(r + 1):\n        for j in range(i, r + 1):\n            polys[i] += coeffs[j] * binomial(j, i).as_poly(n)\n        if not polys[i].is_zero:\n            ((exp,), coeff) = polys[i].LT()\n            terms[i] = (coeff, exp)\n    d = b = terms[0][1]\n    for i in range(1, r + 1):\n        if terms[i][1] > d:\n            d = terms[i][1]\n        if terms[i][1] - i > b:\n            b = terms[i][1] - i\n    (d, b) = (int(d), int(b))\n    x = Dummy('x')\n    degree_poly = S.Zero\n    for i in range(r + 1):\n        if terms[i][1] - i == b:\n            degree_poly += terms[i][0] * FallingFactorial(x, i)\n    nni_roots = list(roots(degree_poly, x, filter='Z', predicate=lambda r: r >= 0).keys())\n    if nni_roots:\n        N = [max(nni_roots)]\n    else:\n        N = []\n    if homogeneous:\n        N += [-b - 1]\n    else:\n        N += [f.as_poly(n).degree() - b, -b - 1]\n    N = int(max(N))\n    if N < 0:\n        if homogeneous:\n            if hints.get('symbols', False):\n                return (S.Zero, [])\n            else:\n                return S.Zero\n        else:\n            return None\n    if N <= r:\n        C = []\n        y = E = S.Zero\n        for i in range(N + 1):\n            C.append(Symbol('C' + str(i + shift)))\n            y += C[i] * n ** i\n        for i in range(r + 1):\n            E += coeffs[i].as_expr() * y.subs(n, n + i)\n        solutions = solve_undetermined_coeffs(E - f, C, n)\n        if solutions is not None:\n            _C = C\n            C = [c for c in C if c not in solutions]\n            result = y.subs(solutions)\n        else:\n            return None\n    else:\n        A = r\n        U = N + A + b + 1\n        nni_roots = list(roots(polys[r], filter='Z', predicate=lambda r: r >= 0).keys())\n        if nni_roots != []:\n            a = max(nni_roots) + 1\n        else:\n            a = S.Zero\n\n        def _zero_vector(k):\n            return [S.Zero] * k\n\n        def _one_vector(k):\n            return [S.One] * k\n\n        def _delta(p, k):\n            B = S.One\n            D = p.subs(n, a + k)\n            for i in range(1, k + 1):\n                B *= Rational(i - k - 1, i)\n                D += B * p.subs(n, a + k - i)\n            return D\n        alpha = {}\n        for i in range(-A, d + 1):\n            I = _one_vector(d + 1)\n            for k in range(1, d + 1):\n                I[k] = I[k - 1] * (x + i - k + 1) / k\n            alpha[i] = S.Zero\n            for j in range(A + 1):\n                for k in range(d + 1):\n                    B = binomial(k, i + j)\n                    D = _delta(polys[j].as_expr(), k)\n                    alpha[i] += I[k] * B * D\n        V = Matrix(U, A, lambda i, j: int(i == j))\n        if homogeneous:\n            for i in range(A, U):\n                v = _zero_vector(A)\n                for k in range(1, A + b + 1):\n                    if i - k < 0:\n                        break\n                    B = alpha[k - A].subs(x, i - k)\n                    for j in range(A):\n                        v[j] += B * V[i - k, j]\n                denom = alpha[-A].subs(x, i)\n                for j in range(A):\n                    V[i, j] = -v[j] / denom\n        else:\n            G = _zero_vector(U)\n            for i in range(A, U):\n                v = _zero_vector(A)\n                g = S.Zero\n                for k in range(1, A + b + 1):\n                    if i - k < 0:\n                        break\n                    B = alpha[k - A].subs(x, i - k)\n                    for j in range(A):\n                        v[j] += B * V[i - k, j]\n                    g += B * G[i - k]\n                denom = alpha[-A].subs(x, i)\n                for j in range(A):\n                    V[i, j] = -v[j] / denom\n                G[i] = (_delta(f, i - A) - g) / denom\n        (P, Q) = (_one_vector(U), _zero_vector(A))\n        for i in range(1, U):\n            P[i] = (P[i - 1] * (n - a - i + 1) / i).expand()\n        for i in range(A):\n            Q[i] = Add(*[(v * p).expand() for (v, p) in zip(V[:, i], P)])\n        if not homogeneous:\n            h = Add(*[(g * p).expand() for (g, p) in zip(G, P)])\n        C = [Symbol('C' + str(i + shift)) for i in range(A)]\n        g = lambda i: Add(*[c * _delta(q, i) for (c, q) in zip(C, Q)])\n        if homogeneous:\n            E = [g(i) for i in range(N + 1, U)]\n        else:\n            E = [g(i) + _delta(h, i) for i in range(N + 1, U)]\n        if E != []:\n            solutions = solve(E, *C)\n            if not solutions:\n                if homogeneous:\n                    if hints.get('symbols', False):\n                        return (S.Zero, [])\n                    else:\n                        return S.Zero\n                else:\n                    return None\n        else:\n            solutions = {}\n        if homogeneous:\n            result = S.Zero\n        else:\n            result = h\n        _C = C[:]\n        for (c, q) in list(zip(C, Q)):\n            if c in solutions:\n                s = solutions[c] * q\n                C.remove(c)\n            else:\n                s = c * q\n            result += s.expand()\n    if C != _C:\n        result = result.xreplace(dict(zip(C, _C)))\n        C = _C[:len(C)]\n    if hints.get('symbols', False):\n        return (result, C)\n    else:\n        return result",
        "mutated": [
            "def rsolve_poly(coeffs, f, n, shift=0, **hints):\n    if False:\n        i = 10\n    \"\\n    Given linear recurrence operator `\\\\operatorname{L}` of order\\n    `k` with polynomial coefficients and inhomogeneous equation\\n    `\\\\operatorname{L} y = f`, where `f` is a polynomial, we seek for\\n    all polynomial solutions over field `K` of characteristic zero.\\n\\n    The algorithm performs two basic steps:\\n\\n        (1) Compute degree `N` of the general polynomial solution.\\n        (2) Find all polynomials of degree `N` or less\\n            of `\\\\operatorname{L} y = f`.\\n\\n    There are two methods for computing the polynomial solutions.\\n    If the degree bound is relatively small, i.e. it's smaller than\\n    or equal to the order of the recurrence, then naive method of\\n    undetermined coefficients is being used. This gives a system\\n    of algebraic equations with `N+1` unknowns.\\n\\n    In the other case, the algorithm performs transformation of the\\n    initial equation to an equivalent one for which the system of\\n    algebraic equations has only `r` indeterminates. This method is\\n    quite sophisticated (in comparison with the naive one) and was\\n    invented together by Abramov, Bronstein and Petkovsek.\\n\\n    It is possible to generalize the algorithm implemented here to\\n    the case of linear q-difference and differential equations.\\n\\n    Lets say that we would like to compute `m`-th Bernoulli polynomial\\n    up to a constant. For this we can use `b(n+1) - b(n) = m n^{m-1}`\\n    recurrence, which has solution `b(n) = B_m + C`. For example:\\n\\n    >>> from sympy import Symbol, rsolve_poly\\n    >>> n = Symbol('n', integer=True)\\n\\n    >>> rsolve_poly([-1, 1], 4*n**3, n)\\n    C0 + n**4 - 2*n**3 + n**2\\n\\n    References\\n    ==========\\n\\n    .. [1] S. A. Abramov, M. Bronstein and M. Petkovsek, On polynomial\\n           solutions of linear operator equations, in: T. Levelt, ed.,\\n           Proc. ISSAC '95, ACM Press, New York, 1995, 290-296.\\n\\n    .. [2] M. Petkovsek, Hypergeometric solutions of linear recurrences\\n           with polynomial coefficients, J. Symbolic Computation,\\n           14 (1992), 243-264.\\n\\n    .. [3] M. Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.\\n\\n    \"\n    f = sympify(f)\n    if not f.is_polynomial(n):\n        return None\n    homogeneous = f.is_zero\n    r = len(coeffs) - 1\n    coeffs = [Poly(coeff, n) for coeff in coeffs]\n    polys = [Poly(0, n)] * (r + 1)\n    terms = [(S.Zero, S.NegativeInfinity)] * (r + 1)\n    for i in range(r + 1):\n        for j in range(i, r + 1):\n            polys[i] += coeffs[j] * binomial(j, i).as_poly(n)\n        if not polys[i].is_zero:\n            ((exp,), coeff) = polys[i].LT()\n            terms[i] = (coeff, exp)\n    d = b = terms[0][1]\n    for i in range(1, r + 1):\n        if terms[i][1] > d:\n            d = terms[i][1]\n        if terms[i][1] - i > b:\n            b = terms[i][1] - i\n    (d, b) = (int(d), int(b))\n    x = Dummy('x')\n    degree_poly = S.Zero\n    for i in range(r + 1):\n        if terms[i][1] - i == b:\n            degree_poly += terms[i][0] * FallingFactorial(x, i)\n    nni_roots = list(roots(degree_poly, x, filter='Z', predicate=lambda r: r >= 0).keys())\n    if nni_roots:\n        N = [max(nni_roots)]\n    else:\n        N = []\n    if homogeneous:\n        N += [-b - 1]\n    else:\n        N += [f.as_poly(n).degree() - b, -b - 1]\n    N = int(max(N))\n    if N < 0:\n        if homogeneous:\n            if hints.get('symbols', False):\n                return (S.Zero, [])\n            else:\n                return S.Zero\n        else:\n            return None\n    if N <= r:\n        C = []\n        y = E = S.Zero\n        for i in range(N + 1):\n            C.append(Symbol('C' + str(i + shift)))\n            y += C[i] * n ** i\n        for i in range(r + 1):\n            E += coeffs[i].as_expr() * y.subs(n, n + i)\n        solutions = solve_undetermined_coeffs(E - f, C, n)\n        if solutions is not None:\n            _C = C\n            C = [c for c in C if c not in solutions]\n            result = y.subs(solutions)\n        else:\n            return None\n    else:\n        A = r\n        U = N + A + b + 1\n        nni_roots = list(roots(polys[r], filter='Z', predicate=lambda r: r >= 0).keys())\n        if nni_roots != []:\n            a = max(nni_roots) + 1\n        else:\n            a = S.Zero\n\n        def _zero_vector(k):\n            return [S.Zero] * k\n\n        def _one_vector(k):\n            return [S.One] * k\n\n        def _delta(p, k):\n            B = S.One\n            D = p.subs(n, a + k)\n            for i in range(1, k + 1):\n                B *= Rational(i - k - 1, i)\n                D += B * p.subs(n, a + k - i)\n            return D\n        alpha = {}\n        for i in range(-A, d + 1):\n            I = _one_vector(d + 1)\n            for k in range(1, d + 1):\n                I[k] = I[k - 1] * (x + i - k + 1) / k\n            alpha[i] = S.Zero\n            for j in range(A + 1):\n                for k in range(d + 1):\n                    B = binomial(k, i + j)\n                    D = _delta(polys[j].as_expr(), k)\n                    alpha[i] += I[k] * B * D\n        V = Matrix(U, A, lambda i, j: int(i == j))\n        if homogeneous:\n            for i in range(A, U):\n                v = _zero_vector(A)\n                for k in range(1, A + b + 1):\n                    if i - k < 0:\n                        break\n                    B = alpha[k - A].subs(x, i - k)\n                    for j in range(A):\n                        v[j] += B * V[i - k, j]\n                denom = alpha[-A].subs(x, i)\n                for j in range(A):\n                    V[i, j] = -v[j] / denom\n        else:\n            G = _zero_vector(U)\n            for i in range(A, U):\n                v = _zero_vector(A)\n                g = S.Zero\n                for k in range(1, A + b + 1):\n                    if i - k < 0:\n                        break\n                    B = alpha[k - A].subs(x, i - k)\n                    for j in range(A):\n                        v[j] += B * V[i - k, j]\n                    g += B * G[i - k]\n                denom = alpha[-A].subs(x, i)\n                for j in range(A):\n                    V[i, j] = -v[j] / denom\n                G[i] = (_delta(f, i - A) - g) / denom\n        (P, Q) = (_one_vector(U), _zero_vector(A))\n        for i in range(1, U):\n            P[i] = (P[i - 1] * (n - a - i + 1) / i).expand()\n        for i in range(A):\n            Q[i] = Add(*[(v * p).expand() for (v, p) in zip(V[:, i], P)])\n        if not homogeneous:\n            h = Add(*[(g * p).expand() for (g, p) in zip(G, P)])\n        C = [Symbol('C' + str(i + shift)) for i in range(A)]\n        g = lambda i: Add(*[c * _delta(q, i) for (c, q) in zip(C, Q)])\n        if homogeneous:\n            E = [g(i) for i in range(N + 1, U)]\n        else:\n            E = [g(i) + _delta(h, i) for i in range(N + 1, U)]\n        if E != []:\n            solutions = solve(E, *C)\n            if not solutions:\n                if homogeneous:\n                    if hints.get('symbols', False):\n                        return (S.Zero, [])\n                    else:\n                        return S.Zero\n                else:\n                    return None\n        else:\n            solutions = {}\n        if homogeneous:\n            result = S.Zero\n        else:\n            result = h\n        _C = C[:]\n        for (c, q) in list(zip(C, Q)):\n            if c in solutions:\n                s = solutions[c] * q\n                C.remove(c)\n            else:\n                s = c * q\n            result += s.expand()\n    if C != _C:\n        result = result.xreplace(dict(zip(C, _C)))\n        C = _C[:len(C)]\n    if hints.get('symbols', False):\n        return (result, C)\n    else:\n        return result",
            "def rsolve_poly(coeffs, f, n, shift=0, **hints):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Given linear recurrence operator `\\\\operatorname{L}` of order\\n    `k` with polynomial coefficients and inhomogeneous equation\\n    `\\\\operatorname{L} y = f`, where `f` is a polynomial, we seek for\\n    all polynomial solutions over field `K` of characteristic zero.\\n\\n    The algorithm performs two basic steps:\\n\\n        (1) Compute degree `N` of the general polynomial solution.\\n        (2) Find all polynomials of degree `N` or less\\n            of `\\\\operatorname{L} y = f`.\\n\\n    There are two methods for computing the polynomial solutions.\\n    If the degree bound is relatively small, i.e. it's smaller than\\n    or equal to the order of the recurrence, then naive method of\\n    undetermined coefficients is being used. This gives a system\\n    of algebraic equations with `N+1` unknowns.\\n\\n    In the other case, the algorithm performs transformation of the\\n    initial equation to an equivalent one for which the system of\\n    algebraic equations has only `r` indeterminates. This method is\\n    quite sophisticated (in comparison with the naive one) and was\\n    invented together by Abramov, Bronstein and Petkovsek.\\n\\n    It is possible to generalize the algorithm implemented here to\\n    the case of linear q-difference and differential equations.\\n\\n    Lets say that we would like to compute `m`-th Bernoulli polynomial\\n    up to a constant. For this we can use `b(n+1) - b(n) = m n^{m-1}`\\n    recurrence, which has solution `b(n) = B_m + C`. For example:\\n\\n    >>> from sympy import Symbol, rsolve_poly\\n    >>> n = Symbol('n', integer=True)\\n\\n    >>> rsolve_poly([-1, 1], 4*n**3, n)\\n    C0 + n**4 - 2*n**3 + n**2\\n\\n    References\\n    ==========\\n\\n    .. [1] S. A. Abramov, M. Bronstein and M. Petkovsek, On polynomial\\n           solutions of linear operator equations, in: T. Levelt, ed.,\\n           Proc. ISSAC '95, ACM Press, New York, 1995, 290-296.\\n\\n    .. [2] M. Petkovsek, Hypergeometric solutions of linear recurrences\\n           with polynomial coefficients, J. Symbolic Computation,\\n           14 (1992), 243-264.\\n\\n    .. [3] M. Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.\\n\\n    \"\n    f = sympify(f)\n    if not f.is_polynomial(n):\n        return None\n    homogeneous = f.is_zero\n    r = len(coeffs) - 1\n    coeffs = [Poly(coeff, n) for coeff in coeffs]\n    polys = [Poly(0, n)] * (r + 1)\n    terms = [(S.Zero, S.NegativeInfinity)] * (r + 1)\n    for i in range(r + 1):\n        for j in range(i, r + 1):\n            polys[i] += coeffs[j] * binomial(j, i).as_poly(n)\n        if not polys[i].is_zero:\n            ((exp,), coeff) = polys[i].LT()\n            terms[i] = (coeff, exp)\n    d = b = terms[0][1]\n    for i in range(1, r + 1):\n        if terms[i][1] > d:\n            d = terms[i][1]\n        if terms[i][1] - i > b:\n            b = terms[i][1] - i\n    (d, b) = (int(d), int(b))\n    x = Dummy('x')\n    degree_poly = S.Zero\n    for i in range(r + 1):\n        if terms[i][1] - i == b:\n            degree_poly += terms[i][0] * FallingFactorial(x, i)\n    nni_roots = list(roots(degree_poly, x, filter='Z', predicate=lambda r: r >= 0).keys())\n    if nni_roots:\n        N = [max(nni_roots)]\n    else:\n        N = []\n    if homogeneous:\n        N += [-b - 1]\n    else:\n        N += [f.as_poly(n).degree() - b, -b - 1]\n    N = int(max(N))\n    if N < 0:\n        if homogeneous:\n            if hints.get('symbols', False):\n                return (S.Zero, [])\n            else:\n                return S.Zero\n        else:\n            return None\n    if N <= r:\n        C = []\n        y = E = S.Zero\n        for i in range(N + 1):\n            C.append(Symbol('C' + str(i + shift)))\n            y += C[i] * n ** i\n        for i in range(r + 1):\n            E += coeffs[i].as_expr() * y.subs(n, n + i)\n        solutions = solve_undetermined_coeffs(E - f, C, n)\n        if solutions is not None:\n            _C = C\n            C = [c for c in C if c not in solutions]\n            result = y.subs(solutions)\n        else:\n            return None\n    else:\n        A = r\n        U = N + A + b + 1\n        nni_roots = list(roots(polys[r], filter='Z', predicate=lambda r: r >= 0).keys())\n        if nni_roots != []:\n            a = max(nni_roots) + 1\n        else:\n            a = S.Zero\n\n        def _zero_vector(k):\n            return [S.Zero] * k\n\n        def _one_vector(k):\n            return [S.One] * k\n\n        def _delta(p, k):\n            B = S.One\n            D = p.subs(n, a + k)\n            for i in range(1, k + 1):\n                B *= Rational(i - k - 1, i)\n                D += B * p.subs(n, a + k - i)\n            return D\n        alpha = {}\n        for i in range(-A, d + 1):\n            I = _one_vector(d + 1)\n            for k in range(1, d + 1):\n                I[k] = I[k - 1] * (x + i - k + 1) / k\n            alpha[i] = S.Zero\n            for j in range(A + 1):\n                for k in range(d + 1):\n                    B = binomial(k, i + j)\n                    D = _delta(polys[j].as_expr(), k)\n                    alpha[i] += I[k] * B * D\n        V = Matrix(U, A, lambda i, j: int(i == j))\n        if homogeneous:\n            for i in range(A, U):\n                v = _zero_vector(A)\n                for k in range(1, A + b + 1):\n                    if i - k < 0:\n                        break\n                    B = alpha[k - A].subs(x, i - k)\n                    for j in range(A):\n                        v[j] += B * V[i - k, j]\n                denom = alpha[-A].subs(x, i)\n                for j in range(A):\n                    V[i, j] = -v[j] / denom\n        else:\n            G = _zero_vector(U)\n            for i in range(A, U):\n                v = _zero_vector(A)\n                g = S.Zero\n                for k in range(1, A + b + 1):\n                    if i - k < 0:\n                        break\n                    B = alpha[k - A].subs(x, i - k)\n                    for j in range(A):\n                        v[j] += B * V[i - k, j]\n                    g += B * G[i - k]\n                denom = alpha[-A].subs(x, i)\n                for j in range(A):\n                    V[i, j] = -v[j] / denom\n                G[i] = (_delta(f, i - A) - g) / denom\n        (P, Q) = (_one_vector(U), _zero_vector(A))\n        for i in range(1, U):\n            P[i] = (P[i - 1] * (n - a - i + 1) / i).expand()\n        for i in range(A):\n            Q[i] = Add(*[(v * p).expand() for (v, p) in zip(V[:, i], P)])\n        if not homogeneous:\n            h = Add(*[(g * p).expand() for (g, p) in zip(G, P)])\n        C = [Symbol('C' + str(i + shift)) for i in range(A)]\n        g = lambda i: Add(*[c * _delta(q, i) for (c, q) in zip(C, Q)])\n        if homogeneous:\n            E = [g(i) for i in range(N + 1, U)]\n        else:\n            E = [g(i) + _delta(h, i) for i in range(N + 1, U)]\n        if E != []:\n            solutions = solve(E, *C)\n            if not solutions:\n                if homogeneous:\n                    if hints.get('symbols', False):\n                        return (S.Zero, [])\n                    else:\n                        return S.Zero\n                else:\n                    return None\n        else:\n            solutions = {}\n        if homogeneous:\n            result = S.Zero\n        else:\n            result = h\n        _C = C[:]\n        for (c, q) in list(zip(C, Q)):\n            if c in solutions:\n                s = solutions[c] * q\n                C.remove(c)\n            else:\n                s = c * q\n            result += s.expand()\n    if C != _C:\n        result = result.xreplace(dict(zip(C, _C)))\n        C = _C[:len(C)]\n    if hints.get('symbols', False):\n        return (result, C)\n    else:\n        return result",
            "def rsolve_poly(coeffs, f, n, shift=0, **hints):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Given linear recurrence operator `\\\\operatorname{L}` of order\\n    `k` with polynomial coefficients and inhomogeneous equation\\n    `\\\\operatorname{L} y = f`, where `f` is a polynomial, we seek for\\n    all polynomial solutions over field `K` of characteristic zero.\\n\\n    The algorithm performs two basic steps:\\n\\n        (1) Compute degree `N` of the general polynomial solution.\\n        (2) Find all polynomials of degree `N` or less\\n            of `\\\\operatorname{L} y = f`.\\n\\n    There are two methods for computing the polynomial solutions.\\n    If the degree bound is relatively small, i.e. it's smaller than\\n    or equal to the order of the recurrence, then naive method of\\n    undetermined coefficients is being used. This gives a system\\n    of algebraic equations with `N+1` unknowns.\\n\\n    In the other case, the algorithm performs transformation of the\\n    initial equation to an equivalent one for which the system of\\n    algebraic equations has only `r` indeterminates. This method is\\n    quite sophisticated (in comparison with the naive one) and was\\n    invented together by Abramov, Bronstein and Petkovsek.\\n\\n    It is possible to generalize the algorithm implemented here to\\n    the case of linear q-difference and differential equations.\\n\\n    Lets say that we would like to compute `m`-th Bernoulli polynomial\\n    up to a constant. For this we can use `b(n+1) - b(n) = m n^{m-1}`\\n    recurrence, which has solution `b(n) = B_m + C`. For example:\\n\\n    >>> from sympy import Symbol, rsolve_poly\\n    >>> n = Symbol('n', integer=True)\\n\\n    >>> rsolve_poly([-1, 1], 4*n**3, n)\\n    C0 + n**4 - 2*n**3 + n**2\\n\\n    References\\n    ==========\\n\\n    .. [1] S. A. Abramov, M. Bronstein and M. Petkovsek, On polynomial\\n           solutions of linear operator equations, in: T. Levelt, ed.,\\n           Proc. ISSAC '95, ACM Press, New York, 1995, 290-296.\\n\\n    .. [2] M. Petkovsek, Hypergeometric solutions of linear recurrences\\n           with polynomial coefficients, J. Symbolic Computation,\\n           14 (1992), 243-264.\\n\\n    .. [3] M. Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.\\n\\n    \"\n    f = sympify(f)\n    if not f.is_polynomial(n):\n        return None\n    homogeneous = f.is_zero\n    r = len(coeffs) - 1\n    coeffs = [Poly(coeff, n) for coeff in coeffs]\n    polys = [Poly(0, n)] * (r + 1)\n    terms = [(S.Zero, S.NegativeInfinity)] * (r + 1)\n    for i in range(r + 1):\n        for j in range(i, r + 1):\n            polys[i] += coeffs[j] * binomial(j, i).as_poly(n)\n        if not polys[i].is_zero:\n            ((exp,), coeff) = polys[i].LT()\n            terms[i] = (coeff, exp)\n    d = b = terms[0][1]\n    for i in range(1, r + 1):\n        if terms[i][1] > d:\n            d = terms[i][1]\n        if terms[i][1] - i > b:\n            b = terms[i][1] - i\n    (d, b) = (int(d), int(b))\n    x = Dummy('x')\n    degree_poly = S.Zero\n    for i in range(r + 1):\n        if terms[i][1] - i == b:\n            degree_poly += terms[i][0] * FallingFactorial(x, i)\n    nni_roots = list(roots(degree_poly, x, filter='Z', predicate=lambda r: r >= 0).keys())\n    if nni_roots:\n        N = [max(nni_roots)]\n    else:\n        N = []\n    if homogeneous:\n        N += [-b - 1]\n    else:\n        N += [f.as_poly(n).degree() - b, -b - 1]\n    N = int(max(N))\n    if N < 0:\n        if homogeneous:\n            if hints.get('symbols', False):\n                return (S.Zero, [])\n            else:\n                return S.Zero\n        else:\n            return None\n    if N <= r:\n        C = []\n        y = E = S.Zero\n        for i in range(N + 1):\n            C.append(Symbol('C' + str(i + shift)))\n            y += C[i] * n ** i\n        for i in range(r + 1):\n            E += coeffs[i].as_expr() * y.subs(n, n + i)\n        solutions = solve_undetermined_coeffs(E - f, C, n)\n        if solutions is not None:\n            _C = C\n            C = [c for c in C if c not in solutions]\n            result = y.subs(solutions)\n        else:\n            return None\n    else:\n        A = r\n        U = N + A + b + 1\n        nni_roots = list(roots(polys[r], filter='Z', predicate=lambda r: r >= 0).keys())\n        if nni_roots != []:\n            a = max(nni_roots) + 1\n        else:\n            a = S.Zero\n\n        def _zero_vector(k):\n            return [S.Zero] * k\n\n        def _one_vector(k):\n            return [S.One] * k\n\n        def _delta(p, k):\n            B = S.One\n            D = p.subs(n, a + k)\n            for i in range(1, k + 1):\n                B *= Rational(i - k - 1, i)\n                D += B * p.subs(n, a + k - i)\n            return D\n        alpha = {}\n        for i in range(-A, d + 1):\n            I = _one_vector(d + 1)\n            for k in range(1, d + 1):\n                I[k] = I[k - 1] * (x + i - k + 1) / k\n            alpha[i] = S.Zero\n            for j in range(A + 1):\n                for k in range(d + 1):\n                    B = binomial(k, i + j)\n                    D = _delta(polys[j].as_expr(), k)\n                    alpha[i] += I[k] * B * D\n        V = Matrix(U, A, lambda i, j: int(i == j))\n        if homogeneous:\n            for i in range(A, U):\n                v = _zero_vector(A)\n                for k in range(1, A + b + 1):\n                    if i - k < 0:\n                        break\n                    B = alpha[k - A].subs(x, i - k)\n                    for j in range(A):\n                        v[j] += B * V[i - k, j]\n                denom = alpha[-A].subs(x, i)\n                for j in range(A):\n                    V[i, j] = -v[j] / denom\n        else:\n            G = _zero_vector(U)\n            for i in range(A, U):\n                v = _zero_vector(A)\n                g = S.Zero\n                for k in range(1, A + b + 1):\n                    if i - k < 0:\n                        break\n                    B = alpha[k - A].subs(x, i - k)\n                    for j in range(A):\n                        v[j] += B * V[i - k, j]\n                    g += B * G[i - k]\n                denom = alpha[-A].subs(x, i)\n                for j in range(A):\n                    V[i, j] = -v[j] / denom\n                G[i] = (_delta(f, i - A) - g) / denom\n        (P, Q) = (_one_vector(U), _zero_vector(A))\n        for i in range(1, U):\n            P[i] = (P[i - 1] * (n - a - i + 1) / i).expand()\n        for i in range(A):\n            Q[i] = Add(*[(v * p).expand() for (v, p) in zip(V[:, i], P)])\n        if not homogeneous:\n            h = Add(*[(g * p).expand() for (g, p) in zip(G, P)])\n        C = [Symbol('C' + str(i + shift)) for i in range(A)]\n        g = lambda i: Add(*[c * _delta(q, i) for (c, q) in zip(C, Q)])\n        if homogeneous:\n            E = [g(i) for i in range(N + 1, U)]\n        else:\n            E = [g(i) + _delta(h, i) for i in range(N + 1, U)]\n        if E != []:\n            solutions = solve(E, *C)\n            if not solutions:\n                if homogeneous:\n                    if hints.get('symbols', False):\n                        return (S.Zero, [])\n                    else:\n                        return S.Zero\n                else:\n                    return None\n        else:\n            solutions = {}\n        if homogeneous:\n            result = S.Zero\n        else:\n            result = h\n        _C = C[:]\n        for (c, q) in list(zip(C, Q)):\n            if c in solutions:\n                s = solutions[c] * q\n                C.remove(c)\n            else:\n                s = c * q\n            result += s.expand()\n    if C != _C:\n        result = result.xreplace(dict(zip(C, _C)))\n        C = _C[:len(C)]\n    if hints.get('symbols', False):\n        return (result, C)\n    else:\n        return result",
            "def rsolve_poly(coeffs, f, n, shift=0, **hints):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Given linear recurrence operator `\\\\operatorname{L}` of order\\n    `k` with polynomial coefficients and inhomogeneous equation\\n    `\\\\operatorname{L} y = f`, where `f` is a polynomial, we seek for\\n    all polynomial solutions over field `K` of characteristic zero.\\n\\n    The algorithm performs two basic steps:\\n\\n        (1) Compute degree `N` of the general polynomial solution.\\n        (2) Find all polynomials of degree `N` or less\\n            of `\\\\operatorname{L} y = f`.\\n\\n    There are two methods for computing the polynomial solutions.\\n    If the degree bound is relatively small, i.e. it's smaller than\\n    or equal to the order of the recurrence, then naive method of\\n    undetermined coefficients is being used. This gives a system\\n    of algebraic equations with `N+1` unknowns.\\n\\n    In the other case, the algorithm performs transformation of the\\n    initial equation to an equivalent one for which the system of\\n    algebraic equations has only `r` indeterminates. This method is\\n    quite sophisticated (in comparison with the naive one) and was\\n    invented together by Abramov, Bronstein and Petkovsek.\\n\\n    It is possible to generalize the algorithm implemented here to\\n    the case of linear q-difference and differential equations.\\n\\n    Lets say that we would like to compute `m`-th Bernoulli polynomial\\n    up to a constant. For this we can use `b(n+1) - b(n) = m n^{m-1}`\\n    recurrence, which has solution `b(n) = B_m + C`. For example:\\n\\n    >>> from sympy import Symbol, rsolve_poly\\n    >>> n = Symbol('n', integer=True)\\n\\n    >>> rsolve_poly([-1, 1], 4*n**3, n)\\n    C0 + n**4 - 2*n**3 + n**2\\n\\n    References\\n    ==========\\n\\n    .. [1] S. A. Abramov, M. Bronstein and M. Petkovsek, On polynomial\\n           solutions of linear operator equations, in: T. Levelt, ed.,\\n           Proc. ISSAC '95, ACM Press, New York, 1995, 290-296.\\n\\n    .. [2] M. Petkovsek, Hypergeometric solutions of linear recurrences\\n           with polynomial coefficients, J. Symbolic Computation,\\n           14 (1992), 243-264.\\n\\n    .. [3] M. Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.\\n\\n    \"\n    f = sympify(f)\n    if not f.is_polynomial(n):\n        return None\n    homogeneous = f.is_zero\n    r = len(coeffs) - 1\n    coeffs = [Poly(coeff, n) for coeff in coeffs]\n    polys = [Poly(0, n)] * (r + 1)\n    terms = [(S.Zero, S.NegativeInfinity)] * (r + 1)\n    for i in range(r + 1):\n        for j in range(i, r + 1):\n            polys[i] += coeffs[j] * binomial(j, i).as_poly(n)\n        if not polys[i].is_zero:\n            ((exp,), coeff) = polys[i].LT()\n            terms[i] = (coeff, exp)\n    d = b = terms[0][1]\n    for i in range(1, r + 1):\n        if terms[i][1] > d:\n            d = terms[i][1]\n        if terms[i][1] - i > b:\n            b = terms[i][1] - i\n    (d, b) = (int(d), int(b))\n    x = Dummy('x')\n    degree_poly = S.Zero\n    for i in range(r + 1):\n        if terms[i][1] - i == b:\n            degree_poly += terms[i][0] * FallingFactorial(x, i)\n    nni_roots = list(roots(degree_poly, x, filter='Z', predicate=lambda r: r >= 0).keys())\n    if nni_roots:\n        N = [max(nni_roots)]\n    else:\n        N = []\n    if homogeneous:\n        N += [-b - 1]\n    else:\n        N += [f.as_poly(n).degree() - b, -b - 1]\n    N = int(max(N))\n    if N < 0:\n        if homogeneous:\n            if hints.get('symbols', False):\n                return (S.Zero, [])\n            else:\n                return S.Zero\n        else:\n            return None\n    if N <= r:\n        C = []\n        y = E = S.Zero\n        for i in range(N + 1):\n            C.append(Symbol('C' + str(i + shift)))\n            y += C[i] * n ** i\n        for i in range(r + 1):\n            E += coeffs[i].as_expr() * y.subs(n, n + i)\n        solutions = solve_undetermined_coeffs(E - f, C, n)\n        if solutions is not None:\n            _C = C\n            C = [c for c in C if c not in solutions]\n            result = y.subs(solutions)\n        else:\n            return None\n    else:\n        A = r\n        U = N + A + b + 1\n        nni_roots = list(roots(polys[r], filter='Z', predicate=lambda r: r >= 0).keys())\n        if nni_roots != []:\n            a = max(nni_roots) + 1\n        else:\n            a = S.Zero\n\n        def _zero_vector(k):\n            return [S.Zero] * k\n\n        def _one_vector(k):\n            return [S.One] * k\n\n        def _delta(p, k):\n            B = S.One\n            D = p.subs(n, a + k)\n            for i in range(1, k + 1):\n                B *= Rational(i - k - 1, i)\n                D += B * p.subs(n, a + k - i)\n            return D\n        alpha = {}\n        for i in range(-A, d + 1):\n            I = _one_vector(d + 1)\n            for k in range(1, d + 1):\n                I[k] = I[k - 1] * (x + i - k + 1) / k\n            alpha[i] = S.Zero\n            for j in range(A + 1):\n                for k in range(d + 1):\n                    B = binomial(k, i + j)\n                    D = _delta(polys[j].as_expr(), k)\n                    alpha[i] += I[k] * B * D\n        V = Matrix(U, A, lambda i, j: int(i == j))\n        if homogeneous:\n            for i in range(A, U):\n                v = _zero_vector(A)\n                for k in range(1, A + b + 1):\n                    if i - k < 0:\n                        break\n                    B = alpha[k - A].subs(x, i - k)\n                    for j in range(A):\n                        v[j] += B * V[i - k, j]\n                denom = alpha[-A].subs(x, i)\n                for j in range(A):\n                    V[i, j] = -v[j] / denom\n        else:\n            G = _zero_vector(U)\n            for i in range(A, U):\n                v = _zero_vector(A)\n                g = S.Zero\n                for k in range(1, A + b + 1):\n                    if i - k < 0:\n                        break\n                    B = alpha[k - A].subs(x, i - k)\n                    for j in range(A):\n                        v[j] += B * V[i - k, j]\n                    g += B * G[i - k]\n                denom = alpha[-A].subs(x, i)\n                for j in range(A):\n                    V[i, j] = -v[j] / denom\n                G[i] = (_delta(f, i - A) - g) / denom\n        (P, Q) = (_one_vector(U), _zero_vector(A))\n        for i in range(1, U):\n            P[i] = (P[i - 1] * (n - a - i + 1) / i).expand()\n        for i in range(A):\n            Q[i] = Add(*[(v * p).expand() for (v, p) in zip(V[:, i], P)])\n        if not homogeneous:\n            h = Add(*[(g * p).expand() for (g, p) in zip(G, P)])\n        C = [Symbol('C' + str(i + shift)) for i in range(A)]\n        g = lambda i: Add(*[c * _delta(q, i) for (c, q) in zip(C, Q)])\n        if homogeneous:\n            E = [g(i) for i in range(N + 1, U)]\n        else:\n            E = [g(i) + _delta(h, i) for i in range(N + 1, U)]\n        if E != []:\n            solutions = solve(E, *C)\n            if not solutions:\n                if homogeneous:\n                    if hints.get('symbols', False):\n                        return (S.Zero, [])\n                    else:\n                        return S.Zero\n                else:\n                    return None\n        else:\n            solutions = {}\n        if homogeneous:\n            result = S.Zero\n        else:\n            result = h\n        _C = C[:]\n        for (c, q) in list(zip(C, Q)):\n            if c in solutions:\n                s = solutions[c] * q\n                C.remove(c)\n            else:\n                s = c * q\n            result += s.expand()\n    if C != _C:\n        result = result.xreplace(dict(zip(C, _C)))\n        C = _C[:len(C)]\n    if hints.get('symbols', False):\n        return (result, C)\n    else:\n        return result",
            "def rsolve_poly(coeffs, f, n, shift=0, **hints):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Given linear recurrence operator `\\\\operatorname{L}` of order\\n    `k` with polynomial coefficients and inhomogeneous equation\\n    `\\\\operatorname{L} y = f`, where `f` is a polynomial, we seek for\\n    all polynomial solutions over field `K` of characteristic zero.\\n\\n    The algorithm performs two basic steps:\\n\\n        (1) Compute degree `N` of the general polynomial solution.\\n        (2) Find all polynomials of degree `N` or less\\n            of `\\\\operatorname{L} y = f`.\\n\\n    There are two methods for computing the polynomial solutions.\\n    If the degree bound is relatively small, i.e. it's smaller than\\n    or equal to the order of the recurrence, then naive method of\\n    undetermined coefficients is being used. This gives a system\\n    of algebraic equations with `N+1` unknowns.\\n\\n    In the other case, the algorithm performs transformation of the\\n    initial equation to an equivalent one for which the system of\\n    algebraic equations has only `r` indeterminates. This method is\\n    quite sophisticated (in comparison with the naive one) and was\\n    invented together by Abramov, Bronstein and Petkovsek.\\n\\n    It is possible to generalize the algorithm implemented here to\\n    the case of linear q-difference and differential equations.\\n\\n    Lets say that we would like to compute `m`-th Bernoulli polynomial\\n    up to a constant. For this we can use `b(n+1) - b(n) = m n^{m-1}`\\n    recurrence, which has solution `b(n) = B_m + C`. For example:\\n\\n    >>> from sympy import Symbol, rsolve_poly\\n    >>> n = Symbol('n', integer=True)\\n\\n    >>> rsolve_poly([-1, 1], 4*n**3, n)\\n    C0 + n**4 - 2*n**3 + n**2\\n\\n    References\\n    ==========\\n\\n    .. [1] S. A. Abramov, M. Bronstein and M. Petkovsek, On polynomial\\n           solutions of linear operator equations, in: T. Levelt, ed.,\\n           Proc. ISSAC '95, ACM Press, New York, 1995, 290-296.\\n\\n    .. [2] M. Petkovsek, Hypergeometric solutions of linear recurrences\\n           with polynomial coefficients, J. Symbolic Computation,\\n           14 (1992), 243-264.\\n\\n    .. [3] M. Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.\\n\\n    \"\n    f = sympify(f)\n    if not f.is_polynomial(n):\n        return None\n    homogeneous = f.is_zero\n    r = len(coeffs) - 1\n    coeffs = [Poly(coeff, n) for coeff in coeffs]\n    polys = [Poly(0, n)] * (r + 1)\n    terms = [(S.Zero, S.NegativeInfinity)] * (r + 1)\n    for i in range(r + 1):\n        for j in range(i, r + 1):\n            polys[i] += coeffs[j] * binomial(j, i).as_poly(n)\n        if not polys[i].is_zero:\n            ((exp,), coeff) = polys[i].LT()\n            terms[i] = (coeff, exp)\n    d = b = terms[0][1]\n    for i in range(1, r + 1):\n        if terms[i][1] > d:\n            d = terms[i][1]\n        if terms[i][1] - i > b:\n            b = terms[i][1] - i\n    (d, b) = (int(d), int(b))\n    x = Dummy('x')\n    degree_poly = S.Zero\n    for i in range(r + 1):\n        if terms[i][1] - i == b:\n            degree_poly += terms[i][0] * FallingFactorial(x, i)\n    nni_roots = list(roots(degree_poly, x, filter='Z', predicate=lambda r: r >= 0).keys())\n    if nni_roots:\n        N = [max(nni_roots)]\n    else:\n        N = []\n    if homogeneous:\n        N += [-b - 1]\n    else:\n        N += [f.as_poly(n).degree() - b, -b - 1]\n    N = int(max(N))\n    if N < 0:\n        if homogeneous:\n            if hints.get('symbols', False):\n                return (S.Zero, [])\n            else:\n                return S.Zero\n        else:\n            return None\n    if N <= r:\n        C = []\n        y = E = S.Zero\n        for i in range(N + 1):\n            C.append(Symbol('C' + str(i + shift)))\n            y += C[i] * n ** i\n        for i in range(r + 1):\n            E += coeffs[i].as_expr() * y.subs(n, n + i)\n        solutions = solve_undetermined_coeffs(E - f, C, n)\n        if solutions is not None:\n            _C = C\n            C = [c for c in C if c not in solutions]\n            result = y.subs(solutions)\n        else:\n            return None\n    else:\n        A = r\n        U = N + A + b + 1\n        nni_roots = list(roots(polys[r], filter='Z', predicate=lambda r: r >= 0).keys())\n        if nni_roots != []:\n            a = max(nni_roots) + 1\n        else:\n            a = S.Zero\n\n        def _zero_vector(k):\n            return [S.Zero] * k\n\n        def _one_vector(k):\n            return [S.One] * k\n\n        def _delta(p, k):\n            B = S.One\n            D = p.subs(n, a + k)\n            for i in range(1, k + 1):\n                B *= Rational(i - k - 1, i)\n                D += B * p.subs(n, a + k - i)\n            return D\n        alpha = {}\n        for i in range(-A, d + 1):\n            I = _one_vector(d + 1)\n            for k in range(1, d + 1):\n                I[k] = I[k - 1] * (x + i - k + 1) / k\n            alpha[i] = S.Zero\n            for j in range(A + 1):\n                for k in range(d + 1):\n                    B = binomial(k, i + j)\n                    D = _delta(polys[j].as_expr(), k)\n                    alpha[i] += I[k] * B * D\n        V = Matrix(U, A, lambda i, j: int(i == j))\n        if homogeneous:\n            for i in range(A, U):\n                v = _zero_vector(A)\n                for k in range(1, A + b + 1):\n                    if i - k < 0:\n                        break\n                    B = alpha[k - A].subs(x, i - k)\n                    for j in range(A):\n                        v[j] += B * V[i - k, j]\n                denom = alpha[-A].subs(x, i)\n                for j in range(A):\n                    V[i, j] = -v[j] / denom\n        else:\n            G = _zero_vector(U)\n            for i in range(A, U):\n                v = _zero_vector(A)\n                g = S.Zero\n                for k in range(1, A + b + 1):\n                    if i - k < 0:\n                        break\n                    B = alpha[k - A].subs(x, i - k)\n                    for j in range(A):\n                        v[j] += B * V[i - k, j]\n                    g += B * G[i - k]\n                denom = alpha[-A].subs(x, i)\n                for j in range(A):\n                    V[i, j] = -v[j] / denom\n                G[i] = (_delta(f, i - A) - g) / denom\n        (P, Q) = (_one_vector(U), _zero_vector(A))\n        for i in range(1, U):\n            P[i] = (P[i - 1] * (n - a - i + 1) / i).expand()\n        for i in range(A):\n            Q[i] = Add(*[(v * p).expand() for (v, p) in zip(V[:, i], P)])\n        if not homogeneous:\n            h = Add(*[(g * p).expand() for (g, p) in zip(G, P)])\n        C = [Symbol('C' + str(i + shift)) for i in range(A)]\n        g = lambda i: Add(*[c * _delta(q, i) for (c, q) in zip(C, Q)])\n        if homogeneous:\n            E = [g(i) for i in range(N + 1, U)]\n        else:\n            E = [g(i) + _delta(h, i) for i in range(N + 1, U)]\n        if E != []:\n            solutions = solve(E, *C)\n            if not solutions:\n                if homogeneous:\n                    if hints.get('symbols', False):\n                        return (S.Zero, [])\n                    else:\n                        return S.Zero\n                else:\n                    return None\n        else:\n            solutions = {}\n        if homogeneous:\n            result = S.Zero\n        else:\n            result = h\n        _C = C[:]\n        for (c, q) in list(zip(C, Q)):\n            if c in solutions:\n                s = solutions[c] * q\n                C.remove(c)\n            else:\n                s = c * q\n            result += s.expand()\n    if C != _C:\n        result = result.xreplace(dict(zip(C, _C)))\n        C = _C[:len(C)]\n    if hints.get('symbols', False):\n        return (result, C)\n    else:\n        return result"
        ]
    },
    {
        "func_name": "rsolve_ratio",
        "original": "def rsolve_ratio(coeffs, f, n, **hints):\n    \"\"\"\n    Given linear recurrence operator `\\\\operatorname{L}` of order `k`\n    with polynomial coefficients and inhomogeneous equation\n    `\\\\operatorname{L} y = f`, where `f` is a polynomial, we seek\n    for all rational solutions over field `K` of characteristic zero.\n\n    This procedure accepts only polynomials, however if you are\n    interested in solving recurrence with rational coefficients\n    then use ``rsolve`` which will pre-process the given equation\n    and run this procedure with polynomial arguments.\n\n    The algorithm performs two basic steps:\n\n        (1) Compute polynomial `v(n)` which can be used as universal\n            denominator of any rational solution of equation\n            `\\\\operatorname{L} y = f`.\n\n        (2) Construct new linear difference equation by substitution\n            `y(n) = u(n)/v(n)` and solve it for `u(n)` finding all its\n            polynomial solutions. Return ``None`` if none were found.\n\n    The algorithm implemented here is a revised version of the original\n    Abramov's algorithm, developed in 1989. The new approach is much\n    simpler to implement and has better overall efficiency. This\n    method can be easily adapted to the q-difference equations case.\n\n    Besides finding rational solutions alone, this functions is\n    an important part of Hyper algorithm where it is used to find\n    a particular solution for the inhomogeneous part of a recurrence.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> from sympy.solvers.recurr import rsolve_ratio\n    >>> rsolve_ratio([-2*x**3 + x**2 + 2*x - 1, 2*x**3 + x**2 - 6*x,\n    ... - 2*x**3 - 11*x**2 - 18*x - 9, 2*x**3 + 13*x**2 + 22*x + 8], 0, x)\n    C0*(2*x - 3)/(2*(x**2 - 1))\n\n    References\n    ==========\n\n    .. [1] S. A. Abramov, Rational solutions of linear difference\n           and q-difference equations with polynomial coefficients,\n           in: T. Levelt, ed., Proc. ISSAC '95, ACM Press, New York,\n           1995, 285-289\n\n    See Also\n    ========\n\n    rsolve_hyper\n    \"\"\"\n    f = sympify(f)\n    if not f.is_polynomial(n):\n        return None\n    coeffs = list(map(sympify, coeffs))\n    r = len(coeffs) - 1\n    (A, B) = (coeffs[r], coeffs[0])\n    A = A.subs(n, n - r).expand()\n    h = Dummy('h')\n    res = resultant(A, B.subs(n, n + h), n)\n    if not res.is_polynomial(h):\n        (p, q) = res.as_numer_denom()\n        res = quo(p, q, h)\n    nni_roots = list(roots(res, h, filter='Z', predicate=lambda r: r >= 0).keys())\n    if not nni_roots:\n        return rsolve_poly(coeffs, f, n, **hints)\n    else:\n        (C, numers) = (S.One, [S.Zero] * (r + 1))\n        for i in range(int(max(nni_roots)), -1, -1):\n            d = gcd(A, B.subs(n, n + i), n)\n            A = quo(A, d, n)\n            B = quo(B, d.subs(n, n - i), n)\n            C *= Mul(*[d.subs(n, n - j) for j in range(i + 1)])\n        denoms = [C.subs(n, n + i) for i in range(r + 1)]\n        for i in range(r + 1):\n            g = gcd(coeffs[i], denoms[i], n)\n            numers[i] = quo(coeffs[i], g, n)\n            denoms[i] = quo(denoms[i], g, n)\n        for i in range(r + 1):\n            numers[i] *= Mul(*denoms[:i] + denoms[i + 1:])\n        result = rsolve_poly(numers, f * Mul(*denoms), n, **hints)\n        if result is not None:\n            if hints.get('symbols', False):\n                return (simplify(result[0] / C), result[1])\n            else:\n                return simplify(result / C)\n        else:\n            return None",
        "mutated": [
            "def rsolve_ratio(coeffs, f, n, **hints):\n    if False:\n        i = 10\n    \"\\n    Given linear recurrence operator `\\\\operatorname{L}` of order `k`\\n    with polynomial coefficients and inhomogeneous equation\\n    `\\\\operatorname{L} y = f`, where `f` is a polynomial, we seek\\n    for all rational solutions over field `K` of characteristic zero.\\n\\n    This procedure accepts only polynomials, however if you are\\n    interested in solving recurrence with rational coefficients\\n    then use ``rsolve`` which will pre-process the given equation\\n    and run this procedure with polynomial arguments.\\n\\n    The algorithm performs two basic steps:\\n\\n        (1) Compute polynomial `v(n)` which can be used as universal\\n            denominator of any rational solution of equation\\n            `\\\\operatorname{L} y = f`.\\n\\n        (2) Construct new linear difference equation by substitution\\n            `y(n) = u(n)/v(n)` and solve it for `u(n)` finding all its\\n            polynomial solutions. Return ``None`` if none were found.\\n\\n    The algorithm implemented here is a revised version of the original\\n    Abramov's algorithm, developed in 1989. The new approach is much\\n    simpler to implement and has better overall efficiency. This\\n    method can be easily adapted to the q-difference equations case.\\n\\n    Besides finding rational solutions alone, this functions is\\n    an important part of Hyper algorithm where it is used to find\\n    a particular solution for the inhomogeneous part of a recurrence.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.abc import x\\n    >>> from sympy.solvers.recurr import rsolve_ratio\\n    >>> rsolve_ratio([-2*x**3 + x**2 + 2*x - 1, 2*x**3 + x**2 - 6*x,\\n    ... - 2*x**3 - 11*x**2 - 18*x - 9, 2*x**3 + 13*x**2 + 22*x + 8], 0, x)\\n    C0*(2*x - 3)/(2*(x**2 - 1))\\n\\n    References\\n    ==========\\n\\n    .. [1] S. A. Abramov, Rational solutions of linear difference\\n           and q-difference equations with polynomial coefficients,\\n           in: T. Levelt, ed., Proc. ISSAC '95, ACM Press, New York,\\n           1995, 285-289\\n\\n    See Also\\n    ========\\n\\n    rsolve_hyper\\n    \"\n    f = sympify(f)\n    if not f.is_polynomial(n):\n        return None\n    coeffs = list(map(sympify, coeffs))\n    r = len(coeffs) - 1\n    (A, B) = (coeffs[r], coeffs[0])\n    A = A.subs(n, n - r).expand()\n    h = Dummy('h')\n    res = resultant(A, B.subs(n, n + h), n)\n    if not res.is_polynomial(h):\n        (p, q) = res.as_numer_denom()\n        res = quo(p, q, h)\n    nni_roots = list(roots(res, h, filter='Z', predicate=lambda r: r >= 0).keys())\n    if not nni_roots:\n        return rsolve_poly(coeffs, f, n, **hints)\n    else:\n        (C, numers) = (S.One, [S.Zero] * (r + 1))\n        for i in range(int(max(nni_roots)), -1, -1):\n            d = gcd(A, B.subs(n, n + i), n)\n            A = quo(A, d, n)\n            B = quo(B, d.subs(n, n - i), n)\n            C *= Mul(*[d.subs(n, n - j) for j in range(i + 1)])\n        denoms = [C.subs(n, n + i) for i in range(r + 1)]\n        for i in range(r + 1):\n            g = gcd(coeffs[i], denoms[i], n)\n            numers[i] = quo(coeffs[i], g, n)\n            denoms[i] = quo(denoms[i], g, n)\n        for i in range(r + 1):\n            numers[i] *= Mul(*denoms[:i] + denoms[i + 1:])\n        result = rsolve_poly(numers, f * Mul(*denoms), n, **hints)\n        if result is not None:\n            if hints.get('symbols', False):\n                return (simplify(result[0] / C), result[1])\n            else:\n                return simplify(result / C)\n        else:\n            return None",
            "def rsolve_ratio(coeffs, f, n, **hints):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Given linear recurrence operator `\\\\operatorname{L}` of order `k`\\n    with polynomial coefficients and inhomogeneous equation\\n    `\\\\operatorname{L} y = f`, where `f` is a polynomial, we seek\\n    for all rational solutions over field `K` of characteristic zero.\\n\\n    This procedure accepts only polynomials, however if you are\\n    interested in solving recurrence with rational coefficients\\n    then use ``rsolve`` which will pre-process the given equation\\n    and run this procedure with polynomial arguments.\\n\\n    The algorithm performs two basic steps:\\n\\n        (1) Compute polynomial `v(n)` which can be used as universal\\n            denominator of any rational solution of equation\\n            `\\\\operatorname{L} y = f`.\\n\\n        (2) Construct new linear difference equation by substitution\\n            `y(n) = u(n)/v(n)` and solve it for `u(n)` finding all its\\n            polynomial solutions. Return ``None`` if none were found.\\n\\n    The algorithm implemented here is a revised version of the original\\n    Abramov's algorithm, developed in 1989. The new approach is much\\n    simpler to implement and has better overall efficiency. This\\n    method can be easily adapted to the q-difference equations case.\\n\\n    Besides finding rational solutions alone, this functions is\\n    an important part of Hyper algorithm where it is used to find\\n    a particular solution for the inhomogeneous part of a recurrence.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.abc import x\\n    >>> from sympy.solvers.recurr import rsolve_ratio\\n    >>> rsolve_ratio([-2*x**3 + x**2 + 2*x - 1, 2*x**3 + x**2 - 6*x,\\n    ... - 2*x**3 - 11*x**2 - 18*x - 9, 2*x**3 + 13*x**2 + 22*x + 8], 0, x)\\n    C0*(2*x - 3)/(2*(x**2 - 1))\\n\\n    References\\n    ==========\\n\\n    .. [1] S. A. Abramov, Rational solutions of linear difference\\n           and q-difference equations with polynomial coefficients,\\n           in: T. Levelt, ed., Proc. ISSAC '95, ACM Press, New York,\\n           1995, 285-289\\n\\n    See Also\\n    ========\\n\\n    rsolve_hyper\\n    \"\n    f = sympify(f)\n    if not f.is_polynomial(n):\n        return None\n    coeffs = list(map(sympify, coeffs))\n    r = len(coeffs) - 1\n    (A, B) = (coeffs[r], coeffs[0])\n    A = A.subs(n, n - r).expand()\n    h = Dummy('h')\n    res = resultant(A, B.subs(n, n + h), n)\n    if not res.is_polynomial(h):\n        (p, q) = res.as_numer_denom()\n        res = quo(p, q, h)\n    nni_roots = list(roots(res, h, filter='Z', predicate=lambda r: r >= 0).keys())\n    if not nni_roots:\n        return rsolve_poly(coeffs, f, n, **hints)\n    else:\n        (C, numers) = (S.One, [S.Zero] * (r + 1))\n        for i in range(int(max(nni_roots)), -1, -1):\n            d = gcd(A, B.subs(n, n + i), n)\n            A = quo(A, d, n)\n            B = quo(B, d.subs(n, n - i), n)\n            C *= Mul(*[d.subs(n, n - j) for j in range(i + 1)])\n        denoms = [C.subs(n, n + i) for i in range(r + 1)]\n        for i in range(r + 1):\n            g = gcd(coeffs[i], denoms[i], n)\n            numers[i] = quo(coeffs[i], g, n)\n            denoms[i] = quo(denoms[i], g, n)\n        for i in range(r + 1):\n            numers[i] *= Mul(*denoms[:i] + denoms[i + 1:])\n        result = rsolve_poly(numers, f * Mul(*denoms), n, **hints)\n        if result is not None:\n            if hints.get('symbols', False):\n                return (simplify(result[0] / C), result[1])\n            else:\n                return simplify(result / C)\n        else:\n            return None",
            "def rsolve_ratio(coeffs, f, n, **hints):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Given linear recurrence operator `\\\\operatorname{L}` of order `k`\\n    with polynomial coefficients and inhomogeneous equation\\n    `\\\\operatorname{L} y = f`, where `f` is a polynomial, we seek\\n    for all rational solutions over field `K` of characteristic zero.\\n\\n    This procedure accepts only polynomials, however if you are\\n    interested in solving recurrence with rational coefficients\\n    then use ``rsolve`` which will pre-process the given equation\\n    and run this procedure with polynomial arguments.\\n\\n    The algorithm performs two basic steps:\\n\\n        (1) Compute polynomial `v(n)` which can be used as universal\\n            denominator of any rational solution of equation\\n            `\\\\operatorname{L} y = f`.\\n\\n        (2) Construct new linear difference equation by substitution\\n            `y(n) = u(n)/v(n)` and solve it for `u(n)` finding all its\\n            polynomial solutions. Return ``None`` if none were found.\\n\\n    The algorithm implemented here is a revised version of the original\\n    Abramov's algorithm, developed in 1989. The new approach is much\\n    simpler to implement and has better overall efficiency. This\\n    method can be easily adapted to the q-difference equations case.\\n\\n    Besides finding rational solutions alone, this functions is\\n    an important part of Hyper algorithm where it is used to find\\n    a particular solution for the inhomogeneous part of a recurrence.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.abc import x\\n    >>> from sympy.solvers.recurr import rsolve_ratio\\n    >>> rsolve_ratio([-2*x**3 + x**2 + 2*x - 1, 2*x**3 + x**2 - 6*x,\\n    ... - 2*x**3 - 11*x**2 - 18*x - 9, 2*x**3 + 13*x**2 + 22*x + 8], 0, x)\\n    C0*(2*x - 3)/(2*(x**2 - 1))\\n\\n    References\\n    ==========\\n\\n    .. [1] S. A. Abramov, Rational solutions of linear difference\\n           and q-difference equations with polynomial coefficients,\\n           in: T. Levelt, ed., Proc. ISSAC '95, ACM Press, New York,\\n           1995, 285-289\\n\\n    See Also\\n    ========\\n\\n    rsolve_hyper\\n    \"\n    f = sympify(f)\n    if not f.is_polynomial(n):\n        return None\n    coeffs = list(map(sympify, coeffs))\n    r = len(coeffs) - 1\n    (A, B) = (coeffs[r], coeffs[0])\n    A = A.subs(n, n - r).expand()\n    h = Dummy('h')\n    res = resultant(A, B.subs(n, n + h), n)\n    if not res.is_polynomial(h):\n        (p, q) = res.as_numer_denom()\n        res = quo(p, q, h)\n    nni_roots = list(roots(res, h, filter='Z', predicate=lambda r: r >= 0).keys())\n    if not nni_roots:\n        return rsolve_poly(coeffs, f, n, **hints)\n    else:\n        (C, numers) = (S.One, [S.Zero] * (r + 1))\n        for i in range(int(max(nni_roots)), -1, -1):\n            d = gcd(A, B.subs(n, n + i), n)\n            A = quo(A, d, n)\n            B = quo(B, d.subs(n, n - i), n)\n            C *= Mul(*[d.subs(n, n - j) for j in range(i + 1)])\n        denoms = [C.subs(n, n + i) for i in range(r + 1)]\n        for i in range(r + 1):\n            g = gcd(coeffs[i], denoms[i], n)\n            numers[i] = quo(coeffs[i], g, n)\n            denoms[i] = quo(denoms[i], g, n)\n        for i in range(r + 1):\n            numers[i] *= Mul(*denoms[:i] + denoms[i + 1:])\n        result = rsolve_poly(numers, f * Mul(*denoms), n, **hints)\n        if result is not None:\n            if hints.get('symbols', False):\n                return (simplify(result[0] / C), result[1])\n            else:\n                return simplify(result / C)\n        else:\n            return None",
            "def rsolve_ratio(coeffs, f, n, **hints):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Given linear recurrence operator `\\\\operatorname{L}` of order `k`\\n    with polynomial coefficients and inhomogeneous equation\\n    `\\\\operatorname{L} y = f`, where `f` is a polynomial, we seek\\n    for all rational solutions over field `K` of characteristic zero.\\n\\n    This procedure accepts only polynomials, however if you are\\n    interested in solving recurrence with rational coefficients\\n    then use ``rsolve`` which will pre-process the given equation\\n    and run this procedure with polynomial arguments.\\n\\n    The algorithm performs two basic steps:\\n\\n        (1) Compute polynomial `v(n)` which can be used as universal\\n            denominator of any rational solution of equation\\n            `\\\\operatorname{L} y = f`.\\n\\n        (2) Construct new linear difference equation by substitution\\n            `y(n) = u(n)/v(n)` and solve it for `u(n)` finding all its\\n            polynomial solutions. Return ``None`` if none were found.\\n\\n    The algorithm implemented here is a revised version of the original\\n    Abramov's algorithm, developed in 1989. The new approach is much\\n    simpler to implement and has better overall efficiency. This\\n    method can be easily adapted to the q-difference equations case.\\n\\n    Besides finding rational solutions alone, this functions is\\n    an important part of Hyper algorithm where it is used to find\\n    a particular solution for the inhomogeneous part of a recurrence.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.abc import x\\n    >>> from sympy.solvers.recurr import rsolve_ratio\\n    >>> rsolve_ratio([-2*x**3 + x**2 + 2*x - 1, 2*x**3 + x**2 - 6*x,\\n    ... - 2*x**3 - 11*x**2 - 18*x - 9, 2*x**3 + 13*x**2 + 22*x + 8], 0, x)\\n    C0*(2*x - 3)/(2*(x**2 - 1))\\n\\n    References\\n    ==========\\n\\n    .. [1] S. A. Abramov, Rational solutions of linear difference\\n           and q-difference equations with polynomial coefficients,\\n           in: T. Levelt, ed., Proc. ISSAC '95, ACM Press, New York,\\n           1995, 285-289\\n\\n    See Also\\n    ========\\n\\n    rsolve_hyper\\n    \"\n    f = sympify(f)\n    if not f.is_polynomial(n):\n        return None\n    coeffs = list(map(sympify, coeffs))\n    r = len(coeffs) - 1\n    (A, B) = (coeffs[r], coeffs[0])\n    A = A.subs(n, n - r).expand()\n    h = Dummy('h')\n    res = resultant(A, B.subs(n, n + h), n)\n    if not res.is_polynomial(h):\n        (p, q) = res.as_numer_denom()\n        res = quo(p, q, h)\n    nni_roots = list(roots(res, h, filter='Z', predicate=lambda r: r >= 0).keys())\n    if not nni_roots:\n        return rsolve_poly(coeffs, f, n, **hints)\n    else:\n        (C, numers) = (S.One, [S.Zero] * (r + 1))\n        for i in range(int(max(nni_roots)), -1, -1):\n            d = gcd(A, B.subs(n, n + i), n)\n            A = quo(A, d, n)\n            B = quo(B, d.subs(n, n - i), n)\n            C *= Mul(*[d.subs(n, n - j) for j in range(i + 1)])\n        denoms = [C.subs(n, n + i) for i in range(r + 1)]\n        for i in range(r + 1):\n            g = gcd(coeffs[i], denoms[i], n)\n            numers[i] = quo(coeffs[i], g, n)\n            denoms[i] = quo(denoms[i], g, n)\n        for i in range(r + 1):\n            numers[i] *= Mul(*denoms[:i] + denoms[i + 1:])\n        result = rsolve_poly(numers, f * Mul(*denoms), n, **hints)\n        if result is not None:\n            if hints.get('symbols', False):\n                return (simplify(result[0] / C), result[1])\n            else:\n                return simplify(result / C)\n        else:\n            return None",
            "def rsolve_ratio(coeffs, f, n, **hints):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Given linear recurrence operator `\\\\operatorname{L}` of order `k`\\n    with polynomial coefficients and inhomogeneous equation\\n    `\\\\operatorname{L} y = f`, where `f` is a polynomial, we seek\\n    for all rational solutions over field `K` of characteristic zero.\\n\\n    This procedure accepts only polynomials, however if you are\\n    interested in solving recurrence with rational coefficients\\n    then use ``rsolve`` which will pre-process the given equation\\n    and run this procedure with polynomial arguments.\\n\\n    The algorithm performs two basic steps:\\n\\n        (1) Compute polynomial `v(n)` which can be used as universal\\n            denominator of any rational solution of equation\\n            `\\\\operatorname{L} y = f`.\\n\\n        (2) Construct new linear difference equation by substitution\\n            `y(n) = u(n)/v(n)` and solve it for `u(n)` finding all its\\n            polynomial solutions. Return ``None`` if none were found.\\n\\n    The algorithm implemented here is a revised version of the original\\n    Abramov's algorithm, developed in 1989. The new approach is much\\n    simpler to implement and has better overall efficiency. This\\n    method can be easily adapted to the q-difference equations case.\\n\\n    Besides finding rational solutions alone, this functions is\\n    an important part of Hyper algorithm where it is used to find\\n    a particular solution for the inhomogeneous part of a recurrence.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.abc import x\\n    >>> from sympy.solvers.recurr import rsolve_ratio\\n    >>> rsolve_ratio([-2*x**3 + x**2 + 2*x - 1, 2*x**3 + x**2 - 6*x,\\n    ... - 2*x**3 - 11*x**2 - 18*x - 9, 2*x**3 + 13*x**2 + 22*x + 8], 0, x)\\n    C0*(2*x - 3)/(2*(x**2 - 1))\\n\\n    References\\n    ==========\\n\\n    .. [1] S. A. Abramov, Rational solutions of linear difference\\n           and q-difference equations with polynomial coefficients,\\n           in: T. Levelt, ed., Proc. ISSAC '95, ACM Press, New York,\\n           1995, 285-289\\n\\n    See Also\\n    ========\\n\\n    rsolve_hyper\\n    \"\n    f = sympify(f)\n    if not f.is_polynomial(n):\n        return None\n    coeffs = list(map(sympify, coeffs))\n    r = len(coeffs) - 1\n    (A, B) = (coeffs[r], coeffs[0])\n    A = A.subs(n, n - r).expand()\n    h = Dummy('h')\n    res = resultant(A, B.subs(n, n + h), n)\n    if not res.is_polynomial(h):\n        (p, q) = res.as_numer_denom()\n        res = quo(p, q, h)\n    nni_roots = list(roots(res, h, filter='Z', predicate=lambda r: r >= 0).keys())\n    if not nni_roots:\n        return rsolve_poly(coeffs, f, n, **hints)\n    else:\n        (C, numers) = (S.One, [S.Zero] * (r + 1))\n        for i in range(int(max(nni_roots)), -1, -1):\n            d = gcd(A, B.subs(n, n + i), n)\n            A = quo(A, d, n)\n            B = quo(B, d.subs(n, n - i), n)\n            C *= Mul(*[d.subs(n, n - j) for j in range(i + 1)])\n        denoms = [C.subs(n, n + i) for i in range(r + 1)]\n        for i in range(r + 1):\n            g = gcd(coeffs[i], denoms[i], n)\n            numers[i] = quo(coeffs[i], g, n)\n            denoms[i] = quo(denoms[i], g, n)\n        for i in range(r + 1):\n            numers[i] *= Mul(*denoms[:i] + denoms[i + 1:])\n        result = rsolve_poly(numers, f * Mul(*denoms), n, **hints)\n        if result is not None:\n            if hints.get('symbols', False):\n                return (simplify(result[0] / C), result[1])\n            else:\n                return simplify(result / C)\n        else:\n            return None"
        ]
    },
    {
        "func_name": "rsolve_hyper",
        "original": "def rsolve_hyper(coeffs, f, n, **hints):\n    \"\"\"\n    Given linear recurrence operator `\\\\operatorname{L}` of order `k`\n    with polynomial coefficients and inhomogeneous equation\n    `\\\\operatorname{L} y = f` we seek for all hypergeometric solutions\n    over field `K` of characteristic zero.\n\n    The inhomogeneous part can be either hypergeometric or a sum\n    of a fixed number of pairwise dissimilar hypergeometric terms.\n\n    The algorithm performs three basic steps:\n\n        (1) Group together similar hypergeometric terms in the\n            inhomogeneous part of `\\\\operatorname{L} y = f`, and find\n            particular solution using Abramov's algorithm.\n\n        (2) Compute generating set of `\\\\operatorname{L}` and find basis\n            in it, so that all solutions are linearly independent.\n\n        (3) Form final solution with the number of arbitrary\n            constants equal to dimension of basis of `\\\\operatorname{L}`.\n\n    Term `a(n)` is hypergeometric if it is annihilated by first order\n    linear difference equations with polynomial coefficients or, in\n    simpler words, if consecutive term ratio is a rational function.\n\n    The output of this procedure is a linear combination of fixed\n    number of hypergeometric terms. However the underlying method\n    can generate larger class of solutions - D'Alembertian terms.\n\n    Note also that this method not only computes the kernel of the\n    inhomogeneous equation, but also reduces in to a basis so that\n    solutions generated by this procedure are linearly independent\n\n    Examples\n    ========\n\n    >>> from sympy.solvers import rsolve_hyper\n    >>> from sympy.abc import x\n\n    >>> rsolve_hyper([-1, -1, 1], 0, x)\n    C0*(1/2 - sqrt(5)/2)**x + C1*(1/2 + sqrt(5)/2)**x\n\n    >>> rsolve_hyper([-1, 1], 1 + x, x)\n    C0 + x*(x + 1)/2\n\n    References\n    ==========\n\n    .. [1] M. Petkovsek, Hypergeometric solutions of linear recurrences\n           with polynomial coefficients, J. Symbolic Computation,\n           14 (1992), 243-264.\n\n    .. [2] M. Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.\n    \"\"\"\n    coeffs = list(map(sympify, coeffs))\n    f = sympify(f)\n    (r, kernel, symbols) = (len(coeffs) - 1, [], set())\n    if not f.is_zero:\n        if f.is_Add:\n            similar = {}\n            for g in f.expand().args:\n                if not g.is_hypergeometric(n):\n                    return None\n                for h in similar.keys():\n                    if hypersimilar(g, h, n):\n                        similar[h] += g\n                        break\n                else:\n                    similar[g] = S.Zero\n            inhomogeneous = [g + h for (g, h) in similar.items()]\n        elif f.is_hypergeometric(n):\n            inhomogeneous = [f]\n        else:\n            return None\n        for (i, g) in enumerate(inhomogeneous):\n            (coeff, polys) = (S.One, coeffs[:])\n            denoms = [S.One] * (r + 1)\n            s = hypersimp(g, n)\n            for j in range(1, r + 1):\n                coeff *= s.subs(n, n + j - 1)\n                (p, q) = coeff.as_numer_denom()\n                polys[j] *= p\n                denoms[j] = q\n            for j in range(r + 1):\n                polys[j] *= Mul(*denoms[:j] + denoms[j + 1:])\n            R = rsolve_ratio(polys, Mul(*denoms), n, symbols=True)\n            if R is not None:\n                (R, syms) = R\n                if syms:\n                    R = R.subs(zip(syms, [0] * len(syms)))\n            else:\n                R = rsolve_poly(polys, Mul(*denoms), n)\n            if R:\n                inhomogeneous[i] *= R\n            else:\n                return None\n            result = Add(*inhomogeneous)\n            result = simplify(result)\n    else:\n        result = S.Zero\n    Z = Dummy('Z')\n    (p, q) = (coeffs[0], coeffs[r].subs(n, n - r + 1))\n    p_factors = list(roots(p, n).keys())\n    q_factors = list(roots(q, n).keys())\n    factors = [(S.One, S.One)]\n    for p in p_factors:\n        for q in q_factors:\n            if p.is_integer and q.is_integer and (p <= q):\n                continue\n            else:\n                factors += [(n - p, n - q)]\n    p = [(n - p, S.One) for p in p_factors]\n    q = [(S.One, n - q) for q in q_factors]\n    factors = p + factors + q\n    for (A, B) in factors:\n        (polys, degrees) = ([], [])\n        D = A * B.subs(n, n + r - 1)\n        for i in range(r + 1):\n            a = Mul(*[A.subs(n, n + j) for j in range(i)])\n            b = Mul(*[B.subs(n, n + j) for j in range(i, r)])\n            poly = quo(coeffs[i] * a * b, D, n)\n            polys.append(poly.as_poly(n))\n            if not poly.is_zero:\n                degrees.append(polys[i].degree())\n        if degrees:\n            (d, poly) = (max(degrees), S.Zero)\n        else:\n            return None\n        for i in range(r + 1):\n            coeff = polys[i].nth(d)\n            if coeff is not S.Zero:\n                poly += coeff * Z ** i\n        for z in roots(poly, Z).keys():\n            if z.is_zero:\n                continue\n            recurr_coeffs = [polys[i].as_expr() * z ** i for i in range(r + 1)]\n            if d == 0 and 0 != Add(*[recurr_coeffs[j] * j for j in range(1, r + 1)]):\n                sol = [Symbol('C' + str(len(symbols)))]\n            else:\n                (sol, syms) = rsolve_poly(recurr_coeffs, 0, n, len(symbols), symbols=True)\n                sol = sol.collect(syms)\n                sol = [sol.coeff(s) for s in syms]\n            for C in sol:\n                ratio = z * A * C.subs(n, n + 1) / B / C\n                ratio = simplify(ratio)\n                n0 = 0\n                for n_root in roots(ratio.as_numer_denom()[1], n).keys():\n                    if n_root.has(I):\n                        return None\n                    elif (n0 < n_root + 1) == True:\n                        n0 = n_root + 1\n                K = product(ratio, (n, n0, n - 1))\n                if K.has(factorial, FallingFactorial, RisingFactorial):\n                    K = simplify(K)\n                if casoratian(kernel + [K], n, zero=False) != 0:\n                    kernel.append(K)\n    kernel.sort(key=default_sort_key)\n    sk = list(zip(numbered_symbols('C'), kernel))\n    for (C, ker) in sk:\n        result += C * ker\n    if hints.get('symbols', False):\n        symbols |= {s for (s, k) in sk}\n        return (result, list(symbols))\n    else:\n        return result",
        "mutated": [
            "def rsolve_hyper(coeffs, f, n, **hints):\n    if False:\n        i = 10\n    \"\\n    Given linear recurrence operator `\\\\operatorname{L}` of order `k`\\n    with polynomial coefficients and inhomogeneous equation\\n    `\\\\operatorname{L} y = f` we seek for all hypergeometric solutions\\n    over field `K` of characteristic zero.\\n\\n    The inhomogeneous part can be either hypergeometric or a sum\\n    of a fixed number of pairwise dissimilar hypergeometric terms.\\n\\n    The algorithm performs three basic steps:\\n\\n        (1) Group together similar hypergeometric terms in the\\n            inhomogeneous part of `\\\\operatorname{L} y = f`, and find\\n            particular solution using Abramov's algorithm.\\n\\n        (2) Compute generating set of `\\\\operatorname{L}` and find basis\\n            in it, so that all solutions are linearly independent.\\n\\n        (3) Form final solution with the number of arbitrary\\n            constants equal to dimension of basis of `\\\\operatorname{L}`.\\n\\n    Term `a(n)` is hypergeometric if it is annihilated by first order\\n    linear difference equations with polynomial coefficients or, in\\n    simpler words, if consecutive term ratio is a rational function.\\n\\n    The output of this procedure is a linear combination of fixed\\n    number of hypergeometric terms. However the underlying method\\n    can generate larger class of solutions - D'Alembertian terms.\\n\\n    Note also that this method not only computes the kernel of the\\n    inhomogeneous equation, but also reduces in to a basis so that\\n    solutions generated by this procedure are linearly independent\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.solvers import rsolve_hyper\\n    >>> from sympy.abc import x\\n\\n    >>> rsolve_hyper([-1, -1, 1], 0, x)\\n    C0*(1/2 - sqrt(5)/2)**x + C1*(1/2 + sqrt(5)/2)**x\\n\\n    >>> rsolve_hyper([-1, 1], 1 + x, x)\\n    C0 + x*(x + 1)/2\\n\\n    References\\n    ==========\\n\\n    .. [1] M. Petkovsek, Hypergeometric solutions of linear recurrences\\n           with polynomial coefficients, J. Symbolic Computation,\\n           14 (1992), 243-264.\\n\\n    .. [2] M. Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.\\n    \"\n    coeffs = list(map(sympify, coeffs))\n    f = sympify(f)\n    (r, kernel, symbols) = (len(coeffs) - 1, [], set())\n    if not f.is_zero:\n        if f.is_Add:\n            similar = {}\n            for g in f.expand().args:\n                if not g.is_hypergeometric(n):\n                    return None\n                for h in similar.keys():\n                    if hypersimilar(g, h, n):\n                        similar[h] += g\n                        break\n                else:\n                    similar[g] = S.Zero\n            inhomogeneous = [g + h for (g, h) in similar.items()]\n        elif f.is_hypergeometric(n):\n            inhomogeneous = [f]\n        else:\n            return None\n        for (i, g) in enumerate(inhomogeneous):\n            (coeff, polys) = (S.One, coeffs[:])\n            denoms = [S.One] * (r + 1)\n            s = hypersimp(g, n)\n            for j in range(1, r + 1):\n                coeff *= s.subs(n, n + j - 1)\n                (p, q) = coeff.as_numer_denom()\n                polys[j] *= p\n                denoms[j] = q\n            for j in range(r + 1):\n                polys[j] *= Mul(*denoms[:j] + denoms[j + 1:])\n            R = rsolve_ratio(polys, Mul(*denoms), n, symbols=True)\n            if R is not None:\n                (R, syms) = R\n                if syms:\n                    R = R.subs(zip(syms, [0] * len(syms)))\n            else:\n                R = rsolve_poly(polys, Mul(*denoms), n)\n            if R:\n                inhomogeneous[i] *= R\n            else:\n                return None\n            result = Add(*inhomogeneous)\n            result = simplify(result)\n    else:\n        result = S.Zero\n    Z = Dummy('Z')\n    (p, q) = (coeffs[0], coeffs[r].subs(n, n - r + 1))\n    p_factors = list(roots(p, n).keys())\n    q_factors = list(roots(q, n).keys())\n    factors = [(S.One, S.One)]\n    for p in p_factors:\n        for q in q_factors:\n            if p.is_integer and q.is_integer and (p <= q):\n                continue\n            else:\n                factors += [(n - p, n - q)]\n    p = [(n - p, S.One) for p in p_factors]\n    q = [(S.One, n - q) for q in q_factors]\n    factors = p + factors + q\n    for (A, B) in factors:\n        (polys, degrees) = ([], [])\n        D = A * B.subs(n, n + r - 1)\n        for i in range(r + 1):\n            a = Mul(*[A.subs(n, n + j) for j in range(i)])\n            b = Mul(*[B.subs(n, n + j) for j in range(i, r)])\n            poly = quo(coeffs[i] * a * b, D, n)\n            polys.append(poly.as_poly(n))\n            if not poly.is_zero:\n                degrees.append(polys[i].degree())\n        if degrees:\n            (d, poly) = (max(degrees), S.Zero)\n        else:\n            return None\n        for i in range(r + 1):\n            coeff = polys[i].nth(d)\n            if coeff is not S.Zero:\n                poly += coeff * Z ** i\n        for z in roots(poly, Z).keys():\n            if z.is_zero:\n                continue\n            recurr_coeffs = [polys[i].as_expr() * z ** i for i in range(r + 1)]\n            if d == 0 and 0 != Add(*[recurr_coeffs[j] * j for j in range(1, r + 1)]):\n                sol = [Symbol('C' + str(len(symbols)))]\n            else:\n                (sol, syms) = rsolve_poly(recurr_coeffs, 0, n, len(symbols), symbols=True)\n                sol = sol.collect(syms)\n                sol = [sol.coeff(s) for s in syms]\n            for C in sol:\n                ratio = z * A * C.subs(n, n + 1) / B / C\n                ratio = simplify(ratio)\n                n0 = 0\n                for n_root in roots(ratio.as_numer_denom()[1], n).keys():\n                    if n_root.has(I):\n                        return None\n                    elif (n0 < n_root + 1) == True:\n                        n0 = n_root + 1\n                K = product(ratio, (n, n0, n - 1))\n                if K.has(factorial, FallingFactorial, RisingFactorial):\n                    K = simplify(K)\n                if casoratian(kernel + [K], n, zero=False) != 0:\n                    kernel.append(K)\n    kernel.sort(key=default_sort_key)\n    sk = list(zip(numbered_symbols('C'), kernel))\n    for (C, ker) in sk:\n        result += C * ker\n    if hints.get('symbols', False):\n        symbols |= {s for (s, k) in sk}\n        return (result, list(symbols))\n    else:\n        return result",
            "def rsolve_hyper(coeffs, f, n, **hints):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Given linear recurrence operator `\\\\operatorname{L}` of order `k`\\n    with polynomial coefficients and inhomogeneous equation\\n    `\\\\operatorname{L} y = f` we seek for all hypergeometric solutions\\n    over field `K` of characteristic zero.\\n\\n    The inhomogeneous part can be either hypergeometric or a sum\\n    of a fixed number of pairwise dissimilar hypergeometric terms.\\n\\n    The algorithm performs three basic steps:\\n\\n        (1) Group together similar hypergeometric terms in the\\n            inhomogeneous part of `\\\\operatorname{L} y = f`, and find\\n            particular solution using Abramov's algorithm.\\n\\n        (2) Compute generating set of `\\\\operatorname{L}` and find basis\\n            in it, so that all solutions are linearly independent.\\n\\n        (3) Form final solution with the number of arbitrary\\n            constants equal to dimension of basis of `\\\\operatorname{L}`.\\n\\n    Term `a(n)` is hypergeometric if it is annihilated by first order\\n    linear difference equations with polynomial coefficients or, in\\n    simpler words, if consecutive term ratio is a rational function.\\n\\n    The output of this procedure is a linear combination of fixed\\n    number of hypergeometric terms. However the underlying method\\n    can generate larger class of solutions - D'Alembertian terms.\\n\\n    Note also that this method not only computes the kernel of the\\n    inhomogeneous equation, but also reduces in to a basis so that\\n    solutions generated by this procedure are linearly independent\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.solvers import rsolve_hyper\\n    >>> from sympy.abc import x\\n\\n    >>> rsolve_hyper([-1, -1, 1], 0, x)\\n    C0*(1/2 - sqrt(5)/2)**x + C1*(1/2 + sqrt(5)/2)**x\\n\\n    >>> rsolve_hyper([-1, 1], 1 + x, x)\\n    C0 + x*(x + 1)/2\\n\\n    References\\n    ==========\\n\\n    .. [1] M. Petkovsek, Hypergeometric solutions of linear recurrences\\n           with polynomial coefficients, J. Symbolic Computation,\\n           14 (1992), 243-264.\\n\\n    .. [2] M. Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.\\n    \"\n    coeffs = list(map(sympify, coeffs))\n    f = sympify(f)\n    (r, kernel, symbols) = (len(coeffs) - 1, [], set())\n    if not f.is_zero:\n        if f.is_Add:\n            similar = {}\n            for g in f.expand().args:\n                if not g.is_hypergeometric(n):\n                    return None\n                for h in similar.keys():\n                    if hypersimilar(g, h, n):\n                        similar[h] += g\n                        break\n                else:\n                    similar[g] = S.Zero\n            inhomogeneous = [g + h for (g, h) in similar.items()]\n        elif f.is_hypergeometric(n):\n            inhomogeneous = [f]\n        else:\n            return None\n        for (i, g) in enumerate(inhomogeneous):\n            (coeff, polys) = (S.One, coeffs[:])\n            denoms = [S.One] * (r + 1)\n            s = hypersimp(g, n)\n            for j in range(1, r + 1):\n                coeff *= s.subs(n, n + j - 1)\n                (p, q) = coeff.as_numer_denom()\n                polys[j] *= p\n                denoms[j] = q\n            for j in range(r + 1):\n                polys[j] *= Mul(*denoms[:j] + denoms[j + 1:])\n            R = rsolve_ratio(polys, Mul(*denoms), n, symbols=True)\n            if R is not None:\n                (R, syms) = R\n                if syms:\n                    R = R.subs(zip(syms, [0] * len(syms)))\n            else:\n                R = rsolve_poly(polys, Mul(*denoms), n)\n            if R:\n                inhomogeneous[i] *= R\n            else:\n                return None\n            result = Add(*inhomogeneous)\n            result = simplify(result)\n    else:\n        result = S.Zero\n    Z = Dummy('Z')\n    (p, q) = (coeffs[0], coeffs[r].subs(n, n - r + 1))\n    p_factors = list(roots(p, n).keys())\n    q_factors = list(roots(q, n).keys())\n    factors = [(S.One, S.One)]\n    for p in p_factors:\n        for q in q_factors:\n            if p.is_integer and q.is_integer and (p <= q):\n                continue\n            else:\n                factors += [(n - p, n - q)]\n    p = [(n - p, S.One) for p in p_factors]\n    q = [(S.One, n - q) for q in q_factors]\n    factors = p + factors + q\n    for (A, B) in factors:\n        (polys, degrees) = ([], [])\n        D = A * B.subs(n, n + r - 1)\n        for i in range(r + 1):\n            a = Mul(*[A.subs(n, n + j) for j in range(i)])\n            b = Mul(*[B.subs(n, n + j) for j in range(i, r)])\n            poly = quo(coeffs[i] * a * b, D, n)\n            polys.append(poly.as_poly(n))\n            if not poly.is_zero:\n                degrees.append(polys[i].degree())\n        if degrees:\n            (d, poly) = (max(degrees), S.Zero)\n        else:\n            return None\n        for i in range(r + 1):\n            coeff = polys[i].nth(d)\n            if coeff is not S.Zero:\n                poly += coeff * Z ** i\n        for z in roots(poly, Z).keys():\n            if z.is_zero:\n                continue\n            recurr_coeffs = [polys[i].as_expr() * z ** i for i in range(r + 1)]\n            if d == 0 and 0 != Add(*[recurr_coeffs[j] * j for j in range(1, r + 1)]):\n                sol = [Symbol('C' + str(len(symbols)))]\n            else:\n                (sol, syms) = rsolve_poly(recurr_coeffs, 0, n, len(symbols), symbols=True)\n                sol = sol.collect(syms)\n                sol = [sol.coeff(s) for s in syms]\n            for C in sol:\n                ratio = z * A * C.subs(n, n + 1) / B / C\n                ratio = simplify(ratio)\n                n0 = 0\n                for n_root in roots(ratio.as_numer_denom()[1], n).keys():\n                    if n_root.has(I):\n                        return None\n                    elif (n0 < n_root + 1) == True:\n                        n0 = n_root + 1\n                K = product(ratio, (n, n0, n - 1))\n                if K.has(factorial, FallingFactorial, RisingFactorial):\n                    K = simplify(K)\n                if casoratian(kernel + [K], n, zero=False) != 0:\n                    kernel.append(K)\n    kernel.sort(key=default_sort_key)\n    sk = list(zip(numbered_symbols('C'), kernel))\n    for (C, ker) in sk:\n        result += C * ker\n    if hints.get('symbols', False):\n        symbols |= {s for (s, k) in sk}\n        return (result, list(symbols))\n    else:\n        return result",
            "def rsolve_hyper(coeffs, f, n, **hints):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Given linear recurrence operator `\\\\operatorname{L}` of order `k`\\n    with polynomial coefficients and inhomogeneous equation\\n    `\\\\operatorname{L} y = f` we seek for all hypergeometric solutions\\n    over field `K` of characteristic zero.\\n\\n    The inhomogeneous part can be either hypergeometric or a sum\\n    of a fixed number of pairwise dissimilar hypergeometric terms.\\n\\n    The algorithm performs three basic steps:\\n\\n        (1) Group together similar hypergeometric terms in the\\n            inhomogeneous part of `\\\\operatorname{L} y = f`, and find\\n            particular solution using Abramov's algorithm.\\n\\n        (2) Compute generating set of `\\\\operatorname{L}` and find basis\\n            in it, so that all solutions are linearly independent.\\n\\n        (3) Form final solution with the number of arbitrary\\n            constants equal to dimension of basis of `\\\\operatorname{L}`.\\n\\n    Term `a(n)` is hypergeometric if it is annihilated by first order\\n    linear difference equations with polynomial coefficients or, in\\n    simpler words, if consecutive term ratio is a rational function.\\n\\n    The output of this procedure is a linear combination of fixed\\n    number of hypergeometric terms. However the underlying method\\n    can generate larger class of solutions - D'Alembertian terms.\\n\\n    Note also that this method not only computes the kernel of the\\n    inhomogeneous equation, but also reduces in to a basis so that\\n    solutions generated by this procedure are linearly independent\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.solvers import rsolve_hyper\\n    >>> from sympy.abc import x\\n\\n    >>> rsolve_hyper([-1, -1, 1], 0, x)\\n    C0*(1/2 - sqrt(5)/2)**x + C1*(1/2 + sqrt(5)/2)**x\\n\\n    >>> rsolve_hyper([-1, 1], 1 + x, x)\\n    C0 + x*(x + 1)/2\\n\\n    References\\n    ==========\\n\\n    .. [1] M. Petkovsek, Hypergeometric solutions of linear recurrences\\n           with polynomial coefficients, J. Symbolic Computation,\\n           14 (1992), 243-264.\\n\\n    .. [2] M. Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.\\n    \"\n    coeffs = list(map(sympify, coeffs))\n    f = sympify(f)\n    (r, kernel, symbols) = (len(coeffs) - 1, [], set())\n    if not f.is_zero:\n        if f.is_Add:\n            similar = {}\n            for g in f.expand().args:\n                if not g.is_hypergeometric(n):\n                    return None\n                for h in similar.keys():\n                    if hypersimilar(g, h, n):\n                        similar[h] += g\n                        break\n                else:\n                    similar[g] = S.Zero\n            inhomogeneous = [g + h for (g, h) in similar.items()]\n        elif f.is_hypergeometric(n):\n            inhomogeneous = [f]\n        else:\n            return None\n        for (i, g) in enumerate(inhomogeneous):\n            (coeff, polys) = (S.One, coeffs[:])\n            denoms = [S.One] * (r + 1)\n            s = hypersimp(g, n)\n            for j in range(1, r + 1):\n                coeff *= s.subs(n, n + j - 1)\n                (p, q) = coeff.as_numer_denom()\n                polys[j] *= p\n                denoms[j] = q\n            for j in range(r + 1):\n                polys[j] *= Mul(*denoms[:j] + denoms[j + 1:])\n            R = rsolve_ratio(polys, Mul(*denoms), n, symbols=True)\n            if R is not None:\n                (R, syms) = R\n                if syms:\n                    R = R.subs(zip(syms, [0] * len(syms)))\n            else:\n                R = rsolve_poly(polys, Mul(*denoms), n)\n            if R:\n                inhomogeneous[i] *= R\n            else:\n                return None\n            result = Add(*inhomogeneous)\n            result = simplify(result)\n    else:\n        result = S.Zero\n    Z = Dummy('Z')\n    (p, q) = (coeffs[0], coeffs[r].subs(n, n - r + 1))\n    p_factors = list(roots(p, n).keys())\n    q_factors = list(roots(q, n).keys())\n    factors = [(S.One, S.One)]\n    for p in p_factors:\n        for q in q_factors:\n            if p.is_integer and q.is_integer and (p <= q):\n                continue\n            else:\n                factors += [(n - p, n - q)]\n    p = [(n - p, S.One) for p in p_factors]\n    q = [(S.One, n - q) for q in q_factors]\n    factors = p + factors + q\n    for (A, B) in factors:\n        (polys, degrees) = ([], [])\n        D = A * B.subs(n, n + r - 1)\n        for i in range(r + 1):\n            a = Mul(*[A.subs(n, n + j) for j in range(i)])\n            b = Mul(*[B.subs(n, n + j) for j in range(i, r)])\n            poly = quo(coeffs[i] * a * b, D, n)\n            polys.append(poly.as_poly(n))\n            if not poly.is_zero:\n                degrees.append(polys[i].degree())\n        if degrees:\n            (d, poly) = (max(degrees), S.Zero)\n        else:\n            return None\n        for i in range(r + 1):\n            coeff = polys[i].nth(d)\n            if coeff is not S.Zero:\n                poly += coeff * Z ** i\n        for z in roots(poly, Z).keys():\n            if z.is_zero:\n                continue\n            recurr_coeffs = [polys[i].as_expr() * z ** i for i in range(r + 1)]\n            if d == 0 and 0 != Add(*[recurr_coeffs[j] * j for j in range(1, r + 1)]):\n                sol = [Symbol('C' + str(len(symbols)))]\n            else:\n                (sol, syms) = rsolve_poly(recurr_coeffs, 0, n, len(symbols), symbols=True)\n                sol = sol.collect(syms)\n                sol = [sol.coeff(s) for s in syms]\n            for C in sol:\n                ratio = z * A * C.subs(n, n + 1) / B / C\n                ratio = simplify(ratio)\n                n0 = 0\n                for n_root in roots(ratio.as_numer_denom()[1], n).keys():\n                    if n_root.has(I):\n                        return None\n                    elif (n0 < n_root + 1) == True:\n                        n0 = n_root + 1\n                K = product(ratio, (n, n0, n - 1))\n                if K.has(factorial, FallingFactorial, RisingFactorial):\n                    K = simplify(K)\n                if casoratian(kernel + [K], n, zero=False) != 0:\n                    kernel.append(K)\n    kernel.sort(key=default_sort_key)\n    sk = list(zip(numbered_symbols('C'), kernel))\n    for (C, ker) in sk:\n        result += C * ker\n    if hints.get('symbols', False):\n        symbols |= {s for (s, k) in sk}\n        return (result, list(symbols))\n    else:\n        return result",
            "def rsolve_hyper(coeffs, f, n, **hints):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Given linear recurrence operator `\\\\operatorname{L}` of order `k`\\n    with polynomial coefficients and inhomogeneous equation\\n    `\\\\operatorname{L} y = f` we seek for all hypergeometric solutions\\n    over field `K` of characteristic zero.\\n\\n    The inhomogeneous part can be either hypergeometric or a sum\\n    of a fixed number of pairwise dissimilar hypergeometric terms.\\n\\n    The algorithm performs three basic steps:\\n\\n        (1) Group together similar hypergeometric terms in the\\n            inhomogeneous part of `\\\\operatorname{L} y = f`, and find\\n            particular solution using Abramov's algorithm.\\n\\n        (2) Compute generating set of `\\\\operatorname{L}` and find basis\\n            in it, so that all solutions are linearly independent.\\n\\n        (3) Form final solution with the number of arbitrary\\n            constants equal to dimension of basis of `\\\\operatorname{L}`.\\n\\n    Term `a(n)` is hypergeometric if it is annihilated by first order\\n    linear difference equations with polynomial coefficients or, in\\n    simpler words, if consecutive term ratio is a rational function.\\n\\n    The output of this procedure is a linear combination of fixed\\n    number of hypergeometric terms. However the underlying method\\n    can generate larger class of solutions - D'Alembertian terms.\\n\\n    Note also that this method not only computes the kernel of the\\n    inhomogeneous equation, but also reduces in to a basis so that\\n    solutions generated by this procedure are linearly independent\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.solvers import rsolve_hyper\\n    >>> from sympy.abc import x\\n\\n    >>> rsolve_hyper([-1, -1, 1], 0, x)\\n    C0*(1/2 - sqrt(5)/2)**x + C1*(1/2 + sqrt(5)/2)**x\\n\\n    >>> rsolve_hyper([-1, 1], 1 + x, x)\\n    C0 + x*(x + 1)/2\\n\\n    References\\n    ==========\\n\\n    .. [1] M. Petkovsek, Hypergeometric solutions of linear recurrences\\n           with polynomial coefficients, J. Symbolic Computation,\\n           14 (1992), 243-264.\\n\\n    .. [2] M. Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.\\n    \"\n    coeffs = list(map(sympify, coeffs))\n    f = sympify(f)\n    (r, kernel, symbols) = (len(coeffs) - 1, [], set())\n    if not f.is_zero:\n        if f.is_Add:\n            similar = {}\n            for g in f.expand().args:\n                if not g.is_hypergeometric(n):\n                    return None\n                for h in similar.keys():\n                    if hypersimilar(g, h, n):\n                        similar[h] += g\n                        break\n                else:\n                    similar[g] = S.Zero\n            inhomogeneous = [g + h for (g, h) in similar.items()]\n        elif f.is_hypergeometric(n):\n            inhomogeneous = [f]\n        else:\n            return None\n        for (i, g) in enumerate(inhomogeneous):\n            (coeff, polys) = (S.One, coeffs[:])\n            denoms = [S.One] * (r + 1)\n            s = hypersimp(g, n)\n            for j in range(1, r + 1):\n                coeff *= s.subs(n, n + j - 1)\n                (p, q) = coeff.as_numer_denom()\n                polys[j] *= p\n                denoms[j] = q\n            for j in range(r + 1):\n                polys[j] *= Mul(*denoms[:j] + denoms[j + 1:])\n            R = rsolve_ratio(polys, Mul(*denoms), n, symbols=True)\n            if R is not None:\n                (R, syms) = R\n                if syms:\n                    R = R.subs(zip(syms, [0] * len(syms)))\n            else:\n                R = rsolve_poly(polys, Mul(*denoms), n)\n            if R:\n                inhomogeneous[i] *= R\n            else:\n                return None\n            result = Add(*inhomogeneous)\n            result = simplify(result)\n    else:\n        result = S.Zero\n    Z = Dummy('Z')\n    (p, q) = (coeffs[0], coeffs[r].subs(n, n - r + 1))\n    p_factors = list(roots(p, n).keys())\n    q_factors = list(roots(q, n).keys())\n    factors = [(S.One, S.One)]\n    for p in p_factors:\n        for q in q_factors:\n            if p.is_integer and q.is_integer and (p <= q):\n                continue\n            else:\n                factors += [(n - p, n - q)]\n    p = [(n - p, S.One) for p in p_factors]\n    q = [(S.One, n - q) for q in q_factors]\n    factors = p + factors + q\n    for (A, B) in factors:\n        (polys, degrees) = ([], [])\n        D = A * B.subs(n, n + r - 1)\n        for i in range(r + 1):\n            a = Mul(*[A.subs(n, n + j) for j in range(i)])\n            b = Mul(*[B.subs(n, n + j) for j in range(i, r)])\n            poly = quo(coeffs[i] * a * b, D, n)\n            polys.append(poly.as_poly(n))\n            if not poly.is_zero:\n                degrees.append(polys[i].degree())\n        if degrees:\n            (d, poly) = (max(degrees), S.Zero)\n        else:\n            return None\n        for i in range(r + 1):\n            coeff = polys[i].nth(d)\n            if coeff is not S.Zero:\n                poly += coeff * Z ** i\n        for z in roots(poly, Z).keys():\n            if z.is_zero:\n                continue\n            recurr_coeffs = [polys[i].as_expr() * z ** i for i in range(r + 1)]\n            if d == 0 and 0 != Add(*[recurr_coeffs[j] * j for j in range(1, r + 1)]):\n                sol = [Symbol('C' + str(len(symbols)))]\n            else:\n                (sol, syms) = rsolve_poly(recurr_coeffs, 0, n, len(symbols), symbols=True)\n                sol = sol.collect(syms)\n                sol = [sol.coeff(s) for s in syms]\n            for C in sol:\n                ratio = z * A * C.subs(n, n + 1) / B / C\n                ratio = simplify(ratio)\n                n0 = 0\n                for n_root in roots(ratio.as_numer_denom()[1], n).keys():\n                    if n_root.has(I):\n                        return None\n                    elif (n0 < n_root + 1) == True:\n                        n0 = n_root + 1\n                K = product(ratio, (n, n0, n - 1))\n                if K.has(factorial, FallingFactorial, RisingFactorial):\n                    K = simplify(K)\n                if casoratian(kernel + [K], n, zero=False) != 0:\n                    kernel.append(K)\n    kernel.sort(key=default_sort_key)\n    sk = list(zip(numbered_symbols('C'), kernel))\n    for (C, ker) in sk:\n        result += C * ker\n    if hints.get('symbols', False):\n        symbols |= {s for (s, k) in sk}\n        return (result, list(symbols))\n    else:\n        return result",
            "def rsolve_hyper(coeffs, f, n, **hints):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Given linear recurrence operator `\\\\operatorname{L}` of order `k`\\n    with polynomial coefficients and inhomogeneous equation\\n    `\\\\operatorname{L} y = f` we seek for all hypergeometric solutions\\n    over field `K` of characteristic zero.\\n\\n    The inhomogeneous part can be either hypergeometric or a sum\\n    of a fixed number of pairwise dissimilar hypergeometric terms.\\n\\n    The algorithm performs three basic steps:\\n\\n        (1) Group together similar hypergeometric terms in the\\n            inhomogeneous part of `\\\\operatorname{L} y = f`, and find\\n            particular solution using Abramov's algorithm.\\n\\n        (2) Compute generating set of `\\\\operatorname{L}` and find basis\\n            in it, so that all solutions are linearly independent.\\n\\n        (3) Form final solution with the number of arbitrary\\n            constants equal to dimension of basis of `\\\\operatorname{L}`.\\n\\n    Term `a(n)` is hypergeometric if it is annihilated by first order\\n    linear difference equations with polynomial coefficients or, in\\n    simpler words, if consecutive term ratio is a rational function.\\n\\n    The output of this procedure is a linear combination of fixed\\n    number of hypergeometric terms. However the underlying method\\n    can generate larger class of solutions - D'Alembertian terms.\\n\\n    Note also that this method not only computes the kernel of the\\n    inhomogeneous equation, but also reduces in to a basis so that\\n    solutions generated by this procedure are linearly independent\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.solvers import rsolve_hyper\\n    >>> from sympy.abc import x\\n\\n    >>> rsolve_hyper([-1, -1, 1], 0, x)\\n    C0*(1/2 - sqrt(5)/2)**x + C1*(1/2 + sqrt(5)/2)**x\\n\\n    >>> rsolve_hyper([-1, 1], 1 + x, x)\\n    C0 + x*(x + 1)/2\\n\\n    References\\n    ==========\\n\\n    .. [1] M. Petkovsek, Hypergeometric solutions of linear recurrences\\n           with polynomial coefficients, J. Symbolic Computation,\\n           14 (1992), 243-264.\\n\\n    .. [2] M. Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.\\n    \"\n    coeffs = list(map(sympify, coeffs))\n    f = sympify(f)\n    (r, kernel, symbols) = (len(coeffs) - 1, [], set())\n    if not f.is_zero:\n        if f.is_Add:\n            similar = {}\n            for g in f.expand().args:\n                if not g.is_hypergeometric(n):\n                    return None\n                for h in similar.keys():\n                    if hypersimilar(g, h, n):\n                        similar[h] += g\n                        break\n                else:\n                    similar[g] = S.Zero\n            inhomogeneous = [g + h for (g, h) in similar.items()]\n        elif f.is_hypergeometric(n):\n            inhomogeneous = [f]\n        else:\n            return None\n        for (i, g) in enumerate(inhomogeneous):\n            (coeff, polys) = (S.One, coeffs[:])\n            denoms = [S.One] * (r + 1)\n            s = hypersimp(g, n)\n            for j in range(1, r + 1):\n                coeff *= s.subs(n, n + j - 1)\n                (p, q) = coeff.as_numer_denom()\n                polys[j] *= p\n                denoms[j] = q\n            for j in range(r + 1):\n                polys[j] *= Mul(*denoms[:j] + denoms[j + 1:])\n            R = rsolve_ratio(polys, Mul(*denoms), n, symbols=True)\n            if R is not None:\n                (R, syms) = R\n                if syms:\n                    R = R.subs(zip(syms, [0] * len(syms)))\n            else:\n                R = rsolve_poly(polys, Mul(*denoms), n)\n            if R:\n                inhomogeneous[i] *= R\n            else:\n                return None\n            result = Add(*inhomogeneous)\n            result = simplify(result)\n    else:\n        result = S.Zero\n    Z = Dummy('Z')\n    (p, q) = (coeffs[0], coeffs[r].subs(n, n - r + 1))\n    p_factors = list(roots(p, n).keys())\n    q_factors = list(roots(q, n).keys())\n    factors = [(S.One, S.One)]\n    for p in p_factors:\n        for q in q_factors:\n            if p.is_integer and q.is_integer and (p <= q):\n                continue\n            else:\n                factors += [(n - p, n - q)]\n    p = [(n - p, S.One) for p in p_factors]\n    q = [(S.One, n - q) for q in q_factors]\n    factors = p + factors + q\n    for (A, B) in factors:\n        (polys, degrees) = ([], [])\n        D = A * B.subs(n, n + r - 1)\n        for i in range(r + 1):\n            a = Mul(*[A.subs(n, n + j) for j in range(i)])\n            b = Mul(*[B.subs(n, n + j) for j in range(i, r)])\n            poly = quo(coeffs[i] * a * b, D, n)\n            polys.append(poly.as_poly(n))\n            if not poly.is_zero:\n                degrees.append(polys[i].degree())\n        if degrees:\n            (d, poly) = (max(degrees), S.Zero)\n        else:\n            return None\n        for i in range(r + 1):\n            coeff = polys[i].nth(d)\n            if coeff is not S.Zero:\n                poly += coeff * Z ** i\n        for z in roots(poly, Z).keys():\n            if z.is_zero:\n                continue\n            recurr_coeffs = [polys[i].as_expr() * z ** i for i in range(r + 1)]\n            if d == 0 and 0 != Add(*[recurr_coeffs[j] * j for j in range(1, r + 1)]):\n                sol = [Symbol('C' + str(len(symbols)))]\n            else:\n                (sol, syms) = rsolve_poly(recurr_coeffs, 0, n, len(symbols), symbols=True)\n                sol = sol.collect(syms)\n                sol = [sol.coeff(s) for s in syms]\n            for C in sol:\n                ratio = z * A * C.subs(n, n + 1) / B / C\n                ratio = simplify(ratio)\n                n0 = 0\n                for n_root in roots(ratio.as_numer_denom()[1], n).keys():\n                    if n_root.has(I):\n                        return None\n                    elif (n0 < n_root + 1) == True:\n                        n0 = n_root + 1\n                K = product(ratio, (n, n0, n - 1))\n                if K.has(factorial, FallingFactorial, RisingFactorial):\n                    K = simplify(K)\n                if casoratian(kernel + [K], n, zero=False) != 0:\n                    kernel.append(K)\n    kernel.sort(key=default_sort_key)\n    sk = list(zip(numbered_symbols('C'), kernel))\n    for (C, ker) in sk:\n        result += C * ker\n    if hints.get('symbols', False):\n        symbols |= {s for (s, k) in sk}\n        return (result, list(symbols))\n    else:\n        return result"
        ]
    },
    {
        "func_name": "rsolve",
        "original": "def rsolve(f, y, init=None):\n    \"\"\"\n    Solve univariate recurrence with rational coefficients.\n\n    Given `k`-th order linear recurrence `\\\\operatorname{L} y = f`,\n    or equivalently:\n\n    .. math:: a_{k}(n) y(n+k) + a_{k-1}(n) y(n+k-1) +\n              \\\\cdots + a_{0}(n) y(n) = f(n)\n\n    where `a_{i}(n)`, for `i=0, \\\\ldots, k`, are polynomials or rational\n    functions in `n`, and `f` is a hypergeometric function or a sum\n    of a fixed number of pairwise dissimilar hypergeometric terms in\n    `n`, finds all solutions or returns ``None``, if none were found.\n\n    Initial conditions can be given as a dictionary in two forms:\n\n        (1) ``{  n_0  : v_0,   n_1  : v_1, ...,   n_m  : v_m}``\n        (2) ``{y(n_0) : v_0, y(n_1) : v_1, ..., y(n_m) : v_m}``\n\n    or as a list ``L`` of values:\n\n        ``L = [v_0, v_1, ..., v_m]``\n\n    where ``L[i] = v_i``, for `i=0, \\\\ldots, m`, maps to `y(n_i)`.\n\n    Examples\n    ========\n\n    Lets consider the following recurrence:\n\n    .. math:: (n - 1) y(n + 2) - (n^2 + 3 n - 2) y(n + 1) +\n              2 n (n + 1) y(n) = 0\n\n    >>> from sympy import Function, rsolve\n    >>> from sympy.abc import n\n    >>> y = Function('y')\n\n    >>> f = (n - 1)*y(n + 2) - (n**2 + 3*n - 2)*y(n + 1) + 2*n*(n + 1)*y(n)\n\n    >>> rsolve(f, y(n))\n    2**n*C0 + C1*factorial(n)\n\n    >>> rsolve(f, y(n), {y(0):0, y(1):3})\n    3*2**n - 3*factorial(n)\n\n    See Also\n    ========\n\n    rsolve_poly, rsolve_ratio, rsolve_hyper\n\n    \"\"\"\n    if isinstance(f, Equality):\n        f = f.lhs - f.rhs\n    n = y.args[0]\n    k = Wild('k', exclude=(n,))\n    f = f.expand().collect(y.func(Wild('m', integer=True)))\n    h_part = defaultdict(list)\n    i_part = []\n    for g in Add.make_args(f):\n        (coeff, dep) = g.as_coeff_mul(y.func)\n        if not dep:\n            i_part.append(coeff)\n            continue\n        for h in dep:\n            if h.is_Function and h.func == y.func:\n                result = h.args[0].match(n + k)\n                if result is not None:\n                    h_part[int(result[k])].append(coeff)\n                    continue\n            raise ValueError(\"'%s(%s + k)' expected, got '%s'\" % (y.func, n, h))\n    for k in h_part:\n        h_part[k] = Add(*h_part[k])\n    h_part.default_factory = lambda : 0\n    i_part = Add(*i_part)\n    for (k, coeff) in h_part.items():\n        h_part[k] = simplify(coeff)\n    common = S.One\n    if not i_part.is_zero and (not i_part.is_hypergeometric(n)) and (not (i_part.is_Add and all((x.is_hypergeometric(n) for x in i_part.expand().args)))):\n        raise ValueError(\"The independent term should be a sum of hypergeometric functions, got '%s'\" % i_part)\n    for coeff in h_part.values():\n        if coeff.is_rational_function(n):\n            if not coeff.is_polynomial(n):\n                common = lcm(common, coeff.as_numer_denom()[1], n)\n        else:\n            raise ValueError(\"Polynomial or rational function expected, got '%s'\" % coeff)\n    (i_numer, i_denom) = i_part.as_numer_denom()\n    if i_denom.is_polynomial(n):\n        common = lcm(common, i_denom, n)\n    if common is not S.One:\n        for (k, coeff) in h_part.items():\n            (numer, denom) = coeff.as_numer_denom()\n            h_part[k] = numer * quo(common, denom, n)\n        i_part = i_numer * quo(common, i_denom, n)\n    K_min = min(h_part.keys())\n    if K_min < 0:\n        K = abs(K_min)\n        H_part = defaultdict(lambda : S.Zero)\n        i_part = i_part.subs(n, n + K).expand()\n        common = common.subs(n, n + K).expand()\n        for (k, coeff) in h_part.items():\n            H_part[k + K] = coeff.subs(n, n + K).expand()\n    else:\n        H_part = h_part\n    K_max = max(H_part.keys())\n    coeffs = [H_part[i] for i in range(K_max + 1)]\n    result = rsolve_hyper(coeffs, -i_part, n, symbols=True)\n    if result is None:\n        return None\n    (solution, symbols) = result\n    if init in ({}, []):\n        init = None\n    if symbols and init is not None:\n        if isinstance(init, list):\n            init = {i: init[i] for i in range(len(init))}\n        equations = []\n        for (k, v) in init.items():\n            try:\n                i = int(k)\n            except TypeError:\n                if k.is_Function and k.func == y.func:\n                    i = int(k.args[0])\n                else:\n                    raise ValueError(\"Integer or term expected, got '%s'\" % k)\n            eq = solution.subs(n, i) - v\n            if eq.has(S.NaN):\n                eq = solution.limit(n, i) - v\n            equations.append(eq)\n        result = solve(equations, *symbols)\n        if not result:\n            return None\n        else:\n            solution = solution.subs(result)\n    return solution",
        "mutated": [
            "def rsolve(f, y, init=None):\n    if False:\n        i = 10\n    \"\\n    Solve univariate recurrence with rational coefficients.\\n\\n    Given `k`-th order linear recurrence `\\\\operatorname{L} y = f`,\\n    or equivalently:\\n\\n    .. math:: a_{k}(n) y(n+k) + a_{k-1}(n) y(n+k-1) +\\n              \\\\cdots + a_{0}(n) y(n) = f(n)\\n\\n    where `a_{i}(n)`, for `i=0, \\\\ldots, k`, are polynomials or rational\\n    functions in `n`, and `f` is a hypergeometric function or a sum\\n    of a fixed number of pairwise dissimilar hypergeometric terms in\\n    `n`, finds all solutions or returns ``None``, if none were found.\\n\\n    Initial conditions can be given as a dictionary in two forms:\\n\\n        (1) ``{  n_0  : v_0,   n_1  : v_1, ...,   n_m  : v_m}``\\n        (2) ``{y(n_0) : v_0, y(n_1) : v_1, ..., y(n_m) : v_m}``\\n\\n    or as a list ``L`` of values:\\n\\n        ``L = [v_0, v_1, ..., v_m]``\\n\\n    where ``L[i] = v_i``, for `i=0, \\\\ldots, m`, maps to `y(n_i)`.\\n\\n    Examples\\n    ========\\n\\n    Lets consider the following recurrence:\\n\\n    .. math:: (n - 1) y(n + 2) - (n^2 + 3 n - 2) y(n + 1) +\\n              2 n (n + 1) y(n) = 0\\n\\n    >>> from sympy import Function, rsolve\\n    >>> from sympy.abc import n\\n    >>> y = Function('y')\\n\\n    >>> f = (n - 1)*y(n + 2) - (n**2 + 3*n - 2)*y(n + 1) + 2*n*(n + 1)*y(n)\\n\\n    >>> rsolve(f, y(n))\\n    2**n*C0 + C1*factorial(n)\\n\\n    >>> rsolve(f, y(n), {y(0):0, y(1):3})\\n    3*2**n - 3*factorial(n)\\n\\n    See Also\\n    ========\\n\\n    rsolve_poly, rsolve_ratio, rsolve_hyper\\n\\n    \"\n    if isinstance(f, Equality):\n        f = f.lhs - f.rhs\n    n = y.args[0]\n    k = Wild('k', exclude=(n,))\n    f = f.expand().collect(y.func(Wild('m', integer=True)))\n    h_part = defaultdict(list)\n    i_part = []\n    for g in Add.make_args(f):\n        (coeff, dep) = g.as_coeff_mul(y.func)\n        if not dep:\n            i_part.append(coeff)\n            continue\n        for h in dep:\n            if h.is_Function and h.func == y.func:\n                result = h.args[0].match(n + k)\n                if result is not None:\n                    h_part[int(result[k])].append(coeff)\n                    continue\n            raise ValueError(\"'%s(%s + k)' expected, got '%s'\" % (y.func, n, h))\n    for k in h_part:\n        h_part[k] = Add(*h_part[k])\n    h_part.default_factory = lambda : 0\n    i_part = Add(*i_part)\n    for (k, coeff) in h_part.items():\n        h_part[k] = simplify(coeff)\n    common = S.One\n    if not i_part.is_zero and (not i_part.is_hypergeometric(n)) and (not (i_part.is_Add and all((x.is_hypergeometric(n) for x in i_part.expand().args)))):\n        raise ValueError(\"The independent term should be a sum of hypergeometric functions, got '%s'\" % i_part)\n    for coeff in h_part.values():\n        if coeff.is_rational_function(n):\n            if not coeff.is_polynomial(n):\n                common = lcm(common, coeff.as_numer_denom()[1], n)\n        else:\n            raise ValueError(\"Polynomial or rational function expected, got '%s'\" % coeff)\n    (i_numer, i_denom) = i_part.as_numer_denom()\n    if i_denom.is_polynomial(n):\n        common = lcm(common, i_denom, n)\n    if common is not S.One:\n        for (k, coeff) in h_part.items():\n            (numer, denom) = coeff.as_numer_denom()\n            h_part[k] = numer * quo(common, denom, n)\n        i_part = i_numer * quo(common, i_denom, n)\n    K_min = min(h_part.keys())\n    if K_min < 0:\n        K = abs(K_min)\n        H_part = defaultdict(lambda : S.Zero)\n        i_part = i_part.subs(n, n + K).expand()\n        common = common.subs(n, n + K).expand()\n        for (k, coeff) in h_part.items():\n            H_part[k + K] = coeff.subs(n, n + K).expand()\n    else:\n        H_part = h_part\n    K_max = max(H_part.keys())\n    coeffs = [H_part[i] for i in range(K_max + 1)]\n    result = rsolve_hyper(coeffs, -i_part, n, symbols=True)\n    if result is None:\n        return None\n    (solution, symbols) = result\n    if init in ({}, []):\n        init = None\n    if symbols and init is not None:\n        if isinstance(init, list):\n            init = {i: init[i] for i in range(len(init))}\n        equations = []\n        for (k, v) in init.items():\n            try:\n                i = int(k)\n            except TypeError:\n                if k.is_Function and k.func == y.func:\n                    i = int(k.args[0])\n                else:\n                    raise ValueError(\"Integer or term expected, got '%s'\" % k)\n            eq = solution.subs(n, i) - v\n            if eq.has(S.NaN):\n                eq = solution.limit(n, i) - v\n            equations.append(eq)\n        result = solve(equations, *symbols)\n        if not result:\n            return None\n        else:\n            solution = solution.subs(result)\n    return solution",
            "def rsolve(f, y, init=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Solve univariate recurrence with rational coefficients.\\n\\n    Given `k`-th order linear recurrence `\\\\operatorname{L} y = f`,\\n    or equivalently:\\n\\n    .. math:: a_{k}(n) y(n+k) + a_{k-1}(n) y(n+k-1) +\\n              \\\\cdots + a_{0}(n) y(n) = f(n)\\n\\n    where `a_{i}(n)`, for `i=0, \\\\ldots, k`, are polynomials or rational\\n    functions in `n`, and `f` is a hypergeometric function or a sum\\n    of a fixed number of pairwise dissimilar hypergeometric terms in\\n    `n`, finds all solutions or returns ``None``, if none were found.\\n\\n    Initial conditions can be given as a dictionary in two forms:\\n\\n        (1) ``{  n_0  : v_0,   n_1  : v_1, ...,   n_m  : v_m}``\\n        (2) ``{y(n_0) : v_0, y(n_1) : v_1, ..., y(n_m) : v_m}``\\n\\n    or as a list ``L`` of values:\\n\\n        ``L = [v_0, v_1, ..., v_m]``\\n\\n    where ``L[i] = v_i``, for `i=0, \\\\ldots, m`, maps to `y(n_i)`.\\n\\n    Examples\\n    ========\\n\\n    Lets consider the following recurrence:\\n\\n    .. math:: (n - 1) y(n + 2) - (n^2 + 3 n - 2) y(n + 1) +\\n              2 n (n + 1) y(n) = 0\\n\\n    >>> from sympy import Function, rsolve\\n    >>> from sympy.abc import n\\n    >>> y = Function('y')\\n\\n    >>> f = (n - 1)*y(n + 2) - (n**2 + 3*n - 2)*y(n + 1) + 2*n*(n + 1)*y(n)\\n\\n    >>> rsolve(f, y(n))\\n    2**n*C0 + C1*factorial(n)\\n\\n    >>> rsolve(f, y(n), {y(0):0, y(1):3})\\n    3*2**n - 3*factorial(n)\\n\\n    See Also\\n    ========\\n\\n    rsolve_poly, rsolve_ratio, rsolve_hyper\\n\\n    \"\n    if isinstance(f, Equality):\n        f = f.lhs - f.rhs\n    n = y.args[0]\n    k = Wild('k', exclude=(n,))\n    f = f.expand().collect(y.func(Wild('m', integer=True)))\n    h_part = defaultdict(list)\n    i_part = []\n    for g in Add.make_args(f):\n        (coeff, dep) = g.as_coeff_mul(y.func)\n        if not dep:\n            i_part.append(coeff)\n            continue\n        for h in dep:\n            if h.is_Function and h.func == y.func:\n                result = h.args[0].match(n + k)\n                if result is not None:\n                    h_part[int(result[k])].append(coeff)\n                    continue\n            raise ValueError(\"'%s(%s + k)' expected, got '%s'\" % (y.func, n, h))\n    for k in h_part:\n        h_part[k] = Add(*h_part[k])\n    h_part.default_factory = lambda : 0\n    i_part = Add(*i_part)\n    for (k, coeff) in h_part.items():\n        h_part[k] = simplify(coeff)\n    common = S.One\n    if not i_part.is_zero and (not i_part.is_hypergeometric(n)) and (not (i_part.is_Add and all((x.is_hypergeometric(n) for x in i_part.expand().args)))):\n        raise ValueError(\"The independent term should be a sum of hypergeometric functions, got '%s'\" % i_part)\n    for coeff in h_part.values():\n        if coeff.is_rational_function(n):\n            if not coeff.is_polynomial(n):\n                common = lcm(common, coeff.as_numer_denom()[1], n)\n        else:\n            raise ValueError(\"Polynomial or rational function expected, got '%s'\" % coeff)\n    (i_numer, i_denom) = i_part.as_numer_denom()\n    if i_denom.is_polynomial(n):\n        common = lcm(common, i_denom, n)\n    if common is not S.One:\n        for (k, coeff) in h_part.items():\n            (numer, denom) = coeff.as_numer_denom()\n            h_part[k] = numer * quo(common, denom, n)\n        i_part = i_numer * quo(common, i_denom, n)\n    K_min = min(h_part.keys())\n    if K_min < 0:\n        K = abs(K_min)\n        H_part = defaultdict(lambda : S.Zero)\n        i_part = i_part.subs(n, n + K).expand()\n        common = common.subs(n, n + K).expand()\n        for (k, coeff) in h_part.items():\n            H_part[k + K] = coeff.subs(n, n + K).expand()\n    else:\n        H_part = h_part\n    K_max = max(H_part.keys())\n    coeffs = [H_part[i] for i in range(K_max + 1)]\n    result = rsolve_hyper(coeffs, -i_part, n, symbols=True)\n    if result is None:\n        return None\n    (solution, symbols) = result\n    if init in ({}, []):\n        init = None\n    if symbols and init is not None:\n        if isinstance(init, list):\n            init = {i: init[i] for i in range(len(init))}\n        equations = []\n        for (k, v) in init.items():\n            try:\n                i = int(k)\n            except TypeError:\n                if k.is_Function and k.func == y.func:\n                    i = int(k.args[0])\n                else:\n                    raise ValueError(\"Integer or term expected, got '%s'\" % k)\n            eq = solution.subs(n, i) - v\n            if eq.has(S.NaN):\n                eq = solution.limit(n, i) - v\n            equations.append(eq)\n        result = solve(equations, *symbols)\n        if not result:\n            return None\n        else:\n            solution = solution.subs(result)\n    return solution",
            "def rsolve(f, y, init=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Solve univariate recurrence with rational coefficients.\\n\\n    Given `k`-th order linear recurrence `\\\\operatorname{L} y = f`,\\n    or equivalently:\\n\\n    .. math:: a_{k}(n) y(n+k) + a_{k-1}(n) y(n+k-1) +\\n              \\\\cdots + a_{0}(n) y(n) = f(n)\\n\\n    where `a_{i}(n)`, for `i=0, \\\\ldots, k`, are polynomials or rational\\n    functions in `n`, and `f` is a hypergeometric function or a sum\\n    of a fixed number of pairwise dissimilar hypergeometric terms in\\n    `n`, finds all solutions or returns ``None``, if none were found.\\n\\n    Initial conditions can be given as a dictionary in two forms:\\n\\n        (1) ``{  n_0  : v_0,   n_1  : v_1, ...,   n_m  : v_m}``\\n        (2) ``{y(n_0) : v_0, y(n_1) : v_1, ..., y(n_m) : v_m}``\\n\\n    or as a list ``L`` of values:\\n\\n        ``L = [v_0, v_1, ..., v_m]``\\n\\n    where ``L[i] = v_i``, for `i=0, \\\\ldots, m`, maps to `y(n_i)`.\\n\\n    Examples\\n    ========\\n\\n    Lets consider the following recurrence:\\n\\n    .. math:: (n - 1) y(n + 2) - (n^2 + 3 n - 2) y(n + 1) +\\n              2 n (n + 1) y(n) = 0\\n\\n    >>> from sympy import Function, rsolve\\n    >>> from sympy.abc import n\\n    >>> y = Function('y')\\n\\n    >>> f = (n - 1)*y(n + 2) - (n**2 + 3*n - 2)*y(n + 1) + 2*n*(n + 1)*y(n)\\n\\n    >>> rsolve(f, y(n))\\n    2**n*C0 + C1*factorial(n)\\n\\n    >>> rsolve(f, y(n), {y(0):0, y(1):3})\\n    3*2**n - 3*factorial(n)\\n\\n    See Also\\n    ========\\n\\n    rsolve_poly, rsolve_ratio, rsolve_hyper\\n\\n    \"\n    if isinstance(f, Equality):\n        f = f.lhs - f.rhs\n    n = y.args[0]\n    k = Wild('k', exclude=(n,))\n    f = f.expand().collect(y.func(Wild('m', integer=True)))\n    h_part = defaultdict(list)\n    i_part = []\n    for g in Add.make_args(f):\n        (coeff, dep) = g.as_coeff_mul(y.func)\n        if not dep:\n            i_part.append(coeff)\n            continue\n        for h in dep:\n            if h.is_Function and h.func == y.func:\n                result = h.args[0].match(n + k)\n                if result is not None:\n                    h_part[int(result[k])].append(coeff)\n                    continue\n            raise ValueError(\"'%s(%s + k)' expected, got '%s'\" % (y.func, n, h))\n    for k in h_part:\n        h_part[k] = Add(*h_part[k])\n    h_part.default_factory = lambda : 0\n    i_part = Add(*i_part)\n    for (k, coeff) in h_part.items():\n        h_part[k] = simplify(coeff)\n    common = S.One\n    if not i_part.is_zero and (not i_part.is_hypergeometric(n)) and (not (i_part.is_Add and all((x.is_hypergeometric(n) for x in i_part.expand().args)))):\n        raise ValueError(\"The independent term should be a sum of hypergeometric functions, got '%s'\" % i_part)\n    for coeff in h_part.values():\n        if coeff.is_rational_function(n):\n            if not coeff.is_polynomial(n):\n                common = lcm(common, coeff.as_numer_denom()[1], n)\n        else:\n            raise ValueError(\"Polynomial or rational function expected, got '%s'\" % coeff)\n    (i_numer, i_denom) = i_part.as_numer_denom()\n    if i_denom.is_polynomial(n):\n        common = lcm(common, i_denom, n)\n    if common is not S.One:\n        for (k, coeff) in h_part.items():\n            (numer, denom) = coeff.as_numer_denom()\n            h_part[k] = numer * quo(common, denom, n)\n        i_part = i_numer * quo(common, i_denom, n)\n    K_min = min(h_part.keys())\n    if K_min < 0:\n        K = abs(K_min)\n        H_part = defaultdict(lambda : S.Zero)\n        i_part = i_part.subs(n, n + K).expand()\n        common = common.subs(n, n + K).expand()\n        for (k, coeff) in h_part.items():\n            H_part[k + K] = coeff.subs(n, n + K).expand()\n    else:\n        H_part = h_part\n    K_max = max(H_part.keys())\n    coeffs = [H_part[i] for i in range(K_max + 1)]\n    result = rsolve_hyper(coeffs, -i_part, n, symbols=True)\n    if result is None:\n        return None\n    (solution, symbols) = result\n    if init in ({}, []):\n        init = None\n    if symbols and init is not None:\n        if isinstance(init, list):\n            init = {i: init[i] for i in range(len(init))}\n        equations = []\n        for (k, v) in init.items():\n            try:\n                i = int(k)\n            except TypeError:\n                if k.is_Function and k.func == y.func:\n                    i = int(k.args[0])\n                else:\n                    raise ValueError(\"Integer or term expected, got '%s'\" % k)\n            eq = solution.subs(n, i) - v\n            if eq.has(S.NaN):\n                eq = solution.limit(n, i) - v\n            equations.append(eq)\n        result = solve(equations, *symbols)\n        if not result:\n            return None\n        else:\n            solution = solution.subs(result)\n    return solution",
            "def rsolve(f, y, init=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Solve univariate recurrence with rational coefficients.\\n\\n    Given `k`-th order linear recurrence `\\\\operatorname{L} y = f`,\\n    or equivalently:\\n\\n    .. math:: a_{k}(n) y(n+k) + a_{k-1}(n) y(n+k-1) +\\n              \\\\cdots + a_{0}(n) y(n) = f(n)\\n\\n    where `a_{i}(n)`, for `i=0, \\\\ldots, k`, are polynomials or rational\\n    functions in `n`, and `f` is a hypergeometric function or a sum\\n    of a fixed number of pairwise dissimilar hypergeometric terms in\\n    `n`, finds all solutions or returns ``None``, if none were found.\\n\\n    Initial conditions can be given as a dictionary in two forms:\\n\\n        (1) ``{  n_0  : v_0,   n_1  : v_1, ...,   n_m  : v_m}``\\n        (2) ``{y(n_0) : v_0, y(n_1) : v_1, ..., y(n_m) : v_m}``\\n\\n    or as a list ``L`` of values:\\n\\n        ``L = [v_0, v_1, ..., v_m]``\\n\\n    where ``L[i] = v_i``, for `i=0, \\\\ldots, m`, maps to `y(n_i)`.\\n\\n    Examples\\n    ========\\n\\n    Lets consider the following recurrence:\\n\\n    .. math:: (n - 1) y(n + 2) - (n^2 + 3 n - 2) y(n + 1) +\\n              2 n (n + 1) y(n) = 0\\n\\n    >>> from sympy import Function, rsolve\\n    >>> from sympy.abc import n\\n    >>> y = Function('y')\\n\\n    >>> f = (n - 1)*y(n + 2) - (n**2 + 3*n - 2)*y(n + 1) + 2*n*(n + 1)*y(n)\\n\\n    >>> rsolve(f, y(n))\\n    2**n*C0 + C1*factorial(n)\\n\\n    >>> rsolve(f, y(n), {y(0):0, y(1):3})\\n    3*2**n - 3*factorial(n)\\n\\n    See Also\\n    ========\\n\\n    rsolve_poly, rsolve_ratio, rsolve_hyper\\n\\n    \"\n    if isinstance(f, Equality):\n        f = f.lhs - f.rhs\n    n = y.args[0]\n    k = Wild('k', exclude=(n,))\n    f = f.expand().collect(y.func(Wild('m', integer=True)))\n    h_part = defaultdict(list)\n    i_part = []\n    for g in Add.make_args(f):\n        (coeff, dep) = g.as_coeff_mul(y.func)\n        if not dep:\n            i_part.append(coeff)\n            continue\n        for h in dep:\n            if h.is_Function and h.func == y.func:\n                result = h.args[0].match(n + k)\n                if result is not None:\n                    h_part[int(result[k])].append(coeff)\n                    continue\n            raise ValueError(\"'%s(%s + k)' expected, got '%s'\" % (y.func, n, h))\n    for k in h_part:\n        h_part[k] = Add(*h_part[k])\n    h_part.default_factory = lambda : 0\n    i_part = Add(*i_part)\n    for (k, coeff) in h_part.items():\n        h_part[k] = simplify(coeff)\n    common = S.One\n    if not i_part.is_zero and (not i_part.is_hypergeometric(n)) and (not (i_part.is_Add and all((x.is_hypergeometric(n) for x in i_part.expand().args)))):\n        raise ValueError(\"The independent term should be a sum of hypergeometric functions, got '%s'\" % i_part)\n    for coeff in h_part.values():\n        if coeff.is_rational_function(n):\n            if not coeff.is_polynomial(n):\n                common = lcm(common, coeff.as_numer_denom()[1], n)\n        else:\n            raise ValueError(\"Polynomial or rational function expected, got '%s'\" % coeff)\n    (i_numer, i_denom) = i_part.as_numer_denom()\n    if i_denom.is_polynomial(n):\n        common = lcm(common, i_denom, n)\n    if common is not S.One:\n        for (k, coeff) in h_part.items():\n            (numer, denom) = coeff.as_numer_denom()\n            h_part[k] = numer * quo(common, denom, n)\n        i_part = i_numer * quo(common, i_denom, n)\n    K_min = min(h_part.keys())\n    if K_min < 0:\n        K = abs(K_min)\n        H_part = defaultdict(lambda : S.Zero)\n        i_part = i_part.subs(n, n + K).expand()\n        common = common.subs(n, n + K).expand()\n        for (k, coeff) in h_part.items():\n            H_part[k + K] = coeff.subs(n, n + K).expand()\n    else:\n        H_part = h_part\n    K_max = max(H_part.keys())\n    coeffs = [H_part[i] for i in range(K_max + 1)]\n    result = rsolve_hyper(coeffs, -i_part, n, symbols=True)\n    if result is None:\n        return None\n    (solution, symbols) = result\n    if init in ({}, []):\n        init = None\n    if symbols and init is not None:\n        if isinstance(init, list):\n            init = {i: init[i] for i in range(len(init))}\n        equations = []\n        for (k, v) in init.items():\n            try:\n                i = int(k)\n            except TypeError:\n                if k.is_Function and k.func == y.func:\n                    i = int(k.args[0])\n                else:\n                    raise ValueError(\"Integer or term expected, got '%s'\" % k)\n            eq = solution.subs(n, i) - v\n            if eq.has(S.NaN):\n                eq = solution.limit(n, i) - v\n            equations.append(eq)\n        result = solve(equations, *symbols)\n        if not result:\n            return None\n        else:\n            solution = solution.subs(result)\n    return solution",
            "def rsolve(f, y, init=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Solve univariate recurrence with rational coefficients.\\n\\n    Given `k`-th order linear recurrence `\\\\operatorname{L} y = f`,\\n    or equivalently:\\n\\n    .. math:: a_{k}(n) y(n+k) + a_{k-1}(n) y(n+k-1) +\\n              \\\\cdots + a_{0}(n) y(n) = f(n)\\n\\n    where `a_{i}(n)`, for `i=0, \\\\ldots, k`, are polynomials or rational\\n    functions in `n`, and `f` is a hypergeometric function or a sum\\n    of a fixed number of pairwise dissimilar hypergeometric terms in\\n    `n`, finds all solutions or returns ``None``, if none were found.\\n\\n    Initial conditions can be given as a dictionary in two forms:\\n\\n        (1) ``{  n_0  : v_0,   n_1  : v_1, ...,   n_m  : v_m}``\\n        (2) ``{y(n_0) : v_0, y(n_1) : v_1, ..., y(n_m) : v_m}``\\n\\n    or as a list ``L`` of values:\\n\\n        ``L = [v_0, v_1, ..., v_m]``\\n\\n    where ``L[i] = v_i``, for `i=0, \\\\ldots, m`, maps to `y(n_i)`.\\n\\n    Examples\\n    ========\\n\\n    Lets consider the following recurrence:\\n\\n    .. math:: (n - 1) y(n + 2) - (n^2 + 3 n - 2) y(n + 1) +\\n              2 n (n + 1) y(n) = 0\\n\\n    >>> from sympy import Function, rsolve\\n    >>> from sympy.abc import n\\n    >>> y = Function('y')\\n\\n    >>> f = (n - 1)*y(n + 2) - (n**2 + 3*n - 2)*y(n + 1) + 2*n*(n + 1)*y(n)\\n\\n    >>> rsolve(f, y(n))\\n    2**n*C0 + C1*factorial(n)\\n\\n    >>> rsolve(f, y(n), {y(0):0, y(1):3})\\n    3*2**n - 3*factorial(n)\\n\\n    See Also\\n    ========\\n\\n    rsolve_poly, rsolve_ratio, rsolve_hyper\\n\\n    \"\n    if isinstance(f, Equality):\n        f = f.lhs - f.rhs\n    n = y.args[0]\n    k = Wild('k', exclude=(n,))\n    f = f.expand().collect(y.func(Wild('m', integer=True)))\n    h_part = defaultdict(list)\n    i_part = []\n    for g in Add.make_args(f):\n        (coeff, dep) = g.as_coeff_mul(y.func)\n        if not dep:\n            i_part.append(coeff)\n            continue\n        for h in dep:\n            if h.is_Function and h.func == y.func:\n                result = h.args[0].match(n + k)\n                if result is not None:\n                    h_part[int(result[k])].append(coeff)\n                    continue\n            raise ValueError(\"'%s(%s + k)' expected, got '%s'\" % (y.func, n, h))\n    for k in h_part:\n        h_part[k] = Add(*h_part[k])\n    h_part.default_factory = lambda : 0\n    i_part = Add(*i_part)\n    for (k, coeff) in h_part.items():\n        h_part[k] = simplify(coeff)\n    common = S.One\n    if not i_part.is_zero and (not i_part.is_hypergeometric(n)) and (not (i_part.is_Add and all((x.is_hypergeometric(n) for x in i_part.expand().args)))):\n        raise ValueError(\"The independent term should be a sum of hypergeometric functions, got '%s'\" % i_part)\n    for coeff in h_part.values():\n        if coeff.is_rational_function(n):\n            if not coeff.is_polynomial(n):\n                common = lcm(common, coeff.as_numer_denom()[1], n)\n        else:\n            raise ValueError(\"Polynomial or rational function expected, got '%s'\" % coeff)\n    (i_numer, i_denom) = i_part.as_numer_denom()\n    if i_denom.is_polynomial(n):\n        common = lcm(common, i_denom, n)\n    if common is not S.One:\n        for (k, coeff) in h_part.items():\n            (numer, denom) = coeff.as_numer_denom()\n            h_part[k] = numer * quo(common, denom, n)\n        i_part = i_numer * quo(common, i_denom, n)\n    K_min = min(h_part.keys())\n    if K_min < 0:\n        K = abs(K_min)\n        H_part = defaultdict(lambda : S.Zero)\n        i_part = i_part.subs(n, n + K).expand()\n        common = common.subs(n, n + K).expand()\n        for (k, coeff) in h_part.items():\n            H_part[k + K] = coeff.subs(n, n + K).expand()\n    else:\n        H_part = h_part\n    K_max = max(H_part.keys())\n    coeffs = [H_part[i] for i in range(K_max + 1)]\n    result = rsolve_hyper(coeffs, -i_part, n, symbols=True)\n    if result is None:\n        return None\n    (solution, symbols) = result\n    if init in ({}, []):\n        init = None\n    if symbols and init is not None:\n        if isinstance(init, list):\n            init = {i: init[i] for i in range(len(init))}\n        equations = []\n        for (k, v) in init.items():\n            try:\n                i = int(k)\n            except TypeError:\n                if k.is_Function and k.func == y.func:\n                    i = int(k.args[0])\n                else:\n                    raise ValueError(\"Integer or term expected, got '%s'\" % k)\n            eq = solution.subs(n, i) - v\n            if eq.has(S.NaN):\n                eq = solution.limit(n, i) - v\n            equations.append(eq)\n        result = solve(equations, *symbols)\n        if not result:\n            return None\n        else:\n            solution = solution.subs(result)\n    return solution"
        ]
    }
]