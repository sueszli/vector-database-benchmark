[
    {
        "func_name": "egyptian_fraction",
        "original": "def egyptian_fraction(r, algorithm='Greedy'):\n    \"\"\"\n    Return the list of denominators of an Egyptian fraction\n    expansion [1]_ of the said rational `r`.\n\n    Parameters\n    ==========\n\n    r : Rational or (p, q)\n        a positive rational number, ``p/q``.\n    algorithm : { \"Greedy\", \"Graham Jewett\", \"Takenouchi\", \"Golomb\" }, optional\n        Denotes the algorithm to be used (the default is \"Greedy\").\n\n    Examples\n    ========\n\n    >>> from sympy import Rational\n    >>> from sympy.ntheory.egyptian_fraction import egyptian_fraction\n    >>> egyptian_fraction(Rational(3, 7))\n    [3, 11, 231]\n    >>> egyptian_fraction((3, 7), \"Graham Jewett\")\n    [7, 8, 9, 56, 57, 72, 3192]\n    >>> egyptian_fraction((3, 7), \"Takenouchi\")\n    [4, 7, 28]\n    >>> egyptian_fraction((3, 7), \"Golomb\")\n    [3, 15, 35]\n    >>> egyptian_fraction((11, 5), \"Golomb\")\n    [1, 2, 3, 4, 9, 234, 1118, 2580]\n\n    See Also\n    ========\n\n    sympy.core.numbers.Rational\n\n    Notes\n    =====\n\n    Currently the following algorithms are supported:\n\n    1) Greedy Algorithm\n\n       Also called the Fibonacci-Sylvester algorithm [2]_.\n       At each step, extract the largest unit fraction less\n       than the target and replace the target with the remainder.\n\n       It has some distinct properties:\n\n       a) Given `p/q` in lowest terms, generates an expansion of maximum\n          length `p`. Even as the numerators get large, the number of\n          terms is seldom more than a handful.\n\n       b) Uses minimal memory.\n\n       c) The terms can blow up (standard examples of this are 5/121 and\n          31/311).  The denominator is at most squared at each step\n          (doubly-exponential growth) and typically exhibits\n          singly-exponential growth.\n\n    2) Graham Jewett Algorithm\n\n       The algorithm suggested by the result of Graham and Jewett.\n       Note that this has a tendency to blow up: the length of the\n       resulting expansion is always ``2**(x/gcd(x, y)) - 1``.  See [3]_.\n\n    3) Takenouchi Algorithm\n\n       The algorithm suggested by Takenouchi (1921).\n       Differs from the Graham-Jewett algorithm only in the handling\n       of duplicates.  See [3]_.\n\n    4) Golomb's Algorithm\n\n       A method given by Golumb (1962), using modular arithmetic and\n       inverses.  It yields the same results as a method using continued\n       fractions proposed by Bleicher (1972).  See [4]_.\n\n    If the given rational is greater than or equal to 1, a greedy algorithm\n    of summing the harmonic sequence 1/1 + 1/2 + 1/3 + ... is used, taking\n    all the unit fractions of this sequence until adding one more would be\n    greater than the given number.  This list of denominators is prefixed\n    to the result from the requested algorithm used on the remainder.  For\n    example, if r is 8/3, using the Greedy algorithm, we get [1, 2, 3, 4,\n    5, 6, 7, 14, 420], where the beginning of the sequence, [1, 2, 3, 4, 5,\n    6, 7] is part of the harmonic sequence summing to 363/140, leaving a\n    remainder of 31/420, which yields [14, 420] by the Greedy algorithm.\n    The result of egyptian_fraction(Rational(8, 3), \"Golomb\") is [1, 2, 3,\n    4, 5, 6, 7, 14, 574, 2788, 6460, 11590, 33062, 113820], and so on.\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Egyptian_fraction\n    .. [2] https://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions\n    .. [3] https://www.ics.uci.edu/~eppstein/numth/egypt/conflict.html\n    .. [4] https://web.archive.org/web/20180413004012/https://ami.ektf.hu/uploads/papers/finalpdf/AMI_42_from129to134.pdf\n\n    \"\"\"\n    if not isinstance(r, Rational):\n        if isinstance(r, (Tuple, tuple)) and len(r) == 2:\n            r = Rational(*r)\n        else:\n            raise ValueError('Value must be a Rational or tuple of ints')\n    if r <= 0:\n        raise ValueError('Value must be positive')\n    (x, y) = r.as_numer_denom()\n    if y == 1 and x == 2:\n        return [Integer(i) for i in [1, 2, 3, 6]]\n    if x == y + 1:\n        return [S.One, y]\n    (prefix, rem) = egypt_harmonic(r)\n    if rem == 0:\n        return prefix\n    (x, y) = (rem.p, rem.q)\n    if algorithm == 'Greedy':\n        postfix = egypt_greedy(x, y)\n    elif algorithm == 'Graham Jewett':\n        postfix = egypt_graham_jewett(x, y)\n    elif algorithm == 'Takenouchi':\n        postfix = egypt_takenouchi(x, y)\n    elif algorithm == 'Golomb':\n        postfix = egypt_golomb(x, y)\n    else:\n        raise ValueError('Entered invalid algorithm')\n    return prefix + [Integer(i) for i in postfix]",
        "mutated": [
            "def egyptian_fraction(r, algorithm='Greedy'):\n    if False:\n        i = 10\n    '\\n    Return the list of denominators of an Egyptian fraction\\n    expansion [1]_ of the said rational `r`.\\n\\n    Parameters\\n    ==========\\n\\n    r : Rational or (p, q)\\n        a positive rational number, ``p/q``.\\n    algorithm : { \"Greedy\", \"Graham Jewett\", \"Takenouchi\", \"Golomb\" }, optional\\n        Denotes the algorithm to be used (the default is \"Greedy\").\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Rational\\n    >>> from sympy.ntheory.egyptian_fraction import egyptian_fraction\\n    >>> egyptian_fraction(Rational(3, 7))\\n    [3, 11, 231]\\n    >>> egyptian_fraction((3, 7), \"Graham Jewett\")\\n    [7, 8, 9, 56, 57, 72, 3192]\\n    >>> egyptian_fraction((3, 7), \"Takenouchi\")\\n    [4, 7, 28]\\n    >>> egyptian_fraction((3, 7), \"Golomb\")\\n    [3, 15, 35]\\n    >>> egyptian_fraction((11, 5), \"Golomb\")\\n    [1, 2, 3, 4, 9, 234, 1118, 2580]\\n\\n    See Also\\n    ========\\n\\n    sympy.core.numbers.Rational\\n\\n    Notes\\n    =====\\n\\n    Currently the following algorithms are supported:\\n\\n    1) Greedy Algorithm\\n\\n       Also called the Fibonacci-Sylvester algorithm [2]_.\\n       At each step, extract the largest unit fraction less\\n       than the target and replace the target with the remainder.\\n\\n       It has some distinct properties:\\n\\n       a) Given `p/q` in lowest terms, generates an expansion of maximum\\n          length `p`. Even as the numerators get large, the number of\\n          terms is seldom more than a handful.\\n\\n       b) Uses minimal memory.\\n\\n       c) The terms can blow up (standard examples of this are 5/121 and\\n          31/311).  The denominator is at most squared at each step\\n          (doubly-exponential growth) and typically exhibits\\n          singly-exponential growth.\\n\\n    2) Graham Jewett Algorithm\\n\\n       The algorithm suggested by the result of Graham and Jewett.\\n       Note that this has a tendency to blow up: the length of the\\n       resulting expansion is always ``2**(x/gcd(x, y)) - 1``.  See [3]_.\\n\\n    3) Takenouchi Algorithm\\n\\n       The algorithm suggested by Takenouchi (1921).\\n       Differs from the Graham-Jewett algorithm only in the handling\\n       of duplicates.  See [3]_.\\n\\n    4) Golomb\\'s Algorithm\\n\\n       A method given by Golumb (1962), using modular arithmetic and\\n       inverses.  It yields the same results as a method using continued\\n       fractions proposed by Bleicher (1972).  See [4]_.\\n\\n    If the given rational is greater than or equal to 1, a greedy algorithm\\n    of summing the harmonic sequence 1/1 + 1/2 + 1/3 + ... is used, taking\\n    all the unit fractions of this sequence until adding one more would be\\n    greater than the given number.  This list of denominators is prefixed\\n    to the result from the requested algorithm used on the remainder.  For\\n    example, if r is 8/3, using the Greedy algorithm, we get [1, 2, 3, 4,\\n    5, 6, 7, 14, 420], where the beginning of the sequence, [1, 2, 3, 4, 5,\\n    6, 7] is part of the harmonic sequence summing to 363/140, leaving a\\n    remainder of 31/420, which yields [14, 420] by the Greedy algorithm.\\n    The result of egyptian_fraction(Rational(8, 3), \"Golomb\") is [1, 2, 3,\\n    4, 5, 6, 7, 14, 574, 2788, 6460, 11590, 33062, 113820], and so on.\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Egyptian_fraction\\n    .. [2] https://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions\\n    .. [3] https://www.ics.uci.edu/~eppstein/numth/egypt/conflict.html\\n    .. [4] https://web.archive.org/web/20180413004012/https://ami.ektf.hu/uploads/papers/finalpdf/AMI_42_from129to134.pdf\\n\\n    '\n    if not isinstance(r, Rational):\n        if isinstance(r, (Tuple, tuple)) and len(r) == 2:\n            r = Rational(*r)\n        else:\n            raise ValueError('Value must be a Rational or tuple of ints')\n    if r <= 0:\n        raise ValueError('Value must be positive')\n    (x, y) = r.as_numer_denom()\n    if y == 1 and x == 2:\n        return [Integer(i) for i in [1, 2, 3, 6]]\n    if x == y + 1:\n        return [S.One, y]\n    (prefix, rem) = egypt_harmonic(r)\n    if rem == 0:\n        return prefix\n    (x, y) = (rem.p, rem.q)\n    if algorithm == 'Greedy':\n        postfix = egypt_greedy(x, y)\n    elif algorithm == 'Graham Jewett':\n        postfix = egypt_graham_jewett(x, y)\n    elif algorithm == 'Takenouchi':\n        postfix = egypt_takenouchi(x, y)\n    elif algorithm == 'Golomb':\n        postfix = egypt_golomb(x, y)\n    else:\n        raise ValueError('Entered invalid algorithm')\n    return prefix + [Integer(i) for i in postfix]",
            "def egyptian_fraction(r, algorithm='Greedy'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return the list of denominators of an Egyptian fraction\\n    expansion [1]_ of the said rational `r`.\\n\\n    Parameters\\n    ==========\\n\\n    r : Rational or (p, q)\\n        a positive rational number, ``p/q``.\\n    algorithm : { \"Greedy\", \"Graham Jewett\", \"Takenouchi\", \"Golomb\" }, optional\\n        Denotes the algorithm to be used (the default is \"Greedy\").\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Rational\\n    >>> from sympy.ntheory.egyptian_fraction import egyptian_fraction\\n    >>> egyptian_fraction(Rational(3, 7))\\n    [3, 11, 231]\\n    >>> egyptian_fraction((3, 7), \"Graham Jewett\")\\n    [7, 8, 9, 56, 57, 72, 3192]\\n    >>> egyptian_fraction((3, 7), \"Takenouchi\")\\n    [4, 7, 28]\\n    >>> egyptian_fraction((3, 7), \"Golomb\")\\n    [3, 15, 35]\\n    >>> egyptian_fraction((11, 5), \"Golomb\")\\n    [1, 2, 3, 4, 9, 234, 1118, 2580]\\n\\n    See Also\\n    ========\\n\\n    sympy.core.numbers.Rational\\n\\n    Notes\\n    =====\\n\\n    Currently the following algorithms are supported:\\n\\n    1) Greedy Algorithm\\n\\n       Also called the Fibonacci-Sylvester algorithm [2]_.\\n       At each step, extract the largest unit fraction less\\n       than the target and replace the target with the remainder.\\n\\n       It has some distinct properties:\\n\\n       a) Given `p/q` in lowest terms, generates an expansion of maximum\\n          length `p`. Even as the numerators get large, the number of\\n          terms is seldom more than a handful.\\n\\n       b) Uses minimal memory.\\n\\n       c) The terms can blow up (standard examples of this are 5/121 and\\n          31/311).  The denominator is at most squared at each step\\n          (doubly-exponential growth) and typically exhibits\\n          singly-exponential growth.\\n\\n    2) Graham Jewett Algorithm\\n\\n       The algorithm suggested by the result of Graham and Jewett.\\n       Note that this has a tendency to blow up: the length of the\\n       resulting expansion is always ``2**(x/gcd(x, y)) - 1``.  See [3]_.\\n\\n    3) Takenouchi Algorithm\\n\\n       The algorithm suggested by Takenouchi (1921).\\n       Differs from the Graham-Jewett algorithm only in the handling\\n       of duplicates.  See [3]_.\\n\\n    4) Golomb\\'s Algorithm\\n\\n       A method given by Golumb (1962), using modular arithmetic and\\n       inverses.  It yields the same results as a method using continued\\n       fractions proposed by Bleicher (1972).  See [4]_.\\n\\n    If the given rational is greater than or equal to 1, a greedy algorithm\\n    of summing the harmonic sequence 1/1 + 1/2 + 1/3 + ... is used, taking\\n    all the unit fractions of this sequence until adding one more would be\\n    greater than the given number.  This list of denominators is prefixed\\n    to the result from the requested algorithm used on the remainder.  For\\n    example, if r is 8/3, using the Greedy algorithm, we get [1, 2, 3, 4,\\n    5, 6, 7, 14, 420], where the beginning of the sequence, [1, 2, 3, 4, 5,\\n    6, 7] is part of the harmonic sequence summing to 363/140, leaving a\\n    remainder of 31/420, which yields [14, 420] by the Greedy algorithm.\\n    The result of egyptian_fraction(Rational(8, 3), \"Golomb\") is [1, 2, 3,\\n    4, 5, 6, 7, 14, 574, 2788, 6460, 11590, 33062, 113820], and so on.\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Egyptian_fraction\\n    .. [2] https://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions\\n    .. [3] https://www.ics.uci.edu/~eppstein/numth/egypt/conflict.html\\n    .. [4] https://web.archive.org/web/20180413004012/https://ami.ektf.hu/uploads/papers/finalpdf/AMI_42_from129to134.pdf\\n\\n    '\n    if not isinstance(r, Rational):\n        if isinstance(r, (Tuple, tuple)) and len(r) == 2:\n            r = Rational(*r)\n        else:\n            raise ValueError('Value must be a Rational or tuple of ints')\n    if r <= 0:\n        raise ValueError('Value must be positive')\n    (x, y) = r.as_numer_denom()\n    if y == 1 and x == 2:\n        return [Integer(i) for i in [1, 2, 3, 6]]\n    if x == y + 1:\n        return [S.One, y]\n    (prefix, rem) = egypt_harmonic(r)\n    if rem == 0:\n        return prefix\n    (x, y) = (rem.p, rem.q)\n    if algorithm == 'Greedy':\n        postfix = egypt_greedy(x, y)\n    elif algorithm == 'Graham Jewett':\n        postfix = egypt_graham_jewett(x, y)\n    elif algorithm == 'Takenouchi':\n        postfix = egypt_takenouchi(x, y)\n    elif algorithm == 'Golomb':\n        postfix = egypt_golomb(x, y)\n    else:\n        raise ValueError('Entered invalid algorithm')\n    return prefix + [Integer(i) for i in postfix]",
            "def egyptian_fraction(r, algorithm='Greedy'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return the list of denominators of an Egyptian fraction\\n    expansion [1]_ of the said rational `r`.\\n\\n    Parameters\\n    ==========\\n\\n    r : Rational or (p, q)\\n        a positive rational number, ``p/q``.\\n    algorithm : { \"Greedy\", \"Graham Jewett\", \"Takenouchi\", \"Golomb\" }, optional\\n        Denotes the algorithm to be used (the default is \"Greedy\").\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Rational\\n    >>> from sympy.ntheory.egyptian_fraction import egyptian_fraction\\n    >>> egyptian_fraction(Rational(3, 7))\\n    [3, 11, 231]\\n    >>> egyptian_fraction((3, 7), \"Graham Jewett\")\\n    [7, 8, 9, 56, 57, 72, 3192]\\n    >>> egyptian_fraction((3, 7), \"Takenouchi\")\\n    [4, 7, 28]\\n    >>> egyptian_fraction((3, 7), \"Golomb\")\\n    [3, 15, 35]\\n    >>> egyptian_fraction((11, 5), \"Golomb\")\\n    [1, 2, 3, 4, 9, 234, 1118, 2580]\\n\\n    See Also\\n    ========\\n\\n    sympy.core.numbers.Rational\\n\\n    Notes\\n    =====\\n\\n    Currently the following algorithms are supported:\\n\\n    1) Greedy Algorithm\\n\\n       Also called the Fibonacci-Sylvester algorithm [2]_.\\n       At each step, extract the largest unit fraction less\\n       than the target and replace the target with the remainder.\\n\\n       It has some distinct properties:\\n\\n       a) Given `p/q` in lowest terms, generates an expansion of maximum\\n          length `p`. Even as the numerators get large, the number of\\n          terms is seldom more than a handful.\\n\\n       b) Uses minimal memory.\\n\\n       c) The terms can blow up (standard examples of this are 5/121 and\\n          31/311).  The denominator is at most squared at each step\\n          (doubly-exponential growth) and typically exhibits\\n          singly-exponential growth.\\n\\n    2) Graham Jewett Algorithm\\n\\n       The algorithm suggested by the result of Graham and Jewett.\\n       Note that this has a tendency to blow up: the length of the\\n       resulting expansion is always ``2**(x/gcd(x, y)) - 1``.  See [3]_.\\n\\n    3) Takenouchi Algorithm\\n\\n       The algorithm suggested by Takenouchi (1921).\\n       Differs from the Graham-Jewett algorithm only in the handling\\n       of duplicates.  See [3]_.\\n\\n    4) Golomb\\'s Algorithm\\n\\n       A method given by Golumb (1962), using modular arithmetic and\\n       inverses.  It yields the same results as a method using continued\\n       fractions proposed by Bleicher (1972).  See [4]_.\\n\\n    If the given rational is greater than or equal to 1, a greedy algorithm\\n    of summing the harmonic sequence 1/1 + 1/2 + 1/3 + ... is used, taking\\n    all the unit fractions of this sequence until adding one more would be\\n    greater than the given number.  This list of denominators is prefixed\\n    to the result from the requested algorithm used on the remainder.  For\\n    example, if r is 8/3, using the Greedy algorithm, we get [1, 2, 3, 4,\\n    5, 6, 7, 14, 420], where the beginning of the sequence, [1, 2, 3, 4, 5,\\n    6, 7] is part of the harmonic sequence summing to 363/140, leaving a\\n    remainder of 31/420, which yields [14, 420] by the Greedy algorithm.\\n    The result of egyptian_fraction(Rational(8, 3), \"Golomb\") is [1, 2, 3,\\n    4, 5, 6, 7, 14, 574, 2788, 6460, 11590, 33062, 113820], and so on.\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Egyptian_fraction\\n    .. [2] https://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions\\n    .. [3] https://www.ics.uci.edu/~eppstein/numth/egypt/conflict.html\\n    .. [4] https://web.archive.org/web/20180413004012/https://ami.ektf.hu/uploads/papers/finalpdf/AMI_42_from129to134.pdf\\n\\n    '\n    if not isinstance(r, Rational):\n        if isinstance(r, (Tuple, tuple)) and len(r) == 2:\n            r = Rational(*r)\n        else:\n            raise ValueError('Value must be a Rational or tuple of ints')\n    if r <= 0:\n        raise ValueError('Value must be positive')\n    (x, y) = r.as_numer_denom()\n    if y == 1 and x == 2:\n        return [Integer(i) for i in [1, 2, 3, 6]]\n    if x == y + 1:\n        return [S.One, y]\n    (prefix, rem) = egypt_harmonic(r)\n    if rem == 0:\n        return prefix\n    (x, y) = (rem.p, rem.q)\n    if algorithm == 'Greedy':\n        postfix = egypt_greedy(x, y)\n    elif algorithm == 'Graham Jewett':\n        postfix = egypt_graham_jewett(x, y)\n    elif algorithm == 'Takenouchi':\n        postfix = egypt_takenouchi(x, y)\n    elif algorithm == 'Golomb':\n        postfix = egypt_golomb(x, y)\n    else:\n        raise ValueError('Entered invalid algorithm')\n    return prefix + [Integer(i) for i in postfix]",
            "def egyptian_fraction(r, algorithm='Greedy'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return the list of denominators of an Egyptian fraction\\n    expansion [1]_ of the said rational `r`.\\n\\n    Parameters\\n    ==========\\n\\n    r : Rational or (p, q)\\n        a positive rational number, ``p/q``.\\n    algorithm : { \"Greedy\", \"Graham Jewett\", \"Takenouchi\", \"Golomb\" }, optional\\n        Denotes the algorithm to be used (the default is \"Greedy\").\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Rational\\n    >>> from sympy.ntheory.egyptian_fraction import egyptian_fraction\\n    >>> egyptian_fraction(Rational(3, 7))\\n    [3, 11, 231]\\n    >>> egyptian_fraction((3, 7), \"Graham Jewett\")\\n    [7, 8, 9, 56, 57, 72, 3192]\\n    >>> egyptian_fraction((3, 7), \"Takenouchi\")\\n    [4, 7, 28]\\n    >>> egyptian_fraction((3, 7), \"Golomb\")\\n    [3, 15, 35]\\n    >>> egyptian_fraction((11, 5), \"Golomb\")\\n    [1, 2, 3, 4, 9, 234, 1118, 2580]\\n\\n    See Also\\n    ========\\n\\n    sympy.core.numbers.Rational\\n\\n    Notes\\n    =====\\n\\n    Currently the following algorithms are supported:\\n\\n    1) Greedy Algorithm\\n\\n       Also called the Fibonacci-Sylvester algorithm [2]_.\\n       At each step, extract the largest unit fraction less\\n       than the target and replace the target with the remainder.\\n\\n       It has some distinct properties:\\n\\n       a) Given `p/q` in lowest terms, generates an expansion of maximum\\n          length `p`. Even as the numerators get large, the number of\\n          terms is seldom more than a handful.\\n\\n       b) Uses minimal memory.\\n\\n       c) The terms can blow up (standard examples of this are 5/121 and\\n          31/311).  The denominator is at most squared at each step\\n          (doubly-exponential growth) and typically exhibits\\n          singly-exponential growth.\\n\\n    2) Graham Jewett Algorithm\\n\\n       The algorithm suggested by the result of Graham and Jewett.\\n       Note that this has a tendency to blow up: the length of the\\n       resulting expansion is always ``2**(x/gcd(x, y)) - 1``.  See [3]_.\\n\\n    3) Takenouchi Algorithm\\n\\n       The algorithm suggested by Takenouchi (1921).\\n       Differs from the Graham-Jewett algorithm only in the handling\\n       of duplicates.  See [3]_.\\n\\n    4) Golomb\\'s Algorithm\\n\\n       A method given by Golumb (1962), using modular arithmetic and\\n       inverses.  It yields the same results as a method using continued\\n       fractions proposed by Bleicher (1972).  See [4]_.\\n\\n    If the given rational is greater than or equal to 1, a greedy algorithm\\n    of summing the harmonic sequence 1/1 + 1/2 + 1/3 + ... is used, taking\\n    all the unit fractions of this sequence until adding one more would be\\n    greater than the given number.  This list of denominators is prefixed\\n    to the result from the requested algorithm used on the remainder.  For\\n    example, if r is 8/3, using the Greedy algorithm, we get [1, 2, 3, 4,\\n    5, 6, 7, 14, 420], where the beginning of the sequence, [1, 2, 3, 4, 5,\\n    6, 7] is part of the harmonic sequence summing to 363/140, leaving a\\n    remainder of 31/420, which yields [14, 420] by the Greedy algorithm.\\n    The result of egyptian_fraction(Rational(8, 3), \"Golomb\") is [1, 2, 3,\\n    4, 5, 6, 7, 14, 574, 2788, 6460, 11590, 33062, 113820], and so on.\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Egyptian_fraction\\n    .. [2] https://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions\\n    .. [3] https://www.ics.uci.edu/~eppstein/numth/egypt/conflict.html\\n    .. [4] https://web.archive.org/web/20180413004012/https://ami.ektf.hu/uploads/papers/finalpdf/AMI_42_from129to134.pdf\\n\\n    '\n    if not isinstance(r, Rational):\n        if isinstance(r, (Tuple, tuple)) and len(r) == 2:\n            r = Rational(*r)\n        else:\n            raise ValueError('Value must be a Rational or tuple of ints')\n    if r <= 0:\n        raise ValueError('Value must be positive')\n    (x, y) = r.as_numer_denom()\n    if y == 1 and x == 2:\n        return [Integer(i) for i in [1, 2, 3, 6]]\n    if x == y + 1:\n        return [S.One, y]\n    (prefix, rem) = egypt_harmonic(r)\n    if rem == 0:\n        return prefix\n    (x, y) = (rem.p, rem.q)\n    if algorithm == 'Greedy':\n        postfix = egypt_greedy(x, y)\n    elif algorithm == 'Graham Jewett':\n        postfix = egypt_graham_jewett(x, y)\n    elif algorithm == 'Takenouchi':\n        postfix = egypt_takenouchi(x, y)\n    elif algorithm == 'Golomb':\n        postfix = egypt_golomb(x, y)\n    else:\n        raise ValueError('Entered invalid algorithm')\n    return prefix + [Integer(i) for i in postfix]",
            "def egyptian_fraction(r, algorithm='Greedy'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return the list of denominators of an Egyptian fraction\\n    expansion [1]_ of the said rational `r`.\\n\\n    Parameters\\n    ==========\\n\\n    r : Rational or (p, q)\\n        a positive rational number, ``p/q``.\\n    algorithm : { \"Greedy\", \"Graham Jewett\", \"Takenouchi\", \"Golomb\" }, optional\\n        Denotes the algorithm to be used (the default is \"Greedy\").\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Rational\\n    >>> from sympy.ntheory.egyptian_fraction import egyptian_fraction\\n    >>> egyptian_fraction(Rational(3, 7))\\n    [3, 11, 231]\\n    >>> egyptian_fraction((3, 7), \"Graham Jewett\")\\n    [7, 8, 9, 56, 57, 72, 3192]\\n    >>> egyptian_fraction((3, 7), \"Takenouchi\")\\n    [4, 7, 28]\\n    >>> egyptian_fraction((3, 7), \"Golomb\")\\n    [3, 15, 35]\\n    >>> egyptian_fraction((11, 5), \"Golomb\")\\n    [1, 2, 3, 4, 9, 234, 1118, 2580]\\n\\n    See Also\\n    ========\\n\\n    sympy.core.numbers.Rational\\n\\n    Notes\\n    =====\\n\\n    Currently the following algorithms are supported:\\n\\n    1) Greedy Algorithm\\n\\n       Also called the Fibonacci-Sylvester algorithm [2]_.\\n       At each step, extract the largest unit fraction less\\n       than the target and replace the target with the remainder.\\n\\n       It has some distinct properties:\\n\\n       a) Given `p/q` in lowest terms, generates an expansion of maximum\\n          length `p`. Even as the numerators get large, the number of\\n          terms is seldom more than a handful.\\n\\n       b) Uses minimal memory.\\n\\n       c) The terms can blow up (standard examples of this are 5/121 and\\n          31/311).  The denominator is at most squared at each step\\n          (doubly-exponential growth) and typically exhibits\\n          singly-exponential growth.\\n\\n    2) Graham Jewett Algorithm\\n\\n       The algorithm suggested by the result of Graham and Jewett.\\n       Note that this has a tendency to blow up: the length of the\\n       resulting expansion is always ``2**(x/gcd(x, y)) - 1``.  See [3]_.\\n\\n    3) Takenouchi Algorithm\\n\\n       The algorithm suggested by Takenouchi (1921).\\n       Differs from the Graham-Jewett algorithm only in the handling\\n       of duplicates.  See [3]_.\\n\\n    4) Golomb\\'s Algorithm\\n\\n       A method given by Golumb (1962), using modular arithmetic and\\n       inverses.  It yields the same results as a method using continued\\n       fractions proposed by Bleicher (1972).  See [4]_.\\n\\n    If the given rational is greater than or equal to 1, a greedy algorithm\\n    of summing the harmonic sequence 1/1 + 1/2 + 1/3 + ... is used, taking\\n    all the unit fractions of this sequence until adding one more would be\\n    greater than the given number.  This list of denominators is prefixed\\n    to the result from the requested algorithm used on the remainder.  For\\n    example, if r is 8/3, using the Greedy algorithm, we get [1, 2, 3, 4,\\n    5, 6, 7, 14, 420], where the beginning of the sequence, [1, 2, 3, 4, 5,\\n    6, 7] is part of the harmonic sequence summing to 363/140, leaving a\\n    remainder of 31/420, which yields [14, 420] by the Greedy algorithm.\\n    The result of egyptian_fraction(Rational(8, 3), \"Golomb\") is [1, 2, 3,\\n    4, 5, 6, 7, 14, 574, 2788, 6460, 11590, 33062, 113820], and so on.\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Egyptian_fraction\\n    .. [2] https://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions\\n    .. [3] https://www.ics.uci.edu/~eppstein/numth/egypt/conflict.html\\n    .. [4] https://web.archive.org/web/20180413004012/https://ami.ektf.hu/uploads/papers/finalpdf/AMI_42_from129to134.pdf\\n\\n    '\n    if not isinstance(r, Rational):\n        if isinstance(r, (Tuple, tuple)) and len(r) == 2:\n            r = Rational(*r)\n        else:\n            raise ValueError('Value must be a Rational or tuple of ints')\n    if r <= 0:\n        raise ValueError('Value must be positive')\n    (x, y) = r.as_numer_denom()\n    if y == 1 and x == 2:\n        return [Integer(i) for i in [1, 2, 3, 6]]\n    if x == y + 1:\n        return [S.One, y]\n    (prefix, rem) = egypt_harmonic(r)\n    if rem == 0:\n        return prefix\n    (x, y) = (rem.p, rem.q)\n    if algorithm == 'Greedy':\n        postfix = egypt_greedy(x, y)\n    elif algorithm == 'Graham Jewett':\n        postfix = egypt_graham_jewett(x, y)\n    elif algorithm == 'Takenouchi':\n        postfix = egypt_takenouchi(x, y)\n    elif algorithm == 'Golomb':\n        postfix = egypt_golomb(x, y)\n    else:\n        raise ValueError('Entered invalid algorithm')\n    return prefix + [Integer(i) for i in postfix]"
        ]
    },
    {
        "func_name": "egypt_greedy",
        "original": "def egypt_greedy(x, y):\n    if x == 1:\n        return [y]\n    else:\n        a = -y % x\n        b = y * (y // x + 1)\n        c = gcd(a, b)\n        if c > 1:\n            (num, denom) = (a // c, b // c)\n        else:\n            (num, denom) = (a, b)\n        return [y // x + 1] + egypt_greedy(num, denom)",
        "mutated": [
            "def egypt_greedy(x, y):\n    if False:\n        i = 10\n    if x == 1:\n        return [y]\n    else:\n        a = -y % x\n        b = y * (y // x + 1)\n        c = gcd(a, b)\n        if c > 1:\n            (num, denom) = (a // c, b // c)\n        else:\n            (num, denom) = (a, b)\n        return [y // x + 1] + egypt_greedy(num, denom)",
            "def egypt_greedy(x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if x == 1:\n        return [y]\n    else:\n        a = -y % x\n        b = y * (y // x + 1)\n        c = gcd(a, b)\n        if c > 1:\n            (num, denom) = (a // c, b // c)\n        else:\n            (num, denom) = (a, b)\n        return [y // x + 1] + egypt_greedy(num, denom)",
            "def egypt_greedy(x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if x == 1:\n        return [y]\n    else:\n        a = -y % x\n        b = y * (y // x + 1)\n        c = gcd(a, b)\n        if c > 1:\n            (num, denom) = (a // c, b // c)\n        else:\n            (num, denom) = (a, b)\n        return [y // x + 1] + egypt_greedy(num, denom)",
            "def egypt_greedy(x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if x == 1:\n        return [y]\n    else:\n        a = -y % x\n        b = y * (y // x + 1)\n        c = gcd(a, b)\n        if c > 1:\n            (num, denom) = (a // c, b // c)\n        else:\n            (num, denom) = (a, b)\n        return [y // x + 1] + egypt_greedy(num, denom)",
            "def egypt_greedy(x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if x == 1:\n        return [y]\n    else:\n        a = -y % x\n        b = y * (y // x + 1)\n        c = gcd(a, b)\n        if c > 1:\n            (num, denom) = (a // c, b // c)\n        else:\n            (num, denom) = (a, b)\n        return [y // x + 1] + egypt_greedy(num, denom)"
        ]
    },
    {
        "func_name": "egypt_graham_jewett",
        "original": "def egypt_graham_jewett(x, y):\n    l = [y] * x\n    while len(l) != len(set(l)):\n        l.sort()\n        for i in range(len(l) - 1):\n            if l[i] == l[i + 1]:\n                break\n        l[i + 1] = l[i] + 1\n        l.append(l[i] * (l[i] + 1))\n    return sorted(l)",
        "mutated": [
            "def egypt_graham_jewett(x, y):\n    if False:\n        i = 10\n    l = [y] * x\n    while len(l) != len(set(l)):\n        l.sort()\n        for i in range(len(l) - 1):\n            if l[i] == l[i + 1]:\n                break\n        l[i + 1] = l[i] + 1\n        l.append(l[i] * (l[i] + 1))\n    return sorted(l)",
            "def egypt_graham_jewett(x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    l = [y] * x\n    while len(l) != len(set(l)):\n        l.sort()\n        for i in range(len(l) - 1):\n            if l[i] == l[i + 1]:\n                break\n        l[i + 1] = l[i] + 1\n        l.append(l[i] * (l[i] + 1))\n    return sorted(l)",
            "def egypt_graham_jewett(x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    l = [y] * x\n    while len(l) != len(set(l)):\n        l.sort()\n        for i in range(len(l) - 1):\n            if l[i] == l[i + 1]:\n                break\n        l[i + 1] = l[i] + 1\n        l.append(l[i] * (l[i] + 1))\n    return sorted(l)",
            "def egypt_graham_jewett(x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    l = [y] * x\n    while len(l) != len(set(l)):\n        l.sort()\n        for i in range(len(l) - 1):\n            if l[i] == l[i + 1]:\n                break\n        l[i + 1] = l[i] + 1\n        l.append(l[i] * (l[i] + 1))\n    return sorted(l)",
            "def egypt_graham_jewett(x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    l = [y] * x\n    while len(l) != len(set(l)):\n        l.sort()\n        for i in range(len(l) - 1):\n            if l[i] == l[i + 1]:\n                break\n        l[i + 1] = l[i] + 1\n        l.append(l[i] * (l[i] + 1))\n    return sorted(l)"
        ]
    },
    {
        "func_name": "egypt_takenouchi",
        "original": "def egypt_takenouchi(x, y):\n    if x == 3:\n        if y % 2 == 0:\n            return [y // 2, y]\n        i = (y - 1) // 2\n        j = i + 1\n        k = j + i\n        return [j, k, j * k]\n    l = [y] * x\n    while len(l) != len(set(l)):\n        l.sort()\n        for i in range(len(l) - 1):\n            if l[i] == l[i + 1]:\n                break\n        k = l[i]\n        if k % 2 == 0:\n            l[i] = l[i] // 2\n            del l[i + 1]\n        else:\n            (l[i], l[i + 1]) = ((k + 1) // 2, k * (k + 1) // 2)\n    return sorted(l)",
        "mutated": [
            "def egypt_takenouchi(x, y):\n    if False:\n        i = 10\n    if x == 3:\n        if y % 2 == 0:\n            return [y // 2, y]\n        i = (y - 1) // 2\n        j = i + 1\n        k = j + i\n        return [j, k, j * k]\n    l = [y] * x\n    while len(l) != len(set(l)):\n        l.sort()\n        for i in range(len(l) - 1):\n            if l[i] == l[i + 1]:\n                break\n        k = l[i]\n        if k % 2 == 0:\n            l[i] = l[i] // 2\n            del l[i + 1]\n        else:\n            (l[i], l[i + 1]) = ((k + 1) // 2, k * (k + 1) // 2)\n    return sorted(l)",
            "def egypt_takenouchi(x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if x == 3:\n        if y % 2 == 0:\n            return [y // 2, y]\n        i = (y - 1) // 2\n        j = i + 1\n        k = j + i\n        return [j, k, j * k]\n    l = [y] * x\n    while len(l) != len(set(l)):\n        l.sort()\n        for i in range(len(l) - 1):\n            if l[i] == l[i + 1]:\n                break\n        k = l[i]\n        if k % 2 == 0:\n            l[i] = l[i] // 2\n            del l[i + 1]\n        else:\n            (l[i], l[i + 1]) = ((k + 1) // 2, k * (k + 1) // 2)\n    return sorted(l)",
            "def egypt_takenouchi(x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if x == 3:\n        if y % 2 == 0:\n            return [y // 2, y]\n        i = (y - 1) // 2\n        j = i + 1\n        k = j + i\n        return [j, k, j * k]\n    l = [y] * x\n    while len(l) != len(set(l)):\n        l.sort()\n        for i in range(len(l) - 1):\n            if l[i] == l[i + 1]:\n                break\n        k = l[i]\n        if k % 2 == 0:\n            l[i] = l[i] // 2\n            del l[i + 1]\n        else:\n            (l[i], l[i + 1]) = ((k + 1) // 2, k * (k + 1) // 2)\n    return sorted(l)",
            "def egypt_takenouchi(x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if x == 3:\n        if y % 2 == 0:\n            return [y // 2, y]\n        i = (y - 1) // 2\n        j = i + 1\n        k = j + i\n        return [j, k, j * k]\n    l = [y] * x\n    while len(l) != len(set(l)):\n        l.sort()\n        for i in range(len(l) - 1):\n            if l[i] == l[i + 1]:\n                break\n        k = l[i]\n        if k % 2 == 0:\n            l[i] = l[i] // 2\n            del l[i + 1]\n        else:\n            (l[i], l[i + 1]) = ((k + 1) // 2, k * (k + 1) // 2)\n    return sorted(l)",
            "def egypt_takenouchi(x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if x == 3:\n        if y % 2 == 0:\n            return [y // 2, y]\n        i = (y - 1) // 2\n        j = i + 1\n        k = j + i\n        return [j, k, j * k]\n    l = [y] * x\n    while len(l) != len(set(l)):\n        l.sort()\n        for i in range(len(l) - 1):\n            if l[i] == l[i + 1]:\n                break\n        k = l[i]\n        if k % 2 == 0:\n            l[i] = l[i] // 2\n            del l[i + 1]\n        else:\n            (l[i], l[i + 1]) = ((k + 1) // 2, k * (k + 1) // 2)\n    return sorted(l)"
        ]
    },
    {
        "func_name": "egypt_golomb",
        "original": "def egypt_golomb(x, y):\n    if x == 1:\n        return [y]\n    xp = sympy.polys.ZZ.invert(int(x), int(y))\n    rv = [xp * y]\n    rv.extend(egypt_golomb((x * xp - 1) // y, xp))\n    return sorted(rv)",
        "mutated": [
            "def egypt_golomb(x, y):\n    if False:\n        i = 10\n    if x == 1:\n        return [y]\n    xp = sympy.polys.ZZ.invert(int(x), int(y))\n    rv = [xp * y]\n    rv.extend(egypt_golomb((x * xp - 1) // y, xp))\n    return sorted(rv)",
            "def egypt_golomb(x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if x == 1:\n        return [y]\n    xp = sympy.polys.ZZ.invert(int(x), int(y))\n    rv = [xp * y]\n    rv.extend(egypt_golomb((x * xp - 1) // y, xp))\n    return sorted(rv)",
            "def egypt_golomb(x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if x == 1:\n        return [y]\n    xp = sympy.polys.ZZ.invert(int(x), int(y))\n    rv = [xp * y]\n    rv.extend(egypt_golomb((x * xp - 1) // y, xp))\n    return sorted(rv)",
            "def egypt_golomb(x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if x == 1:\n        return [y]\n    xp = sympy.polys.ZZ.invert(int(x), int(y))\n    rv = [xp * y]\n    rv.extend(egypt_golomb((x * xp - 1) // y, xp))\n    return sorted(rv)",
            "def egypt_golomb(x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if x == 1:\n        return [y]\n    xp = sympy.polys.ZZ.invert(int(x), int(y))\n    rv = [xp * y]\n    rv.extend(egypt_golomb((x * xp - 1) // y, xp))\n    return sorted(rv)"
        ]
    },
    {
        "func_name": "egypt_harmonic",
        "original": "def egypt_harmonic(r):\n    rv = []\n    d = S.One\n    acc = S.Zero\n    while acc + 1 / d <= r:\n        acc += 1 / d\n        rv.append(d)\n        d += 1\n    return (rv, r - acc)",
        "mutated": [
            "def egypt_harmonic(r):\n    if False:\n        i = 10\n    rv = []\n    d = S.One\n    acc = S.Zero\n    while acc + 1 / d <= r:\n        acc += 1 / d\n        rv.append(d)\n        d += 1\n    return (rv, r - acc)",
            "def egypt_harmonic(r):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rv = []\n    d = S.One\n    acc = S.Zero\n    while acc + 1 / d <= r:\n        acc += 1 / d\n        rv.append(d)\n        d += 1\n    return (rv, r - acc)",
            "def egypt_harmonic(r):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rv = []\n    d = S.One\n    acc = S.Zero\n    while acc + 1 / d <= r:\n        acc += 1 / d\n        rv.append(d)\n        d += 1\n    return (rv, r - acc)",
            "def egypt_harmonic(r):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rv = []\n    d = S.One\n    acc = S.Zero\n    while acc + 1 / d <= r:\n        acc += 1 / d\n        rv.append(d)\n        d += 1\n    return (rv, r - acc)",
            "def egypt_harmonic(r):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rv = []\n    d = S.One\n    acc = S.Zero\n    while acc + 1 / d <= r:\n        acc += 1 / d\n        rv.append(d)\n        d += 1\n    return (rv, r - acc)"
        ]
    }
]