[
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    default_types_info = 'ExprId(\"RDX\", 64): char *'\n    archs = ['AMD64_unk', 'X86_32_unk', 'msp430_unk']\n    func = ida_funcs.get_func(idc.get_screen_ea())\n    func_addr = func.start_ea\n    start_addr = idc.read_selection_start()\n    if start_addr == idc.BADADDR:\n        start_addr = idc.get_screen_ea()\n    end_addr = idc.read_selection_end()\n    ida_kernwin.Form.__init__(self, 'BUTTON YES* Launch\\nBUTTON CANCEL NONE\\nType Propagation Settings\\n\\n{FormChangeCb}\\nAnalysis scope:\\n<Whole function:{rFunction}>\\n<From an address to the end of function:{rAddr}>\\n<Between two addresses:{r2Addr}>{cScope}>\\n\\n<Target function:{functionAddr}>\\n<Start address  :{startAddr}>\\n<End address    :{endAddr}>\\n\\n<Architecture/compilator :{arch}>\\n\\n<##Header file          :{headerFile}>\\n<Use a file for type information:{rTypeFile}>{cTypeFile}>\\n<##Types information   :{typeFile}>\\n<Types information     :{strTypesInfo}>\\n\\n<Unalias stack:{rUnaliasStack}>{cUnalias}>\\n', {'FormChangeCb': ida_kernwin.Form.FormChangeCb(self.OnFormChange), 'cScope': ida_kernwin.Form.RadGroupControl(('rFunction', 'rAddr', 'r2Addr')), 'functionAddr': ida_kernwin.Form.NumericInput(tp=ida_kernwin.Form.FT_RAWHEX, value=func_addr), 'startAddr': ida_kernwin.Form.NumericInput(tp=ida_kernwin.Form.FT_RAWHEX, value=start_addr), 'endAddr': ida_kernwin.Form.NumericInput(tp=ida_kernwin.Form.FT_RAWHEX, value=end_addr), 'arch': ida_kernwin.Form.DropdownListControl(items=archs, readonly=False, selval=archs[0]), 'headerFile': ida_kernwin.Form.FileInput(swidth=20, open=True), 'cTypeFile': ida_kernwin.Form.ChkGroupControl(('rTypeFile',)), 'typeFile': ida_kernwin.Form.FileInput(swidth=20, open=True), 'strTypesInfo': ida_kernwin.Form.MultiLineTextControl(text=default_types_info, flags=ida_kernwin.Form.MultiLineTextControl.TXTF_FIXEDFONT), 'cUnalias': ida_kernwin.Form.ChkGroupControl(('rUnaliasStack',))})\n    (form, args) = self.Compile()\n    form.rUnaliasStack.checked = True\n    form.rTypeFile.checked = True",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    default_types_info = 'ExprId(\"RDX\", 64): char *'\n    archs = ['AMD64_unk', 'X86_32_unk', 'msp430_unk']\n    func = ida_funcs.get_func(idc.get_screen_ea())\n    func_addr = func.start_ea\n    start_addr = idc.read_selection_start()\n    if start_addr == idc.BADADDR:\n        start_addr = idc.get_screen_ea()\n    end_addr = idc.read_selection_end()\n    ida_kernwin.Form.__init__(self, 'BUTTON YES* Launch\\nBUTTON CANCEL NONE\\nType Propagation Settings\\n\\n{FormChangeCb}\\nAnalysis scope:\\n<Whole function:{rFunction}>\\n<From an address to the end of function:{rAddr}>\\n<Between two addresses:{r2Addr}>{cScope}>\\n\\n<Target function:{functionAddr}>\\n<Start address  :{startAddr}>\\n<End address    :{endAddr}>\\n\\n<Architecture/compilator :{arch}>\\n\\n<##Header file          :{headerFile}>\\n<Use a file for type information:{rTypeFile}>{cTypeFile}>\\n<##Types information   :{typeFile}>\\n<Types information     :{strTypesInfo}>\\n\\n<Unalias stack:{rUnaliasStack}>{cUnalias}>\\n', {'FormChangeCb': ida_kernwin.Form.FormChangeCb(self.OnFormChange), 'cScope': ida_kernwin.Form.RadGroupControl(('rFunction', 'rAddr', 'r2Addr')), 'functionAddr': ida_kernwin.Form.NumericInput(tp=ida_kernwin.Form.FT_RAWHEX, value=func_addr), 'startAddr': ida_kernwin.Form.NumericInput(tp=ida_kernwin.Form.FT_RAWHEX, value=start_addr), 'endAddr': ida_kernwin.Form.NumericInput(tp=ida_kernwin.Form.FT_RAWHEX, value=end_addr), 'arch': ida_kernwin.Form.DropdownListControl(items=archs, readonly=False, selval=archs[0]), 'headerFile': ida_kernwin.Form.FileInput(swidth=20, open=True), 'cTypeFile': ida_kernwin.Form.ChkGroupControl(('rTypeFile',)), 'typeFile': ida_kernwin.Form.FileInput(swidth=20, open=True), 'strTypesInfo': ida_kernwin.Form.MultiLineTextControl(text=default_types_info, flags=ida_kernwin.Form.MultiLineTextControl.TXTF_FIXEDFONT), 'cUnalias': ida_kernwin.Form.ChkGroupControl(('rUnaliasStack',))})\n    (form, args) = self.Compile()\n    form.rUnaliasStack.checked = True\n    form.rTypeFile.checked = True",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    default_types_info = 'ExprId(\"RDX\", 64): char *'\n    archs = ['AMD64_unk', 'X86_32_unk', 'msp430_unk']\n    func = ida_funcs.get_func(idc.get_screen_ea())\n    func_addr = func.start_ea\n    start_addr = idc.read_selection_start()\n    if start_addr == idc.BADADDR:\n        start_addr = idc.get_screen_ea()\n    end_addr = idc.read_selection_end()\n    ida_kernwin.Form.__init__(self, 'BUTTON YES* Launch\\nBUTTON CANCEL NONE\\nType Propagation Settings\\n\\n{FormChangeCb}\\nAnalysis scope:\\n<Whole function:{rFunction}>\\n<From an address to the end of function:{rAddr}>\\n<Between two addresses:{r2Addr}>{cScope}>\\n\\n<Target function:{functionAddr}>\\n<Start address  :{startAddr}>\\n<End address    :{endAddr}>\\n\\n<Architecture/compilator :{arch}>\\n\\n<##Header file          :{headerFile}>\\n<Use a file for type information:{rTypeFile}>{cTypeFile}>\\n<##Types information   :{typeFile}>\\n<Types information     :{strTypesInfo}>\\n\\n<Unalias stack:{rUnaliasStack}>{cUnalias}>\\n', {'FormChangeCb': ida_kernwin.Form.FormChangeCb(self.OnFormChange), 'cScope': ida_kernwin.Form.RadGroupControl(('rFunction', 'rAddr', 'r2Addr')), 'functionAddr': ida_kernwin.Form.NumericInput(tp=ida_kernwin.Form.FT_RAWHEX, value=func_addr), 'startAddr': ida_kernwin.Form.NumericInput(tp=ida_kernwin.Form.FT_RAWHEX, value=start_addr), 'endAddr': ida_kernwin.Form.NumericInput(tp=ida_kernwin.Form.FT_RAWHEX, value=end_addr), 'arch': ida_kernwin.Form.DropdownListControl(items=archs, readonly=False, selval=archs[0]), 'headerFile': ida_kernwin.Form.FileInput(swidth=20, open=True), 'cTypeFile': ida_kernwin.Form.ChkGroupControl(('rTypeFile',)), 'typeFile': ida_kernwin.Form.FileInput(swidth=20, open=True), 'strTypesInfo': ida_kernwin.Form.MultiLineTextControl(text=default_types_info, flags=ida_kernwin.Form.MultiLineTextControl.TXTF_FIXEDFONT), 'cUnalias': ida_kernwin.Form.ChkGroupControl(('rUnaliasStack',))})\n    (form, args) = self.Compile()\n    form.rUnaliasStack.checked = True\n    form.rTypeFile.checked = True",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    default_types_info = 'ExprId(\"RDX\", 64): char *'\n    archs = ['AMD64_unk', 'X86_32_unk', 'msp430_unk']\n    func = ida_funcs.get_func(idc.get_screen_ea())\n    func_addr = func.start_ea\n    start_addr = idc.read_selection_start()\n    if start_addr == idc.BADADDR:\n        start_addr = idc.get_screen_ea()\n    end_addr = idc.read_selection_end()\n    ida_kernwin.Form.__init__(self, 'BUTTON YES* Launch\\nBUTTON CANCEL NONE\\nType Propagation Settings\\n\\n{FormChangeCb}\\nAnalysis scope:\\n<Whole function:{rFunction}>\\n<From an address to the end of function:{rAddr}>\\n<Between two addresses:{r2Addr}>{cScope}>\\n\\n<Target function:{functionAddr}>\\n<Start address  :{startAddr}>\\n<End address    :{endAddr}>\\n\\n<Architecture/compilator :{arch}>\\n\\n<##Header file          :{headerFile}>\\n<Use a file for type information:{rTypeFile}>{cTypeFile}>\\n<##Types information   :{typeFile}>\\n<Types information     :{strTypesInfo}>\\n\\n<Unalias stack:{rUnaliasStack}>{cUnalias}>\\n', {'FormChangeCb': ida_kernwin.Form.FormChangeCb(self.OnFormChange), 'cScope': ida_kernwin.Form.RadGroupControl(('rFunction', 'rAddr', 'r2Addr')), 'functionAddr': ida_kernwin.Form.NumericInput(tp=ida_kernwin.Form.FT_RAWHEX, value=func_addr), 'startAddr': ida_kernwin.Form.NumericInput(tp=ida_kernwin.Form.FT_RAWHEX, value=start_addr), 'endAddr': ida_kernwin.Form.NumericInput(tp=ida_kernwin.Form.FT_RAWHEX, value=end_addr), 'arch': ida_kernwin.Form.DropdownListControl(items=archs, readonly=False, selval=archs[0]), 'headerFile': ida_kernwin.Form.FileInput(swidth=20, open=True), 'cTypeFile': ida_kernwin.Form.ChkGroupControl(('rTypeFile',)), 'typeFile': ida_kernwin.Form.FileInput(swidth=20, open=True), 'strTypesInfo': ida_kernwin.Form.MultiLineTextControl(text=default_types_info, flags=ida_kernwin.Form.MultiLineTextControl.TXTF_FIXEDFONT), 'cUnalias': ida_kernwin.Form.ChkGroupControl(('rUnaliasStack',))})\n    (form, args) = self.Compile()\n    form.rUnaliasStack.checked = True\n    form.rTypeFile.checked = True",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    default_types_info = 'ExprId(\"RDX\", 64): char *'\n    archs = ['AMD64_unk', 'X86_32_unk', 'msp430_unk']\n    func = ida_funcs.get_func(idc.get_screen_ea())\n    func_addr = func.start_ea\n    start_addr = idc.read_selection_start()\n    if start_addr == idc.BADADDR:\n        start_addr = idc.get_screen_ea()\n    end_addr = idc.read_selection_end()\n    ida_kernwin.Form.__init__(self, 'BUTTON YES* Launch\\nBUTTON CANCEL NONE\\nType Propagation Settings\\n\\n{FormChangeCb}\\nAnalysis scope:\\n<Whole function:{rFunction}>\\n<From an address to the end of function:{rAddr}>\\n<Between two addresses:{r2Addr}>{cScope}>\\n\\n<Target function:{functionAddr}>\\n<Start address  :{startAddr}>\\n<End address    :{endAddr}>\\n\\n<Architecture/compilator :{arch}>\\n\\n<##Header file          :{headerFile}>\\n<Use a file for type information:{rTypeFile}>{cTypeFile}>\\n<##Types information   :{typeFile}>\\n<Types information     :{strTypesInfo}>\\n\\n<Unalias stack:{rUnaliasStack}>{cUnalias}>\\n', {'FormChangeCb': ida_kernwin.Form.FormChangeCb(self.OnFormChange), 'cScope': ida_kernwin.Form.RadGroupControl(('rFunction', 'rAddr', 'r2Addr')), 'functionAddr': ida_kernwin.Form.NumericInput(tp=ida_kernwin.Form.FT_RAWHEX, value=func_addr), 'startAddr': ida_kernwin.Form.NumericInput(tp=ida_kernwin.Form.FT_RAWHEX, value=start_addr), 'endAddr': ida_kernwin.Form.NumericInput(tp=ida_kernwin.Form.FT_RAWHEX, value=end_addr), 'arch': ida_kernwin.Form.DropdownListControl(items=archs, readonly=False, selval=archs[0]), 'headerFile': ida_kernwin.Form.FileInput(swidth=20, open=True), 'cTypeFile': ida_kernwin.Form.ChkGroupControl(('rTypeFile',)), 'typeFile': ida_kernwin.Form.FileInput(swidth=20, open=True), 'strTypesInfo': ida_kernwin.Form.MultiLineTextControl(text=default_types_info, flags=ida_kernwin.Form.MultiLineTextControl.TXTF_FIXEDFONT), 'cUnalias': ida_kernwin.Form.ChkGroupControl(('rUnaliasStack',))})\n    (form, args) = self.Compile()\n    form.rUnaliasStack.checked = True\n    form.rTypeFile.checked = True",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    default_types_info = 'ExprId(\"RDX\", 64): char *'\n    archs = ['AMD64_unk', 'X86_32_unk', 'msp430_unk']\n    func = ida_funcs.get_func(idc.get_screen_ea())\n    func_addr = func.start_ea\n    start_addr = idc.read_selection_start()\n    if start_addr == idc.BADADDR:\n        start_addr = idc.get_screen_ea()\n    end_addr = idc.read_selection_end()\n    ida_kernwin.Form.__init__(self, 'BUTTON YES* Launch\\nBUTTON CANCEL NONE\\nType Propagation Settings\\n\\n{FormChangeCb}\\nAnalysis scope:\\n<Whole function:{rFunction}>\\n<From an address to the end of function:{rAddr}>\\n<Between two addresses:{r2Addr}>{cScope}>\\n\\n<Target function:{functionAddr}>\\n<Start address  :{startAddr}>\\n<End address    :{endAddr}>\\n\\n<Architecture/compilator :{arch}>\\n\\n<##Header file          :{headerFile}>\\n<Use a file for type information:{rTypeFile}>{cTypeFile}>\\n<##Types information   :{typeFile}>\\n<Types information     :{strTypesInfo}>\\n\\n<Unalias stack:{rUnaliasStack}>{cUnalias}>\\n', {'FormChangeCb': ida_kernwin.Form.FormChangeCb(self.OnFormChange), 'cScope': ida_kernwin.Form.RadGroupControl(('rFunction', 'rAddr', 'r2Addr')), 'functionAddr': ida_kernwin.Form.NumericInput(tp=ida_kernwin.Form.FT_RAWHEX, value=func_addr), 'startAddr': ida_kernwin.Form.NumericInput(tp=ida_kernwin.Form.FT_RAWHEX, value=start_addr), 'endAddr': ida_kernwin.Form.NumericInput(tp=ida_kernwin.Form.FT_RAWHEX, value=end_addr), 'arch': ida_kernwin.Form.DropdownListControl(items=archs, readonly=False, selval=archs[0]), 'headerFile': ida_kernwin.Form.FileInput(swidth=20, open=True), 'cTypeFile': ida_kernwin.Form.ChkGroupControl(('rTypeFile',)), 'typeFile': ida_kernwin.Form.FileInput(swidth=20, open=True), 'strTypesInfo': ida_kernwin.Form.MultiLineTextControl(text=default_types_info, flags=ida_kernwin.Form.MultiLineTextControl.TXTF_FIXEDFONT), 'cUnalias': ida_kernwin.Form.ChkGroupControl(('rUnaliasStack',))})\n    (form, args) = self.Compile()\n    form.rUnaliasStack.checked = True\n    form.rTypeFile.checked = True"
        ]
    },
    {
        "func_name": "OnFormChange",
        "original": "def OnFormChange(self, fid):\n    if fid == -1:\n        self.EnableField(self.functionAddr, True)\n        self.EnableField(self.startAddr, False)\n        self.EnableField(self.endAddr, False)\n        self.EnableField(self.strTypesInfo, False)\n        self.EnableField(self.typeFile, True)\n    elif fid == self.cTypeFile.id:\n        if self.GetControlValue(self.cTypeFile) == 0:\n            self.EnableField(self.strTypesInfo, True)\n            self.EnableField(self.typeFile, False)\n        elif self.GetControlValue(self.cTypeFile) == 1:\n            self.EnableField(self.strTypesInfo, False)\n            self.EnableField(self.typeFile, True)\n    elif fid == self.cScope.id:\n        if self.GetControlValue(self.cScope) == 0:\n            self.EnableField(self.functionAddr, True)\n            self.EnableField(self.startAddr, False)\n            self.EnableField(self.endAddr, False)\n        elif self.GetControlValue(self.cScope) == 1:\n            self.EnableField(self.functionAddr, False)\n            self.EnableField(self.startAddr, True)\n            self.EnableField(self.endAddr, False)\n        elif self.GetControlValue(self.cScope) == 2:\n            self.EnableField(self.functionAddr, False)\n            self.EnableField(self.startAddr, True)\n            self.EnableField(self.endAddr, True)\n    return 1",
        "mutated": [
            "def OnFormChange(self, fid):\n    if False:\n        i = 10\n    if fid == -1:\n        self.EnableField(self.functionAddr, True)\n        self.EnableField(self.startAddr, False)\n        self.EnableField(self.endAddr, False)\n        self.EnableField(self.strTypesInfo, False)\n        self.EnableField(self.typeFile, True)\n    elif fid == self.cTypeFile.id:\n        if self.GetControlValue(self.cTypeFile) == 0:\n            self.EnableField(self.strTypesInfo, True)\n            self.EnableField(self.typeFile, False)\n        elif self.GetControlValue(self.cTypeFile) == 1:\n            self.EnableField(self.strTypesInfo, False)\n            self.EnableField(self.typeFile, True)\n    elif fid == self.cScope.id:\n        if self.GetControlValue(self.cScope) == 0:\n            self.EnableField(self.functionAddr, True)\n            self.EnableField(self.startAddr, False)\n            self.EnableField(self.endAddr, False)\n        elif self.GetControlValue(self.cScope) == 1:\n            self.EnableField(self.functionAddr, False)\n            self.EnableField(self.startAddr, True)\n            self.EnableField(self.endAddr, False)\n        elif self.GetControlValue(self.cScope) == 2:\n            self.EnableField(self.functionAddr, False)\n            self.EnableField(self.startAddr, True)\n            self.EnableField(self.endAddr, True)\n    return 1",
            "def OnFormChange(self, fid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if fid == -1:\n        self.EnableField(self.functionAddr, True)\n        self.EnableField(self.startAddr, False)\n        self.EnableField(self.endAddr, False)\n        self.EnableField(self.strTypesInfo, False)\n        self.EnableField(self.typeFile, True)\n    elif fid == self.cTypeFile.id:\n        if self.GetControlValue(self.cTypeFile) == 0:\n            self.EnableField(self.strTypesInfo, True)\n            self.EnableField(self.typeFile, False)\n        elif self.GetControlValue(self.cTypeFile) == 1:\n            self.EnableField(self.strTypesInfo, False)\n            self.EnableField(self.typeFile, True)\n    elif fid == self.cScope.id:\n        if self.GetControlValue(self.cScope) == 0:\n            self.EnableField(self.functionAddr, True)\n            self.EnableField(self.startAddr, False)\n            self.EnableField(self.endAddr, False)\n        elif self.GetControlValue(self.cScope) == 1:\n            self.EnableField(self.functionAddr, False)\n            self.EnableField(self.startAddr, True)\n            self.EnableField(self.endAddr, False)\n        elif self.GetControlValue(self.cScope) == 2:\n            self.EnableField(self.functionAddr, False)\n            self.EnableField(self.startAddr, True)\n            self.EnableField(self.endAddr, True)\n    return 1",
            "def OnFormChange(self, fid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if fid == -1:\n        self.EnableField(self.functionAddr, True)\n        self.EnableField(self.startAddr, False)\n        self.EnableField(self.endAddr, False)\n        self.EnableField(self.strTypesInfo, False)\n        self.EnableField(self.typeFile, True)\n    elif fid == self.cTypeFile.id:\n        if self.GetControlValue(self.cTypeFile) == 0:\n            self.EnableField(self.strTypesInfo, True)\n            self.EnableField(self.typeFile, False)\n        elif self.GetControlValue(self.cTypeFile) == 1:\n            self.EnableField(self.strTypesInfo, False)\n            self.EnableField(self.typeFile, True)\n    elif fid == self.cScope.id:\n        if self.GetControlValue(self.cScope) == 0:\n            self.EnableField(self.functionAddr, True)\n            self.EnableField(self.startAddr, False)\n            self.EnableField(self.endAddr, False)\n        elif self.GetControlValue(self.cScope) == 1:\n            self.EnableField(self.functionAddr, False)\n            self.EnableField(self.startAddr, True)\n            self.EnableField(self.endAddr, False)\n        elif self.GetControlValue(self.cScope) == 2:\n            self.EnableField(self.functionAddr, False)\n            self.EnableField(self.startAddr, True)\n            self.EnableField(self.endAddr, True)\n    return 1",
            "def OnFormChange(self, fid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if fid == -1:\n        self.EnableField(self.functionAddr, True)\n        self.EnableField(self.startAddr, False)\n        self.EnableField(self.endAddr, False)\n        self.EnableField(self.strTypesInfo, False)\n        self.EnableField(self.typeFile, True)\n    elif fid == self.cTypeFile.id:\n        if self.GetControlValue(self.cTypeFile) == 0:\n            self.EnableField(self.strTypesInfo, True)\n            self.EnableField(self.typeFile, False)\n        elif self.GetControlValue(self.cTypeFile) == 1:\n            self.EnableField(self.strTypesInfo, False)\n            self.EnableField(self.typeFile, True)\n    elif fid == self.cScope.id:\n        if self.GetControlValue(self.cScope) == 0:\n            self.EnableField(self.functionAddr, True)\n            self.EnableField(self.startAddr, False)\n            self.EnableField(self.endAddr, False)\n        elif self.GetControlValue(self.cScope) == 1:\n            self.EnableField(self.functionAddr, False)\n            self.EnableField(self.startAddr, True)\n            self.EnableField(self.endAddr, False)\n        elif self.GetControlValue(self.cScope) == 2:\n            self.EnableField(self.functionAddr, False)\n            self.EnableField(self.startAddr, True)\n            self.EnableField(self.endAddr, True)\n    return 1",
            "def OnFormChange(self, fid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if fid == -1:\n        self.EnableField(self.functionAddr, True)\n        self.EnableField(self.startAddr, False)\n        self.EnableField(self.endAddr, False)\n        self.EnableField(self.strTypesInfo, False)\n        self.EnableField(self.typeFile, True)\n    elif fid == self.cTypeFile.id:\n        if self.GetControlValue(self.cTypeFile) == 0:\n            self.EnableField(self.strTypesInfo, True)\n            self.EnableField(self.typeFile, False)\n        elif self.GetControlValue(self.cTypeFile) == 1:\n            self.EnableField(self.strTypesInfo, False)\n            self.EnableField(self.typeFile, True)\n    elif fid == self.cScope.id:\n        if self.GetControlValue(self.cScope) == 0:\n            self.EnableField(self.functionAddr, True)\n            self.EnableField(self.startAddr, False)\n            self.EnableField(self.endAddr, False)\n        elif self.GetControlValue(self.cScope) == 1:\n            self.EnableField(self.functionAddr, False)\n            self.EnableField(self.startAddr, True)\n            self.EnableField(self.endAddr, False)\n        elif self.GetControlValue(self.cScope) == 2:\n            self.EnableField(self.functionAddr, False)\n            self.EnableField(self.startAddr, True)\n            self.EnableField(self.endAddr, True)\n    return 1"
        ]
    },
    {
        "func_name": "get_types_mngr",
        "original": "def get_types_mngr(headerFile, arch):\n    text = open(headerFile).read()\n    if arch == 'AMD64_unk':\n        base_types = CTypeAMD64_unk()\n    elif arch == 'X86_32_unk':\n        base_types = CTypeX86_unk()\n    elif arch == 'msp430_unk':\n        base_types = CTypeMSP430_unk()\n    else:\n        raise NotImplementedError('Unsupported arch')\n    types_ast = CAstTypes()\n    types_ast.add_c_decl(text)\n    types_mngr = CTypesManagerNotPacked(types_ast, base_types)\n    return types_mngr",
        "mutated": [
            "def get_types_mngr(headerFile, arch):\n    if False:\n        i = 10\n    text = open(headerFile).read()\n    if arch == 'AMD64_unk':\n        base_types = CTypeAMD64_unk()\n    elif arch == 'X86_32_unk':\n        base_types = CTypeX86_unk()\n    elif arch == 'msp430_unk':\n        base_types = CTypeMSP430_unk()\n    else:\n        raise NotImplementedError('Unsupported arch')\n    types_ast = CAstTypes()\n    types_ast.add_c_decl(text)\n    types_mngr = CTypesManagerNotPacked(types_ast, base_types)\n    return types_mngr",
            "def get_types_mngr(headerFile, arch):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    text = open(headerFile).read()\n    if arch == 'AMD64_unk':\n        base_types = CTypeAMD64_unk()\n    elif arch == 'X86_32_unk':\n        base_types = CTypeX86_unk()\n    elif arch == 'msp430_unk':\n        base_types = CTypeMSP430_unk()\n    else:\n        raise NotImplementedError('Unsupported arch')\n    types_ast = CAstTypes()\n    types_ast.add_c_decl(text)\n    types_mngr = CTypesManagerNotPacked(types_ast, base_types)\n    return types_mngr",
            "def get_types_mngr(headerFile, arch):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    text = open(headerFile).read()\n    if arch == 'AMD64_unk':\n        base_types = CTypeAMD64_unk()\n    elif arch == 'X86_32_unk':\n        base_types = CTypeX86_unk()\n    elif arch == 'msp430_unk':\n        base_types = CTypeMSP430_unk()\n    else:\n        raise NotImplementedError('Unsupported arch')\n    types_ast = CAstTypes()\n    types_ast.add_c_decl(text)\n    types_mngr = CTypesManagerNotPacked(types_ast, base_types)\n    return types_mngr",
            "def get_types_mngr(headerFile, arch):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    text = open(headerFile).read()\n    if arch == 'AMD64_unk':\n        base_types = CTypeAMD64_unk()\n    elif arch == 'X86_32_unk':\n        base_types = CTypeX86_unk()\n    elif arch == 'msp430_unk':\n        base_types = CTypeMSP430_unk()\n    else:\n        raise NotImplementedError('Unsupported arch')\n    types_ast = CAstTypes()\n    types_ast.add_c_decl(text)\n    types_mngr = CTypesManagerNotPacked(types_ast, base_types)\n    return types_mngr",
            "def get_types_mngr(headerFile, arch):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    text = open(headerFile).read()\n    if arch == 'AMD64_unk':\n        base_types = CTypeAMD64_unk()\n    elif arch == 'X86_32_unk':\n        base_types = CTypeX86_unk()\n    elif arch == 'msp430_unk':\n        base_types = CTypeMSP430_unk()\n    else:\n        raise NotImplementedError('Unsupported arch')\n    types_ast = CAstTypes()\n    types_ast.add_c_decl(text)\n    types_mngr = CTypesManagerNotPacked(types_ast, base_types)\n    return types_mngr"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, lifter, types_mngr, state):\n    mychandler = MyCHandler(types_mngr, state.symbols)\n    super(TypePropagationEngine, self).__init__(lifter, state.symbols, mychandler)",
        "mutated": [
            "def __init__(self, lifter, types_mngr, state):\n    if False:\n        i = 10\n    mychandler = MyCHandler(types_mngr, state.symbols)\n    super(TypePropagationEngine, self).__init__(lifter, state.symbols, mychandler)",
            "def __init__(self, lifter, types_mngr, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mychandler = MyCHandler(types_mngr, state.symbols)\n    super(TypePropagationEngine, self).__init__(lifter, state.symbols, mychandler)",
            "def __init__(self, lifter, types_mngr, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mychandler = MyCHandler(types_mngr, state.symbols)\n    super(TypePropagationEngine, self).__init__(lifter, state.symbols, mychandler)",
            "def __init__(self, lifter, types_mngr, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mychandler = MyCHandler(types_mngr, state.symbols)\n    super(TypePropagationEngine, self).__init__(lifter, state.symbols, mychandler)",
            "def __init__(self, lifter, types_mngr, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mychandler = MyCHandler(types_mngr, state.symbols)\n    super(TypePropagationEngine, self).__init__(lifter, state.symbols, mychandler)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, lifter, symbols, chandler, cst_propag_link, sb_expr_simp=expr_simp):\n    super(SymbExecCTypeFix, self).__init__(lifter, symbols, chandler, sb_expr_simp=expr_simp)\n    self.cst_propag_link = cst_propag_link",
        "mutated": [
            "def __init__(self, lifter, symbols, chandler, cst_propag_link, sb_expr_simp=expr_simp):\n    if False:\n        i = 10\n    super(SymbExecCTypeFix, self).__init__(lifter, symbols, chandler, sb_expr_simp=expr_simp)\n    self.cst_propag_link = cst_propag_link",
            "def __init__(self, lifter, symbols, chandler, cst_propag_link, sb_expr_simp=expr_simp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(SymbExecCTypeFix, self).__init__(lifter, symbols, chandler, sb_expr_simp=expr_simp)\n    self.cst_propag_link = cst_propag_link",
            "def __init__(self, lifter, symbols, chandler, cst_propag_link, sb_expr_simp=expr_simp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(SymbExecCTypeFix, self).__init__(lifter, symbols, chandler, sb_expr_simp=expr_simp)\n    self.cst_propag_link = cst_propag_link",
            "def __init__(self, lifter, symbols, chandler, cst_propag_link, sb_expr_simp=expr_simp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(SymbExecCTypeFix, self).__init__(lifter, symbols, chandler, sb_expr_simp=expr_simp)\n    self.cst_propag_link = cst_propag_link",
            "def __init__(self, lifter, symbols, chandler, cst_propag_link, sb_expr_simp=expr_simp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(SymbExecCTypeFix, self).__init__(lifter, symbols, chandler, sb_expr_simp=expr_simp)\n    self.cst_propag_link = cst_propag_link"
        ]
    },
    {
        "func_name": "eval_updt_irblock",
        "original": "def eval_updt_irblock(self, irb, step=False):\n    \"\"\"\n        Symbolic execution of the @irb on the current state\n        @irb: irblock instance\n        @step: display intermediate steps\n        \"\"\"\n    offset2cmt = {}\n    for (index, assignblk) in enumerate(irb):\n        if set(assignblk) == set([self.lifter.IRDst, self.lifter.pc]):\n            continue\n        instr = assignblk.instr\n        tmp_r = assignblk.get_r()\n        tmp_w = assignblk.get_w()\n        todo = set()\n        pc_fixed = {self.lifter.pc: m2_expr.ExprInt(instr.offset + instr.l, self.lifter.pc.size)}\n        inputs = tmp_r\n        inputs.update((arg for arg in tmp_w if arg.is_mem()))\n        for arg in inputs:\n            arg = expr_simp(arg.replace_expr(pc_fixed))\n            if arg in tmp_w and (not arg.is_mem()):\n                continue\n            todo.add(arg)\n        for expr in todo:\n            if expr.is_int():\n                continue\n            for (c_str, c_type) in self.chandler.expr_to_c_and_types(expr, self.symbols):\n                expr = self.cst_propag_link.get((irb.loc_key, index), {}).get(expr, expr)\n                offset2cmt.setdefault(instr.offset, set()).add('\\n%s: %s\\n%s' % (expr, c_str, c_type))\n        self.eval_updt_assignblk(assignblk)\n    for (offset, value) in viewitems(offset2cmt):\n        idc.set_cmt(offset, '\\n'.join(value), 0)\n        print('%x\\n' % offset, '\\n'.join(value))\n    return self.eval_expr(self.lifter.IRDst)",
        "mutated": [
            "def eval_updt_irblock(self, irb, step=False):\n    if False:\n        i = 10\n    '\\n        Symbolic execution of the @irb on the current state\\n        @irb: irblock instance\\n        @step: display intermediate steps\\n        '\n    offset2cmt = {}\n    for (index, assignblk) in enumerate(irb):\n        if set(assignblk) == set([self.lifter.IRDst, self.lifter.pc]):\n            continue\n        instr = assignblk.instr\n        tmp_r = assignblk.get_r()\n        tmp_w = assignblk.get_w()\n        todo = set()\n        pc_fixed = {self.lifter.pc: m2_expr.ExprInt(instr.offset + instr.l, self.lifter.pc.size)}\n        inputs = tmp_r\n        inputs.update((arg for arg in tmp_w if arg.is_mem()))\n        for arg in inputs:\n            arg = expr_simp(arg.replace_expr(pc_fixed))\n            if arg in tmp_w and (not arg.is_mem()):\n                continue\n            todo.add(arg)\n        for expr in todo:\n            if expr.is_int():\n                continue\n            for (c_str, c_type) in self.chandler.expr_to_c_and_types(expr, self.symbols):\n                expr = self.cst_propag_link.get((irb.loc_key, index), {}).get(expr, expr)\n                offset2cmt.setdefault(instr.offset, set()).add('\\n%s: %s\\n%s' % (expr, c_str, c_type))\n        self.eval_updt_assignblk(assignblk)\n    for (offset, value) in viewitems(offset2cmt):\n        idc.set_cmt(offset, '\\n'.join(value), 0)\n        print('%x\\n' % offset, '\\n'.join(value))\n    return self.eval_expr(self.lifter.IRDst)",
            "def eval_updt_irblock(self, irb, step=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Symbolic execution of the @irb on the current state\\n        @irb: irblock instance\\n        @step: display intermediate steps\\n        '\n    offset2cmt = {}\n    for (index, assignblk) in enumerate(irb):\n        if set(assignblk) == set([self.lifter.IRDst, self.lifter.pc]):\n            continue\n        instr = assignblk.instr\n        tmp_r = assignblk.get_r()\n        tmp_w = assignblk.get_w()\n        todo = set()\n        pc_fixed = {self.lifter.pc: m2_expr.ExprInt(instr.offset + instr.l, self.lifter.pc.size)}\n        inputs = tmp_r\n        inputs.update((arg for arg in tmp_w if arg.is_mem()))\n        for arg in inputs:\n            arg = expr_simp(arg.replace_expr(pc_fixed))\n            if arg in tmp_w and (not arg.is_mem()):\n                continue\n            todo.add(arg)\n        for expr in todo:\n            if expr.is_int():\n                continue\n            for (c_str, c_type) in self.chandler.expr_to_c_and_types(expr, self.symbols):\n                expr = self.cst_propag_link.get((irb.loc_key, index), {}).get(expr, expr)\n                offset2cmt.setdefault(instr.offset, set()).add('\\n%s: %s\\n%s' % (expr, c_str, c_type))\n        self.eval_updt_assignblk(assignblk)\n    for (offset, value) in viewitems(offset2cmt):\n        idc.set_cmt(offset, '\\n'.join(value), 0)\n        print('%x\\n' % offset, '\\n'.join(value))\n    return self.eval_expr(self.lifter.IRDst)",
            "def eval_updt_irblock(self, irb, step=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Symbolic execution of the @irb on the current state\\n        @irb: irblock instance\\n        @step: display intermediate steps\\n        '\n    offset2cmt = {}\n    for (index, assignblk) in enumerate(irb):\n        if set(assignblk) == set([self.lifter.IRDst, self.lifter.pc]):\n            continue\n        instr = assignblk.instr\n        tmp_r = assignblk.get_r()\n        tmp_w = assignblk.get_w()\n        todo = set()\n        pc_fixed = {self.lifter.pc: m2_expr.ExprInt(instr.offset + instr.l, self.lifter.pc.size)}\n        inputs = tmp_r\n        inputs.update((arg for arg in tmp_w if arg.is_mem()))\n        for arg in inputs:\n            arg = expr_simp(arg.replace_expr(pc_fixed))\n            if arg in tmp_w and (not arg.is_mem()):\n                continue\n            todo.add(arg)\n        for expr in todo:\n            if expr.is_int():\n                continue\n            for (c_str, c_type) in self.chandler.expr_to_c_and_types(expr, self.symbols):\n                expr = self.cst_propag_link.get((irb.loc_key, index), {}).get(expr, expr)\n                offset2cmt.setdefault(instr.offset, set()).add('\\n%s: %s\\n%s' % (expr, c_str, c_type))\n        self.eval_updt_assignblk(assignblk)\n    for (offset, value) in viewitems(offset2cmt):\n        idc.set_cmt(offset, '\\n'.join(value), 0)\n        print('%x\\n' % offset, '\\n'.join(value))\n    return self.eval_expr(self.lifter.IRDst)",
            "def eval_updt_irblock(self, irb, step=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Symbolic execution of the @irb on the current state\\n        @irb: irblock instance\\n        @step: display intermediate steps\\n        '\n    offset2cmt = {}\n    for (index, assignblk) in enumerate(irb):\n        if set(assignblk) == set([self.lifter.IRDst, self.lifter.pc]):\n            continue\n        instr = assignblk.instr\n        tmp_r = assignblk.get_r()\n        tmp_w = assignblk.get_w()\n        todo = set()\n        pc_fixed = {self.lifter.pc: m2_expr.ExprInt(instr.offset + instr.l, self.lifter.pc.size)}\n        inputs = tmp_r\n        inputs.update((arg for arg in tmp_w if arg.is_mem()))\n        for arg in inputs:\n            arg = expr_simp(arg.replace_expr(pc_fixed))\n            if arg in tmp_w and (not arg.is_mem()):\n                continue\n            todo.add(arg)\n        for expr in todo:\n            if expr.is_int():\n                continue\n            for (c_str, c_type) in self.chandler.expr_to_c_and_types(expr, self.symbols):\n                expr = self.cst_propag_link.get((irb.loc_key, index), {}).get(expr, expr)\n                offset2cmt.setdefault(instr.offset, set()).add('\\n%s: %s\\n%s' % (expr, c_str, c_type))\n        self.eval_updt_assignblk(assignblk)\n    for (offset, value) in viewitems(offset2cmt):\n        idc.set_cmt(offset, '\\n'.join(value), 0)\n        print('%x\\n' % offset, '\\n'.join(value))\n    return self.eval_expr(self.lifter.IRDst)",
            "def eval_updt_irblock(self, irb, step=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Symbolic execution of the @irb on the current state\\n        @irb: irblock instance\\n        @step: display intermediate steps\\n        '\n    offset2cmt = {}\n    for (index, assignblk) in enumerate(irb):\n        if set(assignblk) == set([self.lifter.IRDst, self.lifter.pc]):\n            continue\n        instr = assignblk.instr\n        tmp_r = assignblk.get_r()\n        tmp_w = assignblk.get_w()\n        todo = set()\n        pc_fixed = {self.lifter.pc: m2_expr.ExprInt(instr.offset + instr.l, self.lifter.pc.size)}\n        inputs = tmp_r\n        inputs.update((arg for arg in tmp_w if arg.is_mem()))\n        for arg in inputs:\n            arg = expr_simp(arg.replace_expr(pc_fixed))\n            if arg in tmp_w and (not arg.is_mem()):\n                continue\n            todo.add(arg)\n        for expr in todo:\n            if expr.is_int():\n                continue\n            for (c_str, c_type) in self.chandler.expr_to_c_and_types(expr, self.symbols):\n                expr = self.cst_propag_link.get((irb.loc_key, index), {}).get(expr, expr)\n                offset2cmt.setdefault(instr.offset, set()).add('\\n%s: %s\\n%s' % (expr, c_str, c_type))\n        self.eval_updt_assignblk(assignblk)\n    for (offset, value) in viewitems(offset2cmt):\n        idc.set_cmt(offset, '\\n'.join(value), 0)\n        print('%x\\n' % offset, '\\n'.join(value))\n    return self.eval_expr(self.lifter.IRDst)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, lifter, types_mngr, state, cst_propag_link):\n    mychandler = MyCHandler(types_mngr, state.symbols)\n    super(CTypeEngineFixer, self).__init__(lifter, state.symbols, mychandler, cst_propag_link)",
        "mutated": [
            "def __init__(self, lifter, types_mngr, state, cst_propag_link):\n    if False:\n        i = 10\n    mychandler = MyCHandler(types_mngr, state.symbols)\n    super(CTypeEngineFixer, self).__init__(lifter, state.symbols, mychandler, cst_propag_link)",
            "def __init__(self, lifter, types_mngr, state, cst_propag_link):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mychandler = MyCHandler(types_mngr, state.symbols)\n    super(CTypeEngineFixer, self).__init__(lifter, state.symbols, mychandler, cst_propag_link)",
            "def __init__(self, lifter, types_mngr, state, cst_propag_link):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mychandler = MyCHandler(types_mngr, state.symbols)\n    super(CTypeEngineFixer, self).__init__(lifter, state.symbols, mychandler, cst_propag_link)",
            "def __init__(self, lifter, types_mngr, state, cst_propag_link):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mychandler = MyCHandler(types_mngr, state.symbols)\n    super(CTypeEngineFixer, self).__init__(lifter, state.symbols, mychandler, cst_propag_link)",
            "def __init__(self, lifter, types_mngr, state, cst_propag_link):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mychandler = MyCHandler(types_mngr, state.symbols)\n    super(CTypeEngineFixer, self).__init__(lifter, state.symbols, mychandler, cst_propag_link)"
        ]
    },
    {
        "func_name": "call_effects",
        "original": "def call_effects(self, ad, instr):\n    print(hex(instr.offset), instr)\n    stk_before = idc.get_spd(instr.offset)\n    stk_after = idc.get_spd(instr.offset + instr.l)\n    stk_diff = stk_after - stk_before\n    print(hex(stk_diff))\n    call_assignblk = AssignBlock([ExprAssign(self.ret_reg, ExprOp('call_func_ret', ad)), ExprAssign(self.sp, self.sp + ExprInt(stk_diff, self.sp.size))], instr)\n    return ([call_assignblk], [])",
        "mutated": [
            "def call_effects(self, ad, instr):\n    if False:\n        i = 10\n    print(hex(instr.offset), instr)\n    stk_before = idc.get_spd(instr.offset)\n    stk_after = idc.get_spd(instr.offset + instr.l)\n    stk_diff = stk_after - stk_before\n    print(hex(stk_diff))\n    call_assignblk = AssignBlock([ExprAssign(self.ret_reg, ExprOp('call_func_ret', ad)), ExprAssign(self.sp, self.sp + ExprInt(stk_diff, self.sp.size))], instr)\n    return ([call_assignblk], [])",
            "def call_effects(self, ad, instr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    print(hex(instr.offset), instr)\n    stk_before = idc.get_spd(instr.offset)\n    stk_after = idc.get_spd(instr.offset + instr.l)\n    stk_diff = stk_after - stk_before\n    print(hex(stk_diff))\n    call_assignblk = AssignBlock([ExprAssign(self.ret_reg, ExprOp('call_func_ret', ad)), ExprAssign(self.sp, self.sp + ExprInt(stk_diff, self.sp.size))], instr)\n    return ([call_assignblk], [])",
            "def call_effects(self, ad, instr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    print(hex(instr.offset), instr)\n    stk_before = idc.get_spd(instr.offset)\n    stk_after = idc.get_spd(instr.offset + instr.l)\n    stk_diff = stk_after - stk_before\n    print(hex(stk_diff))\n    call_assignblk = AssignBlock([ExprAssign(self.ret_reg, ExprOp('call_func_ret', ad)), ExprAssign(self.sp, self.sp + ExprInt(stk_diff, self.sp.size))], instr)\n    return ([call_assignblk], [])",
            "def call_effects(self, ad, instr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    print(hex(instr.offset), instr)\n    stk_before = idc.get_spd(instr.offset)\n    stk_after = idc.get_spd(instr.offset + instr.l)\n    stk_diff = stk_after - stk_before\n    print(hex(stk_diff))\n    call_assignblk = AssignBlock([ExprAssign(self.ret_reg, ExprOp('call_func_ret', ad)), ExprAssign(self.sp, self.sp + ExprInt(stk_diff, self.sp.size))], instr)\n    return ([call_assignblk], [])",
            "def call_effects(self, ad, instr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    print(hex(instr.offset), instr)\n    stk_before = idc.get_spd(instr.offset)\n    stk_after = idc.get_spd(instr.offset + instr.l)\n    stk_diff = stk_after - stk_before\n    print(hex(stk_diff))\n    call_assignblk = AssignBlock([ExprAssign(self.ret_reg, ExprOp('call_func_ret', ad)), ExprAssign(self.sp, self.sp + ExprInt(stk_diff, self.sp.size))], instr)\n    return ([call_assignblk], [])"
        ]
    },
    {
        "func_name": "get_lifter_model_call_call_fixer",
        "original": "def get_lifter_model_call_call_fixer(lifter_model_call):\n\n    class lifter_model_callCallStackFixer(lifter_model_call):\n\n        def call_effects(self, ad, instr):\n            print(hex(instr.offset), instr)\n            stk_before = idc.get_spd(instr.offset)\n            stk_after = idc.get_spd(instr.offset + instr.l)\n            stk_diff = stk_after - stk_before\n            print(hex(stk_diff))\n            call_assignblk = AssignBlock([ExprAssign(self.ret_reg, ExprOp('call_func_ret', ad)), ExprAssign(self.sp, self.sp + ExprInt(stk_diff, self.sp.size))], instr)\n            return ([call_assignblk], [])\n    return lifter_model_callCallStackFixer",
        "mutated": [
            "def get_lifter_model_call_call_fixer(lifter_model_call):\n    if False:\n        i = 10\n\n    class lifter_model_callCallStackFixer(lifter_model_call):\n\n        def call_effects(self, ad, instr):\n            print(hex(instr.offset), instr)\n            stk_before = idc.get_spd(instr.offset)\n            stk_after = idc.get_spd(instr.offset + instr.l)\n            stk_diff = stk_after - stk_before\n            print(hex(stk_diff))\n            call_assignblk = AssignBlock([ExprAssign(self.ret_reg, ExprOp('call_func_ret', ad)), ExprAssign(self.sp, self.sp + ExprInt(stk_diff, self.sp.size))], instr)\n            return ([call_assignblk], [])\n    return lifter_model_callCallStackFixer",
            "def get_lifter_model_call_call_fixer(lifter_model_call):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class lifter_model_callCallStackFixer(lifter_model_call):\n\n        def call_effects(self, ad, instr):\n            print(hex(instr.offset), instr)\n            stk_before = idc.get_spd(instr.offset)\n            stk_after = idc.get_spd(instr.offset + instr.l)\n            stk_diff = stk_after - stk_before\n            print(hex(stk_diff))\n            call_assignblk = AssignBlock([ExprAssign(self.ret_reg, ExprOp('call_func_ret', ad)), ExprAssign(self.sp, self.sp + ExprInt(stk_diff, self.sp.size))], instr)\n            return ([call_assignblk], [])\n    return lifter_model_callCallStackFixer",
            "def get_lifter_model_call_call_fixer(lifter_model_call):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class lifter_model_callCallStackFixer(lifter_model_call):\n\n        def call_effects(self, ad, instr):\n            print(hex(instr.offset), instr)\n            stk_before = idc.get_spd(instr.offset)\n            stk_after = idc.get_spd(instr.offset + instr.l)\n            stk_diff = stk_after - stk_before\n            print(hex(stk_diff))\n            call_assignblk = AssignBlock([ExprAssign(self.ret_reg, ExprOp('call_func_ret', ad)), ExprAssign(self.sp, self.sp + ExprInt(stk_diff, self.sp.size))], instr)\n            return ([call_assignblk], [])\n    return lifter_model_callCallStackFixer",
            "def get_lifter_model_call_call_fixer(lifter_model_call):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class lifter_model_callCallStackFixer(lifter_model_call):\n\n        def call_effects(self, ad, instr):\n            print(hex(instr.offset), instr)\n            stk_before = idc.get_spd(instr.offset)\n            stk_after = idc.get_spd(instr.offset + instr.l)\n            stk_diff = stk_after - stk_before\n            print(hex(stk_diff))\n            call_assignblk = AssignBlock([ExprAssign(self.ret_reg, ExprOp('call_func_ret', ad)), ExprAssign(self.sp, self.sp + ExprInt(stk_diff, self.sp.size))], instr)\n            return ([call_assignblk], [])\n    return lifter_model_callCallStackFixer",
            "def get_lifter_model_call_call_fixer(lifter_model_call):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class lifter_model_callCallStackFixer(lifter_model_call):\n\n        def call_effects(self, ad, instr):\n            print(hex(instr.offset), instr)\n            stk_before = idc.get_spd(instr.offset)\n            stk_after = idc.get_spd(instr.offset + instr.l)\n            stk_diff = stk_after - stk_before\n            print(hex(stk_diff))\n            call_assignblk = AssignBlock([ExprAssign(self.ret_reg, ExprOp('call_func_ret', ad)), ExprAssign(self.sp, self.sp + ExprInt(stk_diff, self.sp.size))], instr)\n            return ([call_assignblk], [])\n    return lifter_model_callCallStackFixer"
        ]
    },
    {
        "func_name": "analyse_function",
        "original": "def analyse_function():\n    settings = TypePropagationForm()\n    ret = settings.Execute()\n    if not ret:\n        return\n    end = None\n    if settings.cScope.value == 0:\n        addr = settings.functionAddr.value\n    else:\n        addr = settings.startAddr.value\n        if settings.cScope.value == 2:\n            end = settings.endAddr\n    machine = guess_machine(addr=addr)\n    (mn, dis_engine, lifter_model_call) = (machine.mn, machine.dis_engine, machine.lifter_model_call)\n    bs = bin_stream_ida()\n    loc_db = LocationDB()\n    mdis = dis_engine(bs, loc_db=loc_db, dont_dis_nulstart_bloc=True)\n    if end is not None:\n        mdis.dont_dis = [end]\n    lifter_model_callCallStackFixer = get_lifter_model_call_call_fixer(lifter_model_call)\n    lifter = lifter_model_callCallStackFixer(loc_db)\n    asmcfg = mdis.dis_multiblock(addr)\n    ircfg = lifter.new_ircfg_from_asmcfg(asmcfg)\n    cst_propag_link = {}\n    if settings.cUnalias.value:\n        init_infos = {lifter.sp: lifter.arch.regs.regs_init[lifter.sp]}\n        cst_propag_link = propagate_cst_expr(lifter, ircfg, addr, init_infos)\n    types_mngr = get_types_mngr(settings.headerFile.value, settings.arch.value)\n    mychandler = MyCHandler(types_mngr, {})\n    infos_types = {}\n    infos_types_raw = []\n    if settings.cTypeFile.value:\n        infos_types_raw = open(settings.typeFile.value).read().split('\\n')\n    else:\n        infos_types_raw = settings.strTypesInfo.value.split('\\n')\n    for line in infos_types_raw:\n        if not line:\n            continue\n        (expr_str, ctype_str) = line.split(':')\n        (expr_str, ctype_str) = (expr_str.strip(), ctype_str.strip())\n        expr = str_to_expr(expr_str)\n        ast = mychandler.types_mngr.types_ast.parse_c_type(ctype_str)\n        ctype = mychandler.types_mngr.types_ast.ast_parse_declaration(ast.ext[0])\n        objc = types_mngr.get_objc(ctype)\n        print('=' * 20)\n        print(expr, objc)\n        infos_types[expr] = set([objc])\n    lbl_real_start = loc_db.get_offset_location(addr)\n    lbl_head = loc_db.get_or_create_name_location('start')\n    first_block = asmcfg.loc_key_to_block(lbl_real_start)\n    assignblk_head = AssignBlock([ExprAssign(lifter.IRDst, ExprLoc(lbl_real_start, lifter.IRDst.size)), ExprAssign(lifter.sp, lifter.arch.regs.regs_init[lifter.sp])], first_block.lines[0])\n    irb_head = IRBlock(loc_db, lbl_head, [assignblk_head])\n    ircfg.blocks[lbl_head] = irb_head\n    ircfg.add_uniq_edge(lbl_head, lbl_real_start)\n    state = TypePropagationEngine.StateEngine(infos_types)\n    states = {lbl_head: state}\n    todo = set([lbl_head])\n    done = set()\n    while todo:\n        lbl = todo.pop()\n        state = states[lbl]\n        if (lbl, state) in done:\n            continue\n        done.add((lbl, state))\n        if lbl not in ircfg.blocks:\n            continue\n        symbexec_engine = TypePropagationEngine(lifter, types_mngr, state)\n        symbexec_engine.run_block_at(ircfg, lbl)\n        symbexec_engine.del_mem_above_stack(lifter.sp)\n        sons = ircfg.successors(lbl)\n        for son in sons:\n            add_state(ircfg, todo, states, son, symbexec_engine.get_state())\n    for (lbl, state) in viewitems(states):\n        if lbl not in ircfg.blocks:\n            continue\n        symbexec_engine = CTypeEngineFixer(lifter, types_mngr, state, cst_propag_link)\n        symbexec_engine.run_block_at(ircfg, lbl)\n        symbexec_engine.del_mem_above_stack(lifter.sp)",
        "mutated": [
            "def analyse_function():\n    if False:\n        i = 10\n    settings = TypePropagationForm()\n    ret = settings.Execute()\n    if not ret:\n        return\n    end = None\n    if settings.cScope.value == 0:\n        addr = settings.functionAddr.value\n    else:\n        addr = settings.startAddr.value\n        if settings.cScope.value == 2:\n            end = settings.endAddr\n    machine = guess_machine(addr=addr)\n    (mn, dis_engine, lifter_model_call) = (machine.mn, machine.dis_engine, machine.lifter_model_call)\n    bs = bin_stream_ida()\n    loc_db = LocationDB()\n    mdis = dis_engine(bs, loc_db=loc_db, dont_dis_nulstart_bloc=True)\n    if end is not None:\n        mdis.dont_dis = [end]\n    lifter_model_callCallStackFixer = get_lifter_model_call_call_fixer(lifter_model_call)\n    lifter = lifter_model_callCallStackFixer(loc_db)\n    asmcfg = mdis.dis_multiblock(addr)\n    ircfg = lifter.new_ircfg_from_asmcfg(asmcfg)\n    cst_propag_link = {}\n    if settings.cUnalias.value:\n        init_infos = {lifter.sp: lifter.arch.regs.regs_init[lifter.sp]}\n        cst_propag_link = propagate_cst_expr(lifter, ircfg, addr, init_infos)\n    types_mngr = get_types_mngr(settings.headerFile.value, settings.arch.value)\n    mychandler = MyCHandler(types_mngr, {})\n    infos_types = {}\n    infos_types_raw = []\n    if settings.cTypeFile.value:\n        infos_types_raw = open(settings.typeFile.value).read().split('\\n')\n    else:\n        infos_types_raw = settings.strTypesInfo.value.split('\\n')\n    for line in infos_types_raw:\n        if not line:\n            continue\n        (expr_str, ctype_str) = line.split(':')\n        (expr_str, ctype_str) = (expr_str.strip(), ctype_str.strip())\n        expr = str_to_expr(expr_str)\n        ast = mychandler.types_mngr.types_ast.parse_c_type(ctype_str)\n        ctype = mychandler.types_mngr.types_ast.ast_parse_declaration(ast.ext[0])\n        objc = types_mngr.get_objc(ctype)\n        print('=' * 20)\n        print(expr, objc)\n        infos_types[expr] = set([objc])\n    lbl_real_start = loc_db.get_offset_location(addr)\n    lbl_head = loc_db.get_or_create_name_location('start')\n    first_block = asmcfg.loc_key_to_block(lbl_real_start)\n    assignblk_head = AssignBlock([ExprAssign(lifter.IRDst, ExprLoc(lbl_real_start, lifter.IRDst.size)), ExprAssign(lifter.sp, lifter.arch.regs.regs_init[lifter.sp])], first_block.lines[0])\n    irb_head = IRBlock(loc_db, lbl_head, [assignblk_head])\n    ircfg.blocks[lbl_head] = irb_head\n    ircfg.add_uniq_edge(lbl_head, lbl_real_start)\n    state = TypePropagationEngine.StateEngine(infos_types)\n    states = {lbl_head: state}\n    todo = set([lbl_head])\n    done = set()\n    while todo:\n        lbl = todo.pop()\n        state = states[lbl]\n        if (lbl, state) in done:\n            continue\n        done.add((lbl, state))\n        if lbl not in ircfg.blocks:\n            continue\n        symbexec_engine = TypePropagationEngine(lifter, types_mngr, state)\n        symbexec_engine.run_block_at(ircfg, lbl)\n        symbexec_engine.del_mem_above_stack(lifter.sp)\n        sons = ircfg.successors(lbl)\n        for son in sons:\n            add_state(ircfg, todo, states, son, symbexec_engine.get_state())\n    for (lbl, state) in viewitems(states):\n        if lbl not in ircfg.blocks:\n            continue\n        symbexec_engine = CTypeEngineFixer(lifter, types_mngr, state, cst_propag_link)\n        symbexec_engine.run_block_at(ircfg, lbl)\n        symbexec_engine.del_mem_above_stack(lifter.sp)",
            "def analyse_function():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    settings = TypePropagationForm()\n    ret = settings.Execute()\n    if not ret:\n        return\n    end = None\n    if settings.cScope.value == 0:\n        addr = settings.functionAddr.value\n    else:\n        addr = settings.startAddr.value\n        if settings.cScope.value == 2:\n            end = settings.endAddr\n    machine = guess_machine(addr=addr)\n    (mn, dis_engine, lifter_model_call) = (machine.mn, machine.dis_engine, machine.lifter_model_call)\n    bs = bin_stream_ida()\n    loc_db = LocationDB()\n    mdis = dis_engine(bs, loc_db=loc_db, dont_dis_nulstart_bloc=True)\n    if end is not None:\n        mdis.dont_dis = [end]\n    lifter_model_callCallStackFixer = get_lifter_model_call_call_fixer(lifter_model_call)\n    lifter = lifter_model_callCallStackFixer(loc_db)\n    asmcfg = mdis.dis_multiblock(addr)\n    ircfg = lifter.new_ircfg_from_asmcfg(asmcfg)\n    cst_propag_link = {}\n    if settings.cUnalias.value:\n        init_infos = {lifter.sp: lifter.arch.regs.regs_init[lifter.sp]}\n        cst_propag_link = propagate_cst_expr(lifter, ircfg, addr, init_infos)\n    types_mngr = get_types_mngr(settings.headerFile.value, settings.arch.value)\n    mychandler = MyCHandler(types_mngr, {})\n    infos_types = {}\n    infos_types_raw = []\n    if settings.cTypeFile.value:\n        infos_types_raw = open(settings.typeFile.value).read().split('\\n')\n    else:\n        infos_types_raw = settings.strTypesInfo.value.split('\\n')\n    for line in infos_types_raw:\n        if not line:\n            continue\n        (expr_str, ctype_str) = line.split(':')\n        (expr_str, ctype_str) = (expr_str.strip(), ctype_str.strip())\n        expr = str_to_expr(expr_str)\n        ast = mychandler.types_mngr.types_ast.parse_c_type(ctype_str)\n        ctype = mychandler.types_mngr.types_ast.ast_parse_declaration(ast.ext[0])\n        objc = types_mngr.get_objc(ctype)\n        print('=' * 20)\n        print(expr, objc)\n        infos_types[expr] = set([objc])\n    lbl_real_start = loc_db.get_offset_location(addr)\n    lbl_head = loc_db.get_or_create_name_location('start')\n    first_block = asmcfg.loc_key_to_block(lbl_real_start)\n    assignblk_head = AssignBlock([ExprAssign(lifter.IRDst, ExprLoc(lbl_real_start, lifter.IRDst.size)), ExprAssign(lifter.sp, lifter.arch.regs.regs_init[lifter.sp])], first_block.lines[0])\n    irb_head = IRBlock(loc_db, lbl_head, [assignblk_head])\n    ircfg.blocks[lbl_head] = irb_head\n    ircfg.add_uniq_edge(lbl_head, lbl_real_start)\n    state = TypePropagationEngine.StateEngine(infos_types)\n    states = {lbl_head: state}\n    todo = set([lbl_head])\n    done = set()\n    while todo:\n        lbl = todo.pop()\n        state = states[lbl]\n        if (lbl, state) in done:\n            continue\n        done.add((lbl, state))\n        if lbl not in ircfg.blocks:\n            continue\n        symbexec_engine = TypePropagationEngine(lifter, types_mngr, state)\n        symbexec_engine.run_block_at(ircfg, lbl)\n        symbexec_engine.del_mem_above_stack(lifter.sp)\n        sons = ircfg.successors(lbl)\n        for son in sons:\n            add_state(ircfg, todo, states, son, symbexec_engine.get_state())\n    for (lbl, state) in viewitems(states):\n        if lbl not in ircfg.blocks:\n            continue\n        symbexec_engine = CTypeEngineFixer(lifter, types_mngr, state, cst_propag_link)\n        symbexec_engine.run_block_at(ircfg, lbl)\n        symbexec_engine.del_mem_above_stack(lifter.sp)",
            "def analyse_function():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    settings = TypePropagationForm()\n    ret = settings.Execute()\n    if not ret:\n        return\n    end = None\n    if settings.cScope.value == 0:\n        addr = settings.functionAddr.value\n    else:\n        addr = settings.startAddr.value\n        if settings.cScope.value == 2:\n            end = settings.endAddr\n    machine = guess_machine(addr=addr)\n    (mn, dis_engine, lifter_model_call) = (machine.mn, machine.dis_engine, machine.lifter_model_call)\n    bs = bin_stream_ida()\n    loc_db = LocationDB()\n    mdis = dis_engine(bs, loc_db=loc_db, dont_dis_nulstart_bloc=True)\n    if end is not None:\n        mdis.dont_dis = [end]\n    lifter_model_callCallStackFixer = get_lifter_model_call_call_fixer(lifter_model_call)\n    lifter = lifter_model_callCallStackFixer(loc_db)\n    asmcfg = mdis.dis_multiblock(addr)\n    ircfg = lifter.new_ircfg_from_asmcfg(asmcfg)\n    cst_propag_link = {}\n    if settings.cUnalias.value:\n        init_infos = {lifter.sp: lifter.arch.regs.regs_init[lifter.sp]}\n        cst_propag_link = propagate_cst_expr(lifter, ircfg, addr, init_infos)\n    types_mngr = get_types_mngr(settings.headerFile.value, settings.arch.value)\n    mychandler = MyCHandler(types_mngr, {})\n    infos_types = {}\n    infos_types_raw = []\n    if settings.cTypeFile.value:\n        infos_types_raw = open(settings.typeFile.value).read().split('\\n')\n    else:\n        infos_types_raw = settings.strTypesInfo.value.split('\\n')\n    for line in infos_types_raw:\n        if not line:\n            continue\n        (expr_str, ctype_str) = line.split(':')\n        (expr_str, ctype_str) = (expr_str.strip(), ctype_str.strip())\n        expr = str_to_expr(expr_str)\n        ast = mychandler.types_mngr.types_ast.parse_c_type(ctype_str)\n        ctype = mychandler.types_mngr.types_ast.ast_parse_declaration(ast.ext[0])\n        objc = types_mngr.get_objc(ctype)\n        print('=' * 20)\n        print(expr, objc)\n        infos_types[expr] = set([objc])\n    lbl_real_start = loc_db.get_offset_location(addr)\n    lbl_head = loc_db.get_or_create_name_location('start')\n    first_block = asmcfg.loc_key_to_block(lbl_real_start)\n    assignblk_head = AssignBlock([ExprAssign(lifter.IRDst, ExprLoc(lbl_real_start, lifter.IRDst.size)), ExprAssign(lifter.sp, lifter.arch.regs.regs_init[lifter.sp])], first_block.lines[0])\n    irb_head = IRBlock(loc_db, lbl_head, [assignblk_head])\n    ircfg.blocks[lbl_head] = irb_head\n    ircfg.add_uniq_edge(lbl_head, lbl_real_start)\n    state = TypePropagationEngine.StateEngine(infos_types)\n    states = {lbl_head: state}\n    todo = set([lbl_head])\n    done = set()\n    while todo:\n        lbl = todo.pop()\n        state = states[lbl]\n        if (lbl, state) in done:\n            continue\n        done.add((lbl, state))\n        if lbl not in ircfg.blocks:\n            continue\n        symbexec_engine = TypePropagationEngine(lifter, types_mngr, state)\n        symbexec_engine.run_block_at(ircfg, lbl)\n        symbexec_engine.del_mem_above_stack(lifter.sp)\n        sons = ircfg.successors(lbl)\n        for son in sons:\n            add_state(ircfg, todo, states, son, symbexec_engine.get_state())\n    for (lbl, state) in viewitems(states):\n        if lbl not in ircfg.blocks:\n            continue\n        symbexec_engine = CTypeEngineFixer(lifter, types_mngr, state, cst_propag_link)\n        symbexec_engine.run_block_at(ircfg, lbl)\n        symbexec_engine.del_mem_above_stack(lifter.sp)",
            "def analyse_function():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    settings = TypePropagationForm()\n    ret = settings.Execute()\n    if not ret:\n        return\n    end = None\n    if settings.cScope.value == 0:\n        addr = settings.functionAddr.value\n    else:\n        addr = settings.startAddr.value\n        if settings.cScope.value == 2:\n            end = settings.endAddr\n    machine = guess_machine(addr=addr)\n    (mn, dis_engine, lifter_model_call) = (machine.mn, machine.dis_engine, machine.lifter_model_call)\n    bs = bin_stream_ida()\n    loc_db = LocationDB()\n    mdis = dis_engine(bs, loc_db=loc_db, dont_dis_nulstart_bloc=True)\n    if end is not None:\n        mdis.dont_dis = [end]\n    lifter_model_callCallStackFixer = get_lifter_model_call_call_fixer(lifter_model_call)\n    lifter = lifter_model_callCallStackFixer(loc_db)\n    asmcfg = mdis.dis_multiblock(addr)\n    ircfg = lifter.new_ircfg_from_asmcfg(asmcfg)\n    cst_propag_link = {}\n    if settings.cUnalias.value:\n        init_infos = {lifter.sp: lifter.arch.regs.regs_init[lifter.sp]}\n        cst_propag_link = propagate_cst_expr(lifter, ircfg, addr, init_infos)\n    types_mngr = get_types_mngr(settings.headerFile.value, settings.arch.value)\n    mychandler = MyCHandler(types_mngr, {})\n    infos_types = {}\n    infos_types_raw = []\n    if settings.cTypeFile.value:\n        infos_types_raw = open(settings.typeFile.value).read().split('\\n')\n    else:\n        infos_types_raw = settings.strTypesInfo.value.split('\\n')\n    for line in infos_types_raw:\n        if not line:\n            continue\n        (expr_str, ctype_str) = line.split(':')\n        (expr_str, ctype_str) = (expr_str.strip(), ctype_str.strip())\n        expr = str_to_expr(expr_str)\n        ast = mychandler.types_mngr.types_ast.parse_c_type(ctype_str)\n        ctype = mychandler.types_mngr.types_ast.ast_parse_declaration(ast.ext[0])\n        objc = types_mngr.get_objc(ctype)\n        print('=' * 20)\n        print(expr, objc)\n        infos_types[expr] = set([objc])\n    lbl_real_start = loc_db.get_offset_location(addr)\n    lbl_head = loc_db.get_or_create_name_location('start')\n    first_block = asmcfg.loc_key_to_block(lbl_real_start)\n    assignblk_head = AssignBlock([ExprAssign(lifter.IRDst, ExprLoc(lbl_real_start, lifter.IRDst.size)), ExprAssign(lifter.sp, lifter.arch.regs.regs_init[lifter.sp])], first_block.lines[0])\n    irb_head = IRBlock(loc_db, lbl_head, [assignblk_head])\n    ircfg.blocks[lbl_head] = irb_head\n    ircfg.add_uniq_edge(lbl_head, lbl_real_start)\n    state = TypePropagationEngine.StateEngine(infos_types)\n    states = {lbl_head: state}\n    todo = set([lbl_head])\n    done = set()\n    while todo:\n        lbl = todo.pop()\n        state = states[lbl]\n        if (lbl, state) in done:\n            continue\n        done.add((lbl, state))\n        if lbl not in ircfg.blocks:\n            continue\n        symbexec_engine = TypePropagationEngine(lifter, types_mngr, state)\n        symbexec_engine.run_block_at(ircfg, lbl)\n        symbexec_engine.del_mem_above_stack(lifter.sp)\n        sons = ircfg.successors(lbl)\n        for son in sons:\n            add_state(ircfg, todo, states, son, symbexec_engine.get_state())\n    for (lbl, state) in viewitems(states):\n        if lbl not in ircfg.blocks:\n            continue\n        symbexec_engine = CTypeEngineFixer(lifter, types_mngr, state, cst_propag_link)\n        symbexec_engine.run_block_at(ircfg, lbl)\n        symbexec_engine.del_mem_above_stack(lifter.sp)",
            "def analyse_function():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    settings = TypePropagationForm()\n    ret = settings.Execute()\n    if not ret:\n        return\n    end = None\n    if settings.cScope.value == 0:\n        addr = settings.functionAddr.value\n    else:\n        addr = settings.startAddr.value\n        if settings.cScope.value == 2:\n            end = settings.endAddr\n    machine = guess_machine(addr=addr)\n    (mn, dis_engine, lifter_model_call) = (machine.mn, machine.dis_engine, machine.lifter_model_call)\n    bs = bin_stream_ida()\n    loc_db = LocationDB()\n    mdis = dis_engine(bs, loc_db=loc_db, dont_dis_nulstart_bloc=True)\n    if end is not None:\n        mdis.dont_dis = [end]\n    lifter_model_callCallStackFixer = get_lifter_model_call_call_fixer(lifter_model_call)\n    lifter = lifter_model_callCallStackFixer(loc_db)\n    asmcfg = mdis.dis_multiblock(addr)\n    ircfg = lifter.new_ircfg_from_asmcfg(asmcfg)\n    cst_propag_link = {}\n    if settings.cUnalias.value:\n        init_infos = {lifter.sp: lifter.arch.regs.regs_init[lifter.sp]}\n        cst_propag_link = propagate_cst_expr(lifter, ircfg, addr, init_infos)\n    types_mngr = get_types_mngr(settings.headerFile.value, settings.arch.value)\n    mychandler = MyCHandler(types_mngr, {})\n    infos_types = {}\n    infos_types_raw = []\n    if settings.cTypeFile.value:\n        infos_types_raw = open(settings.typeFile.value).read().split('\\n')\n    else:\n        infos_types_raw = settings.strTypesInfo.value.split('\\n')\n    for line in infos_types_raw:\n        if not line:\n            continue\n        (expr_str, ctype_str) = line.split(':')\n        (expr_str, ctype_str) = (expr_str.strip(), ctype_str.strip())\n        expr = str_to_expr(expr_str)\n        ast = mychandler.types_mngr.types_ast.parse_c_type(ctype_str)\n        ctype = mychandler.types_mngr.types_ast.ast_parse_declaration(ast.ext[0])\n        objc = types_mngr.get_objc(ctype)\n        print('=' * 20)\n        print(expr, objc)\n        infos_types[expr] = set([objc])\n    lbl_real_start = loc_db.get_offset_location(addr)\n    lbl_head = loc_db.get_or_create_name_location('start')\n    first_block = asmcfg.loc_key_to_block(lbl_real_start)\n    assignblk_head = AssignBlock([ExprAssign(lifter.IRDst, ExprLoc(lbl_real_start, lifter.IRDst.size)), ExprAssign(lifter.sp, lifter.arch.regs.regs_init[lifter.sp])], first_block.lines[0])\n    irb_head = IRBlock(loc_db, lbl_head, [assignblk_head])\n    ircfg.blocks[lbl_head] = irb_head\n    ircfg.add_uniq_edge(lbl_head, lbl_real_start)\n    state = TypePropagationEngine.StateEngine(infos_types)\n    states = {lbl_head: state}\n    todo = set([lbl_head])\n    done = set()\n    while todo:\n        lbl = todo.pop()\n        state = states[lbl]\n        if (lbl, state) in done:\n            continue\n        done.add((lbl, state))\n        if lbl not in ircfg.blocks:\n            continue\n        symbexec_engine = TypePropagationEngine(lifter, types_mngr, state)\n        symbexec_engine.run_block_at(ircfg, lbl)\n        symbexec_engine.del_mem_above_stack(lifter.sp)\n        sons = ircfg.successors(lbl)\n        for son in sons:\n            add_state(ircfg, todo, states, son, symbexec_engine.get_state())\n    for (lbl, state) in viewitems(states):\n        if lbl not in ircfg.blocks:\n            continue\n        symbexec_engine = CTypeEngineFixer(lifter, types_mngr, state, cst_propag_link)\n        symbexec_engine.run_block_at(ircfg, lbl)\n        symbexec_engine.del_mem_above_stack(lifter.sp)"
        ]
    }
]