[
    {
        "func_name": "_get_figure_with_position",
        "original": "def _get_figure_with_position(position: dict, label_data: pd.DataFrame, start_date=None, end_date=None) -> Iterable[go.Figure]:\n    \"\"\"Get average analysis figures\n\n    :param position: position\n    :param label_data:\n    :param start_date:\n    :param end_date:\n    :return:\n    \"\"\"\n    _position_df = get_position_data(position, label_data, calculate_label_rank=True, start_date=start_date, end_date=end_date)\n    res_dict = dict()\n    _pos_gp = _position_df.groupby(level=1)\n    for _item in _pos_gp:\n        _date = _item[0]\n        _day_df = _item[1]\n        _day_value = res_dict.setdefault(_date, {})\n        for (_i, _name) in {0: 'Hold', 1: 'Buy', -1: 'Sell'}.items():\n            _temp_df = _day_df[_day_df['status'] == _i]\n            if _temp_df.empty:\n                _day_value[_name] = 0\n            else:\n                _day_value[_name] = _temp_df['rank_label_mean'].values[0]\n    _res_df = pd.DataFrame.from_dict(res_dict, orient='index')\n    _res_df.index = _res_df.index.strftime('%Y-%m-%d')\n    for _col in _res_df.columns:\n        yield ScatterGraph(_res_df.loc[:, [_col]], layout=dict(title=_col, xaxis=dict(type='category', tickangle=45), yaxis=dict(title='lable-rank-ratio: %')), graph_kwargs=dict(mode='lines+markers')).figure",
        "mutated": [
            "def _get_figure_with_position(position: dict, label_data: pd.DataFrame, start_date=None, end_date=None) -> Iterable[go.Figure]:\n    if False:\n        i = 10\n    'Get average analysis figures\\n\\n    :param position: position\\n    :param label_data:\\n    :param start_date:\\n    :param end_date:\\n    :return:\\n    '\n    _position_df = get_position_data(position, label_data, calculate_label_rank=True, start_date=start_date, end_date=end_date)\n    res_dict = dict()\n    _pos_gp = _position_df.groupby(level=1)\n    for _item in _pos_gp:\n        _date = _item[0]\n        _day_df = _item[1]\n        _day_value = res_dict.setdefault(_date, {})\n        for (_i, _name) in {0: 'Hold', 1: 'Buy', -1: 'Sell'}.items():\n            _temp_df = _day_df[_day_df['status'] == _i]\n            if _temp_df.empty:\n                _day_value[_name] = 0\n            else:\n                _day_value[_name] = _temp_df['rank_label_mean'].values[0]\n    _res_df = pd.DataFrame.from_dict(res_dict, orient='index')\n    _res_df.index = _res_df.index.strftime('%Y-%m-%d')\n    for _col in _res_df.columns:\n        yield ScatterGraph(_res_df.loc[:, [_col]], layout=dict(title=_col, xaxis=dict(type='category', tickangle=45), yaxis=dict(title='lable-rank-ratio: %')), graph_kwargs=dict(mode='lines+markers')).figure",
            "def _get_figure_with_position(position: dict, label_data: pd.DataFrame, start_date=None, end_date=None) -> Iterable[go.Figure]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Get average analysis figures\\n\\n    :param position: position\\n    :param label_data:\\n    :param start_date:\\n    :param end_date:\\n    :return:\\n    '\n    _position_df = get_position_data(position, label_data, calculate_label_rank=True, start_date=start_date, end_date=end_date)\n    res_dict = dict()\n    _pos_gp = _position_df.groupby(level=1)\n    for _item in _pos_gp:\n        _date = _item[0]\n        _day_df = _item[1]\n        _day_value = res_dict.setdefault(_date, {})\n        for (_i, _name) in {0: 'Hold', 1: 'Buy', -1: 'Sell'}.items():\n            _temp_df = _day_df[_day_df['status'] == _i]\n            if _temp_df.empty:\n                _day_value[_name] = 0\n            else:\n                _day_value[_name] = _temp_df['rank_label_mean'].values[0]\n    _res_df = pd.DataFrame.from_dict(res_dict, orient='index')\n    _res_df.index = _res_df.index.strftime('%Y-%m-%d')\n    for _col in _res_df.columns:\n        yield ScatterGraph(_res_df.loc[:, [_col]], layout=dict(title=_col, xaxis=dict(type='category', tickangle=45), yaxis=dict(title='lable-rank-ratio: %')), graph_kwargs=dict(mode='lines+markers')).figure",
            "def _get_figure_with_position(position: dict, label_data: pd.DataFrame, start_date=None, end_date=None) -> Iterable[go.Figure]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Get average analysis figures\\n\\n    :param position: position\\n    :param label_data:\\n    :param start_date:\\n    :param end_date:\\n    :return:\\n    '\n    _position_df = get_position_data(position, label_data, calculate_label_rank=True, start_date=start_date, end_date=end_date)\n    res_dict = dict()\n    _pos_gp = _position_df.groupby(level=1)\n    for _item in _pos_gp:\n        _date = _item[0]\n        _day_df = _item[1]\n        _day_value = res_dict.setdefault(_date, {})\n        for (_i, _name) in {0: 'Hold', 1: 'Buy', -1: 'Sell'}.items():\n            _temp_df = _day_df[_day_df['status'] == _i]\n            if _temp_df.empty:\n                _day_value[_name] = 0\n            else:\n                _day_value[_name] = _temp_df['rank_label_mean'].values[0]\n    _res_df = pd.DataFrame.from_dict(res_dict, orient='index')\n    _res_df.index = _res_df.index.strftime('%Y-%m-%d')\n    for _col in _res_df.columns:\n        yield ScatterGraph(_res_df.loc[:, [_col]], layout=dict(title=_col, xaxis=dict(type='category', tickangle=45), yaxis=dict(title='lable-rank-ratio: %')), graph_kwargs=dict(mode='lines+markers')).figure",
            "def _get_figure_with_position(position: dict, label_data: pd.DataFrame, start_date=None, end_date=None) -> Iterable[go.Figure]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Get average analysis figures\\n\\n    :param position: position\\n    :param label_data:\\n    :param start_date:\\n    :param end_date:\\n    :return:\\n    '\n    _position_df = get_position_data(position, label_data, calculate_label_rank=True, start_date=start_date, end_date=end_date)\n    res_dict = dict()\n    _pos_gp = _position_df.groupby(level=1)\n    for _item in _pos_gp:\n        _date = _item[0]\n        _day_df = _item[1]\n        _day_value = res_dict.setdefault(_date, {})\n        for (_i, _name) in {0: 'Hold', 1: 'Buy', -1: 'Sell'}.items():\n            _temp_df = _day_df[_day_df['status'] == _i]\n            if _temp_df.empty:\n                _day_value[_name] = 0\n            else:\n                _day_value[_name] = _temp_df['rank_label_mean'].values[0]\n    _res_df = pd.DataFrame.from_dict(res_dict, orient='index')\n    _res_df.index = _res_df.index.strftime('%Y-%m-%d')\n    for _col in _res_df.columns:\n        yield ScatterGraph(_res_df.loc[:, [_col]], layout=dict(title=_col, xaxis=dict(type='category', tickangle=45), yaxis=dict(title='lable-rank-ratio: %')), graph_kwargs=dict(mode='lines+markers')).figure",
            "def _get_figure_with_position(position: dict, label_data: pd.DataFrame, start_date=None, end_date=None) -> Iterable[go.Figure]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Get average analysis figures\\n\\n    :param position: position\\n    :param label_data:\\n    :param start_date:\\n    :param end_date:\\n    :return:\\n    '\n    _position_df = get_position_data(position, label_data, calculate_label_rank=True, start_date=start_date, end_date=end_date)\n    res_dict = dict()\n    _pos_gp = _position_df.groupby(level=1)\n    for _item in _pos_gp:\n        _date = _item[0]\n        _day_df = _item[1]\n        _day_value = res_dict.setdefault(_date, {})\n        for (_i, _name) in {0: 'Hold', 1: 'Buy', -1: 'Sell'}.items():\n            _temp_df = _day_df[_day_df['status'] == _i]\n            if _temp_df.empty:\n                _day_value[_name] = 0\n            else:\n                _day_value[_name] = _temp_df['rank_label_mean'].values[0]\n    _res_df = pd.DataFrame.from_dict(res_dict, orient='index')\n    _res_df.index = _res_df.index.strftime('%Y-%m-%d')\n    for _col in _res_df.columns:\n        yield ScatterGraph(_res_df.loc[:, [_col]], layout=dict(title=_col, xaxis=dict(type='category', tickangle=45), yaxis=dict(title='lable-rank-ratio: %')), graph_kwargs=dict(mode='lines+markers')).figure"
        ]
    },
    {
        "func_name": "rank_label_graph",
        "original": "def rank_label_graph(position: dict, label_data: pd.DataFrame, start_date=None, end_date=None, show_notebook=True) -> Iterable[go.Figure]:\n    \"\"\"Ranking percentage of stocks buy, sell, and holding on the trading day.\n    Average rank-ratio(similar to **sell_df['label'].rank(ascending=False) / len(sell_df)**) of daily trading\n\n        Example:\n\n\n            .. code-block:: python\n\n                from qlib.data import D\n                from qlib.contrib.evaluate import backtest\n                from qlib.contrib.strategy import TopkDropoutStrategy\n\n                # backtest parameters\n                bparas = {}\n                bparas['limit_threshold'] = 0.095\n                bparas['account'] = 1000000000\n\n                sparas = {}\n                sparas['topk'] = 50\n                sparas['n_drop'] = 230\n                strategy = TopkDropoutStrategy(**sparas)\n\n                _, positions = backtest(pred_df, strategy, **bparas)\n\n                pred_df_dates = pred_df.index.get_level_values(level='datetime')\n                features_df = D.features(D.instruments('csi500'), ['Ref($close, -1)/$close-1'], pred_df_dates.min(), pred_df_dates.max())\n                features_df.columns = ['label']\n\n                qcr.analysis_position.rank_label_graph(positions, features_df, pred_df_dates.min(), pred_df_dates.max())\n\n\n    :param position: position data; **qlib.backtest.backtest** result.\n    :param label_data: **D.features** result; index is **pd.MultiIndex**, index name is **[instrument, datetime]**; columns names is **[label]**.\n\n        **The label T is the change from T to T+1**, it is recommended to use ``close``, example: `D.features(D.instruments('csi500'), ['Ref($close, -1)/$close-1'])`.\n\n\n            .. code-block:: python\n\n                                                label\n                instrument  datetime\n                SH600004        2017-12-11  -0.013502\n                                2017-12-12  -0.072367\n                                2017-12-13  -0.068605\n                                2017-12-14  0.012440\n                                2017-12-15  -0.102778\n\n\n    :param start_date: start date\n    :param end_date: end_date\n    :param show_notebook: **True** or **False**. If True, show graph in notebook, else return figures.\n    :return:\n    \"\"\"\n    position = copy.deepcopy(position)\n    label_data.columns = ['label']\n    _figures = _get_figure_with_position(position, label_data, start_date, end_date)\n    if show_notebook:\n        ScatterGraph.show_graph_in_notebook(_figures)\n    else:\n        return _figures",
        "mutated": [
            "def rank_label_graph(position: dict, label_data: pd.DataFrame, start_date=None, end_date=None, show_notebook=True) -> Iterable[go.Figure]:\n    if False:\n        i = 10\n    \"Ranking percentage of stocks buy, sell, and holding on the trading day.\\n    Average rank-ratio(similar to **sell_df['label'].rank(ascending=False) / len(sell_df)**) of daily trading\\n\\n        Example:\\n\\n\\n            .. code-block:: python\\n\\n                from qlib.data import D\\n                from qlib.contrib.evaluate import backtest\\n                from qlib.contrib.strategy import TopkDropoutStrategy\\n\\n                # backtest parameters\\n                bparas = {}\\n                bparas['limit_threshold'] = 0.095\\n                bparas['account'] = 1000000000\\n\\n                sparas = {}\\n                sparas['topk'] = 50\\n                sparas['n_drop'] = 230\\n                strategy = TopkDropoutStrategy(**sparas)\\n\\n                _, positions = backtest(pred_df, strategy, **bparas)\\n\\n                pred_df_dates = pred_df.index.get_level_values(level='datetime')\\n                features_df = D.features(D.instruments('csi500'), ['Ref($close, -1)/$close-1'], pred_df_dates.min(), pred_df_dates.max())\\n                features_df.columns = ['label']\\n\\n                qcr.analysis_position.rank_label_graph(positions, features_df, pred_df_dates.min(), pred_df_dates.max())\\n\\n\\n    :param position: position data; **qlib.backtest.backtest** result.\\n    :param label_data: **D.features** result; index is **pd.MultiIndex**, index name is **[instrument, datetime]**; columns names is **[label]**.\\n\\n        **The label T is the change from T to T+1**, it is recommended to use ``close``, example: `D.features(D.instruments('csi500'), ['Ref($close, -1)/$close-1'])`.\\n\\n\\n            .. code-block:: python\\n\\n                                                label\\n                instrument  datetime\\n                SH600004        2017-12-11  -0.013502\\n                                2017-12-12  -0.072367\\n                                2017-12-13  -0.068605\\n                                2017-12-14  0.012440\\n                                2017-12-15  -0.102778\\n\\n\\n    :param start_date: start date\\n    :param end_date: end_date\\n    :param show_notebook: **True** or **False**. If True, show graph in notebook, else return figures.\\n    :return:\\n    \"\n    position = copy.deepcopy(position)\n    label_data.columns = ['label']\n    _figures = _get_figure_with_position(position, label_data, start_date, end_date)\n    if show_notebook:\n        ScatterGraph.show_graph_in_notebook(_figures)\n    else:\n        return _figures",
            "def rank_label_graph(position: dict, label_data: pd.DataFrame, start_date=None, end_date=None, show_notebook=True) -> Iterable[go.Figure]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Ranking percentage of stocks buy, sell, and holding on the trading day.\\n    Average rank-ratio(similar to **sell_df['label'].rank(ascending=False) / len(sell_df)**) of daily trading\\n\\n        Example:\\n\\n\\n            .. code-block:: python\\n\\n                from qlib.data import D\\n                from qlib.contrib.evaluate import backtest\\n                from qlib.contrib.strategy import TopkDropoutStrategy\\n\\n                # backtest parameters\\n                bparas = {}\\n                bparas['limit_threshold'] = 0.095\\n                bparas['account'] = 1000000000\\n\\n                sparas = {}\\n                sparas['topk'] = 50\\n                sparas['n_drop'] = 230\\n                strategy = TopkDropoutStrategy(**sparas)\\n\\n                _, positions = backtest(pred_df, strategy, **bparas)\\n\\n                pred_df_dates = pred_df.index.get_level_values(level='datetime')\\n                features_df = D.features(D.instruments('csi500'), ['Ref($close, -1)/$close-1'], pred_df_dates.min(), pred_df_dates.max())\\n                features_df.columns = ['label']\\n\\n                qcr.analysis_position.rank_label_graph(positions, features_df, pred_df_dates.min(), pred_df_dates.max())\\n\\n\\n    :param position: position data; **qlib.backtest.backtest** result.\\n    :param label_data: **D.features** result; index is **pd.MultiIndex**, index name is **[instrument, datetime]**; columns names is **[label]**.\\n\\n        **The label T is the change from T to T+1**, it is recommended to use ``close``, example: `D.features(D.instruments('csi500'), ['Ref($close, -1)/$close-1'])`.\\n\\n\\n            .. code-block:: python\\n\\n                                                label\\n                instrument  datetime\\n                SH600004        2017-12-11  -0.013502\\n                                2017-12-12  -0.072367\\n                                2017-12-13  -0.068605\\n                                2017-12-14  0.012440\\n                                2017-12-15  -0.102778\\n\\n\\n    :param start_date: start date\\n    :param end_date: end_date\\n    :param show_notebook: **True** or **False**. If True, show graph in notebook, else return figures.\\n    :return:\\n    \"\n    position = copy.deepcopy(position)\n    label_data.columns = ['label']\n    _figures = _get_figure_with_position(position, label_data, start_date, end_date)\n    if show_notebook:\n        ScatterGraph.show_graph_in_notebook(_figures)\n    else:\n        return _figures",
            "def rank_label_graph(position: dict, label_data: pd.DataFrame, start_date=None, end_date=None, show_notebook=True) -> Iterable[go.Figure]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Ranking percentage of stocks buy, sell, and holding on the trading day.\\n    Average rank-ratio(similar to **sell_df['label'].rank(ascending=False) / len(sell_df)**) of daily trading\\n\\n        Example:\\n\\n\\n            .. code-block:: python\\n\\n                from qlib.data import D\\n                from qlib.contrib.evaluate import backtest\\n                from qlib.contrib.strategy import TopkDropoutStrategy\\n\\n                # backtest parameters\\n                bparas = {}\\n                bparas['limit_threshold'] = 0.095\\n                bparas['account'] = 1000000000\\n\\n                sparas = {}\\n                sparas['topk'] = 50\\n                sparas['n_drop'] = 230\\n                strategy = TopkDropoutStrategy(**sparas)\\n\\n                _, positions = backtest(pred_df, strategy, **bparas)\\n\\n                pred_df_dates = pred_df.index.get_level_values(level='datetime')\\n                features_df = D.features(D.instruments('csi500'), ['Ref($close, -1)/$close-1'], pred_df_dates.min(), pred_df_dates.max())\\n                features_df.columns = ['label']\\n\\n                qcr.analysis_position.rank_label_graph(positions, features_df, pred_df_dates.min(), pred_df_dates.max())\\n\\n\\n    :param position: position data; **qlib.backtest.backtest** result.\\n    :param label_data: **D.features** result; index is **pd.MultiIndex**, index name is **[instrument, datetime]**; columns names is **[label]**.\\n\\n        **The label T is the change from T to T+1**, it is recommended to use ``close``, example: `D.features(D.instruments('csi500'), ['Ref($close, -1)/$close-1'])`.\\n\\n\\n            .. code-block:: python\\n\\n                                                label\\n                instrument  datetime\\n                SH600004        2017-12-11  -0.013502\\n                                2017-12-12  -0.072367\\n                                2017-12-13  -0.068605\\n                                2017-12-14  0.012440\\n                                2017-12-15  -0.102778\\n\\n\\n    :param start_date: start date\\n    :param end_date: end_date\\n    :param show_notebook: **True** or **False**. If True, show graph in notebook, else return figures.\\n    :return:\\n    \"\n    position = copy.deepcopy(position)\n    label_data.columns = ['label']\n    _figures = _get_figure_with_position(position, label_data, start_date, end_date)\n    if show_notebook:\n        ScatterGraph.show_graph_in_notebook(_figures)\n    else:\n        return _figures",
            "def rank_label_graph(position: dict, label_data: pd.DataFrame, start_date=None, end_date=None, show_notebook=True) -> Iterable[go.Figure]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Ranking percentage of stocks buy, sell, and holding on the trading day.\\n    Average rank-ratio(similar to **sell_df['label'].rank(ascending=False) / len(sell_df)**) of daily trading\\n\\n        Example:\\n\\n\\n            .. code-block:: python\\n\\n                from qlib.data import D\\n                from qlib.contrib.evaluate import backtest\\n                from qlib.contrib.strategy import TopkDropoutStrategy\\n\\n                # backtest parameters\\n                bparas = {}\\n                bparas['limit_threshold'] = 0.095\\n                bparas['account'] = 1000000000\\n\\n                sparas = {}\\n                sparas['topk'] = 50\\n                sparas['n_drop'] = 230\\n                strategy = TopkDropoutStrategy(**sparas)\\n\\n                _, positions = backtest(pred_df, strategy, **bparas)\\n\\n                pred_df_dates = pred_df.index.get_level_values(level='datetime')\\n                features_df = D.features(D.instruments('csi500'), ['Ref($close, -1)/$close-1'], pred_df_dates.min(), pred_df_dates.max())\\n                features_df.columns = ['label']\\n\\n                qcr.analysis_position.rank_label_graph(positions, features_df, pred_df_dates.min(), pred_df_dates.max())\\n\\n\\n    :param position: position data; **qlib.backtest.backtest** result.\\n    :param label_data: **D.features** result; index is **pd.MultiIndex**, index name is **[instrument, datetime]**; columns names is **[label]**.\\n\\n        **The label T is the change from T to T+1**, it is recommended to use ``close``, example: `D.features(D.instruments('csi500'), ['Ref($close, -1)/$close-1'])`.\\n\\n\\n            .. code-block:: python\\n\\n                                                label\\n                instrument  datetime\\n                SH600004        2017-12-11  -0.013502\\n                                2017-12-12  -0.072367\\n                                2017-12-13  -0.068605\\n                                2017-12-14  0.012440\\n                                2017-12-15  -0.102778\\n\\n\\n    :param start_date: start date\\n    :param end_date: end_date\\n    :param show_notebook: **True** or **False**. If True, show graph in notebook, else return figures.\\n    :return:\\n    \"\n    position = copy.deepcopy(position)\n    label_data.columns = ['label']\n    _figures = _get_figure_with_position(position, label_data, start_date, end_date)\n    if show_notebook:\n        ScatterGraph.show_graph_in_notebook(_figures)\n    else:\n        return _figures",
            "def rank_label_graph(position: dict, label_data: pd.DataFrame, start_date=None, end_date=None, show_notebook=True) -> Iterable[go.Figure]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Ranking percentage of stocks buy, sell, and holding on the trading day.\\n    Average rank-ratio(similar to **sell_df['label'].rank(ascending=False) / len(sell_df)**) of daily trading\\n\\n        Example:\\n\\n\\n            .. code-block:: python\\n\\n                from qlib.data import D\\n                from qlib.contrib.evaluate import backtest\\n                from qlib.contrib.strategy import TopkDropoutStrategy\\n\\n                # backtest parameters\\n                bparas = {}\\n                bparas['limit_threshold'] = 0.095\\n                bparas['account'] = 1000000000\\n\\n                sparas = {}\\n                sparas['topk'] = 50\\n                sparas['n_drop'] = 230\\n                strategy = TopkDropoutStrategy(**sparas)\\n\\n                _, positions = backtest(pred_df, strategy, **bparas)\\n\\n                pred_df_dates = pred_df.index.get_level_values(level='datetime')\\n                features_df = D.features(D.instruments('csi500'), ['Ref($close, -1)/$close-1'], pred_df_dates.min(), pred_df_dates.max())\\n                features_df.columns = ['label']\\n\\n                qcr.analysis_position.rank_label_graph(positions, features_df, pred_df_dates.min(), pred_df_dates.max())\\n\\n\\n    :param position: position data; **qlib.backtest.backtest** result.\\n    :param label_data: **D.features** result; index is **pd.MultiIndex**, index name is **[instrument, datetime]**; columns names is **[label]**.\\n\\n        **The label T is the change from T to T+1**, it is recommended to use ``close``, example: `D.features(D.instruments('csi500'), ['Ref($close, -1)/$close-1'])`.\\n\\n\\n            .. code-block:: python\\n\\n                                                label\\n                instrument  datetime\\n                SH600004        2017-12-11  -0.013502\\n                                2017-12-12  -0.072367\\n                                2017-12-13  -0.068605\\n                                2017-12-14  0.012440\\n                                2017-12-15  -0.102778\\n\\n\\n    :param start_date: start date\\n    :param end_date: end_date\\n    :param show_notebook: **True** or **False**. If True, show graph in notebook, else return figures.\\n    :return:\\n    \"\n    position = copy.deepcopy(position)\n    label_data.columns = ['label']\n    _figures = _get_figure_with_position(position, label_data, start_date, end_date)\n    if show_notebook:\n        ScatterGraph.show_graph_in_notebook(_figures)\n    else:\n        return _figures"
        ]
    }
]