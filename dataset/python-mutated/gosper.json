[
    {
        "func_name": "gosper_normal",
        "original": "def gosper_normal(f, g, n, polys=True):\n    \"\"\"\n    Compute the Gosper's normal form of ``f`` and ``g``.\n\n    Explanation\n    ===========\n\n    Given relatively prime univariate polynomials ``f`` and ``g``,\n    rewrite their quotient to a normal form defined as follows:\n\n    .. math::\n        \\\\frac{f(n)}{g(n)} = Z \\\\cdot \\\\frac{A(n) C(n+1)}{B(n) C(n)}\n\n    where ``Z`` is an arbitrary constant and ``A``, ``B``, ``C`` are\n    monic polynomials in ``n`` with the following properties:\n\n    1. `\\\\gcd(A(n), B(n+h)) = 1 \\\\forall h \\\\in \\\\mathbb{N}`\n    2. `\\\\gcd(B(n), C(n+1)) = 1`\n    3. `\\\\gcd(A(n), C(n)) = 1`\n\n    This normal form, or rational factorization in other words, is a\n    crucial step in Gosper's algorithm and in solving of difference\n    equations. It can be also used to decide if two hypergeometric\n    terms are similar or not.\n\n    This procedure will return a tuple containing elements of this\n    factorization in the form ``(Z*A, B, C)``.\n\n    Examples\n    ========\n\n    >>> from sympy.concrete.gosper import gosper_normal\n    >>> from sympy.abc import n\n\n    >>> gosper_normal(4*n+5, 2*(4*n+1)*(2*n+3), n, polys=False)\n    (1/4, n + 3/2, n + 1/4)\n\n    \"\"\"\n    ((p, q), opt) = parallel_poly_from_expr((f, g), n, field=True, extension=True)\n    (a, A) = (p.LC(), p.monic())\n    (b, B) = (q.LC(), q.monic())\n    (C, Z) = (A.one, a / b)\n    h = Dummy('h')\n    D = Poly(n + h, n, h, domain=opt.domain)\n    R = A.resultant(B.compose(D))\n    roots = set(R.ground_roots().keys())\n    for r in set(roots):\n        if not r.is_Integer or r < 0:\n            roots.remove(r)\n    for i in sorted(roots):\n        d = A.gcd(B.shift(+i))\n        A = A.quo(d)\n        B = B.quo(d.shift(-i))\n        for j in range(1, i + 1):\n            C *= d.shift(-j)\n    A = A.mul_ground(Z)\n    if not polys:\n        A = A.as_expr()\n        B = B.as_expr()\n        C = C.as_expr()\n    return (A, B, C)",
        "mutated": [
            "def gosper_normal(f, g, n, polys=True):\n    if False:\n        i = 10\n    \"\\n    Compute the Gosper's normal form of ``f`` and ``g``.\\n\\n    Explanation\\n    ===========\\n\\n    Given relatively prime univariate polynomials ``f`` and ``g``,\\n    rewrite their quotient to a normal form defined as follows:\\n\\n    .. math::\\n        \\\\frac{f(n)}{g(n)} = Z \\\\cdot \\\\frac{A(n) C(n+1)}{B(n) C(n)}\\n\\n    where ``Z`` is an arbitrary constant and ``A``, ``B``, ``C`` are\\n    monic polynomials in ``n`` with the following properties:\\n\\n    1. `\\\\gcd(A(n), B(n+h)) = 1 \\\\forall h \\\\in \\\\mathbb{N}`\\n    2. `\\\\gcd(B(n), C(n+1)) = 1`\\n    3. `\\\\gcd(A(n), C(n)) = 1`\\n\\n    This normal form, or rational factorization in other words, is a\\n    crucial step in Gosper's algorithm and in solving of difference\\n    equations. It can be also used to decide if two hypergeometric\\n    terms are similar or not.\\n\\n    This procedure will return a tuple containing elements of this\\n    factorization in the form ``(Z*A, B, C)``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.concrete.gosper import gosper_normal\\n    >>> from sympy.abc import n\\n\\n    >>> gosper_normal(4*n+5, 2*(4*n+1)*(2*n+3), n, polys=False)\\n    (1/4, n + 3/2, n + 1/4)\\n\\n    \"\n    ((p, q), opt) = parallel_poly_from_expr((f, g), n, field=True, extension=True)\n    (a, A) = (p.LC(), p.monic())\n    (b, B) = (q.LC(), q.monic())\n    (C, Z) = (A.one, a / b)\n    h = Dummy('h')\n    D = Poly(n + h, n, h, domain=opt.domain)\n    R = A.resultant(B.compose(D))\n    roots = set(R.ground_roots().keys())\n    for r in set(roots):\n        if not r.is_Integer or r < 0:\n            roots.remove(r)\n    for i in sorted(roots):\n        d = A.gcd(B.shift(+i))\n        A = A.quo(d)\n        B = B.quo(d.shift(-i))\n        for j in range(1, i + 1):\n            C *= d.shift(-j)\n    A = A.mul_ground(Z)\n    if not polys:\n        A = A.as_expr()\n        B = B.as_expr()\n        C = C.as_expr()\n    return (A, B, C)",
            "def gosper_normal(f, g, n, polys=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Compute the Gosper's normal form of ``f`` and ``g``.\\n\\n    Explanation\\n    ===========\\n\\n    Given relatively prime univariate polynomials ``f`` and ``g``,\\n    rewrite their quotient to a normal form defined as follows:\\n\\n    .. math::\\n        \\\\frac{f(n)}{g(n)} = Z \\\\cdot \\\\frac{A(n) C(n+1)}{B(n) C(n)}\\n\\n    where ``Z`` is an arbitrary constant and ``A``, ``B``, ``C`` are\\n    monic polynomials in ``n`` with the following properties:\\n\\n    1. `\\\\gcd(A(n), B(n+h)) = 1 \\\\forall h \\\\in \\\\mathbb{N}`\\n    2. `\\\\gcd(B(n), C(n+1)) = 1`\\n    3. `\\\\gcd(A(n), C(n)) = 1`\\n\\n    This normal form, or rational factorization in other words, is a\\n    crucial step in Gosper's algorithm and in solving of difference\\n    equations. It can be also used to decide if two hypergeometric\\n    terms are similar or not.\\n\\n    This procedure will return a tuple containing elements of this\\n    factorization in the form ``(Z*A, B, C)``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.concrete.gosper import gosper_normal\\n    >>> from sympy.abc import n\\n\\n    >>> gosper_normal(4*n+5, 2*(4*n+1)*(2*n+3), n, polys=False)\\n    (1/4, n + 3/2, n + 1/4)\\n\\n    \"\n    ((p, q), opt) = parallel_poly_from_expr((f, g), n, field=True, extension=True)\n    (a, A) = (p.LC(), p.monic())\n    (b, B) = (q.LC(), q.monic())\n    (C, Z) = (A.one, a / b)\n    h = Dummy('h')\n    D = Poly(n + h, n, h, domain=opt.domain)\n    R = A.resultant(B.compose(D))\n    roots = set(R.ground_roots().keys())\n    for r in set(roots):\n        if not r.is_Integer or r < 0:\n            roots.remove(r)\n    for i in sorted(roots):\n        d = A.gcd(B.shift(+i))\n        A = A.quo(d)\n        B = B.quo(d.shift(-i))\n        for j in range(1, i + 1):\n            C *= d.shift(-j)\n    A = A.mul_ground(Z)\n    if not polys:\n        A = A.as_expr()\n        B = B.as_expr()\n        C = C.as_expr()\n    return (A, B, C)",
            "def gosper_normal(f, g, n, polys=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Compute the Gosper's normal form of ``f`` and ``g``.\\n\\n    Explanation\\n    ===========\\n\\n    Given relatively prime univariate polynomials ``f`` and ``g``,\\n    rewrite their quotient to a normal form defined as follows:\\n\\n    .. math::\\n        \\\\frac{f(n)}{g(n)} = Z \\\\cdot \\\\frac{A(n) C(n+1)}{B(n) C(n)}\\n\\n    where ``Z`` is an arbitrary constant and ``A``, ``B``, ``C`` are\\n    monic polynomials in ``n`` with the following properties:\\n\\n    1. `\\\\gcd(A(n), B(n+h)) = 1 \\\\forall h \\\\in \\\\mathbb{N}`\\n    2. `\\\\gcd(B(n), C(n+1)) = 1`\\n    3. `\\\\gcd(A(n), C(n)) = 1`\\n\\n    This normal form, or rational factorization in other words, is a\\n    crucial step in Gosper's algorithm and in solving of difference\\n    equations. It can be also used to decide if two hypergeometric\\n    terms are similar or not.\\n\\n    This procedure will return a tuple containing elements of this\\n    factorization in the form ``(Z*A, B, C)``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.concrete.gosper import gosper_normal\\n    >>> from sympy.abc import n\\n\\n    >>> gosper_normal(4*n+5, 2*(4*n+1)*(2*n+3), n, polys=False)\\n    (1/4, n + 3/2, n + 1/4)\\n\\n    \"\n    ((p, q), opt) = parallel_poly_from_expr((f, g), n, field=True, extension=True)\n    (a, A) = (p.LC(), p.monic())\n    (b, B) = (q.LC(), q.monic())\n    (C, Z) = (A.one, a / b)\n    h = Dummy('h')\n    D = Poly(n + h, n, h, domain=opt.domain)\n    R = A.resultant(B.compose(D))\n    roots = set(R.ground_roots().keys())\n    for r in set(roots):\n        if not r.is_Integer or r < 0:\n            roots.remove(r)\n    for i in sorted(roots):\n        d = A.gcd(B.shift(+i))\n        A = A.quo(d)\n        B = B.quo(d.shift(-i))\n        for j in range(1, i + 1):\n            C *= d.shift(-j)\n    A = A.mul_ground(Z)\n    if not polys:\n        A = A.as_expr()\n        B = B.as_expr()\n        C = C.as_expr()\n    return (A, B, C)",
            "def gosper_normal(f, g, n, polys=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Compute the Gosper's normal form of ``f`` and ``g``.\\n\\n    Explanation\\n    ===========\\n\\n    Given relatively prime univariate polynomials ``f`` and ``g``,\\n    rewrite their quotient to a normal form defined as follows:\\n\\n    .. math::\\n        \\\\frac{f(n)}{g(n)} = Z \\\\cdot \\\\frac{A(n) C(n+1)}{B(n) C(n)}\\n\\n    where ``Z`` is an arbitrary constant and ``A``, ``B``, ``C`` are\\n    monic polynomials in ``n`` with the following properties:\\n\\n    1. `\\\\gcd(A(n), B(n+h)) = 1 \\\\forall h \\\\in \\\\mathbb{N}`\\n    2. `\\\\gcd(B(n), C(n+1)) = 1`\\n    3. `\\\\gcd(A(n), C(n)) = 1`\\n\\n    This normal form, or rational factorization in other words, is a\\n    crucial step in Gosper's algorithm and in solving of difference\\n    equations. It can be also used to decide if two hypergeometric\\n    terms are similar or not.\\n\\n    This procedure will return a tuple containing elements of this\\n    factorization in the form ``(Z*A, B, C)``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.concrete.gosper import gosper_normal\\n    >>> from sympy.abc import n\\n\\n    >>> gosper_normal(4*n+5, 2*(4*n+1)*(2*n+3), n, polys=False)\\n    (1/4, n + 3/2, n + 1/4)\\n\\n    \"\n    ((p, q), opt) = parallel_poly_from_expr((f, g), n, field=True, extension=True)\n    (a, A) = (p.LC(), p.monic())\n    (b, B) = (q.LC(), q.monic())\n    (C, Z) = (A.one, a / b)\n    h = Dummy('h')\n    D = Poly(n + h, n, h, domain=opt.domain)\n    R = A.resultant(B.compose(D))\n    roots = set(R.ground_roots().keys())\n    for r in set(roots):\n        if not r.is_Integer or r < 0:\n            roots.remove(r)\n    for i in sorted(roots):\n        d = A.gcd(B.shift(+i))\n        A = A.quo(d)\n        B = B.quo(d.shift(-i))\n        for j in range(1, i + 1):\n            C *= d.shift(-j)\n    A = A.mul_ground(Z)\n    if not polys:\n        A = A.as_expr()\n        B = B.as_expr()\n        C = C.as_expr()\n    return (A, B, C)",
            "def gosper_normal(f, g, n, polys=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Compute the Gosper's normal form of ``f`` and ``g``.\\n\\n    Explanation\\n    ===========\\n\\n    Given relatively prime univariate polynomials ``f`` and ``g``,\\n    rewrite their quotient to a normal form defined as follows:\\n\\n    .. math::\\n        \\\\frac{f(n)}{g(n)} = Z \\\\cdot \\\\frac{A(n) C(n+1)}{B(n) C(n)}\\n\\n    where ``Z`` is an arbitrary constant and ``A``, ``B``, ``C`` are\\n    monic polynomials in ``n`` with the following properties:\\n\\n    1. `\\\\gcd(A(n), B(n+h)) = 1 \\\\forall h \\\\in \\\\mathbb{N}`\\n    2. `\\\\gcd(B(n), C(n+1)) = 1`\\n    3. `\\\\gcd(A(n), C(n)) = 1`\\n\\n    This normal form, or rational factorization in other words, is a\\n    crucial step in Gosper's algorithm and in solving of difference\\n    equations. It can be also used to decide if two hypergeometric\\n    terms are similar or not.\\n\\n    This procedure will return a tuple containing elements of this\\n    factorization in the form ``(Z*A, B, C)``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.concrete.gosper import gosper_normal\\n    >>> from sympy.abc import n\\n\\n    >>> gosper_normal(4*n+5, 2*(4*n+1)*(2*n+3), n, polys=False)\\n    (1/4, n + 3/2, n + 1/4)\\n\\n    \"\n    ((p, q), opt) = parallel_poly_from_expr((f, g), n, field=True, extension=True)\n    (a, A) = (p.LC(), p.monic())\n    (b, B) = (q.LC(), q.monic())\n    (C, Z) = (A.one, a / b)\n    h = Dummy('h')\n    D = Poly(n + h, n, h, domain=opt.domain)\n    R = A.resultant(B.compose(D))\n    roots = set(R.ground_roots().keys())\n    for r in set(roots):\n        if not r.is_Integer or r < 0:\n            roots.remove(r)\n    for i in sorted(roots):\n        d = A.gcd(B.shift(+i))\n        A = A.quo(d)\n        B = B.quo(d.shift(-i))\n        for j in range(1, i + 1):\n            C *= d.shift(-j)\n    A = A.mul_ground(Z)\n    if not polys:\n        A = A.as_expr()\n        B = B.as_expr()\n        C = C.as_expr()\n    return (A, B, C)"
        ]
    },
    {
        "func_name": "gosper_term",
        "original": "def gosper_term(f, n):\n    \"\"\"\n    Compute Gosper's hypergeometric term for ``f``.\n\n    Explanation\n    ===========\n\n    Suppose ``f`` is a hypergeometric term such that:\n\n    .. math::\n        s_n = \\\\sum_{k=0}^{n-1} f_k\n\n    and `f_k` does not depend on `n`. Returns a hypergeometric\n    term `g_n` such that `g_{n+1} - g_n = f_n`.\n\n    Examples\n    ========\n\n    >>> from sympy.concrete.gosper import gosper_term\n    >>> from sympy import factorial\n    >>> from sympy.abc import n\n\n    >>> gosper_term((4*n + 1)*factorial(n)/factorial(2*n + 1), n)\n    (-n - 1/2)/(n + 1/4)\n\n    \"\"\"\n    from sympy.simplify import hypersimp\n    r = hypersimp(f, n)\n    if r is None:\n        return None\n    (p, q) = r.as_numer_denom()\n    (A, B, C) = gosper_normal(p, q, n)\n    B = B.shift(-1)\n    N = S(A.degree())\n    M = S(B.degree())\n    K = S(C.degree())\n    if N != M or A.LC() != B.LC():\n        D = {K - max(N, M)}\n    elif not N:\n        D = {K - N + 1, S.Zero}\n    else:\n        D = {K - N + 1, (B.nth(N - 1) - A.nth(N - 1)) / A.LC()}\n    for d in set(D):\n        if not d.is_Integer or d < 0:\n            D.remove(d)\n    if not D:\n        return None\n    d = max(D)\n    coeffs = symbols('c:%s' % (d + 1), cls=Dummy)\n    domain = A.get_domain().inject(*coeffs)\n    x = Poly(coeffs, n, domain=domain)\n    H = A * x.shift(1) - B * x - C\n    from sympy.solvers.solvers import solve\n    solution = solve(H.coeffs(), coeffs)\n    if solution is None:\n        return None\n    x = x.as_expr().subs(solution)\n    for coeff in coeffs:\n        if coeff not in solution:\n            x = x.subs(coeff, 0)\n    if x.is_zero:\n        return None\n    else:\n        return B.as_expr() * x / C.as_expr()",
        "mutated": [
            "def gosper_term(f, n):\n    if False:\n        i = 10\n    \"\\n    Compute Gosper's hypergeometric term for ``f``.\\n\\n    Explanation\\n    ===========\\n\\n    Suppose ``f`` is a hypergeometric term such that:\\n\\n    .. math::\\n        s_n = \\\\sum_{k=0}^{n-1} f_k\\n\\n    and `f_k` does not depend on `n`. Returns a hypergeometric\\n    term `g_n` such that `g_{n+1} - g_n = f_n`.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.concrete.gosper import gosper_term\\n    >>> from sympy import factorial\\n    >>> from sympy.abc import n\\n\\n    >>> gosper_term((4*n + 1)*factorial(n)/factorial(2*n + 1), n)\\n    (-n - 1/2)/(n + 1/4)\\n\\n    \"\n    from sympy.simplify import hypersimp\n    r = hypersimp(f, n)\n    if r is None:\n        return None\n    (p, q) = r.as_numer_denom()\n    (A, B, C) = gosper_normal(p, q, n)\n    B = B.shift(-1)\n    N = S(A.degree())\n    M = S(B.degree())\n    K = S(C.degree())\n    if N != M or A.LC() != B.LC():\n        D = {K - max(N, M)}\n    elif not N:\n        D = {K - N + 1, S.Zero}\n    else:\n        D = {K - N + 1, (B.nth(N - 1) - A.nth(N - 1)) / A.LC()}\n    for d in set(D):\n        if not d.is_Integer or d < 0:\n            D.remove(d)\n    if not D:\n        return None\n    d = max(D)\n    coeffs = symbols('c:%s' % (d + 1), cls=Dummy)\n    domain = A.get_domain().inject(*coeffs)\n    x = Poly(coeffs, n, domain=domain)\n    H = A * x.shift(1) - B * x - C\n    from sympy.solvers.solvers import solve\n    solution = solve(H.coeffs(), coeffs)\n    if solution is None:\n        return None\n    x = x.as_expr().subs(solution)\n    for coeff in coeffs:\n        if coeff not in solution:\n            x = x.subs(coeff, 0)\n    if x.is_zero:\n        return None\n    else:\n        return B.as_expr() * x / C.as_expr()",
            "def gosper_term(f, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Compute Gosper's hypergeometric term for ``f``.\\n\\n    Explanation\\n    ===========\\n\\n    Suppose ``f`` is a hypergeometric term such that:\\n\\n    .. math::\\n        s_n = \\\\sum_{k=0}^{n-1} f_k\\n\\n    and `f_k` does not depend on `n`. Returns a hypergeometric\\n    term `g_n` such that `g_{n+1} - g_n = f_n`.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.concrete.gosper import gosper_term\\n    >>> from sympy import factorial\\n    >>> from sympy.abc import n\\n\\n    >>> gosper_term((4*n + 1)*factorial(n)/factorial(2*n + 1), n)\\n    (-n - 1/2)/(n + 1/4)\\n\\n    \"\n    from sympy.simplify import hypersimp\n    r = hypersimp(f, n)\n    if r is None:\n        return None\n    (p, q) = r.as_numer_denom()\n    (A, B, C) = gosper_normal(p, q, n)\n    B = B.shift(-1)\n    N = S(A.degree())\n    M = S(B.degree())\n    K = S(C.degree())\n    if N != M or A.LC() != B.LC():\n        D = {K - max(N, M)}\n    elif not N:\n        D = {K - N + 1, S.Zero}\n    else:\n        D = {K - N + 1, (B.nth(N - 1) - A.nth(N - 1)) / A.LC()}\n    for d in set(D):\n        if not d.is_Integer or d < 0:\n            D.remove(d)\n    if not D:\n        return None\n    d = max(D)\n    coeffs = symbols('c:%s' % (d + 1), cls=Dummy)\n    domain = A.get_domain().inject(*coeffs)\n    x = Poly(coeffs, n, domain=domain)\n    H = A * x.shift(1) - B * x - C\n    from sympy.solvers.solvers import solve\n    solution = solve(H.coeffs(), coeffs)\n    if solution is None:\n        return None\n    x = x.as_expr().subs(solution)\n    for coeff in coeffs:\n        if coeff not in solution:\n            x = x.subs(coeff, 0)\n    if x.is_zero:\n        return None\n    else:\n        return B.as_expr() * x / C.as_expr()",
            "def gosper_term(f, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Compute Gosper's hypergeometric term for ``f``.\\n\\n    Explanation\\n    ===========\\n\\n    Suppose ``f`` is a hypergeometric term such that:\\n\\n    .. math::\\n        s_n = \\\\sum_{k=0}^{n-1} f_k\\n\\n    and `f_k` does not depend on `n`. Returns a hypergeometric\\n    term `g_n` such that `g_{n+1} - g_n = f_n`.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.concrete.gosper import gosper_term\\n    >>> from sympy import factorial\\n    >>> from sympy.abc import n\\n\\n    >>> gosper_term((4*n + 1)*factorial(n)/factorial(2*n + 1), n)\\n    (-n - 1/2)/(n + 1/4)\\n\\n    \"\n    from sympy.simplify import hypersimp\n    r = hypersimp(f, n)\n    if r is None:\n        return None\n    (p, q) = r.as_numer_denom()\n    (A, B, C) = gosper_normal(p, q, n)\n    B = B.shift(-1)\n    N = S(A.degree())\n    M = S(B.degree())\n    K = S(C.degree())\n    if N != M or A.LC() != B.LC():\n        D = {K - max(N, M)}\n    elif not N:\n        D = {K - N + 1, S.Zero}\n    else:\n        D = {K - N + 1, (B.nth(N - 1) - A.nth(N - 1)) / A.LC()}\n    for d in set(D):\n        if not d.is_Integer or d < 0:\n            D.remove(d)\n    if not D:\n        return None\n    d = max(D)\n    coeffs = symbols('c:%s' % (d + 1), cls=Dummy)\n    domain = A.get_domain().inject(*coeffs)\n    x = Poly(coeffs, n, domain=domain)\n    H = A * x.shift(1) - B * x - C\n    from sympy.solvers.solvers import solve\n    solution = solve(H.coeffs(), coeffs)\n    if solution is None:\n        return None\n    x = x.as_expr().subs(solution)\n    for coeff in coeffs:\n        if coeff not in solution:\n            x = x.subs(coeff, 0)\n    if x.is_zero:\n        return None\n    else:\n        return B.as_expr() * x / C.as_expr()",
            "def gosper_term(f, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Compute Gosper's hypergeometric term for ``f``.\\n\\n    Explanation\\n    ===========\\n\\n    Suppose ``f`` is a hypergeometric term such that:\\n\\n    .. math::\\n        s_n = \\\\sum_{k=0}^{n-1} f_k\\n\\n    and `f_k` does not depend on `n`. Returns a hypergeometric\\n    term `g_n` such that `g_{n+1} - g_n = f_n`.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.concrete.gosper import gosper_term\\n    >>> from sympy import factorial\\n    >>> from sympy.abc import n\\n\\n    >>> gosper_term((4*n + 1)*factorial(n)/factorial(2*n + 1), n)\\n    (-n - 1/2)/(n + 1/4)\\n\\n    \"\n    from sympy.simplify import hypersimp\n    r = hypersimp(f, n)\n    if r is None:\n        return None\n    (p, q) = r.as_numer_denom()\n    (A, B, C) = gosper_normal(p, q, n)\n    B = B.shift(-1)\n    N = S(A.degree())\n    M = S(B.degree())\n    K = S(C.degree())\n    if N != M or A.LC() != B.LC():\n        D = {K - max(N, M)}\n    elif not N:\n        D = {K - N + 1, S.Zero}\n    else:\n        D = {K - N + 1, (B.nth(N - 1) - A.nth(N - 1)) / A.LC()}\n    for d in set(D):\n        if not d.is_Integer or d < 0:\n            D.remove(d)\n    if not D:\n        return None\n    d = max(D)\n    coeffs = symbols('c:%s' % (d + 1), cls=Dummy)\n    domain = A.get_domain().inject(*coeffs)\n    x = Poly(coeffs, n, domain=domain)\n    H = A * x.shift(1) - B * x - C\n    from sympy.solvers.solvers import solve\n    solution = solve(H.coeffs(), coeffs)\n    if solution is None:\n        return None\n    x = x.as_expr().subs(solution)\n    for coeff in coeffs:\n        if coeff not in solution:\n            x = x.subs(coeff, 0)\n    if x.is_zero:\n        return None\n    else:\n        return B.as_expr() * x / C.as_expr()",
            "def gosper_term(f, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Compute Gosper's hypergeometric term for ``f``.\\n\\n    Explanation\\n    ===========\\n\\n    Suppose ``f`` is a hypergeometric term such that:\\n\\n    .. math::\\n        s_n = \\\\sum_{k=0}^{n-1} f_k\\n\\n    and `f_k` does not depend on `n`. Returns a hypergeometric\\n    term `g_n` such that `g_{n+1} - g_n = f_n`.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.concrete.gosper import gosper_term\\n    >>> from sympy import factorial\\n    >>> from sympy.abc import n\\n\\n    >>> gosper_term((4*n + 1)*factorial(n)/factorial(2*n + 1), n)\\n    (-n - 1/2)/(n + 1/4)\\n\\n    \"\n    from sympy.simplify import hypersimp\n    r = hypersimp(f, n)\n    if r is None:\n        return None\n    (p, q) = r.as_numer_denom()\n    (A, B, C) = gosper_normal(p, q, n)\n    B = B.shift(-1)\n    N = S(A.degree())\n    M = S(B.degree())\n    K = S(C.degree())\n    if N != M or A.LC() != B.LC():\n        D = {K - max(N, M)}\n    elif not N:\n        D = {K - N + 1, S.Zero}\n    else:\n        D = {K - N + 1, (B.nth(N - 1) - A.nth(N - 1)) / A.LC()}\n    for d in set(D):\n        if not d.is_Integer or d < 0:\n            D.remove(d)\n    if not D:\n        return None\n    d = max(D)\n    coeffs = symbols('c:%s' % (d + 1), cls=Dummy)\n    domain = A.get_domain().inject(*coeffs)\n    x = Poly(coeffs, n, domain=domain)\n    H = A * x.shift(1) - B * x - C\n    from sympy.solvers.solvers import solve\n    solution = solve(H.coeffs(), coeffs)\n    if solution is None:\n        return None\n    x = x.as_expr().subs(solution)\n    for coeff in coeffs:\n        if coeff not in solution:\n            x = x.subs(coeff, 0)\n    if x.is_zero:\n        return None\n    else:\n        return B.as_expr() * x / C.as_expr()"
        ]
    },
    {
        "func_name": "gosper_sum",
        "original": "def gosper_sum(f, k):\n    \"\"\"\n    Gosper's hypergeometric summation algorithm.\n\n    Explanation\n    ===========\n\n    Given a hypergeometric term ``f`` such that:\n\n    .. math ::\n        s_n = \\\\sum_{k=0}^{n-1} f_k\n\n    and `f(n)` does not depend on `n`, returns `g_{n} - g(0)` where\n    `g_{n+1} - g_n = f_n`, or ``None`` if `s_n` cannot be expressed\n    in closed form as a sum of hypergeometric terms.\n\n    Examples\n    ========\n\n    >>> from sympy.concrete.gosper import gosper_sum\n    >>> from sympy import factorial\n    >>> from sympy.abc import n, k\n\n    >>> f = (4*k + 1)*factorial(k)/factorial(2*k + 1)\n    >>> gosper_sum(f, (k, 0, n))\n    (-factorial(n) + 2*factorial(2*n + 1))/factorial(2*n + 1)\n    >>> _.subs(n, 2) == sum(f.subs(k, i) for i in [0, 1, 2])\n    True\n    >>> gosper_sum(f, (k, 3, n))\n    (-60*factorial(n) + factorial(2*n + 1))/(60*factorial(2*n + 1))\n    >>> _.subs(n, 5) == sum(f.subs(k, i) for i in [3, 4, 5])\n    True\n\n    References\n    ==========\n\n    .. [1] Marko Petkovsek, Herbert S. Wilf, Doron Zeilberger, A = B,\n           AK Peters, Ltd., Wellesley, MA, USA, 1997, pp. 73--100\n\n    \"\"\"\n    indefinite = False\n    if is_sequence(k):\n        (k, a, b) = k\n    else:\n        indefinite = True\n    g = gosper_term(f, k)\n    if g is None:\n        return None\n    if indefinite:\n        result = f * g\n    else:\n        result = (f * (g + 1)).subs(k, b) - (f * g).subs(k, a)\n        if result is S.NaN:\n            try:\n                result = (f * (g + 1)).limit(k, b) - (f * g).limit(k, a)\n            except NotImplementedError:\n                result = None\n    return factor(result)",
        "mutated": [
            "def gosper_sum(f, k):\n    if False:\n        i = 10\n    \"\\n    Gosper's hypergeometric summation algorithm.\\n\\n    Explanation\\n    ===========\\n\\n    Given a hypergeometric term ``f`` such that:\\n\\n    .. math ::\\n        s_n = \\\\sum_{k=0}^{n-1} f_k\\n\\n    and `f(n)` does not depend on `n`, returns `g_{n} - g(0)` where\\n    `g_{n+1} - g_n = f_n`, or ``None`` if `s_n` cannot be expressed\\n    in closed form as a sum of hypergeometric terms.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.concrete.gosper import gosper_sum\\n    >>> from sympy import factorial\\n    >>> from sympy.abc import n, k\\n\\n    >>> f = (4*k + 1)*factorial(k)/factorial(2*k + 1)\\n    >>> gosper_sum(f, (k, 0, n))\\n    (-factorial(n) + 2*factorial(2*n + 1))/factorial(2*n + 1)\\n    >>> _.subs(n, 2) == sum(f.subs(k, i) for i in [0, 1, 2])\\n    True\\n    >>> gosper_sum(f, (k, 3, n))\\n    (-60*factorial(n) + factorial(2*n + 1))/(60*factorial(2*n + 1))\\n    >>> _.subs(n, 5) == sum(f.subs(k, i) for i in [3, 4, 5])\\n    True\\n\\n    References\\n    ==========\\n\\n    .. [1] Marko Petkovsek, Herbert S. Wilf, Doron Zeilberger, A = B,\\n           AK Peters, Ltd., Wellesley, MA, USA, 1997, pp. 73--100\\n\\n    \"\n    indefinite = False\n    if is_sequence(k):\n        (k, a, b) = k\n    else:\n        indefinite = True\n    g = gosper_term(f, k)\n    if g is None:\n        return None\n    if indefinite:\n        result = f * g\n    else:\n        result = (f * (g + 1)).subs(k, b) - (f * g).subs(k, a)\n        if result is S.NaN:\n            try:\n                result = (f * (g + 1)).limit(k, b) - (f * g).limit(k, a)\n            except NotImplementedError:\n                result = None\n    return factor(result)",
            "def gosper_sum(f, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Gosper's hypergeometric summation algorithm.\\n\\n    Explanation\\n    ===========\\n\\n    Given a hypergeometric term ``f`` such that:\\n\\n    .. math ::\\n        s_n = \\\\sum_{k=0}^{n-1} f_k\\n\\n    and `f(n)` does not depend on `n`, returns `g_{n} - g(0)` where\\n    `g_{n+1} - g_n = f_n`, or ``None`` if `s_n` cannot be expressed\\n    in closed form as a sum of hypergeometric terms.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.concrete.gosper import gosper_sum\\n    >>> from sympy import factorial\\n    >>> from sympy.abc import n, k\\n\\n    >>> f = (4*k + 1)*factorial(k)/factorial(2*k + 1)\\n    >>> gosper_sum(f, (k, 0, n))\\n    (-factorial(n) + 2*factorial(2*n + 1))/factorial(2*n + 1)\\n    >>> _.subs(n, 2) == sum(f.subs(k, i) for i in [0, 1, 2])\\n    True\\n    >>> gosper_sum(f, (k, 3, n))\\n    (-60*factorial(n) + factorial(2*n + 1))/(60*factorial(2*n + 1))\\n    >>> _.subs(n, 5) == sum(f.subs(k, i) for i in [3, 4, 5])\\n    True\\n\\n    References\\n    ==========\\n\\n    .. [1] Marko Petkovsek, Herbert S. Wilf, Doron Zeilberger, A = B,\\n           AK Peters, Ltd., Wellesley, MA, USA, 1997, pp. 73--100\\n\\n    \"\n    indefinite = False\n    if is_sequence(k):\n        (k, a, b) = k\n    else:\n        indefinite = True\n    g = gosper_term(f, k)\n    if g is None:\n        return None\n    if indefinite:\n        result = f * g\n    else:\n        result = (f * (g + 1)).subs(k, b) - (f * g).subs(k, a)\n        if result is S.NaN:\n            try:\n                result = (f * (g + 1)).limit(k, b) - (f * g).limit(k, a)\n            except NotImplementedError:\n                result = None\n    return factor(result)",
            "def gosper_sum(f, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Gosper's hypergeometric summation algorithm.\\n\\n    Explanation\\n    ===========\\n\\n    Given a hypergeometric term ``f`` such that:\\n\\n    .. math ::\\n        s_n = \\\\sum_{k=0}^{n-1} f_k\\n\\n    and `f(n)` does not depend on `n`, returns `g_{n} - g(0)` where\\n    `g_{n+1} - g_n = f_n`, or ``None`` if `s_n` cannot be expressed\\n    in closed form as a sum of hypergeometric terms.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.concrete.gosper import gosper_sum\\n    >>> from sympy import factorial\\n    >>> from sympy.abc import n, k\\n\\n    >>> f = (4*k + 1)*factorial(k)/factorial(2*k + 1)\\n    >>> gosper_sum(f, (k, 0, n))\\n    (-factorial(n) + 2*factorial(2*n + 1))/factorial(2*n + 1)\\n    >>> _.subs(n, 2) == sum(f.subs(k, i) for i in [0, 1, 2])\\n    True\\n    >>> gosper_sum(f, (k, 3, n))\\n    (-60*factorial(n) + factorial(2*n + 1))/(60*factorial(2*n + 1))\\n    >>> _.subs(n, 5) == sum(f.subs(k, i) for i in [3, 4, 5])\\n    True\\n\\n    References\\n    ==========\\n\\n    .. [1] Marko Petkovsek, Herbert S. Wilf, Doron Zeilberger, A = B,\\n           AK Peters, Ltd., Wellesley, MA, USA, 1997, pp. 73--100\\n\\n    \"\n    indefinite = False\n    if is_sequence(k):\n        (k, a, b) = k\n    else:\n        indefinite = True\n    g = gosper_term(f, k)\n    if g is None:\n        return None\n    if indefinite:\n        result = f * g\n    else:\n        result = (f * (g + 1)).subs(k, b) - (f * g).subs(k, a)\n        if result is S.NaN:\n            try:\n                result = (f * (g + 1)).limit(k, b) - (f * g).limit(k, a)\n            except NotImplementedError:\n                result = None\n    return factor(result)",
            "def gosper_sum(f, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Gosper's hypergeometric summation algorithm.\\n\\n    Explanation\\n    ===========\\n\\n    Given a hypergeometric term ``f`` such that:\\n\\n    .. math ::\\n        s_n = \\\\sum_{k=0}^{n-1} f_k\\n\\n    and `f(n)` does not depend on `n`, returns `g_{n} - g(0)` where\\n    `g_{n+1} - g_n = f_n`, or ``None`` if `s_n` cannot be expressed\\n    in closed form as a sum of hypergeometric terms.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.concrete.gosper import gosper_sum\\n    >>> from sympy import factorial\\n    >>> from sympy.abc import n, k\\n\\n    >>> f = (4*k + 1)*factorial(k)/factorial(2*k + 1)\\n    >>> gosper_sum(f, (k, 0, n))\\n    (-factorial(n) + 2*factorial(2*n + 1))/factorial(2*n + 1)\\n    >>> _.subs(n, 2) == sum(f.subs(k, i) for i in [0, 1, 2])\\n    True\\n    >>> gosper_sum(f, (k, 3, n))\\n    (-60*factorial(n) + factorial(2*n + 1))/(60*factorial(2*n + 1))\\n    >>> _.subs(n, 5) == sum(f.subs(k, i) for i in [3, 4, 5])\\n    True\\n\\n    References\\n    ==========\\n\\n    .. [1] Marko Petkovsek, Herbert S. Wilf, Doron Zeilberger, A = B,\\n           AK Peters, Ltd., Wellesley, MA, USA, 1997, pp. 73--100\\n\\n    \"\n    indefinite = False\n    if is_sequence(k):\n        (k, a, b) = k\n    else:\n        indefinite = True\n    g = gosper_term(f, k)\n    if g is None:\n        return None\n    if indefinite:\n        result = f * g\n    else:\n        result = (f * (g + 1)).subs(k, b) - (f * g).subs(k, a)\n        if result is S.NaN:\n            try:\n                result = (f * (g + 1)).limit(k, b) - (f * g).limit(k, a)\n            except NotImplementedError:\n                result = None\n    return factor(result)",
            "def gosper_sum(f, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Gosper's hypergeometric summation algorithm.\\n\\n    Explanation\\n    ===========\\n\\n    Given a hypergeometric term ``f`` such that:\\n\\n    .. math ::\\n        s_n = \\\\sum_{k=0}^{n-1} f_k\\n\\n    and `f(n)` does not depend on `n`, returns `g_{n} - g(0)` where\\n    `g_{n+1} - g_n = f_n`, or ``None`` if `s_n` cannot be expressed\\n    in closed form as a sum of hypergeometric terms.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.concrete.gosper import gosper_sum\\n    >>> from sympy import factorial\\n    >>> from sympy.abc import n, k\\n\\n    >>> f = (4*k + 1)*factorial(k)/factorial(2*k + 1)\\n    >>> gosper_sum(f, (k, 0, n))\\n    (-factorial(n) + 2*factorial(2*n + 1))/factorial(2*n + 1)\\n    >>> _.subs(n, 2) == sum(f.subs(k, i) for i in [0, 1, 2])\\n    True\\n    >>> gosper_sum(f, (k, 3, n))\\n    (-60*factorial(n) + factorial(2*n + 1))/(60*factorial(2*n + 1))\\n    >>> _.subs(n, 5) == sum(f.subs(k, i) for i in [3, 4, 5])\\n    True\\n\\n    References\\n    ==========\\n\\n    .. [1] Marko Petkovsek, Herbert S. Wilf, Doron Zeilberger, A = B,\\n           AK Peters, Ltd., Wellesley, MA, USA, 1997, pp. 73--100\\n\\n    \"\n    indefinite = False\n    if is_sequence(k):\n        (k, a, b) = k\n    else:\n        indefinite = True\n    g = gosper_term(f, k)\n    if g is None:\n        return None\n    if indefinite:\n        result = f * g\n    else:\n        result = (f * (g + 1)).subs(k, b) - (f * g).subs(k, a)\n        if result is S.NaN:\n            try:\n                result = (f * (g + 1)).limit(k, b) - (f * g).limit(k, a)\n            except NotImplementedError:\n                result = None\n    return factor(result)"
        ]
    }
]