[
    {
        "func_name": "get_best_stat_str",
        "original": "def get_best_stat_str(task_vals, show_subdir):\n    task_to_best_val = {}\n    task_to_best_dir = {}\n    for (task, subdir_to_val) in task_vals.items():\n        task_to_best_val[task] = max(subdir_to_val.values())\n        task_to_best_dir[task] = max(subdir_to_val.keys(), key=lambda x: subdir_to_val[x])\n    N1 = len(task_to_best_val)\n    N2 = len([k for k in task_to_best_val if k != 'rte'])\n    avg1 = sum(task_to_best_val.values()) / N1\n    avg2 = sum((v for (task, v) in task_to_best_val.items() if task != 'rte')) / N2\n    try:\n        msg = ''\n        for task in TASKS:\n            dir = task_to_best_dir.get(task, 'null')\n            val = task_to_best_val.get(task, -100)\n            msg += f'({dir}, {val})\\t' if show_subdir else f'{val}\\t'\n        msg += f'{avg1:.2f}\\t{avg2:.2f}'\n    except Exception as e:\n        msg = str(e)\n        msg += str(sorted(task_vals.items()))\n    return msg",
        "mutated": [
            "def get_best_stat_str(task_vals, show_subdir):\n    if False:\n        i = 10\n    task_to_best_val = {}\n    task_to_best_dir = {}\n    for (task, subdir_to_val) in task_vals.items():\n        task_to_best_val[task] = max(subdir_to_val.values())\n        task_to_best_dir[task] = max(subdir_to_val.keys(), key=lambda x: subdir_to_val[x])\n    N1 = len(task_to_best_val)\n    N2 = len([k for k in task_to_best_val if k != 'rte'])\n    avg1 = sum(task_to_best_val.values()) / N1\n    avg2 = sum((v for (task, v) in task_to_best_val.items() if task != 'rte')) / N2\n    try:\n        msg = ''\n        for task in TASKS:\n            dir = task_to_best_dir.get(task, 'null')\n            val = task_to_best_val.get(task, -100)\n            msg += f'({dir}, {val})\\t' if show_subdir else f'{val}\\t'\n        msg += f'{avg1:.2f}\\t{avg2:.2f}'\n    except Exception as e:\n        msg = str(e)\n        msg += str(sorted(task_vals.items()))\n    return msg",
            "def get_best_stat_str(task_vals, show_subdir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    task_to_best_val = {}\n    task_to_best_dir = {}\n    for (task, subdir_to_val) in task_vals.items():\n        task_to_best_val[task] = max(subdir_to_val.values())\n        task_to_best_dir[task] = max(subdir_to_val.keys(), key=lambda x: subdir_to_val[x])\n    N1 = len(task_to_best_val)\n    N2 = len([k for k in task_to_best_val if k != 'rte'])\n    avg1 = sum(task_to_best_val.values()) / N1\n    avg2 = sum((v for (task, v) in task_to_best_val.items() if task != 'rte')) / N2\n    try:\n        msg = ''\n        for task in TASKS:\n            dir = task_to_best_dir.get(task, 'null')\n            val = task_to_best_val.get(task, -100)\n            msg += f'({dir}, {val})\\t' if show_subdir else f'{val}\\t'\n        msg += f'{avg1:.2f}\\t{avg2:.2f}'\n    except Exception as e:\n        msg = str(e)\n        msg += str(sorted(task_vals.items()))\n    return msg",
            "def get_best_stat_str(task_vals, show_subdir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    task_to_best_val = {}\n    task_to_best_dir = {}\n    for (task, subdir_to_val) in task_vals.items():\n        task_to_best_val[task] = max(subdir_to_val.values())\n        task_to_best_dir[task] = max(subdir_to_val.keys(), key=lambda x: subdir_to_val[x])\n    N1 = len(task_to_best_val)\n    N2 = len([k for k in task_to_best_val if k != 'rte'])\n    avg1 = sum(task_to_best_val.values()) / N1\n    avg2 = sum((v for (task, v) in task_to_best_val.items() if task != 'rte')) / N2\n    try:\n        msg = ''\n        for task in TASKS:\n            dir = task_to_best_dir.get(task, 'null')\n            val = task_to_best_val.get(task, -100)\n            msg += f'({dir}, {val})\\t' if show_subdir else f'{val}\\t'\n        msg += f'{avg1:.2f}\\t{avg2:.2f}'\n    except Exception as e:\n        msg = str(e)\n        msg += str(sorted(task_vals.items()))\n    return msg",
            "def get_best_stat_str(task_vals, show_subdir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    task_to_best_val = {}\n    task_to_best_dir = {}\n    for (task, subdir_to_val) in task_vals.items():\n        task_to_best_val[task] = max(subdir_to_val.values())\n        task_to_best_dir[task] = max(subdir_to_val.keys(), key=lambda x: subdir_to_val[x])\n    N1 = len(task_to_best_val)\n    N2 = len([k for k in task_to_best_val if k != 'rte'])\n    avg1 = sum(task_to_best_val.values()) / N1\n    avg2 = sum((v for (task, v) in task_to_best_val.items() if task != 'rte')) / N2\n    try:\n        msg = ''\n        for task in TASKS:\n            dir = task_to_best_dir.get(task, 'null')\n            val = task_to_best_val.get(task, -100)\n            msg += f'({dir}, {val})\\t' if show_subdir else f'{val}\\t'\n        msg += f'{avg1:.2f}\\t{avg2:.2f}'\n    except Exception as e:\n        msg = str(e)\n        msg += str(sorted(task_vals.items()))\n    return msg",
            "def get_best_stat_str(task_vals, show_subdir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    task_to_best_val = {}\n    task_to_best_dir = {}\n    for (task, subdir_to_val) in task_vals.items():\n        task_to_best_val[task] = max(subdir_to_val.values())\n        task_to_best_dir[task] = max(subdir_to_val.keys(), key=lambda x: subdir_to_val[x])\n    N1 = len(task_to_best_val)\n    N2 = len([k for k in task_to_best_val if k != 'rte'])\n    avg1 = sum(task_to_best_val.values()) / N1\n    avg2 = sum((v for (task, v) in task_to_best_val.items() if task != 'rte')) / N2\n    try:\n        msg = ''\n        for task in TASKS:\n            dir = task_to_best_dir.get(task, 'null')\n            val = task_to_best_val.get(task, -100)\n            msg += f'({dir}, {val})\\t' if show_subdir else f'{val}\\t'\n        msg += f'{avg1:.2f}\\t{avg2:.2f}'\n    except Exception as e:\n        msg = str(e)\n        msg += str(sorted(task_vals.items()))\n    return msg"
        ]
    },
    {
        "func_name": "get_all_stat_str",
        "original": "def get_all_stat_str(task_vals):\n    msg = ''\n    for task in [task for task in TASKS if task in task_vals]:\n        msg += f'=== {task}\\n'\n        for subdir in sorted(task_vals[task].keys()):\n            msg += f'\\t{subdir}\\t{task_vals[task][subdir]}\\n'\n    return msg",
        "mutated": [
            "def get_all_stat_str(task_vals):\n    if False:\n        i = 10\n    msg = ''\n    for task in [task for task in TASKS if task in task_vals]:\n        msg += f'=== {task}\\n'\n        for subdir in sorted(task_vals[task].keys()):\n            msg += f'\\t{subdir}\\t{task_vals[task][subdir]}\\n'\n    return msg",
            "def get_all_stat_str(task_vals):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    msg = ''\n    for task in [task for task in TASKS if task in task_vals]:\n        msg += f'=== {task}\\n'\n        for subdir in sorted(task_vals[task].keys()):\n            msg += f'\\t{subdir}\\t{task_vals[task][subdir]}\\n'\n    return msg",
            "def get_all_stat_str(task_vals):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    msg = ''\n    for task in [task for task in TASKS if task in task_vals]:\n        msg += f'=== {task}\\n'\n        for subdir in sorted(task_vals[task].keys()):\n            msg += f'\\t{subdir}\\t{task_vals[task][subdir]}\\n'\n    return msg",
            "def get_all_stat_str(task_vals):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    msg = ''\n    for task in [task for task in TASKS if task in task_vals]:\n        msg += f'=== {task}\\n'\n        for subdir in sorted(task_vals[task].keys()):\n            msg += f'\\t{subdir}\\t{task_vals[task][subdir]}\\n'\n    return msg",
            "def get_all_stat_str(task_vals):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    msg = ''\n    for task in [task for task in TASKS if task in task_vals]:\n        msg += f'=== {task}\\n'\n        for subdir in sorted(task_vals[task].keys()):\n            msg += f'\\t{subdir}\\t{task_vals[task][subdir]}\\n'\n    return msg"
        ]
    },
    {
        "func_name": "get_tabular_stat_str",
        "original": "def get_tabular_stat_str(task_vals):\n    \"\"\"assume subdir is <param>/run_*/0\"\"\"\n    msg = ''\n    for task in [task for task in TASKS if task in task_vals]:\n        msg += f'=== {task}\\n'\n        param_to_runs = defaultdict(dict)\n        for subdir in task_vals[task]:\n            match = re.match('(.*)/(run_.*)/0', subdir)\n            assert match, 'subdir'\n            (param, run) = match.groups()\n            param_to_runs[param][run] = task_vals[task][subdir]\n        params = sorted(param_to_runs, key=lambda x: float(x))\n        runs = sorted(set((run for runs in param_to_runs.values() for run in runs)))\n        msg += 'runs:' + '\\t'.join(runs) + '\\n'\n        msg += 'params:' + '\\t'.join(params) + '\\n'\n        for param in params:\n            msg += '\\t'.join([str(param_to_runs[param].get(run, None)) for run in runs])\n            msg += '\\n'\n    return msg",
        "mutated": [
            "def get_tabular_stat_str(task_vals):\n    if False:\n        i = 10\n    'assume subdir is <param>/run_*/0'\n    msg = ''\n    for task in [task for task in TASKS if task in task_vals]:\n        msg += f'=== {task}\\n'\n        param_to_runs = defaultdict(dict)\n        for subdir in task_vals[task]:\n            match = re.match('(.*)/(run_.*)/0', subdir)\n            assert match, 'subdir'\n            (param, run) = match.groups()\n            param_to_runs[param][run] = task_vals[task][subdir]\n        params = sorted(param_to_runs, key=lambda x: float(x))\n        runs = sorted(set((run for runs in param_to_runs.values() for run in runs)))\n        msg += 'runs:' + '\\t'.join(runs) + '\\n'\n        msg += 'params:' + '\\t'.join(params) + '\\n'\n        for param in params:\n            msg += '\\t'.join([str(param_to_runs[param].get(run, None)) for run in runs])\n            msg += '\\n'\n    return msg",
            "def get_tabular_stat_str(task_vals):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'assume subdir is <param>/run_*/0'\n    msg = ''\n    for task in [task for task in TASKS if task in task_vals]:\n        msg += f'=== {task}\\n'\n        param_to_runs = defaultdict(dict)\n        for subdir in task_vals[task]:\n            match = re.match('(.*)/(run_.*)/0', subdir)\n            assert match, 'subdir'\n            (param, run) = match.groups()\n            param_to_runs[param][run] = task_vals[task][subdir]\n        params = sorted(param_to_runs, key=lambda x: float(x))\n        runs = sorted(set((run for runs in param_to_runs.values() for run in runs)))\n        msg += 'runs:' + '\\t'.join(runs) + '\\n'\n        msg += 'params:' + '\\t'.join(params) + '\\n'\n        for param in params:\n            msg += '\\t'.join([str(param_to_runs[param].get(run, None)) for run in runs])\n            msg += '\\n'\n    return msg",
            "def get_tabular_stat_str(task_vals):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'assume subdir is <param>/run_*/0'\n    msg = ''\n    for task in [task for task in TASKS if task in task_vals]:\n        msg += f'=== {task}\\n'\n        param_to_runs = defaultdict(dict)\n        for subdir in task_vals[task]:\n            match = re.match('(.*)/(run_.*)/0', subdir)\n            assert match, 'subdir'\n            (param, run) = match.groups()\n            param_to_runs[param][run] = task_vals[task][subdir]\n        params = sorted(param_to_runs, key=lambda x: float(x))\n        runs = sorted(set((run for runs in param_to_runs.values() for run in runs)))\n        msg += 'runs:' + '\\t'.join(runs) + '\\n'\n        msg += 'params:' + '\\t'.join(params) + '\\n'\n        for param in params:\n            msg += '\\t'.join([str(param_to_runs[param].get(run, None)) for run in runs])\n            msg += '\\n'\n    return msg",
            "def get_tabular_stat_str(task_vals):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'assume subdir is <param>/run_*/0'\n    msg = ''\n    for task in [task for task in TASKS if task in task_vals]:\n        msg += f'=== {task}\\n'\n        param_to_runs = defaultdict(dict)\n        for subdir in task_vals[task]:\n            match = re.match('(.*)/(run_.*)/0', subdir)\n            assert match, 'subdir'\n            (param, run) = match.groups()\n            param_to_runs[param][run] = task_vals[task][subdir]\n        params = sorted(param_to_runs, key=lambda x: float(x))\n        runs = sorted(set((run for runs in param_to_runs.values() for run in runs)))\n        msg += 'runs:' + '\\t'.join(runs) + '\\n'\n        msg += 'params:' + '\\t'.join(params) + '\\n'\n        for param in params:\n            msg += '\\t'.join([str(param_to_runs[param].get(run, None)) for run in runs])\n            msg += '\\n'\n    return msg",
            "def get_tabular_stat_str(task_vals):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'assume subdir is <param>/run_*/0'\n    msg = ''\n    for task in [task for task in TASKS if task in task_vals]:\n        msg += f'=== {task}\\n'\n        param_to_runs = defaultdict(dict)\n        for subdir in task_vals[task]:\n            match = re.match('(.*)/(run_.*)/0', subdir)\n            assert match, 'subdir'\n            (param, run) = match.groups()\n            param_to_runs[param][run] = task_vals[task][subdir]\n        params = sorted(param_to_runs, key=lambda x: float(x))\n        runs = sorted(set((run for runs in param_to_runs.values() for run in runs)))\n        msg += 'runs:' + '\\t'.join(runs) + '\\n'\n        msg += 'params:' + '\\t'.join(params) + '\\n'\n        for param in params:\n            msg += '\\t'.join([str(param_to_runs[param].get(run, None)) for run in runs])\n            msg += '\\n'\n    return msg"
        ]
    },
    {
        "func_name": "main",
        "original": "def main():\n    parser.add_argument('--show_glue', action='store_true', help='show glue metric for each task instead of accuracy')\n    parser.add_argument('--print_mode', default='best', help='best|all|tabular')\n    parser.add_argument('--show_subdir', action='store_true', help='print the subdir that has the best results for each run')\n    parser.add_argument('--override_target', default='valid_accuracy', help='override target')\n    args = parser.parse_args()\n    args.target = args.override_target\n    args.best_biggest = True\n    args.best = True\n    args.last = 0\n    args.path_contains = None\n    res = valids_main(args, print_output=False)\n    grouped_acc = {}\n    grouped_met = {}\n    for (path, v) in res.items():\n        path = '/'.join([args.base, path])\n        path = re.sub('//*', '/', path)\n        match = re.match('(.*)finetune[^/]*/([^/]*)/(.*)', path)\n        if not match:\n            continue\n        (run, task, subdir) = match.groups()\n        if run not in grouped_acc:\n            grouped_acc[run] = {}\n            grouped_met[run] = {}\n        if task not in grouped_acc[run]:\n            grouped_acc[run][task] = {}\n            grouped_met[run][task] = {}\n        if v is not None:\n            grouped_acc[run][task][subdir] = float(v.get('valid_accuracy', -100))\n            grouped_met[run][task][subdir] = float(v.get(f'valid_{TASK_TO_METRIC[task]}', -100))\n        else:\n            print(f'{path} has None return')\n    header = '\\t'.join(TASKS)\n    for run in sorted(grouped_acc):\n        print(run)\n        if args.print_mode == 'all':\n            if args.show_glue:\n                print('===== GLUE =====')\n                print(get_all_stat_str(grouped_met[run]))\n            else:\n                print('===== ACC =====')\n                print(get_all_stat_str(grouped_acc[run]))\n        elif args.print_mode == 'best':\n            print(f'      {header}')\n            if args.show_glue:\n                print(f'GLEU: {get_best_stat_str(grouped_met[run], args.show_subdir)}')\n            else:\n                print(f'ACC:  {get_best_stat_str(grouped_acc[run], args.show_subdir)}')\n        elif args.print_mode == 'tabular':\n            if args.show_glue:\n                print('===== GLUE =====')\n                print(get_tabular_stat_str(grouped_met[run]))\n            else:\n                print('===== ACC =====')\n                print(get_tabular_stat_str(grouped_acc[run]))\n        else:\n            raise ValueError(args.print_mode)\n        print()",
        "mutated": [
            "def main():\n    if False:\n        i = 10\n    parser.add_argument('--show_glue', action='store_true', help='show glue metric for each task instead of accuracy')\n    parser.add_argument('--print_mode', default='best', help='best|all|tabular')\n    parser.add_argument('--show_subdir', action='store_true', help='print the subdir that has the best results for each run')\n    parser.add_argument('--override_target', default='valid_accuracy', help='override target')\n    args = parser.parse_args()\n    args.target = args.override_target\n    args.best_biggest = True\n    args.best = True\n    args.last = 0\n    args.path_contains = None\n    res = valids_main(args, print_output=False)\n    grouped_acc = {}\n    grouped_met = {}\n    for (path, v) in res.items():\n        path = '/'.join([args.base, path])\n        path = re.sub('//*', '/', path)\n        match = re.match('(.*)finetune[^/]*/([^/]*)/(.*)', path)\n        if not match:\n            continue\n        (run, task, subdir) = match.groups()\n        if run not in grouped_acc:\n            grouped_acc[run] = {}\n            grouped_met[run] = {}\n        if task not in grouped_acc[run]:\n            grouped_acc[run][task] = {}\n            grouped_met[run][task] = {}\n        if v is not None:\n            grouped_acc[run][task][subdir] = float(v.get('valid_accuracy', -100))\n            grouped_met[run][task][subdir] = float(v.get(f'valid_{TASK_TO_METRIC[task]}', -100))\n        else:\n            print(f'{path} has None return')\n    header = '\\t'.join(TASKS)\n    for run in sorted(grouped_acc):\n        print(run)\n        if args.print_mode == 'all':\n            if args.show_glue:\n                print('===== GLUE =====')\n                print(get_all_stat_str(grouped_met[run]))\n            else:\n                print('===== ACC =====')\n                print(get_all_stat_str(grouped_acc[run]))\n        elif args.print_mode == 'best':\n            print(f'      {header}')\n            if args.show_glue:\n                print(f'GLEU: {get_best_stat_str(grouped_met[run], args.show_subdir)}')\n            else:\n                print(f'ACC:  {get_best_stat_str(grouped_acc[run], args.show_subdir)}')\n        elif args.print_mode == 'tabular':\n            if args.show_glue:\n                print('===== GLUE =====')\n                print(get_tabular_stat_str(grouped_met[run]))\n            else:\n                print('===== ACC =====')\n                print(get_tabular_stat_str(grouped_acc[run]))\n        else:\n            raise ValueError(args.print_mode)\n        print()",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    parser.add_argument('--show_glue', action='store_true', help='show glue metric for each task instead of accuracy')\n    parser.add_argument('--print_mode', default='best', help='best|all|tabular')\n    parser.add_argument('--show_subdir', action='store_true', help='print the subdir that has the best results for each run')\n    parser.add_argument('--override_target', default='valid_accuracy', help='override target')\n    args = parser.parse_args()\n    args.target = args.override_target\n    args.best_biggest = True\n    args.best = True\n    args.last = 0\n    args.path_contains = None\n    res = valids_main(args, print_output=False)\n    grouped_acc = {}\n    grouped_met = {}\n    for (path, v) in res.items():\n        path = '/'.join([args.base, path])\n        path = re.sub('//*', '/', path)\n        match = re.match('(.*)finetune[^/]*/([^/]*)/(.*)', path)\n        if not match:\n            continue\n        (run, task, subdir) = match.groups()\n        if run not in grouped_acc:\n            grouped_acc[run] = {}\n            grouped_met[run] = {}\n        if task not in grouped_acc[run]:\n            grouped_acc[run][task] = {}\n            grouped_met[run][task] = {}\n        if v is not None:\n            grouped_acc[run][task][subdir] = float(v.get('valid_accuracy', -100))\n            grouped_met[run][task][subdir] = float(v.get(f'valid_{TASK_TO_METRIC[task]}', -100))\n        else:\n            print(f'{path} has None return')\n    header = '\\t'.join(TASKS)\n    for run in sorted(grouped_acc):\n        print(run)\n        if args.print_mode == 'all':\n            if args.show_glue:\n                print('===== GLUE =====')\n                print(get_all_stat_str(grouped_met[run]))\n            else:\n                print('===== ACC =====')\n                print(get_all_stat_str(grouped_acc[run]))\n        elif args.print_mode == 'best':\n            print(f'      {header}')\n            if args.show_glue:\n                print(f'GLEU: {get_best_stat_str(grouped_met[run], args.show_subdir)}')\n            else:\n                print(f'ACC:  {get_best_stat_str(grouped_acc[run], args.show_subdir)}')\n        elif args.print_mode == 'tabular':\n            if args.show_glue:\n                print('===== GLUE =====')\n                print(get_tabular_stat_str(grouped_met[run]))\n            else:\n                print('===== ACC =====')\n                print(get_tabular_stat_str(grouped_acc[run]))\n        else:\n            raise ValueError(args.print_mode)\n        print()",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    parser.add_argument('--show_glue', action='store_true', help='show glue metric for each task instead of accuracy')\n    parser.add_argument('--print_mode', default='best', help='best|all|tabular')\n    parser.add_argument('--show_subdir', action='store_true', help='print the subdir that has the best results for each run')\n    parser.add_argument('--override_target', default='valid_accuracy', help='override target')\n    args = parser.parse_args()\n    args.target = args.override_target\n    args.best_biggest = True\n    args.best = True\n    args.last = 0\n    args.path_contains = None\n    res = valids_main(args, print_output=False)\n    grouped_acc = {}\n    grouped_met = {}\n    for (path, v) in res.items():\n        path = '/'.join([args.base, path])\n        path = re.sub('//*', '/', path)\n        match = re.match('(.*)finetune[^/]*/([^/]*)/(.*)', path)\n        if not match:\n            continue\n        (run, task, subdir) = match.groups()\n        if run not in grouped_acc:\n            grouped_acc[run] = {}\n            grouped_met[run] = {}\n        if task not in grouped_acc[run]:\n            grouped_acc[run][task] = {}\n            grouped_met[run][task] = {}\n        if v is not None:\n            grouped_acc[run][task][subdir] = float(v.get('valid_accuracy', -100))\n            grouped_met[run][task][subdir] = float(v.get(f'valid_{TASK_TO_METRIC[task]}', -100))\n        else:\n            print(f'{path} has None return')\n    header = '\\t'.join(TASKS)\n    for run in sorted(grouped_acc):\n        print(run)\n        if args.print_mode == 'all':\n            if args.show_glue:\n                print('===== GLUE =====')\n                print(get_all_stat_str(grouped_met[run]))\n            else:\n                print('===== ACC =====')\n                print(get_all_stat_str(grouped_acc[run]))\n        elif args.print_mode == 'best':\n            print(f'      {header}')\n            if args.show_glue:\n                print(f'GLEU: {get_best_stat_str(grouped_met[run], args.show_subdir)}')\n            else:\n                print(f'ACC:  {get_best_stat_str(grouped_acc[run], args.show_subdir)}')\n        elif args.print_mode == 'tabular':\n            if args.show_glue:\n                print('===== GLUE =====')\n                print(get_tabular_stat_str(grouped_met[run]))\n            else:\n                print('===== ACC =====')\n                print(get_tabular_stat_str(grouped_acc[run]))\n        else:\n            raise ValueError(args.print_mode)\n        print()",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    parser.add_argument('--show_glue', action='store_true', help='show glue metric for each task instead of accuracy')\n    parser.add_argument('--print_mode', default='best', help='best|all|tabular')\n    parser.add_argument('--show_subdir', action='store_true', help='print the subdir that has the best results for each run')\n    parser.add_argument('--override_target', default='valid_accuracy', help='override target')\n    args = parser.parse_args()\n    args.target = args.override_target\n    args.best_biggest = True\n    args.best = True\n    args.last = 0\n    args.path_contains = None\n    res = valids_main(args, print_output=False)\n    grouped_acc = {}\n    grouped_met = {}\n    for (path, v) in res.items():\n        path = '/'.join([args.base, path])\n        path = re.sub('//*', '/', path)\n        match = re.match('(.*)finetune[^/]*/([^/]*)/(.*)', path)\n        if not match:\n            continue\n        (run, task, subdir) = match.groups()\n        if run not in grouped_acc:\n            grouped_acc[run] = {}\n            grouped_met[run] = {}\n        if task not in grouped_acc[run]:\n            grouped_acc[run][task] = {}\n            grouped_met[run][task] = {}\n        if v is not None:\n            grouped_acc[run][task][subdir] = float(v.get('valid_accuracy', -100))\n            grouped_met[run][task][subdir] = float(v.get(f'valid_{TASK_TO_METRIC[task]}', -100))\n        else:\n            print(f'{path} has None return')\n    header = '\\t'.join(TASKS)\n    for run in sorted(grouped_acc):\n        print(run)\n        if args.print_mode == 'all':\n            if args.show_glue:\n                print('===== GLUE =====')\n                print(get_all_stat_str(grouped_met[run]))\n            else:\n                print('===== ACC =====')\n                print(get_all_stat_str(grouped_acc[run]))\n        elif args.print_mode == 'best':\n            print(f'      {header}')\n            if args.show_glue:\n                print(f'GLEU: {get_best_stat_str(grouped_met[run], args.show_subdir)}')\n            else:\n                print(f'ACC:  {get_best_stat_str(grouped_acc[run], args.show_subdir)}')\n        elif args.print_mode == 'tabular':\n            if args.show_glue:\n                print('===== GLUE =====')\n                print(get_tabular_stat_str(grouped_met[run]))\n            else:\n                print('===== ACC =====')\n                print(get_tabular_stat_str(grouped_acc[run]))\n        else:\n            raise ValueError(args.print_mode)\n        print()",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    parser.add_argument('--show_glue', action='store_true', help='show glue metric for each task instead of accuracy')\n    parser.add_argument('--print_mode', default='best', help='best|all|tabular')\n    parser.add_argument('--show_subdir', action='store_true', help='print the subdir that has the best results for each run')\n    parser.add_argument('--override_target', default='valid_accuracy', help='override target')\n    args = parser.parse_args()\n    args.target = args.override_target\n    args.best_biggest = True\n    args.best = True\n    args.last = 0\n    args.path_contains = None\n    res = valids_main(args, print_output=False)\n    grouped_acc = {}\n    grouped_met = {}\n    for (path, v) in res.items():\n        path = '/'.join([args.base, path])\n        path = re.sub('//*', '/', path)\n        match = re.match('(.*)finetune[^/]*/([^/]*)/(.*)', path)\n        if not match:\n            continue\n        (run, task, subdir) = match.groups()\n        if run not in grouped_acc:\n            grouped_acc[run] = {}\n            grouped_met[run] = {}\n        if task not in grouped_acc[run]:\n            grouped_acc[run][task] = {}\n            grouped_met[run][task] = {}\n        if v is not None:\n            grouped_acc[run][task][subdir] = float(v.get('valid_accuracy', -100))\n            grouped_met[run][task][subdir] = float(v.get(f'valid_{TASK_TO_METRIC[task]}', -100))\n        else:\n            print(f'{path} has None return')\n    header = '\\t'.join(TASKS)\n    for run in sorted(grouped_acc):\n        print(run)\n        if args.print_mode == 'all':\n            if args.show_glue:\n                print('===== GLUE =====')\n                print(get_all_stat_str(grouped_met[run]))\n            else:\n                print('===== ACC =====')\n                print(get_all_stat_str(grouped_acc[run]))\n        elif args.print_mode == 'best':\n            print(f'      {header}')\n            if args.show_glue:\n                print(f'GLEU: {get_best_stat_str(grouped_met[run], args.show_subdir)}')\n            else:\n                print(f'ACC:  {get_best_stat_str(grouped_acc[run], args.show_subdir)}')\n        elif args.print_mode == 'tabular':\n            if args.show_glue:\n                print('===== GLUE =====')\n                print(get_tabular_stat_str(grouped_met[run]))\n            else:\n                print('===== ACC =====')\n                print(get_tabular_stat_str(grouped_acc[run]))\n        else:\n            raise ValueError(args.print_mode)\n        print()"
        ]
    }
]