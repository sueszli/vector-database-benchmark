[
    {
        "func_name": "_hcbm_mat_helper",
        "original": "def _hcbm_mat_helper(mat, n_low=0, n_high=214, rho_low=0.1, rho_high=0.9, blocks=4, depth=4):\n    \"\"\"\n    Helper function for `generate_hcmb_mat` that recursively places rho values to HCBM matrix\n    given as an input.\n\n    By using a uniform distribution we select the start and end locations of the blocks in the\n    matrix. For each block, we recurse depth times and repeat splitting up the sub-matrix into\n    blocks. Each depth level has a unique correlation (rho) values generated from a uniform\n    distributions, and bounded by `rho_low` and `rho_high`. This function works as a\n    side-effect to the `mat` parameter.\n\n    It is reproduced with modifications from the following paper:\n    `Marti, G., Andler, S., Nielsen, F. and Donnat, P., 2016.\n    Clustering financial time series: How long is enough?. arXiv preprint arXiv:1603.04017.\n    <https://www.ijcai.org/Proceedings/16/Papers/367.pdf>`_\n\n    :param mat: (np.array) Parent HCBM matrix.\n    :param n_low: (int) Start location of HCMB matrix to work on.\n    :param n_high: (int) End location of HCMB matrix to work on.\n    :param rho_low: (float) Lower correlation bound of the matrix. Must be greater or equal\n    to 0.\n    :param rho_high: (float) Upper correlation bound of the matrix. Must be less or equal to 1.\n    :param blocks: (int) Maximum number of blocks to generate per level of depth.\n    :param depth: (int) Depth of recursion for generating new blocks.\n    \"\"\"\n    pass",
        "mutated": [
            "def _hcbm_mat_helper(mat, n_low=0, n_high=214, rho_low=0.1, rho_high=0.9, blocks=4, depth=4):\n    if False:\n        i = 10\n    '\\n    Helper function for `generate_hcmb_mat` that recursively places rho values to HCBM matrix\\n    given as an input.\\n\\n    By using a uniform distribution we select the start and end locations of the blocks in the\\n    matrix. For each block, we recurse depth times and repeat splitting up the sub-matrix into\\n    blocks. Each depth level has a unique correlation (rho) values generated from a uniform\\n    distributions, and bounded by `rho_low` and `rho_high`. This function works as a\\n    side-effect to the `mat` parameter.\\n\\n    It is reproduced with modifications from the following paper:\\n    `Marti, G., Andler, S., Nielsen, F. and Donnat, P., 2016.\\n    Clustering financial time series: How long is enough?. arXiv preprint arXiv:1603.04017.\\n    <https://www.ijcai.org/Proceedings/16/Papers/367.pdf>`_\\n\\n    :param mat: (np.array) Parent HCBM matrix.\\n    :param n_low: (int) Start location of HCMB matrix to work on.\\n    :param n_high: (int) End location of HCMB matrix to work on.\\n    :param rho_low: (float) Lower correlation bound of the matrix. Must be greater or equal\\n    to 0.\\n    :param rho_high: (float) Upper correlation bound of the matrix. Must be less or equal to 1.\\n    :param blocks: (int) Maximum number of blocks to generate per level of depth.\\n    :param depth: (int) Depth of recursion for generating new blocks.\\n    '\n    pass",
            "def _hcbm_mat_helper(mat, n_low=0, n_high=214, rho_low=0.1, rho_high=0.9, blocks=4, depth=4):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Helper function for `generate_hcmb_mat` that recursively places rho values to HCBM matrix\\n    given as an input.\\n\\n    By using a uniform distribution we select the start and end locations of the blocks in the\\n    matrix. For each block, we recurse depth times and repeat splitting up the sub-matrix into\\n    blocks. Each depth level has a unique correlation (rho) values generated from a uniform\\n    distributions, and bounded by `rho_low` and `rho_high`. This function works as a\\n    side-effect to the `mat` parameter.\\n\\n    It is reproduced with modifications from the following paper:\\n    `Marti, G., Andler, S., Nielsen, F. and Donnat, P., 2016.\\n    Clustering financial time series: How long is enough?. arXiv preprint arXiv:1603.04017.\\n    <https://www.ijcai.org/Proceedings/16/Papers/367.pdf>`_\\n\\n    :param mat: (np.array) Parent HCBM matrix.\\n    :param n_low: (int) Start location of HCMB matrix to work on.\\n    :param n_high: (int) End location of HCMB matrix to work on.\\n    :param rho_low: (float) Lower correlation bound of the matrix. Must be greater or equal\\n    to 0.\\n    :param rho_high: (float) Upper correlation bound of the matrix. Must be less or equal to 1.\\n    :param blocks: (int) Maximum number of blocks to generate per level of depth.\\n    :param depth: (int) Depth of recursion for generating new blocks.\\n    '\n    pass",
            "def _hcbm_mat_helper(mat, n_low=0, n_high=214, rho_low=0.1, rho_high=0.9, blocks=4, depth=4):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Helper function for `generate_hcmb_mat` that recursively places rho values to HCBM matrix\\n    given as an input.\\n\\n    By using a uniform distribution we select the start and end locations of the blocks in the\\n    matrix. For each block, we recurse depth times and repeat splitting up the sub-matrix into\\n    blocks. Each depth level has a unique correlation (rho) values generated from a uniform\\n    distributions, and bounded by `rho_low` and `rho_high`. This function works as a\\n    side-effect to the `mat` parameter.\\n\\n    It is reproduced with modifications from the following paper:\\n    `Marti, G., Andler, S., Nielsen, F. and Donnat, P., 2016.\\n    Clustering financial time series: How long is enough?. arXiv preprint arXiv:1603.04017.\\n    <https://www.ijcai.org/Proceedings/16/Papers/367.pdf>`_\\n\\n    :param mat: (np.array) Parent HCBM matrix.\\n    :param n_low: (int) Start location of HCMB matrix to work on.\\n    :param n_high: (int) End location of HCMB matrix to work on.\\n    :param rho_low: (float) Lower correlation bound of the matrix. Must be greater or equal\\n    to 0.\\n    :param rho_high: (float) Upper correlation bound of the matrix. Must be less or equal to 1.\\n    :param blocks: (int) Maximum number of blocks to generate per level of depth.\\n    :param depth: (int) Depth of recursion for generating new blocks.\\n    '\n    pass",
            "def _hcbm_mat_helper(mat, n_low=0, n_high=214, rho_low=0.1, rho_high=0.9, blocks=4, depth=4):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Helper function for `generate_hcmb_mat` that recursively places rho values to HCBM matrix\\n    given as an input.\\n\\n    By using a uniform distribution we select the start and end locations of the blocks in the\\n    matrix. For each block, we recurse depth times and repeat splitting up the sub-matrix into\\n    blocks. Each depth level has a unique correlation (rho) values generated from a uniform\\n    distributions, and bounded by `rho_low` and `rho_high`. This function works as a\\n    side-effect to the `mat` parameter.\\n\\n    It is reproduced with modifications from the following paper:\\n    `Marti, G., Andler, S., Nielsen, F. and Donnat, P., 2016.\\n    Clustering financial time series: How long is enough?. arXiv preprint arXiv:1603.04017.\\n    <https://www.ijcai.org/Proceedings/16/Papers/367.pdf>`_\\n\\n    :param mat: (np.array) Parent HCBM matrix.\\n    :param n_low: (int) Start location of HCMB matrix to work on.\\n    :param n_high: (int) End location of HCMB matrix to work on.\\n    :param rho_low: (float) Lower correlation bound of the matrix. Must be greater or equal\\n    to 0.\\n    :param rho_high: (float) Upper correlation bound of the matrix. Must be less or equal to 1.\\n    :param blocks: (int) Maximum number of blocks to generate per level of depth.\\n    :param depth: (int) Depth of recursion for generating new blocks.\\n    '\n    pass",
            "def _hcbm_mat_helper(mat, n_low=0, n_high=214, rho_low=0.1, rho_high=0.9, blocks=4, depth=4):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Helper function for `generate_hcmb_mat` that recursively places rho values to HCBM matrix\\n    given as an input.\\n\\n    By using a uniform distribution we select the start and end locations of the blocks in the\\n    matrix. For each block, we recurse depth times and repeat splitting up the sub-matrix into\\n    blocks. Each depth level has a unique correlation (rho) values generated from a uniform\\n    distributions, and bounded by `rho_low` and `rho_high`. This function works as a\\n    side-effect to the `mat` parameter.\\n\\n    It is reproduced with modifications from the following paper:\\n    `Marti, G., Andler, S., Nielsen, F. and Donnat, P., 2016.\\n    Clustering financial time series: How long is enough?. arXiv preprint arXiv:1603.04017.\\n    <https://www.ijcai.org/Proceedings/16/Papers/367.pdf>`_\\n\\n    :param mat: (np.array) Parent HCBM matrix.\\n    :param n_low: (int) Start location of HCMB matrix to work on.\\n    :param n_high: (int) End location of HCMB matrix to work on.\\n    :param rho_low: (float) Lower correlation bound of the matrix. Must be greater or equal\\n    to 0.\\n    :param rho_high: (float) Upper correlation bound of the matrix. Must be less or equal to 1.\\n    :param blocks: (int) Maximum number of blocks to generate per level of depth.\\n    :param depth: (int) Depth of recursion for generating new blocks.\\n    '\n    pass"
        ]
    },
    {
        "func_name": "generate_hcmb_mat",
        "original": "def generate_hcmb_mat(t_samples, n_size, rho_low=0.1, rho_high=0.9, blocks=4, depth=4, permute=False):\n    \"\"\"\n    Generates a Hierarchical Correlation Block Model (HCBM) matrix  of correlation values.\n\n    By using a uniform distribution we select the start and end locations of the blocks in the\n    matrix. For each block, we recurse depth times and repeat splitting up the sub-matrix into\n    blocks. Each depth level has a unique correlation (rho) values generated from a uniform\n    distributions, and bounded by `rho_low` and `rho_high`.\n\n    It is reproduced with modifications from the following paper:\n    `Marti, G., Andler, S., Nielsen, F. and Donnat, P., 2016.\n    Clustering financial time series: How long is enough?. arXiv preprint arXiv:1603.04017.\n    <https://www.ijcai.org/Proceedings/16/Papers/367.pdf>`_\n\n    :param t_samples: (int) Number of HCBM matrices to generate.\n    :param n_size: (int) Size of HCBM matrix.\n    :param rho_low: (float) Lower correlation bound of the matrix. Must be greater or equal to 0.\n    :param rho_high: (float) Upper correlation bound of the matrix. Must be less or equal to 1.\n    :param blocks: (int) Number of blocks to generate per level of depth.\n    :param depth: (int) Depth of recursion for generating new blocks.\n    :param permute: (bool) Whether to permute the final HCBM matrix.\n    :return: (np.array) Generated HCBM matrix of shape (t_samples, n_size, n_size).\n    \"\"\"\n    pass",
        "mutated": [
            "def generate_hcmb_mat(t_samples, n_size, rho_low=0.1, rho_high=0.9, blocks=4, depth=4, permute=False):\n    if False:\n        i = 10\n    '\\n    Generates a Hierarchical Correlation Block Model (HCBM) matrix  of correlation values.\\n\\n    By using a uniform distribution we select the start and end locations of the blocks in the\\n    matrix. For each block, we recurse depth times and repeat splitting up the sub-matrix into\\n    blocks. Each depth level has a unique correlation (rho) values generated from a uniform\\n    distributions, and bounded by `rho_low` and `rho_high`.\\n\\n    It is reproduced with modifications from the following paper:\\n    `Marti, G., Andler, S., Nielsen, F. and Donnat, P., 2016.\\n    Clustering financial time series: How long is enough?. arXiv preprint arXiv:1603.04017.\\n    <https://www.ijcai.org/Proceedings/16/Papers/367.pdf>`_\\n\\n    :param t_samples: (int) Number of HCBM matrices to generate.\\n    :param n_size: (int) Size of HCBM matrix.\\n    :param rho_low: (float) Lower correlation bound of the matrix. Must be greater or equal to 0.\\n    :param rho_high: (float) Upper correlation bound of the matrix. Must be less or equal to 1.\\n    :param blocks: (int) Number of blocks to generate per level of depth.\\n    :param depth: (int) Depth of recursion for generating new blocks.\\n    :param permute: (bool) Whether to permute the final HCBM matrix.\\n    :return: (np.array) Generated HCBM matrix of shape (t_samples, n_size, n_size).\\n    '\n    pass",
            "def generate_hcmb_mat(t_samples, n_size, rho_low=0.1, rho_high=0.9, blocks=4, depth=4, permute=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Generates a Hierarchical Correlation Block Model (HCBM) matrix  of correlation values.\\n\\n    By using a uniform distribution we select the start and end locations of the blocks in the\\n    matrix. For each block, we recurse depth times and repeat splitting up the sub-matrix into\\n    blocks. Each depth level has a unique correlation (rho) values generated from a uniform\\n    distributions, and bounded by `rho_low` and `rho_high`.\\n\\n    It is reproduced with modifications from the following paper:\\n    `Marti, G., Andler, S., Nielsen, F. and Donnat, P., 2016.\\n    Clustering financial time series: How long is enough?. arXiv preprint arXiv:1603.04017.\\n    <https://www.ijcai.org/Proceedings/16/Papers/367.pdf>`_\\n\\n    :param t_samples: (int) Number of HCBM matrices to generate.\\n    :param n_size: (int) Size of HCBM matrix.\\n    :param rho_low: (float) Lower correlation bound of the matrix. Must be greater or equal to 0.\\n    :param rho_high: (float) Upper correlation bound of the matrix. Must be less or equal to 1.\\n    :param blocks: (int) Number of blocks to generate per level of depth.\\n    :param depth: (int) Depth of recursion for generating new blocks.\\n    :param permute: (bool) Whether to permute the final HCBM matrix.\\n    :return: (np.array) Generated HCBM matrix of shape (t_samples, n_size, n_size).\\n    '\n    pass",
            "def generate_hcmb_mat(t_samples, n_size, rho_low=0.1, rho_high=0.9, blocks=4, depth=4, permute=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Generates a Hierarchical Correlation Block Model (HCBM) matrix  of correlation values.\\n\\n    By using a uniform distribution we select the start and end locations of the blocks in the\\n    matrix. For each block, we recurse depth times and repeat splitting up the sub-matrix into\\n    blocks. Each depth level has a unique correlation (rho) values generated from a uniform\\n    distributions, and bounded by `rho_low` and `rho_high`.\\n\\n    It is reproduced with modifications from the following paper:\\n    `Marti, G., Andler, S., Nielsen, F. and Donnat, P., 2016.\\n    Clustering financial time series: How long is enough?. arXiv preprint arXiv:1603.04017.\\n    <https://www.ijcai.org/Proceedings/16/Papers/367.pdf>`_\\n\\n    :param t_samples: (int) Number of HCBM matrices to generate.\\n    :param n_size: (int) Size of HCBM matrix.\\n    :param rho_low: (float) Lower correlation bound of the matrix. Must be greater or equal to 0.\\n    :param rho_high: (float) Upper correlation bound of the matrix. Must be less or equal to 1.\\n    :param blocks: (int) Number of blocks to generate per level of depth.\\n    :param depth: (int) Depth of recursion for generating new blocks.\\n    :param permute: (bool) Whether to permute the final HCBM matrix.\\n    :return: (np.array) Generated HCBM matrix of shape (t_samples, n_size, n_size).\\n    '\n    pass",
            "def generate_hcmb_mat(t_samples, n_size, rho_low=0.1, rho_high=0.9, blocks=4, depth=4, permute=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Generates a Hierarchical Correlation Block Model (HCBM) matrix  of correlation values.\\n\\n    By using a uniform distribution we select the start and end locations of the blocks in the\\n    matrix. For each block, we recurse depth times and repeat splitting up the sub-matrix into\\n    blocks. Each depth level has a unique correlation (rho) values generated from a uniform\\n    distributions, and bounded by `rho_low` and `rho_high`.\\n\\n    It is reproduced with modifications from the following paper:\\n    `Marti, G., Andler, S., Nielsen, F. and Donnat, P., 2016.\\n    Clustering financial time series: How long is enough?. arXiv preprint arXiv:1603.04017.\\n    <https://www.ijcai.org/Proceedings/16/Papers/367.pdf>`_\\n\\n    :param t_samples: (int) Number of HCBM matrices to generate.\\n    :param n_size: (int) Size of HCBM matrix.\\n    :param rho_low: (float) Lower correlation bound of the matrix. Must be greater or equal to 0.\\n    :param rho_high: (float) Upper correlation bound of the matrix. Must be less or equal to 1.\\n    :param blocks: (int) Number of blocks to generate per level of depth.\\n    :param depth: (int) Depth of recursion for generating new blocks.\\n    :param permute: (bool) Whether to permute the final HCBM matrix.\\n    :return: (np.array) Generated HCBM matrix of shape (t_samples, n_size, n_size).\\n    '\n    pass",
            "def generate_hcmb_mat(t_samples, n_size, rho_low=0.1, rho_high=0.9, blocks=4, depth=4, permute=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Generates a Hierarchical Correlation Block Model (HCBM) matrix  of correlation values.\\n\\n    By using a uniform distribution we select the start and end locations of the blocks in the\\n    matrix. For each block, we recurse depth times and repeat splitting up the sub-matrix into\\n    blocks. Each depth level has a unique correlation (rho) values generated from a uniform\\n    distributions, and bounded by `rho_low` and `rho_high`.\\n\\n    It is reproduced with modifications from the following paper:\\n    `Marti, G., Andler, S., Nielsen, F. and Donnat, P., 2016.\\n    Clustering financial time series: How long is enough?. arXiv preprint arXiv:1603.04017.\\n    <https://www.ijcai.org/Proceedings/16/Papers/367.pdf>`_\\n\\n    :param t_samples: (int) Number of HCBM matrices to generate.\\n    :param n_size: (int) Size of HCBM matrix.\\n    :param rho_low: (float) Lower correlation bound of the matrix. Must be greater or equal to 0.\\n    :param rho_high: (float) Upper correlation bound of the matrix. Must be less or equal to 1.\\n    :param blocks: (int) Number of blocks to generate per level of depth.\\n    :param depth: (int) Depth of recursion for generating new blocks.\\n    :param permute: (bool) Whether to permute the final HCBM matrix.\\n    :return: (np.array) Generated HCBM matrix of shape (t_samples, n_size, n_size).\\n    '\n    pass"
        ]
    },
    {
        "func_name": "time_series_from_dist",
        "original": "def time_series_from_dist(corr, t_samples=1000, dist='normal', deg_free=3):\n    \"\"\"\n    Generates a time series from a given correlation matrix.\n\n    It uses multivariate sampling from distributions to create the time series. It supports\n    normal and student-t distributions. This method relies and acts as a wrapper for the\n    `np.random.multivariate_normal` and\n    `statsmodels.sandbox.distributions.multivariate.multivariate_t_rvs` modules.\n    `<https://numpy.org/doc/stable/reference/random/generated/numpy.random.multivariate_normal.html>`_\n    `<https://www.statsmodels.org/stable/sandbox.html?highlight=sandbox#module-statsmodels.sandbox>`_\n\n    It is reproduced with modifications from the following paper:\n    `Marti, G., Andler, S., Nielsen, F. and Donnat, P., 2016.\n    Clustering financial time series: How long is enough?. arXiv preprint arXiv:1603.04017.\n    <https://www.ijcai.org/Proceedings/16/Papers/367.pdf>`_\n\n    :param corr: (np.array) Correlation matrix.\n    :param t_samples: (int) Number of samples in the time series.\n    :param dist: (str) Type of distributions to use.\n        Can take the values [\"normal\", \"student\"].\n    :param deg_free: (int) Degrees of freedom. Only used for student-t distribution.\n    :return: (pd.DataFrame) The resulting time series of shape (len(corr), t_samples).\n    \"\"\"\n    pass",
        "mutated": [
            "def time_series_from_dist(corr, t_samples=1000, dist='normal', deg_free=3):\n    if False:\n        i = 10\n    '\\n    Generates a time series from a given correlation matrix.\\n\\n    It uses multivariate sampling from distributions to create the time series. It supports\\n    normal and student-t distributions. This method relies and acts as a wrapper for the\\n    `np.random.multivariate_normal` and\\n    `statsmodels.sandbox.distributions.multivariate.multivariate_t_rvs` modules.\\n    `<https://numpy.org/doc/stable/reference/random/generated/numpy.random.multivariate_normal.html>`_\\n    `<https://www.statsmodels.org/stable/sandbox.html?highlight=sandbox#module-statsmodels.sandbox>`_\\n\\n    It is reproduced with modifications from the following paper:\\n    `Marti, G., Andler, S., Nielsen, F. and Donnat, P., 2016.\\n    Clustering financial time series: How long is enough?. arXiv preprint arXiv:1603.04017.\\n    <https://www.ijcai.org/Proceedings/16/Papers/367.pdf>`_\\n\\n    :param corr: (np.array) Correlation matrix.\\n    :param t_samples: (int) Number of samples in the time series.\\n    :param dist: (str) Type of distributions to use.\\n        Can take the values [\"normal\", \"student\"].\\n    :param deg_free: (int) Degrees of freedom. Only used for student-t distribution.\\n    :return: (pd.DataFrame) The resulting time series of shape (len(corr), t_samples).\\n    '\n    pass",
            "def time_series_from_dist(corr, t_samples=1000, dist='normal', deg_free=3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Generates a time series from a given correlation matrix.\\n\\n    It uses multivariate sampling from distributions to create the time series. It supports\\n    normal and student-t distributions. This method relies and acts as a wrapper for the\\n    `np.random.multivariate_normal` and\\n    `statsmodels.sandbox.distributions.multivariate.multivariate_t_rvs` modules.\\n    `<https://numpy.org/doc/stable/reference/random/generated/numpy.random.multivariate_normal.html>`_\\n    `<https://www.statsmodels.org/stable/sandbox.html?highlight=sandbox#module-statsmodels.sandbox>`_\\n\\n    It is reproduced with modifications from the following paper:\\n    `Marti, G., Andler, S., Nielsen, F. and Donnat, P., 2016.\\n    Clustering financial time series: How long is enough?. arXiv preprint arXiv:1603.04017.\\n    <https://www.ijcai.org/Proceedings/16/Papers/367.pdf>`_\\n\\n    :param corr: (np.array) Correlation matrix.\\n    :param t_samples: (int) Number of samples in the time series.\\n    :param dist: (str) Type of distributions to use.\\n        Can take the values [\"normal\", \"student\"].\\n    :param deg_free: (int) Degrees of freedom. Only used for student-t distribution.\\n    :return: (pd.DataFrame) The resulting time series of shape (len(corr), t_samples).\\n    '\n    pass",
            "def time_series_from_dist(corr, t_samples=1000, dist='normal', deg_free=3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Generates a time series from a given correlation matrix.\\n\\n    It uses multivariate sampling from distributions to create the time series. It supports\\n    normal and student-t distributions. This method relies and acts as a wrapper for the\\n    `np.random.multivariate_normal` and\\n    `statsmodels.sandbox.distributions.multivariate.multivariate_t_rvs` modules.\\n    `<https://numpy.org/doc/stable/reference/random/generated/numpy.random.multivariate_normal.html>`_\\n    `<https://www.statsmodels.org/stable/sandbox.html?highlight=sandbox#module-statsmodels.sandbox>`_\\n\\n    It is reproduced with modifications from the following paper:\\n    `Marti, G., Andler, S., Nielsen, F. and Donnat, P., 2016.\\n    Clustering financial time series: How long is enough?. arXiv preprint arXiv:1603.04017.\\n    <https://www.ijcai.org/Proceedings/16/Papers/367.pdf>`_\\n\\n    :param corr: (np.array) Correlation matrix.\\n    :param t_samples: (int) Number of samples in the time series.\\n    :param dist: (str) Type of distributions to use.\\n        Can take the values [\"normal\", \"student\"].\\n    :param deg_free: (int) Degrees of freedom. Only used for student-t distribution.\\n    :return: (pd.DataFrame) The resulting time series of shape (len(corr), t_samples).\\n    '\n    pass",
            "def time_series_from_dist(corr, t_samples=1000, dist='normal', deg_free=3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Generates a time series from a given correlation matrix.\\n\\n    It uses multivariate sampling from distributions to create the time series. It supports\\n    normal and student-t distributions. This method relies and acts as a wrapper for the\\n    `np.random.multivariate_normal` and\\n    `statsmodels.sandbox.distributions.multivariate.multivariate_t_rvs` modules.\\n    `<https://numpy.org/doc/stable/reference/random/generated/numpy.random.multivariate_normal.html>`_\\n    `<https://www.statsmodels.org/stable/sandbox.html?highlight=sandbox#module-statsmodels.sandbox>`_\\n\\n    It is reproduced with modifications from the following paper:\\n    `Marti, G., Andler, S., Nielsen, F. and Donnat, P., 2016.\\n    Clustering financial time series: How long is enough?. arXiv preprint arXiv:1603.04017.\\n    <https://www.ijcai.org/Proceedings/16/Papers/367.pdf>`_\\n\\n    :param corr: (np.array) Correlation matrix.\\n    :param t_samples: (int) Number of samples in the time series.\\n    :param dist: (str) Type of distributions to use.\\n        Can take the values [\"normal\", \"student\"].\\n    :param deg_free: (int) Degrees of freedom. Only used for student-t distribution.\\n    :return: (pd.DataFrame) The resulting time series of shape (len(corr), t_samples).\\n    '\n    pass",
            "def time_series_from_dist(corr, t_samples=1000, dist='normal', deg_free=3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Generates a time series from a given correlation matrix.\\n\\n    It uses multivariate sampling from distributions to create the time series. It supports\\n    normal and student-t distributions. This method relies and acts as a wrapper for the\\n    `np.random.multivariate_normal` and\\n    `statsmodels.sandbox.distributions.multivariate.multivariate_t_rvs` modules.\\n    `<https://numpy.org/doc/stable/reference/random/generated/numpy.random.multivariate_normal.html>`_\\n    `<https://www.statsmodels.org/stable/sandbox.html?highlight=sandbox#module-statsmodels.sandbox>`_\\n\\n    It is reproduced with modifications from the following paper:\\n    `Marti, G., Andler, S., Nielsen, F. and Donnat, P., 2016.\\n    Clustering financial time series: How long is enough?. arXiv preprint arXiv:1603.04017.\\n    <https://www.ijcai.org/Proceedings/16/Papers/367.pdf>`_\\n\\n    :param corr: (np.array) Correlation matrix.\\n    :param t_samples: (int) Number of samples in the time series.\\n    :param dist: (str) Type of distributions to use.\\n        Can take the values [\"normal\", \"student\"].\\n    :param deg_free: (int) Degrees of freedom. Only used for student-t distribution.\\n    :return: (pd.DataFrame) The resulting time series of shape (len(corr), t_samples).\\n    '\n    pass"
        ]
    }
]