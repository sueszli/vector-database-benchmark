[
    {
        "func_name": "merge_informative_pair",
        "original": "def merge_informative_pair(dataframe: pd.DataFrame, informative: pd.DataFrame, timeframe: str, timeframe_inf: str, ffill: bool=True, append_timeframe: bool=True, date_column: str='date', suffix: Optional[str]=None) -> pd.DataFrame:\n    \"\"\"\n    Correctly merge informative samples to the original dataframe, avoiding lookahead bias.\n\n    Since dates are candle open dates, merging a 15m candle that starts at 15:00, and a\n    1h candle that starts at 15:00 will result in all candles to know the close at 16:00\n    which they should not know.\n\n    Moves the date of the informative pair by 1 time interval forward.\n    This way, the 14:00 1h candle is merged to 15:00 15m candle, since the 14:00 1h candle is the\n    last candle that's closed at 15:00, 15:15, 15:30 or 15:45.\n\n    Assuming inf_tf = '1d' - then the resulting columns will be:\n    date_1d, open_1d, high_1d, low_1d, close_1d, rsi_1d\n\n    :param dataframe: Original dataframe\n    :param informative: Informative pair, most likely loaded via dp.get_pair_dataframe\n    :param timeframe: Timeframe of the original pair sample.\n    :param timeframe_inf: Timeframe of the informative pair sample.\n    :param ffill: Forwardfill missing values - optional but usually required\n    :param append_timeframe: Rename columns by appending timeframe.\n    :param date_column: A custom date column name.\n    :param suffix: A string suffix to add at the end of the informative columns. If specified,\n                   append_timeframe must be false.\n    :return: Merged dataframe\n    :raise: ValueError if the secondary timeframe is shorter than the dataframe timeframe\n    \"\"\"\n    minutes_inf = timeframe_to_minutes(timeframe_inf)\n    minutes = timeframe_to_minutes(timeframe)\n    if minutes == minutes_inf:\n        informative['date_merge'] = informative[date_column]\n    elif minutes < minutes_inf:\n        if not informative.empty:\n            informative['date_merge'] = informative[date_column] + pd.to_timedelta(minutes_inf, 'm') - pd.to_timedelta(minutes, 'm')\n        else:\n            informative['date_merge'] = informative[date_column]\n    else:\n        raise ValueError('Tried to merge a faster timeframe to a slower timeframe.This would create new rows, and can throw off your regular indicators.')\n    date_merge = 'date_merge'\n    if suffix and append_timeframe:\n        raise ValueError('You can not specify `append_timeframe` as True and a `suffix`.')\n    elif append_timeframe:\n        date_merge = f'date_merge_{timeframe_inf}'\n        informative.columns = [f'{col}_{timeframe_inf}' for col in informative.columns]\n    elif suffix:\n        date_merge = f'date_merge_{suffix}'\n        informative.columns = [f'{col}_{suffix}' for col in informative.columns]\n    if ffill:\n        dataframe = pd.merge_ordered(dataframe, informative, fill_method='ffill', left_on='date', right_on=date_merge, how='left')\n    else:\n        dataframe = pd.merge(dataframe, informative, left_on='date', right_on=date_merge, how='left')\n    dataframe = dataframe.drop(date_merge, axis=1)\n    return dataframe",
        "mutated": [
            "def merge_informative_pair(dataframe: pd.DataFrame, informative: pd.DataFrame, timeframe: str, timeframe_inf: str, ffill: bool=True, append_timeframe: bool=True, date_column: str='date', suffix: Optional[str]=None) -> pd.DataFrame:\n    if False:\n        i = 10\n    \"\\n    Correctly merge informative samples to the original dataframe, avoiding lookahead bias.\\n\\n    Since dates are candle open dates, merging a 15m candle that starts at 15:00, and a\\n    1h candle that starts at 15:00 will result in all candles to know the close at 16:00\\n    which they should not know.\\n\\n    Moves the date of the informative pair by 1 time interval forward.\\n    This way, the 14:00 1h candle is merged to 15:00 15m candle, since the 14:00 1h candle is the\\n    last candle that's closed at 15:00, 15:15, 15:30 or 15:45.\\n\\n    Assuming inf_tf = '1d' - then the resulting columns will be:\\n    date_1d, open_1d, high_1d, low_1d, close_1d, rsi_1d\\n\\n    :param dataframe: Original dataframe\\n    :param informative: Informative pair, most likely loaded via dp.get_pair_dataframe\\n    :param timeframe: Timeframe of the original pair sample.\\n    :param timeframe_inf: Timeframe of the informative pair sample.\\n    :param ffill: Forwardfill missing values - optional but usually required\\n    :param append_timeframe: Rename columns by appending timeframe.\\n    :param date_column: A custom date column name.\\n    :param suffix: A string suffix to add at the end of the informative columns. If specified,\\n                   append_timeframe must be false.\\n    :return: Merged dataframe\\n    :raise: ValueError if the secondary timeframe is shorter than the dataframe timeframe\\n    \"\n    minutes_inf = timeframe_to_minutes(timeframe_inf)\n    minutes = timeframe_to_minutes(timeframe)\n    if minutes == minutes_inf:\n        informative['date_merge'] = informative[date_column]\n    elif minutes < minutes_inf:\n        if not informative.empty:\n            informative['date_merge'] = informative[date_column] + pd.to_timedelta(minutes_inf, 'm') - pd.to_timedelta(minutes, 'm')\n        else:\n            informative['date_merge'] = informative[date_column]\n    else:\n        raise ValueError('Tried to merge a faster timeframe to a slower timeframe.This would create new rows, and can throw off your regular indicators.')\n    date_merge = 'date_merge'\n    if suffix and append_timeframe:\n        raise ValueError('You can not specify `append_timeframe` as True and a `suffix`.')\n    elif append_timeframe:\n        date_merge = f'date_merge_{timeframe_inf}'\n        informative.columns = [f'{col}_{timeframe_inf}' for col in informative.columns]\n    elif suffix:\n        date_merge = f'date_merge_{suffix}'\n        informative.columns = [f'{col}_{suffix}' for col in informative.columns]\n    if ffill:\n        dataframe = pd.merge_ordered(dataframe, informative, fill_method='ffill', left_on='date', right_on=date_merge, how='left')\n    else:\n        dataframe = pd.merge(dataframe, informative, left_on='date', right_on=date_merge, how='left')\n    dataframe = dataframe.drop(date_merge, axis=1)\n    return dataframe",
            "def merge_informative_pair(dataframe: pd.DataFrame, informative: pd.DataFrame, timeframe: str, timeframe_inf: str, ffill: bool=True, append_timeframe: bool=True, date_column: str='date', suffix: Optional[str]=None) -> pd.DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Correctly merge informative samples to the original dataframe, avoiding lookahead bias.\\n\\n    Since dates are candle open dates, merging a 15m candle that starts at 15:00, and a\\n    1h candle that starts at 15:00 will result in all candles to know the close at 16:00\\n    which they should not know.\\n\\n    Moves the date of the informative pair by 1 time interval forward.\\n    This way, the 14:00 1h candle is merged to 15:00 15m candle, since the 14:00 1h candle is the\\n    last candle that's closed at 15:00, 15:15, 15:30 or 15:45.\\n\\n    Assuming inf_tf = '1d' - then the resulting columns will be:\\n    date_1d, open_1d, high_1d, low_1d, close_1d, rsi_1d\\n\\n    :param dataframe: Original dataframe\\n    :param informative: Informative pair, most likely loaded via dp.get_pair_dataframe\\n    :param timeframe: Timeframe of the original pair sample.\\n    :param timeframe_inf: Timeframe of the informative pair sample.\\n    :param ffill: Forwardfill missing values - optional but usually required\\n    :param append_timeframe: Rename columns by appending timeframe.\\n    :param date_column: A custom date column name.\\n    :param suffix: A string suffix to add at the end of the informative columns. If specified,\\n                   append_timeframe must be false.\\n    :return: Merged dataframe\\n    :raise: ValueError if the secondary timeframe is shorter than the dataframe timeframe\\n    \"\n    minutes_inf = timeframe_to_minutes(timeframe_inf)\n    minutes = timeframe_to_minutes(timeframe)\n    if minutes == minutes_inf:\n        informative['date_merge'] = informative[date_column]\n    elif minutes < minutes_inf:\n        if not informative.empty:\n            informative['date_merge'] = informative[date_column] + pd.to_timedelta(minutes_inf, 'm') - pd.to_timedelta(minutes, 'm')\n        else:\n            informative['date_merge'] = informative[date_column]\n    else:\n        raise ValueError('Tried to merge a faster timeframe to a slower timeframe.This would create new rows, and can throw off your regular indicators.')\n    date_merge = 'date_merge'\n    if suffix and append_timeframe:\n        raise ValueError('You can not specify `append_timeframe` as True and a `suffix`.')\n    elif append_timeframe:\n        date_merge = f'date_merge_{timeframe_inf}'\n        informative.columns = [f'{col}_{timeframe_inf}' for col in informative.columns]\n    elif suffix:\n        date_merge = f'date_merge_{suffix}'\n        informative.columns = [f'{col}_{suffix}' for col in informative.columns]\n    if ffill:\n        dataframe = pd.merge_ordered(dataframe, informative, fill_method='ffill', left_on='date', right_on=date_merge, how='left')\n    else:\n        dataframe = pd.merge(dataframe, informative, left_on='date', right_on=date_merge, how='left')\n    dataframe = dataframe.drop(date_merge, axis=1)\n    return dataframe",
            "def merge_informative_pair(dataframe: pd.DataFrame, informative: pd.DataFrame, timeframe: str, timeframe_inf: str, ffill: bool=True, append_timeframe: bool=True, date_column: str='date', suffix: Optional[str]=None) -> pd.DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Correctly merge informative samples to the original dataframe, avoiding lookahead bias.\\n\\n    Since dates are candle open dates, merging a 15m candle that starts at 15:00, and a\\n    1h candle that starts at 15:00 will result in all candles to know the close at 16:00\\n    which they should not know.\\n\\n    Moves the date of the informative pair by 1 time interval forward.\\n    This way, the 14:00 1h candle is merged to 15:00 15m candle, since the 14:00 1h candle is the\\n    last candle that's closed at 15:00, 15:15, 15:30 or 15:45.\\n\\n    Assuming inf_tf = '1d' - then the resulting columns will be:\\n    date_1d, open_1d, high_1d, low_1d, close_1d, rsi_1d\\n\\n    :param dataframe: Original dataframe\\n    :param informative: Informative pair, most likely loaded via dp.get_pair_dataframe\\n    :param timeframe: Timeframe of the original pair sample.\\n    :param timeframe_inf: Timeframe of the informative pair sample.\\n    :param ffill: Forwardfill missing values - optional but usually required\\n    :param append_timeframe: Rename columns by appending timeframe.\\n    :param date_column: A custom date column name.\\n    :param suffix: A string suffix to add at the end of the informative columns. If specified,\\n                   append_timeframe must be false.\\n    :return: Merged dataframe\\n    :raise: ValueError if the secondary timeframe is shorter than the dataframe timeframe\\n    \"\n    minutes_inf = timeframe_to_minutes(timeframe_inf)\n    minutes = timeframe_to_minutes(timeframe)\n    if minutes == minutes_inf:\n        informative['date_merge'] = informative[date_column]\n    elif minutes < minutes_inf:\n        if not informative.empty:\n            informative['date_merge'] = informative[date_column] + pd.to_timedelta(minutes_inf, 'm') - pd.to_timedelta(minutes, 'm')\n        else:\n            informative['date_merge'] = informative[date_column]\n    else:\n        raise ValueError('Tried to merge a faster timeframe to a slower timeframe.This would create new rows, and can throw off your regular indicators.')\n    date_merge = 'date_merge'\n    if suffix and append_timeframe:\n        raise ValueError('You can not specify `append_timeframe` as True and a `suffix`.')\n    elif append_timeframe:\n        date_merge = f'date_merge_{timeframe_inf}'\n        informative.columns = [f'{col}_{timeframe_inf}' for col in informative.columns]\n    elif suffix:\n        date_merge = f'date_merge_{suffix}'\n        informative.columns = [f'{col}_{suffix}' for col in informative.columns]\n    if ffill:\n        dataframe = pd.merge_ordered(dataframe, informative, fill_method='ffill', left_on='date', right_on=date_merge, how='left')\n    else:\n        dataframe = pd.merge(dataframe, informative, left_on='date', right_on=date_merge, how='left')\n    dataframe = dataframe.drop(date_merge, axis=1)\n    return dataframe",
            "def merge_informative_pair(dataframe: pd.DataFrame, informative: pd.DataFrame, timeframe: str, timeframe_inf: str, ffill: bool=True, append_timeframe: bool=True, date_column: str='date', suffix: Optional[str]=None) -> pd.DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Correctly merge informative samples to the original dataframe, avoiding lookahead bias.\\n\\n    Since dates are candle open dates, merging a 15m candle that starts at 15:00, and a\\n    1h candle that starts at 15:00 will result in all candles to know the close at 16:00\\n    which they should not know.\\n\\n    Moves the date of the informative pair by 1 time interval forward.\\n    This way, the 14:00 1h candle is merged to 15:00 15m candle, since the 14:00 1h candle is the\\n    last candle that's closed at 15:00, 15:15, 15:30 or 15:45.\\n\\n    Assuming inf_tf = '1d' - then the resulting columns will be:\\n    date_1d, open_1d, high_1d, low_1d, close_1d, rsi_1d\\n\\n    :param dataframe: Original dataframe\\n    :param informative: Informative pair, most likely loaded via dp.get_pair_dataframe\\n    :param timeframe: Timeframe of the original pair sample.\\n    :param timeframe_inf: Timeframe of the informative pair sample.\\n    :param ffill: Forwardfill missing values - optional but usually required\\n    :param append_timeframe: Rename columns by appending timeframe.\\n    :param date_column: A custom date column name.\\n    :param suffix: A string suffix to add at the end of the informative columns. If specified,\\n                   append_timeframe must be false.\\n    :return: Merged dataframe\\n    :raise: ValueError if the secondary timeframe is shorter than the dataframe timeframe\\n    \"\n    minutes_inf = timeframe_to_minutes(timeframe_inf)\n    minutes = timeframe_to_minutes(timeframe)\n    if minutes == minutes_inf:\n        informative['date_merge'] = informative[date_column]\n    elif minutes < minutes_inf:\n        if not informative.empty:\n            informative['date_merge'] = informative[date_column] + pd.to_timedelta(minutes_inf, 'm') - pd.to_timedelta(minutes, 'm')\n        else:\n            informative['date_merge'] = informative[date_column]\n    else:\n        raise ValueError('Tried to merge a faster timeframe to a slower timeframe.This would create new rows, and can throw off your regular indicators.')\n    date_merge = 'date_merge'\n    if suffix and append_timeframe:\n        raise ValueError('You can not specify `append_timeframe` as True and a `suffix`.')\n    elif append_timeframe:\n        date_merge = f'date_merge_{timeframe_inf}'\n        informative.columns = [f'{col}_{timeframe_inf}' for col in informative.columns]\n    elif suffix:\n        date_merge = f'date_merge_{suffix}'\n        informative.columns = [f'{col}_{suffix}' for col in informative.columns]\n    if ffill:\n        dataframe = pd.merge_ordered(dataframe, informative, fill_method='ffill', left_on='date', right_on=date_merge, how='left')\n    else:\n        dataframe = pd.merge(dataframe, informative, left_on='date', right_on=date_merge, how='left')\n    dataframe = dataframe.drop(date_merge, axis=1)\n    return dataframe",
            "def merge_informative_pair(dataframe: pd.DataFrame, informative: pd.DataFrame, timeframe: str, timeframe_inf: str, ffill: bool=True, append_timeframe: bool=True, date_column: str='date', suffix: Optional[str]=None) -> pd.DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Correctly merge informative samples to the original dataframe, avoiding lookahead bias.\\n\\n    Since dates are candle open dates, merging a 15m candle that starts at 15:00, and a\\n    1h candle that starts at 15:00 will result in all candles to know the close at 16:00\\n    which they should not know.\\n\\n    Moves the date of the informative pair by 1 time interval forward.\\n    This way, the 14:00 1h candle is merged to 15:00 15m candle, since the 14:00 1h candle is the\\n    last candle that's closed at 15:00, 15:15, 15:30 or 15:45.\\n\\n    Assuming inf_tf = '1d' - then the resulting columns will be:\\n    date_1d, open_1d, high_1d, low_1d, close_1d, rsi_1d\\n\\n    :param dataframe: Original dataframe\\n    :param informative: Informative pair, most likely loaded via dp.get_pair_dataframe\\n    :param timeframe: Timeframe of the original pair sample.\\n    :param timeframe_inf: Timeframe of the informative pair sample.\\n    :param ffill: Forwardfill missing values - optional but usually required\\n    :param append_timeframe: Rename columns by appending timeframe.\\n    :param date_column: A custom date column name.\\n    :param suffix: A string suffix to add at the end of the informative columns. If specified,\\n                   append_timeframe must be false.\\n    :return: Merged dataframe\\n    :raise: ValueError if the secondary timeframe is shorter than the dataframe timeframe\\n    \"\n    minutes_inf = timeframe_to_minutes(timeframe_inf)\n    minutes = timeframe_to_minutes(timeframe)\n    if minutes == minutes_inf:\n        informative['date_merge'] = informative[date_column]\n    elif minutes < minutes_inf:\n        if not informative.empty:\n            informative['date_merge'] = informative[date_column] + pd.to_timedelta(minutes_inf, 'm') - pd.to_timedelta(minutes, 'm')\n        else:\n            informative['date_merge'] = informative[date_column]\n    else:\n        raise ValueError('Tried to merge a faster timeframe to a slower timeframe.This would create new rows, and can throw off your regular indicators.')\n    date_merge = 'date_merge'\n    if suffix and append_timeframe:\n        raise ValueError('You can not specify `append_timeframe` as True and a `suffix`.')\n    elif append_timeframe:\n        date_merge = f'date_merge_{timeframe_inf}'\n        informative.columns = [f'{col}_{timeframe_inf}' for col in informative.columns]\n    elif suffix:\n        date_merge = f'date_merge_{suffix}'\n        informative.columns = [f'{col}_{suffix}' for col in informative.columns]\n    if ffill:\n        dataframe = pd.merge_ordered(dataframe, informative, fill_method='ffill', left_on='date', right_on=date_merge, how='left')\n    else:\n        dataframe = pd.merge(dataframe, informative, left_on='date', right_on=date_merge, how='left')\n    dataframe = dataframe.drop(date_merge, axis=1)\n    return dataframe"
        ]
    },
    {
        "func_name": "stoploss_from_open",
        "original": "def stoploss_from_open(open_relative_stop: float, current_profit: float, is_short: bool=False, leverage: float=1.0) -> float:\n    \"\"\"\n    Given the current profit, and a desired stop loss value relative to the trade entry price,\n    return a stop loss value that is relative to the current price, and which can be\n    returned from `custom_stoploss`.\n\n    The requested stop can be positive for a stop above the open price, or negative for\n    a stop below the open price. The return value is always >= 0.\n    `open_relative_stop` will be considered as adjusted for leverage if leverage is provided..\n\n    Returns 0 if the resulting stop price would be above/below (longs/shorts) the current price\n\n    :param open_relative_stop: Desired stop loss percentage, relative to the open price,\n                               adjusted for leverage\n    :param current_profit: The current profit percentage\n    :param is_short: When true, perform the calculation for short instead of long\n    :param leverage: Leverage to use for the calculation\n    :return: Stop loss value relative to current price\n    \"\"\"\n    _current_profit = current_profit / leverage\n    if _current_profit == -1 and (not is_short) or (is_short and _current_profit == 1):\n        return 1\n    if is_short is True:\n        stoploss = -1 + (1 - open_relative_stop / leverage) / (1 - _current_profit)\n    else:\n        stoploss = 1 - (1 + open_relative_stop / leverage) / (1 + _current_profit)\n    return max(stoploss * leverage, 0.0)",
        "mutated": [
            "def stoploss_from_open(open_relative_stop: float, current_profit: float, is_short: bool=False, leverage: float=1.0) -> float:\n    if False:\n        i = 10\n    '\\n    Given the current profit, and a desired stop loss value relative to the trade entry price,\\n    return a stop loss value that is relative to the current price, and which can be\\n    returned from `custom_stoploss`.\\n\\n    The requested stop can be positive for a stop above the open price, or negative for\\n    a stop below the open price. The return value is always >= 0.\\n    `open_relative_stop` will be considered as adjusted for leverage if leverage is provided..\\n\\n    Returns 0 if the resulting stop price would be above/below (longs/shorts) the current price\\n\\n    :param open_relative_stop: Desired stop loss percentage, relative to the open price,\\n                               adjusted for leverage\\n    :param current_profit: The current profit percentage\\n    :param is_short: When true, perform the calculation for short instead of long\\n    :param leverage: Leverage to use for the calculation\\n    :return: Stop loss value relative to current price\\n    '\n    _current_profit = current_profit / leverage\n    if _current_profit == -1 and (not is_short) or (is_short and _current_profit == 1):\n        return 1\n    if is_short is True:\n        stoploss = -1 + (1 - open_relative_stop / leverage) / (1 - _current_profit)\n    else:\n        stoploss = 1 - (1 + open_relative_stop / leverage) / (1 + _current_profit)\n    return max(stoploss * leverage, 0.0)",
            "def stoploss_from_open(open_relative_stop: float, current_profit: float, is_short: bool=False, leverage: float=1.0) -> float:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Given the current profit, and a desired stop loss value relative to the trade entry price,\\n    return a stop loss value that is relative to the current price, and which can be\\n    returned from `custom_stoploss`.\\n\\n    The requested stop can be positive for a stop above the open price, or negative for\\n    a stop below the open price. The return value is always >= 0.\\n    `open_relative_stop` will be considered as adjusted for leverage if leverage is provided..\\n\\n    Returns 0 if the resulting stop price would be above/below (longs/shorts) the current price\\n\\n    :param open_relative_stop: Desired stop loss percentage, relative to the open price,\\n                               adjusted for leverage\\n    :param current_profit: The current profit percentage\\n    :param is_short: When true, perform the calculation for short instead of long\\n    :param leverage: Leverage to use for the calculation\\n    :return: Stop loss value relative to current price\\n    '\n    _current_profit = current_profit / leverage\n    if _current_profit == -1 and (not is_short) or (is_short and _current_profit == 1):\n        return 1\n    if is_short is True:\n        stoploss = -1 + (1 - open_relative_stop / leverage) / (1 - _current_profit)\n    else:\n        stoploss = 1 - (1 + open_relative_stop / leverage) / (1 + _current_profit)\n    return max(stoploss * leverage, 0.0)",
            "def stoploss_from_open(open_relative_stop: float, current_profit: float, is_short: bool=False, leverage: float=1.0) -> float:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Given the current profit, and a desired stop loss value relative to the trade entry price,\\n    return a stop loss value that is relative to the current price, and which can be\\n    returned from `custom_stoploss`.\\n\\n    The requested stop can be positive for a stop above the open price, or negative for\\n    a stop below the open price. The return value is always >= 0.\\n    `open_relative_stop` will be considered as adjusted for leverage if leverage is provided..\\n\\n    Returns 0 if the resulting stop price would be above/below (longs/shorts) the current price\\n\\n    :param open_relative_stop: Desired stop loss percentage, relative to the open price,\\n                               adjusted for leverage\\n    :param current_profit: The current profit percentage\\n    :param is_short: When true, perform the calculation for short instead of long\\n    :param leverage: Leverage to use for the calculation\\n    :return: Stop loss value relative to current price\\n    '\n    _current_profit = current_profit / leverage\n    if _current_profit == -1 and (not is_short) or (is_short and _current_profit == 1):\n        return 1\n    if is_short is True:\n        stoploss = -1 + (1 - open_relative_stop / leverage) / (1 - _current_profit)\n    else:\n        stoploss = 1 - (1 + open_relative_stop / leverage) / (1 + _current_profit)\n    return max(stoploss * leverage, 0.0)",
            "def stoploss_from_open(open_relative_stop: float, current_profit: float, is_short: bool=False, leverage: float=1.0) -> float:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Given the current profit, and a desired stop loss value relative to the trade entry price,\\n    return a stop loss value that is relative to the current price, and which can be\\n    returned from `custom_stoploss`.\\n\\n    The requested stop can be positive for a stop above the open price, or negative for\\n    a stop below the open price. The return value is always >= 0.\\n    `open_relative_stop` will be considered as adjusted for leverage if leverage is provided..\\n\\n    Returns 0 if the resulting stop price would be above/below (longs/shorts) the current price\\n\\n    :param open_relative_stop: Desired stop loss percentage, relative to the open price,\\n                               adjusted for leverage\\n    :param current_profit: The current profit percentage\\n    :param is_short: When true, perform the calculation for short instead of long\\n    :param leverage: Leverage to use for the calculation\\n    :return: Stop loss value relative to current price\\n    '\n    _current_profit = current_profit / leverage\n    if _current_profit == -1 and (not is_short) or (is_short and _current_profit == 1):\n        return 1\n    if is_short is True:\n        stoploss = -1 + (1 - open_relative_stop / leverage) / (1 - _current_profit)\n    else:\n        stoploss = 1 - (1 + open_relative_stop / leverage) / (1 + _current_profit)\n    return max(stoploss * leverage, 0.0)",
            "def stoploss_from_open(open_relative_stop: float, current_profit: float, is_short: bool=False, leverage: float=1.0) -> float:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Given the current profit, and a desired stop loss value relative to the trade entry price,\\n    return a stop loss value that is relative to the current price, and which can be\\n    returned from `custom_stoploss`.\\n\\n    The requested stop can be positive for a stop above the open price, or negative for\\n    a stop below the open price. The return value is always >= 0.\\n    `open_relative_stop` will be considered as adjusted for leverage if leverage is provided..\\n\\n    Returns 0 if the resulting stop price would be above/below (longs/shorts) the current price\\n\\n    :param open_relative_stop: Desired stop loss percentage, relative to the open price,\\n                               adjusted for leverage\\n    :param current_profit: The current profit percentage\\n    :param is_short: When true, perform the calculation for short instead of long\\n    :param leverage: Leverage to use for the calculation\\n    :return: Stop loss value relative to current price\\n    '\n    _current_profit = current_profit / leverage\n    if _current_profit == -1 and (not is_short) or (is_short and _current_profit == 1):\n        return 1\n    if is_short is True:\n        stoploss = -1 + (1 - open_relative_stop / leverage) / (1 - _current_profit)\n    else:\n        stoploss = 1 - (1 + open_relative_stop / leverage) / (1 + _current_profit)\n    return max(stoploss * leverage, 0.0)"
        ]
    },
    {
        "func_name": "stoploss_from_absolute",
        "original": "def stoploss_from_absolute(stop_rate: float, current_rate: float, is_short: bool=False, leverage: float=1.0) -> float:\n    \"\"\"\n    Given current price and desired stop price, return a stop loss value that is relative to current\n    price.\n\n    The requested stop can be positive for a stop above the open price, or negative for\n    a stop below the open price. The return value is always >= 0.\n\n    Returns 0 if the resulting stop price would be above the current price.\n\n    :param stop_rate: Stop loss price.\n    :param current_rate: Current asset price.\n    :param is_short: When true, perform the calculation for short instead of long\n    :param leverage: Leverage to use for the calculation\n    :return: Positive stop loss value relative to current price\n    \"\"\"\n    if current_rate == 0:\n        return 1\n    stoploss = 1 - stop_rate / current_rate\n    if is_short:\n        stoploss = -stoploss\n    return max(min(stoploss, 1.0), 0.0) * leverage",
        "mutated": [
            "def stoploss_from_absolute(stop_rate: float, current_rate: float, is_short: bool=False, leverage: float=1.0) -> float:\n    if False:\n        i = 10\n    '\\n    Given current price and desired stop price, return a stop loss value that is relative to current\\n    price.\\n\\n    The requested stop can be positive for a stop above the open price, or negative for\\n    a stop below the open price. The return value is always >= 0.\\n\\n    Returns 0 if the resulting stop price would be above the current price.\\n\\n    :param stop_rate: Stop loss price.\\n    :param current_rate: Current asset price.\\n    :param is_short: When true, perform the calculation for short instead of long\\n    :param leverage: Leverage to use for the calculation\\n    :return: Positive stop loss value relative to current price\\n    '\n    if current_rate == 0:\n        return 1\n    stoploss = 1 - stop_rate / current_rate\n    if is_short:\n        stoploss = -stoploss\n    return max(min(stoploss, 1.0), 0.0) * leverage",
            "def stoploss_from_absolute(stop_rate: float, current_rate: float, is_short: bool=False, leverage: float=1.0) -> float:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Given current price and desired stop price, return a stop loss value that is relative to current\\n    price.\\n\\n    The requested stop can be positive for a stop above the open price, or negative for\\n    a stop below the open price. The return value is always >= 0.\\n\\n    Returns 0 if the resulting stop price would be above the current price.\\n\\n    :param stop_rate: Stop loss price.\\n    :param current_rate: Current asset price.\\n    :param is_short: When true, perform the calculation for short instead of long\\n    :param leverage: Leverage to use for the calculation\\n    :return: Positive stop loss value relative to current price\\n    '\n    if current_rate == 0:\n        return 1\n    stoploss = 1 - stop_rate / current_rate\n    if is_short:\n        stoploss = -stoploss\n    return max(min(stoploss, 1.0), 0.0) * leverage",
            "def stoploss_from_absolute(stop_rate: float, current_rate: float, is_short: bool=False, leverage: float=1.0) -> float:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Given current price and desired stop price, return a stop loss value that is relative to current\\n    price.\\n\\n    The requested stop can be positive for a stop above the open price, or negative for\\n    a stop below the open price. The return value is always >= 0.\\n\\n    Returns 0 if the resulting stop price would be above the current price.\\n\\n    :param stop_rate: Stop loss price.\\n    :param current_rate: Current asset price.\\n    :param is_short: When true, perform the calculation for short instead of long\\n    :param leverage: Leverage to use for the calculation\\n    :return: Positive stop loss value relative to current price\\n    '\n    if current_rate == 0:\n        return 1\n    stoploss = 1 - stop_rate / current_rate\n    if is_short:\n        stoploss = -stoploss\n    return max(min(stoploss, 1.0), 0.0) * leverage",
            "def stoploss_from_absolute(stop_rate: float, current_rate: float, is_short: bool=False, leverage: float=1.0) -> float:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Given current price and desired stop price, return a stop loss value that is relative to current\\n    price.\\n\\n    The requested stop can be positive for a stop above the open price, or negative for\\n    a stop below the open price. The return value is always >= 0.\\n\\n    Returns 0 if the resulting stop price would be above the current price.\\n\\n    :param stop_rate: Stop loss price.\\n    :param current_rate: Current asset price.\\n    :param is_short: When true, perform the calculation for short instead of long\\n    :param leverage: Leverage to use for the calculation\\n    :return: Positive stop loss value relative to current price\\n    '\n    if current_rate == 0:\n        return 1\n    stoploss = 1 - stop_rate / current_rate\n    if is_short:\n        stoploss = -stoploss\n    return max(min(stoploss, 1.0), 0.0) * leverage",
            "def stoploss_from_absolute(stop_rate: float, current_rate: float, is_short: bool=False, leverage: float=1.0) -> float:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Given current price and desired stop price, return a stop loss value that is relative to current\\n    price.\\n\\n    The requested stop can be positive for a stop above the open price, or negative for\\n    a stop below the open price. The return value is always >= 0.\\n\\n    Returns 0 if the resulting stop price would be above the current price.\\n\\n    :param stop_rate: Stop loss price.\\n    :param current_rate: Current asset price.\\n    :param is_short: When true, perform the calculation for short instead of long\\n    :param leverage: Leverage to use for the calculation\\n    :return: Positive stop loss value relative to current price\\n    '\n    if current_rate == 0:\n        return 1\n    stoploss = 1 - stop_rate / current_rate\n    if is_short:\n        stoploss = -stoploss\n    return max(min(stoploss, 1.0), 0.0) * leverage"
        ]
    }
]