[
    {
        "func_name": "glrm_orthonnmf",
        "original": "def glrm_orthonnmf():\n    m = 1000\n    n = 100\n    k = 10\n    print('Uploading random uniform matrix with rows = ' + str(m) + ' and cols = ' + str(n))\n    Y = np.random.rand(k, n)\n    X = np.random.rand(m, k)\n    train = np.dot(X, Y)\n    train_h2o = h2o.H2OFrame(train.tolist())\n    print('Run GLRM with orthogonal non-negative regularization on X, non-negative regularization on Y')\n    initial_y = np.random.rand(k, n)\n    initial_y_h2o = h2o.H2OFrame(initial_y.tolist())\n    glrm_h2o = H2OGeneralizedLowRankEstimator(k=k, init='User', user_y=initial_y_h2o, loss='Quadratic', regularization_x='OneSparse', regularization_y='NonNegative', gamma_x=1, gamma_y=1)\n    glrm_h2o.train(x=train_h2o.names, training_frame=train_h2o)\n    glrm_h2o.show()\n    print('Check that X and Y matrices are non-negative')\n    fit_y = glrm_h2o._model_json['output']['archetypes'].cell_values\n    fit_y_np = [[float(s) for s in list(row)[1:]] for row in fit_y]\n    fit_y_np = np.array(fit_y_np)\n    fit_x = h2o.get_frame(glrm_h2o._model_json['output']['representation_name'])\n    fit_x_np = np.array(h2o.as_list(fit_x))\n    assert np.all(fit_y_np >= 0), 'Y must contain only non-negative elements'\n    assert np.all(fit_x_np >= 0), 'X must contain only non-negative elements'\n    print('Check that columns of X are orthogonal')\n    xtx = np.dot(np.transpose(fit_x_np), fit_x_np)\n    offdiag = np.extract(1 - np.eye(k), xtx)\n    assert np.all(offdiag == 0), \"All off diagonal elements of X'X must equal zero\"\n    print('Check final objective function value')\n    fit_xy = np.dot(fit_x_np, fit_y_np)\n    glrm_obj = glrm_h2o._model_json['output']['objective']\n    sse = np.sum(np.square(train.__sub__(fit_xy)))\n    assert abs(glrm_obj - sse) < 1e-06, 'Final objective was ' + str(glrm_obj) + ' but should equal ' + str(sse)\n    print('Impute XY and check error metrics')\n    pred_h2o = glrm_h2o.predict(train_h2o)\n    pred_np = np.array(h2o.as_list(pred_h2o))\n    assert np.allclose(pred_np, fit_xy), 'Imputation for numerics with quadratic loss should equal XY product'\n    glrm_numerr = glrm_h2o._model_json['output']['training_metrics']._metric_json['numerr']\n    glrm_caterr = glrm_h2o._model_json['output']['training_metrics']._metric_json['caterr']\n    assert abs(glrm_numerr - glrm_obj) < 0.001, 'Numeric error was ' + str(glrm_numerr) + ' but should equal final objective ' + str(glrm_obj)\n    assert glrm_caterr == 0, 'Categorical error was ' + str(glrm_caterr) + ' but should be zero'\n    print('Run GLRM with orthogonal non-negative regularization on both X and Y')\n    initial_y = np.random.rand(k, n)\n    initial_y_h2o = h2o.H2OFrame(initial_y.tolist())\n    glrm_h2o = H2OGeneralizedLowRankEstimator(k=k, init='User', user_y=initial_y_h2o, loss='Quadratic', regularization_x='OneSparse', regularization_y='OneSparse', gamma_x=1, gamma_y=1)\n    glrm_h2o.train(x=train_h2o.names, training_frame=train_h2o)\n    glrm_h2o.show()\n    print('Check that X and Y matrices are non-negative')\n    fit_y = glrm_h2o._model_json['output']['archetypes'].cell_values\n    fit_y_np = [[float(s) for s in list(row)[1:]] for row in fit_y]\n    fit_y_np = np.array(fit_y_np)\n    fit_x = h2o.get_frame(glrm_h2o._model_json['output']['representation_name'])\n    fit_x_np = np.array(h2o.as_list(fit_x))\n    assert np.all(fit_y_np >= 0), 'Y must contain only non-negative elements'\n    assert np.all(fit_x_np >= 0), 'X must contain only non-negative elements'\n    print('Check that columns of X are orthogonal')\n    xtx = np.dot(np.transpose(fit_x_np), fit_x_np)\n    offdiag_x = np.extract(1 - np.eye(k), xtx)\n    assert np.all(offdiag_x == 0), \"All off diagonal elements of X'X must equal zero\"\n    print('Check that rows of Y are orthogonal')\n    yyt = np.dot(fit_y_np, np.transpose(fit_y_np))\n    offdiag_y = np.extract(1 - np.eye(k), yyt)\n    assert np.all(offdiag_y == 0), \"All off diagonal elements of YY' must equal zero\"\n    print('Check final objective function value')\n    fit_xy = np.dot(fit_x_np, fit_y_np)\n    glrm_obj = glrm_h2o._model_json['output']['objective']\n    sse = np.sum(np.square(train.__sub__(fit_xy)))\n    assert abs(glrm_obj - sse) < 1e-06, 'Final objective was ' + str(glrm_obj) + ' but should equal ' + str(sse)\n    print('Impute XY and check error metrics')\n    pred_h2o = glrm_h2o.predict(train_h2o)\n    pred_np = np.array(h2o.as_list(pred_h2o))\n    assert np.allclose(pred_np, fit_xy), 'Imputation for numerics with quadratic loss should equal XY product'\n    glrm_numerr = glrm_h2o._model_json['output']['training_metrics']._metric_json['numerr']\n    glrm_caterr = glrm_h2o._model_json['output']['training_metrics']._metric_json['caterr']\n    assert abs(glrm_numerr - glrm_obj) < 0.001, 'Numeric error was ' + str(glrm_numerr) + ' but should equal final objective ' + str(glrm_obj)\n    assert glrm_caterr == 0, 'Categorical error was ' + str(glrm_caterr) + ' but should be zero'",
        "mutated": [
            "def glrm_orthonnmf():\n    if False:\n        i = 10\n    m = 1000\n    n = 100\n    k = 10\n    print('Uploading random uniform matrix with rows = ' + str(m) + ' and cols = ' + str(n))\n    Y = np.random.rand(k, n)\n    X = np.random.rand(m, k)\n    train = np.dot(X, Y)\n    train_h2o = h2o.H2OFrame(train.tolist())\n    print('Run GLRM with orthogonal non-negative regularization on X, non-negative regularization on Y')\n    initial_y = np.random.rand(k, n)\n    initial_y_h2o = h2o.H2OFrame(initial_y.tolist())\n    glrm_h2o = H2OGeneralizedLowRankEstimator(k=k, init='User', user_y=initial_y_h2o, loss='Quadratic', regularization_x='OneSparse', regularization_y='NonNegative', gamma_x=1, gamma_y=1)\n    glrm_h2o.train(x=train_h2o.names, training_frame=train_h2o)\n    glrm_h2o.show()\n    print('Check that X and Y matrices are non-negative')\n    fit_y = glrm_h2o._model_json['output']['archetypes'].cell_values\n    fit_y_np = [[float(s) for s in list(row)[1:]] for row in fit_y]\n    fit_y_np = np.array(fit_y_np)\n    fit_x = h2o.get_frame(glrm_h2o._model_json['output']['representation_name'])\n    fit_x_np = np.array(h2o.as_list(fit_x))\n    assert np.all(fit_y_np >= 0), 'Y must contain only non-negative elements'\n    assert np.all(fit_x_np >= 0), 'X must contain only non-negative elements'\n    print('Check that columns of X are orthogonal')\n    xtx = np.dot(np.transpose(fit_x_np), fit_x_np)\n    offdiag = np.extract(1 - np.eye(k), xtx)\n    assert np.all(offdiag == 0), \"All off diagonal elements of X'X must equal zero\"\n    print('Check final objective function value')\n    fit_xy = np.dot(fit_x_np, fit_y_np)\n    glrm_obj = glrm_h2o._model_json['output']['objective']\n    sse = np.sum(np.square(train.__sub__(fit_xy)))\n    assert abs(glrm_obj - sse) < 1e-06, 'Final objective was ' + str(glrm_obj) + ' but should equal ' + str(sse)\n    print('Impute XY and check error metrics')\n    pred_h2o = glrm_h2o.predict(train_h2o)\n    pred_np = np.array(h2o.as_list(pred_h2o))\n    assert np.allclose(pred_np, fit_xy), 'Imputation for numerics with quadratic loss should equal XY product'\n    glrm_numerr = glrm_h2o._model_json['output']['training_metrics']._metric_json['numerr']\n    glrm_caterr = glrm_h2o._model_json['output']['training_metrics']._metric_json['caterr']\n    assert abs(glrm_numerr - glrm_obj) < 0.001, 'Numeric error was ' + str(glrm_numerr) + ' but should equal final objective ' + str(glrm_obj)\n    assert glrm_caterr == 0, 'Categorical error was ' + str(glrm_caterr) + ' but should be zero'\n    print('Run GLRM with orthogonal non-negative regularization on both X and Y')\n    initial_y = np.random.rand(k, n)\n    initial_y_h2o = h2o.H2OFrame(initial_y.tolist())\n    glrm_h2o = H2OGeneralizedLowRankEstimator(k=k, init='User', user_y=initial_y_h2o, loss='Quadratic', regularization_x='OneSparse', regularization_y='OneSparse', gamma_x=1, gamma_y=1)\n    glrm_h2o.train(x=train_h2o.names, training_frame=train_h2o)\n    glrm_h2o.show()\n    print('Check that X and Y matrices are non-negative')\n    fit_y = glrm_h2o._model_json['output']['archetypes'].cell_values\n    fit_y_np = [[float(s) for s in list(row)[1:]] for row in fit_y]\n    fit_y_np = np.array(fit_y_np)\n    fit_x = h2o.get_frame(glrm_h2o._model_json['output']['representation_name'])\n    fit_x_np = np.array(h2o.as_list(fit_x))\n    assert np.all(fit_y_np >= 0), 'Y must contain only non-negative elements'\n    assert np.all(fit_x_np >= 0), 'X must contain only non-negative elements'\n    print('Check that columns of X are orthogonal')\n    xtx = np.dot(np.transpose(fit_x_np), fit_x_np)\n    offdiag_x = np.extract(1 - np.eye(k), xtx)\n    assert np.all(offdiag_x == 0), \"All off diagonal elements of X'X must equal zero\"\n    print('Check that rows of Y are orthogonal')\n    yyt = np.dot(fit_y_np, np.transpose(fit_y_np))\n    offdiag_y = np.extract(1 - np.eye(k), yyt)\n    assert np.all(offdiag_y == 0), \"All off diagonal elements of YY' must equal zero\"\n    print('Check final objective function value')\n    fit_xy = np.dot(fit_x_np, fit_y_np)\n    glrm_obj = glrm_h2o._model_json['output']['objective']\n    sse = np.sum(np.square(train.__sub__(fit_xy)))\n    assert abs(glrm_obj - sse) < 1e-06, 'Final objective was ' + str(glrm_obj) + ' but should equal ' + str(sse)\n    print('Impute XY and check error metrics')\n    pred_h2o = glrm_h2o.predict(train_h2o)\n    pred_np = np.array(h2o.as_list(pred_h2o))\n    assert np.allclose(pred_np, fit_xy), 'Imputation for numerics with quadratic loss should equal XY product'\n    glrm_numerr = glrm_h2o._model_json['output']['training_metrics']._metric_json['numerr']\n    glrm_caterr = glrm_h2o._model_json['output']['training_metrics']._metric_json['caterr']\n    assert abs(glrm_numerr - glrm_obj) < 0.001, 'Numeric error was ' + str(glrm_numerr) + ' but should equal final objective ' + str(glrm_obj)\n    assert glrm_caterr == 0, 'Categorical error was ' + str(glrm_caterr) + ' but should be zero'",
            "def glrm_orthonnmf():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    m = 1000\n    n = 100\n    k = 10\n    print('Uploading random uniform matrix with rows = ' + str(m) + ' and cols = ' + str(n))\n    Y = np.random.rand(k, n)\n    X = np.random.rand(m, k)\n    train = np.dot(X, Y)\n    train_h2o = h2o.H2OFrame(train.tolist())\n    print('Run GLRM with orthogonal non-negative regularization on X, non-negative regularization on Y')\n    initial_y = np.random.rand(k, n)\n    initial_y_h2o = h2o.H2OFrame(initial_y.tolist())\n    glrm_h2o = H2OGeneralizedLowRankEstimator(k=k, init='User', user_y=initial_y_h2o, loss='Quadratic', regularization_x='OneSparse', regularization_y='NonNegative', gamma_x=1, gamma_y=1)\n    glrm_h2o.train(x=train_h2o.names, training_frame=train_h2o)\n    glrm_h2o.show()\n    print('Check that X and Y matrices are non-negative')\n    fit_y = glrm_h2o._model_json['output']['archetypes'].cell_values\n    fit_y_np = [[float(s) for s in list(row)[1:]] for row in fit_y]\n    fit_y_np = np.array(fit_y_np)\n    fit_x = h2o.get_frame(glrm_h2o._model_json['output']['representation_name'])\n    fit_x_np = np.array(h2o.as_list(fit_x))\n    assert np.all(fit_y_np >= 0), 'Y must contain only non-negative elements'\n    assert np.all(fit_x_np >= 0), 'X must contain only non-negative elements'\n    print('Check that columns of X are orthogonal')\n    xtx = np.dot(np.transpose(fit_x_np), fit_x_np)\n    offdiag = np.extract(1 - np.eye(k), xtx)\n    assert np.all(offdiag == 0), \"All off diagonal elements of X'X must equal zero\"\n    print('Check final objective function value')\n    fit_xy = np.dot(fit_x_np, fit_y_np)\n    glrm_obj = glrm_h2o._model_json['output']['objective']\n    sse = np.sum(np.square(train.__sub__(fit_xy)))\n    assert abs(glrm_obj - sse) < 1e-06, 'Final objective was ' + str(glrm_obj) + ' but should equal ' + str(sse)\n    print('Impute XY and check error metrics')\n    pred_h2o = glrm_h2o.predict(train_h2o)\n    pred_np = np.array(h2o.as_list(pred_h2o))\n    assert np.allclose(pred_np, fit_xy), 'Imputation for numerics with quadratic loss should equal XY product'\n    glrm_numerr = glrm_h2o._model_json['output']['training_metrics']._metric_json['numerr']\n    glrm_caterr = glrm_h2o._model_json['output']['training_metrics']._metric_json['caterr']\n    assert abs(glrm_numerr - glrm_obj) < 0.001, 'Numeric error was ' + str(glrm_numerr) + ' but should equal final objective ' + str(glrm_obj)\n    assert glrm_caterr == 0, 'Categorical error was ' + str(glrm_caterr) + ' but should be zero'\n    print('Run GLRM with orthogonal non-negative regularization on both X and Y')\n    initial_y = np.random.rand(k, n)\n    initial_y_h2o = h2o.H2OFrame(initial_y.tolist())\n    glrm_h2o = H2OGeneralizedLowRankEstimator(k=k, init='User', user_y=initial_y_h2o, loss='Quadratic', regularization_x='OneSparse', regularization_y='OneSparse', gamma_x=1, gamma_y=1)\n    glrm_h2o.train(x=train_h2o.names, training_frame=train_h2o)\n    glrm_h2o.show()\n    print('Check that X and Y matrices are non-negative')\n    fit_y = glrm_h2o._model_json['output']['archetypes'].cell_values\n    fit_y_np = [[float(s) for s in list(row)[1:]] for row in fit_y]\n    fit_y_np = np.array(fit_y_np)\n    fit_x = h2o.get_frame(glrm_h2o._model_json['output']['representation_name'])\n    fit_x_np = np.array(h2o.as_list(fit_x))\n    assert np.all(fit_y_np >= 0), 'Y must contain only non-negative elements'\n    assert np.all(fit_x_np >= 0), 'X must contain only non-negative elements'\n    print('Check that columns of X are orthogonal')\n    xtx = np.dot(np.transpose(fit_x_np), fit_x_np)\n    offdiag_x = np.extract(1 - np.eye(k), xtx)\n    assert np.all(offdiag_x == 0), \"All off diagonal elements of X'X must equal zero\"\n    print('Check that rows of Y are orthogonal')\n    yyt = np.dot(fit_y_np, np.transpose(fit_y_np))\n    offdiag_y = np.extract(1 - np.eye(k), yyt)\n    assert np.all(offdiag_y == 0), \"All off diagonal elements of YY' must equal zero\"\n    print('Check final objective function value')\n    fit_xy = np.dot(fit_x_np, fit_y_np)\n    glrm_obj = glrm_h2o._model_json['output']['objective']\n    sse = np.sum(np.square(train.__sub__(fit_xy)))\n    assert abs(glrm_obj - sse) < 1e-06, 'Final objective was ' + str(glrm_obj) + ' but should equal ' + str(sse)\n    print('Impute XY and check error metrics')\n    pred_h2o = glrm_h2o.predict(train_h2o)\n    pred_np = np.array(h2o.as_list(pred_h2o))\n    assert np.allclose(pred_np, fit_xy), 'Imputation for numerics with quadratic loss should equal XY product'\n    glrm_numerr = glrm_h2o._model_json['output']['training_metrics']._metric_json['numerr']\n    glrm_caterr = glrm_h2o._model_json['output']['training_metrics']._metric_json['caterr']\n    assert abs(glrm_numerr - glrm_obj) < 0.001, 'Numeric error was ' + str(glrm_numerr) + ' but should equal final objective ' + str(glrm_obj)\n    assert glrm_caterr == 0, 'Categorical error was ' + str(glrm_caterr) + ' but should be zero'",
            "def glrm_orthonnmf():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    m = 1000\n    n = 100\n    k = 10\n    print('Uploading random uniform matrix with rows = ' + str(m) + ' and cols = ' + str(n))\n    Y = np.random.rand(k, n)\n    X = np.random.rand(m, k)\n    train = np.dot(X, Y)\n    train_h2o = h2o.H2OFrame(train.tolist())\n    print('Run GLRM with orthogonal non-negative regularization on X, non-negative regularization on Y')\n    initial_y = np.random.rand(k, n)\n    initial_y_h2o = h2o.H2OFrame(initial_y.tolist())\n    glrm_h2o = H2OGeneralizedLowRankEstimator(k=k, init='User', user_y=initial_y_h2o, loss='Quadratic', regularization_x='OneSparse', regularization_y='NonNegative', gamma_x=1, gamma_y=1)\n    glrm_h2o.train(x=train_h2o.names, training_frame=train_h2o)\n    glrm_h2o.show()\n    print('Check that X and Y matrices are non-negative')\n    fit_y = glrm_h2o._model_json['output']['archetypes'].cell_values\n    fit_y_np = [[float(s) for s in list(row)[1:]] for row in fit_y]\n    fit_y_np = np.array(fit_y_np)\n    fit_x = h2o.get_frame(glrm_h2o._model_json['output']['representation_name'])\n    fit_x_np = np.array(h2o.as_list(fit_x))\n    assert np.all(fit_y_np >= 0), 'Y must contain only non-negative elements'\n    assert np.all(fit_x_np >= 0), 'X must contain only non-negative elements'\n    print('Check that columns of X are orthogonal')\n    xtx = np.dot(np.transpose(fit_x_np), fit_x_np)\n    offdiag = np.extract(1 - np.eye(k), xtx)\n    assert np.all(offdiag == 0), \"All off diagonal elements of X'X must equal zero\"\n    print('Check final objective function value')\n    fit_xy = np.dot(fit_x_np, fit_y_np)\n    glrm_obj = glrm_h2o._model_json['output']['objective']\n    sse = np.sum(np.square(train.__sub__(fit_xy)))\n    assert abs(glrm_obj - sse) < 1e-06, 'Final objective was ' + str(glrm_obj) + ' but should equal ' + str(sse)\n    print('Impute XY and check error metrics')\n    pred_h2o = glrm_h2o.predict(train_h2o)\n    pred_np = np.array(h2o.as_list(pred_h2o))\n    assert np.allclose(pred_np, fit_xy), 'Imputation for numerics with quadratic loss should equal XY product'\n    glrm_numerr = glrm_h2o._model_json['output']['training_metrics']._metric_json['numerr']\n    glrm_caterr = glrm_h2o._model_json['output']['training_metrics']._metric_json['caterr']\n    assert abs(glrm_numerr - glrm_obj) < 0.001, 'Numeric error was ' + str(glrm_numerr) + ' but should equal final objective ' + str(glrm_obj)\n    assert glrm_caterr == 0, 'Categorical error was ' + str(glrm_caterr) + ' but should be zero'\n    print('Run GLRM with orthogonal non-negative regularization on both X and Y')\n    initial_y = np.random.rand(k, n)\n    initial_y_h2o = h2o.H2OFrame(initial_y.tolist())\n    glrm_h2o = H2OGeneralizedLowRankEstimator(k=k, init='User', user_y=initial_y_h2o, loss='Quadratic', regularization_x='OneSparse', regularization_y='OneSparse', gamma_x=1, gamma_y=1)\n    glrm_h2o.train(x=train_h2o.names, training_frame=train_h2o)\n    glrm_h2o.show()\n    print('Check that X and Y matrices are non-negative')\n    fit_y = glrm_h2o._model_json['output']['archetypes'].cell_values\n    fit_y_np = [[float(s) for s in list(row)[1:]] for row in fit_y]\n    fit_y_np = np.array(fit_y_np)\n    fit_x = h2o.get_frame(glrm_h2o._model_json['output']['representation_name'])\n    fit_x_np = np.array(h2o.as_list(fit_x))\n    assert np.all(fit_y_np >= 0), 'Y must contain only non-negative elements'\n    assert np.all(fit_x_np >= 0), 'X must contain only non-negative elements'\n    print('Check that columns of X are orthogonal')\n    xtx = np.dot(np.transpose(fit_x_np), fit_x_np)\n    offdiag_x = np.extract(1 - np.eye(k), xtx)\n    assert np.all(offdiag_x == 0), \"All off diagonal elements of X'X must equal zero\"\n    print('Check that rows of Y are orthogonal')\n    yyt = np.dot(fit_y_np, np.transpose(fit_y_np))\n    offdiag_y = np.extract(1 - np.eye(k), yyt)\n    assert np.all(offdiag_y == 0), \"All off diagonal elements of YY' must equal zero\"\n    print('Check final objective function value')\n    fit_xy = np.dot(fit_x_np, fit_y_np)\n    glrm_obj = glrm_h2o._model_json['output']['objective']\n    sse = np.sum(np.square(train.__sub__(fit_xy)))\n    assert abs(glrm_obj - sse) < 1e-06, 'Final objective was ' + str(glrm_obj) + ' but should equal ' + str(sse)\n    print('Impute XY and check error metrics')\n    pred_h2o = glrm_h2o.predict(train_h2o)\n    pred_np = np.array(h2o.as_list(pred_h2o))\n    assert np.allclose(pred_np, fit_xy), 'Imputation for numerics with quadratic loss should equal XY product'\n    glrm_numerr = glrm_h2o._model_json['output']['training_metrics']._metric_json['numerr']\n    glrm_caterr = glrm_h2o._model_json['output']['training_metrics']._metric_json['caterr']\n    assert abs(glrm_numerr - glrm_obj) < 0.001, 'Numeric error was ' + str(glrm_numerr) + ' but should equal final objective ' + str(glrm_obj)\n    assert glrm_caterr == 0, 'Categorical error was ' + str(glrm_caterr) + ' but should be zero'",
            "def glrm_orthonnmf():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    m = 1000\n    n = 100\n    k = 10\n    print('Uploading random uniform matrix with rows = ' + str(m) + ' and cols = ' + str(n))\n    Y = np.random.rand(k, n)\n    X = np.random.rand(m, k)\n    train = np.dot(X, Y)\n    train_h2o = h2o.H2OFrame(train.tolist())\n    print('Run GLRM with orthogonal non-negative regularization on X, non-negative regularization on Y')\n    initial_y = np.random.rand(k, n)\n    initial_y_h2o = h2o.H2OFrame(initial_y.tolist())\n    glrm_h2o = H2OGeneralizedLowRankEstimator(k=k, init='User', user_y=initial_y_h2o, loss='Quadratic', regularization_x='OneSparse', regularization_y='NonNegative', gamma_x=1, gamma_y=1)\n    glrm_h2o.train(x=train_h2o.names, training_frame=train_h2o)\n    glrm_h2o.show()\n    print('Check that X and Y matrices are non-negative')\n    fit_y = glrm_h2o._model_json['output']['archetypes'].cell_values\n    fit_y_np = [[float(s) for s in list(row)[1:]] for row in fit_y]\n    fit_y_np = np.array(fit_y_np)\n    fit_x = h2o.get_frame(glrm_h2o._model_json['output']['representation_name'])\n    fit_x_np = np.array(h2o.as_list(fit_x))\n    assert np.all(fit_y_np >= 0), 'Y must contain only non-negative elements'\n    assert np.all(fit_x_np >= 0), 'X must contain only non-negative elements'\n    print('Check that columns of X are orthogonal')\n    xtx = np.dot(np.transpose(fit_x_np), fit_x_np)\n    offdiag = np.extract(1 - np.eye(k), xtx)\n    assert np.all(offdiag == 0), \"All off diagonal elements of X'X must equal zero\"\n    print('Check final objective function value')\n    fit_xy = np.dot(fit_x_np, fit_y_np)\n    glrm_obj = glrm_h2o._model_json['output']['objective']\n    sse = np.sum(np.square(train.__sub__(fit_xy)))\n    assert abs(glrm_obj - sse) < 1e-06, 'Final objective was ' + str(glrm_obj) + ' but should equal ' + str(sse)\n    print('Impute XY and check error metrics')\n    pred_h2o = glrm_h2o.predict(train_h2o)\n    pred_np = np.array(h2o.as_list(pred_h2o))\n    assert np.allclose(pred_np, fit_xy), 'Imputation for numerics with quadratic loss should equal XY product'\n    glrm_numerr = glrm_h2o._model_json['output']['training_metrics']._metric_json['numerr']\n    glrm_caterr = glrm_h2o._model_json['output']['training_metrics']._metric_json['caterr']\n    assert abs(glrm_numerr - glrm_obj) < 0.001, 'Numeric error was ' + str(glrm_numerr) + ' but should equal final objective ' + str(glrm_obj)\n    assert glrm_caterr == 0, 'Categorical error was ' + str(glrm_caterr) + ' but should be zero'\n    print('Run GLRM with orthogonal non-negative regularization on both X and Y')\n    initial_y = np.random.rand(k, n)\n    initial_y_h2o = h2o.H2OFrame(initial_y.tolist())\n    glrm_h2o = H2OGeneralizedLowRankEstimator(k=k, init='User', user_y=initial_y_h2o, loss='Quadratic', regularization_x='OneSparse', regularization_y='OneSparse', gamma_x=1, gamma_y=1)\n    glrm_h2o.train(x=train_h2o.names, training_frame=train_h2o)\n    glrm_h2o.show()\n    print('Check that X and Y matrices are non-negative')\n    fit_y = glrm_h2o._model_json['output']['archetypes'].cell_values\n    fit_y_np = [[float(s) for s in list(row)[1:]] for row in fit_y]\n    fit_y_np = np.array(fit_y_np)\n    fit_x = h2o.get_frame(glrm_h2o._model_json['output']['representation_name'])\n    fit_x_np = np.array(h2o.as_list(fit_x))\n    assert np.all(fit_y_np >= 0), 'Y must contain only non-negative elements'\n    assert np.all(fit_x_np >= 0), 'X must contain only non-negative elements'\n    print('Check that columns of X are orthogonal')\n    xtx = np.dot(np.transpose(fit_x_np), fit_x_np)\n    offdiag_x = np.extract(1 - np.eye(k), xtx)\n    assert np.all(offdiag_x == 0), \"All off diagonal elements of X'X must equal zero\"\n    print('Check that rows of Y are orthogonal')\n    yyt = np.dot(fit_y_np, np.transpose(fit_y_np))\n    offdiag_y = np.extract(1 - np.eye(k), yyt)\n    assert np.all(offdiag_y == 0), \"All off diagonal elements of YY' must equal zero\"\n    print('Check final objective function value')\n    fit_xy = np.dot(fit_x_np, fit_y_np)\n    glrm_obj = glrm_h2o._model_json['output']['objective']\n    sse = np.sum(np.square(train.__sub__(fit_xy)))\n    assert abs(glrm_obj - sse) < 1e-06, 'Final objective was ' + str(glrm_obj) + ' but should equal ' + str(sse)\n    print('Impute XY and check error metrics')\n    pred_h2o = glrm_h2o.predict(train_h2o)\n    pred_np = np.array(h2o.as_list(pred_h2o))\n    assert np.allclose(pred_np, fit_xy), 'Imputation for numerics with quadratic loss should equal XY product'\n    glrm_numerr = glrm_h2o._model_json['output']['training_metrics']._metric_json['numerr']\n    glrm_caterr = glrm_h2o._model_json['output']['training_metrics']._metric_json['caterr']\n    assert abs(glrm_numerr - glrm_obj) < 0.001, 'Numeric error was ' + str(glrm_numerr) + ' but should equal final objective ' + str(glrm_obj)\n    assert glrm_caterr == 0, 'Categorical error was ' + str(glrm_caterr) + ' but should be zero'",
            "def glrm_orthonnmf():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    m = 1000\n    n = 100\n    k = 10\n    print('Uploading random uniform matrix with rows = ' + str(m) + ' and cols = ' + str(n))\n    Y = np.random.rand(k, n)\n    X = np.random.rand(m, k)\n    train = np.dot(X, Y)\n    train_h2o = h2o.H2OFrame(train.tolist())\n    print('Run GLRM with orthogonal non-negative regularization on X, non-negative regularization on Y')\n    initial_y = np.random.rand(k, n)\n    initial_y_h2o = h2o.H2OFrame(initial_y.tolist())\n    glrm_h2o = H2OGeneralizedLowRankEstimator(k=k, init='User', user_y=initial_y_h2o, loss='Quadratic', regularization_x='OneSparse', regularization_y='NonNegative', gamma_x=1, gamma_y=1)\n    glrm_h2o.train(x=train_h2o.names, training_frame=train_h2o)\n    glrm_h2o.show()\n    print('Check that X and Y matrices are non-negative')\n    fit_y = glrm_h2o._model_json['output']['archetypes'].cell_values\n    fit_y_np = [[float(s) for s in list(row)[1:]] for row in fit_y]\n    fit_y_np = np.array(fit_y_np)\n    fit_x = h2o.get_frame(glrm_h2o._model_json['output']['representation_name'])\n    fit_x_np = np.array(h2o.as_list(fit_x))\n    assert np.all(fit_y_np >= 0), 'Y must contain only non-negative elements'\n    assert np.all(fit_x_np >= 0), 'X must contain only non-negative elements'\n    print('Check that columns of X are orthogonal')\n    xtx = np.dot(np.transpose(fit_x_np), fit_x_np)\n    offdiag = np.extract(1 - np.eye(k), xtx)\n    assert np.all(offdiag == 0), \"All off diagonal elements of X'X must equal zero\"\n    print('Check final objective function value')\n    fit_xy = np.dot(fit_x_np, fit_y_np)\n    glrm_obj = glrm_h2o._model_json['output']['objective']\n    sse = np.sum(np.square(train.__sub__(fit_xy)))\n    assert abs(glrm_obj - sse) < 1e-06, 'Final objective was ' + str(glrm_obj) + ' but should equal ' + str(sse)\n    print('Impute XY and check error metrics')\n    pred_h2o = glrm_h2o.predict(train_h2o)\n    pred_np = np.array(h2o.as_list(pred_h2o))\n    assert np.allclose(pred_np, fit_xy), 'Imputation for numerics with quadratic loss should equal XY product'\n    glrm_numerr = glrm_h2o._model_json['output']['training_metrics']._metric_json['numerr']\n    glrm_caterr = glrm_h2o._model_json['output']['training_metrics']._metric_json['caterr']\n    assert abs(glrm_numerr - glrm_obj) < 0.001, 'Numeric error was ' + str(glrm_numerr) + ' but should equal final objective ' + str(glrm_obj)\n    assert glrm_caterr == 0, 'Categorical error was ' + str(glrm_caterr) + ' but should be zero'\n    print('Run GLRM with orthogonal non-negative regularization on both X and Y')\n    initial_y = np.random.rand(k, n)\n    initial_y_h2o = h2o.H2OFrame(initial_y.tolist())\n    glrm_h2o = H2OGeneralizedLowRankEstimator(k=k, init='User', user_y=initial_y_h2o, loss='Quadratic', regularization_x='OneSparse', regularization_y='OneSparse', gamma_x=1, gamma_y=1)\n    glrm_h2o.train(x=train_h2o.names, training_frame=train_h2o)\n    glrm_h2o.show()\n    print('Check that X and Y matrices are non-negative')\n    fit_y = glrm_h2o._model_json['output']['archetypes'].cell_values\n    fit_y_np = [[float(s) for s in list(row)[1:]] for row in fit_y]\n    fit_y_np = np.array(fit_y_np)\n    fit_x = h2o.get_frame(glrm_h2o._model_json['output']['representation_name'])\n    fit_x_np = np.array(h2o.as_list(fit_x))\n    assert np.all(fit_y_np >= 0), 'Y must contain only non-negative elements'\n    assert np.all(fit_x_np >= 0), 'X must contain only non-negative elements'\n    print('Check that columns of X are orthogonal')\n    xtx = np.dot(np.transpose(fit_x_np), fit_x_np)\n    offdiag_x = np.extract(1 - np.eye(k), xtx)\n    assert np.all(offdiag_x == 0), \"All off diagonal elements of X'X must equal zero\"\n    print('Check that rows of Y are orthogonal')\n    yyt = np.dot(fit_y_np, np.transpose(fit_y_np))\n    offdiag_y = np.extract(1 - np.eye(k), yyt)\n    assert np.all(offdiag_y == 0), \"All off diagonal elements of YY' must equal zero\"\n    print('Check final objective function value')\n    fit_xy = np.dot(fit_x_np, fit_y_np)\n    glrm_obj = glrm_h2o._model_json['output']['objective']\n    sse = np.sum(np.square(train.__sub__(fit_xy)))\n    assert abs(glrm_obj - sse) < 1e-06, 'Final objective was ' + str(glrm_obj) + ' but should equal ' + str(sse)\n    print('Impute XY and check error metrics')\n    pred_h2o = glrm_h2o.predict(train_h2o)\n    pred_np = np.array(h2o.as_list(pred_h2o))\n    assert np.allclose(pred_np, fit_xy), 'Imputation for numerics with quadratic loss should equal XY product'\n    glrm_numerr = glrm_h2o._model_json['output']['training_metrics']._metric_json['numerr']\n    glrm_caterr = glrm_h2o._model_json['output']['training_metrics']._metric_json['caterr']\n    assert abs(glrm_numerr - glrm_obj) < 0.001, 'Numeric error was ' + str(glrm_numerr) + ' but should equal final objective ' + str(glrm_obj)\n    assert glrm_caterr == 0, 'Categorical error was ' + str(glrm_caterr) + ' but should be zero'"
        ]
    }
]