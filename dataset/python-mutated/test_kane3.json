[
    {
        "func_name": "test_bicycle",
        "original": "@slow\ndef test_bicycle():\n    (q1, q2, q4, q5) = dynamicsymbols('q1 q2 q4 q5')\n    (q1d, q2d, q4d, q5d) = dynamicsymbols('q1 q2 q4 q5', 1)\n    (u1, u2, u3, u4, u5, u6) = dynamicsymbols('u1 u2 u3 u4 u5 u6')\n    (u1d, u2d, u3d, u4d, u5d, u6d) = dynamicsymbols('u1 u2 u3 u4 u5 u6', 1)\n    (WFrad, WRrad, htangle, forkoffset) = symbols('WFrad WRrad htangle forkoffset')\n    (forklength, framelength, forkcg1) = symbols('forklength framelength forkcg1')\n    (forkcg3, framecg1, framecg3, Iwr11) = symbols('forkcg3 framecg1 framecg3 Iwr11')\n    (Iwr22, Iwf11, Iwf22, Iframe11) = symbols('Iwr22 Iwf11 Iwf22 Iframe11')\n    (Iframe22, Iframe33, Iframe31, Ifork11) = symbols('Iframe22 Iframe33 Iframe31 Ifork11')\n    (Ifork22, Ifork33, Ifork31, g) = symbols('Ifork22 Ifork33 Ifork31 g')\n    (mframe, mfork, mwf, mwr) = symbols('mframe mfork mwf mwr')\n    N = ReferenceFrame('N')\n    Y = N.orientnew('Y', 'Axis', [q1, N.z])\n    R = Y.orientnew('R', 'Axis', [q2, Y.x])\n    Frame = R.orientnew('Frame', 'Axis', [q4 + htangle, R.y])\n    WR = ReferenceFrame('WR')\n    TempFrame = Frame.orientnew('TempFrame', 'Axis', [-htangle, Frame.y])\n    Fork = Frame.orientnew('Fork', 'Axis', [q5, Frame.x])\n    TempFork = Fork.orientnew('TempFork', 'Axis', [-htangle, Fork.y])\n    WF = ReferenceFrame('WF')\n    WR_cont = Point('WR_cont')\n    WR_mc = WR_cont.locatenew('WR_mc', WRrad * R.z)\n    Steer = WR_mc.locatenew('Steer', framelength * Frame.z)\n    Frame_mc = WR_mc.locatenew('Frame_mc', -framecg1 * Frame.x + framecg3 * Frame.z)\n    Fork_mc = Steer.locatenew('Fork_mc', -forkcg1 * Fork.x + forkcg3 * Fork.z)\n    WF_mc = Steer.locatenew('WF_mc', forklength * Fork.x + forkoffset * Fork.z)\n    WF_cont = WF_mc.locatenew('WF_cont', WFrad * (dot(Fork.y, Y.z) * Fork.y - Y.z).normalize())\n    Y.set_ang_vel(N, u1 * Y.z)\n    R.set_ang_vel(Y, u2 * R.x)\n    WR.set_ang_vel(Frame, u3 * Frame.y)\n    Frame.set_ang_vel(R, u4 * Frame.y)\n    Fork.set_ang_vel(Frame, u5 * Fork.x)\n    WF.set_ang_vel(Fork, u6 * Fork.y)\n    WR_cont.set_vel(N, 0)\n    WR_mc.v2pt_theory(WR_cont, N, WR)\n    Steer.v2pt_theory(WR_mc, N, Frame)\n    Frame_mc.v2pt_theory(WR_mc, N, Frame)\n    Fork_mc.v2pt_theory(Steer, N, Fork)\n    WF_mc.v2pt_theory(Steer, N, Fork)\n    WF_cont.v2pt_theory(WF_mc, N, WF)\n    Frame_I = (inertia(TempFrame, Iframe11, Iframe22, Iframe33, 0, 0, Iframe31), Frame_mc)\n    Fork_I = (inertia(TempFork, Ifork11, Ifork22, Ifork33, 0, 0, Ifork31), Fork_mc)\n    WR_I = (inertia(Frame, Iwr11, Iwr22, Iwr11), WR_mc)\n    WF_I = (inertia(Fork, Iwf11, Iwf22, Iwf11), WF_mc)\n    BodyFrame = RigidBody('BodyFrame', Frame_mc, Frame, mframe, Frame_I)\n    BodyFork = RigidBody('BodyFork', Fork_mc, Fork, mfork, Fork_I)\n    BodyWR = RigidBody('BodyWR', WR_mc, WR, mwr, WR_I)\n    BodyWF = RigidBody('BodyWF', WF_mc, WF, mwf, WF_I)\n    kd = [q1d - u1, q2d - u2, q4d - u4, q5d - u5]\n    conlist_speed = [WF_cont.vel(N) & Y.x, WF_cont.vel(N) & Y.y, WF_cont.vel(N) & Y.z]\n    conlist_coord = [WF_cont.pos_from(WR_cont) & Y.z]\n    FL = [(Frame_mc, -mframe * g * Y.z), (Fork_mc, -mfork * g * Y.z), (WF_mc, -mwf * g * Y.z), (WR_mc, -mwr * g * Y.z)]\n    BL = [BodyFrame, BodyFork, BodyWR, BodyWF]\n    KM = KanesMethod(N, q_ind=[q1, q2, q5], q_dependent=[q4], configuration_constraints=conlist_coord, u_ind=[u2, u3, u5], u_dependent=[u1, u4, u6], velocity_constraints=conlist_speed, kd_eqs=kd, constraint_solver='CRAMER')\n    (fr, frstar) = KM.kanes_equations(BL, FL)\n    PaperRadRear = 0.3\n    PaperRadFront = 0.35\n    HTA = (pi / 2 - pi / 10).evalf()\n    TrailPaper = 0.08\n    rake = (-(TrailPaper * sin(HTA) - PaperRadFront * cos(HTA))).evalf()\n    PaperWb = 1.02\n    PaperFrameCgX = 0.3\n    PaperFrameCgZ = 0.9\n    PaperForkCgX = 0.9\n    PaperForkCgZ = 0.7\n    FrameLength = (PaperWb * sin(HTA) - (rake - (PaperRadFront - PaperRadRear) * cos(HTA))).evalf()\n    FrameCGNorm = ((PaperFrameCgZ - PaperRadRear - PaperFrameCgX / sin(HTA) * cos(HTA)) * sin(HTA)).evalf()\n    FrameCGPar = (PaperFrameCgX / sin(HTA) + (PaperFrameCgZ - PaperRadRear - PaperFrameCgX / sin(HTA) * cos(HTA)) * cos(HTA)).evalf()\n    tempa = PaperForkCgZ - PaperRadFront\n    tempb = PaperWb - PaperForkCgX\n    tempc = sqrt(tempa ** 2 + tempb ** 2).evalf()\n    PaperForkL = (PaperWb * cos(HTA) - (PaperRadFront - PaperRadRear) * sin(HTA)).evalf()\n    ForkCGNorm = (rake + tempc * sin(pi / 2 - HTA - acos(tempa / tempc))).evalf()\n    ForkCGPar = (tempc * cos(pi / 2 - HTA - acos(tempa / tempc)) - PaperForkL).evalf()\n    v = symbols('v')\n    val_dict = {WFrad: PaperRadFront, WRrad: PaperRadRear, htangle: HTA, forkoffset: rake, forklength: PaperForkL, framelength: FrameLength, forkcg1: ForkCGPar, forkcg3: ForkCGNorm, framecg1: FrameCGNorm, framecg3: FrameCGPar, Iwr11: 0.0603, Iwr22: 0.12, Iwf11: 0.1405, Iwf22: 0.28, Ifork11: 0.05892, Ifork22: 0.06, Ifork33: 0.00708, Ifork31: 0.00756, Iframe11: 9.2, Iframe22: 11, Iframe33: 2.8, Iframe31: -2.4, mfork: 4, mframe: 85, mwf: 3, mwr: 2, g: 9.81, q1: 0, q2: 0, q4: 0, q5: 0, u1: 0, u2: 0, u3: v / PaperRadRear, u4: 0, u5: 0, u6: v / PaperRadFront}\n    (A, B, _) = KM.linearize(A_and_B=True, op_point={u1.diff(): 0, u2.diff(): 0, u3.diff(): 0, u4.diff(): 0, u5.diff(): 0, u6.diff(): 0, u1: 0, u2: 0, u3: v / PaperRadRear, u4: 0, u5: 0, u6: v / PaperRadFront, q1: 0, q2: 0, q4: 0, q5: 0}, linear_solver='CRAMER')\n    A_s = A.xreplace(val_dict)\n    B_s = B.xreplace(val_dict)\n    A_s = A_s.evalf()\n    B_s = B_s.evalf()\n    A = A_s.extract([1, 2, 3, 5], [1, 2, 3, 5])\n    Res = Matrix([[0, 0, 1.0, 0], [0, 0, 0, 1.0], [9.48977444677355, -0.891197738059089 * v ** 2 - 0.571523173729245, -0.105522449805691 * v, -0.330515398992311 * v], [11.7194768719633, -1.97171508499972 * v ** 2 + 30.9087533932407, 3.67680523332152 * v, -3.08486552743311 * v]])\n    eps = 1e-12\n    for i in range(6):\n        error = Res.subs(v, i) - A.subs(v, i)\n        assert all((abs(x) < eps for x in error))",
        "mutated": [
            "@slow\ndef test_bicycle():\n    if False:\n        i = 10\n    (q1, q2, q4, q5) = dynamicsymbols('q1 q2 q4 q5')\n    (q1d, q2d, q4d, q5d) = dynamicsymbols('q1 q2 q4 q5', 1)\n    (u1, u2, u3, u4, u5, u6) = dynamicsymbols('u1 u2 u3 u4 u5 u6')\n    (u1d, u2d, u3d, u4d, u5d, u6d) = dynamicsymbols('u1 u2 u3 u4 u5 u6', 1)\n    (WFrad, WRrad, htangle, forkoffset) = symbols('WFrad WRrad htangle forkoffset')\n    (forklength, framelength, forkcg1) = symbols('forklength framelength forkcg1')\n    (forkcg3, framecg1, framecg3, Iwr11) = symbols('forkcg3 framecg1 framecg3 Iwr11')\n    (Iwr22, Iwf11, Iwf22, Iframe11) = symbols('Iwr22 Iwf11 Iwf22 Iframe11')\n    (Iframe22, Iframe33, Iframe31, Ifork11) = symbols('Iframe22 Iframe33 Iframe31 Ifork11')\n    (Ifork22, Ifork33, Ifork31, g) = symbols('Ifork22 Ifork33 Ifork31 g')\n    (mframe, mfork, mwf, mwr) = symbols('mframe mfork mwf mwr')\n    N = ReferenceFrame('N')\n    Y = N.orientnew('Y', 'Axis', [q1, N.z])\n    R = Y.orientnew('R', 'Axis', [q2, Y.x])\n    Frame = R.orientnew('Frame', 'Axis', [q4 + htangle, R.y])\n    WR = ReferenceFrame('WR')\n    TempFrame = Frame.orientnew('TempFrame', 'Axis', [-htangle, Frame.y])\n    Fork = Frame.orientnew('Fork', 'Axis', [q5, Frame.x])\n    TempFork = Fork.orientnew('TempFork', 'Axis', [-htangle, Fork.y])\n    WF = ReferenceFrame('WF')\n    WR_cont = Point('WR_cont')\n    WR_mc = WR_cont.locatenew('WR_mc', WRrad * R.z)\n    Steer = WR_mc.locatenew('Steer', framelength * Frame.z)\n    Frame_mc = WR_mc.locatenew('Frame_mc', -framecg1 * Frame.x + framecg3 * Frame.z)\n    Fork_mc = Steer.locatenew('Fork_mc', -forkcg1 * Fork.x + forkcg3 * Fork.z)\n    WF_mc = Steer.locatenew('WF_mc', forklength * Fork.x + forkoffset * Fork.z)\n    WF_cont = WF_mc.locatenew('WF_cont', WFrad * (dot(Fork.y, Y.z) * Fork.y - Y.z).normalize())\n    Y.set_ang_vel(N, u1 * Y.z)\n    R.set_ang_vel(Y, u2 * R.x)\n    WR.set_ang_vel(Frame, u3 * Frame.y)\n    Frame.set_ang_vel(R, u4 * Frame.y)\n    Fork.set_ang_vel(Frame, u5 * Fork.x)\n    WF.set_ang_vel(Fork, u6 * Fork.y)\n    WR_cont.set_vel(N, 0)\n    WR_mc.v2pt_theory(WR_cont, N, WR)\n    Steer.v2pt_theory(WR_mc, N, Frame)\n    Frame_mc.v2pt_theory(WR_mc, N, Frame)\n    Fork_mc.v2pt_theory(Steer, N, Fork)\n    WF_mc.v2pt_theory(Steer, N, Fork)\n    WF_cont.v2pt_theory(WF_mc, N, WF)\n    Frame_I = (inertia(TempFrame, Iframe11, Iframe22, Iframe33, 0, 0, Iframe31), Frame_mc)\n    Fork_I = (inertia(TempFork, Ifork11, Ifork22, Ifork33, 0, 0, Ifork31), Fork_mc)\n    WR_I = (inertia(Frame, Iwr11, Iwr22, Iwr11), WR_mc)\n    WF_I = (inertia(Fork, Iwf11, Iwf22, Iwf11), WF_mc)\n    BodyFrame = RigidBody('BodyFrame', Frame_mc, Frame, mframe, Frame_I)\n    BodyFork = RigidBody('BodyFork', Fork_mc, Fork, mfork, Fork_I)\n    BodyWR = RigidBody('BodyWR', WR_mc, WR, mwr, WR_I)\n    BodyWF = RigidBody('BodyWF', WF_mc, WF, mwf, WF_I)\n    kd = [q1d - u1, q2d - u2, q4d - u4, q5d - u5]\n    conlist_speed = [WF_cont.vel(N) & Y.x, WF_cont.vel(N) & Y.y, WF_cont.vel(N) & Y.z]\n    conlist_coord = [WF_cont.pos_from(WR_cont) & Y.z]\n    FL = [(Frame_mc, -mframe * g * Y.z), (Fork_mc, -mfork * g * Y.z), (WF_mc, -mwf * g * Y.z), (WR_mc, -mwr * g * Y.z)]\n    BL = [BodyFrame, BodyFork, BodyWR, BodyWF]\n    KM = KanesMethod(N, q_ind=[q1, q2, q5], q_dependent=[q4], configuration_constraints=conlist_coord, u_ind=[u2, u3, u5], u_dependent=[u1, u4, u6], velocity_constraints=conlist_speed, kd_eqs=kd, constraint_solver='CRAMER')\n    (fr, frstar) = KM.kanes_equations(BL, FL)\n    PaperRadRear = 0.3\n    PaperRadFront = 0.35\n    HTA = (pi / 2 - pi / 10).evalf()\n    TrailPaper = 0.08\n    rake = (-(TrailPaper * sin(HTA) - PaperRadFront * cos(HTA))).evalf()\n    PaperWb = 1.02\n    PaperFrameCgX = 0.3\n    PaperFrameCgZ = 0.9\n    PaperForkCgX = 0.9\n    PaperForkCgZ = 0.7\n    FrameLength = (PaperWb * sin(HTA) - (rake - (PaperRadFront - PaperRadRear) * cos(HTA))).evalf()\n    FrameCGNorm = ((PaperFrameCgZ - PaperRadRear - PaperFrameCgX / sin(HTA) * cos(HTA)) * sin(HTA)).evalf()\n    FrameCGPar = (PaperFrameCgX / sin(HTA) + (PaperFrameCgZ - PaperRadRear - PaperFrameCgX / sin(HTA) * cos(HTA)) * cos(HTA)).evalf()\n    tempa = PaperForkCgZ - PaperRadFront\n    tempb = PaperWb - PaperForkCgX\n    tempc = sqrt(tempa ** 2 + tempb ** 2).evalf()\n    PaperForkL = (PaperWb * cos(HTA) - (PaperRadFront - PaperRadRear) * sin(HTA)).evalf()\n    ForkCGNorm = (rake + tempc * sin(pi / 2 - HTA - acos(tempa / tempc))).evalf()\n    ForkCGPar = (tempc * cos(pi / 2 - HTA - acos(tempa / tempc)) - PaperForkL).evalf()\n    v = symbols('v')\n    val_dict = {WFrad: PaperRadFront, WRrad: PaperRadRear, htangle: HTA, forkoffset: rake, forklength: PaperForkL, framelength: FrameLength, forkcg1: ForkCGPar, forkcg3: ForkCGNorm, framecg1: FrameCGNorm, framecg3: FrameCGPar, Iwr11: 0.0603, Iwr22: 0.12, Iwf11: 0.1405, Iwf22: 0.28, Ifork11: 0.05892, Ifork22: 0.06, Ifork33: 0.00708, Ifork31: 0.00756, Iframe11: 9.2, Iframe22: 11, Iframe33: 2.8, Iframe31: -2.4, mfork: 4, mframe: 85, mwf: 3, mwr: 2, g: 9.81, q1: 0, q2: 0, q4: 0, q5: 0, u1: 0, u2: 0, u3: v / PaperRadRear, u4: 0, u5: 0, u6: v / PaperRadFront}\n    (A, B, _) = KM.linearize(A_and_B=True, op_point={u1.diff(): 0, u2.diff(): 0, u3.diff(): 0, u4.diff(): 0, u5.diff(): 0, u6.diff(): 0, u1: 0, u2: 0, u3: v / PaperRadRear, u4: 0, u5: 0, u6: v / PaperRadFront, q1: 0, q2: 0, q4: 0, q5: 0}, linear_solver='CRAMER')\n    A_s = A.xreplace(val_dict)\n    B_s = B.xreplace(val_dict)\n    A_s = A_s.evalf()\n    B_s = B_s.evalf()\n    A = A_s.extract([1, 2, 3, 5], [1, 2, 3, 5])\n    Res = Matrix([[0, 0, 1.0, 0], [0, 0, 0, 1.0], [9.48977444677355, -0.891197738059089 * v ** 2 - 0.571523173729245, -0.105522449805691 * v, -0.330515398992311 * v], [11.7194768719633, -1.97171508499972 * v ** 2 + 30.9087533932407, 3.67680523332152 * v, -3.08486552743311 * v]])\n    eps = 1e-12\n    for i in range(6):\n        error = Res.subs(v, i) - A.subs(v, i)\n        assert all((abs(x) < eps for x in error))",
            "@slow\ndef test_bicycle():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (q1, q2, q4, q5) = dynamicsymbols('q1 q2 q4 q5')\n    (q1d, q2d, q4d, q5d) = dynamicsymbols('q1 q2 q4 q5', 1)\n    (u1, u2, u3, u4, u5, u6) = dynamicsymbols('u1 u2 u3 u4 u5 u6')\n    (u1d, u2d, u3d, u4d, u5d, u6d) = dynamicsymbols('u1 u2 u3 u4 u5 u6', 1)\n    (WFrad, WRrad, htangle, forkoffset) = symbols('WFrad WRrad htangle forkoffset')\n    (forklength, framelength, forkcg1) = symbols('forklength framelength forkcg1')\n    (forkcg3, framecg1, framecg3, Iwr11) = symbols('forkcg3 framecg1 framecg3 Iwr11')\n    (Iwr22, Iwf11, Iwf22, Iframe11) = symbols('Iwr22 Iwf11 Iwf22 Iframe11')\n    (Iframe22, Iframe33, Iframe31, Ifork11) = symbols('Iframe22 Iframe33 Iframe31 Ifork11')\n    (Ifork22, Ifork33, Ifork31, g) = symbols('Ifork22 Ifork33 Ifork31 g')\n    (mframe, mfork, mwf, mwr) = symbols('mframe mfork mwf mwr')\n    N = ReferenceFrame('N')\n    Y = N.orientnew('Y', 'Axis', [q1, N.z])\n    R = Y.orientnew('R', 'Axis', [q2, Y.x])\n    Frame = R.orientnew('Frame', 'Axis', [q4 + htangle, R.y])\n    WR = ReferenceFrame('WR')\n    TempFrame = Frame.orientnew('TempFrame', 'Axis', [-htangle, Frame.y])\n    Fork = Frame.orientnew('Fork', 'Axis', [q5, Frame.x])\n    TempFork = Fork.orientnew('TempFork', 'Axis', [-htangle, Fork.y])\n    WF = ReferenceFrame('WF')\n    WR_cont = Point('WR_cont')\n    WR_mc = WR_cont.locatenew('WR_mc', WRrad * R.z)\n    Steer = WR_mc.locatenew('Steer', framelength * Frame.z)\n    Frame_mc = WR_mc.locatenew('Frame_mc', -framecg1 * Frame.x + framecg3 * Frame.z)\n    Fork_mc = Steer.locatenew('Fork_mc', -forkcg1 * Fork.x + forkcg3 * Fork.z)\n    WF_mc = Steer.locatenew('WF_mc', forklength * Fork.x + forkoffset * Fork.z)\n    WF_cont = WF_mc.locatenew('WF_cont', WFrad * (dot(Fork.y, Y.z) * Fork.y - Y.z).normalize())\n    Y.set_ang_vel(N, u1 * Y.z)\n    R.set_ang_vel(Y, u2 * R.x)\n    WR.set_ang_vel(Frame, u3 * Frame.y)\n    Frame.set_ang_vel(R, u4 * Frame.y)\n    Fork.set_ang_vel(Frame, u5 * Fork.x)\n    WF.set_ang_vel(Fork, u6 * Fork.y)\n    WR_cont.set_vel(N, 0)\n    WR_mc.v2pt_theory(WR_cont, N, WR)\n    Steer.v2pt_theory(WR_mc, N, Frame)\n    Frame_mc.v2pt_theory(WR_mc, N, Frame)\n    Fork_mc.v2pt_theory(Steer, N, Fork)\n    WF_mc.v2pt_theory(Steer, N, Fork)\n    WF_cont.v2pt_theory(WF_mc, N, WF)\n    Frame_I = (inertia(TempFrame, Iframe11, Iframe22, Iframe33, 0, 0, Iframe31), Frame_mc)\n    Fork_I = (inertia(TempFork, Ifork11, Ifork22, Ifork33, 0, 0, Ifork31), Fork_mc)\n    WR_I = (inertia(Frame, Iwr11, Iwr22, Iwr11), WR_mc)\n    WF_I = (inertia(Fork, Iwf11, Iwf22, Iwf11), WF_mc)\n    BodyFrame = RigidBody('BodyFrame', Frame_mc, Frame, mframe, Frame_I)\n    BodyFork = RigidBody('BodyFork', Fork_mc, Fork, mfork, Fork_I)\n    BodyWR = RigidBody('BodyWR', WR_mc, WR, mwr, WR_I)\n    BodyWF = RigidBody('BodyWF', WF_mc, WF, mwf, WF_I)\n    kd = [q1d - u1, q2d - u2, q4d - u4, q5d - u5]\n    conlist_speed = [WF_cont.vel(N) & Y.x, WF_cont.vel(N) & Y.y, WF_cont.vel(N) & Y.z]\n    conlist_coord = [WF_cont.pos_from(WR_cont) & Y.z]\n    FL = [(Frame_mc, -mframe * g * Y.z), (Fork_mc, -mfork * g * Y.z), (WF_mc, -mwf * g * Y.z), (WR_mc, -mwr * g * Y.z)]\n    BL = [BodyFrame, BodyFork, BodyWR, BodyWF]\n    KM = KanesMethod(N, q_ind=[q1, q2, q5], q_dependent=[q4], configuration_constraints=conlist_coord, u_ind=[u2, u3, u5], u_dependent=[u1, u4, u6], velocity_constraints=conlist_speed, kd_eqs=kd, constraint_solver='CRAMER')\n    (fr, frstar) = KM.kanes_equations(BL, FL)\n    PaperRadRear = 0.3\n    PaperRadFront = 0.35\n    HTA = (pi / 2 - pi / 10).evalf()\n    TrailPaper = 0.08\n    rake = (-(TrailPaper * sin(HTA) - PaperRadFront * cos(HTA))).evalf()\n    PaperWb = 1.02\n    PaperFrameCgX = 0.3\n    PaperFrameCgZ = 0.9\n    PaperForkCgX = 0.9\n    PaperForkCgZ = 0.7\n    FrameLength = (PaperWb * sin(HTA) - (rake - (PaperRadFront - PaperRadRear) * cos(HTA))).evalf()\n    FrameCGNorm = ((PaperFrameCgZ - PaperRadRear - PaperFrameCgX / sin(HTA) * cos(HTA)) * sin(HTA)).evalf()\n    FrameCGPar = (PaperFrameCgX / sin(HTA) + (PaperFrameCgZ - PaperRadRear - PaperFrameCgX / sin(HTA) * cos(HTA)) * cos(HTA)).evalf()\n    tempa = PaperForkCgZ - PaperRadFront\n    tempb = PaperWb - PaperForkCgX\n    tempc = sqrt(tempa ** 2 + tempb ** 2).evalf()\n    PaperForkL = (PaperWb * cos(HTA) - (PaperRadFront - PaperRadRear) * sin(HTA)).evalf()\n    ForkCGNorm = (rake + tempc * sin(pi / 2 - HTA - acos(tempa / tempc))).evalf()\n    ForkCGPar = (tempc * cos(pi / 2 - HTA - acos(tempa / tempc)) - PaperForkL).evalf()\n    v = symbols('v')\n    val_dict = {WFrad: PaperRadFront, WRrad: PaperRadRear, htangle: HTA, forkoffset: rake, forklength: PaperForkL, framelength: FrameLength, forkcg1: ForkCGPar, forkcg3: ForkCGNorm, framecg1: FrameCGNorm, framecg3: FrameCGPar, Iwr11: 0.0603, Iwr22: 0.12, Iwf11: 0.1405, Iwf22: 0.28, Ifork11: 0.05892, Ifork22: 0.06, Ifork33: 0.00708, Ifork31: 0.00756, Iframe11: 9.2, Iframe22: 11, Iframe33: 2.8, Iframe31: -2.4, mfork: 4, mframe: 85, mwf: 3, mwr: 2, g: 9.81, q1: 0, q2: 0, q4: 0, q5: 0, u1: 0, u2: 0, u3: v / PaperRadRear, u4: 0, u5: 0, u6: v / PaperRadFront}\n    (A, B, _) = KM.linearize(A_and_B=True, op_point={u1.diff(): 0, u2.diff(): 0, u3.diff(): 0, u4.diff(): 0, u5.diff(): 0, u6.diff(): 0, u1: 0, u2: 0, u3: v / PaperRadRear, u4: 0, u5: 0, u6: v / PaperRadFront, q1: 0, q2: 0, q4: 0, q5: 0}, linear_solver='CRAMER')\n    A_s = A.xreplace(val_dict)\n    B_s = B.xreplace(val_dict)\n    A_s = A_s.evalf()\n    B_s = B_s.evalf()\n    A = A_s.extract([1, 2, 3, 5], [1, 2, 3, 5])\n    Res = Matrix([[0, 0, 1.0, 0], [0, 0, 0, 1.0], [9.48977444677355, -0.891197738059089 * v ** 2 - 0.571523173729245, -0.105522449805691 * v, -0.330515398992311 * v], [11.7194768719633, -1.97171508499972 * v ** 2 + 30.9087533932407, 3.67680523332152 * v, -3.08486552743311 * v]])\n    eps = 1e-12\n    for i in range(6):\n        error = Res.subs(v, i) - A.subs(v, i)\n        assert all((abs(x) < eps for x in error))",
            "@slow\ndef test_bicycle():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (q1, q2, q4, q5) = dynamicsymbols('q1 q2 q4 q5')\n    (q1d, q2d, q4d, q5d) = dynamicsymbols('q1 q2 q4 q5', 1)\n    (u1, u2, u3, u4, u5, u6) = dynamicsymbols('u1 u2 u3 u4 u5 u6')\n    (u1d, u2d, u3d, u4d, u5d, u6d) = dynamicsymbols('u1 u2 u3 u4 u5 u6', 1)\n    (WFrad, WRrad, htangle, forkoffset) = symbols('WFrad WRrad htangle forkoffset')\n    (forklength, framelength, forkcg1) = symbols('forklength framelength forkcg1')\n    (forkcg3, framecg1, framecg3, Iwr11) = symbols('forkcg3 framecg1 framecg3 Iwr11')\n    (Iwr22, Iwf11, Iwf22, Iframe11) = symbols('Iwr22 Iwf11 Iwf22 Iframe11')\n    (Iframe22, Iframe33, Iframe31, Ifork11) = symbols('Iframe22 Iframe33 Iframe31 Ifork11')\n    (Ifork22, Ifork33, Ifork31, g) = symbols('Ifork22 Ifork33 Ifork31 g')\n    (mframe, mfork, mwf, mwr) = symbols('mframe mfork mwf mwr')\n    N = ReferenceFrame('N')\n    Y = N.orientnew('Y', 'Axis', [q1, N.z])\n    R = Y.orientnew('R', 'Axis', [q2, Y.x])\n    Frame = R.orientnew('Frame', 'Axis', [q4 + htangle, R.y])\n    WR = ReferenceFrame('WR')\n    TempFrame = Frame.orientnew('TempFrame', 'Axis', [-htangle, Frame.y])\n    Fork = Frame.orientnew('Fork', 'Axis', [q5, Frame.x])\n    TempFork = Fork.orientnew('TempFork', 'Axis', [-htangle, Fork.y])\n    WF = ReferenceFrame('WF')\n    WR_cont = Point('WR_cont')\n    WR_mc = WR_cont.locatenew('WR_mc', WRrad * R.z)\n    Steer = WR_mc.locatenew('Steer', framelength * Frame.z)\n    Frame_mc = WR_mc.locatenew('Frame_mc', -framecg1 * Frame.x + framecg3 * Frame.z)\n    Fork_mc = Steer.locatenew('Fork_mc', -forkcg1 * Fork.x + forkcg3 * Fork.z)\n    WF_mc = Steer.locatenew('WF_mc', forklength * Fork.x + forkoffset * Fork.z)\n    WF_cont = WF_mc.locatenew('WF_cont', WFrad * (dot(Fork.y, Y.z) * Fork.y - Y.z).normalize())\n    Y.set_ang_vel(N, u1 * Y.z)\n    R.set_ang_vel(Y, u2 * R.x)\n    WR.set_ang_vel(Frame, u3 * Frame.y)\n    Frame.set_ang_vel(R, u4 * Frame.y)\n    Fork.set_ang_vel(Frame, u5 * Fork.x)\n    WF.set_ang_vel(Fork, u6 * Fork.y)\n    WR_cont.set_vel(N, 0)\n    WR_mc.v2pt_theory(WR_cont, N, WR)\n    Steer.v2pt_theory(WR_mc, N, Frame)\n    Frame_mc.v2pt_theory(WR_mc, N, Frame)\n    Fork_mc.v2pt_theory(Steer, N, Fork)\n    WF_mc.v2pt_theory(Steer, N, Fork)\n    WF_cont.v2pt_theory(WF_mc, N, WF)\n    Frame_I = (inertia(TempFrame, Iframe11, Iframe22, Iframe33, 0, 0, Iframe31), Frame_mc)\n    Fork_I = (inertia(TempFork, Ifork11, Ifork22, Ifork33, 0, 0, Ifork31), Fork_mc)\n    WR_I = (inertia(Frame, Iwr11, Iwr22, Iwr11), WR_mc)\n    WF_I = (inertia(Fork, Iwf11, Iwf22, Iwf11), WF_mc)\n    BodyFrame = RigidBody('BodyFrame', Frame_mc, Frame, mframe, Frame_I)\n    BodyFork = RigidBody('BodyFork', Fork_mc, Fork, mfork, Fork_I)\n    BodyWR = RigidBody('BodyWR', WR_mc, WR, mwr, WR_I)\n    BodyWF = RigidBody('BodyWF', WF_mc, WF, mwf, WF_I)\n    kd = [q1d - u1, q2d - u2, q4d - u4, q5d - u5]\n    conlist_speed = [WF_cont.vel(N) & Y.x, WF_cont.vel(N) & Y.y, WF_cont.vel(N) & Y.z]\n    conlist_coord = [WF_cont.pos_from(WR_cont) & Y.z]\n    FL = [(Frame_mc, -mframe * g * Y.z), (Fork_mc, -mfork * g * Y.z), (WF_mc, -mwf * g * Y.z), (WR_mc, -mwr * g * Y.z)]\n    BL = [BodyFrame, BodyFork, BodyWR, BodyWF]\n    KM = KanesMethod(N, q_ind=[q1, q2, q5], q_dependent=[q4], configuration_constraints=conlist_coord, u_ind=[u2, u3, u5], u_dependent=[u1, u4, u6], velocity_constraints=conlist_speed, kd_eqs=kd, constraint_solver='CRAMER')\n    (fr, frstar) = KM.kanes_equations(BL, FL)\n    PaperRadRear = 0.3\n    PaperRadFront = 0.35\n    HTA = (pi / 2 - pi / 10).evalf()\n    TrailPaper = 0.08\n    rake = (-(TrailPaper * sin(HTA) - PaperRadFront * cos(HTA))).evalf()\n    PaperWb = 1.02\n    PaperFrameCgX = 0.3\n    PaperFrameCgZ = 0.9\n    PaperForkCgX = 0.9\n    PaperForkCgZ = 0.7\n    FrameLength = (PaperWb * sin(HTA) - (rake - (PaperRadFront - PaperRadRear) * cos(HTA))).evalf()\n    FrameCGNorm = ((PaperFrameCgZ - PaperRadRear - PaperFrameCgX / sin(HTA) * cos(HTA)) * sin(HTA)).evalf()\n    FrameCGPar = (PaperFrameCgX / sin(HTA) + (PaperFrameCgZ - PaperRadRear - PaperFrameCgX / sin(HTA) * cos(HTA)) * cos(HTA)).evalf()\n    tempa = PaperForkCgZ - PaperRadFront\n    tempb = PaperWb - PaperForkCgX\n    tempc = sqrt(tempa ** 2 + tempb ** 2).evalf()\n    PaperForkL = (PaperWb * cos(HTA) - (PaperRadFront - PaperRadRear) * sin(HTA)).evalf()\n    ForkCGNorm = (rake + tempc * sin(pi / 2 - HTA - acos(tempa / tempc))).evalf()\n    ForkCGPar = (tempc * cos(pi / 2 - HTA - acos(tempa / tempc)) - PaperForkL).evalf()\n    v = symbols('v')\n    val_dict = {WFrad: PaperRadFront, WRrad: PaperRadRear, htangle: HTA, forkoffset: rake, forklength: PaperForkL, framelength: FrameLength, forkcg1: ForkCGPar, forkcg3: ForkCGNorm, framecg1: FrameCGNorm, framecg3: FrameCGPar, Iwr11: 0.0603, Iwr22: 0.12, Iwf11: 0.1405, Iwf22: 0.28, Ifork11: 0.05892, Ifork22: 0.06, Ifork33: 0.00708, Ifork31: 0.00756, Iframe11: 9.2, Iframe22: 11, Iframe33: 2.8, Iframe31: -2.4, mfork: 4, mframe: 85, mwf: 3, mwr: 2, g: 9.81, q1: 0, q2: 0, q4: 0, q5: 0, u1: 0, u2: 0, u3: v / PaperRadRear, u4: 0, u5: 0, u6: v / PaperRadFront}\n    (A, B, _) = KM.linearize(A_and_B=True, op_point={u1.diff(): 0, u2.diff(): 0, u3.diff(): 0, u4.diff(): 0, u5.diff(): 0, u6.diff(): 0, u1: 0, u2: 0, u3: v / PaperRadRear, u4: 0, u5: 0, u6: v / PaperRadFront, q1: 0, q2: 0, q4: 0, q5: 0}, linear_solver='CRAMER')\n    A_s = A.xreplace(val_dict)\n    B_s = B.xreplace(val_dict)\n    A_s = A_s.evalf()\n    B_s = B_s.evalf()\n    A = A_s.extract([1, 2, 3, 5], [1, 2, 3, 5])\n    Res = Matrix([[0, 0, 1.0, 0], [0, 0, 0, 1.0], [9.48977444677355, -0.891197738059089 * v ** 2 - 0.571523173729245, -0.105522449805691 * v, -0.330515398992311 * v], [11.7194768719633, -1.97171508499972 * v ** 2 + 30.9087533932407, 3.67680523332152 * v, -3.08486552743311 * v]])\n    eps = 1e-12\n    for i in range(6):\n        error = Res.subs(v, i) - A.subs(v, i)\n        assert all((abs(x) < eps for x in error))",
            "@slow\ndef test_bicycle():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (q1, q2, q4, q5) = dynamicsymbols('q1 q2 q4 q5')\n    (q1d, q2d, q4d, q5d) = dynamicsymbols('q1 q2 q4 q5', 1)\n    (u1, u2, u3, u4, u5, u6) = dynamicsymbols('u1 u2 u3 u4 u5 u6')\n    (u1d, u2d, u3d, u4d, u5d, u6d) = dynamicsymbols('u1 u2 u3 u4 u5 u6', 1)\n    (WFrad, WRrad, htangle, forkoffset) = symbols('WFrad WRrad htangle forkoffset')\n    (forklength, framelength, forkcg1) = symbols('forklength framelength forkcg1')\n    (forkcg3, framecg1, framecg3, Iwr11) = symbols('forkcg3 framecg1 framecg3 Iwr11')\n    (Iwr22, Iwf11, Iwf22, Iframe11) = symbols('Iwr22 Iwf11 Iwf22 Iframe11')\n    (Iframe22, Iframe33, Iframe31, Ifork11) = symbols('Iframe22 Iframe33 Iframe31 Ifork11')\n    (Ifork22, Ifork33, Ifork31, g) = symbols('Ifork22 Ifork33 Ifork31 g')\n    (mframe, mfork, mwf, mwr) = symbols('mframe mfork mwf mwr')\n    N = ReferenceFrame('N')\n    Y = N.orientnew('Y', 'Axis', [q1, N.z])\n    R = Y.orientnew('R', 'Axis', [q2, Y.x])\n    Frame = R.orientnew('Frame', 'Axis', [q4 + htangle, R.y])\n    WR = ReferenceFrame('WR')\n    TempFrame = Frame.orientnew('TempFrame', 'Axis', [-htangle, Frame.y])\n    Fork = Frame.orientnew('Fork', 'Axis', [q5, Frame.x])\n    TempFork = Fork.orientnew('TempFork', 'Axis', [-htangle, Fork.y])\n    WF = ReferenceFrame('WF')\n    WR_cont = Point('WR_cont')\n    WR_mc = WR_cont.locatenew('WR_mc', WRrad * R.z)\n    Steer = WR_mc.locatenew('Steer', framelength * Frame.z)\n    Frame_mc = WR_mc.locatenew('Frame_mc', -framecg1 * Frame.x + framecg3 * Frame.z)\n    Fork_mc = Steer.locatenew('Fork_mc', -forkcg1 * Fork.x + forkcg3 * Fork.z)\n    WF_mc = Steer.locatenew('WF_mc', forklength * Fork.x + forkoffset * Fork.z)\n    WF_cont = WF_mc.locatenew('WF_cont', WFrad * (dot(Fork.y, Y.z) * Fork.y - Y.z).normalize())\n    Y.set_ang_vel(N, u1 * Y.z)\n    R.set_ang_vel(Y, u2 * R.x)\n    WR.set_ang_vel(Frame, u3 * Frame.y)\n    Frame.set_ang_vel(R, u4 * Frame.y)\n    Fork.set_ang_vel(Frame, u5 * Fork.x)\n    WF.set_ang_vel(Fork, u6 * Fork.y)\n    WR_cont.set_vel(N, 0)\n    WR_mc.v2pt_theory(WR_cont, N, WR)\n    Steer.v2pt_theory(WR_mc, N, Frame)\n    Frame_mc.v2pt_theory(WR_mc, N, Frame)\n    Fork_mc.v2pt_theory(Steer, N, Fork)\n    WF_mc.v2pt_theory(Steer, N, Fork)\n    WF_cont.v2pt_theory(WF_mc, N, WF)\n    Frame_I = (inertia(TempFrame, Iframe11, Iframe22, Iframe33, 0, 0, Iframe31), Frame_mc)\n    Fork_I = (inertia(TempFork, Ifork11, Ifork22, Ifork33, 0, 0, Ifork31), Fork_mc)\n    WR_I = (inertia(Frame, Iwr11, Iwr22, Iwr11), WR_mc)\n    WF_I = (inertia(Fork, Iwf11, Iwf22, Iwf11), WF_mc)\n    BodyFrame = RigidBody('BodyFrame', Frame_mc, Frame, mframe, Frame_I)\n    BodyFork = RigidBody('BodyFork', Fork_mc, Fork, mfork, Fork_I)\n    BodyWR = RigidBody('BodyWR', WR_mc, WR, mwr, WR_I)\n    BodyWF = RigidBody('BodyWF', WF_mc, WF, mwf, WF_I)\n    kd = [q1d - u1, q2d - u2, q4d - u4, q5d - u5]\n    conlist_speed = [WF_cont.vel(N) & Y.x, WF_cont.vel(N) & Y.y, WF_cont.vel(N) & Y.z]\n    conlist_coord = [WF_cont.pos_from(WR_cont) & Y.z]\n    FL = [(Frame_mc, -mframe * g * Y.z), (Fork_mc, -mfork * g * Y.z), (WF_mc, -mwf * g * Y.z), (WR_mc, -mwr * g * Y.z)]\n    BL = [BodyFrame, BodyFork, BodyWR, BodyWF]\n    KM = KanesMethod(N, q_ind=[q1, q2, q5], q_dependent=[q4], configuration_constraints=conlist_coord, u_ind=[u2, u3, u5], u_dependent=[u1, u4, u6], velocity_constraints=conlist_speed, kd_eqs=kd, constraint_solver='CRAMER')\n    (fr, frstar) = KM.kanes_equations(BL, FL)\n    PaperRadRear = 0.3\n    PaperRadFront = 0.35\n    HTA = (pi / 2 - pi / 10).evalf()\n    TrailPaper = 0.08\n    rake = (-(TrailPaper * sin(HTA) - PaperRadFront * cos(HTA))).evalf()\n    PaperWb = 1.02\n    PaperFrameCgX = 0.3\n    PaperFrameCgZ = 0.9\n    PaperForkCgX = 0.9\n    PaperForkCgZ = 0.7\n    FrameLength = (PaperWb * sin(HTA) - (rake - (PaperRadFront - PaperRadRear) * cos(HTA))).evalf()\n    FrameCGNorm = ((PaperFrameCgZ - PaperRadRear - PaperFrameCgX / sin(HTA) * cos(HTA)) * sin(HTA)).evalf()\n    FrameCGPar = (PaperFrameCgX / sin(HTA) + (PaperFrameCgZ - PaperRadRear - PaperFrameCgX / sin(HTA) * cos(HTA)) * cos(HTA)).evalf()\n    tempa = PaperForkCgZ - PaperRadFront\n    tempb = PaperWb - PaperForkCgX\n    tempc = sqrt(tempa ** 2 + tempb ** 2).evalf()\n    PaperForkL = (PaperWb * cos(HTA) - (PaperRadFront - PaperRadRear) * sin(HTA)).evalf()\n    ForkCGNorm = (rake + tempc * sin(pi / 2 - HTA - acos(tempa / tempc))).evalf()\n    ForkCGPar = (tempc * cos(pi / 2 - HTA - acos(tempa / tempc)) - PaperForkL).evalf()\n    v = symbols('v')\n    val_dict = {WFrad: PaperRadFront, WRrad: PaperRadRear, htangle: HTA, forkoffset: rake, forklength: PaperForkL, framelength: FrameLength, forkcg1: ForkCGPar, forkcg3: ForkCGNorm, framecg1: FrameCGNorm, framecg3: FrameCGPar, Iwr11: 0.0603, Iwr22: 0.12, Iwf11: 0.1405, Iwf22: 0.28, Ifork11: 0.05892, Ifork22: 0.06, Ifork33: 0.00708, Ifork31: 0.00756, Iframe11: 9.2, Iframe22: 11, Iframe33: 2.8, Iframe31: -2.4, mfork: 4, mframe: 85, mwf: 3, mwr: 2, g: 9.81, q1: 0, q2: 0, q4: 0, q5: 0, u1: 0, u2: 0, u3: v / PaperRadRear, u4: 0, u5: 0, u6: v / PaperRadFront}\n    (A, B, _) = KM.linearize(A_and_B=True, op_point={u1.diff(): 0, u2.diff(): 0, u3.diff(): 0, u4.diff(): 0, u5.diff(): 0, u6.diff(): 0, u1: 0, u2: 0, u3: v / PaperRadRear, u4: 0, u5: 0, u6: v / PaperRadFront, q1: 0, q2: 0, q4: 0, q5: 0}, linear_solver='CRAMER')\n    A_s = A.xreplace(val_dict)\n    B_s = B.xreplace(val_dict)\n    A_s = A_s.evalf()\n    B_s = B_s.evalf()\n    A = A_s.extract([1, 2, 3, 5], [1, 2, 3, 5])\n    Res = Matrix([[0, 0, 1.0, 0], [0, 0, 0, 1.0], [9.48977444677355, -0.891197738059089 * v ** 2 - 0.571523173729245, -0.105522449805691 * v, -0.330515398992311 * v], [11.7194768719633, -1.97171508499972 * v ** 2 + 30.9087533932407, 3.67680523332152 * v, -3.08486552743311 * v]])\n    eps = 1e-12\n    for i in range(6):\n        error = Res.subs(v, i) - A.subs(v, i)\n        assert all((abs(x) < eps for x in error))",
            "@slow\ndef test_bicycle():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (q1, q2, q4, q5) = dynamicsymbols('q1 q2 q4 q5')\n    (q1d, q2d, q4d, q5d) = dynamicsymbols('q1 q2 q4 q5', 1)\n    (u1, u2, u3, u4, u5, u6) = dynamicsymbols('u1 u2 u3 u4 u5 u6')\n    (u1d, u2d, u3d, u4d, u5d, u6d) = dynamicsymbols('u1 u2 u3 u4 u5 u6', 1)\n    (WFrad, WRrad, htangle, forkoffset) = symbols('WFrad WRrad htangle forkoffset')\n    (forklength, framelength, forkcg1) = symbols('forklength framelength forkcg1')\n    (forkcg3, framecg1, framecg3, Iwr11) = symbols('forkcg3 framecg1 framecg3 Iwr11')\n    (Iwr22, Iwf11, Iwf22, Iframe11) = symbols('Iwr22 Iwf11 Iwf22 Iframe11')\n    (Iframe22, Iframe33, Iframe31, Ifork11) = symbols('Iframe22 Iframe33 Iframe31 Ifork11')\n    (Ifork22, Ifork33, Ifork31, g) = symbols('Ifork22 Ifork33 Ifork31 g')\n    (mframe, mfork, mwf, mwr) = symbols('mframe mfork mwf mwr')\n    N = ReferenceFrame('N')\n    Y = N.orientnew('Y', 'Axis', [q1, N.z])\n    R = Y.orientnew('R', 'Axis', [q2, Y.x])\n    Frame = R.orientnew('Frame', 'Axis', [q4 + htangle, R.y])\n    WR = ReferenceFrame('WR')\n    TempFrame = Frame.orientnew('TempFrame', 'Axis', [-htangle, Frame.y])\n    Fork = Frame.orientnew('Fork', 'Axis', [q5, Frame.x])\n    TempFork = Fork.orientnew('TempFork', 'Axis', [-htangle, Fork.y])\n    WF = ReferenceFrame('WF')\n    WR_cont = Point('WR_cont')\n    WR_mc = WR_cont.locatenew('WR_mc', WRrad * R.z)\n    Steer = WR_mc.locatenew('Steer', framelength * Frame.z)\n    Frame_mc = WR_mc.locatenew('Frame_mc', -framecg1 * Frame.x + framecg3 * Frame.z)\n    Fork_mc = Steer.locatenew('Fork_mc', -forkcg1 * Fork.x + forkcg3 * Fork.z)\n    WF_mc = Steer.locatenew('WF_mc', forklength * Fork.x + forkoffset * Fork.z)\n    WF_cont = WF_mc.locatenew('WF_cont', WFrad * (dot(Fork.y, Y.z) * Fork.y - Y.z).normalize())\n    Y.set_ang_vel(N, u1 * Y.z)\n    R.set_ang_vel(Y, u2 * R.x)\n    WR.set_ang_vel(Frame, u3 * Frame.y)\n    Frame.set_ang_vel(R, u4 * Frame.y)\n    Fork.set_ang_vel(Frame, u5 * Fork.x)\n    WF.set_ang_vel(Fork, u6 * Fork.y)\n    WR_cont.set_vel(N, 0)\n    WR_mc.v2pt_theory(WR_cont, N, WR)\n    Steer.v2pt_theory(WR_mc, N, Frame)\n    Frame_mc.v2pt_theory(WR_mc, N, Frame)\n    Fork_mc.v2pt_theory(Steer, N, Fork)\n    WF_mc.v2pt_theory(Steer, N, Fork)\n    WF_cont.v2pt_theory(WF_mc, N, WF)\n    Frame_I = (inertia(TempFrame, Iframe11, Iframe22, Iframe33, 0, 0, Iframe31), Frame_mc)\n    Fork_I = (inertia(TempFork, Ifork11, Ifork22, Ifork33, 0, 0, Ifork31), Fork_mc)\n    WR_I = (inertia(Frame, Iwr11, Iwr22, Iwr11), WR_mc)\n    WF_I = (inertia(Fork, Iwf11, Iwf22, Iwf11), WF_mc)\n    BodyFrame = RigidBody('BodyFrame', Frame_mc, Frame, mframe, Frame_I)\n    BodyFork = RigidBody('BodyFork', Fork_mc, Fork, mfork, Fork_I)\n    BodyWR = RigidBody('BodyWR', WR_mc, WR, mwr, WR_I)\n    BodyWF = RigidBody('BodyWF', WF_mc, WF, mwf, WF_I)\n    kd = [q1d - u1, q2d - u2, q4d - u4, q5d - u5]\n    conlist_speed = [WF_cont.vel(N) & Y.x, WF_cont.vel(N) & Y.y, WF_cont.vel(N) & Y.z]\n    conlist_coord = [WF_cont.pos_from(WR_cont) & Y.z]\n    FL = [(Frame_mc, -mframe * g * Y.z), (Fork_mc, -mfork * g * Y.z), (WF_mc, -mwf * g * Y.z), (WR_mc, -mwr * g * Y.z)]\n    BL = [BodyFrame, BodyFork, BodyWR, BodyWF]\n    KM = KanesMethod(N, q_ind=[q1, q2, q5], q_dependent=[q4], configuration_constraints=conlist_coord, u_ind=[u2, u3, u5], u_dependent=[u1, u4, u6], velocity_constraints=conlist_speed, kd_eqs=kd, constraint_solver='CRAMER')\n    (fr, frstar) = KM.kanes_equations(BL, FL)\n    PaperRadRear = 0.3\n    PaperRadFront = 0.35\n    HTA = (pi / 2 - pi / 10).evalf()\n    TrailPaper = 0.08\n    rake = (-(TrailPaper * sin(HTA) - PaperRadFront * cos(HTA))).evalf()\n    PaperWb = 1.02\n    PaperFrameCgX = 0.3\n    PaperFrameCgZ = 0.9\n    PaperForkCgX = 0.9\n    PaperForkCgZ = 0.7\n    FrameLength = (PaperWb * sin(HTA) - (rake - (PaperRadFront - PaperRadRear) * cos(HTA))).evalf()\n    FrameCGNorm = ((PaperFrameCgZ - PaperRadRear - PaperFrameCgX / sin(HTA) * cos(HTA)) * sin(HTA)).evalf()\n    FrameCGPar = (PaperFrameCgX / sin(HTA) + (PaperFrameCgZ - PaperRadRear - PaperFrameCgX / sin(HTA) * cos(HTA)) * cos(HTA)).evalf()\n    tempa = PaperForkCgZ - PaperRadFront\n    tempb = PaperWb - PaperForkCgX\n    tempc = sqrt(tempa ** 2 + tempb ** 2).evalf()\n    PaperForkL = (PaperWb * cos(HTA) - (PaperRadFront - PaperRadRear) * sin(HTA)).evalf()\n    ForkCGNorm = (rake + tempc * sin(pi / 2 - HTA - acos(tempa / tempc))).evalf()\n    ForkCGPar = (tempc * cos(pi / 2 - HTA - acos(tempa / tempc)) - PaperForkL).evalf()\n    v = symbols('v')\n    val_dict = {WFrad: PaperRadFront, WRrad: PaperRadRear, htangle: HTA, forkoffset: rake, forklength: PaperForkL, framelength: FrameLength, forkcg1: ForkCGPar, forkcg3: ForkCGNorm, framecg1: FrameCGNorm, framecg3: FrameCGPar, Iwr11: 0.0603, Iwr22: 0.12, Iwf11: 0.1405, Iwf22: 0.28, Ifork11: 0.05892, Ifork22: 0.06, Ifork33: 0.00708, Ifork31: 0.00756, Iframe11: 9.2, Iframe22: 11, Iframe33: 2.8, Iframe31: -2.4, mfork: 4, mframe: 85, mwf: 3, mwr: 2, g: 9.81, q1: 0, q2: 0, q4: 0, q5: 0, u1: 0, u2: 0, u3: v / PaperRadRear, u4: 0, u5: 0, u6: v / PaperRadFront}\n    (A, B, _) = KM.linearize(A_and_B=True, op_point={u1.diff(): 0, u2.diff(): 0, u3.diff(): 0, u4.diff(): 0, u5.diff(): 0, u6.diff(): 0, u1: 0, u2: 0, u3: v / PaperRadRear, u4: 0, u5: 0, u6: v / PaperRadFront, q1: 0, q2: 0, q4: 0, q5: 0}, linear_solver='CRAMER')\n    A_s = A.xreplace(val_dict)\n    B_s = B.xreplace(val_dict)\n    A_s = A_s.evalf()\n    B_s = B_s.evalf()\n    A = A_s.extract([1, 2, 3, 5], [1, 2, 3, 5])\n    Res = Matrix([[0, 0, 1.0, 0], [0, 0, 0, 1.0], [9.48977444677355, -0.891197738059089 * v ** 2 - 0.571523173729245, -0.105522449805691 * v, -0.330515398992311 * v], [11.7194768719633, -1.97171508499972 * v ** 2 + 30.9087533932407, 3.67680523332152 * v, -3.08486552743311 * v]])\n    eps = 1e-12\n    for i in range(6):\n        error = Res.subs(v, i) - A.subs(v, i)\n        assert all((abs(x) < eps for x in error))"
        ]
    }
]