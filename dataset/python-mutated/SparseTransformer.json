[
    {
        "func_name": "__init__",
        "original": "def __init__(self, name, optype, p=None, op=None):\n    self.name = name\n    self.optype = optype\n    self.ops = {}\n    self.prev = {}\n    self.insertInput(p)\n    self.visited = False\n    self.op = op",
        "mutated": [
            "def __init__(self, name, optype, p=None, op=None):\n    if False:\n        i = 10\n    self.name = name\n    self.optype = optype\n    self.ops = {}\n    self.prev = {}\n    self.insertInput(p)\n    self.visited = False\n    self.op = op",
            "def __init__(self, name, optype, p=None, op=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.name = name\n    self.optype = optype\n    self.ops = {}\n    self.prev = {}\n    self.insertInput(p)\n    self.visited = False\n    self.op = op",
            "def __init__(self, name, optype, p=None, op=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.name = name\n    self.optype = optype\n    self.ops = {}\n    self.prev = {}\n    self.insertInput(p)\n    self.visited = False\n    self.op = op",
            "def __init__(self, name, optype, p=None, op=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.name = name\n    self.optype = optype\n    self.ops = {}\n    self.prev = {}\n    self.insertInput(p)\n    self.visited = False\n    self.op = op",
            "def __init__(self, name, optype, p=None, op=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.name = name\n    self.optype = optype\n    self.ops = {}\n    self.prev = {}\n    self.insertInput(p)\n    self.visited = False\n    self.op = op"
        ]
    },
    {
        "func_name": "insertInput",
        "original": "def insertInput(self, p):\n    \"\"\"\n        Insert input of this op\n        also maintain the output of previous op\n        p: a node or a list of node\n        \"\"\"\n    if isinstance(p, list):\n        for i in p:\n            self.prev[i.name] = i\n            i.ops[self.name] = self\n    elif isinstance(p, NetDefNode):\n        self.prev[p.name] = p\n        p.ops[self.name] = self",
        "mutated": [
            "def insertInput(self, p):\n    if False:\n        i = 10\n    '\\n        Insert input of this op\\n        also maintain the output of previous op\\n        p: a node or a list of node\\n        '\n    if isinstance(p, list):\n        for i in p:\n            self.prev[i.name] = i\n            i.ops[self.name] = self\n    elif isinstance(p, NetDefNode):\n        self.prev[p.name] = p\n        p.ops[self.name] = self",
            "def insertInput(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Insert input of this op\\n        also maintain the output of previous op\\n        p: a node or a list of node\\n        '\n    if isinstance(p, list):\n        for i in p:\n            self.prev[i.name] = i\n            i.ops[self.name] = self\n    elif isinstance(p, NetDefNode):\n        self.prev[p.name] = p\n        p.ops[self.name] = self",
            "def insertInput(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Insert input of this op\\n        also maintain the output of previous op\\n        p: a node or a list of node\\n        '\n    if isinstance(p, list):\n        for i in p:\n            self.prev[i.name] = i\n            i.ops[self.name] = self\n    elif isinstance(p, NetDefNode):\n        self.prev[p.name] = p\n        p.ops[self.name] = self",
            "def insertInput(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Insert input of this op\\n        also maintain the output of previous op\\n        p: a node or a list of node\\n        '\n    if isinstance(p, list):\n        for i in p:\n            self.prev[i.name] = i\n            i.ops[self.name] = self\n    elif isinstance(p, NetDefNode):\n        self.prev[p.name] = p\n        p.ops[self.name] = self",
            "def insertInput(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Insert input of this op\\n        also maintain the output of previous op\\n        p: a node or a list of node\\n        '\n    if isinstance(p, list):\n        for i in p:\n            self.prev[i.name] = i\n            i.ops[self.name] = self\n    elif isinstance(p, NetDefNode):\n        self.prev[p.name] = p\n        p.ops[self.name] = self"
        ]
    },
    {
        "func_name": "deleteInput",
        "original": "def deleteInput(self, p):\n    if isinstance(p, NetDefNode):\n        del self.prev[p.name]\n        del p.ops[self.name]",
        "mutated": [
            "def deleteInput(self, p):\n    if False:\n        i = 10\n    if isinstance(p, NetDefNode):\n        del self.prev[p.name]\n        del p.ops[self.name]",
            "def deleteInput(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if isinstance(p, NetDefNode):\n        del self.prev[p.name]\n        del p.ops[self.name]",
            "def deleteInput(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if isinstance(p, NetDefNode):\n        del self.prev[p.name]\n        del p.ops[self.name]",
            "def deleteInput(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if isinstance(p, NetDefNode):\n        del self.prev[p.name]\n        del p.ops[self.name]",
            "def deleteInput(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if isinstance(p, NetDefNode):\n        del self.prev[p.name]\n        del p.ops[self.name]"
        ]
    },
    {
        "func_name": "maskNallocate",
        "original": "def maskNallocate(weight_name):\n    \"\"\"\n    Combine mask and weights\n    create wcsr, iw, jw, return their names\n    \"\"\"\n    w = workspace.FetchBlob(weight_name)\n    w_csr = scipy.sparse.csr_matrix(w)\n    wcsr = w_csr.data\n    iw = w_csr.indptr\n    jw = w_csr.indices\n    workspace.FeedBlob(weight_name + 'wcsr', wcsr)\n    workspace.FeedBlob(weight_name + 'iw', iw)\n    workspace.FeedBlob(weight_name + 'jw', jw)\n    return (weight_name + 'wcsr', weight_name + 'iw', weight_name + 'jw')",
        "mutated": [
            "def maskNallocate(weight_name):\n    if False:\n        i = 10\n    '\\n    Combine mask and weights\\n    create wcsr, iw, jw, return their names\\n    '\n    w = workspace.FetchBlob(weight_name)\n    w_csr = scipy.sparse.csr_matrix(w)\n    wcsr = w_csr.data\n    iw = w_csr.indptr\n    jw = w_csr.indices\n    workspace.FeedBlob(weight_name + 'wcsr', wcsr)\n    workspace.FeedBlob(weight_name + 'iw', iw)\n    workspace.FeedBlob(weight_name + 'jw', jw)\n    return (weight_name + 'wcsr', weight_name + 'iw', weight_name + 'jw')",
            "def maskNallocate(weight_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Combine mask and weights\\n    create wcsr, iw, jw, return their names\\n    '\n    w = workspace.FetchBlob(weight_name)\n    w_csr = scipy.sparse.csr_matrix(w)\n    wcsr = w_csr.data\n    iw = w_csr.indptr\n    jw = w_csr.indices\n    workspace.FeedBlob(weight_name + 'wcsr', wcsr)\n    workspace.FeedBlob(weight_name + 'iw', iw)\n    workspace.FeedBlob(weight_name + 'jw', jw)\n    return (weight_name + 'wcsr', weight_name + 'iw', weight_name + 'jw')",
            "def maskNallocate(weight_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Combine mask and weights\\n    create wcsr, iw, jw, return their names\\n    '\n    w = workspace.FetchBlob(weight_name)\n    w_csr = scipy.sparse.csr_matrix(w)\n    wcsr = w_csr.data\n    iw = w_csr.indptr\n    jw = w_csr.indices\n    workspace.FeedBlob(weight_name + 'wcsr', wcsr)\n    workspace.FeedBlob(weight_name + 'iw', iw)\n    workspace.FeedBlob(weight_name + 'jw', jw)\n    return (weight_name + 'wcsr', weight_name + 'iw', weight_name + 'jw')",
            "def maskNallocate(weight_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Combine mask and weights\\n    create wcsr, iw, jw, return their names\\n    '\n    w = workspace.FetchBlob(weight_name)\n    w_csr = scipy.sparse.csr_matrix(w)\n    wcsr = w_csr.data\n    iw = w_csr.indptr\n    jw = w_csr.indices\n    workspace.FeedBlob(weight_name + 'wcsr', wcsr)\n    workspace.FeedBlob(weight_name + 'iw', iw)\n    workspace.FeedBlob(weight_name + 'jw', jw)\n    return (weight_name + 'wcsr', weight_name + 'iw', weight_name + 'jw')",
            "def maskNallocate(weight_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Combine mask and weights\\n    create wcsr, iw, jw, return their names\\n    '\n    w = workspace.FetchBlob(weight_name)\n    w_csr = scipy.sparse.csr_matrix(w)\n    wcsr = w_csr.data\n    iw = w_csr.indptr\n    jw = w_csr.indices\n    workspace.FeedBlob(weight_name + 'wcsr', wcsr)\n    workspace.FeedBlob(weight_name + 'iw', iw)\n    workspace.FeedBlob(weight_name + 'jw', jw)\n    return (weight_name + 'wcsr', weight_name + 'iw', weight_name + 'jw')"
        ]
    },
    {
        "func_name": "transFCRelu",
        "original": "def transFCRelu(cur, id2node, name2id, ops, model):\n    \"\"\"\n    Add trans before and after this FC_Prune->(Relu)->FC_Prune chain.\n    \"\"\"\n    pre = cur.prev.itervalues().next()\n    current_blob = model.Transpose(cur.op.input[0], cur.op.input[0] + '_trans')\n    trans_op = model.net.Proto().op[-1]\n    trans_node = NetDefNode(trans_op.output[0], 'Transpose', pre, trans_op)\n    trans_node.visited = True\n    pre_new = trans_node\n    while True:\n        cur.deleteInput(pre)\n        if not (cur.optype == 'FC_Prune' or cur.optype == 'Relu'):\n            print('Reaching the end of the chain')\n            break\n        if len(cur.ops) > 1:\n            print('A FC/Relu giving more than 1 useful outputs')\n        if cur.optype == 'FC_Prune':\n            op = cur.op\n            (wcsr, iw, jw) = maskNallocate(op.input[1])\n            bias_name = op.input[3]\n            current_blob = model.FC_Sparse(current_blob, cur.op.output[0] + '_Sparse', wcsr, iw, jw, bias_name)\n            sps_op = model.net.Proto().op[-1]\n            sps_node = NetDefNode(cur.op.output[0] + '_Sparse', 'FC_Sparse', pre_new, sps_op)\n            sps_node.visited = True\n            pre_new = sps_node\n        if cur.optype == 'Relu':\n            op = cur.op\n            current_blob = model.Relu(current_blob, current_blob)\n            rel_op = model.net.Proto().op[-1]\n            rel_node = NetDefNode(str(current_blob), 'Relu', pre_new, rel_op)\n            rel_node.visited = True\n            pre_new = rel_node\n        cur.visited = True\n        pre = cur\n        flag = False\n        for (_, temp) in cur.ops.iteritems():\n            if temp.optype == 'Relu' or temp.optype == 'FC_Prune':\n                flag = True\n                cur = temp\n        if not flag:\n            cur = cur.ops.itervalues().next()\n            cur.deleteInput(pre)\n            print('No FC/RElu children')\n            print(cur.op.type)\n            break\n    current_blob = model.Transpose(current_blob, pre.op.output[0])\n    trans_op = model.net.Proto().op[-1]\n    trans_node = NetDefNode(str(current_blob), 'Transpose', pre_new, trans_op)\n    trans_node.visited = True\n    cur.insertInput(trans_node)\n    print(cur.prev)\n    print(trans_node.ops)",
        "mutated": [
            "def transFCRelu(cur, id2node, name2id, ops, model):\n    if False:\n        i = 10\n    '\\n    Add trans before and after this FC_Prune->(Relu)->FC_Prune chain.\\n    '\n    pre = cur.prev.itervalues().next()\n    current_blob = model.Transpose(cur.op.input[0], cur.op.input[0] + '_trans')\n    trans_op = model.net.Proto().op[-1]\n    trans_node = NetDefNode(trans_op.output[0], 'Transpose', pre, trans_op)\n    trans_node.visited = True\n    pre_new = trans_node\n    while True:\n        cur.deleteInput(pre)\n        if not (cur.optype == 'FC_Prune' or cur.optype == 'Relu'):\n            print('Reaching the end of the chain')\n            break\n        if len(cur.ops) > 1:\n            print('A FC/Relu giving more than 1 useful outputs')\n        if cur.optype == 'FC_Prune':\n            op = cur.op\n            (wcsr, iw, jw) = maskNallocate(op.input[1])\n            bias_name = op.input[3]\n            current_blob = model.FC_Sparse(current_blob, cur.op.output[0] + '_Sparse', wcsr, iw, jw, bias_name)\n            sps_op = model.net.Proto().op[-1]\n            sps_node = NetDefNode(cur.op.output[0] + '_Sparse', 'FC_Sparse', pre_new, sps_op)\n            sps_node.visited = True\n            pre_new = sps_node\n        if cur.optype == 'Relu':\n            op = cur.op\n            current_blob = model.Relu(current_blob, current_blob)\n            rel_op = model.net.Proto().op[-1]\n            rel_node = NetDefNode(str(current_blob), 'Relu', pre_new, rel_op)\n            rel_node.visited = True\n            pre_new = rel_node\n        cur.visited = True\n        pre = cur\n        flag = False\n        for (_, temp) in cur.ops.iteritems():\n            if temp.optype == 'Relu' or temp.optype == 'FC_Prune':\n                flag = True\n                cur = temp\n        if not flag:\n            cur = cur.ops.itervalues().next()\n            cur.deleteInput(pre)\n            print('No FC/RElu children')\n            print(cur.op.type)\n            break\n    current_blob = model.Transpose(current_blob, pre.op.output[0])\n    trans_op = model.net.Proto().op[-1]\n    trans_node = NetDefNode(str(current_blob), 'Transpose', pre_new, trans_op)\n    trans_node.visited = True\n    cur.insertInput(trans_node)\n    print(cur.prev)\n    print(trans_node.ops)",
            "def transFCRelu(cur, id2node, name2id, ops, model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Add trans before and after this FC_Prune->(Relu)->FC_Prune chain.\\n    '\n    pre = cur.prev.itervalues().next()\n    current_blob = model.Transpose(cur.op.input[0], cur.op.input[0] + '_trans')\n    trans_op = model.net.Proto().op[-1]\n    trans_node = NetDefNode(trans_op.output[0], 'Transpose', pre, trans_op)\n    trans_node.visited = True\n    pre_new = trans_node\n    while True:\n        cur.deleteInput(pre)\n        if not (cur.optype == 'FC_Prune' or cur.optype == 'Relu'):\n            print('Reaching the end of the chain')\n            break\n        if len(cur.ops) > 1:\n            print('A FC/Relu giving more than 1 useful outputs')\n        if cur.optype == 'FC_Prune':\n            op = cur.op\n            (wcsr, iw, jw) = maskNallocate(op.input[1])\n            bias_name = op.input[3]\n            current_blob = model.FC_Sparse(current_blob, cur.op.output[0] + '_Sparse', wcsr, iw, jw, bias_name)\n            sps_op = model.net.Proto().op[-1]\n            sps_node = NetDefNode(cur.op.output[0] + '_Sparse', 'FC_Sparse', pre_new, sps_op)\n            sps_node.visited = True\n            pre_new = sps_node\n        if cur.optype == 'Relu':\n            op = cur.op\n            current_blob = model.Relu(current_blob, current_blob)\n            rel_op = model.net.Proto().op[-1]\n            rel_node = NetDefNode(str(current_blob), 'Relu', pre_new, rel_op)\n            rel_node.visited = True\n            pre_new = rel_node\n        cur.visited = True\n        pre = cur\n        flag = False\n        for (_, temp) in cur.ops.iteritems():\n            if temp.optype == 'Relu' or temp.optype == 'FC_Prune':\n                flag = True\n                cur = temp\n        if not flag:\n            cur = cur.ops.itervalues().next()\n            cur.deleteInput(pre)\n            print('No FC/RElu children')\n            print(cur.op.type)\n            break\n    current_blob = model.Transpose(current_blob, pre.op.output[0])\n    trans_op = model.net.Proto().op[-1]\n    trans_node = NetDefNode(str(current_blob), 'Transpose', pre_new, trans_op)\n    trans_node.visited = True\n    cur.insertInput(trans_node)\n    print(cur.prev)\n    print(trans_node.ops)",
            "def transFCRelu(cur, id2node, name2id, ops, model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Add trans before and after this FC_Prune->(Relu)->FC_Prune chain.\\n    '\n    pre = cur.prev.itervalues().next()\n    current_blob = model.Transpose(cur.op.input[0], cur.op.input[0] + '_trans')\n    trans_op = model.net.Proto().op[-1]\n    trans_node = NetDefNode(trans_op.output[0], 'Transpose', pre, trans_op)\n    trans_node.visited = True\n    pre_new = trans_node\n    while True:\n        cur.deleteInput(pre)\n        if not (cur.optype == 'FC_Prune' or cur.optype == 'Relu'):\n            print('Reaching the end of the chain')\n            break\n        if len(cur.ops) > 1:\n            print('A FC/Relu giving more than 1 useful outputs')\n        if cur.optype == 'FC_Prune':\n            op = cur.op\n            (wcsr, iw, jw) = maskNallocate(op.input[1])\n            bias_name = op.input[3]\n            current_blob = model.FC_Sparse(current_blob, cur.op.output[0] + '_Sparse', wcsr, iw, jw, bias_name)\n            sps_op = model.net.Proto().op[-1]\n            sps_node = NetDefNode(cur.op.output[0] + '_Sparse', 'FC_Sparse', pre_new, sps_op)\n            sps_node.visited = True\n            pre_new = sps_node\n        if cur.optype == 'Relu':\n            op = cur.op\n            current_blob = model.Relu(current_blob, current_blob)\n            rel_op = model.net.Proto().op[-1]\n            rel_node = NetDefNode(str(current_blob), 'Relu', pre_new, rel_op)\n            rel_node.visited = True\n            pre_new = rel_node\n        cur.visited = True\n        pre = cur\n        flag = False\n        for (_, temp) in cur.ops.iteritems():\n            if temp.optype == 'Relu' or temp.optype == 'FC_Prune':\n                flag = True\n                cur = temp\n        if not flag:\n            cur = cur.ops.itervalues().next()\n            cur.deleteInput(pre)\n            print('No FC/RElu children')\n            print(cur.op.type)\n            break\n    current_blob = model.Transpose(current_blob, pre.op.output[0])\n    trans_op = model.net.Proto().op[-1]\n    trans_node = NetDefNode(str(current_blob), 'Transpose', pre_new, trans_op)\n    trans_node.visited = True\n    cur.insertInput(trans_node)\n    print(cur.prev)\n    print(trans_node.ops)",
            "def transFCRelu(cur, id2node, name2id, ops, model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Add trans before and after this FC_Prune->(Relu)->FC_Prune chain.\\n    '\n    pre = cur.prev.itervalues().next()\n    current_blob = model.Transpose(cur.op.input[0], cur.op.input[0] + '_trans')\n    trans_op = model.net.Proto().op[-1]\n    trans_node = NetDefNode(trans_op.output[0], 'Transpose', pre, trans_op)\n    trans_node.visited = True\n    pre_new = trans_node\n    while True:\n        cur.deleteInput(pre)\n        if not (cur.optype == 'FC_Prune' or cur.optype == 'Relu'):\n            print('Reaching the end of the chain')\n            break\n        if len(cur.ops) > 1:\n            print('A FC/Relu giving more than 1 useful outputs')\n        if cur.optype == 'FC_Prune':\n            op = cur.op\n            (wcsr, iw, jw) = maskNallocate(op.input[1])\n            bias_name = op.input[3]\n            current_blob = model.FC_Sparse(current_blob, cur.op.output[0] + '_Sparse', wcsr, iw, jw, bias_name)\n            sps_op = model.net.Proto().op[-1]\n            sps_node = NetDefNode(cur.op.output[0] + '_Sparse', 'FC_Sparse', pre_new, sps_op)\n            sps_node.visited = True\n            pre_new = sps_node\n        if cur.optype == 'Relu':\n            op = cur.op\n            current_blob = model.Relu(current_blob, current_blob)\n            rel_op = model.net.Proto().op[-1]\n            rel_node = NetDefNode(str(current_blob), 'Relu', pre_new, rel_op)\n            rel_node.visited = True\n            pre_new = rel_node\n        cur.visited = True\n        pre = cur\n        flag = False\n        for (_, temp) in cur.ops.iteritems():\n            if temp.optype == 'Relu' or temp.optype == 'FC_Prune':\n                flag = True\n                cur = temp\n        if not flag:\n            cur = cur.ops.itervalues().next()\n            cur.deleteInput(pre)\n            print('No FC/RElu children')\n            print(cur.op.type)\n            break\n    current_blob = model.Transpose(current_blob, pre.op.output[0])\n    trans_op = model.net.Proto().op[-1]\n    trans_node = NetDefNode(str(current_blob), 'Transpose', pre_new, trans_op)\n    trans_node.visited = True\n    cur.insertInput(trans_node)\n    print(cur.prev)\n    print(trans_node.ops)",
            "def transFCRelu(cur, id2node, name2id, ops, model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Add trans before and after this FC_Prune->(Relu)->FC_Prune chain.\\n    '\n    pre = cur.prev.itervalues().next()\n    current_blob = model.Transpose(cur.op.input[0], cur.op.input[0] + '_trans')\n    trans_op = model.net.Proto().op[-1]\n    trans_node = NetDefNode(trans_op.output[0], 'Transpose', pre, trans_op)\n    trans_node.visited = True\n    pre_new = trans_node\n    while True:\n        cur.deleteInput(pre)\n        if not (cur.optype == 'FC_Prune' or cur.optype == 'Relu'):\n            print('Reaching the end of the chain')\n            break\n        if len(cur.ops) > 1:\n            print('A FC/Relu giving more than 1 useful outputs')\n        if cur.optype == 'FC_Prune':\n            op = cur.op\n            (wcsr, iw, jw) = maskNallocate(op.input[1])\n            bias_name = op.input[3]\n            current_blob = model.FC_Sparse(current_blob, cur.op.output[0] + '_Sparse', wcsr, iw, jw, bias_name)\n            sps_op = model.net.Proto().op[-1]\n            sps_node = NetDefNode(cur.op.output[0] + '_Sparse', 'FC_Sparse', pre_new, sps_op)\n            sps_node.visited = True\n            pre_new = sps_node\n        if cur.optype == 'Relu':\n            op = cur.op\n            current_blob = model.Relu(current_blob, current_blob)\n            rel_op = model.net.Proto().op[-1]\n            rel_node = NetDefNode(str(current_blob), 'Relu', pre_new, rel_op)\n            rel_node.visited = True\n            pre_new = rel_node\n        cur.visited = True\n        pre = cur\n        flag = False\n        for (_, temp) in cur.ops.iteritems():\n            if temp.optype == 'Relu' or temp.optype == 'FC_Prune':\n                flag = True\n                cur = temp\n        if not flag:\n            cur = cur.ops.itervalues().next()\n            cur.deleteInput(pre)\n            print('No FC/RElu children')\n            print(cur.op.type)\n            break\n    current_blob = model.Transpose(current_blob, pre.op.output[0])\n    trans_op = model.net.Proto().op[-1]\n    trans_node = NetDefNode(str(current_blob), 'Transpose', pre_new, trans_op)\n    trans_node.visited = True\n    cur.insertInput(trans_node)\n    print(cur.prev)\n    print(trans_node.ops)"
        ]
    },
    {
        "func_name": "Prune2Sparse",
        "original": "def Prune2Sparse(cur, id2node, name2id, ops, model):\n    if not cur.visited and cur.optype == 'FC_Prune':\n        transFCRelu(cur, id2node, name2id, ops, model)\n    cur.visited = True\n    for (name, n) in cur.ops.iteritems():\n        Prune2Sparse(n, id2node, name2id, ops, model)",
        "mutated": [
            "def Prune2Sparse(cur, id2node, name2id, ops, model):\n    if False:\n        i = 10\n    if not cur.visited and cur.optype == 'FC_Prune':\n        transFCRelu(cur, id2node, name2id, ops, model)\n    cur.visited = True\n    for (name, n) in cur.ops.iteritems():\n        Prune2Sparse(n, id2node, name2id, ops, model)",
            "def Prune2Sparse(cur, id2node, name2id, ops, model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not cur.visited and cur.optype == 'FC_Prune':\n        transFCRelu(cur, id2node, name2id, ops, model)\n    cur.visited = True\n    for (name, n) in cur.ops.iteritems():\n        Prune2Sparse(n, id2node, name2id, ops, model)",
            "def Prune2Sparse(cur, id2node, name2id, ops, model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not cur.visited and cur.optype == 'FC_Prune':\n        transFCRelu(cur, id2node, name2id, ops, model)\n    cur.visited = True\n    for (name, n) in cur.ops.iteritems():\n        Prune2Sparse(n, id2node, name2id, ops, model)",
            "def Prune2Sparse(cur, id2node, name2id, ops, model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not cur.visited and cur.optype == 'FC_Prune':\n        transFCRelu(cur, id2node, name2id, ops, model)\n    cur.visited = True\n    for (name, n) in cur.ops.iteritems():\n        Prune2Sparse(n, id2node, name2id, ops, model)",
            "def Prune2Sparse(cur, id2node, name2id, ops, model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not cur.visited and cur.optype == 'FC_Prune':\n        transFCRelu(cur, id2node, name2id, ops, model)\n    cur.visited = True\n    for (name, n) in cur.ops.iteritems():\n        Prune2Sparse(n, id2node, name2id, ops, model)"
        ]
    },
    {
        "func_name": "net2list",
        "original": "def net2list(net_root):\n    \"\"\"\n    Use topological order(BFS) to print the op of a net in a list\n    \"\"\"\n    bfs_queue = []\n    op_list = []\n    cur = net_root\n    for (_, n) in cur.ops.iteritems():\n        bfs_queue.append(n)\n    while bfs_queue:\n        node = bfs_queue[0]\n        bfs_queue = bfs_queue[1:]\n        op_list.append(node.op)\n        for (_, n) in node.ops.iteritems():\n            bfs_queue.append(n)\n    return op_list",
        "mutated": [
            "def net2list(net_root):\n    if False:\n        i = 10\n    '\\n    Use topological order(BFS) to print the op of a net in a list\\n    '\n    bfs_queue = []\n    op_list = []\n    cur = net_root\n    for (_, n) in cur.ops.iteritems():\n        bfs_queue.append(n)\n    while bfs_queue:\n        node = bfs_queue[0]\n        bfs_queue = bfs_queue[1:]\n        op_list.append(node.op)\n        for (_, n) in node.ops.iteritems():\n            bfs_queue.append(n)\n    return op_list",
            "def net2list(net_root):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Use topological order(BFS) to print the op of a net in a list\\n    '\n    bfs_queue = []\n    op_list = []\n    cur = net_root\n    for (_, n) in cur.ops.iteritems():\n        bfs_queue.append(n)\n    while bfs_queue:\n        node = bfs_queue[0]\n        bfs_queue = bfs_queue[1:]\n        op_list.append(node.op)\n        for (_, n) in node.ops.iteritems():\n            bfs_queue.append(n)\n    return op_list",
            "def net2list(net_root):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Use topological order(BFS) to print the op of a net in a list\\n    '\n    bfs_queue = []\n    op_list = []\n    cur = net_root\n    for (_, n) in cur.ops.iteritems():\n        bfs_queue.append(n)\n    while bfs_queue:\n        node = bfs_queue[0]\n        bfs_queue = bfs_queue[1:]\n        op_list.append(node.op)\n        for (_, n) in node.ops.iteritems():\n            bfs_queue.append(n)\n    return op_list",
            "def net2list(net_root):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Use topological order(BFS) to print the op of a net in a list\\n    '\n    bfs_queue = []\n    op_list = []\n    cur = net_root\n    for (_, n) in cur.ops.iteritems():\n        bfs_queue.append(n)\n    while bfs_queue:\n        node = bfs_queue[0]\n        bfs_queue = bfs_queue[1:]\n        op_list.append(node.op)\n        for (_, n) in node.ops.iteritems():\n            bfs_queue.append(n)\n    return op_list",
            "def net2list(net_root):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Use topological order(BFS) to print the op of a net in a list\\n    '\n    bfs_queue = []\n    op_list = []\n    cur = net_root\n    for (_, n) in cur.ops.iteritems():\n        bfs_queue.append(n)\n    while bfs_queue:\n        node = bfs_queue[0]\n        bfs_queue = bfs_queue[1:]\n        op_list.append(node.op)\n        for (_, n) in node.ops.iteritems():\n            bfs_queue.append(n)\n    return op_list"
        ]
    },
    {
        "func_name": "netbuilder",
        "original": "def netbuilder(model):\n    print('Welcome to model checker')\n    proto = model.net.Proto()\n    net_name2id = {}\n    net_id2node = {}\n    net_root = NetDefNode('net_root', 'root', None)\n    for (op_id, op) in enumerate(proto.op):\n        if op.type == 'Print':\n            continue\n        op_name = '%s/%s (op#%d)' % (op.name, op.type, op_id) if op.name else '%s (op#%d)' % (op.type, op_id)\n        op_node = NetDefNode(op_name, op.type, op=op)\n        net_id2node[op_id] = op_node\n        if_has_layer_input = False\n        for input_name in op.input:\n            if input_name not in net_name2id:\n                continue\n            op_node.insertInput(net_id2node[net_name2id[input_name]])\n            if_has_layer_input = True\n        if not if_has_layer_input:\n            op_node.insertInput(net_root)\n        for output_name in op.output:\n            net_name2id[output_name] = op_id\n    return (net_root, net_name2id, net_id2node)",
        "mutated": [
            "def netbuilder(model):\n    if False:\n        i = 10\n    print('Welcome to model checker')\n    proto = model.net.Proto()\n    net_name2id = {}\n    net_id2node = {}\n    net_root = NetDefNode('net_root', 'root', None)\n    for (op_id, op) in enumerate(proto.op):\n        if op.type == 'Print':\n            continue\n        op_name = '%s/%s (op#%d)' % (op.name, op.type, op_id) if op.name else '%s (op#%d)' % (op.type, op_id)\n        op_node = NetDefNode(op_name, op.type, op=op)\n        net_id2node[op_id] = op_node\n        if_has_layer_input = False\n        for input_name in op.input:\n            if input_name not in net_name2id:\n                continue\n            op_node.insertInput(net_id2node[net_name2id[input_name]])\n            if_has_layer_input = True\n        if not if_has_layer_input:\n            op_node.insertInput(net_root)\n        for output_name in op.output:\n            net_name2id[output_name] = op_id\n    return (net_root, net_name2id, net_id2node)",
            "def netbuilder(model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    print('Welcome to model checker')\n    proto = model.net.Proto()\n    net_name2id = {}\n    net_id2node = {}\n    net_root = NetDefNode('net_root', 'root', None)\n    for (op_id, op) in enumerate(proto.op):\n        if op.type == 'Print':\n            continue\n        op_name = '%s/%s (op#%d)' % (op.name, op.type, op_id) if op.name else '%s (op#%d)' % (op.type, op_id)\n        op_node = NetDefNode(op_name, op.type, op=op)\n        net_id2node[op_id] = op_node\n        if_has_layer_input = False\n        for input_name in op.input:\n            if input_name not in net_name2id:\n                continue\n            op_node.insertInput(net_id2node[net_name2id[input_name]])\n            if_has_layer_input = True\n        if not if_has_layer_input:\n            op_node.insertInput(net_root)\n        for output_name in op.output:\n            net_name2id[output_name] = op_id\n    return (net_root, net_name2id, net_id2node)",
            "def netbuilder(model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    print('Welcome to model checker')\n    proto = model.net.Proto()\n    net_name2id = {}\n    net_id2node = {}\n    net_root = NetDefNode('net_root', 'root', None)\n    for (op_id, op) in enumerate(proto.op):\n        if op.type == 'Print':\n            continue\n        op_name = '%s/%s (op#%d)' % (op.name, op.type, op_id) if op.name else '%s (op#%d)' % (op.type, op_id)\n        op_node = NetDefNode(op_name, op.type, op=op)\n        net_id2node[op_id] = op_node\n        if_has_layer_input = False\n        for input_name in op.input:\n            if input_name not in net_name2id:\n                continue\n            op_node.insertInput(net_id2node[net_name2id[input_name]])\n            if_has_layer_input = True\n        if not if_has_layer_input:\n            op_node.insertInput(net_root)\n        for output_name in op.output:\n            net_name2id[output_name] = op_id\n    return (net_root, net_name2id, net_id2node)",
            "def netbuilder(model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    print('Welcome to model checker')\n    proto = model.net.Proto()\n    net_name2id = {}\n    net_id2node = {}\n    net_root = NetDefNode('net_root', 'root', None)\n    for (op_id, op) in enumerate(proto.op):\n        if op.type == 'Print':\n            continue\n        op_name = '%s/%s (op#%d)' % (op.name, op.type, op_id) if op.name else '%s (op#%d)' % (op.type, op_id)\n        op_node = NetDefNode(op_name, op.type, op=op)\n        net_id2node[op_id] = op_node\n        if_has_layer_input = False\n        for input_name in op.input:\n            if input_name not in net_name2id:\n                continue\n            op_node.insertInput(net_id2node[net_name2id[input_name]])\n            if_has_layer_input = True\n        if not if_has_layer_input:\n            op_node.insertInput(net_root)\n        for output_name in op.output:\n            net_name2id[output_name] = op_id\n    return (net_root, net_name2id, net_id2node)",
            "def netbuilder(model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    print('Welcome to model checker')\n    proto = model.net.Proto()\n    net_name2id = {}\n    net_id2node = {}\n    net_root = NetDefNode('net_root', 'root', None)\n    for (op_id, op) in enumerate(proto.op):\n        if op.type == 'Print':\n            continue\n        op_name = '%s/%s (op#%d)' % (op.name, op.type, op_id) if op.name else '%s (op#%d)' % (op.type, op_id)\n        op_node = NetDefNode(op_name, op.type, op=op)\n        net_id2node[op_id] = op_node\n        if_has_layer_input = False\n        for input_name in op.input:\n            if input_name not in net_name2id:\n                continue\n            op_node.insertInput(net_id2node[net_name2id[input_name]])\n            if_has_layer_input = True\n        if not if_has_layer_input:\n            op_node.insertInput(net_root)\n        for output_name in op.output:\n            net_name2id[output_name] = op_id\n    return (net_root, net_name2id, net_id2node)"
        ]
    }
]