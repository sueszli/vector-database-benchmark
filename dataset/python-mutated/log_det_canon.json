[
    {
        "func_name": "log_det_canon",
        "original": "def log_det_canon(expr, args):\n    \"\"\"Reduces the atom to an affine expression and list of constraints.\n\n    Creates the equivalent problem::\n\n       maximize    sum(log(D[i, i]))\n       subject to: D diagonal\n                   diag(D) = diag(Z)\n                   Z is upper triangular.\n                   [D Z; Z.T A] is positive semidefinite\n\n    The problem computes the LDL factorization:\n\n    .. math::\n\n       A = (Z^TD^{-1})D(D^{-1}Z)\n\n    This follows from the inequality:\n\n    .. math::\n\n       \\\\det(A) >= \\\\det(D) + \\\\det([D, Z; Z^T, A])/\\\\det(D)\n               >= \\\\det(D)\n\n    because (Z^TD^{-1})D(D^{-1}Z) is a feasible D, Z that achieves\n    det(A) = det(D) and the objective maximizes det(D).\n\n    Parameters\n    ----------\n    expr : log_det\n    args : list\n        The arguments for the expression\n\n    Returns\n    -------\n    tuple\n        (Variable for objective, list of constraints)\n    \"\"\"\n    A = args[0]\n    (n, _) = A.shape\n    z = Variable(shape=(n * (n + 1) // 2,))\n    Z = vec_to_upper_tri(z, strict=False)\n    d = diag_mat(Z)\n    D = diag_vec(d)\n    X = bmat([[D, Z], [Z.T, A]])\n    constraints = [PSD(X)]\n    log_expr = log(d)\n    (obj, constr) = log_canon(log_expr, log_expr.args)\n    constraints += constr\n    return (sum(obj), constraints)",
        "mutated": [
            "def log_det_canon(expr, args):\n    if False:\n        i = 10\n    'Reduces the atom to an affine expression and list of constraints.\\n\\n    Creates the equivalent problem::\\n\\n       maximize    sum(log(D[i, i]))\\n       subject to: D diagonal\\n                   diag(D) = diag(Z)\\n                   Z is upper triangular.\\n                   [D Z; Z.T A] is positive semidefinite\\n\\n    The problem computes the LDL factorization:\\n\\n    .. math::\\n\\n       A = (Z^TD^{-1})D(D^{-1}Z)\\n\\n    This follows from the inequality:\\n\\n    .. math::\\n\\n       \\\\det(A) >= \\\\det(D) + \\\\det([D, Z; Z^T, A])/\\\\det(D)\\n               >= \\\\det(D)\\n\\n    because (Z^TD^{-1})D(D^{-1}Z) is a feasible D, Z that achieves\\n    det(A) = det(D) and the objective maximizes det(D).\\n\\n    Parameters\\n    ----------\\n    expr : log_det\\n    args : list\\n        The arguments for the expression\\n\\n    Returns\\n    -------\\n    tuple\\n        (Variable for objective, list of constraints)\\n    '\n    A = args[0]\n    (n, _) = A.shape\n    z = Variable(shape=(n * (n + 1) // 2,))\n    Z = vec_to_upper_tri(z, strict=False)\n    d = diag_mat(Z)\n    D = diag_vec(d)\n    X = bmat([[D, Z], [Z.T, A]])\n    constraints = [PSD(X)]\n    log_expr = log(d)\n    (obj, constr) = log_canon(log_expr, log_expr.args)\n    constraints += constr\n    return (sum(obj), constraints)",
            "def log_det_canon(expr, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Reduces the atom to an affine expression and list of constraints.\\n\\n    Creates the equivalent problem::\\n\\n       maximize    sum(log(D[i, i]))\\n       subject to: D diagonal\\n                   diag(D) = diag(Z)\\n                   Z is upper triangular.\\n                   [D Z; Z.T A] is positive semidefinite\\n\\n    The problem computes the LDL factorization:\\n\\n    .. math::\\n\\n       A = (Z^TD^{-1})D(D^{-1}Z)\\n\\n    This follows from the inequality:\\n\\n    .. math::\\n\\n       \\\\det(A) >= \\\\det(D) + \\\\det([D, Z; Z^T, A])/\\\\det(D)\\n               >= \\\\det(D)\\n\\n    because (Z^TD^{-1})D(D^{-1}Z) is a feasible D, Z that achieves\\n    det(A) = det(D) and the objective maximizes det(D).\\n\\n    Parameters\\n    ----------\\n    expr : log_det\\n    args : list\\n        The arguments for the expression\\n\\n    Returns\\n    -------\\n    tuple\\n        (Variable for objective, list of constraints)\\n    '\n    A = args[0]\n    (n, _) = A.shape\n    z = Variable(shape=(n * (n + 1) // 2,))\n    Z = vec_to_upper_tri(z, strict=False)\n    d = diag_mat(Z)\n    D = diag_vec(d)\n    X = bmat([[D, Z], [Z.T, A]])\n    constraints = [PSD(X)]\n    log_expr = log(d)\n    (obj, constr) = log_canon(log_expr, log_expr.args)\n    constraints += constr\n    return (sum(obj), constraints)",
            "def log_det_canon(expr, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Reduces the atom to an affine expression and list of constraints.\\n\\n    Creates the equivalent problem::\\n\\n       maximize    sum(log(D[i, i]))\\n       subject to: D diagonal\\n                   diag(D) = diag(Z)\\n                   Z is upper triangular.\\n                   [D Z; Z.T A] is positive semidefinite\\n\\n    The problem computes the LDL factorization:\\n\\n    .. math::\\n\\n       A = (Z^TD^{-1})D(D^{-1}Z)\\n\\n    This follows from the inequality:\\n\\n    .. math::\\n\\n       \\\\det(A) >= \\\\det(D) + \\\\det([D, Z; Z^T, A])/\\\\det(D)\\n               >= \\\\det(D)\\n\\n    because (Z^TD^{-1})D(D^{-1}Z) is a feasible D, Z that achieves\\n    det(A) = det(D) and the objective maximizes det(D).\\n\\n    Parameters\\n    ----------\\n    expr : log_det\\n    args : list\\n        The arguments for the expression\\n\\n    Returns\\n    -------\\n    tuple\\n        (Variable for objective, list of constraints)\\n    '\n    A = args[0]\n    (n, _) = A.shape\n    z = Variable(shape=(n * (n + 1) // 2,))\n    Z = vec_to_upper_tri(z, strict=False)\n    d = diag_mat(Z)\n    D = diag_vec(d)\n    X = bmat([[D, Z], [Z.T, A]])\n    constraints = [PSD(X)]\n    log_expr = log(d)\n    (obj, constr) = log_canon(log_expr, log_expr.args)\n    constraints += constr\n    return (sum(obj), constraints)",
            "def log_det_canon(expr, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Reduces the atom to an affine expression and list of constraints.\\n\\n    Creates the equivalent problem::\\n\\n       maximize    sum(log(D[i, i]))\\n       subject to: D diagonal\\n                   diag(D) = diag(Z)\\n                   Z is upper triangular.\\n                   [D Z; Z.T A] is positive semidefinite\\n\\n    The problem computes the LDL factorization:\\n\\n    .. math::\\n\\n       A = (Z^TD^{-1})D(D^{-1}Z)\\n\\n    This follows from the inequality:\\n\\n    .. math::\\n\\n       \\\\det(A) >= \\\\det(D) + \\\\det([D, Z; Z^T, A])/\\\\det(D)\\n               >= \\\\det(D)\\n\\n    because (Z^TD^{-1})D(D^{-1}Z) is a feasible D, Z that achieves\\n    det(A) = det(D) and the objective maximizes det(D).\\n\\n    Parameters\\n    ----------\\n    expr : log_det\\n    args : list\\n        The arguments for the expression\\n\\n    Returns\\n    -------\\n    tuple\\n        (Variable for objective, list of constraints)\\n    '\n    A = args[0]\n    (n, _) = A.shape\n    z = Variable(shape=(n * (n + 1) // 2,))\n    Z = vec_to_upper_tri(z, strict=False)\n    d = diag_mat(Z)\n    D = diag_vec(d)\n    X = bmat([[D, Z], [Z.T, A]])\n    constraints = [PSD(X)]\n    log_expr = log(d)\n    (obj, constr) = log_canon(log_expr, log_expr.args)\n    constraints += constr\n    return (sum(obj), constraints)",
            "def log_det_canon(expr, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Reduces the atom to an affine expression and list of constraints.\\n\\n    Creates the equivalent problem::\\n\\n       maximize    sum(log(D[i, i]))\\n       subject to: D diagonal\\n                   diag(D) = diag(Z)\\n                   Z is upper triangular.\\n                   [D Z; Z.T A] is positive semidefinite\\n\\n    The problem computes the LDL factorization:\\n\\n    .. math::\\n\\n       A = (Z^TD^{-1})D(D^{-1}Z)\\n\\n    This follows from the inequality:\\n\\n    .. math::\\n\\n       \\\\det(A) >= \\\\det(D) + \\\\det([D, Z; Z^T, A])/\\\\det(D)\\n               >= \\\\det(D)\\n\\n    because (Z^TD^{-1})D(D^{-1}Z) is a feasible D, Z that achieves\\n    det(A) = det(D) and the objective maximizes det(D).\\n\\n    Parameters\\n    ----------\\n    expr : log_det\\n    args : list\\n        The arguments for the expression\\n\\n    Returns\\n    -------\\n    tuple\\n        (Variable for objective, list of constraints)\\n    '\n    A = args[0]\n    (n, _) = A.shape\n    z = Variable(shape=(n * (n + 1) // 2,))\n    Z = vec_to_upper_tri(z, strict=False)\n    d = diag_mat(Z)\n    D = diag_vec(d)\n    X = bmat([[D, Z], [Z.T, A]])\n    constraints = [PSD(X)]\n    log_expr = log(d)\n    (obj, constr) = log_canon(log_expr, log_expr.args)\n    constraints += constr\n    return (sum(obj), constraints)"
        ]
    }
]