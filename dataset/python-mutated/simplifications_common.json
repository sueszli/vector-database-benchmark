[
    {
        "func_name": "simp_cst_propagation",
        "original": "def simp_cst_propagation(e_s, expr):\n    \"\"\"This passe includes:\n     - Constant folding\n     - Common logical identities\n     - Common binary identities\n     \"\"\"\n    args = list(expr.args)\n    op_name = expr.op\n    if op_name in op_propag_cst:\n        while len(args) >= 2 and args[-1].is_int() and args[-2].is_int():\n            int2 = args.pop()\n            int1 = args.pop()\n            if op_name == '+':\n                out = mod_size2uint[int1.size](int(int1) + int(int2))\n            elif op_name == '*':\n                out = mod_size2uint[int1.size](int(int1) * int(int2))\n            elif op_name == '**':\n                out = mod_size2uint[int1.size](int(int1) ** int(int2))\n            elif op_name == '^':\n                out = mod_size2uint[int1.size](int(int1) ^ int(int2))\n            elif op_name == '&':\n                out = mod_size2uint[int1.size](int(int1) & int(int2))\n            elif op_name == '|':\n                out = mod_size2uint[int1.size](int(int1) | int(int2))\n            elif op_name == '>>':\n                if int(int2) > int1.size:\n                    out = 0\n                else:\n                    out = mod_size2uint[int1.size](int(int1) >> int(int2))\n            elif op_name == '<<':\n                if int(int2) > int1.size:\n                    out = 0\n                else:\n                    out = mod_size2uint[int1.size](int(int1) << int(int2))\n            elif op_name == 'a>>':\n                tmp1 = mod_size2int[int1.size](int(int1))\n                tmp2 = mod_size2uint[int2.size](int(int2))\n                if tmp2 > int1.size:\n                    is_signed = int(int1) & 1 << int1.size - 1\n                    if is_signed:\n                        out = -1\n                    else:\n                        out = 0\n                else:\n                    out = mod_size2uint[int1.size](tmp1 >> tmp2)\n            elif op_name == '>>>':\n                shifter = int(int2) % int2.size\n                out = int(int1) >> shifter | int(int1) << int2.size - shifter\n            elif op_name == '<<<':\n                shifter = int(int2) % int2.size\n                out = int(int1) << shifter | int(int1) >> int2.size - shifter\n            elif op_name == '/':\n                if int(int2) == 0:\n                    return expr\n                out = int(int1) // int(int2)\n            elif op_name == '%':\n                if int(int2) == 0:\n                    return expr\n                out = int(int1) % int(int2)\n            elif op_name == 'sdiv':\n                if int(int2) == 0:\n                    return expr\n                tmp1 = mod_size2int[int1.size](int(int1))\n                tmp2 = mod_size2int[int2.size](int(int2))\n                out = mod_size2uint[int1.size](tmp1 // tmp2)\n            elif op_name == 'smod':\n                if int(int2) == 0:\n                    return expr\n                tmp1 = mod_size2int[int1.size](int(int1))\n                tmp2 = mod_size2int[int2.size](int(int2))\n                out = mod_size2uint[int1.size](tmp1 % tmp2)\n            elif op_name == 'umod':\n                if int(int2) == 0:\n                    return expr\n                tmp1 = mod_size2uint[int1.size](int(int1))\n                tmp2 = mod_size2uint[int2.size](int(int2))\n                out = mod_size2uint[int1.size](tmp1 % tmp2)\n            elif op_name == 'udiv':\n                if int(int2) == 0:\n                    return expr\n                tmp1 = mod_size2uint[int1.size](int(int1))\n                tmp2 = mod_size2uint[int2.size](int(int2))\n                out = mod_size2uint[int1.size](tmp1 // tmp2)\n            args.append(ExprInt(int(out), int1.size))\n    if op_name == 'cnttrailzeros' and args[0].is_int():\n        i = 0\n        while int(args[0]) & 1 << i == 0 and i < args[0].size:\n            i += 1\n        return ExprInt(i, args[0].size)\n    if op_name == 'cntleadzeros' and args[0].is_int():\n        if int(args[0]) == 0:\n            return ExprInt(args[0].size, args[0].size)\n        i = args[0].size - 1\n        while int(args[0]) & 1 << i == 0:\n            i -= 1\n        return ExprInt(expr.size - (i + 1), args[0].size)\n    if op_name == '-' and len(args) == 1 and args[0].is_op('-') and (len(args[0].args) == 1):\n        return args[0].args[0]\n    if op_name == '-' and len(args) == 1 and args[0].is_int():\n        return ExprInt(-int(args[0]), expr.size)\n    if op_name in ['+', '|', '^', '<<', '>>', '<<<', '>>>'] and len(args) > 1:\n        if args[-1].is_int(0):\n            args.pop()\n    if op_name == '-' and len(args) > 1 and args[-1].is_int(0):\n        assert len(args) == 2\n        return args[0]\n    if op_name == '*' and len(args) > 1 and args[-1].is_int(1):\n        args.pop()\n    if op_name == '*' and len(args) > 1 and (args[-1] == args[-1].mask):\n        args.pop()\n        args[-1] = -args[-1]\n    if op_name in ['+', '*', '^', '&', '|', '>>', '<<', 'a>>', '<<<', '>>>', 'sdiv', 'smod', 'umod', 'udiv'] and len(args) == 1:\n        return args[0]\n    if op_name == '-' and len(args) > 1:\n        if len(args) > 2:\n            raise ValueError('sanity check fail on expr -: should have one or 2 args ' + '%r %s' % (expr, expr))\n        return ExprOp('+', args[0], -args[1])\n    if op_name in ['&', '*'] and args[-1].is_int(0):\n        return ExprInt(0, expr.size)\n    if op_name == '-' and len(args) == 1 and args[0].is_op('+'):\n        args = [-a for a in args[0].args]\n        return ExprOp('+', *args)\n    if op_name == '-' and len(args) == 1 and args[0].is_cond() and args[0].src1.is_int() and args[0].src2.is_int():\n        int1 = args[0].src1\n        int2 = args[0].src2\n        int1 = ExprInt(-int1.arg, int1.size)\n        int2 = ExprInt(-int2.arg, int2.size)\n        return ExprCond(args[0].cond, int1, int2)\n    i = 0\n    while i < len(args) - 1:\n        j = i + 1\n        while j < len(args):\n            if op_name == '^' and args[i] == args[j]:\n                args[i] = ExprInt(0, args[i].size)\n                del args[j]\n                continue\n            if op_name == '+' and args[j].is_op('-'):\n                if len(args[j].args) == 1 and args[i] == args[j].args[0]:\n                    args[i] = ExprInt(0, args[i].size)\n                    del args[j]\n                    continue\n            if op_name == '+' and args[i].is_op('-'):\n                if len(args[i].args) == 1 and args[j] == args[i].args[0]:\n                    args[i] = ExprInt(0, args[i].size)\n                    del args[j]\n                    continue\n            if op_name == '|' and args[i] == args[j]:\n                del args[j]\n                continue\n            if op_name == '&' and args[i] == args[j]:\n                del args[j]\n                continue\n            j += 1\n        i += 1\n    if op_name in ['+', '^', '|', '&', '%', '/', '**'] and len(args) == 1:\n        return args[0]\n    if op_name in ['<<<', '>>>'] and args[1].is_int() and (int(args[1]) == args[0].size):\n        return args[0]\n    if op_name in ['<<<', '>>>'] and args[0].is_op() and (args[0].op in ['<<<', '>>>']):\n        A = args[0].args[0]\n        X = args[0].args[1]\n        Y = args[1]\n        if op_name != args[0].op and e_s(X - Y) == ExprInt(0, X.size):\n            return args[0].args[0]\n        elif X.is_int() and Y.is_int():\n            new_X = int(X) % expr.size\n            new_Y = int(Y) % expr.size\n            if op_name == args[0].op:\n                rot = (new_X + new_Y) % expr.size\n                op = op_name\n            else:\n                rot = new_Y - new_X\n                op = op_name\n                if rot < 0:\n                    rot = -rot\n                    op = {'>>>': '<<<', '<<<': '>>>'}[op_name]\n            args = [A, ExprInt(rot, expr.size)]\n            op_name = op\n        else:\n            pass\n    if op_name in ['<<', '>>'] and args[0].is_op(op_name):\n        X = args[0].args[1]\n        Y = args[1]\n        if e_s(X.msb()) == ExprInt(0, 1) and e_s(Y.msb()) == ExprInt(0, 1):\n            args = [args[0].args[0], X + Y]\n    if op_name in ['<<', '>>'] and args[0].is_op() and (args[0].op in ['<<', '>>']) and (op_name != args[0]):\n        var = args[0].args[0]\n        int1 = args[0].args[1]\n        int2 = args[1]\n        if int1 == int2 and int1.is_int() and (int(int1) < expr.size):\n            if op_name == '>>':\n                mask = ExprInt((1 << expr.size - int(int1)) - 1, expr.size)\n            else:\n                mask = ExprInt((1 << int(int1)) - 1 ^ (1 << expr.size) - 1, expr.size)\n            ret = var & mask\n            return ret\n    if op_name == '&' and args[-1] == expr.mask:\n        args = args[:-1]\n        if len(args) == 1:\n            return args[0]\n        return ExprOp('&', *args)\n    if op_name == '|' and args[-1] == expr.mask:\n        return args[-1]\n    if op_name == '>>' and args[1].is_int() and args[0].is_op('&'):\n        if args[0].args[1].is_int() and 2 ** int(args[1]) > int(args[0].args[1]):\n            return ExprInt(0, args[0].size)\n    if op_name == 'parity' and args[0].is_int():\n        return ExprInt(parity(int(args[0])), 1)\n    if op_name == '*' and len(args) > 1:\n        new_args = []\n        counter = 0\n        for arg in args:\n            if arg.is_op('-') and len(arg.args) == 1:\n                new_args.append(arg.args[0])\n                counter += 1\n            else:\n                new_args.append(arg)\n        if counter % 2:\n            return -ExprOp(op_name, *new_args)\n        args = new_args\n    if op_name == '-' and args[0].is_op('*') and args[0].args[-1].is_int():\n        args = args[0].args\n        return ExprOp('*', *list(args[:-1]) + [ExprInt(-int(args[-1]), expr.size)])\n    if op_name == '<<' and args[0].is_compose() and args[1].is_int() and (int(args[1]) != 0):\n        final_size = args[0].size\n        shift = int(args[1])\n        new_args = []\n        for (index, arg) in args[0].iter_args():\n            new_args.append((arg, index + shift, index + shift + arg.size))\n        filter_args = []\n        min_index = final_size\n        for (tmp, start, stop) in new_args:\n            if start >= final_size:\n                continue\n            if stop > final_size:\n                tmp = tmp[:tmp.size - (stop - final_size)]\n            filter_args.append(tmp)\n            min_index = min(start, min_index)\n        assert min_index != 0\n        tmp = ExprInt(0, min_index)\n        args = [tmp] + filter_args\n        return ExprCompose(*args)\n    if op_name == '>>' and args[0].is_compose() and args[1].is_int():\n        final_size = args[0].size\n        shift = int(args[1])\n        new_args = []\n        for (index, arg) in args[0].iter_args():\n            new_args.append((arg, index - shift, index + arg.size - shift))\n        filter_args = []\n        max_index = 0\n        for (tmp, start, stop) in new_args:\n            if stop <= 0:\n                continue\n            if start < 0:\n                tmp = tmp[-start:]\n            filter_args.append(tmp)\n            max_index = max(stop, max_index)\n        tmp = ExprInt(0, final_size - max_index)\n        args = filter_args + [tmp]\n        return ExprCompose(*args)\n    if op_name in ['|', '&', '^'] and all([arg.is_compose() for arg in args]):\n        bounds = set()\n        for arg in args:\n            bound = tuple([tmp.size for tmp in arg.args])\n            bounds.add(bound)\n        if len(bounds) == 1:\n            new_args = [[tmp] for tmp in args[0].args]\n            for sub_arg in args[1:]:\n                for (i, tmp) in enumerate(sub_arg.args):\n                    new_args[i].append(tmp)\n            args = []\n            for (i, arg) in enumerate(new_args):\n                args.append(ExprOp(op_name, *arg))\n            return ExprCompose(*args)\n    return ExprOp(op_name, *args)",
        "mutated": [
            "def simp_cst_propagation(e_s, expr):\n    if False:\n        i = 10\n    'This passe includes:\\n     - Constant folding\\n     - Common logical identities\\n     - Common binary identities\\n     '\n    args = list(expr.args)\n    op_name = expr.op\n    if op_name in op_propag_cst:\n        while len(args) >= 2 and args[-1].is_int() and args[-2].is_int():\n            int2 = args.pop()\n            int1 = args.pop()\n            if op_name == '+':\n                out = mod_size2uint[int1.size](int(int1) + int(int2))\n            elif op_name == '*':\n                out = mod_size2uint[int1.size](int(int1) * int(int2))\n            elif op_name == '**':\n                out = mod_size2uint[int1.size](int(int1) ** int(int2))\n            elif op_name == '^':\n                out = mod_size2uint[int1.size](int(int1) ^ int(int2))\n            elif op_name == '&':\n                out = mod_size2uint[int1.size](int(int1) & int(int2))\n            elif op_name == '|':\n                out = mod_size2uint[int1.size](int(int1) | int(int2))\n            elif op_name == '>>':\n                if int(int2) > int1.size:\n                    out = 0\n                else:\n                    out = mod_size2uint[int1.size](int(int1) >> int(int2))\n            elif op_name == '<<':\n                if int(int2) > int1.size:\n                    out = 0\n                else:\n                    out = mod_size2uint[int1.size](int(int1) << int(int2))\n            elif op_name == 'a>>':\n                tmp1 = mod_size2int[int1.size](int(int1))\n                tmp2 = mod_size2uint[int2.size](int(int2))\n                if tmp2 > int1.size:\n                    is_signed = int(int1) & 1 << int1.size - 1\n                    if is_signed:\n                        out = -1\n                    else:\n                        out = 0\n                else:\n                    out = mod_size2uint[int1.size](tmp1 >> tmp2)\n            elif op_name == '>>>':\n                shifter = int(int2) % int2.size\n                out = int(int1) >> shifter | int(int1) << int2.size - shifter\n            elif op_name == '<<<':\n                shifter = int(int2) % int2.size\n                out = int(int1) << shifter | int(int1) >> int2.size - shifter\n            elif op_name == '/':\n                if int(int2) == 0:\n                    return expr\n                out = int(int1) // int(int2)\n            elif op_name == '%':\n                if int(int2) == 0:\n                    return expr\n                out = int(int1) % int(int2)\n            elif op_name == 'sdiv':\n                if int(int2) == 0:\n                    return expr\n                tmp1 = mod_size2int[int1.size](int(int1))\n                tmp2 = mod_size2int[int2.size](int(int2))\n                out = mod_size2uint[int1.size](tmp1 // tmp2)\n            elif op_name == 'smod':\n                if int(int2) == 0:\n                    return expr\n                tmp1 = mod_size2int[int1.size](int(int1))\n                tmp2 = mod_size2int[int2.size](int(int2))\n                out = mod_size2uint[int1.size](tmp1 % tmp2)\n            elif op_name == 'umod':\n                if int(int2) == 0:\n                    return expr\n                tmp1 = mod_size2uint[int1.size](int(int1))\n                tmp2 = mod_size2uint[int2.size](int(int2))\n                out = mod_size2uint[int1.size](tmp1 % tmp2)\n            elif op_name == 'udiv':\n                if int(int2) == 0:\n                    return expr\n                tmp1 = mod_size2uint[int1.size](int(int1))\n                tmp2 = mod_size2uint[int2.size](int(int2))\n                out = mod_size2uint[int1.size](tmp1 // tmp2)\n            args.append(ExprInt(int(out), int1.size))\n    if op_name == 'cnttrailzeros' and args[0].is_int():\n        i = 0\n        while int(args[0]) & 1 << i == 0 and i < args[0].size:\n            i += 1\n        return ExprInt(i, args[0].size)\n    if op_name == 'cntleadzeros' and args[0].is_int():\n        if int(args[0]) == 0:\n            return ExprInt(args[0].size, args[0].size)\n        i = args[0].size - 1\n        while int(args[0]) & 1 << i == 0:\n            i -= 1\n        return ExprInt(expr.size - (i + 1), args[0].size)\n    if op_name == '-' and len(args) == 1 and args[0].is_op('-') and (len(args[0].args) == 1):\n        return args[0].args[0]\n    if op_name == '-' and len(args) == 1 and args[0].is_int():\n        return ExprInt(-int(args[0]), expr.size)\n    if op_name in ['+', '|', '^', '<<', '>>', '<<<', '>>>'] and len(args) > 1:\n        if args[-1].is_int(0):\n            args.pop()\n    if op_name == '-' and len(args) > 1 and args[-1].is_int(0):\n        assert len(args) == 2\n        return args[0]\n    if op_name == '*' and len(args) > 1 and args[-1].is_int(1):\n        args.pop()\n    if op_name == '*' and len(args) > 1 and (args[-1] == args[-1].mask):\n        args.pop()\n        args[-1] = -args[-1]\n    if op_name in ['+', '*', '^', '&', '|', '>>', '<<', 'a>>', '<<<', '>>>', 'sdiv', 'smod', 'umod', 'udiv'] and len(args) == 1:\n        return args[0]\n    if op_name == '-' and len(args) > 1:\n        if len(args) > 2:\n            raise ValueError('sanity check fail on expr -: should have one or 2 args ' + '%r %s' % (expr, expr))\n        return ExprOp('+', args[0], -args[1])\n    if op_name in ['&', '*'] and args[-1].is_int(0):\n        return ExprInt(0, expr.size)\n    if op_name == '-' and len(args) == 1 and args[0].is_op('+'):\n        args = [-a for a in args[0].args]\n        return ExprOp('+', *args)\n    if op_name == '-' and len(args) == 1 and args[0].is_cond() and args[0].src1.is_int() and args[0].src2.is_int():\n        int1 = args[0].src1\n        int2 = args[0].src2\n        int1 = ExprInt(-int1.arg, int1.size)\n        int2 = ExprInt(-int2.arg, int2.size)\n        return ExprCond(args[0].cond, int1, int2)\n    i = 0\n    while i < len(args) - 1:\n        j = i + 1\n        while j < len(args):\n            if op_name == '^' and args[i] == args[j]:\n                args[i] = ExprInt(0, args[i].size)\n                del args[j]\n                continue\n            if op_name == '+' and args[j].is_op('-'):\n                if len(args[j].args) == 1 and args[i] == args[j].args[0]:\n                    args[i] = ExprInt(0, args[i].size)\n                    del args[j]\n                    continue\n            if op_name == '+' and args[i].is_op('-'):\n                if len(args[i].args) == 1 and args[j] == args[i].args[0]:\n                    args[i] = ExprInt(0, args[i].size)\n                    del args[j]\n                    continue\n            if op_name == '|' and args[i] == args[j]:\n                del args[j]\n                continue\n            if op_name == '&' and args[i] == args[j]:\n                del args[j]\n                continue\n            j += 1\n        i += 1\n    if op_name in ['+', '^', '|', '&', '%', '/', '**'] and len(args) == 1:\n        return args[0]\n    if op_name in ['<<<', '>>>'] and args[1].is_int() and (int(args[1]) == args[0].size):\n        return args[0]\n    if op_name in ['<<<', '>>>'] and args[0].is_op() and (args[0].op in ['<<<', '>>>']):\n        A = args[0].args[0]\n        X = args[0].args[1]\n        Y = args[1]\n        if op_name != args[0].op and e_s(X - Y) == ExprInt(0, X.size):\n            return args[0].args[0]\n        elif X.is_int() and Y.is_int():\n            new_X = int(X) % expr.size\n            new_Y = int(Y) % expr.size\n            if op_name == args[0].op:\n                rot = (new_X + new_Y) % expr.size\n                op = op_name\n            else:\n                rot = new_Y - new_X\n                op = op_name\n                if rot < 0:\n                    rot = -rot\n                    op = {'>>>': '<<<', '<<<': '>>>'}[op_name]\n            args = [A, ExprInt(rot, expr.size)]\n            op_name = op\n        else:\n            pass\n    if op_name in ['<<', '>>'] and args[0].is_op(op_name):\n        X = args[0].args[1]\n        Y = args[1]\n        if e_s(X.msb()) == ExprInt(0, 1) and e_s(Y.msb()) == ExprInt(0, 1):\n            args = [args[0].args[0], X + Y]\n    if op_name in ['<<', '>>'] and args[0].is_op() and (args[0].op in ['<<', '>>']) and (op_name != args[0]):\n        var = args[0].args[0]\n        int1 = args[0].args[1]\n        int2 = args[1]\n        if int1 == int2 and int1.is_int() and (int(int1) < expr.size):\n            if op_name == '>>':\n                mask = ExprInt((1 << expr.size - int(int1)) - 1, expr.size)\n            else:\n                mask = ExprInt((1 << int(int1)) - 1 ^ (1 << expr.size) - 1, expr.size)\n            ret = var & mask\n            return ret\n    if op_name == '&' and args[-1] == expr.mask:\n        args = args[:-1]\n        if len(args) == 1:\n            return args[0]\n        return ExprOp('&', *args)\n    if op_name == '|' and args[-1] == expr.mask:\n        return args[-1]\n    if op_name == '>>' and args[1].is_int() and args[0].is_op('&'):\n        if args[0].args[1].is_int() and 2 ** int(args[1]) > int(args[0].args[1]):\n            return ExprInt(0, args[0].size)\n    if op_name == 'parity' and args[0].is_int():\n        return ExprInt(parity(int(args[0])), 1)\n    if op_name == '*' and len(args) > 1:\n        new_args = []\n        counter = 0\n        for arg in args:\n            if arg.is_op('-') and len(arg.args) == 1:\n                new_args.append(arg.args[0])\n                counter += 1\n            else:\n                new_args.append(arg)\n        if counter % 2:\n            return -ExprOp(op_name, *new_args)\n        args = new_args\n    if op_name == '-' and args[0].is_op('*') and args[0].args[-1].is_int():\n        args = args[0].args\n        return ExprOp('*', *list(args[:-1]) + [ExprInt(-int(args[-1]), expr.size)])\n    if op_name == '<<' and args[0].is_compose() and args[1].is_int() and (int(args[1]) != 0):\n        final_size = args[0].size\n        shift = int(args[1])\n        new_args = []\n        for (index, arg) in args[0].iter_args():\n            new_args.append((arg, index + shift, index + shift + arg.size))\n        filter_args = []\n        min_index = final_size\n        for (tmp, start, stop) in new_args:\n            if start >= final_size:\n                continue\n            if stop > final_size:\n                tmp = tmp[:tmp.size - (stop - final_size)]\n            filter_args.append(tmp)\n            min_index = min(start, min_index)\n        assert min_index != 0\n        tmp = ExprInt(0, min_index)\n        args = [tmp] + filter_args\n        return ExprCompose(*args)\n    if op_name == '>>' and args[0].is_compose() and args[1].is_int():\n        final_size = args[0].size\n        shift = int(args[1])\n        new_args = []\n        for (index, arg) in args[0].iter_args():\n            new_args.append((arg, index - shift, index + arg.size - shift))\n        filter_args = []\n        max_index = 0\n        for (tmp, start, stop) in new_args:\n            if stop <= 0:\n                continue\n            if start < 0:\n                tmp = tmp[-start:]\n            filter_args.append(tmp)\n            max_index = max(stop, max_index)\n        tmp = ExprInt(0, final_size - max_index)\n        args = filter_args + [tmp]\n        return ExprCompose(*args)\n    if op_name in ['|', '&', '^'] and all([arg.is_compose() for arg in args]):\n        bounds = set()\n        for arg in args:\n            bound = tuple([tmp.size for tmp in arg.args])\n            bounds.add(bound)\n        if len(bounds) == 1:\n            new_args = [[tmp] for tmp in args[0].args]\n            for sub_arg in args[1:]:\n                for (i, tmp) in enumerate(sub_arg.args):\n                    new_args[i].append(tmp)\n            args = []\n            for (i, arg) in enumerate(new_args):\n                args.append(ExprOp(op_name, *arg))\n            return ExprCompose(*args)\n    return ExprOp(op_name, *args)",
            "def simp_cst_propagation(e_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'This passe includes:\\n     - Constant folding\\n     - Common logical identities\\n     - Common binary identities\\n     '\n    args = list(expr.args)\n    op_name = expr.op\n    if op_name in op_propag_cst:\n        while len(args) >= 2 and args[-1].is_int() and args[-2].is_int():\n            int2 = args.pop()\n            int1 = args.pop()\n            if op_name == '+':\n                out = mod_size2uint[int1.size](int(int1) + int(int2))\n            elif op_name == '*':\n                out = mod_size2uint[int1.size](int(int1) * int(int2))\n            elif op_name == '**':\n                out = mod_size2uint[int1.size](int(int1) ** int(int2))\n            elif op_name == '^':\n                out = mod_size2uint[int1.size](int(int1) ^ int(int2))\n            elif op_name == '&':\n                out = mod_size2uint[int1.size](int(int1) & int(int2))\n            elif op_name == '|':\n                out = mod_size2uint[int1.size](int(int1) | int(int2))\n            elif op_name == '>>':\n                if int(int2) > int1.size:\n                    out = 0\n                else:\n                    out = mod_size2uint[int1.size](int(int1) >> int(int2))\n            elif op_name == '<<':\n                if int(int2) > int1.size:\n                    out = 0\n                else:\n                    out = mod_size2uint[int1.size](int(int1) << int(int2))\n            elif op_name == 'a>>':\n                tmp1 = mod_size2int[int1.size](int(int1))\n                tmp2 = mod_size2uint[int2.size](int(int2))\n                if tmp2 > int1.size:\n                    is_signed = int(int1) & 1 << int1.size - 1\n                    if is_signed:\n                        out = -1\n                    else:\n                        out = 0\n                else:\n                    out = mod_size2uint[int1.size](tmp1 >> tmp2)\n            elif op_name == '>>>':\n                shifter = int(int2) % int2.size\n                out = int(int1) >> shifter | int(int1) << int2.size - shifter\n            elif op_name == '<<<':\n                shifter = int(int2) % int2.size\n                out = int(int1) << shifter | int(int1) >> int2.size - shifter\n            elif op_name == '/':\n                if int(int2) == 0:\n                    return expr\n                out = int(int1) // int(int2)\n            elif op_name == '%':\n                if int(int2) == 0:\n                    return expr\n                out = int(int1) % int(int2)\n            elif op_name == 'sdiv':\n                if int(int2) == 0:\n                    return expr\n                tmp1 = mod_size2int[int1.size](int(int1))\n                tmp2 = mod_size2int[int2.size](int(int2))\n                out = mod_size2uint[int1.size](tmp1 // tmp2)\n            elif op_name == 'smod':\n                if int(int2) == 0:\n                    return expr\n                tmp1 = mod_size2int[int1.size](int(int1))\n                tmp2 = mod_size2int[int2.size](int(int2))\n                out = mod_size2uint[int1.size](tmp1 % tmp2)\n            elif op_name == 'umod':\n                if int(int2) == 0:\n                    return expr\n                tmp1 = mod_size2uint[int1.size](int(int1))\n                tmp2 = mod_size2uint[int2.size](int(int2))\n                out = mod_size2uint[int1.size](tmp1 % tmp2)\n            elif op_name == 'udiv':\n                if int(int2) == 0:\n                    return expr\n                tmp1 = mod_size2uint[int1.size](int(int1))\n                tmp2 = mod_size2uint[int2.size](int(int2))\n                out = mod_size2uint[int1.size](tmp1 // tmp2)\n            args.append(ExprInt(int(out), int1.size))\n    if op_name == 'cnttrailzeros' and args[0].is_int():\n        i = 0\n        while int(args[0]) & 1 << i == 0 and i < args[0].size:\n            i += 1\n        return ExprInt(i, args[0].size)\n    if op_name == 'cntleadzeros' and args[0].is_int():\n        if int(args[0]) == 0:\n            return ExprInt(args[0].size, args[0].size)\n        i = args[0].size - 1\n        while int(args[0]) & 1 << i == 0:\n            i -= 1\n        return ExprInt(expr.size - (i + 1), args[0].size)\n    if op_name == '-' and len(args) == 1 and args[0].is_op('-') and (len(args[0].args) == 1):\n        return args[0].args[0]\n    if op_name == '-' and len(args) == 1 and args[0].is_int():\n        return ExprInt(-int(args[0]), expr.size)\n    if op_name in ['+', '|', '^', '<<', '>>', '<<<', '>>>'] and len(args) > 1:\n        if args[-1].is_int(0):\n            args.pop()\n    if op_name == '-' and len(args) > 1 and args[-1].is_int(0):\n        assert len(args) == 2\n        return args[0]\n    if op_name == '*' and len(args) > 1 and args[-1].is_int(1):\n        args.pop()\n    if op_name == '*' and len(args) > 1 and (args[-1] == args[-1].mask):\n        args.pop()\n        args[-1] = -args[-1]\n    if op_name in ['+', '*', '^', '&', '|', '>>', '<<', 'a>>', '<<<', '>>>', 'sdiv', 'smod', 'umod', 'udiv'] and len(args) == 1:\n        return args[0]\n    if op_name == '-' and len(args) > 1:\n        if len(args) > 2:\n            raise ValueError('sanity check fail on expr -: should have one or 2 args ' + '%r %s' % (expr, expr))\n        return ExprOp('+', args[0], -args[1])\n    if op_name in ['&', '*'] and args[-1].is_int(0):\n        return ExprInt(0, expr.size)\n    if op_name == '-' and len(args) == 1 and args[0].is_op('+'):\n        args = [-a for a in args[0].args]\n        return ExprOp('+', *args)\n    if op_name == '-' and len(args) == 1 and args[0].is_cond() and args[0].src1.is_int() and args[0].src2.is_int():\n        int1 = args[0].src1\n        int2 = args[0].src2\n        int1 = ExprInt(-int1.arg, int1.size)\n        int2 = ExprInt(-int2.arg, int2.size)\n        return ExprCond(args[0].cond, int1, int2)\n    i = 0\n    while i < len(args) - 1:\n        j = i + 1\n        while j < len(args):\n            if op_name == '^' and args[i] == args[j]:\n                args[i] = ExprInt(0, args[i].size)\n                del args[j]\n                continue\n            if op_name == '+' and args[j].is_op('-'):\n                if len(args[j].args) == 1 and args[i] == args[j].args[0]:\n                    args[i] = ExprInt(0, args[i].size)\n                    del args[j]\n                    continue\n            if op_name == '+' and args[i].is_op('-'):\n                if len(args[i].args) == 1 and args[j] == args[i].args[0]:\n                    args[i] = ExprInt(0, args[i].size)\n                    del args[j]\n                    continue\n            if op_name == '|' and args[i] == args[j]:\n                del args[j]\n                continue\n            if op_name == '&' and args[i] == args[j]:\n                del args[j]\n                continue\n            j += 1\n        i += 1\n    if op_name in ['+', '^', '|', '&', '%', '/', '**'] and len(args) == 1:\n        return args[0]\n    if op_name in ['<<<', '>>>'] and args[1].is_int() and (int(args[1]) == args[0].size):\n        return args[0]\n    if op_name in ['<<<', '>>>'] and args[0].is_op() and (args[0].op in ['<<<', '>>>']):\n        A = args[0].args[0]\n        X = args[0].args[1]\n        Y = args[1]\n        if op_name != args[0].op and e_s(X - Y) == ExprInt(0, X.size):\n            return args[0].args[0]\n        elif X.is_int() and Y.is_int():\n            new_X = int(X) % expr.size\n            new_Y = int(Y) % expr.size\n            if op_name == args[0].op:\n                rot = (new_X + new_Y) % expr.size\n                op = op_name\n            else:\n                rot = new_Y - new_X\n                op = op_name\n                if rot < 0:\n                    rot = -rot\n                    op = {'>>>': '<<<', '<<<': '>>>'}[op_name]\n            args = [A, ExprInt(rot, expr.size)]\n            op_name = op\n        else:\n            pass\n    if op_name in ['<<', '>>'] and args[0].is_op(op_name):\n        X = args[0].args[1]\n        Y = args[1]\n        if e_s(X.msb()) == ExprInt(0, 1) and e_s(Y.msb()) == ExprInt(0, 1):\n            args = [args[0].args[0], X + Y]\n    if op_name in ['<<', '>>'] and args[0].is_op() and (args[0].op in ['<<', '>>']) and (op_name != args[0]):\n        var = args[0].args[0]\n        int1 = args[0].args[1]\n        int2 = args[1]\n        if int1 == int2 and int1.is_int() and (int(int1) < expr.size):\n            if op_name == '>>':\n                mask = ExprInt((1 << expr.size - int(int1)) - 1, expr.size)\n            else:\n                mask = ExprInt((1 << int(int1)) - 1 ^ (1 << expr.size) - 1, expr.size)\n            ret = var & mask\n            return ret\n    if op_name == '&' and args[-1] == expr.mask:\n        args = args[:-1]\n        if len(args) == 1:\n            return args[0]\n        return ExprOp('&', *args)\n    if op_name == '|' and args[-1] == expr.mask:\n        return args[-1]\n    if op_name == '>>' and args[1].is_int() and args[0].is_op('&'):\n        if args[0].args[1].is_int() and 2 ** int(args[1]) > int(args[0].args[1]):\n            return ExprInt(0, args[0].size)\n    if op_name == 'parity' and args[0].is_int():\n        return ExprInt(parity(int(args[0])), 1)\n    if op_name == '*' and len(args) > 1:\n        new_args = []\n        counter = 0\n        for arg in args:\n            if arg.is_op('-') and len(arg.args) == 1:\n                new_args.append(arg.args[0])\n                counter += 1\n            else:\n                new_args.append(arg)\n        if counter % 2:\n            return -ExprOp(op_name, *new_args)\n        args = new_args\n    if op_name == '-' and args[0].is_op('*') and args[0].args[-1].is_int():\n        args = args[0].args\n        return ExprOp('*', *list(args[:-1]) + [ExprInt(-int(args[-1]), expr.size)])\n    if op_name == '<<' and args[0].is_compose() and args[1].is_int() and (int(args[1]) != 0):\n        final_size = args[0].size\n        shift = int(args[1])\n        new_args = []\n        for (index, arg) in args[0].iter_args():\n            new_args.append((arg, index + shift, index + shift + arg.size))\n        filter_args = []\n        min_index = final_size\n        for (tmp, start, stop) in new_args:\n            if start >= final_size:\n                continue\n            if stop > final_size:\n                tmp = tmp[:tmp.size - (stop - final_size)]\n            filter_args.append(tmp)\n            min_index = min(start, min_index)\n        assert min_index != 0\n        tmp = ExprInt(0, min_index)\n        args = [tmp] + filter_args\n        return ExprCompose(*args)\n    if op_name == '>>' and args[0].is_compose() and args[1].is_int():\n        final_size = args[0].size\n        shift = int(args[1])\n        new_args = []\n        for (index, arg) in args[0].iter_args():\n            new_args.append((arg, index - shift, index + arg.size - shift))\n        filter_args = []\n        max_index = 0\n        for (tmp, start, stop) in new_args:\n            if stop <= 0:\n                continue\n            if start < 0:\n                tmp = tmp[-start:]\n            filter_args.append(tmp)\n            max_index = max(stop, max_index)\n        tmp = ExprInt(0, final_size - max_index)\n        args = filter_args + [tmp]\n        return ExprCompose(*args)\n    if op_name in ['|', '&', '^'] and all([arg.is_compose() for arg in args]):\n        bounds = set()\n        for arg in args:\n            bound = tuple([tmp.size for tmp in arg.args])\n            bounds.add(bound)\n        if len(bounds) == 1:\n            new_args = [[tmp] for tmp in args[0].args]\n            for sub_arg in args[1:]:\n                for (i, tmp) in enumerate(sub_arg.args):\n                    new_args[i].append(tmp)\n            args = []\n            for (i, arg) in enumerate(new_args):\n                args.append(ExprOp(op_name, *arg))\n            return ExprCompose(*args)\n    return ExprOp(op_name, *args)",
            "def simp_cst_propagation(e_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'This passe includes:\\n     - Constant folding\\n     - Common logical identities\\n     - Common binary identities\\n     '\n    args = list(expr.args)\n    op_name = expr.op\n    if op_name in op_propag_cst:\n        while len(args) >= 2 and args[-1].is_int() and args[-2].is_int():\n            int2 = args.pop()\n            int1 = args.pop()\n            if op_name == '+':\n                out = mod_size2uint[int1.size](int(int1) + int(int2))\n            elif op_name == '*':\n                out = mod_size2uint[int1.size](int(int1) * int(int2))\n            elif op_name == '**':\n                out = mod_size2uint[int1.size](int(int1) ** int(int2))\n            elif op_name == '^':\n                out = mod_size2uint[int1.size](int(int1) ^ int(int2))\n            elif op_name == '&':\n                out = mod_size2uint[int1.size](int(int1) & int(int2))\n            elif op_name == '|':\n                out = mod_size2uint[int1.size](int(int1) | int(int2))\n            elif op_name == '>>':\n                if int(int2) > int1.size:\n                    out = 0\n                else:\n                    out = mod_size2uint[int1.size](int(int1) >> int(int2))\n            elif op_name == '<<':\n                if int(int2) > int1.size:\n                    out = 0\n                else:\n                    out = mod_size2uint[int1.size](int(int1) << int(int2))\n            elif op_name == 'a>>':\n                tmp1 = mod_size2int[int1.size](int(int1))\n                tmp2 = mod_size2uint[int2.size](int(int2))\n                if tmp2 > int1.size:\n                    is_signed = int(int1) & 1 << int1.size - 1\n                    if is_signed:\n                        out = -1\n                    else:\n                        out = 0\n                else:\n                    out = mod_size2uint[int1.size](tmp1 >> tmp2)\n            elif op_name == '>>>':\n                shifter = int(int2) % int2.size\n                out = int(int1) >> shifter | int(int1) << int2.size - shifter\n            elif op_name == '<<<':\n                shifter = int(int2) % int2.size\n                out = int(int1) << shifter | int(int1) >> int2.size - shifter\n            elif op_name == '/':\n                if int(int2) == 0:\n                    return expr\n                out = int(int1) // int(int2)\n            elif op_name == '%':\n                if int(int2) == 0:\n                    return expr\n                out = int(int1) % int(int2)\n            elif op_name == 'sdiv':\n                if int(int2) == 0:\n                    return expr\n                tmp1 = mod_size2int[int1.size](int(int1))\n                tmp2 = mod_size2int[int2.size](int(int2))\n                out = mod_size2uint[int1.size](tmp1 // tmp2)\n            elif op_name == 'smod':\n                if int(int2) == 0:\n                    return expr\n                tmp1 = mod_size2int[int1.size](int(int1))\n                tmp2 = mod_size2int[int2.size](int(int2))\n                out = mod_size2uint[int1.size](tmp1 % tmp2)\n            elif op_name == 'umod':\n                if int(int2) == 0:\n                    return expr\n                tmp1 = mod_size2uint[int1.size](int(int1))\n                tmp2 = mod_size2uint[int2.size](int(int2))\n                out = mod_size2uint[int1.size](tmp1 % tmp2)\n            elif op_name == 'udiv':\n                if int(int2) == 0:\n                    return expr\n                tmp1 = mod_size2uint[int1.size](int(int1))\n                tmp2 = mod_size2uint[int2.size](int(int2))\n                out = mod_size2uint[int1.size](tmp1 // tmp2)\n            args.append(ExprInt(int(out), int1.size))\n    if op_name == 'cnttrailzeros' and args[0].is_int():\n        i = 0\n        while int(args[0]) & 1 << i == 0 and i < args[0].size:\n            i += 1\n        return ExprInt(i, args[0].size)\n    if op_name == 'cntleadzeros' and args[0].is_int():\n        if int(args[0]) == 0:\n            return ExprInt(args[0].size, args[0].size)\n        i = args[0].size - 1\n        while int(args[0]) & 1 << i == 0:\n            i -= 1\n        return ExprInt(expr.size - (i + 1), args[0].size)\n    if op_name == '-' and len(args) == 1 and args[0].is_op('-') and (len(args[0].args) == 1):\n        return args[0].args[0]\n    if op_name == '-' and len(args) == 1 and args[0].is_int():\n        return ExprInt(-int(args[0]), expr.size)\n    if op_name in ['+', '|', '^', '<<', '>>', '<<<', '>>>'] and len(args) > 1:\n        if args[-1].is_int(0):\n            args.pop()\n    if op_name == '-' and len(args) > 1 and args[-1].is_int(0):\n        assert len(args) == 2\n        return args[0]\n    if op_name == '*' and len(args) > 1 and args[-1].is_int(1):\n        args.pop()\n    if op_name == '*' and len(args) > 1 and (args[-1] == args[-1].mask):\n        args.pop()\n        args[-1] = -args[-1]\n    if op_name in ['+', '*', '^', '&', '|', '>>', '<<', 'a>>', '<<<', '>>>', 'sdiv', 'smod', 'umod', 'udiv'] and len(args) == 1:\n        return args[0]\n    if op_name == '-' and len(args) > 1:\n        if len(args) > 2:\n            raise ValueError('sanity check fail on expr -: should have one or 2 args ' + '%r %s' % (expr, expr))\n        return ExprOp('+', args[0], -args[1])\n    if op_name in ['&', '*'] and args[-1].is_int(0):\n        return ExprInt(0, expr.size)\n    if op_name == '-' and len(args) == 1 and args[0].is_op('+'):\n        args = [-a for a in args[0].args]\n        return ExprOp('+', *args)\n    if op_name == '-' and len(args) == 1 and args[0].is_cond() and args[0].src1.is_int() and args[0].src2.is_int():\n        int1 = args[0].src1\n        int2 = args[0].src2\n        int1 = ExprInt(-int1.arg, int1.size)\n        int2 = ExprInt(-int2.arg, int2.size)\n        return ExprCond(args[0].cond, int1, int2)\n    i = 0\n    while i < len(args) - 1:\n        j = i + 1\n        while j < len(args):\n            if op_name == '^' and args[i] == args[j]:\n                args[i] = ExprInt(0, args[i].size)\n                del args[j]\n                continue\n            if op_name == '+' and args[j].is_op('-'):\n                if len(args[j].args) == 1 and args[i] == args[j].args[0]:\n                    args[i] = ExprInt(0, args[i].size)\n                    del args[j]\n                    continue\n            if op_name == '+' and args[i].is_op('-'):\n                if len(args[i].args) == 1 and args[j] == args[i].args[0]:\n                    args[i] = ExprInt(0, args[i].size)\n                    del args[j]\n                    continue\n            if op_name == '|' and args[i] == args[j]:\n                del args[j]\n                continue\n            if op_name == '&' and args[i] == args[j]:\n                del args[j]\n                continue\n            j += 1\n        i += 1\n    if op_name in ['+', '^', '|', '&', '%', '/', '**'] and len(args) == 1:\n        return args[0]\n    if op_name in ['<<<', '>>>'] and args[1].is_int() and (int(args[1]) == args[0].size):\n        return args[0]\n    if op_name in ['<<<', '>>>'] and args[0].is_op() and (args[0].op in ['<<<', '>>>']):\n        A = args[0].args[0]\n        X = args[0].args[1]\n        Y = args[1]\n        if op_name != args[0].op and e_s(X - Y) == ExprInt(0, X.size):\n            return args[0].args[0]\n        elif X.is_int() and Y.is_int():\n            new_X = int(X) % expr.size\n            new_Y = int(Y) % expr.size\n            if op_name == args[0].op:\n                rot = (new_X + new_Y) % expr.size\n                op = op_name\n            else:\n                rot = new_Y - new_X\n                op = op_name\n                if rot < 0:\n                    rot = -rot\n                    op = {'>>>': '<<<', '<<<': '>>>'}[op_name]\n            args = [A, ExprInt(rot, expr.size)]\n            op_name = op\n        else:\n            pass\n    if op_name in ['<<', '>>'] and args[0].is_op(op_name):\n        X = args[0].args[1]\n        Y = args[1]\n        if e_s(X.msb()) == ExprInt(0, 1) and e_s(Y.msb()) == ExprInt(0, 1):\n            args = [args[0].args[0], X + Y]\n    if op_name in ['<<', '>>'] and args[0].is_op() and (args[0].op in ['<<', '>>']) and (op_name != args[0]):\n        var = args[0].args[0]\n        int1 = args[0].args[1]\n        int2 = args[1]\n        if int1 == int2 and int1.is_int() and (int(int1) < expr.size):\n            if op_name == '>>':\n                mask = ExprInt((1 << expr.size - int(int1)) - 1, expr.size)\n            else:\n                mask = ExprInt((1 << int(int1)) - 1 ^ (1 << expr.size) - 1, expr.size)\n            ret = var & mask\n            return ret\n    if op_name == '&' and args[-1] == expr.mask:\n        args = args[:-1]\n        if len(args) == 1:\n            return args[0]\n        return ExprOp('&', *args)\n    if op_name == '|' and args[-1] == expr.mask:\n        return args[-1]\n    if op_name == '>>' and args[1].is_int() and args[0].is_op('&'):\n        if args[0].args[1].is_int() and 2 ** int(args[1]) > int(args[0].args[1]):\n            return ExprInt(0, args[0].size)\n    if op_name == 'parity' and args[0].is_int():\n        return ExprInt(parity(int(args[0])), 1)\n    if op_name == '*' and len(args) > 1:\n        new_args = []\n        counter = 0\n        for arg in args:\n            if arg.is_op('-') and len(arg.args) == 1:\n                new_args.append(arg.args[0])\n                counter += 1\n            else:\n                new_args.append(arg)\n        if counter % 2:\n            return -ExprOp(op_name, *new_args)\n        args = new_args\n    if op_name == '-' and args[0].is_op('*') and args[0].args[-1].is_int():\n        args = args[0].args\n        return ExprOp('*', *list(args[:-1]) + [ExprInt(-int(args[-1]), expr.size)])\n    if op_name == '<<' and args[0].is_compose() and args[1].is_int() and (int(args[1]) != 0):\n        final_size = args[0].size\n        shift = int(args[1])\n        new_args = []\n        for (index, arg) in args[0].iter_args():\n            new_args.append((arg, index + shift, index + shift + arg.size))\n        filter_args = []\n        min_index = final_size\n        for (tmp, start, stop) in new_args:\n            if start >= final_size:\n                continue\n            if stop > final_size:\n                tmp = tmp[:tmp.size - (stop - final_size)]\n            filter_args.append(tmp)\n            min_index = min(start, min_index)\n        assert min_index != 0\n        tmp = ExprInt(0, min_index)\n        args = [tmp] + filter_args\n        return ExprCompose(*args)\n    if op_name == '>>' and args[0].is_compose() and args[1].is_int():\n        final_size = args[0].size\n        shift = int(args[1])\n        new_args = []\n        for (index, arg) in args[0].iter_args():\n            new_args.append((arg, index - shift, index + arg.size - shift))\n        filter_args = []\n        max_index = 0\n        for (tmp, start, stop) in new_args:\n            if stop <= 0:\n                continue\n            if start < 0:\n                tmp = tmp[-start:]\n            filter_args.append(tmp)\n            max_index = max(stop, max_index)\n        tmp = ExprInt(0, final_size - max_index)\n        args = filter_args + [tmp]\n        return ExprCompose(*args)\n    if op_name in ['|', '&', '^'] and all([arg.is_compose() for arg in args]):\n        bounds = set()\n        for arg in args:\n            bound = tuple([tmp.size for tmp in arg.args])\n            bounds.add(bound)\n        if len(bounds) == 1:\n            new_args = [[tmp] for tmp in args[0].args]\n            for sub_arg in args[1:]:\n                for (i, tmp) in enumerate(sub_arg.args):\n                    new_args[i].append(tmp)\n            args = []\n            for (i, arg) in enumerate(new_args):\n                args.append(ExprOp(op_name, *arg))\n            return ExprCompose(*args)\n    return ExprOp(op_name, *args)",
            "def simp_cst_propagation(e_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'This passe includes:\\n     - Constant folding\\n     - Common logical identities\\n     - Common binary identities\\n     '\n    args = list(expr.args)\n    op_name = expr.op\n    if op_name in op_propag_cst:\n        while len(args) >= 2 and args[-1].is_int() and args[-2].is_int():\n            int2 = args.pop()\n            int1 = args.pop()\n            if op_name == '+':\n                out = mod_size2uint[int1.size](int(int1) + int(int2))\n            elif op_name == '*':\n                out = mod_size2uint[int1.size](int(int1) * int(int2))\n            elif op_name == '**':\n                out = mod_size2uint[int1.size](int(int1) ** int(int2))\n            elif op_name == '^':\n                out = mod_size2uint[int1.size](int(int1) ^ int(int2))\n            elif op_name == '&':\n                out = mod_size2uint[int1.size](int(int1) & int(int2))\n            elif op_name == '|':\n                out = mod_size2uint[int1.size](int(int1) | int(int2))\n            elif op_name == '>>':\n                if int(int2) > int1.size:\n                    out = 0\n                else:\n                    out = mod_size2uint[int1.size](int(int1) >> int(int2))\n            elif op_name == '<<':\n                if int(int2) > int1.size:\n                    out = 0\n                else:\n                    out = mod_size2uint[int1.size](int(int1) << int(int2))\n            elif op_name == 'a>>':\n                tmp1 = mod_size2int[int1.size](int(int1))\n                tmp2 = mod_size2uint[int2.size](int(int2))\n                if tmp2 > int1.size:\n                    is_signed = int(int1) & 1 << int1.size - 1\n                    if is_signed:\n                        out = -1\n                    else:\n                        out = 0\n                else:\n                    out = mod_size2uint[int1.size](tmp1 >> tmp2)\n            elif op_name == '>>>':\n                shifter = int(int2) % int2.size\n                out = int(int1) >> shifter | int(int1) << int2.size - shifter\n            elif op_name == '<<<':\n                shifter = int(int2) % int2.size\n                out = int(int1) << shifter | int(int1) >> int2.size - shifter\n            elif op_name == '/':\n                if int(int2) == 0:\n                    return expr\n                out = int(int1) // int(int2)\n            elif op_name == '%':\n                if int(int2) == 0:\n                    return expr\n                out = int(int1) % int(int2)\n            elif op_name == 'sdiv':\n                if int(int2) == 0:\n                    return expr\n                tmp1 = mod_size2int[int1.size](int(int1))\n                tmp2 = mod_size2int[int2.size](int(int2))\n                out = mod_size2uint[int1.size](tmp1 // tmp2)\n            elif op_name == 'smod':\n                if int(int2) == 0:\n                    return expr\n                tmp1 = mod_size2int[int1.size](int(int1))\n                tmp2 = mod_size2int[int2.size](int(int2))\n                out = mod_size2uint[int1.size](tmp1 % tmp2)\n            elif op_name == 'umod':\n                if int(int2) == 0:\n                    return expr\n                tmp1 = mod_size2uint[int1.size](int(int1))\n                tmp2 = mod_size2uint[int2.size](int(int2))\n                out = mod_size2uint[int1.size](tmp1 % tmp2)\n            elif op_name == 'udiv':\n                if int(int2) == 0:\n                    return expr\n                tmp1 = mod_size2uint[int1.size](int(int1))\n                tmp2 = mod_size2uint[int2.size](int(int2))\n                out = mod_size2uint[int1.size](tmp1 // tmp2)\n            args.append(ExprInt(int(out), int1.size))\n    if op_name == 'cnttrailzeros' and args[0].is_int():\n        i = 0\n        while int(args[0]) & 1 << i == 0 and i < args[0].size:\n            i += 1\n        return ExprInt(i, args[0].size)\n    if op_name == 'cntleadzeros' and args[0].is_int():\n        if int(args[0]) == 0:\n            return ExprInt(args[0].size, args[0].size)\n        i = args[0].size - 1\n        while int(args[0]) & 1 << i == 0:\n            i -= 1\n        return ExprInt(expr.size - (i + 1), args[0].size)\n    if op_name == '-' and len(args) == 1 and args[0].is_op('-') and (len(args[0].args) == 1):\n        return args[0].args[0]\n    if op_name == '-' and len(args) == 1 and args[0].is_int():\n        return ExprInt(-int(args[0]), expr.size)\n    if op_name in ['+', '|', '^', '<<', '>>', '<<<', '>>>'] and len(args) > 1:\n        if args[-1].is_int(0):\n            args.pop()\n    if op_name == '-' and len(args) > 1 and args[-1].is_int(0):\n        assert len(args) == 2\n        return args[0]\n    if op_name == '*' and len(args) > 1 and args[-1].is_int(1):\n        args.pop()\n    if op_name == '*' and len(args) > 1 and (args[-1] == args[-1].mask):\n        args.pop()\n        args[-1] = -args[-1]\n    if op_name in ['+', '*', '^', '&', '|', '>>', '<<', 'a>>', '<<<', '>>>', 'sdiv', 'smod', 'umod', 'udiv'] and len(args) == 1:\n        return args[0]\n    if op_name == '-' and len(args) > 1:\n        if len(args) > 2:\n            raise ValueError('sanity check fail on expr -: should have one or 2 args ' + '%r %s' % (expr, expr))\n        return ExprOp('+', args[0], -args[1])\n    if op_name in ['&', '*'] and args[-1].is_int(0):\n        return ExprInt(0, expr.size)\n    if op_name == '-' and len(args) == 1 and args[0].is_op('+'):\n        args = [-a for a in args[0].args]\n        return ExprOp('+', *args)\n    if op_name == '-' and len(args) == 1 and args[0].is_cond() and args[0].src1.is_int() and args[0].src2.is_int():\n        int1 = args[0].src1\n        int2 = args[0].src2\n        int1 = ExprInt(-int1.arg, int1.size)\n        int2 = ExprInt(-int2.arg, int2.size)\n        return ExprCond(args[0].cond, int1, int2)\n    i = 0\n    while i < len(args) - 1:\n        j = i + 1\n        while j < len(args):\n            if op_name == '^' and args[i] == args[j]:\n                args[i] = ExprInt(0, args[i].size)\n                del args[j]\n                continue\n            if op_name == '+' and args[j].is_op('-'):\n                if len(args[j].args) == 1 and args[i] == args[j].args[0]:\n                    args[i] = ExprInt(0, args[i].size)\n                    del args[j]\n                    continue\n            if op_name == '+' and args[i].is_op('-'):\n                if len(args[i].args) == 1 and args[j] == args[i].args[0]:\n                    args[i] = ExprInt(0, args[i].size)\n                    del args[j]\n                    continue\n            if op_name == '|' and args[i] == args[j]:\n                del args[j]\n                continue\n            if op_name == '&' and args[i] == args[j]:\n                del args[j]\n                continue\n            j += 1\n        i += 1\n    if op_name in ['+', '^', '|', '&', '%', '/', '**'] and len(args) == 1:\n        return args[0]\n    if op_name in ['<<<', '>>>'] and args[1].is_int() and (int(args[1]) == args[0].size):\n        return args[0]\n    if op_name in ['<<<', '>>>'] and args[0].is_op() and (args[0].op in ['<<<', '>>>']):\n        A = args[0].args[0]\n        X = args[0].args[1]\n        Y = args[1]\n        if op_name != args[0].op and e_s(X - Y) == ExprInt(0, X.size):\n            return args[0].args[0]\n        elif X.is_int() and Y.is_int():\n            new_X = int(X) % expr.size\n            new_Y = int(Y) % expr.size\n            if op_name == args[0].op:\n                rot = (new_X + new_Y) % expr.size\n                op = op_name\n            else:\n                rot = new_Y - new_X\n                op = op_name\n                if rot < 0:\n                    rot = -rot\n                    op = {'>>>': '<<<', '<<<': '>>>'}[op_name]\n            args = [A, ExprInt(rot, expr.size)]\n            op_name = op\n        else:\n            pass\n    if op_name in ['<<', '>>'] and args[0].is_op(op_name):\n        X = args[0].args[1]\n        Y = args[1]\n        if e_s(X.msb()) == ExprInt(0, 1) and e_s(Y.msb()) == ExprInt(0, 1):\n            args = [args[0].args[0], X + Y]\n    if op_name in ['<<', '>>'] and args[0].is_op() and (args[0].op in ['<<', '>>']) and (op_name != args[0]):\n        var = args[0].args[0]\n        int1 = args[0].args[1]\n        int2 = args[1]\n        if int1 == int2 and int1.is_int() and (int(int1) < expr.size):\n            if op_name == '>>':\n                mask = ExprInt((1 << expr.size - int(int1)) - 1, expr.size)\n            else:\n                mask = ExprInt((1 << int(int1)) - 1 ^ (1 << expr.size) - 1, expr.size)\n            ret = var & mask\n            return ret\n    if op_name == '&' and args[-1] == expr.mask:\n        args = args[:-1]\n        if len(args) == 1:\n            return args[0]\n        return ExprOp('&', *args)\n    if op_name == '|' and args[-1] == expr.mask:\n        return args[-1]\n    if op_name == '>>' and args[1].is_int() and args[0].is_op('&'):\n        if args[0].args[1].is_int() and 2 ** int(args[1]) > int(args[0].args[1]):\n            return ExprInt(0, args[0].size)\n    if op_name == 'parity' and args[0].is_int():\n        return ExprInt(parity(int(args[0])), 1)\n    if op_name == '*' and len(args) > 1:\n        new_args = []\n        counter = 0\n        for arg in args:\n            if arg.is_op('-') and len(arg.args) == 1:\n                new_args.append(arg.args[0])\n                counter += 1\n            else:\n                new_args.append(arg)\n        if counter % 2:\n            return -ExprOp(op_name, *new_args)\n        args = new_args\n    if op_name == '-' and args[0].is_op('*') and args[0].args[-1].is_int():\n        args = args[0].args\n        return ExprOp('*', *list(args[:-1]) + [ExprInt(-int(args[-1]), expr.size)])\n    if op_name == '<<' and args[0].is_compose() and args[1].is_int() and (int(args[1]) != 0):\n        final_size = args[0].size\n        shift = int(args[1])\n        new_args = []\n        for (index, arg) in args[0].iter_args():\n            new_args.append((arg, index + shift, index + shift + arg.size))\n        filter_args = []\n        min_index = final_size\n        for (tmp, start, stop) in new_args:\n            if start >= final_size:\n                continue\n            if stop > final_size:\n                tmp = tmp[:tmp.size - (stop - final_size)]\n            filter_args.append(tmp)\n            min_index = min(start, min_index)\n        assert min_index != 0\n        tmp = ExprInt(0, min_index)\n        args = [tmp] + filter_args\n        return ExprCompose(*args)\n    if op_name == '>>' and args[0].is_compose() and args[1].is_int():\n        final_size = args[0].size\n        shift = int(args[1])\n        new_args = []\n        for (index, arg) in args[0].iter_args():\n            new_args.append((arg, index - shift, index + arg.size - shift))\n        filter_args = []\n        max_index = 0\n        for (tmp, start, stop) in new_args:\n            if stop <= 0:\n                continue\n            if start < 0:\n                tmp = tmp[-start:]\n            filter_args.append(tmp)\n            max_index = max(stop, max_index)\n        tmp = ExprInt(0, final_size - max_index)\n        args = filter_args + [tmp]\n        return ExprCompose(*args)\n    if op_name in ['|', '&', '^'] and all([arg.is_compose() for arg in args]):\n        bounds = set()\n        for arg in args:\n            bound = tuple([tmp.size for tmp in arg.args])\n            bounds.add(bound)\n        if len(bounds) == 1:\n            new_args = [[tmp] for tmp in args[0].args]\n            for sub_arg in args[1:]:\n                for (i, tmp) in enumerate(sub_arg.args):\n                    new_args[i].append(tmp)\n            args = []\n            for (i, arg) in enumerate(new_args):\n                args.append(ExprOp(op_name, *arg))\n            return ExprCompose(*args)\n    return ExprOp(op_name, *args)",
            "def simp_cst_propagation(e_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'This passe includes:\\n     - Constant folding\\n     - Common logical identities\\n     - Common binary identities\\n     '\n    args = list(expr.args)\n    op_name = expr.op\n    if op_name in op_propag_cst:\n        while len(args) >= 2 and args[-1].is_int() and args[-2].is_int():\n            int2 = args.pop()\n            int1 = args.pop()\n            if op_name == '+':\n                out = mod_size2uint[int1.size](int(int1) + int(int2))\n            elif op_name == '*':\n                out = mod_size2uint[int1.size](int(int1) * int(int2))\n            elif op_name == '**':\n                out = mod_size2uint[int1.size](int(int1) ** int(int2))\n            elif op_name == '^':\n                out = mod_size2uint[int1.size](int(int1) ^ int(int2))\n            elif op_name == '&':\n                out = mod_size2uint[int1.size](int(int1) & int(int2))\n            elif op_name == '|':\n                out = mod_size2uint[int1.size](int(int1) | int(int2))\n            elif op_name == '>>':\n                if int(int2) > int1.size:\n                    out = 0\n                else:\n                    out = mod_size2uint[int1.size](int(int1) >> int(int2))\n            elif op_name == '<<':\n                if int(int2) > int1.size:\n                    out = 0\n                else:\n                    out = mod_size2uint[int1.size](int(int1) << int(int2))\n            elif op_name == 'a>>':\n                tmp1 = mod_size2int[int1.size](int(int1))\n                tmp2 = mod_size2uint[int2.size](int(int2))\n                if tmp2 > int1.size:\n                    is_signed = int(int1) & 1 << int1.size - 1\n                    if is_signed:\n                        out = -1\n                    else:\n                        out = 0\n                else:\n                    out = mod_size2uint[int1.size](tmp1 >> tmp2)\n            elif op_name == '>>>':\n                shifter = int(int2) % int2.size\n                out = int(int1) >> shifter | int(int1) << int2.size - shifter\n            elif op_name == '<<<':\n                shifter = int(int2) % int2.size\n                out = int(int1) << shifter | int(int1) >> int2.size - shifter\n            elif op_name == '/':\n                if int(int2) == 0:\n                    return expr\n                out = int(int1) // int(int2)\n            elif op_name == '%':\n                if int(int2) == 0:\n                    return expr\n                out = int(int1) % int(int2)\n            elif op_name == 'sdiv':\n                if int(int2) == 0:\n                    return expr\n                tmp1 = mod_size2int[int1.size](int(int1))\n                tmp2 = mod_size2int[int2.size](int(int2))\n                out = mod_size2uint[int1.size](tmp1 // tmp2)\n            elif op_name == 'smod':\n                if int(int2) == 0:\n                    return expr\n                tmp1 = mod_size2int[int1.size](int(int1))\n                tmp2 = mod_size2int[int2.size](int(int2))\n                out = mod_size2uint[int1.size](tmp1 % tmp2)\n            elif op_name == 'umod':\n                if int(int2) == 0:\n                    return expr\n                tmp1 = mod_size2uint[int1.size](int(int1))\n                tmp2 = mod_size2uint[int2.size](int(int2))\n                out = mod_size2uint[int1.size](tmp1 % tmp2)\n            elif op_name == 'udiv':\n                if int(int2) == 0:\n                    return expr\n                tmp1 = mod_size2uint[int1.size](int(int1))\n                tmp2 = mod_size2uint[int2.size](int(int2))\n                out = mod_size2uint[int1.size](tmp1 // tmp2)\n            args.append(ExprInt(int(out), int1.size))\n    if op_name == 'cnttrailzeros' and args[0].is_int():\n        i = 0\n        while int(args[0]) & 1 << i == 0 and i < args[0].size:\n            i += 1\n        return ExprInt(i, args[0].size)\n    if op_name == 'cntleadzeros' and args[0].is_int():\n        if int(args[0]) == 0:\n            return ExprInt(args[0].size, args[0].size)\n        i = args[0].size - 1\n        while int(args[0]) & 1 << i == 0:\n            i -= 1\n        return ExprInt(expr.size - (i + 1), args[0].size)\n    if op_name == '-' and len(args) == 1 and args[0].is_op('-') and (len(args[0].args) == 1):\n        return args[0].args[0]\n    if op_name == '-' and len(args) == 1 and args[0].is_int():\n        return ExprInt(-int(args[0]), expr.size)\n    if op_name in ['+', '|', '^', '<<', '>>', '<<<', '>>>'] and len(args) > 1:\n        if args[-1].is_int(0):\n            args.pop()\n    if op_name == '-' and len(args) > 1 and args[-1].is_int(0):\n        assert len(args) == 2\n        return args[0]\n    if op_name == '*' and len(args) > 1 and args[-1].is_int(1):\n        args.pop()\n    if op_name == '*' and len(args) > 1 and (args[-1] == args[-1].mask):\n        args.pop()\n        args[-1] = -args[-1]\n    if op_name in ['+', '*', '^', '&', '|', '>>', '<<', 'a>>', '<<<', '>>>', 'sdiv', 'smod', 'umod', 'udiv'] and len(args) == 1:\n        return args[0]\n    if op_name == '-' and len(args) > 1:\n        if len(args) > 2:\n            raise ValueError('sanity check fail on expr -: should have one or 2 args ' + '%r %s' % (expr, expr))\n        return ExprOp('+', args[0], -args[1])\n    if op_name in ['&', '*'] and args[-1].is_int(0):\n        return ExprInt(0, expr.size)\n    if op_name == '-' and len(args) == 1 and args[0].is_op('+'):\n        args = [-a for a in args[0].args]\n        return ExprOp('+', *args)\n    if op_name == '-' and len(args) == 1 and args[0].is_cond() and args[0].src1.is_int() and args[0].src2.is_int():\n        int1 = args[0].src1\n        int2 = args[0].src2\n        int1 = ExprInt(-int1.arg, int1.size)\n        int2 = ExprInt(-int2.arg, int2.size)\n        return ExprCond(args[0].cond, int1, int2)\n    i = 0\n    while i < len(args) - 1:\n        j = i + 1\n        while j < len(args):\n            if op_name == '^' and args[i] == args[j]:\n                args[i] = ExprInt(0, args[i].size)\n                del args[j]\n                continue\n            if op_name == '+' and args[j].is_op('-'):\n                if len(args[j].args) == 1 and args[i] == args[j].args[0]:\n                    args[i] = ExprInt(0, args[i].size)\n                    del args[j]\n                    continue\n            if op_name == '+' and args[i].is_op('-'):\n                if len(args[i].args) == 1 and args[j] == args[i].args[0]:\n                    args[i] = ExprInt(0, args[i].size)\n                    del args[j]\n                    continue\n            if op_name == '|' and args[i] == args[j]:\n                del args[j]\n                continue\n            if op_name == '&' and args[i] == args[j]:\n                del args[j]\n                continue\n            j += 1\n        i += 1\n    if op_name in ['+', '^', '|', '&', '%', '/', '**'] and len(args) == 1:\n        return args[0]\n    if op_name in ['<<<', '>>>'] and args[1].is_int() and (int(args[1]) == args[0].size):\n        return args[0]\n    if op_name in ['<<<', '>>>'] and args[0].is_op() and (args[0].op in ['<<<', '>>>']):\n        A = args[0].args[0]\n        X = args[0].args[1]\n        Y = args[1]\n        if op_name != args[0].op and e_s(X - Y) == ExprInt(0, X.size):\n            return args[0].args[0]\n        elif X.is_int() and Y.is_int():\n            new_X = int(X) % expr.size\n            new_Y = int(Y) % expr.size\n            if op_name == args[0].op:\n                rot = (new_X + new_Y) % expr.size\n                op = op_name\n            else:\n                rot = new_Y - new_X\n                op = op_name\n                if rot < 0:\n                    rot = -rot\n                    op = {'>>>': '<<<', '<<<': '>>>'}[op_name]\n            args = [A, ExprInt(rot, expr.size)]\n            op_name = op\n        else:\n            pass\n    if op_name in ['<<', '>>'] and args[0].is_op(op_name):\n        X = args[0].args[1]\n        Y = args[1]\n        if e_s(X.msb()) == ExprInt(0, 1) and e_s(Y.msb()) == ExprInt(0, 1):\n            args = [args[0].args[0], X + Y]\n    if op_name in ['<<', '>>'] and args[0].is_op() and (args[0].op in ['<<', '>>']) and (op_name != args[0]):\n        var = args[0].args[0]\n        int1 = args[0].args[1]\n        int2 = args[1]\n        if int1 == int2 and int1.is_int() and (int(int1) < expr.size):\n            if op_name == '>>':\n                mask = ExprInt((1 << expr.size - int(int1)) - 1, expr.size)\n            else:\n                mask = ExprInt((1 << int(int1)) - 1 ^ (1 << expr.size) - 1, expr.size)\n            ret = var & mask\n            return ret\n    if op_name == '&' and args[-1] == expr.mask:\n        args = args[:-1]\n        if len(args) == 1:\n            return args[0]\n        return ExprOp('&', *args)\n    if op_name == '|' and args[-1] == expr.mask:\n        return args[-1]\n    if op_name == '>>' and args[1].is_int() and args[0].is_op('&'):\n        if args[0].args[1].is_int() and 2 ** int(args[1]) > int(args[0].args[1]):\n            return ExprInt(0, args[0].size)\n    if op_name == 'parity' and args[0].is_int():\n        return ExprInt(parity(int(args[0])), 1)\n    if op_name == '*' and len(args) > 1:\n        new_args = []\n        counter = 0\n        for arg in args:\n            if arg.is_op('-') and len(arg.args) == 1:\n                new_args.append(arg.args[0])\n                counter += 1\n            else:\n                new_args.append(arg)\n        if counter % 2:\n            return -ExprOp(op_name, *new_args)\n        args = new_args\n    if op_name == '-' and args[0].is_op('*') and args[0].args[-1].is_int():\n        args = args[0].args\n        return ExprOp('*', *list(args[:-1]) + [ExprInt(-int(args[-1]), expr.size)])\n    if op_name == '<<' and args[0].is_compose() and args[1].is_int() and (int(args[1]) != 0):\n        final_size = args[0].size\n        shift = int(args[1])\n        new_args = []\n        for (index, arg) in args[0].iter_args():\n            new_args.append((arg, index + shift, index + shift + arg.size))\n        filter_args = []\n        min_index = final_size\n        for (tmp, start, stop) in new_args:\n            if start >= final_size:\n                continue\n            if stop > final_size:\n                tmp = tmp[:tmp.size - (stop - final_size)]\n            filter_args.append(tmp)\n            min_index = min(start, min_index)\n        assert min_index != 0\n        tmp = ExprInt(0, min_index)\n        args = [tmp] + filter_args\n        return ExprCompose(*args)\n    if op_name == '>>' and args[0].is_compose() and args[1].is_int():\n        final_size = args[0].size\n        shift = int(args[1])\n        new_args = []\n        for (index, arg) in args[0].iter_args():\n            new_args.append((arg, index - shift, index + arg.size - shift))\n        filter_args = []\n        max_index = 0\n        for (tmp, start, stop) in new_args:\n            if stop <= 0:\n                continue\n            if start < 0:\n                tmp = tmp[-start:]\n            filter_args.append(tmp)\n            max_index = max(stop, max_index)\n        tmp = ExprInt(0, final_size - max_index)\n        args = filter_args + [tmp]\n        return ExprCompose(*args)\n    if op_name in ['|', '&', '^'] and all([arg.is_compose() for arg in args]):\n        bounds = set()\n        for arg in args:\n            bound = tuple([tmp.size for tmp in arg.args])\n            bounds.add(bound)\n        if len(bounds) == 1:\n            new_args = [[tmp] for tmp in args[0].args]\n            for sub_arg in args[1:]:\n                for (i, tmp) in enumerate(sub_arg.args):\n                    new_args[i].append(tmp)\n            args = []\n            for (i, arg) in enumerate(new_args):\n                args.append(ExprOp(op_name, *arg))\n            return ExprCompose(*args)\n    return ExprOp(op_name, *args)"
        ]
    },
    {
        "func_name": "simp_cond_op_int",
        "original": "def simp_cond_op_int(_, expr):\n    \"\"\"Extract conditions from operations\"\"\"\n    if not expr.op in ['+', '|', '^', '&', '*', '<<', '>>', 'a>>']:\n        return expr\n    if len(expr.args) < 2:\n        return expr\n    conds = set()\n    for arg in expr.args:\n        if arg.is_cond():\n            conds.add(arg)\n    if len(conds) != 1:\n        return expr\n    cond = list(conds).pop()\n    (args1, args2) = ([], [])\n    for arg in expr.args:\n        if arg.is_cond():\n            args1.append(arg.src1)\n            args2.append(arg.src2)\n        else:\n            args1.append(arg)\n            args2.append(arg)\n    return ExprCond(cond.cond, ExprOp(expr.op, *args1), ExprOp(expr.op, *args2))",
        "mutated": [
            "def simp_cond_op_int(_, expr):\n    if False:\n        i = 10\n    'Extract conditions from operations'\n    if not expr.op in ['+', '|', '^', '&', '*', '<<', '>>', 'a>>']:\n        return expr\n    if len(expr.args) < 2:\n        return expr\n    conds = set()\n    for arg in expr.args:\n        if arg.is_cond():\n            conds.add(arg)\n    if len(conds) != 1:\n        return expr\n    cond = list(conds).pop()\n    (args1, args2) = ([], [])\n    for arg in expr.args:\n        if arg.is_cond():\n            args1.append(arg.src1)\n            args2.append(arg.src2)\n        else:\n            args1.append(arg)\n            args2.append(arg)\n    return ExprCond(cond.cond, ExprOp(expr.op, *args1), ExprOp(expr.op, *args2))",
            "def simp_cond_op_int(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Extract conditions from operations'\n    if not expr.op in ['+', '|', '^', '&', '*', '<<', '>>', 'a>>']:\n        return expr\n    if len(expr.args) < 2:\n        return expr\n    conds = set()\n    for arg in expr.args:\n        if arg.is_cond():\n            conds.add(arg)\n    if len(conds) != 1:\n        return expr\n    cond = list(conds).pop()\n    (args1, args2) = ([], [])\n    for arg in expr.args:\n        if arg.is_cond():\n            args1.append(arg.src1)\n            args2.append(arg.src2)\n        else:\n            args1.append(arg)\n            args2.append(arg)\n    return ExprCond(cond.cond, ExprOp(expr.op, *args1), ExprOp(expr.op, *args2))",
            "def simp_cond_op_int(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Extract conditions from operations'\n    if not expr.op in ['+', '|', '^', '&', '*', '<<', '>>', 'a>>']:\n        return expr\n    if len(expr.args) < 2:\n        return expr\n    conds = set()\n    for arg in expr.args:\n        if arg.is_cond():\n            conds.add(arg)\n    if len(conds) != 1:\n        return expr\n    cond = list(conds).pop()\n    (args1, args2) = ([], [])\n    for arg in expr.args:\n        if arg.is_cond():\n            args1.append(arg.src1)\n            args2.append(arg.src2)\n        else:\n            args1.append(arg)\n            args2.append(arg)\n    return ExprCond(cond.cond, ExprOp(expr.op, *args1), ExprOp(expr.op, *args2))",
            "def simp_cond_op_int(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Extract conditions from operations'\n    if not expr.op in ['+', '|', '^', '&', '*', '<<', '>>', 'a>>']:\n        return expr\n    if len(expr.args) < 2:\n        return expr\n    conds = set()\n    for arg in expr.args:\n        if arg.is_cond():\n            conds.add(arg)\n    if len(conds) != 1:\n        return expr\n    cond = list(conds).pop()\n    (args1, args2) = ([], [])\n    for arg in expr.args:\n        if arg.is_cond():\n            args1.append(arg.src1)\n            args2.append(arg.src2)\n        else:\n            args1.append(arg)\n            args2.append(arg)\n    return ExprCond(cond.cond, ExprOp(expr.op, *args1), ExprOp(expr.op, *args2))",
            "def simp_cond_op_int(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Extract conditions from operations'\n    if not expr.op in ['+', '|', '^', '&', '*', '<<', '>>', 'a>>']:\n        return expr\n    if len(expr.args) < 2:\n        return expr\n    conds = set()\n    for arg in expr.args:\n        if arg.is_cond():\n            conds.add(arg)\n    if len(conds) != 1:\n        return expr\n    cond = list(conds).pop()\n    (args1, args2) = ([], [])\n    for arg in expr.args:\n        if arg.is_cond():\n            args1.append(arg.src1)\n            args2.append(arg.src2)\n        else:\n            args1.append(arg)\n            args2.append(arg)\n    return ExprCond(cond.cond, ExprOp(expr.op, *args1), ExprOp(expr.op, *args2))"
        ]
    },
    {
        "func_name": "simp_cond_factor",
        "original": "def simp_cond_factor(e_s, expr):\n    \"\"\"Merge similar conditions\"\"\"\n    if not expr.op in ['+', '|', '^', '&', '*', '<<', '>>', 'a>>']:\n        return expr\n    if len(expr.args) < 2:\n        return expr\n    if expr.op in ['>>', '<<', 'a>>']:\n        assert len(expr.args) == 2\n    conds = {}\n    not_conds = []\n    multi_cond = False\n    for arg in expr.args:\n        if not arg.is_cond():\n            not_conds.append(arg)\n            continue\n        cond = arg.cond\n        if not cond in conds:\n            conds[cond] = []\n        else:\n            multi_cond = True\n        conds[cond].append(arg)\n    if not multi_cond:\n        return expr\n    c_out = not_conds\n    for (cond, vals) in viewitems(conds):\n        new_src1 = [x.src1 for x in vals]\n        new_src2 = [x.src2 for x in vals]\n        src1 = e_s.expr_simp(ExprOp(expr.op, *new_src1))\n        src2 = e_s.expr_simp(ExprOp(expr.op, *new_src2))\n        c_out.append(ExprCond(cond, src1, src2))\n    if len(c_out) == 1:\n        new_e = c_out[0]\n    else:\n        new_e = ExprOp(expr.op, *c_out)\n    return new_e",
        "mutated": [
            "def simp_cond_factor(e_s, expr):\n    if False:\n        i = 10\n    'Merge similar conditions'\n    if not expr.op in ['+', '|', '^', '&', '*', '<<', '>>', 'a>>']:\n        return expr\n    if len(expr.args) < 2:\n        return expr\n    if expr.op in ['>>', '<<', 'a>>']:\n        assert len(expr.args) == 2\n    conds = {}\n    not_conds = []\n    multi_cond = False\n    for arg in expr.args:\n        if not arg.is_cond():\n            not_conds.append(arg)\n            continue\n        cond = arg.cond\n        if not cond in conds:\n            conds[cond] = []\n        else:\n            multi_cond = True\n        conds[cond].append(arg)\n    if not multi_cond:\n        return expr\n    c_out = not_conds\n    for (cond, vals) in viewitems(conds):\n        new_src1 = [x.src1 for x in vals]\n        new_src2 = [x.src2 for x in vals]\n        src1 = e_s.expr_simp(ExprOp(expr.op, *new_src1))\n        src2 = e_s.expr_simp(ExprOp(expr.op, *new_src2))\n        c_out.append(ExprCond(cond, src1, src2))\n    if len(c_out) == 1:\n        new_e = c_out[0]\n    else:\n        new_e = ExprOp(expr.op, *c_out)\n    return new_e",
            "def simp_cond_factor(e_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Merge similar conditions'\n    if not expr.op in ['+', '|', '^', '&', '*', '<<', '>>', 'a>>']:\n        return expr\n    if len(expr.args) < 2:\n        return expr\n    if expr.op in ['>>', '<<', 'a>>']:\n        assert len(expr.args) == 2\n    conds = {}\n    not_conds = []\n    multi_cond = False\n    for arg in expr.args:\n        if not arg.is_cond():\n            not_conds.append(arg)\n            continue\n        cond = arg.cond\n        if not cond in conds:\n            conds[cond] = []\n        else:\n            multi_cond = True\n        conds[cond].append(arg)\n    if not multi_cond:\n        return expr\n    c_out = not_conds\n    for (cond, vals) in viewitems(conds):\n        new_src1 = [x.src1 for x in vals]\n        new_src2 = [x.src2 for x in vals]\n        src1 = e_s.expr_simp(ExprOp(expr.op, *new_src1))\n        src2 = e_s.expr_simp(ExprOp(expr.op, *new_src2))\n        c_out.append(ExprCond(cond, src1, src2))\n    if len(c_out) == 1:\n        new_e = c_out[0]\n    else:\n        new_e = ExprOp(expr.op, *c_out)\n    return new_e",
            "def simp_cond_factor(e_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Merge similar conditions'\n    if not expr.op in ['+', '|', '^', '&', '*', '<<', '>>', 'a>>']:\n        return expr\n    if len(expr.args) < 2:\n        return expr\n    if expr.op in ['>>', '<<', 'a>>']:\n        assert len(expr.args) == 2\n    conds = {}\n    not_conds = []\n    multi_cond = False\n    for arg in expr.args:\n        if not arg.is_cond():\n            not_conds.append(arg)\n            continue\n        cond = arg.cond\n        if not cond in conds:\n            conds[cond] = []\n        else:\n            multi_cond = True\n        conds[cond].append(arg)\n    if not multi_cond:\n        return expr\n    c_out = not_conds\n    for (cond, vals) in viewitems(conds):\n        new_src1 = [x.src1 for x in vals]\n        new_src2 = [x.src2 for x in vals]\n        src1 = e_s.expr_simp(ExprOp(expr.op, *new_src1))\n        src2 = e_s.expr_simp(ExprOp(expr.op, *new_src2))\n        c_out.append(ExprCond(cond, src1, src2))\n    if len(c_out) == 1:\n        new_e = c_out[0]\n    else:\n        new_e = ExprOp(expr.op, *c_out)\n    return new_e",
            "def simp_cond_factor(e_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Merge similar conditions'\n    if not expr.op in ['+', '|', '^', '&', '*', '<<', '>>', 'a>>']:\n        return expr\n    if len(expr.args) < 2:\n        return expr\n    if expr.op in ['>>', '<<', 'a>>']:\n        assert len(expr.args) == 2\n    conds = {}\n    not_conds = []\n    multi_cond = False\n    for arg in expr.args:\n        if not arg.is_cond():\n            not_conds.append(arg)\n            continue\n        cond = arg.cond\n        if not cond in conds:\n            conds[cond] = []\n        else:\n            multi_cond = True\n        conds[cond].append(arg)\n    if not multi_cond:\n        return expr\n    c_out = not_conds\n    for (cond, vals) in viewitems(conds):\n        new_src1 = [x.src1 for x in vals]\n        new_src2 = [x.src2 for x in vals]\n        src1 = e_s.expr_simp(ExprOp(expr.op, *new_src1))\n        src2 = e_s.expr_simp(ExprOp(expr.op, *new_src2))\n        c_out.append(ExprCond(cond, src1, src2))\n    if len(c_out) == 1:\n        new_e = c_out[0]\n    else:\n        new_e = ExprOp(expr.op, *c_out)\n    return new_e",
            "def simp_cond_factor(e_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Merge similar conditions'\n    if not expr.op in ['+', '|', '^', '&', '*', '<<', '>>', 'a>>']:\n        return expr\n    if len(expr.args) < 2:\n        return expr\n    if expr.op in ['>>', '<<', 'a>>']:\n        assert len(expr.args) == 2\n    conds = {}\n    not_conds = []\n    multi_cond = False\n    for arg in expr.args:\n        if not arg.is_cond():\n            not_conds.append(arg)\n            continue\n        cond = arg.cond\n        if not cond in conds:\n            conds[cond] = []\n        else:\n            multi_cond = True\n        conds[cond].append(arg)\n    if not multi_cond:\n        return expr\n    c_out = not_conds\n    for (cond, vals) in viewitems(conds):\n        new_src1 = [x.src1 for x in vals]\n        new_src2 = [x.src2 for x in vals]\n        src1 = e_s.expr_simp(ExprOp(expr.op, *new_src1))\n        src2 = e_s.expr_simp(ExprOp(expr.op, *new_src2))\n        c_out.append(ExprCond(cond, src1, src2))\n    if len(c_out) == 1:\n        new_e = c_out[0]\n    else:\n        new_e = ExprOp(expr.op, *c_out)\n    return new_e"
        ]
    },
    {
        "func_name": "simp_slice",
        "original": "def simp_slice(e_s, expr):\n    \"\"\"Slice optimization\"\"\"\n    if expr.start == 0 and expr.stop == expr.arg.size:\n        return expr.arg\n    if expr.arg.is_int():\n        total_bit = expr.stop - expr.start\n        mask = (1 << expr.stop - expr.start) - 1\n        return ExprInt(int(int(expr.arg) >> expr.start & mask), total_bit)\n    if expr.arg.is_slice():\n        if expr.stop - expr.start > expr.arg.stop - expr.arg.start:\n            raise ValueError('slice in slice: getting more val', str(expr))\n        return ExprSlice(expr.arg.arg, expr.start + expr.arg.start, expr.start + expr.arg.start + (expr.stop - expr.start))\n    if expr.arg.is_compose():\n        for (index, arg) in expr.arg.iter_args():\n            if index <= expr.start and index + arg.size >= expr.stop:\n                return arg[expr.start - index:expr.stop - index]\n        out = []\n        for (index, arg) in expr.arg.iter_args():\n            if expr.start >= index + arg.size:\n                continue\n            elif expr.stop <= index:\n                continue\n            elif expr.start <= index and index + arg.size <= expr.stop:\n                out.append(arg)\n                continue\n            if expr.start > index:\n                slice_start = expr.start - index\n            else:\n                slice_start = 0\n            if expr.stop < index + arg.size:\n                slice_stop = arg.size + expr.stop - (index + arg.size) - slice_start\n            else:\n                slice_stop = arg.size\n            out.append(arg[slice_start:slice_stop])\n        return ExprCompose(*out)\n    if expr.arg.is_mem() and expr.start == 0 and (expr.arg.size > expr.stop) and (expr.stop % 8 == 0):\n        return ExprMem(expr.arg.ptr, size=expr.stop)\n    if expr.arg.is_op('&') and expr.arg.args[-1].is_int():\n        tmp = e_s.expr_simp(expr.arg.args[-1][expr.start:expr.stop])\n        if tmp.is_int(0):\n            return tmp\n    if expr.arg.is_cond() and (expr.arg.src1.is_int() or expr.arg.src1.is_compose()) and (expr.arg.src2.is_int() or expr.arg.src2.is_compose()):\n        src1 = expr.arg.src1[expr.start:expr.stop]\n        src2 = expr.arg.src2[expr.start:expr.stop]\n        return ExprCond(expr.arg.cond, src1, src2)\n    if expr.start == 0 and expr.arg.is_op('*') and expr.arg.args[-1].is_int():\n        args = [e_s.expr_simp(a[expr.start:expr.stop]) for a in expr.arg.args]\n        return ExprOp(expr.arg.op, *args)\n    if expr.arg.is_op() and expr.arg.op in ['>>', '<<'] and expr.arg.args[1].is_int():\n        (arg, shift) = expr.arg.args\n        shift = int(shift)\n        if expr.arg.op == '>>':\n            if shift + expr.stop <= arg.size:\n                return arg[expr.start + shift:expr.stop + shift]\n        elif expr.arg.op == '<<':\n            if expr.start - shift >= 0:\n                return arg[expr.start - shift:expr.stop - shift]\n        else:\n            raise ValueError('Bad case')\n    return expr",
        "mutated": [
            "def simp_slice(e_s, expr):\n    if False:\n        i = 10\n    'Slice optimization'\n    if expr.start == 0 and expr.stop == expr.arg.size:\n        return expr.arg\n    if expr.arg.is_int():\n        total_bit = expr.stop - expr.start\n        mask = (1 << expr.stop - expr.start) - 1\n        return ExprInt(int(int(expr.arg) >> expr.start & mask), total_bit)\n    if expr.arg.is_slice():\n        if expr.stop - expr.start > expr.arg.stop - expr.arg.start:\n            raise ValueError('slice in slice: getting more val', str(expr))\n        return ExprSlice(expr.arg.arg, expr.start + expr.arg.start, expr.start + expr.arg.start + (expr.stop - expr.start))\n    if expr.arg.is_compose():\n        for (index, arg) in expr.arg.iter_args():\n            if index <= expr.start and index + arg.size >= expr.stop:\n                return arg[expr.start - index:expr.stop - index]\n        out = []\n        for (index, arg) in expr.arg.iter_args():\n            if expr.start >= index + arg.size:\n                continue\n            elif expr.stop <= index:\n                continue\n            elif expr.start <= index and index + arg.size <= expr.stop:\n                out.append(arg)\n                continue\n            if expr.start > index:\n                slice_start = expr.start - index\n            else:\n                slice_start = 0\n            if expr.stop < index + arg.size:\n                slice_stop = arg.size + expr.stop - (index + arg.size) - slice_start\n            else:\n                slice_stop = arg.size\n            out.append(arg[slice_start:slice_stop])\n        return ExprCompose(*out)\n    if expr.arg.is_mem() and expr.start == 0 and (expr.arg.size > expr.stop) and (expr.stop % 8 == 0):\n        return ExprMem(expr.arg.ptr, size=expr.stop)\n    if expr.arg.is_op('&') and expr.arg.args[-1].is_int():\n        tmp = e_s.expr_simp(expr.arg.args[-1][expr.start:expr.stop])\n        if tmp.is_int(0):\n            return tmp\n    if expr.arg.is_cond() and (expr.arg.src1.is_int() or expr.arg.src1.is_compose()) and (expr.arg.src2.is_int() or expr.arg.src2.is_compose()):\n        src1 = expr.arg.src1[expr.start:expr.stop]\n        src2 = expr.arg.src2[expr.start:expr.stop]\n        return ExprCond(expr.arg.cond, src1, src2)\n    if expr.start == 0 and expr.arg.is_op('*') and expr.arg.args[-1].is_int():\n        args = [e_s.expr_simp(a[expr.start:expr.stop]) for a in expr.arg.args]\n        return ExprOp(expr.arg.op, *args)\n    if expr.arg.is_op() and expr.arg.op in ['>>', '<<'] and expr.arg.args[1].is_int():\n        (arg, shift) = expr.arg.args\n        shift = int(shift)\n        if expr.arg.op == '>>':\n            if shift + expr.stop <= arg.size:\n                return arg[expr.start + shift:expr.stop + shift]\n        elif expr.arg.op == '<<':\n            if expr.start - shift >= 0:\n                return arg[expr.start - shift:expr.stop - shift]\n        else:\n            raise ValueError('Bad case')\n    return expr",
            "def simp_slice(e_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Slice optimization'\n    if expr.start == 0 and expr.stop == expr.arg.size:\n        return expr.arg\n    if expr.arg.is_int():\n        total_bit = expr.stop - expr.start\n        mask = (1 << expr.stop - expr.start) - 1\n        return ExprInt(int(int(expr.arg) >> expr.start & mask), total_bit)\n    if expr.arg.is_slice():\n        if expr.stop - expr.start > expr.arg.stop - expr.arg.start:\n            raise ValueError('slice in slice: getting more val', str(expr))\n        return ExprSlice(expr.arg.arg, expr.start + expr.arg.start, expr.start + expr.arg.start + (expr.stop - expr.start))\n    if expr.arg.is_compose():\n        for (index, arg) in expr.arg.iter_args():\n            if index <= expr.start and index + arg.size >= expr.stop:\n                return arg[expr.start - index:expr.stop - index]\n        out = []\n        for (index, arg) in expr.arg.iter_args():\n            if expr.start >= index + arg.size:\n                continue\n            elif expr.stop <= index:\n                continue\n            elif expr.start <= index and index + arg.size <= expr.stop:\n                out.append(arg)\n                continue\n            if expr.start > index:\n                slice_start = expr.start - index\n            else:\n                slice_start = 0\n            if expr.stop < index + arg.size:\n                slice_stop = arg.size + expr.stop - (index + arg.size) - slice_start\n            else:\n                slice_stop = arg.size\n            out.append(arg[slice_start:slice_stop])\n        return ExprCompose(*out)\n    if expr.arg.is_mem() and expr.start == 0 and (expr.arg.size > expr.stop) and (expr.stop % 8 == 0):\n        return ExprMem(expr.arg.ptr, size=expr.stop)\n    if expr.arg.is_op('&') and expr.arg.args[-1].is_int():\n        tmp = e_s.expr_simp(expr.arg.args[-1][expr.start:expr.stop])\n        if tmp.is_int(0):\n            return tmp\n    if expr.arg.is_cond() and (expr.arg.src1.is_int() or expr.arg.src1.is_compose()) and (expr.arg.src2.is_int() or expr.arg.src2.is_compose()):\n        src1 = expr.arg.src1[expr.start:expr.stop]\n        src2 = expr.arg.src2[expr.start:expr.stop]\n        return ExprCond(expr.arg.cond, src1, src2)\n    if expr.start == 0 and expr.arg.is_op('*') and expr.arg.args[-1].is_int():\n        args = [e_s.expr_simp(a[expr.start:expr.stop]) for a in expr.arg.args]\n        return ExprOp(expr.arg.op, *args)\n    if expr.arg.is_op() and expr.arg.op in ['>>', '<<'] and expr.arg.args[1].is_int():\n        (arg, shift) = expr.arg.args\n        shift = int(shift)\n        if expr.arg.op == '>>':\n            if shift + expr.stop <= arg.size:\n                return arg[expr.start + shift:expr.stop + shift]\n        elif expr.arg.op == '<<':\n            if expr.start - shift >= 0:\n                return arg[expr.start - shift:expr.stop - shift]\n        else:\n            raise ValueError('Bad case')\n    return expr",
            "def simp_slice(e_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Slice optimization'\n    if expr.start == 0 and expr.stop == expr.arg.size:\n        return expr.arg\n    if expr.arg.is_int():\n        total_bit = expr.stop - expr.start\n        mask = (1 << expr.stop - expr.start) - 1\n        return ExprInt(int(int(expr.arg) >> expr.start & mask), total_bit)\n    if expr.arg.is_slice():\n        if expr.stop - expr.start > expr.arg.stop - expr.arg.start:\n            raise ValueError('slice in slice: getting more val', str(expr))\n        return ExprSlice(expr.arg.arg, expr.start + expr.arg.start, expr.start + expr.arg.start + (expr.stop - expr.start))\n    if expr.arg.is_compose():\n        for (index, arg) in expr.arg.iter_args():\n            if index <= expr.start and index + arg.size >= expr.stop:\n                return arg[expr.start - index:expr.stop - index]\n        out = []\n        for (index, arg) in expr.arg.iter_args():\n            if expr.start >= index + arg.size:\n                continue\n            elif expr.stop <= index:\n                continue\n            elif expr.start <= index and index + arg.size <= expr.stop:\n                out.append(arg)\n                continue\n            if expr.start > index:\n                slice_start = expr.start - index\n            else:\n                slice_start = 0\n            if expr.stop < index + arg.size:\n                slice_stop = arg.size + expr.stop - (index + arg.size) - slice_start\n            else:\n                slice_stop = arg.size\n            out.append(arg[slice_start:slice_stop])\n        return ExprCompose(*out)\n    if expr.arg.is_mem() and expr.start == 0 and (expr.arg.size > expr.stop) and (expr.stop % 8 == 0):\n        return ExprMem(expr.arg.ptr, size=expr.stop)\n    if expr.arg.is_op('&') and expr.arg.args[-1].is_int():\n        tmp = e_s.expr_simp(expr.arg.args[-1][expr.start:expr.stop])\n        if tmp.is_int(0):\n            return tmp\n    if expr.arg.is_cond() and (expr.arg.src1.is_int() or expr.arg.src1.is_compose()) and (expr.arg.src2.is_int() or expr.arg.src2.is_compose()):\n        src1 = expr.arg.src1[expr.start:expr.stop]\n        src2 = expr.arg.src2[expr.start:expr.stop]\n        return ExprCond(expr.arg.cond, src1, src2)\n    if expr.start == 0 and expr.arg.is_op('*') and expr.arg.args[-1].is_int():\n        args = [e_s.expr_simp(a[expr.start:expr.stop]) for a in expr.arg.args]\n        return ExprOp(expr.arg.op, *args)\n    if expr.arg.is_op() and expr.arg.op in ['>>', '<<'] and expr.arg.args[1].is_int():\n        (arg, shift) = expr.arg.args\n        shift = int(shift)\n        if expr.arg.op == '>>':\n            if shift + expr.stop <= arg.size:\n                return arg[expr.start + shift:expr.stop + shift]\n        elif expr.arg.op == '<<':\n            if expr.start - shift >= 0:\n                return arg[expr.start - shift:expr.stop - shift]\n        else:\n            raise ValueError('Bad case')\n    return expr",
            "def simp_slice(e_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Slice optimization'\n    if expr.start == 0 and expr.stop == expr.arg.size:\n        return expr.arg\n    if expr.arg.is_int():\n        total_bit = expr.stop - expr.start\n        mask = (1 << expr.stop - expr.start) - 1\n        return ExprInt(int(int(expr.arg) >> expr.start & mask), total_bit)\n    if expr.arg.is_slice():\n        if expr.stop - expr.start > expr.arg.stop - expr.arg.start:\n            raise ValueError('slice in slice: getting more val', str(expr))\n        return ExprSlice(expr.arg.arg, expr.start + expr.arg.start, expr.start + expr.arg.start + (expr.stop - expr.start))\n    if expr.arg.is_compose():\n        for (index, arg) in expr.arg.iter_args():\n            if index <= expr.start and index + arg.size >= expr.stop:\n                return arg[expr.start - index:expr.stop - index]\n        out = []\n        for (index, arg) in expr.arg.iter_args():\n            if expr.start >= index + arg.size:\n                continue\n            elif expr.stop <= index:\n                continue\n            elif expr.start <= index and index + arg.size <= expr.stop:\n                out.append(arg)\n                continue\n            if expr.start > index:\n                slice_start = expr.start - index\n            else:\n                slice_start = 0\n            if expr.stop < index + arg.size:\n                slice_stop = arg.size + expr.stop - (index + arg.size) - slice_start\n            else:\n                slice_stop = arg.size\n            out.append(arg[slice_start:slice_stop])\n        return ExprCompose(*out)\n    if expr.arg.is_mem() and expr.start == 0 and (expr.arg.size > expr.stop) and (expr.stop % 8 == 0):\n        return ExprMem(expr.arg.ptr, size=expr.stop)\n    if expr.arg.is_op('&') and expr.arg.args[-1].is_int():\n        tmp = e_s.expr_simp(expr.arg.args[-1][expr.start:expr.stop])\n        if tmp.is_int(0):\n            return tmp\n    if expr.arg.is_cond() and (expr.arg.src1.is_int() or expr.arg.src1.is_compose()) and (expr.arg.src2.is_int() or expr.arg.src2.is_compose()):\n        src1 = expr.arg.src1[expr.start:expr.stop]\n        src2 = expr.arg.src2[expr.start:expr.stop]\n        return ExprCond(expr.arg.cond, src1, src2)\n    if expr.start == 0 and expr.arg.is_op('*') and expr.arg.args[-1].is_int():\n        args = [e_s.expr_simp(a[expr.start:expr.stop]) for a in expr.arg.args]\n        return ExprOp(expr.arg.op, *args)\n    if expr.arg.is_op() and expr.arg.op in ['>>', '<<'] and expr.arg.args[1].is_int():\n        (arg, shift) = expr.arg.args\n        shift = int(shift)\n        if expr.arg.op == '>>':\n            if shift + expr.stop <= arg.size:\n                return arg[expr.start + shift:expr.stop + shift]\n        elif expr.arg.op == '<<':\n            if expr.start - shift >= 0:\n                return arg[expr.start - shift:expr.stop - shift]\n        else:\n            raise ValueError('Bad case')\n    return expr",
            "def simp_slice(e_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Slice optimization'\n    if expr.start == 0 and expr.stop == expr.arg.size:\n        return expr.arg\n    if expr.arg.is_int():\n        total_bit = expr.stop - expr.start\n        mask = (1 << expr.stop - expr.start) - 1\n        return ExprInt(int(int(expr.arg) >> expr.start & mask), total_bit)\n    if expr.arg.is_slice():\n        if expr.stop - expr.start > expr.arg.stop - expr.arg.start:\n            raise ValueError('slice in slice: getting more val', str(expr))\n        return ExprSlice(expr.arg.arg, expr.start + expr.arg.start, expr.start + expr.arg.start + (expr.stop - expr.start))\n    if expr.arg.is_compose():\n        for (index, arg) in expr.arg.iter_args():\n            if index <= expr.start and index + arg.size >= expr.stop:\n                return arg[expr.start - index:expr.stop - index]\n        out = []\n        for (index, arg) in expr.arg.iter_args():\n            if expr.start >= index + arg.size:\n                continue\n            elif expr.stop <= index:\n                continue\n            elif expr.start <= index and index + arg.size <= expr.stop:\n                out.append(arg)\n                continue\n            if expr.start > index:\n                slice_start = expr.start - index\n            else:\n                slice_start = 0\n            if expr.stop < index + arg.size:\n                slice_stop = arg.size + expr.stop - (index + arg.size) - slice_start\n            else:\n                slice_stop = arg.size\n            out.append(arg[slice_start:slice_stop])\n        return ExprCompose(*out)\n    if expr.arg.is_mem() and expr.start == 0 and (expr.arg.size > expr.stop) and (expr.stop % 8 == 0):\n        return ExprMem(expr.arg.ptr, size=expr.stop)\n    if expr.arg.is_op('&') and expr.arg.args[-1].is_int():\n        tmp = e_s.expr_simp(expr.arg.args[-1][expr.start:expr.stop])\n        if tmp.is_int(0):\n            return tmp\n    if expr.arg.is_cond() and (expr.arg.src1.is_int() or expr.arg.src1.is_compose()) and (expr.arg.src2.is_int() or expr.arg.src2.is_compose()):\n        src1 = expr.arg.src1[expr.start:expr.stop]\n        src2 = expr.arg.src2[expr.start:expr.stop]\n        return ExprCond(expr.arg.cond, src1, src2)\n    if expr.start == 0 and expr.arg.is_op('*') and expr.arg.args[-1].is_int():\n        args = [e_s.expr_simp(a[expr.start:expr.stop]) for a in expr.arg.args]\n        return ExprOp(expr.arg.op, *args)\n    if expr.arg.is_op() and expr.arg.op in ['>>', '<<'] and expr.arg.args[1].is_int():\n        (arg, shift) = expr.arg.args\n        shift = int(shift)\n        if expr.arg.op == '>>':\n            if shift + expr.stop <= arg.size:\n                return arg[expr.start + shift:expr.stop + shift]\n        elif expr.arg.op == '<<':\n            if expr.start - shift >= 0:\n                return arg[expr.start - shift:expr.stop - shift]\n        else:\n            raise ValueError('Bad case')\n    return expr"
        ]
    },
    {
        "func_name": "simp_compose",
        "original": "def simp_compose(e_s, expr):\n    \"\"\"Commons simplification on ExprCompose\"\"\"\n    args = merge_sliceto_slice(expr)\n    out = []\n    for arg in args:\n        if arg.is_compose():\n            out += arg.args\n        else:\n            out.append(arg)\n    args = out\n    if len(args) == 1 and args[0].size == expr.size:\n        return args[0]\n    if len(args) == 2 and args[1].is_int(0):\n        if args[0].is_slice() and args[0].stop == args[0].arg.size and (args[0].size + args[1].size == args[0].arg.size):\n            new_expr = args[0].arg >> ExprInt(args[0].start, args[0].arg.size)\n            return new_expr\n    for (i, arg) in enumerate(args[:-1]):\n        nxt = args[i + 1]\n        if arg.is_mem() and nxt.is_mem():\n            gap = e_s(nxt.ptr - arg.ptr)\n            if gap.is_int() and arg.size % 8 == 0 and (int(gap) == arg.size // 8):\n                args = args[:i] + [ExprMem(arg.ptr, arg.size + nxt.size)] + args[i + 2:]\n                return ExprCompose(*args)\n    if len(args) == 2 and args[0].size == args[1].size:\n        (arg1, arg2) = args\n        size = arg1.size\n        sign_ext = arg1.signExtend(arg1.size * 2)\n        if arg2 == sign_ext[size:2 * size]:\n            return sign_ext\n    conds = set((arg.cond for arg in expr.args if arg.is_cond()))\n    if len(conds) == 1:\n        cond = list(conds)[0]\n        (args1, args2) = ([], [])\n        for arg in expr.args:\n            if arg.is_cond():\n                args1.append(arg.src1)\n                args2.append(arg.src2)\n            else:\n                args1.append(arg)\n                args2.append(arg)\n        arg1 = e_s(ExprCompose(*args1))\n        arg2 = e_s(ExprCompose(*args2))\n        return ExprCond(cond, arg1, arg2)\n    return ExprCompose(*args)",
        "mutated": [
            "def simp_compose(e_s, expr):\n    if False:\n        i = 10\n    'Commons simplification on ExprCompose'\n    args = merge_sliceto_slice(expr)\n    out = []\n    for arg in args:\n        if arg.is_compose():\n            out += arg.args\n        else:\n            out.append(arg)\n    args = out\n    if len(args) == 1 and args[0].size == expr.size:\n        return args[0]\n    if len(args) == 2 and args[1].is_int(0):\n        if args[0].is_slice() and args[0].stop == args[0].arg.size and (args[0].size + args[1].size == args[0].arg.size):\n            new_expr = args[0].arg >> ExprInt(args[0].start, args[0].arg.size)\n            return new_expr\n    for (i, arg) in enumerate(args[:-1]):\n        nxt = args[i + 1]\n        if arg.is_mem() and nxt.is_mem():\n            gap = e_s(nxt.ptr - arg.ptr)\n            if gap.is_int() and arg.size % 8 == 0 and (int(gap) == arg.size // 8):\n                args = args[:i] + [ExprMem(arg.ptr, arg.size + nxt.size)] + args[i + 2:]\n                return ExprCompose(*args)\n    if len(args) == 2 and args[0].size == args[1].size:\n        (arg1, arg2) = args\n        size = arg1.size\n        sign_ext = arg1.signExtend(arg1.size * 2)\n        if arg2 == sign_ext[size:2 * size]:\n            return sign_ext\n    conds = set((arg.cond for arg in expr.args if arg.is_cond()))\n    if len(conds) == 1:\n        cond = list(conds)[0]\n        (args1, args2) = ([], [])\n        for arg in expr.args:\n            if arg.is_cond():\n                args1.append(arg.src1)\n                args2.append(arg.src2)\n            else:\n                args1.append(arg)\n                args2.append(arg)\n        arg1 = e_s(ExprCompose(*args1))\n        arg2 = e_s(ExprCompose(*args2))\n        return ExprCond(cond, arg1, arg2)\n    return ExprCompose(*args)",
            "def simp_compose(e_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Commons simplification on ExprCompose'\n    args = merge_sliceto_slice(expr)\n    out = []\n    for arg in args:\n        if arg.is_compose():\n            out += arg.args\n        else:\n            out.append(arg)\n    args = out\n    if len(args) == 1 and args[0].size == expr.size:\n        return args[0]\n    if len(args) == 2 and args[1].is_int(0):\n        if args[0].is_slice() and args[0].stop == args[0].arg.size and (args[0].size + args[1].size == args[0].arg.size):\n            new_expr = args[0].arg >> ExprInt(args[0].start, args[0].arg.size)\n            return new_expr\n    for (i, arg) in enumerate(args[:-1]):\n        nxt = args[i + 1]\n        if arg.is_mem() and nxt.is_mem():\n            gap = e_s(nxt.ptr - arg.ptr)\n            if gap.is_int() and arg.size % 8 == 0 and (int(gap) == arg.size // 8):\n                args = args[:i] + [ExprMem(arg.ptr, arg.size + nxt.size)] + args[i + 2:]\n                return ExprCompose(*args)\n    if len(args) == 2 and args[0].size == args[1].size:\n        (arg1, arg2) = args\n        size = arg1.size\n        sign_ext = arg1.signExtend(arg1.size * 2)\n        if arg2 == sign_ext[size:2 * size]:\n            return sign_ext\n    conds = set((arg.cond for arg in expr.args if arg.is_cond()))\n    if len(conds) == 1:\n        cond = list(conds)[0]\n        (args1, args2) = ([], [])\n        for arg in expr.args:\n            if arg.is_cond():\n                args1.append(arg.src1)\n                args2.append(arg.src2)\n            else:\n                args1.append(arg)\n                args2.append(arg)\n        arg1 = e_s(ExprCompose(*args1))\n        arg2 = e_s(ExprCompose(*args2))\n        return ExprCond(cond, arg1, arg2)\n    return ExprCompose(*args)",
            "def simp_compose(e_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Commons simplification on ExprCompose'\n    args = merge_sliceto_slice(expr)\n    out = []\n    for arg in args:\n        if arg.is_compose():\n            out += arg.args\n        else:\n            out.append(arg)\n    args = out\n    if len(args) == 1 and args[0].size == expr.size:\n        return args[0]\n    if len(args) == 2 and args[1].is_int(0):\n        if args[0].is_slice() and args[0].stop == args[0].arg.size and (args[0].size + args[1].size == args[0].arg.size):\n            new_expr = args[0].arg >> ExprInt(args[0].start, args[0].arg.size)\n            return new_expr\n    for (i, arg) in enumerate(args[:-1]):\n        nxt = args[i + 1]\n        if arg.is_mem() and nxt.is_mem():\n            gap = e_s(nxt.ptr - arg.ptr)\n            if gap.is_int() and arg.size % 8 == 0 and (int(gap) == arg.size // 8):\n                args = args[:i] + [ExprMem(arg.ptr, arg.size + nxt.size)] + args[i + 2:]\n                return ExprCompose(*args)\n    if len(args) == 2 and args[0].size == args[1].size:\n        (arg1, arg2) = args\n        size = arg1.size\n        sign_ext = arg1.signExtend(arg1.size * 2)\n        if arg2 == sign_ext[size:2 * size]:\n            return sign_ext\n    conds = set((arg.cond for arg in expr.args if arg.is_cond()))\n    if len(conds) == 1:\n        cond = list(conds)[0]\n        (args1, args2) = ([], [])\n        for arg in expr.args:\n            if arg.is_cond():\n                args1.append(arg.src1)\n                args2.append(arg.src2)\n            else:\n                args1.append(arg)\n                args2.append(arg)\n        arg1 = e_s(ExprCompose(*args1))\n        arg2 = e_s(ExprCompose(*args2))\n        return ExprCond(cond, arg1, arg2)\n    return ExprCompose(*args)",
            "def simp_compose(e_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Commons simplification on ExprCompose'\n    args = merge_sliceto_slice(expr)\n    out = []\n    for arg in args:\n        if arg.is_compose():\n            out += arg.args\n        else:\n            out.append(arg)\n    args = out\n    if len(args) == 1 and args[0].size == expr.size:\n        return args[0]\n    if len(args) == 2 and args[1].is_int(0):\n        if args[0].is_slice() and args[0].stop == args[0].arg.size and (args[0].size + args[1].size == args[0].arg.size):\n            new_expr = args[0].arg >> ExprInt(args[0].start, args[0].arg.size)\n            return new_expr\n    for (i, arg) in enumerate(args[:-1]):\n        nxt = args[i + 1]\n        if arg.is_mem() and nxt.is_mem():\n            gap = e_s(nxt.ptr - arg.ptr)\n            if gap.is_int() and arg.size % 8 == 0 and (int(gap) == arg.size // 8):\n                args = args[:i] + [ExprMem(arg.ptr, arg.size + nxt.size)] + args[i + 2:]\n                return ExprCompose(*args)\n    if len(args) == 2 and args[0].size == args[1].size:\n        (arg1, arg2) = args\n        size = arg1.size\n        sign_ext = arg1.signExtend(arg1.size * 2)\n        if arg2 == sign_ext[size:2 * size]:\n            return sign_ext\n    conds = set((arg.cond for arg in expr.args if arg.is_cond()))\n    if len(conds) == 1:\n        cond = list(conds)[0]\n        (args1, args2) = ([], [])\n        for arg in expr.args:\n            if arg.is_cond():\n                args1.append(arg.src1)\n                args2.append(arg.src2)\n            else:\n                args1.append(arg)\n                args2.append(arg)\n        arg1 = e_s(ExprCompose(*args1))\n        arg2 = e_s(ExprCompose(*args2))\n        return ExprCond(cond, arg1, arg2)\n    return ExprCompose(*args)",
            "def simp_compose(e_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Commons simplification on ExprCompose'\n    args = merge_sliceto_slice(expr)\n    out = []\n    for arg in args:\n        if arg.is_compose():\n            out += arg.args\n        else:\n            out.append(arg)\n    args = out\n    if len(args) == 1 and args[0].size == expr.size:\n        return args[0]\n    if len(args) == 2 and args[1].is_int(0):\n        if args[0].is_slice() and args[0].stop == args[0].arg.size and (args[0].size + args[1].size == args[0].arg.size):\n            new_expr = args[0].arg >> ExprInt(args[0].start, args[0].arg.size)\n            return new_expr\n    for (i, arg) in enumerate(args[:-1]):\n        nxt = args[i + 1]\n        if arg.is_mem() and nxt.is_mem():\n            gap = e_s(nxt.ptr - arg.ptr)\n            if gap.is_int() and arg.size % 8 == 0 and (int(gap) == arg.size // 8):\n                args = args[:i] + [ExprMem(arg.ptr, arg.size + nxt.size)] + args[i + 2:]\n                return ExprCompose(*args)\n    if len(args) == 2 and args[0].size == args[1].size:\n        (arg1, arg2) = args\n        size = arg1.size\n        sign_ext = arg1.signExtend(arg1.size * 2)\n        if arg2 == sign_ext[size:2 * size]:\n            return sign_ext\n    conds = set((arg.cond for arg in expr.args if arg.is_cond()))\n    if len(conds) == 1:\n        cond = list(conds)[0]\n        (args1, args2) = ([], [])\n        for arg in expr.args:\n            if arg.is_cond():\n                args1.append(arg.src1)\n                args2.append(arg.src2)\n            else:\n                args1.append(arg)\n                args2.append(arg)\n        arg1 = e_s(ExprCompose(*args1))\n        arg2 = e_s(ExprCompose(*args2))\n        return ExprCond(cond, arg1, arg2)\n    return ExprCompose(*args)"
        ]
    },
    {
        "func_name": "simp_cond",
        "original": "def simp_cond(_, expr):\n    \"\"\"\n    Common simplifications on ExprCond.\n    Eval exprcond src1/src2 with satifiable/unsatisfiable condition propagation\n    \"\"\"\n    if not expr.cond.is_int() and expr.cond.size == 1:\n        src1 = expr.src1.replace_expr({expr.cond: ExprInt(1, 1)})\n        src2 = expr.src2.replace_expr({expr.cond: ExprInt(0, 1)})\n        if src1 != expr.src1 or src2 != expr.src2:\n            return ExprCond(expr.cond, src1, src2)\n    if expr.cond.is_op('-') and len(expr.cond.args) == 1:\n        expr = ExprCond(expr.cond.args[0], expr.src1, expr.src2)\n    elif expr.src1 == expr.src2:\n        expr = expr.src1\n    elif expr.cond.is_int():\n        if int(expr.cond) == 0:\n            expr = expr.src2\n        else:\n            expr = expr.src1\n    elif expr.src1.is_cond() and expr.cond == expr.src1.cond:\n        expr = ExprCond(expr.cond, expr.src1.src1, expr.src2)\n    elif expr.src2.is_cond() and expr.cond == expr.src2.cond:\n        expr = ExprCond(expr.cond, expr.src1, expr.src2.src2)\n    elif expr.cond.is_op('|') and expr.cond.args[1].is_int() and (expr.cond.args[1].arg != 0):\n        return expr.src1\n    elif expr.cond.is_cond() and expr.cond.src1.is_int() and expr.cond.src2.is_int():\n        int1 = int(expr.cond.src1)\n        int2 = int(expr.cond.src2)\n        if int1 and int2:\n            expr = expr.src1\n        elif int1 == 0 and int2 == 0:\n            expr = expr.src2\n        elif int1 == 0 and int2:\n            expr = ExprCond(expr.cond.cond, expr.src2, expr.src1)\n        elif int1 and int2 == 0:\n            expr = ExprCond(expr.cond.cond, expr.src1, expr.src2)\n    elif expr.cond.is_compose():\n        args = [arg for arg in expr.cond.args if not arg.is_int(0)]\n        if len(args) == 1:\n            arg = args.pop()\n            return ExprCond(arg, expr.src1, expr.src2)\n        elif len(args) < len(expr.cond.args):\n            return ExprCond(ExprCompose(*args), expr.src1, expr.src2)\n    return expr",
        "mutated": [
            "def simp_cond(_, expr):\n    if False:\n        i = 10\n    '\\n    Common simplifications on ExprCond.\\n    Eval exprcond src1/src2 with satifiable/unsatisfiable condition propagation\\n    '\n    if not expr.cond.is_int() and expr.cond.size == 1:\n        src1 = expr.src1.replace_expr({expr.cond: ExprInt(1, 1)})\n        src2 = expr.src2.replace_expr({expr.cond: ExprInt(0, 1)})\n        if src1 != expr.src1 or src2 != expr.src2:\n            return ExprCond(expr.cond, src1, src2)\n    if expr.cond.is_op('-') and len(expr.cond.args) == 1:\n        expr = ExprCond(expr.cond.args[0], expr.src1, expr.src2)\n    elif expr.src1 == expr.src2:\n        expr = expr.src1\n    elif expr.cond.is_int():\n        if int(expr.cond) == 0:\n            expr = expr.src2\n        else:\n            expr = expr.src1\n    elif expr.src1.is_cond() and expr.cond == expr.src1.cond:\n        expr = ExprCond(expr.cond, expr.src1.src1, expr.src2)\n    elif expr.src2.is_cond() and expr.cond == expr.src2.cond:\n        expr = ExprCond(expr.cond, expr.src1, expr.src2.src2)\n    elif expr.cond.is_op('|') and expr.cond.args[1].is_int() and (expr.cond.args[1].arg != 0):\n        return expr.src1\n    elif expr.cond.is_cond() and expr.cond.src1.is_int() and expr.cond.src2.is_int():\n        int1 = int(expr.cond.src1)\n        int2 = int(expr.cond.src2)\n        if int1 and int2:\n            expr = expr.src1\n        elif int1 == 0 and int2 == 0:\n            expr = expr.src2\n        elif int1 == 0 and int2:\n            expr = ExprCond(expr.cond.cond, expr.src2, expr.src1)\n        elif int1 and int2 == 0:\n            expr = ExprCond(expr.cond.cond, expr.src1, expr.src2)\n    elif expr.cond.is_compose():\n        args = [arg for arg in expr.cond.args if not arg.is_int(0)]\n        if len(args) == 1:\n            arg = args.pop()\n            return ExprCond(arg, expr.src1, expr.src2)\n        elif len(args) < len(expr.cond.args):\n            return ExprCond(ExprCompose(*args), expr.src1, expr.src2)\n    return expr",
            "def simp_cond(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Common simplifications on ExprCond.\\n    Eval exprcond src1/src2 with satifiable/unsatisfiable condition propagation\\n    '\n    if not expr.cond.is_int() and expr.cond.size == 1:\n        src1 = expr.src1.replace_expr({expr.cond: ExprInt(1, 1)})\n        src2 = expr.src2.replace_expr({expr.cond: ExprInt(0, 1)})\n        if src1 != expr.src1 or src2 != expr.src2:\n            return ExprCond(expr.cond, src1, src2)\n    if expr.cond.is_op('-') and len(expr.cond.args) == 1:\n        expr = ExprCond(expr.cond.args[0], expr.src1, expr.src2)\n    elif expr.src1 == expr.src2:\n        expr = expr.src1\n    elif expr.cond.is_int():\n        if int(expr.cond) == 0:\n            expr = expr.src2\n        else:\n            expr = expr.src1\n    elif expr.src1.is_cond() and expr.cond == expr.src1.cond:\n        expr = ExprCond(expr.cond, expr.src1.src1, expr.src2)\n    elif expr.src2.is_cond() and expr.cond == expr.src2.cond:\n        expr = ExprCond(expr.cond, expr.src1, expr.src2.src2)\n    elif expr.cond.is_op('|') and expr.cond.args[1].is_int() and (expr.cond.args[1].arg != 0):\n        return expr.src1\n    elif expr.cond.is_cond() and expr.cond.src1.is_int() and expr.cond.src2.is_int():\n        int1 = int(expr.cond.src1)\n        int2 = int(expr.cond.src2)\n        if int1 and int2:\n            expr = expr.src1\n        elif int1 == 0 and int2 == 0:\n            expr = expr.src2\n        elif int1 == 0 and int2:\n            expr = ExprCond(expr.cond.cond, expr.src2, expr.src1)\n        elif int1 and int2 == 0:\n            expr = ExprCond(expr.cond.cond, expr.src1, expr.src2)\n    elif expr.cond.is_compose():\n        args = [arg for arg in expr.cond.args if not arg.is_int(0)]\n        if len(args) == 1:\n            arg = args.pop()\n            return ExprCond(arg, expr.src1, expr.src2)\n        elif len(args) < len(expr.cond.args):\n            return ExprCond(ExprCompose(*args), expr.src1, expr.src2)\n    return expr",
            "def simp_cond(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Common simplifications on ExprCond.\\n    Eval exprcond src1/src2 with satifiable/unsatisfiable condition propagation\\n    '\n    if not expr.cond.is_int() and expr.cond.size == 1:\n        src1 = expr.src1.replace_expr({expr.cond: ExprInt(1, 1)})\n        src2 = expr.src2.replace_expr({expr.cond: ExprInt(0, 1)})\n        if src1 != expr.src1 or src2 != expr.src2:\n            return ExprCond(expr.cond, src1, src2)\n    if expr.cond.is_op('-') and len(expr.cond.args) == 1:\n        expr = ExprCond(expr.cond.args[0], expr.src1, expr.src2)\n    elif expr.src1 == expr.src2:\n        expr = expr.src1\n    elif expr.cond.is_int():\n        if int(expr.cond) == 0:\n            expr = expr.src2\n        else:\n            expr = expr.src1\n    elif expr.src1.is_cond() and expr.cond == expr.src1.cond:\n        expr = ExprCond(expr.cond, expr.src1.src1, expr.src2)\n    elif expr.src2.is_cond() and expr.cond == expr.src2.cond:\n        expr = ExprCond(expr.cond, expr.src1, expr.src2.src2)\n    elif expr.cond.is_op('|') and expr.cond.args[1].is_int() and (expr.cond.args[1].arg != 0):\n        return expr.src1\n    elif expr.cond.is_cond() and expr.cond.src1.is_int() and expr.cond.src2.is_int():\n        int1 = int(expr.cond.src1)\n        int2 = int(expr.cond.src2)\n        if int1 and int2:\n            expr = expr.src1\n        elif int1 == 0 and int2 == 0:\n            expr = expr.src2\n        elif int1 == 0 and int2:\n            expr = ExprCond(expr.cond.cond, expr.src2, expr.src1)\n        elif int1 and int2 == 0:\n            expr = ExprCond(expr.cond.cond, expr.src1, expr.src2)\n    elif expr.cond.is_compose():\n        args = [arg for arg in expr.cond.args if not arg.is_int(0)]\n        if len(args) == 1:\n            arg = args.pop()\n            return ExprCond(arg, expr.src1, expr.src2)\n        elif len(args) < len(expr.cond.args):\n            return ExprCond(ExprCompose(*args), expr.src1, expr.src2)\n    return expr",
            "def simp_cond(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Common simplifications on ExprCond.\\n    Eval exprcond src1/src2 with satifiable/unsatisfiable condition propagation\\n    '\n    if not expr.cond.is_int() and expr.cond.size == 1:\n        src1 = expr.src1.replace_expr({expr.cond: ExprInt(1, 1)})\n        src2 = expr.src2.replace_expr({expr.cond: ExprInt(0, 1)})\n        if src1 != expr.src1 or src2 != expr.src2:\n            return ExprCond(expr.cond, src1, src2)\n    if expr.cond.is_op('-') and len(expr.cond.args) == 1:\n        expr = ExprCond(expr.cond.args[0], expr.src1, expr.src2)\n    elif expr.src1 == expr.src2:\n        expr = expr.src1\n    elif expr.cond.is_int():\n        if int(expr.cond) == 0:\n            expr = expr.src2\n        else:\n            expr = expr.src1\n    elif expr.src1.is_cond() and expr.cond == expr.src1.cond:\n        expr = ExprCond(expr.cond, expr.src1.src1, expr.src2)\n    elif expr.src2.is_cond() and expr.cond == expr.src2.cond:\n        expr = ExprCond(expr.cond, expr.src1, expr.src2.src2)\n    elif expr.cond.is_op('|') and expr.cond.args[1].is_int() and (expr.cond.args[1].arg != 0):\n        return expr.src1\n    elif expr.cond.is_cond() and expr.cond.src1.is_int() and expr.cond.src2.is_int():\n        int1 = int(expr.cond.src1)\n        int2 = int(expr.cond.src2)\n        if int1 and int2:\n            expr = expr.src1\n        elif int1 == 0 and int2 == 0:\n            expr = expr.src2\n        elif int1 == 0 and int2:\n            expr = ExprCond(expr.cond.cond, expr.src2, expr.src1)\n        elif int1 and int2 == 0:\n            expr = ExprCond(expr.cond.cond, expr.src1, expr.src2)\n    elif expr.cond.is_compose():\n        args = [arg for arg in expr.cond.args if not arg.is_int(0)]\n        if len(args) == 1:\n            arg = args.pop()\n            return ExprCond(arg, expr.src1, expr.src2)\n        elif len(args) < len(expr.cond.args):\n            return ExprCond(ExprCompose(*args), expr.src1, expr.src2)\n    return expr",
            "def simp_cond(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Common simplifications on ExprCond.\\n    Eval exprcond src1/src2 with satifiable/unsatisfiable condition propagation\\n    '\n    if not expr.cond.is_int() and expr.cond.size == 1:\n        src1 = expr.src1.replace_expr({expr.cond: ExprInt(1, 1)})\n        src2 = expr.src2.replace_expr({expr.cond: ExprInt(0, 1)})\n        if src1 != expr.src1 or src2 != expr.src2:\n            return ExprCond(expr.cond, src1, src2)\n    if expr.cond.is_op('-') and len(expr.cond.args) == 1:\n        expr = ExprCond(expr.cond.args[0], expr.src1, expr.src2)\n    elif expr.src1 == expr.src2:\n        expr = expr.src1\n    elif expr.cond.is_int():\n        if int(expr.cond) == 0:\n            expr = expr.src2\n        else:\n            expr = expr.src1\n    elif expr.src1.is_cond() and expr.cond == expr.src1.cond:\n        expr = ExprCond(expr.cond, expr.src1.src1, expr.src2)\n    elif expr.src2.is_cond() and expr.cond == expr.src2.cond:\n        expr = ExprCond(expr.cond, expr.src1, expr.src2.src2)\n    elif expr.cond.is_op('|') and expr.cond.args[1].is_int() and (expr.cond.args[1].arg != 0):\n        return expr.src1\n    elif expr.cond.is_cond() and expr.cond.src1.is_int() and expr.cond.src2.is_int():\n        int1 = int(expr.cond.src1)\n        int2 = int(expr.cond.src2)\n        if int1 and int2:\n            expr = expr.src1\n        elif int1 == 0 and int2 == 0:\n            expr = expr.src2\n        elif int1 == 0 and int2:\n            expr = ExprCond(expr.cond.cond, expr.src2, expr.src1)\n        elif int1 and int2 == 0:\n            expr = ExprCond(expr.cond.cond, expr.src1, expr.src2)\n    elif expr.cond.is_compose():\n        args = [arg for arg in expr.cond.args if not arg.is_int(0)]\n        if len(args) == 1:\n            arg = args.pop()\n            return ExprCond(arg, expr.src1, expr.src2)\n        elif len(args) < len(expr.cond.args):\n            return ExprCond(ExprCompose(*args), expr.src1, expr.src2)\n    return expr"
        ]
    },
    {
        "func_name": "simp_mem",
        "original": "def simp_mem(_, expr):\n    \"\"\"\n    Common simplifications on ExprMem:\n    @32[x?a:b] => x?@32[a]:@32[b]\n    \"\"\"\n    if expr.ptr.is_cond():\n        cond = expr.ptr\n        ret = ExprCond(cond.cond, ExprMem(cond.src1, expr.size), ExprMem(cond.src2, expr.size))\n        return ret\n    return expr",
        "mutated": [
            "def simp_mem(_, expr):\n    if False:\n        i = 10\n    '\\n    Common simplifications on ExprMem:\\n    @32[x?a:b] => x?@32[a]:@32[b]\\n    '\n    if expr.ptr.is_cond():\n        cond = expr.ptr\n        ret = ExprCond(cond.cond, ExprMem(cond.src1, expr.size), ExprMem(cond.src2, expr.size))\n        return ret\n    return expr",
            "def simp_mem(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Common simplifications on ExprMem:\\n    @32[x?a:b] => x?@32[a]:@32[b]\\n    '\n    if expr.ptr.is_cond():\n        cond = expr.ptr\n        ret = ExprCond(cond.cond, ExprMem(cond.src1, expr.size), ExprMem(cond.src2, expr.size))\n        return ret\n    return expr",
            "def simp_mem(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Common simplifications on ExprMem:\\n    @32[x?a:b] => x?@32[a]:@32[b]\\n    '\n    if expr.ptr.is_cond():\n        cond = expr.ptr\n        ret = ExprCond(cond.cond, ExprMem(cond.src1, expr.size), ExprMem(cond.src2, expr.size))\n        return ret\n    return expr",
            "def simp_mem(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Common simplifications on ExprMem:\\n    @32[x?a:b] => x?@32[a]:@32[b]\\n    '\n    if expr.ptr.is_cond():\n        cond = expr.ptr\n        ret = ExprCond(cond.cond, ExprMem(cond.src1, expr.size), ExprMem(cond.src2, expr.size))\n        return ret\n    return expr",
            "def simp_mem(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Common simplifications on ExprMem:\\n    @32[x?a:b] => x?@32[a]:@32[b]\\n    '\n    if expr.ptr.is_cond():\n        cond = expr.ptr\n        ret = ExprCond(cond.cond, ExprMem(cond.src1, expr.size), ExprMem(cond.src2, expr.size))\n        return ret\n    return expr"
        ]
    },
    {
        "func_name": "test_cc_eq_args",
        "original": "def test_cc_eq_args(expr, *sons_op):\n    \"\"\"\n    Return True if expression's arguments match the list in sons_op, and their\n    sub arguments are identical. Ex:\n    CC_S<=(\n              FLAG_SIGN_SUB(A, B),\n              FLAG_SUB_OF(A, B),\n              FLAG_EQ_CMP(A, B)\n    )\n    \"\"\"\n    if not expr.is_op():\n        return False\n    if len(expr.args) != len(sons_op):\n        return False\n    all_args = set()\n    for (i, arg) in enumerate(expr.args):\n        if not arg.is_op(sons_op[i]):\n            return False\n        all_args.add(arg.args)\n    return len(all_args) == 1",
        "mutated": [
            "def test_cc_eq_args(expr, *sons_op):\n    if False:\n        i = 10\n    \"\\n    Return True if expression's arguments match the list in sons_op, and their\\n    sub arguments are identical. Ex:\\n    CC_S<=(\\n              FLAG_SIGN_SUB(A, B),\\n              FLAG_SUB_OF(A, B),\\n              FLAG_EQ_CMP(A, B)\\n    )\\n    \"\n    if not expr.is_op():\n        return False\n    if len(expr.args) != len(sons_op):\n        return False\n    all_args = set()\n    for (i, arg) in enumerate(expr.args):\n        if not arg.is_op(sons_op[i]):\n            return False\n        all_args.add(arg.args)\n    return len(all_args) == 1",
            "def test_cc_eq_args(expr, *sons_op):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Return True if expression's arguments match the list in sons_op, and their\\n    sub arguments are identical. Ex:\\n    CC_S<=(\\n              FLAG_SIGN_SUB(A, B),\\n              FLAG_SUB_OF(A, B),\\n              FLAG_EQ_CMP(A, B)\\n    )\\n    \"\n    if not expr.is_op():\n        return False\n    if len(expr.args) != len(sons_op):\n        return False\n    all_args = set()\n    for (i, arg) in enumerate(expr.args):\n        if not arg.is_op(sons_op[i]):\n            return False\n        all_args.add(arg.args)\n    return len(all_args) == 1",
            "def test_cc_eq_args(expr, *sons_op):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Return True if expression's arguments match the list in sons_op, and their\\n    sub arguments are identical. Ex:\\n    CC_S<=(\\n              FLAG_SIGN_SUB(A, B),\\n              FLAG_SUB_OF(A, B),\\n              FLAG_EQ_CMP(A, B)\\n    )\\n    \"\n    if not expr.is_op():\n        return False\n    if len(expr.args) != len(sons_op):\n        return False\n    all_args = set()\n    for (i, arg) in enumerate(expr.args):\n        if not arg.is_op(sons_op[i]):\n            return False\n        all_args.add(arg.args)\n    return len(all_args) == 1",
            "def test_cc_eq_args(expr, *sons_op):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Return True if expression's arguments match the list in sons_op, and their\\n    sub arguments are identical. Ex:\\n    CC_S<=(\\n              FLAG_SIGN_SUB(A, B),\\n              FLAG_SUB_OF(A, B),\\n              FLAG_EQ_CMP(A, B)\\n    )\\n    \"\n    if not expr.is_op():\n        return False\n    if len(expr.args) != len(sons_op):\n        return False\n    all_args = set()\n    for (i, arg) in enumerate(expr.args):\n        if not arg.is_op(sons_op[i]):\n            return False\n        all_args.add(arg.args)\n    return len(all_args) == 1",
            "def test_cc_eq_args(expr, *sons_op):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Return True if expression's arguments match the list in sons_op, and their\\n    sub arguments are identical. Ex:\\n    CC_S<=(\\n              FLAG_SIGN_SUB(A, B),\\n              FLAG_SUB_OF(A, B),\\n              FLAG_EQ_CMP(A, B)\\n    )\\n    \"\n    if not expr.is_op():\n        return False\n    if len(expr.args) != len(sons_op):\n        return False\n    all_args = set()\n    for (i, arg) in enumerate(expr.args):\n        if not arg.is_op(sons_op[i]):\n            return False\n        all_args.add(arg.args)\n    return len(all_args) == 1"
        ]
    },
    {
        "func_name": "simp_cc_conds",
        "original": "def simp_cc_conds(_, expr):\n    \"\"\"\n    High level simplifications. Example:\n    CC_U<(FLAG_SUB_CF(A, B) => A <u B\n    \"\"\"\n    if expr.is_op('CC_U>=') and test_cc_eq_args(expr, 'FLAG_SUB_CF'):\n        expr = ExprCond(ExprOp(TOK_INF_UNSIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_U<') and test_cc_eq_args(expr, 'FLAG_SUB_CF'):\n        expr = ExprOp(TOK_INF_UNSIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_NEG') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB'):\n        expr = ExprOp(TOK_INF_SIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_POS') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB'):\n        expr = ExprCond(ExprOp(TOK_INF_SIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_EQ') and test_cc_eq_args(expr, 'FLAG_EQ'):\n        arg = expr.args[0].args[0]\n        expr = ExprOp(TOK_EQUAL, arg, ExprInt(0, arg.size))\n    elif expr.is_op('CC_NE') and test_cc_eq_args(expr, 'FLAG_EQ'):\n        arg = expr.args[0].args[0]\n        expr = ExprCond(ExprOp(TOK_EQUAL, arg, ExprInt(0, arg.size)), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_NE') and test_cc_eq_args(expr, 'FLAG_EQ_CMP'):\n        expr = ExprCond(ExprOp(TOK_EQUAL, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_EQ') and test_cc_eq_args(expr, 'FLAG_EQ_CMP'):\n        expr = ExprOp(TOK_EQUAL, *expr.args[0].args)\n    elif expr.is_op('CC_NE') and test_cc_eq_args(expr, 'FLAG_EQ_AND'):\n        expr = ExprOp('&', *expr.args[0].args)\n    elif expr.is_op('CC_EQ') and test_cc_eq_args(expr, 'FLAG_EQ_AND'):\n        expr = ExprCond(ExprOp('&', *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S>') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB', 'FLAG_SUB_OF', 'FLAG_EQ_CMP'):\n        expr = ExprCond(ExprOp(TOK_INF_EQUAL_SIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S>') and len(expr.args) == 3 and expr.args[0].is_op('FLAG_SIGN_SUB') and expr.args[2].is_op('FLAG_EQ_CMP') and (expr.args[0].args == expr.args[2].args) and expr.args[1].is_int(0):\n        expr = ExprCond(ExprOp(TOK_INF_EQUAL_SIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S>=') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB', 'FLAG_SUB_OF'):\n        expr = ExprCond(ExprOp(TOK_INF_SIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S>=') and len(expr.args) == 2 and expr.args[0].is_op('FLAG_SIGN_SUB') and expr.args[0].args[1].is_int(0) and expr.args[1].is_int(0):\n        expr = ExprOp(TOK_INF_EQUAL_SIGNED, expr.args[0].args[1], expr.args[0].args[0])\n    elif expr.is_op('CC_S<') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB', 'FLAG_SUB_OF'):\n        expr = ExprOp(TOK_INF_SIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_S<=') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB', 'FLAG_SUB_OF', 'FLAG_EQ_CMP'):\n        expr = ExprOp(TOK_INF_EQUAL_SIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_S<=') and len(expr.args) == 3 and expr.args[0].is_op('FLAG_SIGN_SUB') and expr.args[2].is_op('FLAG_EQ_CMP') and (expr.args[0].args == expr.args[2].args) and expr.args[1].is_int(0):\n        expr = ExprOp(TOK_INF_EQUAL_SIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_U<=') and test_cc_eq_args(expr, 'FLAG_SUB_CF', 'FLAG_EQ_CMP'):\n        expr = ExprOp(TOK_INF_EQUAL_UNSIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_U>') and test_cc_eq_args(expr, 'FLAG_SUB_CF', 'FLAG_EQ_CMP'):\n        expr = ExprCond(ExprOp(TOK_INF_EQUAL_UNSIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S<') and test_cc_eq_args(expr, 'FLAG_SIGN_ADD', 'FLAG_ADD_OF'):\n        (arg0, arg1) = expr.args[0].args\n        expr = ExprOp(TOK_INF_SIGNED, arg0, -arg1)\n    return expr",
        "mutated": [
            "def simp_cc_conds(_, expr):\n    if False:\n        i = 10\n    '\\n    High level simplifications. Example:\\n    CC_U<(FLAG_SUB_CF(A, B) => A <u B\\n    '\n    if expr.is_op('CC_U>=') and test_cc_eq_args(expr, 'FLAG_SUB_CF'):\n        expr = ExprCond(ExprOp(TOK_INF_UNSIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_U<') and test_cc_eq_args(expr, 'FLAG_SUB_CF'):\n        expr = ExprOp(TOK_INF_UNSIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_NEG') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB'):\n        expr = ExprOp(TOK_INF_SIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_POS') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB'):\n        expr = ExprCond(ExprOp(TOK_INF_SIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_EQ') and test_cc_eq_args(expr, 'FLAG_EQ'):\n        arg = expr.args[0].args[0]\n        expr = ExprOp(TOK_EQUAL, arg, ExprInt(0, arg.size))\n    elif expr.is_op('CC_NE') and test_cc_eq_args(expr, 'FLAG_EQ'):\n        arg = expr.args[0].args[0]\n        expr = ExprCond(ExprOp(TOK_EQUAL, arg, ExprInt(0, arg.size)), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_NE') and test_cc_eq_args(expr, 'FLAG_EQ_CMP'):\n        expr = ExprCond(ExprOp(TOK_EQUAL, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_EQ') and test_cc_eq_args(expr, 'FLAG_EQ_CMP'):\n        expr = ExprOp(TOK_EQUAL, *expr.args[0].args)\n    elif expr.is_op('CC_NE') and test_cc_eq_args(expr, 'FLAG_EQ_AND'):\n        expr = ExprOp('&', *expr.args[0].args)\n    elif expr.is_op('CC_EQ') and test_cc_eq_args(expr, 'FLAG_EQ_AND'):\n        expr = ExprCond(ExprOp('&', *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S>') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB', 'FLAG_SUB_OF', 'FLAG_EQ_CMP'):\n        expr = ExprCond(ExprOp(TOK_INF_EQUAL_SIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S>') and len(expr.args) == 3 and expr.args[0].is_op('FLAG_SIGN_SUB') and expr.args[2].is_op('FLAG_EQ_CMP') and (expr.args[0].args == expr.args[2].args) and expr.args[1].is_int(0):\n        expr = ExprCond(ExprOp(TOK_INF_EQUAL_SIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S>=') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB', 'FLAG_SUB_OF'):\n        expr = ExprCond(ExprOp(TOK_INF_SIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S>=') and len(expr.args) == 2 and expr.args[0].is_op('FLAG_SIGN_SUB') and expr.args[0].args[1].is_int(0) and expr.args[1].is_int(0):\n        expr = ExprOp(TOK_INF_EQUAL_SIGNED, expr.args[0].args[1], expr.args[0].args[0])\n    elif expr.is_op('CC_S<') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB', 'FLAG_SUB_OF'):\n        expr = ExprOp(TOK_INF_SIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_S<=') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB', 'FLAG_SUB_OF', 'FLAG_EQ_CMP'):\n        expr = ExprOp(TOK_INF_EQUAL_SIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_S<=') and len(expr.args) == 3 and expr.args[0].is_op('FLAG_SIGN_SUB') and expr.args[2].is_op('FLAG_EQ_CMP') and (expr.args[0].args == expr.args[2].args) and expr.args[1].is_int(0):\n        expr = ExprOp(TOK_INF_EQUAL_SIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_U<=') and test_cc_eq_args(expr, 'FLAG_SUB_CF', 'FLAG_EQ_CMP'):\n        expr = ExprOp(TOK_INF_EQUAL_UNSIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_U>') and test_cc_eq_args(expr, 'FLAG_SUB_CF', 'FLAG_EQ_CMP'):\n        expr = ExprCond(ExprOp(TOK_INF_EQUAL_UNSIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S<') and test_cc_eq_args(expr, 'FLAG_SIGN_ADD', 'FLAG_ADD_OF'):\n        (arg0, arg1) = expr.args[0].args\n        expr = ExprOp(TOK_INF_SIGNED, arg0, -arg1)\n    return expr",
            "def simp_cc_conds(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    High level simplifications. Example:\\n    CC_U<(FLAG_SUB_CF(A, B) => A <u B\\n    '\n    if expr.is_op('CC_U>=') and test_cc_eq_args(expr, 'FLAG_SUB_CF'):\n        expr = ExprCond(ExprOp(TOK_INF_UNSIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_U<') and test_cc_eq_args(expr, 'FLAG_SUB_CF'):\n        expr = ExprOp(TOK_INF_UNSIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_NEG') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB'):\n        expr = ExprOp(TOK_INF_SIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_POS') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB'):\n        expr = ExprCond(ExprOp(TOK_INF_SIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_EQ') and test_cc_eq_args(expr, 'FLAG_EQ'):\n        arg = expr.args[0].args[0]\n        expr = ExprOp(TOK_EQUAL, arg, ExprInt(0, arg.size))\n    elif expr.is_op('CC_NE') and test_cc_eq_args(expr, 'FLAG_EQ'):\n        arg = expr.args[0].args[0]\n        expr = ExprCond(ExprOp(TOK_EQUAL, arg, ExprInt(0, arg.size)), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_NE') and test_cc_eq_args(expr, 'FLAG_EQ_CMP'):\n        expr = ExprCond(ExprOp(TOK_EQUAL, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_EQ') and test_cc_eq_args(expr, 'FLAG_EQ_CMP'):\n        expr = ExprOp(TOK_EQUAL, *expr.args[0].args)\n    elif expr.is_op('CC_NE') and test_cc_eq_args(expr, 'FLAG_EQ_AND'):\n        expr = ExprOp('&', *expr.args[0].args)\n    elif expr.is_op('CC_EQ') and test_cc_eq_args(expr, 'FLAG_EQ_AND'):\n        expr = ExprCond(ExprOp('&', *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S>') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB', 'FLAG_SUB_OF', 'FLAG_EQ_CMP'):\n        expr = ExprCond(ExprOp(TOK_INF_EQUAL_SIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S>') and len(expr.args) == 3 and expr.args[0].is_op('FLAG_SIGN_SUB') and expr.args[2].is_op('FLAG_EQ_CMP') and (expr.args[0].args == expr.args[2].args) and expr.args[1].is_int(0):\n        expr = ExprCond(ExprOp(TOK_INF_EQUAL_SIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S>=') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB', 'FLAG_SUB_OF'):\n        expr = ExprCond(ExprOp(TOK_INF_SIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S>=') and len(expr.args) == 2 and expr.args[0].is_op('FLAG_SIGN_SUB') and expr.args[0].args[1].is_int(0) and expr.args[1].is_int(0):\n        expr = ExprOp(TOK_INF_EQUAL_SIGNED, expr.args[0].args[1], expr.args[0].args[0])\n    elif expr.is_op('CC_S<') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB', 'FLAG_SUB_OF'):\n        expr = ExprOp(TOK_INF_SIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_S<=') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB', 'FLAG_SUB_OF', 'FLAG_EQ_CMP'):\n        expr = ExprOp(TOK_INF_EQUAL_SIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_S<=') and len(expr.args) == 3 and expr.args[0].is_op('FLAG_SIGN_SUB') and expr.args[2].is_op('FLAG_EQ_CMP') and (expr.args[0].args == expr.args[2].args) and expr.args[1].is_int(0):\n        expr = ExprOp(TOK_INF_EQUAL_SIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_U<=') and test_cc_eq_args(expr, 'FLAG_SUB_CF', 'FLAG_EQ_CMP'):\n        expr = ExprOp(TOK_INF_EQUAL_UNSIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_U>') and test_cc_eq_args(expr, 'FLAG_SUB_CF', 'FLAG_EQ_CMP'):\n        expr = ExprCond(ExprOp(TOK_INF_EQUAL_UNSIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S<') and test_cc_eq_args(expr, 'FLAG_SIGN_ADD', 'FLAG_ADD_OF'):\n        (arg0, arg1) = expr.args[0].args\n        expr = ExprOp(TOK_INF_SIGNED, arg0, -arg1)\n    return expr",
            "def simp_cc_conds(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    High level simplifications. Example:\\n    CC_U<(FLAG_SUB_CF(A, B) => A <u B\\n    '\n    if expr.is_op('CC_U>=') and test_cc_eq_args(expr, 'FLAG_SUB_CF'):\n        expr = ExprCond(ExprOp(TOK_INF_UNSIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_U<') and test_cc_eq_args(expr, 'FLAG_SUB_CF'):\n        expr = ExprOp(TOK_INF_UNSIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_NEG') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB'):\n        expr = ExprOp(TOK_INF_SIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_POS') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB'):\n        expr = ExprCond(ExprOp(TOK_INF_SIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_EQ') and test_cc_eq_args(expr, 'FLAG_EQ'):\n        arg = expr.args[0].args[0]\n        expr = ExprOp(TOK_EQUAL, arg, ExprInt(0, arg.size))\n    elif expr.is_op('CC_NE') and test_cc_eq_args(expr, 'FLAG_EQ'):\n        arg = expr.args[0].args[0]\n        expr = ExprCond(ExprOp(TOK_EQUAL, arg, ExprInt(0, arg.size)), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_NE') and test_cc_eq_args(expr, 'FLAG_EQ_CMP'):\n        expr = ExprCond(ExprOp(TOK_EQUAL, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_EQ') and test_cc_eq_args(expr, 'FLAG_EQ_CMP'):\n        expr = ExprOp(TOK_EQUAL, *expr.args[0].args)\n    elif expr.is_op('CC_NE') and test_cc_eq_args(expr, 'FLAG_EQ_AND'):\n        expr = ExprOp('&', *expr.args[0].args)\n    elif expr.is_op('CC_EQ') and test_cc_eq_args(expr, 'FLAG_EQ_AND'):\n        expr = ExprCond(ExprOp('&', *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S>') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB', 'FLAG_SUB_OF', 'FLAG_EQ_CMP'):\n        expr = ExprCond(ExprOp(TOK_INF_EQUAL_SIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S>') and len(expr.args) == 3 and expr.args[0].is_op('FLAG_SIGN_SUB') and expr.args[2].is_op('FLAG_EQ_CMP') and (expr.args[0].args == expr.args[2].args) and expr.args[1].is_int(0):\n        expr = ExprCond(ExprOp(TOK_INF_EQUAL_SIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S>=') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB', 'FLAG_SUB_OF'):\n        expr = ExprCond(ExprOp(TOK_INF_SIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S>=') and len(expr.args) == 2 and expr.args[0].is_op('FLAG_SIGN_SUB') and expr.args[0].args[1].is_int(0) and expr.args[1].is_int(0):\n        expr = ExprOp(TOK_INF_EQUAL_SIGNED, expr.args[0].args[1], expr.args[0].args[0])\n    elif expr.is_op('CC_S<') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB', 'FLAG_SUB_OF'):\n        expr = ExprOp(TOK_INF_SIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_S<=') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB', 'FLAG_SUB_OF', 'FLAG_EQ_CMP'):\n        expr = ExprOp(TOK_INF_EQUAL_SIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_S<=') and len(expr.args) == 3 and expr.args[0].is_op('FLAG_SIGN_SUB') and expr.args[2].is_op('FLAG_EQ_CMP') and (expr.args[0].args == expr.args[2].args) and expr.args[1].is_int(0):\n        expr = ExprOp(TOK_INF_EQUAL_SIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_U<=') and test_cc_eq_args(expr, 'FLAG_SUB_CF', 'FLAG_EQ_CMP'):\n        expr = ExprOp(TOK_INF_EQUAL_UNSIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_U>') and test_cc_eq_args(expr, 'FLAG_SUB_CF', 'FLAG_EQ_CMP'):\n        expr = ExprCond(ExprOp(TOK_INF_EQUAL_UNSIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S<') and test_cc_eq_args(expr, 'FLAG_SIGN_ADD', 'FLAG_ADD_OF'):\n        (arg0, arg1) = expr.args[0].args\n        expr = ExprOp(TOK_INF_SIGNED, arg0, -arg1)\n    return expr",
            "def simp_cc_conds(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    High level simplifications. Example:\\n    CC_U<(FLAG_SUB_CF(A, B) => A <u B\\n    '\n    if expr.is_op('CC_U>=') and test_cc_eq_args(expr, 'FLAG_SUB_CF'):\n        expr = ExprCond(ExprOp(TOK_INF_UNSIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_U<') and test_cc_eq_args(expr, 'FLAG_SUB_CF'):\n        expr = ExprOp(TOK_INF_UNSIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_NEG') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB'):\n        expr = ExprOp(TOK_INF_SIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_POS') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB'):\n        expr = ExprCond(ExprOp(TOK_INF_SIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_EQ') and test_cc_eq_args(expr, 'FLAG_EQ'):\n        arg = expr.args[0].args[0]\n        expr = ExprOp(TOK_EQUAL, arg, ExprInt(0, arg.size))\n    elif expr.is_op('CC_NE') and test_cc_eq_args(expr, 'FLAG_EQ'):\n        arg = expr.args[0].args[0]\n        expr = ExprCond(ExprOp(TOK_EQUAL, arg, ExprInt(0, arg.size)), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_NE') and test_cc_eq_args(expr, 'FLAG_EQ_CMP'):\n        expr = ExprCond(ExprOp(TOK_EQUAL, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_EQ') and test_cc_eq_args(expr, 'FLAG_EQ_CMP'):\n        expr = ExprOp(TOK_EQUAL, *expr.args[0].args)\n    elif expr.is_op('CC_NE') and test_cc_eq_args(expr, 'FLAG_EQ_AND'):\n        expr = ExprOp('&', *expr.args[0].args)\n    elif expr.is_op('CC_EQ') and test_cc_eq_args(expr, 'FLAG_EQ_AND'):\n        expr = ExprCond(ExprOp('&', *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S>') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB', 'FLAG_SUB_OF', 'FLAG_EQ_CMP'):\n        expr = ExprCond(ExprOp(TOK_INF_EQUAL_SIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S>') and len(expr.args) == 3 and expr.args[0].is_op('FLAG_SIGN_SUB') and expr.args[2].is_op('FLAG_EQ_CMP') and (expr.args[0].args == expr.args[2].args) and expr.args[1].is_int(0):\n        expr = ExprCond(ExprOp(TOK_INF_EQUAL_SIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S>=') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB', 'FLAG_SUB_OF'):\n        expr = ExprCond(ExprOp(TOK_INF_SIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S>=') and len(expr.args) == 2 and expr.args[0].is_op('FLAG_SIGN_SUB') and expr.args[0].args[1].is_int(0) and expr.args[1].is_int(0):\n        expr = ExprOp(TOK_INF_EQUAL_SIGNED, expr.args[0].args[1], expr.args[0].args[0])\n    elif expr.is_op('CC_S<') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB', 'FLAG_SUB_OF'):\n        expr = ExprOp(TOK_INF_SIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_S<=') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB', 'FLAG_SUB_OF', 'FLAG_EQ_CMP'):\n        expr = ExprOp(TOK_INF_EQUAL_SIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_S<=') and len(expr.args) == 3 and expr.args[0].is_op('FLAG_SIGN_SUB') and expr.args[2].is_op('FLAG_EQ_CMP') and (expr.args[0].args == expr.args[2].args) and expr.args[1].is_int(0):\n        expr = ExprOp(TOK_INF_EQUAL_SIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_U<=') and test_cc_eq_args(expr, 'FLAG_SUB_CF', 'FLAG_EQ_CMP'):\n        expr = ExprOp(TOK_INF_EQUAL_UNSIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_U>') and test_cc_eq_args(expr, 'FLAG_SUB_CF', 'FLAG_EQ_CMP'):\n        expr = ExprCond(ExprOp(TOK_INF_EQUAL_UNSIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S<') and test_cc_eq_args(expr, 'FLAG_SIGN_ADD', 'FLAG_ADD_OF'):\n        (arg0, arg1) = expr.args[0].args\n        expr = ExprOp(TOK_INF_SIGNED, arg0, -arg1)\n    return expr",
            "def simp_cc_conds(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    High level simplifications. Example:\\n    CC_U<(FLAG_SUB_CF(A, B) => A <u B\\n    '\n    if expr.is_op('CC_U>=') and test_cc_eq_args(expr, 'FLAG_SUB_CF'):\n        expr = ExprCond(ExprOp(TOK_INF_UNSIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_U<') and test_cc_eq_args(expr, 'FLAG_SUB_CF'):\n        expr = ExprOp(TOK_INF_UNSIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_NEG') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB'):\n        expr = ExprOp(TOK_INF_SIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_POS') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB'):\n        expr = ExprCond(ExprOp(TOK_INF_SIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_EQ') and test_cc_eq_args(expr, 'FLAG_EQ'):\n        arg = expr.args[0].args[0]\n        expr = ExprOp(TOK_EQUAL, arg, ExprInt(0, arg.size))\n    elif expr.is_op('CC_NE') and test_cc_eq_args(expr, 'FLAG_EQ'):\n        arg = expr.args[0].args[0]\n        expr = ExprCond(ExprOp(TOK_EQUAL, arg, ExprInt(0, arg.size)), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_NE') and test_cc_eq_args(expr, 'FLAG_EQ_CMP'):\n        expr = ExprCond(ExprOp(TOK_EQUAL, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_EQ') and test_cc_eq_args(expr, 'FLAG_EQ_CMP'):\n        expr = ExprOp(TOK_EQUAL, *expr.args[0].args)\n    elif expr.is_op('CC_NE') and test_cc_eq_args(expr, 'FLAG_EQ_AND'):\n        expr = ExprOp('&', *expr.args[0].args)\n    elif expr.is_op('CC_EQ') and test_cc_eq_args(expr, 'FLAG_EQ_AND'):\n        expr = ExprCond(ExprOp('&', *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S>') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB', 'FLAG_SUB_OF', 'FLAG_EQ_CMP'):\n        expr = ExprCond(ExprOp(TOK_INF_EQUAL_SIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S>') and len(expr.args) == 3 and expr.args[0].is_op('FLAG_SIGN_SUB') and expr.args[2].is_op('FLAG_EQ_CMP') and (expr.args[0].args == expr.args[2].args) and expr.args[1].is_int(0):\n        expr = ExprCond(ExprOp(TOK_INF_EQUAL_SIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S>=') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB', 'FLAG_SUB_OF'):\n        expr = ExprCond(ExprOp(TOK_INF_SIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S>=') and len(expr.args) == 2 and expr.args[0].is_op('FLAG_SIGN_SUB') and expr.args[0].args[1].is_int(0) and expr.args[1].is_int(0):\n        expr = ExprOp(TOK_INF_EQUAL_SIGNED, expr.args[0].args[1], expr.args[0].args[0])\n    elif expr.is_op('CC_S<') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB', 'FLAG_SUB_OF'):\n        expr = ExprOp(TOK_INF_SIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_S<=') and test_cc_eq_args(expr, 'FLAG_SIGN_SUB', 'FLAG_SUB_OF', 'FLAG_EQ_CMP'):\n        expr = ExprOp(TOK_INF_EQUAL_SIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_S<=') and len(expr.args) == 3 and expr.args[0].is_op('FLAG_SIGN_SUB') and expr.args[2].is_op('FLAG_EQ_CMP') and (expr.args[0].args == expr.args[2].args) and expr.args[1].is_int(0):\n        expr = ExprOp(TOK_INF_EQUAL_SIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_U<=') and test_cc_eq_args(expr, 'FLAG_SUB_CF', 'FLAG_EQ_CMP'):\n        expr = ExprOp(TOK_INF_EQUAL_UNSIGNED, *expr.args[0].args)\n    elif expr.is_op('CC_U>') and test_cc_eq_args(expr, 'FLAG_SUB_CF', 'FLAG_EQ_CMP'):\n        expr = ExprCond(ExprOp(TOK_INF_EQUAL_UNSIGNED, *expr.args[0].args), ExprInt(0, expr.size), ExprInt(1, expr.size))\n    elif expr.is_op('CC_S<') and test_cc_eq_args(expr, 'FLAG_SIGN_ADD', 'FLAG_ADD_OF'):\n        (arg0, arg1) = expr.args[0].args\n        expr = ExprOp(TOK_INF_SIGNED, arg0, -arg1)\n    return expr"
        ]
    },
    {
        "func_name": "simp_cond_flag",
        "original": "def simp_cond_flag(_, expr):\n    \"\"\"FLAG_EQ_CMP(X, Y)?A:B => (X == Y)?A:B\"\"\"\n    cond = expr.cond\n    if cond.is_op('FLAG_EQ_CMP'):\n        return ExprCond(ExprOp(TOK_EQUAL, *cond.args), expr.src1, expr.src2)\n    return expr",
        "mutated": [
            "def simp_cond_flag(_, expr):\n    if False:\n        i = 10\n    'FLAG_EQ_CMP(X, Y)?A:B => (X == Y)?A:B'\n    cond = expr.cond\n    if cond.is_op('FLAG_EQ_CMP'):\n        return ExprCond(ExprOp(TOK_EQUAL, *cond.args), expr.src1, expr.src2)\n    return expr",
            "def simp_cond_flag(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'FLAG_EQ_CMP(X, Y)?A:B => (X == Y)?A:B'\n    cond = expr.cond\n    if cond.is_op('FLAG_EQ_CMP'):\n        return ExprCond(ExprOp(TOK_EQUAL, *cond.args), expr.src1, expr.src2)\n    return expr",
            "def simp_cond_flag(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'FLAG_EQ_CMP(X, Y)?A:B => (X == Y)?A:B'\n    cond = expr.cond\n    if cond.is_op('FLAG_EQ_CMP'):\n        return ExprCond(ExprOp(TOK_EQUAL, *cond.args), expr.src1, expr.src2)\n    return expr",
            "def simp_cond_flag(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'FLAG_EQ_CMP(X, Y)?A:B => (X == Y)?A:B'\n    cond = expr.cond\n    if cond.is_op('FLAG_EQ_CMP'):\n        return ExprCond(ExprOp(TOK_EQUAL, *cond.args), expr.src1, expr.src2)\n    return expr",
            "def simp_cond_flag(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'FLAG_EQ_CMP(X, Y)?A:B => (X == Y)?A:B'\n    cond = expr.cond\n    if cond.is_op('FLAG_EQ_CMP'):\n        return ExprCond(ExprOp(TOK_EQUAL, *cond.args), expr.src1, expr.src2)\n    return expr"
        ]
    },
    {
        "func_name": "simp_sub_cf_zero",
        "original": "def simp_sub_cf_zero(_, expr):\n    \"\"\"FLAG_SUB_CF(0, X) => (X)?1:0\"\"\"\n    if not expr.is_op('FLAG_SUB_CF'):\n        return expr\n    if not expr.args[0].is_int(0):\n        return expr\n    return ExprCond(expr.args[1], ExprInt(1, 1), ExprInt(0, 1))",
        "mutated": [
            "def simp_sub_cf_zero(_, expr):\n    if False:\n        i = 10\n    'FLAG_SUB_CF(0, X) => (X)?1:0'\n    if not expr.is_op('FLAG_SUB_CF'):\n        return expr\n    if not expr.args[0].is_int(0):\n        return expr\n    return ExprCond(expr.args[1], ExprInt(1, 1), ExprInt(0, 1))",
            "def simp_sub_cf_zero(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'FLAG_SUB_CF(0, X) => (X)?1:0'\n    if not expr.is_op('FLAG_SUB_CF'):\n        return expr\n    if not expr.args[0].is_int(0):\n        return expr\n    return ExprCond(expr.args[1], ExprInt(1, 1), ExprInt(0, 1))",
            "def simp_sub_cf_zero(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'FLAG_SUB_CF(0, X) => (X)?1:0'\n    if not expr.is_op('FLAG_SUB_CF'):\n        return expr\n    if not expr.args[0].is_int(0):\n        return expr\n    return ExprCond(expr.args[1], ExprInt(1, 1), ExprInt(0, 1))",
            "def simp_sub_cf_zero(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'FLAG_SUB_CF(0, X) => (X)?1:0'\n    if not expr.is_op('FLAG_SUB_CF'):\n        return expr\n    if not expr.args[0].is_int(0):\n        return expr\n    return ExprCond(expr.args[1], ExprInt(1, 1), ExprInt(0, 1))",
            "def simp_sub_cf_zero(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'FLAG_SUB_CF(0, X) => (X)?1:0'\n    if not expr.is_op('FLAG_SUB_CF'):\n        return expr\n    if not expr.args[0].is_int(0):\n        return expr\n    return ExprCond(expr.args[1], ExprInt(1, 1), ExprInt(0, 1))"
        ]
    },
    {
        "func_name": "simp_cond_cc_flag",
        "original": "def simp_cond_cc_flag(expr_simp, expr):\n    \"\"\"\n    ExprCond(CC_><(bit), X, Y) => ExprCond(bit, X, Y)\n    ExprCond(CC_U>=(bit), X, Y) => ExprCond(bit, Y, X)\n    \"\"\"\n    if not expr.is_cond():\n        return expr\n    if not expr.cond.is_op():\n        return expr\n    expr_op = expr.cond\n    if expr_op.op not in ['CC_U<', 'CC_U>=']:\n        return expr\n    arg = expr_op.args[0]\n    if arg.size != 1:\n        return expr\n    if expr_op.op == 'CC_U<':\n        return ExprCond(arg, expr.src1, expr.src2)\n    if expr_op.op == 'CC_U>=':\n        return ExprCond(arg, expr.src2, expr.src1)\n    return expr",
        "mutated": [
            "def simp_cond_cc_flag(expr_simp, expr):\n    if False:\n        i = 10\n    '\\n    ExprCond(CC_><(bit), X, Y) => ExprCond(bit, X, Y)\\n    ExprCond(CC_U>=(bit), X, Y) => ExprCond(bit, Y, X)\\n    '\n    if not expr.is_cond():\n        return expr\n    if not expr.cond.is_op():\n        return expr\n    expr_op = expr.cond\n    if expr_op.op not in ['CC_U<', 'CC_U>=']:\n        return expr\n    arg = expr_op.args[0]\n    if arg.size != 1:\n        return expr\n    if expr_op.op == 'CC_U<':\n        return ExprCond(arg, expr.src1, expr.src2)\n    if expr_op.op == 'CC_U>=':\n        return ExprCond(arg, expr.src2, expr.src1)\n    return expr",
            "def simp_cond_cc_flag(expr_simp, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    ExprCond(CC_><(bit), X, Y) => ExprCond(bit, X, Y)\\n    ExprCond(CC_U>=(bit), X, Y) => ExprCond(bit, Y, X)\\n    '\n    if not expr.is_cond():\n        return expr\n    if not expr.cond.is_op():\n        return expr\n    expr_op = expr.cond\n    if expr_op.op not in ['CC_U<', 'CC_U>=']:\n        return expr\n    arg = expr_op.args[0]\n    if arg.size != 1:\n        return expr\n    if expr_op.op == 'CC_U<':\n        return ExprCond(arg, expr.src1, expr.src2)\n    if expr_op.op == 'CC_U>=':\n        return ExprCond(arg, expr.src2, expr.src1)\n    return expr",
            "def simp_cond_cc_flag(expr_simp, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    ExprCond(CC_><(bit), X, Y) => ExprCond(bit, X, Y)\\n    ExprCond(CC_U>=(bit), X, Y) => ExprCond(bit, Y, X)\\n    '\n    if not expr.is_cond():\n        return expr\n    if not expr.cond.is_op():\n        return expr\n    expr_op = expr.cond\n    if expr_op.op not in ['CC_U<', 'CC_U>=']:\n        return expr\n    arg = expr_op.args[0]\n    if arg.size != 1:\n        return expr\n    if expr_op.op == 'CC_U<':\n        return ExprCond(arg, expr.src1, expr.src2)\n    if expr_op.op == 'CC_U>=':\n        return ExprCond(arg, expr.src2, expr.src1)\n    return expr",
            "def simp_cond_cc_flag(expr_simp, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    ExprCond(CC_><(bit), X, Y) => ExprCond(bit, X, Y)\\n    ExprCond(CC_U>=(bit), X, Y) => ExprCond(bit, Y, X)\\n    '\n    if not expr.is_cond():\n        return expr\n    if not expr.cond.is_op():\n        return expr\n    expr_op = expr.cond\n    if expr_op.op not in ['CC_U<', 'CC_U>=']:\n        return expr\n    arg = expr_op.args[0]\n    if arg.size != 1:\n        return expr\n    if expr_op.op == 'CC_U<':\n        return ExprCond(arg, expr.src1, expr.src2)\n    if expr_op.op == 'CC_U>=':\n        return ExprCond(arg, expr.src2, expr.src1)\n    return expr",
            "def simp_cond_cc_flag(expr_simp, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    ExprCond(CC_><(bit), X, Y) => ExprCond(bit, X, Y)\\n    ExprCond(CC_U>=(bit), X, Y) => ExprCond(bit, Y, X)\\n    '\n    if not expr.is_cond():\n        return expr\n    if not expr.cond.is_op():\n        return expr\n    expr_op = expr.cond\n    if expr_op.op not in ['CC_U<', 'CC_U>=']:\n        return expr\n    arg = expr_op.args[0]\n    if arg.size != 1:\n        return expr\n    if expr_op.op == 'CC_U<':\n        return ExprCond(arg, expr.src1, expr.src2)\n    if expr_op.op == 'CC_U>=':\n        return ExprCond(arg, expr.src2, expr.src1)\n    return expr"
        ]
    },
    {
        "func_name": "simp_cond_sub_cf",
        "original": "def simp_cond_sub_cf(expr_simp, expr):\n    \"\"\"\n    ExprCond(FLAG_SUB_CF(A, B), X, Y) => ExprCond(A <u B, X, Y)\n    \"\"\"\n    if not expr.is_cond():\n        return expr\n    if not expr.cond.is_op('FLAG_SUB_CF'):\n        return expr\n    cond = ExprOp(TOK_INF_UNSIGNED, *expr.cond.args)\n    return ExprCond(cond, expr.src1, expr.src2)",
        "mutated": [
            "def simp_cond_sub_cf(expr_simp, expr):\n    if False:\n        i = 10\n    '\\n    ExprCond(FLAG_SUB_CF(A, B), X, Y) => ExprCond(A <u B, X, Y)\\n    '\n    if not expr.is_cond():\n        return expr\n    if not expr.cond.is_op('FLAG_SUB_CF'):\n        return expr\n    cond = ExprOp(TOK_INF_UNSIGNED, *expr.cond.args)\n    return ExprCond(cond, expr.src1, expr.src2)",
            "def simp_cond_sub_cf(expr_simp, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    ExprCond(FLAG_SUB_CF(A, B), X, Y) => ExprCond(A <u B, X, Y)\\n    '\n    if not expr.is_cond():\n        return expr\n    if not expr.cond.is_op('FLAG_SUB_CF'):\n        return expr\n    cond = ExprOp(TOK_INF_UNSIGNED, *expr.cond.args)\n    return ExprCond(cond, expr.src1, expr.src2)",
            "def simp_cond_sub_cf(expr_simp, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    ExprCond(FLAG_SUB_CF(A, B), X, Y) => ExprCond(A <u B, X, Y)\\n    '\n    if not expr.is_cond():\n        return expr\n    if not expr.cond.is_op('FLAG_SUB_CF'):\n        return expr\n    cond = ExprOp(TOK_INF_UNSIGNED, *expr.cond.args)\n    return ExprCond(cond, expr.src1, expr.src2)",
            "def simp_cond_sub_cf(expr_simp, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    ExprCond(FLAG_SUB_CF(A, B), X, Y) => ExprCond(A <u B, X, Y)\\n    '\n    if not expr.is_cond():\n        return expr\n    if not expr.cond.is_op('FLAG_SUB_CF'):\n        return expr\n    cond = ExprOp(TOK_INF_UNSIGNED, *expr.cond.args)\n    return ExprCond(cond, expr.src1, expr.src2)",
            "def simp_cond_sub_cf(expr_simp, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    ExprCond(FLAG_SUB_CF(A, B), X, Y) => ExprCond(A <u B, X, Y)\\n    '\n    if not expr.is_cond():\n        return expr\n    if not expr.cond.is_op('FLAG_SUB_CF'):\n        return expr\n    cond = ExprOp(TOK_INF_UNSIGNED, *expr.cond.args)\n    return ExprCond(cond, expr.src1, expr.src2)"
        ]
    },
    {
        "func_name": "simp_cmp_int",
        "original": "def simp_cmp_int(expr_simp, expr):\n    \"\"\"\n    ({X, 0} == int) => X == int[:]\n    X + int1 == int2 => X == int2-int1\n    X ^ int1 == int2 => X == int1^int2\n    \"\"\"\n    if expr.is_op(TOK_EQUAL) and expr.args[1].is_int() and expr.args[0].is_compose() and (len(expr.args[0].args) == 2) and expr.args[0].args[1].is_int(0):\n        src = expr.args[0].args[0]\n        int_val = int(expr.args[1])\n        new_int = ExprInt(int_val, src.size)\n        expr = expr_simp(ExprOp(TOK_EQUAL, src, new_int))\n    elif not expr.is_op(TOK_EQUAL):\n        return expr\n    assert len(expr.args) == 2\n    (left, right) = expr.args\n    if left.is_int() and (not right.is_int()):\n        (left, right) = (right, left)\n    if not right.is_int():\n        return expr\n    if not (left.is_op() and left.op in ['+', '^']):\n        return expr\n    if not left.args[-1].is_int():\n        return expr\n    left_orig = left\n    (left, last_int) = (left.args[:-1], left.args[-1])\n    if len(left) == 1:\n        left = left[0]\n    else:\n        left = ExprOp(left_orig.op, *left)\n    if left_orig.op == '+':\n        new_int = expr_simp(right - last_int)\n    elif left_orig.op == '^':\n        new_int = expr_simp(right ^ last_int)\n    else:\n        raise RuntimeError('Unsupported operator')\n    expr = expr_simp(ExprOp(TOK_EQUAL, left, new_int))\n    return expr",
        "mutated": [
            "def simp_cmp_int(expr_simp, expr):\n    if False:\n        i = 10\n    '\\n    ({X, 0} == int) => X == int[:]\\n    X + int1 == int2 => X == int2-int1\\n    X ^ int1 == int2 => X == int1^int2\\n    '\n    if expr.is_op(TOK_EQUAL) and expr.args[1].is_int() and expr.args[0].is_compose() and (len(expr.args[0].args) == 2) and expr.args[0].args[1].is_int(0):\n        src = expr.args[0].args[0]\n        int_val = int(expr.args[1])\n        new_int = ExprInt(int_val, src.size)\n        expr = expr_simp(ExprOp(TOK_EQUAL, src, new_int))\n    elif not expr.is_op(TOK_EQUAL):\n        return expr\n    assert len(expr.args) == 2\n    (left, right) = expr.args\n    if left.is_int() and (not right.is_int()):\n        (left, right) = (right, left)\n    if not right.is_int():\n        return expr\n    if not (left.is_op() and left.op in ['+', '^']):\n        return expr\n    if not left.args[-1].is_int():\n        return expr\n    left_orig = left\n    (left, last_int) = (left.args[:-1], left.args[-1])\n    if len(left) == 1:\n        left = left[0]\n    else:\n        left = ExprOp(left_orig.op, *left)\n    if left_orig.op == '+':\n        new_int = expr_simp(right - last_int)\n    elif left_orig.op == '^':\n        new_int = expr_simp(right ^ last_int)\n    else:\n        raise RuntimeError('Unsupported operator')\n    expr = expr_simp(ExprOp(TOK_EQUAL, left, new_int))\n    return expr",
            "def simp_cmp_int(expr_simp, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    ({X, 0} == int) => X == int[:]\\n    X + int1 == int2 => X == int2-int1\\n    X ^ int1 == int2 => X == int1^int2\\n    '\n    if expr.is_op(TOK_EQUAL) and expr.args[1].is_int() and expr.args[0].is_compose() and (len(expr.args[0].args) == 2) and expr.args[0].args[1].is_int(0):\n        src = expr.args[0].args[0]\n        int_val = int(expr.args[1])\n        new_int = ExprInt(int_val, src.size)\n        expr = expr_simp(ExprOp(TOK_EQUAL, src, new_int))\n    elif not expr.is_op(TOK_EQUAL):\n        return expr\n    assert len(expr.args) == 2\n    (left, right) = expr.args\n    if left.is_int() and (not right.is_int()):\n        (left, right) = (right, left)\n    if not right.is_int():\n        return expr\n    if not (left.is_op() and left.op in ['+', '^']):\n        return expr\n    if not left.args[-1].is_int():\n        return expr\n    left_orig = left\n    (left, last_int) = (left.args[:-1], left.args[-1])\n    if len(left) == 1:\n        left = left[0]\n    else:\n        left = ExprOp(left_orig.op, *left)\n    if left_orig.op == '+':\n        new_int = expr_simp(right - last_int)\n    elif left_orig.op == '^':\n        new_int = expr_simp(right ^ last_int)\n    else:\n        raise RuntimeError('Unsupported operator')\n    expr = expr_simp(ExprOp(TOK_EQUAL, left, new_int))\n    return expr",
            "def simp_cmp_int(expr_simp, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    ({X, 0} == int) => X == int[:]\\n    X + int1 == int2 => X == int2-int1\\n    X ^ int1 == int2 => X == int1^int2\\n    '\n    if expr.is_op(TOK_EQUAL) and expr.args[1].is_int() and expr.args[0].is_compose() and (len(expr.args[0].args) == 2) and expr.args[0].args[1].is_int(0):\n        src = expr.args[0].args[0]\n        int_val = int(expr.args[1])\n        new_int = ExprInt(int_val, src.size)\n        expr = expr_simp(ExprOp(TOK_EQUAL, src, new_int))\n    elif not expr.is_op(TOK_EQUAL):\n        return expr\n    assert len(expr.args) == 2\n    (left, right) = expr.args\n    if left.is_int() and (not right.is_int()):\n        (left, right) = (right, left)\n    if not right.is_int():\n        return expr\n    if not (left.is_op() and left.op in ['+', '^']):\n        return expr\n    if not left.args[-1].is_int():\n        return expr\n    left_orig = left\n    (left, last_int) = (left.args[:-1], left.args[-1])\n    if len(left) == 1:\n        left = left[0]\n    else:\n        left = ExprOp(left_orig.op, *left)\n    if left_orig.op == '+':\n        new_int = expr_simp(right - last_int)\n    elif left_orig.op == '^':\n        new_int = expr_simp(right ^ last_int)\n    else:\n        raise RuntimeError('Unsupported operator')\n    expr = expr_simp(ExprOp(TOK_EQUAL, left, new_int))\n    return expr",
            "def simp_cmp_int(expr_simp, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    ({X, 0} == int) => X == int[:]\\n    X + int1 == int2 => X == int2-int1\\n    X ^ int1 == int2 => X == int1^int2\\n    '\n    if expr.is_op(TOK_EQUAL) and expr.args[1].is_int() and expr.args[0].is_compose() and (len(expr.args[0].args) == 2) and expr.args[0].args[1].is_int(0):\n        src = expr.args[0].args[0]\n        int_val = int(expr.args[1])\n        new_int = ExprInt(int_val, src.size)\n        expr = expr_simp(ExprOp(TOK_EQUAL, src, new_int))\n    elif not expr.is_op(TOK_EQUAL):\n        return expr\n    assert len(expr.args) == 2\n    (left, right) = expr.args\n    if left.is_int() and (not right.is_int()):\n        (left, right) = (right, left)\n    if not right.is_int():\n        return expr\n    if not (left.is_op() and left.op in ['+', '^']):\n        return expr\n    if not left.args[-1].is_int():\n        return expr\n    left_orig = left\n    (left, last_int) = (left.args[:-1], left.args[-1])\n    if len(left) == 1:\n        left = left[0]\n    else:\n        left = ExprOp(left_orig.op, *left)\n    if left_orig.op == '+':\n        new_int = expr_simp(right - last_int)\n    elif left_orig.op == '^':\n        new_int = expr_simp(right ^ last_int)\n    else:\n        raise RuntimeError('Unsupported operator')\n    expr = expr_simp(ExprOp(TOK_EQUAL, left, new_int))\n    return expr",
            "def simp_cmp_int(expr_simp, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    ({X, 0} == int) => X == int[:]\\n    X + int1 == int2 => X == int2-int1\\n    X ^ int1 == int2 => X == int1^int2\\n    '\n    if expr.is_op(TOK_EQUAL) and expr.args[1].is_int() and expr.args[0].is_compose() and (len(expr.args[0].args) == 2) and expr.args[0].args[1].is_int(0):\n        src = expr.args[0].args[0]\n        int_val = int(expr.args[1])\n        new_int = ExprInt(int_val, src.size)\n        expr = expr_simp(ExprOp(TOK_EQUAL, src, new_int))\n    elif not expr.is_op(TOK_EQUAL):\n        return expr\n    assert len(expr.args) == 2\n    (left, right) = expr.args\n    if left.is_int() and (not right.is_int()):\n        (left, right) = (right, left)\n    if not right.is_int():\n        return expr\n    if not (left.is_op() and left.op in ['+', '^']):\n        return expr\n    if not left.args[-1].is_int():\n        return expr\n    left_orig = left\n    (left, last_int) = (left.args[:-1], left.args[-1])\n    if len(left) == 1:\n        left = left[0]\n    else:\n        left = ExprOp(left_orig.op, *left)\n    if left_orig.op == '+':\n        new_int = expr_simp(right - last_int)\n    elif left_orig.op == '^':\n        new_int = expr_simp(right ^ last_int)\n    else:\n        raise RuntimeError('Unsupported operator')\n    expr = expr_simp(ExprOp(TOK_EQUAL, left, new_int))\n    return expr"
        ]
    },
    {
        "func_name": "simp_cmp_int_arg",
        "original": "def simp_cmp_int_arg(_, expr):\n    \"\"\"\n    (0x10 <= R0) ? A:B\n    =>\n    (R0 < 0x10) ? B:A\n    \"\"\"\n    cond = expr.cond\n    if not cond.is_op():\n        return expr\n    op = cond.op\n    if op not in [TOK_EQUAL, TOK_INF_SIGNED, TOK_INF_EQUAL_SIGNED, TOK_INF_UNSIGNED, TOK_INF_EQUAL_UNSIGNED]:\n        return expr\n    (arg1, arg2) = cond.args\n    if arg2.is_int():\n        return expr\n    if not arg1.is_int():\n        return expr\n    (src1, src2) = (expr.src1, expr.src2)\n    if op == TOK_EQUAL:\n        return ExprCond(ExprOp(TOK_EQUAL, arg2, arg1), src1, src2)\n    (arg1, arg2) = (arg2, arg1)\n    (src1, src2) = (src2, src1)\n    if op == TOK_INF_SIGNED:\n        op = TOK_INF_EQUAL_SIGNED\n    elif op == TOK_INF_EQUAL_SIGNED:\n        op = TOK_INF_SIGNED\n    elif op == TOK_INF_UNSIGNED:\n        op = TOK_INF_EQUAL_UNSIGNED\n    elif op == TOK_INF_EQUAL_UNSIGNED:\n        op = TOK_INF_UNSIGNED\n    return ExprCond(ExprOp(op, arg1, arg2), src1, src2)",
        "mutated": [
            "def simp_cmp_int_arg(_, expr):\n    if False:\n        i = 10\n    '\\n    (0x10 <= R0) ? A:B\\n    =>\\n    (R0 < 0x10) ? B:A\\n    '\n    cond = expr.cond\n    if not cond.is_op():\n        return expr\n    op = cond.op\n    if op not in [TOK_EQUAL, TOK_INF_SIGNED, TOK_INF_EQUAL_SIGNED, TOK_INF_UNSIGNED, TOK_INF_EQUAL_UNSIGNED]:\n        return expr\n    (arg1, arg2) = cond.args\n    if arg2.is_int():\n        return expr\n    if not arg1.is_int():\n        return expr\n    (src1, src2) = (expr.src1, expr.src2)\n    if op == TOK_EQUAL:\n        return ExprCond(ExprOp(TOK_EQUAL, arg2, arg1), src1, src2)\n    (arg1, arg2) = (arg2, arg1)\n    (src1, src2) = (src2, src1)\n    if op == TOK_INF_SIGNED:\n        op = TOK_INF_EQUAL_SIGNED\n    elif op == TOK_INF_EQUAL_SIGNED:\n        op = TOK_INF_SIGNED\n    elif op == TOK_INF_UNSIGNED:\n        op = TOK_INF_EQUAL_UNSIGNED\n    elif op == TOK_INF_EQUAL_UNSIGNED:\n        op = TOK_INF_UNSIGNED\n    return ExprCond(ExprOp(op, arg1, arg2), src1, src2)",
            "def simp_cmp_int_arg(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    (0x10 <= R0) ? A:B\\n    =>\\n    (R0 < 0x10) ? B:A\\n    '\n    cond = expr.cond\n    if not cond.is_op():\n        return expr\n    op = cond.op\n    if op not in [TOK_EQUAL, TOK_INF_SIGNED, TOK_INF_EQUAL_SIGNED, TOK_INF_UNSIGNED, TOK_INF_EQUAL_UNSIGNED]:\n        return expr\n    (arg1, arg2) = cond.args\n    if arg2.is_int():\n        return expr\n    if not arg1.is_int():\n        return expr\n    (src1, src2) = (expr.src1, expr.src2)\n    if op == TOK_EQUAL:\n        return ExprCond(ExprOp(TOK_EQUAL, arg2, arg1), src1, src2)\n    (arg1, arg2) = (arg2, arg1)\n    (src1, src2) = (src2, src1)\n    if op == TOK_INF_SIGNED:\n        op = TOK_INF_EQUAL_SIGNED\n    elif op == TOK_INF_EQUAL_SIGNED:\n        op = TOK_INF_SIGNED\n    elif op == TOK_INF_UNSIGNED:\n        op = TOK_INF_EQUAL_UNSIGNED\n    elif op == TOK_INF_EQUAL_UNSIGNED:\n        op = TOK_INF_UNSIGNED\n    return ExprCond(ExprOp(op, arg1, arg2), src1, src2)",
            "def simp_cmp_int_arg(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    (0x10 <= R0) ? A:B\\n    =>\\n    (R0 < 0x10) ? B:A\\n    '\n    cond = expr.cond\n    if not cond.is_op():\n        return expr\n    op = cond.op\n    if op not in [TOK_EQUAL, TOK_INF_SIGNED, TOK_INF_EQUAL_SIGNED, TOK_INF_UNSIGNED, TOK_INF_EQUAL_UNSIGNED]:\n        return expr\n    (arg1, arg2) = cond.args\n    if arg2.is_int():\n        return expr\n    if not arg1.is_int():\n        return expr\n    (src1, src2) = (expr.src1, expr.src2)\n    if op == TOK_EQUAL:\n        return ExprCond(ExprOp(TOK_EQUAL, arg2, arg1), src1, src2)\n    (arg1, arg2) = (arg2, arg1)\n    (src1, src2) = (src2, src1)\n    if op == TOK_INF_SIGNED:\n        op = TOK_INF_EQUAL_SIGNED\n    elif op == TOK_INF_EQUAL_SIGNED:\n        op = TOK_INF_SIGNED\n    elif op == TOK_INF_UNSIGNED:\n        op = TOK_INF_EQUAL_UNSIGNED\n    elif op == TOK_INF_EQUAL_UNSIGNED:\n        op = TOK_INF_UNSIGNED\n    return ExprCond(ExprOp(op, arg1, arg2), src1, src2)",
            "def simp_cmp_int_arg(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    (0x10 <= R0) ? A:B\\n    =>\\n    (R0 < 0x10) ? B:A\\n    '\n    cond = expr.cond\n    if not cond.is_op():\n        return expr\n    op = cond.op\n    if op not in [TOK_EQUAL, TOK_INF_SIGNED, TOK_INF_EQUAL_SIGNED, TOK_INF_UNSIGNED, TOK_INF_EQUAL_UNSIGNED]:\n        return expr\n    (arg1, arg2) = cond.args\n    if arg2.is_int():\n        return expr\n    if not arg1.is_int():\n        return expr\n    (src1, src2) = (expr.src1, expr.src2)\n    if op == TOK_EQUAL:\n        return ExprCond(ExprOp(TOK_EQUAL, arg2, arg1), src1, src2)\n    (arg1, arg2) = (arg2, arg1)\n    (src1, src2) = (src2, src1)\n    if op == TOK_INF_SIGNED:\n        op = TOK_INF_EQUAL_SIGNED\n    elif op == TOK_INF_EQUAL_SIGNED:\n        op = TOK_INF_SIGNED\n    elif op == TOK_INF_UNSIGNED:\n        op = TOK_INF_EQUAL_UNSIGNED\n    elif op == TOK_INF_EQUAL_UNSIGNED:\n        op = TOK_INF_UNSIGNED\n    return ExprCond(ExprOp(op, arg1, arg2), src1, src2)",
            "def simp_cmp_int_arg(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    (0x10 <= R0) ? A:B\\n    =>\\n    (R0 < 0x10) ? B:A\\n    '\n    cond = expr.cond\n    if not cond.is_op():\n        return expr\n    op = cond.op\n    if op not in [TOK_EQUAL, TOK_INF_SIGNED, TOK_INF_EQUAL_SIGNED, TOK_INF_UNSIGNED, TOK_INF_EQUAL_UNSIGNED]:\n        return expr\n    (arg1, arg2) = cond.args\n    if arg2.is_int():\n        return expr\n    if not arg1.is_int():\n        return expr\n    (src1, src2) = (expr.src1, expr.src2)\n    if op == TOK_EQUAL:\n        return ExprCond(ExprOp(TOK_EQUAL, arg2, arg1), src1, src2)\n    (arg1, arg2) = (arg2, arg1)\n    (src1, src2) = (src2, src1)\n    if op == TOK_INF_SIGNED:\n        op = TOK_INF_EQUAL_SIGNED\n    elif op == TOK_INF_EQUAL_SIGNED:\n        op = TOK_INF_SIGNED\n    elif op == TOK_INF_UNSIGNED:\n        op = TOK_INF_EQUAL_UNSIGNED\n    elif op == TOK_INF_EQUAL_UNSIGNED:\n        op = TOK_INF_UNSIGNED\n    return ExprCond(ExprOp(op, arg1, arg2), src1, src2)"
        ]
    },
    {
        "func_name": "simp_cmp_bijective_op",
        "original": "def simp_cmp_bijective_op(expr_simp, expr):\n    \"\"\"\n    A + B == A => A == 0\n\n    X + A == X + B => A == B\n    X ^ A == X ^ B => A == B\n\n    TODO:\n    3 * A + B == A + C => 2 * A + B == C\n    \"\"\"\n    if not expr.is_op(TOK_EQUAL):\n        return expr\n    op_a = expr.args[0]\n    op_b = expr.args[1]\n    if op_a == op_b:\n        return ExprInt(1, 1)\n    if op_a.is_op() and op_a.op in ['+', '^']:\n        args = list(op_a.args)\n        if op_b in args:\n            args.remove(op_b)\n            if not args:\n                raise ValueError('Can be here')\n            elif len(args) == 1:\n                op_a = args[0]\n            else:\n                op_a = ExprOp(op_a.op, *args)\n            return ExprOp(TOK_EQUAL, op_a, ExprInt(0, args[0].size))\n    if op_b.is_op() and op_b.op in ['+', '^']:\n        args = list(op_b.args)\n        if op_a in args:\n            args.remove(op_a)\n            if not args:\n                raise ValueError('Can be here')\n            elif len(args) == 1:\n                op_b = args[0]\n            else:\n                op_b = ExprOp(op_b.op, *args)\n            return ExprOp(TOK_EQUAL, op_b, ExprInt(0, args[0].size))\n    if not (op_a.is_op() and op_b.is_op()):\n        return expr\n    if op_a.op != op_b.op:\n        return expr\n    op = op_a.op\n    if op not in ['+', '^']:\n        return expr\n    common = set(op_a.args).intersection(op_b.args)\n    if not common:\n        return expr\n    args_a = list(op_a.args)\n    args_b = list(op_b.args)\n    for value in common:\n        while value in args_a and value in args_b:\n            args_a.remove(value)\n            args_b.remove(value)\n    if not args_a:\n        return ExprOp(TOK_EQUAL, ExprOp(op, *args_b), ExprInt(0, args_b[0].size))\n    if not args_b:\n        return ExprOp(TOK_EQUAL, ExprOp(op, *args_a), ExprInt(0, args_a[0].size))\n    arg_a = ExprOp(op, *args_a)\n    arg_b = ExprOp(op, *args_b)\n    return ExprOp(TOK_EQUAL, arg_a, arg_b)",
        "mutated": [
            "def simp_cmp_bijective_op(expr_simp, expr):\n    if False:\n        i = 10\n    '\\n    A + B == A => A == 0\\n\\n    X + A == X + B => A == B\\n    X ^ A == X ^ B => A == B\\n\\n    TODO:\\n    3 * A + B == A + C => 2 * A + B == C\\n    '\n    if not expr.is_op(TOK_EQUAL):\n        return expr\n    op_a = expr.args[0]\n    op_b = expr.args[1]\n    if op_a == op_b:\n        return ExprInt(1, 1)\n    if op_a.is_op() and op_a.op in ['+', '^']:\n        args = list(op_a.args)\n        if op_b in args:\n            args.remove(op_b)\n            if not args:\n                raise ValueError('Can be here')\n            elif len(args) == 1:\n                op_a = args[0]\n            else:\n                op_a = ExprOp(op_a.op, *args)\n            return ExprOp(TOK_EQUAL, op_a, ExprInt(0, args[0].size))\n    if op_b.is_op() and op_b.op in ['+', '^']:\n        args = list(op_b.args)\n        if op_a in args:\n            args.remove(op_a)\n            if not args:\n                raise ValueError('Can be here')\n            elif len(args) == 1:\n                op_b = args[0]\n            else:\n                op_b = ExprOp(op_b.op, *args)\n            return ExprOp(TOK_EQUAL, op_b, ExprInt(0, args[0].size))\n    if not (op_a.is_op() and op_b.is_op()):\n        return expr\n    if op_a.op != op_b.op:\n        return expr\n    op = op_a.op\n    if op not in ['+', '^']:\n        return expr\n    common = set(op_a.args).intersection(op_b.args)\n    if not common:\n        return expr\n    args_a = list(op_a.args)\n    args_b = list(op_b.args)\n    for value in common:\n        while value in args_a and value in args_b:\n            args_a.remove(value)\n            args_b.remove(value)\n    if not args_a:\n        return ExprOp(TOK_EQUAL, ExprOp(op, *args_b), ExprInt(0, args_b[0].size))\n    if not args_b:\n        return ExprOp(TOK_EQUAL, ExprOp(op, *args_a), ExprInt(0, args_a[0].size))\n    arg_a = ExprOp(op, *args_a)\n    arg_b = ExprOp(op, *args_b)\n    return ExprOp(TOK_EQUAL, arg_a, arg_b)",
            "def simp_cmp_bijective_op(expr_simp, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    A + B == A => A == 0\\n\\n    X + A == X + B => A == B\\n    X ^ A == X ^ B => A == B\\n\\n    TODO:\\n    3 * A + B == A + C => 2 * A + B == C\\n    '\n    if not expr.is_op(TOK_EQUAL):\n        return expr\n    op_a = expr.args[0]\n    op_b = expr.args[1]\n    if op_a == op_b:\n        return ExprInt(1, 1)\n    if op_a.is_op() and op_a.op in ['+', '^']:\n        args = list(op_a.args)\n        if op_b in args:\n            args.remove(op_b)\n            if not args:\n                raise ValueError('Can be here')\n            elif len(args) == 1:\n                op_a = args[0]\n            else:\n                op_a = ExprOp(op_a.op, *args)\n            return ExprOp(TOK_EQUAL, op_a, ExprInt(0, args[0].size))\n    if op_b.is_op() and op_b.op in ['+', '^']:\n        args = list(op_b.args)\n        if op_a in args:\n            args.remove(op_a)\n            if not args:\n                raise ValueError('Can be here')\n            elif len(args) == 1:\n                op_b = args[0]\n            else:\n                op_b = ExprOp(op_b.op, *args)\n            return ExprOp(TOK_EQUAL, op_b, ExprInt(0, args[0].size))\n    if not (op_a.is_op() and op_b.is_op()):\n        return expr\n    if op_a.op != op_b.op:\n        return expr\n    op = op_a.op\n    if op not in ['+', '^']:\n        return expr\n    common = set(op_a.args).intersection(op_b.args)\n    if not common:\n        return expr\n    args_a = list(op_a.args)\n    args_b = list(op_b.args)\n    for value in common:\n        while value in args_a and value in args_b:\n            args_a.remove(value)\n            args_b.remove(value)\n    if not args_a:\n        return ExprOp(TOK_EQUAL, ExprOp(op, *args_b), ExprInt(0, args_b[0].size))\n    if not args_b:\n        return ExprOp(TOK_EQUAL, ExprOp(op, *args_a), ExprInt(0, args_a[0].size))\n    arg_a = ExprOp(op, *args_a)\n    arg_b = ExprOp(op, *args_b)\n    return ExprOp(TOK_EQUAL, arg_a, arg_b)",
            "def simp_cmp_bijective_op(expr_simp, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    A + B == A => A == 0\\n\\n    X + A == X + B => A == B\\n    X ^ A == X ^ B => A == B\\n\\n    TODO:\\n    3 * A + B == A + C => 2 * A + B == C\\n    '\n    if not expr.is_op(TOK_EQUAL):\n        return expr\n    op_a = expr.args[0]\n    op_b = expr.args[1]\n    if op_a == op_b:\n        return ExprInt(1, 1)\n    if op_a.is_op() and op_a.op in ['+', '^']:\n        args = list(op_a.args)\n        if op_b in args:\n            args.remove(op_b)\n            if not args:\n                raise ValueError('Can be here')\n            elif len(args) == 1:\n                op_a = args[0]\n            else:\n                op_a = ExprOp(op_a.op, *args)\n            return ExprOp(TOK_EQUAL, op_a, ExprInt(0, args[0].size))\n    if op_b.is_op() and op_b.op in ['+', '^']:\n        args = list(op_b.args)\n        if op_a in args:\n            args.remove(op_a)\n            if not args:\n                raise ValueError('Can be here')\n            elif len(args) == 1:\n                op_b = args[0]\n            else:\n                op_b = ExprOp(op_b.op, *args)\n            return ExprOp(TOK_EQUAL, op_b, ExprInt(0, args[0].size))\n    if not (op_a.is_op() and op_b.is_op()):\n        return expr\n    if op_a.op != op_b.op:\n        return expr\n    op = op_a.op\n    if op not in ['+', '^']:\n        return expr\n    common = set(op_a.args).intersection(op_b.args)\n    if not common:\n        return expr\n    args_a = list(op_a.args)\n    args_b = list(op_b.args)\n    for value in common:\n        while value in args_a and value in args_b:\n            args_a.remove(value)\n            args_b.remove(value)\n    if not args_a:\n        return ExprOp(TOK_EQUAL, ExprOp(op, *args_b), ExprInt(0, args_b[0].size))\n    if not args_b:\n        return ExprOp(TOK_EQUAL, ExprOp(op, *args_a), ExprInt(0, args_a[0].size))\n    arg_a = ExprOp(op, *args_a)\n    arg_b = ExprOp(op, *args_b)\n    return ExprOp(TOK_EQUAL, arg_a, arg_b)",
            "def simp_cmp_bijective_op(expr_simp, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    A + B == A => A == 0\\n\\n    X + A == X + B => A == B\\n    X ^ A == X ^ B => A == B\\n\\n    TODO:\\n    3 * A + B == A + C => 2 * A + B == C\\n    '\n    if not expr.is_op(TOK_EQUAL):\n        return expr\n    op_a = expr.args[0]\n    op_b = expr.args[1]\n    if op_a == op_b:\n        return ExprInt(1, 1)\n    if op_a.is_op() and op_a.op in ['+', '^']:\n        args = list(op_a.args)\n        if op_b in args:\n            args.remove(op_b)\n            if not args:\n                raise ValueError('Can be here')\n            elif len(args) == 1:\n                op_a = args[0]\n            else:\n                op_a = ExprOp(op_a.op, *args)\n            return ExprOp(TOK_EQUAL, op_a, ExprInt(0, args[0].size))\n    if op_b.is_op() and op_b.op in ['+', '^']:\n        args = list(op_b.args)\n        if op_a in args:\n            args.remove(op_a)\n            if not args:\n                raise ValueError('Can be here')\n            elif len(args) == 1:\n                op_b = args[0]\n            else:\n                op_b = ExprOp(op_b.op, *args)\n            return ExprOp(TOK_EQUAL, op_b, ExprInt(0, args[0].size))\n    if not (op_a.is_op() and op_b.is_op()):\n        return expr\n    if op_a.op != op_b.op:\n        return expr\n    op = op_a.op\n    if op not in ['+', '^']:\n        return expr\n    common = set(op_a.args).intersection(op_b.args)\n    if not common:\n        return expr\n    args_a = list(op_a.args)\n    args_b = list(op_b.args)\n    for value in common:\n        while value in args_a and value in args_b:\n            args_a.remove(value)\n            args_b.remove(value)\n    if not args_a:\n        return ExprOp(TOK_EQUAL, ExprOp(op, *args_b), ExprInt(0, args_b[0].size))\n    if not args_b:\n        return ExprOp(TOK_EQUAL, ExprOp(op, *args_a), ExprInt(0, args_a[0].size))\n    arg_a = ExprOp(op, *args_a)\n    arg_b = ExprOp(op, *args_b)\n    return ExprOp(TOK_EQUAL, arg_a, arg_b)",
            "def simp_cmp_bijective_op(expr_simp, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    A + B == A => A == 0\\n\\n    X + A == X + B => A == B\\n    X ^ A == X ^ B => A == B\\n\\n    TODO:\\n    3 * A + B == A + C => 2 * A + B == C\\n    '\n    if not expr.is_op(TOK_EQUAL):\n        return expr\n    op_a = expr.args[0]\n    op_b = expr.args[1]\n    if op_a == op_b:\n        return ExprInt(1, 1)\n    if op_a.is_op() and op_a.op in ['+', '^']:\n        args = list(op_a.args)\n        if op_b in args:\n            args.remove(op_b)\n            if not args:\n                raise ValueError('Can be here')\n            elif len(args) == 1:\n                op_a = args[0]\n            else:\n                op_a = ExprOp(op_a.op, *args)\n            return ExprOp(TOK_EQUAL, op_a, ExprInt(0, args[0].size))\n    if op_b.is_op() and op_b.op in ['+', '^']:\n        args = list(op_b.args)\n        if op_a in args:\n            args.remove(op_a)\n            if not args:\n                raise ValueError('Can be here')\n            elif len(args) == 1:\n                op_b = args[0]\n            else:\n                op_b = ExprOp(op_b.op, *args)\n            return ExprOp(TOK_EQUAL, op_b, ExprInt(0, args[0].size))\n    if not (op_a.is_op() and op_b.is_op()):\n        return expr\n    if op_a.op != op_b.op:\n        return expr\n    op = op_a.op\n    if op not in ['+', '^']:\n        return expr\n    common = set(op_a.args).intersection(op_b.args)\n    if not common:\n        return expr\n    args_a = list(op_a.args)\n    args_b = list(op_b.args)\n    for value in common:\n        while value in args_a and value in args_b:\n            args_a.remove(value)\n            args_b.remove(value)\n    if not args_a:\n        return ExprOp(TOK_EQUAL, ExprOp(op, *args_b), ExprInt(0, args_b[0].size))\n    if not args_b:\n        return ExprOp(TOK_EQUAL, ExprOp(op, *args_a), ExprInt(0, args_a[0].size))\n    arg_a = ExprOp(op, *args_a)\n    arg_b = ExprOp(op, *args_b)\n    return ExprOp(TOK_EQUAL, arg_a, arg_b)"
        ]
    },
    {
        "func_name": "simp_subwc_cf",
        "original": "def simp_subwc_cf(_, expr):\n    \"\"\"SUBWC_CF(A, B, SUB_CF(C, D)) => SUB_CF({A, C}, {B, D})\"\"\"\n    if not expr.is_op('FLAG_SUBWC_CF'):\n        return expr\n    op3 = expr.args[2]\n    if not op3.is_op('FLAG_SUB_CF'):\n        return expr\n    op1 = ExprCompose(expr.args[0], op3.args[0])\n    op2 = ExprCompose(expr.args[1], op3.args[1])\n    return ExprOp('FLAG_SUB_CF', op1, op2)",
        "mutated": [
            "def simp_subwc_cf(_, expr):\n    if False:\n        i = 10\n    'SUBWC_CF(A, B, SUB_CF(C, D)) => SUB_CF({A, C}, {B, D})'\n    if not expr.is_op('FLAG_SUBWC_CF'):\n        return expr\n    op3 = expr.args[2]\n    if not op3.is_op('FLAG_SUB_CF'):\n        return expr\n    op1 = ExprCompose(expr.args[0], op3.args[0])\n    op2 = ExprCompose(expr.args[1], op3.args[1])\n    return ExprOp('FLAG_SUB_CF', op1, op2)",
            "def simp_subwc_cf(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'SUBWC_CF(A, B, SUB_CF(C, D)) => SUB_CF({A, C}, {B, D})'\n    if not expr.is_op('FLAG_SUBWC_CF'):\n        return expr\n    op3 = expr.args[2]\n    if not op3.is_op('FLAG_SUB_CF'):\n        return expr\n    op1 = ExprCompose(expr.args[0], op3.args[0])\n    op2 = ExprCompose(expr.args[1], op3.args[1])\n    return ExprOp('FLAG_SUB_CF', op1, op2)",
            "def simp_subwc_cf(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'SUBWC_CF(A, B, SUB_CF(C, D)) => SUB_CF({A, C}, {B, D})'\n    if not expr.is_op('FLAG_SUBWC_CF'):\n        return expr\n    op3 = expr.args[2]\n    if not op3.is_op('FLAG_SUB_CF'):\n        return expr\n    op1 = ExprCompose(expr.args[0], op3.args[0])\n    op2 = ExprCompose(expr.args[1], op3.args[1])\n    return ExprOp('FLAG_SUB_CF', op1, op2)",
            "def simp_subwc_cf(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'SUBWC_CF(A, B, SUB_CF(C, D)) => SUB_CF({A, C}, {B, D})'\n    if not expr.is_op('FLAG_SUBWC_CF'):\n        return expr\n    op3 = expr.args[2]\n    if not op3.is_op('FLAG_SUB_CF'):\n        return expr\n    op1 = ExprCompose(expr.args[0], op3.args[0])\n    op2 = ExprCompose(expr.args[1], op3.args[1])\n    return ExprOp('FLAG_SUB_CF', op1, op2)",
            "def simp_subwc_cf(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'SUBWC_CF(A, B, SUB_CF(C, D)) => SUB_CF({A, C}, {B, D})'\n    if not expr.is_op('FLAG_SUBWC_CF'):\n        return expr\n    op3 = expr.args[2]\n    if not op3.is_op('FLAG_SUB_CF'):\n        return expr\n    op1 = ExprCompose(expr.args[0], op3.args[0])\n    op2 = ExprCompose(expr.args[1], op3.args[1])\n    return ExprOp('FLAG_SUB_CF', op1, op2)"
        ]
    },
    {
        "func_name": "simp_subwc_of",
        "original": "def simp_subwc_of(_, expr):\n    \"\"\"SUBWC_OF(A, B, SUB_CF(C, D)) => SUB_OF({A, C}, {B, D})\"\"\"\n    if not expr.is_op('FLAG_SUBWC_OF'):\n        return expr\n    op3 = expr.args[2]\n    if not op3.is_op('FLAG_SUB_CF'):\n        return expr\n    op1 = ExprCompose(expr.args[0], op3.args[0])\n    op2 = ExprCompose(expr.args[1], op3.args[1])\n    return ExprOp('FLAG_SUB_OF', op1, op2)",
        "mutated": [
            "def simp_subwc_of(_, expr):\n    if False:\n        i = 10\n    'SUBWC_OF(A, B, SUB_CF(C, D)) => SUB_OF({A, C}, {B, D})'\n    if not expr.is_op('FLAG_SUBWC_OF'):\n        return expr\n    op3 = expr.args[2]\n    if not op3.is_op('FLAG_SUB_CF'):\n        return expr\n    op1 = ExprCompose(expr.args[0], op3.args[0])\n    op2 = ExprCompose(expr.args[1], op3.args[1])\n    return ExprOp('FLAG_SUB_OF', op1, op2)",
            "def simp_subwc_of(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'SUBWC_OF(A, B, SUB_CF(C, D)) => SUB_OF({A, C}, {B, D})'\n    if not expr.is_op('FLAG_SUBWC_OF'):\n        return expr\n    op3 = expr.args[2]\n    if not op3.is_op('FLAG_SUB_CF'):\n        return expr\n    op1 = ExprCompose(expr.args[0], op3.args[0])\n    op2 = ExprCompose(expr.args[1], op3.args[1])\n    return ExprOp('FLAG_SUB_OF', op1, op2)",
            "def simp_subwc_of(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'SUBWC_OF(A, B, SUB_CF(C, D)) => SUB_OF({A, C}, {B, D})'\n    if not expr.is_op('FLAG_SUBWC_OF'):\n        return expr\n    op3 = expr.args[2]\n    if not op3.is_op('FLAG_SUB_CF'):\n        return expr\n    op1 = ExprCompose(expr.args[0], op3.args[0])\n    op2 = ExprCompose(expr.args[1], op3.args[1])\n    return ExprOp('FLAG_SUB_OF', op1, op2)",
            "def simp_subwc_of(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'SUBWC_OF(A, B, SUB_CF(C, D)) => SUB_OF({A, C}, {B, D})'\n    if not expr.is_op('FLAG_SUBWC_OF'):\n        return expr\n    op3 = expr.args[2]\n    if not op3.is_op('FLAG_SUB_CF'):\n        return expr\n    op1 = ExprCompose(expr.args[0], op3.args[0])\n    op2 = ExprCompose(expr.args[1], op3.args[1])\n    return ExprOp('FLAG_SUB_OF', op1, op2)",
            "def simp_subwc_of(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'SUBWC_OF(A, B, SUB_CF(C, D)) => SUB_OF({A, C}, {B, D})'\n    if not expr.is_op('FLAG_SUBWC_OF'):\n        return expr\n    op3 = expr.args[2]\n    if not op3.is_op('FLAG_SUB_CF'):\n        return expr\n    op1 = ExprCompose(expr.args[0], op3.args[0])\n    op2 = ExprCompose(expr.args[1], op3.args[1])\n    return ExprOp('FLAG_SUB_OF', op1, op2)"
        ]
    },
    {
        "func_name": "simp_sign_subwc_cf",
        "original": "def simp_sign_subwc_cf(_, expr):\n    \"\"\"SIGN_SUBWC(A, B, SUB_CF(C, D)) => SIGN_SUB({A, C}, {B, D})\"\"\"\n    if not expr.is_op('FLAG_SIGN_SUBWC'):\n        return expr\n    op3 = expr.args[2]\n    if not op3.is_op('FLAG_SUB_CF'):\n        return expr\n    op1 = ExprCompose(expr.args[0], op3.args[0])\n    op2 = ExprCompose(expr.args[1], op3.args[1])\n    return ExprOp('FLAG_SIGN_SUB', op1, op2)",
        "mutated": [
            "def simp_sign_subwc_cf(_, expr):\n    if False:\n        i = 10\n    'SIGN_SUBWC(A, B, SUB_CF(C, D)) => SIGN_SUB({A, C}, {B, D})'\n    if not expr.is_op('FLAG_SIGN_SUBWC'):\n        return expr\n    op3 = expr.args[2]\n    if not op3.is_op('FLAG_SUB_CF'):\n        return expr\n    op1 = ExprCompose(expr.args[0], op3.args[0])\n    op2 = ExprCompose(expr.args[1], op3.args[1])\n    return ExprOp('FLAG_SIGN_SUB', op1, op2)",
            "def simp_sign_subwc_cf(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'SIGN_SUBWC(A, B, SUB_CF(C, D)) => SIGN_SUB({A, C}, {B, D})'\n    if not expr.is_op('FLAG_SIGN_SUBWC'):\n        return expr\n    op3 = expr.args[2]\n    if not op3.is_op('FLAG_SUB_CF'):\n        return expr\n    op1 = ExprCompose(expr.args[0], op3.args[0])\n    op2 = ExprCompose(expr.args[1], op3.args[1])\n    return ExprOp('FLAG_SIGN_SUB', op1, op2)",
            "def simp_sign_subwc_cf(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'SIGN_SUBWC(A, B, SUB_CF(C, D)) => SIGN_SUB({A, C}, {B, D})'\n    if not expr.is_op('FLAG_SIGN_SUBWC'):\n        return expr\n    op3 = expr.args[2]\n    if not op3.is_op('FLAG_SUB_CF'):\n        return expr\n    op1 = ExprCompose(expr.args[0], op3.args[0])\n    op2 = ExprCompose(expr.args[1], op3.args[1])\n    return ExprOp('FLAG_SIGN_SUB', op1, op2)",
            "def simp_sign_subwc_cf(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'SIGN_SUBWC(A, B, SUB_CF(C, D)) => SIGN_SUB({A, C}, {B, D})'\n    if not expr.is_op('FLAG_SIGN_SUBWC'):\n        return expr\n    op3 = expr.args[2]\n    if not op3.is_op('FLAG_SUB_CF'):\n        return expr\n    op1 = ExprCompose(expr.args[0], op3.args[0])\n    op2 = ExprCompose(expr.args[1], op3.args[1])\n    return ExprOp('FLAG_SIGN_SUB', op1, op2)",
            "def simp_sign_subwc_cf(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'SIGN_SUBWC(A, B, SUB_CF(C, D)) => SIGN_SUB({A, C}, {B, D})'\n    if not expr.is_op('FLAG_SIGN_SUBWC'):\n        return expr\n    op3 = expr.args[2]\n    if not op3.is_op('FLAG_SUB_CF'):\n        return expr\n    op1 = ExprCompose(expr.args[0], op3.args[0])\n    op2 = ExprCompose(expr.args[1], op3.args[1])\n    return ExprOp('FLAG_SIGN_SUB', op1, op2)"
        ]
    },
    {
        "func_name": "simp_double_zeroext",
        "original": "def simp_double_zeroext(_, expr):\n    \"\"\"A.zeroExt(X).zeroExt(Y) => A.zeroExt(Y)\"\"\"\n    if not (expr.is_op() and expr.op.startswith('zeroExt')):\n        return expr\n    arg1 = expr.args[0]\n    if not (arg1.is_op() and arg1.op.startswith('zeroExt')):\n        return expr\n    arg2 = arg1.args[0]\n    return ExprOp(expr.op, arg2)",
        "mutated": [
            "def simp_double_zeroext(_, expr):\n    if False:\n        i = 10\n    'A.zeroExt(X).zeroExt(Y) => A.zeroExt(Y)'\n    if not (expr.is_op() and expr.op.startswith('zeroExt')):\n        return expr\n    arg1 = expr.args[0]\n    if not (arg1.is_op() and arg1.op.startswith('zeroExt')):\n        return expr\n    arg2 = arg1.args[0]\n    return ExprOp(expr.op, arg2)",
            "def simp_double_zeroext(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'A.zeroExt(X).zeroExt(Y) => A.zeroExt(Y)'\n    if not (expr.is_op() and expr.op.startswith('zeroExt')):\n        return expr\n    arg1 = expr.args[0]\n    if not (arg1.is_op() and arg1.op.startswith('zeroExt')):\n        return expr\n    arg2 = arg1.args[0]\n    return ExprOp(expr.op, arg2)",
            "def simp_double_zeroext(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'A.zeroExt(X).zeroExt(Y) => A.zeroExt(Y)'\n    if not (expr.is_op() and expr.op.startswith('zeroExt')):\n        return expr\n    arg1 = expr.args[0]\n    if not (arg1.is_op() and arg1.op.startswith('zeroExt')):\n        return expr\n    arg2 = arg1.args[0]\n    return ExprOp(expr.op, arg2)",
            "def simp_double_zeroext(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'A.zeroExt(X).zeroExt(Y) => A.zeroExt(Y)'\n    if not (expr.is_op() and expr.op.startswith('zeroExt')):\n        return expr\n    arg1 = expr.args[0]\n    if not (arg1.is_op() and arg1.op.startswith('zeroExt')):\n        return expr\n    arg2 = arg1.args[0]\n    return ExprOp(expr.op, arg2)",
            "def simp_double_zeroext(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'A.zeroExt(X).zeroExt(Y) => A.zeroExt(Y)'\n    if not (expr.is_op() and expr.op.startswith('zeroExt')):\n        return expr\n    arg1 = expr.args[0]\n    if not (arg1.is_op() and arg1.op.startswith('zeroExt')):\n        return expr\n    arg2 = arg1.args[0]\n    return ExprOp(expr.op, arg2)"
        ]
    },
    {
        "func_name": "simp_double_signext",
        "original": "def simp_double_signext(_, expr):\n    \"\"\"A.signExt(X).signExt(Y) => A.signExt(Y)\"\"\"\n    if not (expr.is_op() and expr.op.startswith('signExt')):\n        return expr\n    arg1 = expr.args[0]\n    if not (arg1.is_op() and arg1.op.startswith('signExt')):\n        return expr\n    arg2 = arg1.args[0]\n    return ExprOp(expr.op, arg2)",
        "mutated": [
            "def simp_double_signext(_, expr):\n    if False:\n        i = 10\n    'A.signExt(X).signExt(Y) => A.signExt(Y)'\n    if not (expr.is_op() and expr.op.startswith('signExt')):\n        return expr\n    arg1 = expr.args[0]\n    if not (arg1.is_op() and arg1.op.startswith('signExt')):\n        return expr\n    arg2 = arg1.args[0]\n    return ExprOp(expr.op, arg2)",
            "def simp_double_signext(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'A.signExt(X).signExt(Y) => A.signExt(Y)'\n    if not (expr.is_op() and expr.op.startswith('signExt')):\n        return expr\n    arg1 = expr.args[0]\n    if not (arg1.is_op() and arg1.op.startswith('signExt')):\n        return expr\n    arg2 = arg1.args[0]\n    return ExprOp(expr.op, arg2)",
            "def simp_double_signext(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'A.signExt(X).signExt(Y) => A.signExt(Y)'\n    if not (expr.is_op() and expr.op.startswith('signExt')):\n        return expr\n    arg1 = expr.args[0]\n    if not (arg1.is_op() and arg1.op.startswith('signExt')):\n        return expr\n    arg2 = arg1.args[0]\n    return ExprOp(expr.op, arg2)",
            "def simp_double_signext(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'A.signExt(X).signExt(Y) => A.signExt(Y)'\n    if not (expr.is_op() and expr.op.startswith('signExt')):\n        return expr\n    arg1 = expr.args[0]\n    if not (arg1.is_op() and arg1.op.startswith('signExt')):\n        return expr\n    arg2 = arg1.args[0]\n    return ExprOp(expr.op, arg2)",
            "def simp_double_signext(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'A.signExt(X).signExt(Y) => A.signExt(Y)'\n    if not (expr.is_op() and expr.op.startswith('signExt')):\n        return expr\n    arg1 = expr.args[0]\n    if not (arg1.is_op() and arg1.op.startswith('signExt')):\n        return expr\n    arg2 = arg1.args[0]\n    return ExprOp(expr.op, arg2)"
        ]
    },
    {
        "func_name": "simp_zeroext_eq_cst",
        "original": "def simp_zeroext_eq_cst(_, expr):\n    \"\"\"A.zeroExt(X) == int => A == int[:A.size]\"\"\"\n    if not expr.is_op(TOK_EQUAL):\n        return expr\n    (arg1, arg2) = expr.args\n    if not arg2.is_int():\n        return expr\n    if not (arg1.is_op() and arg1.op.startswith('zeroExt')):\n        return expr\n    src = arg1.args[0]\n    if int(arg2) > 1 << src.size:\n        return ExprInt(0, expr.size)\n    return ExprOp(TOK_EQUAL, src, ExprInt(int(arg2), src.size))",
        "mutated": [
            "def simp_zeroext_eq_cst(_, expr):\n    if False:\n        i = 10\n    'A.zeroExt(X) == int => A == int[:A.size]'\n    if not expr.is_op(TOK_EQUAL):\n        return expr\n    (arg1, arg2) = expr.args\n    if not arg2.is_int():\n        return expr\n    if not (arg1.is_op() and arg1.op.startswith('zeroExt')):\n        return expr\n    src = arg1.args[0]\n    if int(arg2) > 1 << src.size:\n        return ExprInt(0, expr.size)\n    return ExprOp(TOK_EQUAL, src, ExprInt(int(arg2), src.size))",
            "def simp_zeroext_eq_cst(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'A.zeroExt(X) == int => A == int[:A.size]'\n    if not expr.is_op(TOK_EQUAL):\n        return expr\n    (arg1, arg2) = expr.args\n    if not arg2.is_int():\n        return expr\n    if not (arg1.is_op() and arg1.op.startswith('zeroExt')):\n        return expr\n    src = arg1.args[0]\n    if int(arg2) > 1 << src.size:\n        return ExprInt(0, expr.size)\n    return ExprOp(TOK_EQUAL, src, ExprInt(int(arg2), src.size))",
            "def simp_zeroext_eq_cst(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'A.zeroExt(X) == int => A == int[:A.size]'\n    if not expr.is_op(TOK_EQUAL):\n        return expr\n    (arg1, arg2) = expr.args\n    if not arg2.is_int():\n        return expr\n    if not (arg1.is_op() and arg1.op.startswith('zeroExt')):\n        return expr\n    src = arg1.args[0]\n    if int(arg2) > 1 << src.size:\n        return ExprInt(0, expr.size)\n    return ExprOp(TOK_EQUAL, src, ExprInt(int(arg2), src.size))",
            "def simp_zeroext_eq_cst(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'A.zeroExt(X) == int => A == int[:A.size]'\n    if not expr.is_op(TOK_EQUAL):\n        return expr\n    (arg1, arg2) = expr.args\n    if not arg2.is_int():\n        return expr\n    if not (arg1.is_op() and arg1.op.startswith('zeroExt')):\n        return expr\n    src = arg1.args[0]\n    if int(arg2) > 1 << src.size:\n        return ExprInt(0, expr.size)\n    return ExprOp(TOK_EQUAL, src, ExprInt(int(arg2), src.size))",
            "def simp_zeroext_eq_cst(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'A.zeroExt(X) == int => A == int[:A.size]'\n    if not expr.is_op(TOK_EQUAL):\n        return expr\n    (arg1, arg2) = expr.args\n    if not arg2.is_int():\n        return expr\n    if not (arg1.is_op() and arg1.op.startswith('zeroExt')):\n        return expr\n    src = arg1.args[0]\n    if int(arg2) > 1 << src.size:\n        return ExprInt(0, expr.size)\n    return ExprOp(TOK_EQUAL, src, ExprInt(int(arg2), src.size))"
        ]
    },
    {
        "func_name": "simp_cond_zeroext",
        "original": "def simp_cond_zeroext(_, expr):\n    \"\"\"\n    X.zeroExt()?(A:B) => X ? A:B\n    X.signExt()?(A:B) => X ? A:B\n    \"\"\"\n    if not (expr.cond.is_op() and (expr.cond.op.startswith('zeroExt') or expr.cond.op.startswith('signExt'))):\n        return expr\n    ret = ExprCond(expr.cond.args[0], expr.src1, expr.src2)\n    return ret",
        "mutated": [
            "def simp_cond_zeroext(_, expr):\n    if False:\n        i = 10\n    '\\n    X.zeroExt()?(A:B) => X ? A:B\\n    X.signExt()?(A:B) => X ? A:B\\n    '\n    if not (expr.cond.is_op() and (expr.cond.op.startswith('zeroExt') or expr.cond.op.startswith('signExt'))):\n        return expr\n    ret = ExprCond(expr.cond.args[0], expr.src1, expr.src2)\n    return ret",
            "def simp_cond_zeroext(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    X.zeroExt()?(A:B) => X ? A:B\\n    X.signExt()?(A:B) => X ? A:B\\n    '\n    if not (expr.cond.is_op() and (expr.cond.op.startswith('zeroExt') or expr.cond.op.startswith('signExt'))):\n        return expr\n    ret = ExprCond(expr.cond.args[0], expr.src1, expr.src2)\n    return ret",
            "def simp_cond_zeroext(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    X.zeroExt()?(A:B) => X ? A:B\\n    X.signExt()?(A:B) => X ? A:B\\n    '\n    if not (expr.cond.is_op() and (expr.cond.op.startswith('zeroExt') or expr.cond.op.startswith('signExt'))):\n        return expr\n    ret = ExprCond(expr.cond.args[0], expr.src1, expr.src2)\n    return ret",
            "def simp_cond_zeroext(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    X.zeroExt()?(A:B) => X ? A:B\\n    X.signExt()?(A:B) => X ? A:B\\n    '\n    if not (expr.cond.is_op() and (expr.cond.op.startswith('zeroExt') or expr.cond.op.startswith('signExt'))):\n        return expr\n    ret = ExprCond(expr.cond.args[0], expr.src1, expr.src2)\n    return ret",
            "def simp_cond_zeroext(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    X.zeroExt()?(A:B) => X ? A:B\\n    X.signExt()?(A:B) => X ? A:B\\n    '\n    if not (expr.cond.is_op() and (expr.cond.op.startswith('zeroExt') or expr.cond.op.startswith('signExt'))):\n        return expr\n    ret = ExprCond(expr.cond.args[0], expr.src1, expr.src2)\n    return ret"
        ]
    },
    {
        "func_name": "simp_ext_eq_ext",
        "original": "def simp_ext_eq_ext(_, expr):\n    \"\"\"\n    A.zeroExt(X) == B.zeroExt(X) => A == B\n    A.signExt(X) == B.signExt(X) => A == B\n    \"\"\"\n    if not expr.is_op(TOK_EQUAL):\n        return expr\n    (arg1, arg2) = expr.args\n    if not (arg1.is_op() and arg1.op.startswith('zeroExt') and arg2.is_op() and arg2.op.startswith('zeroExt') or (arg1.is_op() and arg1.op.startswith('signExt') and arg2.is_op() and arg2.op.startswith('signExt'))):\n        return expr\n    if arg1.args[0].size != arg2.args[0].size:\n        return expr\n    return ExprOp(TOK_EQUAL, arg1.args[0], arg2.args[0])",
        "mutated": [
            "def simp_ext_eq_ext(_, expr):\n    if False:\n        i = 10\n    '\\n    A.zeroExt(X) == B.zeroExt(X) => A == B\\n    A.signExt(X) == B.signExt(X) => A == B\\n    '\n    if not expr.is_op(TOK_EQUAL):\n        return expr\n    (arg1, arg2) = expr.args\n    if not (arg1.is_op() and arg1.op.startswith('zeroExt') and arg2.is_op() and arg2.op.startswith('zeroExt') or (arg1.is_op() and arg1.op.startswith('signExt') and arg2.is_op() and arg2.op.startswith('signExt'))):\n        return expr\n    if arg1.args[0].size != arg2.args[0].size:\n        return expr\n    return ExprOp(TOK_EQUAL, arg1.args[0], arg2.args[0])",
            "def simp_ext_eq_ext(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    A.zeroExt(X) == B.zeroExt(X) => A == B\\n    A.signExt(X) == B.signExt(X) => A == B\\n    '\n    if not expr.is_op(TOK_EQUAL):\n        return expr\n    (arg1, arg2) = expr.args\n    if not (arg1.is_op() and arg1.op.startswith('zeroExt') and arg2.is_op() and arg2.op.startswith('zeroExt') or (arg1.is_op() and arg1.op.startswith('signExt') and arg2.is_op() and arg2.op.startswith('signExt'))):\n        return expr\n    if arg1.args[0].size != arg2.args[0].size:\n        return expr\n    return ExprOp(TOK_EQUAL, arg1.args[0], arg2.args[0])",
            "def simp_ext_eq_ext(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    A.zeroExt(X) == B.zeroExt(X) => A == B\\n    A.signExt(X) == B.signExt(X) => A == B\\n    '\n    if not expr.is_op(TOK_EQUAL):\n        return expr\n    (arg1, arg2) = expr.args\n    if not (arg1.is_op() and arg1.op.startswith('zeroExt') and arg2.is_op() and arg2.op.startswith('zeroExt') or (arg1.is_op() and arg1.op.startswith('signExt') and arg2.is_op() and arg2.op.startswith('signExt'))):\n        return expr\n    if arg1.args[0].size != arg2.args[0].size:\n        return expr\n    return ExprOp(TOK_EQUAL, arg1.args[0], arg2.args[0])",
            "def simp_ext_eq_ext(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    A.zeroExt(X) == B.zeroExt(X) => A == B\\n    A.signExt(X) == B.signExt(X) => A == B\\n    '\n    if not expr.is_op(TOK_EQUAL):\n        return expr\n    (arg1, arg2) = expr.args\n    if not (arg1.is_op() and arg1.op.startswith('zeroExt') and arg2.is_op() and arg2.op.startswith('zeroExt') or (arg1.is_op() and arg1.op.startswith('signExt') and arg2.is_op() and arg2.op.startswith('signExt'))):\n        return expr\n    if arg1.args[0].size != arg2.args[0].size:\n        return expr\n    return ExprOp(TOK_EQUAL, arg1.args[0], arg2.args[0])",
            "def simp_ext_eq_ext(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    A.zeroExt(X) == B.zeroExt(X) => A == B\\n    A.signExt(X) == B.signExt(X) => A == B\\n    '\n    if not expr.is_op(TOK_EQUAL):\n        return expr\n    (arg1, arg2) = expr.args\n    if not (arg1.is_op() and arg1.op.startswith('zeroExt') and arg2.is_op() and arg2.op.startswith('zeroExt') or (arg1.is_op() and arg1.op.startswith('signExt') and arg2.is_op() and arg2.op.startswith('signExt'))):\n        return expr\n    if arg1.args[0].size != arg2.args[0].size:\n        return expr\n    return ExprOp(TOK_EQUAL, arg1.args[0], arg2.args[0])"
        ]
    },
    {
        "func_name": "simp_cond_eq_zero",
        "original": "def simp_cond_eq_zero(_, expr):\n    \"\"\"(X == 0)?(A:B) => X?(B:A)\"\"\"\n    cond = expr.cond\n    if not cond.is_op(TOK_EQUAL):\n        return expr\n    (arg1, arg2) = cond.args\n    if not arg2.is_int(0):\n        return expr\n    new_expr = ExprCond(arg1, expr.src2, expr.src1)\n    return new_expr",
        "mutated": [
            "def simp_cond_eq_zero(_, expr):\n    if False:\n        i = 10\n    '(X == 0)?(A:B) => X?(B:A)'\n    cond = expr.cond\n    if not cond.is_op(TOK_EQUAL):\n        return expr\n    (arg1, arg2) = cond.args\n    if not arg2.is_int(0):\n        return expr\n    new_expr = ExprCond(arg1, expr.src2, expr.src1)\n    return new_expr",
            "def simp_cond_eq_zero(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '(X == 0)?(A:B) => X?(B:A)'\n    cond = expr.cond\n    if not cond.is_op(TOK_EQUAL):\n        return expr\n    (arg1, arg2) = cond.args\n    if not arg2.is_int(0):\n        return expr\n    new_expr = ExprCond(arg1, expr.src2, expr.src1)\n    return new_expr",
            "def simp_cond_eq_zero(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '(X == 0)?(A:B) => X?(B:A)'\n    cond = expr.cond\n    if not cond.is_op(TOK_EQUAL):\n        return expr\n    (arg1, arg2) = cond.args\n    if not arg2.is_int(0):\n        return expr\n    new_expr = ExprCond(arg1, expr.src2, expr.src1)\n    return new_expr",
            "def simp_cond_eq_zero(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '(X == 0)?(A:B) => X?(B:A)'\n    cond = expr.cond\n    if not cond.is_op(TOK_EQUAL):\n        return expr\n    (arg1, arg2) = cond.args\n    if not arg2.is_int(0):\n        return expr\n    new_expr = ExprCond(arg1, expr.src2, expr.src1)\n    return new_expr",
            "def simp_cond_eq_zero(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '(X == 0)?(A:B) => X?(B:A)'\n    cond = expr.cond\n    if not cond.is_op(TOK_EQUAL):\n        return expr\n    (arg1, arg2) = cond.args\n    if not arg2.is_int(0):\n        return expr\n    new_expr = ExprCond(arg1, expr.src2, expr.src1)\n    return new_expr"
        ]
    },
    {
        "func_name": "simp_sign_inf_zeroext",
        "original": "def simp_sign_inf_zeroext(expr_s, expr):\n    \"\"\"\n    /!\\\\ Ensure before: X.zeroExt(X.size) => X\n\n    X.zeroExt() <s 0 => 0\n    X.zeroExt() <=s 0 => X == 0\n\n    X.zeroExt() <s cst => X.zeroExt() <u cst (cst positive)\n    X.zeroExt() <=s cst => X.zeroExt() <=u cst (cst positive)\n\n    X.zeroExt() <s cst => 0 (cst negative)\n    X.zeroExt() <=s cst => 0 (cst negative)\n\n    \"\"\"\n    if not (expr.is_op(TOK_INF_SIGNED) or expr.is_op(TOK_INF_EQUAL_SIGNED)):\n        return expr\n    (arg1, arg2) = expr.args\n    if not arg2.is_int():\n        return expr\n    if not (arg1.is_op() and arg1.op.startswith('zeroExt')):\n        return expr\n    src = arg1.args[0]\n    assert src.size < arg1.size\n    if arg2.is_int(0):\n        if expr.is_op(TOK_INF_SIGNED):\n            return ExprInt(0, expr.size)\n        else:\n            return ExprOp(TOK_EQUAL, src, ExprInt(0, src.size))\n    cst = int(arg2)\n    if cst & 1 << arg2.size - 1:\n        return ExprInt(0, expr.size)\n    if expr.is_op(TOK_INF_SIGNED):\n        return ExprOp(TOK_INF_UNSIGNED, src, expr_s(arg2[:src.size]))\n    return ExprOp(TOK_INF_EQUAL_UNSIGNED, src, expr_s(arg2[:src.size]))",
        "mutated": [
            "def simp_sign_inf_zeroext(expr_s, expr):\n    if False:\n        i = 10\n    '\\n    /!\\\\ Ensure before: X.zeroExt(X.size) => X\\n\\n    X.zeroExt() <s 0 => 0\\n    X.zeroExt() <=s 0 => X == 0\\n\\n    X.zeroExt() <s cst => X.zeroExt() <u cst (cst positive)\\n    X.zeroExt() <=s cst => X.zeroExt() <=u cst (cst positive)\\n\\n    X.zeroExt() <s cst => 0 (cst negative)\\n    X.zeroExt() <=s cst => 0 (cst negative)\\n\\n    '\n    if not (expr.is_op(TOK_INF_SIGNED) or expr.is_op(TOK_INF_EQUAL_SIGNED)):\n        return expr\n    (arg1, arg2) = expr.args\n    if not arg2.is_int():\n        return expr\n    if not (arg1.is_op() and arg1.op.startswith('zeroExt')):\n        return expr\n    src = arg1.args[0]\n    assert src.size < arg1.size\n    if arg2.is_int(0):\n        if expr.is_op(TOK_INF_SIGNED):\n            return ExprInt(0, expr.size)\n        else:\n            return ExprOp(TOK_EQUAL, src, ExprInt(0, src.size))\n    cst = int(arg2)\n    if cst & 1 << arg2.size - 1:\n        return ExprInt(0, expr.size)\n    if expr.is_op(TOK_INF_SIGNED):\n        return ExprOp(TOK_INF_UNSIGNED, src, expr_s(arg2[:src.size]))\n    return ExprOp(TOK_INF_EQUAL_UNSIGNED, src, expr_s(arg2[:src.size]))",
            "def simp_sign_inf_zeroext(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    /!\\\\ Ensure before: X.zeroExt(X.size) => X\\n\\n    X.zeroExt() <s 0 => 0\\n    X.zeroExt() <=s 0 => X == 0\\n\\n    X.zeroExt() <s cst => X.zeroExt() <u cst (cst positive)\\n    X.zeroExt() <=s cst => X.zeroExt() <=u cst (cst positive)\\n\\n    X.zeroExt() <s cst => 0 (cst negative)\\n    X.zeroExt() <=s cst => 0 (cst negative)\\n\\n    '\n    if not (expr.is_op(TOK_INF_SIGNED) or expr.is_op(TOK_INF_EQUAL_SIGNED)):\n        return expr\n    (arg1, arg2) = expr.args\n    if not arg2.is_int():\n        return expr\n    if not (arg1.is_op() and arg1.op.startswith('zeroExt')):\n        return expr\n    src = arg1.args[0]\n    assert src.size < arg1.size\n    if arg2.is_int(0):\n        if expr.is_op(TOK_INF_SIGNED):\n            return ExprInt(0, expr.size)\n        else:\n            return ExprOp(TOK_EQUAL, src, ExprInt(0, src.size))\n    cst = int(arg2)\n    if cst & 1 << arg2.size - 1:\n        return ExprInt(0, expr.size)\n    if expr.is_op(TOK_INF_SIGNED):\n        return ExprOp(TOK_INF_UNSIGNED, src, expr_s(arg2[:src.size]))\n    return ExprOp(TOK_INF_EQUAL_UNSIGNED, src, expr_s(arg2[:src.size]))",
            "def simp_sign_inf_zeroext(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    /!\\\\ Ensure before: X.zeroExt(X.size) => X\\n\\n    X.zeroExt() <s 0 => 0\\n    X.zeroExt() <=s 0 => X == 0\\n\\n    X.zeroExt() <s cst => X.zeroExt() <u cst (cst positive)\\n    X.zeroExt() <=s cst => X.zeroExt() <=u cst (cst positive)\\n\\n    X.zeroExt() <s cst => 0 (cst negative)\\n    X.zeroExt() <=s cst => 0 (cst negative)\\n\\n    '\n    if not (expr.is_op(TOK_INF_SIGNED) or expr.is_op(TOK_INF_EQUAL_SIGNED)):\n        return expr\n    (arg1, arg2) = expr.args\n    if not arg2.is_int():\n        return expr\n    if not (arg1.is_op() and arg1.op.startswith('zeroExt')):\n        return expr\n    src = arg1.args[0]\n    assert src.size < arg1.size\n    if arg2.is_int(0):\n        if expr.is_op(TOK_INF_SIGNED):\n            return ExprInt(0, expr.size)\n        else:\n            return ExprOp(TOK_EQUAL, src, ExprInt(0, src.size))\n    cst = int(arg2)\n    if cst & 1 << arg2.size - 1:\n        return ExprInt(0, expr.size)\n    if expr.is_op(TOK_INF_SIGNED):\n        return ExprOp(TOK_INF_UNSIGNED, src, expr_s(arg2[:src.size]))\n    return ExprOp(TOK_INF_EQUAL_UNSIGNED, src, expr_s(arg2[:src.size]))",
            "def simp_sign_inf_zeroext(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    /!\\\\ Ensure before: X.zeroExt(X.size) => X\\n\\n    X.zeroExt() <s 0 => 0\\n    X.zeroExt() <=s 0 => X == 0\\n\\n    X.zeroExt() <s cst => X.zeroExt() <u cst (cst positive)\\n    X.zeroExt() <=s cst => X.zeroExt() <=u cst (cst positive)\\n\\n    X.zeroExt() <s cst => 0 (cst negative)\\n    X.zeroExt() <=s cst => 0 (cst negative)\\n\\n    '\n    if not (expr.is_op(TOK_INF_SIGNED) or expr.is_op(TOK_INF_EQUAL_SIGNED)):\n        return expr\n    (arg1, arg2) = expr.args\n    if not arg2.is_int():\n        return expr\n    if not (arg1.is_op() and arg1.op.startswith('zeroExt')):\n        return expr\n    src = arg1.args[0]\n    assert src.size < arg1.size\n    if arg2.is_int(0):\n        if expr.is_op(TOK_INF_SIGNED):\n            return ExprInt(0, expr.size)\n        else:\n            return ExprOp(TOK_EQUAL, src, ExprInt(0, src.size))\n    cst = int(arg2)\n    if cst & 1 << arg2.size - 1:\n        return ExprInt(0, expr.size)\n    if expr.is_op(TOK_INF_SIGNED):\n        return ExprOp(TOK_INF_UNSIGNED, src, expr_s(arg2[:src.size]))\n    return ExprOp(TOK_INF_EQUAL_UNSIGNED, src, expr_s(arg2[:src.size]))",
            "def simp_sign_inf_zeroext(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    /!\\\\ Ensure before: X.zeroExt(X.size) => X\\n\\n    X.zeroExt() <s 0 => 0\\n    X.zeroExt() <=s 0 => X == 0\\n\\n    X.zeroExt() <s cst => X.zeroExt() <u cst (cst positive)\\n    X.zeroExt() <=s cst => X.zeroExt() <=u cst (cst positive)\\n\\n    X.zeroExt() <s cst => 0 (cst negative)\\n    X.zeroExt() <=s cst => 0 (cst negative)\\n\\n    '\n    if not (expr.is_op(TOK_INF_SIGNED) or expr.is_op(TOK_INF_EQUAL_SIGNED)):\n        return expr\n    (arg1, arg2) = expr.args\n    if not arg2.is_int():\n        return expr\n    if not (arg1.is_op() and arg1.op.startswith('zeroExt')):\n        return expr\n    src = arg1.args[0]\n    assert src.size < arg1.size\n    if arg2.is_int(0):\n        if expr.is_op(TOK_INF_SIGNED):\n            return ExprInt(0, expr.size)\n        else:\n            return ExprOp(TOK_EQUAL, src, ExprInt(0, src.size))\n    cst = int(arg2)\n    if cst & 1 << arg2.size - 1:\n        return ExprInt(0, expr.size)\n    if expr.is_op(TOK_INF_SIGNED):\n        return ExprOp(TOK_INF_UNSIGNED, src, expr_s(arg2[:src.size]))\n    return ExprOp(TOK_INF_EQUAL_UNSIGNED, src, expr_s(arg2[:src.size]))"
        ]
    },
    {
        "func_name": "simp_zeroext_and_cst_eq_cst",
        "original": "def simp_zeroext_and_cst_eq_cst(expr_s, expr):\n    \"\"\"\n    A.zeroExt(X) & ... & int == int => A & ... & int[:A.size] == int[:A.size]\n    \"\"\"\n    if not expr.is_op(TOK_EQUAL):\n        return expr\n    (arg1, arg2) = expr.args\n    if not arg2.is_int():\n        return expr\n    if not arg1.is_op('&'):\n        return expr\n    is_ok = True\n    sizes = set()\n    for arg in arg1.args:\n        if arg.is_int():\n            continue\n        if arg.is_op() and arg.op.startswith('zeroExt'):\n            sizes.add(arg.args[0].size)\n            continue\n        is_ok = False\n        break\n    if not is_ok:\n        return expr\n    if len(sizes) != 1:\n        return expr\n    size = list(sizes)[0]\n    if int(arg2) > (1 << size) - 1:\n        return expr\n    args = [expr_s(arg[:size]) for arg in arg1.args]\n    left = ExprOp('&', *args)\n    right = expr_s(arg2[:size])\n    ret = ExprOp(TOK_EQUAL, left, right)\n    return ret",
        "mutated": [
            "def simp_zeroext_and_cst_eq_cst(expr_s, expr):\n    if False:\n        i = 10\n    '\\n    A.zeroExt(X) & ... & int == int => A & ... & int[:A.size] == int[:A.size]\\n    '\n    if not expr.is_op(TOK_EQUAL):\n        return expr\n    (arg1, arg2) = expr.args\n    if not arg2.is_int():\n        return expr\n    if not arg1.is_op('&'):\n        return expr\n    is_ok = True\n    sizes = set()\n    for arg in arg1.args:\n        if arg.is_int():\n            continue\n        if arg.is_op() and arg.op.startswith('zeroExt'):\n            sizes.add(arg.args[0].size)\n            continue\n        is_ok = False\n        break\n    if not is_ok:\n        return expr\n    if len(sizes) != 1:\n        return expr\n    size = list(sizes)[0]\n    if int(arg2) > (1 << size) - 1:\n        return expr\n    args = [expr_s(arg[:size]) for arg in arg1.args]\n    left = ExprOp('&', *args)\n    right = expr_s(arg2[:size])\n    ret = ExprOp(TOK_EQUAL, left, right)\n    return ret",
            "def simp_zeroext_and_cst_eq_cst(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    A.zeroExt(X) & ... & int == int => A & ... & int[:A.size] == int[:A.size]\\n    '\n    if not expr.is_op(TOK_EQUAL):\n        return expr\n    (arg1, arg2) = expr.args\n    if not arg2.is_int():\n        return expr\n    if not arg1.is_op('&'):\n        return expr\n    is_ok = True\n    sizes = set()\n    for arg in arg1.args:\n        if arg.is_int():\n            continue\n        if arg.is_op() and arg.op.startswith('zeroExt'):\n            sizes.add(arg.args[0].size)\n            continue\n        is_ok = False\n        break\n    if not is_ok:\n        return expr\n    if len(sizes) != 1:\n        return expr\n    size = list(sizes)[0]\n    if int(arg2) > (1 << size) - 1:\n        return expr\n    args = [expr_s(arg[:size]) for arg in arg1.args]\n    left = ExprOp('&', *args)\n    right = expr_s(arg2[:size])\n    ret = ExprOp(TOK_EQUAL, left, right)\n    return ret",
            "def simp_zeroext_and_cst_eq_cst(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    A.zeroExt(X) & ... & int == int => A & ... & int[:A.size] == int[:A.size]\\n    '\n    if not expr.is_op(TOK_EQUAL):\n        return expr\n    (arg1, arg2) = expr.args\n    if not arg2.is_int():\n        return expr\n    if not arg1.is_op('&'):\n        return expr\n    is_ok = True\n    sizes = set()\n    for arg in arg1.args:\n        if arg.is_int():\n            continue\n        if arg.is_op() and arg.op.startswith('zeroExt'):\n            sizes.add(arg.args[0].size)\n            continue\n        is_ok = False\n        break\n    if not is_ok:\n        return expr\n    if len(sizes) != 1:\n        return expr\n    size = list(sizes)[0]\n    if int(arg2) > (1 << size) - 1:\n        return expr\n    args = [expr_s(arg[:size]) for arg in arg1.args]\n    left = ExprOp('&', *args)\n    right = expr_s(arg2[:size])\n    ret = ExprOp(TOK_EQUAL, left, right)\n    return ret",
            "def simp_zeroext_and_cst_eq_cst(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    A.zeroExt(X) & ... & int == int => A & ... & int[:A.size] == int[:A.size]\\n    '\n    if not expr.is_op(TOK_EQUAL):\n        return expr\n    (arg1, arg2) = expr.args\n    if not arg2.is_int():\n        return expr\n    if not arg1.is_op('&'):\n        return expr\n    is_ok = True\n    sizes = set()\n    for arg in arg1.args:\n        if arg.is_int():\n            continue\n        if arg.is_op() and arg.op.startswith('zeroExt'):\n            sizes.add(arg.args[0].size)\n            continue\n        is_ok = False\n        break\n    if not is_ok:\n        return expr\n    if len(sizes) != 1:\n        return expr\n    size = list(sizes)[0]\n    if int(arg2) > (1 << size) - 1:\n        return expr\n    args = [expr_s(arg[:size]) for arg in arg1.args]\n    left = ExprOp('&', *args)\n    right = expr_s(arg2[:size])\n    ret = ExprOp(TOK_EQUAL, left, right)\n    return ret",
            "def simp_zeroext_and_cst_eq_cst(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    A.zeroExt(X) & ... & int == int => A & ... & int[:A.size] == int[:A.size]\\n    '\n    if not expr.is_op(TOK_EQUAL):\n        return expr\n    (arg1, arg2) = expr.args\n    if not arg2.is_int():\n        return expr\n    if not arg1.is_op('&'):\n        return expr\n    is_ok = True\n    sizes = set()\n    for arg in arg1.args:\n        if arg.is_int():\n            continue\n        if arg.is_op() and arg.op.startswith('zeroExt'):\n            sizes.add(arg.args[0].size)\n            continue\n        is_ok = False\n        break\n    if not is_ok:\n        return expr\n    if len(sizes) != 1:\n        return expr\n    size = list(sizes)[0]\n    if int(arg2) > (1 << size) - 1:\n        return expr\n    args = [expr_s(arg[:size]) for arg in arg1.args]\n    left = ExprOp('&', *args)\n    right = expr_s(arg2[:size])\n    ret = ExprOp(TOK_EQUAL, left, right)\n    return ret"
        ]
    },
    {
        "func_name": "test_one_bit_set",
        "original": "def test_one_bit_set(arg):\n    \"\"\"\n    Return True if arg has form 1 << X\n    \"\"\"\n    return arg != 0 and arg & arg - 1 == 0",
        "mutated": [
            "def test_one_bit_set(arg):\n    if False:\n        i = 10\n    '\\n    Return True if arg has form 1 << X\\n    '\n    return arg != 0 and arg & arg - 1 == 0",
            "def test_one_bit_set(arg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return True if arg has form 1 << X\\n    '\n    return arg != 0 and arg & arg - 1 == 0",
            "def test_one_bit_set(arg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return True if arg has form 1 << X\\n    '\n    return arg != 0 and arg & arg - 1 == 0",
            "def test_one_bit_set(arg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return True if arg has form 1 << X\\n    '\n    return arg != 0 and arg & arg - 1 == 0",
            "def test_one_bit_set(arg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return True if arg has form 1 << X\\n    '\n    return arg != 0 and arg & arg - 1 == 0"
        ]
    },
    {
        "func_name": "simp_x_and_cst_eq_cst",
        "original": "def simp_x_and_cst_eq_cst(_, expr):\n    \"\"\"\n    (x & ... & onebitmask == onebitmask) ? A:B => (x & ... & onebitmask) ? A:B\n    \"\"\"\n    cond = expr.cond\n    if not cond.is_op(TOK_EQUAL):\n        return expr\n    (arg1, mask2) = cond.args\n    if not mask2.is_int():\n        return expr\n    if not test_one_bit_set(int(mask2)):\n        return expr\n    if not arg1.is_op('&'):\n        return expr\n    mask1 = arg1.args[-1]\n    if mask1 != mask2:\n        return expr\n    cond = ExprOp('&', *arg1.args)\n    return ExprCond(cond, expr.src1, expr.src2)",
        "mutated": [
            "def simp_x_and_cst_eq_cst(_, expr):\n    if False:\n        i = 10\n    '\\n    (x & ... & onebitmask == onebitmask) ? A:B => (x & ... & onebitmask) ? A:B\\n    '\n    cond = expr.cond\n    if not cond.is_op(TOK_EQUAL):\n        return expr\n    (arg1, mask2) = cond.args\n    if not mask2.is_int():\n        return expr\n    if not test_one_bit_set(int(mask2)):\n        return expr\n    if not arg1.is_op('&'):\n        return expr\n    mask1 = arg1.args[-1]\n    if mask1 != mask2:\n        return expr\n    cond = ExprOp('&', *arg1.args)\n    return ExprCond(cond, expr.src1, expr.src2)",
            "def simp_x_and_cst_eq_cst(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    (x & ... & onebitmask == onebitmask) ? A:B => (x & ... & onebitmask) ? A:B\\n    '\n    cond = expr.cond\n    if not cond.is_op(TOK_EQUAL):\n        return expr\n    (arg1, mask2) = cond.args\n    if not mask2.is_int():\n        return expr\n    if not test_one_bit_set(int(mask2)):\n        return expr\n    if not arg1.is_op('&'):\n        return expr\n    mask1 = arg1.args[-1]\n    if mask1 != mask2:\n        return expr\n    cond = ExprOp('&', *arg1.args)\n    return ExprCond(cond, expr.src1, expr.src2)",
            "def simp_x_and_cst_eq_cst(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    (x & ... & onebitmask == onebitmask) ? A:B => (x & ... & onebitmask) ? A:B\\n    '\n    cond = expr.cond\n    if not cond.is_op(TOK_EQUAL):\n        return expr\n    (arg1, mask2) = cond.args\n    if not mask2.is_int():\n        return expr\n    if not test_one_bit_set(int(mask2)):\n        return expr\n    if not arg1.is_op('&'):\n        return expr\n    mask1 = arg1.args[-1]\n    if mask1 != mask2:\n        return expr\n    cond = ExprOp('&', *arg1.args)\n    return ExprCond(cond, expr.src1, expr.src2)",
            "def simp_x_and_cst_eq_cst(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    (x & ... & onebitmask == onebitmask) ? A:B => (x & ... & onebitmask) ? A:B\\n    '\n    cond = expr.cond\n    if not cond.is_op(TOK_EQUAL):\n        return expr\n    (arg1, mask2) = cond.args\n    if not mask2.is_int():\n        return expr\n    if not test_one_bit_set(int(mask2)):\n        return expr\n    if not arg1.is_op('&'):\n        return expr\n    mask1 = arg1.args[-1]\n    if mask1 != mask2:\n        return expr\n    cond = ExprOp('&', *arg1.args)\n    return ExprCond(cond, expr.src1, expr.src2)",
            "def simp_x_and_cst_eq_cst(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    (x & ... & onebitmask == onebitmask) ? A:B => (x & ... & onebitmask) ? A:B\\n    '\n    cond = expr.cond\n    if not cond.is_op(TOK_EQUAL):\n        return expr\n    (arg1, mask2) = cond.args\n    if not mask2.is_int():\n        return expr\n    if not test_one_bit_set(int(mask2)):\n        return expr\n    if not arg1.is_op('&'):\n        return expr\n    mask1 = arg1.args[-1]\n    if mask1 != mask2:\n        return expr\n    cond = ExprOp('&', *arg1.args)\n    return ExprCond(cond, expr.src1, expr.src2)"
        ]
    },
    {
        "func_name": "simp_cmp_int_int",
        "original": "def simp_cmp_int_int(_, expr):\n    \"\"\"\n    IntA <s IntB => int\n    IntA <u IntB => int\n    IntA <=s IntB => int\n    IntA <=u IntB => int\n    IntA == IntB => int\n    \"\"\"\n    if expr.op not in [TOK_EQUAL, TOK_INF_SIGNED, TOK_INF_UNSIGNED, TOK_INF_EQUAL_SIGNED, TOK_INF_EQUAL_UNSIGNED]:\n        return expr\n    if not all((arg.is_int() for arg in expr.args)):\n        return expr\n    (int_a, int_b) = expr.args\n    if expr.is_op(TOK_EQUAL):\n        if int_a == int_b:\n            return ExprInt(1, 1)\n        return ExprInt(0, expr.size)\n    if expr.op in [TOK_INF_SIGNED, TOK_INF_EQUAL_SIGNED]:\n        int_a = int(mod_size2int[int_a.size](int(int_a)))\n        int_b = int(mod_size2int[int_b.size](int(int_b)))\n    else:\n        int_a = int(mod_size2uint[int_a.size](int(int_a)))\n        int_b = int(mod_size2uint[int_b.size](int(int_b)))\n    if expr.op in [TOK_INF_SIGNED, TOK_INF_UNSIGNED]:\n        ret = int_a < int_b\n    else:\n        ret = int_a <= int_b\n    if ret:\n        ret = 1\n    else:\n        ret = 0\n    return ExprInt(ret, 1)",
        "mutated": [
            "def simp_cmp_int_int(_, expr):\n    if False:\n        i = 10\n    '\\n    IntA <s IntB => int\\n    IntA <u IntB => int\\n    IntA <=s IntB => int\\n    IntA <=u IntB => int\\n    IntA == IntB => int\\n    '\n    if expr.op not in [TOK_EQUAL, TOK_INF_SIGNED, TOK_INF_UNSIGNED, TOK_INF_EQUAL_SIGNED, TOK_INF_EQUAL_UNSIGNED]:\n        return expr\n    if not all((arg.is_int() for arg in expr.args)):\n        return expr\n    (int_a, int_b) = expr.args\n    if expr.is_op(TOK_EQUAL):\n        if int_a == int_b:\n            return ExprInt(1, 1)\n        return ExprInt(0, expr.size)\n    if expr.op in [TOK_INF_SIGNED, TOK_INF_EQUAL_SIGNED]:\n        int_a = int(mod_size2int[int_a.size](int(int_a)))\n        int_b = int(mod_size2int[int_b.size](int(int_b)))\n    else:\n        int_a = int(mod_size2uint[int_a.size](int(int_a)))\n        int_b = int(mod_size2uint[int_b.size](int(int_b)))\n    if expr.op in [TOK_INF_SIGNED, TOK_INF_UNSIGNED]:\n        ret = int_a < int_b\n    else:\n        ret = int_a <= int_b\n    if ret:\n        ret = 1\n    else:\n        ret = 0\n    return ExprInt(ret, 1)",
            "def simp_cmp_int_int(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    IntA <s IntB => int\\n    IntA <u IntB => int\\n    IntA <=s IntB => int\\n    IntA <=u IntB => int\\n    IntA == IntB => int\\n    '\n    if expr.op not in [TOK_EQUAL, TOK_INF_SIGNED, TOK_INF_UNSIGNED, TOK_INF_EQUAL_SIGNED, TOK_INF_EQUAL_UNSIGNED]:\n        return expr\n    if not all((arg.is_int() for arg in expr.args)):\n        return expr\n    (int_a, int_b) = expr.args\n    if expr.is_op(TOK_EQUAL):\n        if int_a == int_b:\n            return ExprInt(1, 1)\n        return ExprInt(0, expr.size)\n    if expr.op in [TOK_INF_SIGNED, TOK_INF_EQUAL_SIGNED]:\n        int_a = int(mod_size2int[int_a.size](int(int_a)))\n        int_b = int(mod_size2int[int_b.size](int(int_b)))\n    else:\n        int_a = int(mod_size2uint[int_a.size](int(int_a)))\n        int_b = int(mod_size2uint[int_b.size](int(int_b)))\n    if expr.op in [TOK_INF_SIGNED, TOK_INF_UNSIGNED]:\n        ret = int_a < int_b\n    else:\n        ret = int_a <= int_b\n    if ret:\n        ret = 1\n    else:\n        ret = 0\n    return ExprInt(ret, 1)",
            "def simp_cmp_int_int(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    IntA <s IntB => int\\n    IntA <u IntB => int\\n    IntA <=s IntB => int\\n    IntA <=u IntB => int\\n    IntA == IntB => int\\n    '\n    if expr.op not in [TOK_EQUAL, TOK_INF_SIGNED, TOK_INF_UNSIGNED, TOK_INF_EQUAL_SIGNED, TOK_INF_EQUAL_UNSIGNED]:\n        return expr\n    if not all((arg.is_int() for arg in expr.args)):\n        return expr\n    (int_a, int_b) = expr.args\n    if expr.is_op(TOK_EQUAL):\n        if int_a == int_b:\n            return ExprInt(1, 1)\n        return ExprInt(0, expr.size)\n    if expr.op in [TOK_INF_SIGNED, TOK_INF_EQUAL_SIGNED]:\n        int_a = int(mod_size2int[int_a.size](int(int_a)))\n        int_b = int(mod_size2int[int_b.size](int(int_b)))\n    else:\n        int_a = int(mod_size2uint[int_a.size](int(int_a)))\n        int_b = int(mod_size2uint[int_b.size](int(int_b)))\n    if expr.op in [TOK_INF_SIGNED, TOK_INF_UNSIGNED]:\n        ret = int_a < int_b\n    else:\n        ret = int_a <= int_b\n    if ret:\n        ret = 1\n    else:\n        ret = 0\n    return ExprInt(ret, 1)",
            "def simp_cmp_int_int(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    IntA <s IntB => int\\n    IntA <u IntB => int\\n    IntA <=s IntB => int\\n    IntA <=u IntB => int\\n    IntA == IntB => int\\n    '\n    if expr.op not in [TOK_EQUAL, TOK_INF_SIGNED, TOK_INF_UNSIGNED, TOK_INF_EQUAL_SIGNED, TOK_INF_EQUAL_UNSIGNED]:\n        return expr\n    if not all((arg.is_int() for arg in expr.args)):\n        return expr\n    (int_a, int_b) = expr.args\n    if expr.is_op(TOK_EQUAL):\n        if int_a == int_b:\n            return ExprInt(1, 1)\n        return ExprInt(0, expr.size)\n    if expr.op in [TOK_INF_SIGNED, TOK_INF_EQUAL_SIGNED]:\n        int_a = int(mod_size2int[int_a.size](int(int_a)))\n        int_b = int(mod_size2int[int_b.size](int(int_b)))\n    else:\n        int_a = int(mod_size2uint[int_a.size](int(int_a)))\n        int_b = int(mod_size2uint[int_b.size](int(int_b)))\n    if expr.op in [TOK_INF_SIGNED, TOK_INF_UNSIGNED]:\n        ret = int_a < int_b\n    else:\n        ret = int_a <= int_b\n    if ret:\n        ret = 1\n    else:\n        ret = 0\n    return ExprInt(ret, 1)",
            "def simp_cmp_int_int(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    IntA <s IntB => int\\n    IntA <u IntB => int\\n    IntA <=s IntB => int\\n    IntA <=u IntB => int\\n    IntA == IntB => int\\n    '\n    if expr.op not in [TOK_EQUAL, TOK_INF_SIGNED, TOK_INF_UNSIGNED, TOK_INF_EQUAL_SIGNED, TOK_INF_EQUAL_UNSIGNED]:\n        return expr\n    if not all((arg.is_int() for arg in expr.args)):\n        return expr\n    (int_a, int_b) = expr.args\n    if expr.is_op(TOK_EQUAL):\n        if int_a == int_b:\n            return ExprInt(1, 1)\n        return ExprInt(0, expr.size)\n    if expr.op in [TOK_INF_SIGNED, TOK_INF_EQUAL_SIGNED]:\n        int_a = int(mod_size2int[int_a.size](int(int_a)))\n        int_b = int(mod_size2int[int_b.size](int(int_b)))\n    else:\n        int_a = int(mod_size2uint[int_a.size](int(int_a)))\n        int_b = int(mod_size2uint[int_b.size](int(int_b)))\n    if expr.op in [TOK_INF_SIGNED, TOK_INF_UNSIGNED]:\n        ret = int_a < int_b\n    else:\n        ret = int_a <= int_b\n    if ret:\n        ret = 1\n    else:\n        ret = 0\n    return ExprInt(ret, 1)"
        ]
    },
    {
        "func_name": "simp_ext_cst",
        "original": "def simp_ext_cst(_, expr):\n    \"\"\"\n    Int.zeroExt(X) => Int\n    Int.signExt(X) => Int\n    \"\"\"\n    if not (expr.op.startswith('zeroExt') or expr.op.startswith('signExt')):\n        return expr\n    arg = expr.args[0]\n    if not arg.is_int():\n        return expr\n    if expr.op.startswith('zeroExt'):\n        ret = int(arg)\n    else:\n        ret = int(mod_size2int[arg.size](int(arg)))\n    ret = ExprInt(ret, expr.size)\n    return ret",
        "mutated": [
            "def simp_ext_cst(_, expr):\n    if False:\n        i = 10\n    '\\n    Int.zeroExt(X) => Int\\n    Int.signExt(X) => Int\\n    '\n    if not (expr.op.startswith('zeroExt') or expr.op.startswith('signExt')):\n        return expr\n    arg = expr.args[0]\n    if not arg.is_int():\n        return expr\n    if expr.op.startswith('zeroExt'):\n        ret = int(arg)\n    else:\n        ret = int(mod_size2int[arg.size](int(arg)))\n    ret = ExprInt(ret, expr.size)\n    return ret",
            "def simp_ext_cst(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Int.zeroExt(X) => Int\\n    Int.signExt(X) => Int\\n    '\n    if not (expr.op.startswith('zeroExt') or expr.op.startswith('signExt')):\n        return expr\n    arg = expr.args[0]\n    if not arg.is_int():\n        return expr\n    if expr.op.startswith('zeroExt'):\n        ret = int(arg)\n    else:\n        ret = int(mod_size2int[arg.size](int(arg)))\n    ret = ExprInt(ret, expr.size)\n    return ret",
            "def simp_ext_cst(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Int.zeroExt(X) => Int\\n    Int.signExt(X) => Int\\n    '\n    if not (expr.op.startswith('zeroExt') or expr.op.startswith('signExt')):\n        return expr\n    arg = expr.args[0]\n    if not arg.is_int():\n        return expr\n    if expr.op.startswith('zeroExt'):\n        ret = int(arg)\n    else:\n        ret = int(mod_size2int[arg.size](int(arg)))\n    ret = ExprInt(ret, expr.size)\n    return ret",
            "def simp_ext_cst(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Int.zeroExt(X) => Int\\n    Int.signExt(X) => Int\\n    '\n    if not (expr.op.startswith('zeroExt') or expr.op.startswith('signExt')):\n        return expr\n    arg = expr.args[0]\n    if not arg.is_int():\n        return expr\n    if expr.op.startswith('zeroExt'):\n        ret = int(arg)\n    else:\n        ret = int(mod_size2int[arg.size](int(arg)))\n    ret = ExprInt(ret, expr.size)\n    return ret",
            "def simp_ext_cst(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Int.zeroExt(X) => Int\\n    Int.signExt(X) => Int\\n    '\n    if not (expr.op.startswith('zeroExt') or expr.op.startswith('signExt')):\n        return expr\n    arg = expr.args[0]\n    if not arg.is_int():\n        return expr\n    if expr.op.startswith('zeroExt'):\n        ret = int(arg)\n    else:\n        ret = int(mod_size2int[arg.size](int(arg)))\n    ret = ExprInt(ret, expr.size)\n    return ret"
        ]
    },
    {
        "func_name": "simp_ext_cond_int",
        "original": "def simp_ext_cond_int(e_s, expr):\n    \"\"\"\n    zeroExt(ExprCond(X, Int, Int)) => ExprCond(X, Int, Int)\n    \"\"\"\n    if not (expr.op.startswith('zeroExt') or expr.op.startswith('signExt')):\n        return expr\n    arg = expr.args[0]\n    if not arg.is_cond():\n        return expr\n    if not (arg.src1.is_int() and arg.src2.is_int()):\n        return expr\n    src1 = ExprOp(expr.op, arg.src1)\n    src2 = ExprOp(expr.op, arg.src2)\n    return e_s(ExprCond(arg.cond, src1, src2))",
        "mutated": [
            "def simp_ext_cond_int(e_s, expr):\n    if False:\n        i = 10\n    '\\n    zeroExt(ExprCond(X, Int, Int)) => ExprCond(X, Int, Int)\\n    '\n    if not (expr.op.startswith('zeroExt') or expr.op.startswith('signExt')):\n        return expr\n    arg = expr.args[0]\n    if not arg.is_cond():\n        return expr\n    if not (arg.src1.is_int() and arg.src2.is_int()):\n        return expr\n    src1 = ExprOp(expr.op, arg.src1)\n    src2 = ExprOp(expr.op, arg.src2)\n    return e_s(ExprCond(arg.cond, src1, src2))",
            "def simp_ext_cond_int(e_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    zeroExt(ExprCond(X, Int, Int)) => ExprCond(X, Int, Int)\\n    '\n    if not (expr.op.startswith('zeroExt') or expr.op.startswith('signExt')):\n        return expr\n    arg = expr.args[0]\n    if not arg.is_cond():\n        return expr\n    if not (arg.src1.is_int() and arg.src2.is_int()):\n        return expr\n    src1 = ExprOp(expr.op, arg.src1)\n    src2 = ExprOp(expr.op, arg.src2)\n    return e_s(ExprCond(arg.cond, src1, src2))",
            "def simp_ext_cond_int(e_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    zeroExt(ExprCond(X, Int, Int)) => ExprCond(X, Int, Int)\\n    '\n    if not (expr.op.startswith('zeroExt') or expr.op.startswith('signExt')):\n        return expr\n    arg = expr.args[0]\n    if not arg.is_cond():\n        return expr\n    if not (arg.src1.is_int() and arg.src2.is_int()):\n        return expr\n    src1 = ExprOp(expr.op, arg.src1)\n    src2 = ExprOp(expr.op, arg.src2)\n    return e_s(ExprCond(arg.cond, src1, src2))",
            "def simp_ext_cond_int(e_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    zeroExt(ExprCond(X, Int, Int)) => ExprCond(X, Int, Int)\\n    '\n    if not (expr.op.startswith('zeroExt') or expr.op.startswith('signExt')):\n        return expr\n    arg = expr.args[0]\n    if not arg.is_cond():\n        return expr\n    if not (arg.src1.is_int() and arg.src2.is_int()):\n        return expr\n    src1 = ExprOp(expr.op, arg.src1)\n    src2 = ExprOp(expr.op, arg.src2)\n    return e_s(ExprCond(arg.cond, src1, src2))",
            "def simp_ext_cond_int(e_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    zeroExt(ExprCond(X, Int, Int)) => ExprCond(X, Int, Int)\\n    '\n    if not (expr.op.startswith('zeroExt') or expr.op.startswith('signExt')):\n        return expr\n    arg = expr.args[0]\n    if not arg.is_cond():\n        return expr\n    if not (arg.src1.is_int() and arg.src2.is_int()):\n        return expr\n    src1 = ExprOp(expr.op, arg.src1)\n    src2 = ExprOp(expr.op, arg.src2)\n    return e_s(ExprCond(arg.cond, src1, src2))"
        ]
    },
    {
        "func_name": "simp_slice_of_ext",
        "original": "def simp_slice_of_ext(_, expr):\n    \"\"\"\n    C.zeroExt(X)[A:B] => 0 if A >= size(C)\n    C.zeroExt(X)[A:B] => C[A:B] if B <= size(C)\n    A.zeroExt(X)[0:Y] => A.zeroExt(Y)\n    \"\"\"\n    if not expr.arg.is_op():\n        return expr\n    if not expr.arg.op.startswith('zeroExt'):\n        return expr\n    arg = expr.arg.args[0]\n    if expr.start >= arg.size:\n        return ExprInt(0, expr.size)\n    if expr.stop <= arg.size:\n        return arg[expr.start:expr.stop]\n    if expr.start == 0:\n        return arg.zeroExtend(expr.stop)\n    return expr",
        "mutated": [
            "def simp_slice_of_ext(_, expr):\n    if False:\n        i = 10\n    '\\n    C.zeroExt(X)[A:B] => 0 if A >= size(C)\\n    C.zeroExt(X)[A:B] => C[A:B] if B <= size(C)\\n    A.zeroExt(X)[0:Y] => A.zeroExt(Y)\\n    '\n    if not expr.arg.is_op():\n        return expr\n    if not expr.arg.op.startswith('zeroExt'):\n        return expr\n    arg = expr.arg.args[0]\n    if expr.start >= arg.size:\n        return ExprInt(0, expr.size)\n    if expr.stop <= arg.size:\n        return arg[expr.start:expr.stop]\n    if expr.start == 0:\n        return arg.zeroExtend(expr.stop)\n    return expr",
            "def simp_slice_of_ext(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    C.zeroExt(X)[A:B] => 0 if A >= size(C)\\n    C.zeroExt(X)[A:B] => C[A:B] if B <= size(C)\\n    A.zeroExt(X)[0:Y] => A.zeroExt(Y)\\n    '\n    if not expr.arg.is_op():\n        return expr\n    if not expr.arg.op.startswith('zeroExt'):\n        return expr\n    arg = expr.arg.args[0]\n    if expr.start >= arg.size:\n        return ExprInt(0, expr.size)\n    if expr.stop <= arg.size:\n        return arg[expr.start:expr.stop]\n    if expr.start == 0:\n        return arg.zeroExtend(expr.stop)\n    return expr",
            "def simp_slice_of_ext(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    C.zeroExt(X)[A:B] => 0 if A >= size(C)\\n    C.zeroExt(X)[A:B] => C[A:B] if B <= size(C)\\n    A.zeroExt(X)[0:Y] => A.zeroExt(Y)\\n    '\n    if not expr.arg.is_op():\n        return expr\n    if not expr.arg.op.startswith('zeroExt'):\n        return expr\n    arg = expr.arg.args[0]\n    if expr.start >= arg.size:\n        return ExprInt(0, expr.size)\n    if expr.stop <= arg.size:\n        return arg[expr.start:expr.stop]\n    if expr.start == 0:\n        return arg.zeroExtend(expr.stop)\n    return expr",
            "def simp_slice_of_ext(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    C.zeroExt(X)[A:B] => 0 if A >= size(C)\\n    C.zeroExt(X)[A:B] => C[A:B] if B <= size(C)\\n    A.zeroExt(X)[0:Y] => A.zeroExt(Y)\\n    '\n    if not expr.arg.is_op():\n        return expr\n    if not expr.arg.op.startswith('zeroExt'):\n        return expr\n    arg = expr.arg.args[0]\n    if expr.start >= arg.size:\n        return ExprInt(0, expr.size)\n    if expr.stop <= arg.size:\n        return arg[expr.start:expr.stop]\n    if expr.start == 0:\n        return arg.zeroExtend(expr.stop)\n    return expr",
            "def simp_slice_of_ext(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    C.zeroExt(X)[A:B] => 0 if A >= size(C)\\n    C.zeroExt(X)[A:B] => C[A:B] if B <= size(C)\\n    A.zeroExt(X)[0:Y] => A.zeroExt(Y)\\n    '\n    if not expr.arg.is_op():\n        return expr\n    if not expr.arg.op.startswith('zeroExt'):\n        return expr\n    arg = expr.arg.args[0]\n    if expr.start >= arg.size:\n        return ExprInt(0, expr.size)\n    if expr.stop <= arg.size:\n        return arg[expr.start:expr.stop]\n    if expr.start == 0:\n        return arg.zeroExtend(expr.stop)\n    return expr"
        ]
    },
    {
        "func_name": "simp_slice_of_sext",
        "original": "def simp_slice_of_sext(e_s, expr):\n    \"\"\"\n    with Y <= size(A)\n    A.signExt(X)[0:Y] => A[0:Y]\n    \"\"\"\n    if not expr.arg.is_op():\n        return expr\n    if not expr.arg.op.startswith('signExt'):\n        return expr\n    arg = expr.arg.args[0]\n    if expr.start != 0:\n        return expr\n    if expr.stop <= arg.size:\n        return e_s.expr_simp(arg[:expr.stop])\n    return expr",
        "mutated": [
            "def simp_slice_of_sext(e_s, expr):\n    if False:\n        i = 10\n    '\\n    with Y <= size(A)\\n    A.signExt(X)[0:Y] => A[0:Y]\\n    '\n    if not expr.arg.is_op():\n        return expr\n    if not expr.arg.op.startswith('signExt'):\n        return expr\n    arg = expr.arg.args[0]\n    if expr.start != 0:\n        return expr\n    if expr.stop <= arg.size:\n        return e_s.expr_simp(arg[:expr.stop])\n    return expr",
            "def simp_slice_of_sext(e_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    with Y <= size(A)\\n    A.signExt(X)[0:Y] => A[0:Y]\\n    '\n    if not expr.arg.is_op():\n        return expr\n    if not expr.arg.op.startswith('signExt'):\n        return expr\n    arg = expr.arg.args[0]\n    if expr.start != 0:\n        return expr\n    if expr.stop <= arg.size:\n        return e_s.expr_simp(arg[:expr.stop])\n    return expr",
            "def simp_slice_of_sext(e_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    with Y <= size(A)\\n    A.signExt(X)[0:Y] => A[0:Y]\\n    '\n    if not expr.arg.is_op():\n        return expr\n    if not expr.arg.op.startswith('signExt'):\n        return expr\n    arg = expr.arg.args[0]\n    if expr.start != 0:\n        return expr\n    if expr.stop <= arg.size:\n        return e_s.expr_simp(arg[:expr.stop])\n    return expr",
            "def simp_slice_of_sext(e_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    with Y <= size(A)\\n    A.signExt(X)[0:Y] => A[0:Y]\\n    '\n    if not expr.arg.is_op():\n        return expr\n    if not expr.arg.op.startswith('signExt'):\n        return expr\n    arg = expr.arg.args[0]\n    if expr.start != 0:\n        return expr\n    if expr.stop <= arg.size:\n        return e_s.expr_simp(arg[:expr.stop])\n    return expr",
            "def simp_slice_of_sext(e_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    with Y <= size(A)\\n    A.signExt(X)[0:Y] => A[0:Y]\\n    '\n    if not expr.arg.is_op():\n        return expr\n    if not expr.arg.op.startswith('signExt'):\n        return expr\n    arg = expr.arg.args[0]\n    if expr.start != 0:\n        return expr\n    if expr.stop <= arg.size:\n        return e_s.expr_simp(arg[:expr.stop])\n    return expr"
        ]
    },
    {
        "func_name": "simp_slice_of_op_ext",
        "original": "def simp_slice_of_op_ext(expr_s, expr):\n    \"\"\"\n    (X.zeroExt() + {Z, } + ... + Int)[0:8] => X + ... + int[:]\n    (X.zeroExt() | ... | Int)[0:8] => X | ... | int[:]\n    ...\n    \"\"\"\n    if expr.start != 0:\n        return expr\n    src = expr.arg\n    if not src.is_op():\n        return expr\n    if src.op not in ['+', '|', '^', '&']:\n        return expr\n    is_ok = True\n    for arg in src.args:\n        if arg.is_int():\n            continue\n        if arg.is_op() and arg.op.startswith('zeroExt') and (arg.args[0].size == expr.stop):\n            continue\n        if arg.is_compose():\n            continue\n        is_ok = False\n        break\n    if not is_ok:\n        return expr\n    args = [expr_s(arg[:expr.stop]) for arg in src.args]\n    return ExprOp(src.op, *args)",
        "mutated": [
            "def simp_slice_of_op_ext(expr_s, expr):\n    if False:\n        i = 10\n    '\\n    (X.zeroExt() + {Z, } + ... + Int)[0:8] => X + ... + int[:]\\n    (X.zeroExt() | ... | Int)[0:8] => X | ... | int[:]\\n    ...\\n    '\n    if expr.start != 0:\n        return expr\n    src = expr.arg\n    if not src.is_op():\n        return expr\n    if src.op not in ['+', '|', '^', '&']:\n        return expr\n    is_ok = True\n    for arg in src.args:\n        if arg.is_int():\n            continue\n        if arg.is_op() and arg.op.startswith('zeroExt') and (arg.args[0].size == expr.stop):\n            continue\n        if arg.is_compose():\n            continue\n        is_ok = False\n        break\n    if not is_ok:\n        return expr\n    args = [expr_s(arg[:expr.stop]) for arg in src.args]\n    return ExprOp(src.op, *args)",
            "def simp_slice_of_op_ext(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    (X.zeroExt() + {Z, } + ... + Int)[0:8] => X + ... + int[:]\\n    (X.zeroExt() | ... | Int)[0:8] => X | ... | int[:]\\n    ...\\n    '\n    if expr.start != 0:\n        return expr\n    src = expr.arg\n    if not src.is_op():\n        return expr\n    if src.op not in ['+', '|', '^', '&']:\n        return expr\n    is_ok = True\n    for arg in src.args:\n        if arg.is_int():\n            continue\n        if arg.is_op() and arg.op.startswith('zeroExt') and (arg.args[0].size == expr.stop):\n            continue\n        if arg.is_compose():\n            continue\n        is_ok = False\n        break\n    if not is_ok:\n        return expr\n    args = [expr_s(arg[:expr.stop]) for arg in src.args]\n    return ExprOp(src.op, *args)",
            "def simp_slice_of_op_ext(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    (X.zeroExt() + {Z, } + ... + Int)[0:8] => X + ... + int[:]\\n    (X.zeroExt() | ... | Int)[0:8] => X | ... | int[:]\\n    ...\\n    '\n    if expr.start != 0:\n        return expr\n    src = expr.arg\n    if not src.is_op():\n        return expr\n    if src.op not in ['+', '|', '^', '&']:\n        return expr\n    is_ok = True\n    for arg in src.args:\n        if arg.is_int():\n            continue\n        if arg.is_op() and arg.op.startswith('zeroExt') and (arg.args[0].size == expr.stop):\n            continue\n        if arg.is_compose():\n            continue\n        is_ok = False\n        break\n    if not is_ok:\n        return expr\n    args = [expr_s(arg[:expr.stop]) for arg in src.args]\n    return ExprOp(src.op, *args)",
            "def simp_slice_of_op_ext(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    (X.zeroExt() + {Z, } + ... + Int)[0:8] => X + ... + int[:]\\n    (X.zeroExt() | ... | Int)[0:8] => X | ... | int[:]\\n    ...\\n    '\n    if expr.start != 0:\n        return expr\n    src = expr.arg\n    if not src.is_op():\n        return expr\n    if src.op not in ['+', '|', '^', '&']:\n        return expr\n    is_ok = True\n    for arg in src.args:\n        if arg.is_int():\n            continue\n        if arg.is_op() and arg.op.startswith('zeroExt') and (arg.args[0].size == expr.stop):\n            continue\n        if arg.is_compose():\n            continue\n        is_ok = False\n        break\n    if not is_ok:\n        return expr\n    args = [expr_s(arg[:expr.stop]) for arg in src.args]\n    return ExprOp(src.op, *args)",
            "def simp_slice_of_op_ext(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    (X.zeroExt() + {Z, } + ... + Int)[0:8] => X + ... + int[:]\\n    (X.zeroExt() | ... | Int)[0:8] => X | ... | int[:]\\n    ...\\n    '\n    if expr.start != 0:\n        return expr\n    src = expr.arg\n    if not src.is_op():\n        return expr\n    if src.op not in ['+', '|', '^', '&']:\n        return expr\n    is_ok = True\n    for arg in src.args:\n        if arg.is_int():\n            continue\n        if arg.is_op() and arg.op.startswith('zeroExt') and (arg.args[0].size == expr.stop):\n            continue\n        if arg.is_compose():\n            continue\n        is_ok = False\n        break\n    if not is_ok:\n        return expr\n    args = [expr_s(arg[:expr.stop]) for arg in src.args]\n    return ExprOp(src.op, *args)"
        ]
    },
    {
        "func_name": "simp_cond_logic_ext",
        "original": "def simp_cond_logic_ext(expr_s, expr):\n    \"\"\"(X.zeroExt() + ... + Int) ? A:B => X + ... + int[:] ? A:B\"\"\"\n    cond = expr.cond\n    if not cond.is_op():\n        return expr\n    if cond.op not in ['&', '^', '|']:\n        return expr\n    is_ok = True\n    sizes = set()\n    for arg in cond.args:\n        if arg.is_int():\n            continue\n        if arg.is_op() and arg.op.startswith('zeroExt'):\n            sizes.add(arg.args[0].size)\n            continue\n        is_ok = False\n        break\n    if not is_ok:\n        return expr\n    if len(sizes) != 1:\n        return expr\n    size = list(sizes)[0]\n    args = [expr_s(arg[:size]) for arg in cond.args]\n    cond = ExprOp(cond.op, *args)\n    return ExprCond(cond, expr.src1, expr.src2)",
        "mutated": [
            "def simp_cond_logic_ext(expr_s, expr):\n    if False:\n        i = 10\n    '(X.zeroExt() + ... + Int) ? A:B => X + ... + int[:] ? A:B'\n    cond = expr.cond\n    if not cond.is_op():\n        return expr\n    if cond.op not in ['&', '^', '|']:\n        return expr\n    is_ok = True\n    sizes = set()\n    for arg in cond.args:\n        if arg.is_int():\n            continue\n        if arg.is_op() and arg.op.startswith('zeroExt'):\n            sizes.add(arg.args[0].size)\n            continue\n        is_ok = False\n        break\n    if not is_ok:\n        return expr\n    if len(sizes) != 1:\n        return expr\n    size = list(sizes)[0]\n    args = [expr_s(arg[:size]) for arg in cond.args]\n    cond = ExprOp(cond.op, *args)\n    return ExprCond(cond, expr.src1, expr.src2)",
            "def simp_cond_logic_ext(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '(X.zeroExt() + ... + Int) ? A:B => X + ... + int[:] ? A:B'\n    cond = expr.cond\n    if not cond.is_op():\n        return expr\n    if cond.op not in ['&', '^', '|']:\n        return expr\n    is_ok = True\n    sizes = set()\n    for arg in cond.args:\n        if arg.is_int():\n            continue\n        if arg.is_op() and arg.op.startswith('zeroExt'):\n            sizes.add(arg.args[0].size)\n            continue\n        is_ok = False\n        break\n    if not is_ok:\n        return expr\n    if len(sizes) != 1:\n        return expr\n    size = list(sizes)[0]\n    args = [expr_s(arg[:size]) for arg in cond.args]\n    cond = ExprOp(cond.op, *args)\n    return ExprCond(cond, expr.src1, expr.src2)",
            "def simp_cond_logic_ext(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '(X.zeroExt() + ... + Int) ? A:B => X + ... + int[:] ? A:B'\n    cond = expr.cond\n    if not cond.is_op():\n        return expr\n    if cond.op not in ['&', '^', '|']:\n        return expr\n    is_ok = True\n    sizes = set()\n    for arg in cond.args:\n        if arg.is_int():\n            continue\n        if arg.is_op() and arg.op.startswith('zeroExt'):\n            sizes.add(arg.args[0].size)\n            continue\n        is_ok = False\n        break\n    if not is_ok:\n        return expr\n    if len(sizes) != 1:\n        return expr\n    size = list(sizes)[0]\n    args = [expr_s(arg[:size]) for arg in cond.args]\n    cond = ExprOp(cond.op, *args)\n    return ExprCond(cond, expr.src1, expr.src2)",
            "def simp_cond_logic_ext(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '(X.zeroExt() + ... + Int) ? A:B => X + ... + int[:] ? A:B'\n    cond = expr.cond\n    if not cond.is_op():\n        return expr\n    if cond.op not in ['&', '^', '|']:\n        return expr\n    is_ok = True\n    sizes = set()\n    for arg in cond.args:\n        if arg.is_int():\n            continue\n        if arg.is_op() and arg.op.startswith('zeroExt'):\n            sizes.add(arg.args[0].size)\n            continue\n        is_ok = False\n        break\n    if not is_ok:\n        return expr\n    if len(sizes) != 1:\n        return expr\n    size = list(sizes)[0]\n    args = [expr_s(arg[:size]) for arg in cond.args]\n    cond = ExprOp(cond.op, *args)\n    return ExprCond(cond, expr.src1, expr.src2)",
            "def simp_cond_logic_ext(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '(X.zeroExt() + ... + Int) ? A:B => X + ... + int[:] ? A:B'\n    cond = expr.cond\n    if not cond.is_op():\n        return expr\n    if cond.op not in ['&', '^', '|']:\n        return expr\n    is_ok = True\n    sizes = set()\n    for arg in cond.args:\n        if arg.is_int():\n            continue\n        if arg.is_op() and arg.op.startswith('zeroExt'):\n            sizes.add(arg.args[0].size)\n            continue\n        is_ok = False\n        break\n    if not is_ok:\n        return expr\n    if len(sizes) != 1:\n        return expr\n    size = list(sizes)[0]\n    args = [expr_s(arg[:size]) for arg in cond.args]\n    cond = ExprOp(cond.op, *args)\n    return ExprCond(cond, expr.src1, expr.src2)"
        ]
    },
    {
        "func_name": "simp_cond_sign_bit",
        "original": "def simp_cond_sign_bit(_, expr):\n    \"\"\"(a & .. & 0x80000000) ? A:B => (a & ...) <s 0 ? A:B\"\"\"\n    cond = expr.cond\n    if not cond.is_op('&'):\n        return expr\n    last = cond.args[-1]\n    if not last.is_int(1 << last.size - 1):\n        return expr\n    zero = ExprInt(0, expr.cond.size)\n    if len(cond.args) == 2:\n        args = [cond.args[0], zero]\n    else:\n        args = [ExprOp('&', *list(cond.args[:-1])), zero]\n    cond = ExprOp(TOK_INF_SIGNED, *args)\n    return ExprCond(cond, expr.src1, expr.src2)",
        "mutated": [
            "def simp_cond_sign_bit(_, expr):\n    if False:\n        i = 10\n    '(a & .. & 0x80000000) ? A:B => (a & ...) <s 0 ? A:B'\n    cond = expr.cond\n    if not cond.is_op('&'):\n        return expr\n    last = cond.args[-1]\n    if not last.is_int(1 << last.size - 1):\n        return expr\n    zero = ExprInt(0, expr.cond.size)\n    if len(cond.args) == 2:\n        args = [cond.args[0], zero]\n    else:\n        args = [ExprOp('&', *list(cond.args[:-1])), zero]\n    cond = ExprOp(TOK_INF_SIGNED, *args)\n    return ExprCond(cond, expr.src1, expr.src2)",
            "def simp_cond_sign_bit(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '(a & .. & 0x80000000) ? A:B => (a & ...) <s 0 ? A:B'\n    cond = expr.cond\n    if not cond.is_op('&'):\n        return expr\n    last = cond.args[-1]\n    if not last.is_int(1 << last.size - 1):\n        return expr\n    zero = ExprInt(0, expr.cond.size)\n    if len(cond.args) == 2:\n        args = [cond.args[0], zero]\n    else:\n        args = [ExprOp('&', *list(cond.args[:-1])), zero]\n    cond = ExprOp(TOK_INF_SIGNED, *args)\n    return ExprCond(cond, expr.src1, expr.src2)",
            "def simp_cond_sign_bit(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '(a & .. & 0x80000000) ? A:B => (a & ...) <s 0 ? A:B'\n    cond = expr.cond\n    if not cond.is_op('&'):\n        return expr\n    last = cond.args[-1]\n    if not last.is_int(1 << last.size - 1):\n        return expr\n    zero = ExprInt(0, expr.cond.size)\n    if len(cond.args) == 2:\n        args = [cond.args[0], zero]\n    else:\n        args = [ExprOp('&', *list(cond.args[:-1])), zero]\n    cond = ExprOp(TOK_INF_SIGNED, *args)\n    return ExprCond(cond, expr.src1, expr.src2)",
            "def simp_cond_sign_bit(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '(a & .. & 0x80000000) ? A:B => (a & ...) <s 0 ? A:B'\n    cond = expr.cond\n    if not cond.is_op('&'):\n        return expr\n    last = cond.args[-1]\n    if not last.is_int(1 << last.size - 1):\n        return expr\n    zero = ExprInt(0, expr.cond.size)\n    if len(cond.args) == 2:\n        args = [cond.args[0], zero]\n    else:\n        args = [ExprOp('&', *list(cond.args[:-1])), zero]\n    cond = ExprOp(TOK_INF_SIGNED, *args)\n    return ExprCond(cond, expr.src1, expr.src2)",
            "def simp_cond_sign_bit(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '(a & .. & 0x80000000) ? A:B => (a & ...) <s 0 ? A:B'\n    cond = expr.cond\n    if not cond.is_op('&'):\n        return expr\n    last = cond.args[-1]\n    if not last.is_int(1 << last.size - 1):\n        return expr\n    zero = ExprInt(0, expr.cond.size)\n    if len(cond.args) == 2:\n        args = [cond.args[0], zero]\n    else:\n        args = [ExprOp('&', *list(cond.args[:-1])), zero]\n    cond = ExprOp(TOK_INF_SIGNED, *args)\n    return ExprCond(cond, expr.src1, expr.src2)"
        ]
    },
    {
        "func_name": "simp_cond_add",
        "original": "def simp_cond_add(expr_s, expr):\n    \"\"\"\n    (a+b)?X:Y => (a == b)?Y:X\n    (a^b)?X:Y => (a == b)?Y:X\n    \"\"\"\n    cond = expr.cond\n    if not cond.is_op():\n        return expr\n    if cond.op not in ['+', '^']:\n        return expr\n    if len(cond.args) != 2:\n        return expr\n    (arg1, arg2) = cond.args\n    if cond.is_op('+'):\n        new_cond = ExprOp('==', arg1, expr_s(-arg2))\n    elif cond.is_op('^'):\n        new_cond = ExprOp('==', arg1, arg2)\n    else:\n        raise ValueError('Bad case')\n    return ExprCond(new_cond, expr.src2, expr.src1)",
        "mutated": [
            "def simp_cond_add(expr_s, expr):\n    if False:\n        i = 10\n    '\\n    (a+b)?X:Y => (a == b)?Y:X\\n    (a^b)?X:Y => (a == b)?Y:X\\n    '\n    cond = expr.cond\n    if not cond.is_op():\n        return expr\n    if cond.op not in ['+', '^']:\n        return expr\n    if len(cond.args) != 2:\n        return expr\n    (arg1, arg2) = cond.args\n    if cond.is_op('+'):\n        new_cond = ExprOp('==', arg1, expr_s(-arg2))\n    elif cond.is_op('^'):\n        new_cond = ExprOp('==', arg1, arg2)\n    else:\n        raise ValueError('Bad case')\n    return ExprCond(new_cond, expr.src2, expr.src1)",
            "def simp_cond_add(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    (a+b)?X:Y => (a == b)?Y:X\\n    (a^b)?X:Y => (a == b)?Y:X\\n    '\n    cond = expr.cond\n    if not cond.is_op():\n        return expr\n    if cond.op not in ['+', '^']:\n        return expr\n    if len(cond.args) != 2:\n        return expr\n    (arg1, arg2) = cond.args\n    if cond.is_op('+'):\n        new_cond = ExprOp('==', arg1, expr_s(-arg2))\n    elif cond.is_op('^'):\n        new_cond = ExprOp('==', arg1, arg2)\n    else:\n        raise ValueError('Bad case')\n    return ExprCond(new_cond, expr.src2, expr.src1)",
            "def simp_cond_add(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    (a+b)?X:Y => (a == b)?Y:X\\n    (a^b)?X:Y => (a == b)?Y:X\\n    '\n    cond = expr.cond\n    if not cond.is_op():\n        return expr\n    if cond.op not in ['+', '^']:\n        return expr\n    if len(cond.args) != 2:\n        return expr\n    (arg1, arg2) = cond.args\n    if cond.is_op('+'):\n        new_cond = ExprOp('==', arg1, expr_s(-arg2))\n    elif cond.is_op('^'):\n        new_cond = ExprOp('==', arg1, arg2)\n    else:\n        raise ValueError('Bad case')\n    return ExprCond(new_cond, expr.src2, expr.src1)",
            "def simp_cond_add(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    (a+b)?X:Y => (a == b)?Y:X\\n    (a^b)?X:Y => (a == b)?Y:X\\n    '\n    cond = expr.cond\n    if not cond.is_op():\n        return expr\n    if cond.op not in ['+', '^']:\n        return expr\n    if len(cond.args) != 2:\n        return expr\n    (arg1, arg2) = cond.args\n    if cond.is_op('+'):\n        new_cond = ExprOp('==', arg1, expr_s(-arg2))\n    elif cond.is_op('^'):\n        new_cond = ExprOp('==', arg1, arg2)\n    else:\n        raise ValueError('Bad case')\n    return ExprCond(new_cond, expr.src2, expr.src1)",
            "def simp_cond_add(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    (a+b)?X:Y => (a == b)?Y:X\\n    (a^b)?X:Y => (a == b)?Y:X\\n    '\n    cond = expr.cond\n    if not cond.is_op():\n        return expr\n    if cond.op not in ['+', '^']:\n        return expr\n    if len(cond.args) != 2:\n        return expr\n    (arg1, arg2) = cond.args\n    if cond.is_op('+'):\n        new_cond = ExprOp('==', arg1, expr_s(-arg2))\n    elif cond.is_op('^'):\n        new_cond = ExprOp('==', arg1, arg2)\n    else:\n        raise ValueError('Bad case')\n    return ExprCond(new_cond, expr.src2, expr.src1)"
        ]
    },
    {
        "func_name": "simp_cond_eq_1_0",
        "original": "def simp_cond_eq_1_0(expr_s, expr):\n    \"\"\"\n    (a == b)?ExprInt(1, 1):ExprInt(0, 1) => a == b\n    (a <s b)?ExprInt(1, 1):ExprInt(0, 1) => a == b\n    ...\n    \"\"\"\n    cond = expr.cond\n    if not cond.is_op():\n        return expr\n    if cond.op not in [TOK_EQUAL, TOK_INF_SIGNED, TOK_INF_EQUAL_SIGNED, TOK_INF_UNSIGNED, TOK_INF_EQUAL_UNSIGNED]:\n        return expr\n    if expr.src1 != ExprInt(1, 1) or expr.src2 != ExprInt(0, 1):\n        return expr\n    return cond",
        "mutated": [
            "def simp_cond_eq_1_0(expr_s, expr):\n    if False:\n        i = 10\n    '\\n    (a == b)?ExprInt(1, 1):ExprInt(0, 1) => a == b\\n    (a <s b)?ExprInt(1, 1):ExprInt(0, 1) => a == b\\n    ...\\n    '\n    cond = expr.cond\n    if not cond.is_op():\n        return expr\n    if cond.op not in [TOK_EQUAL, TOK_INF_SIGNED, TOK_INF_EQUAL_SIGNED, TOK_INF_UNSIGNED, TOK_INF_EQUAL_UNSIGNED]:\n        return expr\n    if expr.src1 != ExprInt(1, 1) or expr.src2 != ExprInt(0, 1):\n        return expr\n    return cond",
            "def simp_cond_eq_1_0(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    (a == b)?ExprInt(1, 1):ExprInt(0, 1) => a == b\\n    (a <s b)?ExprInt(1, 1):ExprInt(0, 1) => a == b\\n    ...\\n    '\n    cond = expr.cond\n    if not cond.is_op():\n        return expr\n    if cond.op not in [TOK_EQUAL, TOK_INF_SIGNED, TOK_INF_EQUAL_SIGNED, TOK_INF_UNSIGNED, TOK_INF_EQUAL_UNSIGNED]:\n        return expr\n    if expr.src1 != ExprInt(1, 1) or expr.src2 != ExprInt(0, 1):\n        return expr\n    return cond",
            "def simp_cond_eq_1_0(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    (a == b)?ExprInt(1, 1):ExprInt(0, 1) => a == b\\n    (a <s b)?ExprInt(1, 1):ExprInt(0, 1) => a == b\\n    ...\\n    '\n    cond = expr.cond\n    if not cond.is_op():\n        return expr\n    if cond.op not in [TOK_EQUAL, TOK_INF_SIGNED, TOK_INF_EQUAL_SIGNED, TOK_INF_UNSIGNED, TOK_INF_EQUAL_UNSIGNED]:\n        return expr\n    if expr.src1 != ExprInt(1, 1) or expr.src2 != ExprInt(0, 1):\n        return expr\n    return cond",
            "def simp_cond_eq_1_0(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    (a == b)?ExprInt(1, 1):ExprInt(0, 1) => a == b\\n    (a <s b)?ExprInt(1, 1):ExprInt(0, 1) => a == b\\n    ...\\n    '\n    cond = expr.cond\n    if not cond.is_op():\n        return expr\n    if cond.op not in [TOK_EQUAL, TOK_INF_SIGNED, TOK_INF_EQUAL_SIGNED, TOK_INF_UNSIGNED, TOK_INF_EQUAL_UNSIGNED]:\n        return expr\n    if expr.src1 != ExprInt(1, 1) or expr.src2 != ExprInt(0, 1):\n        return expr\n    return cond",
            "def simp_cond_eq_1_0(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    (a == b)?ExprInt(1, 1):ExprInt(0, 1) => a == b\\n    (a <s b)?ExprInt(1, 1):ExprInt(0, 1) => a == b\\n    ...\\n    '\n    cond = expr.cond\n    if not cond.is_op():\n        return expr\n    if cond.op not in [TOK_EQUAL, TOK_INF_SIGNED, TOK_INF_EQUAL_SIGNED, TOK_INF_UNSIGNED, TOK_INF_EQUAL_UNSIGNED]:\n        return expr\n    if expr.src1 != ExprInt(1, 1) or expr.src2 != ExprInt(0, 1):\n        return expr\n    return cond"
        ]
    },
    {
        "func_name": "simp_cond_inf_eq_unsigned_zero",
        "original": "def simp_cond_inf_eq_unsigned_zero(expr_s, expr):\n    \"\"\"\n    (a <=u 0) => a == 0\n    \"\"\"\n    if not expr.is_op(TOK_INF_EQUAL_UNSIGNED):\n        return expr\n    if not expr.args[1].is_int(0):\n        return expr\n    return ExprOp(TOK_EQUAL, expr.args[0], expr.args[1])",
        "mutated": [
            "def simp_cond_inf_eq_unsigned_zero(expr_s, expr):\n    if False:\n        i = 10\n    '\\n    (a <=u 0) => a == 0\\n    '\n    if not expr.is_op(TOK_INF_EQUAL_UNSIGNED):\n        return expr\n    if not expr.args[1].is_int(0):\n        return expr\n    return ExprOp(TOK_EQUAL, expr.args[0], expr.args[1])",
            "def simp_cond_inf_eq_unsigned_zero(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    (a <=u 0) => a == 0\\n    '\n    if not expr.is_op(TOK_INF_EQUAL_UNSIGNED):\n        return expr\n    if not expr.args[1].is_int(0):\n        return expr\n    return ExprOp(TOK_EQUAL, expr.args[0], expr.args[1])",
            "def simp_cond_inf_eq_unsigned_zero(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    (a <=u 0) => a == 0\\n    '\n    if not expr.is_op(TOK_INF_EQUAL_UNSIGNED):\n        return expr\n    if not expr.args[1].is_int(0):\n        return expr\n    return ExprOp(TOK_EQUAL, expr.args[0], expr.args[1])",
            "def simp_cond_inf_eq_unsigned_zero(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    (a <=u 0) => a == 0\\n    '\n    if not expr.is_op(TOK_INF_EQUAL_UNSIGNED):\n        return expr\n    if not expr.args[1].is_int(0):\n        return expr\n    return ExprOp(TOK_EQUAL, expr.args[0], expr.args[1])",
            "def simp_cond_inf_eq_unsigned_zero(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    (a <=u 0) => a == 0\\n    '\n    if not expr.is_op(TOK_INF_EQUAL_UNSIGNED):\n        return expr\n    if not expr.args[1].is_int(0):\n        return expr\n    return ExprOp(TOK_EQUAL, expr.args[0], expr.args[1])"
        ]
    },
    {
        "func_name": "simp_test_signext_inf",
        "original": "def simp_test_signext_inf(expr_s, expr):\n    \"\"\"A.signExt() <s int => A <s int[:]\"\"\"\n    if not (expr.is_op(TOK_INF_SIGNED) or expr.is_op(TOK_INF_EQUAL_SIGNED)):\n        return expr\n    (arg, cst) = expr.args\n    if not (arg.is_op() and arg.op.startswith('signExt')):\n        return expr\n    if not cst.is_int():\n        return expr\n    base = arg.args[0]\n    tmp = int(mod_size2int[cst.size](int(cst)))\n    if -(1 << base.size - 1) <= tmp < 1 << base.size - 1:\n        return ExprOp(expr.op, base, expr_s(cst[:base.size]))\n    if tmp >= 1 << base.size - 1 or tmp < -(1 << base.size - 1):\n        return ExprInt(1, 1)\n    return expr",
        "mutated": [
            "def simp_test_signext_inf(expr_s, expr):\n    if False:\n        i = 10\n    'A.signExt() <s int => A <s int[:]'\n    if not (expr.is_op(TOK_INF_SIGNED) or expr.is_op(TOK_INF_EQUAL_SIGNED)):\n        return expr\n    (arg, cst) = expr.args\n    if not (arg.is_op() and arg.op.startswith('signExt')):\n        return expr\n    if not cst.is_int():\n        return expr\n    base = arg.args[0]\n    tmp = int(mod_size2int[cst.size](int(cst)))\n    if -(1 << base.size - 1) <= tmp < 1 << base.size - 1:\n        return ExprOp(expr.op, base, expr_s(cst[:base.size]))\n    if tmp >= 1 << base.size - 1 or tmp < -(1 << base.size - 1):\n        return ExprInt(1, 1)\n    return expr",
            "def simp_test_signext_inf(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'A.signExt() <s int => A <s int[:]'\n    if not (expr.is_op(TOK_INF_SIGNED) or expr.is_op(TOK_INF_EQUAL_SIGNED)):\n        return expr\n    (arg, cst) = expr.args\n    if not (arg.is_op() and arg.op.startswith('signExt')):\n        return expr\n    if not cst.is_int():\n        return expr\n    base = arg.args[0]\n    tmp = int(mod_size2int[cst.size](int(cst)))\n    if -(1 << base.size - 1) <= tmp < 1 << base.size - 1:\n        return ExprOp(expr.op, base, expr_s(cst[:base.size]))\n    if tmp >= 1 << base.size - 1 or tmp < -(1 << base.size - 1):\n        return ExprInt(1, 1)\n    return expr",
            "def simp_test_signext_inf(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'A.signExt() <s int => A <s int[:]'\n    if not (expr.is_op(TOK_INF_SIGNED) or expr.is_op(TOK_INF_EQUAL_SIGNED)):\n        return expr\n    (arg, cst) = expr.args\n    if not (arg.is_op() and arg.op.startswith('signExt')):\n        return expr\n    if not cst.is_int():\n        return expr\n    base = arg.args[0]\n    tmp = int(mod_size2int[cst.size](int(cst)))\n    if -(1 << base.size - 1) <= tmp < 1 << base.size - 1:\n        return ExprOp(expr.op, base, expr_s(cst[:base.size]))\n    if tmp >= 1 << base.size - 1 or tmp < -(1 << base.size - 1):\n        return ExprInt(1, 1)\n    return expr",
            "def simp_test_signext_inf(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'A.signExt() <s int => A <s int[:]'\n    if not (expr.is_op(TOK_INF_SIGNED) or expr.is_op(TOK_INF_EQUAL_SIGNED)):\n        return expr\n    (arg, cst) = expr.args\n    if not (arg.is_op() and arg.op.startswith('signExt')):\n        return expr\n    if not cst.is_int():\n        return expr\n    base = arg.args[0]\n    tmp = int(mod_size2int[cst.size](int(cst)))\n    if -(1 << base.size - 1) <= tmp < 1 << base.size - 1:\n        return ExprOp(expr.op, base, expr_s(cst[:base.size]))\n    if tmp >= 1 << base.size - 1 or tmp < -(1 << base.size - 1):\n        return ExprInt(1, 1)\n    return expr",
            "def simp_test_signext_inf(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'A.signExt() <s int => A <s int[:]'\n    if not (expr.is_op(TOK_INF_SIGNED) or expr.is_op(TOK_INF_EQUAL_SIGNED)):\n        return expr\n    (arg, cst) = expr.args\n    if not (arg.is_op() and arg.op.startswith('signExt')):\n        return expr\n    if not cst.is_int():\n        return expr\n    base = arg.args[0]\n    tmp = int(mod_size2int[cst.size](int(cst)))\n    if -(1 << base.size - 1) <= tmp < 1 << base.size - 1:\n        return ExprOp(expr.op, base, expr_s(cst[:base.size]))\n    if tmp >= 1 << base.size - 1 or tmp < -(1 << base.size - 1):\n        return ExprInt(1, 1)\n    return expr"
        ]
    },
    {
        "func_name": "simp_test_zeroext_inf",
        "original": "def simp_test_zeroext_inf(expr_s, expr):\n    \"\"\"A.zeroExt() <u int => A <u int[:]\"\"\"\n    if not (expr.is_op(TOK_INF_UNSIGNED) or expr.is_op(TOK_INF_EQUAL_UNSIGNED)):\n        return expr\n    (arg, cst) = expr.args\n    if not (arg.is_op() and arg.op.startswith('zeroExt')):\n        return expr\n    if not cst.is_int():\n        return expr\n    base = arg.args[0]\n    tmp = int(mod_size2uint[cst.size](int(cst)))\n    if 0 <= tmp < 1 << base.size:\n        return ExprOp(expr.op, base, expr_s(cst[:base.size]))\n    if tmp >= 1 << base.size:\n        return ExprInt(1, 1)\n    return expr",
        "mutated": [
            "def simp_test_zeroext_inf(expr_s, expr):\n    if False:\n        i = 10\n    'A.zeroExt() <u int => A <u int[:]'\n    if not (expr.is_op(TOK_INF_UNSIGNED) or expr.is_op(TOK_INF_EQUAL_UNSIGNED)):\n        return expr\n    (arg, cst) = expr.args\n    if not (arg.is_op() and arg.op.startswith('zeroExt')):\n        return expr\n    if not cst.is_int():\n        return expr\n    base = arg.args[0]\n    tmp = int(mod_size2uint[cst.size](int(cst)))\n    if 0 <= tmp < 1 << base.size:\n        return ExprOp(expr.op, base, expr_s(cst[:base.size]))\n    if tmp >= 1 << base.size:\n        return ExprInt(1, 1)\n    return expr",
            "def simp_test_zeroext_inf(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'A.zeroExt() <u int => A <u int[:]'\n    if not (expr.is_op(TOK_INF_UNSIGNED) or expr.is_op(TOK_INF_EQUAL_UNSIGNED)):\n        return expr\n    (arg, cst) = expr.args\n    if not (arg.is_op() and arg.op.startswith('zeroExt')):\n        return expr\n    if not cst.is_int():\n        return expr\n    base = arg.args[0]\n    tmp = int(mod_size2uint[cst.size](int(cst)))\n    if 0 <= tmp < 1 << base.size:\n        return ExprOp(expr.op, base, expr_s(cst[:base.size]))\n    if tmp >= 1 << base.size:\n        return ExprInt(1, 1)\n    return expr",
            "def simp_test_zeroext_inf(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'A.zeroExt() <u int => A <u int[:]'\n    if not (expr.is_op(TOK_INF_UNSIGNED) or expr.is_op(TOK_INF_EQUAL_UNSIGNED)):\n        return expr\n    (arg, cst) = expr.args\n    if not (arg.is_op() and arg.op.startswith('zeroExt')):\n        return expr\n    if not cst.is_int():\n        return expr\n    base = arg.args[0]\n    tmp = int(mod_size2uint[cst.size](int(cst)))\n    if 0 <= tmp < 1 << base.size:\n        return ExprOp(expr.op, base, expr_s(cst[:base.size]))\n    if tmp >= 1 << base.size:\n        return ExprInt(1, 1)\n    return expr",
            "def simp_test_zeroext_inf(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'A.zeroExt() <u int => A <u int[:]'\n    if not (expr.is_op(TOK_INF_UNSIGNED) or expr.is_op(TOK_INF_EQUAL_UNSIGNED)):\n        return expr\n    (arg, cst) = expr.args\n    if not (arg.is_op() and arg.op.startswith('zeroExt')):\n        return expr\n    if not cst.is_int():\n        return expr\n    base = arg.args[0]\n    tmp = int(mod_size2uint[cst.size](int(cst)))\n    if 0 <= tmp < 1 << base.size:\n        return ExprOp(expr.op, base, expr_s(cst[:base.size]))\n    if tmp >= 1 << base.size:\n        return ExprInt(1, 1)\n    return expr",
            "def simp_test_zeroext_inf(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'A.zeroExt() <u int => A <u int[:]'\n    if not (expr.is_op(TOK_INF_UNSIGNED) or expr.is_op(TOK_INF_EQUAL_UNSIGNED)):\n        return expr\n    (arg, cst) = expr.args\n    if not (arg.is_op() and arg.op.startswith('zeroExt')):\n        return expr\n    if not cst.is_int():\n        return expr\n    base = arg.args[0]\n    tmp = int(mod_size2uint[cst.size](int(cst)))\n    if 0 <= tmp < 1 << base.size:\n        return ExprOp(expr.op, base, expr_s(cst[:base.size]))\n    if tmp >= 1 << base.size:\n        return ExprInt(1, 1)\n    return expr"
        ]
    },
    {
        "func_name": "simp_add_multiple",
        "original": "def simp_add_multiple(_, expr):\n    \"\"\"\n    X + X => 2 * X\n    X + X * int1 => X * (1 + int1)\n    X * int1 + (- X) => X * (int1 - 1)\n    X + (X << int1) => X * (1 + 2 ** int1)\n    Correct even if addition overflow/underflow\n    \"\"\"\n    if not expr.is_op('+'):\n        return expr\n    operands = {}\n    for arg in expr.args:\n        if arg.is_op('*') and arg.args[1].is_int():\n            (base_expr, factor) = arg.args\n            operands[base_expr] = operands.get(base_expr, 0) + int(factor)\n        elif arg.is_op('<<') and arg.args[1].is_int():\n            (base_expr, factor) = arg.args\n            operands[base_expr] = operands.get(base_expr, 0) + 2 ** int(factor)\n        elif arg.is_op('-'):\n            arg = arg.args[0]\n            if arg.is_op('<<') and arg.args[1].is_int():\n                (base_expr, factor) = arg.args\n                operands[base_expr] = operands.get(base_expr, 0) - 2 ** int(factor)\n            else:\n                operands[arg] = operands.get(arg, 0) - 1\n        else:\n            operands[arg] = operands.get(arg, 0) + 1\n    out = []\n    modified = True\n    while modified:\n        modified = False\n        for (arg, count) in list(viewitems(operands)):\n            if not arg.is_op('+'):\n                continue\n            components = arg.args\n            if not all((component in operands for component in components)):\n                continue\n            counters = set((operands[component] for component in components))\n            if len(counters) != 1:\n                continue\n            counter = counters.pop()\n            for component in components:\n                del operands[component]\n            operands[arg] += counter\n            modified = True\n            break\n    for (arg, count) in viewitems(operands):\n        if count == 0:\n            continue\n        if count == 1:\n            out.append(arg)\n            continue\n        out.append(arg * ExprInt(count, expr.size))\n    if len(out) == len(expr.args):\n        return expr\n    if not out:\n        return ExprInt(0, expr.size)\n    if len(out) == 1:\n        return out[0]\n    return ExprOp('+', *out)",
        "mutated": [
            "def simp_add_multiple(_, expr):\n    if False:\n        i = 10\n    '\\n    X + X => 2 * X\\n    X + X * int1 => X * (1 + int1)\\n    X * int1 + (- X) => X * (int1 - 1)\\n    X + (X << int1) => X * (1 + 2 ** int1)\\n    Correct even if addition overflow/underflow\\n    '\n    if not expr.is_op('+'):\n        return expr\n    operands = {}\n    for arg in expr.args:\n        if arg.is_op('*') and arg.args[1].is_int():\n            (base_expr, factor) = arg.args\n            operands[base_expr] = operands.get(base_expr, 0) + int(factor)\n        elif arg.is_op('<<') and arg.args[1].is_int():\n            (base_expr, factor) = arg.args\n            operands[base_expr] = operands.get(base_expr, 0) + 2 ** int(factor)\n        elif arg.is_op('-'):\n            arg = arg.args[0]\n            if arg.is_op('<<') and arg.args[1].is_int():\n                (base_expr, factor) = arg.args\n                operands[base_expr] = operands.get(base_expr, 0) - 2 ** int(factor)\n            else:\n                operands[arg] = operands.get(arg, 0) - 1\n        else:\n            operands[arg] = operands.get(arg, 0) + 1\n    out = []\n    modified = True\n    while modified:\n        modified = False\n        for (arg, count) in list(viewitems(operands)):\n            if not arg.is_op('+'):\n                continue\n            components = arg.args\n            if not all((component in operands for component in components)):\n                continue\n            counters = set((operands[component] for component in components))\n            if len(counters) != 1:\n                continue\n            counter = counters.pop()\n            for component in components:\n                del operands[component]\n            operands[arg] += counter\n            modified = True\n            break\n    for (arg, count) in viewitems(operands):\n        if count == 0:\n            continue\n        if count == 1:\n            out.append(arg)\n            continue\n        out.append(arg * ExprInt(count, expr.size))\n    if len(out) == len(expr.args):\n        return expr\n    if not out:\n        return ExprInt(0, expr.size)\n    if len(out) == 1:\n        return out[0]\n    return ExprOp('+', *out)",
            "def simp_add_multiple(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    X + X => 2 * X\\n    X + X * int1 => X * (1 + int1)\\n    X * int1 + (- X) => X * (int1 - 1)\\n    X + (X << int1) => X * (1 + 2 ** int1)\\n    Correct even if addition overflow/underflow\\n    '\n    if not expr.is_op('+'):\n        return expr\n    operands = {}\n    for arg in expr.args:\n        if arg.is_op('*') and arg.args[1].is_int():\n            (base_expr, factor) = arg.args\n            operands[base_expr] = operands.get(base_expr, 0) + int(factor)\n        elif arg.is_op('<<') and arg.args[1].is_int():\n            (base_expr, factor) = arg.args\n            operands[base_expr] = operands.get(base_expr, 0) + 2 ** int(factor)\n        elif arg.is_op('-'):\n            arg = arg.args[0]\n            if arg.is_op('<<') and arg.args[1].is_int():\n                (base_expr, factor) = arg.args\n                operands[base_expr] = operands.get(base_expr, 0) - 2 ** int(factor)\n            else:\n                operands[arg] = operands.get(arg, 0) - 1\n        else:\n            operands[arg] = operands.get(arg, 0) + 1\n    out = []\n    modified = True\n    while modified:\n        modified = False\n        for (arg, count) in list(viewitems(operands)):\n            if not arg.is_op('+'):\n                continue\n            components = arg.args\n            if not all((component in operands for component in components)):\n                continue\n            counters = set((operands[component] for component in components))\n            if len(counters) != 1:\n                continue\n            counter = counters.pop()\n            for component in components:\n                del operands[component]\n            operands[arg] += counter\n            modified = True\n            break\n    for (arg, count) in viewitems(operands):\n        if count == 0:\n            continue\n        if count == 1:\n            out.append(arg)\n            continue\n        out.append(arg * ExprInt(count, expr.size))\n    if len(out) == len(expr.args):\n        return expr\n    if not out:\n        return ExprInt(0, expr.size)\n    if len(out) == 1:\n        return out[0]\n    return ExprOp('+', *out)",
            "def simp_add_multiple(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    X + X => 2 * X\\n    X + X * int1 => X * (1 + int1)\\n    X * int1 + (- X) => X * (int1 - 1)\\n    X + (X << int1) => X * (1 + 2 ** int1)\\n    Correct even if addition overflow/underflow\\n    '\n    if not expr.is_op('+'):\n        return expr\n    operands = {}\n    for arg in expr.args:\n        if arg.is_op('*') and arg.args[1].is_int():\n            (base_expr, factor) = arg.args\n            operands[base_expr] = operands.get(base_expr, 0) + int(factor)\n        elif arg.is_op('<<') and arg.args[1].is_int():\n            (base_expr, factor) = arg.args\n            operands[base_expr] = operands.get(base_expr, 0) + 2 ** int(factor)\n        elif arg.is_op('-'):\n            arg = arg.args[0]\n            if arg.is_op('<<') and arg.args[1].is_int():\n                (base_expr, factor) = arg.args\n                operands[base_expr] = operands.get(base_expr, 0) - 2 ** int(factor)\n            else:\n                operands[arg] = operands.get(arg, 0) - 1\n        else:\n            operands[arg] = operands.get(arg, 0) + 1\n    out = []\n    modified = True\n    while modified:\n        modified = False\n        for (arg, count) in list(viewitems(operands)):\n            if not arg.is_op('+'):\n                continue\n            components = arg.args\n            if not all((component in operands for component in components)):\n                continue\n            counters = set((operands[component] for component in components))\n            if len(counters) != 1:\n                continue\n            counter = counters.pop()\n            for component in components:\n                del operands[component]\n            operands[arg] += counter\n            modified = True\n            break\n    for (arg, count) in viewitems(operands):\n        if count == 0:\n            continue\n        if count == 1:\n            out.append(arg)\n            continue\n        out.append(arg * ExprInt(count, expr.size))\n    if len(out) == len(expr.args):\n        return expr\n    if not out:\n        return ExprInt(0, expr.size)\n    if len(out) == 1:\n        return out[0]\n    return ExprOp('+', *out)",
            "def simp_add_multiple(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    X + X => 2 * X\\n    X + X * int1 => X * (1 + int1)\\n    X * int1 + (- X) => X * (int1 - 1)\\n    X + (X << int1) => X * (1 + 2 ** int1)\\n    Correct even if addition overflow/underflow\\n    '\n    if not expr.is_op('+'):\n        return expr\n    operands = {}\n    for arg in expr.args:\n        if arg.is_op('*') and arg.args[1].is_int():\n            (base_expr, factor) = arg.args\n            operands[base_expr] = operands.get(base_expr, 0) + int(factor)\n        elif arg.is_op('<<') and arg.args[1].is_int():\n            (base_expr, factor) = arg.args\n            operands[base_expr] = operands.get(base_expr, 0) + 2 ** int(factor)\n        elif arg.is_op('-'):\n            arg = arg.args[0]\n            if arg.is_op('<<') and arg.args[1].is_int():\n                (base_expr, factor) = arg.args\n                operands[base_expr] = operands.get(base_expr, 0) - 2 ** int(factor)\n            else:\n                operands[arg] = operands.get(arg, 0) - 1\n        else:\n            operands[arg] = operands.get(arg, 0) + 1\n    out = []\n    modified = True\n    while modified:\n        modified = False\n        for (arg, count) in list(viewitems(operands)):\n            if not arg.is_op('+'):\n                continue\n            components = arg.args\n            if not all((component in operands for component in components)):\n                continue\n            counters = set((operands[component] for component in components))\n            if len(counters) != 1:\n                continue\n            counter = counters.pop()\n            for component in components:\n                del operands[component]\n            operands[arg] += counter\n            modified = True\n            break\n    for (arg, count) in viewitems(operands):\n        if count == 0:\n            continue\n        if count == 1:\n            out.append(arg)\n            continue\n        out.append(arg * ExprInt(count, expr.size))\n    if len(out) == len(expr.args):\n        return expr\n    if not out:\n        return ExprInt(0, expr.size)\n    if len(out) == 1:\n        return out[0]\n    return ExprOp('+', *out)",
            "def simp_add_multiple(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    X + X => 2 * X\\n    X + X * int1 => X * (1 + int1)\\n    X * int1 + (- X) => X * (int1 - 1)\\n    X + (X << int1) => X * (1 + 2 ** int1)\\n    Correct even if addition overflow/underflow\\n    '\n    if not expr.is_op('+'):\n        return expr\n    operands = {}\n    for arg in expr.args:\n        if arg.is_op('*') and arg.args[1].is_int():\n            (base_expr, factor) = arg.args\n            operands[base_expr] = operands.get(base_expr, 0) + int(factor)\n        elif arg.is_op('<<') and arg.args[1].is_int():\n            (base_expr, factor) = arg.args\n            operands[base_expr] = operands.get(base_expr, 0) + 2 ** int(factor)\n        elif arg.is_op('-'):\n            arg = arg.args[0]\n            if arg.is_op('<<') and arg.args[1].is_int():\n                (base_expr, factor) = arg.args\n                operands[base_expr] = operands.get(base_expr, 0) - 2 ** int(factor)\n            else:\n                operands[arg] = operands.get(arg, 0) - 1\n        else:\n            operands[arg] = operands.get(arg, 0) + 1\n    out = []\n    modified = True\n    while modified:\n        modified = False\n        for (arg, count) in list(viewitems(operands)):\n            if not arg.is_op('+'):\n                continue\n            components = arg.args\n            if not all((component in operands for component in components)):\n                continue\n            counters = set((operands[component] for component in components))\n            if len(counters) != 1:\n                continue\n            counter = counters.pop()\n            for component in components:\n                del operands[component]\n            operands[arg] += counter\n            modified = True\n            break\n    for (arg, count) in viewitems(operands):\n        if count == 0:\n            continue\n        if count == 1:\n            out.append(arg)\n            continue\n        out.append(arg * ExprInt(count, expr.size))\n    if len(out) == len(expr.args):\n        return expr\n    if not out:\n        return ExprInt(0, expr.size)\n    if len(out) == 1:\n        return out[0]\n    return ExprOp('+', *out)"
        ]
    },
    {
        "func_name": "simp_compose_and_mask",
        "original": "def simp_compose_and_mask(_, expr):\n    \"\"\"\n    {X 0 8, Y 8 32} & 0xFF => zeroExt(X)\n    {X 0 8, Y 8 16, Z 16 32} & 0xFFFF => {X 0 8, Y 8 16, 0x0 16 32}\n    {X 0 8, 0x123456 8 32} & 0xFFFFFF => {X 0 8, 0x1234 8 24, 0x0 24 32}\n    \"\"\"\n    if not expr.is_op('&'):\n        return expr\n    if len(expr.args) != 2:\n        return expr\n    (arg1, arg2) = expr.args\n    if not arg1.is_compose():\n        return expr\n    if not arg2.is_int():\n        return expr\n    int2 = int(arg2)\n    if int2 + 1 & int2 != 0:\n        return expr\n    mask_size = int2.bit_length() + 7 // 8\n    out = []\n    for (offset, arg) in arg1.iter_args():\n        if offset == mask_size:\n            return ExprCompose(*out).zeroExtend(expr.size)\n        elif mask_size > offset and mask_size < offset + arg.size and arg.is_int():\n            out.append(ExprSlice(arg, 0, mask_size - offset))\n            return ExprCompose(*out).zeroExtend(expr.size)\n        else:\n            out.append(arg)\n    return expr",
        "mutated": [
            "def simp_compose_and_mask(_, expr):\n    if False:\n        i = 10\n    '\\n    {X 0 8, Y 8 32} & 0xFF => zeroExt(X)\\n    {X 0 8, Y 8 16, Z 16 32} & 0xFFFF => {X 0 8, Y 8 16, 0x0 16 32}\\n    {X 0 8, 0x123456 8 32} & 0xFFFFFF => {X 0 8, 0x1234 8 24, 0x0 24 32}\\n    '\n    if not expr.is_op('&'):\n        return expr\n    if len(expr.args) != 2:\n        return expr\n    (arg1, arg2) = expr.args\n    if not arg1.is_compose():\n        return expr\n    if not arg2.is_int():\n        return expr\n    int2 = int(arg2)\n    if int2 + 1 & int2 != 0:\n        return expr\n    mask_size = int2.bit_length() + 7 // 8\n    out = []\n    for (offset, arg) in arg1.iter_args():\n        if offset == mask_size:\n            return ExprCompose(*out).zeroExtend(expr.size)\n        elif mask_size > offset and mask_size < offset + arg.size and arg.is_int():\n            out.append(ExprSlice(arg, 0, mask_size - offset))\n            return ExprCompose(*out).zeroExtend(expr.size)\n        else:\n            out.append(arg)\n    return expr",
            "def simp_compose_and_mask(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    {X 0 8, Y 8 32} & 0xFF => zeroExt(X)\\n    {X 0 8, Y 8 16, Z 16 32} & 0xFFFF => {X 0 8, Y 8 16, 0x0 16 32}\\n    {X 0 8, 0x123456 8 32} & 0xFFFFFF => {X 0 8, 0x1234 8 24, 0x0 24 32}\\n    '\n    if not expr.is_op('&'):\n        return expr\n    if len(expr.args) != 2:\n        return expr\n    (arg1, arg2) = expr.args\n    if not arg1.is_compose():\n        return expr\n    if not arg2.is_int():\n        return expr\n    int2 = int(arg2)\n    if int2 + 1 & int2 != 0:\n        return expr\n    mask_size = int2.bit_length() + 7 // 8\n    out = []\n    for (offset, arg) in arg1.iter_args():\n        if offset == mask_size:\n            return ExprCompose(*out).zeroExtend(expr.size)\n        elif mask_size > offset and mask_size < offset + arg.size and arg.is_int():\n            out.append(ExprSlice(arg, 0, mask_size - offset))\n            return ExprCompose(*out).zeroExtend(expr.size)\n        else:\n            out.append(arg)\n    return expr",
            "def simp_compose_and_mask(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    {X 0 8, Y 8 32} & 0xFF => zeroExt(X)\\n    {X 0 8, Y 8 16, Z 16 32} & 0xFFFF => {X 0 8, Y 8 16, 0x0 16 32}\\n    {X 0 8, 0x123456 8 32} & 0xFFFFFF => {X 0 8, 0x1234 8 24, 0x0 24 32}\\n    '\n    if not expr.is_op('&'):\n        return expr\n    if len(expr.args) != 2:\n        return expr\n    (arg1, arg2) = expr.args\n    if not arg1.is_compose():\n        return expr\n    if not arg2.is_int():\n        return expr\n    int2 = int(arg2)\n    if int2 + 1 & int2 != 0:\n        return expr\n    mask_size = int2.bit_length() + 7 // 8\n    out = []\n    for (offset, arg) in arg1.iter_args():\n        if offset == mask_size:\n            return ExprCompose(*out).zeroExtend(expr.size)\n        elif mask_size > offset and mask_size < offset + arg.size and arg.is_int():\n            out.append(ExprSlice(arg, 0, mask_size - offset))\n            return ExprCompose(*out).zeroExtend(expr.size)\n        else:\n            out.append(arg)\n    return expr",
            "def simp_compose_and_mask(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    {X 0 8, Y 8 32} & 0xFF => zeroExt(X)\\n    {X 0 8, Y 8 16, Z 16 32} & 0xFFFF => {X 0 8, Y 8 16, 0x0 16 32}\\n    {X 0 8, 0x123456 8 32} & 0xFFFFFF => {X 0 8, 0x1234 8 24, 0x0 24 32}\\n    '\n    if not expr.is_op('&'):\n        return expr\n    if len(expr.args) != 2:\n        return expr\n    (arg1, arg2) = expr.args\n    if not arg1.is_compose():\n        return expr\n    if not arg2.is_int():\n        return expr\n    int2 = int(arg2)\n    if int2 + 1 & int2 != 0:\n        return expr\n    mask_size = int2.bit_length() + 7 // 8\n    out = []\n    for (offset, arg) in arg1.iter_args():\n        if offset == mask_size:\n            return ExprCompose(*out).zeroExtend(expr.size)\n        elif mask_size > offset and mask_size < offset + arg.size and arg.is_int():\n            out.append(ExprSlice(arg, 0, mask_size - offset))\n            return ExprCompose(*out).zeroExtend(expr.size)\n        else:\n            out.append(arg)\n    return expr",
            "def simp_compose_and_mask(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    {X 0 8, Y 8 32} & 0xFF => zeroExt(X)\\n    {X 0 8, Y 8 16, Z 16 32} & 0xFFFF => {X 0 8, Y 8 16, 0x0 16 32}\\n    {X 0 8, 0x123456 8 32} & 0xFFFFFF => {X 0 8, 0x1234 8 24, 0x0 24 32}\\n    '\n    if not expr.is_op('&'):\n        return expr\n    if len(expr.args) != 2:\n        return expr\n    (arg1, arg2) = expr.args\n    if not arg1.is_compose():\n        return expr\n    if not arg2.is_int():\n        return expr\n    int2 = int(arg2)\n    if int2 + 1 & int2 != 0:\n        return expr\n    mask_size = int2.bit_length() + 7 // 8\n    out = []\n    for (offset, arg) in arg1.iter_args():\n        if offset == mask_size:\n            return ExprCompose(*out).zeroExtend(expr.size)\n        elif mask_size > offset and mask_size < offset + arg.size and arg.is_int():\n            out.append(ExprSlice(arg, 0, mask_size - offset))\n            return ExprCompose(*out).zeroExtend(expr.size)\n        else:\n            out.append(arg)\n    return expr"
        ]
    },
    {
        "func_name": "simp_bcdadd_cf",
        "original": "def simp_bcdadd_cf(_, expr):\n    \"\"\"bcdadd(const, const) => decimal\"\"\"\n    if not expr.is_op('bcdadd_cf'):\n        return expr\n    arg1 = expr.args[0]\n    arg2 = expr.args[1]\n    if not (arg1.is_int() and arg2.is_int()):\n        return expr\n    carry = 0\n    res = 0\n    (nib_1, nib_2) = (0, 0)\n    for i in range(0, 16, 4):\n        nib_1 = arg1.arg >> i & 15\n        nib_2 = arg2.arg >> i & 15\n        j = carry + nib_1 + nib_2\n        if j >= 10:\n            carry = 1\n            j -= 10\n            j &= 15\n        else:\n            carry = 0\n    return ExprInt(carry, 1)",
        "mutated": [
            "def simp_bcdadd_cf(_, expr):\n    if False:\n        i = 10\n    'bcdadd(const, const) => decimal'\n    if not expr.is_op('bcdadd_cf'):\n        return expr\n    arg1 = expr.args[0]\n    arg2 = expr.args[1]\n    if not (arg1.is_int() and arg2.is_int()):\n        return expr\n    carry = 0\n    res = 0\n    (nib_1, nib_2) = (0, 0)\n    for i in range(0, 16, 4):\n        nib_1 = arg1.arg >> i & 15\n        nib_2 = arg2.arg >> i & 15\n        j = carry + nib_1 + nib_2\n        if j >= 10:\n            carry = 1\n            j -= 10\n            j &= 15\n        else:\n            carry = 0\n    return ExprInt(carry, 1)",
            "def simp_bcdadd_cf(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'bcdadd(const, const) => decimal'\n    if not expr.is_op('bcdadd_cf'):\n        return expr\n    arg1 = expr.args[0]\n    arg2 = expr.args[1]\n    if not (arg1.is_int() and arg2.is_int()):\n        return expr\n    carry = 0\n    res = 0\n    (nib_1, nib_2) = (0, 0)\n    for i in range(0, 16, 4):\n        nib_1 = arg1.arg >> i & 15\n        nib_2 = arg2.arg >> i & 15\n        j = carry + nib_1 + nib_2\n        if j >= 10:\n            carry = 1\n            j -= 10\n            j &= 15\n        else:\n            carry = 0\n    return ExprInt(carry, 1)",
            "def simp_bcdadd_cf(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'bcdadd(const, const) => decimal'\n    if not expr.is_op('bcdadd_cf'):\n        return expr\n    arg1 = expr.args[0]\n    arg2 = expr.args[1]\n    if not (arg1.is_int() and arg2.is_int()):\n        return expr\n    carry = 0\n    res = 0\n    (nib_1, nib_2) = (0, 0)\n    for i in range(0, 16, 4):\n        nib_1 = arg1.arg >> i & 15\n        nib_2 = arg2.arg >> i & 15\n        j = carry + nib_1 + nib_2\n        if j >= 10:\n            carry = 1\n            j -= 10\n            j &= 15\n        else:\n            carry = 0\n    return ExprInt(carry, 1)",
            "def simp_bcdadd_cf(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'bcdadd(const, const) => decimal'\n    if not expr.is_op('bcdadd_cf'):\n        return expr\n    arg1 = expr.args[0]\n    arg2 = expr.args[1]\n    if not (arg1.is_int() and arg2.is_int()):\n        return expr\n    carry = 0\n    res = 0\n    (nib_1, nib_2) = (0, 0)\n    for i in range(0, 16, 4):\n        nib_1 = arg1.arg >> i & 15\n        nib_2 = arg2.arg >> i & 15\n        j = carry + nib_1 + nib_2\n        if j >= 10:\n            carry = 1\n            j -= 10\n            j &= 15\n        else:\n            carry = 0\n    return ExprInt(carry, 1)",
            "def simp_bcdadd_cf(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'bcdadd(const, const) => decimal'\n    if not expr.is_op('bcdadd_cf'):\n        return expr\n    arg1 = expr.args[0]\n    arg2 = expr.args[1]\n    if not (arg1.is_int() and arg2.is_int()):\n        return expr\n    carry = 0\n    res = 0\n    (nib_1, nib_2) = (0, 0)\n    for i in range(0, 16, 4):\n        nib_1 = arg1.arg >> i & 15\n        nib_2 = arg2.arg >> i & 15\n        j = carry + nib_1 + nib_2\n        if j >= 10:\n            carry = 1\n            j -= 10\n            j &= 15\n        else:\n            carry = 0\n    return ExprInt(carry, 1)"
        ]
    },
    {
        "func_name": "simp_bcdadd",
        "original": "def simp_bcdadd(_, expr):\n    \"\"\"bcdadd(const, const) => decimal\"\"\"\n    if not expr.is_op('bcdadd'):\n        return expr\n    arg1 = expr.args[0]\n    arg2 = expr.args[1]\n    if not (arg1.is_int() and arg2.is_int()):\n        return expr\n    carry = 0\n    res = 0\n    (nib_1, nib_2) = (0, 0)\n    for i in range(0, 16, 4):\n        nib_1 = arg1.arg >> i & 15\n        nib_2 = arg2.arg >> i & 15\n        j = carry + nib_1 + nib_2\n        if j >= 10:\n            carry = 1\n            j -= 10\n            j &= 15\n        else:\n            carry = 0\n        res += j << i\n    return ExprInt(res, arg1.size)",
        "mutated": [
            "def simp_bcdadd(_, expr):\n    if False:\n        i = 10\n    'bcdadd(const, const) => decimal'\n    if not expr.is_op('bcdadd'):\n        return expr\n    arg1 = expr.args[0]\n    arg2 = expr.args[1]\n    if not (arg1.is_int() and arg2.is_int()):\n        return expr\n    carry = 0\n    res = 0\n    (nib_1, nib_2) = (0, 0)\n    for i in range(0, 16, 4):\n        nib_1 = arg1.arg >> i & 15\n        nib_2 = arg2.arg >> i & 15\n        j = carry + nib_1 + nib_2\n        if j >= 10:\n            carry = 1\n            j -= 10\n            j &= 15\n        else:\n            carry = 0\n        res += j << i\n    return ExprInt(res, arg1.size)",
            "def simp_bcdadd(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'bcdadd(const, const) => decimal'\n    if not expr.is_op('bcdadd'):\n        return expr\n    arg1 = expr.args[0]\n    arg2 = expr.args[1]\n    if not (arg1.is_int() and arg2.is_int()):\n        return expr\n    carry = 0\n    res = 0\n    (nib_1, nib_2) = (0, 0)\n    for i in range(0, 16, 4):\n        nib_1 = arg1.arg >> i & 15\n        nib_2 = arg2.arg >> i & 15\n        j = carry + nib_1 + nib_2\n        if j >= 10:\n            carry = 1\n            j -= 10\n            j &= 15\n        else:\n            carry = 0\n        res += j << i\n    return ExprInt(res, arg1.size)",
            "def simp_bcdadd(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'bcdadd(const, const) => decimal'\n    if not expr.is_op('bcdadd'):\n        return expr\n    arg1 = expr.args[0]\n    arg2 = expr.args[1]\n    if not (arg1.is_int() and arg2.is_int()):\n        return expr\n    carry = 0\n    res = 0\n    (nib_1, nib_2) = (0, 0)\n    for i in range(0, 16, 4):\n        nib_1 = arg1.arg >> i & 15\n        nib_2 = arg2.arg >> i & 15\n        j = carry + nib_1 + nib_2\n        if j >= 10:\n            carry = 1\n            j -= 10\n            j &= 15\n        else:\n            carry = 0\n        res += j << i\n    return ExprInt(res, arg1.size)",
            "def simp_bcdadd(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'bcdadd(const, const) => decimal'\n    if not expr.is_op('bcdadd'):\n        return expr\n    arg1 = expr.args[0]\n    arg2 = expr.args[1]\n    if not (arg1.is_int() and arg2.is_int()):\n        return expr\n    carry = 0\n    res = 0\n    (nib_1, nib_2) = (0, 0)\n    for i in range(0, 16, 4):\n        nib_1 = arg1.arg >> i & 15\n        nib_2 = arg2.arg >> i & 15\n        j = carry + nib_1 + nib_2\n        if j >= 10:\n            carry = 1\n            j -= 10\n            j &= 15\n        else:\n            carry = 0\n        res += j << i\n    return ExprInt(res, arg1.size)",
            "def simp_bcdadd(_, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'bcdadd(const, const) => decimal'\n    if not expr.is_op('bcdadd'):\n        return expr\n    arg1 = expr.args[0]\n    arg2 = expr.args[1]\n    if not (arg1.is_int() and arg2.is_int()):\n        return expr\n    carry = 0\n    res = 0\n    (nib_1, nib_2) = (0, 0)\n    for i in range(0, 16, 4):\n        nib_1 = arg1.arg >> i & 15\n        nib_2 = arg2.arg >> i & 15\n        j = carry + nib_1 + nib_2\n        if j >= 10:\n            carry = 1\n            j -= 10\n            j &= 15\n        else:\n            carry = 0\n        res += j << i\n    return ExprInt(res, arg1.size)"
        ]
    },
    {
        "func_name": "simp_smod_sext",
        "original": "def simp_smod_sext(expr_s, expr):\n    \"\"\"\n    a.size == b.size\n    smod(a.signExtend(X), b.signExtend(X)) => smod(a, b).signExtend(X)\n    \"\"\"\n    if not expr.is_op('smod'):\n        return expr\n    (arg1, arg2) = expr.args\n    if arg1.is_op() and arg1.op.startswith('signExt'):\n        src1 = arg1.args[0]\n        if arg2.is_op() and arg2.op.startswith('signExt'):\n            src2 = arg2.args[0]\n            if src1.size == src2.size:\n                return ExprOp('smod', src1, src2).signExtend(expr.size)\n            return expr\n        elif arg2.is_int():\n            src2 = expr_s.expr_simp(arg2[:src1.size])\n            if expr_s.expr_simp(src2.signExtend(arg2.size)) == arg2:\n                return ExprOp('smod', src1, src2).signExtend(expr.size)\n            return expr\n    if arg2.is_op() and arg2.op.startswith('signExt'):\n        src2 = arg2.args[0]\n        if arg1.is_int():\n            src1 = expr_s.expr_simp(arg1[:src2.size])\n            if expr_s.expr_simp(src1.signExtend(arg1.size)) == arg1:\n                return ExprOp('smod', src1, src2).signExtend(expr.size)\n    return expr",
        "mutated": [
            "def simp_smod_sext(expr_s, expr):\n    if False:\n        i = 10\n    '\\n    a.size == b.size\\n    smod(a.signExtend(X), b.signExtend(X)) => smod(a, b).signExtend(X)\\n    '\n    if not expr.is_op('smod'):\n        return expr\n    (arg1, arg2) = expr.args\n    if arg1.is_op() and arg1.op.startswith('signExt'):\n        src1 = arg1.args[0]\n        if arg2.is_op() and arg2.op.startswith('signExt'):\n            src2 = arg2.args[0]\n            if src1.size == src2.size:\n                return ExprOp('smod', src1, src2).signExtend(expr.size)\n            return expr\n        elif arg2.is_int():\n            src2 = expr_s.expr_simp(arg2[:src1.size])\n            if expr_s.expr_simp(src2.signExtend(arg2.size)) == arg2:\n                return ExprOp('smod', src1, src2).signExtend(expr.size)\n            return expr\n    if arg2.is_op() and arg2.op.startswith('signExt'):\n        src2 = arg2.args[0]\n        if arg1.is_int():\n            src1 = expr_s.expr_simp(arg1[:src2.size])\n            if expr_s.expr_simp(src1.signExtend(arg1.size)) == arg1:\n                return ExprOp('smod', src1, src2).signExtend(expr.size)\n    return expr",
            "def simp_smod_sext(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    a.size == b.size\\n    smod(a.signExtend(X), b.signExtend(X)) => smod(a, b).signExtend(X)\\n    '\n    if not expr.is_op('smod'):\n        return expr\n    (arg1, arg2) = expr.args\n    if arg1.is_op() and arg1.op.startswith('signExt'):\n        src1 = arg1.args[0]\n        if arg2.is_op() and arg2.op.startswith('signExt'):\n            src2 = arg2.args[0]\n            if src1.size == src2.size:\n                return ExprOp('smod', src1, src2).signExtend(expr.size)\n            return expr\n        elif arg2.is_int():\n            src2 = expr_s.expr_simp(arg2[:src1.size])\n            if expr_s.expr_simp(src2.signExtend(arg2.size)) == arg2:\n                return ExprOp('smod', src1, src2).signExtend(expr.size)\n            return expr\n    if arg2.is_op() and arg2.op.startswith('signExt'):\n        src2 = arg2.args[0]\n        if arg1.is_int():\n            src1 = expr_s.expr_simp(arg1[:src2.size])\n            if expr_s.expr_simp(src1.signExtend(arg1.size)) == arg1:\n                return ExprOp('smod', src1, src2).signExtend(expr.size)\n    return expr",
            "def simp_smod_sext(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    a.size == b.size\\n    smod(a.signExtend(X), b.signExtend(X)) => smod(a, b).signExtend(X)\\n    '\n    if not expr.is_op('smod'):\n        return expr\n    (arg1, arg2) = expr.args\n    if arg1.is_op() and arg1.op.startswith('signExt'):\n        src1 = arg1.args[0]\n        if arg2.is_op() and arg2.op.startswith('signExt'):\n            src2 = arg2.args[0]\n            if src1.size == src2.size:\n                return ExprOp('smod', src1, src2).signExtend(expr.size)\n            return expr\n        elif arg2.is_int():\n            src2 = expr_s.expr_simp(arg2[:src1.size])\n            if expr_s.expr_simp(src2.signExtend(arg2.size)) == arg2:\n                return ExprOp('smod', src1, src2).signExtend(expr.size)\n            return expr\n    if arg2.is_op() and arg2.op.startswith('signExt'):\n        src2 = arg2.args[0]\n        if arg1.is_int():\n            src1 = expr_s.expr_simp(arg1[:src2.size])\n            if expr_s.expr_simp(src1.signExtend(arg1.size)) == arg1:\n                return ExprOp('smod', src1, src2).signExtend(expr.size)\n    return expr",
            "def simp_smod_sext(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    a.size == b.size\\n    smod(a.signExtend(X), b.signExtend(X)) => smod(a, b).signExtend(X)\\n    '\n    if not expr.is_op('smod'):\n        return expr\n    (arg1, arg2) = expr.args\n    if arg1.is_op() and arg1.op.startswith('signExt'):\n        src1 = arg1.args[0]\n        if arg2.is_op() and arg2.op.startswith('signExt'):\n            src2 = arg2.args[0]\n            if src1.size == src2.size:\n                return ExprOp('smod', src1, src2).signExtend(expr.size)\n            return expr\n        elif arg2.is_int():\n            src2 = expr_s.expr_simp(arg2[:src1.size])\n            if expr_s.expr_simp(src2.signExtend(arg2.size)) == arg2:\n                return ExprOp('smod', src1, src2).signExtend(expr.size)\n            return expr\n    if arg2.is_op() and arg2.op.startswith('signExt'):\n        src2 = arg2.args[0]\n        if arg1.is_int():\n            src1 = expr_s.expr_simp(arg1[:src2.size])\n            if expr_s.expr_simp(src1.signExtend(arg1.size)) == arg1:\n                return ExprOp('smod', src1, src2).signExtend(expr.size)\n    return expr",
            "def simp_smod_sext(expr_s, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    a.size == b.size\\n    smod(a.signExtend(X), b.signExtend(X)) => smod(a, b).signExtend(X)\\n    '\n    if not expr.is_op('smod'):\n        return expr\n    (arg1, arg2) = expr.args\n    if arg1.is_op() and arg1.op.startswith('signExt'):\n        src1 = arg1.args[0]\n        if arg2.is_op() and arg2.op.startswith('signExt'):\n            src2 = arg2.args[0]\n            if src1.size == src2.size:\n                return ExprOp('smod', src1, src2).signExtend(expr.size)\n            return expr\n        elif arg2.is_int():\n            src2 = expr_s.expr_simp(arg2[:src1.size])\n            if expr_s.expr_simp(src2.signExtend(arg2.size)) == arg2:\n                return ExprOp('smod', src1, src2).signExtend(expr.size)\n            return expr\n    if arg2.is_op() and arg2.op.startswith('signExt'):\n        src2 = arg2.args[0]\n        if arg1.is_int():\n            src1 = expr_s.expr_simp(arg1[:src2.size])\n            if expr_s.expr_simp(src1.signExtend(arg1.size)) == arg1:\n                return ExprOp('smod', src1, src2).signExtend(expr.size)\n    return expr"
        ]
    },
    {
        "func_name": "simp_flag_cst",
        "original": "def simp_flag_cst(expr_simp, expr):\n    if expr.op not in ['FLAG_EQ', 'FLAG_EQ_AND', 'FLAG_SIGN_SUB', 'FLAG_EQ_CMP', 'FLAG_ADD_CF', 'FLAG_SUB_CF', 'FLAG_ADD_OF', 'FLAG_SUB_OF', 'FLAG_EQ_ADDWC', 'FLAG_ADDWC_OF', 'FLAG_SUBWC_OF', 'FLAG_ADDWC_CF', 'FLAG_SUBWC_CF', 'FLAG_SIGN_ADDWC', 'FLAG_SIGN_SUBWC', 'FLAG_EQ_SUBWC', 'CC_U<=', 'CC_U>=', 'CC_S<', 'CC_S>', 'CC_S<=', 'CC_S>=', 'CC_U>', 'CC_U<', 'CC_NEG', 'CC_EQ', 'CC_NE', 'CC_POS']:\n        return expr\n    if not all((arg.is_int() for arg in expr.args)):\n        return expr\n    new_expr = expr_simp(simp_flags(expr_simp, expr))\n    return new_expr",
        "mutated": [
            "def simp_flag_cst(expr_simp, expr):\n    if False:\n        i = 10\n    if expr.op not in ['FLAG_EQ', 'FLAG_EQ_AND', 'FLAG_SIGN_SUB', 'FLAG_EQ_CMP', 'FLAG_ADD_CF', 'FLAG_SUB_CF', 'FLAG_ADD_OF', 'FLAG_SUB_OF', 'FLAG_EQ_ADDWC', 'FLAG_ADDWC_OF', 'FLAG_SUBWC_OF', 'FLAG_ADDWC_CF', 'FLAG_SUBWC_CF', 'FLAG_SIGN_ADDWC', 'FLAG_SIGN_SUBWC', 'FLAG_EQ_SUBWC', 'CC_U<=', 'CC_U>=', 'CC_S<', 'CC_S>', 'CC_S<=', 'CC_S>=', 'CC_U>', 'CC_U<', 'CC_NEG', 'CC_EQ', 'CC_NE', 'CC_POS']:\n        return expr\n    if not all((arg.is_int() for arg in expr.args)):\n        return expr\n    new_expr = expr_simp(simp_flags(expr_simp, expr))\n    return new_expr",
            "def simp_flag_cst(expr_simp, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if expr.op not in ['FLAG_EQ', 'FLAG_EQ_AND', 'FLAG_SIGN_SUB', 'FLAG_EQ_CMP', 'FLAG_ADD_CF', 'FLAG_SUB_CF', 'FLAG_ADD_OF', 'FLAG_SUB_OF', 'FLAG_EQ_ADDWC', 'FLAG_ADDWC_OF', 'FLAG_SUBWC_OF', 'FLAG_ADDWC_CF', 'FLAG_SUBWC_CF', 'FLAG_SIGN_ADDWC', 'FLAG_SIGN_SUBWC', 'FLAG_EQ_SUBWC', 'CC_U<=', 'CC_U>=', 'CC_S<', 'CC_S>', 'CC_S<=', 'CC_S>=', 'CC_U>', 'CC_U<', 'CC_NEG', 'CC_EQ', 'CC_NE', 'CC_POS']:\n        return expr\n    if not all((arg.is_int() for arg in expr.args)):\n        return expr\n    new_expr = expr_simp(simp_flags(expr_simp, expr))\n    return new_expr",
            "def simp_flag_cst(expr_simp, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if expr.op not in ['FLAG_EQ', 'FLAG_EQ_AND', 'FLAG_SIGN_SUB', 'FLAG_EQ_CMP', 'FLAG_ADD_CF', 'FLAG_SUB_CF', 'FLAG_ADD_OF', 'FLAG_SUB_OF', 'FLAG_EQ_ADDWC', 'FLAG_ADDWC_OF', 'FLAG_SUBWC_OF', 'FLAG_ADDWC_CF', 'FLAG_SUBWC_CF', 'FLAG_SIGN_ADDWC', 'FLAG_SIGN_SUBWC', 'FLAG_EQ_SUBWC', 'CC_U<=', 'CC_U>=', 'CC_S<', 'CC_S>', 'CC_S<=', 'CC_S>=', 'CC_U>', 'CC_U<', 'CC_NEG', 'CC_EQ', 'CC_NE', 'CC_POS']:\n        return expr\n    if not all((arg.is_int() for arg in expr.args)):\n        return expr\n    new_expr = expr_simp(simp_flags(expr_simp, expr))\n    return new_expr",
            "def simp_flag_cst(expr_simp, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if expr.op not in ['FLAG_EQ', 'FLAG_EQ_AND', 'FLAG_SIGN_SUB', 'FLAG_EQ_CMP', 'FLAG_ADD_CF', 'FLAG_SUB_CF', 'FLAG_ADD_OF', 'FLAG_SUB_OF', 'FLAG_EQ_ADDWC', 'FLAG_ADDWC_OF', 'FLAG_SUBWC_OF', 'FLAG_ADDWC_CF', 'FLAG_SUBWC_CF', 'FLAG_SIGN_ADDWC', 'FLAG_SIGN_SUBWC', 'FLAG_EQ_SUBWC', 'CC_U<=', 'CC_U>=', 'CC_S<', 'CC_S>', 'CC_S<=', 'CC_S>=', 'CC_U>', 'CC_U<', 'CC_NEG', 'CC_EQ', 'CC_NE', 'CC_POS']:\n        return expr\n    if not all((arg.is_int() for arg in expr.args)):\n        return expr\n    new_expr = expr_simp(simp_flags(expr_simp, expr))\n    return new_expr",
            "def simp_flag_cst(expr_simp, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if expr.op not in ['FLAG_EQ', 'FLAG_EQ_AND', 'FLAG_SIGN_SUB', 'FLAG_EQ_CMP', 'FLAG_ADD_CF', 'FLAG_SUB_CF', 'FLAG_ADD_OF', 'FLAG_SUB_OF', 'FLAG_EQ_ADDWC', 'FLAG_ADDWC_OF', 'FLAG_SUBWC_OF', 'FLAG_ADDWC_CF', 'FLAG_SUBWC_CF', 'FLAG_SIGN_ADDWC', 'FLAG_SIGN_SUBWC', 'FLAG_EQ_SUBWC', 'CC_U<=', 'CC_U>=', 'CC_S<', 'CC_S>', 'CC_S<=', 'CC_S>=', 'CC_U>', 'CC_U<', 'CC_NEG', 'CC_EQ', 'CC_NE', 'CC_POS']:\n        return expr\n    if not all((arg.is_int() for arg in expr.args)):\n        return expr\n    new_expr = expr_simp(simp_flags(expr_simp, expr))\n    return new_expr"
        ]
    }
]