[
    {
        "func_name": "stackedensemble_custom_metalearner_test",
        "original": "def stackedensemble_custom_metalearner_test():\n    \"\"\"This test checks the following:\n    1) That H2OStackedEnsembleEstimator `metalearner_nfolds` works correctly\n    2) That H2OStackedEnsembleEstimator `metalearner_nfolds` works in concert with `metalearner_nfolds`\n    \"\"\"\n    train = h2o.import_file(path=pyunit_utils.locate('smalldata/testng/higgs_train_5k.csv'), destination_frame='higgs_train_5k')\n    test = h2o.import_file(path=pyunit_utils.locate('smalldata/testng/higgs_test_5k.csv'), destination_frame='higgs_test_5k')\n    x = train.columns\n    y = 'response'\n    x.remove(y)\n    train[y] = train[y].asfactor()\n    test[y] = test[y].asfactor()\n    nfolds = 3\n    gbm_params = {'ntrees': 100, 'max_depth': 6}\n    drf_params = {'ntrees': 100, 'max_depth': 6}\n    glm_params = {'alpha': 0, 'lambda': 0}\n    dl_params = {'hidden': [32, 32, 32], 'epochs': 20}\n    my_gbm = H2OGradientBoostingEstimator(distribution='bernoulli', ntrees=10, nfolds=nfolds, fold_assignment='Modulo', keep_cross_validation_predictions=True, seed=1)\n    my_gbm.train(x=x, y=y, training_frame=train)\n    my_rf = H2ORandomForestEstimator(ntrees=50, nfolds=nfolds, fold_assignment='Modulo', keep_cross_validation_predictions=True, seed=1)\n    my_rf.train(x=x, y=y, training_frame=train)\n    stack_gbm = H2OStackedEnsembleEstimator(base_models=[my_gbm, my_rf], metalearner_algorithm='gbm', metalearner_params=gbm_params)\n    stack_gbm.train(x=x, y=y, training_frame=train)\n    assert stack_gbm.params['metalearner_algorithm']['actual'] == 'gbm'\n    meta_gbm = h2o.get_model(stack_gbm.metalearner()['name'])\n    assert meta_gbm.algo == 'gbm'\n    assert meta_gbm.params['ntrees']['actual'] == 100\n    assert meta_gbm.params['max_depth']['actual'] == 6\n    stack_drf = H2OStackedEnsembleEstimator(base_models=[my_gbm, my_rf], metalearner_algorithm='drf', metalearner_nfolds=3, metalearner_params=drf_params)\n    stack_drf.train(x=x, y=y, training_frame=train)\n    assert stack_drf.params['metalearner_algorithm']['actual'] == 'drf'\n    assert stack_drf.params['metalearner_nfolds']['actual'] == 3\n    meta_drf = h2o.get_model(stack_drf.metalearner()['name'])\n    assert meta_drf.algo == 'drf'\n    assert meta_drf.params['nfolds']['actual'] == 3\n    assert meta_drf.params['ntrees']['actual'] == 100\n    assert meta_drf.params['max_depth']['actual'] == 6\n    stack_glm = H2OStackedEnsembleEstimator(base_models=[my_gbm, my_rf], metalearner_algorithm='glm', metalearner_params=glm_params)\n    stack_glm.train(x=x, y=y, training_frame=train)\n    assert stack_glm.params['metalearner_algorithm']['actual'] == 'glm'\n    meta_glm = h2o.get_model(stack_glm.metalearner()['name'])\n    assert meta_glm.algo == 'glm'\n    assert meta_glm.params['alpha']['actual'] == [0.0]\n    assert meta_glm.params['lambda']['actual'] == [0.0]\n    stack_dl = H2OStackedEnsembleEstimator(base_models=[my_gbm, my_rf], metalearner_algorithm='deeplearning', metalearner_params=dl_params)\n    stack_dl.train(x=x, y=y, training_frame=train)\n    assert stack_dl.params['metalearner_algorithm']['actual'] == 'deeplearning'\n    meta_dl = h2o.get_model(stack_dl.metalearner()['name'])\n    assert meta_dl.algo == 'deeplearning'\n    assert meta_dl.params['hidden']['actual'] == [32, 32, 32]\n    assert meta_dl.params['epochs']['actual'] == 20.0",
        "mutated": [
            "def stackedensemble_custom_metalearner_test():\n    if False:\n        i = 10\n    'This test checks the following:\\n    1) That H2OStackedEnsembleEstimator `metalearner_nfolds` works correctly\\n    2) That H2OStackedEnsembleEstimator `metalearner_nfolds` works in concert with `metalearner_nfolds`\\n    '\n    train = h2o.import_file(path=pyunit_utils.locate('smalldata/testng/higgs_train_5k.csv'), destination_frame='higgs_train_5k')\n    test = h2o.import_file(path=pyunit_utils.locate('smalldata/testng/higgs_test_5k.csv'), destination_frame='higgs_test_5k')\n    x = train.columns\n    y = 'response'\n    x.remove(y)\n    train[y] = train[y].asfactor()\n    test[y] = test[y].asfactor()\n    nfolds = 3\n    gbm_params = {'ntrees': 100, 'max_depth': 6}\n    drf_params = {'ntrees': 100, 'max_depth': 6}\n    glm_params = {'alpha': 0, 'lambda': 0}\n    dl_params = {'hidden': [32, 32, 32], 'epochs': 20}\n    my_gbm = H2OGradientBoostingEstimator(distribution='bernoulli', ntrees=10, nfolds=nfolds, fold_assignment='Modulo', keep_cross_validation_predictions=True, seed=1)\n    my_gbm.train(x=x, y=y, training_frame=train)\n    my_rf = H2ORandomForestEstimator(ntrees=50, nfolds=nfolds, fold_assignment='Modulo', keep_cross_validation_predictions=True, seed=1)\n    my_rf.train(x=x, y=y, training_frame=train)\n    stack_gbm = H2OStackedEnsembleEstimator(base_models=[my_gbm, my_rf], metalearner_algorithm='gbm', metalearner_params=gbm_params)\n    stack_gbm.train(x=x, y=y, training_frame=train)\n    assert stack_gbm.params['metalearner_algorithm']['actual'] == 'gbm'\n    meta_gbm = h2o.get_model(stack_gbm.metalearner()['name'])\n    assert meta_gbm.algo == 'gbm'\n    assert meta_gbm.params['ntrees']['actual'] == 100\n    assert meta_gbm.params['max_depth']['actual'] == 6\n    stack_drf = H2OStackedEnsembleEstimator(base_models=[my_gbm, my_rf], metalearner_algorithm='drf', metalearner_nfolds=3, metalearner_params=drf_params)\n    stack_drf.train(x=x, y=y, training_frame=train)\n    assert stack_drf.params['metalearner_algorithm']['actual'] == 'drf'\n    assert stack_drf.params['metalearner_nfolds']['actual'] == 3\n    meta_drf = h2o.get_model(stack_drf.metalearner()['name'])\n    assert meta_drf.algo == 'drf'\n    assert meta_drf.params['nfolds']['actual'] == 3\n    assert meta_drf.params['ntrees']['actual'] == 100\n    assert meta_drf.params['max_depth']['actual'] == 6\n    stack_glm = H2OStackedEnsembleEstimator(base_models=[my_gbm, my_rf], metalearner_algorithm='glm', metalearner_params=glm_params)\n    stack_glm.train(x=x, y=y, training_frame=train)\n    assert stack_glm.params['metalearner_algorithm']['actual'] == 'glm'\n    meta_glm = h2o.get_model(stack_glm.metalearner()['name'])\n    assert meta_glm.algo == 'glm'\n    assert meta_glm.params['alpha']['actual'] == [0.0]\n    assert meta_glm.params['lambda']['actual'] == [0.0]\n    stack_dl = H2OStackedEnsembleEstimator(base_models=[my_gbm, my_rf], metalearner_algorithm='deeplearning', metalearner_params=dl_params)\n    stack_dl.train(x=x, y=y, training_frame=train)\n    assert stack_dl.params['metalearner_algorithm']['actual'] == 'deeplearning'\n    meta_dl = h2o.get_model(stack_dl.metalearner()['name'])\n    assert meta_dl.algo == 'deeplearning'\n    assert meta_dl.params['hidden']['actual'] == [32, 32, 32]\n    assert meta_dl.params['epochs']['actual'] == 20.0",
            "def stackedensemble_custom_metalearner_test():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'This test checks the following:\\n    1) That H2OStackedEnsembleEstimator `metalearner_nfolds` works correctly\\n    2) That H2OStackedEnsembleEstimator `metalearner_nfolds` works in concert with `metalearner_nfolds`\\n    '\n    train = h2o.import_file(path=pyunit_utils.locate('smalldata/testng/higgs_train_5k.csv'), destination_frame='higgs_train_5k')\n    test = h2o.import_file(path=pyunit_utils.locate('smalldata/testng/higgs_test_5k.csv'), destination_frame='higgs_test_5k')\n    x = train.columns\n    y = 'response'\n    x.remove(y)\n    train[y] = train[y].asfactor()\n    test[y] = test[y].asfactor()\n    nfolds = 3\n    gbm_params = {'ntrees': 100, 'max_depth': 6}\n    drf_params = {'ntrees': 100, 'max_depth': 6}\n    glm_params = {'alpha': 0, 'lambda': 0}\n    dl_params = {'hidden': [32, 32, 32], 'epochs': 20}\n    my_gbm = H2OGradientBoostingEstimator(distribution='bernoulli', ntrees=10, nfolds=nfolds, fold_assignment='Modulo', keep_cross_validation_predictions=True, seed=1)\n    my_gbm.train(x=x, y=y, training_frame=train)\n    my_rf = H2ORandomForestEstimator(ntrees=50, nfolds=nfolds, fold_assignment='Modulo', keep_cross_validation_predictions=True, seed=1)\n    my_rf.train(x=x, y=y, training_frame=train)\n    stack_gbm = H2OStackedEnsembleEstimator(base_models=[my_gbm, my_rf], metalearner_algorithm='gbm', metalearner_params=gbm_params)\n    stack_gbm.train(x=x, y=y, training_frame=train)\n    assert stack_gbm.params['metalearner_algorithm']['actual'] == 'gbm'\n    meta_gbm = h2o.get_model(stack_gbm.metalearner()['name'])\n    assert meta_gbm.algo == 'gbm'\n    assert meta_gbm.params['ntrees']['actual'] == 100\n    assert meta_gbm.params['max_depth']['actual'] == 6\n    stack_drf = H2OStackedEnsembleEstimator(base_models=[my_gbm, my_rf], metalearner_algorithm='drf', metalearner_nfolds=3, metalearner_params=drf_params)\n    stack_drf.train(x=x, y=y, training_frame=train)\n    assert stack_drf.params['metalearner_algorithm']['actual'] == 'drf'\n    assert stack_drf.params['metalearner_nfolds']['actual'] == 3\n    meta_drf = h2o.get_model(stack_drf.metalearner()['name'])\n    assert meta_drf.algo == 'drf'\n    assert meta_drf.params['nfolds']['actual'] == 3\n    assert meta_drf.params['ntrees']['actual'] == 100\n    assert meta_drf.params['max_depth']['actual'] == 6\n    stack_glm = H2OStackedEnsembleEstimator(base_models=[my_gbm, my_rf], metalearner_algorithm='glm', metalearner_params=glm_params)\n    stack_glm.train(x=x, y=y, training_frame=train)\n    assert stack_glm.params['metalearner_algorithm']['actual'] == 'glm'\n    meta_glm = h2o.get_model(stack_glm.metalearner()['name'])\n    assert meta_glm.algo == 'glm'\n    assert meta_glm.params['alpha']['actual'] == [0.0]\n    assert meta_glm.params['lambda']['actual'] == [0.0]\n    stack_dl = H2OStackedEnsembleEstimator(base_models=[my_gbm, my_rf], metalearner_algorithm='deeplearning', metalearner_params=dl_params)\n    stack_dl.train(x=x, y=y, training_frame=train)\n    assert stack_dl.params['metalearner_algorithm']['actual'] == 'deeplearning'\n    meta_dl = h2o.get_model(stack_dl.metalearner()['name'])\n    assert meta_dl.algo == 'deeplearning'\n    assert meta_dl.params['hidden']['actual'] == [32, 32, 32]\n    assert meta_dl.params['epochs']['actual'] == 20.0",
            "def stackedensemble_custom_metalearner_test():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'This test checks the following:\\n    1) That H2OStackedEnsembleEstimator `metalearner_nfolds` works correctly\\n    2) That H2OStackedEnsembleEstimator `metalearner_nfolds` works in concert with `metalearner_nfolds`\\n    '\n    train = h2o.import_file(path=pyunit_utils.locate('smalldata/testng/higgs_train_5k.csv'), destination_frame='higgs_train_5k')\n    test = h2o.import_file(path=pyunit_utils.locate('smalldata/testng/higgs_test_5k.csv'), destination_frame='higgs_test_5k')\n    x = train.columns\n    y = 'response'\n    x.remove(y)\n    train[y] = train[y].asfactor()\n    test[y] = test[y].asfactor()\n    nfolds = 3\n    gbm_params = {'ntrees': 100, 'max_depth': 6}\n    drf_params = {'ntrees': 100, 'max_depth': 6}\n    glm_params = {'alpha': 0, 'lambda': 0}\n    dl_params = {'hidden': [32, 32, 32], 'epochs': 20}\n    my_gbm = H2OGradientBoostingEstimator(distribution='bernoulli', ntrees=10, nfolds=nfolds, fold_assignment='Modulo', keep_cross_validation_predictions=True, seed=1)\n    my_gbm.train(x=x, y=y, training_frame=train)\n    my_rf = H2ORandomForestEstimator(ntrees=50, nfolds=nfolds, fold_assignment='Modulo', keep_cross_validation_predictions=True, seed=1)\n    my_rf.train(x=x, y=y, training_frame=train)\n    stack_gbm = H2OStackedEnsembleEstimator(base_models=[my_gbm, my_rf], metalearner_algorithm='gbm', metalearner_params=gbm_params)\n    stack_gbm.train(x=x, y=y, training_frame=train)\n    assert stack_gbm.params['metalearner_algorithm']['actual'] == 'gbm'\n    meta_gbm = h2o.get_model(stack_gbm.metalearner()['name'])\n    assert meta_gbm.algo == 'gbm'\n    assert meta_gbm.params['ntrees']['actual'] == 100\n    assert meta_gbm.params['max_depth']['actual'] == 6\n    stack_drf = H2OStackedEnsembleEstimator(base_models=[my_gbm, my_rf], metalearner_algorithm='drf', metalearner_nfolds=3, metalearner_params=drf_params)\n    stack_drf.train(x=x, y=y, training_frame=train)\n    assert stack_drf.params['metalearner_algorithm']['actual'] == 'drf'\n    assert stack_drf.params['metalearner_nfolds']['actual'] == 3\n    meta_drf = h2o.get_model(stack_drf.metalearner()['name'])\n    assert meta_drf.algo == 'drf'\n    assert meta_drf.params['nfolds']['actual'] == 3\n    assert meta_drf.params['ntrees']['actual'] == 100\n    assert meta_drf.params['max_depth']['actual'] == 6\n    stack_glm = H2OStackedEnsembleEstimator(base_models=[my_gbm, my_rf], metalearner_algorithm='glm', metalearner_params=glm_params)\n    stack_glm.train(x=x, y=y, training_frame=train)\n    assert stack_glm.params['metalearner_algorithm']['actual'] == 'glm'\n    meta_glm = h2o.get_model(stack_glm.metalearner()['name'])\n    assert meta_glm.algo == 'glm'\n    assert meta_glm.params['alpha']['actual'] == [0.0]\n    assert meta_glm.params['lambda']['actual'] == [0.0]\n    stack_dl = H2OStackedEnsembleEstimator(base_models=[my_gbm, my_rf], metalearner_algorithm='deeplearning', metalearner_params=dl_params)\n    stack_dl.train(x=x, y=y, training_frame=train)\n    assert stack_dl.params['metalearner_algorithm']['actual'] == 'deeplearning'\n    meta_dl = h2o.get_model(stack_dl.metalearner()['name'])\n    assert meta_dl.algo == 'deeplearning'\n    assert meta_dl.params['hidden']['actual'] == [32, 32, 32]\n    assert meta_dl.params['epochs']['actual'] == 20.0",
            "def stackedensemble_custom_metalearner_test():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'This test checks the following:\\n    1) That H2OStackedEnsembleEstimator `metalearner_nfolds` works correctly\\n    2) That H2OStackedEnsembleEstimator `metalearner_nfolds` works in concert with `metalearner_nfolds`\\n    '\n    train = h2o.import_file(path=pyunit_utils.locate('smalldata/testng/higgs_train_5k.csv'), destination_frame='higgs_train_5k')\n    test = h2o.import_file(path=pyunit_utils.locate('smalldata/testng/higgs_test_5k.csv'), destination_frame='higgs_test_5k')\n    x = train.columns\n    y = 'response'\n    x.remove(y)\n    train[y] = train[y].asfactor()\n    test[y] = test[y].asfactor()\n    nfolds = 3\n    gbm_params = {'ntrees': 100, 'max_depth': 6}\n    drf_params = {'ntrees': 100, 'max_depth': 6}\n    glm_params = {'alpha': 0, 'lambda': 0}\n    dl_params = {'hidden': [32, 32, 32], 'epochs': 20}\n    my_gbm = H2OGradientBoostingEstimator(distribution='bernoulli', ntrees=10, nfolds=nfolds, fold_assignment='Modulo', keep_cross_validation_predictions=True, seed=1)\n    my_gbm.train(x=x, y=y, training_frame=train)\n    my_rf = H2ORandomForestEstimator(ntrees=50, nfolds=nfolds, fold_assignment='Modulo', keep_cross_validation_predictions=True, seed=1)\n    my_rf.train(x=x, y=y, training_frame=train)\n    stack_gbm = H2OStackedEnsembleEstimator(base_models=[my_gbm, my_rf], metalearner_algorithm='gbm', metalearner_params=gbm_params)\n    stack_gbm.train(x=x, y=y, training_frame=train)\n    assert stack_gbm.params['metalearner_algorithm']['actual'] == 'gbm'\n    meta_gbm = h2o.get_model(stack_gbm.metalearner()['name'])\n    assert meta_gbm.algo == 'gbm'\n    assert meta_gbm.params['ntrees']['actual'] == 100\n    assert meta_gbm.params['max_depth']['actual'] == 6\n    stack_drf = H2OStackedEnsembleEstimator(base_models=[my_gbm, my_rf], metalearner_algorithm='drf', metalearner_nfolds=3, metalearner_params=drf_params)\n    stack_drf.train(x=x, y=y, training_frame=train)\n    assert stack_drf.params['metalearner_algorithm']['actual'] == 'drf'\n    assert stack_drf.params['metalearner_nfolds']['actual'] == 3\n    meta_drf = h2o.get_model(stack_drf.metalearner()['name'])\n    assert meta_drf.algo == 'drf'\n    assert meta_drf.params['nfolds']['actual'] == 3\n    assert meta_drf.params['ntrees']['actual'] == 100\n    assert meta_drf.params['max_depth']['actual'] == 6\n    stack_glm = H2OStackedEnsembleEstimator(base_models=[my_gbm, my_rf], metalearner_algorithm='glm', metalearner_params=glm_params)\n    stack_glm.train(x=x, y=y, training_frame=train)\n    assert stack_glm.params['metalearner_algorithm']['actual'] == 'glm'\n    meta_glm = h2o.get_model(stack_glm.metalearner()['name'])\n    assert meta_glm.algo == 'glm'\n    assert meta_glm.params['alpha']['actual'] == [0.0]\n    assert meta_glm.params['lambda']['actual'] == [0.0]\n    stack_dl = H2OStackedEnsembleEstimator(base_models=[my_gbm, my_rf], metalearner_algorithm='deeplearning', metalearner_params=dl_params)\n    stack_dl.train(x=x, y=y, training_frame=train)\n    assert stack_dl.params['metalearner_algorithm']['actual'] == 'deeplearning'\n    meta_dl = h2o.get_model(stack_dl.metalearner()['name'])\n    assert meta_dl.algo == 'deeplearning'\n    assert meta_dl.params['hidden']['actual'] == [32, 32, 32]\n    assert meta_dl.params['epochs']['actual'] == 20.0",
            "def stackedensemble_custom_metalearner_test():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'This test checks the following:\\n    1) That H2OStackedEnsembleEstimator `metalearner_nfolds` works correctly\\n    2) That H2OStackedEnsembleEstimator `metalearner_nfolds` works in concert with `metalearner_nfolds`\\n    '\n    train = h2o.import_file(path=pyunit_utils.locate('smalldata/testng/higgs_train_5k.csv'), destination_frame='higgs_train_5k')\n    test = h2o.import_file(path=pyunit_utils.locate('smalldata/testng/higgs_test_5k.csv'), destination_frame='higgs_test_5k')\n    x = train.columns\n    y = 'response'\n    x.remove(y)\n    train[y] = train[y].asfactor()\n    test[y] = test[y].asfactor()\n    nfolds = 3\n    gbm_params = {'ntrees': 100, 'max_depth': 6}\n    drf_params = {'ntrees': 100, 'max_depth': 6}\n    glm_params = {'alpha': 0, 'lambda': 0}\n    dl_params = {'hidden': [32, 32, 32], 'epochs': 20}\n    my_gbm = H2OGradientBoostingEstimator(distribution='bernoulli', ntrees=10, nfolds=nfolds, fold_assignment='Modulo', keep_cross_validation_predictions=True, seed=1)\n    my_gbm.train(x=x, y=y, training_frame=train)\n    my_rf = H2ORandomForestEstimator(ntrees=50, nfolds=nfolds, fold_assignment='Modulo', keep_cross_validation_predictions=True, seed=1)\n    my_rf.train(x=x, y=y, training_frame=train)\n    stack_gbm = H2OStackedEnsembleEstimator(base_models=[my_gbm, my_rf], metalearner_algorithm='gbm', metalearner_params=gbm_params)\n    stack_gbm.train(x=x, y=y, training_frame=train)\n    assert stack_gbm.params['metalearner_algorithm']['actual'] == 'gbm'\n    meta_gbm = h2o.get_model(stack_gbm.metalearner()['name'])\n    assert meta_gbm.algo == 'gbm'\n    assert meta_gbm.params['ntrees']['actual'] == 100\n    assert meta_gbm.params['max_depth']['actual'] == 6\n    stack_drf = H2OStackedEnsembleEstimator(base_models=[my_gbm, my_rf], metalearner_algorithm='drf', metalearner_nfolds=3, metalearner_params=drf_params)\n    stack_drf.train(x=x, y=y, training_frame=train)\n    assert stack_drf.params['metalearner_algorithm']['actual'] == 'drf'\n    assert stack_drf.params['metalearner_nfolds']['actual'] == 3\n    meta_drf = h2o.get_model(stack_drf.metalearner()['name'])\n    assert meta_drf.algo == 'drf'\n    assert meta_drf.params['nfolds']['actual'] == 3\n    assert meta_drf.params['ntrees']['actual'] == 100\n    assert meta_drf.params['max_depth']['actual'] == 6\n    stack_glm = H2OStackedEnsembleEstimator(base_models=[my_gbm, my_rf], metalearner_algorithm='glm', metalearner_params=glm_params)\n    stack_glm.train(x=x, y=y, training_frame=train)\n    assert stack_glm.params['metalearner_algorithm']['actual'] == 'glm'\n    meta_glm = h2o.get_model(stack_glm.metalearner()['name'])\n    assert meta_glm.algo == 'glm'\n    assert meta_glm.params['alpha']['actual'] == [0.0]\n    assert meta_glm.params['lambda']['actual'] == [0.0]\n    stack_dl = H2OStackedEnsembleEstimator(base_models=[my_gbm, my_rf], metalearner_algorithm='deeplearning', metalearner_params=dl_params)\n    stack_dl.train(x=x, y=y, training_frame=train)\n    assert stack_dl.params['metalearner_algorithm']['actual'] == 'deeplearning'\n    meta_dl = h2o.get_model(stack_dl.metalearner()['name'])\n    assert meta_dl.algo == 'deeplearning'\n    assert meta_dl.params['hidden']['actual'] == [32, 32, 32]\n    assert meta_dl.params['epochs']['actual'] == 20.0"
        ]
    }
]