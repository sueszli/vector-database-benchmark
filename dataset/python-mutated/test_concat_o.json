[
    {
        "func_name": "concat2",
        "original": "def concat2(arr, dim):\n    \"\"\"Concat Operator can concat a list of jt Var at a specfic dimension.\n    \n    * [in] x:   input var list for concat\n\n    * [in] dim: concat which dim\n\n    * [out] out:  concat result\n\nExample::\n\n        jt.concat([jt.array([[1],[2]]), jt.array([[2],[2]])], dim=1)\n        # return [[1],[2],[2],[2]]\n    \"\"\"\n    total_dim = 0\n    if dim < 0:\n        dim += len(arr[0].shape)\n    for a in arr:\n        total_dim += a.shape[dim]\n    cdim = 0\n    shape = list(a.shape)\n    shape[dim] = total_dim\n    s = jt.empty(shape, a.dtype)\n    slices = [slice(None)] * len(a.shape)\n    for a in arr:\n        slices[dim] = slice(cdim, cdim + a.shape[dim])\n        s = s.setitem(tuple(slices), a)\n        cdim += a.shape[dim]\n    return s",
        "mutated": [
            "def concat2(arr, dim):\n    if False:\n        i = 10\n    'Concat Operator can concat a list of jt Var at a specfic dimension.\\n    \\n    * [in] x:   input var list for concat\\n\\n    * [in] dim: concat which dim\\n\\n    * [out] out:  concat result\\n\\nExample::\\n\\n        jt.concat([jt.array([[1],[2]]), jt.array([[2],[2]])], dim=1)\\n        # return [[1],[2],[2],[2]]\\n    '\n    total_dim = 0\n    if dim < 0:\n        dim += len(arr[0].shape)\n    for a in arr:\n        total_dim += a.shape[dim]\n    cdim = 0\n    shape = list(a.shape)\n    shape[dim] = total_dim\n    s = jt.empty(shape, a.dtype)\n    slices = [slice(None)] * len(a.shape)\n    for a in arr:\n        slices[dim] = slice(cdim, cdim + a.shape[dim])\n        s = s.setitem(tuple(slices), a)\n        cdim += a.shape[dim]\n    return s",
            "def concat2(arr, dim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Concat Operator can concat a list of jt Var at a specfic dimension.\\n    \\n    * [in] x:   input var list for concat\\n\\n    * [in] dim: concat which dim\\n\\n    * [out] out:  concat result\\n\\nExample::\\n\\n        jt.concat([jt.array([[1],[2]]), jt.array([[2],[2]])], dim=1)\\n        # return [[1],[2],[2],[2]]\\n    '\n    total_dim = 0\n    if dim < 0:\n        dim += len(arr[0].shape)\n    for a in arr:\n        total_dim += a.shape[dim]\n    cdim = 0\n    shape = list(a.shape)\n    shape[dim] = total_dim\n    s = jt.empty(shape, a.dtype)\n    slices = [slice(None)] * len(a.shape)\n    for a in arr:\n        slices[dim] = slice(cdim, cdim + a.shape[dim])\n        s = s.setitem(tuple(slices), a)\n        cdim += a.shape[dim]\n    return s",
            "def concat2(arr, dim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Concat Operator can concat a list of jt Var at a specfic dimension.\\n    \\n    * [in] x:   input var list for concat\\n\\n    * [in] dim: concat which dim\\n\\n    * [out] out:  concat result\\n\\nExample::\\n\\n        jt.concat([jt.array([[1],[2]]), jt.array([[2],[2]])], dim=1)\\n        # return [[1],[2],[2],[2]]\\n    '\n    total_dim = 0\n    if dim < 0:\n        dim += len(arr[0].shape)\n    for a in arr:\n        total_dim += a.shape[dim]\n    cdim = 0\n    shape = list(a.shape)\n    shape[dim] = total_dim\n    s = jt.empty(shape, a.dtype)\n    slices = [slice(None)] * len(a.shape)\n    for a in arr:\n        slices[dim] = slice(cdim, cdim + a.shape[dim])\n        s = s.setitem(tuple(slices), a)\n        cdim += a.shape[dim]\n    return s",
            "def concat2(arr, dim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Concat Operator can concat a list of jt Var at a specfic dimension.\\n    \\n    * [in] x:   input var list for concat\\n\\n    * [in] dim: concat which dim\\n\\n    * [out] out:  concat result\\n\\nExample::\\n\\n        jt.concat([jt.array([[1],[2]]), jt.array([[2],[2]])], dim=1)\\n        # return [[1],[2],[2],[2]]\\n    '\n    total_dim = 0\n    if dim < 0:\n        dim += len(arr[0].shape)\n    for a in arr:\n        total_dim += a.shape[dim]\n    cdim = 0\n    shape = list(a.shape)\n    shape[dim] = total_dim\n    s = jt.empty(shape, a.dtype)\n    slices = [slice(None)] * len(a.shape)\n    for a in arr:\n        slices[dim] = slice(cdim, cdim + a.shape[dim])\n        s = s.setitem(tuple(slices), a)\n        cdim += a.shape[dim]\n    return s",
            "def concat2(arr, dim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Concat Operator can concat a list of jt Var at a specfic dimension.\\n    \\n    * [in] x:   input var list for concat\\n\\n    * [in] dim: concat which dim\\n\\n    * [out] out:  concat result\\n\\nExample::\\n\\n        jt.concat([jt.array([[1],[2]]), jt.array([[2],[2]])], dim=1)\\n        # return [[1],[2],[2],[2]]\\n    '\n    total_dim = 0\n    if dim < 0:\n        dim += len(arr[0].shape)\n    for a in arr:\n        total_dim += a.shape[dim]\n    cdim = 0\n    shape = list(a.shape)\n    shape[dim] = total_dim\n    s = jt.empty(shape, a.dtype)\n    slices = [slice(None)] * len(a.shape)\n    for a in arr:\n        slices[dim] = slice(cdim, cdim + a.shape[dim])\n        s = s.setitem(tuple(slices), a)\n        cdim += a.shape[dim]\n    return s"
        ]
    },
    {
        "func_name": "numpy_concat",
        "original": "def numpy_concat(arr, dim):\n    arr = [a.numpy() for a in arr]\n    return np.concatenate(arr, dim)",
        "mutated": [
            "def numpy_concat(arr, dim):\n    if False:\n        i = 10\n    arr = [a.numpy() for a in arr]\n    return np.concatenate(arr, dim)",
            "def numpy_concat(arr, dim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    arr = [a.numpy() for a in arr]\n    return np.concatenate(arr, dim)",
            "def numpy_concat(arr, dim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    arr = [a.numpy() for a in arr]\n    return np.concatenate(arr, dim)",
            "def numpy_concat(arr, dim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    arr = [a.numpy() for a in arr]\n    return np.concatenate(arr, dim)",
            "def numpy_concat(arr, dim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    arr = [a.numpy() for a in arr]\n    return np.concatenate(arr, dim)"
        ]
    },
    {
        "func_name": "check",
        "original": "def check(tmp, dim=0):\n    res1 = numpy_concat(tmp, dim=dim)\n    res2 = jt.concat(tmp, dim=dim)\n    assert (res2 != res1).data.sum() == 0, 'concat fail...'",
        "mutated": [
            "def check(tmp, dim=0):\n    if False:\n        i = 10\n    res1 = numpy_concat(tmp, dim=dim)\n    res2 = jt.concat(tmp, dim=dim)\n    assert (res2 != res1).data.sum() == 0, 'concat fail...'",
            "def check(tmp, dim=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    res1 = numpy_concat(tmp, dim=dim)\n    res2 = jt.concat(tmp, dim=dim)\n    assert (res2 != res1).data.sum() == 0, 'concat fail...'",
            "def check(tmp, dim=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    res1 = numpy_concat(tmp, dim=dim)\n    res2 = jt.concat(tmp, dim=dim)\n    assert (res2 != res1).data.sum() == 0, 'concat fail...'",
            "def check(tmp, dim=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    res1 = numpy_concat(tmp, dim=dim)\n    res2 = jt.concat(tmp, dim=dim)\n    assert (res2 != res1).data.sum() == 0, 'concat fail...'",
            "def check(tmp, dim=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    res1 = numpy_concat(tmp, dim=dim)\n    res2 = jt.concat(tmp, dim=dim)\n    assert (res2 != res1).data.sum() == 0, 'concat fail...'"
        ]
    },
    {
        "func_name": "test_concat_op",
        "original": "def test_concat_op(self):\n\n    def check(tmp, dim=0):\n        res1 = numpy_concat(tmp, dim=dim)\n        res2 = jt.concat(tmp, dim=dim)\n        assert (res2 != res1).data.sum() == 0, 'concat fail...'\n    check([jt.array([[1], [2]]), jt.array([[2], [2]])])\n    check([jt.array(np.array(range(24))).reshape((1, 2, 3, 4)), jt.array(np.array(range(24))).reshape((1, 2, 3, 4))])\n    check([jt.array(np.array(range(120))).reshape((5, 2, 3, 4)), jt.array(np.array(range(24))).reshape((1, 2, 3, 4))])\n    check([jt.array(np.array(range(5))).reshape((5, 1)), jt.array(np.array(range(1))).reshape((1, 1))])\n    print('concat success...')",
        "mutated": [
            "def test_concat_op(self):\n    if False:\n        i = 10\n\n    def check(tmp, dim=0):\n        res1 = numpy_concat(tmp, dim=dim)\n        res2 = jt.concat(tmp, dim=dim)\n        assert (res2 != res1).data.sum() == 0, 'concat fail...'\n    check([jt.array([[1], [2]]), jt.array([[2], [2]])])\n    check([jt.array(np.array(range(24))).reshape((1, 2, 3, 4)), jt.array(np.array(range(24))).reshape((1, 2, 3, 4))])\n    check([jt.array(np.array(range(120))).reshape((5, 2, 3, 4)), jt.array(np.array(range(24))).reshape((1, 2, 3, 4))])\n    check([jt.array(np.array(range(5))).reshape((5, 1)), jt.array(np.array(range(1))).reshape((1, 1))])\n    print('concat success...')",
            "def test_concat_op(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def check(tmp, dim=0):\n        res1 = numpy_concat(tmp, dim=dim)\n        res2 = jt.concat(tmp, dim=dim)\n        assert (res2 != res1).data.sum() == 0, 'concat fail...'\n    check([jt.array([[1], [2]]), jt.array([[2], [2]])])\n    check([jt.array(np.array(range(24))).reshape((1, 2, 3, 4)), jt.array(np.array(range(24))).reshape((1, 2, 3, 4))])\n    check([jt.array(np.array(range(120))).reshape((5, 2, 3, 4)), jt.array(np.array(range(24))).reshape((1, 2, 3, 4))])\n    check([jt.array(np.array(range(5))).reshape((5, 1)), jt.array(np.array(range(1))).reshape((1, 1))])\n    print('concat success...')",
            "def test_concat_op(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def check(tmp, dim=0):\n        res1 = numpy_concat(tmp, dim=dim)\n        res2 = jt.concat(tmp, dim=dim)\n        assert (res2 != res1).data.sum() == 0, 'concat fail...'\n    check([jt.array([[1], [2]]), jt.array([[2], [2]])])\n    check([jt.array(np.array(range(24))).reshape((1, 2, 3, 4)), jt.array(np.array(range(24))).reshape((1, 2, 3, 4))])\n    check([jt.array(np.array(range(120))).reshape((5, 2, 3, 4)), jt.array(np.array(range(24))).reshape((1, 2, 3, 4))])\n    check([jt.array(np.array(range(5))).reshape((5, 1)), jt.array(np.array(range(1))).reshape((1, 1))])\n    print('concat success...')",
            "def test_concat_op(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def check(tmp, dim=0):\n        res1 = numpy_concat(tmp, dim=dim)\n        res2 = jt.concat(tmp, dim=dim)\n        assert (res2 != res1).data.sum() == 0, 'concat fail...'\n    check([jt.array([[1], [2]]), jt.array([[2], [2]])])\n    check([jt.array(np.array(range(24))).reshape((1, 2, 3, 4)), jt.array(np.array(range(24))).reshape((1, 2, 3, 4))])\n    check([jt.array(np.array(range(120))).reshape((5, 2, 3, 4)), jt.array(np.array(range(24))).reshape((1, 2, 3, 4))])\n    check([jt.array(np.array(range(5))).reshape((5, 1)), jt.array(np.array(range(1))).reshape((1, 1))])\n    print('concat success...')",
            "def test_concat_op(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def check(tmp, dim=0):\n        res1 = numpy_concat(tmp, dim=dim)\n        res2 = jt.concat(tmp, dim=dim)\n        assert (res2 != res1).data.sum() == 0, 'concat fail...'\n    check([jt.array([[1], [2]]), jt.array([[2], [2]])])\n    check([jt.array(np.array(range(24))).reshape((1, 2, 3, 4)), jt.array(np.array(range(24))).reshape((1, 2, 3, 4))])\n    check([jt.array(np.array(range(120))).reshape((5, 2, 3, 4)), jt.array(np.array(range(24))).reshape((1, 2, 3, 4))])\n    check([jt.array(np.array(range(5))).reshape((5, 1)), jt.array(np.array(range(1))).reshape((1, 1))])\n    print('concat success...')"
        ]
    },
    {
        "func_name": "check",
        "original": "def check(dim, size, backward=False):\n    n = 64\n    a = jt.random((n, n, n, n))\n    a.sync()\n    m = n // size\n    arr = []\n    for i in range(m):\n        arr.append(a[(slice(None),) * dim + (slice(i * size, i * size + size),)])\n    b = jt.concat(arr, dim)\n    if backward:\n        loss = b * a\n        b = jt.grad(loss, a)\n    with jt.profile_scope(1, 0) as rep:\n        b.sync()\n    i = rep[0].index('TotalTime')\n    stime = 0\n    for r in rep[1:]:\n        stime += float(r[i])\n    bw = 4 * 64 ** 4 * 2 * 2 / stime\n    print(f'{dim} {size} {stime / 1000000.0}ms, {bw}GB/s')\n    return bw",
        "mutated": [
            "def check(dim, size, backward=False):\n    if False:\n        i = 10\n    n = 64\n    a = jt.random((n, n, n, n))\n    a.sync()\n    m = n // size\n    arr = []\n    for i in range(m):\n        arr.append(a[(slice(None),) * dim + (slice(i * size, i * size + size),)])\n    b = jt.concat(arr, dim)\n    if backward:\n        loss = b * a\n        b = jt.grad(loss, a)\n    with jt.profile_scope(1, 0) as rep:\n        b.sync()\n    i = rep[0].index('TotalTime')\n    stime = 0\n    for r in rep[1:]:\n        stime += float(r[i])\n    bw = 4 * 64 ** 4 * 2 * 2 / stime\n    print(f'{dim} {size} {stime / 1000000.0}ms, {bw}GB/s')\n    return bw",
            "def check(dim, size, backward=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    n = 64\n    a = jt.random((n, n, n, n))\n    a.sync()\n    m = n // size\n    arr = []\n    for i in range(m):\n        arr.append(a[(slice(None),) * dim + (slice(i * size, i * size + size),)])\n    b = jt.concat(arr, dim)\n    if backward:\n        loss = b * a\n        b = jt.grad(loss, a)\n    with jt.profile_scope(1, 0) as rep:\n        b.sync()\n    i = rep[0].index('TotalTime')\n    stime = 0\n    for r in rep[1:]:\n        stime += float(r[i])\n    bw = 4 * 64 ** 4 * 2 * 2 / stime\n    print(f'{dim} {size} {stime / 1000000.0}ms, {bw}GB/s')\n    return bw",
            "def check(dim, size, backward=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    n = 64\n    a = jt.random((n, n, n, n))\n    a.sync()\n    m = n // size\n    arr = []\n    for i in range(m):\n        arr.append(a[(slice(None),) * dim + (slice(i * size, i * size + size),)])\n    b = jt.concat(arr, dim)\n    if backward:\n        loss = b * a\n        b = jt.grad(loss, a)\n    with jt.profile_scope(1, 0) as rep:\n        b.sync()\n    i = rep[0].index('TotalTime')\n    stime = 0\n    for r in rep[1:]:\n        stime += float(r[i])\n    bw = 4 * 64 ** 4 * 2 * 2 / stime\n    print(f'{dim} {size} {stime / 1000000.0}ms, {bw}GB/s')\n    return bw",
            "def check(dim, size, backward=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    n = 64\n    a = jt.random((n, n, n, n))\n    a.sync()\n    m = n // size\n    arr = []\n    for i in range(m):\n        arr.append(a[(slice(None),) * dim + (slice(i * size, i * size + size),)])\n    b = jt.concat(arr, dim)\n    if backward:\n        loss = b * a\n        b = jt.grad(loss, a)\n    with jt.profile_scope(1, 0) as rep:\n        b.sync()\n    i = rep[0].index('TotalTime')\n    stime = 0\n    for r in rep[1:]:\n        stime += float(r[i])\n    bw = 4 * 64 ** 4 * 2 * 2 / stime\n    print(f'{dim} {size} {stime / 1000000.0}ms, {bw}GB/s')\n    return bw",
            "def check(dim, size, backward=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    n = 64\n    a = jt.random((n, n, n, n))\n    a.sync()\n    m = n // size\n    arr = []\n    for i in range(m):\n        arr.append(a[(slice(None),) * dim + (slice(i * size, i * size + size),)])\n    b = jt.concat(arr, dim)\n    if backward:\n        loss = b * a\n        b = jt.grad(loss, a)\n    with jt.profile_scope(1, 0) as rep:\n        b.sync()\n    i = rep[0].index('TotalTime')\n    stime = 0\n    for r in rep[1:]:\n        stime += float(r[i])\n    bw = 4 * 64 ** 4 * 2 * 2 / stime\n    print(f'{dim} {size} {stime / 1000000.0}ms, {bw}GB/s')\n    return bw"
        ]
    },
    {
        "func_name": "test_concat_perf",
        "original": "@unittest.skipIf(not jt.has_cuda, 'No CUDA found')\n@jt.flag_scope(use_cuda=1)\ndef test_concat_perf(self):\n\n    def check(dim, size, backward=False):\n        n = 64\n        a = jt.random((n, n, n, n))\n        a.sync()\n        m = n // size\n        arr = []\n        for i in range(m):\n            arr.append(a[(slice(None),) * dim + (slice(i * size, i * size + size),)])\n        b = jt.concat(arr, dim)\n        if backward:\n            loss = b * a\n            b = jt.grad(loss, a)\n        with jt.profile_scope(1, 0) as rep:\n            b.sync()\n        i = rep[0].index('TotalTime')\n        stime = 0\n        for r in rep[1:]:\n            stime += float(r[i])\n        bw = 4 * 64 ** 4 * 2 * 2 / stime\n        print(f'{dim} {size} {stime / 1000000.0}ms, {bw}GB/s')\n        return bw\n    ndim = 4\n    splits = [1, 2, 4, 8, 16, 32, 64]\n    m = len(splits)\n    result = np.zeros((4, m))\n    result_back = np.zeros((4, m))\n    for i in range(ndim):\n        for j in range(m):\n            result[i, j] = check(i, splits[j])\n            result_back[i, j] = check(i, splits[j], True)\n    print(result.T)\n    print(result_back.T)\n    '\\n[[ 17.02802497  17.12933081  17.10814418  15.49217942]\\n [ 33.10922467  33.01865886  33.08940182  30.24637466]\\n [ 62.27219795  62.06702029  61.90039457  58.68727009]\\n [112.31933307 111.89659519 111.02357161 108.98520165]\\n [187.24806534 190.68837367 186.73965711 186.32242015]\\n [280.28594579 278.94498734 284.42015302 284.98722929]\\n [387.03887468 386.14916854 386.47551229 385.28621521]]\\n\\n[[  5.04141217   4.55677858   4.55677363   3.79321142]\\n [  9.05243799   8.99777599   8.96021333   7.49345194]\\n [ 17.45032635  17.36882645  17.14316909  14.98928307]\\n [ 35.60450372  35.55333375  35.32826879  32.00750909]\\n [ 61.72854251  62.285231    61.64460882  58.17541776]\\n [ 97.44981525  96.79104909  95.38118155  95.09154931]\\n [135.11495888 134.60444658 135.41807381 135.38139881]]\\n\\n        '",
        "mutated": [
            "@unittest.skipIf(not jt.has_cuda, 'No CUDA found')\n@jt.flag_scope(use_cuda=1)\ndef test_concat_perf(self):\n    if False:\n        i = 10\n\n    def check(dim, size, backward=False):\n        n = 64\n        a = jt.random((n, n, n, n))\n        a.sync()\n        m = n // size\n        arr = []\n        for i in range(m):\n            arr.append(a[(slice(None),) * dim + (slice(i * size, i * size + size),)])\n        b = jt.concat(arr, dim)\n        if backward:\n            loss = b * a\n            b = jt.grad(loss, a)\n        with jt.profile_scope(1, 0) as rep:\n            b.sync()\n        i = rep[0].index('TotalTime')\n        stime = 0\n        for r in rep[1:]:\n            stime += float(r[i])\n        bw = 4 * 64 ** 4 * 2 * 2 / stime\n        print(f'{dim} {size} {stime / 1000000.0}ms, {bw}GB/s')\n        return bw\n    ndim = 4\n    splits = [1, 2, 4, 8, 16, 32, 64]\n    m = len(splits)\n    result = np.zeros((4, m))\n    result_back = np.zeros((4, m))\n    for i in range(ndim):\n        for j in range(m):\n            result[i, j] = check(i, splits[j])\n            result_back[i, j] = check(i, splits[j], True)\n    print(result.T)\n    print(result_back.T)\n    '\\n[[ 17.02802497  17.12933081  17.10814418  15.49217942]\\n [ 33.10922467  33.01865886  33.08940182  30.24637466]\\n [ 62.27219795  62.06702029  61.90039457  58.68727009]\\n [112.31933307 111.89659519 111.02357161 108.98520165]\\n [187.24806534 190.68837367 186.73965711 186.32242015]\\n [280.28594579 278.94498734 284.42015302 284.98722929]\\n [387.03887468 386.14916854 386.47551229 385.28621521]]\\n\\n[[  5.04141217   4.55677858   4.55677363   3.79321142]\\n [  9.05243799   8.99777599   8.96021333   7.49345194]\\n [ 17.45032635  17.36882645  17.14316909  14.98928307]\\n [ 35.60450372  35.55333375  35.32826879  32.00750909]\\n [ 61.72854251  62.285231    61.64460882  58.17541776]\\n [ 97.44981525  96.79104909  95.38118155  95.09154931]\\n [135.11495888 134.60444658 135.41807381 135.38139881]]\\n\\n        '",
            "@unittest.skipIf(not jt.has_cuda, 'No CUDA found')\n@jt.flag_scope(use_cuda=1)\ndef test_concat_perf(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def check(dim, size, backward=False):\n        n = 64\n        a = jt.random((n, n, n, n))\n        a.sync()\n        m = n // size\n        arr = []\n        for i in range(m):\n            arr.append(a[(slice(None),) * dim + (slice(i * size, i * size + size),)])\n        b = jt.concat(arr, dim)\n        if backward:\n            loss = b * a\n            b = jt.grad(loss, a)\n        with jt.profile_scope(1, 0) as rep:\n            b.sync()\n        i = rep[0].index('TotalTime')\n        stime = 0\n        for r in rep[1:]:\n            stime += float(r[i])\n        bw = 4 * 64 ** 4 * 2 * 2 / stime\n        print(f'{dim} {size} {stime / 1000000.0}ms, {bw}GB/s')\n        return bw\n    ndim = 4\n    splits = [1, 2, 4, 8, 16, 32, 64]\n    m = len(splits)\n    result = np.zeros((4, m))\n    result_back = np.zeros((4, m))\n    for i in range(ndim):\n        for j in range(m):\n            result[i, j] = check(i, splits[j])\n            result_back[i, j] = check(i, splits[j], True)\n    print(result.T)\n    print(result_back.T)\n    '\\n[[ 17.02802497  17.12933081  17.10814418  15.49217942]\\n [ 33.10922467  33.01865886  33.08940182  30.24637466]\\n [ 62.27219795  62.06702029  61.90039457  58.68727009]\\n [112.31933307 111.89659519 111.02357161 108.98520165]\\n [187.24806534 190.68837367 186.73965711 186.32242015]\\n [280.28594579 278.94498734 284.42015302 284.98722929]\\n [387.03887468 386.14916854 386.47551229 385.28621521]]\\n\\n[[  5.04141217   4.55677858   4.55677363   3.79321142]\\n [  9.05243799   8.99777599   8.96021333   7.49345194]\\n [ 17.45032635  17.36882645  17.14316909  14.98928307]\\n [ 35.60450372  35.55333375  35.32826879  32.00750909]\\n [ 61.72854251  62.285231    61.64460882  58.17541776]\\n [ 97.44981525  96.79104909  95.38118155  95.09154931]\\n [135.11495888 134.60444658 135.41807381 135.38139881]]\\n\\n        '",
            "@unittest.skipIf(not jt.has_cuda, 'No CUDA found')\n@jt.flag_scope(use_cuda=1)\ndef test_concat_perf(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def check(dim, size, backward=False):\n        n = 64\n        a = jt.random((n, n, n, n))\n        a.sync()\n        m = n // size\n        arr = []\n        for i in range(m):\n            arr.append(a[(slice(None),) * dim + (slice(i * size, i * size + size),)])\n        b = jt.concat(arr, dim)\n        if backward:\n            loss = b * a\n            b = jt.grad(loss, a)\n        with jt.profile_scope(1, 0) as rep:\n            b.sync()\n        i = rep[0].index('TotalTime')\n        stime = 0\n        for r in rep[1:]:\n            stime += float(r[i])\n        bw = 4 * 64 ** 4 * 2 * 2 / stime\n        print(f'{dim} {size} {stime / 1000000.0}ms, {bw}GB/s')\n        return bw\n    ndim = 4\n    splits = [1, 2, 4, 8, 16, 32, 64]\n    m = len(splits)\n    result = np.zeros((4, m))\n    result_back = np.zeros((4, m))\n    for i in range(ndim):\n        for j in range(m):\n            result[i, j] = check(i, splits[j])\n            result_back[i, j] = check(i, splits[j], True)\n    print(result.T)\n    print(result_back.T)\n    '\\n[[ 17.02802497  17.12933081  17.10814418  15.49217942]\\n [ 33.10922467  33.01865886  33.08940182  30.24637466]\\n [ 62.27219795  62.06702029  61.90039457  58.68727009]\\n [112.31933307 111.89659519 111.02357161 108.98520165]\\n [187.24806534 190.68837367 186.73965711 186.32242015]\\n [280.28594579 278.94498734 284.42015302 284.98722929]\\n [387.03887468 386.14916854 386.47551229 385.28621521]]\\n\\n[[  5.04141217   4.55677858   4.55677363   3.79321142]\\n [  9.05243799   8.99777599   8.96021333   7.49345194]\\n [ 17.45032635  17.36882645  17.14316909  14.98928307]\\n [ 35.60450372  35.55333375  35.32826879  32.00750909]\\n [ 61.72854251  62.285231    61.64460882  58.17541776]\\n [ 97.44981525  96.79104909  95.38118155  95.09154931]\\n [135.11495888 134.60444658 135.41807381 135.38139881]]\\n\\n        '",
            "@unittest.skipIf(not jt.has_cuda, 'No CUDA found')\n@jt.flag_scope(use_cuda=1)\ndef test_concat_perf(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def check(dim, size, backward=False):\n        n = 64\n        a = jt.random((n, n, n, n))\n        a.sync()\n        m = n // size\n        arr = []\n        for i in range(m):\n            arr.append(a[(slice(None),) * dim + (slice(i * size, i * size + size),)])\n        b = jt.concat(arr, dim)\n        if backward:\n            loss = b * a\n            b = jt.grad(loss, a)\n        with jt.profile_scope(1, 0) as rep:\n            b.sync()\n        i = rep[0].index('TotalTime')\n        stime = 0\n        for r in rep[1:]:\n            stime += float(r[i])\n        bw = 4 * 64 ** 4 * 2 * 2 / stime\n        print(f'{dim} {size} {stime / 1000000.0}ms, {bw}GB/s')\n        return bw\n    ndim = 4\n    splits = [1, 2, 4, 8, 16, 32, 64]\n    m = len(splits)\n    result = np.zeros((4, m))\n    result_back = np.zeros((4, m))\n    for i in range(ndim):\n        for j in range(m):\n            result[i, j] = check(i, splits[j])\n            result_back[i, j] = check(i, splits[j], True)\n    print(result.T)\n    print(result_back.T)\n    '\\n[[ 17.02802497  17.12933081  17.10814418  15.49217942]\\n [ 33.10922467  33.01865886  33.08940182  30.24637466]\\n [ 62.27219795  62.06702029  61.90039457  58.68727009]\\n [112.31933307 111.89659519 111.02357161 108.98520165]\\n [187.24806534 190.68837367 186.73965711 186.32242015]\\n [280.28594579 278.94498734 284.42015302 284.98722929]\\n [387.03887468 386.14916854 386.47551229 385.28621521]]\\n\\n[[  5.04141217   4.55677858   4.55677363   3.79321142]\\n [  9.05243799   8.99777599   8.96021333   7.49345194]\\n [ 17.45032635  17.36882645  17.14316909  14.98928307]\\n [ 35.60450372  35.55333375  35.32826879  32.00750909]\\n [ 61.72854251  62.285231    61.64460882  58.17541776]\\n [ 97.44981525  96.79104909  95.38118155  95.09154931]\\n [135.11495888 134.60444658 135.41807381 135.38139881]]\\n\\n        '",
            "@unittest.skipIf(not jt.has_cuda, 'No CUDA found')\n@jt.flag_scope(use_cuda=1)\ndef test_concat_perf(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def check(dim, size, backward=False):\n        n = 64\n        a = jt.random((n, n, n, n))\n        a.sync()\n        m = n // size\n        arr = []\n        for i in range(m):\n            arr.append(a[(slice(None),) * dim + (slice(i * size, i * size + size),)])\n        b = jt.concat(arr, dim)\n        if backward:\n            loss = b * a\n            b = jt.grad(loss, a)\n        with jt.profile_scope(1, 0) as rep:\n            b.sync()\n        i = rep[0].index('TotalTime')\n        stime = 0\n        for r in rep[1:]:\n            stime += float(r[i])\n        bw = 4 * 64 ** 4 * 2 * 2 / stime\n        print(f'{dim} {size} {stime / 1000000.0}ms, {bw}GB/s')\n        return bw\n    ndim = 4\n    splits = [1, 2, 4, 8, 16, 32, 64]\n    m = len(splits)\n    result = np.zeros((4, m))\n    result_back = np.zeros((4, m))\n    for i in range(ndim):\n        for j in range(m):\n            result[i, j] = check(i, splits[j])\n            result_back[i, j] = check(i, splits[j], True)\n    print(result.T)\n    print(result_back.T)\n    '\\n[[ 17.02802497  17.12933081  17.10814418  15.49217942]\\n [ 33.10922467  33.01865886  33.08940182  30.24637466]\\n [ 62.27219795  62.06702029  61.90039457  58.68727009]\\n [112.31933307 111.89659519 111.02357161 108.98520165]\\n [187.24806534 190.68837367 186.73965711 186.32242015]\\n [280.28594579 278.94498734 284.42015302 284.98722929]\\n [387.03887468 386.14916854 386.47551229 385.28621521]]\\n\\n[[  5.04141217   4.55677858   4.55677363   3.79321142]\\n [  9.05243799   8.99777599   8.96021333   7.49345194]\\n [ 17.45032635  17.36882645  17.14316909  14.98928307]\\n [ 35.60450372  35.55333375  35.32826879  32.00750909]\\n [ 61.72854251  62.285231    61.64460882  58.17541776]\\n [ 97.44981525  96.79104909  95.38118155  95.09154931]\\n [135.11495888 134.60444658 135.41807381 135.38139881]]\\n\\n        '"
        ]
    },
    {
        "func_name": "check",
        "original": "def check(dim, size, backward=False):\n    n = 64\n    a = jt.random((n, n, n, n))\n    a.sync()\n    m = n // size\n    arr = []\n    for i in range(m):\n        arr.append(a.getitem((slice(None),) * dim + (slice(i * size, i * size + size),)))\n    b = concat2(arr, dim)\n    if backward:\n        loss = b * a\n        b = jt.grad(loss, a)\n    with jt.profile_scope(1, 0) as rep:\n        b.sync()\n    i = rep[0].index('TotalTime')\n    stime = 0\n    for r in rep[1:]:\n        stime += float(r[i])\n    bw = 4 * 64 ** 4 * 2 * 2 / stime\n    print(f'{dim} {size} {stime / 1000000.0}ms, {bw}GB/s')\n    return bw",
        "mutated": [
            "def check(dim, size, backward=False):\n    if False:\n        i = 10\n    n = 64\n    a = jt.random((n, n, n, n))\n    a.sync()\n    m = n // size\n    arr = []\n    for i in range(m):\n        arr.append(a.getitem((slice(None),) * dim + (slice(i * size, i * size + size),)))\n    b = concat2(arr, dim)\n    if backward:\n        loss = b * a\n        b = jt.grad(loss, a)\n    with jt.profile_scope(1, 0) as rep:\n        b.sync()\n    i = rep[0].index('TotalTime')\n    stime = 0\n    for r in rep[1:]:\n        stime += float(r[i])\n    bw = 4 * 64 ** 4 * 2 * 2 / stime\n    print(f'{dim} {size} {stime / 1000000.0}ms, {bw}GB/s')\n    return bw",
            "def check(dim, size, backward=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    n = 64\n    a = jt.random((n, n, n, n))\n    a.sync()\n    m = n // size\n    arr = []\n    for i in range(m):\n        arr.append(a.getitem((slice(None),) * dim + (slice(i * size, i * size + size),)))\n    b = concat2(arr, dim)\n    if backward:\n        loss = b * a\n        b = jt.grad(loss, a)\n    with jt.profile_scope(1, 0) as rep:\n        b.sync()\n    i = rep[0].index('TotalTime')\n    stime = 0\n    for r in rep[1:]:\n        stime += float(r[i])\n    bw = 4 * 64 ** 4 * 2 * 2 / stime\n    print(f'{dim} {size} {stime / 1000000.0}ms, {bw}GB/s')\n    return bw",
            "def check(dim, size, backward=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    n = 64\n    a = jt.random((n, n, n, n))\n    a.sync()\n    m = n // size\n    arr = []\n    for i in range(m):\n        arr.append(a.getitem((slice(None),) * dim + (slice(i * size, i * size + size),)))\n    b = concat2(arr, dim)\n    if backward:\n        loss = b * a\n        b = jt.grad(loss, a)\n    with jt.profile_scope(1, 0) as rep:\n        b.sync()\n    i = rep[0].index('TotalTime')\n    stime = 0\n    for r in rep[1:]:\n        stime += float(r[i])\n    bw = 4 * 64 ** 4 * 2 * 2 / stime\n    print(f'{dim} {size} {stime / 1000000.0}ms, {bw}GB/s')\n    return bw",
            "def check(dim, size, backward=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    n = 64\n    a = jt.random((n, n, n, n))\n    a.sync()\n    m = n // size\n    arr = []\n    for i in range(m):\n        arr.append(a.getitem((slice(None),) * dim + (slice(i * size, i * size + size),)))\n    b = concat2(arr, dim)\n    if backward:\n        loss = b * a\n        b = jt.grad(loss, a)\n    with jt.profile_scope(1, 0) as rep:\n        b.sync()\n    i = rep[0].index('TotalTime')\n    stime = 0\n    for r in rep[1:]:\n        stime += float(r[i])\n    bw = 4 * 64 ** 4 * 2 * 2 / stime\n    print(f'{dim} {size} {stime / 1000000.0}ms, {bw}GB/s')\n    return bw",
            "def check(dim, size, backward=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    n = 64\n    a = jt.random((n, n, n, n))\n    a.sync()\n    m = n // size\n    arr = []\n    for i in range(m):\n        arr.append(a.getitem((slice(None),) * dim + (slice(i * size, i * size + size),)))\n    b = concat2(arr, dim)\n    if backward:\n        loss = b * a\n        b = jt.grad(loss, a)\n    with jt.profile_scope(1, 0) as rep:\n        b.sync()\n    i = rep[0].index('TotalTime')\n    stime = 0\n    for r in rep[1:]:\n        stime += float(r[i])\n    bw = 4 * 64 ** 4 * 2 * 2 / stime\n    print(f'{dim} {size} {stime / 1000000.0}ms, {bw}GB/s')\n    return bw"
        ]
    },
    {
        "func_name": "test_concat2_perf",
        "original": "@unittest.skipIf(not jt.has_cuda, 'No CUDA found')\n@jt.flag_scope(use_cuda=1)\ndef test_concat2_perf(self):\n\n    def check(dim, size, backward=False):\n        n = 64\n        a = jt.random((n, n, n, n))\n        a.sync()\n        m = n // size\n        arr = []\n        for i in range(m):\n            arr.append(a.getitem((slice(None),) * dim + (slice(i * size, i * size + size),)))\n        b = concat2(arr, dim)\n        if backward:\n            loss = b * a\n            b = jt.grad(loss, a)\n        with jt.profile_scope(1, 0) as rep:\n            b.sync()\n        i = rep[0].index('TotalTime')\n        stime = 0\n        for r in rep[1:]:\n            stime += float(r[i])\n        bw = 4 * 64 ** 4 * 2 * 2 / stime\n        print(f'{dim} {size} {stime / 1000000.0}ms, {bw}GB/s')\n        return bw\n    ndim = 4\n    splits = [1, 2, 4, 8, 16, 32, 64]\n    m = len(splits)\n    result = np.zeros((4, m))\n    result_back = np.zeros((4, m))\n    for i in range(ndim):\n        for j in range(m):\n            result[i, j] = check(i, splits[j])\n            result_back[i, j] = check(i, splits[j], True)\n    print(result.T)\n    print(result_back.T)\n    '\\n[[ 15.59142118  15.8001291   15.77589713  11.79319714]\\n [ 31.33130734  31.2476813   31.20394782  23.19700034]\\n [ 57.90763098  57.71203221  58.02228419  45.60297828]\\n [104.20428796 104.08291412 104.18568373  91.648383  ]\\n [175.21896606 175.44422637 176.57915576 168.33344684]\\n [264.35929995 267.63202466 262.92687504 268.41854563]\\n [352.36998687 355.89200025 360.95753527 361.34916742]]\\n[[  3.39802237   3.42782551   3.43126375   2.85884566]\\n [  7.12993628   7.11445323   7.11482319   5.90134142]\\n [ 15.13540229  15.11031669  15.12954432  12.76302703]\\n [ 28.08930928  28.09445985  28.01005224  25.43536254]\\n [ 49.58246623  49.70843778  49.49253912  48.07459389]\\n [ 80.3745414   80.85044884  79.74203591  80.97114412]\\n [117.14450249 119.22320442 119.2380328  119.63622556]]\\n\\n        '",
        "mutated": [
            "@unittest.skipIf(not jt.has_cuda, 'No CUDA found')\n@jt.flag_scope(use_cuda=1)\ndef test_concat2_perf(self):\n    if False:\n        i = 10\n\n    def check(dim, size, backward=False):\n        n = 64\n        a = jt.random((n, n, n, n))\n        a.sync()\n        m = n // size\n        arr = []\n        for i in range(m):\n            arr.append(a.getitem((slice(None),) * dim + (slice(i * size, i * size + size),)))\n        b = concat2(arr, dim)\n        if backward:\n            loss = b * a\n            b = jt.grad(loss, a)\n        with jt.profile_scope(1, 0) as rep:\n            b.sync()\n        i = rep[0].index('TotalTime')\n        stime = 0\n        for r in rep[1:]:\n            stime += float(r[i])\n        bw = 4 * 64 ** 4 * 2 * 2 / stime\n        print(f'{dim} {size} {stime / 1000000.0}ms, {bw}GB/s')\n        return bw\n    ndim = 4\n    splits = [1, 2, 4, 8, 16, 32, 64]\n    m = len(splits)\n    result = np.zeros((4, m))\n    result_back = np.zeros((4, m))\n    for i in range(ndim):\n        for j in range(m):\n            result[i, j] = check(i, splits[j])\n            result_back[i, j] = check(i, splits[j], True)\n    print(result.T)\n    print(result_back.T)\n    '\\n[[ 15.59142118  15.8001291   15.77589713  11.79319714]\\n [ 31.33130734  31.2476813   31.20394782  23.19700034]\\n [ 57.90763098  57.71203221  58.02228419  45.60297828]\\n [104.20428796 104.08291412 104.18568373  91.648383  ]\\n [175.21896606 175.44422637 176.57915576 168.33344684]\\n [264.35929995 267.63202466 262.92687504 268.41854563]\\n [352.36998687 355.89200025 360.95753527 361.34916742]]\\n[[  3.39802237   3.42782551   3.43126375   2.85884566]\\n [  7.12993628   7.11445323   7.11482319   5.90134142]\\n [ 15.13540229  15.11031669  15.12954432  12.76302703]\\n [ 28.08930928  28.09445985  28.01005224  25.43536254]\\n [ 49.58246623  49.70843778  49.49253912  48.07459389]\\n [ 80.3745414   80.85044884  79.74203591  80.97114412]\\n [117.14450249 119.22320442 119.2380328  119.63622556]]\\n\\n        '",
            "@unittest.skipIf(not jt.has_cuda, 'No CUDA found')\n@jt.flag_scope(use_cuda=1)\ndef test_concat2_perf(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def check(dim, size, backward=False):\n        n = 64\n        a = jt.random((n, n, n, n))\n        a.sync()\n        m = n // size\n        arr = []\n        for i in range(m):\n            arr.append(a.getitem((slice(None),) * dim + (slice(i * size, i * size + size),)))\n        b = concat2(arr, dim)\n        if backward:\n            loss = b * a\n            b = jt.grad(loss, a)\n        with jt.profile_scope(1, 0) as rep:\n            b.sync()\n        i = rep[0].index('TotalTime')\n        stime = 0\n        for r in rep[1:]:\n            stime += float(r[i])\n        bw = 4 * 64 ** 4 * 2 * 2 / stime\n        print(f'{dim} {size} {stime / 1000000.0}ms, {bw}GB/s')\n        return bw\n    ndim = 4\n    splits = [1, 2, 4, 8, 16, 32, 64]\n    m = len(splits)\n    result = np.zeros((4, m))\n    result_back = np.zeros((4, m))\n    for i in range(ndim):\n        for j in range(m):\n            result[i, j] = check(i, splits[j])\n            result_back[i, j] = check(i, splits[j], True)\n    print(result.T)\n    print(result_back.T)\n    '\\n[[ 15.59142118  15.8001291   15.77589713  11.79319714]\\n [ 31.33130734  31.2476813   31.20394782  23.19700034]\\n [ 57.90763098  57.71203221  58.02228419  45.60297828]\\n [104.20428796 104.08291412 104.18568373  91.648383  ]\\n [175.21896606 175.44422637 176.57915576 168.33344684]\\n [264.35929995 267.63202466 262.92687504 268.41854563]\\n [352.36998687 355.89200025 360.95753527 361.34916742]]\\n[[  3.39802237   3.42782551   3.43126375   2.85884566]\\n [  7.12993628   7.11445323   7.11482319   5.90134142]\\n [ 15.13540229  15.11031669  15.12954432  12.76302703]\\n [ 28.08930928  28.09445985  28.01005224  25.43536254]\\n [ 49.58246623  49.70843778  49.49253912  48.07459389]\\n [ 80.3745414   80.85044884  79.74203591  80.97114412]\\n [117.14450249 119.22320442 119.2380328  119.63622556]]\\n\\n        '",
            "@unittest.skipIf(not jt.has_cuda, 'No CUDA found')\n@jt.flag_scope(use_cuda=1)\ndef test_concat2_perf(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def check(dim, size, backward=False):\n        n = 64\n        a = jt.random((n, n, n, n))\n        a.sync()\n        m = n // size\n        arr = []\n        for i in range(m):\n            arr.append(a.getitem((slice(None),) * dim + (slice(i * size, i * size + size),)))\n        b = concat2(arr, dim)\n        if backward:\n            loss = b * a\n            b = jt.grad(loss, a)\n        with jt.profile_scope(1, 0) as rep:\n            b.sync()\n        i = rep[0].index('TotalTime')\n        stime = 0\n        for r in rep[1:]:\n            stime += float(r[i])\n        bw = 4 * 64 ** 4 * 2 * 2 / stime\n        print(f'{dim} {size} {stime / 1000000.0}ms, {bw}GB/s')\n        return bw\n    ndim = 4\n    splits = [1, 2, 4, 8, 16, 32, 64]\n    m = len(splits)\n    result = np.zeros((4, m))\n    result_back = np.zeros((4, m))\n    for i in range(ndim):\n        for j in range(m):\n            result[i, j] = check(i, splits[j])\n            result_back[i, j] = check(i, splits[j], True)\n    print(result.T)\n    print(result_back.T)\n    '\\n[[ 15.59142118  15.8001291   15.77589713  11.79319714]\\n [ 31.33130734  31.2476813   31.20394782  23.19700034]\\n [ 57.90763098  57.71203221  58.02228419  45.60297828]\\n [104.20428796 104.08291412 104.18568373  91.648383  ]\\n [175.21896606 175.44422637 176.57915576 168.33344684]\\n [264.35929995 267.63202466 262.92687504 268.41854563]\\n [352.36998687 355.89200025 360.95753527 361.34916742]]\\n[[  3.39802237   3.42782551   3.43126375   2.85884566]\\n [  7.12993628   7.11445323   7.11482319   5.90134142]\\n [ 15.13540229  15.11031669  15.12954432  12.76302703]\\n [ 28.08930928  28.09445985  28.01005224  25.43536254]\\n [ 49.58246623  49.70843778  49.49253912  48.07459389]\\n [ 80.3745414   80.85044884  79.74203591  80.97114412]\\n [117.14450249 119.22320442 119.2380328  119.63622556]]\\n\\n        '",
            "@unittest.skipIf(not jt.has_cuda, 'No CUDA found')\n@jt.flag_scope(use_cuda=1)\ndef test_concat2_perf(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def check(dim, size, backward=False):\n        n = 64\n        a = jt.random((n, n, n, n))\n        a.sync()\n        m = n // size\n        arr = []\n        for i in range(m):\n            arr.append(a.getitem((slice(None),) * dim + (slice(i * size, i * size + size),)))\n        b = concat2(arr, dim)\n        if backward:\n            loss = b * a\n            b = jt.grad(loss, a)\n        with jt.profile_scope(1, 0) as rep:\n            b.sync()\n        i = rep[0].index('TotalTime')\n        stime = 0\n        for r in rep[1:]:\n            stime += float(r[i])\n        bw = 4 * 64 ** 4 * 2 * 2 / stime\n        print(f'{dim} {size} {stime / 1000000.0}ms, {bw}GB/s')\n        return bw\n    ndim = 4\n    splits = [1, 2, 4, 8, 16, 32, 64]\n    m = len(splits)\n    result = np.zeros((4, m))\n    result_back = np.zeros((4, m))\n    for i in range(ndim):\n        for j in range(m):\n            result[i, j] = check(i, splits[j])\n            result_back[i, j] = check(i, splits[j], True)\n    print(result.T)\n    print(result_back.T)\n    '\\n[[ 15.59142118  15.8001291   15.77589713  11.79319714]\\n [ 31.33130734  31.2476813   31.20394782  23.19700034]\\n [ 57.90763098  57.71203221  58.02228419  45.60297828]\\n [104.20428796 104.08291412 104.18568373  91.648383  ]\\n [175.21896606 175.44422637 176.57915576 168.33344684]\\n [264.35929995 267.63202466 262.92687504 268.41854563]\\n [352.36998687 355.89200025 360.95753527 361.34916742]]\\n[[  3.39802237   3.42782551   3.43126375   2.85884566]\\n [  7.12993628   7.11445323   7.11482319   5.90134142]\\n [ 15.13540229  15.11031669  15.12954432  12.76302703]\\n [ 28.08930928  28.09445985  28.01005224  25.43536254]\\n [ 49.58246623  49.70843778  49.49253912  48.07459389]\\n [ 80.3745414   80.85044884  79.74203591  80.97114412]\\n [117.14450249 119.22320442 119.2380328  119.63622556]]\\n\\n        '",
            "@unittest.skipIf(not jt.has_cuda, 'No CUDA found')\n@jt.flag_scope(use_cuda=1)\ndef test_concat2_perf(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def check(dim, size, backward=False):\n        n = 64\n        a = jt.random((n, n, n, n))\n        a.sync()\n        m = n // size\n        arr = []\n        for i in range(m):\n            arr.append(a.getitem((slice(None),) * dim + (slice(i * size, i * size + size),)))\n        b = concat2(arr, dim)\n        if backward:\n            loss = b * a\n            b = jt.grad(loss, a)\n        with jt.profile_scope(1, 0) as rep:\n            b.sync()\n        i = rep[0].index('TotalTime')\n        stime = 0\n        for r in rep[1:]:\n            stime += float(r[i])\n        bw = 4 * 64 ** 4 * 2 * 2 / stime\n        print(f'{dim} {size} {stime / 1000000.0}ms, {bw}GB/s')\n        return bw\n    ndim = 4\n    splits = [1, 2, 4, 8, 16, 32, 64]\n    m = len(splits)\n    result = np.zeros((4, m))\n    result_back = np.zeros((4, m))\n    for i in range(ndim):\n        for j in range(m):\n            result[i, j] = check(i, splits[j])\n            result_back[i, j] = check(i, splits[j], True)\n    print(result.T)\n    print(result_back.T)\n    '\\n[[ 15.59142118  15.8001291   15.77589713  11.79319714]\\n [ 31.33130734  31.2476813   31.20394782  23.19700034]\\n [ 57.90763098  57.71203221  58.02228419  45.60297828]\\n [104.20428796 104.08291412 104.18568373  91.648383  ]\\n [175.21896606 175.44422637 176.57915576 168.33344684]\\n [264.35929995 267.63202466 262.92687504 268.41854563]\\n [352.36998687 355.89200025 360.95753527 361.34916742]]\\n[[  3.39802237   3.42782551   3.43126375   2.85884566]\\n [  7.12993628   7.11445323   7.11482319   5.90134142]\\n [ 15.13540229  15.11031669  15.12954432  12.76302703]\\n [ 28.08930928  28.09445985  28.01005224  25.43536254]\\n [ 49.58246623  49.70843778  49.49253912  48.07459389]\\n [ 80.3745414   80.85044884  79.74203591  80.97114412]\\n [117.14450249 119.22320442 119.2380328  119.63622556]]\\n\\n        '"
        ]
    }
]