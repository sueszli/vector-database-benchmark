[
    {
        "func_name": "_forward_learn",
        "original": "def _forward_learn(self, data: dict) -> Dict[str, Any]:\n    \"\"\"\n        Overview:\n            Forward computation of learn mode(updating policy). It supports both single and multi-discrete action                 space. It depends on whether the ``q_value`` is a list.\n        Arguments:\n            - data (:obj:`Dict[str, Any]`): Dict type data, a batch of data for training, values are torch.Tensor or                 np.ndarray or dict/list combinations.\n        Returns:\n            - info_dict (:obj:`Dict[str, Any]`): Dict type data, a info dict indicated training result, which will be                 recorded in text log and tensorboard, values are python scalar or a list of scalars.\n        ArgumentsKeys:\n            - necessary: ``obs``, ``action``, ``reward``, ``next_obs``, ``done``\n            - optional: ``value_gamma``, ``IS``\n        ReturnsKeys:\n            - necessary: ``cur_lr``, ``total_loss``, ``priority``\n            - optional: ``action_distribution``\n        \"\"\"\n    data = default_preprocess_learn(data, use_priority=self._priority, use_priority_IS_weight=self._cfg.priority_IS_weight, ignore_done=self._cfg.learn.ignore_done, use_nstep=True)\n    if self._cuda:\n        data = to_device(data, self._device)\n    self._learn_model.train()\n    self._target_model.train()\n    q_value = self._learn_model.forward(data['obs'])['logit']\n    with torch.no_grad():\n        target_q_value = self._target_model.forward(data['next_obs'])['logit']\n        target_q_action = self._learn_model.forward(data['next_obs'])['action']\n    value_gamma = data.get('value_gamma')\n    if isinstance(q_value, list):\n        act_num = len(q_value)\n        (loss, td_error_per_sample) = ([], [])\n        q_value_list = []\n        for i in range(act_num):\n            td_data = q_nstep_td_data(q_value[i], target_q_value[i], data['action'][i], target_q_action[i], data['reward'], data['done'], data['weight'])\n            (loss_, td_error_per_sample_) = q_nstep_td_error(td_data, self._gamma, nstep=self._nstep, value_gamma=value_gamma)\n            loss.append(loss_)\n            td_error_per_sample.append(td_error_per_sample_.abs())\n            q_value_list.append(q_value[i].mean().item())\n        loss = sum(loss) / (len(loss) + 1e-08)\n        td_error_per_sample = sum(td_error_per_sample) / (len(td_error_per_sample) + 1e-08)\n        q_value_mean = sum(q_value_list) / act_num\n    else:\n        data_n = q_nstep_td_data(q_value, target_q_value, data['action'], target_q_action, data['reward'], data['done'], data['weight'])\n        (loss, td_error_per_sample) = q_nstep_td_error(data_n, self._gamma, nstep=self._nstep, value_gamma=value_gamma)\n        q_value_mean = q_value.mean().item()\n    self._optimizer.zero_grad()\n    loss.backward()\n    if self._cfg.multi_gpu:\n        self.sync_gradients(self._learn_model)\n    self._optimizer.step()\n    self._target_model.update(self._learn_model.state_dict())\n    return {'cur_lr': self._optimizer.defaults['lr'], 'total_loss': loss.item(), 'q_value_mean': q_value_mean, 'priority': td_error_per_sample.abs().tolist()}",
        "mutated": [
            "def _forward_learn(self, data: dict) -> Dict[str, Any]:\n    if False:\n        i = 10\n    '\\n        Overview:\\n            Forward computation of learn mode(updating policy). It supports both single and multi-discrete action                 space. It depends on whether the ``q_value`` is a list.\\n        Arguments:\\n            - data (:obj:`Dict[str, Any]`): Dict type data, a batch of data for training, values are torch.Tensor or                 np.ndarray or dict/list combinations.\\n        Returns:\\n            - info_dict (:obj:`Dict[str, Any]`): Dict type data, a info dict indicated training result, which will be                 recorded in text log and tensorboard, values are python scalar or a list of scalars.\\n        ArgumentsKeys:\\n            - necessary: ``obs``, ``action``, ``reward``, ``next_obs``, ``done``\\n            - optional: ``value_gamma``, ``IS``\\n        ReturnsKeys:\\n            - necessary: ``cur_lr``, ``total_loss``, ``priority``\\n            - optional: ``action_distribution``\\n        '\n    data = default_preprocess_learn(data, use_priority=self._priority, use_priority_IS_weight=self._cfg.priority_IS_weight, ignore_done=self._cfg.learn.ignore_done, use_nstep=True)\n    if self._cuda:\n        data = to_device(data, self._device)\n    self._learn_model.train()\n    self._target_model.train()\n    q_value = self._learn_model.forward(data['obs'])['logit']\n    with torch.no_grad():\n        target_q_value = self._target_model.forward(data['next_obs'])['logit']\n        target_q_action = self._learn_model.forward(data['next_obs'])['action']\n    value_gamma = data.get('value_gamma')\n    if isinstance(q_value, list):\n        act_num = len(q_value)\n        (loss, td_error_per_sample) = ([], [])\n        q_value_list = []\n        for i in range(act_num):\n            td_data = q_nstep_td_data(q_value[i], target_q_value[i], data['action'][i], target_q_action[i], data['reward'], data['done'], data['weight'])\n            (loss_, td_error_per_sample_) = q_nstep_td_error(td_data, self._gamma, nstep=self._nstep, value_gamma=value_gamma)\n            loss.append(loss_)\n            td_error_per_sample.append(td_error_per_sample_.abs())\n            q_value_list.append(q_value[i].mean().item())\n        loss = sum(loss) / (len(loss) + 1e-08)\n        td_error_per_sample = sum(td_error_per_sample) / (len(td_error_per_sample) + 1e-08)\n        q_value_mean = sum(q_value_list) / act_num\n    else:\n        data_n = q_nstep_td_data(q_value, target_q_value, data['action'], target_q_action, data['reward'], data['done'], data['weight'])\n        (loss, td_error_per_sample) = q_nstep_td_error(data_n, self._gamma, nstep=self._nstep, value_gamma=value_gamma)\n        q_value_mean = q_value.mean().item()\n    self._optimizer.zero_grad()\n    loss.backward()\n    if self._cfg.multi_gpu:\n        self.sync_gradients(self._learn_model)\n    self._optimizer.step()\n    self._target_model.update(self._learn_model.state_dict())\n    return {'cur_lr': self._optimizer.defaults['lr'], 'total_loss': loss.item(), 'q_value_mean': q_value_mean, 'priority': td_error_per_sample.abs().tolist()}",
            "def _forward_learn(self, data: dict) -> Dict[str, Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Overview:\\n            Forward computation of learn mode(updating policy). It supports both single and multi-discrete action                 space. It depends on whether the ``q_value`` is a list.\\n        Arguments:\\n            - data (:obj:`Dict[str, Any]`): Dict type data, a batch of data for training, values are torch.Tensor or                 np.ndarray or dict/list combinations.\\n        Returns:\\n            - info_dict (:obj:`Dict[str, Any]`): Dict type data, a info dict indicated training result, which will be                 recorded in text log and tensorboard, values are python scalar or a list of scalars.\\n        ArgumentsKeys:\\n            - necessary: ``obs``, ``action``, ``reward``, ``next_obs``, ``done``\\n            - optional: ``value_gamma``, ``IS``\\n        ReturnsKeys:\\n            - necessary: ``cur_lr``, ``total_loss``, ``priority``\\n            - optional: ``action_distribution``\\n        '\n    data = default_preprocess_learn(data, use_priority=self._priority, use_priority_IS_weight=self._cfg.priority_IS_weight, ignore_done=self._cfg.learn.ignore_done, use_nstep=True)\n    if self._cuda:\n        data = to_device(data, self._device)\n    self._learn_model.train()\n    self._target_model.train()\n    q_value = self._learn_model.forward(data['obs'])['logit']\n    with torch.no_grad():\n        target_q_value = self._target_model.forward(data['next_obs'])['logit']\n        target_q_action = self._learn_model.forward(data['next_obs'])['action']\n    value_gamma = data.get('value_gamma')\n    if isinstance(q_value, list):\n        act_num = len(q_value)\n        (loss, td_error_per_sample) = ([], [])\n        q_value_list = []\n        for i in range(act_num):\n            td_data = q_nstep_td_data(q_value[i], target_q_value[i], data['action'][i], target_q_action[i], data['reward'], data['done'], data['weight'])\n            (loss_, td_error_per_sample_) = q_nstep_td_error(td_data, self._gamma, nstep=self._nstep, value_gamma=value_gamma)\n            loss.append(loss_)\n            td_error_per_sample.append(td_error_per_sample_.abs())\n            q_value_list.append(q_value[i].mean().item())\n        loss = sum(loss) / (len(loss) + 1e-08)\n        td_error_per_sample = sum(td_error_per_sample) / (len(td_error_per_sample) + 1e-08)\n        q_value_mean = sum(q_value_list) / act_num\n    else:\n        data_n = q_nstep_td_data(q_value, target_q_value, data['action'], target_q_action, data['reward'], data['done'], data['weight'])\n        (loss, td_error_per_sample) = q_nstep_td_error(data_n, self._gamma, nstep=self._nstep, value_gamma=value_gamma)\n        q_value_mean = q_value.mean().item()\n    self._optimizer.zero_grad()\n    loss.backward()\n    if self._cfg.multi_gpu:\n        self.sync_gradients(self._learn_model)\n    self._optimizer.step()\n    self._target_model.update(self._learn_model.state_dict())\n    return {'cur_lr': self._optimizer.defaults['lr'], 'total_loss': loss.item(), 'q_value_mean': q_value_mean, 'priority': td_error_per_sample.abs().tolist()}",
            "def _forward_learn(self, data: dict) -> Dict[str, Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Overview:\\n            Forward computation of learn mode(updating policy). It supports both single and multi-discrete action                 space. It depends on whether the ``q_value`` is a list.\\n        Arguments:\\n            - data (:obj:`Dict[str, Any]`): Dict type data, a batch of data for training, values are torch.Tensor or                 np.ndarray or dict/list combinations.\\n        Returns:\\n            - info_dict (:obj:`Dict[str, Any]`): Dict type data, a info dict indicated training result, which will be                 recorded in text log and tensorboard, values are python scalar or a list of scalars.\\n        ArgumentsKeys:\\n            - necessary: ``obs``, ``action``, ``reward``, ``next_obs``, ``done``\\n            - optional: ``value_gamma``, ``IS``\\n        ReturnsKeys:\\n            - necessary: ``cur_lr``, ``total_loss``, ``priority``\\n            - optional: ``action_distribution``\\n        '\n    data = default_preprocess_learn(data, use_priority=self._priority, use_priority_IS_weight=self._cfg.priority_IS_weight, ignore_done=self._cfg.learn.ignore_done, use_nstep=True)\n    if self._cuda:\n        data = to_device(data, self._device)\n    self._learn_model.train()\n    self._target_model.train()\n    q_value = self._learn_model.forward(data['obs'])['logit']\n    with torch.no_grad():\n        target_q_value = self._target_model.forward(data['next_obs'])['logit']\n        target_q_action = self._learn_model.forward(data['next_obs'])['action']\n    value_gamma = data.get('value_gamma')\n    if isinstance(q_value, list):\n        act_num = len(q_value)\n        (loss, td_error_per_sample) = ([], [])\n        q_value_list = []\n        for i in range(act_num):\n            td_data = q_nstep_td_data(q_value[i], target_q_value[i], data['action'][i], target_q_action[i], data['reward'], data['done'], data['weight'])\n            (loss_, td_error_per_sample_) = q_nstep_td_error(td_data, self._gamma, nstep=self._nstep, value_gamma=value_gamma)\n            loss.append(loss_)\n            td_error_per_sample.append(td_error_per_sample_.abs())\n            q_value_list.append(q_value[i].mean().item())\n        loss = sum(loss) / (len(loss) + 1e-08)\n        td_error_per_sample = sum(td_error_per_sample) / (len(td_error_per_sample) + 1e-08)\n        q_value_mean = sum(q_value_list) / act_num\n    else:\n        data_n = q_nstep_td_data(q_value, target_q_value, data['action'], target_q_action, data['reward'], data['done'], data['weight'])\n        (loss, td_error_per_sample) = q_nstep_td_error(data_n, self._gamma, nstep=self._nstep, value_gamma=value_gamma)\n        q_value_mean = q_value.mean().item()\n    self._optimizer.zero_grad()\n    loss.backward()\n    if self._cfg.multi_gpu:\n        self.sync_gradients(self._learn_model)\n    self._optimizer.step()\n    self._target_model.update(self._learn_model.state_dict())\n    return {'cur_lr': self._optimizer.defaults['lr'], 'total_loss': loss.item(), 'q_value_mean': q_value_mean, 'priority': td_error_per_sample.abs().tolist()}",
            "def _forward_learn(self, data: dict) -> Dict[str, Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Overview:\\n            Forward computation of learn mode(updating policy). It supports both single and multi-discrete action                 space. It depends on whether the ``q_value`` is a list.\\n        Arguments:\\n            - data (:obj:`Dict[str, Any]`): Dict type data, a batch of data for training, values are torch.Tensor or                 np.ndarray or dict/list combinations.\\n        Returns:\\n            - info_dict (:obj:`Dict[str, Any]`): Dict type data, a info dict indicated training result, which will be                 recorded in text log and tensorboard, values are python scalar or a list of scalars.\\n        ArgumentsKeys:\\n            - necessary: ``obs``, ``action``, ``reward``, ``next_obs``, ``done``\\n            - optional: ``value_gamma``, ``IS``\\n        ReturnsKeys:\\n            - necessary: ``cur_lr``, ``total_loss``, ``priority``\\n            - optional: ``action_distribution``\\n        '\n    data = default_preprocess_learn(data, use_priority=self._priority, use_priority_IS_weight=self._cfg.priority_IS_weight, ignore_done=self._cfg.learn.ignore_done, use_nstep=True)\n    if self._cuda:\n        data = to_device(data, self._device)\n    self._learn_model.train()\n    self._target_model.train()\n    q_value = self._learn_model.forward(data['obs'])['logit']\n    with torch.no_grad():\n        target_q_value = self._target_model.forward(data['next_obs'])['logit']\n        target_q_action = self._learn_model.forward(data['next_obs'])['action']\n    value_gamma = data.get('value_gamma')\n    if isinstance(q_value, list):\n        act_num = len(q_value)\n        (loss, td_error_per_sample) = ([], [])\n        q_value_list = []\n        for i in range(act_num):\n            td_data = q_nstep_td_data(q_value[i], target_q_value[i], data['action'][i], target_q_action[i], data['reward'], data['done'], data['weight'])\n            (loss_, td_error_per_sample_) = q_nstep_td_error(td_data, self._gamma, nstep=self._nstep, value_gamma=value_gamma)\n            loss.append(loss_)\n            td_error_per_sample.append(td_error_per_sample_.abs())\n            q_value_list.append(q_value[i].mean().item())\n        loss = sum(loss) / (len(loss) + 1e-08)\n        td_error_per_sample = sum(td_error_per_sample) / (len(td_error_per_sample) + 1e-08)\n        q_value_mean = sum(q_value_list) / act_num\n    else:\n        data_n = q_nstep_td_data(q_value, target_q_value, data['action'], target_q_action, data['reward'], data['done'], data['weight'])\n        (loss, td_error_per_sample) = q_nstep_td_error(data_n, self._gamma, nstep=self._nstep, value_gamma=value_gamma)\n        q_value_mean = q_value.mean().item()\n    self._optimizer.zero_grad()\n    loss.backward()\n    if self._cfg.multi_gpu:\n        self.sync_gradients(self._learn_model)\n    self._optimizer.step()\n    self._target_model.update(self._learn_model.state_dict())\n    return {'cur_lr': self._optimizer.defaults['lr'], 'total_loss': loss.item(), 'q_value_mean': q_value_mean, 'priority': td_error_per_sample.abs().tolist()}",
            "def _forward_learn(self, data: dict) -> Dict[str, Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Overview:\\n            Forward computation of learn mode(updating policy). It supports both single and multi-discrete action                 space. It depends on whether the ``q_value`` is a list.\\n        Arguments:\\n            - data (:obj:`Dict[str, Any]`): Dict type data, a batch of data for training, values are torch.Tensor or                 np.ndarray or dict/list combinations.\\n        Returns:\\n            - info_dict (:obj:`Dict[str, Any]`): Dict type data, a info dict indicated training result, which will be                 recorded in text log and tensorboard, values are python scalar or a list of scalars.\\n        ArgumentsKeys:\\n            - necessary: ``obs``, ``action``, ``reward``, ``next_obs``, ``done``\\n            - optional: ``value_gamma``, ``IS``\\n        ReturnsKeys:\\n            - necessary: ``cur_lr``, ``total_loss``, ``priority``\\n            - optional: ``action_distribution``\\n        '\n    data = default_preprocess_learn(data, use_priority=self._priority, use_priority_IS_weight=self._cfg.priority_IS_weight, ignore_done=self._cfg.learn.ignore_done, use_nstep=True)\n    if self._cuda:\n        data = to_device(data, self._device)\n    self._learn_model.train()\n    self._target_model.train()\n    q_value = self._learn_model.forward(data['obs'])['logit']\n    with torch.no_grad():\n        target_q_value = self._target_model.forward(data['next_obs'])['logit']\n        target_q_action = self._learn_model.forward(data['next_obs'])['action']\n    value_gamma = data.get('value_gamma')\n    if isinstance(q_value, list):\n        act_num = len(q_value)\n        (loss, td_error_per_sample) = ([], [])\n        q_value_list = []\n        for i in range(act_num):\n            td_data = q_nstep_td_data(q_value[i], target_q_value[i], data['action'][i], target_q_action[i], data['reward'], data['done'], data['weight'])\n            (loss_, td_error_per_sample_) = q_nstep_td_error(td_data, self._gamma, nstep=self._nstep, value_gamma=value_gamma)\n            loss.append(loss_)\n            td_error_per_sample.append(td_error_per_sample_.abs())\n            q_value_list.append(q_value[i].mean().item())\n        loss = sum(loss) / (len(loss) + 1e-08)\n        td_error_per_sample = sum(td_error_per_sample) / (len(td_error_per_sample) + 1e-08)\n        q_value_mean = sum(q_value_list) / act_num\n    else:\n        data_n = q_nstep_td_data(q_value, target_q_value, data['action'], target_q_action, data['reward'], data['done'], data['weight'])\n        (loss, td_error_per_sample) = q_nstep_td_error(data_n, self._gamma, nstep=self._nstep, value_gamma=value_gamma)\n        q_value_mean = q_value.mean().item()\n    self._optimizer.zero_grad()\n    loss.backward()\n    if self._cfg.multi_gpu:\n        self.sync_gradients(self._learn_model)\n    self._optimizer.step()\n    self._target_model.update(self._learn_model.state_dict())\n    return {'cur_lr': self._optimizer.defaults['lr'], 'total_loss': loss.item(), 'q_value_mean': q_value_mean, 'priority': td_error_per_sample.abs().tolist()}"
        ]
    }
]