[
    {
        "func_name": "configboard_files",
        "original": "def configboard_files():\n    \"\"\"A pathlib glob search for all ports/*/boards/*/mpconfigboard.mk file\n    paths.\n\n    :returns: A ``pathlib.Path.glob()`` generator object\n    \"\"\"\n    working_dir = pathlib.Path(__file__).resolve().parent.parent\n    return working_dir.glob('ports/**/boards/**/mpconfigboard.mk')",
        "mutated": [
            "def configboard_files():\n    if False:\n        i = 10\n    'A pathlib glob search for all ports/*/boards/*/mpconfigboard.mk file\\n    paths.\\n\\n    :returns: A ``pathlib.Path.glob()`` generator object\\n    '\n    working_dir = pathlib.Path(__file__).resolve().parent.parent\n    return working_dir.glob('ports/**/boards/**/mpconfigboard.mk')",
            "def configboard_files():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'A pathlib glob search for all ports/*/boards/*/mpconfigboard.mk file\\n    paths.\\n\\n    :returns: A ``pathlib.Path.glob()`` generator object\\n    '\n    working_dir = pathlib.Path(__file__).resolve().parent.parent\n    return working_dir.glob('ports/**/boards/**/mpconfigboard.mk')",
            "def configboard_files():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'A pathlib glob search for all ports/*/boards/*/mpconfigboard.mk file\\n    paths.\\n\\n    :returns: A ``pathlib.Path.glob()`` generator object\\n    '\n    working_dir = pathlib.Path(__file__).resolve().parent.parent\n    return working_dir.glob('ports/**/boards/**/mpconfigboard.mk')",
            "def configboard_files():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'A pathlib glob search for all ports/*/boards/*/mpconfigboard.mk file\\n    paths.\\n\\n    :returns: A ``pathlib.Path.glob()`` generator object\\n    '\n    working_dir = pathlib.Path(__file__).resolve().parent.parent\n    return working_dir.glob('ports/**/boards/**/mpconfigboard.mk')",
            "def configboard_files():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'A pathlib glob search for all ports/*/boards/*/mpconfigboard.mk file\\n    paths.\\n\\n    :returns: A ``pathlib.Path.glob()`` generator object\\n    '\n    working_dir = pathlib.Path(__file__).resolve().parent.parent\n    return working_dir.glob('ports/**/boards/**/mpconfigboard.mk')"
        ]
    },
    {
        "func_name": "check_vid_pid",
        "original": "def check_vid_pid(files, clusterlist):\n    \"\"\"Compiles a list of USB VID & PID values for all boards, and checks\n    for duplicates. Exits with ``sys.exit()`` (non-zero exit code)\n    if duplicates are found, and lists the duplicates.\n    \"\"\"\n    usb_pattern = re.compile('^CIRCUITPY_USB\\\\s*=\\\\s*0$|^IDF_TARGET = (esp32|esp32c3|esp32c6|esp32h2)$', flags=re.M)\n    usb_ids = defaultdict(set)\n    for board_config in files:\n        src_text = board_config.read_text()\n        usb_vid = VID_PATTERN.search(src_text)\n        usb_pid = PID_PATTERN.search(src_text)\n        creator = CREATOR_PATTERN.search(src_text)\n        creation = CREATION_PATTERN.search(src_text)\n        non_usb = usb_pattern.search(src_text)\n        board_name = board_config.parts[-2]\n        if usb_vid and usb_pid:\n            id_group = f'0x{int(usb_vid.group(1), 16):04X}:0x{int(usb_pid.group(1), 16):04X}'\n        elif non_usb:\n            if creator is None or creation is None:\n                print(f'board_name={board_name!r} creator={creator!r} creation={creation!r}', file=sys.stderr)\n                continue\n            id_group = f'0x{int(creator.group(1), 16):08X}:0x{int(creation.group(1), 16):08X}'\n        else:\n            raise SystemExit(f'Could not find expected settings in {board_config}')\n        usb_ids[id_group].add(board_name)\n    duplicates = []\n    for (key, boards) in usb_ids.items():\n        if len(boards) == 1:\n            continue\n        cluster = set(clusterlist.get(key, []))\n        if cluster != boards:\n            if key == '':\n                duplicates.append(f\"- Non-USB:\\n  Boards: {', '.join(sorted(boards))}\")\n            else:\n                duplicates.append(f\"- VID/PID: {key}\\n  Boards: {', '.join(sorted(boards))}\")\n    if duplicates:\n        duplicates = '\\n'.join(duplicates)\n        duplicate_message = f'Duplicate VID/PID usage found!\\n{duplicates}\\nIf you are open source maker, then you can request a PID from http://pid.codes\\nFor boards without native USB, you can request a Creator ID from https://github.com/creationid/creators/\\nOtherwise, companies should pay the USB-IF for a vendor ID: https://www.usb.org/getting-vendor-id\\nFAQ: Why does CircuitPython require a unique VID:PID for every board definition? https://learn.adafruit.com/how-to-add-a-new-board-to-circuitpython/frequently-asked-questions#faq-3130480'\n        sys.exit(duplicate_message)\n    else:\n        print('No unexpected ID duplicates found.')",
        "mutated": [
            "def check_vid_pid(files, clusterlist):\n    if False:\n        i = 10\n    'Compiles a list of USB VID & PID values for all boards, and checks\\n    for duplicates. Exits with ``sys.exit()`` (non-zero exit code)\\n    if duplicates are found, and lists the duplicates.\\n    '\n    usb_pattern = re.compile('^CIRCUITPY_USB\\\\s*=\\\\s*0$|^IDF_TARGET = (esp32|esp32c3|esp32c6|esp32h2)$', flags=re.M)\n    usb_ids = defaultdict(set)\n    for board_config in files:\n        src_text = board_config.read_text()\n        usb_vid = VID_PATTERN.search(src_text)\n        usb_pid = PID_PATTERN.search(src_text)\n        creator = CREATOR_PATTERN.search(src_text)\n        creation = CREATION_PATTERN.search(src_text)\n        non_usb = usb_pattern.search(src_text)\n        board_name = board_config.parts[-2]\n        if usb_vid and usb_pid:\n            id_group = f'0x{int(usb_vid.group(1), 16):04X}:0x{int(usb_pid.group(1), 16):04X}'\n        elif non_usb:\n            if creator is None or creation is None:\n                print(f'board_name={board_name!r} creator={creator!r} creation={creation!r}', file=sys.stderr)\n                continue\n            id_group = f'0x{int(creator.group(1), 16):08X}:0x{int(creation.group(1), 16):08X}'\n        else:\n            raise SystemExit(f'Could not find expected settings in {board_config}')\n        usb_ids[id_group].add(board_name)\n    duplicates = []\n    for (key, boards) in usb_ids.items():\n        if len(boards) == 1:\n            continue\n        cluster = set(clusterlist.get(key, []))\n        if cluster != boards:\n            if key == '':\n                duplicates.append(f\"- Non-USB:\\n  Boards: {', '.join(sorted(boards))}\")\n            else:\n                duplicates.append(f\"- VID/PID: {key}\\n  Boards: {', '.join(sorted(boards))}\")\n    if duplicates:\n        duplicates = '\\n'.join(duplicates)\n        duplicate_message = f'Duplicate VID/PID usage found!\\n{duplicates}\\nIf you are open source maker, then you can request a PID from http://pid.codes\\nFor boards without native USB, you can request a Creator ID from https://github.com/creationid/creators/\\nOtherwise, companies should pay the USB-IF for a vendor ID: https://www.usb.org/getting-vendor-id\\nFAQ: Why does CircuitPython require a unique VID:PID for every board definition? https://learn.adafruit.com/how-to-add-a-new-board-to-circuitpython/frequently-asked-questions#faq-3130480'\n        sys.exit(duplicate_message)\n    else:\n        print('No unexpected ID duplicates found.')",
            "def check_vid_pid(files, clusterlist):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compiles a list of USB VID & PID values for all boards, and checks\\n    for duplicates. Exits with ``sys.exit()`` (non-zero exit code)\\n    if duplicates are found, and lists the duplicates.\\n    '\n    usb_pattern = re.compile('^CIRCUITPY_USB\\\\s*=\\\\s*0$|^IDF_TARGET = (esp32|esp32c3|esp32c6|esp32h2)$', flags=re.M)\n    usb_ids = defaultdict(set)\n    for board_config in files:\n        src_text = board_config.read_text()\n        usb_vid = VID_PATTERN.search(src_text)\n        usb_pid = PID_PATTERN.search(src_text)\n        creator = CREATOR_PATTERN.search(src_text)\n        creation = CREATION_PATTERN.search(src_text)\n        non_usb = usb_pattern.search(src_text)\n        board_name = board_config.parts[-2]\n        if usb_vid and usb_pid:\n            id_group = f'0x{int(usb_vid.group(1), 16):04X}:0x{int(usb_pid.group(1), 16):04X}'\n        elif non_usb:\n            if creator is None or creation is None:\n                print(f'board_name={board_name!r} creator={creator!r} creation={creation!r}', file=sys.stderr)\n                continue\n            id_group = f'0x{int(creator.group(1), 16):08X}:0x{int(creation.group(1), 16):08X}'\n        else:\n            raise SystemExit(f'Could not find expected settings in {board_config}')\n        usb_ids[id_group].add(board_name)\n    duplicates = []\n    for (key, boards) in usb_ids.items():\n        if len(boards) == 1:\n            continue\n        cluster = set(clusterlist.get(key, []))\n        if cluster != boards:\n            if key == '':\n                duplicates.append(f\"- Non-USB:\\n  Boards: {', '.join(sorted(boards))}\")\n            else:\n                duplicates.append(f\"- VID/PID: {key}\\n  Boards: {', '.join(sorted(boards))}\")\n    if duplicates:\n        duplicates = '\\n'.join(duplicates)\n        duplicate_message = f'Duplicate VID/PID usage found!\\n{duplicates}\\nIf you are open source maker, then you can request a PID from http://pid.codes\\nFor boards without native USB, you can request a Creator ID from https://github.com/creationid/creators/\\nOtherwise, companies should pay the USB-IF for a vendor ID: https://www.usb.org/getting-vendor-id\\nFAQ: Why does CircuitPython require a unique VID:PID for every board definition? https://learn.adafruit.com/how-to-add-a-new-board-to-circuitpython/frequently-asked-questions#faq-3130480'\n        sys.exit(duplicate_message)\n    else:\n        print('No unexpected ID duplicates found.')",
            "def check_vid_pid(files, clusterlist):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compiles a list of USB VID & PID values for all boards, and checks\\n    for duplicates. Exits with ``sys.exit()`` (non-zero exit code)\\n    if duplicates are found, and lists the duplicates.\\n    '\n    usb_pattern = re.compile('^CIRCUITPY_USB\\\\s*=\\\\s*0$|^IDF_TARGET = (esp32|esp32c3|esp32c6|esp32h2)$', flags=re.M)\n    usb_ids = defaultdict(set)\n    for board_config in files:\n        src_text = board_config.read_text()\n        usb_vid = VID_PATTERN.search(src_text)\n        usb_pid = PID_PATTERN.search(src_text)\n        creator = CREATOR_PATTERN.search(src_text)\n        creation = CREATION_PATTERN.search(src_text)\n        non_usb = usb_pattern.search(src_text)\n        board_name = board_config.parts[-2]\n        if usb_vid and usb_pid:\n            id_group = f'0x{int(usb_vid.group(1), 16):04X}:0x{int(usb_pid.group(1), 16):04X}'\n        elif non_usb:\n            if creator is None or creation is None:\n                print(f'board_name={board_name!r} creator={creator!r} creation={creation!r}', file=sys.stderr)\n                continue\n            id_group = f'0x{int(creator.group(1), 16):08X}:0x{int(creation.group(1), 16):08X}'\n        else:\n            raise SystemExit(f'Could not find expected settings in {board_config}')\n        usb_ids[id_group].add(board_name)\n    duplicates = []\n    for (key, boards) in usb_ids.items():\n        if len(boards) == 1:\n            continue\n        cluster = set(clusterlist.get(key, []))\n        if cluster != boards:\n            if key == '':\n                duplicates.append(f\"- Non-USB:\\n  Boards: {', '.join(sorted(boards))}\")\n            else:\n                duplicates.append(f\"- VID/PID: {key}\\n  Boards: {', '.join(sorted(boards))}\")\n    if duplicates:\n        duplicates = '\\n'.join(duplicates)\n        duplicate_message = f'Duplicate VID/PID usage found!\\n{duplicates}\\nIf you are open source maker, then you can request a PID from http://pid.codes\\nFor boards without native USB, you can request a Creator ID from https://github.com/creationid/creators/\\nOtherwise, companies should pay the USB-IF for a vendor ID: https://www.usb.org/getting-vendor-id\\nFAQ: Why does CircuitPython require a unique VID:PID for every board definition? https://learn.adafruit.com/how-to-add-a-new-board-to-circuitpython/frequently-asked-questions#faq-3130480'\n        sys.exit(duplicate_message)\n    else:\n        print('No unexpected ID duplicates found.')",
            "def check_vid_pid(files, clusterlist):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compiles a list of USB VID & PID values for all boards, and checks\\n    for duplicates. Exits with ``sys.exit()`` (non-zero exit code)\\n    if duplicates are found, and lists the duplicates.\\n    '\n    usb_pattern = re.compile('^CIRCUITPY_USB\\\\s*=\\\\s*0$|^IDF_TARGET = (esp32|esp32c3|esp32c6|esp32h2)$', flags=re.M)\n    usb_ids = defaultdict(set)\n    for board_config in files:\n        src_text = board_config.read_text()\n        usb_vid = VID_PATTERN.search(src_text)\n        usb_pid = PID_PATTERN.search(src_text)\n        creator = CREATOR_PATTERN.search(src_text)\n        creation = CREATION_PATTERN.search(src_text)\n        non_usb = usb_pattern.search(src_text)\n        board_name = board_config.parts[-2]\n        if usb_vid and usb_pid:\n            id_group = f'0x{int(usb_vid.group(1), 16):04X}:0x{int(usb_pid.group(1), 16):04X}'\n        elif non_usb:\n            if creator is None or creation is None:\n                print(f'board_name={board_name!r} creator={creator!r} creation={creation!r}', file=sys.stderr)\n                continue\n            id_group = f'0x{int(creator.group(1), 16):08X}:0x{int(creation.group(1), 16):08X}'\n        else:\n            raise SystemExit(f'Could not find expected settings in {board_config}')\n        usb_ids[id_group].add(board_name)\n    duplicates = []\n    for (key, boards) in usb_ids.items():\n        if len(boards) == 1:\n            continue\n        cluster = set(clusterlist.get(key, []))\n        if cluster != boards:\n            if key == '':\n                duplicates.append(f\"- Non-USB:\\n  Boards: {', '.join(sorted(boards))}\")\n            else:\n                duplicates.append(f\"- VID/PID: {key}\\n  Boards: {', '.join(sorted(boards))}\")\n    if duplicates:\n        duplicates = '\\n'.join(duplicates)\n        duplicate_message = f'Duplicate VID/PID usage found!\\n{duplicates}\\nIf you are open source maker, then you can request a PID from http://pid.codes\\nFor boards without native USB, you can request a Creator ID from https://github.com/creationid/creators/\\nOtherwise, companies should pay the USB-IF for a vendor ID: https://www.usb.org/getting-vendor-id\\nFAQ: Why does CircuitPython require a unique VID:PID for every board definition? https://learn.adafruit.com/how-to-add-a-new-board-to-circuitpython/frequently-asked-questions#faq-3130480'\n        sys.exit(duplicate_message)\n    else:\n        print('No unexpected ID duplicates found.')",
            "def check_vid_pid(files, clusterlist):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compiles a list of USB VID & PID values for all boards, and checks\\n    for duplicates. Exits with ``sys.exit()`` (non-zero exit code)\\n    if duplicates are found, and lists the duplicates.\\n    '\n    usb_pattern = re.compile('^CIRCUITPY_USB\\\\s*=\\\\s*0$|^IDF_TARGET = (esp32|esp32c3|esp32c6|esp32h2)$', flags=re.M)\n    usb_ids = defaultdict(set)\n    for board_config in files:\n        src_text = board_config.read_text()\n        usb_vid = VID_PATTERN.search(src_text)\n        usb_pid = PID_PATTERN.search(src_text)\n        creator = CREATOR_PATTERN.search(src_text)\n        creation = CREATION_PATTERN.search(src_text)\n        non_usb = usb_pattern.search(src_text)\n        board_name = board_config.parts[-2]\n        if usb_vid and usb_pid:\n            id_group = f'0x{int(usb_vid.group(1), 16):04X}:0x{int(usb_pid.group(1), 16):04X}'\n        elif non_usb:\n            if creator is None or creation is None:\n                print(f'board_name={board_name!r} creator={creator!r} creation={creation!r}', file=sys.stderr)\n                continue\n            id_group = f'0x{int(creator.group(1), 16):08X}:0x{int(creation.group(1), 16):08X}'\n        else:\n            raise SystemExit(f'Could not find expected settings in {board_config}')\n        usb_ids[id_group].add(board_name)\n    duplicates = []\n    for (key, boards) in usb_ids.items():\n        if len(boards) == 1:\n            continue\n        cluster = set(clusterlist.get(key, []))\n        if cluster != boards:\n            if key == '':\n                duplicates.append(f\"- Non-USB:\\n  Boards: {', '.join(sorted(boards))}\")\n            else:\n                duplicates.append(f\"- VID/PID: {key}\\n  Boards: {', '.join(sorted(boards))}\")\n    if duplicates:\n        duplicates = '\\n'.join(duplicates)\n        duplicate_message = f'Duplicate VID/PID usage found!\\n{duplicates}\\nIf you are open source maker, then you can request a PID from http://pid.codes\\nFor boards without native USB, you can request a Creator ID from https://github.com/creationid/creators/\\nOtherwise, companies should pay the USB-IF for a vendor ID: https://www.usb.org/getting-vendor-id\\nFAQ: Why does CircuitPython require a unique VID:PID for every board definition? https://learn.adafruit.com/how-to-add-a-new-board-to-circuitpython/frequently-asked-questions#faq-3130480'\n        sys.exit(duplicate_message)\n    else:\n        print('No unexpected ID duplicates found.')"
        ]
    }
]