[
    {
        "func_name": "setup",
        "original": "def setup(self, bottom, top):\n    layer_params = dict()\n    layer_params['feat_stride'] = 16\n    layer_params['scales'] = (8, 16, 32)\n    layer_params['allowed_border'] = 0\n    self.RPN_NEGATIVE_OVERLAP = 0.3\n    self.RPN_POSITIVE_OVERLAP = 0.7\n    self.RPN_FG_FRACTION = 0.5\n    self.RPN_BATCHSIZE = 256\n    self.EPS = 1e-14\n    self.RPN_BBOX_INSIDE_WEIGHTS = 1\n    self.RPN_POSITIVE_WEIGHT = -1\n    anchor_scales = layer_params.get('scales', (8, 16, 32))\n    self._anchors = generate_anchors(scales=np.array(anchor_scales))\n    self._num_anchors = self._anchors.shape[0]\n    self._feat_stride = layer_params['feat_stride']\n    if DEBUG:\n        self._counts = self.EPS\n        self._sums = np.zeros((1, 4))\n        self._squared_sums = np.zeros((1, 4))\n        self._fg_sum = 0\n        self._bg_sum = 0\n        self._count = 0\n    self._allowed_border = layer_params.get('allowed_border', 0)",
        "mutated": [
            "def setup(self, bottom, top):\n    if False:\n        i = 10\n    layer_params = dict()\n    layer_params['feat_stride'] = 16\n    layer_params['scales'] = (8, 16, 32)\n    layer_params['allowed_border'] = 0\n    self.RPN_NEGATIVE_OVERLAP = 0.3\n    self.RPN_POSITIVE_OVERLAP = 0.7\n    self.RPN_FG_FRACTION = 0.5\n    self.RPN_BATCHSIZE = 256\n    self.EPS = 1e-14\n    self.RPN_BBOX_INSIDE_WEIGHTS = 1\n    self.RPN_POSITIVE_WEIGHT = -1\n    anchor_scales = layer_params.get('scales', (8, 16, 32))\n    self._anchors = generate_anchors(scales=np.array(anchor_scales))\n    self._num_anchors = self._anchors.shape[0]\n    self._feat_stride = layer_params['feat_stride']\n    if DEBUG:\n        self._counts = self.EPS\n        self._sums = np.zeros((1, 4))\n        self._squared_sums = np.zeros((1, 4))\n        self._fg_sum = 0\n        self._bg_sum = 0\n        self._count = 0\n    self._allowed_border = layer_params.get('allowed_border', 0)",
            "def setup(self, bottom, top):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    layer_params = dict()\n    layer_params['feat_stride'] = 16\n    layer_params['scales'] = (8, 16, 32)\n    layer_params['allowed_border'] = 0\n    self.RPN_NEGATIVE_OVERLAP = 0.3\n    self.RPN_POSITIVE_OVERLAP = 0.7\n    self.RPN_FG_FRACTION = 0.5\n    self.RPN_BATCHSIZE = 256\n    self.EPS = 1e-14\n    self.RPN_BBOX_INSIDE_WEIGHTS = 1\n    self.RPN_POSITIVE_WEIGHT = -1\n    anchor_scales = layer_params.get('scales', (8, 16, 32))\n    self._anchors = generate_anchors(scales=np.array(anchor_scales))\n    self._num_anchors = self._anchors.shape[0]\n    self._feat_stride = layer_params['feat_stride']\n    if DEBUG:\n        self._counts = self.EPS\n        self._sums = np.zeros((1, 4))\n        self._squared_sums = np.zeros((1, 4))\n        self._fg_sum = 0\n        self._bg_sum = 0\n        self._count = 0\n    self._allowed_border = layer_params.get('allowed_border', 0)",
            "def setup(self, bottom, top):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    layer_params = dict()\n    layer_params['feat_stride'] = 16\n    layer_params['scales'] = (8, 16, 32)\n    layer_params['allowed_border'] = 0\n    self.RPN_NEGATIVE_OVERLAP = 0.3\n    self.RPN_POSITIVE_OVERLAP = 0.7\n    self.RPN_FG_FRACTION = 0.5\n    self.RPN_BATCHSIZE = 256\n    self.EPS = 1e-14\n    self.RPN_BBOX_INSIDE_WEIGHTS = 1\n    self.RPN_POSITIVE_WEIGHT = -1\n    anchor_scales = layer_params.get('scales', (8, 16, 32))\n    self._anchors = generate_anchors(scales=np.array(anchor_scales))\n    self._num_anchors = self._anchors.shape[0]\n    self._feat_stride = layer_params['feat_stride']\n    if DEBUG:\n        self._counts = self.EPS\n        self._sums = np.zeros((1, 4))\n        self._squared_sums = np.zeros((1, 4))\n        self._fg_sum = 0\n        self._bg_sum = 0\n        self._count = 0\n    self._allowed_border = layer_params.get('allowed_border', 0)",
            "def setup(self, bottom, top):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    layer_params = dict()\n    layer_params['feat_stride'] = 16\n    layer_params['scales'] = (8, 16, 32)\n    layer_params['allowed_border'] = 0\n    self.RPN_NEGATIVE_OVERLAP = 0.3\n    self.RPN_POSITIVE_OVERLAP = 0.7\n    self.RPN_FG_FRACTION = 0.5\n    self.RPN_BATCHSIZE = 256\n    self.EPS = 1e-14\n    self.RPN_BBOX_INSIDE_WEIGHTS = 1\n    self.RPN_POSITIVE_WEIGHT = -1\n    anchor_scales = layer_params.get('scales', (8, 16, 32))\n    self._anchors = generate_anchors(scales=np.array(anchor_scales))\n    self._num_anchors = self._anchors.shape[0]\n    self._feat_stride = layer_params['feat_stride']\n    if DEBUG:\n        self._counts = self.EPS\n        self._sums = np.zeros((1, 4))\n        self._squared_sums = np.zeros((1, 4))\n        self._fg_sum = 0\n        self._bg_sum = 0\n        self._count = 0\n    self._allowed_border = layer_params.get('allowed_border', 0)",
            "def setup(self, bottom, top):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    layer_params = dict()\n    layer_params['feat_stride'] = 16\n    layer_params['scales'] = (8, 16, 32)\n    layer_params['allowed_border'] = 0\n    self.RPN_NEGATIVE_OVERLAP = 0.3\n    self.RPN_POSITIVE_OVERLAP = 0.7\n    self.RPN_FG_FRACTION = 0.5\n    self.RPN_BATCHSIZE = 256\n    self.EPS = 1e-14\n    self.RPN_BBOX_INSIDE_WEIGHTS = 1\n    self.RPN_POSITIVE_WEIGHT = -1\n    anchor_scales = layer_params.get('scales', (8, 16, 32))\n    self._anchors = generate_anchors(scales=np.array(anchor_scales))\n    self._num_anchors = self._anchors.shape[0]\n    self._feat_stride = layer_params['feat_stride']\n    if DEBUG:\n        self._counts = self.EPS\n        self._sums = np.zeros((1, 4))\n        self._squared_sums = np.zeros((1, 4))\n        self._fg_sum = 0\n        self._bg_sum = 0\n        self._count = 0\n    self._allowed_border = layer_params.get('allowed_border', 0)"
        ]
    },
    {
        "func_name": "forward",
        "original": "def forward(self, bottom, top):\n    height = bottom[0].shape[0]\n    width = bottom[0].shape[1]\n    gt_boxes = bottom[1]\n    im_info = bottom[2]\n    if DEBUG:\n        print('')\n        print('im_size: ({}, {})'.format(im_info[0], im_info[1]))\n        print('scale: {}'.format(im_info[2]))\n        print('height, width: ({}, {})'.format(height, width))\n        print('rpn: gt_boxes.shape', gt_boxes.shape)\n        print('rpn: gt_boxes', gt_boxes)\n    shift_x = np.arange(0, width) * self._feat_stride\n    shift_y = np.arange(0, height) * self._feat_stride\n    (shift_x, shift_y) = np.meshgrid(shift_x, shift_y)\n    shifts = np.vstack((shift_x.ravel(), shift_y.ravel(), shift_x.ravel(), shift_y.ravel())).transpose()\n    A = self._num_anchors\n    K = shifts.shape[0]\n    all_anchors = self._anchors.reshape((1, A, 4)) + shifts.reshape((1, K, 4)).transpose((1, 0, 2))\n    all_anchors = all_anchors.reshape((K * A, 4))\n    total_anchors = int(K * A)\n    inds_inside = np.where((all_anchors[:, 0] >= -self._allowed_border) & (all_anchors[:, 1] >= -self._allowed_border) & (all_anchors[:, 2] < im_info[0] + self._allowed_border) & (all_anchors[:, 3] < im_info[1] + self._allowed_border))[0]\n    if DEBUG:\n        print('total_anchors', total_anchors)\n        print('inds_inside', len(inds_inside))\n    anchors = all_anchors[inds_inside, :]\n    if DEBUG:\n        print('anchors.shape', anchors.shape)\n    labels = np.empty((len(inds_inside),), dtype=np.float32)\n    labels.fill(-1)\n    overlaps = calculate_bb_overlap(np.ascontiguousarray(anchors, dtype=np.float), np.ascontiguousarray(gt_boxes, dtype=np.float))\n    argmax_overlaps = overlaps.argmax(axis=1)\n    max_overlaps = overlaps[np.arange(len(inds_inside)), argmax_overlaps]\n    gt_argmax_overlaps = overlaps.argmax(axis=0)\n    gt_max_overlaps = overlaps[gt_argmax_overlaps, np.arange(overlaps.shape[1])]\n    gt_argmax_overlaps = np.where(overlaps == gt_max_overlaps)[0]\n    labels[max_overlaps < self.RPN_NEGATIVE_OVERLAP] = 0\n    labels[gt_argmax_overlaps] = 1\n    labels[max_overlaps >= self.RPN_POSITIVE_OVERLAP] = 1\n    if DEBUG:\n        print('rpn: max max_overlap', np.max(max_overlaps))\n        print('rpn: num_positive', np.sum(labels == 1))\n        print('rpn: num_negative', np.sum(labels == 0))\n    num_fg = int(self.RPN_FG_FRACTION * self.RPN_BATCHSIZE)\n    fg_inds = np.where(labels == 1)[0]\n    if len(fg_inds) > num_fg:\n        disable_inds = npr.choice(fg_inds, size=len(fg_inds) - num_fg, replace=False)\n        labels[disable_inds] = -1\n    num_bg = self.RPN_BATCHSIZE - np.sum(labels == 1)\n    bg_inds = np.where(labels == 0)[0]\n    if len(bg_inds) > num_bg:\n        disable_inds = npr.choice(bg_inds, size=len(bg_inds) - num_bg, replace=False)\n        labels[disable_inds] = -1\n    bbox_targets = np.zeros((len(inds_inside), 4), dtype=np.float32)\n    bbox_targets = _compute_targets(anchors, gt_boxes[argmax_overlaps, :])\n    bbox_inside_weights = np.zeros((len(inds_inside), 4), dtype=np.float32)\n    bbox_inside_weights[labels == 1, :] = np.array(self.RPN_BBOX_INSIDE_WEIGHTS)\n    bbox_outside_weights = np.zeros((len(inds_inside), 4), dtype=np.float32)\n    if self.RPN_POSITIVE_WEIGHT < 0:\n        num_examples = np.sum(labels >= 0)\n        positive_weights = np.ones((1, 4)) * 1.0 / num_examples\n        negative_weights = np.ones((1, 4)) * 1.0 / num_examples\n    else:\n        assert (self.RPN_POSITIVE_WEIGHT > 0) & (self.RPN_POSITIVE_WEIGHT < 1)\n        positive_weights = self.RPN_POSITIVE_WEIGHT / np.sum(labels == 1)\n        negative_weights = (1.0 - self.RPN_POSITIVE_WEIGHT) / np.sum(labels == 0)\n    bbox_outside_weights[labels == 1, :] = positive_weights\n    bbox_outside_weights[labels == 0, :] = negative_weights\n    if DEBUG:\n        self._sums += bbox_targets[labels == 1, :].sum(axis=0)\n        self._squared_sums += (bbox_targets[labels == 1, :] ** 2).sum(axis=0)\n        self._counts += np.sum(labels == 1)\n        means = self._sums / self._counts\n        stds = np.sqrt(self._squared_sums / self._counts - means ** 2)\n        print('means:')\n        print(means)\n        print('stdevs:')\n        print(stds)\n    labels = _unmap(labels, total_anchors, inds_inside, fill=-1)\n    bbox_targets = _unmap(bbox_targets, total_anchors, inds_inside, fill=0)\n    bbox_inside_weights = _unmap(bbox_inside_weights, total_anchors, inds_inside, fill=0)\n    bbox_outside_weights = _unmap(bbox_outside_weights, total_anchors, inds_inside, fill=0)\n    if DEBUG:\n        print('rpn: max max_overlap', np.max(max_overlaps))\n        print('rpn: num_positive', np.sum(labels == 1))\n        print('rpn: num_negative', np.sum(labels == 0))\n        self._fg_sum += np.sum(labels == 1)\n        self._bg_sum += np.sum(labels == 0)\n        self._count += 1\n        print('rpn: num_positive avg', self._fg_sum / self._count)\n        print('rpn: num_negative avg', self._bg_sum / self._count)\n    labels = labels.reshape((1, height, width, A)).transpose(0, 3, 1, 2)\n    labels = labels.reshape((1, 1, A * height, width))\n    top[0] = labels\n    bbox_targets = bbox_targets.reshape((1, height, width, A * 4)).transpose(0, 3, 1, 2)\n    top[1] = bbox_targets\n    bbox_inside_weights = bbox_inside_weights.reshape((1, height, width, A * 4)).transpose(0, 3, 1, 2)\n    assert bbox_inside_weights.shape[2] == height\n    assert bbox_inside_weights.shape[3] == width\n    top[2] = bbox_inside_weights\n    bbox_outside_weights = bbox_outside_weights.reshape((1, height, width, A * 4)).transpose(0, 3, 1, 2)\n    assert bbox_outside_weights.shape[2] == height\n    assert bbox_outside_weights.shape[3] == width\n    top[3] = bbox_outside_weights",
        "mutated": [
            "def forward(self, bottom, top):\n    if False:\n        i = 10\n    height = bottom[0].shape[0]\n    width = bottom[0].shape[1]\n    gt_boxes = bottom[1]\n    im_info = bottom[2]\n    if DEBUG:\n        print('')\n        print('im_size: ({}, {})'.format(im_info[0], im_info[1]))\n        print('scale: {}'.format(im_info[2]))\n        print('height, width: ({}, {})'.format(height, width))\n        print('rpn: gt_boxes.shape', gt_boxes.shape)\n        print('rpn: gt_boxes', gt_boxes)\n    shift_x = np.arange(0, width) * self._feat_stride\n    shift_y = np.arange(0, height) * self._feat_stride\n    (shift_x, shift_y) = np.meshgrid(shift_x, shift_y)\n    shifts = np.vstack((shift_x.ravel(), shift_y.ravel(), shift_x.ravel(), shift_y.ravel())).transpose()\n    A = self._num_anchors\n    K = shifts.shape[0]\n    all_anchors = self._anchors.reshape((1, A, 4)) + shifts.reshape((1, K, 4)).transpose((1, 0, 2))\n    all_anchors = all_anchors.reshape((K * A, 4))\n    total_anchors = int(K * A)\n    inds_inside = np.where((all_anchors[:, 0] >= -self._allowed_border) & (all_anchors[:, 1] >= -self._allowed_border) & (all_anchors[:, 2] < im_info[0] + self._allowed_border) & (all_anchors[:, 3] < im_info[1] + self._allowed_border))[0]\n    if DEBUG:\n        print('total_anchors', total_anchors)\n        print('inds_inside', len(inds_inside))\n    anchors = all_anchors[inds_inside, :]\n    if DEBUG:\n        print('anchors.shape', anchors.shape)\n    labels = np.empty((len(inds_inside),), dtype=np.float32)\n    labels.fill(-1)\n    overlaps = calculate_bb_overlap(np.ascontiguousarray(anchors, dtype=np.float), np.ascontiguousarray(gt_boxes, dtype=np.float))\n    argmax_overlaps = overlaps.argmax(axis=1)\n    max_overlaps = overlaps[np.arange(len(inds_inside)), argmax_overlaps]\n    gt_argmax_overlaps = overlaps.argmax(axis=0)\n    gt_max_overlaps = overlaps[gt_argmax_overlaps, np.arange(overlaps.shape[1])]\n    gt_argmax_overlaps = np.where(overlaps == gt_max_overlaps)[0]\n    labels[max_overlaps < self.RPN_NEGATIVE_OVERLAP] = 0\n    labels[gt_argmax_overlaps] = 1\n    labels[max_overlaps >= self.RPN_POSITIVE_OVERLAP] = 1\n    if DEBUG:\n        print('rpn: max max_overlap', np.max(max_overlaps))\n        print('rpn: num_positive', np.sum(labels == 1))\n        print('rpn: num_negative', np.sum(labels == 0))\n    num_fg = int(self.RPN_FG_FRACTION * self.RPN_BATCHSIZE)\n    fg_inds = np.where(labels == 1)[0]\n    if len(fg_inds) > num_fg:\n        disable_inds = npr.choice(fg_inds, size=len(fg_inds) - num_fg, replace=False)\n        labels[disable_inds] = -1\n    num_bg = self.RPN_BATCHSIZE - np.sum(labels == 1)\n    bg_inds = np.where(labels == 0)[0]\n    if len(bg_inds) > num_bg:\n        disable_inds = npr.choice(bg_inds, size=len(bg_inds) - num_bg, replace=False)\n        labels[disable_inds] = -1\n    bbox_targets = np.zeros((len(inds_inside), 4), dtype=np.float32)\n    bbox_targets = _compute_targets(anchors, gt_boxes[argmax_overlaps, :])\n    bbox_inside_weights = np.zeros((len(inds_inside), 4), dtype=np.float32)\n    bbox_inside_weights[labels == 1, :] = np.array(self.RPN_BBOX_INSIDE_WEIGHTS)\n    bbox_outside_weights = np.zeros((len(inds_inside), 4), dtype=np.float32)\n    if self.RPN_POSITIVE_WEIGHT < 0:\n        num_examples = np.sum(labels >= 0)\n        positive_weights = np.ones((1, 4)) * 1.0 / num_examples\n        negative_weights = np.ones((1, 4)) * 1.0 / num_examples\n    else:\n        assert (self.RPN_POSITIVE_WEIGHT > 0) & (self.RPN_POSITIVE_WEIGHT < 1)\n        positive_weights = self.RPN_POSITIVE_WEIGHT / np.sum(labels == 1)\n        negative_weights = (1.0 - self.RPN_POSITIVE_WEIGHT) / np.sum(labels == 0)\n    bbox_outside_weights[labels == 1, :] = positive_weights\n    bbox_outside_weights[labels == 0, :] = negative_weights\n    if DEBUG:\n        self._sums += bbox_targets[labels == 1, :].sum(axis=0)\n        self._squared_sums += (bbox_targets[labels == 1, :] ** 2).sum(axis=0)\n        self._counts += np.sum(labels == 1)\n        means = self._sums / self._counts\n        stds = np.sqrt(self._squared_sums / self._counts - means ** 2)\n        print('means:')\n        print(means)\n        print('stdevs:')\n        print(stds)\n    labels = _unmap(labels, total_anchors, inds_inside, fill=-1)\n    bbox_targets = _unmap(bbox_targets, total_anchors, inds_inside, fill=0)\n    bbox_inside_weights = _unmap(bbox_inside_weights, total_anchors, inds_inside, fill=0)\n    bbox_outside_weights = _unmap(bbox_outside_weights, total_anchors, inds_inside, fill=0)\n    if DEBUG:\n        print('rpn: max max_overlap', np.max(max_overlaps))\n        print('rpn: num_positive', np.sum(labels == 1))\n        print('rpn: num_negative', np.sum(labels == 0))\n        self._fg_sum += np.sum(labels == 1)\n        self._bg_sum += np.sum(labels == 0)\n        self._count += 1\n        print('rpn: num_positive avg', self._fg_sum / self._count)\n        print('rpn: num_negative avg', self._bg_sum / self._count)\n    labels = labels.reshape((1, height, width, A)).transpose(0, 3, 1, 2)\n    labels = labels.reshape((1, 1, A * height, width))\n    top[0] = labels\n    bbox_targets = bbox_targets.reshape((1, height, width, A * 4)).transpose(0, 3, 1, 2)\n    top[1] = bbox_targets\n    bbox_inside_weights = bbox_inside_weights.reshape((1, height, width, A * 4)).transpose(0, 3, 1, 2)\n    assert bbox_inside_weights.shape[2] == height\n    assert bbox_inside_weights.shape[3] == width\n    top[2] = bbox_inside_weights\n    bbox_outside_weights = bbox_outside_weights.reshape((1, height, width, A * 4)).transpose(0, 3, 1, 2)\n    assert bbox_outside_weights.shape[2] == height\n    assert bbox_outside_weights.shape[3] == width\n    top[3] = bbox_outside_weights",
            "def forward(self, bottom, top):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    height = bottom[0].shape[0]\n    width = bottom[0].shape[1]\n    gt_boxes = bottom[1]\n    im_info = bottom[2]\n    if DEBUG:\n        print('')\n        print('im_size: ({}, {})'.format(im_info[0], im_info[1]))\n        print('scale: {}'.format(im_info[2]))\n        print('height, width: ({}, {})'.format(height, width))\n        print('rpn: gt_boxes.shape', gt_boxes.shape)\n        print('rpn: gt_boxes', gt_boxes)\n    shift_x = np.arange(0, width) * self._feat_stride\n    shift_y = np.arange(0, height) * self._feat_stride\n    (shift_x, shift_y) = np.meshgrid(shift_x, shift_y)\n    shifts = np.vstack((shift_x.ravel(), shift_y.ravel(), shift_x.ravel(), shift_y.ravel())).transpose()\n    A = self._num_anchors\n    K = shifts.shape[0]\n    all_anchors = self._anchors.reshape((1, A, 4)) + shifts.reshape((1, K, 4)).transpose((1, 0, 2))\n    all_anchors = all_anchors.reshape((K * A, 4))\n    total_anchors = int(K * A)\n    inds_inside = np.where((all_anchors[:, 0] >= -self._allowed_border) & (all_anchors[:, 1] >= -self._allowed_border) & (all_anchors[:, 2] < im_info[0] + self._allowed_border) & (all_anchors[:, 3] < im_info[1] + self._allowed_border))[0]\n    if DEBUG:\n        print('total_anchors', total_anchors)\n        print('inds_inside', len(inds_inside))\n    anchors = all_anchors[inds_inside, :]\n    if DEBUG:\n        print('anchors.shape', anchors.shape)\n    labels = np.empty((len(inds_inside),), dtype=np.float32)\n    labels.fill(-1)\n    overlaps = calculate_bb_overlap(np.ascontiguousarray(anchors, dtype=np.float), np.ascontiguousarray(gt_boxes, dtype=np.float))\n    argmax_overlaps = overlaps.argmax(axis=1)\n    max_overlaps = overlaps[np.arange(len(inds_inside)), argmax_overlaps]\n    gt_argmax_overlaps = overlaps.argmax(axis=0)\n    gt_max_overlaps = overlaps[gt_argmax_overlaps, np.arange(overlaps.shape[1])]\n    gt_argmax_overlaps = np.where(overlaps == gt_max_overlaps)[0]\n    labels[max_overlaps < self.RPN_NEGATIVE_OVERLAP] = 0\n    labels[gt_argmax_overlaps] = 1\n    labels[max_overlaps >= self.RPN_POSITIVE_OVERLAP] = 1\n    if DEBUG:\n        print('rpn: max max_overlap', np.max(max_overlaps))\n        print('rpn: num_positive', np.sum(labels == 1))\n        print('rpn: num_negative', np.sum(labels == 0))\n    num_fg = int(self.RPN_FG_FRACTION * self.RPN_BATCHSIZE)\n    fg_inds = np.where(labels == 1)[0]\n    if len(fg_inds) > num_fg:\n        disable_inds = npr.choice(fg_inds, size=len(fg_inds) - num_fg, replace=False)\n        labels[disable_inds] = -1\n    num_bg = self.RPN_BATCHSIZE - np.sum(labels == 1)\n    bg_inds = np.where(labels == 0)[0]\n    if len(bg_inds) > num_bg:\n        disable_inds = npr.choice(bg_inds, size=len(bg_inds) - num_bg, replace=False)\n        labels[disable_inds] = -1\n    bbox_targets = np.zeros((len(inds_inside), 4), dtype=np.float32)\n    bbox_targets = _compute_targets(anchors, gt_boxes[argmax_overlaps, :])\n    bbox_inside_weights = np.zeros((len(inds_inside), 4), dtype=np.float32)\n    bbox_inside_weights[labels == 1, :] = np.array(self.RPN_BBOX_INSIDE_WEIGHTS)\n    bbox_outside_weights = np.zeros((len(inds_inside), 4), dtype=np.float32)\n    if self.RPN_POSITIVE_WEIGHT < 0:\n        num_examples = np.sum(labels >= 0)\n        positive_weights = np.ones((1, 4)) * 1.0 / num_examples\n        negative_weights = np.ones((1, 4)) * 1.0 / num_examples\n    else:\n        assert (self.RPN_POSITIVE_WEIGHT > 0) & (self.RPN_POSITIVE_WEIGHT < 1)\n        positive_weights = self.RPN_POSITIVE_WEIGHT / np.sum(labels == 1)\n        negative_weights = (1.0 - self.RPN_POSITIVE_WEIGHT) / np.sum(labels == 0)\n    bbox_outside_weights[labels == 1, :] = positive_weights\n    bbox_outside_weights[labels == 0, :] = negative_weights\n    if DEBUG:\n        self._sums += bbox_targets[labels == 1, :].sum(axis=0)\n        self._squared_sums += (bbox_targets[labels == 1, :] ** 2).sum(axis=0)\n        self._counts += np.sum(labels == 1)\n        means = self._sums / self._counts\n        stds = np.sqrt(self._squared_sums / self._counts - means ** 2)\n        print('means:')\n        print(means)\n        print('stdevs:')\n        print(stds)\n    labels = _unmap(labels, total_anchors, inds_inside, fill=-1)\n    bbox_targets = _unmap(bbox_targets, total_anchors, inds_inside, fill=0)\n    bbox_inside_weights = _unmap(bbox_inside_weights, total_anchors, inds_inside, fill=0)\n    bbox_outside_weights = _unmap(bbox_outside_weights, total_anchors, inds_inside, fill=0)\n    if DEBUG:\n        print('rpn: max max_overlap', np.max(max_overlaps))\n        print('rpn: num_positive', np.sum(labels == 1))\n        print('rpn: num_negative', np.sum(labels == 0))\n        self._fg_sum += np.sum(labels == 1)\n        self._bg_sum += np.sum(labels == 0)\n        self._count += 1\n        print('rpn: num_positive avg', self._fg_sum / self._count)\n        print('rpn: num_negative avg', self._bg_sum / self._count)\n    labels = labels.reshape((1, height, width, A)).transpose(0, 3, 1, 2)\n    labels = labels.reshape((1, 1, A * height, width))\n    top[0] = labels\n    bbox_targets = bbox_targets.reshape((1, height, width, A * 4)).transpose(0, 3, 1, 2)\n    top[1] = bbox_targets\n    bbox_inside_weights = bbox_inside_weights.reshape((1, height, width, A * 4)).transpose(0, 3, 1, 2)\n    assert bbox_inside_weights.shape[2] == height\n    assert bbox_inside_weights.shape[3] == width\n    top[2] = bbox_inside_weights\n    bbox_outside_weights = bbox_outside_weights.reshape((1, height, width, A * 4)).transpose(0, 3, 1, 2)\n    assert bbox_outside_weights.shape[2] == height\n    assert bbox_outside_weights.shape[3] == width\n    top[3] = bbox_outside_weights",
            "def forward(self, bottom, top):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    height = bottom[0].shape[0]\n    width = bottom[0].shape[1]\n    gt_boxes = bottom[1]\n    im_info = bottom[2]\n    if DEBUG:\n        print('')\n        print('im_size: ({}, {})'.format(im_info[0], im_info[1]))\n        print('scale: {}'.format(im_info[2]))\n        print('height, width: ({}, {})'.format(height, width))\n        print('rpn: gt_boxes.shape', gt_boxes.shape)\n        print('rpn: gt_boxes', gt_boxes)\n    shift_x = np.arange(0, width) * self._feat_stride\n    shift_y = np.arange(0, height) * self._feat_stride\n    (shift_x, shift_y) = np.meshgrid(shift_x, shift_y)\n    shifts = np.vstack((shift_x.ravel(), shift_y.ravel(), shift_x.ravel(), shift_y.ravel())).transpose()\n    A = self._num_anchors\n    K = shifts.shape[0]\n    all_anchors = self._anchors.reshape((1, A, 4)) + shifts.reshape((1, K, 4)).transpose((1, 0, 2))\n    all_anchors = all_anchors.reshape((K * A, 4))\n    total_anchors = int(K * A)\n    inds_inside = np.where((all_anchors[:, 0] >= -self._allowed_border) & (all_anchors[:, 1] >= -self._allowed_border) & (all_anchors[:, 2] < im_info[0] + self._allowed_border) & (all_anchors[:, 3] < im_info[1] + self._allowed_border))[0]\n    if DEBUG:\n        print('total_anchors', total_anchors)\n        print('inds_inside', len(inds_inside))\n    anchors = all_anchors[inds_inside, :]\n    if DEBUG:\n        print('anchors.shape', anchors.shape)\n    labels = np.empty((len(inds_inside),), dtype=np.float32)\n    labels.fill(-1)\n    overlaps = calculate_bb_overlap(np.ascontiguousarray(anchors, dtype=np.float), np.ascontiguousarray(gt_boxes, dtype=np.float))\n    argmax_overlaps = overlaps.argmax(axis=1)\n    max_overlaps = overlaps[np.arange(len(inds_inside)), argmax_overlaps]\n    gt_argmax_overlaps = overlaps.argmax(axis=0)\n    gt_max_overlaps = overlaps[gt_argmax_overlaps, np.arange(overlaps.shape[1])]\n    gt_argmax_overlaps = np.where(overlaps == gt_max_overlaps)[0]\n    labels[max_overlaps < self.RPN_NEGATIVE_OVERLAP] = 0\n    labels[gt_argmax_overlaps] = 1\n    labels[max_overlaps >= self.RPN_POSITIVE_OVERLAP] = 1\n    if DEBUG:\n        print('rpn: max max_overlap', np.max(max_overlaps))\n        print('rpn: num_positive', np.sum(labels == 1))\n        print('rpn: num_negative', np.sum(labels == 0))\n    num_fg = int(self.RPN_FG_FRACTION * self.RPN_BATCHSIZE)\n    fg_inds = np.where(labels == 1)[0]\n    if len(fg_inds) > num_fg:\n        disable_inds = npr.choice(fg_inds, size=len(fg_inds) - num_fg, replace=False)\n        labels[disable_inds] = -1\n    num_bg = self.RPN_BATCHSIZE - np.sum(labels == 1)\n    bg_inds = np.where(labels == 0)[0]\n    if len(bg_inds) > num_bg:\n        disable_inds = npr.choice(bg_inds, size=len(bg_inds) - num_bg, replace=False)\n        labels[disable_inds] = -1\n    bbox_targets = np.zeros((len(inds_inside), 4), dtype=np.float32)\n    bbox_targets = _compute_targets(anchors, gt_boxes[argmax_overlaps, :])\n    bbox_inside_weights = np.zeros((len(inds_inside), 4), dtype=np.float32)\n    bbox_inside_weights[labels == 1, :] = np.array(self.RPN_BBOX_INSIDE_WEIGHTS)\n    bbox_outside_weights = np.zeros((len(inds_inside), 4), dtype=np.float32)\n    if self.RPN_POSITIVE_WEIGHT < 0:\n        num_examples = np.sum(labels >= 0)\n        positive_weights = np.ones((1, 4)) * 1.0 / num_examples\n        negative_weights = np.ones((1, 4)) * 1.0 / num_examples\n    else:\n        assert (self.RPN_POSITIVE_WEIGHT > 0) & (self.RPN_POSITIVE_WEIGHT < 1)\n        positive_weights = self.RPN_POSITIVE_WEIGHT / np.sum(labels == 1)\n        negative_weights = (1.0 - self.RPN_POSITIVE_WEIGHT) / np.sum(labels == 0)\n    bbox_outside_weights[labels == 1, :] = positive_weights\n    bbox_outside_weights[labels == 0, :] = negative_weights\n    if DEBUG:\n        self._sums += bbox_targets[labels == 1, :].sum(axis=0)\n        self._squared_sums += (bbox_targets[labels == 1, :] ** 2).sum(axis=0)\n        self._counts += np.sum(labels == 1)\n        means = self._sums / self._counts\n        stds = np.sqrt(self._squared_sums / self._counts - means ** 2)\n        print('means:')\n        print(means)\n        print('stdevs:')\n        print(stds)\n    labels = _unmap(labels, total_anchors, inds_inside, fill=-1)\n    bbox_targets = _unmap(bbox_targets, total_anchors, inds_inside, fill=0)\n    bbox_inside_weights = _unmap(bbox_inside_weights, total_anchors, inds_inside, fill=0)\n    bbox_outside_weights = _unmap(bbox_outside_weights, total_anchors, inds_inside, fill=0)\n    if DEBUG:\n        print('rpn: max max_overlap', np.max(max_overlaps))\n        print('rpn: num_positive', np.sum(labels == 1))\n        print('rpn: num_negative', np.sum(labels == 0))\n        self._fg_sum += np.sum(labels == 1)\n        self._bg_sum += np.sum(labels == 0)\n        self._count += 1\n        print('rpn: num_positive avg', self._fg_sum / self._count)\n        print('rpn: num_negative avg', self._bg_sum / self._count)\n    labels = labels.reshape((1, height, width, A)).transpose(0, 3, 1, 2)\n    labels = labels.reshape((1, 1, A * height, width))\n    top[0] = labels\n    bbox_targets = bbox_targets.reshape((1, height, width, A * 4)).transpose(0, 3, 1, 2)\n    top[1] = bbox_targets\n    bbox_inside_weights = bbox_inside_weights.reshape((1, height, width, A * 4)).transpose(0, 3, 1, 2)\n    assert bbox_inside_weights.shape[2] == height\n    assert bbox_inside_weights.shape[3] == width\n    top[2] = bbox_inside_weights\n    bbox_outside_weights = bbox_outside_weights.reshape((1, height, width, A * 4)).transpose(0, 3, 1, 2)\n    assert bbox_outside_weights.shape[2] == height\n    assert bbox_outside_weights.shape[3] == width\n    top[3] = bbox_outside_weights",
            "def forward(self, bottom, top):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    height = bottom[0].shape[0]\n    width = bottom[0].shape[1]\n    gt_boxes = bottom[1]\n    im_info = bottom[2]\n    if DEBUG:\n        print('')\n        print('im_size: ({}, {})'.format(im_info[0], im_info[1]))\n        print('scale: {}'.format(im_info[2]))\n        print('height, width: ({}, {})'.format(height, width))\n        print('rpn: gt_boxes.shape', gt_boxes.shape)\n        print('rpn: gt_boxes', gt_boxes)\n    shift_x = np.arange(0, width) * self._feat_stride\n    shift_y = np.arange(0, height) * self._feat_stride\n    (shift_x, shift_y) = np.meshgrid(shift_x, shift_y)\n    shifts = np.vstack((shift_x.ravel(), shift_y.ravel(), shift_x.ravel(), shift_y.ravel())).transpose()\n    A = self._num_anchors\n    K = shifts.shape[0]\n    all_anchors = self._anchors.reshape((1, A, 4)) + shifts.reshape((1, K, 4)).transpose((1, 0, 2))\n    all_anchors = all_anchors.reshape((K * A, 4))\n    total_anchors = int(K * A)\n    inds_inside = np.where((all_anchors[:, 0] >= -self._allowed_border) & (all_anchors[:, 1] >= -self._allowed_border) & (all_anchors[:, 2] < im_info[0] + self._allowed_border) & (all_anchors[:, 3] < im_info[1] + self._allowed_border))[0]\n    if DEBUG:\n        print('total_anchors', total_anchors)\n        print('inds_inside', len(inds_inside))\n    anchors = all_anchors[inds_inside, :]\n    if DEBUG:\n        print('anchors.shape', anchors.shape)\n    labels = np.empty((len(inds_inside),), dtype=np.float32)\n    labels.fill(-1)\n    overlaps = calculate_bb_overlap(np.ascontiguousarray(anchors, dtype=np.float), np.ascontiguousarray(gt_boxes, dtype=np.float))\n    argmax_overlaps = overlaps.argmax(axis=1)\n    max_overlaps = overlaps[np.arange(len(inds_inside)), argmax_overlaps]\n    gt_argmax_overlaps = overlaps.argmax(axis=0)\n    gt_max_overlaps = overlaps[gt_argmax_overlaps, np.arange(overlaps.shape[1])]\n    gt_argmax_overlaps = np.where(overlaps == gt_max_overlaps)[0]\n    labels[max_overlaps < self.RPN_NEGATIVE_OVERLAP] = 0\n    labels[gt_argmax_overlaps] = 1\n    labels[max_overlaps >= self.RPN_POSITIVE_OVERLAP] = 1\n    if DEBUG:\n        print('rpn: max max_overlap', np.max(max_overlaps))\n        print('rpn: num_positive', np.sum(labels == 1))\n        print('rpn: num_negative', np.sum(labels == 0))\n    num_fg = int(self.RPN_FG_FRACTION * self.RPN_BATCHSIZE)\n    fg_inds = np.where(labels == 1)[0]\n    if len(fg_inds) > num_fg:\n        disable_inds = npr.choice(fg_inds, size=len(fg_inds) - num_fg, replace=False)\n        labels[disable_inds] = -1\n    num_bg = self.RPN_BATCHSIZE - np.sum(labels == 1)\n    bg_inds = np.where(labels == 0)[0]\n    if len(bg_inds) > num_bg:\n        disable_inds = npr.choice(bg_inds, size=len(bg_inds) - num_bg, replace=False)\n        labels[disable_inds] = -1\n    bbox_targets = np.zeros((len(inds_inside), 4), dtype=np.float32)\n    bbox_targets = _compute_targets(anchors, gt_boxes[argmax_overlaps, :])\n    bbox_inside_weights = np.zeros((len(inds_inside), 4), dtype=np.float32)\n    bbox_inside_weights[labels == 1, :] = np.array(self.RPN_BBOX_INSIDE_WEIGHTS)\n    bbox_outside_weights = np.zeros((len(inds_inside), 4), dtype=np.float32)\n    if self.RPN_POSITIVE_WEIGHT < 0:\n        num_examples = np.sum(labels >= 0)\n        positive_weights = np.ones((1, 4)) * 1.0 / num_examples\n        negative_weights = np.ones((1, 4)) * 1.0 / num_examples\n    else:\n        assert (self.RPN_POSITIVE_WEIGHT > 0) & (self.RPN_POSITIVE_WEIGHT < 1)\n        positive_weights = self.RPN_POSITIVE_WEIGHT / np.sum(labels == 1)\n        negative_weights = (1.0 - self.RPN_POSITIVE_WEIGHT) / np.sum(labels == 0)\n    bbox_outside_weights[labels == 1, :] = positive_weights\n    bbox_outside_weights[labels == 0, :] = negative_weights\n    if DEBUG:\n        self._sums += bbox_targets[labels == 1, :].sum(axis=0)\n        self._squared_sums += (bbox_targets[labels == 1, :] ** 2).sum(axis=0)\n        self._counts += np.sum(labels == 1)\n        means = self._sums / self._counts\n        stds = np.sqrt(self._squared_sums / self._counts - means ** 2)\n        print('means:')\n        print(means)\n        print('stdevs:')\n        print(stds)\n    labels = _unmap(labels, total_anchors, inds_inside, fill=-1)\n    bbox_targets = _unmap(bbox_targets, total_anchors, inds_inside, fill=0)\n    bbox_inside_weights = _unmap(bbox_inside_weights, total_anchors, inds_inside, fill=0)\n    bbox_outside_weights = _unmap(bbox_outside_weights, total_anchors, inds_inside, fill=0)\n    if DEBUG:\n        print('rpn: max max_overlap', np.max(max_overlaps))\n        print('rpn: num_positive', np.sum(labels == 1))\n        print('rpn: num_negative', np.sum(labels == 0))\n        self._fg_sum += np.sum(labels == 1)\n        self._bg_sum += np.sum(labels == 0)\n        self._count += 1\n        print('rpn: num_positive avg', self._fg_sum / self._count)\n        print('rpn: num_negative avg', self._bg_sum / self._count)\n    labels = labels.reshape((1, height, width, A)).transpose(0, 3, 1, 2)\n    labels = labels.reshape((1, 1, A * height, width))\n    top[0] = labels\n    bbox_targets = bbox_targets.reshape((1, height, width, A * 4)).transpose(0, 3, 1, 2)\n    top[1] = bbox_targets\n    bbox_inside_weights = bbox_inside_weights.reshape((1, height, width, A * 4)).transpose(0, 3, 1, 2)\n    assert bbox_inside_weights.shape[2] == height\n    assert bbox_inside_weights.shape[3] == width\n    top[2] = bbox_inside_weights\n    bbox_outside_weights = bbox_outside_weights.reshape((1, height, width, A * 4)).transpose(0, 3, 1, 2)\n    assert bbox_outside_weights.shape[2] == height\n    assert bbox_outside_weights.shape[3] == width\n    top[3] = bbox_outside_weights",
            "def forward(self, bottom, top):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    height = bottom[0].shape[0]\n    width = bottom[0].shape[1]\n    gt_boxes = bottom[1]\n    im_info = bottom[2]\n    if DEBUG:\n        print('')\n        print('im_size: ({}, {})'.format(im_info[0], im_info[1]))\n        print('scale: {}'.format(im_info[2]))\n        print('height, width: ({}, {})'.format(height, width))\n        print('rpn: gt_boxes.shape', gt_boxes.shape)\n        print('rpn: gt_boxes', gt_boxes)\n    shift_x = np.arange(0, width) * self._feat_stride\n    shift_y = np.arange(0, height) * self._feat_stride\n    (shift_x, shift_y) = np.meshgrid(shift_x, shift_y)\n    shifts = np.vstack((shift_x.ravel(), shift_y.ravel(), shift_x.ravel(), shift_y.ravel())).transpose()\n    A = self._num_anchors\n    K = shifts.shape[0]\n    all_anchors = self._anchors.reshape((1, A, 4)) + shifts.reshape((1, K, 4)).transpose((1, 0, 2))\n    all_anchors = all_anchors.reshape((K * A, 4))\n    total_anchors = int(K * A)\n    inds_inside = np.where((all_anchors[:, 0] >= -self._allowed_border) & (all_anchors[:, 1] >= -self._allowed_border) & (all_anchors[:, 2] < im_info[0] + self._allowed_border) & (all_anchors[:, 3] < im_info[1] + self._allowed_border))[0]\n    if DEBUG:\n        print('total_anchors', total_anchors)\n        print('inds_inside', len(inds_inside))\n    anchors = all_anchors[inds_inside, :]\n    if DEBUG:\n        print('anchors.shape', anchors.shape)\n    labels = np.empty((len(inds_inside),), dtype=np.float32)\n    labels.fill(-1)\n    overlaps = calculate_bb_overlap(np.ascontiguousarray(anchors, dtype=np.float), np.ascontiguousarray(gt_boxes, dtype=np.float))\n    argmax_overlaps = overlaps.argmax(axis=1)\n    max_overlaps = overlaps[np.arange(len(inds_inside)), argmax_overlaps]\n    gt_argmax_overlaps = overlaps.argmax(axis=0)\n    gt_max_overlaps = overlaps[gt_argmax_overlaps, np.arange(overlaps.shape[1])]\n    gt_argmax_overlaps = np.where(overlaps == gt_max_overlaps)[0]\n    labels[max_overlaps < self.RPN_NEGATIVE_OVERLAP] = 0\n    labels[gt_argmax_overlaps] = 1\n    labels[max_overlaps >= self.RPN_POSITIVE_OVERLAP] = 1\n    if DEBUG:\n        print('rpn: max max_overlap', np.max(max_overlaps))\n        print('rpn: num_positive', np.sum(labels == 1))\n        print('rpn: num_negative', np.sum(labels == 0))\n    num_fg = int(self.RPN_FG_FRACTION * self.RPN_BATCHSIZE)\n    fg_inds = np.where(labels == 1)[0]\n    if len(fg_inds) > num_fg:\n        disable_inds = npr.choice(fg_inds, size=len(fg_inds) - num_fg, replace=False)\n        labels[disable_inds] = -1\n    num_bg = self.RPN_BATCHSIZE - np.sum(labels == 1)\n    bg_inds = np.where(labels == 0)[0]\n    if len(bg_inds) > num_bg:\n        disable_inds = npr.choice(bg_inds, size=len(bg_inds) - num_bg, replace=False)\n        labels[disable_inds] = -1\n    bbox_targets = np.zeros((len(inds_inside), 4), dtype=np.float32)\n    bbox_targets = _compute_targets(anchors, gt_boxes[argmax_overlaps, :])\n    bbox_inside_weights = np.zeros((len(inds_inside), 4), dtype=np.float32)\n    bbox_inside_weights[labels == 1, :] = np.array(self.RPN_BBOX_INSIDE_WEIGHTS)\n    bbox_outside_weights = np.zeros((len(inds_inside), 4), dtype=np.float32)\n    if self.RPN_POSITIVE_WEIGHT < 0:\n        num_examples = np.sum(labels >= 0)\n        positive_weights = np.ones((1, 4)) * 1.0 / num_examples\n        negative_weights = np.ones((1, 4)) * 1.0 / num_examples\n    else:\n        assert (self.RPN_POSITIVE_WEIGHT > 0) & (self.RPN_POSITIVE_WEIGHT < 1)\n        positive_weights = self.RPN_POSITIVE_WEIGHT / np.sum(labels == 1)\n        negative_weights = (1.0 - self.RPN_POSITIVE_WEIGHT) / np.sum(labels == 0)\n    bbox_outside_weights[labels == 1, :] = positive_weights\n    bbox_outside_weights[labels == 0, :] = negative_weights\n    if DEBUG:\n        self._sums += bbox_targets[labels == 1, :].sum(axis=0)\n        self._squared_sums += (bbox_targets[labels == 1, :] ** 2).sum(axis=0)\n        self._counts += np.sum(labels == 1)\n        means = self._sums / self._counts\n        stds = np.sqrt(self._squared_sums / self._counts - means ** 2)\n        print('means:')\n        print(means)\n        print('stdevs:')\n        print(stds)\n    labels = _unmap(labels, total_anchors, inds_inside, fill=-1)\n    bbox_targets = _unmap(bbox_targets, total_anchors, inds_inside, fill=0)\n    bbox_inside_weights = _unmap(bbox_inside_weights, total_anchors, inds_inside, fill=0)\n    bbox_outside_weights = _unmap(bbox_outside_weights, total_anchors, inds_inside, fill=0)\n    if DEBUG:\n        print('rpn: max max_overlap', np.max(max_overlaps))\n        print('rpn: num_positive', np.sum(labels == 1))\n        print('rpn: num_negative', np.sum(labels == 0))\n        self._fg_sum += np.sum(labels == 1)\n        self._bg_sum += np.sum(labels == 0)\n        self._count += 1\n        print('rpn: num_positive avg', self._fg_sum / self._count)\n        print('rpn: num_negative avg', self._bg_sum / self._count)\n    labels = labels.reshape((1, height, width, A)).transpose(0, 3, 1, 2)\n    labels = labels.reshape((1, 1, A * height, width))\n    top[0] = labels\n    bbox_targets = bbox_targets.reshape((1, height, width, A * 4)).transpose(0, 3, 1, 2)\n    top[1] = bbox_targets\n    bbox_inside_weights = bbox_inside_weights.reshape((1, height, width, A * 4)).transpose(0, 3, 1, 2)\n    assert bbox_inside_weights.shape[2] == height\n    assert bbox_inside_weights.shape[3] == width\n    top[2] = bbox_inside_weights\n    bbox_outside_weights = bbox_outside_weights.reshape((1, height, width, A * 4)).transpose(0, 3, 1, 2)\n    assert bbox_outside_weights.shape[2] == height\n    assert bbox_outside_weights.shape[3] == width\n    top[3] = bbox_outside_weights"
        ]
    },
    {
        "func_name": "backward",
        "original": "def backward(self, top, propagate_down, bottom):\n    \"\"\"This layer does not propagate gradients.\"\"\"\n    pass",
        "mutated": [
            "def backward(self, top, propagate_down, bottom):\n    if False:\n        i = 10\n    'This layer does not propagate gradients.'\n    pass",
            "def backward(self, top, propagate_down, bottom):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'This layer does not propagate gradients.'\n    pass",
            "def backward(self, top, propagate_down, bottom):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'This layer does not propagate gradients.'\n    pass",
            "def backward(self, top, propagate_down, bottom):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'This layer does not propagate gradients.'\n    pass",
            "def backward(self, top, propagate_down, bottom):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'This layer does not propagate gradients.'\n    pass"
        ]
    },
    {
        "func_name": "reshape",
        "original": "def reshape(self, bottom, top):\n    \"\"\"Reshaping happens during the call to forward.\"\"\"\n    pass",
        "mutated": [
            "def reshape(self, bottom, top):\n    if False:\n        i = 10\n    'Reshaping happens during the call to forward.'\n    pass",
            "def reshape(self, bottom, top):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Reshaping happens during the call to forward.'\n    pass",
            "def reshape(self, bottom, top):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Reshaping happens during the call to forward.'\n    pass",
            "def reshape(self, bottom, top):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Reshaping happens during the call to forward.'\n    pass",
            "def reshape(self, bottom, top):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Reshaping happens during the call to forward.'\n    pass"
        ]
    },
    {
        "func_name": "_unmap",
        "original": "def _unmap(data, count, inds, fill=0):\n    \"\"\" Unmap a subset of item (data) back to the original set of items (of\n    size count) \"\"\"\n    if len(data.shape) == 1:\n        ret = np.empty((count,), dtype=np.float32)\n        ret.fill(fill)\n        ret[inds] = data\n    else:\n        ret = np.empty((count,) + data.shape[1:], dtype=np.float32)\n        ret.fill(fill)\n        ret[inds, :] = data\n    return ret",
        "mutated": [
            "def _unmap(data, count, inds, fill=0):\n    if False:\n        i = 10\n    ' Unmap a subset of item (data) back to the original set of items (of\\n    size count) '\n    if len(data.shape) == 1:\n        ret = np.empty((count,), dtype=np.float32)\n        ret.fill(fill)\n        ret[inds] = data\n    else:\n        ret = np.empty((count,) + data.shape[1:], dtype=np.float32)\n        ret.fill(fill)\n        ret[inds, :] = data\n    return ret",
            "def _unmap(data, count, inds, fill=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Unmap a subset of item (data) back to the original set of items (of\\n    size count) '\n    if len(data.shape) == 1:\n        ret = np.empty((count,), dtype=np.float32)\n        ret.fill(fill)\n        ret[inds] = data\n    else:\n        ret = np.empty((count,) + data.shape[1:], dtype=np.float32)\n        ret.fill(fill)\n        ret[inds, :] = data\n    return ret",
            "def _unmap(data, count, inds, fill=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Unmap a subset of item (data) back to the original set of items (of\\n    size count) '\n    if len(data.shape) == 1:\n        ret = np.empty((count,), dtype=np.float32)\n        ret.fill(fill)\n        ret[inds] = data\n    else:\n        ret = np.empty((count,) + data.shape[1:], dtype=np.float32)\n        ret.fill(fill)\n        ret[inds, :] = data\n    return ret",
            "def _unmap(data, count, inds, fill=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Unmap a subset of item (data) back to the original set of items (of\\n    size count) '\n    if len(data.shape) == 1:\n        ret = np.empty((count,), dtype=np.float32)\n        ret.fill(fill)\n        ret[inds] = data\n    else:\n        ret = np.empty((count,) + data.shape[1:], dtype=np.float32)\n        ret.fill(fill)\n        ret[inds, :] = data\n    return ret",
            "def _unmap(data, count, inds, fill=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Unmap a subset of item (data) back to the original set of items (of\\n    size count) '\n    if len(data.shape) == 1:\n        ret = np.empty((count,), dtype=np.float32)\n        ret.fill(fill)\n        ret[inds] = data\n    else:\n        ret = np.empty((count,) + data.shape[1:], dtype=np.float32)\n        ret.fill(fill)\n        ret[inds, :] = data\n    return ret"
        ]
    },
    {
        "func_name": "_compute_targets",
        "original": "def _compute_targets(ex_rois, gt_rois):\n    \"\"\"Compute bounding-box regression targets for an image.\"\"\"\n    assert ex_rois.shape[0] == gt_rois.shape[0]\n    assert ex_rois.shape[1] == 4\n    return bbox_transform(ex_rois, gt_rois[:, :4]).astype(np.float32, copy=False)",
        "mutated": [
            "def _compute_targets(ex_rois, gt_rois):\n    if False:\n        i = 10\n    'Compute bounding-box regression targets for an image.'\n    assert ex_rois.shape[0] == gt_rois.shape[0]\n    assert ex_rois.shape[1] == 4\n    return bbox_transform(ex_rois, gt_rois[:, :4]).astype(np.float32, copy=False)",
            "def _compute_targets(ex_rois, gt_rois):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute bounding-box regression targets for an image.'\n    assert ex_rois.shape[0] == gt_rois.shape[0]\n    assert ex_rois.shape[1] == 4\n    return bbox_transform(ex_rois, gt_rois[:, :4]).astype(np.float32, copy=False)",
            "def _compute_targets(ex_rois, gt_rois):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute bounding-box regression targets for an image.'\n    assert ex_rois.shape[0] == gt_rois.shape[0]\n    assert ex_rois.shape[1] == 4\n    return bbox_transform(ex_rois, gt_rois[:, :4]).astype(np.float32, copy=False)",
            "def _compute_targets(ex_rois, gt_rois):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute bounding-box regression targets for an image.'\n    assert ex_rois.shape[0] == gt_rois.shape[0]\n    assert ex_rois.shape[1] == 4\n    return bbox_transform(ex_rois, gt_rois[:, :4]).astype(np.float32, copy=False)",
            "def _compute_targets(ex_rois, gt_rois):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute bounding-box regression targets for an image.'\n    assert ex_rois.shape[0] == gt_rois.shape[0]\n    assert ex_rois.shape[1] == 4\n    return bbox_transform(ex_rois, gt_rois[:, :4]).astype(np.float32, copy=False)"
        ]
    },
    {
        "func_name": "calculate_bb_overlap",
        "original": "def calculate_bb_overlap(rp, gt):\n    \"\"\"\n    Returns a matrix of overlaps between every possible pair of the two provided\n    bounding box lists.\n\n    Arguments:\n        rp (list): an array of region proposals, shape (R, 4)\n        gt (list): an array of ground truth ROIs, shape (G, 4)\n\n    Outputs:\n        overlaps: a matrix of overlaps between 2 list, shape (R, G)\n    \"\"\"\n    R = rp.shape[0]\n    G = gt.shape[0]\n    overlaps = np.zeros((R, G), dtype=np.float32)\n    for g in range(G):\n        gt_box_area = float((gt[g, 2] - gt[g, 0] + 1) * (gt[g, 3] - gt[g, 1] + 1))\n        for r in range(R):\n            iw = float(min(rp[r, 2], gt[g, 2]) - max(rp[r, 0], gt[g, 0]) + 1)\n            if iw > 0:\n                ih = float(min(rp[r, 3], gt[g, 3]) - max(rp[r, 1], gt[g, 1]) + 1)\n                if ih > 0:\n                    ua = float((rp[r, 2] - rp[r, 0] + 1) * (rp[r, 3] - rp[r, 1] + 1) + gt_box_area - iw * ih)\n                    overlaps[r, g] = iw * ih / ua\n    return overlaps",
        "mutated": [
            "def calculate_bb_overlap(rp, gt):\n    if False:\n        i = 10\n    '\\n    Returns a matrix of overlaps between every possible pair of the two provided\\n    bounding box lists.\\n\\n    Arguments:\\n        rp (list): an array of region proposals, shape (R, 4)\\n        gt (list): an array of ground truth ROIs, shape (G, 4)\\n\\n    Outputs:\\n        overlaps: a matrix of overlaps between 2 list, shape (R, G)\\n    '\n    R = rp.shape[0]\n    G = gt.shape[0]\n    overlaps = np.zeros((R, G), dtype=np.float32)\n    for g in range(G):\n        gt_box_area = float((gt[g, 2] - gt[g, 0] + 1) * (gt[g, 3] - gt[g, 1] + 1))\n        for r in range(R):\n            iw = float(min(rp[r, 2], gt[g, 2]) - max(rp[r, 0], gt[g, 0]) + 1)\n            if iw > 0:\n                ih = float(min(rp[r, 3], gt[g, 3]) - max(rp[r, 1], gt[g, 1]) + 1)\n                if ih > 0:\n                    ua = float((rp[r, 2] - rp[r, 0] + 1) * (rp[r, 3] - rp[r, 1] + 1) + gt_box_area - iw * ih)\n                    overlaps[r, g] = iw * ih / ua\n    return overlaps",
            "def calculate_bb_overlap(rp, gt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns a matrix of overlaps between every possible pair of the two provided\\n    bounding box lists.\\n\\n    Arguments:\\n        rp (list): an array of region proposals, shape (R, 4)\\n        gt (list): an array of ground truth ROIs, shape (G, 4)\\n\\n    Outputs:\\n        overlaps: a matrix of overlaps between 2 list, shape (R, G)\\n    '\n    R = rp.shape[0]\n    G = gt.shape[0]\n    overlaps = np.zeros((R, G), dtype=np.float32)\n    for g in range(G):\n        gt_box_area = float((gt[g, 2] - gt[g, 0] + 1) * (gt[g, 3] - gt[g, 1] + 1))\n        for r in range(R):\n            iw = float(min(rp[r, 2], gt[g, 2]) - max(rp[r, 0], gt[g, 0]) + 1)\n            if iw > 0:\n                ih = float(min(rp[r, 3], gt[g, 3]) - max(rp[r, 1], gt[g, 1]) + 1)\n                if ih > 0:\n                    ua = float((rp[r, 2] - rp[r, 0] + 1) * (rp[r, 3] - rp[r, 1] + 1) + gt_box_area - iw * ih)\n                    overlaps[r, g] = iw * ih / ua\n    return overlaps",
            "def calculate_bb_overlap(rp, gt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns a matrix of overlaps between every possible pair of the two provided\\n    bounding box lists.\\n\\n    Arguments:\\n        rp (list): an array of region proposals, shape (R, 4)\\n        gt (list): an array of ground truth ROIs, shape (G, 4)\\n\\n    Outputs:\\n        overlaps: a matrix of overlaps between 2 list, shape (R, G)\\n    '\n    R = rp.shape[0]\n    G = gt.shape[0]\n    overlaps = np.zeros((R, G), dtype=np.float32)\n    for g in range(G):\n        gt_box_area = float((gt[g, 2] - gt[g, 0] + 1) * (gt[g, 3] - gt[g, 1] + 1))\n        for r in range(R):\n            iw = float(min(rp[r, 2], gt[g, 2]) - max(rp[r, 0], gt[g, 0]) + 1)\n            if iw > 0:\n                ih = float(min(rp[r, 3], gt[g, 3]) - max(rp[r, 1], gt[g, 1]) + 1)\n                if ih > 0:\n                    ua = float((rp[r, 2] - rp[r, 0] + 1) * (rp[r, 3] - rp[r, 1] + 1) + gt_box_area - iw * ih)\n                    overlaps[r, g] = iw * ih / ua\n    return overlaps",
            "def calculate_bb_overlap(rp, gt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns a matrix of overlaps between every possible pair of the two provided\\n    bounding box lists.\\n\\n    Arguments:\\n        rp (list): an array of region proposals, shape (R, 4)\\n        gt (list): an array of ground truth ROIs, shape (G, 4)\\n\\n    Outputs:\\n        overlaps: a matrix of overlaps between 2 list, shape (R, G)\\n    '\n    R = rp.shape[0]\n    G = gt.shape[0]\n    overlaps = np.zeros((R, G), dtype=np.float32)\n    for g in range(G):\n        gt_box_area = float((gt[g, 2] - gt[g, 0] + 1) * (gt[g, 3] - gt[g, 1] + 1))\n        for r in range(R):\n            iw = float(min(rp[r, 2], gt[g, 2]) - max(rp[r, 0], gt[g, 0]) + 1)\n            if iw > 0:\n                ih = float(min(rp[r, 3], gt[g, 3]) - max(rp[r, 1], gt[g, 1]) + 1)\n                if ih > 0:\n                    ua = float((rp[r, 2] - rp[r, 0] + 1) * (rp[r, 3] - rp[r, 1] + 1) + gt_box_area - iw * ih)\n                    overlaps[r, g] = iw * ih / ua\n    return overlaps",
            "def calculate_bb_overlap(rp, gt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns a matrix of overlaps between every possible pair of the two provided\\n    bounding box lists.\\n\\n    Arguments:\\n        rp (list): an array of region proposals, shape (R, 4)\\n        gt (list): an array of ground truth ROIs, shape (G, 4)\\n\\n    Outputs:\\n        overlaps: a matrix of overlaps between 2 list, shape (R, G)\\n    '\n    R = rp.shape[0]\n    G = gt.shape[0]\n    overlaps = np.zeros((R, G), dtype=np.float32)\n    for g in range(G):\n        gt_box_area = float((gt[g, 2] - gt[g, 0] + 1) * (gt[g, 3] - gt[g, 1] + 1))\n        for r in range(R):\n            iw = float(min(rp[r, 2], gt[g, 2]) - max(rp[r, 0], gt[g, 0]) + 1)\n            if iw > 0:\n                ih = float(min(rp[r, 3], gt[g, 3]) - max(rp[r, 1], gt[g, 1]) + 1)\n                if ih > 0:\n                    ua = float((rp[r, 2] - rp[r, 0] + 1) * (rp[r, 3] - rp[r, 1] + 1) + gt_box_area - iw * ih)\n                    overlaps[r, g] = iw * ih / ua\n    return overlaps"
        ]
    }
]