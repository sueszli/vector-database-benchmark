import paddle
from paddle.base.core import VarDesc
from paddle.base.data_feeder import check_type, check_variable_and_dtype
from paddle.base.framework import Variable, in_dygraph_mode
from paddle.base.layer_helper import LayerHelper
from paddle.base.layers.layer_function_generator import templatedoc
__all__ = []

@templatedoc()
def sequence_conv(input, num_filters, filter_size=3, filter_stride=1, padding=True, padding_start=None, bias_attr=None, param_attr=None, act=None, name=None):
    if False:
        return 10
    "\n\n    Note:\n        Only receives Tensor as input. If your input is Tensor, please use conv2d Op.(base.layers.** :ref:`api_paddle_nn_functional_conv2d` ).\n\n    This operator receives input sequences with variable length and other convolutional\n    configuration parameters(num_filters, filter_size) to apply the convolution operation.\n    It fills all-zero padding data on both sides of the sequence by default to ensure that\n    the output is the same length as the input. You can customize the padding behavior by\n    configuring the parameter :attr:`padding\\_start` .\n\n    **Warning:** the parameter :attr:`padding` take no effect and will be deprecated in the future.\n\n    .. code-block:: text\n\n            Here we will illustrate the details of the padding operation:\n            For a mini-batch of 2 variable lengths sentences, containing 3, and 1 time-steps:\n            Assumed input (X) is a [4, N] float Tensor, and for the sake of simplicity, we assume N=2.\n            input.data = [[1, 1],\n                          [2, 2],\n                          [3, 3],\n                          [4, 4]]\n\n            This is to say that input (X) has 4 words and the dimension of each word\n            representation is 2.\n\n            * Case1:\n\n                If padding_start is -1 and filter_size is 3.\n                The length of padding data is calculated as follows:\n                up_pad_len = max(0, -padding_start) = 1\n                down_pad_len = max(0, filter_size + padding_start - 1) = 1\n\n                The output of the input sequence after padding is:\n                data_aftet_padding = [[0, 0, 1, 1, 2, 2],\n                                      [1, 1, 2, 2, 3, 3],\n                                      [2, 2, 3, 3, 0, 0],\n                                      [0, 0, 4, 4, 0, 0]]\n\n                It will be multiplied by the filter weight to get the final output.\n                Assume num_filters = 3\n                output.data = [[ 0.3234, -0.2334,  0.7433],\n                               [ 0.5646,  0.9464, -0.1223],\n                               [-0.1343,  0.5653,  0.4555],\n                               [ 0.9954, -0.1234, -0.1234]]\n                output.shape = [4, 3]     # 3 = num_filters\n                output.lod = [[0, 3, 4]]  # Remain the same\n\n\n    Args:\n        input (Tensor): Tensor with shape :math:`(M, K)`, where M is the total time-step of mini-batch\n            and K is hidden_size of input. Only lod_level of 1 is supported. The data type should be float32 or\n            float64.\n        num_filters (int): the number of filters.\n        filter_size (int): the height of filter. Specified filter width is not supported, the width is\n            hidden_size by default. Default: 3.\n        filter_stride (int, optional): stride of the filter. Currently only supports :attr:`stride` = 1.\n        padding (bool, optional): the parameter :attr:`padding` take no effect and will be discarded in the\n            future. Currently, it will always pad input to make sure the length of the output is\n            the same as input whether :attr:`padding` is set true or false. Because the length of\n            input sequence may be shorter than :attr:`filter\\_size`, which will cause the convolution\n            result to not be computed correctly. These padding data will not be trainable or updated\n            while training. Default: True.\n        padding_start (int): It is used to indicate the start index for padding the input\n            sequence, which can be negative. The negative number means to pad\n            :attr:`|padding_start|` time-steps of all-zero data at the beginning of each instance.\n            The positive number means to skip :attr:`padding_start` time-steps of each instance,\n            and it will pad :math:`filter\\_size + padding\\_start - 1` time-steps of all-zero data\n            at the end of the sequence to ensure that the output is the same length as the input.\n            If set None, the same length :math:`\\\\frac{filter\\_size}{2}` of data will be filled\n            on both sides of the sequence. If set 0, the length of :math:`filter\\_size - 1` data\n            is padded at the end of each input sequence. Default: None.\n        bias_attr (ParamAttr): To specify the bias parameter property. Default: None, which means the\n            default bias parameter property is used. See usage for details in :ref:`api_paddle_ParamAttr` .\n        param_attr (ParamAttr): To specify the weight parameter property. Default: None, which means the\n            default weight parameter property is used. See usage for details in :ref:`api_paddle_ParamAttr` .\n        act (str): Activation to be applied to the output of this layer, such as tanh, softmax,\n            sigmoid, relu. For more information, please refer to :ref:`api_guide_activations_en` . Default: None.\n        name (str, optional): The default value is None.  Normally there is no need for user to set this property.\n            For more information, please refer to :ref:`api_guide_Name` .\n\n    Returns:\n        Tensor: Tensor with the same length as input. The data type is float32 or float64, which is same as input.\n\n    Examples:\n\n        .. code-block:: python\n\n            >>> import paddle\n            >>> paddle.enable_static()\n\n            >>> x = paddle.static.data(name='x', shape=[-1, 10], dtype='float32', lod_level=1)\n            >>> x_conved = paddle.static.nn.sequence_conv(input=x, num_filters=2, filter_size=3, padding_start=-1)\n    "
    assert not in_dygraph_mode(), 'sequence layer is not supported in dygraph mode yet.'
    check_variable_and_dtype(input, 'input', ['float32', 'float64'], 'sequence_conv')
    helper = LayerHelper('sequence_conv', **locals())
    dtype = helper.input_dtype()
    filter_shape = [filter_size * input.shape[1], num_filters]
    filter_param = helper.create_parameter(attr=helper.param_attr, shape=filter_shape, dtype=dtype)
    pre_bias = helper.create_variable_for_type_inference(dtype)
    if padding_start is None:
        padding_start = -int(filter_size // 2)
    helper.append_op(type='sequence_conv', inputs={'X': [input], 'Filter': [filter_param]}, outputs={'Out': pre_bias}, attrs={'contextStride': filter_stride, 'contextStart': padding_start, 'contextLength': filter_size})
    pre_act = helper.append_bias_op(pre_bias)
    return helper.append_activation(pre_act)

def sequence_softmax(input, use_cudnn=False, name=None):
    if False:
        i = 10
        return i + 15
    "\n\n    Note:\n        The input type of the OP must be Tensor. For Tensor, use:** :ref:`api_paddle_nn_functional_softmax`\n\n    A LoD-tensor can be regarded as several sequences, and this op apply softmax algo on each sequence.\n    The shape of input Tensor can be :math:`[N, 1]` or :math:`[N]`, where :math:`N`\n    is the sum of the length of all sequences. Recommended usage: :math:`[N]`.\n\n    For i-th sequence in a mini-batch:\n\n    .. math::\n\n        Out(X[lod[i]:lod[i+1]], :) = \\\\frac{\\exp(X[lod[i]:lod[i+1], :])}{\\sum(\\exp(X[lod[i]:lod[i+1], :]))}\n\n    For example, for a LoD-Tensor with 6 sequences ([3, 2, 4, 1, 2, 3] - sequence length list in order),\n    the lod in the runtime is [[0, 3, 5, 9, 10, 12, 15]],\n    then softmax will be computed among :math:`X[0:3,:],X[3:5,:],X[5:9,:],X[9:10,:],X[10:12,:],X[12:15,:]`,\n    and :math:`N` turns out to be 15.\n\n    .. code-block:: text\n\n        *Case 1:\n\n            Given:\n                input.data = [0.7, 1, 0.6,\n                              1.5, 1.1,\n                              1.2, 0.2, 0.6, 1.9,\n                              3.1,\n                              2.5, 0.8,\n                              0.1, 2.4, 1.3]\n                input.lod = [[0, 3, 5, 9, 10, 12, 15]]\n            then:\n                 output.data = [0.30724832, 0.41474187, 0.2780098,\n                                0.59868765, 0.40131235,\n                                0.2544242, 0.09359743, 0.13963096, 0.5123474,\n                                1.,\n                                0.84553474, 0.15446526,\n                                0.06995796, 0.69777346, 0.23226859]\n                 output.lod = [[0, 3, 5, 9, 10, 12, 15]]\n\n\n    Args:\n        input (Tensor):A Tensor with shape of  :math:`[N, 1]` or  :math:`[N]`, Recommended usage: :math:`[N]`.\n                         Supported data types: float32, float64.\n        use_cudnn (bool, optional): Use cudnn kernel or not. Effective only when the cudnn version of the paddle\n                                    library is installed and GPU is used for training or reasoning. Default: False.\n        name (str, optional): The default value is None. Normally there is no need for user to set this property.\n                              For more information, please refer to :ref:`api_guide_Name`\n\n    Returns:\n        Tensor: A LoD-Tensor which has the same shape and data type with input.\n\n    Examples:\n\n        .. code-block:: python\n\n            >>> import paddle\n            >>> paddle.enable_static()\n\n            >>> x = paddle.static.data(name='x', shape=[7, 1],\n                              dtype='float32', lod_level=1)\n            >>> x_sequence_softmax_1 = paddle.static.nn.sequence_softmax(input=x)\n\n            >>> y = paddle.static.data(name='y', shape=[7],\n            ...     dtype='float32', lod_level=1)\n            >>> x_sequence_softmax_2 = paddle.static.nn.sequence_softmax(input=y)\n    "
    assert not in_dygraph_mode(), 'sequence layer is not supported in dygraph mode yet.'
    helper = LayerHelper('sequence_softmax', **locals())
    check_variable_and_dtype(input, 'input', ['float32', 'float64'], 'sequence_softmax')
    dtype = helper.input_dtype()
    softmax_out = helper.create_variable_for_type_inference(dtype)
    helper.append_op(type='sequence_softmax', inputs={'X': input}, outputs={'Out': softmax_out}, attrs={'use_cudnn': use_cudnn})
    return softmax_out

def sequence_pool(input, pool_type, is_test=False, pad_value=0.0):
    if False:
        return 10
    "\n\n    Note:\n        Only receives Tensor as input. If your input is Tensor, please use pool2d Op.(static.nn.** :ref:`api_paddle_nn_functional_avg_pool2d` or :ref:`api_paddle_nn_functional_max_pool2d` ).\n\n    This operator only supports Tensor as input. It will apply specified pooling\n    operation on the input Tensor. It pools features of all time-steps of each\n    sequence at the last lod_level using :attr:`pool_type` mentioned in the parameters,\n    such as sum, average, sqrt, etc.\n\n    It supports six pool_type:\n\n    - average: :math:`Out[i] = \\\\frac{\\sum_i X_i}{N}`\n    - sum:     :math:`Out[i] = \\sum_jX_{ij}`\n    - sqrt:    :math:`Out[i] = \\\\frac{\\sum_jX_{ij}}{\\sqrt{len(X_i)}}`\n    - max:     :math:`Out[i] = max(X_i)`\n    - last:    :math:`Out[i] = X_{N_i}`\n    - first:   :math:`Out[i]` = X_0\n\n    where :math:`N_i` is the length of i-th input sequence.\n\n    .. code-block:: text\n\n        Case 1:\n        input is a 1-level Tensor and pad_value = 0.0:\n            input.lod = [[0, 2, 5, 7, 7]]\n            input.data = [[1.], [3.], [2.], [4.], [6.], [5.], [1.]]\n            input.shape = [7, 1]\n\n        output is Tensor:\n            out.shape = [4, 1]\n            with condition out.shape[0] == len(x.lod[-1]) == 4\n\n        for different pool_type:\n            average: out.data = [[2.], [4.], [3.], [0.0]], where 2.=(1. + 3.)/2, 4.=(2. + 4. + 6.)/3, 3.=(5. + 1.)/2\n            sum    : out.data = [[4.], [12.], [6.], [0.0]], where 4.=1. + 3., 12.=2. + 4. + 6., 6.=5. + 1.\n            sqrt   : out.data = [[2.82], [6.93], [4.24], [0.0]], where 2.82=(1. + 3.)/sqrt(2), 6.93=(2. + 4. + 6.)/sqrt(3), 4.24=(5. + 1.)/sqrt(2)\n            max    : out.data = [[3.], [6.], [5.], [0.0]], where 3.=max(1., 3.), 6.=max(2., 4., 6.), 5.=max(5., 1.)\n            last   : out.data = [[3.], [6.], [1.], [0.0]], where 3.=last(1., 3.), 6.=last(2., 4., 6.), 1.=last(5., 1.)\n            first  : out.data = [[1.], [2.], [5.], [0.0]], where 1.=first(1., 3.), 2.=first(2., 4., 6.), 5.=first(5., 1.)\n\n            and all above [0.0] at last of out.data is padding data.\n\n        Case 2:\n        input is a 2-level Tensor containing 3 sequences with length info [2, 0, 3],\n        where 0 means empty sequence.\n        The first sequence contains 2 subsequence with length info [1, 2];\n        The last sequence contains 3 subsequence with length info [1, 0, 3].\n            input.lod = [[0, 2, 2, 5], [0, 1, 3, 4, 4, 7]]\n            input.data = [[1.], [3.], [2.], [4.], [6.], [5.], [1.]]\n            input.shape = [7, 1]\n\n        If pool_typ = sum, it will apply pooling on last lod_level [0, 1, 3, 4, 4, 7]. pad_value = 0.0\n        output is Tensor:\n            out.shape= [5, 1]\n            out.lod = [[0, 2, 2, 5]]\n            where out.shape[0] == len(x.lod[-1]) == 5\n            sum: out.data = [[1.], [5.], [4.], [0.0], [12.]]\n            where 1.=1., 5.=3. + 2., 4.=4., 0.0=pad_value, 12.=6. + 5. + 1.\n\n    Args:\n        input (variable): Tensor with lod_level no more than 2. The data type should be float32 or float64.\n        pool_type (str): The pooling type that supports average, sum, sqrt, max, last or first.\n        is_test (bool): Only works when :attr:`pool_type` is max. If set False, a temporary Tenosr maxIndex is\n            created to record the index information corresponding to the maximum value, which is used for backward\n            gradient calculation in the training phase. Default: False.\n        pad_value (float): Used to pad the pooling result for empty input sequence. Default: 0.0\n\n    Returns:\n        Tensor: Tensor after pooling with data type float32 or float64.\n\n    Examples:\n\n        .. code-block:: python\n\n            >>> import paddle\n            >>> paddle.enable_static()\n\n            >>> x = paddle.static.data(name='x', shape=[None, 10], dtype='float32', lod_level=1)\n            >>> avg_x = paddle.static.nn.sequence_pool(input=x, pool_type='average')\n            >>> sum_x = paddle.static.nn.sequence_pool(input=x, pool_type='sum')\n            >>> sqrt_x = paddle.static.nn.sequence_pool(input=x, pool_type='sqrt')\n            >>> max_x = paddle.static.nn.sequence_pool(input=x, pool_type='max')\n            >>> last_x = paddle.static.nn.sequence_pool(input=x, pool_type='last')\n            >>> first_x = paddle.static.nn.sequence_pool(input=x, pool_type='first')\n    "
    assert not in_dygraph_mode(), 'sequence layer is not supported in dygraph mode yet.'
    check_variable_and_dtype(input, 'input', ['float32', 'float64'], 'sequence_pool')
    helper = LayerHelper('sequence_pool', **locals())
    dtype = helper.input_dtype()
    pool_out = helper.create_variable_for_type_inference(dtype)
    max_index = helper.create_variable_for_type_inference(dtype)
    helper.append_op(type='sequence_pool', inputs={'X': input}, outputs={'Out': pool_out, 'MaxIndex': max_index}, attrs={'pooltype': pool_type.upper(), 'is_test': is_test, 'pad_value': pad_value})
    if pool_type == 'max':
        max_index.stop_gradient = True
    return pool_out

@templatedoc()
def sequence_concat(input, name=None):
    if False:
        return 10
    "\n\n    Note:\n        Only receives Tensor as input. If your input is Tensor, please use concat Op.(static.nn.** :ref:`api_paddle_concat` ).\n\n    This operator only supports Tensor as input. It concatenates the multiple Tensor from input by the LoD information,\n    and outputs the concatenated Tensor.\n\n    .. code-block:: text\n\n        input is a list of Tensor:\n            input = [x1, x2]\n        where:\n            x1.lod = [[0, 3, 5]]\n            x1.data = [[1], [2], [3], [4], [5]]\n            x1.shape = [5, 1]\n\n            x2.lod = [[0, 2, 4]]\n            x2.data = [[6], [7], [8], [9]]\n            x2.shape = [4, 1]\n        and should satisfy: len(x1.lod[0]) == len(x2.lod[0])\n\n        output is Tensor:\n            out.lod = [[0, 3+2, 5+4]]\n            out.data = [[1], [2], [3], [6], [7], [4], [5], [8], [9]]\n            out.shape = [9, 1]\n\n    Args:\n        input(list of Tensor): List of Tensor to be concatenated. The length of each Tensor should be same.\n            The data type can be float32, float64 or int64.\n        name(str, optional): The default value is None.  Normally there is no need for user to set this property.\n            For more information, please refer to :ref:`api_guide_Name` .\n\n    Returns:\n        Tensor: Output the concatenated Tensor. The data type is same as input.\n\n    Examples:\n        .. code-block:: python\n\n            >>> import paddle\n            >>> paddle.enable_static()\n\n            >>> x = paddle.static.data(name='x', shape=[-1, 10], dtype='float32', lod_level=1)\n            >>> y = paddle.static.data(name='y', shape=[-1, 10], dtype='float32', lod_level=1)\n            >>> out = paddle.static.nn.sequence_concat(input=[x, y])\n    "
    assert not in_dygraph_mode(), 'sequence layer is not supported in dygraph mode yet.'
    helper = LayerHelper('sequence_concat', **locals())
    check_type(input, 'input', list, 'paddle.static.nn.sequence_lod.sequence_concat')
    for (i, input_x) in enumerate(input):
        check_variable_and_dtype(input_x, 'input[' + str(i) + ']', ['int64', 'float32', 'float64'], 'paddle.static.nn.sequence_lod.sequence_concat')
    out = helper.create_variable_for_type_inference(dtype=helper.input_dtype())
    helper.append_op(type='sequence_concat', inputs={'X': input}, outputs={'Out': [out]})
    return out

def sequence_first_step(input):
    if False:
        return 10
    "\n\n    Only supports Tensor as input. Given the input Tensor, it will\n    select first time-step feature of each sequence as output.\n\n    .. code-block:: text\n\n       Case 1:\n        input is 1-level Tensor:\n            input.lod = [[0, 2, 5, 7]]\n            input.data = [[1.], [3.], [2.], [4.], [6.], [5.], [1.]]\n            input.shape = [7, 1]\n\n        output is a Tensor:\n            out.shape = [3, 1]\n            out.shape[0] == len(x.lod[-1]) == 3\n            out.data = [[1.], [2.], [5.]], where 1.=first(1., 3.), 2.=first(2., 4., 6.), 5.=first(5., 1.)\n\n        Case 2:\n        input is a 2-level Tensor containing 3 sequences with length info [2, 0, 3],\n        where 0 means empty sequence.\n        The first sequence contains 2 subsequence with length info [1, 2];\n        The last sequence contains 3 subsequence with length info [1, 0, 3].\n            input.lod = [[0, 2, 2, 5], [0, 1, 3, 4, 4, 7]]\n            input.data = [[1.], [3.], [2.], [4.], [6.], [5.], [1.]]\n            input.shape = [7, 1]\n\n        It will apply pooling on last lod_level [0, 1, 3, 4, 4, 7]. pad_value = 0.0\n        output is a Tensor:\n            out.shape= [5, 1]\n            out.lod = [[0, 2, 2, 5]]\n            out.shape[0] == len(x.lod[-1]) == 5\n            out.data = [[1.], [3.], [4.], [0.0], [6.]]\n            where 1.=first(1.), 3.=first(3., 2.), 4.=first(4.), 0.0 = pad_value, 6.=first(6., 5., 1.)\n\n    Args:\n        input(Tensor): Tensor with lod_level no more than 2. The data type should be float32 or float64.\n\n    Returns:\n        Tensor: Tensor consist of the sequence's first step vector. The data type is float32 or float64.\n\n    Examples:\n\n        .. code-block:: python\n\n            >>> import paddle\n            >>> paddle.enable_static()\n\n            >>> x = paddle.static.data(name='x', shape=[None, 10], dtype='float32', lod_level=1)\n            >>> x_first_step = paddle.static.nn.sequence_first_step(input=x)\n    "
    check_variable_and_dtype(input, 'input', ['float32', 'float64'], 'sequence_first_step')
    return sequence_pool(input=input, pool_type='first')

def sequence_last_step(input):
    if False:
        return 10
    "\n\n    Only supports Tensor as input. Given the input Tensor, it will\n    select last time-step feature of each sequence as output.\n\n    .. code-block:: text\n\n        Case 1:\n        input is 1-level Tensor:\n            input.lod = [[0, 2, 5, 7]]\n            input.data = [[1.], [3.], [2.], [4.], [6.], [5.], [1.]]\n            input.shape = [7, 1]\n\n        output is a Tensor:\n            out.shape = [3, 1]\n            out.shape[0] == len(x.lod[-1]) == 3\n            out.data = [[3.], [6.], [1.]], where 3.=last(1., 3.), 6.=last(2., 4., 6.), 1.=last(5., 1.)\n\n        Case 2:\n        input is a 2-level Tensor containing 3 sequences with length info [2, 0, 3],\n        where 0 means empty sequence.\n        The first sequence contains 2 subsequence with length info [1, 2];\n        The last sequence contains 3 subsequence with length info [1, 0, 3].\n            input.lod = [[0, 2, 2, 5], [0, 1, 3, 4, 4, 7]]\n            input.data = [[1.], [3.], [2.], [4.], [6.], [5.], [1.]]\n            input.shape = [7, 1]\n\n        It will apply pooling on last lod_level [0, 1, 3, 4, 4, 7]. pad_value = 0.0\n        output is a Tensor:\n            out.shape= [5, 1]\n            out.lod = [[0, 2, 2, 5]]\n            out.shape[0] == len(x.lod[-1]) == 5\n            out.data = [[1.], [2.], [4.], [0.0], [1.]]\n            where 1.=last(1.), 2.=last(3., 2.), 4.=last(4.), 0.0 = pad_value, 1=last(6., 5., 1.)\n\n\n    Args:\n        input(Tensor): Tensor with lod_level no more than 2. The data type should be float32.\n\n    Returns:\n        Tensor: Tensor consist of the sequence's last step vector. The data type is float32.\n\n    Examples:\n\n        .. code-block:: python\n\n            >>> import paddle\n            >>> paddle.enable_static()\n\n            >>> x = paddle.static.data(name='x', shape=[None, 10], dtype='float32', lod_level=1)\n            >>> x_last_step = paddle.static.nn.sequence_last_step(input=x)\n    "
    check_variable_and_dtype(input, 'input', ['float32', 'float64'], 'sequence_last_step')
    return sequence_pool(input=input, pool_type='last')

def sequence_slice(input, offset, length, name=None):
    if False:
        while True:
            i = 10
    '\n\n    **Sequence Slice Layer**\n\n    The layer crops a subsequence from given sequence with given start\n    offset and subsequence length.\n\n    It only supports sequence data (Tensor with lod_level equal to 1).\n\n    .. code-block:: text\n\n              - Case:\n\n            Given the input Tensor **input**:\n\n                input.data = [[a1, a2], [b1, b2], [c1, c2], [d1, d2], [e1, e2]],\n                input.lod = [[3, 2]],\n                input.dims = (5, 2),\n\n            with offset.data = [[0], [1]] and length.data = [[2], [1]],\n\n            the output Tensor will be\n\n                out.data = [[a1, a2], [b1, b2], [e1, e2]],\n                out.lod = [[2, 1]],\n                out.dims = (3, 2).\n\n    Note:\n          The first dimension size of **input**, **offset** and **length**\n          should be equal. The **offset** should start from 0.\n\n    Args:\n        input(Tensor): Tensor, The input Tensor which consists of the complete\n                         sequences.The data type can be float32, float64, int32 or int64\n        offset(Tensor): Tensor, The offset to slice each sequence. The data\n                         type is int32 or int64.\n        length(Tensor): Tensor, The length of each subsequence. The data\n                         type is int32 or int64.\n        name(str|None): The default value is None.  Normally there is no need\n                        for user to set this property.  For more information,\n                        please refer to :ref:`api_guide_Name`\n\n    Returns:\n        Tensor: The output subsequences.\n\n    Examples:\n\n        .. code-block:: python\n\n            >>> import paddle\n            >>> paddle.enable_static()\n\n            >>> import numpy as np\n            >>> seqs = paddle.static.data(name=\'x\', shape=[10, 5],\n            ...                  dtype=\'float32\', lod_level=1)\n            >>> offset = paddle.assign(np.array([[0, 1]]).astype("int32"))\n            >>> length = paddle.assign(np.array([[2, 1]]).astype("int32"))\n            ... subseqs = paddle.static.nn.sequence_slice(input=seqs, offset=offset,\n            ...                                       length=length)\n    '
    assert not in_dygraph_mode(), 'sequence layer is not supported in dygraph mode yet.'
    helper = LayerHelper('sequence_slice', **locals())
    check_variable_and_dtype(input, 'input', ['float32', 'float64', 'int32', 'int64'], 'sequence_slice')
    check_variable_and_dtype(offset, 'offset', ['int32', 'int64'], 'sequence_slice')
    check_variable_and_dtype(length, 'length', ['int32', 'int64'], 'sequence_slice')
    dtype = helper.input_dtype()
    out = helper.create_variable_for_type_inference(dtype)
    offset.stop_gradient = True
    length.stop_gradient = True
    helper.append_op(type='sequence_slice', inputs={'X': input, 'Offset': offset, 'Length': length}, outputs={'Out': out})
    return out

def sequence_expand(x, y, ref_level=-1, name=None):
    if False:
        print('Hello World!')
    "\n\n        Sequence Expand Layer. This layer will expand the input variable ``x`` \\\n        according to specified level ``ref_level`` lod of ``y``. Please note that \\\n        the lod level of ``x`` is at most 1. If the lod level of ``x`` is 1, than \\\n        the size of lod of ``x`` must be equal to the length of ``ref_level`` lod \\\n        of ``y``. If the lod level of ``x`` is 0, then the first dim of ``x`` should \\\n        be equal to the size of ``ref_level`` of ``y``. The rank of **x** is at least 2. \\\n        When rank of ``x`` is greater than 2, then it would be viewed as a 2-D tensor.\n\n    Note:\n\n        Please note that the input ``x`` should be Tensor or Tensor, \\\n        and input ``y`` must be Tensor.\n\n    **Following examples will explain how sequence_expand works:**\n\n    .. code-block:: text\n\n        Case 1\n\n        Consider 2 sequences [a][b] and [c][d], now we want to expand them to [a][b], [a][b], [c][d] and [c][d].\n        Sequence [a][b] expand twice and [c][d] expands twice, so the lod which according to is [2, 2].\n\n        Input x is a 1-level Tensor:\n            x.lod  = [[2,        2]]    #lod based on length may be easier to understand\n            x.data = [[a], [b], [c], [d]]\n            x.dims = [4, 1]\n\n        input y is a Tensor:\n            y.lod = [[2,    2],    #the 0th level lod, according to this level\n                     [3, 3, 1, 1]] #the 1st level lod, it has nothing to do with this level\n\n        ref_level: 0\n\n        then output is a 1-level Tensor out:\n            out.lod =  [[2,        2,        2,        2]]    #lod based on offset\n            out.data = [[a], [b], [a], [b], [c], [d], [c], [d]]\n            out.dims = [8, 1]\n\n\n        Case 2\n\n        Consider 3 sequences [a], [b], [c], now we want to expand them to [a][a], [c][c][c].\n        It's obvious that the lod info of expanded sequences is [2, 0, 3].\n\n        x is a Tensor:\n            x.data = [[a], [b], [c]]\n            x.dims = [3, 1]\n\n        y is a Tensor:\n            y.lod = [[2, 0, 3]]\n\n        ref_level: -1\n\n        then output is a 1-level Tensor:\n            out.data = [[a], [a], [c], [c], [c]]\n            out.dims = [5, 1]\n\n    Args:\n        x (Tensor): The input variable which is a Tensor or Tensor, with the \\\n            dims ``[M, K]``. The lod level is at most 1. The data type should be \\\n            float32, float64, int32 or int64.\n        y (Tensor): The input variable which is a Tensor, the lod level is \\\n            at least 1.\n        ref_level (int): Lod level of ``y`` to be referred by ``x``. If set to -1, \\\n                         refer the last level of lod.\n        name(str, optional): For detailed information, please refer \\\n            to :ref:`api_guide_Name`. Usually name is no need to set and \\\n            None by default.\n\n    Returns:\n            Tensor, The expanded variable which is a Tensor, with dims ``[N, K]``. \\\n            ``N`` depends on the lod info of ``x`` and ``y``. \\\n            The data type is same as input.\n\n    Examples:\n        .. code-block:: python\n\n            >>> import paddle\n            >>> from paddle import base\n            >>> paddle.enable_static()\n            >>> import numpy as np\n\n            >>> x = paddle.static.data(name='x', shape=[4, 1], dtype='float32')\n            >>> y = paddle.static.data(name='y', shape=[8, 1],\n            ...             dtype='float32', lod_level=1)\n            >>> out = paddle.static.nn.sequence_expand(x=x, y=y, ref_level=0)\n\n            >>> exe = paddle.static.Executor(base.CPUPlace())\n            >>> place = paddle.CPUPlace()\n\n            >>> np_data = np.array([[1], [2], [3], [4]]).astype('float32')\n            >>> x_lod_tensor = base.create_lod_tensor(np_data, [[2, 2]], place)\n            >>> print(x_lod_tensor)\n            - lod: {{0, 2, 4}}\n            - place: Place(cpu)\n            - shape: [4, 1]\n            - layout: NCHW\n            - dtype: float32\n            - data: [1 2 3 4]\n\n            >>> np_data = np.array([[1], [2], [3], [4], [5], [6], [7], [8]]).astype('float32')\n            >>> y_lod_tensor = base.create_lod_tensor(np_data, [[2, 2], [3,3,1,1]], place)\n            >>> print(y_lod_tensor)\n            - lod: {{0, 2, 4}{0, 3, 6, 7, 8}}\n            - place: Place(cpu)\n            - shape: [8, 1]\n            - layout: NCHW\n            - dtype: float32\n            - data: [1 2 3 4 5 6 7 8]\n\n            >>> out_main = exe.run(base.default_main_program(),\n            ...                 feed={'x': x_lod_tensor, 'y': y_lod_tensor},\n            ...                 fetch_list=[out], return_numpy=False)\n            >>> print(out_main[0])\n            - lod: {{0, 2, 4, 6, 8}}\n            - place: Place(cpu)\n            - shape: [8, 1]\n            - layout: NCHW\n            - dtype: float32\n            - data: [1 2 1 2 3 4 3 4]\n    "
    assert not in_dygraph_mode(), 'sequence layer is not supported in dygraph mode yet.'
    check_variable_and_dtype(x, 'x', ['float32', 'float64', 'int32', 'int64'], 'sequence_expand')
    helper = LayerHelper('sequence_expand', **locals())
    dtype = helper.input_dtype(input_param_name='x')
    tmp = helper.create_variable_for_type_inference(dtype)
    helper.append_op(type='sequence_expand', inputs={'X': x, 'Y': y}, outputs={'Out': tmp}, attrs={'ref_level': ref_level})
    return tmp

def sequence_expand_as(x, y, name=None):
    if False:
        while True:
            i = 10
    "\n\n        Sequence Expand As Layer. This OP will expand the input variable ``x`` \\\n        according to the zeroth level lod of ``y``. Current implementation requires \\\n        the level number of ``y``'s lod must be 1, and the first dimension of \\\n        ``x`` should be equal to the size of ``y``'s zeroth level lod, thus \\\n        the expanded Tensor has the same lod info as ``y``. The expanded result \\\n        has nothing to do with ``x``'s lod, so the lod of Input(X) is not considered.\n\n    Note:\n        Please note that the input ``x`` should be Tensor or Tensor, \\\n        and input ``y`` must be Tensor.\n\n    Following examples will explain how sequence_expand_as works:\n\n    .. code-block:: text\n\n        Case 1:\n\n        Consider 4 sequences [a], [b], [c], [d], now we want to expand them to [a][a][a], [b][b][b], [c] and [d].\n        It's obvious that the lod info of expanded sequences is [0, 3, 6, 7, 8].\n        Given a 1-level Tensor ``x``:\n            x.data = [[a], [b], [c], [d]]\n            x.dims = [4, 1]\n        and input ``y``\n            y.lod = [[3, 3, 1, 1]] #lod based on length may be easier to understand\n\n        then we get 1-level Tensor out:\n            Out.lod =  [[0,            3,              6,  7,  8]] #based on offset\n            Out.data = [[a], [a], [a], [b], [b], [b], [c], [d]]\n            Out.dims = [8, 1]\n\n\n        Case 2:\n\n        Given a common Tensor ``x``:\n            x.data = [[a, b], [c, d], [e, f]]\n            x.dims = [3, 2]\n        and input ``y``:\n            y.lod = [[0, 2, 3, 6]]\n\n        then we get a 1-level Tensor:\n            out.lod =  [[0,             2,     3,                    6]]\n            out.data = [[a, b], [a, b] [c, d], [e, f], [e, f], [e, f]]\n            out.dims = [6, 2]\n\n    Args:\n        x (Tensor): The input variable which is a Tensor or Tensor, with the \\\n            dims ``[M, K]``. The data type should be float32, float64, int32 \\\n            or int64.\n        y (Tensor): The input variable which is a Tensor with 1-level lod.\n        name (str, optional): For detailed information, please refer \\\n            to :ref:`api_guide_Name`. Usually name is no need to set and \\\n            None by default.\n\n    Returns:\n            Tensor, The expanded variable which is a Tensor with the dims ``[N, K]``. \\\n            ``N`` depends on the lod of ``y``, and the lod level must be 1. \\\n            The data type is same as input.\n\n    Examples:\n        .. code-block:: python\n\n            >>> import paddle\n            >>> import paddle.base as base\n            >>> paddle.enable_static()\n            >>> import numpy as np\n\n            >>> x = paddle.static.data(name='x', shape=[4, 1], dtype='float32')\n            >>> y = paddle.static.data(name='y', shape=[8, 1], dtype='float32', lod_level=1)\n            >>> out = paddle.static.nn.sequence_expand_as(x=x, y=y)\n\n            >>> exe = base.Executor(base.CPUPlace())\n            >>> place = base.CPUPlace()\n\n            >>> np_data = np.array([[1], [2], [3], [4]]).astype('float32')\n            >>> x_lod_tensor = base.create_lod_tensor(np_data, [[2, 2]], place)\n            >>> print(x_lod_tensor)\n            - lod: {{0, 2, 4}}\n            - place: Place(cpu)\n            - shape: [4, 1]\n            - layout: NCHW\n            - dtype: float32\n            - data: [1 2 3 4]\n\n            >>> np_data = np.array([[1], [2], [3], [4], [5], [6], [7], [8]]).astype('float32')\n            >>> y_lod_tensor = base.create_lod_tensor(np_data, [[3,3,1,1]], place)\n            >>> print(y_lod_tensor)\n            - lod: {{0, 3, 6, 7, 8}}\n            - place: Place(cpu)\n            - shape: [8, 1]\n            - layout: NCHW\n            - dtype: float32\n            - data: [1 2 3 4 5 6 7 8]\n\n            >>> out_main = exe.run(base.default_main_program(),\n            ...                 feed={'x': x_lod_tensor, 'y': y_lod_tensor},\n            ...                 fetch_list=[out], return_numpy=False)\n            >>> print(out_main[0])\n            - lod: {{0, 3, 6, 7, 8}}\n            - place: Place(cpu)\n            - shape: [8, 1]\n            - layout: NCHW\n            - dtype: float32\n            - data: [1 1 1 2 2 2 3 4]\n    "
    assert not in_dygraph_mode(), 'sequence layer is not supported in dygraph mode yet.'
    check_variable_and_dtype(x, 'x', ['float32', 'float64', 'int32', 'int64'], 'sequence_expand_as')
    check_type(y, 'y', Variable, 'sequence_expand_as')
    helper = LayerHelper('sequence_expand_as', **locals())
    dtype = helper.input_dtype(input_param_name='x')
    tmp = helper.create_variable_for_type_inference(dtype)
    helper.append_op(type='sequence_expand_as', inputs={'X': x, 'Y': y}, outputs={'Out': tmp})
    return tmp

def sequence_pad(x, pad_value, maxlen=None, name=None):
    if False:
        for i in range(10):
            print('nop')
    "\n\n        This layer padding the sequences in a same batch to a common length (according\n        to ``maxlen``). The padding value is defined by ``pad_value``, and will be\n        appended to the tail of sequences. The result is a Python tuple ``(Out, Length)``:\n        the Tensor ``Out`` is the padded sequences, and Tensor ``Length`` is\n        the length information of input sequences. For removing padding data (unpadding operation), See :ref:`api_paddle_static_nn_sequence_unpad`.\n\n    Note:\n        Please note that the input ``x`` should be Tensor.\n\n    .. code-block:: text\n\n        Case 1:\n        Given input 1-level Tensor x:\n            x.lod = [[0,  2,   5]]\n            x.data = [[a],[b],[c],[d],[e]]\n        pad_value:\n            pad_value.data = [0]\n        maxlen = 4\n\n        the output tuple (Out, Length):\n            Out.data = [[[a],[b],[0],[0]],[[c],[d],[e],[0]]]\n            Length.data = [2, 3]      #Original sequences length\n\n        Case 2:\n        Given input 1-level Tensor x:\n            x.lod =  [[0,             2,                     5]]\n            x.data = [[a1,a2],[b1,b2],[c1,c2],[d1,d2],[e1,e2]]\n        pad_value:\n            pad_value.data = [0]\n        default maxlen = None, (the virtual value is 3, according to the shape of x)\n\n        the output tuple (Out, Length):\n            Out.data = [[[a1,a2],[b1,b2],[0,0]],[[c1,c2],[d1,d2],[e1,e2]]]\n            Length.data = [2, 3]\n\n        Case 3:\n        Given input 1-level Tensor x:\n            x.lod =  [[0,             2,                     5]]\n            x.data = [[a1,a2],[b1,b2],[c1,c2],[d1,d2],[e1,e2]]\n        pad_value:\n            pad_value.data = [p1,p2]\n        default maxlen = None, (the virtual value is 3)\n\n        get tuple (Out, Length):\n            Out.data = [[[a1,a2],[b1,b2],[p1,p2]],[[c1,c2],[d1,d2],[e1,e2]]]\n            Length.data = [2, 3]\n\n\n\n    Args:\n        x (Tensor): Input 1-level Tensor with dims ``[M, K]``. The batch \\\n            size is described by lod infor (the number of sequences ). \\\n            The data type should be float32, float64, int8, int32 or int64.\n        pad_value (Tensor): Padding value. It can be a scalar or a 1D tensor \\\n            with length ``K``. If it's a scalar, it will be automatically broadcasted \\\n            to a Tensor. The data type should be as same as ``x``.\n        maxlen (int, optional): The length of padded sequences, None by default. \\\n            When it is None, all sequences will be padded up to the length of the \\\n            longest one among them; when it a certain positive value, it must be \\\n            greater than the length of the longest original sequence.\n        name (str, optional): For detailed information, please refer \\\n            to :ref:`api_guide_Name`. Usually name is no need to set and \\\n            None by default.\n\n    Returns:\n            tuple, A Python tuple (Out, Length): the 1st is a 0 level Tensor \\\n            ``Out``, with the shape ``[batch_size, maxlen, K]``; the second is the original \\\n            sequences length infor ``Length``, which should be a 0-level 1D Tensor. \\\n            The size of ``Length`` is equal to batch size, and the data type is int64.\n\n    Examples:\n        .. code-block:: python\n\n            >>> import paddle\n            >>> paddle.enable_static()\n            >>> import paddle.base as base\n            >>> import numpy\n\n            >>> x = paddle.static.data(name='x', shape=[10, 5], dtype='float32', lod_level=1)\n            >>> pad_value = paddle.assign(\n            ...     numpy.array([0.0], dtype=numpy.float32))\n            >>> out = paddle.static.nn.sequence_pad(x=x, pad_value=pad_value)\n    "
    assert not in_dygraph_mode(), 'sequence layer is not supported in dygraph mode yet.'
    helper = LayerHelper('sequence_pad', **locals())
    check_variable_and_dtype(x, 'x', ['float32', 'float64', 'int32', 'int64'], 'paddle.static.nn.sequence_lod.sequence_pad')
    check_variable_and_dtype(pad_value, 'pad_value', ['float32', 'float64', 'int32', 'int64'], 'paddle.static.nn.sequence_lod.sequence_pad')
    dtype = helper.input_dtype(input_param_name='x')
    out = helper.create_variable_for_type_inference(dtype)
    length = helper.create_variable_for_type_inference(VarDesc.VarType.INT64)
    pad_value.stop_gradient = True
    length.stop_gradient = True
    if maxlen is None:
        maxlen = -1
    helper.append_op(type='sequence_pad', inputs={'X': x, 'PadValue': pad_value}, outputs={'Out': out, 'Length': length}, attrs={'padded_length': maxlen})
    return (out, length)

def sequence_unpad(x, length, name=None):
    if False:
        while True:
            i = 10
    "\n\n    Note:\n        The input of the OP is Tensor and the output is Tensor.  For padding operation, See:**  :ref:`api_paddle_static_nn_sequence_pad`\n\n    Remove the padding data from the input based on the length information and returns a Tensor.\n\n    .. code-block:: text\n\n        Case 1:\n\n        Given input Tensor **x**:\n            x.data = [[ 1.0,  2.0,  3.0,  4.0,  5.0],\n                      [ 6.0,  7.0,  8.0,  9.0, 10.0],\n                      [11.0, 12.0, 13.0, 14.0, 15.0]],\n\n        in which there are 3 sequences padded to length 5, and the actual length\n        specified by input Tensor **length**:\n\n            length.data = [2, 3, 4],\n\n        after unpadding, the output Tensor will be:\n\n            out.data = [[1.0, 2.0, 6.0, 7.0, 8.0, 11.0, 12.0, 13.0, 14.0]]\n            out.lod = [[0, 2, 5, 9]]\n\n    Args:\n        x(Tensor): A Tensor which contains padding data, and its shape size can not be less than 2.\n                     Supported data types: float32, float64, int32, int64.\n        length(Tensor): A 1D Tensor that stores the actual length of each sample, and the Tensor\n                          has the same shape with the 0th dimension of the X . Supported data types: int64.\n        name(str|None):  The default value is None.  Normally there is no need for user to set this property.\n                         For more information, please refer to :ref:`api_guide_Name`\n\n    Returns:\n        Tensor: A Tensor whose recursive sequence length is consistent with the information of the length parameter and it has the same data type with input.\n\n    Examples:\n        .. code-block:: python\n\n            >>> import paddle\n            >>> paddle.enable_static()\n            >>> import paddle.base as base\n            >>> import numpy\n\n            >>> # pad data\n            >>> x = paddle.static.data(name='x', shape=[10, 5], dtype='float32', lod_level=1)\n            >>> pad_value = paddle.assign(numpy.array([0.0], dtype=numpy.float32))\n            >>> pad_data, len = paddle.static.nn.sequence_pad(x=x, pad_value=pad_value)\n\n            >>> # unpad data\n            >>> unpad_data = paddle.static.nn.sequence_unpad(x=pad_data, length=len)\n    "
    assert not in_dygraph_mode(), 'sequence layer is not supported in dygraph mode yet.'
    helper = LayerHelper('sequence_unpad', **locals())
    check_variable_and_dtype(x, 'x', ['float32', 'float64', 'int32', 'int64'], 'paddle.static.nn.sequence_lod.sequence_unpad')
    check_variable_and_dtype(length, 'length', ['int64'], 'paddle.static.nn.sequence_lod.sequence_unpad')
    dtype = helper.input_dtype(input_param_name='x')
    out = helper.create_variable_for_type_inference(dtype)
    length.stop_gradient = True
    helper.append_op(type='sequence_unpad', inputs={'X': x, 'Length': length}, outputs={'Out': out})
    return out

def sequence_reshape(input, new_dim):
    if False:
        for i in range(10):
            print('nop')
    "\n\n    Note:\n        Only receives Tensor as input. If your input is Tensor, please use reshape Op.(static.nn.** :ref:`api_paddle_reshape` ).\n\n    Only supports Tensor as input. Given :attr:`new_dim` ,\n    it will compute new shape according to original length of each sequence,\n    original dimensions and :attr:`new_dim` . Then it will output a new Tensor\n    containing :attr:`new_dim` . Currently it only supports 1-level Tensor.\n    Please make sure that (original length * original dimensions) can be divided\n    by the :attr:`new_dim` with no remainder for each sequence.\n\n    .. code-block:: text\n\n        input is a Tensor:\n            input.lod  = [[0, 2, 6]]\n            input.data = [[1,  2], [3,  4],\n                          [5,  6], [7,  8],\n                          [9, 10], [11, 12]]\n            input.shape = [6, 2]\n\n        set new_dim = 4\n        out is a Tensor:\n            out.lod  = [[0, 1, 3]]\n            out.data = [[1,  2,  3,  4],\n                        [5,  6,  7,  8],\n                        [9, 10, 11, 12]]\n            out.shape = [3, 4]\n\n\n    Args:\n\n       input (Tensor): 1-level Tensor with shape :math:`[M, K]` . The data type should\n            be int32, int64, float32 or float64.\n       new_dim (int): New dimension that the input Tensor is reshaped to.\n\n    Returns:\n        Tensor: Reshaped Tensor according to new dimension. The data type is same as input.\n\n    Examples:\n        .. code-block:: python\n\n            >>> import paddle\n            >>> paddle.enable_static()\n\n            >>> x = paddle.static.data(name='x', shape=[None, 16], dtype='float32', lod_level=1)\n            >>> x_reshaped = paddle.static.nn.sequence_reshape(input=x, new_dim=4)\n    "
    assert not in_dygraph_mode(), 'sequence layer is not supported in dygraph mode yet.'
    helper = LayerHelper('sequence_reshape', **locals())
    check_variable_and_dtype(input, 'input', ['float32', 'float64', 'int32', 'int64'], 'static.nn.sequence_reshape')
    out = helper.create_variable_for_type_inference(helper.input_dtype())
    helper.append_op(type='sequence_reshape', inputs={'X': [input]}, outputs={'Out': [out]}, attrs={'new_dim': new_dim})
    return out

def sequence_scatter(input, index, updates, name=None):
    if False:
        for i in range(10):
            print('nop')
    '\n\n    Note:\n        The index and updates parameters of the OP must be Tensor.\n\n    Plus the updates data to the corresponding input according to the index.\n\n    The updated algorithm is as follows: output[instance_index][index [pos]] = input[instance_index][index [pos]] +  updates[pos],\n    where instance_idx is the K sample corresponding to pos in batch.\n\n    The value of output[i][j] depends on whether j can be found in the i+1th interval of the index. If found,\n    out[i][j] = input[i][j] + update[m] [n], otherwise, out[i][j] = input[i][j].\n\n    For example, in the following example, the lod information for index is divided into three sequences. Among\n    them, because the element 0 can be found in the first interval of the index, it is updated with the value of\n    the corresponding position of the updates, out[0][0] = input[0][0]+updates[0][0] . Because element 1 cannot\n    be found in the third interval of index, out[2][1] = input[2][1].\n\n    .. code-block:: text\n\n        *Case 1:\n\n            Given:\n                input.data = [[1.0, 1.0, 1.0, 1.0, 1.0, 1.0],\n                              [1.0, 1.0, 1.0, 1.0, 1.0, 1.0],\n                              [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]]\n                              input.dims = [3, 6]\n\n                index.data = [[0], [1], [2], [5], [4], [3], [2], [1], [3], [2], [5], [4]]\n                index.lod =  [[0,        3,                       8,                 12]]\n\n                updates.data = [[0.3], [0.3], [0.4], [0.1], [0.2], [0.3], [0.4], [0.0], [0.2], [0.3], [0.1], [0.4]]\n                updates.lod =  [[  0,            3,                                 8,                         12]]\n\n            Then:\n                out.data = [[1.3, 1.3, 1.4, 1.0, 1.0, 1.0],\n                            [1.0, 1.0, 1.4, 1.3, 1.2, 1.1],\n                            [1.0, 1.0, 1.3, 1.2, 1.4, 1.1]]\n                out.dims = X.dims = [3, 6]\n\n    Args:\n        input (Tensor): A Tensor with shape of  :math:`[N, k_1... k_n]`. Supported data types: float32, float64, int32, int64.\n        index (Tensor):  A Tensor contains index information. Its LoD level must be 1 and its data type can be int32 or int64.\n        updates (Tensor): A Tensor contains updates information. It has the same  LoD level with the index and has the\n                            same data type  with the input. Supported data types: float32, float64, int32, int64.\n        name (str, optional): The default value is None.  Normally there is no need for user to set this property.  For more information,\n                              please refer to :ref:`api_guide_Name`\n\n    Returns:\n        Tensor: A Tensor which has been updated. It has the same shape and data type with input.\n\n    Examples:\n\n        .. code-block:: python\n\n            >>> import paddle\n            >>> paddle.enable_static()\n\n            >>> input = paddle.static.data(name="x", shape=[None, 3, 6], dtype=\'float32\' )\n            >>> index = paddle.static.data(name=\'index\', shape=[12, 1],  dtype=\'int64\', lod_level=1)\n            >>> updates = paddle.static.data(name=\'updates\', shape=[12, 1], dtype=\'float32\', lod_level=1)\n            >>> output = paddle.static.nn.sequence_scatter(input, index, updates)\n\n    '
    assert not in_dygraph_mode(), 'sequence layer is not supported in dygraph mode yet.'
    helper = LayerHelper('sequence_scatter', **locals())
    check_variable_and_dtype(input, 'input', ['float32', 'float64', 'int32', 'int64'], 'sequence_scatter')
    check_variable_and_dtype(index, 'index', ['int32', 'int64'], 'sequence_scatter')
    check_variable_and_dtype(updates, 'updates', ['float32', 'float64', 'int32', 'int64'], 'sequence_scatter')
    dtype = helper.input_dtype()
    out = helper.create_variable_for_type_inference(dtype)
    helper.append_op(type='sequence_scatter', inputs={'X': input, 'Ids': index, 'Updates': updates}, outputs={'Out': out})
    return out

def sequence_enumerate(input, win_size, pad_value=0, name=None):
    if False:
        print('Hello World!')
    "\n\n    Generate a new sequence for the input index sequence with \\\n        shape ``[d_1, win_size]``, which enumerates all the \\\n        sub-sequences with length ``win_size`` of the input with \\\n        shape ``[d_1, 1]``, and padded by ``pad_value`` if necessary in generation.\n\n    Please note that the `input` must be Tensor.\n\n    .. code-block:: text\n\n        Input x:\n            x.lod = [[0, 3, 5]]\n            x.data = [[1], [2], [3], [4], [5]]\n            x.dims = [5, 1]\n\n        Attrs:\n            win_size = 2\n            pad_value = 0\n\n        Output:\n            out.lod = [[0, 3, 5]]\n            out.data = [[1, 2], [2, 3], [3, 0], [4, 5], [5, 0]]\n            out.dims = [5, 2]\n\n\n    Args:\n        input (Tensor): The input variable which is a index sequence, \\\n            which should be a Tensor with shape ``[d_1, 1]`` and 1-level lod info. \\\n            The data type should be int32 or int64.\n        win_size (int): The window size for enumerating all sub-sequences.\n        pad_value (int, optional): The padding value, default 0.\n        name(str, optional): For detailed information, please refer \\\n            to :ref:`api_guide_Name`. Usually name is no need to set and \\\n            None by default.\n\n    Returns:\n            Tensor, The enumerate sequence variable which is a Tensor with \\\n            shape ``[d_1, win_size]`` and 1-level lod info. \\\n            The data type is same as ``input``.\n\n    Examples:\n        .. code-block:: python\n\n            >>> import paddle\n            >>> paddle.enable_static()\n\n            >>> x = paddle.static.data(name='x', shape=[-1, 1], dtype='int32', lod_level=1)\n            >>> out = paddle.static.nn.sequence_enumerate(input=x, win_size=3, pad_value=0)\n    "
    assert not in_dygraph_mode(), 'sequence layer is not supported in dygraph mode yet.'
    check_variable_and_dtype(input, 'input', ['int32', 'int64'], 'sequence_enumerate')
    helper = LayerHelper('sequence_enumerate', **locals())
    out = helper.create_variable_for_type_inference(helper.input_dtype(), stop_gradient=True)
    helper.append_op(type='sequence_enumerate', inputs={'X': input}, outputs={'Out': out}, attrs={'win_size': win_size, 'pad_value': pad_value})
    return out

def sequence_mask(x, maxlen=None, dtype='int64', name=None):
    if False:
        return 10
    '\n    **SequenceMask Layer**\n\n    This layer outputs a mask according to the input :code:`x` and\n    :code:`maxlen` with data type of :code:`dtype`.\n\n    Supposing :code:`x` is a Tensor with shape [d_1, d_2, ..., d_n], the\n    :code:`y` is a mask with shape [d_1, d_2, ..., d_n, maxlen], where:\n\n    .. math::\n\n        y(i_1, i_2,..., i_n, j) = (j < x(i_1, i_2,..., i_n))\n\n    .. code-block:: text\n\n        Case:\n\n        Consider input:\n            x = [3, 1, 1, 0]    max_len = 4\n\n        then we get out:\n            mask = [[1, 1, 1, 0],\n                    [1, 0, 0, 0],\n                    [1, 0, 0, 0],\n                    [0, 0, 0, 0]]\n\n    Args:\n        x (Tensor): Input tensor of sequence_mask layer, \\\n            whose elements are integers less than :code:`maxlen`. \\\n            Tensor or Tensor with shape [d_1, d_2, ..., d_n].\n        maxlen (int, optional): Maximum length of the sequence. If :code:`maxlen` \\\n                           is None, it would be replace with :math:`max(x)`.\n        dtype (np.dtype|paddle.dtype|str, optional): Data type of the output, \\\n             ``int64`` by default.\n        name(str, optional): For detailed information, please refer \\\n            to :ref:`api_guide_Name`. Usually name is no need to set and \\\n            None by default.\n\n    Returns:\n            Tensor, The output sequence mask. Tensor with shape [d_1, d_2, ..., d_n, maxlen]\n            and data type of :code:`dtype`. The data type should be bool, float32, float64, int8,\n            int32 or int64.\n\n    Examples:\n        .. code-block:: python\n\n            >>> import paddle\n\n            >>> lengths = paddle.to_tensor([10, 9, 8])\n            >>> mask = paddle.nn.functional.sequence_mask(lengths)\n\n            >>> print(mask.numpy())\n            [[1 1 1 1 1 1 1 1 1 1]\n             [1 1 1 1 1 1 1 1 1 0]\n             [1 1 1 1 1 1 1 1 0 0]]\n\n    '
    return paddle.nn.functional.sequence_mask(x, maxlen, dtype, name)

@templatedoc()
def sequence_reverse(x, name=None):
    if False:
        i = 10
        return i + 15
    "\n    Note:\n        Only receives Tensor as input. If your input is Tensor, please use reverse Op.(static.nn.** :ref:`api_paddle_flip` ).\n\n    Only supports Tensor as input. It will reverse each sequence for input Tensor.\n    Currently it only supports 1-level Tensor. This operator is very useful when building a\n    reverse :ref:`api_paddle_nn_RNN` network.\n\n    .. code-block:: text\n\n        input(x) is a Tensor:\n            x.lod  = [[0, 2, 5]]\n            x.data = [[1,  2,  3,  4],\n                      [5,  6,  7,  8],\n                      [9, 10, 11, 12],\n                      [13,14, 15, 16],\n                      [17,18, 19, 20]]\n            x.shape = [5, 4]\n\n        output Tensor with same shape and LoD info:\n            out.lod  = [[0, 2, 5]]\n            out.data = [[5,  6,  7,  8],\n                        [1,  2,  3,  4],\n                        [17,18, 19, 20],\n                        [13,14, 15, 16],\n                        [9, 10, 11, 12]]\n            out.shape = [5, 4]\n\n    Args:\n        x(Tensor): Tensor with 1-level LoD info. Currently it only supports 1-level Tensor.\n            The data type should be float32, float64, int8, int32 or int64.\n        name(str, optional): The default value is None.  Normally there is no need for user to set this property.\n            For more information, please refer to :ref:`api_guide_Name` .\n\n    Returns:\n        Tensor: Tensor reversed from input. The data type is same with input.\n\n    Examples:\n        .. code-block:: python\n\n            >>> import paddle\n            >>> paddle.enable_static()\n\n            >>> x = paddle.static.data(name='x', shape=[None, 10], dtype='float32', lod_level=1)\n            >>> x_reversed = paddle.static.nn.sequence_reverse(x)\n    "
    assert not in_dygraph_mode(), 'sequence layer is not supported in dygraph mode yet.'
    helper = LayerHelper('sequence_reverse', **locals())
    check_variable_and_dtype(x, 'x', ['float32', 'float64', 'int8', 'int32', 'int64'], 'static.nn.sequence_reverse')
    out = helper.create_variable_for_type_inference(dtype=x.dtype)
    helper.append_op(type='sequence_reverse', inputs={'X': x}, outputs={'Y': out}, attrs={})
    return out