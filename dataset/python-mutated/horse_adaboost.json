[
    {
        "func_name": "loadDataSet",
        "original": "def loadDataSet(fileName):\n    numFeat = len(open(fileName).readline().split('\\t'))\n    dataMat = []\n    labelMat = []\n    fr = open(fileName)\n    for line in fr.readlines():\n        lineArr = []\n        curLine = line.strip().split('\\t')\n        for i in range(numFeat - 1):\n            lineArr.append(float(curLine[i]))\n        dataMat.append(lineArr)\n        labelMat.append(float(curLine[-1]))\n    return (dataMat, labelMat)",
        "mutated": [
            "def loadDataSet(fileName):\n    if False:\n        i = 10\n    numFeat = len(open(fileName).readline().split('\\t'))\n    dataMat = []\n    labelMat = []\n    fr = open(fileName)\n    for line in fr.readlines():\n        lineArr = []\n        curLine = line.strip().split('\\t')\n        for i in range(numFeat - 1):\n            lineArr.append(float(curLine[i]))\n        dataMat.append(lineArr)\n        labelMat.append(float(curLine[-1]))\n    return (dataMat, labelMat)",
            "def loadDataSet(fileName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    numFeat = len(open(fileName).readline().split('\\t'))\n    dataMat = []\n    labelMat = []\n    fr = open(fileName)\n    for line in fr.readlines():\n        lineArr = []\n        curLine = line.strip().split('\\t')\n        for i in range(numFeat - 1):\n            lineArr.append(float(curLine[i]))\n        dataMat.append(lineArr)\n        labelMat.append(float(curLine[-1]))\n    return (dataMat, labelMat)",
            "def loadDataSet(fileName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    numFeat = len(open(fileName).readline().split('\\t'))\n    dataMat = []\n    labelMat = []\n    fr = open(fileName)\n    for line in fr.readlines():\n        lineArr = []\n        curLine = line.strip().split('\\t')\n        for i in range(numFeat - 1):\n            lineArr.append(float(curLine[i]))\n        dataMat.append(lineArr)\n        labelMat.append(float(curLine[-1]))\n    return (dataMat, labelMat)",
            "def loadDataSet(fileName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    numFeat = len(open(fileName).readline().split('\\t'))\n    dataMat = []\n    labelMat = []\n    fr = open(fileName)\n    for line in fr.readlines():\n        lineArr = []\n        curLine = line.strip().split('\\t')\n        for i in range(numFeat - 1):\n            lineArr.append(float(curLine[i]))\n        dataMat.append(lineArr)\n        labelMat.append(float(curLine[-1]))\n    return (dataMat, labelMat)",
            "def loadDataSet(fileName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    numFeat = len(open(fileName).readline().split('\\t'))\n    dataMat = []\n    labelMat = []\n    fr = open(fileName)\n    for line in fr.readlines():\n        lineArr = []\n        curLine = line.strip().split('\\t')\n        for i in range(numFeat - 1):\n            lineArr.append(float(curLine[i]))\n        dataMat.append(lineArr)\n        labelMat.append(float(curLine[-1]))\n    return (dataMat, labelMat)"
        ]
    },
    {
        "func_name": "stumpClassify",
        "original": "def stumpClassify(dataMatrix, dimen, threshVal, threshIneq):\n    \"\"\"\n\t\u5355\u5c42\u51b3\u7b56\u6811\u5206\u7c7b\u51fd\u6570\n\tParameters:\n\t\tdataMatrix - \u6570\u636e\u77e9\u9635\n\t\tdimen - \u7b2cdimen\u5217\uff0c\u4e5f\u5c31\u662f\u7b2c\u51e0\u4e2a\u7279\u5f81\n\t\tthreshVal - \u9608\u503c\n\t\tthreshIneq - \u6807\u5fd7\n\tReturns:\n\t\tretArray - \u5206\u7c7b\u7ed3\u679c\n\t\"\"\"\n    retArray = np.ones((np.shape(dataMatrix)[0], 1))\n    if threshIneq == 'lt':\n        retArray[dataMatrix[:, dimen] <= threshVal] = -1.0\n    else:\n        retArray[dataMatrix[:, dimen] > threshVal] = -1.0\n    return retArray",
        "mutated": [
            "def stumpClassify(dataMatrix, dimen, threshVal, threshIneq):\n    if False:\n        i = 10\n    '\\n\\t\u5355\u5c42\u51b3\u7b56\u6811\u5206\u7c7b\u51fd\u6570\\n\\tParameters:\\n\\t\\tdataMatrix - \u6570\u636e\u77e9\u9635\\n\\t\\tdimen - \u7b2cdimen\u5217\uff0c\u4e5f\u5c31\u662f\u7b2c\u51e0\u4e2a\u7279\u5f81\\n\\t\\tthreshVal - \u9608\u503c\\n\\t\\tthreshIneq - \u6807\u5fd7\\n\\tReturns:\\n\\t\\tretArray - \u5206\u7c7b\u7ed3\u679c\\n\\t'\n    retArray = np.ones((np.shape(dataMatrix)[0], 1))\n    if threshIneq == 'lt':\n        retArray[dataMatrix[:, dimen] <= threshVal] = -1.0\n    else:\n        retArray[dataMatrix[:, dimen] > threshVal] = -1.0\n    return retArray",
            "def stumpClassify(dataMatrix, dimen, threshVal, threshIneq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n\\t\u5355\u5c42\u51b3\u7b56\u6811\u5206\u7c7b\u51fd\u6570\\n\\tParameters:\\n\\t\\tdataMatrix - \u6570\u636e\u77e9\u9635\\n\\t\\tdimen - \u7b2cdimen\u5217\uff0c\u4e5f\u5c31\u662f\u7b2c\u51e0\u4e2a\u7279\u5f81\\n\\t\\tthreshVal - \u9608\u503c\\n\\t\\tthreshIneq - \u6807\u5fd7\\n\\tReturns:\\n\\t\\tretArray - \u5206\u7c7b\u7ed3\u679c\\n\\t'\n    retArray = np.ones((np.shape(dataMatrix)[0], 1))\n    if threshIneq == 'lt':\n        retArray[dataMatrix[:, dimen] <= threshVal] = -1.0\n    else:\n        retArray[dataMatrix[:, dimen] > threshVal] = -1.0\n    return retArray",
            "def stumpClassify(dataMatrix, dimen, threshVal, threshIneq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n\\t\u5355\u5c42\u51b3\u7b56\u6811\u5206\u7c7b\u51fd\u6570\\n\\tParameters:\\n\\t\\tdataMatrix - \u6570\u636e\u77e9\u9635\\n\\t\\tdimen - \u7b2cdimen\u5217\uff0c\u4e5f\u5c31\u662f\u7b2c\u51e0\u4e2a\u7279\u5f81\\n\\t\\tthreshVal - \u9608\u503c\\n\\t\\tthreshIneq - \u6807\u5fd7\\n\\tReturns:\\n\\t\\tretArray - \u5206\u7c7b\u7ed3\u679c\\n\\t'\n    retArray = np.ones((np.shape(dataMatrix)[0], 1))\n    if threshIneq == 'lt':\n        retArray[dataMatrix[:, dimen] <= threshVal] = -1.0\n    else:\n        retArray[dataMatrix[:, dimen] > threshVal] = -1.0\n    return retArray",
            "def stumpClassify(dataMatrix, dimen, threshVal, threshIneq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n\\t\u5355\u5c42\u51b3\u7b56\u6811\u5206\u7c7b\u51fd\u6570\\n\\tParameters:\\n\\t\\tdataMatrix - \u6570\u636e\u77e9\u9635\\n\\t\\tdimen - \u7b2cdimen\u5217\uff0c\u4e5f\u5c31\u662f\u7b2c\u51e0\u4e2a\u7279\u5f81\\n\\t\\tthreshVal - \u9608\u503c\\n\\t\\tthreshIneq - \u6807\u5fd7\\n\\tReturns:\\n\\t\\tretArray - \u5206\u7c7b\u7ed3\u679c\\n\\t'\n    retArray = np.ones((np.shape(dataMatrix)[0], 1))\n    if threshIneq == 'lt':\n        retArray[dataMatrix[:, dimen] <= threshVal] = -1.0\n    else:\n        retArray[dataMatrix[:, dimen] > threshVal] = -1.0\n    return retArray",
            "def stumpClassify(dataMatrix, dimen, threshVal, threshIneq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n\\t\u5355\u5c42\u51b3\u7b56\u6811\u5206\u7c7b\u51fd\u6570\\n\\tParameters:\\n\\t\\tdataMatrix - \u6570\u636e\u77e9\u9635\\n\\t\\tdimen - \u7b2cdimen\u5217\uff0c\u4e5f\u5c31\u662f\u7b2c\u51e0\u4e2a\u7279\u5f81\\n\\t\\tthreshVal - \u9608\u503c\\n\\t\\tthreshIneq - \u6807\u5fd7\\n\\tReturns:\\n\\t\\tretArray - \u5206\u7c7b\u7ed3\u679c\\n\\t'\n    retArray = np.ones((np.shape(dataMatrix)[0], 1))\n    if threshIneq == 'lt':\n        retArray[dataMatrix[:, dimen] <= threshVal] = -1.0\n    else:\n        retArray[dataMatrix[:, dimen] > threshVal] = -1.0\n    return retArray"
        ]
    },
    {
        "func_name": "buildStump",
        "original": "def buildStump(dataArr, classLabels, D):\n    \"\"\"\n\t\u627e\u5230\u6570\u636e\u96c6\u4e0a\u6700\u4f73\u7684\u5355\u5c42\u51b3\u7b56\u6811\n\tParameters:\n\t\tdataArr - \u6570\u636e\u77e9\u9635\n\t\tclassLabels - \u6570\u636e\u6807\u7b7e\n\t\tD - \u6837\u672c\u6743\u91cd\n\tReturns:\n\t\tbestStump - \u6700\u4f73\u5355\u5c42\u51b3\u7b56\u6811\u4fe1\u606f\n\t\tminError - \u6700\u5c0f\u8bef\u5dee\n\t\tbestClasEst - \u6700\u4f73\u7684\u5206\u7c7b\u7ed3\u679c\n\t\"\"\"\n    dataMatrix = np.mat(dataArr)\n    labelMat = np.mat(classLabels).T\n    (m, n) = np.shape(dataMatrix)\n    numSteps = 10.0\n    bestStump = {}\n    bestClasEst = np.mat(np.zeros((m, 1)))\n    minError = float('inf')\n    for i in range(n):\n        rangeMin = dataMatrix[:, i].min()\n        rangeMax = dataMatrix[:, i].max()\n        stepSize = (rangeMax - rangeMin) / numSteps\n        for j in range(-1, int(numSteps) + 1):\n            for inequal in ['lt', 'gt']:\n                threshVal = rangeMin + float(j) * stepSize\n                predictedVals = stumpClassify(dataMatrix, i, threshVal, inequal)\n                errArr = np.mat(np.ones((m, 1)))\n                errArr[predictedVals == labelMat] = 0\n                weightedError = D.T * errArr\n                if weightedError < minError:\n                    minError = weightedError\n                    bestClasEst = predictedVals.copy()\n                    bestStump['dim'] = i\n                    bestStump['thresh'] = threshVal\n                    bestStump['ineq'] = inequal\n    return (bestStump, minError, bestClasEst)",
        "mutated": [
            "def buildStump(dataArr, classLabels, D):\n    if False:\n        i = 10\n    '\\n\\t\u627e\u5230\u6570\u636e\u96c6\u4e0a\u6700\u4f73\u7684\u5355\u5c42\u51b3\u7b56\u6811\\n\\tParameters:\\n\\t\\tdataArr - \u6570\u636e\u77e9\u9635\\n\\t\\tclassLabels - \u6570\u636e\u6807\u7b7e\\n\\t\\tD - \u6837\u672c\u6743\u91cd\\n\\tReturns:\\n\\t\\tbestStump - \u6700\u4f73\u5355\u5c42\u51b3\u7b56\u6811\u4fe1\u606f\\n\\t\\tminError - \u6700\u5c0f\u8bef\u5dee\\n\\t\\tbestClasEst - \u6700\u4f73\u7684\u5206\u7c7b\u7ed3\u679c\\n\\t'\n    dataMatrix = np.mat(dataArr)\n    labelMat = np.mat(classLabels).T\n    (m, n) = np.shape(dataMatrix)\n    numSteps = 10.0\n    bestStump = {}\n    bestClasEst = np.mat(np.zeros((m, 1)))\n    minError = float('inf')\n    for i in range(n):\n        rangeMin = dataMatrix[:, i].min()\n        rangeMax = dataMatrix[:, i].max()\n        stepSize = (rangeMax - rangeMin) / numSteps\n        for j in range(-1, int(numSteps) + 1):\n            for inequal in ['lt', 'gt']:\n                threshVal = rangeMin + float(j) * stepSize\n                predictedVals = stumpClassify(dataMatrix, i, threshVal, inequal)\n                errArr = np.mat(np.ones((m, 1)))\n                errArr[predictedVals == labelMat] = 0\n                weightedError = D.T * errArr\n                if weightedError < minError:\n                    minError = weightedError\n                    bestClasEst = predictedVals.copy()\n                    bestStump['dim'] = i\n                    bestStump['thresh'] = threshVal\n                    bestStump['ineq'] = inequal\n    return (bestStump, minError, bestClasEst)",
            "def buildStump(dataArr, classLabels, D):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n\\t\u627e\u5230\u6570\u636e\u96c6\u4e0a\u6700\u4f73\u7684\u5355\u5c42\u51b3\u7b56\u6811\\n\\tParameters:\\n\\t\\tdataArr - \u6570\u636e\u77e9\u9635\\n\\t\\tclassLabels - \u6570\u636e\u6807\u7b7e\\n\\t\\tD - \u6837\u672c\u6743\u91cd\\n\\tReturns:\\n\\t\\tbestStump - \u6700\u4f73\u5355\u5c42\u51b3\u7b56\u6811\u4fe1\u606f\\n\\t\\tminError - \u6700\u5c0f\u8bef\u5dee\\n\\t\\tbestClasEst - \u6700\u4f73\u7684\u5206\u7c7b\u7ed3\u679c\\n\\t'\n    dataMatrix = np.mat(dataArr)\n    labelMat = np.mat(classLabels).T\n    (m, n) = np.shape(dataMatrix)\n    numSteps = 10.0\n    bestStump = {}\n    bestClasEst = np.mat(np.zeros((m, 1)))\n    minError = float('inf')\n    for i in range(n):\n        rangeMin = dataMatrix[:, i].min()\n        rangeMax = dataMatrix[:, i].max()\n        stepSize = (rangeMax - rangeMin) / numSteps\n        for j in range(-1, int(numSteps) + 1):\n            for inequal in ['lt', 'gt']:\n                threshVal = rangeMin + float(j) * stepSize\n                predictedVals = stumpClassify(dataMatrix, i, threshVal, inequal)\n                errArr = np.mat(np.ones((m, 1)))\n                errArr[predictedVals == labelMat] = 0\n                weightedError = D.T * errArr\n                if weightedError < minError:\n                    minError = weightedError\n                    bestClasEst = predictedVals.copy()\n                    bestStump['dim'] = i\n                    bestStump['thresh'] = threshVal\n                    bestStump['ineq'] = inequal\n    return (bestStump, minError, bestClasEst)",
            "def buildStump(dataArr, classLabels, D):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n\\t\u627e\u5230\u6570\u636e\u96c6\u4e0a\u6700\u4f73\u7684\u5355\u5c42\u51b3\u7b56\u6811\\n\\tParameters:\\n\\t\\tdataArr - \u6570\u636e\u77e9\u9635\\n\\t\\tclassLabels - \u6570\u636e\u6807\u7b7e\\n\\t\\tD - \u6837\u672c\u6743\u91cd\\n\\tReturns:\\n\\t\\tbestStump - \u6700\u4f73\u5355\u5c42\u51b3\u7b56\u6811\u4fe1\u606f\\n\\t\\tminError - \u6700\u5c0f\u8bef\u5dee\\n\\t\\tbestClasEst - \u6700\u4f73\u7684\u5206\u7c7b\u7ed3\u679c\\n\\t'\n    dataMatrix = np.mat(dataArr)\n    labelMat = np.mat(classLabels).T\n    (m, n) = np.shape(dataMatrix)\n    numSteps = 10.0\n    bestStump = {}\n    bestClasEst = np.mat(np.zeros((m, 1)))\n    minError = float('inf')\n    for i in range(n):\n        rangeMin = dataMatrix[:, i].min()\n        rangeMax = dataMatrix[:, i].max()\n        stepSize = (rangeMax - rangeMin) / numSteps\n        for j in range(-1, int(numSteps) + 1):\n            for inequal in ['lt', 'gt']:\n                threshVal = rangeMin + float(j) * stepSize\n                predictedVals = stumpClassify(dataMatrix, i, threshVal, inequal)\n                errArr = np.mat(np.ones((m, 1)))\n                errArr[predictedVals == labelMat] = 0\n                weightedError = D.T * errArr\n                if weightedError < minError:\n                    minError = weightedError\n                    bestClasEst = predictedVals.copy()\n                    bestStump['dim'] = i\n                    bestStump['thresh'] = threshVal\n                    bestStump['ineq'] = inequal\n    return (bestStump, minError, bestClasEst)",
            "def buildStump(dataArr, classLabels, D):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n\\t\u627e\u5230\u6570\u636e\u96c6\u4e0a\u6700\u4f73\u7684\u5355\u5c42\u51b3\u7b56\u6811\\n\\tParameters:\\n\\t\\tdataArr - \u6570\u636e\u77e9\u9635\\n\\t\\tclassLabels - \u6570\u636e\u6807\u7b7e\\n\\t\\tD - \u6837\u672c\u6743\u91cd\\n\\tReturns:\\n\\t\\tbestStump - \u6700\u4f73\u5355\u5c42\u51b3\u7b56\u6811\u4fe1\u606f\\n\\t\\tminError - \u6700\u5c0f\u8bef\u5dee\\n\\t\\tbestClasEst - \u6700\u4f73\u7684\u5206\u7c7b\u7ed3\u679c\\n\\t'\n    dataMatrix = np.mat(dataArr)\n    labelMat = np.mat(classLabels).T\n    (m, n) = np.shape(dataMatrix)\n    numSteps = 10.0\n    bestStump = {}\n    bestClasEst = np.mat(np.zeros((m, 1)))\n    minError = float('inf')\n    for i in range(n):\n        rangeMin = dataMatrix[:, i].min()\n        rangeMax = dataMatrix[:, i].max()\n        stepSize = (rangeMax - rangeMin) / numSteps\n        for j in range(-1, int(numSteps) + 1):\n            for inequal in ['lt', 'gt']:\n                threshVal = rangeMin + float(j) * stepSize\n                predictedVals = stumpClassify(dataMatrix, i, threshVal, inequal)\n                errArr = np.mat(np.ones((m, 1)))\n                errArr[predictedVals == labelMat] = 0\n                weightedError = D.T * errArr\n                if weightedError < minError:\n                    minError = weightedError\n                    bestClasEst = predictedVals.copy()\n                    bestStump['dim'] = i\n                    bestStump['thresh'] = threshVal\n                    bestStump['ineq'] = inequal\n    return (bestStump, minError, bestClasEst)",
            "def buildStump(dataArr, classLabels, D):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n\\t\u627e\u5230\u6570\u636e\u96c6\u4e0a\u6700\u4f73\u7684\u5355\u5c42\u51b3\u7b56\u6811\\n\\tParameters:\\n\\t\\tdataArr - \u6570\u636e\u77e9\u9635\\n\\t\\tclassLabels - \u6570\u636e\u6807\u7b7e\\n\\t\\tD - \u6837\u672c\u6743\u91cd\\n\\tReturns:\\n\\t\\tbestStump - \u6700\u4f73\u5355\u5c42\u51b3\u7b56\u6811\u4fe1\u606f\\n\\t\\tminError - \u6700\u5c0f\u8bef\u5dee\\n\\t\\tbestClasEst - \u6700\u4f73\u7684\u5206\u7c7b\u7ed3\u679c\\n\\t'\n    dataMatrix = np.mat(dataArr)\n    labelMat = np.mat(classLabels).T\n    (m, n) = np.shape(dataMatrix)\n    numSteps = 10.0\n    bestStump = {}\n    bestClasEst = np.mat(np.zeros((m, 1)))\n    minError = float('inf')\n    for i in range(n):\n        rangeMin = dataMatrix[:, i].min()\n        rangeMax = dataMatrix[:, i].max()\n        stepSize = (rangeMax - rangeMin) / numSteps\n        for j in range(-1, int(numSteps) + 1):\n            for inequal in ['lt', 'gt']:\n                threshVal = rangeMin + float(j) * stepSize\n                predictedVals = stumpClassify(dataMatrix, i, threshVal, inequal)\n                errArr = np.mat(np.ones((m, 1)))\n                errArr[predictedVals == labelMat] = 0\n                weightedError = D.T * errArr\n                if weightedError < minError:\n                    minError = weightedError\n                    bestClasEst = predictedVals.copy()\n                    bestStump['dim'] = i\n                    bestStump['thresh'] = threshVal\n                    bestStump['ineq'] = inequal\n    return (bestStump, minError, bestClasEst)"
        ]
    },
    {
        "func_name": "adaBoostTrainDS",
        "original": "def adaBoostTrainDS(dataArr, classLabels, numIt=40):\n    \"\"\"\n\t\u4f7f\u7528AdaBoost\u7b97\u6cd5\u63d0\u5347\u5f31\u5206\u7c7b\u5668\u6027\u80fd\n\tParameters:\n\t\tdataArr - \u6570\u636e\u77e9\u9635\n\t\tclassLabels - \u6570\u636e\u6807\u7b7e\n\t\tnumIt - \u6700\u5927\u8fed\u4ee3\u6b21\u6570\n\tReturns:\n\t\tweakClassArr - \u8bad\u7ec3\u597d\u7684\u5206\u7c7b\u5668\n\t\taggClassEst - \u7c7b\u522b\u4f30\u8ba1\u7d2f\u8ba1\u503c\n\t\"\"\"\n    weakClassArr = []\n    m = np.shape(dataArr)[0]\n    D = np.mat(np.ones((m, 1)) / m)\n    aggClassEst = np.mat(np.zeros((m, 1)))\n    for i in range(numIt):\n        (bestStump, error, classEst) = buildStump(dataArr, classLabels, D)\n        alpha = float(0.5 * np.log((1.0 - error) / max(error, 1e-16)))\n        bestStump['alpha'] = alpha\n        weakClassArr.append(bestStump)\n        expon = np.multiply(-1 * alpha * np.mat(classLabels).T, classEst)\n        D = np.multiply(D, np.exp(expon))\n        D = D / D.sum()\n        aggClassEst += alpha * classEst\n        aggErrors = np.multiply(np.sign(aggClassEst) != np.mat(classLabels).T, np.ones((m, 1)))\n        errorRate = aggErrors.sum() / m\n        if errorRate == 0.0:\n            break\n    return (weakClassArr, aggClassEst)",
        "mutated": [
            "def adaBoostTrainDS(dataArr, classLabels, numIt=40):\n    if False:\n        i = 10\n    '\\n\\t\u4f7f\u7528AdaBoost\u7b97\u6cd5\u63d0\u5347\u5f31\u5206\u7c7b\u5668\u6027\u80fd\\n\\tParameters:\\n\\t\\tdataArr - \u6570\u636e\u77e9\u9635\\n\\t\\tclassLabels - \u6570\u636e\u6807\u7b7e\\n\\t\\tnumIt - \u6700\u5927\u8fed\u4ee3\u6b21\u6570\\n\\tReturns:\\n\\t\\tweakClassArr - \u8bad\u7ec3\u597d\u7684\u5206\u7c7b\u5668\\n\\t\\taggClassEst - \u7c7b\u522b\u4f30\u8ba1\u7d2f\u8ba1\u503c\\n\\t'\n    weakClassArr = []\n    m = np.shape(dataArr)[0]\n    D = np.mat(np.ones((m, 1)) / m)\n    aggClassEst = np.mat(np.zeros((m, 1)))\n    for i in range(numIt):\n        (bestStump, error, classEst) = buildStump(dataArr, classLabels, D)\n        alpha = float(0.5 * np.log((1.0 - error) / max(error, 1e-16)))\n        bestStump['alpha'] = alpha\n        weakClassArr.append(bestStump)\n        expon = np.multiply(-1 * alpha * np.mat(classLabels).T, classEst)\n        D = np.multiply(D, np.exp(expon))\n        D = D / D.sum()\n        aggClassEst += alpha * classEst\n        aggErrors = np.multiply(np.sign(aggClassEst) != np.mat(classLabels).T, np.ones((m, 1)))\n        errorRate = aggErrors.sum() / m\n        if errorRate == 0.0:\n            break\n    return (weakClassArr, aggClassEst)",
            "def adaBoostTrainDS(dataArr, classLabels, numIt=40):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n\\t\u4f7f\u7528AdaBoost\u7b97\u6cd5\u63d0\u5347\u5f31\u5206\u7c7b\u5668\u6027\u80fd\\n\\tParameters:\\n\\t\\tdataArr - \u6570\u636e\u77e9\u9635\\n\\t\\tclassLabels - \u6570\u636e\u6807\u7b7e\\n\\t\\tnumIt - \u6700\u5927\u8fed\u4ee3\u6b21\u6570\\n\\tReturns:\\n\\t\\tweakClassArr - \u8bad\u7ec3\u597d\u7684\u5206\u7c7b\u5668\\n\\t\\taggClassEst - \u7c7b\u522b\u4f30\u8ba1\u7d2f\u8ba1\u503c\\n\\t'\n    weakClassArr = []\n    m = np.shape(dataArr)[0]\n    D = np.mat(np.ones((m, 1)) / m)\n    aggClassEst = np.mat(np.zeros((m, 1)))\n    for i in range(numIt):\n        (bestStump, error, classEst) = buildStump(dataArr, classLabels, D)\n        alpha = float(0.5 * np.log((1.0 - error) / max(error, 1e-16)))\n        bestStump['alpha'] = alpha\n        weakClassArr.append(bestStump)\n        expon = np.multiply(-1 * alpha * np.mat(classLabels).T, classEst)\n        D = np.multiply(D, np.exp(expon))\n        D = D / D.sum()\n        aggClassEst += alpha * classEst\n        aggErrors = np.multiply(np.sign(aggClassEst) != np.mat(classLabels).T, np.ones((m, 1)))\n        errorRate = aggErrors.sum() / m\n        if errorRate == 0.0:\n            break\n    return (weakClassArr, aggClassEst)",
            "def adaBoostTrainDS(dataArr, classLabels, numIt=40):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n\\t\u4f7f\u7528AdaBoost\u7b97\u6cd5\u63d0\u5347\u5f31\u5206\u7c7b\u5668\u6027\u80fd\\n\\tParameters:\\n\\t\\tdataArr - \u6570\u636e\u77e9\u9635\\n\\t\\tclassLabels - \u6570\u636e\u6807\u7b7e\\n\\t\\tnumIt - \u6700\u5927\u8fed\u4ee3\u6b21\u6570\\n\\tReturns:\\n\\t\\tweakClassArr - \u8bad\u7ec3\u597d\u7684\u5206\u7c7b\u5668\\n\\t\\taggClassEst - \u7c7b\u522b\u4f30\u8ba1\u7d2f\u8ba1\u503c\\n\\t'\n    weakClassArr = []\n    m = np.shape(dataArr)[0]\n    D = np.mat(np.ones((m, 1)) / m)\n    aggClassEst = np.mat(np.zeros((m, 1)))\n    for i in range(numIt):\n        (bestStump, error, classEst) = buildStump(dataArr, classLabels, D)\n        alpha = float(0.5 * np.log((1.0 - error) / max(error, 1e-16)))\n        bestStump['alpha'] = alpha\n        weakClassArr.append(bestStump)\n        expon = np.multiply(-1 * alpha * np.mat(classLabels).T, classEst)\n        D = np.multiply(D, np.exp(expon))\n        D = D / D.sum()\n        aggClassEst += alpha * classEst\n        aggErrors = np.multiply(np.sign(aggClassEst) != np.mat(classLabels).T, np.ones((m, 1)))\n        errorRate = aggErrors.sum() / m\n        if errorRate == 0.0:\n            break\n    return (weakClassArr, aggClassEst)",
            "def adaBoostTrainDS(dataArr, classLabels, numIt=40):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n\\t\u4f7f\u7528AdaBoost\u7b97\u6cd5\u63d0\u5347\u5f31\u5206\u7c7b\u5668\u6027\u80fd\\n\\tParameters:\\n\\t\\tdataArr - \u6570\u636e\u77e9\u9635\\n\\t\\tclassLabels - \u6570\u636e\u6807\u7b7e\\n\\t\\tnumIt - \u6700\u5927\u8fed\u4ee3\u6b21\u6570\\n\\tReturns:\\n\\t\\tweakClassArr - \u8bad\u7ec3\u597d\u7684\u5206\u7c7b\u5668\\n\\t\\taggClassEst - \u7c7b\u522b\u4f30\u8ba1\u7d2f\u8ba1\u503c\\n\\t'\n    weakClassArr = []\n    m = np.shape(dataArr)[0]\n    D = np.mat(np.ones((m, 1)) / m)\n    aggClassEst = np.mat(np.zeros((m, 1)))\n    for i in range(numIt):\n        (bestStump, error, classEst) = buildStump(dataArr, classLabels, D)\n        alpha = float(0.5 * np.log((1.0 - error) / max(error, 1e-16)))\n        bestStump['alpha'] = alpha\n        weakClassArr.append(bestStump)\n        expon = np.multiply(-1 * alpha * np.mat(classLabels).T, classEst)\n        D = np.multiply(D, np.exp(expon))\n        D = D / D.sum()\n        aggClassEst += alpha * classEst\n        aggErrors = np.multiply(np.sign(aggClassEst) != np.mat(classLabels).T, np.ones((m, 1)))\n        errorRate = aggErrors.sum() / m\n        if errorRate == 0.0:\n            break\n    return (weakClassArr, aggClassEst)",
            "def adaBoostTrainDS(dataArr, classLabels, numIt=40):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n\\t\u4f7f\u7528AdaBoost\u7b97\u6cd5\u63d0\u5347\u5f31\u5206\u7c7b\u5668\u6027\u80fd\\n\\tParameters:\\n\\t\\tdataArr - \u6570\u636e\u77e9\u9635\\n\\t\\tclassLabels - \u6570\u636e\u6807\u7b7e\\n\\t\\tnumIt - \u6700\u5927\u8fed\u4ee3\u6b21\u6570\\n\\tReturns:\\n\\t\\tweakClassArr - \u8bad\u7ec3\u597d\u7684\u5206\u7c7b\u5668\\n\\t\\taggClassEst - \u7c7b\u522b\u4f30\u8ba1\u7d2f\u8ba1\u503c\\n\\t'\n    weakClassArr = []\n    m = np.shape(dataArr)[0]\n    D = np.mat(np.ones((m, 1)) / m)\n    aggClassEst = np.mat(np.zeros((m, 1)))\n    for i in range(numIt):\n        (bestStump, error, classEst) = buildStump(dataArr, classLabels, D)\n        alpha = float(0.5 * np.log((1.0 - error) / max(error, 1e-16)))\n        bestStump['alpha'] = alpha\n        weakClassArr.append(bestStump)\n        expon = np.multiply(-1 * alpha * np.mat(classLabels).T, classEst)\n        D = np.multiply(D, np.exp(expon))\n        D = D / D.sum()\n        aggClassEst += alpha * classEst\n        aggErrors = np.multiply(np.sign(aggClassEst) != np.mat(classLabels).T, np.ones((m, 1)))\n        errorRate = aggErrors.sum() / m\n        if errorRate == 0.0:\n            break\n    return (weakClassArr, aggClassEst)"
        ]
    },
    {
        "func_name": "adaClassify",
        "original": "def adaClassify(datToClass, classifierArr):\n    \"\"\"\n\tAdaBoost\u5206\u7c7b\u51fd\u6570\n\tParameters:\n\t\tdatToClass - \u5f85\u5206\u7c7b\u6837\u4f8b\n\t\tclassifierArr - \u8bad\u7ec3\u597d\u7684\u5206\u7c7b\u5668\n\tReturns:\n\t\t\u5206\u7c7b\u7ed3\u679c\n\t\"\"\"\n    dataMatrix = np.mat(datToClass)\n    m = np.shape(dataMatrix)[0]\n    aggClassEst = np.mat(np.zeros((m, 1)))\n    for i in range(len(classifierArr)):\n        classEst = stumpClassify(dataMatrix, classifierArr[i]['dim'], classifierArr[i]['thresh'], classifierArr[i]['ineq'])\n        aggClassEst += classifierArr[i]['alpha'] * classEst\n    return np.sign(aggClassEst)",
        "mutated": [
            "def adaClassify(datToClass, classifierArr):\n    if False:\n        i = 10\n    '\\n\\tAdaBoost\u5206\u7c7b\u51fd\u6570\\n\\tParameters:\\n\\t\\tdatToClass - \u5f85\u5206\u7c7b\u6837\u4f8b\\n\\t\\tclassifierArr - \u8bad\u7ec3\u597d\u7684\u5206\u7c7b\u5668\\n\\tReturns:\\n\\t\\t\u5206\u7c7b\u7ed3\u679c\\n\\t'\n    dataMatrix = np.mat(datToClass)\n    m = np.shape(dataMatrix)[0]\n    aggClassEst = np.mat(np.zeros((m, 1)))\n    for i in range(len(classifierArr)):\n        classEst = stumpClassify(dataMatrix, classifierArr[i]['dim'], classifierArr[i]['thresh'], classifierArr[i]['ineq'])\n        aggClassEst += classifierArr[i]['alpha'] * classEst\n    return np.sign(aggClassEst)",
            "def adaClassify(datToClass, classifierArr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n\\tAdaBoost\u5206\u7c7b\u51fd\u6570\\n\\tParameters:\\n\\t\\tdatToClass - \u5f85\u5206\u7c7b\u6837\u4f8b\\n\\t\\tclassifierArr - \u8bad\u7ec3\u597d\u7684\u5206\u7c7b\u5668\\n\\tReturns:\\n\\t\\t\u5206\u7c7b\u7ed3\u679c\\n\\t'\n    dataMatrix = np.mat(datToClass)\n    m = np.shape(dataMatrix)[0]\n    aggClassEst = np.mat(np.zeros((m, 1)))\n    for i in range(len(classifierArr)):\n        classEst = stumpClassify(dataMatrix, classifierArr[i]['dim'], classifierArr[i]['thresh'], classifierArr[i]['ineq'])\n        aggClassEst += classifierArr[i]['alpha'] * classEst\n    return np.sign(aggClassEst)",
            "def adaClassify(datToClass, classifierArr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n\\tAdaBoost\u5206\u7c7b\u51fd\u6570\\n\\tParameters:\\n\\t\\tdatToClass - \u5f85\u5206\u7c7b\u6837\u4f8b\\n\\t\\tclassifierArr - \u8bad\u7ec3\u597d\u7684\u5206\u7c7b\u5668\\n\\tReturns:\\n\\t\\t\u5206\u7c7b\u7ed3\u679c\\n\\t'\n    dataMatrix = np.mat(datToClass)\n    m = np.shape(dataMatrix)[0]\n    aggClassEst = np.mat(np.zeros((m, 1)))\n    for i in range(len(classifierArr)):\n        classEst = stumpClassify(dataMatrix, classifierArr[i]['dim'], classifierArr[i]['thresh'], classifierArr[i]['ineq'])\n        aggClassEst += classifierArr[i]['alpha'] * classEst\n    return np.sign(aggClassEst)",
            "def adaClassify(datToClass, classifierArr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n\\tAdaBoost\u5206\u7c7b\u51fd\u6570\\n\\tParameters:\\n\\t\\tdatToClass - \u5f85\u5206\u7c7b\u6837\u4f8b\\n\\t\\tclassifierArr - \u8bad\u7ec3\u597d\u7684\u5206\u7c7b\u5668\\n\\tReturns:\\n\\t\\t\u5206\u7c7b\u7ed3\u679c\\n\\t'\n    dataMatrix = np.mat(datToClass)\n    m = np.shape(dataMatrix)[0]\n    aggClassEst = np.mat(np.zeros((m, 1)))\n    for i in range(len(classifierArr)):\n        classEst = stumpClassify(dataMatrix, classifierArr[i]['dim'], classifierArr[i]['thresh'], classifierArr[i]['ineq'])\n        aggClassEst += classifierArr[i]['alpha'] * classEst\n    return np.sign(aggClassEst)",
            "def adaClassify(datToClass, classifierArr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n\\tAdaBoost\u5206\u7c7b\u51fd\u6570\\n\\tParameters:\\n\\t\\tdatToClass - \u5f85\u5206\u7c7b\u6837\u4f8b\\n\\t\\tclassifierArr - \u8bad\u7ec3\u597d\u7684\u5206\u7c7b\u5668\\n\\tReturns:\\n\\t\\t\u5206\u7c7b\u7ed3\u679c\\n\\t'\n    dataMatrix = np.mat(datToClass)\n    m = np.shape(dataMatrix)[0]\n    aggClassEst = np.mat(np.zeros((m, 1)))\n    for i in range(len(classifierArr)):\n        classEst = stumpClassify(dataMatrix, classifierArr[i]['dim'], classifierArr[i]['thresh'], classifierArr[i]['ineq'])\n        aggClassEst += classifierArr[i]['alpha'] * classEst\n    return np.sign(aggClassEst)"
        ]
    }
]