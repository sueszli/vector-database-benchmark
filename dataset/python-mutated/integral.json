[
    {
        "func_name": "integral_image",
        "original": "def integral_image(image, *, dtype=None):\n    \"\"\"Integral image / summed area table.\n\n    The integral image contains the sum of all elements above and to the\n    left of it, i.e.:\n\n    .. math::\n\n       S[m, n] = \\\\sum_{i \\\\leq m} \\\\sum_{j \\\\leq n} X[i, j]\n\n    Parameters\n    ----------\n    image : ndarray\n        Input image.\n\n    Returns\n    -------\n    S : ndarray\n        Integral image/summed area table of same shape as input image.\n\n    Notes\n    -----\n    For better accuracy and to avoid potential overflow, the data type of the\n    output may differ from the input's when the default dtype of None is used.\n    For inputs with integer dtype, the behavior matches that for\n    :func:`numpy.cumsum`. Floating point inputs will be promoted to at least\n    double precision. The user can set `dtype` to override this behavior.\n\n    References\n    ----------\n    .. [1] F.C. Crow, \"Summed-area tables for texture mapping,\"\n           ACM SIGGRAPH Computer Graphics, vol. 18, 1984, pp. 207-212.\n\n    \"\"\"\n    if dtype is None and image.real.dtype.kind == 'f':\n        dtype = np.promote_types(image.dtype, np.float64)\n    S = image\n    for i in range(image.ndim):\n        S = S.cumsum(axis=i, dtype=dtype)\n    return S",
        "mutated": [
            "def integral_image(image, *, dtype=None):\n    if False:\n        i = 10\n    'Integral image / summed area table.\\n\\n    The integral image contains the sum of all elements above and to the\\n    left of it, i.e.:\\n\\n    .. math::\\n\\n       S[m, n] = \\\\sum_{i \\\\leq m} \\\\sum_{j \\\\leq n} X[i, j]\\n\\n    Parameters\\n    ----------\\n    image : ndarray\\n        Input image.\\n\\n    Returns\\n    -------\\n    S : ndarray\\n        Integral image/summed area table of same shape as input image.\\n\\n    Notes\\n    -----\\n    For better accuracy and to avoid potential overflow, the data type of the\\n    output may differ from the input\\'s when the default dtype of None is used.\\n    For inputs with integer dtype, the behavior matches that for\\n    :func:`numpy.cumsum`. Floating point inputs will be promoted to at least\\n    double precision. The user can set `dtype` to override this behavior.\\n\\n    References\\n    ----------\\n    .. [1] F.C. Crow, \"Summed-area tables for texture mapping,\"\\n           ACM SIGGRAPH Computer Graphics, vol. 18, 1984, pp. 207-212.\\n\\n    '\n    if dtype is None and image.real.dtype.kind == 'f':\n        dtype = np.promote_types(image.dtype, np.float64)\n    S = image\n    for i in range(image.ndim):\n        S = S.cumsum(axis=i, dtype=dtype)\n    return S",
            "def integral_image(image, *, dtype=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Integral image / summed area table.\\n\\n    The integral image contains the sum of all elements above and to the\\n    left of it, i.e.:\\n\\n    .. math::\\n\\n       S[m, n] = \\\\sum_{i \\\\leq m} \\\\sum_{j \\\\leq n} X[i, j]\\n\\n    Parameters\\n    ----------\\n    image : ndarray\\n        Input image.\\n\\n    Returns\\n    -------\\n    S : ndarray\\n        Integral image/summed area table of same shape as input image.\\n\\n    Notes\\n    -----\\n    For better accuracy and to avoid potential overflow, the data type of the\\n    output may differ from the input\\'s when the default dtype of None is used.\\n    For inputs with integer dtype, the behavior matches that for\\n    :func:`numpy.cumsum`. Floating point inputs will be promoted to at least\\n    double precision. The user can set `dtype` to override this behavior.\\n\\n    References\\n    ----------\\n    .. [1] F.C. Crow, \"Summed-area tables for texture mapping,\"\\n           ACM SIGGRAPH Computer Graphics, vol. 18, 1984, pp. 207-212.\\n\\n    '\n    if dtype is None and image.real.dtype.kind == 'f':\n        dtype = np.promote_types(image.dtype, np.float64)\n    S = image\n    for i in range(image.ndim):\n        S = S.cumsum(axis=i, dtype=dtype)\n    return S",
            "def integral_image(image, *, dtype=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Integral image / summed area table.\\n\\n    The integral image contains the sum of all elements above and to the\\n    left of it, i.e.:\\n\\n    .. math::\\n\\n       S[m, n] = \\\\sum_{i \\\\leq m} \\\\sum_{j \\\\leq n} X[i, j]\\n\\n    Parameters\\n    ----------\\n    image : ndarray\\n        Input image.\\n\\n    Returns\\n    -------\\n    S : ndarray\\n        Integral image/summed area table of same shape as input image.\\n\\n    Notes\\n    -----\\n    For better accuracy and to avoid potential overflow, the data type of the\\n    output may differ from the input\\'s when the default dtype of None is used.\\n    For inputs with integer dtype, the behavior matches that for\\n    :func:`numpy.cumsum`. Floating point inputs will be promoted to at least\\n    double precision. The user can set `dtype` to override this behavior.\\n\\n    References\\n    ----------\\n    .. [1] F.C. Crow, \"Summed-area tables for texture mapping,\"\\n           ACM SIGGRAPH Computer Graphics, vol. 18, 1984, pp. 207-212.\\n\\n    '\n    if dtype is None and image.real.dtype.kind == 'f':\n        dtype = np.promote_types(image.dtype, np.float64)\n    S = image\n    for i in range(image.ndim):\n        S = S.cumsum(axis=i, dtype=dtype)\n    return S",
            "def integral_image(image, *, dtype=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Integral image / summed area table.\\n\\n    The integral image contains the sum of all elements above and to the\\n    left of it, i.e.:\\n\\n    .. math::\\n\\n       S[m, n] = \\\\sum_{i \\\\leq m} \\\\sum_{j \\\\leq n} X[i, j]\\n\\n    Parameters\\n    ----------\\n    image : ndarray\\n        Input image.\\n\\n    Returns\\n    -------\\n    S : ndarray\\n        Integral image/summed area table of same shape as input image.\\n\\n    Notes\\n    -----\\n    For better accuracy and to avoid potential overflow, the data type of the\\n    output may differ from the input\\'s when the default dtype of None is used.\\n    For inputs with integer dtype, the behavior matches that for\\n    :func:`numpy.cumsum`. Floating point inputs will be promoted to at least\\n    double precision. The user can set `dtype` to override this behavior.\\n\\n    References\\n    ----------\\n    .. [1] F.C. Crow, \"Summed-area tables for texture mapping,\"\\n           ACM SIGGRAPH Computer Graphics, vol. 18, 1984, pp. 207-212.\\n\\n    '\n    if dtype is None and image.real.dtype.kind == 'f':\n        dtype = np.promote_types(image.dtype, np.float64)\n    S = image\n    for i in range(image.ndim):\n        S = S.cumsum(axis=i, dtype=dtype)\n    return S",
            "def integral_image(image, *, dtype=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Integral image / summed area table.\\n\\n    The integral image contains the sum of all elements above and to the\\n    left of it, i.e.:\\n\\n    .. math::\\n\\n       S[m, n] = \\\\sum_{i \\\\leq m} \\\\sum_{j \\\\leq n} X[i, j]\\n\\n    Parameters\\n    ----------\\n    image : ndarray\\n        Input image.\\n\\n    Returns\\n    -------\\n    S : ndarray\\n        Integral image/summed area table of same shape as input image.\\n\\n    Notes\\n    -----\\n    For better accuracy and to avoid potential overflow, the data type of the\\n    output may differ from the input\\'s when the default dtype of None is used.\\n    For inputs with integer dtype, the behavior matches that for\\n    :func:`numpy.cumsum`. Floating point inputs will be promoted to at least\\n    double precision. The user can set `dtype` to override this behavior.\\n\\n    References\\n    ----------\\n    .. [1] F.C. Crow, \"Summed-area tables for texture mapping,\"\\n           ACM SIGGRAPH Computer Graphics, vol. 18, 1984, pp. 207-212.\\n\\n    '\n    if dtype is None and image.real.dtype.kind == 'f':\n        dtype = np.promote_types(image.dtype, np.float64)\n    S = image\n    for i in range(image.ndim):\n        S = S.cumsum(axis=i, dtype=dtype)\n    return S"
        ]
    },
    {
        "func_name": "integrate",
        "original": "def integrate(ii, start, end):\n    \"\"\"Use an integral image to integrate over a given window.\n\n    Parameters\n    ----------\n    ii : ndarray\n        Integral image.\n    start : List of tuples, each tuple of length equal to dimension of `ii`\n        Coordinates of top left corner of window(s).\n        Each tuple in the list contains the starting row, col, ... index\n        i.e `[(row_win1, col_win1, ...), (row_win2, col_win2,...), ...]`.\n    end : List of tuples, each tuple of length equal to dimension of `ii`\n        Coordinates of bottom right corner of window(s).\n        Each tuple in the list containing the end row, col, ... index i.e\n        `[(row_win1, col_win1, ...), (row_win2, col_win2, ...), ...]`.\n\n    Returns\n    -------\n    S : scalar or ndarray\n        Integral (sum) over the given window(s).\n\n\n    Examples\n    --------\n    >>> arr = np.ones((5, 6), dtype=float)\n    >>> ii = integral_image(arr)\n    >>> integrate(ii, (1, 0), (1, 2))  # sum from (1, 0) to (1, 2)\n    array([3.])\n    >>> integrate(ii, [(3, 3)], [(4, 5)])  # sum from (3, 3) to (4, 5)\n    array([6.])\n    >>> # sum from (1, 0) to (1, 2) and from (3, 3) to (4, 5)\n    >>> integrate(ii, [(1, 0), (3, 3)], [(1, 2), (4, 5)])\n    array([3., 6.])\n    \"\"\"\n    start = np.atleast_2d(np.array(start))\n    end = np.atleast_2d(np.array(end))\n    rows = start.shape[0]\n    total_shape = ii.shape\n    total_shape = np.tile(total_shape, [rows, 1])\n    start_negatives = start < 0\n    end_negatives = end < 0\n    start = (start + total_shape) * start_negatives + start * ~start_negatives\n    end = (end + total_shape) * end_negatives + end * ~end_negatives\n    if np.any(end - start < 0):\n        raise IndexError('end coordinates must be greater or equal to start')\n    S = np.zeros(rows)\n    bit_perm = 2 ** ii.ndim\n    width = len(bin(bit_perm - 1)[2:])\n    for i in range(bit_perm):\n        binary = bin(i)[2:].zfill(width)\n        bool_mask = [bit == '1' for bit in binary]\n        sign = (-1) ** sum(bool_mask)\n        bad = [np.any((start[r] - 1) * bool_mask < 0) for r in range(rows)]\n        corner_points = end * np.invert(bool_mask) + (start - 1) * bool_mask\n        S += [sign * ii[tuple(corner_points[r])] if not bad[r] else 0 for r in range(rows)]\n    return S",
        "mutated": [
            "def integrate(ii, start, end):\n    if False:\n        i = 10\n    'Use an integral image to integrate over a given window.\\n\\n    Parameters\\n    ----------\\n    ii : ndarray\\n        Integral image.\\n    start : List of tuples, each tuple of length equal to dimension of `ii`\\n        Coordinates of top left corner of window(s).\\n        Each tuple in the list contains the starting row, col, ... index\\n        i.e `[(row_win1, col_win1, ...), (row_win2, col_win2,...), ...]`.\\n    end : List of tuples, each tuple of length equal to dimension of `ii`\\n        Coordinates of bottom right corner of window(s).\\n        Each tuple in the list containing the end row, col, ... index i.e\\n        `[(row_win1, col_win1, ...), (row_win2, col_win2, ...), ...]`.\\n\\n    Returns\\n    -------\\n    S : scalar or ndarray\\n        Integral (sum) over the given window(s).\\n\\n\\n    Examples\\n    --------\\n    >>> arr = np.ones((5, 6), dtype=float)\\n    >>> ii = integral_image(arr)\\n    >>> integrate(ii, (1, 0), (1, 2))  # sum from (1, 0) to (1, 2)\\n    array([3.])\\n    >>> integrate(ii, [(3, 3)], [(4, 5)])  # sum from (3, 3) to (4, 5)\\n    array([6.])\\n    >>> # sum from (1, 0) to (1, 2) and from (3, 3) to (4, 5)\\n    >>> integrate(ii, [(1, 0), (3, 3)], [(1, 2), (4, 5)])\\n    array([3., 6.])\\n    '\n    start = np.atleast_2d(np.array(start))\n    end = np.atleast_2d(np.array(end))\n    rows = start.shape[0]\n    total_shape = ii.shape\n    total_shape = np.tile(total_shape, [rows, 1])\n    start_negatives = start < 0\n    end_negatives = end < 0\n    start = (start + total_shape) * start_negatives + start * ~start_negatives\n    end = (end + total_shape) * end_negatives + end * ~end_negatives\n    if np.any(end - start < 0):\n        raise IndexError('end coordinates must be greater or equal to start')\n    S = np.zeros(rows)\n    bit_perm = 2 ** ii.ndim\n    width = len(bin(bit_perm - 1)[2:])\n    for i in range(bit_perm):\n        binary = bin(i)[2:].zfill(width)\n        bool_mask = [bit == '1' for bit in binary]\n        sign = (-1) ** sum(bool_mask)\n        bad = [np.any((start[r] - 1) * bool_mask < 0) for r in range(rows)]\n        corner_points = end * np.invert(bool_mask) + (start - 1) * bool_mask\n        S += [sign * ii[tuple(corner_points[r])] if not bad[r] else 0 for r in range(rows)]\n    return S",
            "def integrate(ii, start, end):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Use an integral image to integrate over a given window.\\n\\n    Parameters\\n    ----------\\n    ii : ndarray\\n        Integral image.\\n    start : List of tuples, each tuple of length equal to dimension of `ii`\\n        Coordinates of top left corner of window(s).\\n        Each tuple in the list contains the starting row, col, ... index\\n        i.e `[(row_win1, col_win1, ...), (row_win2, col_win2,...), ...]`.\\n    end : List of tuples, each tuple of length equal to dimension of `ii`\\n        Coordinates of bottom right corner of window(s).\\n        Each tuple in the list containing the end row, col, ... index i.e\\n        `[(row_win1, col_win1, ...), (row_win2, col_win2, ...), ...]`.\\n\\n    Returns\\n    -------\\n    S : scalar or ndarray\\n        Integral (sum) over the given window(s).\\n\\n\\n    Examples\\n    --------\\n    >>> arr = np.ones((5, 6), dtype=float)\\n    >>> ii = integral_image(arr)\\n    >>> integrate(ii, (1, 0), (1, 2))  # sum from (1, 0) to (1, 2)\\n    array([3.])\\n    >>> integrate(ii, [(3, 3)], [(4, 5)])  # sum from (3, 3) to (4, 5)\\n    array([6.])\\n    >>> # sum from (1, 0) to (1, 2) and from (3, 3) to (4, 5)\\n    >>> integrate(ii, [(1, 0), (3, 3)], [(1, 2), (4, 5)])\\n    array([3., 6.])\\n    '\n    start = np.atleast_2d(np.array(start))\n    end = np.atleast_2d(np.array(end))\n    rows = start.shape[0]\n    total_shape = ii.shape\n    total_shape = np.tile(total_shape, [rows, 1])\n    start_negatives = start < 0\n    end_negatives = end < 0\n    start = (start + total_shape) * start_negatives + start * ~start_negatives\n    end = (end + total_shape) * end_negatives + end * ~end_negatives\n    if np.any(end - start < 0):\n        raise IndexError('end coordinates must be greater or equal to start')\n    S = np.zeros(rows)\n    bit_perm = 2 ** ii.ndim\n    width = len(bin(bit_perm - 1)[2:])\n    for i in range(bit_perm):\n        binary = bin(i)[2:].zfill(width)\n        bool_mask = [bit == '1' for bit in binary]\n        sign = (-1) ** sum(bool_mask)\n        bad = [np.any((start[r] - 1) * bool_mask < 0) for r in range(rows)]\n        corner_points = end * np.invert(bool_mask) + (start - 1) * bool_mask\n        S += [sign * ii[tuple(corner_points[r])] if not bad[r] else 0 for r in range(rows)]\n    return S",
            "def integrate(ii, start, end):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Use an integral image to integrate over a given window.\\n\\n    Parameters\\n    ----------\\n    ii : ndarray\\n        Integral image.\\n    start : List of tuples, each tuple of length equal to dimension of `ii`\\n        Coordinates of top left corner of window(s).\\n        Each tuple in the list contains the starting row, col, ... index\\n        i.e `[(row_win1, col_win1, ...), (row_win2, col_win2,...), ...]`.\\n    end : List of tuples, each tuple of length equal to dimension of `ii`\\n        Coordinates of bottom right corner of window(s).\\n        Each tuple in the list containing the end row, col, ... index i.e\\n        `[(row_win1, col_win1, ...), (row_win2, col_win2, ...), ...]`.\\n\\n    Returns\\n    -------\\n    S : scalar or ndarray\\n        Integral (sum) over the given window(s).\\n\\n\\n    Examples\\n    --------\\n    >>> arr = np.ones((5, 6), dtype=float)\\n    >>> ii = integral_image(arr)\\n    >>> integrate(ii, (1, 0), (1, 2))  # sum from (1, 0) to (1, 2)\\n    array([3.])\\n    >>> integrate(ii, [(3, 3)], [(4, 5)])  # sum from (3, 3) to (4, 5)\\n    array([6.])\\n    >>> # sum from (1, 0) to (1, 2) and from (3, 3) to (4, 5)\\n    >>> integrate(ii, [(1, 0), (3, 3)], [(1, 2), (4, 5)])\\n    array([3., 6.])\\n    '\n    start = np.atleast_2d(np.array(start))\n    end = np.atleast_2d(np.array(end))\n    rows = start.shape[0]\n    total_shape = ii.shape\n    total_shape = np.tile(total_shape, [rows, 1])\n    start_negatives = start < 0\n    end_negatives = end < 0\n    start = (start + total_shape) * start_negatives + start * ~start_negatives\n    end = (end + total_shape) * end_negatives + end * ~end_negatives\n    if np.any(end - start < 0):\n        raise IndexError('end coordinates must be greater or equal to start')\n    S = np.zeros(rows)\n    bit_perm = 2 ** ii.ndim\n    width = len(bin(bit_perm - 1)[2:])\n    for i in range(bit_perm):\n        binary = bin(i)[2:].zfill(width)\n        bool_mask = [bit == '1' for bit in binary]\n        sign = (-1) ** sum(bool_mask)\n        bad = [np.any((start[r] - 1) * bool_mask < 0) for r in range(rows)]\n        corner_points = end * np.invert(bool_mask) + (start - 1) * bool_mask\n        S += [sign * ii[tuple(corner_points[r])] if not bad[r] else 0 for r in range(rows)]\n    return S",
            "def integrate(ii, start, end):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Use an integral image to integrate over a given window.\\n\\n    Parameters\\n    ----------\\n    ii : ndarray\\n        Integral image.\\n    start : List of tuples, each tuple of length equal to dimension of `ii`\\n        Coordinates of top left corner of window(s).\\n        Each tuple in the list contains the starting row, col, ... index\\n        i.e `[(row_win1, col_win1, ...), (row_win2, col_win2,...), ...]`.\\n    end : List of tuples, each tuple of length equal to dimension of `ii`\\n        Coordinates of bottom right corner of window(s).\\n        Each tuple in the list containing the end row, col, ... index i.e\\n        `[(row_win1, col_win1, ...), (row_win2, col_win2, ...), ...]`.\\n\\n    Returns\\n    -------\\n    S : scalar or ndarray\\n        Integral (sum) over the given window(s).\\n\\n\\n    Examples\\n    --------\\n    >>> arr = np.ones((5, 6), dtype=float)\\n    >>> ii = integral_image(arr)\\n    >>> integrate(ii, (1, 0), (1, 2))  # sum from (1, 0) to (1, 2)\\n    array([3.])\\n    >>> integrate(ii, [(3, 3)], [(4, 5)])  # sum from (3, 3) to (4, 5)\\n    array([6.])\\n    >>> # sum from (1, 0) to (1, 2) and from (3, 3) to (4, 5)\\n    >>> integrate(ii, [(1, 0), (3, 3)], [(1, 2), (4, 5)])\\n    array([3., 6.])\\n    '\n    start = np.atleast_2d(np.array(start))\n    end = np.atleast_2d(np.array(end))\n    rows = start.shape[0]\n    total_shape = ii.shape\n    total_shape = np.tile(total_shape, [rows, 1])\n    start_negatives = start < 0\n    end_negatives = end < 0\n    start = (start + total_shape) * start_negatives + start * ~start_negatives\n    end = (end + total_shape) * end_negatives + end * ~end_negatives\n    if np.any(end - start < 0):\n        raise IndexError('end coordinates must be greater or equal to start')\n    S = np.zeros(rows)\n    bit_perm = 2 ** ii.ndim\n    width = len(bin(bit_perm - 1)[2:])\n    for i in range(bit_perm):\n        binary = bin(i)[2:].zfill(width)\n        bool_mask = [bit == '1' for bit in binary]\n        sign = (-1) ** sum(bool_mask)\n        bad = [np.any((start[r] - 1) * bool_mask < 0) for r in range(rows)]\n        corner_points = end * np.invert(bool_mask) + (start - 1) * bool_mask\n        S += [sign * ii[tuple(corner_points[r])] if not bad[r] else 0 for r in range(rows)]\n    return S",
            "def integrate(ii, start, end):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Use an integral image to integrate over a given window.\\n\\n    Parameters\\n    ----------\\n    ii : ndarray\\n        Integral image.\\n    start : List of tuples, each tuple of length equal to dimension of `ii`\\n        Coordinates of top left corner of window(s).\\n        Each tuple in the list contains the starting row, col, ... index\\n        i.e `[(row_win1, col_win1, ...), (row_win2, col_win2,...), ...]`.\\n    end : List of tuples, each tuple of length equal to dimension of `ii`\\n        Coordinates of bottom right corner of window(s).\\n        Each tuple in the list containing the end row, col, ... index i.e\\n        `[(row_win1, col_win1, ...), (row_win2, col_win2, ...), ...]`.\\n\\n    Returns\\n    -------\\n    S : scalar or ndarray\\n        Integral (sum) over the given window(s).\\n\\n\\n    Examples\\n    --------\\n    >>> arr = np.ones((5, 6), dtype=float)\\n    >>> ii = integral_image(arr)\\n    >>> integrate(ii, (1, 0), (1, 2))  # sum from (1, 0) to (1, 2)\\n    array([3.])\\n    >>> integrate(ii, [(3, 3)], [(4, 5)])  # sum from (3, 3) to (4, 5)\\n    array([6.])\\n    >>> # sum from (1, 0) to (1, 2) and from (3, 3) to (4, 5)\\n    >>> integrate(ii, [(1, 0), (3, 3)], [(1, 2), (4, 5)])\\n    array([3., 6.])\\n    '\n    start = np.atleast_2d(np.array(start))\n    end = np.atleast_2d(np.array(end))\n    rows = start.shape[0]\n    total_shape = ii.shape\n    total_shape = np.tile(total_shape, [rows, 1])\n    start_negatives = start < 0\n    end_negatives = end < 0\n    start = (start + total_shape) * start_negatives + start * ~start_negatives\n    end = (end + total_shape) * end_negatives + end * ~end_negatives\n    if np.any(end - start < 0):\n        raise IndexError('end coordinates must be greater or equal to start')\n    S = np.zeros(rows)\n    bit_perm = 2 ** ii.ndim\n    width = len(bin(bit_perm - 1)[2:])\n    for i in range(bit_perm):\n        binary = bin(i)[2:].zfill(width)\n        bool_mask = [bit == '1' for bit in binary]\n        sign = (-1) ** sum(bool_mask)\n        bad = [np.any((start[r] - 1) * bool_mask < 0) for r in range(rows)]\n        corner_points = end * np.invert(bool_mask) + (start - 1) * bool_mask\n        S += [sign * ii[tuple(corner_points[r])] if not bad[r] else 0 for r in range(rows)]\n    return S"
        ]
    }
]