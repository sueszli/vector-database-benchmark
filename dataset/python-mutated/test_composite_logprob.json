[
    {
        "func_name": "test_scalar_clipped_mixture",
        "original": "def test_scalar_clipped_mixture():\n    x = pt.clip(pt.random.normal(loc=1), 0.5, 1.5)\n    x.name = 'x'\n    y = pt.random.beta(1, 2, name='y')\n    comps = pt.stack([x, y])\n    comps.name = 'comps'\n    idxs = pt.random.bernoulli(0.4, name='idxs')\n    mix = comps[idxs]\n    mix.name = 'mix'\n    mix_vv = mix.clone()\n    mix_vv.name = 'mix_val'\n    idxs_vv = idxs.clone()\n    idxs_vv.name = 'idxs_val'\n    logp = conditional_logp({idxs: idxs_vv, mix: mix_vv})\n    logp_combined = pt.sum([pt.sum(factor) for factor in logp.values()])\n    logp_fn = pytensor.function([idxs_vv, mix_vv], logp_combined)\n    assert logp_fn(0, 0.4) == -np.inf\n    assert np.isclose(logp_fn(0, 0.5), st.norm.logcdf(0.5, 1) + np.log(0.6))\n    assert np.isclose(logp_fn(0, 1.3), st.norm.logpdf(1.3, 1) + np.log(0.6))\n    assert np.isclose(logp_fn(1, 0.4), st.beta.logpdf(0.4, 1, 2) + np.log(0.4))",
        "mutated": [
            "def test_scalar_clipped_mixture():\n    if False:\n        i = 10\n    x = pt.clip(pt.random.normal(loc=1), 0.5, 1.5)\n    x.name = 'x'\n    y = pt.random.beta(1, 2, name='y')\n    comps = pt.stack([x, y])\n    comps.name = 'comps'\n    idxs = pt.random.bernoulli(0.4, name='idxs')\n    mix = comps[idxs]\n    mix.name = 'mix'\n    mix_vv = mix.clone()\n    mix_vv.name = 'mix_val'\n    idxs_vv = idxs.clone()\n    idxs_vv.name = 'idxs_val'\n    logp = conditional_logp({idxs: idxs_vv, mix: mix_vv})\n    logp_combined = pt.sum([pt.sum(factor) for factor in logp.values()])\n    logp_fn = pytensor.function([idxs_vv, mix_vv], logp_combined)\n    assert logp_fn(0, 0.4) == -np.inf\n    assert np.isclose(logp_fn(0, 0.5), st.norm.logcdf(0.5, 1) + np.log(0.6))\n    assert np.isclose(logp_fn(0, 1.3), st.norm.logpdf(1.3, 1) + np.log(0.6))\n    assert np.isclose(logp_fn(1, 0.4), st.beta.logpdf(0.4, 1, 2) + np.log(0.4))",
            "def test_scalar_clipped_mixture():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    x = pt.clip(pt.random.normal(loc=1), 0.5, 1.5)\n    x.name = 'x'\n    y = pt.random.beta(1, 2, name='y')\n    comps = pt.stack([x, y])\n    comps.name = 'comps'\n    idxs = pt.random.bernoulli(0.4, name='idxs')\n    mix = comps[idxs]\n    mix.name = 'mix'\n    mix_vv = mix.clone()\n    mix_vv.name = 'mix_val'\n    idxs_vv = idxs.clone()\n    idxs_vv.name = 'idxs_val'\n    logp = conditional_logp({idxs: idxs_vv, mix: mix_vv})\n    logp_combined = pt.sum([pt.sum(factor) for factor in logp.values()])\n    logp_fn = pytensor.function([idxs_vv, mix_vv], logp_combined)\n    assert logp_fn(0, 0.4) == -np.inf\n    assert np.isclose(logp_fn(0, 0.5), st.norm.logcdf(0.5, 1) + np.log(0.6))\n    assert np.isclose(logp_fn(0, 1.3), st.norm.logpdf(1.3, 1) + np.log(0.6))\n    assert np.isclose(logp_fn(1, 0.4), st.beta.logpdf(0.4, 1, 2) + np.log(0.4))",
            "def test_scalar_clipped_mixture():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    x = pt.clip(pt.random.normal(loc=1), 0.5, 1.5)\n    x.name = 'x'\n    y = pt.random.beta(1, 2, name='y')\n    comps = pt.stack([x, y])\n    comps.name = 'comps'\n    idxs = pt.random.bernoulli(0.4, name='idxs')\n    mix = comps[idxs]\n    mix.name = 'mix'\n    mix_vv = mix.clone()\n    mix_vv.name = 'mix_val'\n    idxs_vv = idxs.clone()\n    idxs_vv.name = 'idxs_val'\n    logp = conditional_logp({idxs: idxs_vv, mix: mix_vv})\n    logp_combined = pt.sum([pt.sum(factor) for factor in logp.values()])\n    logp_fn = pytensor.function([idxs_vv, mix_vv], logp_combined)\n    assert logp_fn(0, 0.4) == -np.inf\n    assert np.isclose(logp_fn(0, 0.5), st.norm.logcdf(0.5, 1) + np.log(0.6))\n    assert np.isclose(logp_fn(0, 1.3), st.norm.logpdf(1.3, 1) + np.log(0.6))\n    assert np.isclose(logp_fn(1, 0.4), st.beta.logpdf(0.4, 1, 2) + np.log(0.4))",
            "def test_scalar_clipped_mixture():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    x = pt.clip(pt.random.normal(loc=1), 0.5, 1.5)\n    x.name = 'x'\n    y = pt.random.beta(1, 2, name='y')\n    comps = pt.stack([x, y])\n    comps.name = 'comps'\n    idxs = pt.random.bernoulli(0.4, name='idxs')\n    mix = comps[idxs]\n    mix.name = 'mix'\n    mix_vv = mix.clone()\n    mix_vv.name = 'mix_val'\n    idxs_vv = idxs.clone()\n    idxs_vv.name = 'idxs_val'\n    logp = conditional_logp({idxs: idxs_vv, mix: mix_vv})\n    logp_combined = pt.sum([pt.sum(factor) for factor in logp.values()])\n    logp_fn = pytensor.function([idxs_vv, mix_vv], logp_combined)\n    assert logp_fn(0, 0.4) == -np.inf\n    assert np.isclose(logp_fn(0, 0.5), st.norm.logcdf(0.5, 1) + np.log(0.6))\n    assert np.isclose(logp_fn(0, 1.3), st.norm.logpdf(1.3, 1) + np.log(0.6))\n    assert np.isclose(logp_fn(1, 0.4), st.beta.logpdf(0.4, 1, 2) + np.log(0.4))",
            "def test_scalar_clipped_mixture():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    x = pt.clip(pt.random.normal(loc=1), 0.5, 1.5)\n    x.name = 'x'\n    y = pt.random.beta(1, 2, name='y')\n    comps = pt.stack([x, y])\n    comps.name = 'comps'\n    idxs = pt.random.bernoulli(0.4, name='idxs')\n    mix = comps[idxs]\n    mix.name = 'mix'\n    mix_vv = mix.clone()\n    mix_vv.name = 'mix_val'\n    idxs_vv = idxs.clone()\n    idxs_vv.name = 'idxs_val'\n    logp = conditional_logp({idxs: idxs_vv, mix: mix_vv})\n    logp_combined = pt.sum([pt.sum(factor) for factor in logp.values()])\n    logp_fn = pytensor.function([idxs_vv, mix_vv], logp_combined)\n    assert logp_fn(0, 0.4) == -np.inf\n    assert np.isclose(logp_fn(0, 0.5), st.norm.logcdf(0.5, 1) + np.log(0.6))\n    assert np.isclose(logp_fn(0, 1.3), st.norm.logpdf(1.3, 1) + np.log(0.6))\n    assert np.isclose(logp_fn(1, 0.4), st.beta.logpdf(0.4, 1, 2) + np.log(0.4))"
        ]
    },
    {
        "func_name": "test_nested_scalar_mixtures",
        "original": "def test_nested_scalar_mixtures():\n    x = pt.random.normal(loc=-50, name='x')\n    y = pt.random.normal(loc=50, name='y')\n    comps1 = pt.stack([x, y])\n    comps1.name = 'comps1'\n    idxs1 = pt.random.bernoulli(0.5, name='idxs1')\n    mix1 = comps1[idxs1]\n    mix1.name = 'mix1'\n    w = pt.random.normal(loc=-100, name='w')\n    z = pt.random.normal(loc=100, name='z')\n    comps2 = pt.stack([w, z])\n    comps2.name = 'comps2'\n    idxs2 = pt.random.bernoulli(0.5, name='idxs2')\n    mix2 = comps2[idxs2]\n    mix2.name = 'mix2'\n    comps12 = pt.stack([mix1, mix2])\n    comps12.name = 'comps12'\n    idxs12 = pt.random.bernoulli(0.5, name='idxs12')\n    mix12 = comps12[idxs12]\n    mix12.name = 'mix12'\n    idxs1_vv = idxs1.clone()\n    idxs2_vv = idxs2.clone()\n    idxs12_vv = idxs12.clone()\n    mix12_vv = mix12.clone()\n    logp = conditional_logp({idxs1: idxs1_vv, idxs2: idxs2_vv, idxs12: idxs12_vv, mix12: mix12_vv})\n    logp_combined = pt.sum([pt.sum(factor) for factor in logp.values()])\n    logp_fn = pytensor.function([idxs1_vv, idxs2_vv, idxs12_vv, mix12_vv], logp_combined)\n    expected_mu_logpdf = st.norm.logpdf(0) + np.log(0.5) * 3\n    assert np.isclose(logp_fn(0, 0, 0, -50), expected_mu_logpdf)\n    assert np.isclose(logp_fn(0, 1, 0, -50), expected_mu_logpdf)\n    assert np.isclose(logp_fn(1, 0, 0, 50), expected_mu_logpdf)\n    assert np.isclose(logp_fn(1, 1, 0, 50), expected_mu_logpdf)\n    assert np.isclose(logp_fn(0, 0, 1, -100), expected_mu_logpdf)\n    assert np.isclose(logp_fn(0, 1, 1, 100), expected_mu_logpdf)\n    assert np.isclose(logp_fn(1, 0, 1, -100), expected_mu_logpdf)\n    assert np.isclose(logp_fn(1, 1, 1, 100), expected_mu_logpdf)\n    assert np.isclose(logp_fn(0, 0, 0, 50), st.norm.logpdf(100) + np.log(0.5) * 3)\n    assert np.isclose(logp_fn(0, 0, 1, 50), st.norm.logpdf(150) + np.log(0.5) * 3)",
        "mutated": [
            "def test_nested_scalar_mixtures():\n    if False:\n        i = 10\n    x = pt.random.normal(loc=-50, name='x')\n    y = pt.random.normal(loc=50, name='y')\n    comps1 = pt.stack([x, y])\n    comps1.name = 'comps1'\n    idxs1 = pt.random.bernoulli(0.5, name='idxs1')\n    mix1 = comps1[idxs1]\n    mix1.name = 'mix1'\n    w = pt.random.normal(loc=-100, name='w')\n    z = pt.random.normal(loc=100, name='z')\n    comps2 = pt.stack([w, z])\n    comps2.name = 'comps2'\n    idxs2 = pt.random.bernoulli(0.5, name='idxs2')\n    mix2 = comps2[idxs2]\n    mix2.name = 'mix2'\n    comps12 = pt.stack([mix1, mix2])\n    comps12.name = 'comps12'\n    idxs12 = pt.random.bernoulli(0.5, name='idxs12')\n    mix12 = comps12[idxs12]\n    mix12.name = 'mix12'\n    idxs1_vv = idxs1.clone()\n    idxs2_vv = idxs2.clone()\n    idxs12_vv = idxs12.clone()\n    mix12_vv = mix12.clone()\n    logp = conditional_logp({idxs1: idxs1_vv, idxs2: idxs2_vv, idxs12: idxs12_vv, mix12: mix12_vv})\n    logp_combined = pt.sum([pt.sum(factor) for factor in logp.values()])\n    logp_fn = pytensor.function([idxs1_vv, idxs2_vv, idxs12_vv, mix12_vv], logp_combined)\n    expected_mu_logpdf = st.norm.logpdf(0) + np.log(0.5) * 3\n    assert np.isclose(logp_fn(0, 0, 0, -50), expected_mu_logpdf)\n    assert np.isclose(logp_fn(0, 1, 0, -50), expected_mu_logpdf)\n    assert np.isclose(logp_fn(1, 0, 0, 50), expected_mu_logpdf)\n    assert np.isclose(logp_fn(1, 1, 0, 50), expected_mu_logpdf)\n    assert np.isclose(logp_fn(0, 0, 1, -100), expected_mu_logpdf)\n    assert np.isclose(logp_fn(0, 1, 1, 100), expected_mu_logpdf)\n    assert np.isclose(logp_fn(1, 0, 1, -100), expected_mu_logpdf)\n    assert np.isclose(logp_fn(1, 1, 1, 100), expected_mu_logpdf)\n    assert np.isclose(logp_fn(0, 0, 0, 50), st.norm.logpdf(100) + np.log(0.5) * 3)\n    assert np.isclose(logp_fn(0, 0, 1, 50), st.norm.logpdf(150) + np.log(0.5) * 3)",
            "def test_nested_scalar_mixtures():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    x = pt.random.normal(loc=-50, name='x')\n    y = pt.random.normal(loc=50, name='y')\n    comps1 = pt.stack([x, y])\n    comps1.name = 'comps1'\n    idxs1 = pt.random.bernoulli(0.5, name='idxs1')\n    mix1 = comps1[idxs1]\n    mix1.name = 'mix1'\n    w = pt.random.normal(loc=-100, name='w')\n    z = pt.random.normal(loc=100, name='z')\n    comps2 = pt.stack([w, z])\n    comps2.name = 'comps2'\n    idxs2 = pt.random.bernoulli(0.5, name='idxs2')\n    mix2 = comps2[idxs2]\n    mix2.name = 'mix2'\n    comps12 = pt.stack([mix1, mix2])\n    comps12.name = 'comps12'\n    idxs12 = pt.random.bernoulli(0.5, name='idxs12')\n    mix12 = comps12[idxs12]\n    mix12.name = 'mix12'\n    idxs1_vv = idxs1.clone()\n    idxs2_vv = idxs2.clone()\n    idxs12_vv = idxs12.clone()\n    mix12_vv = mix12.clone()\n    logp = conditional_logp({idxs1: idxs1_vv, idxs2: idxs2_vv, idxs12: idxs12_vv, mix12: mix12_vv})\n    logp_combined = pt.sum([pt.sum(factor) for factor in logp.values()])\n    logp_fn = pytensor.function([idxs1_vv, idxs2_vv, idxs12_vv, mix12_vv], logp_combined)\n    expected_mu_logpdf = st.norm.logpdf(0) + np.log(0.5) * 3\n    assert np.isclose(logp_fn(0, 0, 0, -50), expected_mu_logpdf)\n    assert np.isclose(logp_fn(0, 1, 0, -50), expected_mu_logpdf)\n    assert np.isclose(logp_fn(1, 0, 0, 50), expected_mu_logpdf)\n    assert np.isclose(logp_fn(1, 1, 0, 50), expected_mu_logpdf)\n    assert np.isclose(logp_fn(0, 0, 1, -100), expected_mu_logpdf)\n    assert np.isclose(logp_fn(0, 1, 1, 100), expected_mu_logpdf)\n    assert np.isclose(logp_fn(1, 0, 1, -100), expected_mu_logpdf)\n    assert np.isclose(logp_fn(1, 1, 1, 100), expected_mu_logpdf)\n    assert np.isclose(logp_fn(0, 0, 0, 50), st.norm.logpdf(100) + np.log(0.5) * 3)\n    assert np.isclose(logp_fn(0, 0, 1, 50), st.norm.logpdf(150) + np.log(0.5) * 3)",
            "def test_nested_scalar_mixtures():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    x = pt.random.normal(loc=-50, name='x')\n    y = pt.random.normal(loc=50, name='y')\n    comps1 = pt.stack([x, y])\n    comps1.name = 'comps1'\n    idxs1 = pt.random.bernoulli(0.5, name='idxs1')\n    mix1 = comps1[idxs1]\n    mix1.name = 'mix1'\n    w = pt.random.normal(loc=-100, name='w')\n    z = pt.random.normal(loc=100, name='z')\n    comps2 = pt.stack([w, z])\n    comps2.name = 'comps2'\n    idxs2 = pt.random.bernoulli(0.5, name='idxs2')\n    mix2 = comps2[idxs2]\n    mix2.name = 'mix2'\n    comps12 = pt.stack([mix1, mix2])\n    comps12.name = 'comps12'\n    idxs12 = pt.random.bernoulli(0.5, name='idxs12')\n    mix12 = comps12[idxs12]\n    mix12.name = 'mix12'\n    idxs1_vv = idxs1.clone()\n    idxs2_vv = idxs2.clone()\n    idxs12_vv = idxs12.clone()\n    mix12_vv = mix12.clone()\n    logp = conditional_logp({idxs1: idxs1_vv, idxs2: idxs2_vv, idxs12: idxs12_vv, mix12: mix12_vv})\n    logp_combined = pt.sum([pt.sum(factor) for factor in logp.values()])\n    logp_fn = pytensor.function([idxs1_vv, idxs2_vv, idxs12_vv, mix12_vv], logp_combined)\n    expected_mu_logpdf = st.norm.logpdf(0) + np.log(0.5) * 3\n    assert np.isclose(logp_fn(0, 0, 0, -50), expected_mu_logpdf)\n    assert np.isclose(logp_fn(0, 1, 0, -50), expected_mu_logpdf)\n    assert np.isclose(logp_fn(1, 0, 0, 50), expected_mu_logpdf)\n    assert np.isclose(logp_fn(1, 1, 0, 50), expected_mu_logpdf)\n    assert np.isclose(logp_fn(0, 0, 1, -100), expected_mu_logpdf)\n    assert np.isclose(logp_fn(0, 1, 1, 100), expected_mu_logpdf)\n    assert np.isclose(logp_fn(1, 0, 1, -100), expected_mu_logpdf)\n    assert np.isclose(logp_fn(1, 1, 1, 100), expected_mu_logpdf)\n    assert np.isclose(logp_fn(0, 0, 0, 50), st.norm.logpdf(100) + np.log(0.5) * 3)\n    assert np.isclose(logp_fn(0, 0, 1, 50), st.norm.logpdf(150) + np.log(0.5) * 3)",
            "def test_nested_scalar_mixtures():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    x = pt.random.normal(loc=-50, name='x')\n    y = pt.random.normal(loc=50, name='y')\n    comps1 = pt.stack([x, y])\n    comps1.name = 'comps1'\n    idxs1 = pt.random.bernoulli(0.5, name='idxs1')\n    mix1 = comps1[idxs1]\n    mix1.name = 'mix1'\n    w = pt.random.normal(loc=-100, name='w')\n    z = pt.random.normal(loc=100, name='z')\n    comps2 = pt.stack([w, z])\n    comps2.name = 'comps2'\n    idxs2 = pt.random.bernoulli(0.5, name='idxs2')\n    mix2 = comps2[idxs2]\n    mix2.name = 'mix2'\n    comps12 = pt.stack([mix1, mix2])\n    comps12.name = 'comps12'\n    idxs12 = pt.random.bernoulli(0.5, name='idxs12')\n    mix12 = comps12[idxs12]\n    mix12.name = 'mix12'\n    idxs1_vv = idxs1.clone()\n    idxs2_vv = idxs2.clone()\n    idxs12_vv = idxs12.clone()\n    mix12_vv = mix12.clone()\n    logp = conditional_logp({idxs1: idxs1_vv, idxs2: idxs2_vv, idxs12: idxs12_vv, mix12: mix12_vv})\n    logp_combined = pt.sum([pt.sum(factor) for factor in logp.values()])\n    logp_fn = pytensor.function([idxs1_vv, idxs2_vv, idxs12_vv, mix12_vv], logp_combined)\n    expected_mu_logpdf = st.norm.logpdf(0) + np.log(0.5) * 3\n    assert np.isclose(logp_fn(0, 0, 0, -50), expected_mu_logpdf)\n    assert np.isclose(logp_fn(0, 1, 0, -50), expected_mu_logpdf)\n    assert np.isclose(logp_fn(1, 0, 0, 50), expected_mu_logpdf)\n    assert np.isclose(logp_fn(1, 1, 0, 50), expected_mu_logpdf)\n    assert np.isclose(logp_fn(0, 0, 1, -100), expected_mu_logpdf)\n    assert np.isclose(logp_fn(0, 1, 1, 100), expected_mu_logpdf)\n    assert np.isclose(logp_fn(1, 0, 1, -100), expected_mu_logpdf)\n    assert np.isclose(logp_fn(1, 1, 1, 100), expected_mu_logpdf)\n    assert np.isclose(logp_fn(0, 0, 0, 50), st.norm.logpdf(100) + np.log(0.5) * 3)\n    assert np.isclose(logp_fn(0, 0, 1, 50), st.norm.logpdf(150) + np.log(0.5) * 3)",
            "def test_nested_scalar_mixtures():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    x = pt.random.normal(loc=-50, name='x')\n    y = pt.random.normal(loc=50, name='y')\n    comps1 = pt.stack([x, y])\n    comps1.name = 'comps1'\n    idxs1 = pt.random.bernoulli(0.5, name='idxs1')\n    mix1 = comps1[idxs1]\n    mix1.name = 'mix1'\n    w = pt.random.normal(loc=-100, name='w')\n    z = pt.random.normal(loc=100, name='z')\n    comps2 = pt.stack([w, z])\n    comps2.name = 'comps2'\n    idxs2 = pt.random.bernoulli(0.5, name='idxs2')\n    mix2 = comps2[idxs2]\n    mix2.name = 'mix2'\n    comps12 = pt.stack([mix1, mix2])\n    comps12.name = 'comps12'\n    idxs12 = pt.random.bernoulli(0.5, name='idxs12')\n    mix12 = comps12[idxs12]\n    mix12.name = 'mix12'\n    idxs1_vv = idxs1.clone()\n    idxs2_vv = idxs2.clone()\n    idxs12_vv = idxs12.clone()\n    mix12_vv = mix12.clone()\n    logp = conditional_logp({idxs1: idxs1_vv, idxs2: idxs2_vv, idxs12: idxs12_vv, mix12: mix12_vv})\n    logp_combined = pt.sum([pt.sum(factor) for factor in logp.values()])\n    logp_fn = pytensor.function([idxs1_vv, idxs2_vv, idxs12_vv, mix12_vv], logp_combined)\n    expected_mu_logpdf = st.norm.logpdf(0) + np.log(0.5) * 3\n    assert np.isclose(logp_fn(0, 0, 0, -50), expected_mu_logpdf)\n    assert np.isclose(logp_fn(0, 1, 0, -50), expected_mu_logpdf)\n    assert np.isclose(logp_fn(1, 0, 0, 50), expected_mu_logpdf)\n    assert np.isclose(logp_fn(1, 1, 0, 50), expected_mu_logpdf)\n    assert np.isclose(logp_fn(0, 0, 1, -100), expected_mu_logpdf)\n    assert np.isclose(logp_fn(0, 1, 1, 100), expected_mu_logpdf)\n    assert np.isclose(logp_fn(1, 0, 1, -100), expected_mu_logpdf)\n    assert np.isclose(logp_fn(1, 1, 1, 100), expected_mu_logpdf)\n    assert np.isclose(logp_fn(0, 0, 0, 50), st.norm.logpdf(100) + np.log(0.5) * 3)\n    assert np.isclose(logp_fn(0, 0, 1, 50), st.norm.logpdf(150) + np.log(0.5) * 3)"
        ]
    },
    {
        "func_name": "test_unvalued_ir_reversion",
        "original": "@pytest.mark.parametrize('nested', (False, True))\ndef test_unvalued_ir_reversion(nested):\n    \"\"\"Make sure that un-valued IR rewrites are reverted.\"\"\"\n    x_rv = pt.random.normal()\n    y_rv = pt.clip(x_rv, 0, 1)\n    if nested:\n        y_rv = y_rv + 5\n    z_rv = pt.random.normal(y_rv, 1, name='z')\n    z_vv = z_rv.clone()\n    rv_values = {z_rv: z_vv}\n    (z_fgraph, _, memo) = construct_ir_fgraph(rv_values)\n    assert sum((isinstance(node.op, MeasurableVariable) for node in z_fgraph.apply_nodes)) == 2",
        "mutated": [
            "@pytest.mark.parametrize('nested', (False, True))\ndef test_unvalued_ir_reversion(nested):\n    if False:\n        i = 10\n    'Make sure that un-valued IR rewrites are reverted.'\n    x_rv = pt.random.normal()\n    y_rv = pt.clip(x_rv, 0, 1)\n    if nested:\n        y_rv = y_rv + 5\n    z_rv = pt.random.normal(y_rv, 1, name='z')\n    z_vv = z_rv.clone()\n    rv_values = {z_rv: z_vv}\n    (z_fgraph, _, memo) = construct_ir_fgraph(rv_values)\n    assert sum((isinstance(node.op, MeasurableVariable) for node in z_fgraph.apply_nodes)) == 2",
            "@pytest.mark.parametrize('nested', (False, True))\ndef test_unvalued_ir_reversion(nested):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Make sure that un-valued IR rewrites are reverted.'\n    x_rv = pt.random.normal()\n    y_rv = pt.clip(x_rv, 0, 1)\n    if nested:\n        y_rv = y_rv + 5\n    z_rv = pt.random.normal(y_rv, 1, name='z')\n    z_vv = z_rv.clone()\n    rv_values = {z_rv: z_vv}\n    (z_fgraph, _, memo) = construct_ir_fgraph(rv_values)\n    assert sum((isinstance(node.op, MeasurableVariable) for node in z_fgraph.apply_nodes)) == 2",
            "@pytest.mark.parametrize('nested', (False, True))\ndef test_unvalued_ir_reversion(nested):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Make sure that un-valued IR rewrites are reverted.'\n    x_rv = pt.random.normal()\n    y_rv = pt.clip(x_rv, 0, 1)\n    if nested:\n        y_rv = y_rv + 5\n    z_rv = pt.random.normal(y_rv, 1, name='z')\n    z_vv = z_rv.clone()\n    rv_values = {z_rv: z_vv}\n    (z_fgraph, _, memo) = construct_ir_fgraph(rv_values)\n    assert sum((isinstance(node.op, MeasurableVariable) for node in z_fgraph.apply_nodes)) == 2",
            "@pytest.mark.parametrize('nested', (False, True))\ndef test_unvalued_ir_reversion(nested):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Make sure that un-valued IR rewrites are reverted.'\n    x_rv = pt.random.normal()\n    y_rv = pt.clip(x_rv, 0, 1)\n    if nested:\n        y_rv = y_rv + 5\n    z_rv = pt.random.normal(y_rv, 1, name='z')\n    z_vv = z_rv.clone()\n    rv_values = {z_rv: z_vv}\n    (z_fgraph, _, memo) = construct_ir_fgraph(rv_values)\n    assert sum((isinstance(node.op, MeasurableVariable) for node in z_fgraph.apply_nodes)) == 2",
            "@pytest.mark.parametrize('nested', (False, True))\ndef test_unvalued_ir_reversion(nested):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Make sure that un-valued IR rewrites are reverted.'\n    x_rv = pt.random.normal()\n    y_rv = pt.clip(x_rv, 0, 1)\n    if nested:\n        y_rv = y_rv + 5\n    z_rv = pt.random.normal(y_rv, 1, name='z')\n    z_vv = z_rv.clone()\n    rv_values = {z_rv: z_vv}\n    (z_fgraph, _, memo) = construct_ir_fgraph(rv_values)\n    assert sum((isinstance(node.op, MeasurableVariable) for node in z_fgraph.apply_nodes)) == 2"
        ]
    },
    {
        "func_name": "test_shifted_cumsum",
        "original": "def test_shifted_cumsum():\n    x = pt.random.normal(size=(5,), name='x')\n    y = 5 + pt.cumsum(x)\n    y.name = 'y'\n    y_vv = y.clone()\n    logprob = logp(y, y_vv)\n    assert np.isclose(logprob.eval({y_vv: np.arange(5) + 1 + 5}).sum(), st.norm.logpdf(1) * 5)",
        "mutated": [
            "def test_shifted_cumsum():\n    if False:\n        i = 10\n    x = pt.random.normal(size=(5,), name='x')\n    y = 5 + pt.cumsum(x)\n    y.name = 'y'\n    y_vv = y.clone()\n    logprob = logp(y, y_vv)\n    assert np.isclose(logprob.eval({y_vv: np.arange(5) + 1 + 5}).sum(), st.norm.logpdf(1) * 5)",
            "def test_shifted_cumsum():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    x = pt.random.normal(size=(5,), name='x')\n    y = 5 + pt.cumsum(x)\n    y.name = 'y'\n    y_vv = y.clone()\n    logprob = logp(y, y_vv)\n    assert np.isclose(logprob.eval({y_vv: np.arange(5) + 1 + 5}).sum(), st.norm.logpdf(1) * 5)",
            "def test_shifted_cumsum():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    x = pt.random.normal(size=(5,), name='x')\n    y = 5 + pt.cumsum(x)\n    y.name = 'y'\n    y_vv = y.clone()\n    logprob = logp(y, y_vv)\n    assert np.isclose(logprob.eval({y_vv: np.arange(5) + 1 + 5}).sum(), st.norm.logpdf(1) * 5)",
            "def test_shifted_cumsum():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    x = pt.random.normal(size=(5,), name='x')\n    y = 5 + pt.cumsum(x)\n    y.name = 'y'\n    y_vv = y.clone()\n    logprob = logp(y, y_vv)\n    assert np.isclose(logprob.eval({y_vv: np.arange(5) + 1 + 5}).sum(), st.norm.logpdf(1) * 5)",
            "def test_shifted_cumsum():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    x = pt.random.normal(size=(5,), name='x')\n    y = 5 + pt.cumsum(x)\n    y.name = 'y'\n    y_vv = y.clone()\n    logprob = logp(y, y_vv)\n    assert np.isclose(logprob.eval({y_vv: np.arange(5) + 1 + 5}).sum(), st.norm.logpdf(1) * 5)"
        ]
    },
    {
        "func_name": "test_double_log_transform_rv",
        "original": "def test_double_log_transform_rv():\n    base_rv = pt.random.normal(0, 1)\n    y_rv = pt.log(pt.log(base_rv))\n    y_rv.name = 'y'\n    y_vv = y_rv.clone()\n    logprob = logp(y_rv, y_vv)\n    logp_fn = pytensor.function([y_vv], logprob)\n    log_log_y_val = np.asarray(0.5)\n    log_y_val = np.exp(log_log_y_val)\n    y_val = np.exp(log_y_val)\n    np.testing.assert_allclose(logp_fn(log_log_y_val), st.norm().logpdf(y_val) + log_y_val + log_log_y_val)",
        "mutated": [
            "def test_double_log_transform_rv():\n    if False:\n        i = 10\n    base_rv = pt.random.normal(0, 1)\n    y_rv = pt.log(pt.log(base_rv))\n    y_rv.name = 'y'\n    y_vv = y_rv.clone()\n    logprob = logp(y_rv, y_vv)\n    logp_fn = pytensor.function([y_vv], logprob)\n    log_log_y_val = np.asarray(0.5)\n    log_y_val = np.exp(log_log_y_val)\n    y_val = np.exp(log_y_val)\n    np.testing.assert_allclose(logp_fn(log_log_y_val), st.norm().logpdf(y_val) + log_y_val + log_log_y_val)",
            "def test_double_log_transform_rv():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    base_rv = pt.random.normal(0, 1)\n    y_rv = pt.log(pt.log(base_rv))\n    y_rv.name = 'y'\n    y_vv = y_rv.clone()\n    logprob = logp(y_rv, y_vv)\n    logp_fn = pytensor.function([y_vv], logprob)\n    log_log_y_val = np.asarray(0.5)\n    log_y_val = np.exp(log_log_y_val)\n    y_val = np.exp(log_y_val)\n    np.testing.assert_allclose(logp_fn(log_log_y_val), st.norm().logpdf(y_val) + log_y_val + log_log_y_val)",
            "def test_double_log_transform_rv():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    base_rv = pt.random.normal(0, 1)\n    y_rv = pt.log(pt.log(base_rv))\n    y_rv.name = 'y'\n    y_vv = y_rv.clone()\n    logprob = logp(y_rv, y_vv)\n    logp_fn = pytensor.function([y_vv], logprob)\n    log_log_y_val = np.asarray(0.5)\n    log_y_val = np.exp(log_log_y_val)\n    y_val = np.exp(log_y_val)\n    np.testing.assert_allclose(logp_fn(log_log_y_val), st.norm().logpdf(y_val) + log_y_val + log_log_y_val)",
            "def test_double_log_transform_rv():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    base_rv = pt.random.normal(0, 1)\n    y_rv = pt.log(pt.log(base_rv))\n    y_rv.name = 'y'\n    y_vv = y_rv.clone()\n    logprob = logp(y_rv, y_vv)\n    logp_fn = pytensor.function([y_vv], logprob)\n    log_log_y_val = np.asarray(0.5)\n    log_y_val = np.exp(log_log_y_val)\n    y_val = np.exp(log_y_val)\n    np.testing.assert_allclose(logp_fn(log_log_y_val), st.norm().logpdf(y_val) + log_y_val + log_log_y_val)",
            "def test_double_log_transform_rv():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    base_rv = pt.random.normal(0, 1)\n    y_rv = pt.log(pt.log(base_rv))\n    y_rv.name = 'y'\n    y_vv = y_rv.clone()\n    logprob = logp(y_rv, y_vv)\n    logp_fn = pytensor.function([y_vv], logprob)\n    log_log_y_val = np.asarray(0.5)\n    log_y_val = np.exp(log_log_y_val)\n    y_val = np.exp(log_y_val)\n    np.testing.assert_allclose(logp_fn(log_log_y_val), st.norm().logpdf(y_val) + log_y_val + log_log_y_val)"
        ]
    },
    {
        "func_name": "test_affine_transform_rv",
        "original": "def test_affine_transform_rv():\n    loc = pt.scalar('loc')\n    scale = pt.vector('scale')\n    rv_size = 3\n    y_rv = loc + pt.random.normal(0, 1, size=rv_size, name='base_rv') * scale\n    y_rv.name = 'y'\n    y_vv = y_rv.clone()\n    logprob = logp(y_rv, y_vv)\n    assert_no_rvs(logprob)\n    logp_fn = pytensor.function([loc, scale, y_vv], logprob)\n    loc_test_val = 4.0\n    scale_test_val = np.full(rv_size, 0.5)\n    y_test_val = np.full(rv_size, 1.0)\n    np.testing.assert_allclose(logp_fn(loc_test_val, scale_test_val, y_test_val), st.norm(loc_test_val, scale_test_val).logpdf(y_test_val))",
        "mutated": [
            "def test_affine_transform_rv():\n    if False:\n        i = 10\n    loc = pt.scalar('loc')\n    scale = pt.vector('scale')\n    rv_size = 3\n    y_rv = loc + pt.random.normal(0, 1, size=rv_size, name='base_rv') * scale\n    y_rv.name = 'y'\n    y_vv = y_rv.clone()\n    logprob = logp(y_rv, y_vv)\n    assert_no_rvs(logprob)\n    logp_fn = pytensor.function([loc, scale, y_vv], logprob)\n    loc_test_val = 4.0\n    scale_test_val = np.full(rv_size, 0.5)\n    y_test_val = np.full(rv_size, 1.0)\n    np.testing.assert_allclose(logp_fn(loc_test_val, scale_test_val, y_test_val), st.norm(loc_test_val, scale_test_val).logpdf(y_test_val))",
            "def test_affine_transform_rv():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    loc = pt.scalar('loc')\n    scale = pt.vector('scale')\n    rv_size = 3\n    y_rv = loc + pt.random.normal(0, 1, size=rv_size, name='base_rv') * scale\n    y_rv.name = 'y'\n    y_vv = y_rv.clone()\n    logprob = logp(y_rv, y_vv)\n    assert_no_rvs(logprob)\n    logp_fn = pytensor.function([loc, scale, y_vv], logprob)\n    loc_test_val = 4.0\n    scale_test_val = np.full(rv_size, 0.5)\n    y_test_val = np.full(rv_size, 1.0)\n    np.testing.assert_allclose(logp_fn(loc_test_val, scale_test_val, y_test_val), st.norm(loc_test_val, scale_test_val).logpdf(y_test_val))",
            "def test_affine_transform_rv():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    loc = pt.scalar('loc')\n    scale = pt.vector('scale')\n    rv_size = 3\n    y_rv = loc + pt.random.normal(0, 1, size=rv_size, name='base_rv') * scale\n    y_rv.name = 'y'\n    y_vv = y_rv.clone()\n    logprob = logp(y_rv, y_vv)\n    assert_no_rvs(logprob)\n    logp_fn = pytensor.function([loc, scale, y_vv], logprob)\n    loc_test_val = 4.0\n    scale_test_val = np.full(rv_size, 0.5)\n    y_test_val = np.full(rv_size, 1.0)\n    np.testing.assert_allclose(logp_fn(loc_test_val, scale_test_val, y_test_val), st.norm(loc_test_val, scale_test_val).logpdf(y_test_val))",
            "def test_affine_transform_rv():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    loc = pt.scalar('loc')\n    scale = pt.vector('scale')\n    rv_size = 3\n    y_rv = loc + pt.random.normal(0, 1, size=rv_size, name='base_rv') * scale\n    y_rv.name = 'y'\n    y_vv = y_rv.clone()\n    logprob = logp(y_rv, y_vv)\n    assert_no_rvs(logprob)\n    logp_fn = pytensor.function([loc, scale, y_vv], logprob)\n    loc_test_val = 4.0\n    scale_test_val = np.full(rv_size, 0.5)\n    y_test_val = np.full(rv_size, 1.0)\n    np.testing.assert_allclose(logp_fn(loc_test_val, scale_test_val, y_test_val), st.norm(loc_test_val, scale_test_val).logpdf(y_test_val))",
            "def test_affine_transform_rv():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    loc = pt.scalar('loc')\n    scale = pt.vector('scale')\n    rv_size = 3\n    y_rv = loc + pt.random.normal(0, 1, size=rv_size, name='base_rv') * scale\n    y_rv.name = 'y'\n    y_vv = y_rv.clone()\n    logprob = logp(y_rv, y_vv)\n    assert_no_rvs(logprob)\n    logp_fn = pytensor.function([loc, scale, y_vv], logprob)\n    loc_test_val = 4.0\n    scale_test_val = np.full(rv_size, 0.5)\n    y_test_val = np.full(rv_size, 1.0)\n    np.testing.assert_allclose(logp_fn(loc_test_val, scale_test_val, y_test_val), st.norm(loc_test_val, scale_test_val).logpdf(y_test_val))"
        ]
    },
    {
        "func_name": "test_affine_log_transform_rv",
        "original": "def test_affine_log_transform_rv():\n    (a, b) = pt.scalars('a', 'b')\n    base_rv = pt.random.lognormal(0, 1, name='base_rv', size=(1, 2))\n    y_rv = a + pt.log(base_rv) * b\n    y_rv.name = 'y'\n    y_vv = y_rv.clone()\n    logprob = logp(y_rv, y_vv)\n    logp_fn = pytensor.function([a, b, y_vv], logprob)\n    a_val = -1.5\n    b_val = 3.0\n    y_val = [[0.1, 0.1]]\n    assert np.allclose(logp_fn(a_val, b_val, y_val), st.norm(a_val, b_val).logpdf(y_val))",
        "mutated": [
            "def test_affine_log_transform_rv():\n    if False:\n        i = 10\n    (a, b) = pt.scalars('a', 'b')\n    base_rv = pt.random.lognormal(0, 1, name='base_rv', size=(1, 2))\n    y_rv = a + pt.log(base_rv) * b\n    y_rv.name = 'y'\n    y_vv = y_rv.clone()\n    logprob = logp(y_rv, y_vv)\n    logp_fn = pytensor.function([a, b, y_vv], logprob)\n    a_val = -1.5\n    b_val = 3.0\n    y_val = [[0.1, 0.1]]\n    assert np.allclose(logp_fn(a_val, b_val, y_val), st.norm(a_val, b_val).logpdf(y_val))",
            "def test_affine_log_transform_rv():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (a, b) = pt.scalars('a', 'b')\n    base_rv = pt.random.lognormal(0, 1, name='base_rv', size=(1, 2))\n    y_rv = a + pt.log(base_rv) * b\n    y_rv.name = 'y'\n    y_vv = y_rv.clone()\n    logprob = logp(y_rv, y_vv)\n    logp_fn = pytensor.function([a, b, y_vv], logprob)\n    a_val = -1.5\n    b_val = 3.0\n    y_val = [[0.1, 0.1]]\n    assert np.allclose(logp_fn(a_val, b_val, y_val), st.norm(a_val, b_val).logpdf(y_val))",
            "def test_affine_log_transform_rv():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (a, b) = pt.scalars('a', 'b')\n    base_rv = pt.random.lognormal(0, 1, name='base_rv', size=(1, 2))\n    y_rv = a + pt.log(base_rv) * b\n    y_rv.name = 'y'\n    y_vv = y_rv.clone()\n    logprob = logp(y_rv, y_vv)\n    logp_fn = pytensor.function([a, b, y_vv], logprob)\n    a_val = -1.5\n    b_val = 3.0\n    y_val = [[0.1, 0.1]]\n    assert np.allclose(logp_fn(a_val, b_val, y_val), st.norm(a_val, b_val).logpdf(y_val))",
            "def test_affine_log_transform_rv():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (a, b) = pt.scalars('a', 'b')\n    base_rv = pt.random.lognormal(0, 1, name='base_rv', size=(1, 2))\n    y_rv = a + pt.log(base_rv) * b\n    y_rv.name = 'y'\n    y_vv = y_rv.clone()\n    logprob = logp(y_rv, y_vv)\n    logp_fn = pytensor.function([a, b, y_vv], logprob)\n    a_val = -1.5\n    b_val = 3.0\n    y_val = [[0.1, 0.1]]\n    assert np.allclose(logp_fn(a_val, b_val, y_val), st.norm(a_val, b_val).logpdf(y_val))",
            "def test_affine_log_transform_rv():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (a, b) = pt.scalars('a', 'b')\n    base_rv = pt.random.lognormal(0, 1, name='base_rv', size=(1, 2))\n    y_rv = a + pt.log(base_rv) * b\n    y_rv.name = 'y'\n    y_vv = y_rv.clone()\n    logprob = logp(y_rv, y_vv)\n    logp_fn = pytensor.function([a, b, y_vv], logprob)\n    a_val = -1.5\n    b_val = 3.0\n    y_val = [[0.1, 0.1]]\n    assert np.allclose(logp_fn(a_val, b_val, y_val), st.norm(a_val, b_val).logpdf(y_val))"
        ]
    },
    {
        "func_name": "test_affine_join_interdependent",
        "original": "@pytest.mark.parametrize('reverse', (False, True))\ndef test_affine_join_interdependent(reverse):\n    x = pt.random.normal(name='x')\n    y_rvs = []\n    prev_rv = x\n    for i in range(3):\n        next_rv = pt.exp(prev_rv + pt.random.beta(3, 1, name=f'y{i}', size=(1, 2)))\n        y_rvs.append(next_rv)\n        prev_rv = next_rv\n    if reverse:\n        y_rvs = y_rvs[::-1]\n    ys = pt.concatenate(y_rvs, axis=0)\n    ys.name = 'ys'\n    x_vv = x.clone()\n    ys_vv = ys.clone()\n    logp = conditional_logp({x: x_vv, ys: ys_vv})\n    logp_combined = pt.sum([pt.sum(factor) for factor in logp.values()])\n    assert_no_rvs(logp_combined)\n    y0_vv = y_rvs[0].clone()\n    y1_vv = y_rvs[1].clone()\n    y2_vv = y_rvs[2].clone()\n    ref_logp = conditional_logp({x: x_vv, y_rvs[0]: y0_vv, y_rvs[1]: y1_vv, y_rvs[2]: y2_vv})\n    ref_logp_combined = pt.sum([pt.sum(factor) for factor in ref_logp.values()])\n    rng = np.random.default_rng()\n    (x_vv_test, ys_vv_test) = draw([x, ys], random_seed=rng)\n    ys_vv_test = rng.normal(size=(3, 2))\n    np.testing.assert_allclose(logp_combined.eval({x_vv: x_vv_test, ys_vv: ys_vv_test}), ref_logp_combined.eval({x_vv: x_vv_test, y0_vv: ys_vv_test[0:1], y1_vv: ys_vv_test[1:2], y2_vv: ys_vv_test[2:3]}))",
        "mutated": [
            "@pytest.mark.parametrize('reverse', (False, True))\ndef test_affine_join_interdependent(reverse):\n    if False:\n        i = 10\n    x = pt.random.normal(name='x')\n    y_rvs = []\n    prev_rv = x\n    for i in range(3):\n        next_rv = pt.exp(prev_rv + pt.random.beta(3, 1, name=f'y{i}', size=(1, 2)))\n        y_rvs.append(next_rv)\n        prev_rv = next_rv\n    if reverse:\n        y_rvs = y_rvs[::-1]\n    ys = pt.concatenate(y_rvs, axis=0)\n    ys.name = 'ys'\n    x_vv = x.clone()\n    ys_vv = ys.clone()\n    logp = conditional_logp({x: x_vv, ys: ys_vv})\n    logp_combined = pt.sum([pt.sum(factor) for factor in logp.values()])\n    assert_no_rvs(logp_combined)\n    y0_vv = y_rvs[0].clone()\n    y1_vv = y_rvs[1].clone()\n    y2_vv = y_rvs[2].clone()\n    ref_logp = conditional_logp({x: x_vv, y_rvs[0]: y0_vv, y_rvs[1]: y1_vv, y_rvs[2]: y2_vv})\n    ref_logp_combined = pt.sum([pt.sum(factor) for factor in ref_logp.values()])\n    rng = np.random.default_rng()\n    (x_vv_test, ys_vv_test) = draw([x, ys], random_seed=rng)\n    ys_vv_test = rng.normal(size=(3, 2))\n    np.testing.assert_allclose(logp_combined.eval({x_vv: x_vv_test, ys_vv: ys_vv_test}), ref_logp_combined.eval({x_vv: x_vv_test, y0_vv: ys_vv_test[0:1], y1_vv: ys_vv_test[1:2], y2_vv: ys_vv_test[2:3]}))",
            "@pytest.mark.parametrize('reverse', (False, True))\ndef test_affine_join_interdependent(reverse):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    x = pt.random.normal(name='x')\n    y_rvs = []\n    prev_rv = x\n    for i in range(3):\n        next_rv = pt.exp(prev_rv + pt.random.beta(3, 1, name=f'y{i}', size=(1, 2)))\n        y_rvs.append(next_rv)\n        prev_rv = next_rv\n    if reverse:\n        y_rvs = y_rvs[::-1]\n    ys = pt.concatenate(y_rvs, axis=0)\n    ys.name = 'ys'\n    x_vv = x.clone()\n    ys_vv = ys.clone()\n    logp = conditional_logp({x: x_vv, ys: ys_vv})\n    logp_combined = pt.sum([pt.sum(factor) for factor in logp.values()])\n    assert_no_rvs(logp_combined)\n    y0_vv = y_rvs[0].clone()\n    y1_vv = y_rvs[1].clone()\n    y2_vv = y_rvs[2].clone()\n    ref_logp = conditional_logp({x: x_vv, y_rvs[0]: y0_vv, y_rvs[1]: y1_vv, y_rvs[2]: y2_vv})\n    ref_logp_combined = pt.sum([pt.sum(factor) for factor in ref_logp.values()])\n    rng = np.random.default_rng()\n    (x_vv_test, ys_vv_test) = draw([x, ys], random_seed=rng)\n    ys_vv_test = rng.normal(size=(3, 2))\n    np.testing.assert_allclose(logp_combined.eval({x_vv: x_vv_test, ys_vv: ys_vv_test}), ref_logp_combined.eval({x_vv: x_vv_test, y0_vv: ys_vv_test[0:1], y1_vv: ys_vv_test[1:2], y2_vv: ys_vv_test[2:3]}))",
            "@pytest.mark.parametrize('reverse', (False, True))\ndef test_affine_join_interdependent(reverse):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    x = pt.random.normal(name='x')\n    y_rvs = []\n    prev_rv = x\n    for i in range(3):\n        next_rv = pt.exp(prev_rv + pt.random.beta(3, 1, name=f'y{i}', size=(1, 2)))\n        y_rvs.append(next_rv)\n        prev_rv = next_rv\n    if reverse:\n        y_rvs = y_rvs[::-1]\n    ys = pt.concatenate(y_rvs, axis=0)\n    ys.name = 'ys'\n    x_vv = x.clone()\n    ys_vv = ys.clone()\n    logp = conditional_logp({x: x_vv, ys: ys_vv})\n    logp_combined = pt.sum([pt.sum(factor) for factor in logp.values()])\n    assert_no_rvs(logp_combined)\n    y0_vv = y_rvs[0].clone()\n    y1_vv = y_rvs[1].clone()\n    y2_vv = y_rvs[2].clone()\n    ref_logp = conditional_logp({x: x_vv, y_rvs[0]: y0_vv, y_rvs[1]: y1_vv, y_rvs[2]: y2_vv})\n    ref_logp_combined = pt.sum([pt.sum(factor) for factor in ref_logp.values()])\n    rng = np.random.default_rng()\n    (x_vv_test, ys_vv_test) = draw([x, ys], random_seed=rng)\n    ys_vv_test = rng.normal(size=(3, 2))\n    np.testing.assert_allclose(logp_combined.eval({x_vv: x_vv_test, ys_vv: ys_vv_test}), ref_logp_combined.eval({x_vv: x_vv_test, y0_vv: ys_vv_test[0:1], y1_vv: ys_vv_test[1:2], y2_vv: ys_vv_test[2:3]}))",
            "@pytest.mark.parametrize('reverse', (False, True))\ndef test_affine_join_interdependent(reverse):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    x = pt.random.normal(name='x')\n    y_rvs = []\n    prev_rv = x\n    for i in range(3):\n        next_rv = pt.exp(prev_rv + pt.random.beta(3, 1, name=f'y{i}', size=(1, 2)))\n        y_rvs.append(next_rv)\n        prev_rv = next_rv\n    if reverse:\n        y_rvs = y_rvs[::-1]\n    ys = pt.concatenate(y_rvs, axis=0)\n    ys.name = 'ys'\n    x_vv = x.clone()\n    ys_vv = ys.clone()\n    logp = conditional_logp({x: x_vv, ys: ys_vv})\n    logp_combined = pt.sum([pt.sum(factor) for factor in logp.values()])\n    assert_no_rvs(logp_combined)\n    y0_vv = y_rvs[0].clone()\n    y1_vv = y_rvs[1].clone()\n    y2_vv = y_rvs[2].clone()\n    ref_logp = conditional_logp({x: x_vv, y_rvs[0]: y0_vv, y_rvs[1]: y1_vv, y_rvs[2]: y2_vv})\n    ref_logp_combined = pt.sum([pt.sum(factor) for factor in ref_logp.values()])\n    rng = np.random.default_rng()\n    (x_vv_test, ys_vv_test) = draw([x, ys], random_seed=rng)\n    ys_vv_test = rng.normal(size=(3, 2))\n    np.testing.assert_allclose(logp_combined.eval({x_vv: x_vv_test, ys_vv: ys_vv_test}), ref_logp_combined.eval({x_vv: x_vv_test, y0_vv: ys_vv_test[0:1], y1_vv: ys_vv_test[1:2], y2_vv: ys_vv_test[2:3]}))",
            "@pytest.mark.parametrize('reverse', (False, True))\ndef test_affine_join_interdependent(reverse):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    x = pt.random.normal(name='x')\n    y_rvs = []\n    prev_rv = x\n    for i in range(3):\n        next_rv = pt.exp(prev_rv + pt.random.beta(3, 1, name=f'y{i}', size=(1, 2)))\n        y_rvs.append(next_rv)\n        prev_rv = next_rv\n    if reverse:\n        y_rvs = y_rvs[::-1]\n    ys = pt.concatenate(y_rvs, axis=0)\n    ys.name = 'ys'\n    x_vv = x.clone()\n    ys_vv = ys.clone()\n    logp = conditional_logp({x: x_vv, ys: ys_vv})\n    logp_combined = pt.sum([pt.sum(factor) for factor in logp.values()])\n    assert_no_rvs(logp_combined)\n    y0_vv = y_rvs[0].clone()\n    y1_vv = y_rvs[1].clone()\n    y2_vv = y_rvs[2].clone()\n    ref_logp = conditional_logp({x: x_vv, y_rvs[0]: y0_vv, y_rvs[1]: y1_vv, y_rvs[2]: y2_vv})\n    ref_logp_combined = pt.sum([pt.sum(factor) for factor in ref_logp.values()])\n    rng = np.random.default_rng()\n    (x_vv_test, ys_vv_test) = draw([x, ys], random_seed=rng)\n    ys_vv_test = rng.normal(size=(3, 2))\n    np.testing.assert_allclose(logp_combined.eval({x_vv: x_vv_test, ys_vv: ys_vv_test}), ref_logp_combined.eval({x_vv: x_vv_test, y0_vv: ys_vv_test[0:1], y1_vv: ys_vv_test[1:2], y2_vv: ys_vv_test[2:3]}))"
        ]
    }
]