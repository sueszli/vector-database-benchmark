import numpy as np
from .._shared import utils
from .._shared.utils import convert_to_float
from ._nl_means_denoising import _nl_means_denoising_2d, _nl_means_denoising_3d, _fast_nl_means_denoising_2d, _fast_nl_means_denoising_3d, _fast_nl_means_denoising_4d

@utils.channel_as_last_axis()
def denoise_nl_means(image, patch_size=7, patch_distance=11, h=0.1, fast_mode=True, sigma=0.0, *, preserve_range=False, channel_axis=None):
    if False:
        return 10
    'Perform non-local means denoising on 2D-4D grayscale or RGB images.\n\n    Parameters\n    ----------\n    image : 2D or 3D ndarray\n        Input image to be denoised, which can be 2D or 3D, and grayscale\n        or RGB (for 2D images only, see ``channel_axis`` parameter). There can\n        be any number of channels (does not strictly have to be RGB).\n    patch_size : int, optional\n        Size of patches used for denoising.\n    patch_distance : int, optional\n        Maximal distance in pixels where to search patches used for denoising.\n    h : float, optional\n        Cut-off distance (in gray levels). The higher h, the more permissive\n        one is in accepting patches. A higher h results in a smoother image,\n        at the expense of blurring features. For a Gaussian noise of standard\n        deviation sigma, a rule of thumb is to choose the value of h to be\n        sigma of slightly less.\n    fast_mode : bool, optional\n        If True (default value), a fast version of the non-local means\n        algorithm is used. If False, the original version of non-local means is\n        used. See the Notes section for more details about the algorithms.\n    sigma : float, optional\n        The standard deviation of the (Gaussian) noise.  If provided, a more\n        robust computation of patch weights is computed that takes the expected\n        noise variance into account (see Notes below).\n    preserve_range : bool, optional\n        Whether to keep the original range of values. Otherwise, the input\n        image is converted according to the conventions of `img_as_float`.\n        Also see https://scikit-image.org/docs/dev/user_guide/data_types.html\n    channel_axis : int or None, optional\n        If None, the image is assumed to be a grayscale (single channel) image.\n        Otherwise, this parameter indicates which axis of the array corresponds\n        to channels.\n\n        .. versionadded:: 0.19\n           ``channel_axis`` was added in 0.19.\n\n    Returns\n    -------\n    result : ndarray\n        Denoised image, of same shape as `image`.\n\n    Notes\n    -----\n\n    The non-local means algorithm is well suited for denoising images with\n    specific textures. The principle of the algorithm is to average the value\n    of a given pixel with values of other pixels in a limited neighborhood,\n    provided that the *patches* centered on the other pixels are similar enough\n    to the patch centered on the pixel of interest.\n\n    In the original version of the algorithm [1]_, corresponding to\n    ``fast=False``, the computational complexity is::\n\n        image.size * patch_size ** image.ndim * patch_distance ** image.ndim\n\n    Hence, changing the size of patches or their maximal distance has a\n    strong effect on computing times, especially for 3-D images.\n\n    However, the default behavior corresponds to ``fast_mode=True``, for which\n    another version of non-local means [2]_ is used, corresponding to a\n    complexity of::\n\n        image.size * patch_distance ** image.ndim\n\n    The computing time depends only weakly on the patch size, thanks to\n    the computation of the integral of patches distances for a given\n    shift, that reduces the number of operations [1]_. Therefore, this\n    algorithm executes faster than the classic algorithm\n    (``fast_mode=False``), at the expense of using twice as much memory.\n    This implementation has been proven to be more efficient compared to\n    other alternatives, see e.g. [3]_.\n\n    Compared to the classic algorithm, all pixels of a patch contribute\n    to the distance to another patch with the same weight, no matter\n    their distance to the center of the patch. This coarser computation\n    of the distance can result in a slightly poorer denoising\n    performance. Moreover, for small images (images with a linear size\n    that is only a few times the patch size), the classic algorithm can\n    be faster due to boundary effects.\n\n    The image is padded using the `reflect` mode of `skimage.util.pad`\n    before denoising.\n\n    If the noise standard deviation, `sigma`, is provided a more robust\n    computation of patch weights is used.  Subtracting the known noise variance\n    from the computed patch distances improves the estimates of patch\n    similarity, giving a moderate improvement to denoising performance [4]_.\n    It was also mentioned as an option for the fast variant of the algorithm in\n    [3]_.\n\n    When `sigma` is provided, a smaller `h` should typically be used to\n    avoid oversmoothing.  The optimal value for `h` depends on the image\n    content and noise level, but a reasonable starting point is\n    ``h = 0.8 * sigma`` when `fast_mode` is `True`, or ``h = 0.6 * sigma`` when\n    `fast_mode` is `False`.\n\n    References\n    ----------\n    .. [1] A. Buades, B. Coll, & J-M. Morel. A non-local algorithm for image\n           denoising. In CVPR 2005, Vol. 2, pp. 60-65, IEEE.\n           :DOI:`10.1109/CVPR.2005.38`\n\n    .. [2] J. Darbon, A. Cunha, T.F. Chan, S. Osher, and G.J. Jensen, Fast\n           nonlocal filtering applied to electron cryomicroscopy, in 5th IEEE\n           International Symposium on Biomedical Imaging: From Nano to Macro,\n           2008, pp. 1331-1334.\n           :DOI:`10.1109/ISBI.2008.4541250`\n\n    .. [3] Jacques Froment. Parameter-Free Fast Pixelwise Non-Local Means\n           Denoising. Image Processing On Line, 2014, vol. 4, pp. 300-326.\n           :DOI:`10.5201/ipol.2014.120`\n\n    .. [4] A. Buades, B. Coll, & J-M. Morel. Non-Local Means Denoising.\n           Image Processing On Line, 2011, vol. 1, pp. 208-212.\n           :DOI:`10.5201/ipol.2011.bcm_nlm`\n\n    Examples\n    --------\n    >>> a = np.zeros((40, 40))\n    >>> a[10:-10, 10:-10] = 1.\n    >>> rng = np.random.default_rng()\n    >>> a += 0.3 * rng.standard_normal(a.shape)\n    >>> denoised_a = denoise_nl_means(a, 7, 5, 0.1)\n    '
    if channel_axis is None:
        multichannel = False
        image = image[..., np.newaxis]
    else:
        multichannel = True
    ndim_no_channel = image.ndim - 1
    if ndim_no_channel < 2 or ndim_no_channel > 4:
        raise NotImplementedError('Non-local means denoising is only implemented for 2D, 3D or 4D grayscale or multichannel images.')
    image = convert_to_float(image, preserve_range)
    if not image.flags.c_contiguous:
        image = np.ascontiguousarray(image)
    kwargs = dict(s=patch_size, d=patch_distance, h=h, var=sigma * sigma)
    if ndim_no_channel == 2:
        nlm_func = _fast_nl_means_denoising_2d if fast_mode else _nl_means_denoising_2d
    elif ndim_no_channel == 3:
        if multichannel and (not fast_mode):
            raise NotImplementedError('Multichannel 3D requires fast_mode to be True.')
        if fast_mode:
            nlm_func = _fast_nl_means_denoising_3d
        else:
            image = image[..., 0]
            nlm_func = _nl_means_denoising_3d
    elif ndim_no_channel == 4:
        if fast_mode:
            nlm_func = _fast_nl_means_denoising_4d
        else:
            raise NotImplementedError('4D requires fast_mode to be True.')
    dn = np.asarray(nlm_func(image, **kwargs))
    return dn