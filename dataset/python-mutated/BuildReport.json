[
    {
        "func_name": "FileWrite",
        "original": "def FileWrite(File, String, Wrapper=False):\n    if Wrapper:\n        String = textwrap.fill(String, 120)\n    File.append(String + gEndOfLine)",
        "mutated": [
            "def FileWrite(File, String, Wrapper=False):\n    if False:\n        i = 10\n    if Wrapper:\n        String = textwrap.fill(String, 120)\n    File.append(String + gEndOfLine)",
            "def FileWrite(File, String, Wrapper=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if Wrapper:\n        String = textwrap.fill(String, 120)\n    File.append(String + gEndOfLine)",
            "def FileWrite(File, String, Wrapper=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if Wrapper:\n        String = textwrap.fill(String, 120)\n    File.append(String + gEndOfLine)",
            "def FileWrite(File, String, Wrapper=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if Wrapper:\n        String = textwrap.fill(String, 120)\n    File.append(String + gEndOfLine)",
            "def FileWrite(File, String, Wrapper=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if Wrapper:\n        String = textwrap.fill(String, 120)\n    File.append(String + gEndOfLine)"
        ]
    },
    {
        "func_name": "ByteArrayForamt",
        "original": "def ByteArrayForamt(Value):\n    IsByteArray = False\n    SplitNum = 16\n    ArrayList = []\n    if Value.startswith('{') and Value.endswith('}') and (not Value.startswith('{CODE(')):\n        Value = Value[1:-1]\n        ValueList = Value.split(',')\n        if len(ValueList) >= SplitNum:\n            IsByteArray = True\n    if IsByteArray:\n        if ValueList:\n            Len = len(ValueList) / SplitNum\n            for (i, element) in enumerate(ValueList):\n                ValueList[i] = '0x%02X' % int(element.strip(), 16)\n        if Len:\n            Id = 0\n            while Id <= Len:\n                End = min(SplitNum * (Id + 1), len(ValueList))\n                Str = ','.join(ValueList[SplitNum * Id:End])\n                if End == len(ValueList):\n                    Str += '}'\n                    ArrayList.append(Str)\n                    break\n                else:\n                    Str += ','\n                    ArrayList.append(Str)\n                Id += 1\n        else:\n            ArrayList = [Value + '}']\n    return (IsByteArray, ArrayList)",
        "mutated": [
            "def ByteArrayForamt(Value):\n    if False:\n        i = 10\n    IsByteArray = False\n    SplitNum = 16\n    ArrayList = []\n    if Value.startswith('{') and Value.endswith('}') and (not Value.startswith('{CODE(')):\n        Value = Value[1:-1]\n        ValueList = Value.split(',')\n        if len(ValueList) >= SplitNum:\n            IsByteArray = True\n    if IsByteArray:\n        if ValueList:\n            Len = len(ValueList) / SplitNum\n            for (i, element) in enumerate(ValueList):\n                ValueList[i] = '0x%02X' % int(element.strip(), 16)\n        if Len:\n            Id = 0\n            while Id <= Len:\n                End = min(SplitNum * (Id + 1), len(ValueList))\n                Str = ','.join(ValueList[SplitNum * Id:End])\n                if End == len(ValueList):\n                    Str += '}'\n                    ArrayList.append(Str)\n                    break\n                else:\n                    Str += ','\n                    ArrayList.append(Str)\n                Id += 1\n        else:\n            ArrayList = [Value + '}']\n    return (IsByteArray, ArrayList)",
            "def ByteArrayForamt(Value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    IsByteArray = False\n    SplitNum = 16\n    ArrayList = []\n    if Value.startswith('{') and Value.endswith('}') and (not Value.startswith('{CODE(')):\n        Value = Value[1:-1]\n        ValueList = Value.split(',')\n        if len(ValueList) >= SplitNum:\n            IsByteArray = True\n    if IsByteArray:\n        if ValueList:\n            Len = len(ValueList) / SplitNum\n            for (i, element) in enumerate(ValueList):\n                ValueList[i] = '0x%02X' % int(element.strip(), 16)\n        if Len:\n            Id = 0\n            while Id <= Len:\n                End = min(SplitNum * (Id + 1), len(ValueList))\n                Str = ','.join(ValueList[SplitNum * Id:End])\n                if End == len(ValueList):\n                    Str += '}'\n                    ArrayList.append(Str)\n                    break\n                else:\n                    Str += ','\n                    ArrayList.append(Str)\n                Id += 1\n        else:\n            ArrayList = [Value + '}']\n    return (IsByteArray, ArrayList)",
            "def ByteArrayForamt(Value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    IsByteArray = False\n    SplitNum = 16\n    ArrayList = []\n    if Value.startswith('{') and Value.endswith('}') and (not Value.startswith('{CODE(')):\n        Value = Value[1:-1]\n        ValueList = Value.split(',')\n        if len(ValueList) >= SplitNum:\n            IsByteArray = True\n    if IsByteArray:\n        if ValueList:\n            Len = len(ValueList) / SplitNum\n            for (i, element) in enumerate(ValueList):\n                ValueList[i] = '0x%02X' % int(element.strip(), 16)\n        if Len:\n            Id = 0\n            while Id <= Len:\n                End = min(SplitNum * (Id + 1), len(ValueList))\n                Str = ','.join(ValueList[SplitNum * Id:End])\n                if End == len(ValueList):\n                    Str += '}'\n                    ArrayList.append(Str)\n                    break\n                else:\n                    Str += ','\n                    ArrayList.append(Str)\n                Id += 1\n        else:\n            ArrayList = [Value + '}']\n    return (IsByteArray, ArrayList)",
            "def ByteArrayForamt(Value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    IsByteArray = False\n    SplitNum = 16\n    ArrayList = []\n    if Value.startswith('{') and Value.endswith('}') and (not Value.startswith('{CODE(')):\n        Value = Value[1:-1]\n        ValueList = Value.split(',')\n        if len(ValueList) >= SplitNum:\n            IsByteArray = True\n    if IsByteArray:\n        if ValueList:\n            Len = len(ValueList) / SplitNum\n            for (i, element) in enumerate(ValueList):\n                ValueList[i] = '0x%02X' % int(element.strip(), 16)\n        if Len:\n            Id = 0\n            while Id <= Len:\n                End = min(SplitNum * (Id + 1), len(ValueList))\n                Str = ','.join(ValueList[SplitNum * Id:End])\n                if End == len(ValueList):\n                    Str += '}'\n                    ArrayList.append(Str)\n                    break\n                else:\n                    Str += ','\n                    ArrayList.append(Str)\n                Id += 1\n        else:\n            ArrayList = [Value + '}']\n    return (IsByteArray, ArrayList)",
            "def ByteArrayForamt(Value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    IsByteArray = False\n    SplitNum = 16\n    ArrayList = []\n    if Value.startswith('{') and Value.endswith('}') and (not Value.startswith('{CODE(')):\n        Value = Value[1:-1]\n        ValueList = Value.split(',')\n        if len(ValueList) >= SplitNum:\n            IsByteArray = True\n    if IsByteArray:\n        if ValueList:\n            Len = len(ValueList) / SplitNum\n            for (i, element) in enumerate(ValueList):\n                ValueList[i] = '0x%02X' % int(element.strip(), 16)\n        if Len:\n            Id = 0\n            while Id <= Len:\n                End = min(SplitNum * (Id + 1), len(ValueList))\n                Str = ','.join(ValueList[SplitNum * Id:End])\n                if End == len(ValueList):\n                    Str += '}'\n                    ArrayList.append(Str)\n                    break\n                else:\n                    Str += ','\n                    ArrayList.append(Str)\n                Id += 1\n        else:\n            ArrayList = [Value + '}']\n    return (IsByteArray, ArrayList)"
        ]
    },
    {
        "func_name": "FindIncludeFiles",
        "original": "def FindIncludeFiles(Source, IncludePathList, IncludeFiles):\n    FileContents = open(Source).read()\n    for Match in gIncludePattern.finditer(FileContents):\n        FileName = Match.group(1).strip()\n        for Dir in [os.path.dirname(Source)] + IncludePathList:\n            FullFileName = os.path.normpath(os.path.join(Dir, FileName))\n            if os.path.exists(FullFileName):\n                IncludeFiles[FullFileName.lower().replace('\\\\', '/')] = FullFileName\n                break\n    for Match in gIncludePattern2.finditer(FileContents):\n        Key = Match.group(2)\n        Type = Match.group(1)\n        if 'ARCH_PROTOCOL' in Type:\n            FileName = 'ArchProtocol/%(Key)s/%(Key)s.h' % {'Key': Key}\n        elif 'PROTOCOL' in Type:\n            FileName = 'Protocol/%(Key)s/%(Key)s.h' % {'Key': Key}\n        elif 'PPI' in Type:\n            FileName = 'Ppi/%(Key)s/%(Key)s.h' % {'Key': Key}\n        elif TAB_GUID in Type:\n            FileName = 'Guid/%(Key)s/%(Key)s.h' % {'Key': Key}\n        else:\n            continue\n        for Dir in IncludePathList:\n            FullFileName = os.path.normpath(os.path.join(Dir, FileName))\n            if os.path.exists(FullFileName):\n                IncludeFiles[FullFileName.lower().replace('\\\\', '/')] = FullFileName\n                break",
        "mutated": [
            "def FindIncludeFiles(Source, IncludePathList, IncludeFiles):\n    if False:\n        i = 10\n    FileContents = open(Source).read()\n    for Match in gIncludePattern.finditer(FileContents):\n        FileName = Match.group(1).strip()\n        for Dir in [os.path.dirname(Source)] + IncludePathList:\n            FullFileName = os.path.normpath(os.path.join(Dir, FileName))\n            if os.path.exists(FullFileName):\n                IncludeFiles[FullFileName.lower().replace('\\\\', '/')] = FullFileName\n                break\n    for Match in gIncludePattern2.finditer(FileContents):\n        Key = Match.group(2)\n        Type = Match.group(1)\n        if 'ARCH_PROTOCOL' in Type:\n            FileName = 'ArchProtocol/%(Key)s/%(Key)s.h' % {'Key': Key}\n        elif 'PROTOCOL' in Type:\n            FileName = 'Protocol/%(Key)s/%(Key)s.h' % {'Key': Key}\n        elif 'PPI' in Type:\n            FileName = 'Ppi/%(Key)s/%(Key)s.h' % {'Key': Key}\n        elif TAB_GUID in Type:\n            FileName = 'Guid/%(Key)s/%(Key)s.h' % {'Key': Key}\n        else:\n            continue\n        for Dir in IncludePathList:\n            FullFileName = os.path.normpath(os.path.join(Dir, FileName))\n            if os.path.exists(FullFileName):\n                IncludeFiles[FullFileName.lower().replace('\\\\', '/')] = FullFileName\n                break",
            "def FindIncludeFiles(Source, IncludePathList, IncludeFiles):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    FileContents = open(Source).read()\n    for Match in gIncludePattern.finditer(FileContents):\n        FileName = Match.group(1).strip()\n        for Dir in [os.path.dirname(Source)] + IncludePathList:\n            FullFileName = os.path.normpath(os.path.join(Dir, FileName))\n            if os.path.exists(FullFileName):\n                IncludeFiles[FullFileName.lower().replace('\\\\', '/')] = FullFileName\n                break\n    for Match in gIncludePattern2.finditer(FileContents):\n        Key = Match.group(2)\n        Type = Match.group(1)\n        if 'ARCH_PROTOCOL' in Type:\n            FileName = 'ArchProtocol/%(Key)s/%(Key)s.h' % {'Key': Key}\n        elif 'PROTOCOL' in Type:\n            FileName = 'Protocol/%(Key)s/%(Key)s.h' % {'Key': Key}\n        elif 'PPI' in Type:\n            FileName = 'Ppi/%(Key)s/%(Key)s.h' % {'Key': Key}\n        elif TAB_GUID in Type:\n            FileName = 'Guid/%(Key)s/%(Key)s.h' % {'Key': Key}\n        else:\n            continue\n        for Dir in IncludePathList:\n            FullFileName = os.path.normpath(os.path.join(Dir, FileName))\n            if os.path.exists(FullFileName):\n                IncludeFiles[FullFileName.lower().replace('\\\\', '/')] = FullFileName\n                break",
            "def FindIncludeFiles(Source, IncludePathList, IncludeFiles):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    FileContents = open(Source).read()\n    for Match in gIncludePattern.finditer(FileContents):\n        FileName = Match.group(1).strip()\n        for Dir in [os.path.dirname(Source)] + IncludePathList:\n            FullFileName = os.path.normpath(os.path.join(Dir, FileName))\n            if os.path.exists(FullFileName):\n                IncludeFiles[FullFileName.lower().replace('\\\\', '/')] = FullFileName\n                break\n    for Match in gIncludePattern2.finditer(FileContents):\n        Key = Match.group(2)\n        Type = Match.group(1)\n        if 'ARCH_PROTOCOL' in Type:\n            FileName = 'ArchProtocol/%(Key)s/%(Key)s.h' % {'Key': Key}\n        elif 'PROTOCOL' in Type:\n            FileName = 'Protocol/%(Key)s/%(Key)s.h' % {'Key': Key}\n        elif 'PPI' in Type:\n            FileName = 'Ppi/%(Key)s/%(Key)s.h' % {'Key': Key}\n        elif TAB_GUID in Type:\n            FileName = 'Guid/%(Key)s/%(Key)s.h' % {'Key': Key}\n        else:\n            continue\n        for Dir in IncludePathList:\n            FullFileName = os.path.normpath(os.path.join(Dir, FileName))\n            if os.path.exists(FullFileName):\n                IncludeFiles[FullFileName.lower().replace('\\\\', '/')] = FullFileName\n                break",
            "def FindIncludeFiles(Source, IncludePathList, IncludeFiles):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    FileContents = open(Source).read()\n    for Match in gIncludePattern.finditer(FileContents):\n        FileName = Match.group(1).strip()\n        for Dir in [os.path.dirname(Source)] + IncludePathList:\n            FullFileName = os.path.normpath(os.path.join(Dir, FileName))\n            if os.path.exists(FullFileName):\n                IncludeFiles[FullFileName.lower().replace('\\\\', '/')] = FullFileName\n                break\n    for Match in gIncludePattern2.finditer(FileContents):\n        Key = Match.group(2)\n        Type = Match.group(1)\n        if 'ARCH_PROTOCOL' in Type:\n            FileName = 'ArchProtocol/%(Key)s/%(Key)s.h' % {'Key': Key}\n        elif 'PROTOCOL' in Type:\n            FileName = 'Protocol/%(Key)s/%(Key)s.h' % {'Key': Key}\n        elif 'PPI' in Type:\n            FileName = 'Ppi/%(Key)s/%(Key)s.h' % {'Key': Key}\n        elif TAB_GUID in Type:\n            FileName = 'Guid/%(Key)s/%(Key)s.h' % {'Key': Key}\n        else:\n            continue\n        for Dir in IncludePathList:\n            FullFileName = os.path.normpath(os.path.join(Dir, FileName))\n            if os.path.exists(FullFileName):\n                IncludeFiles[FullFileName.lower().replace('\\\\', '/')] = FullFileName\n                break",
            "def FindIncludeFiles(Source, IncludePathList, IncludeFiles):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    FileContents = open(Source).read()\n    for Match in gIncludePattern.finditer(FileContents):\n        FileName = Match.group(1).strip()\n        for Dir in [os.path.dirname(Source)] + IncludePathList:\n            FullFileName = os.path.normpath(os.path.join(Dir, FileName))\n            if os.path.exists(FullFileName):\n                IncludeFiles[FullFileName.lower().replace('\\\\', '/')] = FullFileName\n                break\n    for Match in gIncludePattern2.finditer(FileContents):\n        Key = Match.group(2)\n        Type = Match.group(1)\n        if 'ARCH_PROTOCOL' in Type:\n            FileName = 'ArchProtocol/%(Key)s/%(Key)s.h' % {'Key': Key}\n        elif 'PROTOCOL' in Type:\n            FileName = 'Protocol/%(Key)s/%(Key)s.h' % {'Key': Key}\n        elif 'PPI' in Type:\n            FileName = 'Ppi/%(Key)s/%(Key)s.h' % {'Key': Key}\n        elif TAB_GUID in Type:\n            FileName = 'Guid/%(Key)s/%(Key)s.h' % {'Key': Key}\n        else:\n            continue\n        for Dir in IncludePathList:\n            FullFileName = os.path.normpath(os.path.join(Dir, FileName))\n            if os.path.exists(FullFileName):\n                IncludeFiles[FullFileName.lower().replace('\\\\', '/')] = FullFileName\n                break"
        ]
    },
    {
        "func_name": "FileLinesSplit",
        "original": "def FileLinesSplit(Content=None, MaxLength=None):\n    ContentList = Content.split(TAB_LINE_BREAK)\n    NewContent = ''\n    NewContentList = []\n    for Line in ContentList:\n        while len(Line.rstrip()) > MaxLength:\n            LineSpaceIndex = Line.rfind(TAB_SPACE_SPLIT, 0, MaxLength)\n            LineSlashIndex = Line.rfind(TAB_SLASH, 0, MaxLength)\n            LineBackSlashIndex = Line.rfind(TAB_BACK_SLASH, 0, MaxLength)\n            if max(LineSpaceIndex, LineSlashIndex, LineBackSlashIndex) > 0:\n                LineBreakIndex = max(LineSpaceIndex, LineSlashIndex, LineBackSlashIndex)\n            else:\n                LineBreakIndex = MaxLength\n            NewContentList.append(Line[:LineBreakIndex])\n            Line = Line[LineBreakIndex:]\n        if Line:\n            NewContentList.append(Line)\n    for NewLine in NewContentList:\n        NewContent += NewLine + TAB_LINE_BREAK\n    NewContent = NewContent.replace(gEndOfLine, TAB_LINE_BREAK).replace('\\r\\r\\n', gEndOfLine)\n    return NewContent",
        "mutated": [
            "def FileLinesSplit(Content=None, MaxLength=None):\n    if False:\n        i = 10\n    ContentList = Content.split(TAB_LINE_BREAK)\n    NewContent = ''\n    NewContentList = []\n    for Line in ContentList:\n        while len(Line.rstrip()) > MaxLength:\n            LineSpaceIndex = Line.rfind(TAB_SPACE_SPLIT, 0, MaxLength)\n            LineSlashIndex = Line.rfind(TAB_SLASH, 0, MaxLength)\n            LineBackSlashIndex = Line.rfind(TAB_BACK_SLASH, 0, MaxLength)\n            if max(LineSpaceIndex, LineSlashIndex, LineBackSlashIndex) > 0:\n                LineBreakIndex = max(LineSpaceIndex, LineSlashIndex, LineBackSlashIndex)\n            else:\n                LineBreakIndex = MaxLength\n            NewContentList.append(Line[:LineBreakIndex])\n            Line = Line[LineBreakIndex:]\n        if Line:\n            NewContentList.append(Line)\n    for NewLine in NewContentList:\n        NewContent += NewLine + TAB_LINE_BREAK\n    NewContent = NewContent.replace(gEndOfLine, TAB_LINE_BREAK).replace('\\r\\r\\n', gEndOfLine)\n    return NewContent",
            "def FileLinesSplit(Content=None, MaxLength=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ContentList = Content.split(TAB_LINE_BREAK)\n    NewContent = ''\n    NewContentList = []\n    for Line in ContentList:\n        while len(Line.rstrip()) > MaxLength:\n            LineSpaceIndex = Line.rfind(TAB_SPACE_SPLIT, 0, MaxLength)\n            LineSlashIndex = Line.rfind(TAB_SLASH, 0, MaxLength)\n            LineBackSlashIndex = Line.rfind(TAB_BACK_SLASH, 0, MaxLength)\n            if max(LineSpaceIndex, LineSlashIndex, LineBackSlashIndex) > 0:\n                LineBreakIndex = max(LineSpaceIndex, LineSlashIndex, LineBackSlashIndex)\n            else:\n                LineBreakIndex = MaxLength\n            NewContentList.append(Line[:LineBreakIndex])\n            Line = Line[LineBreakIndex:]\n        if Line:\n            NewContentList.append(Line)\n    for NewLine in NewContentList:\n        NewContent += NewLine + TAB_LINE_BREAK\n    NewContent = NewContent.replace(gEndOfLine, TAB_LINE_BREAK).replace('\\r\\r\\n', gEndOfLine)\n    return NewContent",
            "def FileLinesSplit(Content=None, MaxLength=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ContentList = Content.split(TAB_LINE_BREAK)\n    NewContent = ''\n    NewContentList = []\n    for Line in ContentList:\n        while len(Line.rstrip()) > MaxLength:\n            LineSpaceIndex = Line.rfind(TAB_SPACE_SPLIT, 0, MaxLength)\n            LineSlashIndex = Line.rfind(TAB_SLASH, 0, MaxLength)\n            LineBackSlashIndex = Line.rfind(TAB_BACK_SLASH, 0, MaxLength)\n            if max(LineSpaceIndex, LineSlashIndex, LineBackSlashIndex) > 0:\n                LineBreakIndex = max(LineSpaceIndex, LineSlashIndex, LineBackSlashIndex)\n            else:\n                LineBreakIndex = MaxLength\n            NewContentList.append(Line[:LineBreakIndex])\n            Line = Line[LineBreakIndex:]\n        if Line:\n            NewContentList.append(Line)\n    for NewLine in NewContentList:\n        NewContent += NewLine + TAB_LINE_BREAK\n    NewContent = NewContent.replace(gEndOfLine, TAB_LINE_BREAK).replace('\\r\\r\\n', gEndOfLine)\n    return NewContent",
            "def FileLinesSplit(Content=None, MaxLength=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ContentList = Content.split(TAB_LINE_BREAK)\n    NewContent = ''\n    NewContentList = []\n    for Line in ContentList:\n        while len(Line.rstrip()) > MaxLength:\n            LineSpaceIndex = Line.rfind(TAB_SPACE_SPLIT, 0, MaxLength)\n            LineSlashIndex = Line.rfind(TAB_SLASH, 0, MaxLength)\n            LineBackSlashIndex = Line.rfind(TAB_BACK_SLASH, 0, MaxLength)\n            if max(LineSpaceIndex, LineSlashIndex, LineBackSlashIndex) > 0:\n                LineBreakIndex = max(LineSpaceIndex, LineSlashIndex, LineBackSlashIndex)\n            else:\n                LineBreakIndex = MaxLength\n            NewContentList.append(Line[:LineBreakIndex])\n            Line = Line[LineBreakIndex:]\n        if Line:\n            NewContentList.append(Line)\n    for NewLine in NewContentList:\n        NewContent += NewLine + TAB_LINE_BREAK\n    NewContent = NewContent.replace(gEndOfLine, TAB_LINE_BREAK).replace('\\r\\r\\n', gEndOfLine)\n    return NewContent",
            "def FileLinesSplit(Content=None, MaxLength=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ContentList = Content.split(TAB_LINE_BREAK)\n    NewContent = ''\n    NewContentList = []\n    for Line in ContentList:\n        while len(Line.rstrip()) > MaxLength:\n            LineSpaceIndex = Line.rfind(TAB_SPACE_SPLIT, 0, MaxLength)\n            LineSlashIndex = Line.rfind(TAB_SLASH, 0, MaxLength)\n            LineBackSlashIndex = Line.rfind(TAB_BACK_SLASH, 0, MaxLength)\n            if max(LineSpaceIndex, LineSlashIndex, LineBackSlashIndex) > 0:\n                LineBreakIndex = max(LineSpaceIndex, LineSlashIndex, LineBackSlashIndex)\n            else:\n                LineBreakIndex = MaxLength\n            NewContentList.append(Line[:LineBreakIndex])\n            Line = Line[LineBreakIndex:]\n        if Line:\n            NewContentList.append(Line)\n    for NewLine in NewContentList:\n        NewContent += NewLine + TAB_LINE_BREAK\n    NewContent = NewContent.replace(gEndOfLine, TAB_LINE_BREAK).replace('\\r\\r\\n', gEndOfLine)\n    return NewContent"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, Wa):\n    self._GuidDb = {}\n    for Pa in Wa.AutoGenObjectList:\n        for Package in Pa.PackageList:\n            for Protocol in Package.Protocols:\n                GuidValue = GuidStructureStringToGuidString(Package.Protocols[Protocol])\n                self._GuidDb[GuidValue.upper()] = Protocol\n            for Ppi in Package.Ppis:\n                GuidValue = GuidStructureStringToGuidString(Package.Ppis[Ppi])\n                self._GuidDb[GuidValue.upper()] = Ppi\n            for Guid in Package.Guids:\n                GuidValue = GuidStructureStringToGuidString(Package.Guids[Guid])\n                self._GuidDb[GuidValue.upper()] = Guid\n        for Ma in Pa.ModuleAutoGenList:\n            for Pcd in Ma.FixedVoidTypePcds:\n                PcdValue = Ma.FixedVoidTypePcds[Pcd]\n                if len(PcdValue.split(',')) == 16:\n                    GuidValue = GuidStructureByteArrayToGuidString(PcdValue)\n                    self._GuidDb[GuidValue.upper()] = Pcd",
        "mutated": [
            "def __init__(self, Wa):\n    if False:\n        i = 10\n    self._GuidDb = {}\n    for Pa in Wa.AutoGenObjectList:\n        for Package in Pa.PackageList:\n            for Protocol in Package.Protocols:\n                GuidValue = GuidStructureStringToGuidString(Package.Protocols[Protocol])\n                self._GuidDb[GuidValue.upper()] = Protocol\n            for Ppi in Package.Ppis:\n                GuidValue = GuidStructureStringToGuidString(Package.Ppis[Ppi])\n                self._GuidDb[GuidValue.upper()] = Ppi\n            for Guid in Package.Guids:\n                GuidValue = GuidStructureStringToGuidString(Package.Guids[Guid])\n                self._GuidDb[GuidValue.upper()] = Guid\n        for Ma in Pa.ModuleAutoGenList:\n            for Pcd in Ma.FixedVoidTypePcds:\n                PcdValue = Ma.FixedVoidTypePcds[Pcd]\n                if len(PcdValue.split(',')) == 16:\n                    GuidValue = GuidStructureByteArrayToGuidString(PcdValue)\n                    self._GuidDb[GuidValue.upper()] = Pcd",
            "def __init__(self, Wa):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._GuidDb = {}\n    for Pa in Wa.AutoGenObjectList:\n        for Package in Pa.PackageList:\n            for Protocol in Package.Protocols:\n                GuidValue = GuidStructureStringToGuidString(Package.Protocols[Protocol])\n                self._GuidDb[GuidValue.upper()] = Protocol\n            for Ppi in Package.Ppis:\n                GuidValue = GuidStructureStringToGuidString(Package.Ppis[Ppi])\n                self._GuidDb[GuidValue.upper()] = Ppi\n            for Guid in Package.Guids:\n                GuidValue = GuidStructureStringToGuidString(Package.Guids[Guid])\n                self._GuidDb[GuidValue.upper()] = Guid\n        for Ma in Pa.ModuleAutoGenList:\n            for Pcd in Ma.FixedVoidTypePcds:\n                PcdValue = Ma.FixedVoidTypePcds[Pcd]\n                if len(PcdValue.split(',')) == 16:\n                    GuidValue = GuidStructureByteArrayToGuidString(PcdValue)\n                    self._GuidDb[GuidValue.upper()] = Pcd",
            "def __init__(self, Wa):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._GuidDb = {}\n    for Pa in Wa.AutoGenObjectList:\n        for Package in Pa.PackageList:\n            for Protocol in Package.Protocols:\n                GuidValue = GuidStructureStringToGuidString(Package.Protocols[Protocol])\n                self._GuidDb[GuidValue.upper()] = Protocol\n            for Ppi in Package.Ppis:\n                GuidValue = GuidStructureStringToGuidString(Package.Ppis[Ppi])\n                self._GuidDb[GuidValue.upper()] = Ppi\n            for Guid in Package.Guids:\n                GuidValue = GuidStructureStringToGuidString(Package.Guids[Guid])\n                self._GuidDb[GuidValue.upper()] = Guid\n        for Ma in Pa.ModuleAutoGenList:\n            for Pcd in Ma.FixedVoidTypePcds:\n                PcdValue = Ma.FixedVoidTypePcds[Pcd]\n                if len(PcdValue.split(',')) == 16:\n                    GuidValue = GuidStructureByteArrayToGuidString(PcdValue)\n                    self._GuidDb[GuidValue.upper()] = Pcd",
            "def __init__(self, Wa):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._GuidDb = {}\n    for Pa in Wa.AutoGenObjectList:\n        for Package in Pa.PackageList:\n            for Protocol in Package.Protocols:\n                GuidValue = GuidStructureStringToGuidString(Package.Protocols[Protocol])\n                self._GuidDb[GuidValue.upper()] = Protocol\n            for Ppi in Package.Ppis:\n                GuidValue = GuidStructureStringToGuidString(Package.Ppis[Ppi])\n                self._GuidDb[GuidValue.upper()] = Ppi\n            for Guid in Package.Guids:\n                GuidValue = GuidStructureStringToGuidString(Package.Guids[Guid])\n                self._GuidDb[GuidValue.upper()] = Guid\n        for Ma in Pa.ModuleAutoGenList:\n            for Pcd in Ma.FixedVoidTypePcds:\n                PcdValue = Ma.FixedVoidTypePcds[Pcd]\n                if len(PcdValue.split(',')) == 16:\n                    GuidValue = GuidStructureByteArrayToGuidString(PcdValue)\n                    self._GuidDb[GuidValue.upper()] = Pcd",
            "def __init__(self, Wa):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._GuidDb = {}\n    for Pa in Wa.AutoGenObjectList:\n        for Package in Pa.PackageList:\n            for Protocol in Package.Protocols:\n                GuidValue = GuidStructureStringToGuidString(Package.Protocols[Protocol])\n                self._GuidDb[GuidValue.upper()] = Protocol\n            for Ppi in Package.Ppis:\n                GuidValue = GuidStructureStringToGuidString(Package.Ppis[Ppi])\n                self._GuidDb[GuidValue.upper()] = Ppi\n            for Guid in Package.Guids:\n                GuidValue = GuidStructureStringToGuidString(Package.Guids[Guid])\n                self._GuidDb[GuidValue.upper()] = Guid\n        for Ma in Pa.ModuleAutoGenList:\n            for Pcd in Ma.FixedVoidTypePcds:\n                PcdValue = Ma.FixedVoidTypePcds[Pcd]\n                if len(PcdValue.split(',')) == 16:\n                    GuidValue = GuidStructureByteArrayToGuidString(PcdValue)\n                    self._GuidDb[GuidValue.upper()] = Pcd"
        ]
    },
    {
        "func_name": "ParseDepexFile",
        "original": "def ParseDepexFile(self, DepexFileName):\n    DepexFile = open(DepexFileName, 'rb')\n    DepexStatement = []\n    OpCode = DepexFile.read(1)\n    while OpCode:\n        Statement = gOpCodeList[struct.unpack('B', OpCode)[0]]\n        if Statement in ['BEFORE', 'AFTER', 'PUSH']:\n            GuidValue = '%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X' % struct.unpack(PACK_PATTERN_GUID, DepexFile.read(16))\n            GuidString = self._GuidDb.get(GuidValue, GuidValue)\n            Statement = '%s %s' % (Statement, GuidString)\n        DepexStatement.append(Statement)\n        OpCode = DepexFile.read(1)\n    return DepexStatement",
        "mutated": [
            "def ParseDepexFile(self, DepexFileName):\n    if False:\n        i = 10\n    DepexFile = open(DepexFileName, 'rb')\n    DepexStatement = []\n    OpCode = DepexFile.read(1)\n    while OpCode:\n        Statement = gOpCodeList[struct.unpack('B', OpCode)[0]]\n        if Statement in ['BEFORE', 'AFTER', 'PUSH']:\n            GuidValue = '%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X' % struct.unpack(PACK_PATTERN_GUID, DepexFile.read(16))\n            GuidString = self._GuidDb.get(GuidValue, GuidValue)\n            Statement = '%s %s' % (Statement, GuidString)\n        DepexStatement.append(Statement)\n        OpCode = DepexFile.read(1)\n    return DepexStatement",
            "def ParseDepexFile(self, DepexFileName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    DepexFile = open(DepexFileName, 'rb')\n    DepexStatement = []\n    OpCode = DepexFile.read(1)\n    while OpCode:\n        Statement = gOpCodeList[struct.unpack('B', OpCode)[0]]\n        if Statement in ['BEFORE', 'AFTER', 'PUSH']:\n            GuidValue = '%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X' % struct.unpack(PACK_PATTERN_GUID, DepexFile.read(16))\n            GuidString = self._GuidDb.get(GuidValue, GuidValue)\n            Statement = '%s %s' % (Statement, GuidString)\n        DepexStatement.append(Statement)\n        OpCode = DepexFile.read(1)\n    return DepexStatement",
            "def ParseDepexFile(self, DepexFileName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    DepexFile = open(DepexFileName, 'rb')\n    DepexStatement = []\n    OpCode = DepexFile.read(1)\n    while OpCode:\n        Statement = gOpCodeList[struct.unpack('B', OpCode)[0]]\n        if Statement in ['BEFORE', 'AFTER', 'PUSH']:\n            GuidValue = '%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X' % struct.unpack(PACK_PATTERN_GUID, DepexFile.read(16))\n            GuidString = self._GuidDb.get(GuidValue, GuidValue)\n            Statement = '%s %s' % (Statement, GuidString)\n        DepexStatement.append(Statement)\n        OpCode = DepexFile.read(1)\n    return DepexStatement",
            "def ParseDepexFile(self, DepexFileName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    DepexFile = open(DepexFileName, 'rb')\n    DepexStatement = []\n    OpCode = DepexFile.read(1)\n    while OpCode:\n        Statement = gOpCodeList[struct.unpack('B', OpCode)[0]]\n        if Statement in ['BEFORE', 'AFTER', 'PUSH']:\n            GuidValue = '%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X' % struct.unpack(PACK_PATTERN_GUID, DepexFile.read(16))\n            GuidString = self._GuidDb.get(GuidValue, GuidValue)\n            Statement = '%s %s' % (Statement, GuidString)\n        DepexStatement.append(Statement)\n        OpCode = DepexFile.read(1)\n    return DepexStatement",
            "def ParseDepexFile(self, DepexFileName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    DepexFile = open(DepexFileName, 'rb')\n    DepexStatement = []\n    OpCode = DepexFile.read(1)\n    while OpCode:\n        Statement = gOpCodeList[struct.unpack('B', OpCode)[0]]\n        if Statement in ['BEFORE', 'AFTER', 'PUSH']:\n            GuidValue = '%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X' % struct.unpack(PACK_PATTERN_GUID, DepexFile.read(16))\n            GuidString = self._GuidDb.get(GuidValue, GuidValue)\n            Statement = '%s %s' % (Statement, GuidString)\n        DepexStatement.append(Statement)\n        OpCode = DepexFile.read(1)\n    return DepexStatement"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, M):\n    self.LibraryList = []\n    for Lib in M.DependentLibraryList:\n        LibInfPath = str(Lib)\n        LibClassList = Lib.LibraryClass[0].LibraryClass\n        LibConstructorList = Lib.ConstructorList\n        LibDesstructorList = Lib.DestructorList\n        LibDepexList = Lib.DepexExpression[M.Arch, M.ModuleType]\n        for LibAutoGen in M.LibraryAutoGenList:\n            if LibInfPath == LibAutoGen.MetaFile.Path:\n                LibTime = LibAutoGen.BuildTime\n                break\n        self.LibraryList.append((LibInfPath, LibClassList, LibConstructorList, LibDesstructorList, LibDepexList, LibTime))",
        "mutated": [
            "def __init__(self, M):\n    if False:\n        i = 10\n    self.LibraryList = []\n    for Lib in M.DependentLibraryList:\n        LibInfPath = str(Lib)\n        LibClassList = Lib.LibraryClass[0].LibraryClass\n        LibConstructorList = Lib.ConstructorList\n        LibDesstructorList = Lib.DestructorList\n        LibDepexList = Lib.DepexExpression[M.Arch, M.ModuleType]\n        for LibAutoGen in M.LibraryAutoGenList:\n            if LibInfPath == LibAutoGen.MetaFile.Path:\n                LibTime = LibAutoGen.BuildTime\n                break\n        self.LibraryList.append((LibInfPath, LibClassList, LibConstructorList, LibDesstructorList, LibDepexList, LibTime))",
            "def __init__(self, M):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.LibraryList = []\n    for Lib in M.DependentLibraryList:\n        LibInfPath = str(Lib)\n        LibClassList = Lib.LibraryClass[0].LibraryClass\n        LibConstructorList = Lib.ConstructorList\n        LibDesstructorList = Lib.DestructorList\n        LibDepexList = Lib.DepexExpression[M.Arch, M.ModuleType]\n        for LibAutoGen in M.LibraryAutoGenList:\n            if LibInfPath == LibAutoGen.MetaFile.Path:\n                LibTime = LibAutoGen.BuildTime\n                break\n        self.LibraryList.append((LibInfPath, LibClassList, LibConstructorList, LibDesstructorList, LibDepexList, LibTime))",
            "def __init__(self, M):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.LibraryList = []\n    for Lib in M.DependentLibraryList:\n        LibInfPath = str(Lib)\n        LibClassList = Lib.LibraryClass[0].LibraryClass\n        LibConstructorList = Lib.ConstructorList\n        LibDesstructorList = Lib.DestructorList\n        LibDepexList = Lib.DepexExpression[M.Arch, M.ModuleType]\n        for LibAutoGen in M.LibraryAutoGenList:\n            if LibInfPath == LibAutoGen.MetaFile.Path:\n                LibTime = LibAutoGen.BuildTime\n                break\n        self.LibraryList.append((LibInfPath, LibClassList, LibConstructorList, LibDesstructorList, LibDepexList, LibTime))",
            "def __init__(self, M):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.LibraryList = []\n    for Lib in M.DependentLibraryList:\n        LibInfPath = str(Lib)\n        LibClassList = Lib.LibraryClass[0].LibraryClass\n        LibConstructorList = Lib.ConstructorList\n        LibDesstructorList = Lib.DestructorList\n        LibDepexList = Lib.DepexExpression[M.Arch, M.ModuleType]\n        for LibAutoGen in M.LibraryAutoGenList:\n            if LibInfPath == LibAutoGen.MetaFile.Path:\n                LibTime = LibAutoGen.BuildTime\n                break\n        self.LibraryList.append((LibInfPath, LibClassList, LibConstructorList, LibDesstructorList, LibDepexList, LibTime))",
            "def __init__(self, M):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.LibraryList = []\n    for Lib in M.DependentLibraryList:\n        LibInfPath = str(Lib)\n        LibClassList = Lib.LibraryClass[0].LibraryClass\n        LibConstructorList = Lib.ConstructorList\n        LibDesstructorList = Lib.DestructorList\n        LibDepexList = Lib.DepexExpression[M.Arch, M.ModuleType]\n        for LibAutoGen in M.LibraryAutoGenList:\n            if LibInfPath == LibAutoGen.MetaFile.Path:\n                LibTime = LibAutoGen.BuildTime\n                break\n        self.LibraryList.append((LibInfPath, LibClassList, LibConstructorList, LibDesstructorList, LibDepexList, LibTime))"
        ]
    },
    {
        "func_name": "GenerateReport",
        "original": "def GenerateReport(self, File):\n    if len(self.LibraryList) > 0:\n        FileWrite(File, gSubSectionStart)\n        FileWrite(File, TAB_BRG_LIBRARY)\n        FileWrite(File, gSubSectionSep)\n        for LibraryItem in self.LibraryList:\n            LibInfPath = LibraryItem[0]\n            FileWrite(File, LibInfPath)\n            LibClass = LibraryItem[1]\n            EdkIILibInfo = ''\n            LibConstructor = ' '.join(LibraryItem[2])\n            if LibConstructor:\n                EdkIILibInfo += ' C = ' + LibConstructor\n            LibDestructor = ' '.join(LibraryItem[3])\n            if LibDestructor:\n                EdkIILibInfo += ' D = ' + LibDestructor\n            LibDepex = ' '.join(LibraryItem[4])\n            if LibDepex:\n                EdkIILibInfo += ' Depex = ' + LibDepex\n            if LibraryItem[5]:\n                EdkIILibInfo += ' Time = ' + LibraryItem[5]\n            if EdkIILibInfo:\n                FileWrite(File, '{%s: %s}' % (LibClass, EdkIILibInfo))\n            else:\n                FileWrite(File, '{%s}' % LibClass)\n        FileWrite(File, gSubSectionEnd)",
        "mutated": [
            "def GenerateReport(self, File):\n    if False:\n        i = 10\n    if len(self.LibraryList) > 0:\n        FileWrite(File, gSubSectionStart)\n        FileWrite(File, TAB_BRG_LIBRARY)\n        FileWrite(File, gSubSectionSep)\n        for LibraryItem in self.LibraryList:\n            LibInfPath = LibraryItem[0]\n            FileWrite(File, LibInfPath)\n            LibClass = LibraryItem[1]\n            EdkIILibInfo = ''\n            LibConstructor = ' '.join(LibraryItem[2])\n            if LibConstructor:\n                EdkIILibInfo += ' C = ' + LibConstructor\n            LibDestructor = ' '.join(LibraryItem[3])\n            if LibDestructor:\n                EdkIILibInfo += ' D = ' + LibDestructor\n            LibDepex = ' '.join(LibraryItem[4])\n            if LibDepex:\n                EdkIILibInfo += ' Depex = ' + LibDepex\n            if LibraryItem[5]:\n                EdkIILibInfo += ' Time = ' + LibraryItem[5]\n            if EdkIILibInfo:\n                FileWrite(File, '{%s: %s}' % (LibClass, EdkIILibInfo))\n            else:\n                FileWrite(File, '{%s}' % LibClass)\n        FileWrite(File, gSubSectionEnd)",
            "def GenerateReport(self, File):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if len(self.LibraryList) > 0:\n        FileWrite(File, gSubSectionStart)\n        FileWrite(File, TAB_BRG_LIBRARY)\n        FileWrite(File, gSubSectionSep)\n        for LibraryItem in self.LibraryList:\n            LibInfPath = LibraryItem[0]\n            FileWrite(File, LibInfPath)\n            LibClass = LibraryItem[1]\n            EdkIILibInfo = ''\n            LibConstructor = ' '.join(LibraryItem[2])\n            if LibConstructor:\n                EdkIILibInfo += ' C = ' + LibConstructor\n            LibDestructor = ' '.join(LibraryItem[3])\n            if LibDestructor:\n                EdkIILibInfo += ' D = ' + LibDestructor\n            LibDepex = ' '.join(LibraryItem[4])\n            if LibDepex:\n                EdkIILibInfo += ' Depex = ' + LibDepex\n            if LibraryItem[5]:\n                EdkIILibInfo += ' Time = ' + LibraryItem[5]\n            if EdkIILibInfo:\n                FileWrite(File, '{%s: %s}' % (LibClass, EdkIILibInfo))\n            else:\n                FileWrite(File, '{%s}' % LibClass)\n        FileWrite(File, gSubSectionEnd)",
            "def GenerateReport(self, File):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if len(self.LibraryList) > 0:\n        FileWrite(File, gSubSectionStart)\n        FileWrite(File, TAB_BRG_LIBRARY)\n        FileWrite(File, gSubSectionSep)\n        for LibraryItem in self.LibraryList:\n            LibInfPath = LibraryItem[0]\n            FileWrite(File, LibInfPath)\n            LibClass = LibraryItem[1]\n            EdkIILibInfo = ''\n            LibConstructor = ' '.join(LibraryItem[2])\n            if LibConstructor:\n                EdkIILibInfo += ' C = ' + LibConstructor\n            LibDestructor = ' '.join(LibraryItem[3])\n            if LibDestructor:\n                EdkIILibInfo += ' D = ' + LibDestructor\n            LibDepex = ' '.join(LibraryItem[4])\n            if LibDepex:\n                EdkIILibInfo += ' Depex = ' + LibDepex\n            if LibraryItem[5]:\n                EdkIILibInfo += ' Time = ' + LibraryItem[5]\n            if EdkIILibInfo:\n                FileWrite(File, '{%s: %s}' % (LibClass, EdkIILibInfo))\n            else:\n                FileWrite(File, '{%s}' % LibClass)\n        FileWrite(File, gSubSectionEnd)",
            "def GenerateReport(self, File):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if len(self.LibraryList) > 0:\n        FileWrite(File, gSubSectionStart)\n        FileWrite(File, TAB_BRG_LIBRARY)\n        FileWrite(File, gSubSectionSep)\n        for LibraryItem in self.LibraryList:\n            LibInfPath = LibraryItem[0]\n            FileWrite(File, LibInfPath)\n            LibClass = LibraryItem[1]\n            EdkIILibInfo = ''\n            LibConstructor = ' '.join(LibraryItem[2])\n            if LibConstructor:\n                EdkIILibInfo += ' C = ' + LibConstructor\n            LibDestructor = ' '.join(LibraryItem[3])\n            if LibDestructor:\n                EdkIILibInfo += ' D = ' + LibDestructor\n            LibDepex = ' '.join(LibraryItem[4])\n            if LibDepex:\n                EdkIILibInfo += ' Depex = ' + LibDepex\n            if LibraryItem[5]:\n                EdkIILibInfo += ' Time = ' + LibraryItem[5]\n            if EdkIILibInfo:\n                FileWrite(File, '{%s: %s}' % (LibClass, EdkIILibInfo))\n            else:\n                FileWrite(File, '{%s}' % LibClass)\n        FileWrite(File, gSubSectionEnd)",
            "def GenerateReport(self, File):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if len(self.LibraryList) > 0:\n        FileWrite(File, gSubSectionStart)\n        FileWrite(File, TAB_BRG_LIBRARY)\n        FileWrite(File, gSubSectionSep)\n        for LibraryItem in self.LibraryList:\n            LibInfPath = LibraryItem[0]\n            FileWrite(File, LibInfPath)\n            LibClass = LibraryItem[1]\n            EdkIILibInfo = ''\n            LibConstructor = ' '.join(LibraryItem[2])\n            if LibConstructor:\n                EdkIILibInfo += ' C = ' + LibConstructor\n            LibDestructor = ' '.join(LibraryItem[3])\n            if LibDestructor:\n                EdkIILibInfo += ' D = ' + LibDestructor\n            LibDepex = ' '.join(LibraryItem[4])\n            if LibDepex:\n                EdkIILibInfo += ' Depex = ' + LibDepex\n            if LibraryItem[5]:\n                EdkIILibInfo += ' Time = ' + LibraryItem[5]\n            if EdkIILibInfo:\n                FileWrite(File, '{%s: %s}' % (LibClass, EdkIILibInfo))\n            else:\n                FileWrite(File, '{%s}' % LibClass)\n        FileWrite(File, gSubSectionEnd)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, M):\n    self.Depex = ''\n    self._DepexFileName = os.path.join(M.BuildDir, 'OUTPUT', M.Module.BaseName + '.depex')\n    ModuleType = M.ModuleType\n    if not ModuleType:\n        ModuleType = COMPONENT_TO_MODULE_MAP_DICT.get(M.ComponentType, '')\n    if ModuleType in [SUP_MODULE_SEC, SUP_MODULE_PEI_CORE, SUP_MODULE_DXE_CORE, SUP_MODULE_SMM_CORE, SUP_MODULE_MM_CORE_STANDALONE, SUP_MODULE_UEFI_APPLICATION]:\n        return\n    for Source in M.SourceFileList:\n        if os.path.splitext(Source.Path)[1].lower() == '.dxs':\n            Match = gDxsDependencyPattern.search(open(Source.Path).read())\n            if Match:\n                self.Depex = Match.group(1).strip()\n                self.Source = 'DXS'\n                break\n    else:\n        self.Depex = M.DepexExpressionDict.get(M.ModuleType, '')\n        self.ModuleDepex = ' '.join(M.Module.DepexExpression[M.Arch, M.ModuleType])\n        if not self.ModuleDepex:\n            self.ModuleDepex = '(None)'\n        LibDepexList = []\n        for Lib in M.DependentLibraryList:\n            LibDepex = ' '.join(Lib.DepexExpression[M.Arch, M.ModuleType]).strip()\n            if LibDepex != '':\n                LibDepexList.append('(' + LibDepex + ')')\n        self.LibraryDepex = ' AND '.join(LibDepexList)\n        if not self.LibraryDepex:\n            self.LibraryDepex = '(None)'\n        self.Source = 'INF'",
        "mutated": [
            "def __init__(self, M):\n    if False:\n        i = 10\n    self.Depex = ''\n    self._DepexFileName = os.path.join(M.BuildDir, 'OUTPUT', M.Module.BaseName + '.depex')\n    ModuleType = M.ModuleType\n    if not ModuleType:\n        ModuleType = COMPONENT_TO_MODULE_MAP_DICT.get(M.ComponentType, '')\n    if ModuleType in [SUP_MODULE_SEC, SUP_MODULE_PEI_CORE, SUP_MODULE_DXE_CORE, SUP_MODULE_SMM_CORE, SUP_MODULE_MM_CORE_STANDALONE, SUP_MODULE_UEFI_APPLICATION]:\n        return\n    for Source in M.SourceFileList:\n        if os.path.splitext(Source.Path)[1].lower() == '.dxs':\n            Match = gDxsDependencyPattern.search(open(Source.Path).read())\n            if Match:\n                self.Depex = Match.group(1).strip()\n                self.Source = 'DXS'\n                break\n    else:\n        self.Depex = M.DepexExpressionDict.get(M.ModuleType, '')\n        self.ModuleDepex = ' '.join(M.Module.DepexExpression[M.Arch, M.ModuleType])\n        if not self.ModuleDepex:\n            self.ModuleDepex = '(None)'\n        LibDepexList = []\n        for Lib in M.DependentLibraryList:\n            LibDepex = ' '.join(Lib.DepexExpression[M.Arch, M.ModuleType]).strip()\n            if LibDepex != '':\n                LibDepexList.append('(' + LibDepex + ')')\n        self.LibraryDepex = ' AND '.join(LibDepexList)\n        if not self.LibraryDepex:\n            self.LibraryDepex = '(None)'\n        self.Source = 'INF'",
            "def __init__(self, M):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.Depex = ''\n    self._DepexFileName = os.path.join(M.BuildDir, 'OUTPUT', M.Module.BaseName + '.depex')\n    ModuleType = M.ModuleType\n    if not ModuleType:\n        ModuleType = COMPONENT_TO_MODULE_MAP_DICT.get(M.ComponentType, '')\n    if ModuleType in [SUP_MODULE_SEC, SUP_MODULE_PEI_CORE, SUP_MODULE_DXE_CORE, SUP_MODULE_SMM_CORE, SUP_MODULE_MM_CORE_STANDALONE, SUP_MODULE_UEFI_APPLICATION]:\n        return\n    for Source in M.SourceFileList:\n        if os.path.splitext(Source.Path)[1].lower() == '.dxs':\n            Match = gDxsDependencyPattern.search(open(Source.Path).read())\n            if Match:\n                self.Depex = Match.group(1).strip()\n                self.Source = 'DXS'\n                break\n    else:\n        self.Depex = M.DepexExpressionDict.get(M.ModuleType, '')\n        self.ModuleDepex = ' '.join(M.Module.DepexExpression[M.Arch, M.ModuleType])\n        if not self.ModuleDepex:\n            self.ModuleDepex = '(None)'\n        LibDepexList = []\n        for Lib in M.DependentLibraryList:\n            LibDepex = ' '.join(Lib.DepexExpression[M.Arch, M.ModuleType]).strip()\n            if LibDepex != '':\n                LibDepexList.append('(' + LibDepex + ')')\n        self.LibraryDepex = ' AND '.join(LibDepexList)\n        if not self.LibraryDepex:\n            self.LibraryDepex = '(None)'\n        self.Source = 'INF'",
            "def __init__(self, M):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.Depex = ''\n    self._DepexFileName = os.path.join(M.BuildDir, 'OUTPUT', M.Module.BaseName + '.depex')\n    ModuleType = M.ModuleType\n    if not ModuleType:\n        ModuleType = COMPONENT_TO_MODULE_MAP_DICT.get(M.ComponentType, '')\n    if ModuleType in [SUP_MODULE_SEC, SUP_MODULE_PEI_CORE, SUP_MODULE_DXE_CORE, SUP_MODULE_SMM_CORE, SUP_MODULE_MM_CORE_STANDALONE, SUP_MODULE_UEFI_APPLICATION]:\n        return\n    for Source in M.SourceFileList:\n        if os.path.splitext(Source.Path)[1].lower() == '.dxs':\n            Match = gDxsDependencyPattern.search(open(Source.Path).read())\n            if Match:\n                self.Depex = Match.group(1).strip()\n                self.Source = 'DXS'\n                break\n    else:\n        self.Depex = M.DepexExpressionDict.get(M.ModuleType, '')\n        self.ModuleDepex = ' '.join(M.Module.DepexExpression[M.Arch, M.ModuleType])\n        if not self.ModuleDepex:\n            self.ModuleDepex = '(None)'\n        LibDepexList = []\n        for Lib in M.DependentLibraryList:\n            LibDepex = ' '.join(Lib.DepexExpression[M.Arch, M.ModuleType]).strip()\n            if LibDepex != '':\n                LibDepexList.append('(' + LibDepex + ')')\n        self.LibraryDepex = ' AND '.join(LibDepexList)\n        if not self.LibraryDepex:\n            self.LibraryDepex = '(None)'\n        self.Source = 'INF'",
            "def __init__(self, M):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.Depex = ''\n    self._DepexFileName = os.path.join(M.BuildDir, 'OUTPUT', M.Module.BaseName + '.depex')\n    ModuleType = M.ModuleType\n    if not ModuleType:\n        ModuleType = COMPONENT_TO_MODULE_MAP_DICT.get(M.ComponentType, '')\n    if ModuleType in [SUP_MODULE_SEC, SUP_MODULE_PEI_CORE, SUP_MODULE_DXE_CORE, SUP_MODULE_SMM_CORE, SUP_MODULE_MM_CORE_STANDALONE, SUP_MODULE_UEFI_APPLICATION]:\n        return\n    for Source in M.SourceFileList:\n        if os.path.splitext(Source.Path)[1].lower() == '.dxs':\n            Match = gDxsDependencyPattern.search(open(Source.Path).read())\n            if Match:\n                self.Depex = Match.group(1).strip()\n                self.Source = 'DXS'\n                break\n    else:\n        self.Depex = M.DepexExpressionDict.get(M.ModuleType, '')\n        self.ModuleDepex = ' '.join(M.Module.DepexExpression[M.Arch, M.ModuleType])\n        if not self.ModuleDepex:\n            self.ModuleDepex = '(None)'\n        LibDepexList = []\n        for Lib in M.DependentLibraryList:\n            LibDepex = ' '.join(Lib.DepexExpression[M.Arch, M.ModuleType]).strip()\n            if LibDepex != '':\n                LibDepexList.append('(' + LibDepex + ')')\n        self.LibraryDepex = ' AND '.join(LibDepexList)\n        if not self.LibraryDepex:\n            self.LibraryDepex = '(None)'\n        self.Source = 'INF'",
            "def __init__(self, M):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.Depex = ''\n    self._DepexFileName = os.path.join(M.BuildDir, 'OUTPUT', M.Module.BaseName + '.depex')\n    ModuleType = M.ModuleType\n    if not ModuleType:\n        ModuleType = COMPONENT_TO_MODULE_MAP_DICT.get(M.ComponentType, '')\n    if ModuleType in [SUP_MODULE_SEC, SUP_MODULE_PEI_CORE, SUP_MODULE_DXE_CORE, SUP_MODULE_SMM_CORE, SUP_MODULE_MM_CORE_STANDALONE, SUP_MODULE_UEFI_APPLICATION]:\n        return\n    for Source in M.SourceFileList:\n        if os.path.splitext(Source.Path)[1].lower() == '.dxs':\n            Match = gDxsDependencyPattern.search(open(Source.Path).read())\n            if Match:\n                self.Depex = Match.group(1).strip()\n                self.Source = 'DXS'\n                break\n    else:\n        self.Depex = M.DepexExpressionDict.get(M.ModuleType, '')\n        self.ModuleDepex = ' '.join(M.Module.DepexExpression[M.Arch, M.ModuleType])\n        if not self.ModuleDepex:\n            self.ModuleDepex = '(None)'\n        LibDepexList = []\n        for Lib in M.DependentLibraryList:\n            LibDepex = ' '.join(Lib.DepexExpression[M.Arch, M.ModuleType]).strip()\n            if LibDepex != '':\n                LibDepexList.append('(' + LibDepex + ')')\n        self.LibraryDepex = ' AND '.join(LibDepexList)\n        if not self.LibraryDepex:\n            self.LibraryDepex = '(None)'\n        self.Source = 'INF'"
        ]
    },
    {
        "func_name": "GenerateReport",
        "original": "def GenerateReport(self, File, GlobalDepexParser):\n    if not self.Depex:\n        return\n    FileWrite(File, gSubSectionStart)\n    if os.path.isfile(self._DepexFileName):\n        try:\n            DepexStatements = GlobalDepexParser.ParseDepexFile(self._DepexFileName)\n            FileWrite(File, 'Final Dependency Expression (DEPEX) Instructions')\n            for DepexStatement in DepexStatements:\n                FileWrite(File, '  %s' % DepexStatement)\n            FileWrite(File, gSubSectionSep)\n        except:\n            EdkLogger.warn(None, 'Dependency expression file is corrupted', self._DepexFileName)\n    FileWrite(File, 'Dependency Expression (DEPEX) from %s' % self.Source)\n    if self.Source == 'INF':\n        FileWrite(File, self.Depex, True)\n        FileWrite(File, gSubSectionSep)\n        FileWrite(File, 'From Module INF:  %s' % self.ModuleDepex, True)\n        FileWrite(File, 'From Library INF: %s' % self.LibraryDepex, True)\n    else:\n        FileWrite(File, self.Depex)\n    FileWrite(File, gSubSectionEnd)",
        "mutated": [
            "def GenerateReport(self, File, GlobalDepexParser):\n    if False:\n        i = 10\n    if not self.Depex:\n        return\n    FileWrite(File, gSubSectionStart)\n    if os.path.isfile(self._DepexFileName):\n        try:\n            DepexStatements = GlobalDepexParser.ParseDepexFile(self._DepexFileName)\n            FileWrite(File, 'Final Dependency Expression (DEPEX) Instructions')\n            for DepexStatement in DepexStatements:\n                FileWrite(File, '  %s' % DepexStatement)\n            FileWrite(File, gSubSectionSep)\n        except:\n            EdkLogger.warn(None, 'Dependency expression file is corrupted', self._DepexFileName)\n    FileWrite(File, 'Dependency Expression (DEPEX) from %s' % self.Source)\n    if self.Source == 'INF':\n        FileWrite(File, self.Depex, True)\n        FileWrite(File, gSubSectionSep)\n        FileWrite(File, 'From Module INF:  %s' % self.ModuleDepex, True)\n        FileWrite(File, 'From Library INF: %s' % self.LibraryDepex, True)\n    else:\n        FileWrite(File, self.Depex)\n    FileWrite(File, gSubSectionEnd)",
            "def GenerateReport(self, File, GlobalDepexParser):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not self.Depex:\n        return\n    FileWrite(File, gSubSectionStart)\n    if os.path.isfile(self._DepexFileName):\n        try:\n            DepexStatements = GlobalDepexParser.ParseDepexFile(self._DepexFileName)\n            FileWrite(File, 'Final Dependency Expression (DEPEX) Instructions')\n            for DepexStatement in DepexStatements:\n                FileWrite(File, '  %s' % DepexStatement)\n            FileWrite(File, gSubSectionSep)\n        except:\n            EdkLogger.warn(None, 'Dependency expression file is corrupted', self._DepexFileName)\n    FileWrite(File, 'Dependency Expression (DEPEX) from %s' % self.Source)\n    if self.Source == 'INF':\n        FileWrite(File, self.Depex, True)\n        FileWrite(File, gSubSectionSep)\n        FileWrite(File, 'From Module INF:  %s' % self.ModuleDepex, True)\n        FileWrite(File, 'From Library INF: %s' % self.LibraryDepex, True)\n    else:\n        FileWrite(File, self.Depex)\n    FileWrite(File, gSubSectionEnd)",
            "def GenerateReport(self, File, GlobalDepexParser):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not self.Depex:\n        return\n    FileWrite(File, gSubSectionStart)\n    if os.path.isfile(self._DepexFileName):\n        try:\n            DepexStatements = GlobalDepexParser.ParseDepexFile(self._DepexFileName)\n            FileWrite(File, 'Final Dependency Expression (DEPEX) Instructions')\n            for DepexStatement in DepexStatements:\n                FileWrite(File, '  %s' % DepexStatement)\n            FileWrite(File, gSubSectionSep)\n        except:\n            EdkLogger.warn(None, 'Dependency expression file is corrupted', self._DepexFileName)\n    FileWrite(File, 'Dependency Expression (DEPEX) from %s' % self.Source)\n    if self.Source == 'INF':\n        FileWrite(File, self.Depex, True)\n        FileWrite(File, gSubSectionSep)\n        FileWrite(File, 'From Module INF:  %s' % self.ModuleDepex, True)\n        FileWrite(File, 'From Library INF: %s' % self.LibraryDepex, True)\n    else:\n        FileWrite(File, self.Depex)\n    FileWrite(File, gSubSectionEnd)",
            "def GenerateReport(self, File, GlobalDepexParser):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not self.Depex:\n        return\n    FileWrite(File, gSubSectionStart)\n    if os.path.isfile(self._DepexFileName):\n        try:\n            DepexStatements = GlobalDepexParser.ParseDepexFile(self._DepexFileName)\n            FileWrite(File, 'Final Dependency Expression (DEPEX) Instructions')\n            for DepexStatement in DepexStatements:\n                FileWrite(File, '  %s' % DepexStatement)\n            FileWrite(File, gSubSectionSep)\n        except:\n            EdkLogger.warn(None, 'Dependency expression file is corrupted', self._DepexFileName)\n    FileWrite(File, 'Dependency Expression (DEPEX) from %s' % self.Source)\n    if self.Source == 'INF':\n        FileWrite(File, self.Depex, True)\n        FileWrite(File, gSubSectionSep)\n        FileWrite(File, 'From Module INF:  %s' % self.ModuleDepex, True)\n        FileWrite(File, 'From Library INF: %s' % self.LibraryDepex, True)\n    else:\n        FileWrite(File, self.Depex)\n    FileWrite(File, gSubSectionEnd)",
            "def GenerateReport(self, File, GlobalDepexParser):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not self.Depex:\n        return\n    FileWrite(File, gSubSectionStart)\n    if os.path.isfile(self._DepexFileName):\n        try:\n            DepexStatements = GlobalDepexParser.ParseDepexFile(self._DepexFileName)\n            FileWrite(File, 'Final Dependency Expression (DEPEX) Instructions')\n            for DepexStatement in DepexStatements:\n                FileWrite(File, '  %s' % DepexStatement)\n            FileWrite(File, gSubSectionSep)\n        except:\n            EdkLogger.warn(None, 'Dependency expression file is corrupted', self._DepexFileName)\n    FileWrite(File, 'Dependency Expression (DEPEX) from %s' % self.Source)\n    if self.Source == 'INF':\n        FileWrite(File, self.Depex, True)\n        FileWrite(File, gSubSectionSep)\n        FileWrite(File, 'From Module INF:  %s' % self.ModuleDepex, True)\n        FileWrite(File, 'From Library INF: %s' % self.LibraryDepex, True)\n    else:\n        FileWrite(File, self.Depex)\n    FileWrite(File, gSubSectionEnd)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, M):\n    BuildOptions = {}\n    for Source in M.SourceFileList:\n        Ext = os.path.splitext(Source.File)[1].lower()\n        if Ext in ['.c', '.cc', '.cpp']:\n            BuildOptions['CC'] = 1\n        elif Ext in ['.s', '.asm']:\n            BuildOptions['PP'] = 1\n            BuildOptions['ASM'] = 1\n        elif Ext in ['.vfr']:\n            BuildOptions['VFRPP'] = 1\n            BuildOptions['VFR'] = 1\n        elif Ext in ['.dxs']:\n            BuildOptions['APP'] = 1\n            BuildOptions['CC'] = 1\n        elif Ext in ['.asl']:\n            BuildOptions['ASLPP'] = 1\n            BuildOptions['ASL'] = 1\n        elif Ext in ['.aslc']:\n            BuildOptions['ASLCC'] = 1\n            BuildOptions['ASLDLINK'] = 1\n            BuildOptions['CC'] = 1\n        elif Ext in ['.asm16']:\n            BuildOptions['ASMLINK'] = 1\n        BuildOptions['SLINK'] = 1\n        BuildOptions['DLINK'] = 1\n    self.ToolChainTag = M.ToolChain\n    self.BuildFlags = {}\n    for Tool in BuildOptions:\n        self.BuildFlags[Tool + '_FLAGS'] = M.BuildOption.get(Tool, {}).get('FLAGS', '')",
        "mutated": [
            "def __init__(self, M):\n    if False:\n        i = 10\n    BuildOptions = {}\n    for Source in M.SourceFileList:\n        Ext = os.path.splitext(Source.File)[1].lower()\n        if Ext in ['.c', '.cc', '.cpp']:\n            BuildOptions['CC'] = 1\n        elif Ext in ['.s', '.asm']:\n            BuildOptions['PP'] = 1\n            BuildOptions['ASM'] = 1\n        elif Ext in ['.vfr']:\n            BuildOptions['VFRPP'] = 1\n            BuildOptions['VFR'] = 1\n        elif Ext in ['.dxs']:\n            BuildOptions['APP'] = 1\n            BuildOptions['CC'] = 1\n        elif Ext in ['.asl']:\n            BuildOptions['ASLPP'] = 1\n            BuildOptions['ASL'] = 1\n        elif Ext in ['.aslc']:\n            BuildOptions['ASLCC'] = 1\n            BuildOptions['ASLDLINK'] = 1\n            BuildOptions['CC'] = 1\n        elif Ext in ['.asm16']:\n            BuildOptions['ASMLINK'] = 1\n        BuildOptions['SLINK'] = 1\n        BuildOptions['DLINK'] = 1\n    self.ToolChainTag = M.ToolChain\n    self.BuildFlags = {}\n    for Tool in BuildOptions:\n        self.BuildFlags[Tool + '_FLAGS'] = M.BuildOption.get(Tool, {}).get('FLAGS', '')",
            "def __init__(self, M):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    BuildOptions = {}\n    for Source in M.SourceFileList:\n        Ext = os.path.splitext(Source.File)[1].lower()\n        if Ext in ['.c', '.cc', '.cpp']:\n            BuildOptions['CC'] = 1\n        elif Ext in ['.s', '.asm']:\n            BuildOptions['PP'] = 1\n            BuildOptions['ASM'] = 1\n        elif Ext in ['.vfr']:\n            BuildOptions['VFRPP'] = 1\n            BuildOptions['VFR'] = 1\n        elif Ext in ['.dxs']:\n            BuildOptions['APP'] = 1\n            BuildOptions['CC'] = 1\n        elif Ext in ['.asl']:\n            BuildOptions['ASLPP'] = 1\n            BuildOptions['ASL'] = 1\n        elif Ext in ['.aslc']:\n            BuildOptions['ASLCC'] = 1\n            BuildOptions['ASLDLINK'] = 1\n            BuildOptions['CC'] = 1\n        elif Ext in ['.asm16']:\n            BuildOptions['ASMLINK'] = 1\n        BuildOptions['SLINK'] = 1\n        BuildOptions['DLINK'] = 1\n    self.ToolChainTag = M.ToolChain\n    self.BuildFlags = {}\n    for Tool in BuildOptions:\n        self.BuildFlags[Tool + '_FLAGS'] = M.BuildOption.get(Tool, {}).get('FLAGS', '')",
            "def __init__(self, M):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    BuildOptions = {}\n    for Source in M.SourceFileList:\n        Ext = os.path.splitext(Source.File)[1].lower()\n        if Ext in ['.c', '.cc', '.cpp']:\n            BuildOptions['CC'] = 1\n        elif Ext in ['.s', '.asm']:\n            BuildOptions['PP'] = 1\n            BuildOptions['ASM'] = 1\n        elif Ext in ['.vfr']:\n            BuildOptions['VFRPP'] = 1\n            BuildOptions['VFR'] = 1\n        elif Ext in ['.dxs']:\n            BuildOptions['APP'] = 1\n            BuildOptions['CC'] = 1\n        elif Ext in ['.asl']:\n            BuildOptions['ASLPP'] = 1\n            BuildOptions['ASL'] = 1\n        elif Ext in ['.aslc']:\n            BuildOptions['ASLCC'] = 1\n            BuildOptions['ASLDLINK'] = 1\n            BuildOptions['CC'] = 1\n        elif Ext in ['.asm16']:\n            BuildOptions['ASMLINK'] = 1\n        BuildOptions['SLINK'] = 1\n        BuildOptions['DLINK'] = 1\n    self.ToolChainTag = M.ToolChain\n    self.BuildFlags = {}\n    for Tool in BuildOptions:\n        self.BuildFlags[Tool + '_FLAGS'] = M.BuildOption.get(Tool, {}).get('FLAGS', '')",
            "def __init__(self, M):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    BuildOptions = {}\n    for Source in M.SourceFileList:\n        Ext = os.path.splitext(Source.File)[1].lower()\n        if Ext in ['.c', '.cc', '.cpp']:\n            BuildOptions['CC'] = 1\n        elif Ext in ['.s', '.asm']:\n            BuildOptions['PP'] = 1\n            BuildOptions['ASM'] = 1\n        elif Ext in ['.vfr']:\n            BuildOptions['VFRPP'] = 1\n            BuildOptions['VFR'] = 1\n        elif Ext in ['.dxs']:\n            BuildOptions['APP'] = 1\n            BuildOptions['CC'] = 1\n        elif Ext in ['.asl']:\n            BuildOptions['ASLPP'] = 1\n            BuildOptions['ASL'] = 1\n        elif Ext in ['.aslc']:\n            BuildOptions['ASLCC'] = 1\n            BuildOptions['ASLDLINK'] = 1\n            BuildOptions['CC'] = 1\n        elif Ext in ['.asm16']:\n            BuildOptions['ASMLINK'] = 1\n        BuildOptions['SLINK'] = 1\n        BuildOptions['DLINK'] = 1\n    self.ToolChainTag = M.ToolChain\n    self.BuildFlags = {}\n    for Tool in BuildOptions:\n        self.BuildFlags[Tool + '_FLAGS'] = M.BuildOption.get(Tool, {}).get('FLAGS', '')",
            "def __init__(self, M):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    BuildOptions = {}\n    for Source in M.SourceFileList:\n        Ext = os.path.splitext(Source.File)[1].lower()\n        if Ext in ['.c', '.cc', '.cpp']:\n            BuildOptions['CC'] = 1\n        elif Ext in ['.s', '.asm']:\n            BuildOptions['PP'] = 1\n            BuildOptions['ASM'] = 1\n        elif Ext in ['.vfr']:\n            BuildOptions['VFRPP'] = 1\n            BuildOptions['VFR'] = 1\n        elif Ext in ['.dxs']:\n            BuildOptions['APP'] = 1\n            BuildOptions['CC'] = 1\n        elif Ext in ['.asl']:\n            BuildOptions['ASLPP'] = 1\n            BuildOptions['ASL'] = 1\n        elif Ext in ['.aslc']:\n            BuildOptions['ASLCC'] = 1\n            BuildOptions['ASLDLINK'] = 1\n            BuildOptions['CC'] = 1\n        elif Ext in ['.asm16']:\n            BuildOptions['ASMLINK'] = 1\n        BuildOptions['SLINK'] = 1\n        BuildOptions['DLINK'] = 1\n    self.ToolChainTag = M.ToolChain\n    self.BuildFlags = {}\n    for Tool in BuildOptions:\n        self.BuildFlags[Tool + '_FLAGS'] = M.BuildOption.get(Tool, {}).get('FLAGS', '')"
        ]
    },
    {
        "func_name": "GenerateReport",
        "original": "def GenerateReport(self, File):\n    FileWrite(File, gSubSectionStart)\n    FileWrite(File, 'Build Flags')\n    FileWrite(File, 'Tool Chain Tag: %s' % self.ToolChainTag)\n    for Tool in self.BuildFlags:\n        FileWrite(File, gSubSectionSep)\n        FileWrite(File, '%s = %s' % (Tool, self.BuildFlags[Tool]), True)\n    FileWrite(File, gSubSectionEnd)",
        "mutated": [
            "def GenerateReport(self, File):\n    if False:\n        i = 10\n    FileWrite(File, gSubSectionStart)\n    FileWrite(File, 'Build Flags')\n    FileWrite(File, 'Tool Chain Tag: %s' % self.ToolChainTag)\n    for Tool in self.BuildFlags:\n        FileWrite(File, gSubSectionSep)\n        FileWrite(File, '%s = %s' % (Tool, self.BuildFlags[Tool]), True)\n    FileWrite(File, gSubSectionEnd)",
            "def GenerateReport(self, File):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    FileWrite(File, gSubSectionStart)\n    FileWrite(File, 'Build Flags')\n    FileWrite(File, 'Tool Chain Tag: %s' % self.ToolChainTag)\n    for Tool in self.BuildFlags:\n        FileWrite(File, gSubSectionSep)\n        FileWrite(File, '%s = %s' % (Tool, self.BuildFlags[Tool]), True)\n    FileWrite(File, gSubSectionEnd)",
            "def GenerateReport(self, File):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    FileWrite(File, gSubSectionStart)\n    FileWrite(File, 'Build Flags')\n    FileWrite(File, 'Tool Chain Tag: %s' % self.ToolChainTag)\n    for Tool in self.BuildFlags:\n        FileWrite(File, gSubSectionSep)\n        FileWrite(File, '%s = %s' % (Tool, self.BuildFlags[Tool]), True)\n    FileWrite(File, gSubSectionEnd)",
            "def GenerateReport(self, File):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    FileWrite(File, gSubSectionStart)\n    FileWrite(File, 'Build Flags')\n    FileWrite(File, 'Tool Chain Tag: %s' % self.ToolChainTag)\n    for Tool in self.BuildFlags:\n        FileWrite(File, gSubSectionSep)\n        FileWrite(File, '%s = %s' % (Tool, self.BuildFlags[Tool]), True)\n    FileWrite(File, gSubSectionEnd)",
            "def GenerateReport(self, File):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    FileWrite(File, gSubSectionStart)\n    FileWrite(File, 'Build Flags')\n    FileWrite(File, 'Tool Chain Tag: %s' % self.ToolChainTag)\n    for Tool in self.BuildFlags:\n        FileWrite(File, gSubSectionSep)\n        FileWrite(File, '%s = %s' % (Tool, self.BuildFlags[Tool]), True)\n    FileWrite(File, gSubSectionEnd)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, M, ReportType):\n    self.ModuleName = M.Module.BaseName\n    self.ModuleInfPath = M.MetaFile.File\n    self.ModuleArch = M.Arch\n    self.FileGuid = M.Guid\n    self.Size = 0\n    self.BuildTimeStamp = None\n    self.Hash = 0\n    self.DriverType = ''\n    if not M.IsLibrary:\n        ModuleType = M.ModuleType\n        if not ModuleType:\n            ModuleType = COMPONENT_TO_MODULE_MAP_DICT.get(M.ComponentType, '')\n        if ModuleType == SUP_MODULE_DXE_SMM_DRIVER:\n            PiSpec = M.Module.Specification.get('PI_SPECIFICATION_VERSION', '0x00010000')\n            if int(PiSpec, 0) >= 65546:\n                ModuleType = 'SMM_DRIVER'\n        self.DriverType = gDriverTypeMap.get(ModuleType, '0x2 (FREE_FORM)')\n    self.UefiSpecVersion = M.Module.Specification.get('UEFI_SPECIFICATION_VERSION', '')\n    self.PiSpecVersion = M.Module.Specification.get('PI_SPECIFICATION_VERSION', '')\n    self.PciDeviceId = M.Module.Defines.get('PCI_DEVICE_ID', '')\n    self.PciVendorId = M.Module.Defines.get('PCI_VENDOR_ID', '')\n    self.PciClassCode = M.Module.Defines.get('PCI_CLASS_CODE', '')\n    self.BuildTime = M.BuildTime\n    self._BuildDir = M.BuildDir\n    self.ModulePcdSet = {}\n    if 'PCD' in ReportType:\n        for Pcd in M.ModulePcdList + M.LibraryPcdList:\n            self.ModulePcdSet.setdefault((Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Pcd.Type), (Pcd.InfDefaultValue, Pcd.DefaultValue))\n    self.LibraryReport = None\n    if 'LIBRARY' in ReportType:\n        self.LibraryReport = LibraryReport(M)\n    self.DepexReport = None\n    if 'DEPEX' in ReportType:\n        self.DepexReport = DepexReport(M)\n    if 'BUILD_FLAGS' in ReportType:\n        self.BuildFlagsReport = BuildFlagsReport(M)",
        "mutated": [
            "def __init__(self, M, ReportType):\n    if False:\n        i = 10\n    self.ModuleName = M.Module.BaseName\n    self.ModuleInfPath = M.MetaFile.File\n    self.ModuleArch = M.Arch\n    self.FileGuid = M.Guid\n    self.Size = 0\n    self.BuildTimeStamp = None\n    self.Hash = 0\n    self.DriverType = ''\n    if not M.IsLibrary:\n        ModuleType = M.ModuleType\n        if not ModuleType:\n            ModuleType = COMPONENT_TO_MODULE_MAP_DICT.get(M.ComponentType, '')\n        if ModuleType == SUP_MODULE_DXE_SMM_DRIVER:\n            PiSpec = M.Module.Specification.get('PI_SPECIFICATION_VERSION', '0x00010000')\n            if int(PiSpec, 0) >= 65546:\n                ModuleType = 'SMM_DRIVER'\n        self.DriverType = gDriverTypeMap.get(ModuleType, '0x2 (FREE_FORM)')\n    self.UefiSpecVersion = M.Module.Specification.get('UEFI_SPECIFICATION_VERSION', '')\n    self.PiSpecVersion = M.Module.Specification.get('PI_SPECIFICATION_VERSION', '')\n    self.PciDeviceId = M.Module.Defines.get('PCI_DEVICE_ID', '')\n    self.PciVendorId = M.Module.Defines.get('PCI_VENDOR_ID', '')\n    self.PciClassCode = M.Module.Defines.get('PCI_CLASS_CODE', '')\n    self.BuildTime = M.BuildTime\n    self._BuildDir = M.BuildDir\n    self.ModulePcdSet = {}\n    if 'PCD' in ReportType:\n        for Pcd in M.ModulePcdList + M.LibraryPcdList:\n            self.ModulePcdSet.setdefault((Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Pcd.Type), (Pcd.InfDefaultValue, Pcd.DefaultValue))\n    self.LibraryReport = None\n    if 'LIBRARY' in ReportType:\n        self.LibraryReport = LibraryReport(M)\n    self.DepexReport = None\n    if 'DEPEX' in ReportType:\n        self.DepexReport = DepexReport(M)\n    if 'BUILD_FLAGS' in ReportType:\n        self.BuildFlagsReport = BuildFlagsReport(M)",
            "def __init__(self, M, ReportType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.ModuleName = M.Module.BaseName\n    self.ModuleInfPath = M.MetaFile.File\n    self.ModuleArch = M.Arch\n    self.FileGuid = M.Guid\n    self.Size = 0\n    self.BuildTimeStamp = None\n    self.Hash = 0\n    self.DriverType = ''\n    if not M.IsLibrary:\n        ModuleType = M.ModuleType\n        if not ModuleType:\n            ModuleType = COMPONENT_TO_MODULE_MAP_DICT.get(M.ComponentType, '')\n        if ModuleType == SUP_MODULE_DXE_SMM_DRIVER:\n            PiSpec = M.Module.Specification.get('PI_SPECIFICATION_VERSION', '0x00010000')\n            if int(PiSpec, 0) >= 65546:\n                ModuleType = 'SMM_DRIVER'\n        self.DriverType = gDriverTypeMap.get(ModuleType, '0x2 (FREE_FORM)')\n    self.UefiSpecVersion = M.Module.Specification.get('UEFI_SPECIFICATION_VERSION', '')\n    self.PiSpecVersion = M.Module.Specification.get('PI_SPECIFICATION_VERSION', '')\n    self.PciDeviceId = M.Module.Defines.get('PCI_DEVICE_ID', '')\n    self.PciVendorId = M.Module.Defines.get('PCI_VENDOR_ID', '')\n    self.PciClassCode = M.Module.Defines.get('PCI_CLASS_CODE', '')\n    self.BuildTime = M.BuildTime\n    self._BuildDir = M.BuildDir\n    self.ModulePcdSet = {}\n    if 'PCD' in ReportType:\n        for Pcd in M.ModulePcdList + M.LibraryPcdList:\n            self.ModulePcdSet.setdefault((Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Pcd.Type), (Pcd.InfDefaultValue, Pcd.DefaultValue))\n    self.LibraryReport = None\n    if 'LIBRARY' in ReportType:\n        self.LibraryReport = LibraryReport(M)\n    self.DepexReport = None\n    if 'DEPEX' in ReportType:\n        self.DepexReport = DepexReport(M)\n    if 'BUILD_FLAGS' in ReportType:\n        self.BuildFlagsReport = BuildFlagsReport(M)",
            "def __init__(self, M, ReportType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.ModuleName = M.Module.BaseName\n    self.ModuleInfPath = M.MetaFile.File\n    self.ModuleArch = M.Arch\n    self.FileGuid = M.Guid\n    self.Size = 0\n    self.BuildTimeStamp = None\n    self.Hash = 0\n    self.DriverType = ''\n    if not M.IsLibrary:\n        ModuleType = M.ModuleType\n        if not ModuleType:\n            ModuleType = COMPONENT_TO_MODULE_MAP_DICT.get(M.ComponentType, '')\n        if ModuleType == SUP_MODULE_DXE_SMM_DRIVER:\n            PiSpec = M.Module.Specification.get('PI_SPECIFICATION_VERSION', '0x00010000')\n            if int(PiSpec, 0) >= 65546:\n                ModuleType = 'SMM_DRIVER'\n        self.DriverType = gDriverTypeMap.get(ModuleType, '0x2 (FREE_FORM)')\n    self.UefiSpecVersion = M.Module.Specification.get('UEFI_SPECIFICATION_VERSION', '')\n    self.PiSpecVersion = M.Module.Specification.get('PI_SPECIFICATION_VERSION', '')\n    self.PciDeviceId = M.Module.Defines.get('PCI_DEVICE_ID', '')\n    self.PciVendorId = M.Module.Defines.get('PCI_VENDOR_ID', '')\n    self.PciClassCode = M.Module.Defines.get('PCI_CLASS_CODE', '')\n    self.BuildTime = M.BuildTime\n    self._BuildDir = M.BuildDir\n    self.ModulePcdSet = {}\n    if 'PCD' in ReportType:\n        for Pcd in M.ModulePcdList + M.LibraryPcdList:\n            self.ModulePcdSet.setdefault((Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Pcd.Type), (Pcd.InfDefaultValue, Pcd.DefaultValue))\n    self.LibraryReport = None\n    if 'LIBRARY' in ReportType:\n        self.LibraryReport = LibraryReport(M)\n    self.DepexReport = None\n    if 'DEPEX' in ReportType:\n        self.DepexReport = DepexReport(M)\n    if 'BUILD_FLAGS' in ReportType:\n        self.BuildFlagsReport = BuildFlagsReport(M)",
            "def __init__(self, M, ReportType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.ModuleName = M.Module.BaseName\n    self.ModuleInfPath = M.MetaFile.File\n    self.ModuleArch = M.Arch\n    self.FileGuid = M.Guid\n    self.Size = 0\n    self.BuildTimeStamp = None\n    self.Hash = 0\n    self.DriverType = ''\n    if not M.IsLibrary:\n        ModuleType = M.ModuleType\n        if not ModuleType:\n            ModuleType = COMPONENT_TO_MODULE_MAP_DICT.get(M.ComponentType, '')\n        if ModuleType == SUP_MODULE_DXE_SMM_DRIVER:\n            PiSpec = M.Module.Specification.get('PI_SPECIFICATION_VERSION', '0x00010000')\n            if int(PiSpec, 0) >= 65546:\n                ModuleType = 'SMM_DRIVER'\n        self.DriverType = gDriverTypeMap.get(ModuleType, '0x2 (FREE_FORM)')\n    self.UefiSpecVersion = M.Module.Specification.get('UEFI_SPECIFICATION_VERSION', '')\n    self.PiSpecVersion = M.Module.Specification.get('PI_SPECIFICATION_VERSION', '')\n    self.PciDeviceId = M.Module.Defines.get('PCI_DEVICE_ID', '')\n    self.PciVendorId = M.Module.Defines.get('PCI_VENDOR_ID', '')\n    self.PciClassCode = M.Module.Defines.get('PCI_CLASS_CODE', '')\n    self.BuildTime = M.BuildTime\n    self._BuildDir = M.BuildDir\n    self.ModulePcdSet = {}\n    if 'PCD' in ReportType:\n        for Pcd in M.ModulePcdList + M.LibraryPcdList:\n            self.ModulePcdSet.setdefault((Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Pcd.Type), (Pcd.InfDefaultValue, Pcd.DefaultValue))\n    self.LibraryReport = None\n    if 'LIBRARY' in ReportType:\n        self.LibraryReport = LibraryReport(M)\n    self.DepexReport = None\n    if 'DEPEX' in ReportType:\n        self.DepexReport = DepexReport(M)\n    if 'BUILD_FLAGS' in ReportType:\n        self.BuildFlagsReport = BuildFlagsReport(M)",
            "def __init__(self, M, ReportType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.ModuleName = M.Module.BaseName\n    self.ModuleInfPath = M.MetaFile.File\n    self.ModuleArch = M.Arch\n    self.FileGuid = M.Guid\n    self.Size = 0\n    self.BuildTimeStamp = None\n    self.Hash = 0\n    self.DriverType = ''\n    if not M.IsLibrary:\n        ModuleType = M.ModuleType\n        if not ModuleType:\n            ModuleType = COMPONENT_TO_MODULE_MAP_DICT.get(M.ComponentType, '')\n        if ModuleType == SUP_MODULE_DXE_SMM_DRIVER:\n            PiSpec = M.Module.Specification.get('PI_SPECIFICATION_VERSION', '0x00010000')\n            if int(PiSpec, 0) >= 65546:\n                ModuleType = 'SMM_DRIVER'\n        self.DriverType = gDriverTypeMap.get(ModuleType, '0x2 (FREE_FORM)')\n    self.UefiSpecVersion = M.Module.Specification.get('UEFI_SPECIFICATION_VERSION', '')\n    self.PiSpecVersion = M.Module.Specification.get('PI_SPECIFICATION_VERSION', '')\n    self.PciDeviceId = M.Module.Defines.get('PCI_DEVICE_ID', '')\n    self.PciVendorId = M.Module.Defines.get('PCI_VENDOR_ID', '')\n    self.PciClassCode = M.Module.Defines.get('PCI_CLASS_CODE', '')\n    self.BuildTime = M.BuildTime\n    self._BuildDir = M.BuildDir\n    self.ModulePcdSet = {}\n    if 'PCD' in ReportType:\n        for Pcd in M.ModulePcdList + M.LibraryPcdList:\n            self.ModulePcdSet.setdefault((Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Pcd.Type), (Pcd.InfDefaultValue, Pcd.DefaultValue))\n    self.LibraryReport = None\n    if 'LIBRARY' in ReportType:\n        self.LibraryReport = LibraryReport(M)\n    self.DepexReport = None\n    if 'DEPEX' in ReportType:\n        self.DepexReport = DepexReport(M)\n    if 'BUILD_FLAGS' in ReportType:\n        self.BuildFlagsReport = BuildFlagsReport(M)"
        ]
    },
    {
        "func_name": "GenerateReport",
        "original": "def GenerateReport(self, File, GlobalPcdReport, GlobalPredictionReport, GlobalDepexParser, ReportType):\n    FileWrite(File, gSectionStart)\n    FwReportFileName = os.path.join(self._BuildDir, 'OUTPUT', self.ModuleName + '.txt')\n    if os.path.isfile(FwReportFileName):\n        try:\n            FileContents = open(FwReportFileName).read()\n            Match = gModuleSizePattern.search(FileContents)\n            if Match:\n                self.Size = int(Match.group(1))\n            Match = gTimeStampPattern.search(FileContents)\n            if Match:\n                self.BuildTimeStamp = datetime.utcfromtimestamp(int(Match.group(1)))\n        except IOError:\n            EdkLogger.warn(None, 'Fail to read report file', FwReportFileName)\n    if 'HASH' in ReportType:\n        OutputDir = os.path.join(self._BuildDir, 'OUTPUT')\n        DefaultEFIfile = os.path.join(OutputDir, self.ModuleName + '.efi')\n        if os.path.isfile(DefaultEFIfile):\n            Tempfile = os.path.join(OutputDir, self.ModuleName + '_hash.tmp')\n            cmd = ['GenFw', '--rebase', str(0), '-o', Tempfile, DefaultEFIfile]\n            try:\n                PopenObject = subprocess.Popen(' '.join(cmd), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n            except Exception as X:\n                EdkLogger.error('GenFw', COMMAND_FAILURE, ExtraData='%s: %s' % (str(X), cmd[0]))\n            EndOfProcedure = threading.Event()\n            EndOfProcedure.clear()\n            if PopenObject.stderr:\n                StdErrThread = threading.Thread(target=ReadMessage, args=(PopenObject.stderr, EdkLogger.quiet, EndOfProcedure))\n                StdErrThread.setName('STDERR-Redirector')\n                StdErrThread.setDaemon(False)\n                StdErrThread.start()\n            PopenObject.wait()\n            if PopenObject.stderr:\n                StdErrThread.join()\n            if PopenObject.returncode != 0:\n                EdkLogger.error('GenFw', COMMAND_FAILURE, 'Failed to generate firmware hash image for %s' % DefaultEFIfile)\n            if os.path.isfile(Tempfile):\n                self.Hash = hashlib.sha1()\n                buf = open(Tempfile, 'rb').read()\n                if self.Hash.update(buf):\n                    self.Hash = self.Hash.update(buf)\n                self.Hash = self.Hash.hexdigest()\n                os.remove(Tempfile)\n    FileWrite(File, 'Module Summary')\n    FileWrite(File, 'Module Name:          %s' % self.ModuleName)\n    FileWrite(File, 'Module Arch:          %s' % self.ModuleArch)\n    FileWrite(File, 'Module INF Path:      %s' % self.ModuleInfPath)\n    FileWrite(File, 'File GUID:            %s' % self.FileGuid)\n    if self.Size:\n        FileWrite(File, 'Size:                 0x%X (%.2fK)' % (self.Size, self.Size / 1024.0))\n    if self.Hash:\n        FileWrite(File, 'SHA1 HASH:            %s *%s' % (self.Hash, self.ModuleName + '.efi'))\n    if self.BuildTimeStamp:\n        FileWrite(File, 'Build Time Stamp:     %s' % self.BuildTimeStamp)\n    if self.BuildTime:\n        FileWrite(File, 'Module Build Time:    %s' % self.BuildTime)\n    if self.DriverType:\n        FileWrite(File, 'Driver Type:          %s' % self.DriverType)\n    if self.UefiSpecVersion:\n        FileWrite(File, 'UEFI Spec Version:    %s' % self.UefiSpecVersion)\n    if self.PiSpecVersion:\n        FileWrite(File, 'PI Spec Version:      %s' % self.PiSpecVersion)\n    if self.PciDeviceId:\n        FileWrite(File, 'PCI Device ID:        %s' % self.PciDeviceId)\n    if self.PciVendorId:\n        FileWrite(File, 'PCI Vendor ID:        %s' % self.PciVendorId)\n    if self.PciClassCode:\n        FileWrite(File, 'PCI Class Code:       %s' % self.PciClassCode)\n    FileWrite(File, gSectionSep)\n    if 'PCD' in ReportType:\n        GlobalPcdReport.GenerateReport(File, self.ModulePcdSet, self.FileGuid)\n    if 'LIBRARY' in ReportType:\n        self.LibraryReport.GenerateReport(File)\n    if 'DEPEX' in ReportType:\n        self.DepexReport.GenerateReport(File, GlobalDepexParser)\n    if 'BUILD_FLAGS' in ReportType:\n        self.BuildFlagsReport.GenerateReport(File)\n    if 'FIXED_ADDRESS' in ReportType and self.FileGuid:\n        GlobalPredictionReport.GenerateReport(File, self.FileGuid)\n    FileWrite(File, gSectionEnd)",
        "mutated": [
            "def GenerateReport(self, File, GlobalPcdReport, GlobalPredictionReport, GlobalDepexParser, ReportType):\n    if False:\n        i = 10\n    FileWrite(File, gSectionStart)\n    FwReportFileName = os.path.join(self._BuildDir, 'OUTPUT', self.ModuleName + '.txt')\n    if os.path.isfile(FwReportFileName):\n        try:\n            FileContents = open(FwReportFileName).read()\n            Match = gModuleSizePattern.search(FileContents)\n            if Match:\n                self.Size = int(Match.group(1))\n            Match = gTimeStampPattern.search(FileContents)\n            if Match:\n                self.BuildTimeStamp = datetime.utcfromtimestamp(int(Match.group(1)))\n        except IOError:\n            EdkLogger.warn(None, 'Fail to read report file', FwReportFileName)\n    if 'HASH' in ReportType:\n        OutputDir = os.path.join(self._BuildDir, 'OUTPUT')\n        DefaultEFIfile = os.path.join(OutputDir, self.ModuleName + '.efi')\n        if os.path.isfile(DefaultEFIfile):\n            Tempfile = os.path.join(OutputDir, self.ModuleName + '_hash.tmp')\n            cmd = ['GenFw', '--rebase', str(0), '-o', Tempfile, DefaultEFIfile]\n            try:\n                PopenObject = subprocess.Popen(' '.join(cmd), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n            except Exception as X:\n                EdkLogger.error('GenFw', COMMAND_FAILURE, ExtraData='%s: %s' % (str(X), cmd[0]))\n            EndOfProcedure = threading.Event()\n            EndOfProcedure.clear()\n            if PopenObject.stderr:\n                StdErrThread = threading.Thread(target=ReadMessage, args=(PopenObject.stderr, EdkLogger.quiet, EndOfProcedure))\n                StdErrThread.setName('STDERR-Redirector')\n                StdErrThread.setDaemon(False)\n                StdErrThread.start()\n            PopenObject.wait()\n            if PopenObject.stderr:\n                StdErrThread.join()\n            if PopenObject.returncode != 0:\n                EdkLogger.error('GenFw', COMMAND_FAILURE, 'Failed to generate firmware hash image for %s' % DefaultEFIfile)\n            if os.path.isfile(Tempfile):\n                self.Hash = hashlib.sha1()\n                buf = open(Tempfile, 'rb').read()\n                if self.Hash.update(buf):\n                    self.Hash = self.Hash.update(buf)\n                self.Hash = self.Hash.hexdigest()\n                os.remove(Tempfile)\n    FileWrite(File, 'Module Summary')\n    FileWrite(File, 'Module Name:          %s' % self.ModuleName)\n    FileWrite(File, 'Module Arch:          %s' % self.ModuleArch)\n    FileWrite(File, 'Module INF Path:      %s' % self.ModuleInfPath)\n    FileWrite(File, 'File GUID:            %s' % self.FileGuid)\n    if self.Size:\n        FileWrite(File, 'Size:                 0x%X (%.2fK)' % (self.Size, self.Size / 1024.0))\n    if self.Hash:\n        FileWrite(File, 'SHA1 HASH:            %s *%s' % (self.Hash, self.ModuleName + '.efi'))\n    if self.BuildTimeStamp:\n        FileWrite(File, 'Build Time Stamp:     %s' % self.BuildTimeStamp)\n    if self.BuildTime:\n        FileWrite(File, 'Module Build Time:    %s' % self.BuildTime)\n    if self.DriverType:\n        FileWrite(File, 'Driver Type:          %s' % self.DriverType)\n    if self.UefiSpecVersion:\n        FileWrite(File, 'UEFI Spec Version:    %s' % self.UefiSpecVersion)\n    if self.PiSpecVersion:\n        FileWrite(File, 'PI Spec Version:      %s' % self.PiSpecVersion)\n    if self.PciDeviceId:\n        FileWrite(File, 'PCI Device ID:        %s' % self.PciDeviceId)\n    if self.PciVendorId:\n        FileWrite(File, 'PCI Vendor ID:        %s' % self.PciVendorId)\n    if self.PciClassCode:\n        FileWrite(File, 'PCI Class Code:       %s' % self.PciClassCode)\n    FileWrite(File, gSectionSep)\n    if 'PCD' in ReportType:\n        GlobalPcdReport.GenerateReport(File, self.ModulePcdSet, self.FileGuid)\n    if 'LIBRARY' in ReportType:\n        self.LibraryReport.GenerateReport(File)\n    if 'DEPEX' in ReportType:\n        self.DepexReport.GenerateReport(File, GlobalDepexParser)\n    if 'BUILD_FLAGS' in ReportType:\n        self.BuildFlagsReport.GenerateReport(File)\n    if 'FIXED_ADDRESS' in ReportType and self.FileGuid:\n        GlobalPredictionReport.GenerateReport(File, self.FileGuid)\n    FileWrite(File, gSectionEnd)",
            "def GenerateReport(self, File, GlobalPcdReport, GlobalPredictionReport, GlobalDepexParser, ReportType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    FileWrite(File, gSectionStart)\n    FwReportFileName = os.path.join(self._BuildDir, 'OUTPUT', self.ModuleName + '.txt')\n    if os.path.isfile(FwReportFileName):\n        try:\n            FileContents = open(FwReportFileName).read()\n            Match = gModuleSizePattern.search(FileContents)\n            if Match:\n                self.Size = int(Match.group(1))\n            Match = gTimeStampPattern.search(FileContents)\n            if Match:\n                self.BuildTimeStamp = datetime.utcfromtimestamp(int(Match.group(1)))\n        except IOError:\n            EdkLogger.warn(None, 'Fail to read report file', FwReportFileName)\n    if 'HASH' in ReportType:\n        OutputDir = os.path.join(self._BuildDir, 'OUTPUT')\n        DefaultEFIfile = os.path.join(OutputDir, self.ModuleName + '.efi')\n        if os.path.isfile(DefaultEFIfile):\n            Tempfile = os.path.join(OutputDir, self.ModuleName + '_hash.tmp')\n            cmd = ['GenFw', '--rebase', str(0), '-o', Tempfile, DefaultEFIfile]\n            try:\n                PopenObject = subprocess.Popen(' '.join(cmd), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n            except Exception as X:\n                EdkLogger.error('GenFw', COMMAND_FAILURE, ExtraData='%s: %s' % (str(X), cmd[0]))\n            EndOfProcedure = threading.Event()\n            EndOfProcedure.clear()\n            if PopenObject.stderr:\n                StdErrThread = threading.Thread(target=ReadMessage, args=(PopenObject.stderr, EdkLogger.quiet, EndOfProcedure))\n                StdErrThread.setName('STDERR-Redirector')\n                StdErrThread.setDaemon(False)\n                StdErrThread.start()\n            PopenObject.wait()\n            if PopenObject.stderr:\n                StdErrThread.join()\n            if PopenObject.returncode != 0:\n                EdkLogger.error('GenFw', COMMAND_FAILURE, 'Failed to generate firmware hash image for %s' % DefaultEFIfile)\n            if os.path.isfile(Tempfile):\n                self.Hash = hashlib.sha1()\n                buf = open(Tempfile, 'rb').read()\n                if self.Hash.update(buf):\n                    self.Hash = self.Hash.update(buf)\n                self.Hash = self.Hash.hexdigest()\n                os.remove(Tempfile)\n    FileWrite(File, 'Module Summary')\n    FileWrite(File, 'Module Name:          %s' % self.ModuleName)\n    FileWrite(File, 'Module Arch:          %s' % self.ModuleArch)\n    FileWrite(File, 'Module INF Path:      %s' % self.ModuleInfPath)\n    FileWrite(File, 'File GUID:            %s' % self.FileGuid)\n    if self.Size:\n        FileWrite(File, 'Size:                 0x%X (%.2fK)' % (self.Size, self.Size / 1024.0))\n    if self.Hash:\n        FileWrite(File, 'SHA1 HASH:            %s *%s' % (self.Hash, self.ModuleName + '.efi'))\n    if self.BuildTimeStamp:\n        FileWrite(File, 'Build Time Stamp:     %s' % self.BuildTimeStamp)\n    if self.BuildTime:\n        FileWrite(File, 'Module Build Time:    %s' % self.BuildTime)\n    if self.DriverType:\n        FileWrite(File, 'Driver Type:          %s' % self.DriverType)\n    if self.UefiSpecVersion:\n        FileWrite(File, 'UEFI Spec Version:    %s' % self.UefiSpecVersion)\n    if self.PiSpecVersion:\n        FileWrite(File, 'PI Spec Version:      %s' % self.PiSpecVersion)\n    if self.PciDeviceId:\n        FileWrite(File, 'PCI Device ID:        %s' % self.PciDeviceId)\n    if self.PciVendorId:\n        FileWrite(File, 'PCI Vendor ID:        %s' % self.PciVendorId)\n    if self.PciClassCode:\n        FileWrite(File, 'PCI Class Code:       %s' % self.PciClassCode)\n    FileWrite(File, gSectionSep)\n    if 'PCD' in ReportType:\n        GlobalPcdReport.GenerateReport(File, self.ModulePcdSet, self.FileGuid)\n    if 'LIBRARY' in ReportType:\n        self.LibraryReport.GenerateReport(File)\n    if 'DEPEX' in ReportType:\n        self.DepexReport.GenerateReport(File, GlobalDepexParser)\n    if 'BUILD_FLAGS' in ReportType:\n        self.BuildFlagsReport.GenerateReport(File)\n    if 'FIXED_ADDRESS' in ReportType and self.FileGuid:\n        GlobalPredictionReport.GenerateReport(File, self.FileGuid)\n    FileWrite(File, gSectionEnd)",
            "def GenerateReport(self, File, GlobalPcdReport, GlobalPredictionReport, GlobalDepexParser, ReportType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    FileWrite(File, gSectionStart)\n    FwReportFileName = os.path.join(self._BuildDir, 'OUTPUT', self.ModuleName + '.txt')\n    if os.path.isfile(FwReportFileName):\n        try:\n            FileContents = open(FwReportFileName).read()\n            Match = gModuleSizePattern.search(FileContents)\n            if Match:\n                self.Size = int(Match.group(1))\n            Match = gTimeStampPattern.search(FileContents)\n            if Match:\n                self.BuildTimeStamp = datetime.utcfromtimestamp(int(Match.group(1)))\n        except IOError:\n            EdkLogger.warn(None, 'Fail to read report file', FwReportFileName)\n    if 'HASH' in ReportType:\n        OutputDir = os.path.join(self._BuildDir, 'OUTPUT')\n        DefaultEFIfile = os.path.join(OutputDir, self.ModuleName + '.efi')\n        if os.path.isfile(DefaultEFIfile):\n            Tempfile = os.path.join(OutputDir, self.ModuleName + '_hash.tmp')\n            cmd = ['GenFw', '--rebase', str(0), '-o', Tempfile, DefaultEFIfile]\n            try:\n                PopenObject = subprocess.Popen(' '.join(cmd), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n            except Exception as X:\n                EdkLogger.error('GenFw', COMMAND_FAILURE, ExtraData='%s: %s' % (str(X), cmd[0]))\n            EndOfProcedure = threading.Event()\n            EndOfProcedure.clear()\n            if PopenObject.stderr:\n                StdErrThread = threading.Thread(target=ReadMessage, args=(PopenObject.stderr, EdkLogger.quiet, EndOfProcedure))\n                StdErrThread.setName('STDERR-Redirector')\n                StdErrThread.setDaemon(False)\n                StdErrThread.start()\n            PopenObject.wait()\n            if PopenObject.stderr:\n                StdErrThread.join()\n            if PopenObject.returncode != 0:\n                EdkLogger.error('GenFw', COMMAND_FAILURE, 'Failed to generate firmware hash image for %s' % DefaultEFIfile)\n            if os.path.isfile(Tempfile):\n                self.Hash = hashlib.sha1()\n                buf = open(Tempfile, 'rb').read()\n                if self.Hash.update(buf):\n                    self.Hash = self.Hash.update(buf)\n                self.Hash = self.Hash.hexdigest()\n                os.remove(Tempfile)\n    FileWrite(File, 'Module Summary')\n    FileWrite(File, 'Module Name:          %s' % self.ModuleName)\n    FileWrite(File, 'Module Arch:          %s' % self.ModuleArch)\n    FileWrite(File, 'Module INF Path:      %s' % self.ModuleInfPath)\n    FileWrite(File, 'File GUID:            %s' % self.FileGuid)\n    if self.Size:\n        FileWrite(File, 'Size:                 0x%X (%.2fK)' % (self.Size, self.Size / 1024.0))\n    if self.Hash:\n        FileWrite(File, 'SHA1 HASH:            %s *%s' % (self.Hash, self.ModuleName + '.efi'))\n    if self.BuildTimeStamp:\n        FileWrite(File, 'Build Time Stamp:     %s' % self.BuildTimeStamp)\n    if self.BuildTime:\n        FileWrite(File, 'Module Build Time:    %s' % self.BuildTime)\n    if self.DriverType:\n        FileWrite(File, 'Driver Type:          %s' % self.DriverType)\n    if self.UefiSpecVersion:\n        FileWrite(File, 'UEFI Spec Version:    %s' % self.UefiSpecVersion)\n    if self.PiSpecVersion:\n        FileWrite(File, 'PI Spec Version:      %s' % self.PiSpecVersion)\n    if self.PciDeviceId:\n        FileWrite(File, 'PCI Device ID:        %s' % self.PciDeviceId)\n    if self.PciVendorId:\n        FileWrite(File, 'PCI Vendor ID:        %s' % self.PciVendorId)\n    if self.PciClassCode:\n        FileWrite(File, 'PCI Class Code:       %s' % self.PciClassCode)\n    FileWrite(File, gSectionSep)\n    if 'PCD' in ReportType:\n        GlobalPcdReport.GenerateReport(File, self.ModulePcdSet, self.FileGuid)\n    if 'LIBRARY' in ReportType:\n        self.LibraryReport.GenerateReport(File)\n    if 'DEPEX' in ReportType:\n        self.DepexReport.GenerateReport(File, GlobalDepexParser)\n    if 'BUILD_FLAGS' in ReportType:\n        self.BuildFlagsReport.GenerateReport(File)\n    if 'FIXED_ADDRESS' in ReportType and self.FileGuid:\n        GlobalPredictionReport.GenerateReport(File, self.FileGuid)\n    FileWrite(File, gSectionEnd)",
            "def GenerateReport(self, File, GlobalPcdReport, GlobalPredictionReport, GlobalDepexParser, ReportType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    FileWrite(File, gSectionStart)\n    FwReportFileName = os.path.join(self._BuildDir, 'OUTPUT', self.ModuleName + '.txt')\n    if os.path.isfile(FwReportFileName):\n        try:\n            FileContents = open(FwReportFileName).read()\n            Match = gModuleSizePattern.search(FileContents)\n            if Match:\n                self.Size = int(Match.group(1))\n            Match = gTimeStampPattern.search(FileContents)\n            if Match:\n                self.BuildTimeStamp = datetime.utcfromtimestamp(int(Match.group(1)))\n        except IOError:\n            EdkLogger.warn(None, 'Fail to read report file', FwReportFileName)\n    if 'HASH' in ReportType:\n        OutputDir = os.path.join(self._BuildDir, 'OUTPUT')\n        DefaultEFIfile = os.path.join(OutputDir, self.ModuleName + '.efi')\n        if os.path.isfile(DefaultEFIfile):\n            Tempfile = os.path.join(OutputDir, self.ModuleName + '_hash.tmp')\n            cmd = ['GenFw', '--rebase', str(0), '-o', Tempfile, DefaultEFIfile]\n            try:\n                PopenObject = subprocess.Popen(' '.join(cmd), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n            except Exception as X:\n                EdkLogger.error('GenFw', COMMAND_FAILURE, ExtraData='%s: %s' % (str(X), cmd[0]))\n            EndOfProcedure = threading.Event()\n            EndOfProcedure.clear()\n            if PopenObject.stderr:\n                StdErrThread = threading.Thread(target=ReadMessage, args=(PopenObject.stderr, EdkLogger.quiet, EndOfProcedure))\n                StdErrThread.setName('STDERR-Redirector')\n                StdErrThread.setDaemon(False)\n                StdErrThread.start()\n            PopenObject.wait()\n            if PopenObject.stderr:\n                StdErrThread.join()\n            if PopenObject.returncode != 0:\n                EdkLogger.error('GenFw', COMMAND_FAILURE, 'Failed to generate firmware hash image for %s' % DefaultEFIfile)\n            if os.path.isfile(Tempfile):\n                self.Hash = hashlib.sha1()\n                buf = open(Tempfile, 'rb').read()\n                if self.Hash.update(buf):\n                    self.Hash = self.Hash.update(buf)\n                self.Hash = self.Hash.hexdigest()\n                os.remove(Tempfile)\n    FileWrite(File, 'Module Summary')\n    FileWrite(File, 'Module Name:          %s' % self.ModuleName)\n    FileWrite(File, 'Module Arch:          %s' % self.ModuleArch)\n    FileWrite(File, 'Module INF Path:      %s' % self.ModuleInfPath)\n    FileWrite(File, 'File GUID:            %s' % self.FileGuid)\n    if self.Size:\n        FileWrite(File, 'Size:                 0x%X (%.2fK)' % (self.Size, self.Size / 1024.0))\n    if self.Hash:\n        FileWrite(File, 'SHA1 HASH:            %s *%s' % (self.Hash, self.ModuleName + '.efi'))\n    if self.BuildTimeStamp:\n        FileWrite(File, 'Build Time Stamp:     %s' % self.BuildTimeStamp)\n    if self.BuildTime:\n        FileWrite(File, 'Module Build Time:    %s' % self.BuildTime)\n    if self.DriverType:\n        FileWrite(File, 'Driver Type:          %s' % self.DriverType)\n    if self.UefiSpecVersion:\n        FileWrite(File, 'UEFI Spec Version:    %s' % self.UefiSpecVersion)\n    if self.PiSpecVersion:\n        FileWrite(File, 'PI Spec Version:      %s' % self.PiSpecVersion)\n    if self.PciDeviceId:\n        FileWrite(File, 'PCI Device ID:        %s' % self.PciDeviceId)\n    if self.PciVendorId:\n        FileWrite(File, 'PCI Vendor ID:        %s' % self.PciVendorId)\n    if self.PciClassCode:\n        FileWrite(File, 'PCI Class Code:       %s' % self.PciClassCode)\n    FileWrite(File, gSectionSep)\n    if 'PCD' in ReportType:\n        GlobalPcdReport.GenerateReport(File, self.ModulePcdSet, self.FileGuid)\n    if 'LIBRARY' in ReportType:\n        self.LibraryReport.GenerateReport(File)\n    if 'DEPEX' in ReportType:\n        self.DepexReport.GenerateReport(File, GlobalDepexParser)\n    if 'BUILD_FLAGS' in ReportType:\n        self.BuildFlagsReport.GenerateReport(File)\n    if 'FIXED_ADDRESS' in ReportType and self.FileGuid:\n        GlobalPredictionReport.GenerateReport(File, self.FileGuid)\n    FileWrite(File, gSectionEnd)",
            "def GenerateReport(self, File, GlobalPcdReport, GlobalPredictionReport, GlobalDepexParser, ReportType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    FileWrite(File, gSectionStart)\n    FwReportFileName = os.path.join(self._BuildDir, 'OUTPUT', self.ModuleName + '.txt')\n    if os.path.isfile(FwReportFileName):\n        try:\n            FileContents = open(FwReportFileName).read()\n            Match = gModuleSizePattern.search(FileContents)\n            if Match:\n                self.Size = int(Match.group(1))\n            Match = gTimeStampPattern.search(FileContents)\n            if Match:\n                self.BuildTimeStamp = datetime.utcfromtimestamp(int(Match.group(1)))\n        except IOError:\n            EdkLogger.warn(None, 'Fail to read report file', FwReportFileName)\n    if 'HASH' in ReportType:\n        OutputDir = os.path.join(self._BuildDir, 'OUTPUT')\n        DefaultEFIfile = os.path.join(OutputDir, self.ModuleName + '.efi')\n        if os.path.isfile(DefaultEFIfile):\n            Tempfile = os.path.join(OutputDir, self.ModuleName + '_hash.tmp')\n            cmd = ['GenFw', '--rebase', str(0), '-o', Tempfile, DefaultEFIfile]\n            try:\n                PopenObject = subprocess.Popen(' '.join(cmd), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n            except Exception as X:\n                EdkLogger.error('GenFw', COMMAND_FAILURE, ExtraData='%s: %s' % (str(X), cmd[0]))\n            EndOfProcedure = threading.Event()\n            EndOfProcedure.clear()\n            if PopenObject.stderr:\n                StdErrThread = threading.Thread(target=ReadMessage, args=(PopenObject.stderr, EdkLogger.quiet, EndOfProcedure))\n                StdErrThread.setName('STDERR-Redirector')\n                StdErrThread.setDaemon(False)\n                StdErrThread.start()\n            PopenObject.wait()\n            if PopenObject.stderr:\n                StdErrThread.join()\n            if PopenObject.returncode != 0:\n                EdkLogger.error('GenFw', COMMAND_FAILURE, 'Failed to generate firmware hash image for %s' % DefaultEFIfile)\n            if os.path.isfile(Tempfile):\n                self.Hash = hashlib.sha1()\n                buf = open(Tempfile, 'rb').read()\n                if self.Hash.update(buf):\n                    self.Hash = self.Hash.update(buf)\n                self.Hash = self.Hash.hexdigest()\n                os.remove(Tempfile)\n    FileWrite(File, 'Module Summary')\n    FileWrite(File, 'Module Name:          %s' % self.ModuleName)\n    FileWrite(File, 'Module Arch:          %s' % self.ModuleArch)\n    FileWrite(File, 'Module INF Path:      %s' % self.ModuleInfPath)\n    FileWrite(File, 'File GUID:            %s' % self.FileGuid)\n    if self.Size:\n        FileWrite(File, 'Size:                 0x%X (%.2fK)' % (self.Size, self.Size / 1024.0))\n    if self.Hash:\n        FileWrite(File, 'SHA1 HASH:            %s *%s' % (self.Hash, self.ModuleName + '.efi'))\n    if self.BuildTimeStamp:\n        FileWrite(File, 'Build Time Stamp:     %s' % self.BuildTimeStamp)\n    if self.BuildTime:\n        FileWrite(File, 'Module Build Time:    %s' % self.BuildTime)\n    if self.DriverType:\n        FileWrite(File, 'Driver Type:          %s' % self.DriverType)\n    if self.UefiSpecVersion:\n        FileWrite(File, 'UEFI Spec Version:    %s' % self.UefiSpecVersion)\n    if self.PiSpecVersion:\n        FileWrite(File, 'PI Spec Version:      %s' % self.PiSpecVersion)\n    if self.PciDeviceId:\n        FileWrite(File, 'PCI Device ID:        %s' % self.PciDeviceId)\n    if self.PciVendorId:\n        FileWrite(File, 'PCI Vendor ID:        %s' % self.PciVendorId)\n    if self.PciClassCode:\n        FileWrite(File, 'PCI Class Code:       %s' % self.PciClassCode)\n    FileWrite(File, gSectionSep)\n    if 'PCD' in ReportType:\n        GlobalPcdReport.GenerateReport(File, self.ModulePcdSet, self.FileGuid)\n    if 'LIBRARY' in ReportType:\n        self.LibraryReport.GenerateReport(File)\n    if 'DEPEX' in ReportType:\n        self.DepexReport.GenerateReport(File, GlobalDepexParser)\n    if 'BUILD_FLAGS' in ReportType:\n        self.BuildFlagsReport.GenerateReport(File)\n    if 'FIXED_ADDRESS' in ReportType and self.FileGuid:\n        GlobalPredictionReport.GenerateReport(File, self.FileGuid)\n    FileWrite(File, gSectionEnd)"
        ]
    },
    {
        "func_name": "ReadMessage",
        "original": "def ReadMessage(From, To, ExitFlag):\n    while True:\n        Line = From.readline()\n        if Line is not None and Line != b'':\n            To(Line.rstrip().decode(encoding='utf-8', errors='ignore'))\n        else:\n            break\n        if ExitFlag.isSet():\n            break",
        "mutated": [
            "def ReadMessage(From, To, ExitFlag):\n    if False:\n        i = 10\n    while True:\n        Line = From.readline()\n        if Line is not None and Line != b'':\n            To(Line.rstrip().decode(encoding='utf-8', errors='ignore'))\n        else:\n            break\n        if ExitFlag.isSet():\n            break",
            "def ReadMessage(From, To, ExitFlag):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    while True:\n        Line = From.readline()\n        if Line is not None and Line != b'':\n            To(Line.rstrip().decode(encoding='utf-8', errors='ignore'))\n        else:\n            break\n        if ExitFlag.isSet():\n            break",
            "def ReadMessage(From, To, ExitFlag):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    while True:\n        Line = From.readline()\n        if Line is not None and Line != b'':\n            To(Line.rstrip().decode(encoding='utf-8', errors='ignore'))\n        else:\n            break\n        if ExitFlag.isSet():\n            break",
            "def ReadMessage(From, To, ExitFlag):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    while True:\n        Line = From.readline()\n        if Line is not None and Line != b'':\n            To(Line.rstrip().decode(encoding='utf-8', errors='ignore'))\n        else:\n            break\n        if ExitFlag.isSet():\n            break",
            "def ReadMessage(From, To, ExitFlag):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    while True:\n        Line = From.readline()\n        if Line is not None and Line != b'':\n            To(Line.rstrip().decode(encoding='utf-8', errors='ignore'))\n        else:\n            break\n        if ExitFlag.isSet():\n            break"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, Wa):\n    self.AllPcds = {}\n    self.UnusedPcds = {}\n    self.ConditionalPcds = {}\n    self.MaxLen = 0\n    self.Arch = None\n    if Wa.FdfProfile:\n        self.FdfPcdSet = Wa.FdfProfile.PcdDict\n    else:\n        self.FdfPcdSet = {}\n    self.DefaultStoreSingle = True\n    self.SkuSingle = True\n    if GlobalData.gDefaultStores and len(GlobalData.gDefaultStores) > 1:\n        self.DefaultStoreSingle = False\n    if GlobalData.gSkuids and len(GlobalData.gSkuids) > 1:\n        self.SkuSingle = False\n    self.ModulePcdOverride = {}\n    for Pa in Wa.AutoGenObjectList:\n        self.Arch = Pa.Arch\n        for Pcd in Pa.AllPcdList:\n            PcdList = self.AllPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n            if Pcd not in PcdList:\n                PcdList.append(Pcd)\n            if len(Pcd.TokenCName) > self.MaxLen:\n                self.MaxLen = len(Pcd.TokenCName)\n        UnusedPcdFullList = []\n        StructPcdDict = GlobalData.gStructurePcd.get(self.Arch, collections.OrderedDict())\n        for (Name, Guid) in StructPcdDict:\n            if (Name, Guid) not in Pa.Platform.Pcds:\n                Pcd = StructPcdDict[Name, Guid]\n                PcdList = self.AllPcds.setdefault(Guid, {}).setdefault(Pcd.Type, [])\n                if Pcd not in PcdList and Pcd not in UnusedPcdFullList:\n                    UnusedPcdFullList.append(Pcd)\n        for item in Pa.Platform.Pcds:\n            Pcd = Pa.Platform.Pcds[item]\n            if not Pcd.Type:\n                for T in PCD_TYPE_LIST:\n                    PcdList = self.AllPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(T, [])\n                    if Pcd in PcdList:\n                        Pcd.Type = T\n                        break\n            if not Pcd.Type:\n                PcdTypeFlag = False\n                for package in Pa.PackageList:\n                    for T in PCD_TYPE_LIST:\n                        if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName, T) in package.Pcds:\n                            Pcd.Type = T\n                            PcdTypeFlag = True\n                            if not Pcd.DatumType:\n                                Pcd.DatumType = package.Pcds[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, T].DatumType\n                            break\n                    if PcdTypeFlag:\n                        break\n            if not Pcd.DatumType:\n                PcdType = Pcd.Type\n                if PcdType.startswith(TAB_PCDS_DYNAMIC_EX):\n                    PcdType = TAB_PCDS_DYNAMIC_EX\n                elif PcdType.startswith(TAB_PCDS_DYNAMIC):\n                    PcdType = TAB_PCDS_DYNAMIC\n                for package in Pa.PackageList:\n                    if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName, PcdType) in package.Pcds:\n                        Pcd.DatumType = package.Pcds[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, PcdType].DatumType\n                        break\n            PcdList = self.AllPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n            UnusedPcdList = self.UnusedPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n            if Pcd in UnusedPcdList:\n                UnusedPcdList.remove(Pcd)\n            if Pcd not in PcdList and Pcd not in UnusedPcdFullList:\n                UnusedPcdFullList.append(Pcd)\n            if len(Pcd.TokenCName) > self.MaxLen:\n                self.MaxLen = len(Pcd.TokenCName)\n        if GlobalData.gConditionalPcds:\n            for PcdItem in GlobalData.gConditionalPcds:\n                if '.' in PcdItem:\n                    (TokenSpaceGuidCName, TokenCName) = PcdItem.split('.')\n                    if (TokenCName, TokenSpaceGuidCName) in Pa.Platform.Pcds:\n                        Pcd = Pa.Platform.Pcds[TokenCName, TokenSpaceGuidCName]\n                        PcdList = self.ConditionalPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n                        if Pcd not in PcdList:\n                            PcdList.append(Pcd)\n        UnusedPcdList = []\n        if UnusedPcdFullList:\n            for Pcd in UnusedPcdFullList:\n                if Pcd.TokenSpaceGuidCName + '.' + Pcd.TokenCName in GlobalData.gConditionalPcds:\n                    continue\n                UnusedPcdList.append(Pcd)\n        for Pcd in UnusedPcdList:\n            PcdList = self.UnusedPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n            if Pcd not in PcdList:\n                PcdList.append(Pcd)\n        for Module in Pa.Platform.Modules.values():\n            for ModulePcd in Module.M.ModulePcdList + Module.M.LibraryPcdList:\n                TokenCName = ModulePcd.TokenCName\n                TokenSpaceGuid = ModulePcd.TokenSpaceGuidCName\n                ModuleDefault = ModulePcd.DefaultValue\n                ModulePath = os.path.basename(Module.M.MetaFile.File)\n                self.ModulePcdOverride.setdefault((TokenCName, TokenSpaceGuid), {})[ModulePath] = ModuleDefault\n    self.DecPcdDefault = {}\n    self._GuidDict = {}\n    for Pa in Wa.AutoGenObjectList:\n        for Package in Pa.PackageList:\n            Guids = Package.Guids\n            self._GuidDict.update(Guids)\n            for (TokenCName, TokenSpaceGuidCName, DecType) in Package.Pcds:\n                DecDefaultValue = Package.Pcds[TokenCName, TokenSpaceGuidCName, DecType].DefaultValue\n                self.DecPcdDefault.setdefault((TokenCName, TokenSpaceGuidCName, DecType), DecDefaultValue)\n    self.DscPcdDefault = {}\n    for Pa in Wa.AutoGenObjectList:\n        for (TokenCName, TokenSpaceGuidCName) in Pa.Platform.Pcds:\n            DscDefaultValue = Pa.Platform.Pcds[TokenCName, TokenSpaceGuidCName].DscDefaultValue\n            if DscDefaultValue:\n                self.DscPcdDefault[TokenCName, TokenSpaceGuidCName] = DscDefaultValue",
        "mutated": [
            "def __init__(self, Wa):\n    if False:\n        i = 10\n    self.AllPcds = {}\n    self.UnusedPcds = {}\n    self.ConditionalPcds = {}\n    self.MaxLen = 0\n    self.Arch = None\n    if Wa.FdfProfile:\n        self.FdfPcdSet = Wa.FdfProfile.PcdDict\n    else:\n        self.FdfPcdSet = {}\n    self.DefaultStoreSingle = True\n    self.SkuSingle = True\n    if GlobalData.gDefaultStores and len(GlobalData.gDefaultStores) > 1:\n        self.DefaultStoreSingle = False\n    if GlobalData.gSkuids and len(GlobalData.gSkuids) > 1:\n        self.SkuSingle = False\n    self.ModulePcdOverride = {}\n    for Pa in Wa.AutoGenObjectList:\n        self.Arch = Pa.Arch\n        for Pcd in Pa.AllPcdList:\n            PcdList = self.AllPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n            if Pcd not in PcdList:\n                PcdList.append(Pcd)\n            if len(Pcd.TokenCName) > self.MaxLen:\n                self.MaxLen = len(Pcd.TokenCName)\n        UnusedPcdFullList = []\n        StructPcdDict = GlobalData.gStructurePcd.get(self.Arch, collections.OrderedDict())\n        for (Name, Guid) in StructPcdDict:\n            if (Name, Guid) not in Pa.Platform.Pcds:\n                Pcd = StructPcdDict[Name, Guid]\n                PcdList = self.AllPcds.setdefault(Guid, {}).setdefault(Pcd.Type, [])\n                if Pcd not in PcdList and Pcd not in UnusedPcdFullList:\n                    UnusedPcdFullList.append(Pcd)\n        for item in Pa.Platform.Pcds:\n            Pcd = Pa.Platform.Pcds[item]\n            if not Pcd.Type:\n                for T in PCD_TYPE_LIST:\n                    PcdList = self.AllPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(T, [])\n                    if Pcd in PcdList:\n                        Pcd.Type = T\n                        break\n            if not Pcd.Type:\n                PcdTypeFlag = False\n                for package in Pa.PackageList:\n                    for T in PCD_TYPE_LIST:\n                        if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName, T) in package.Pcds:\n                            Pcd.Type = T\n                            PcdTypeFlag = True\n                            if not Pcd.DatumType:\n                                Pcd.DatumType = package.Pcds[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, T].DatumType\n                            break\n                    if PcdTypeFlag:\n                        break\n            if not Pcd.DatumType:\n                PcdType = Pcd.Type\n                if PcdType.startswith(TAB_PCDS_DYNAMIC_EX):\n                    PcdType = TAB_PCDS_DYNAMIC_EX\n                elif PcdType.startswith(TAB_PCDS_DYNAMIC):\n                    PcdType = TAB_PCDS_DYNAMIC\n                for package in Pa.PackageList:\n                    if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName, PcdType) in package.Pcds:\n                        Pcd.DatumType = package.Pcds[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, PcdType].DatumType\n                        break\n            PcdList = self.AllPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n            UnusedPcdList = self.UnusedPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n            if Pcd in UnusedPcdList:\n                UnusedPcdList.remove(Pcd)\n            if Pcd not in PcdList and Pcd not in UnusedPcdFullList:\n                UnusedPcdFullList.append(Pcd)\n            if len(Pcd.TokenCName) > self.MaxLen:\n                self.MaxLen = len(Pcd.TokenCName)\n        if GlobalData.gConditionalPcds:\n            for PcdItem in GlobalData.gConditionalPcds:\n                if '.' in PcdItem:\n                    (TokenSpaceGuidCName, TokenCName) = PcdItem.split('.')\n                    if (TokenCName, TokenSpaceGuidCName) in Pa.Platform.Pcds:\n                        Pcd = Pa.Platform.Pcds[TokenCName, TokenSpaceGuidCName]\n                        PcdList = self.ConditionalPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n                        if Pcd not in PcdList:\n                            PcdList.append(Pcd)\n        UnusedPcdList = []\n        if UnusedPcdFullList:\n            for Pcd in UnusedPcdFullList:\n                if Pcd.TokenSpaceGuidCName + '.' + Pcd.TokenCName in GlobalData.gConditionalPcds:\n                    continue\n                UnusedPcdList.append(Pcd)\n        for Pcd in UnusedPcdList:\n            PcdList = self.UnusedPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n            if Pcd not in PcdList:\n                PcdList.append(Pcd)\n        for Module in Pa.Platform.Modules.values():\n            for ModulePcd in Module.M.ModulePcdList + Module.M.LibraryPcdList:\n                TokenCName = ModulePcd.TokenCName\n                TokenSpaceGuid = ModulePcd.TokenSpaceGuidCName\n                ModuleDefault = ModulePcd.DefaultValue\n                ModulePath = os.path.basename(Module.M.MetaFile.File)\n                self.ModulePcdOverride.setdefault((TokenCName, TokenSpaceGuid), {})[ModulePath] = ModuleDefault\n    self.DecPcdDefault = {}\n    self._GuidDict = {}\n    for Pa in Wa.AutoGenObjectList:\n        for Package in Pa.PackageList:\n            Guids = Package.Guids\n            self._GuidDict.update(Guids)\n            for (TokenCName, TokenSpaceGuidCName, DecType) in Package.Pcds:\n                DecDefaultValue = Package.Pcds[TokenCName, TokenSpaceGuidCName, DecType].DefaultValue\n                self.DecPcdDefault.setdefault((TokenCName, TokenSpaceGuidCName, DecType), DecDefaultValue)\n    self.DscPcdDefault = {}\n    for Pa in Wa.AutoGenObjectList:\n        for (TokenCName, TokenSpaceGuidCName) in Pa.Platform.Pcds:\n            DscDefaultValue = Pa.Platform.Pcds[TokenCName, TokenSpaceGuidCName].DscDefaultValue\n            if DscDefaultValue:\n                self.DscPcdDefault[TokenCName, TokenSpaceGuidCName] = DscDefaultValue",
            "def __init__(self, Wa):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.AllPcds = {}\n    self.UnusedPcds = {}\n    self.ConditionalPcds = {}\n    self.MaxLen = 0\n    self.Arch = None\n    if Wa.FdfProfile:\n        self.FdfPcdSet = Wa.FdfProfile.PcdDict\n    else:\n        self.FdfPcdSet = {}\n    self.DefaultStoreSingle = True\n    self.SkuSingle = True\n    if GlobalData.gDefaultStores and len(GlobalData.gDefaultStores) > 1:\n        self.DefaultStoreSingle = False\n    if GlobalData.gSkuids and len(GlobalData.gSkuids) > 1:\n        self.SkuSingle = False\n    self.ModulePcdOverride = {}\n    for Pa in Wa.AutoGenObjectList:\n        self.Arch = Pa.Arch\n        for Pcd in Pa.AllPcdList:\n            PcdList = self.AllPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n            if Pcd not in PcdList:\n                PcdList.append(Pcd)\n            if len(Pcd.TokenCName) > self.MaxLen:\n                self.MaxLen = len(Pcd.TokenCName)\n        UnusedPcdFullList = []\n        StructPcdDict = GlobalData.gStructurePcd.get(self.Arch, collections.OrderedDict())\n        for (Name, Guid) in StructPcdDict:\n            if (Name, Guid) not in Pa.Platform.Pcds:\n                Pcd = StructPcdDict[Name, Guid]\n                PcdList = self.AllPcds.setdefault(Guid, {}).setdefault(Pcd.Type, [])\n                if Pcd not in PcdList and Pcd not in UnusedPcdFullList:\n                    UnusedPcdFullList.append(Pcd)\n        for item in Pa.Platform.Pcds:\n            Pcd = Pa.Platform.Pcds[item]\n            if not Pcd.Type:\n                for T in PCD_TYPE_LIST:\n                    PcdList = self.AllPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(T, [])\n                    if Pcd in PcdList:\n                        Pcd.Type = T\n                        break\n            if not Pcd.Type:\n                PcdTypeFlag = False\n                for package in Pa.PackageList:\n                    for T in PCD_TYPE_LIST:\n                        if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName, T) in package.Pcds:\n                            Pcd.Type = T\n                            PcdTypeFlag = True\n                            if not Pcd.DatumType:\n                                Pcd.DatumType = package.Pcds[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, T].DatumType\n                            break\n                    if PcdTypeFlag:\n                        break\n            if not Pcd.DatumType:\n                PcdType = Pcd.Type\n                if PcdType.startswith(TAB_PCDS_DYNAMIC_EX):\n                    PcdType = TAB_PCDS_DYNAMIC_EX\n                elif PcdType.startswith(TAB_PCDS_DYNAMIC):\n                    PcdType = TAB_PCDS_DYNAMIC\n                for package in Pa.PackageList:\n                    if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName, PcdType) in package.Pcds:\n                        Pcd.DatumType = package.Pcds[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, PcdType].DatumType\n                        break\n            PcdList = self.AllPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n            UnusedPcdList = self.UnusedPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n            if Pcd in UnusedPcdList:\n                UnusedPcdList.remove(Pcd)\n            if Pcd not in PcdList and Pcd not in UnusedPcdFullList:\n                UnusedPcdFullList.append(Pcd)\n            if len(Pcd.TokenCName) > self.MaxLen:\n                self.MaxLen = len(Pcd.TokenCName)\n        if GlobalData.gConditionalPcds:\n            for PcdItem in GlobalData.gConditionalPcds:\n                if '.' in PcdItem:\n                    (TokenSpaceGuidCName, TokenCName) = PcdItem.split('.')\n                    if (TokenCName, TokenSpaceGuidCName) in Pa.Platform.Pcds:\n                        Pcd = Pa.Platform.Pcds[TokenCName, TokenSpaceGuidCName]\n                        PcdList = self.ConditionalPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n                        if Pcd not in PcdList:\n                            PcdList.append(Pcd)\n        UnusedPcdList = []\n        if UnusedPcdFullList:\n            for Pcd in UnusedPcdFullList:\n                if Pcd.TokenSpaceGuidCName + '.' + Pcd.TokenCName in GlobalData.gConditionalPcds:\n                    continue\n                UnusedPcdList.append(Pcd)\n        for Pcd in UnusedPcdList:\n            PcdList = self.UnusedPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n            if Pcd not in PcdList:\n                PcdList.append(Pcd)\n        for Module in Pa.Platform.Modules.values():\n            for ModulePcd in Module.M.ModulePcdList + Module.M.LibraryPcdList:\n                TokenCName = ModulePcd.TokenCName\n                TokenSpaceGuid = ModulePcd.TokenSpaceGuidCName\n                ModuleDefault = ModulePcd.DefaultValue\n                ModulePath = os.path.basename(Module.M.MetaFile.File)\n                self.ModulePcdOverride.setdefault((TokenCName, TokenSpaceGuid), {})[ModulePath] = ModuleDefault\n    self.DecPcdDefault = {}\n    self._GuidDict = {}\n    for Pa in Wa.AutoGenObjectList:\n        for Package in Pa.PackageList:\n            Guids = Package.Guids\n            self._GuidDict.update(Guids)\n            for (TokenCName, TokenSpaceGuidCName, DecType) in Package.Pcds:\n                DecDefaultValue = Package.Pcds[TokenCName, TokenSpaceGuidCName, DecType].DefaultValue\n                self.DecPcdDefault.setdefault((TokenCName, TokenSpaceGuidCName, DecType), DecDefaultValue)\n    self.DscPcdDefault = {}\n    for Pa in Wa.AutoGenObjectList:\n        for (TokenCName, TokenSpaceGuidCName) in Pa.Platform.Pcds:\n            DscDefaultValue = Pa.Platform.Pcds[TokenCName, TokenSpaceGuidCName].DscDefaultValue\n            if DscDefaultValue:\n                self.DscPcdDefault[TokenCName, TokenSpaceGuidCName] = DscDefaultValue",
            "def __init__(self, Wa):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.AllPcds = {}\n    self.UnusedPcds = {}\n    self.ConditionalPcds = {}\n    self.MaxLen = 0\n    self.Arch = None\n    if Wa.FdfProfile:\n        self.FdfPcdSet = Wa.FdfProfile.PcdDict\n    else:\n        self.FdfPcdSet = {}\n    self.DefaultStoreSingle = True\n    self.SkuSingle = True\n    if GlobalData.gDefaultStores and len(GlobalData.gDefaultStores) > 1:\n        self.DefaultStoreSingle = False\n    if GlobalData.gSkuids and len(GlobalData.gSkuids) > 1:\n        self.SkuSingle = False\n    self.ModulePcdOverride = {}\n    for Pa in Wa.AutoGenObjectList:\n        self.Arch = Pa.Arch\n        for Pcd in Pa.AllPcdList:\n            PcdList = self.AllPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n            if Pcd not in PcdList:\n                PcdList.append(Pcd)\n            if len(Pcd.TokenCName) > self.MaxLen:\n                self.MaxLen = len(Pcd.TokenCName)\n        UnusedPcdFullList = []\n        StructPcdDict = GlobalData.gStructurePcd.get(self.Arch, collections.OrderedDict())\n        for (Name, Guid) in StructPcdDict:\n            if (Name, Guid) not in Pa.Platform.Pcds:\n                Pcd = StructPcdDict[Name, Guid]\n                PcdList = self.AllPcds.setdefault(Guid, {}).setdefault(Pcd.Type, [])\n                if Pcd not in PcdList and Pcd not in UnusedPcdFullList:\n                    UnusedPcdFullList.append(Pcd)\n        for item in Pa.Platform.Pcds:\n            Pcd = Pa.Platform.Pcds[item]\n            if not Pcd.Type:\n                for T in PCD_TYPE_LIST:\n                    PcdList = self.AllPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(T, [])\n                    if Pcd in PcdList:\n                        Pcd.Type = T\n                        break\n            if not Pcd.Type:\n                PcdTypeFlag = False\n                for package in Pa.PackageList:\n                    for T in PCD_TYPE_LIST:\n                        if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName, T) in package.Pcds:\n                            Pcd.Type = T\n                            PcdTypeFlag = True\n                            if not Pcd.DatumType:\n                                Pcd.DatumType = package.Pcds[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, T].DatumType\n                            break\n                    if PcdTypeFlag:\n                        break\n            if not Pcd.DatumType:\n                PcdType = Pcd.Type\n                if PcdType.startswith(TAB_PCDS_DYNAMIC_EX):\n                    PcdType = TAB_PCDS_DYNAMIC_EX\n                elif PcdType.startswith(TAB_PCDS_DYNAMIC):\n                    PcdType = TAB_PCDS_DYNAMIC\n                for package in Pa.PackageList:\n                    if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName, PcdType) in package.Pcds:\n                        Pcd.DatumType = package.Pcds[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, PcdType].DatumType\n                        break\n            PcdList = self.AllPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n            UnusedPcdList = self.UnusedPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n            if Pcd in UnusedPcdList:\n                UnusedPcdList.remove(Pcd)\n            if Pcd not in PcdList and Pcd not in UnusedPcdFullList:\n                UnusedPcdFullList.append(Pcd)\n            if len(Pcd.TokenCName) > self.MaxLen:\n                self.MaxLen = len(Pcd.TokenCName)\n        if GlobalData.gConditionalPcds:\n            for PcdItem in GlobalData.gConditionalPcds:\n                if '.' in PcdItem:\n                    (TokenSpaceGuidCName, TokenCName) = PcdItem.split('.')\n                    if (TokenCName, TokenSpaceGuidCName) in Pa.Platform.Pcds:\n                        Pcd = Pa.Platform.Pcds[TokenCName, TokenSpaceGuidCName]\n                        PcdList = self.ConditionalPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n                        if Pcd not in PcdList:\n                            PcdList.append(Pcd)\n        UnusedPcdList = []\n        if UnusedPcdFullList:\n            for Pcd in UnusedPcdFullList:\n                if Pcd.TokenSpaceGuidCName + '.' + Pcd.TokenCName in GlobalData.gConditionalPcds:\n                    continue\n                UnusedPcdList.append(Pcd)\n        for Pcd in UnusedPcdList:\n            PcdList = self.UnusedPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n            if Pcd not in PcdList:\n                PcdList.append(Pcd)\n        for Module in Pa.Platform.Modules.values():\n            for ModulePcd in Module.M.ModulePcdList + Module.M.LibraryPcdList:\n                TokenCName = ModulePcd.TokenCName\n                TokenSpaceGuid = ModulePcd.TokenSpaceGuidCName\n                ModuleDefault = ModulePcd.DefaultValue\n                ModulePath = os.path.basename(Module.M.MetaFile.File)\n                self.ModulePcdOverride.setdefault((TokenCName, TokenSpaceGuid), {})[ModulePath] = ModuleDefault\n    self.DecPcdDefault = {}\n    self._GuidDict = {}\n    for Pa in Wa.AutoGenObjectList:\n        for Package in Pa.PackageList:\n            Guids = Package.Guids\n            self._GuidDict.update(Guids)\n            for (TokenCName, TokenSpaceGuidCName, DecType) in Package.Pcds:\n                DecDefaultValue = Package.Pcds[TokenCName, TokenSpaceGuidCName, DecType].DefaultValue\n                self.DecPcdDefault.setdefault((TokenCName, TokenSpaceGuidCName, DecType), DecDefaultValue)\n    self.DscPcdDefault = {}\n    for Pa in Wa.AutoGenObjectList:\n        for (TokenCName, TokenSpaceGuidCName) in Pa.Platform.Pcds:\n            DscDefaultValue = Pa.Platform.Pcds[TokenCName, TokenSpaceGuidCName].DscDefaultValue\n            if DscDefaultValue:\n                self.DscPcdDefault[TokenCName, TokenSpaceGuidCName] = DscDefaultValue",
            "def __init__(self, Wa):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.AllPcds = {}\n    self.UnusedPcds = {}\n    self.ConditionalPcds = {}\n    self.MaxLen = 0\n    self.Arch = None\n    if Wa.FdfProfile:\n        self.FdfPcdSet = Wa.FdfProfile.PcdDict\n    else:\n        self.FdfPcdSet = {}\n    self.DefaultStoreSingle = True\n    self.SkuSingle = True\n    if GlobalData.gDefaultStores and len(GlobalData.gDefaultStores) > 1:\n        self.DefaultStoreSingle = False\n    if GlobalData.gSkuids and len(GlobalData.gSkuids) > 1:\n        self.SkuSingle = False\n    self.ModulePcdOverride = {}\n    for Pa in Wa.AutoGenObjectList:\n        self.Arch = Pa.Arch\n        for Pcd in Pa.AllPcdList:\n            PcdList = self.AllPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n            if Pcd not in PcdList:\n                PcdList.append(Pcd)\n            if len(Pcd.TokenCName) > self.MaxLen:\n                self.MaxLen = len(Pcd.TokenCName)\n        UnusedPcdFullList = []\n        StructPcdDict = GlobalData.gStructurePcd.get(self.Arch, collections.OrderedDict())\n        for (Name, Guid) in StructPcdDict:\n            if (Name, Guid) not in Pa.Platform.Pcds:\n                Pcd = StructPcdDict[Name, Guid]\n                PcdList = self.AllPcds.setdefault(Guid, {}).setdefault(Pcd.Type, [])\n                if Pcd not in PcdList and Pcd not in UnusedPcdFullList:\n                    UnusedPcdFullList.append(Pcd)\n        for item in Pa.Platform.Pcds:\n            Pcd = Pa.Platform.Pcds[item]\n            if not Pcd.Type:\n                for T in PCD_TYPE_LIST:\n                    PcdList = self.AllPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(T, [])\n                    if Pcd in PcdList:\n                        Pcd.Type = T\n                        break\n            if not Pcd.Type:\n                PcdTypeFlag = False\n                for package in Pa.PackageList:\n                    for T in PCD_TYPE_LIST:\n                        if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName, T) in package.Pcds:\n                            Pcd.Type = T\n                            PcdTypeFlag = True\n                            if not Pcd.DatumType:\n                                Pcd.DatumType = package.Pcds[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, T].DatumType\n                            break\n                    if PcdTypeFlag:\n                        break\n            if not Pcd.DatumType:\n                PcdType = Pcd.Type\n                if PcdType.startswith(TAB_PCDS_DYNAMIC_EX):\n                    PcdType = TAB_PCDS_DYNAMIC_EX\n                elif PcdType.startswith(TAB_PCDS_DYNAMIC):\n                    PcdType = TAB_PCDS_DYNAMIC\n                for package in Pa.PackageList:\n                    if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName, PcdType) in package.Pcds:\n                        Pcd.DatumType = package.Pcds[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, PcdType].DatumType\n                        break\n            PcdList = self.AllPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n            UnusedPcdList = self.UnusedPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n            if Pcd in UnusedPcdList:\n                UnusedPcdList.remove(Pcd)\n            if Pcd not in PcdList and Pcd not in UnusedPcdFullList:\n                UnusedPcdFullList.append(Pcd)\n            if len(Pcd.TokenCName) > self.MaxLen:\n                self.MaxLen = len(Pcd.TokenCName)\n        if GlobalData.gConditionalPcds:\n            for PcdItem in GlobalData.gConditionalPcds:\n                if '.' in PcdItem:\n                    (TokenSpaceGuidCName, TokenCName) = PcdItem.split('.')\n                    if (TokenCName, TokenSpaceGuidCName) in Pa.Platform.Pcds:\n                        Pcd = Pa.Platform.Pcds[TokenCName, TokenSpaceGuidCName]\n                        PcdList = self.ConditionalPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n                        if Pcd not in PcdList:\n                            PcdList.append(Pcd)\n        UnusedPcdList = []\n        if UnusedPcdFullList:\n            for Pcd in UnusedPcdFullList:\n                if Pcd.TokenSpaceGuidCName + '.' + Pcd.TokenCName in GlobalData.gConditionalPcds:\n                    continue\n                UnusedPcdList.append(Pcd)\n        for Pcd in UnusedPcdList:\n            PcdList = self.UnusedPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n            if Pcd not in PcdList:\n                PcdList.append(Pcd)\n        for Module in Pa.Platform.Modules.values():\n            for ModulePcd in Module.M.ModulePcdList + Module.M.LibraryPcdList:\n                TokenCName = ModulePcd.TokenCName\n                TokenSpaceGuid = ModulePcd.TokenSpaceGuidCName\n                ModuleDefault = ModulePcd.DefaultValue\n                ModulePath = os.path.basename(Module.M.MetaFile.File)\n                self.ModulePcdOverride.setdefault((TokenCName, TokenSpaceGuid), {})[ModulePath] = ModuleDefault\n    self.DecPcdDefault = {}\n    self._GuidDict = {}\n    for Pa in Wa.AutoGenObjectList:\n        for Package in Pa.PackageList:\n            Guids = Package.Guids\n            self._GuidDict.update(Guids)\n            for (TokenCName, TokenSpaceGuidCName, DecType) in Package.Pcds:\n                DecDefaultValue = Package.Pcds[TokenCName, TokenSpaceGuidCName, DecType].DefaultValue\n                self.DecPcdDefault.setdefault((TokenCName, TokenSpaceGuidCName, DecType), DecDefaultValue)\n    self.DscPcdDefault = {}\n    for Pa in Wa.AutoGenObjectList:\n        for (TokenCName, TokenSpaceGuidCName) in Pa.Platform.Pcds:\n            DscDefaultValue = Pa.Platform.Pcds[TokenCName, TokenSpaceGuidCName].DscDefaultValue\n            if DscDefaultValue:\n                self.DscPcdDefault[TokenCName, TokenSpaceGuidCName] = DscDefaultValue",
            "def __init__(self, Wa):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.AllPcds = {}\n    self.UnusedPcds = {}\n    self.ConditionalPcds = {}\n    self.MaxLen = 0\n    self.Arch = None\n    if Wa.FdfProfile:\n        self.FdfPcdSet = Wa.FdfProfile.PcdDict\n    else:\n        self.FdfPcdSet = {}\n    self.DefaultStoreSingle = True\n    self.SkuSingle = True\n    if GlobalData.gDefaultStores and len(GlobalData.gDefaultStores) > 1:\n        self.DefaultStoreSingle = False\n    if GlobalData.gSkuids and len(GlobalData.gSkuids) > 1:\n        self.SkuSingle = False\n    self.ModulePcdOverride = {}\n    for Pa in Wa.AutoGenObjectList:\n        self.Arch = Pa.Arch\n        for Pcd in Pa.AllPcdList:\n            PcdList = self.AllPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n            if Pcd not in PcdList:\n                PcdList.append(Pcd)\n            if len(Pcd.TokenCName) > self.MaxLen:\n                self.MaxLen = len(Pcd.TokenCName)\n        UnusedPcdFullList = []\n        StructPcdDict = GlobalData.gStructurePcd.get(self.Arch, collections.OrderedDict())\n        for (Name, Guid) in StructPcdDict:\n            if (Name, Guid) not in Pa.Platform.Pcds:\n                Pcd = StructPcdDict[Name, Guid]\n                PcdList = self.AllPcds.setdefault(Guid, {}).setdefault(Pcd.Type, [])\n                if Pcd not in PcdList and Pcd not in UnusedPcdFullList:\n                    UnusedPcdFullList.append(Pcd)\n        for item in Pa.Platform.Pcds:\n            Pcd = Pa.Platform.Pcds[item]\n            if not Pcd.Type:\n                for T in PCD_TYPE_LIST:\n                    PcdList = self.AllPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(T, [])\n                    if Pcd in PcdList:\n                        Pcd.Type = T\n                        break\n            if not Pcd.Type:\n                PcdTypeFlag = False\n                for package in Pa.PackageList:\n                    for T in PCD_TYPE_LIST:\n                        if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName, T) in package.Pcds:\n                            Pcd.Type = T\n                            PcdTypeFlag = True\n                            if not Pcd.DatumType:\n                                Pcd.DatumType = package.Pcds[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, T].DatumType\n                            break\n                    if PcdTypeFlag:\n                        break\n            if not Pcd.DatumType:\n                PcdType = Pcd.Type\n                if PcdType.startswith(TAB_PCDS_DYNAMIC_EX):\n                    PcdType = TAB_PCDS_DYNAMIC_EX\n                elif PcdType.startswith(TAB_PCDS_DYNAMIC):\n                    PcdType = TAB_PCDS_DYNAMIC\n                for package in Pa.PackageList:\n                    if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName, PcdType) in package.Pcds:\n                        Pcd.DatumType = package.Pcds[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, PcdType].DatumType\n                        break\n            PcdList = self.AllPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n            UnusedPcdList = self.UnusedPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n            if Pcd in UnusedPcdList:\n                UnusedPcdList.remove(Pcd)\n            if Pcd not in PcdList and Pcd not in UnusedPcdFullList:\n                UnusedPcdFullList.append(Pcd)\n            if len(Pcd.TokenCName) > self.MaxLen:\n                self.MaxLen = len(Pcd.TokenCName)\n        if GlobalData.gConditionalPcds:\n            for PcdItem in GlobalData.gConditionalPcds:\n                if '.' in PcdItem:\n                    (TokenSpaceGuidCName, TokenCName) = PcdItem.split('.')\n                    if (TokenCName, TokenSpaceGuidCName) in Pa.Platform.Pcds:\n                        Pcd = Pa.Platform.Pcds[TokenCName, TokenSpaceGuidCName]\n                        PcdList = self.ConditionalPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n                        if Pcd not in PcdList:\n                            PcdList.append(Pcd)\n        UnusedPcdList = []\n        if UnusedPcdFullList:\n            for Pcd in UnusedPcdFullList:\n                if Pcd.TokenSpaceGuidCName + '.' + Pcd.TokenCName in GlobalData.gConditionalPcds:\n                    continue\n                UnusedPcdList.append(Pcd)\n        for Pcd in UnusedPcdList:\n            PcdList = self.UnusedPcds.setdefault(Pcd.TokenSpaceGuidCName, {}).setdefault(Pcd.Type, [])\n            if Pcd not in PcdList:\n                PcdList.append(Pcd)\n        for Module in Pa.Platform.Modules.values():\n            for ModulePcd in Module.M.ModulePcdList + Module.M.LibraryPcdList:\n                TokenCName = ModulePcd.TokenCName\n                TokenSpaceGuid = ModulePcd.TokenSpaceGuidCName\n                ModuleDefault = ModulePcd.DefaultValue\n                ModulePath = os.path.basename(Module.M.MetaFile.File)\n                self.ModulePcdOverride.setdefault((TokenCName, TokenSpaceGuid), {})[ModulePath] = ModuleDefault\n    self.DecPcdDefault = {}\n    self._GuidDict = {}\n    for Pa in Wa.AutoGenObjectList:\n        for Package in Pa.PackageList:\n            Guids = Package.Guids\n            self._GuidDict.update(Guids)\n            for (TokenCName, TokenSpaceGuidCName, DecType) in Package.Pcds:\n                DecDefaultValue = Package.Pcds[TokenCName, TokenSpaceGuidCName, DecType].DefaultValue\n                self.DecPcdDefault.setdefault((TokenCName, TokenSpaceGuidCName, DecType), DecDefaultValue)\n    self.DscPcdDefault = {}\n    for Pa in Wa.AutoGenObjectList:\n        for (TokenCName, TokenSpaceGuidCName) in Pa.Platform.Pcds:\n            DscDefaultValue = Pa.Platform.Pcds[TokenCName, TokenSpaceGuidCName].DscDefaultValue\n            if DscDefaultValue:\n                self.DscPcdDefault[TokenCName, TokenSpaceGuidCName] = DscDefaultValue"
        ]
    },
    {
        "func_name": "GenerateReport",
        "original": "def GenerateReport(self, File, ModulePcdSet, ModuleGuid=None):\n    if not ModulePcdSet:\n        if self.ConditionalPcds:\n            self.GenerateReportDetail(File, ModulePcdSet, 1)\n        if self.UnusedPcds:\n            IsEmpty = True\n            for Token in self.UnusedPcds:\n                TokenDict = self.UnusedPcds[Token]\n                for Type in TokenDict:\n                    if TokenDict[Type]:\n                        IsEmpty = False\n                        break\n                if not IsEmpty:\n                    break\n            if not IsEmpty:\n                self.GenerateReportDetail(File, ModulePcdSet, 2)\n    self.GenerateReportDetail(File, ModulePcdSet, ModuleGuid=ModuleGuid)",
        "mutated": [
            "def GenerateReport(self, File, ModulePcdSet, ModuleGuid=None):\n    if False:\n        i = 10\n    if not ModulePcdSet:\n        if self.ConditionalPcds:\n            self.GenerateReportDetail(File, ModulePcdSet, 1)\n        if self.UnusedPcds:\n            IsEmpty = True\n            for Token in self.UnusedPcds:\n                TokenDict = self.UnusedPcds[Token]\n                for Type in TokenDict:\n                    if TokenDict[Type]:\n                        IsEmpty = False\n                        break\n                if not IsEmpty:\n                    break\n            if not IsEmpty:\n                self.GenerateReportDetail(File, ModulePcdSet, 2)\n    self.GenerateReportDetail(File, ModulePcdSet, ModuleGuid=ModuleGuid)",
            "def GenerateReport(self, File, ModulePcdSet, ModuleGuid=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not ModulePcdSet:\n        if self.ConditionalPcds:\n            self.GenerateReportDetail(File, ModulePcdSet, 1)\n        if self.UnusedPcds:\n            IsEmpty = True\n            for Token in self.UnusedPcds:\n                TokenDict = self.UnusedPcds[Token]\n                for Type in TokenDict:\n                    if TokenDict[Type]:\n                        IsEmpty = False\n                        break\n                if not IsEmpty:\n                    break\n            if not IsEmpty:\n                self.GenerateReportDetail(File, ModulePcdSet, 2)\n    self.GenerateReportDetail(File, ModulePcdSet, ModuleGuid=ModuleGuid)",
            "def GenerateReport(self, File, ModulePcdSet, ModuleGuid=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not ModulePcdSet:\n        if self.ConditionalPcds:\n            self.GenerateReportDetail(File, ModulePcdSet, 1)\n        if self.UnusedPcds:\n            IsEmpty = True\n            for Token in self.UnusedPcds:\n                TokenDict = self.UnusedPcds[Token]\n                for Type in TokenDict:\n                    if TokenDict[Type]:\n                        IsEmpty = False\n                        break\n                if not IsEmpty:\n                    break\n            if not IsEmpty:\n                self.GenerateReportDetail(File, ModulePcdSet, 2)\n    self.GenerateReportDetail(File, ModulePcdSet, ModuleGuid=ModuleGuid)",
            "def GenerateReport(self, File, ModulePcdSet, ModuleGuid=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not ModulePcdSet:\n        if self.ConditionalPcds:\n            self.GenerateReportDetail(File, ModulePcdSet, 1)\n        if self.UnusedPcds:\n            IsEmpty = True\n            for Token in self.UnusedPcds:\n                TokenDict = self.UnusedPcds[Token]\n                for Type in TokenDict:\n                    if TokenDict[Type]:\n                        IsEmpty = False\n                        break\n                if not IsEmpty:\n                    break\n            if not IsEmpty:\n                self.GenerateReportDetail(File, ModulePcdSet, 2)\n    self.GenerateReportDetail(File, ModulePcdSet, ModuleGuid=ModuleGuid)",
            "def GenerateReport(self, File, ModulePcdSet, ModuleGuid=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not ModulePcdSet:\n        if self.ConditionalPcds:\n            self.GenerateReportDetail(File, ModulePcdSet, 1)\n        if self.UnusedPcds:\n            IsEmpty = True\n            for Token in self.UnusedPcds:\n                TokenDict = self.UnusedPcds[Token]\n                for Type in TokenDict:\n                    if TokenDict[Type]:\n                        IsEmpty = False\n                        break\n                if not IsEmpty:\n                    break\n            if not IsEmpty:\n                self.GenerateReportDetail(File, ModulePcdSet, 2)\n    self.GenerateReportDetail(File, ModulePcdSet, ModuleGuid=ModuleGuid)"
        ]
    },
    {
        "func_name": "GenerateReportDetail",
        "original": "def GenerateReportDetail(self, File, ModulePcdSet, ReportSubType=0, ModuleGuid=None):\n    PcdDict = self.AllPcds\n    if ReportSubType == 1:\n        PcdDict = self.ConditionalPcds\n    elif ReportSubType == 2:\n        PcdDict = self.UnusedPcds\n    if not ModulePcdSet:\n        FileWrite(File, gSectionStart)\n        if ReportSubType == 1:\n            FileWrite(File, 'Conditional Directives used by the build system')\n        elif ReportSubType == 2:\n            FileWrite(File, 'PCDs not used by modules or in conditional directives')\n        else:\n            FileWrite(File, 'Platform Configuration Database Report')\n        FileWrite(File, '  *B  - PCD override in the build option')\n        FileWrite(File, '  *P  - Platform scoped PCD override in DSC file')\n        FileWrite(File, '  *F  - Platform scoped PCD override in FDF file')\n        if not ReportSubType:\n            FileWrite(File, '  *M  - Module scoped PCD override')\n        FileWrite(File, gSectionSep)\n    elif not ReportSubType and ModulePcdSet:\n        FileWrite(File, gSubSectionStart)\n        FileWrite(File, TAB_BRG_PCD)\n        FileWrite(File, gSubSectionSep)\n    AllPcdDict = {}\n    for Key in PcdDict:\n        AllPcdDict[Key] = {}\n        for Type in PcdDict[Key]:\n            for Pcd in PcdDict[Key][Type]:\n                AllPcdDict[Key][Pcd.TokenCName, Type] = Pcd\n    for Key in sorted(AllPcdDict):\n        First = True\n        for (PcdTokenCName, Type) in sorted(AllPcdDict[Key]):\n            Pcd = AllPcdDict[Key][PcdTokenCName, Type]\n            (TypeName, DecType) = gPcdTypeMap.get(Type, ('', Type))\n            MixedPcdFlag = False\n            if GlobalData.MixedPcd:\n                for PcdKey in GlobalData.MixedPcd:\n                    if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdKey]:\n                        PcdTokenCName = PcdKey[0]\n                        MixedPcdFlag = True\n                if MixedPcdFlag and (not ModulePcdSet):\n                    continue\n            DecDefaultValue = self.DecPcdDefault.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName, DecType))\n            DscDefaultValue = self.DscPcdDefault.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName))\n            DscDefaultValBak = DscDefaultValue\n            Field = ''\n            for (CName, Guid, Field) in self.FdfPcdSet:\n                if CName == PcdTokenCName and Guid == Key:\n                    DscDefaultValue = self.FdfPcdSet[CName, Guid, Field]\n                    break\n            if DscDefaultValue != DscDefaultValBak:\n                try:\n                    DscDefaultValue = ValueExpressionEx(DscDefaultValue, Pcd.DatumType, self._GuidDict)(True)\n                except BadExpression as DscDefaultValue:\n                    EdkLogger.error('BuildReport', FORMAT_INVALID, 'PCD Value: %s, Type: %s' % (DscDefaultValue, Pcd.DatumType))\n            InfDefaultValue = None\n            PcdValue = DecDefaultValue\n            if DscDefaultValue:\n                PcdValue = DscDefaultValue\n            if not self.IsStructurePcd(Pcd.TokenCName, Pcd.TokenSpaceGuidCName):\n                Pcd.DefaultValue = PcdValue\n            PcdComponentValue = None\n            if ModulePcdSet is not None:\n                if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Type) not in ModulePcdSet:\n                    continue\n                (InfDefaultValue, PcdComponentValue) = ModulePcdSet[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Type]\n                PcdValue = PcdComponentValue\n                if not self.IsStructurePcd(Pcd.TokenCName, Pcd.TokenSpaceGuidCName):\n                    Pcd.DefaultValue = PcdValue\n                if InfDefaultValue:\n                    try:\n                        InfDefaultValue = ValueExpressionEx(InfDefaultValue, Pcd.DatumType, self._GuidDict)(True)\n                    except BadExpression as InfDefaultValue:\n                        EdkLogger.error('BuildReport', FORMAT_INVALID, 'PCD Value: %s, Type: %s' % (InfDefaultValue, Pcd.DatumType))\n                if InfDefaultValue == '':\n                    InfDefaultValue = None\n            BuildOptionMatch = False\n            if GlobalData.BuildOptionPcd:\n                for pcd in GlobalData.BuildOptionPcd:\n                    if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) == (pcd[0], pcd[1]):\n                        if pcd[2]:\n                            continue\n                        PcdValue = pcd[3]\n                        if not self.IsStructurePcd(Pcd.TokenCName, Pcd.TokenSpaceGuidCName):\n                            Pcd.DefaultValue = PcdValue\n                        BuildOptionMatch = True\n                        break\n            if First:\n                if ModulePcdSet is None:\n                    FileWrite(File, '')\n                FileWrite(File, Key)\n                First = False\n            if Pcd.DatumType in TAB_PCD_NUMERIC_TYPES:\n                if PcdValue.startswith('0') and (not PcdValue.lower().startswith('0x')) and (len(PcdValue) > 1) and PcdValue.lstrip('0'):\n                    PcdValue = PcdValue.lstrip('0')\n                PcdValueNumber = int(PcdValue.strip(), 0)\n                if DecDefaultValue is None:\n                    DecMatch = True\n                else:\n                    if DecDefaultValue.startswith('0') and (not DecDefaultValue.lower().startswith('0x')) and (len(DecDefaultValue) > 1) and DecDefaultValue.lstrip('0'):\n                        DecDefaultValue = DecDefaultValue.lstrip('0')\n                    DecDefaultValueNumber = int(DecDefaultValue.strip(), 0)\n                    DecMatch = DecDefaultValueNumber == PcdValueNumber\n                if InfDefaultValue is None:\n                    InfMatch = True\n                else:\n                    if InfDefaultValue.startswith('0') and (not InfDefaultValue.lower().startswith('0x')) and (len(InfDefaultValue) > 1) and InfDefaultValue.lstrip('0'):\n                        InfDefaultValue = InfDefaultValue.lstrip('0')\n                    InfDefaultValueNumber = int(InfDefaultValue.strip(), 0)\n                    InfMatch = InfDefaultValueNumber == PcdValueNumber\n                if DscDefaultValue is None:\n                    DscMatch = True\n                else:\n                    if DscDefaultValue.startswith('0') and (not DscDefaultValue.lower().startswith('0x')) and (len(DscDefaultValue) > 1) and DscDefaultValue.lstrip('0'):\n                        DscDefaultValue = DscDefaultValue.lstrip('0')\n                    DscDefaultValueNumber = int(DscDefaultValue.strip(), 0)\n                    DscMatch = DscDefaultValueNumber == PcdValueNumber\n            else:\n                if DecDefaultValue is None:\n                    DecMatch = True\n                else:\n                    DecMatch = DecDefaultValue.strip() == PcdValue.strip()\n                if InfDefaultValue is None:\n                    InfMatch = True\n                else:\n                    InfMatch = InfDefaultValue.strip() == PcdValue.strip()\n                if DscDefaultValue is None:\n                    DscMatch = True\n                else:\n                    DscMatch = DscDefaultValue.strip() == PcdValue.strip()\n            IsStructure = False\n            if self.IsStructurePcd(Pcd.TokenCName, Pcd.TokenSpaceGuidCName):\n                IsStructure = True\n                if TypeName in ('DYNVPD', 'DEXVPD'):\n                    SkuInfoList = Pcd.SkuInfoList\n                Pcd = GlobalData.gStructurePcd[self.Arch][Pcd.TokenCName, Pcd.TokenSpaceGuidCName]\n                if ModulePcdSet and ModulePcdSet.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Type)):\n                    (InfDefaultValue, PcdComponentValue) = ModulePcdSet[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Type]\n                    DscDefaultValBak = Pcd.DefaultValue\n                    Pcd.DefaultValue = PcdComponentValue\n                Pcd.DatumType = Pcd.StructName\n                if TypeName in ('DYNVPD', 'DEXVPD'):\n                    Pcd.SkuInfoList = SkuInfoList\n                if Pcd.PcdValueFromComm or Pcd.PcdFieldValueFromComm:\n                    BuildOptionMatch = True\n                    DecMatch = False\n                elif Pcd.PcdValueFromFdf or Pcd.PcdFieldValueFromFdf:\n                    DscDefaultValue = True\n                    DscMatch = True\n                    DecMatch = False\n                elif Pcd.Type in PCD_DYNAMIC_TYPE_SET | PCD_DYNAMIC_EX_TYPE_SET:\n                    DscOverride = False\n                    if Pcd.DefaultFromDSC:\n                        DscOverride = True\n                    else:\n                        DictLen = 0\n                        for item in Pcd.SkuOverrideValues:\n                            DictLen += len(Pcd.SkuOverrideValues[item])\n                        if not DictLen:\n                            DscOverride = False\n                        elif not Pcd.SkuInfoList:\n                            OverrideValues = Pcd.SkuOverrideValues\n                            if OverrideValues:\n                                for Data in OverrideValues.values():\n                                    Struct = list(Data.values())\n                                    if Struct:\n                                        DscOverride = self.ParseStruct(Struct[0])\n                                        break\n                        else:\n                            SkuList = sorted(Pcd.SkuInfoList.keys())\n                            for Sku in SkuList:\n                                SkuInfo = Pcd.SkuInfoList[Sku]\n                                if SkuInfo.DefaultStoreDict:\n                                    DefaultStoreList = sorted(SkuInfo.DefaultStoreDict.keys())\n                                    for DefaultStore in DefaultStoreList:\n                                        OverrideValues = Pcd.SkuOverrideValues.get(Sku)\n                                        if OverrideValues:\n                                            DscOverride = self.ParseStruct(OverrideValues[DefaultStore])\n                                            if DscOverride:\n                                                break\n                                if DscOverride:\n                                    break\n                    if DscOverride:\n                        DscDefaultValue = True\n                        DscMatch = True\n                        DecMatch = False\n                    else:\n                        DecMatch = True\n                elif Pcd.DscRawValue or (ModuleGuid and ModuleGuid.replace('-', 'S') in Pcd.PcdValueFromComponents):\n                    DscDefaultValue = True\n                    DscMatch = True\n                    DecMatch = False\n                else:\n                    DscDefaultValue = False\n                    DecMatch = True\n            if Pcd.DatumType == 'BOOLEAN':\n                if DscDefaultValue:\n                    DscDefaultValue = str(int(DscDefaultValue, 0))\n                if DecDefaultValue:\n                    DecDefaultValue = str(int(DecDefaultValue, 0))\n                if InfDefaultValue:\n                    InfDefaultValue = str(int(InfDefaultValue, 0))\n                if Pcd.DefaultValue:\n                    Pcd.DefaultValue = str(int(Pcd.DefaultValue, 0))\n            if DecMatch:\n                self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '  ')\n            elif InfDefaultValue and InfMatch:\n                self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '*M')\n            elif BuildOptionMatch:\n                self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '*B')\n            elif PcdComponentValue:\n                self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, PcdComponentValue, DecMatch, DecDefaultValue, '*M', ModuleGuid)\n            elif DscDefaultValue and DscMatch:\n                if (Pcd.TokenCName, Key, Field) in self.FdfPcdSet:\n                    self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '*F')\n                else:\n                    self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '*P')\n            if ModulePcdSet is None:\n                if IsStructure:\n                    continue\n                if not TypeName in ('PATCH', 'FLAG', 'FIXED'):\n                    continue\n                if not BuildOptionMatch:\n                    ModuleOverride = self.ModulePcdOverride.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName), {})\n                    for ModulePath in ModuleOverride:\n                        ModuleDefault = ModuleOverride[ModulePath]\n                        if Pcd.DatumType in TAB_PCD_NUMERIC_TYPES:\n                            if ModuleDefault.startswith('0') and (not ModuleDefault.lower().startswith('0x')) and (len(ModuleDefault) > 1) and ModuleDefault.lstrip('0'):\n                                ModuleDefault = ModuleDefault.lstrip('0')\n                            ModulePcdDefaultValueNumber = int(ModuleDefault.strip(), 0)\n                            Match = ModulePcdDefaultValueNumber == PcdValueNumber\n                            if Pcd.DatumType == 'BOOLEAN':\n                                ModuleDefault = str(ModulePcdDefaultValueNumber)\n                        else:\n                            Match = ModuleDefault.strip() == PcdValue.strip()\n                        if Match:\n                            continue\n                        (IsByteArray, ArrayList) = ByteArrayForamt(ModuleDefault.strip())\n                        if IsByteArray:\n                            FileWrite(File, ' *M     %-*s = %s' % (self.MaxLen + 15, ModulePath, '{'))\n                            for Array in ArrayList:\n                                FileWrite(File, Array)\n                        else:\n                            Value = ModuleDefault.strip()\n                            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                                if Value.startswith(('0x', '0X')):\n                                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                                else:\n                                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                            FileWrite(File, ' *M     %-*s = %s' % (self.MaxLen + 15, ModulePath, Value))\n    if ModulePcdSet is None:\n        FileWrite(File, gSectionEnd)\n    elif not ReportSubType and ModulePcdSet:\n        FileWrite(File, gSubSectionEnd)",
        "mutated": [
            "def GenerateReportDetail(self, File, ModulePcdSet, ReportSubType=0, ModuleGuid=None):\n    if False:\n        i = 10\n    PcdDict = self.AllPcds\n    if ReportSubType == 1:\n        PcdDict = self.ConditionalPcds\n    elif ReportSubType == 2:\n        PcdDict = self.UnusedPcds\n    if not ModulePcdSet:\n        FileWrite(File, gSectionStart)\n        if ReportSubType == 1:\n            FileWrite(File, 'Conditional Directives used by the build system')\n        elif ReportSubType == 2:\n            FileWrite(File, 'PCDs not used by modules or in conditional directives')\n        else:\n            FileWrite(File, 'Platform Configuration Database Report')\n        FileWrite(File, '  *B  - PCD override in the build option')\n        FileWrite(File, '  *P  - Platform scoped PCD override in DSC file')\n        FileWrite(File, '  *F  - Platform scoped PCD override in FDF file')\n        if not ReportSubType:\n            FileWrite(File, '  *M  - Module scoped PCD override')\n        FileWrite(File, gSectionSep)\n    elif not ReportSubType and ModulePcdSet:\n        FileWrite(File, gSubSectionStart)\n        FileWrite(File, TAB_BRG_PCD)\n        FileWrite(File, gSubSectionSep)\n    AllPcdDict = {}\n    for Key in PcdDict:\n        AllPcdDict[Key] = {}\n        for Type in PcdDict[Key]:\n            for Pcd in PcdDict[Key][Type]:\n                AllPcdDict[Key][Pcd.TokenCName, Type] = Pcd\n    for Key in sorted(AllPcdDict):\n        First = True\n        for (PcdTokenCName, Type) in sorted(AllPcdDict[Key]):\n            Pcd = AllPcdDict[Key][PcdTokenCName, Type]\n            (TypeName, DecType) = gPcdTypeMap.get(Type, ('', Type))\n            MixedPcdFlag = False\n            if GlobalData.MixedPcd:\n                for PcdKey in GlobalData.MixedPcd:\n                    if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdKey]:\n                        PcdTokenCName = PcdKey[0]\n                        MixedPcdFlag = True\n                if MixedPcdFlag and (not ModulePcdSet):\n                    continue\n            DecDefaultValue = self.DecPcdDefault.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName, DecType))\n            DscDefaultValue = self.DscPcdDefault.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName))\n            DscDefaultValBak = DscDefaultValue\n            Field = ''\n            for (CName, Guid, Field) in self.FdfPcdSet:\n                if CName == PcdTokenCName and Guid == Key:\n                    DscDefaultValue = self.FdfPcdSet[CName, Guid, Field]\n                    break\n            if DscDefaultValue != DscDefaultValBak:\n                try:\n                    DscDefaultValue = ValueExpressionEx(DscDefaultValue, Pcd.DatumType, self._GuidDict)(True)\n                except BadExpression as DscDefaultValue:\n                    EdkLogger.error('BuildReport', FORMAT_INVALID, 'PCD Value: %s, Type: %s' % (DscDefaultValue, Pcd.DatumType))\n            InfDefaultValue = None\n            PcdValue = DecDefaultValue\n            if DscDefaultValue:\n                PcdValue = DscDefaultValue\n            if not self.IsStructurePcd(Pcd.TokenCName, Pcd.TokenSpaceGuidCName):\n                Pcd.DefaultValue = PcdValue\n            PcdComponentValue = None\n            if ModulePcdSet is not None:\n                if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Type) not in ModulePcdSet:\n                    continue\n                (InfDefaultValue, PcdComponentValue) = ModulePcdSet[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Type]\n                PcdValue = PcdComponentValue\n                if not self.IsStructurePcd(Pcd.TokenCName, Pcd.TokenSpaceGuidCName):\n                    Pcd.DefaultValue = PcdValue\n                if InfDefaultValue:\n                    try:\n                        InfDefaultValue = ValueExpressionEx(InfDefaultValue, Pcd.DatumType, self._GuidDict)(True)\n                    except BadExpression as InfDefaultValue:\n                        EdkLogger.error('BuildReport', FORMAT_INVALID, 'PCD Value: %s, Type: %s' % (InfDefaultValue, Pcd.DatumType))\n                if InfDefaultValue == '':\n                    InfDefaultValue = None\n            BuildOptionMatch = False\n            if GlobalData.BuildOptionPcd:\n                for pcd in GlobalData.BuildOptionPcd:\n                    if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) == (pcd[0], pcd[1]):\n                        if pcd[2]:\n                            continue\n                        PcdValue = pcd[3]\n                        if not self.IsStructurePcd(Pcd.TokenCName, Pcd.TokenSpaceGuidCName):\n                            Pcd.DefaultValue = PcdValue\n                        BuildOptionMatch = True\n                        break\n            if First:\n                if ModulePcdSet is None:\n                    FileWrite(File, '')\n                FileWrite(File, Key)\n                First = False\n            if Pcd.DatumType in TAB_PCD_NUMERIC_TYPES:\n                if PcdValue.startswith('0') and (not PcdValue.lower().startswith('0x')) and (len(PcdValue) > 1) and PcdValue.lstrip('0'):\n                    PcdValue = PcdValue.lstrip('0')\n                PcdValueNumber = int(PcdValue.strip(), 0)\n                if DecDefaultValue is None:\n                    DecMatch = True\n                else:\n                    if DecDefaultValue.startswith('0') and (not DecDefaultValue.lower().startswith('0x')) and (len(DecDefaultValue) > 1) and DecDefaultValue.lstrip('0'):\n                        DecDefaultValue = DecDefaultValue.lstrip('0')\n                    DecDefaultValueNumber = int(DecDefaultValue.strip(), 0)\n                    DecMatch = DecDefaultValueNumber == PcdValueNumber\n                if InfDefaultValue is None:\n                    InfMatch = True\n                else:\n                    if InfDefaultValue.startswith('0') and (not InfDefaultValue.lower().startswith('0x')) and (len(InfDefaultValue) > 1) and InfDefaultValue.lstrip('0'):\n                        InfDefaultValue = InfDefaultValue.lstrip('0')\n                    InfDefaultValueNumber = int(InfDefaultValue.strip(), 0)\n                    InfMatch = InfDefaultValueNumber == PcdValueNumber\n                if DscDefaultValue is None:\n                    DscMatch = True\n                else:\n                    if DscDefaultValue.startswith('0') and (not DscDefaultValue.lower().startswith('0x')) and (len(DscDefaultValue) > 1) and DscDefaultValue.lstrip('0'):\n                        DscDefaultValue = DscDefaultValue.lstrip('0')\n                    DscDefaultValueNumber = int(DscDefaultValue.strip(), 0)\n                    DscMatch = DscDefaultValueNumber == PcdValueNumber\n            else:\n                if DecDefaultValue is None:\n                    DecMatch = True\n                else:\n                    DecMatch = DecDefaultValue.strip() == PcdValue.strip()\n                if InfDefaultValue is None:\n                    InfMatch = True\n                else:\n                    InfMatch = InfDefaultValue.strip() == PcdValue.strip()\n                if DscDefaultValue is None:\n                    DscMatch = True\n                else:\n                    DscMatch = DscDefaultValue.strip() == PcdValue.strip()\n            IsStructure = False\n            if self.IsStructurePcd(Pcd.TokenCName, Pcd.TokenSpaceGuidCName):\n                IsStructure = True\n                if TypeName in ('DYNVPD', 'DEXVPD'):\n                    SkuInfoList = Pcd.SkuInfoList\n                Pcd = GlobalData.gStructurePcd[self.Arch][Pcd.TokenCName, Pcd.TokenSpaceGuidCName]\n                if ModulePcdSet and ModulePcdSet.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Type)):\n                    (InfDefaultValue, PcdComponentValue) = ModulePcdSet[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Type]\n                    DscDefaultValBak = Pcd.DefaultValue\n                    Pcd.DefaultValue = PcdComponentValue\n                Pcd.DatumType = Pcd.StructName\n                if TypeName in ('DYNVPD', 'DEXVPD'):\n                    Pcd.SkuInfoList = SkuInfoList\n                if Pcd.PcdValueFromComm or Pcd.PcdFieldValueFromComm:\n                    BuildOptionMatch = True\n                    DecMatch = False\n                elif Pcd.PcdValueFromFdf or Pcd.PcdFieldValueFromFdf:\n                    DscDefaultValue = True\n                    DscMatch = True\n                    DecMatch = False\n                elif Pcd.Type in PCD_DYNAMIC_TYPE_SET | PCD_DYNAMIC_EX_TYPE_SET:\n                    DscOverride = False\n                    if Pcd.DefaultFromDSC:\n                        DscOverride = True\n                    else:\n                        DictLen = 0\n                        for item in Pcd.SkuOverrideValues:\n                            DictLen += len(Pcd.SkuOverrideValues[item])\n                        if not DictLen:\n                            DscOverride = False\n                        elif not Pcd.SkuInfoList:\n                            OverrideValues = Pcd.SkuOverrideValues\n                            if OverrideValues:\n                                for Data in OverrideValues.values():\n                                    Struct = list(Data.values())\n                                    if Struct:\n                                        DscOverride = self.ParseStruct(Struct[0])\n                                        break\n                        else:\n                            SkuList = sorted(Pcd.SkuInfoList.keys())\n                            for Sku in SkuList:\n                                SkuInfo = Pcd.SkuInfoList[Sku]\n                                if SkuInfo.DefaultStoreDict:\n                                    DefaultStoreList = sorted(SkuInfo.DefaultStoreDict.keys())\n                                    for DefaultStore in DefaultStoreList:\n                                        OverrideValues = Pcd.SkuOverrideValues.get(Sku)\n                                        if OverrideValues:\n                                            DscOverride = self.ParseStruct(OverrideValues[DefaultStore])\n                                            if DscOverride:\n                                                break\n                                if DscOverride:\n                                    break\n                    if DscOverride:\n                        DscDefaultValue = True\n                        DscMatch = True\n                        DecMatch = False\n                    else:\n                        DecMatch = True\n                elif Pcd.DscRawValue or (ModuleGuid and ModuleGuid.replace('-', 'S') in Pcd.PcdValueFromComponents):\n                    DscDefaultValue = True\n                    DscMatch = True\n                    DecMatch = False\n                else:\n                    DscDefaultValue = False\n                    DecMatch = True\n            if Pcd.DatumType == 'BOOLEAN':\n                if DscDefaultValue:\n                    DscDefaultValue = str(int(DscDefaultValue, 0))\n                if DecDefaultValue:\n                    DecDefaultValue = str(int(DecDefaultValue, 0))\n                if InfDefaultValue:\n                    InfDefaultValue = str(int(InfDefaultValue, 0))\n                if Pcd.DefaultValue:\n                    Pcd.DefaultValue = str(int(Pcd.DefaultValue, 0))\n            if DecMatch:\n                self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '  ')\n            elif InfDefaultValue and InfMatch:\n                self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '*M')\n            elif BuildOptionMatch:\n                self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '*B')\n            elif PcdComponentValue:\n                self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, PcdComponentValue, DecMatch, DecDefaultValue, '*M', ModuleGuid)\n            elif DscDefaultValue and DscMatch:\n                if (Pcd.TokenCName, Key, Field) in self.FdfPcdSet:\n                    self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '*F')\n                else:\n                    self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '*P')\n            if ModulePcdSet is None:\n                if IsStructure:\n                    continue\n                if not TypeName in ('PATCH', 'FLAG', 'FIXED'):\n                    continue\n                if not BuildOptionMatch:\n                    ModuleOverride = self.ModulePcdOverride.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName), {})\n                    for ModulePath in ModuleOverride:\n                        ModuleDefault = ModuleOverride[ModulePath]\n                        if Pcd.DatumType in TAB_PCD_NUMERIC_TYPES:\n                            if ModuleDefault.startswith('0') and (not ModuleDefault.lower().startswith('0x')) and (len(ModuleDefault) > 1) and ModuleDefault.lstrip('0'):\n                                ModuleDefault = ModuleDefault.lstrip('0')\n                            ModulePcdDefaultValueNumber = int(ModuleDefault.strip(), 0)\n                            Match = ModulePcdDefaultValueNumber == PcdValueNumber\n                            if Pcd.DatumType == 'BOOLEAN':\n                                ModuleDefault = str(ModulePcdDefaultValueNumber)\n                        else:\n                            Match = ModuleDefault.strip() == PcdValue.strip()\n                        if Match:\n                            continue\n                        (IsByteArray, ArrayList) = ByteArrayForamt(ModuleDefault.strip())\n                        if IsByteArray:\n                            FileWrite(File, ' *M     %-*s = %s' % (self.MaxLen + 15, ModulePath, '{'))\n                            for Array in ArrayList:\n                                FileWrite(File, Array)\n                        else:\n                            Value = ModuleDefault.strip()\n                            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                                if Value.startswith(('0x', '0X')):\n                                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                                else:\n                                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                            FileWrite(File, ' *M     %-*s = %s' % (self.MaxLen + 15, ModulePath, Value))\n    if ModulePcdSet is None:\n        FileWrite(File, gSectionEnd)\n    elif not ReportSubType and ModulePcdSet:\n        FileWrite(File, gSubSectionEnd)",
            "def GenerateReportDetail(self, File, ModulePcdSet, ReportSubType=0, ModuleGuid=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    PcdDict = self.AllPcds\n    if ReportSubType == 1:\n        PcdDict = self.ConditionalPcds\n    elif ReportSubType == 2:\n        PcdDict = self.UnusedPcds\n    if not ModulePcdSet:\n        FileWrite(File, gSectionStart)\n        if ReportSubType == 1:\n            FileWrite(File, 'Conditional Directives used by the build system')\n        elif ReportSubType == 2:\n            FileWrite(File, 'PCDs not used by modules or in conditional directives')\n        else:\n            FileWrite(File, 'Platform Configuration Database Report')\n        FileWrite(File, '  *B  - PCD override in the build option')\n        FileWrite(File, '  *P  - Platform scoped PCD override in DSC file')\n        FileWrite(File, '  *F  - Platform scoped PCD override in FDF file')\n        if not ReportSubType:\n            FileWrite(File, '  *M  - Module scoped PCD override')\n        FileWrite(File, gSectionSep)\n    elif not ReportSubType and ModulePcdSet:\n        FileWrite(File, gSubSectionStart)\n        FileWrite(File, TAB_BRG_PCD)\n        FileWrite(File, gSubSectionSep)\n    AllPcdDict = {}\n    for Key in PcdDict:\n        AllPcdDict[Key] = {}\n        for Type in PcdDict[Key]:\n            for Pcd in PcdDict[Key][Type]:\n                AllPcdDict[Key][Pcd.TokenCName, Type] = Pcd\n    for Key in sorted(AllPcdDict):\n        First = True\n        for (PcdTokenCName, Type) in sorted(AllPcdDict[Key]):\n            Pcd = AllPcdDict[Key][PcdTokenCName, Type]\n            (TypeName, DecType) = gPcdTypeMap.get(Type, ('', Type))\n            MixedPcdFlag = False\n            if GlobalData.MixedPcd:\n                for PcdKey in GlobalData.MixedPcd:\n                    if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdKey]:\n                        PcdTokenCName = PcdKey[0]\n                        MixedPcdFlag = True\n                if MixedPcdFlag and (not ModulePcdSet):\n                    continue\n            DecDefaultValue = self.DecPcdDefault.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName, DecType))\n            DscDefaultValue = self.DscPcdDefault.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName))\n            DscDefaultValBak = DscDefaultValue\n            Field = ''\n            for (CName, Guid, Field) in self.FdfPcdSet:\n                if CName == PcdTokenCName and Guid == Key:\n                    DscDefaultValue = self.FdfPcdSet[CName, Guid, Field]\n                    break\n            if DscDefaultValue != DscDefaultValBak:\n                try:\n                    DscDefaultValue = ValueExpressionEx(DscDefaultValue, Pcd.DatumType, self._GuidDict)(True)\n                except BadExpression as DscDefaultValue:\n                    EdkLogger.error('BuildReport', FORMAT_INVALID, 'PCD Value: %s, Type: %s' % (DscDefaultValue, Pcd.DatumType))\n            InfDefaultValue = None\n            PcdValue = DecDefaultValue\n            if DscDefaultValue:\n                PcdValue = DscDefaultValue\n            if not self.IsStructurePcd(Pcd.TokenCName, Pcd.TokenSpaceGuidCName):\n                Pcd.DefaultValue = PcdValue\n            PcdComponentValue = None\n            if ModulePcdSet is not None:\n                if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Type) not in ModulePcdSet:\n                    continue\n                (InfDefaultValue, PcdComponentValue) = ModulePcdSet[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Type]\n                PcdValue = PcdComponentValue\n                if not self.IsStructurePcd(Pcd.TokenCName, Pcd.TokenSpaceGuidCName):\n                    Pcd.DefaultValue = PcdValue\n                if InfDefaultValue:\n                    try:\n                        InfDefaultValue = ValueExpressionEx(InfDefaultValue, Pcd.DatumType, self._GuidDict)(True)\n                    except BadExpression as InfDefaultValue:\n                        EdkLogger.error('BuildReport', FORMAT_INVALID, 'PCD Value: %s, Type: %s' % (InfDefaultValue, Pcd.DatumType))\n                if InfDefaultValue == '':\n                    InfDefaultValue = None\n            BuildOptionMatch = False\n            if GlobalData.BuildOptionPcd:\n                for pcd in GlobalData.BuildOptionPcd:\n                    if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) == (pcd[0], pcd[1]):\n                        if pcd[2]:\n                            continue\n                        PcdValue = pcd[3]\n                        if not self.IsStructurePcd(Pcd.TokenCName, Pcd.TokenSpaceGuidCName):\n                            Pcd.DefaultValue = PcdValue\n                        BuildOptionMatch = True\n                        break\n            if First:\n                if ModulePcdSet is None:\n                    FileWrite(File, '')\n                FileWrite(File, Key)\n                First = False\n            if Pcd.DatumType in TAB_PCD_NUMERIC_TYPES:\n                if PcdValue.startswith('0') and (not PcdValue.lower().startswith('0x')) and (len(PcdValue) > 1) and PcdValue.lstrip('0'):\n                    PcdValue = PcdValue.lstrip('0')\n                PcdValueNumber = int(PcdValue.strip(), 0)\n                if DecDefaultValue is None:\n                    DecMatch = True\n                else:\n                    if DecDefaultValue.startswith('0') and (not DecDefaultValue.lower().startswith('0x')) and (len(DecDefaultValue) > 1) and DecDefaultValue.lstrip('0'):\n                        DecDefaultValue = DecDefaultValue.lstrip('0')\n                    DecDefaultValueNumber = int(DecDefaultValue.strip(), 0)\n                    DecMatch = DecDefaultValueNumber == PcdValueNumber\n                if InfDefaultValue is None:\n                    InfMatch = True\n                else:\n                    if InfDefaultValue.startswith('0') and (not InfDefaultValue.lower().startswith('0x')) and (len(InfDefaultValue) > 1) and InfDefaultValue.lstrip('0'):\n                        InfDefaultValue = InfDefaultValue.lstrip('0')\n                    InfDefaultValueNumber = int(InfDefaultValue.strip(), 0)\n                    InfMatch = InfDefaultValueNumber == PcdValueNumber\n                if DscDefaultValue is None:\n                    DscMatch = True\n                else:\n                    if DscDefaultValue.startswith('0') and (not DscDefaultValue.lower().startswith('0x')) and (len(DscDefaultValue) > 1) and DscDefaultValue.lstrip('0'):\n                        DscDefaultValue = DscDefaultValue.lstrip('0')\n                    DscDefaultValueNumber = int(DscDefaultValue.strip(), 0)\n                    DscMatch = DscDefaultValueNumber == PcdValueNumber\n            else:\n                if DecDefaultValue is None:\n                    DecMatch = True\n                else:\n                    DecMatch = DecDefaultValue.strip() == PcdValue.strip()\n                if InfDefaultValue is None:\n                    InfMatch = True\n                else:\n                    InfMatch = InfDefaultValue.strip() == PcdValue.strip()\n                if DscDefaultValue is None:\n                    DscMatch = True\n                else:\n                    DscMatch = DscDefaultValue.strip() == PcdValue.strip()\n            IsStructure = False\n            if self.IsStructurePcd(Pcd.TokenCName, Pcd.TokenSpaceGuidCName):\n                IsStructure = True\n                if TypeName in ('DYNVPD', 'DEXVPD'):\n                    SkuInfoList = Pcd.SkuInfoList\n                Pcd = GlobalData.gStructurePcd[self.Arch][Pcd.TokenCName, Pcd.TokenSpaceGuidCName]\n                if ModulePcdSet and ModulePcdSet.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Type)):\n                    (InfDefaultValue, PcdComponentValue) = ModulePcdSet[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Type]\n                    DscDefaultValBak = Pcd.DefaultValue\n                    Pcd.DefaultValue = PcdComponentValue\n                Pcd.DatumType = Pcd.StructName\n                if TypeName in ('DYNVPD', 'DEXVPD'):\n                    Pcd.SkuInfoList = SkuInfoList\n                if Pcd.PcdValueFromComm or Pcd.PcdFieldValueFromComm:\n                    BuildOptionMatch = True\n                    DecMatch = False\n                elif Pcd.PcdValueFromFdf or Pcd.PcdFieldValueFromFdf:\n                    DscDefaultValue = True\n                    DscMatch = True\n                    DecMatch = False\n                elif Pcd.Type in PCD_DYNAMIC_TYPE_SET | PCD_DYNAMIC_EX_TYPE_SET:\n                    DscOverride = False\n                    if Pcd.DefaultFromDSC:\n                        DscOverride = True\n                    else:\n                        DictLen = 0\n                        for item in Pcd.SkuOverrideValues:\n                            DictLen += len(Pcd.SkuOverrideValues[item])\n                        if not DictLen:\n                            DscOverride = False\n                        elif not Pcd.SkuInfoList:\n                            OverrideValues = Pcd.SkuOverrideValues\n                            if OverrideValues:\n                                for Data in OverrideValues.values():\n                                    Struct = list(Data.values())\n                                    if Struct:\n                                        DscOverride = self.ParseStruct(Struct[0])\n                                        break\n                        else:\n                            SkuList = sorted(Pcd.SkuInfoList.keys())\n                            for Sku in SkuList:\n                                SkuInfo = Pcd.SkuInfoList[Sku]\n                                if SkuInfo.DefaultStoreDict:\n                                    DefaultStoreList = sorted(SkuInfo.DefaultStoreDict.keys())\n                                    for DefaultStore in DefaultStoreList:\n                                        OverrideValues = Pcd.SkuOverrideValues.get(Sku)\n                                        if OverrideValues:\n                                            DscOverride = self.ParseStruct(OverrideValues[DefaultStore])\n                                            if DscOverride:\n                                                break\n                                if DscOverride:\n                                    break\n                    if DscOverride:\n                        DscDefaultValue = True\n                        DscMatch = True\n                        DecMatch = False\n                    else:\n                        DecMatch = True\n                elif Pcd.DscRawValue or (ModuleGuid and ModuleGuid.replace('-', 'S') in Pcd.PcdValueFromComponents):\n                    DscDefaultValue = True\n                    DscMatch = True\n                    DecMatch = False\n                else:\n                    DscDefaultValue = False\n                    DecMatch = True\n            if Pcd.DatumType == 'BOOLEAN':\n                if DscDefaultValue:\n                    DscDefaultValue = str(int(DscDefaultValue, 0))\n                if DecDefaultValue:\n                    DecDefaultValue = str(int(DecDefaultValue, 0))\n                if InfDefaultValue:\n                    InfDefaultValue = str(int(InfDefaultValue, 0))\n                if Pcd.DefaultValue:\n                    Pcd.DefaultValue = str(int(Pcd.DefaultValue, 0))\n            if DecMatch:\n                self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '  ')\n            elif InfDefaultValue and InfMatch:\n                self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '*M')\n            elif BuildOptionMatch:\n                self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '*B')\n            elif PcdComponentValue:\n                self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, PcdComponentValue, DecMatch, DecDefaultValue, '*M', ModuleGuid)\n            elif DscDefaultValue and DscMatch:\n                if (Pcd.TokenCName, Key, Field) in self.FdfPcdSet:\n                    self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '*F')\n                else:\n                    self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '*P')\n            if ModulePcdSet is None:\n                if IsStructure:\n                    continue\n                if not TypeName in ('PATCH', 'FLAG', 'FIXED'):\n                    continue\n                if not BuildOptionMatch:\n                    ModuleOverride = self.ModulePcdOverride.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName), {})\n                    for ModulePath in ModuleOverride:\n                        ModuleDefault = ModuleOverride[ModulePath]\n                        if Pcd.DatumType in TAB_PCD_NUMERIC_TYPES:\n                            if ModuleDefault.startswith('0') and (not ModuleDefault.lower().startswith('0x')) and (len(ModuleDefault) > 1) and ModuleDefault.lstrip('0'):\n                                ModuleDefault = ModuleDefault.lstrip('0')\n                            ModulePcdDefaultValueNumber = int(ModuleDefault.strip(), 0)\n                            Match = ModulePcdDefaultValueNumber == PcdValueNumber\n                            if Pcd.DatumType == 'BOOLEAN':\n                                ModuleDefault = str(ModulePcdDefaultValueNumber)\n                        else:\n                            Match = ModuleDefault.strip() == PcdValue.strip()\n                        if Match:\n                            continue\n                        (IsByteArray, ArrayList) = ByteArrayForamt(ModuleDefault.strip())\n                        if IsByteArray:\n                            FileWrite(File, ' *M     %-*s = %s' % (self.MaxLen + 15, ModulePath, '{'))\n                            for Array in ArrayList:\n                                FileWrite(File, Array)\n                        else:\n                            Value = ModuleDefault.strip()\n                            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                                if Value.startswith(('0x', '0X')):\n                                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                                else:\n                                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                            FileWrite(File, ' *M     %-*s = %s' % (self.MaxLen + 15, ModulePath, Value))\n    if ModulePcdSet is None:\n        FileWrite(File, gSectionEnd)\n    elif not ReportSubType and ModulePcdSet:\n        FileWrite(File, gSubSectionEnd)",
            "def GenerateReportDetail(self, File, ModulePcdSet, ReportSubType=0, ModuleGuid=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    PcdDict = self.AllPcds\n    if ReportSubType == 1:\n        PcdDict = self.ConditionalPcds\n    elif ReportSubType == 2:\n        PcdDict = self.UnusedPcds\n    if not ModulePcdSet:\n        FileWrite(File, gSectionStart)\n        if ReportSubType == 1:\n            FileWrite(File, 'Conditional Directives used by the build system')\n        elif ReportSubType == 2:\n            FileWrite(File, 'PCDs not used by modules or in conditional directives')\n        else:\n            FileWrite(File, 'Platform Configuration Database Report')\n        FileWrite(File, '  *B  - PCD override in the build option')\n        FileWrite(File, '  *P  - Platform scoped PCD override in DSC file')\n        FileWrite(File, '  *F  - Platform scoped PCD override in FDF file')\n        if not ReportSubType:\n            FileWrite(File, '  *M  - Module scoped PCD override')\n        FileWrite(File, gSectionSep)\n    elif not ReportSubType and ModulePcdSet:\n        FileWrite(File, gSubSectionStart)\n        FileWrite(File, TAB_BRG_PCD)\n        FileWrite(File, gSubSectionSep)\n    AllPcdDict = {}\n    for Key in PcdDict:\n        AllPcdDict[Key] = {}\n        for Type in PcdDict[Key]:\n            for Pcd in PcdDict[Key][Type]:\n                AllPcdDict[Key][Pcd.TokenCName, Type] = Pcd\n    for Key in sorted(AllPcdDict):\n        First = True\n        for (PcdTokenCName, Type) in sorted(AllPcdDict[Key]):\n            Pcd = AllPcdDict[Key][PcdTokenCName, Type]\n            (TypeName, DecType) = gPcdTypeMap.get(Type, ('', Type))\n            MixedPcdFlag = False\n            if GlobalData.MixedPcd:\n                for PcdKey in GlobalData.MixedPcd:\n                    if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdKey]:\n                        PcdTokenCName = PcdKey[0]\n                        MixedPcdFlag = True\n                if MixedPcdFlag and (not ModulePcdSet):\n                    continue\n            DecDefaultValue = self.DecPcdDefault.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName, DecType))\n            DscDefaultValue = self.DscPcdDefault.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName))\n            DscDefaultValBak = DscDefaultValue\n            Field = ''\n            for (CName, Guid, Field) in self.FdfPcdSet:\n                if CName == PcdTokenCName and Guid == Key:\n                    DscDefaultValue = self.FdfPcdSet[CName, Guid, Field]\n                    break\n            if DscDefaultValue != DscDefaultValBak:\n                try:\n                    DscDefaultValue = ValueExpressionEx(DscDefaultValue, Pcd.DatumType, self._GuidDict)(True)\n                except BadExpression as DscDefaultValue:\n                    EdkLogger.error('BuildReport', FORMAT_INVALID, 'PCD Value: %s, Type: %s' % (DscDefaultValue, Pcd.DatumType))\n            InfDefaultValue = None\n            PcdValue = DecDefaultValue\n            if DscDefaultValue:\n                PcdValue = DscDefaultValue\n            if not self.IsStructurePcd(Pcd.TokenCName, Pcd.TokenSpaceGuidCName):\n                Pcd.DefaultValue = PcdValue\n            PcdComponentValue = None\n            if ModulePcdSet is not None:\n                if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Type) not in ModulePcdSet:\n                    continue\n                (InfDefaultValue, PcdComponentValue) = ModulePcdSet[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Type]\n                PcdValue = PcdComponentValue\n                if not self.IsStructurePcd(Pcd.TokenCName, Pcd.TokenSpaceGuidCName):\n                    Pcd.DefaultValue = PcdValue\n                if InfDefaultValue:\n                    try:\n                        InfDefaultValue = ValueExpressionEx(InfDefaultValue, Pcd.DatumType, self._GuidDict)(True)\n                    except BadExpression as InfDefaultValue:\n                        EdkLogger.error('BuildReport', FORMAT_INVALID, 'PCD Value: %s, Type: %s' % (InfDefaultValue, Pcd.DatumType))\n                if InfDefaultValue == '':\n                    InfDefaultValue = None\n            BuildOptionMatch = False\n            if GlobalData.BuildOptionPcd:\n                for pcd in GlobalData.BuildOptionPcd:\n                    if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) == (pcd[0], pcd[1]):\n                        if pcd[2]:\n                            continue\n                        PcdValue = pcd[3]\n                        if not self.IsStructurePcd(Pcd.TokenCName, Pcd.TokenSpaceGuidCName):\n                            Pcd.DefaultValue = PcdValue\n                        BuildOptionMatch = True\n                        break\n            if First:\n                if ModulePcdSet is None:\n                    FileWrite(File, '')\n                FileWrite(File, Key)\n                First = False\n            if Pcd.DatumType in TAB_PCD_NUMERIC_TYPES:\n                if PcdValue.startswith('0') and (not PcdValue.lower().startswith('0x')) and (len(PcdValue) > 1) and PcdValue.lstrip('0'):\n                    PcdValue = PcdValue.lstrip('0')\n                PcdValueNumber = int(PcdValue.strip(), 0)\n                if DecDefaultValue is None:\n                    DecMatch = True\n                else:\n                    if DecDefaultValue.startswith('0') and (not DecDefaultValue.lower().startswith('0x')) and (len(DecDefaultValue) > 1) and DecDefaultValue.lstrip('0'):\n                        DecDefaultValue = DecDefaultValue.lstrip('0')\n                    DecDefaultValueNumber = int(DecDefaultValue.strip(), 0)\n                    DecMatch = DecDefaultValueNumber == PcdValueNumber\n                if InfDefaultValue is None:\n                    InfMatch = True\n                else:\n                    if InfDefaultValue.startswith('0') and (not InfDefaultValue.lower().startswith('0x')) and (len(InfDefaultValue) > 1) and InfDefaultValue.lstrip('0'):\n                        InfDefaultValue = InfDefaultValue.lstrip('0')\n                    InfDefaultValueNumber = int(InfDefaultValue.strip(), 0)\n                    InfMatch = InfDefaultValueNumber == PcdValueNumber\n                if DscDefaultValue is None:\n                    DscMatch = True\n                else:\n                    if DscDefaultValue.startswith('0') and (not DscDefaultValue.lower().startswith('0x')) and (len(DscDefaultValue) > 1) and DscDefaultValue.lstrip('0'):\n                        DscDefaultValue = DscDefaultValue.lstrip('0')\n                    DscDefaultValueNumber = int(DscDefaultValue.strip(), 0)\n                    DscMatch = DscDefaultValueNumber == PcdValueNumber\n            else:\n                if DecDefaultValue is None:\n                    DecMatch = True\n                else:\n                    DecMatch = DecDefaultValue.strip() == PcdValue.strip()\n                if InfDefaultValue is None:\n                    InfMatch = True\n                else:\n                    InfMatch = InfDefaultValue.strip() == PcdValue.strip()\n                if DscDefaultValue is None:\n                    DscMatch = True\n                else:\n                    DscMatch = DscDefaultValue.strip() == PcdValue.strip()\n            IsStructure = False\n            if self.IsStructurePcd(Pcd.TokenCName, Pcd.TokenSpaceGuidCName):\n                IsStructure = True\n                if TypeName in ('DYNVPD', 'DEXVPD'):\n                    SkuInfoList = Pcd.SkuInfoList\n                Pcd = GlobalData.gStructurePcd[self.Arch][Pcd.TokenCName, Pcd.TokenSpaceGuidCName]\n                if ModulePcdSet and ModulePcdSet.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Type)):\n                    (InfDefaultValue, PcdComponentValue) = ModulePcdSet[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Type]\n                    DscDefaultValBak = Pcd.DefaultValue\n                    Pcd.DefaultValue = PcdComponentValue\n                Pcd.DatumType = Pcd.StructName\n                if TypeName in ('DYNVPD', 'DEXVPD'):\n                    Pcd.SkuInfoList = SkuInfoList\n                if Pcd.PcdValueFromComm or Pcd.PcdFieldValueFromComm:\n                    BuildOptionMatch = True\n                    DecMatch = False\n                elif Pcd.PcdValueFromFdf or Pcd.PcdFieldValueFromFdf:\n                    DscDefaultValue = True\n                    DscMatch = True\n                    DecMatch = False\n                elif Pcd.Type in PCD_DYNAMIC_TYPE_SET | PCD_DYNAMIC_EX_TYPE_SET:\n                    DscOverride = False\n                    if Pcd.DefaultFromDSC:\n                        DscOverride = True\n                    else:\n                        DictLen = 0\n                        for item in Pcd.SkuOverrideValues:\n                            DictLen += len(Pcd.SkuOverrideValues[item])\n                        if not DictLen:\n                            DscOverride = False\n                        elif not Pcd.SkuInfoList:\n                            OverrideValues = Pcd.SkuOverrideValues\n                            if OverrideValues:\n                                for Data in OverrideValues.values():\n                                    Struct = list(Data.values())\n                                    if Struct:\n                                        DscOverride = self.ParseStruct(Struct[0])\n                                        break\n                        else:\n                            SkuList = sorted(Pcd.SkuInfoList.keys())\n                            for Sku in SkuList:\n                                SkuInfo = Pcd.SkuInfoList[Sku]\n                                if SkuInfo.DefaultStoreDict:\n                                    DefaultStoreList = sorted(SkuInfo.DefaultStoreDict.keys())\n                                    for DefaultStore in DefaultStoreList:\n                                        OverrideValues = Pcd.SkuOverrideValues.get(Sku)\n                                        if OverrideValues:\n                                            DscOverride = self.ParseStruct(OverrideValues[DefaultStore])\n                                            if DscOverride:\n                                                break\n                                if DscOverride:\n                                    break\n                    if DscOverride:\n                        DscDefaultValue = True\n                        DscMatch = True\n                        DecMatch = False\n                    else:\n                        DecMatch = True\n                elif Pcd.DscRawValue or (ModuleGuid and ModuleGuid.replace('-', 'S') in Pcd.PcdValueFromComponents):\n                    DscDefaultValue = True\n                    DscMatch = True\n                    DecMatch = False\n                else:\n                    DscDefaultValue = False\n                    DecMatch = True\n            if Pcd.DatumType == 'BOOLEAN':\n                if DscDefaultValue:\n                    DscDefaultValue = str(int(DscDefaultValue, 0))\n                if DecDefaultValue:\n                    DecDefaultValue = str(int(DecDefaultValue, 0))\n                if InfDefaultValue:\n                    InfDefaultValue = str(int(InfDefaultValue, 0))\n                if Pcd.DefaultValue:\n                    Pcd.DefaultValue = str(int(Pcd.DefaultValue, 0))\n            if DecMatch:\n                self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '  ')\n            elif InfDefaultValue and InfMatch:\n                self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '*M')\n            elif BuildOptionMatch:\n                self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '*B')\n            elif PcdComponentValue:\n                self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, PcdComponentValue, DecMatch, DecDefaultValue, '*M', ModuleGuid)\n            elif DscDefaultValue and DscMatch:\n                if (Pcd.TokenCName, Key, Field) in self.FdfPcdSet:\n                    self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '*F')\n                else:\n                    self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '*P')\n            if ModulePcdSet is None:\n                if IsStructure:\n                    continue\n                if not TypeName in ('PATCH', 'FLAG', 'FIXED'):\n                    continue\n                if not BuildOptionMatch:\n                    ModuleOverride = self.ModulePcdOverride.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName), {})\n                    for ModulePath in ModuleOverride:\n                        ModuleDefault = ModuleOverride[ModulePath]\n                        if Pcd.DatumType in TAB_PCD_NUMERIC_TYPES:\n                            if ModuleDefault.startswith('0') and (not ModuleDefault.lower().startswith('0x')) and (len(ModuleDefault) > 1) and ModuleDefault.lstrip('0'):\n                                ModuleDefault = ModuleDefault.lstrip('0')\n                            ModulePcdDefaultValueNumber = int(ModuleDefault.strip(), 0)\n                            Match = ModulePcdDefaultValueNumber == PcdValueNumber\n                            if Pcd.DatumType == 'BOOLEAN':\n                                ModuleDefault = str(ModulePcdDefaultValueNumber)\n                        else:\n                            Match = ModuleDefault.strip() == PcdValue.strip()\n                        if Match:\n                            continue\n                        (IsByteArray, ArrayList) = ByteArrayForamt(ModuleDefault.strip())\n                        if IsByteArray:\n                            FileWrite(File, ' *M     %-*s = %s' % (self.MaxLen + 15, ModulePath, '{'))\n                            for Array in ArrayList:\n                                FileWrite(File, Array)\n                        else:\n                            Value = ModuleDefault.strip()\n                            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                                if Value.startswith(('0x', '0X')):\n                                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                                else:\n                                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                            FileWrite(File, ' *M     %-*s = %s' % (self.MaxLen + 15, ModulePath, Value))\n    if ModulePcdSet is None:\n        FileWrite(File, gSectionEnd)\n    elif not ReportSubType and ModulePcdSet:\n        FileWrite(File, gSubSectionEnd)",
            "def GenerateReportDetail(self, File, ModulePcdSet, ReportSubType=0, ModuleGuid=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    PcdDict = self.AllPcds\n    if ReportSubType == 1:\n        PcdDict = self.ConditionalPcds\n    elif ReportSubType == 2:\n        PcdDict = self.UnusedPcds\n    if not ModulePcdSet:\n        FileWrite(File, gSectionStart)\n        if ReportSubType == 1:\n            FileWrite(File, 'Conditional Directives used by the build system')\n        elif ReportSubType == 2:\n            FileWrite(File, 'PCDs not used by modules or in conditional directives')\n        else:\n            FileWrite(File, 'Platform Configuration Database Report')\n        FileWrite(File, '  *B  - PCD override in the build option')\n        FileWrite(File, '  *P  - Platform scoped PCD override in DSC file')\n        FileWrite(File, '  *F  - Platform scoped PCD override in FDF file')\n        if not ReportSubType:\n            FileWrite(File, '  *M  - Module scoped PCD override')\n        FileWrite(File, gSectionSep)\n    elif not ReportSubType and ModulePcdSet:\n        FileWrite(File, gSubSectionStart)\n        FileWrite(File, TAB_BRG_PCD)\n        FileWrite(File, gSubSectionSep)\n    AllPcdDict = {}\n    for Key in PcdDict:\n        AllPcdDict[Key] = {}\n        for Type in PcdDict[Key]:\n            for Pcd in PcdDict[Key][Type]:\n                AllPcdDict[Key][Pcd.TokenCName, Type] = Pcd\n    for Key in sorted(AllPcdDict):\n        First = True\n        for (PcdTokenCName, Type) in sorted(AllPcdDict[Key]):\n            Pcd = AllPcdDict[Key][PcdTokenCName, Type]\n            (TypeName, DecType) = gPcdTypeMap.get(Type, ('', Type))\n            MixedPcdFlag = False\n            if GlobalData.MixedPcd:\n                for PcdKey in GlobalData.MixedPcd:\n                    if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdKey]:\n                        PcdTokenCName = PcdKey[0]\n                        MixedPcdFlag = True\n                if MixedPcdFlag and (not ModulePcdSet):\n                    continue\n            DecDefaultValue = self.DecPcdDefault.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName, DecType))\n            DscDefaultValue = self.DscPcdDefault.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName))\n            DscDefaultValBak = DscDefaultValue\n            Field = ''\n            for (CName, Guid, Field) in self.FdfPcdSet:\n                if CName == PcdTokenCName and Guid == Key:\n                    DscDefaultValue = self.FdfPcdSet[CName, Guid, Field]\n                    break\n            if DscDefaultValue != DscDefaultValBak:\n                try:\n                    DscDefaultValue = ValueExpressionEx(DscDefaultValue, Pcd.DatumType, self._GuidDict)(True)\n                except BadExpression as DscDefaultValue:\n                    EdkLogger.error('BuildReport', FORMAT_INVALID, 'PCD Value: %s, Type: %s' % (DscDefaultValue, Pcd.DatumType))\n            InfDefaultValue = None\n            PcdValue = DecDefaultValue\n            if DscDefaultValue:\n                PcdValue = DscDefaultValue\n            if not self.IsStructurePcd(Pcd.TokenCName, Pcd.TokenSpaceGuidCName):\n                Pcd.DefaultValue = PcdValue\n            PcdComponentValue = None\n            if ModulePcdSet is not None:\n                if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Type) not in ModulePcdSet:\n                    continue\n                (InfDefaultValue, PcdComponentValue) = ModulePcdSet[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Type]\n                PcdValue = PcdComponentValue\n                if not self.IsStructurePcd(Pcd.TokenCName, Pcd.TokenSpaceGuidCName):\n                    Pcd.DefaultValue = PcdValue\n                if InfDefaultValue:\n                    try:\n                        InfDefaultValue = ValueExpressionEx(InfDefaultValue, Pcd.DatumType, self._GuidDict)(True)\n                    except BadExpression as InfDefaultValue:\n                        EdkLogger.error('BuildReport', FORMAT_INVALID, 'PCD Value: %s, Type: %s' % (InfDefaultValue, Pcd.DatumType))\n                if InfDefaultValue == '':\n                    InfDefaultValue = None\n            BuildOptionMatch = False\n            if GlobalData.BuildOptionPcd:\n                for pcd in GlobalData.BuildOptionPcd:\n                    if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) == (pcd[0], pcd[1]):\n                        if pcd[2]:\n                            continue\n                        PcdValue = pcd[3]\n                        if not self.IsStructurePcd(Pcd.TokenCName, Pcd.TokenSpaceGuidCName):\n                            Pcd.DefaultValue = PcdValue\n                        BuildOptionMatch = True\n                        break\n            if First:\n                if ModulePcdSet is None:\n                    FileWrite(File, '')\n                FileWrite(File, Key)\n                First = False\n            if Pcd.DatumType in TAB_PCD_NUMERIC_TYPES:\n                if PcdValue.startswith('0') and (not PcdValue.lower().startswith('0x')) and (len(PcdValue) > 1) and PcdValue.lstrip('0'):\n                    PcdValue = PcdValue.lstrip('0')\n                PcdValueNumber = int(PcdValue.strip(), 0)\n                if DecDefaultValue is None:\n                    DecMatch = True\n                else:\n                    if DecDefaultValue.startswith('0') and (not DecDefaultValue.lower().startswith('0x')) and (len(DecDefaultValue) > 1) and DecDefaultValue.lstrip('0'):\n                        DecDefaultValue = DecDefaultValue.lstrip('0')\n                    DecDefaultValueNumber = int(DecDefaultValue.strip(), 0)\n                    DecMatch = DecDefaultValueNumber == PcdValueNumber\n                if InfDefaultValue is None:\n                    InfMatch = True\n                else:\n                    if InfDefaultValue.startswith('0') and (not InfDefaultValue.lower().startswith('0x')) and (len(InfDefaultValue) > 1) and InfDefaultValue.lstrip('0'):\n                        InfDefaultValue = InfDefaultValue.lstrip('0')\n                    InfDefaultValueNumber = int(InfDefaultValue.strip(), 0)\n                    InfMatch = InfDefaultValueNumber == PcdValueNumber\n                if DscDefaultValue is None:\n                    DscMatch = True\n                else:\n                    if DscDefaultValue.startswith('0') and (not DscDefaultValue.lower().startswith('0x')) and (len(DscDefaultValue) > 1) and DscDefaultValue.lstrip('0'):\n                        DscDefaultValue = DscDefaultValue.lstrip('0')\n                    DscDefaultValueNumber = int(DscDefaultValue.strip(), 0)\n                    DscMatch = DscDefaultValueNumber == PcdValueNumber\n            else:\n                if DecDefaultValue is None:\n                    DecMatch = True\n                else:\n                    DecMatch = DecDefaultValue.strip() == PcdValue.strip()\n                if InfDefaultValue is None:\n                    InfMatch = True\n                else:\n                    InfMatch = InfDefaultValue.strip() == PcdValue.strip()\n                if DscDefaultValue is None:\n                    DscMatch = True\n                else:\n                    DscMatch = DscDefaultValue.strip() == PcdValue.strip()\n            IsStructure = False\n            if self.IsStructurePcd(Pcd.TokenCName, Pcd.TokenSpaceGuidCName):\n                IsStructure = True\n                if TypeName in ('DYNVPD', 'DEXVPD'):\n                    SkuInfoList = Pcd.SkuInfoList\n                Pcd = GlobalData.gStructurePcd[self.Arch][Pcd.TokenCName, Pcd.TokenSpaceGuidCName]\n                if ModulePcdSet and ModulePcdSet.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Type)):\n                    (InfDefaultValue, PcdComponentValue) = ModulePcdSet[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Type]\n                    DscDefaultValBak = Pcd.DefaultValue\n                    Pcd.DefaultValue = PcdComponentValue\n                Pcd.DatumType = Pcd.StructName\n                if TypeName in ('DYNVPD', 'DEXVPD'):\n                    Pcd.SkuInfoList = SkuInfoList\n                if Pcd.PcdValueFromComm or Pcd.PcdFieldValueFromComm:\n                    BuildOptionMatch = True\n                    DecMatch = False\n                elif Pcd.PcdValueFromFdf or Pcd.PcdFieldValueFromFdf:\n                    DscDefaultValue = True\n                    DscMatch = True\n                    DecMatch = False\n                elif Pcd.Type in PCD_DYNAMIC_TYPE_SET | PCD_DYNAMIC_EX_TYPE_SET:\n                    DscOverride = False\n                    if Pcd.DefaultFromDSC:\n                        DscOverride = True\n                    else:\n                        DictLen = 0\n                        for item in Pcd.SkuOverrideValues:\n                            DictLen += len(Pcd.SkuOverrideValues[item])\n                        if not DictLen:\n                            DscOverride = False\n                        elif not Pcd.SkuInfoList:\n                            OverrideValues = Pcd.SkuOverrideValues\n                            if OverrideValues:\n                                for Data in OverrideValues.values():\n                                    Struct = list(Data.values())\n                                    if Struct:\n                                        DscOverride = self.ParseStruct(Struct[0])\n                                        break\n                        else:\n                            SkuList = sorted(Pcd.SkuInfoList.keys())\n                            for Sku in SkuList:\n                                SkuInfo = Pcd.SkuInfoList[Sku]\n                                if SkuInfo.DefaultStoreDict:\n                                    DefaultStoreList = sorted(SkuInfo.DefaultStoreDict.keys())\n                                    for DefaultStore in DefaultStoreList:\n                                        OverrideValues = Pcd.SkuOverrideValues.get(Sku)\n                                        if OverrideValues:\n                                            DscOverride = self.ParseStruct(OverrideValues[DefaultStore])\n                                            if DscOverride:\n                                                break\n                                if DscOverride:\n                                    break\n                    if DscOverride:\n                        DscDefaultValue = True\n                        DscMatch = True\n                        DecMatch = False\n                    else:\n                        DecMatch = True\n                elif Pcd.DscRawValue or (ModuleGuid and ModuleGuid.replace('-', 'S') in Pcd.PcdValueFromComponents):\n                    DscDefaultValue = True\n                    DscMatch = True\n                    DecMatch = False\n                else:\n                    DscDefaultValue = False\n                    DecMatch = True\n            if Pcd.DatumType == 'BOOLEAN':\n                if DscDefaultValue:\n                    DscDefaultValue = str(int(DscDefaultValue, 0))\n                if DecDefaultValue:\n                    DecDefaultValue = str(int(DecDefaultValue, 0))\n                if InfDefaultValue:\n                    InfDefaultValue = str(int(InfDefaultValue, 0))\n                if Pcd.DefaultValue:\n                    Pcd.DefaultValue = str(int(Pcd.DefaultValue, 0))\n            if DecMatch:\n                self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '  ')\n            elif InfDefaultValue and InfMatch:\n                self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '*M')\n            elif BuildOptionMatch:\n                self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '*B')\n            elif PcdComponentValue:\n                self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, PcdComponentValue, DecMatch, DecDefaultValue, '*M', ModuleGuid)\n            elif DscDefaultValue and DscMatch:\n                if (Pcd.TokenCName, Key, Field) in self.FdfPcdSet:\n                    self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '*F')\n                else:\n                    self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '*P')\n            if ModulePcdSet is None:\n                if IsStructure:\n                    continue\n                if not TypeName in ('PATCH', 'FLAG', 'FIXED'):\n                    continue\n                if not BuildOptionMatch:\n                    ModuleOverride = self.ModulePcdOverride.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName), {})\n                    for ModulePath in ModuleOverride:\n                        ModuleDefault = ModuleOverride[ModulePath]\n                        if Pcd.DatumType in TAB_PCD_NUMERIC_TYPES:\n                            if ModuleDefault.startswith('0') and (not ModuleDefault.lower().startswith('0x')) and (len(ModuleDefault) > 1) and ModuleDefault.lstrip('0'):\n                                ModuleDefault = ModuleDefault.lstrip('0')\n                            ModulePcdDefaultValueNumber = int(ModuleDefault.strip(), 0)\n                            Match = ModulePcdDefaultValueNumber == PcdValueNumber\n                            if Pcd.DatumType == 'BOOLEAN':\n                                ModuleDefault = str(ModulePcdDefaultValueNumber)\n                        else:\n                            Match = ModuleDefault.strip() == PcdValue.strip()\n                        if Match:\n                            continue\n                        (IsByteArray, ArrayList) = ByteArrayForamt(ModuleDefault.strip())\n                        if IsByteArray:\n                            FileWrite(File, ' *M     %-*s = %s' % (self.MaxLen + 15, ModulePath, '{'))\n                            for Array in ArrayList:\n                                FileWrite(File, Array)\n                        else:\n                            Value = ModuleDefault.strip()\n                            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                                if Value.startswith(('0x', '0X')):\n                                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                                else:\n                                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                            FileWrite(File, ' *M     %-*s = %s' % (self.MaxLen + 15, ModulePath, Value))\n    if ModulePcdSet is None:\n        FileWrite(File, gSectionEnd)\n    elif not ReportSubType and ModulePcdSet:\n        FileWrite(File, gSubSectionEnd)",
            "def GenerateReportDetail(self, File, ModulePcdSet, ReportSubType=0, ModuleGuid=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    PcdDict = self.AllPcds\n    if ReportSubType == 1:\n        PcdDict = self.ConditionalPcds\n    elif ReportSubType == 2:\n        PcdDict = self.UnusedPcds\n    if not ModulePcdSet:\n        FileWrite(File, gSectionStart)\n        if ReportSubType == 1:\n            FileWrite(File, 'Conditional Directives used by the build system')\n        elif ReportSubType == 2:\n            FileWrite(File, 'PCDs not used by modules or in conditional directives')\n        else:\n            FileWrite(File, 'Platform Configuration Database Report')\n        FileWrite(File, '  *B  - PCD override in the build option')\n        FileWrite(File, '  *P  - Platform scoped PCD override in DSC file')\n        FileWrite(File, '  *F  - Platform scoped PCD override in FDF file')\n        if not ReportSubType:\n            FileWrite(File, '  *M  - Module scoped PCD override')\n        FileWrite(File, gSectionSep)\n    elif not ReportSubType and ModulePcdSet:\n        FileWrite(File, gSubSectionStart)\n        FileWrite(File, TAB_BRG_PCD)\n        FileWrite(File, gSubSectionSep)\n    AllPcdDict = {}\n    for Key in PcdDict:\n        AllPcdDict[Key] = {}\n        for Type in PcdDict[Key]:\n            for Pcd in PcdDict[Key][Type]:\n                AllPcdDict[Key][Pcd.TokenCName, Type] = Pcd\n    for Key in sorted(AllPcdDict):\n        First = True\n        for (PcdTokenCName, Type) in sorted(AllPcdDict[Key]):\n            Pcd = AllPcdDict[Key][PcdTokenCName, Type]\n            (TypeName, DecType) = gPcdTypeMap.get(Type, ('', Type))\n            MixedPcdFlag = False\n            if GlobalData.MixedPcd:\n                for PcdKey in GlobalData.MixedPcd:\n                    if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdKey]:\n                        PcdTokenCName = PcdKey[0]\n                        MixedPcdFlag = True\n                if MixedPcdFlag and (not ModulePcdSet):\n                    continue\n            DecDefaultValue = self.DecPcdDefault.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName, DecType))\n            DscDefaultValue = self.DscPcdDefault.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName))\n            DscDefaultValBak = DscDefaultValue\n            Field = ''\n            for (CName, Guid, Field) in self.FdfPcdSet:\n                if CName == PcdTokenCName and Guid == Key:\n                    DscDefaultValue = self.FdfPcdSet[CName, Guid, Field]\n                    break\n            if DscDefaultValue != DscDefaultValBak:\n                try:\n                    DscDefaultValue = ValueExpressionEx(DscDefaultValue, Pcd.DatumType, self._GuidDict)(True)\n                except BadExpression as DscDefaultValue:\n                    EdkLogger.error('BuildReport', FORMAT_INVALID, 'PCD Value: %s, Type: %s' % (DscDefaultValue, Pcd.DatumType))\n            InfDefaultValue = None\n            PcdValue = DecDefaultValue\n            if DscDefaultValue:\n                PcdValue = DscDefaultValue\n            if not self.IsStructurePcd(Pcd.TokenCName, Pcd.TokenSpaceGuidCName):\n                Pcd.DefaultValue = PcdValue\n            PcdComponentValue = None\n            if ModulePcdSet is not None:\n                if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Type) not in ModulePcdSet:\n                    continue\n                (InfDefaultValue, PcdComponentValue) = ModulePcdSet[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Type]\n                PcdValue = PcdComponentValue\n                if not self.IsStructurePcd(Pcd.TokenCName, Pcd.TokenSpaceGuidCName):\n                    Pcd.DefaultValue = PcdValue\n                if InfDefaultValue:\n                    try:\n                        InfDefaultValue = ValueExpressionEx(InfDefaultValue, Pcd.DatumType, self._GuidDict)(True)\n                    except BadExpression as InfDefaultValue:\n                        EdkLogger.error('BuildReport', FORMAT_INVALID, 'PCD Value: %s, Type: %s' % (InfDefaultValue, Pcd.DatumType))\n                if InfDefaultValue == '':\n                    InfDefaultValue = None\n            BuildOptionMatch = False\n            if GlobalData.BuildOptionPcd:\n                for pcd in GlobalData.BuildOptionPcd:\n                    if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) == (pcd[0], pcd[1]):\n                        if pcd[2]:\n                            continue\n                        PcdValue = pcd[3]\n                        if not self.IsStructurePcd(Pcd.TokenCName, Pcd.TokenSpaceGuidCName):\n                            Pcd.DefaultValue = PcdValue\n                        BuildOptionMatch = True\n                        break\n            if First:\n                if ModulePcdSet is None:\n                    FileWrite(File, '')\n                FileWrite(File, Key)\n                First = False\n            if Pcd.DatumType in TAB_PCD_NUMERIC_TYPES:\n                if PcdValue.startswith('0') and (not PcdValue.lower().startswith('0x')) and (len(PcdValue) > 1) and PcdValue.lstrip('0'):\n                    PcdValue = PcdValue.lstrip('0')\n                PcdValueNumber = int(PcdValue.strip(), 0)\n                if DecDefaultValue is None:\n                    DecMatch = True\n                else:\n                    if DecDefaultValue.startswith('0') and (not DecDefaultValue.lower().startswith('0x')) and (len(DecDefaultValue) > 1) and DecDefaultValue.lstrip('0'):\n                        DecDefaultValue = DecDefaultValue.lstrip('0')\n                    DecDefaultValueNumber = int(DecDefaultValue.strip(), 0)\n                    DecMatch = DecDefaultValueNumber == PcdValueNumber\n                if InfDefaultValue is None:\n                    InfMatch = True\n                else:\n                    if InfDefaultValue.startswith('0') and (not InfDefaultValue.lower().startswith('0x')) and (len(InfDefaultValue) > 1) and InfDefaultValue.lstrip('0'):\n                        InfDefaultValue = InfDefaultValue.lstrip('0')\n                    InfDefaultValueNumber = int(InfDefaultValue.strip(), 0)\n                    InfMatch = InfDefaultValueNumber == PcdValueNumber\n                if DscDefaultValue is None:\n                    DscMatch = True\n                else:\n                    if DscDefaultValue.startswith('0') and (not DscDefaultValue.lower().startswith('0x')) and (len(DscDefaultValue) > 1) and DscDefaultValue.lstrip('0'):\n                        DscDefaultValue = DscDefaultValue.lstrip('0')\n                    DscDefaultValueNumber = int(DscDefaultValue.strip(), 0)\n                    DscMatch = DscDefaultValueNumber == PcdValueNumber\n            else:\n                if DecDefaultValue is None:\n                    DecMatch = True\n                else:\n                    DecMatch = DecDefaultValue.strip() == PcdValue.strip()\n                if InfDefaultValue is None:\n                    InfMatch = True\n                else:\n                    InfMatch = InfDefaultValue.strip() == PcdValue.strip()\n                if DscDefaultValue is None:\n                    DscMatch = True\n                else:\n                    DscMatch = DscDefaultValue.strip() == PcdValue.strip()\n            IsStructure = False\n            if self.IsStructurePcd(Pcd.TokenCName, Pcd.TokenSpaceGuidCName):\n                IsStructure = True\n                if TypeName in ('DYNVPD', 'DEXVPD'):\n                    SkuInfoList = Pcd.SkuInfoList\n                Pcd = GlobalData.gStructurePcd[self.Arch][Pcd.TokenCName, Pcd.TokenSpaceGuidCName]\n                if ModulePcdSet and ModulePcdSet.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Type)):\n                    (InfDefaultValue, PcdComponentValue) = ModulePcdSet[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Type]\n                    DscDefaultValBak = Pcd.DefaultValue\n                    Pcd.DefaultValue = PcdComponentValue\n                Pcd.DatumType = Pcd.StructName\n                if TypeName in ('DYNVPD', 'DEXVPD'):\n                    Pcd.SkuInfoList = SkuInfoList\n                if Pcd.PcdValueFromComm or Pcd.PcdFieldValueFromComm:\n                    BuildOptionMatch = True\n                    DecMatch = False\n                elif Pcd.PcdValueFromFdf or Pcd.PcdFieldValueFromFdf:\n                    DscDefaultValue = True\n                    DscMatch = True\n                    DecMatch = False\n                elif Pcd.Type in PCD_DYNAMIC_TYPE_SET | PCD_DYNAMIC_EX_TYPE_SET:\n                    DscOverride = False\n                    if Pcd.DefaultFromDSC:\n                        DscOverride = True\n                    else:\n                        DictLen = 0\n                        for item in Pcd.SkuOverrideValues:\n                            DictLen += len(Pcd.SkuOverrideValues[item])\n                        if not DictLen:\n                            DscOverride = False\n                        elif not Pcd.SkuInfoList:\n                            OverrideValues = Pcd.SkuOverrideValues\n                            if OverrideValues:\n                                for Data in OverrideValues.values():\n                                    Struct = list(Data.values())\n                                    if Struct:\n                                        DscOverride = self.ParseStruct(Struct[0])\n                                        break\n                        else:\n                            SkuList = sorted(Pcd.SkuInfoList.keys())\n                            for Sku in SkuList:\n                                SkuInfo = Pcd.SkuInfoList[Sku]\n                                if SkuInfo.DefaultStoreDict:\n                                    DefaultStoreList = sorted(SkuInfo.DefaultStoreDict.keys())\n                                    for DefaultStore in DefaultStoreList:\n                                        OverrideValues = Pcd.SkuOverrideValues.get(Sku)\n                                        if OverrideValues:\n                                            DscOverride = self.ParseStruct(OverrideValues[DefaultStore])\n                                            if DscOverride:\n                                                break\n                                if DscOverride:\n                                    break\n                    if DscOverride:\n                        DscDefaultValue = True\n                        DscMatch = True\n                        DecMatch = False\n                    else:\n                        DecMatch = True\n                elif Pcd.DscRawValue or (ModuleGuid and ModuleGuid.replace('-', 'S') in Pcd.PcdValueFromComponents):\n                    DscDefaultValue = True\n                    DscMatch = True\n                    DecMatch = False\n                else:\n                    DscDefaultValue = False\n                    DecMatch = True\n            if Pcd.DatumType == 'BOOLEAN':\n                if DscDefaultValue:\n                    DscDefaultValue = str(int(DscDefaultValue, 0))\n                if DecDefaultValue:\n                    DecDefaultValue = str(int(DecDefaultValue, 0))\n                if InfDefaultValue:\n                    InfDefaultValue = str(int(InfDefaultValue, 0))\n                if Pcd.DefaultValue:\n                    Pcd.DefaultValue = str(int(Pcd.DefaultValue, 0))\n            if DecMatch:\n                self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '  ')\n            elif InfDefaultValue and InfMatch:\n                self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '*M')\n            elif BuildOptionMatch:\n                self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '*B')\n            elif PcdComponentValue:\n                self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, PcdComponentValue, DecMatch, DecDefaultValue, '*M', ModuleGuid)\n            elif DscDefaultValue and DscMatch:\n                if (Pcd.TokenCName, Key, Field) in self.FdfPcdSet:\n                    self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '*F')\n                else:\n                    self.PrintPcdValue(File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValBak, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, '*P')\n            if ModulePcdSet is None:\n                if IsStructure:\n                    continue\n                if not TypeName in ('PATCH', 'FLAG', 'FIXED'):\n                    continue\n                if not BuildOptionMatch:\n                    ModuleOverride = self.ModulePcdOverride.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName), {})\n                    for ModulePath in ModuleOverride:\n                        ModuleDefault = ModuleOverride[ModulePath]\n                        if Pcd.DatumType in TAB_PCD_NUMERIC_TYPES:\n                            if ModuleDefault.startswith('0') and (not ModuleDefault.lower().startswith('0x')) and (len(ModuleDefault) > 1) and ModuleDefault.lstrip('0'):\n                                ModuleDefault = ModuleDefault.lstrip('0')\n                            ModulePcdDefaultValueNumber = int(ModuleDefault.strip(), 0)\n                            Match = ModulePcdDefaultValueNumber == PcdValueNumber\n                            if Pcd.DatumType == 'BOOLEAN':\n                                ModuleDefault = str(ModulePcdDefaultValueNumber)\n                        else:\n                            Match = ModuleDefault.strip() == PcdValue.strip()\n                        if Match:\n                            continue\n                        (IsByteArray, ArrayList) = ByteArrayForamt(ModuleDefault.strip())\n                        if IsByteArray:\n                            FileWrite(File, ' *M     %-*s = %s' % (self.MaxLen + 15, ModulePath, '{'))\n                            for Array in ArrayList:\n                                FileWrite(File, Array)\n                        else:\n                            Value = ModuleDefault.strip()\n                            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                                if Value.startswith(('0x', '0X')):\n                                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                                else:\n                                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                            FileWrite(File, ' *M     %-*s = %s' % (self.MaxLen + 15, ModulePath, Value))\n    if ModulePcdSet is None:\n        FileWrite(File, gSectionEnd)\n    elif not ReportSubType and ModulePcdSet:\n        FileWrite(File, gSubSectionEnd)"
        ]
    },
    {
        "func_name": "ParseStruct",
        "original": "def ParseStruct(self, struct):\n    HasDscOverride = False\n    if struct:\n        for (_, Values) in list(struct.items()):\n            for (Key, value) in Values.items():\n                if value[1] and value[1].endswith('.dsc'):\n                    HasDscOverride = True\n                    break\n            if HasDscOverride == True:\n                break\n    return HasDscOverride",
        "mutated": [
            "def ParseStruct(self, struct):\n    if False:\n        i = 10\n    HasDscOverride = False\n    if struct:\n        for (_, Values) in list(struct.items()):\n            for (Key, value) in Values.items():\n                if value[1] and value[1].endswith('.dsc'):\n                    HasDscOverride = True\n                    break\n            if HasDscOverride == True:\n                break\n    return HasDscOverride",
            "def ParseStruct(self, struct):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    HasDscOverride = False\n    if struct:\n        for (_, Values) in list(struct.items()):\n            for (Key, value) in Values.items():\n                if value[1] and value[1].endswith('.dsc'):\n                    HasDscOverride = True\n                    break\n            if HasDscOverride == True:\n                break\n    return HasDscOverride",
            "def ParseStruct(self, struct):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    HasDscOverride = False\n    if struct:\n        for (_, Values) in list(struct.items()):\n            for (Key, value) in Values.items():\n                if value[1] and value[1].endswith('.dsc'):\n                    HasDscOverride = True\n                    break\n            if HasDscOverride == True:\n                break\n    return HasDscOverride",
            "def ParseStruct(self, struct):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    HasDscOverride = False\n    if struct:\n        for (_, Values) in list(struct.items()):\n            for (Key, value) in Values.items():\n                if value[1] and value[1].endswith('.dsc'):\n                    HasDscOverride = True\n                    break\n            if HasDscOverride == True:\n                break\n    return HasDscOverride",
            "def ParseStruct(self, struct):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    HasDscOverride = False\n    if struct:\n        for (_, Values) in list(struct.items()):\n            for (Key, value) in Values.items():\n                if value[1] and value[1].endswith('.dsc'):\n                    HasDscOverride = True\n                    break\n            if HasDscOverride == True:\n                break\n    return HasDscOverride"
        ]
    },
    {
        "func_name": "PrintPcdDefault",
        "original": "def PrintPcdDefault(self, File, Pcd, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue):\n    if not DscMatch and DscDefaultValue is not None:\n        Value = DscDefaultValue.strip()\n        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n        if IsByteArray:\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'DSC DEFAULT', '{'))\n            for Array in ArrayList:\n                FileWrite(File, Array)\n        else:\n            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                if Value.startswith(('0x', '0X')):\n                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                else:\n                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'DSC DEFAULT', Value))\n    if not InfMatch and InfDefaultValue is not None:\n        Value = InfDefaultValue.strip()\n        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n        if IsByteArray:\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'INF DEFAULT', '{'))\n            for Array in ArrayList:\n                FileWrite(File, Array)\n        else:\n            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                if Value.startswith(('0x', '0X')):\n                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                else:\n                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'INF DEFAULT', Value))\n    if not DecMatch and DecDefaultValue is not None:\n        Value = DecDefaultValue.strip()\n        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n        if IsByteArray:\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'DEC DEFAULT', '{'))\n            for Array in ArrayList:\n                FileWrite(File, Array)\n        else:\n            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                if Value.startswith(('0x', '0X')):\n                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                else:\n                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'DEC DEFAULT', Value))\n        if IsStructure:\n            for filedvalues in Pcd.DefaultValues.values():\n                self.PrintStructureInfo(File, filedvalues)\n    if DecMatch and IsStructure:\n        for filedvalues in Pcd.DefaultValues.values():\n            self.PrintStructureInfo(File, filedvalues)",
        "mutated": [
            "def PrintPcdDefault(self, File, Pcd, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue):\n    if False:\n        i = 10\n    if not DscMatch and DscDefaultValue is not None:\n        Value = DscDefaultValue.strip()\n        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n        if IsByteArray:\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'DSC DEFAULT', '{'))\n            for Array in ArrayList:\n                FileWrite(File, Array)\n        else:\n            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                if Value.startswith(('0x', '0X')):\n                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                else:\n                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'DSC DEFAULT', Value))\n    if not InfMatch and InfDefaultValue is not None:\n        Value = InfDefaultValue.strip()\n        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n        if IsByteArray:\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'INF DEFAULT', '{'))\n            for Array in ArrayList:\n                FileWrite(File, Array)\n        else:\n            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                if Value.startswith(('0x', '0X')):\n                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                else:\n                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'INF DEFAULT', Value))\n    if not DecMatch and DecDefaultValue is not None:\n        Value = DecDefaultValue.strip()\n        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n        if IsByteArray:\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'DEC DEFAULT', '{'))\n            for Array in ArrayList:\n                FileWrite(File, Array)\n        else:\n            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                if Value.startswith(('0x', '0X')):\n                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                else:\n                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'DEC DEFAULT', Value))\n        if IsStructure:\n            for filedvalues in Pcd.DefaultValues.values():\n                self.PrintStructureInfo(File, filedvalues)\n    if DecMatch and IsStructure:\n        for filedvalues in Pcd.DefaultValues.values():\n            self.PrintStructureInfo(File, filedvalues)",
            "def PrintPcdDefault(self, File, Pcd, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not DscMatch and DscDefaultValue is not None:\n        Value = DscDefaultValue.strip()\n        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n        if IsByteArray:\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'DSC DEFAULT', '{'))\n            for Array in ArrayList:\n                FileWrite(File, Array)\n        else:\n            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                if Value.startswith(('0x', '0X')):\n                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                else:\n                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'DSC DEFAULT', Value))\n    if not InfMatch and InfDefaultValue is not None:\n        Value = InfDefaultValue.strip()\n        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n        if IsByteArray:\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'INF DEFAULT', '{'))\n            for Array in ArrayList:\n                FileWrite(File, Array)\n        else:\n            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                if Value.startswith(('0x', '0X')):\n                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                else:\n                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'INF DEFAULT', Value))\n    if not DecMatch and DecDefaultValue is not None:\n        Value = DecDefaultValue.strip()\n        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n        if IsByteArray:\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'DEC DEFAULT', '{'))\n            for Array in ArrayList:\n                FileWrite(File, Array)\n        else:\n            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                if Value.startswith(('0x', '0X')):\n                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                else:\n                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'DEC DEFAULT', Value))\n        if IsStructure:\n            for filedvalues in Pcd.DefaultValues.values():\n                self.PrintStructureInfo(File, filedvalues)\n    if DecMatch and IsStructure:\n        for filedvalues in Pcd.DefaultValues.values():\n            self.PrintStructureInfo(File, filedvalues)",
            "def PrintPcdDefault(self, File, Pcd, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not DscMatch and DscDefaultValue is not None:\n        Value = DscDefaultValue.strip()\n        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n        if IsByteArray:\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'DSC DEFAULT', '{'))\n            for Array in ArrayList:\n                FileWrite(File, Array)\n        else:\n            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                if Value.startswith(('0x', '0X')):\n                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                else:\n                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'DSC DEFAULT', Value))\n    if not InfMatch and InfDefaultValue is not None:\n        Value = InfDefaultValue.strip()\n        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n        if IsByteArray:\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'INF DEFAULT', '{'))\n            for Array in ArrayList:\n                FileWrite(File, Array)\n        else:\n            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                if Value.startswith(('0x', '0X')):\n                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                else:\n                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'INF DEFAULT', Value))\n    if not DecMatch and DecDefaultValue is not None:\n        Value = DecDefaultValue.strip()\n        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n        if IsByteArray:\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'DEC DEFAULT', '{'))\n            for Array in ArrayList:\n                FileWrite(File, Array)\n        else:\n            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                if Value.startswith(('0x', '0X')):\n                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                else:\n                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'DEC DEFAULT', Value))\n        if IsStructure:\n            for filedvalues in Pcd.DefaultValues.values():\n                self.PrintStructureInfo(File, filedvalues)\n    if DecMatch and IsStructure:\n        for filedvalues in Pcd.DefaultValues.values():\n            self.PrintStructureInfo(File, filedvalues)",
            "def PrintPcdDefault(self, File, Pcd, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not DscMatch and DscDefaultValue is not None:\n        Value = DscDefaultValue.strip()\n        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n        if IsByteArray:\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'DSC DEFAULT', '{'))\n            for Array in ArrayList:\n                FileWrite(File, Array)\n        else:\n            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                if Value.startswith(('0x', '0X')):\n                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                else:\n                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'DSC DEFAULT', Value))\n    if not InfMatch and InfDefaultValue is not None:\n        Value = InfDefaultValue.strip()\n        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n        if IsByteArray:\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'INF DEFAULT', '{'))\n            for Array in ArrayList:\n                FileWrite(File, Array)\n        else:\n            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                if Value.startswith(('0x', '0X')):\n                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                else:\n                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'INF DEFAULT', Value))\n    if not DecMatch and DecDefaultValue is not None:\n        Value = DecDefaultValue.strip()\n        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n        if IsByteArray:\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'DEC DEFAULT', '{'))\n            for Array in ArrayList:\n                FileWrite(File, Array)\n        else:\n            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                if Value.startswith(('0x', '0X')):\n                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                else:\n                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'DEC DEFAULT', Value))\n        if IsStructure:\n            for filedvalues in Pcd.DefaultValues.values():\n                self.PrintStructureInfo(File, filedvalues)\n    if DecMatch and IsStructure:\n        for filedvalues in Pcd.DefaultValues.values():\n            self.PrintStructureInfo(File, filedvalues)",
            "def PrintPcdDefault(self, File, Pcd, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not DscMatch and DscDefaultValue is not None:\n        Value = DscDefaultValue.strip()\n        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n        if IsByteArray:\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'DSC DEFAULT', '{'))\n            for Array in ArrayList:\n                FileWrite(File, Array)\n        else:\n            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                if Value.startswith(('0x', '0X')):\n                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                else:\n                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'DSC DEFAULT', Value))\n    if not InfMatch and InfDefaultValue is not None:\n        Value = InfDefaultValue.strip()\n        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n        if IsByteArray:\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'INF DEFAULT', '{'))\n            for Array in ArrayList:\n                FileWrite(File, Array)\n        else:\n            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                if Value.startswith(('0x', '0X')):\n                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                else:\n                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'INF DEFAULT', Value))\n    if not DecMatch and DecDefaultValue is not None:\n        Value = DecDefaultValue.strip()\n        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n        if IsByteArray:\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'DEC DEFAULT', '{'))\n            for Array in ArrayList:\n                FileWrite(File, Array)\n        else:\n            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                if Value.startswith(('0x', '0X')):\n                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                else:\n                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n            FileWrite(File, '    %*s = %s' % (self.MaxLen + 19, 'DEC DEFAULT', Value))\n        if IsStructure:\n            for filedvalues in Pcd.DefaultValues.values():\n                self.PrintStructureInfo(File, filedvalues)\n    if DecMatch and IsStructure:\n        for filedvalues in Pcd.DefaultValues.values():\n            self.PrintStructureInfo(File, filedvalues)"
        ]
    },
    {
        "func_name": "PrintPcdValue",
        "original": "def PrintPcdValue(self, File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, Flag='  ', ModuleGuid=None):\n    if not Pcd.SkuInfoList:\n        Value = Pcd.DefaultValue\n        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n        if IsByteArray:\n            FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '{'))\n            for Array in ArrayList:\n                FileWrite(File, Array)\n        else:\n            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                if Value.startswith('0') and (not Value.lower().startswith('0x')) and (len(Value) > 1) and Value.lstrip('0'):\n                    Value = Value.lstrip('0')\n                if Value.startswith(('0x', '0X')):\n                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                else:\n                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n            FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', Value))\n        if IsStructure:\n            FiledOverrideFlag = False\n            if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.gPcdSkuOverrides:\n                OverrideValues = GlobalData.gPcdSkuOverrides[Pcd.TokenCName, Pcd.TokenSpaceGuidCName]\n            else:\n                OverrideValues = Pcd.SkuOverrideValues\n            FieldOverrideValues = None\n            if OverrideValues:\n                for Data in OverrideValues.values():\n                    Struct = list(Data.values())\n                    if Struct:\n                        FieldOverrideValues = Struct[0]\n                        FiledOverrideFlag = True\n                        break\n            if Pcd.PcdFiledValueFromDscComponent and ModuleGuid and (ModuleGuid.replace('-', 'S') in Pcd.PcdFiledValueFromDscComponent):\n                FieldOverrideValues = Pcd.PcdFiledValueFromDscComponent[ModuleGuid.replace('-', 'S')]\n            if FieldOverrideValues:\n                OverrideFieldStruct = self.OverrideFieldValue(Pcd, FieldOverrideValues)\n                self.PrintStructureInfo(File, OverrideFieldStruct)\n            if not FiledOverrideFlag and (Pcd.PcdFieldValueFromComm or Pcd.PcdFieldValueFromFdf):\n                OverrideFieldStruct = self.OverrideFieldValue(Pcd, {})\n                self.PrintStructureInfo(File, OverrideFieldStruct)\n        self.PrintPcdDefault(File, Pcd, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue)\n    else:\n        FirstPrint = True\n        SkuList = sorted(Pcd.SkuInfoList.keys())\n        for Sku in SkuList:\n            SkuInfo = Pcd.SkuInfoList[Sku]\n            SkuIdName = SkuInfo.SkuIdName\n            if TypeName in ('DYNHII', 'DEXHII'):\n                if SkuInfo.DefaultStoreDict:\n                    DefaultStoreList = sorted(SkuInfo.DefaultStoreDict.keys())\n                    for DefaultStore in DefaultStoreList:\n                        Value = SkuInfo.DefaultStoreDict[DefaultStore]\n                        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n                        if Pcd.DatumType == 'BOOLEAN':\n                            Value = str(int(Value, 0))\n                        if FirstPrint:\n                            FirstPrint = False\n                            if IsByteArray:\n                                if self.DefaultStoreSingle and self.SkuSingle:\n                                    FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '{'))\n                                elif self.DefaultStoreSingle and (not self.SkuSingle):\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '{'))\n                                elif not self.DefaultStoreSingle and self.SkuSingle:\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + DefaultStore + ')', '{'))\n                                else:\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '(' + DefaultStore + ')', '{'))\n                                for Array in ArrayList:\n                                    FileWrite(File, Array)\n                            else:\n                                if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                                    if Value.startswith(('0x', '0X')):\n                                        Value = '{} ({:d})'.format(Value, int(Value, 0))\n                                    else:\n                                        Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                                if self.DefaultStoreSingle and self.SkuSingle:\n                                    FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', Value))\n                                elif self.DefaultStoreSingle and (not self.SkuSingle):\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', Value))\n                                elif not self.DefaultStoreSingle and self.SkuSingle:\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + DefaultStore + ')', Value))\n                                else:\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '(' + DefaultStore + ')', Value))\n                        elif IsByteArray:\n                            if self.DefaultStoreSingle and self.SkuSingle:\n                                FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '{'))\n                            elif self.DefaultStoreSingle and (not self.SkuSingle):\n                                FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '{'))\n                            elif not self.DefaultStoreSingle and self.SkuSingle:\n                                FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + DefaultStore + ')', '{'))\n                            else:\n                                FileWrite(File, ' %-*s   : %6s %10s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '(' + DefaultStore + ')', '{'))\n                            for Array in ArrayList:\n                                FileWrite(File, Array)\n                        else:\n                            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                                if Value.startswith(('0x', '0X')):\n                                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                                else:\n                                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                            if self.DefaultStoreSingle and self.SkuSingle:\n                                FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', Value))\n                            elif self.DefaultStoreSingle and (not self.SkuSingle):\n                                FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', Value))\n                            elif not self.DefaultStoreSingle and self.SkuSingle:\n                                FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + DefaultStore + ')', Value))\n                            else:\n                                FileWrite(File, ' %-*s   : %6s %10s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '(' + DefaultStore + ')', Value))\n                        FileWrite(File, '%*s: %s: %s' % (self.MaxLen + 4, SkuInfo.VariableGuid, SkuInfo.VariableName, SkuInfo.VariableOffset))\n                        if IsStructure:\n                            OverrideValues = Pcd.SkuOverrideValues.get(Sku)\n                            if OverrideValues:\n                                OverrideFieldStruct = self.OverrideFieldValue(Pcd, OverrideValues[DefaultStore])\n                                self.PrintStructureInfo(File, OverrideFieldStruct)\n                        self.PrintPcdDefault(File, Pcd, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue)\n            else:\n                Value = SkuInfo.DefaultValue\n                (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n                if Pcd.DatumType == 'BOOLEAN':\n                    Value = str(int(Value, 0))\n                if FirstPrint:\n                    FirstPrint = False\n                    if IsByteArray:\n                        if self.SkuSingle:\n                            FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '{'))\n                        else:\n                            FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '{'))\n                        for Array in ArrayList:\n                            FileWrite(File, Array)\n                    else:\n                        if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                            if Value.startswith(('0x', '0X')):\n                                Value = '{} ({:d})'.format(Value, int(Value, 0))\n                            else:\n                                Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                        if self.SkuSingle:\n                            FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', Value))\n                        else:\n                            FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', Value))\n                elif IsByteArray:\n                    if self.SkuSingle:\n                        FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '{'))\n                    else:\n                        FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '{'))\n                    for Array in ArrayList:\n                        FileWrite(File, Array)\n                else:\n                    if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                        if Value.startswith(('0x', '0X')):\n                            Value = '{} ({:d})'.format(Value, int(Value, 0))\n                        else:\n                            Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                    if self.SkuSingle:\n                        FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', Value))\n                    else:\n                        FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', Value))\n                if TypeName in ('DYNVPD', 'DEXVPD'):\n                    FileWrite(File, '%*s' % (self.MaxLen + 4, SkuInfo.VpdOffset))\n                    VPDPcdItem = (Pcd.TokenSpaceGuidCName + '.' + PcdTokenCName, SkuIdName, SkuInfo.VpdOffset, Pcd.MaxDatumSize, SkuInfo.DefaultValue)\n                    if VPDPcdItem not in VPDPcdList:\n                        PcdGuidList = self.UnusedPcds.get(Pcd.TokenSpaceGuidCName)\n                        if PcdGuidList:\n                            PcdList = PcdGuidList.get(Pcd.Type)\n                            if not PcdList:\n                                VPDPcdList.append(VPDPcdItem)\n                            for VpdPcd in PcdList:\n                                if PcdTokenCName == VpdPcd.TokenCName:\n                                    break\n                            else:\n                                VPDPcdList.append(VPDPcdItem)\n                if IsStructure:\n                    FiledOverrideFlag = False\n                    OverrideValues = Pcd.SkuOverrideValues.get(Sku)\n                    if OverrideValues:\n                        Keys = list(OverrideValues.keys())\n                        OverrideFieldStruct = self.OverrideFieldValue(Pcd, OverrideValues[Keys[0]])\n                        self.PrintStructureInfo(File, OverrideFieldStruct)\n                        FiledOverrideFlag = True\n                    if not FiledOverrideFlag and (Pcd.PcdFieldValueFromComm or Pcd.PcdFieldValueFromFdf):\n                        OverrideFieldStruct = self.OverrideFieldValue(Pcd, {})\n                        self.PrintStructureInfo(File, OverrideFieldStruct)\n                self.PrintPcdDefault(File, Pcd, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue)",
        "mutated": [
            "def PrintPcdValue(self, File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, Flag='  ', ModuleGuid=None):\n    if False:\n        i = 10\n    if not Pcd.SkuInfoList:\n        Value = Pcd.DefaultValue\n        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n        if IsByteArray:\n            FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '{'))\n            for Array in ArrayList:\n                FileWrite(File, Array)\n        else:\n            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                if Value.startswith('0') and (not Value.lower().startswith('0x')) and (len(Value) > 1) and Value.lstrip('0'):\n                    Value = Value.lstrip('0')\n                if Value.startswith(('0x', '0X')):\n                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                else:\n                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n            FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', Value))\n        if IsStructure:\n            FiledOverrideFlag = False\n            if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.gPcdSkuOverrides:\n                OverrideValues = GlobalData.gPcdSkuOverrides[Pcd.TokenCName, Pcd.TokenSpaceGuidCName]\n            else:\n                OverrideValues = Pcd.SkuOverrideValues\n            FieldOverrideValues = None\n            if OverrideValues:\n                for Data in OverrideValues.values():\n                    Struct = list(Data.values())\n                    if Struct:\n                        FieldOverrideValues = Struct[0]\n                        FiledOverrideFlag = True\n                        break\n            if Pcd.PcdFiledValueFromDscComponent and ModuleGuid and (ModuleGuid.replace('-', 'S') in Pcd.PcdFiledValueFromDscComponent):\n                FieldOverrideValues = Pcd.PcdFiledValueFromDscComponent[ModuleGuid.replace('-', 'S')]\n            if FieldOverrideValues:\n                OverrideFieldStruct = self.OverrideFieldValue(Pcd, FieldOverrideValues)\n                self.PrintStructureInfo(File, OverrideFieldStruct)\n            if not FiledOverrideFlag and (Pcd.PcdFieldValueFromComm or Pcd.PcdFieldValueFromFdf):\n                OverrideFieldStruct = self.OverrideFieldValue(Pcd, {})\n                self.PrintStructureInfo(File, OverrideFieldStruct)\n        self.PrintPcdDefault(File, Pcd, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue)\n    else:\n        FirstPrint = True\n        SkuList = sorted(Pcd.SkuInfoList.keys())\n        for Sku in SkuList:\n            SkuInfo = Pcd.SkuInfoList[Sku]\n            SkuIdName = SkuInfo.SkuIdName\n            if TypeName in ('DYNHII', 'DEXHII'):\n                if SkuInfo.DefaultStoreDict:\n                    DefaultStoreList = sorted(SkuInfo.DefaultStoreDict.keys())\n                    for DefaultStore in DefaultStoreList:\n                        Value = SkuInfo.DefaultStoreDict[DefaultStore]\n                        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n                        if Pcd.DatumType == 'BOOLEAN':\n                            Value = str(int(Value, 0))\n                        if FirstPrint:\n                            FirstPrint = False\n                            if IsByteArray:\n                                if self.DefaultStoreSingle and self.SkuSingle:\n                                    FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '{'))\n                                elif self.DefaultStoreSingle and (not self.SkuSingle):\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '{'))\n                                elif not self.DefaultStoreSingle and self.SkuSingle:\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + DefaultStore + ')', '{'))\n                                else:\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '(' + DefaultStore + ')', '{'))\n                                for Array in ArrayList:\n                                    FileWrite(File, Array)\n                            else:\n                                if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                                    if Value.startswith(('0x', '0X')):\n                                        Value = '{} ({:d})'.format(Value, int(Value, 0))\n                                    else:\n                                        Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                                if self.DefaultStoreSingle and self.SkuSingle:\n                                    FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', Value))\n                                elif self.DefaultStoreSingle and (not self.SkuSingle):\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', Value))\n                                elif not self.DefaultStoreSingle and self.SkuSingle:\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + DefaultStore + ')', Value))\n                                else:\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '(' + DefaultStore + ')', Value))\n                        elif IsByteArray:\n                            if self.DefaultStoreSingle and self.SkuSingle:\n                                FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '{'))\n                            elif self.DefaultStoreSingle and (not self.SkuSingle):\n                                FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '{'))\n                            elif not self.DefaultStoreSingle and self.SkuSingle:\n                                FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + DefaultStore + ')', '{'))\n                            else:\n                                FileWrite(File, ' %-*s   : %6s %10s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '(' + DefaultStore + ')', '{'))\n                            for Array in ArrayList:\n                                FileWrite(File, Array)\n                        else:\n                            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                                if Value.startswith(('0x', '0X')):\n                                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                                else:\n                                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                            if self.DefaultStoreSingle and self.SkuSingle:\n                                FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', Value))\n                            elif self.DefaultStoreSingle and (not self.SkuSingle):\n                                FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', Value))\n                            elif not self.DefaultStoreSingle and self.SkuSingle:\n                                FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + DefaultStore + ')', Value))\n                            else:\n                                FileWrite(File, ' %-*s   : %6s %10s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '(' + DefaultStore + ')', Value))\n                        FileWrite(File, '%*s: %s: %s' % (self.MaxLen + 4, SkuInfo.VariableGuid, SkuInfo.VariableName, SkuInfo.VariableOffset))\n                        if IsStructure:\n                            OverrideValues = Pcd.SkuOverrideValues.get(Sku)\n                            if OverrideValues:\n                                OverrideFieldStruct = self.OverrideFieldValue(Pcd, OverrideValues[DefaultStore])\n                                self.PrintStructureInfo(File, OverrideFieldStruct)\n                        self.PrintPcdDefault(File, Pcd, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue)\n            else:\n                Value = SkuInfo.DefaultValue\n                (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n                if Pcd.DatumType == 'BOOLEAN':\n                    Value = str(int(Value, 0))\n                if FirstPrint:\n                    FirstPrint = False\n                    if IsByteArray:\n                        if self.SkuSingle:\n                            FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '{'))\n                        else:\n                            FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '{'))\n                        for Array in ArrayList:\n                            FileWrite(File, Array)\n                    else:\n                        if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                            if Value.startswith(('0x', '0X')):\n                                Value = '{} ({:d})'.format(Value, int(Value, 0))\n                            else:\n                                Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                        if self.SkuSingle:\n                            FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', Value))\n                        else:\n                            FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', Value))\n                elif IsByteArray:\n                    if self.SkuSingle:\n                        FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '{'))\n                    else:\n                        FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '{'))\n                    for Array in ArrayList:\n                        FileWrite(File, Array)\n                else:\n                    if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                        if Value.startswith(('0x', '0X')):\n                            Value = '{} ({:d})'.format(Value, int(Value, 0))\n                        else:\n                            Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                    if self.SkuSingle:\n                        FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', Value))\n                    else:\n                        FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', Value))\n                if TypeName in ('DYNVPD', 'DEXVPD'):\n                    FileWrite(File, '%*s' % (self.MaxLen + 4, SkuInfo.VpdOffset))\n                    VPDPcdItem = (Pcd.TokenSpaceGuidCName + '.' + PcdTokenCName, SkuIdName, SkuInfo.VpdOffset, Pcd.MaxDatumSize, SkuInfo.DefaultValue)\n                    if VPDPcdItem not in VPDPcdList:\n                        PcdGuidList = self.UnusedPcds.get(Pcd.TokenSpaceGuidCName)\n                        if PcdGuidList:\n                            PcdList = PcdGuidList.get(Pcd.Type)\n                            if not PcdList:\n                                VPDPcdList.append(VPDPcdItem)\n                            for VpdPcd in PcdList:\n                                if PcdTokenCName == VpdPcd.TokenCName:\n                                    break\n                            else:\n                                VPDPcdList.append(VPDPcdItem)\n                if IsStructure:\n                    FiledOverrideFlag = False\n                    OverrideValues = Pcd.SkuOverrideValues.get(Sku)\n                    if OverrideValues:\n                        Keys = list(OverrideValues.keys())\n                        OverrideFieldStruct = self.OverrideFieldValue(Pcd, OverrideValues[Keys[0]])\n                        self.PrintStructureInfo(File, OverrideFieldStruct)\n                        FiledOverrideFlag = True\n                    if not FiledOverrideFlag and (Pcd.PcdFieldValueFromComm or Pcd.PcdFieldValueFromFdf):\n                        OverrideFieldStruct = self.OverrideFieldValue(Pcd, {})\n                        self.PrintStructureInfo(File, OverrideFieldStruct)\n                self.PrintPcdDefault(File, Pcd, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue)",
            "def PrintPcdValue(self, File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, Flag='  ', ModuleGuid=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not Pcd.SkuInfoList:\n        Value = Pcd.DefaultValue\n        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n        if IsByteArray:\n            FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '{'))\n            for Array in ArrayList:\n                FileWrite(File, Array)\n        else:\n            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                if Value.startswith('0') and (not Value.lower().startswith('0x')) and (len(Value) > 1) and Value.lstrip('0'):\n                    Value = Value.lstrip('0')\n                if Value.startswith(('0x', '0X')):\n                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                else:\n                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n            FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', Value))\n        if IsStructure:\n            FiledOverrideFlag = False\n            if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.gPcdSkuOverrides:\n                OverrideValues = GlobalData.gPcdSkuOverrides[Pcd.TokenCName, Pcd.TokenSpaceGuidCName]\n            else:\n                OverrideValues = Pcd.SkuOverrideValues\n            FieldOverrideValues = None\n            if OverrideValues:\n                for Data in OverrideValues.values():\n                    Struct = list(Data.values())\n                    if Struct:\n                        FieldOverrideValues = Struct[0]\n                        FiledOverrideFlag = True\n                        break\n            if Pcd.PcdFiledValueFromDscComponent and ModuleGuid and (ModuleGuid.replace('-', 'S') in Pcd.PcdFiledValueFromDscComponent):\n                FieldOverrideValues = Pcd.PcdFiledValueFromDscComponent[ModuleGuid.replace('-', 'S')]\n            if FieldOverrideValues:\n                OverrideFieldStruct = self.OverrideFieldValue(Pcd, FieldOverrideValues)\n                self.PrintStructureInfo(File, OverrideFieldStruct)\n            if not FiledOverrideFlag and (Pcd.PcdFieldValueFromComm or Pcd.PcdFieldValueFromFdf):\n                OverrideFieldStruct = self.OverrideFieldValue(Pcd, {})\n                self.PrintStructureInfo(File, OverrideFieldStruct)\n        self.PrintPcdDefault(File, Pcd, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue)\n    else:\n        FirstPrint = True\n        SkuList = sorted(Pcd.SkuInfoList.keys())\n        for Sku in SkuList:\n            SkuInfo = Pcd.SkuInfoList[Sku]\n            SkuIdName = SkuInfo.SkuIdName\n            if TypeName in ('DYNHII', 'DEXHII'):\n                if SkuInfo.DefaultStoreDict:\n                    DefaultStoreList = sorted(SkuInfo.DefaultStoreDict.keys())\n                    for DefaultStore in DefaultStoreList:\n                        Value = SkuInfo.DefaultStoreDict[DefaultStore]\n                        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n                        if Pcd.DatumType == 'BOOLEAN':\n                            Value = str(int(Value, 0))\n                        if FirstPrint:\n                            FirstPrint = False\n                            if IsByteArray:\n                                if self.DefaultStoreSingle and self.SkuSingle:\n                                    FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '{'))\n                                elif self.DefaultStoreSingle and (not self.SkuSingle):\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '{'))\n                                elif not self.DefaultStoreSingle and self.SkuSingle:\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + DefaultStore + ')', '{'))\n                                else:\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '(' + DefaultStore + ')', '{'))\n                                for Array in ArrayList:\n                                    FileWrite(File, Array)\n                            else:\n                                if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                                    if Value.startswith(('0x', '0X')):\n                                        Value = '{} ({:d})'.format(Value, int(Value, 0))\n                                    else:\n                                        Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                                if self.DefaultStoreSingle and self.SkuSingle:\n                                    FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', Value))\n                                elif self.DefaultStoreSingle and (not self.SkuSingle):\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', Value))\n                                elif not self.DefaultStoreSingle and self.SkuSingle:\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + DefaultStore + ')', Value))\n                                else:\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '(' + DefaultStore + ')', Value))\n                        elif IsByteArray:\n                            if self.DefaultStoreSingle and self.SkuSingle:\n                                FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '{'))\n                            elif self.DefaultStoreSingle and (not self.SkuSingle):\n                                FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '{'))\n                            elif not self.DefaultStoreSingle and self.SkuSingle:\n                                FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + DefaultStore + ')', '{'))\n                            else:\n                                FileWrite(File, ' %-*s   : %6s %10s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '(' + DefaultStore + ')', '{'))\n                            for Array in ArrayList:\n                                FileWrite(File, Array)\n                        else:\n                            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                                if Value.startswith(('0x', '0X')):\n                                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                                else:\n                                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                            if self.DefaultStoreSingle and self.SkuSingle:\n                                FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', Value))\n                            elif self.DefaultStoreSingle and (not self.SkuSingle):\n                                FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', Value))\n                            elif not self.DefaultStoreSingle and self.SkuSingle:\n                                FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + DefaultStore + ')', Value))\n                            else:\n                                FileWrite(File, ' %-*s   : %6s %10s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '(' + DefaultStore + ')', Value))\n                        FileWrite(File, '%*s: %s: %s' % (self.MaxLen + 4, SkuInfo.VariableGuid, SkuInfo.VariableName, SkuInfo.VariableOffset))\n                        if IsStructure:\n                            OverrideValues = Pcd.SkuOverrideValues.get(Sku)\n                            if OverrideValues:\n                                OverrideFieldStruct = self.OverrideFieldValue(Pcd, OverrideValues[DefaultStore])\n                                self.PrintStructureInfo(File, OverrideFieldStruct)\n                        self.PrintPcdDefault(File, Pcd, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue)\n            else:\n                Value = SkuInfo.DefaultValue\n                (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n                if Pcd.DatumType == 'BOOLEAN':\n                    Value = str(int(Value, 0))\n                if FirstPrint:\n                    FirstPrint = False\n                    if IsByteArray:\n                        if self.SkuSingle:\n                            FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '{'))\n                        else:\n                            FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '{'))\n                        for Array in ArrayList:\n                            FileWrite(File, Array)\n                    else:\n                        if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                            if Value.startswith(('0x', '0X')):\n                                Value = '{} ({:d})'.format(Value, int(Value, 0))\n                            else:\n                                Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                        if self.SkuSingle:\n                            FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', Value))\n                        else:\n                            FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', Value))\n                elif IsByteArray:\n                    if self.SkuSingle:\n                        FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '{'))\n                    else:\n                        FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '{'))\n                    for Array in ArrayList:\n                        FileWrite(File, Array)\n                else:\n                    if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                        if Value.startswith(('0x', '0X')):\n                            Value = '{} ({:d})'.format(Value, int(Value, 0))\n                        else:\n                            Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                    if self.SkuSingle:\n                        FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', Value))\n                    else:\n                        FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', Value))\n                if TypeName in ('DYNVPD', 'DEXVPD'):\n                    FileWrite(File, '%*s' % (self.MaxLen + 4, SkuInfo.VpdOffset))\n                    VPDPcdItem = (Pcd.TokenSpaceGuidCName + '.' + PcdTokenCName, SkuIdName, SkuInfo.VpdOffset, Pcd.MaxDatumSize, SkuInfo.DefaultValue)\n                    if VPDPcdItem not in VPDPcdList:\n                        PcdGuidList = self.UnusedPcds.get(Pcd.TokenSpaceGuidCName)\n                        if PcdGuidList:\n                            PcdList = PcdGuidList.get(Pcd.Type)\n                            if not PcdList:\n                                VPDPcdList.append(VPDPcdItem)\n                            for VpdPcd in PcdList:\n                                if PcdTokenCName == VpdPcd.TokenCName:\n                                    break\n                            else:\n                                VPDPcdList.append(VPDPcdItem)\n                if IsStructure:\n                    FiledOverrideFlag = False\n                    OverrideValues = Pcd.SkuOverrideValues.get(Sku)\n                    if OverrideValues:\n                        Keys = list(OverrideValues.keys())\n                        OverrideFieldStruct = self.OverrideFieldValue(Pcd, OverrideValues[Keys[0]])\n                        self.PrintStructureInfo(File, OverrideFieldStruct)\n                        FiledOverrideFlag = True\n                    if not FiledOverrideFlag and (Pcd.PcdFieldValueFromComm or Pcd.PcdFieldValueFromFdf):\n                        OverrideFieldStruct = self.OverrideFieldValue(Pcd, {})\n                        self.PrintStructureInfo(File, OverrideFieldStruct)\n                self.PrintPcdDefault(File, Pcd, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue)",
            "def PrintPcdValue(self, File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, Flag='  ', ModuleGuid=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not Pcd.SkuInfoList:\n        Value = Pcd.DefaultValue\n        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n        if IsByteArray:\n            FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '{'))\n            for Array in ArrayList:\n                FileWrite(File, Array)\n        else:\n            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                if Value.startswith('0') and (not Value.lower().startswith('0x')) and (len(Value) > 1) and Value.lstrip('0'):\n                    Value = Value.lstrip('0')\n                if Value.startswith(('0x', '0X')):\n                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                else:\n                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n            FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', Value))\n        if IsStructure:\n            FiledOverrideFlag = False\n            if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.gPcdSkuOverrides:\n                OverrideValues = GlobalData.gPcdSkuOverrides[Pcd.TokenCName, Pcd.TokenSpaceGuidCName]\n            else:\n                OverrideValues = Pcd.SkuOverrideValues\n            FieldOverrideValues = None\n            if OverrideValues:\n                for Data in OverrideValues.values():\n                    Struct = list(Data.values())\n                    if Struct:\n                        FieldOverrideValues = Struct[0]\n                        FiledOverrideFlag = True\n                        break\n            if Pcd.PcdFiledValueFromDscComponent and ModuleGuid and (ModuleGuid.replace('-', 'S') in Pcd.PcdFiledValueFromDscComponent):\n                FieldOverrideValues = Pcd.PcdFiledValueFromDscComponent[ModuleGuid.replace('-', 'S')]\n            if FieldOverrideValues:\n                OverrideFieldStruct = self.OverrideFieldValue(Pcd, FieldOverrideValues)\n                self.PrintStructureInfo(File, OverrideFieldStruct)\n            if not FiledOverrideFlag and (Pcd.PcdFieldValueFromComm or Pcd.PcdFieldValueFromFdf):\n                OverrideFieldStruct = self.OverrideFieldValue(Pcd, {})\n                self.PrintStructureInfo(File, OverrideFieldStruct)\n        self.PrintPcdDefault(File, Pcd, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue)\n    else:\n        FirstPrint = True\n        SkuList = sorted(Pcd.SkuInfoList.keys())\n        for Sku in SkuList:\n            SkuInfo = Pcd.SkuInfoList[Sku]\n            SkuIdName = SkuInfo.SkuIdName\n            if TypeName in ('DYNHII', 'DEXHII'):\n                if SkuInfo.DefaultStoreDict:\n                    DefaultStoreList = sorted(SkuInfo.DefaultStoreDict.keys())\n                    for DefaultStore in DefaultStoreList:\n                        Value = SkuInfo.DefaultStoreDict[DefaultStore]\n                        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n                        if Pcd.DatumType == 'BOOLEAN':\n                            Value = str(int(Value, 0))\n                        if FirstPrint:\n                            FirstPrint = False\n                            if IsByteArray:\n                                if self.DefaultStoreSingle and self.SkuSingle:\n                                    FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '{'))\n                                elif self.DefaultStoreSingle and (not self.SkuSingle):\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '{'))\n                                elif not self.DefaultStoreSingle and self.SkuSingle:\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + DefaultStore + ')', '{'))\n                                else:\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '(' + DefaultStore + ')', '{'))\n                                for Array in ArrayList:\n                                    FileWrite(File, Array)\n                            else:\n                                if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                                    if Value.startswith(('0x', '0X')):\n                                        Value = '{} ({:d})'.format(Value, int(Value, 0))\n                                    else:\n                                        Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                                if self.DefaultStoreSingle and self.SkuSingle:\n                                    FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', Value))\n                                elif self.DefaultStoreSingle and (not self.SkuSingle):\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', Value))\n                                elif not self.DefaultStoreSingle and self.SkuSingle:\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + DefaultStore + ')', Value))\n                                else:\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '(' + DefaultStore + ')', Value))\n                        elif IsByteArray:\n                            if self.DefaultStoreSingle and self.SkuSingle:\n                                FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '{'))\n                            elif self.DefaultStoreSingle and (not self.SkuSingle):\n                                FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '{'))\n                            elif not self.DefaultStoreSingle and self.SkuSingle:\n                                FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + DefaultStore + ')', '{'))\n                            else:\n                                FileWrite(File, ' %-*s   : %6s %10s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '(' + DefaultStore + ')', '{'))\n                            for Array in ArrayList:\n                                FileWrite(File, Array)\n                        else:\n                            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                                if Value.startswith(('0x', '0X')):\n                                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                                else:\n                                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                            if self.DefaultStoreSingle and self.SkuSingle:\n                                FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', Value))\n                            elif self.DefaultStoreSingle and (not self.SkuSingle):\n                                FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', Value))\n                            elif not self.DefaultStoreSingle and self.SkuSingle:\n                                FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + DefaultStore + ')', Value))\n                            else:\n                                FileWrite(File, ' %-*s   : %6s %10s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '(' + DefaultStore + ')', Value))\n                        FileWrite(File, '%*s: %s: %s' % (self.MaxLen + 4, SkuInfo.VariableGuid, SkuInfo.VariableName, SkuInfo.VariableOffset))\n                        if IsStructure:\n                            OverrideValues = Pcd.SkuOverrideValues.get(Sku)\n                            if OverrideValues:\n                                OverrideFieldStruct = self.OverrideFieldValue(Pcd, OverrideValues[DefaultStore])\n                                self.PrintStructureInfo(File, OverrideFieldStruct)\n                        self.PrintPcdDefault(File, Pcd, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue)\n            else:\n                Value = SkuInfo.DefaultValue\n                (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n                if Pcd.DatumType == 'BOOLEAN':\n                    Value = str(int(Value, 0))\n                if FirstPrint:\n                    FirstPrint = False\n                    if IsByteArray:\n                        if self.SkuSingle:\n                            FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '{'))\n                        else:\n                            FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '{'))\n                        for Array in ArrayList:\n                            FileWrite(File, Array)\n                    else:\n                        if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                            if Value.startswith(('0x', '0X')):\n                                Value = '{} ({:d})'.format(Value, int(Value, 0))\n                            else:\n                                Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                        if self.SkuSingle:\n                            FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', Value))\n                        else:\n                            FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', Value))\n                elif IsByteArray:\n                    if self.SkuSingle:\n                        FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '{'))\n                    else:\n                        FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '{'))\n                    for Array in ArrayList:\n                        FileWrite(File, Array)\n                else:\n                    if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                        if Value.startswith(('0x', '0X')):\n                            Value = '{} ({:d})'.format(Value, int(Value, 0))\n                        else:\n                            Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                    if self.SkuSingle:\n                        FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', Value))\n                    else:\n                        FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', Value))\n                if TypeName in ('DYNVPD', 'DEXVPD'):\n                    FileWrite(File, '%*s' % (self.MaxLen + 4, SkuInfo.VpdOffset))\n                    VPDPcdItem = (Pcd.TokenSpaceGuidCName + '.' + PcdTokenCName, SkuIdName, SkuInfo.VpdOffset, Pcd.MaxDatumSize, SkuInfo.DefaultValue)\n                    if VPDPcdItem not in VPDPcdList:\n                        PcdGuidList = self.UnusedPcds.get(Pcd.TokenSpaceGuidCName)\n                        if PcdGuidList:\n                            PcdList = PcdGuidList.get(Pcd.Type)\n                            if not PcdList:\n                                VPDPcdList.append(VPDPcdItem)\n                            for VpdPcd in PcdList:\n                                if PcdTokenCName == VpdPcd.TokenCName:\n                                    break\n                            else:\n                                VPDPcdList.append(VPDPcdItem)\n                if IsStructure:\n                    FiledOverrideFlag = False\n                    OverrideValues = Pcd.SkuOverrideValues.get(Sku)\n                    if OverrideValues:\n                        Keys = list(OverrideValues.keys())\n                        OverrideFieldStruct = self.OverrideFieldValue(Pcd, OverrideValues[Keys[0]])\n                        self.PrintStructureInfo(File, OverrideFieldStruct)\n                        FiledOverrideFlag = True\n                    if not FiledOverrideFlag and (Pcd.PcdFieldValueFromComm or Pcd.PcdFieldValueFromFdf):\n                        OverrideFieldStruct = self.OverrideFieldValue(Pcd, {})\n                        self.PrintStructureInfo(File, OverrideFieldStruct)\n                self.PrintPcdDefault(File, Pcd, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue)",
            "def PrintPcdValue(self, File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, Flag='  ', ModuleGuid=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not Pcd.SkuInfoList:\n        Value = Pcd.DefaultValue\n        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n        if IsByteArray:\n            FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '{'))\n            for Array in ArrayList:\n                FileWrite(File, Array)\n        else:\n            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                if Value.startswith('0') and (not Value.lower().startswith('0x')) and (len(Value) > 1) and Value.lstrip('0'):\n                    Value = Value.lstrip('0')\n                if Value.startswith(('0x', '0X')):\n                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                else:\n                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n            FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', Value))\n        if IsStructure:\n            FiledOverrideFlag = False\n            if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.gPcdSkuOverrides:\n                OverrideValues = GlobalData.gPcdSkuOverrides[Pcd.TokenCName, Pcd.TokenSpaceGuidCName]\n            else:\n                OverrideValues = Pcd.SkuOverrideValues\n            FieldOverrideValues = None\n            if OverrideValues:\n                for Data in OverrideValues.values():\n                    Struct = list(Data.values())\n                    if Struct:\n                        FieldOverrideValues = Struct[0]\n                        FiledOverrideFlag = True\n                        break\n            if Pcd.PcdFiledValueFromDscComponent and ModuleGuid and (ModuleGuid.replace('-', 'S') in Pcd.PcdFiledValueFromDscComponent):\n                FieldOverrideValues = Pcd.PcdFiledValueFromDscComponent[ModuleGuid.replace('-', 'S')]\n            if FieldOverrideValues:\n                OverrideFieldStruct = self.OverrideFieldValue(Pcd, FieldOverrideValues)\n                self.PrintStructureInfo(File, OverrideFieldStruct)\n            if not FiledOverrideFlag and (Pcd.PcdFieldValueFromComm or Pcd.PcdFieldValueFromFdf):\n                OverrideFieldStruct = self.OverrideFieldValue(Pcd, {})\n                self.PrintStructureInfo(File, OverrideFieldStruct)\n        self.PrintPcdDefault(File, Pcd, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue)\n    else:\n        FirstPrint = True\n        SkuList = sorted(Pcd.SkuInfoList.keys())\n        for Sku in SkuList:\n            SkuInfo = Pcd.SkuInfoList[Sku]\n            SkuIdName = SkuInfo.SkuIdName\n            if TypeName in ('DYNHII', 'DEXHII'):\n                if SkuInfo.DefaultStoreDict:\n                    DefaultStoreList = sorted(SkuInfo.DefaultStoreDict.keys())\n                    for DefaultStore in DefaultStoreList:\n                        Value = SkuInfo.DefaultStoreDict[DefaultStore]\n                        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n                        if Pcd.DatumType == 'BOOLEAN':\n                            Value = str(int(Value, 0))\n                        if FirstPrint:\n                            FirstPrint = False\n                            if IsByteArray:\n                                if self.DefaultStoreSingle and self.SkuSingle:\n                                    FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '{'))\n                                elif self.DefaultStoreSingle and (not self.SkuSingle):\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '{'))\n                                elif not self.DefaultStoreSingle and self.SkuSingle:\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + DefaultStore + ')', '{'))\n                                else:\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '(' + DefaultStore + ')', '{'))\n                                for Array in ArrayList:\n                                    FileWrite(File, Array)\n                            else:\n                                if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                                    if Value.startswith(('0x', '0X')):\n                                        Value = '{} ({:d})'.format(Value, int(Value, 0))\n                                    else:\n                                        Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                                if self.DefaultStoreSingle and self.SkuSingle:\n                                    FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', Value))\n                                elif self.DefaultStoreSingle and (not self.SkuSingle):\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', Value))\n                                elif not self.DefaultStoreSingle and self.SkuSingle:\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + DefaultStore + ')', Value))\n                                else:\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '(' + DefaultStore + ')', Value))\n                        elif IsByteArray:\n                            if self.DefaultStoreSingle and self.SkuSingle:\n                                FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '{'))\n                            elif self.DefaultStoreSingle and (not self.SkuSingle):\n                                FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '{'))\n                            elif not self.DefaultStoreSingle and self.SkuSingle:\n                                FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + DefaultStore + ')', '{'))\n                            else:\n                                FileWrite(File, ' %-*s   : %6s %10s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '(' + DefaultStore + ')', '{'))\n                            for Array in ArrayList:\n                                FileWrite(File, Array)\n                        else:\n                            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                                if Value.startswith(('0x', '0X')):\n                                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                                else:\n                                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                            if self.DefaultStoreSingle and self.SkuSingle:\n                                FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', Value))\n                            elif self.DefaultStoreSingle and (not self.SkuSingle):\n                                FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', Value))\n                            elif not self.DefaultStoreSingle and self.SkuSingle:\n                                FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + DefaultStore + ')', Value))\n                            else:\n                                FileWrite(File, ' %-*s   : %6s %10s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '(' + DefaultStore + ')', Value))\n                        FileWrite(File, '%*s: %s: %s' % (self.MaxLen + 4, SkuInfo.VariableGuid, SkuInfo.VariableName, SkuInfo.VariableOffset))\n                        if IsStructure:\n                            OverrideValues = Pcd.SkuOverrideValues.get(Sku)\n                            if OverrideValues:\n                                OverrideFieldStruct = self.OverrideFieldValue(Pcd, OverrideValues[DefaultStore])\n                                self.PrintStructureInfo(File, OverrideFieldStruct)\n                        self.PrintPcdDefault(File, Pcd, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue)\n            else:\n                Value = SkuInfo.DefaultValue\n                (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n                if Pcd.DatumType == 'BOOLEAN':\n                    Value = str(int(Value, 0))\n                if FirstPrint:\n                    FirstPrint = False\n                    if IsByteArray:\n                        if self.SkuSingle:\n                            FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '{'))\n                        else:\n                            FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '{'))\n                        for Array in ArrayList:\n                            FileWrite(File, Array)\n                    else:\n                        if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                            if Value.startswith(('0x', '0X')):\n                                Value = '{} ({:d})'.format(Value, int(Value, 0))\n                            else:\n                                Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                        if self.SkuSingle:\n                            FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', Value))\n                        else:\n                            FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', Value))\n                elif IsByteArray:\n                    if self.SkuSingle:\n                        FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '{'))\n                    else:\n                        FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '{'))\n                    for Array in ArrayList:\n                        FileWrite(File, Array)\n                else:\n                    if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                        if Value.startswith(('0x', '0X')):\n                            Value = '{} ({:d})'.format(Value, int(Value, 0))\n                        else:\n                            Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                    if self.SkuSingle:\n                        FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', Value))\n                    else:\n                        FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', Value))\n                if TypeName in ('DYNVPD', 'DEXVPD'):\n                    FileWrite(File, '%*s' % (self.MaxLen + 4, SkuInfo.VpdOffset))\n                    VPDPcdItem = (Pcd.TokenSpaceGuidCName + '.' + PcdTokenCName, SkuIdName, SkuInfo.VpdOffset, Pcd.MaxDatumSize, SkuInfo.DefaultValue)\n                    if VPDPcdItem not in VPDPcdList:\n                        PcdGuidList = self.UnusedPcds.get(Pcd.TokenSpaceGuidCName)\n                        if PcdGuidList:\n                            PcdList = PcdGuidList.get(Pcd.Type)\n                            if not PcdList:\n                                VPDPcdList.append(VPDPcdItem)\n                            for VpdPcd in PcdList:\n                                if PcdTokenCName == VpdPcd.TokenCName:\n                                    break\n                            else:\n                                VPDPcdList.append(VPDPcdItem)\n                if IsStructure:\n                    FiledOverrideFlag = False\n                    OverrideValues = Pcd.SkuOverrideValues.get(Sku)\n                    if OverrideValues:\n                        Keys = list(OverrideValues.keys())\n                        OverrideFieldStruct = self.OverrideFieldValue(Pcd, OverrideValues[Keys[0]])\n                        self.PrintStructureInfo(File, OverrideFieldStruct)\n                        FiledOverrideFlag = True\n                    if not FiledOverrideFlag and (Pcd.PcdFieldValueFromComm or Pcd.PcdFieldValueFromFdf):\n                        OverrideFieldStruct = self.OverrideFieldValue(Pcd, {})\n                        self.PrintStructureInfo(File, OverrideFieldStruct)\n                self.PrintPcdDefault(File, Pcd, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue)",
            "def PrintPcdValue(self, File, Pcd, PcdTokenCName, TypeName, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue, Flag='  ', ModuleGuid=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not Pcd.SkuInfoList:\n        Value = Pcd.DefaultValue\n        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n        if IsByteArray:\n            FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '{'))\n            for Array in ArrayList:\n                FileWrite(File, Array)\n        else:\n            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                if Value.startswith('0') and (not Value.lower().startswith('0x')) and (len(Value) > 1) and Value.lstrip('0'):\n                    Value = Value.lstrip('0')\n                if Value.startswith(('0x', '0X')):\n                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                else:\n                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n            FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', Value))\n        if IsStructure:\n            FiledOverrideFlag = False\n            if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.gPcdSkuOverrides:\n                OverrideValues = GlobalData.gPcdSkuOverrides[Pcd.TokenCName, Pcd.TokenSpaceGuidCName]\n            else:\n                OverrideValues = Pcd.SkuOverrideValues\n            FieldOverrideValues = None\n            if OverrideValues:\n                for Data in OverrideValues.values():\n                    Struct = list(Data.values())\n                    if Struct:\n                        FieldOverrideValues = Struct[0]\n                        FiledOverrideFlag = True\n                        break\n            if Pcd.PcdFiledValueFromDscComponent and ModuleGuid and (ModuleGuid.replace('-', 'S') in Pcd.PcdFiledValueFromDscComponent):\n                FieldOverrideValues = Pcd.PcdFiledValueFromDscComponent[ModuleGuid.replace('-', 'S')]\n            if FieldOverrideValues:\n                OverrideFieldStruct = self.OverrideFieldValue(Pcd, FieldOverrideValues)\n                self.PrintStructureInfo(File, OverrideFieldStruct)\n            if not FiledOverrideFlag and (Pcd.PcdFieldValueFromComm or Pcd.PcdFieldValueFromFdf):\n                OverrideFieldStruct = self.OverrideFieldValue(Pcd, {})\n                self.PrintStructureInfo(File, OverrideFieldStruct)\n        self.PrintPcdDefault(File, Pcd, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue)\n    else:\n        FirstPrint = True\n        SkuList = sorted(Pcd.SkuInfoList.keys())\n        for Sku in SkuList:\n            SkuInfo = Pcd.SkuInfoList[Sku]\n            SkuIdName = SkuInfo.SkuIdName\n            if TypeName in ('DYNHII', 'DEXHII'):\n                if SkuInfo.DefaultStoreDict:\n                    DefaultStoreList = sorted(SkuInfo.DefaultStoreDict.keys())\n                    for DefaultStore in DefaultStoreList:\n                        Value = SkuInfo.DefaultStoreDict[DefaultStore]\n                        (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n                        if Pcd.DatumType == 'BOOLEAN':\n                            Value = str(int(Value, 0))\n                        if FirstPrint:\n                            FirstPrint = False\n                            if IsByteArray:\n                                if self.DefaultStoreSingle and self.SkuSingle:\n                                    FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '{'))\n                                elif self.DefaultStoreSingle and (not self.SkuSingle):\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '{'))\n                                elif not self.DefaultStoreSingle and self.SkuSingle:\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + DefaultStore + ')', '{'))\n                                else:\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '(' + DefaultStore + ')', '{'))\n                                for Array in ArrayList:\n                                    FileWrite(File, Array)\n                            else:\n                                if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                                    if Value.startswith(('0x', '0X')):\n                                        Value = '{} ({:d})'.format(Value, int(Value, 0))\n                                    else:\n                                        Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                                if self.DefaultStoreSingle and self.SkuSingle:\n                                    FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', Value))\n                                elif self.DefaultStoreSingle and (not self.SkuSingle):\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', Value))\n                                elif not self.DefaultStoreSingle and self.SkuSingle:\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + DefaultStore + ')', Value))\n                                else:\n                                    FileWrite(File, ' %-*s   : %6s %10s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '(' + DefaultStore + ')', Value))\n                        elif IsByteArray:\n                            if self.DefaultStoreSingle and self.SkuSingle:\n                                FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '{'))\n                            elif self.DefaultStoreSingle and (not self.SkuSingle):\n                                FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '{'))\n                            elif not self.DefaultStoreSingle and self.SkuSingle:\n                                FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + DefaultStore + ')', '{'))\n                            else:\n                                FileWrite(File, ' %-*s   : %6s %10s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '(' + DefaultStore + ')', '{'))\n                            for Array in ArrayList:\n                                FileWrite(File, Array)\n                        else:\n                            if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                                if Value.startswith(('0x', '0X')):\n                                    Value = '{} ({:d})'.format(Value, int(Value, 0))\n                                else:\n                                    Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                            if self.DefaultStoreSingle and self.SkuSingle:\n                                FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', Value))\n                            elif self.DefaultStoreSingle and (not self.SkuSingle):\n                                FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', Value))\n                            elif not self.DefaultStoreSingle and self.SkuSingle:\n                                FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + DefaultStore + ')', Value))\n                            else:\n                                FileWrite(File, ' %-*s   : %6s %10s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '(' + DefaultStore + ')', Value))\n                        FileWrite(File, '%*s: %s: %s' % (self.MaxLen + 4, SkuInfo.VariableGuid, SkuInfo.VariableName, SkuInfo.VariableOffset))\n                        if IsStructure:\n                            OverrideValues = Pcd.SkuOverrideValues.get(Sku)\n                            if OverrideValues:\n                                OverrideFieldStruct = self.OverrideFieldValue(Pcd, OverrideValues[DefaultStore])\n                                self.PrintStructureInfo(File, OverrideFieldStruct)\n                        self.PrintPcdDefault(File, Pcd, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue)\n            else:\n                Value = SkuInfo.DefaultValue\n                (IsByteArray, ArrayList) = ByteArrayForamt(Value)\n                if Pcd.DatumType == 'BOOLEAN':\n                    Value = str(int(Value, 0))\n                if FirstPrint:\n                    FirstPrint = False\n                    if IsByteArray:\n                        if self.SkuSingle:\n                            FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '{'))\n                        else:\n                            FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '{'))\n                        for Array in ArrayList:\n                            FileWrite(File, Array)\n                    else:\n                        if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                            if Value.startswith(('0x', '0X')):\n                                Value = '{} ({:d})'.format(Value, int(Value, 0))\n                            else:\n                                Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                        if self.SkuSingle:\n                            FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', Value))\n                        else:\n                            FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, Flag + ' ' + PcdTokenCName, TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', Value))\n                elif IsByteArray:\n                    if self.SkuSingle:\n                        FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '{'))\n                    else:\n                        FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', '{'))\n                    for Array in ArrayList:\n                        FileWrite(File, Array)\n                else:\n                    if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n                        if Value.startswith(('0x', '0X')):\n                            Value = '{} ({:d})'.format(Value, int(Value, 0))\n                        else:\n                            Value = '0x{:X} ({})'.format(int(Value, 0), Value)\n                    if self.SkuSingle:\n                        FileWrite(File, ' %-*s   : %6s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', Value))\n                    else:\n                        FileWrite(File, ' %-*s   : %6s %10s %10s = %s' % (self.MaxLen, ' ', TypeName, '(' + Pcd.DatumType + ')', '(' + SkuIdName + ')', Value))\n                if TypeName in ('DYNVPD', 'DEXVPD'):\n                    FileWrite(File, '%*s' % (self.MaxLen + 4, SkuInfo.VpdOffset))\n                    VPDPcdItem = (Pcd.TokenSpaceGuidCName + '.' + PcdTokenCName, SkuIdName, SkuInfo.VpdOffset, Pcd.MaxDatumSize, SkuInfo.DefaultValue)\n                    if VPDPcdItem not in VPDPcdList:\n                        PcdGuidList = self.UnusedPcds.get(Pcd.TokenSpaceGuidCName)\n                        if PcdGuidList:\n                            PcdList = PcdGuidList.get(Pcd.Type)\n                            if not PcdList:\n                                VPDPcdList.append(VPDPcdItem)\n                            for VpdPcd in PcdList:\n                                if PcdTokenCName == VpdPcd.TokenCName:\n                                    break\n                            else:\n                                VPDPcdList.append(VPDPcdItem)\n                if IsStructure:\n                    FiledOverrideFlag = False\n                    OverrideValues = Pcd.SkuOverrideValues.get(Sku)\n                    if OverrideValues:\n                        Keys = list(OverrideValues.keys())\n                        OverrideFieldStruct = self.OverrideFieldValue(Pcd, OverrideValues[Keys[0]])\n                        self.PrintStructureInfo(File, OverrideFieldStruct)\n                        FiledOverrideFlag = True\n                    if not FiledOverrideFlag and (Pcd.PcdFieldValueFromComm or Pcd.PcdFieldValueFromFdf):\n                        OverrideFieldStruct = self.OverrideFieldValue(Pcd, {})\n                        self.PrintStructureInfo(File, OverrideFieldStruct)\n                self.PrintPcdDefault(File, Pcd, IsStructure, DscMatch, DscDefaultValue, InfMatch, InfDefaultValue, DecMatch, DecDefaultValue)"
        ]
    },
    {
        "func_name": "OverrideFieldValue",
        "original": "def OverrideFieldValue(self, Pcd, OverrideStruct):\n    OverrideFieldStruct = collections.OrderedDict()\n    if OverrideStruct:\n        for (_, Values) in OverrideStruct.items():\n            for (Key, value) in Values.items():\n                if value[1] and value[1].endswith('.dsc'):\n                    OverrideFieldStruct[Key] = value\n    if Pcd.PcdFieldValueFromFdf:\n        for (Key, Values) in Pcd.PcdFieldValueFromFdf.items():\n            if Key in OverrideFieldStruct and Values[0] == OverrideFieldStruct[Key][0]:\n                continue\n            OverrideFieldStruct[Key] = Values\n    if Pcd.PcdFieldValueFromComm:\n        for (Key, Values) in Pcd.PcdFieldValueFromComm.items():\n            if Key in OverrideFieldStruct and Values[0] == OverrideFieldStruct[Key][0]:\n                continue\n            OverrideFieldStruct[Key] = Values\n    return OverrideFieldStruct",
        "mutated": [
            "def OverrideFieldValue(self, Pcd, OverrideStruct):\n    if False:\n        i = 10\n    OverrideFieldStruct = collections.OrderedDict()\n    if OverrideStruct:\n        for (_, Values) in OverrideStruct.items():\n            for (Key, value) in Values.items():\n                if value[1] and value[1].endswith('.dsc'):\n                    OverrideFieldStruct[Key] = value\n    if Pcd.PcdFieldValueFromFdf:\n        for (Key, Values) in Pcd.PcdFieldValueFromFdf.items():\n            if Key in OverrideFieldStruct and Values[0] == OverrideFieldStruct[Key][0]:\n                continue\n            OverrideFieldStruct[Key] = Values\n    if Pcd.PcdFieldValueFromComm:\n        for (Key, Values) in Pcd.PcdFieldValueFromComm.items():\n            if Key in OverrideFieldStruct and Values[0] == OverrideFieldStruct[Key][0]:\n                continue\n            OverrideFieldStruct[Key] = Values\n    return OverrideFieldStruct",
            "def OverrideFieldValue(self, Pcd, OverrideStruct):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    OverrideFieldStruct = collections.OrderedDict()\n    if OverrideStruct:\n        for (_, Values) in OverrideStruct.items():\n            for (Key, value) in Values.items():\n                if value[1] and value[1].endswith('.dsc'):\n                    OverrideFieldStruct[Key] = value\n    if Pcd.PcdFieldValueFromFdf:\n        for (Key, Values) in Pcd.PcdFieldValueFromFdf.items():\n            if Key in OverrideFieldStruct and Values[0] == OverrideFieldStruct[Key][0]:\n                continue\n            OverrideFieldStruct[Key] = Values\n    if Pcd.PcdFieldValueFromComm:\n        for (Key, Values) in Pcd.PcdFieldValueFromComm.items():\n            if Key in OverrideFieldStruct and Values[0] == OverrideFieldStruct[Key][0]:\n                continue\n            OverrideFieldStruct[Key] = Values\n    return OverrideFieldStruct",
            "def OverrideFieldValue(self, Pcd, OverrideStruct):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    OverrideFieldStruct = collections.OrderedDict()\n    if OverrideStruct:\n        for (_, Values) in OverrideStruct.items():\n            for (Key, value) in Values.items():\n                if value[1] and value[1].endswith('.dsc'):\n                    OverrideFieldStruct[Key] = value\n    if Pcd.PcdFieldValueFromFdf:\n        for (Key, Values) in Pcd.PcdFieldValueFromFdf.items():\n            if Key in OverrideFieldStruct and Values[0] == OverrideFieldStruct[Key][0]:\n                continue\n            OverrideFieldStruct[Key] = Values\n    if Pcd.PcdFieldValueFromComm:\n        for (Key, Values) in Pcd.PcdFieldValueFromComm.items():\n            if Key in OverrideFieldStruct and Values[0] == OverrideFieldStruct[Key][0]:\n                continue\n            OverrideFieldStruct[Key] = Values\n    return OverrideFieldStruct",
            "def OverrideFieldValue(self, Pcd, OverrideStruct):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    OverrideFieldStruct = collections.OrderedDict()\n    if OverrideStruct:\n        for (_, Values) in OverrideStruct.items():\n            for (Key, value) in Values.items():\n                if value[1] and value[1].endswith('.dsc'):\n                    OverrideFieldStruct[Key] = value\n    if Pcd.PcdFieldValueFromFdf:\n        for (Key, Values) in Pcd.PcdFieldValueFromFdf.items():\n            if Key in OverrideFieldStruct and Values[0] == OverrideFieldStruct[Key][0]:\n                continue\n            OverrideFieldStruct[Key] = Values\n    if Pcd.PcdFieldValueFromComm:\n        for (Key, Values) in Pcd.PcdFieldValueFromComm.items():\n            if Key in OverrideFieldStruct and Values[0] == OverrideFieldStruct[Key][0]:\n                continue\n            OverrideFieldStruct[Key] = Values\n    return OverrideFieldStruct",
            "def OverrideFieldValue(self, Pcd, OverrideStruct):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    OverrideFieldStruct = collections.OrderedDict()\n    if OverrideStruct:\n        for (_, Values) in OverrideStruct.items():\n            for (Key, value) in Values.items():\n                if value[1] and value[1].endswith('.dsc'):\n                    OverrideFieldStruct[Key] = value\n    if Pcd.PcdFieldValueFromFdf:\n        for (Key, Values) in Pcd.PcdFieldValueFromFdf.items():\n            if Key in OverrideFieldStruct and Values[0] == OverrideFieldStruct[Key][0]:\n                continue\n            OverrideFieldStruct[Key] = Values\n    if Pcd.PcdFieldValueFromComm:\n        for (Key, Values) in Pcd.PcdFieldValueFromComm.items():\n            if Key in OverrideFieldStruct and Values[0] == OverrideFieldStruct[Key][0]:\n                continue\n            OverrideFieldStruct[Key] = Values\n    return OverrideFieldStruct"
        ]
    },
    {
        "func_name": "PrintStructureInfo",
        "original": "def PrintStructureInfo(self, File, Struct):\n    for (Key, Value) in sorted(Struct.items(), key=lambda x: x[0]):\n        if Value[1] and 'build command options' in Value[1]:\n            FileWrite(File, '    *B  %-*s = %s' % (self.MaxLen + 4, '.' + Key, Value[0]))\n        elif Value[1] and Value[1].endswith('.fdf'):\n            FileWrite(File, '    *F  %-*s = %s' % (self.MaxLen + 4, '.' + Key, Value[0]))\n        else:\n            FileWrite(File, '        %-*s = %s' % (self.MaxLen + 4, '.' + Key, Value[0]))",
        "mutated": [
            "def PrintStructureInfo(self, File, Struct):\n    if False:\n        i = 10\n    for (Key, Value) in sorted(Struct.items(), key=lambda x: x[0]):\n        if Value[1] and 'build command options' in Value[1]:\n            FileWrite(File, '    *B  %-*s = %s' % (self.MaxLen + 4, '.' + Key, Value[0]))\n        elif Value[1] and Value[1].endswith('.fdf'):\n            FileWrite(File, '    *F  %-*s = %s' % (self.MaxLen + 4, '.' + Key, Value[0]))\n        else:\n            FileWrite(File, '        %-*s = %s' % (self.MaxLen + 4, '.' + Key, Value[0]))",
            "def PrintStructureInfo(self, File, Struct):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    for (Key, Value) in sorted(Struct.items(), key=lambda x: x[0]):\n        if Value[1] and 'build command options' in Value[1]:\n            FileWrite(File, '    *B  %-*s = %s' % (self.MaxLen + 4, '.' + Key, Value[0]))\n        elif Value[1] and Value[1].endswith('.fdf'):\n            FileWrite(File, '    *F  %-*s = %s' % (self.MaxLen + 4, '.' + Key, Value[0]))\n        else:\n            FileWrite(File, '        %-*s = %s' % (self.MaxLen + 4, '.' + Key, Value[0]))",
            "def PrintStructureInfo(self, File, Struct):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    for (Key, Value) in sorted(Struct.items(), key=lambda x: x[0]):\n        if Value[1] and 'build command options' in Value[1]:\n            FileWrite(File, '    *B  %-*s = %s' % (self.MaxLen + 4, '.' + Key, Value[0]))\n        elif Value[1] and Value[1].endswith('.fdf'):\n            FileWrite(File, '    *F  %-*s = %s' % (self.MaxLen + 4, '.' + Key, Value[0]))\n        else:\n            FileWrite(File, '        %-*s = %s' % (self.MaxLen + 4, '.' + Key, Value[0]))",
            "def PrintStructureInfo(self, File, Struct):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    for (Key, Value) in sorted(Struct.items(), key=lambda x: x[0]):\n        if Value[1] and 'build command options' in Value[1]:\n            FileWrite(File, '    *B  %-*s = %s' % (self.MaxLen + 4, '.' + Key, Value[0]))\n        elif Value[1] and Value[1].endswith('.fdf'):\n            FileWrite(File, '    *F  %-*s = %s' % (self.MaxLen + 4, '.' + Key, Value[0]))\n        else:\n            FileWrite(File, '        %-*s = %s' % (self.MaxLen + 4, '.' + Key, Value[0]))",
            "def PrintStructureInfo(self, File, Struct):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    for (Key, Value) in sorted(Struct.items(), key=lambda x: x[0]):\n        if Value[1] and 'build command options' in Value[1]:\n            FileWrite(File, '    *B  %-*s = %s' % (self.MaxLen + 4, '.' + Key, Value[0]))\n        elif Value[1] and Value[1].endswith('.fdf'):\n            FileWrite(File, '    *F  %-*s = %s' % (self.MaxLen + 4, '.' + Key, Value[0]))\n        else:\n            FileWrite(File, '        %-*s = %s' % (self.MaxLen + 4, '.' + Key, Value[0]))"
        ]
    },
    {
        "func_name": "StrtoHex",
        "original": "def StrtoHex(self, value):\n    try:\n        value = hex(int(value))\n        return value\n    except:\n        if value.startswith('L\"') and value.endswith('\"'):\n            valuelist = []\n            for ch in value[2:-1]:\n                valuelist.append(hex(ord(ch)))\n                valuelist.append('0x00')\n            return valuelist\n        elif value.startswith('\"') and value.endswith('\"'):\n            return hex(ord(value[1:-1]))\n        elif value.startswith('{') and value.endswith('}'):\n            valuelist = []\n            if ',' not in value:\n                return value[1:-1]\n            for ch in value[1:-1].split(','):\n                ch = ch.strip()\n                if ch.startswith('0x') or ch.startswith('0X'):\n                    valuelist.append(ch)\n                    continue\n                try:\n                    valuelist.append(hex(int(ch.strip())))\n                except:\n                    pass\n            return valuelist\n        else:\n            return value",
        "mutated": [
            "def StrtoHex(self, value):\n    if False:\n        i = 10\n    try:\n        value = hex(int(value))\n        return value\n    except:\n        if value.startswith('L\"') and value.endswith('\"'):\n            valuelist = []\n            for ch in value[2:-1]:\n                valuelist.append(hex(ord(ch)))\n                valuelist.append('0x00')\n            return valuelist\n        elif value.startswith('\"') and value.endswith('\"'):\n            return hex(ord(value[1:-1]))\n        elif value.startswith('{') and value.endswith('}'):\n            valuelist = []\n            if ',' not in value:\n                return value[1:-1]\n            for ch in value[1:-1].split(','):\n                ch = ch.strip()\n                if ch.startswith('0x') or ch.startswith('0X'):\n                    valuelist.append(ch)\n                    continue\n                try:\n                    valuelist.append(hex(int(ch.strip())))\n                except:\n                    pass\n            return valuelist\n        else:\n            return value",
            "def StrtoHex(self, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        value = hex(int(value))\n        return value\n    except:\n        if value.startswith('L\"') and value.endswith('\"'):\n            valuelist = []\n            for ch in value[2:-1]:\n                valuelist.append(hex(ord(ch)))\n                valuelist.append('0x00')\n            return valuelist\n        elif value.startswith('\"') and value.endswith('\"'):\n            return hex(ord(value[1:-1]))\n        elif value.startswith('{') and value.endswith('}'):\n            valuelist = []\n            if ',' not in value:\n                return value[1:-1]\n            for ch in value[1:-1].split(','):\n                ch = ch.strip()\n                if ch.startswith('0x') or ch.startswith('0X'):\n                    valuelist.append(ch)\n                    continue\n                try:\n                    valuelist.append(hex(int(ch.strip())))\n                except:\n                    pass\n            return valuelist\n        else:\n            return value",
            "def StrtoHex(self, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        value = hex(int(value))\n        return value\n    except:\n        if value.startswith('L\"') and value.endswith('\"'):\n            valuelist = []\n            for ch in value[2:-1]:\n                valuelist.append(hex(ord(ch)))\n                valuelist.append('0x00')\n            return valuelist\n        elif value.startswith('\"') and value.endswith('\"'):\n            return hex(ord(value[1:-1]))\n        elif value.startswith('{') and value.endswith('}'):\n            valuelist = []\n            if ',' not in value:\n                return value[1:-1]\n            for ch in value[1:-1].split(','):\n                ch = ch.strip()\n                if ch.startswith('0x') or ch.startswith('0X'):\n                    valuelist.append(ch)\n                    continue\n                try:\n                    valuelist.append(hex(int(ch.strip())))\n                except:\n                    pass\n            return valuelist\n        else:\n            return value",
            "def StrtoHex(self, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        value = hex(int(value))\n        return value\n    except:\n        if value.startswith('L\"') and value.endswith('\"'):\n            valuelist = []\n            for ch in value[2:-1]:\n                valuelist.append(hex(ord(ch)))\n                valuelist.append('0x00')\n            return valuelist\n        elif value.startswith('\"') and value.endswith('\"'):\n            return hex(ord(value[1:-1]))\n        elif value.startswith('{') and value.endswith('}'):\n            valuelist = []\n            if ',' not in value:\n                return value[1:-1]\n            for ch in value[1:-1].split(','):\n                ch = ch.strip()\n                if ch.startswith('0x') or ch.startswith('0X'):\n                    valuelist.append(ch)\n                    continue\n                try:\n                    valuelist.append(hex(int(ch.strip())))\n                except:\n                    pass\n            return valuelist\n        else:\n            return value",
            "def StrtoHex(self, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        value = hex(int(value))\n        return value\n    except:\n        if value.startswith('L\"') and value.endswith('\"'):\n            valuelist = []\n            for ch in value[2:-1]:\n                valuelist.append(hex(ord(ch)))\n                valuelist.append('0x00')\n            return valuelist\n        elif value.startswith('\"') and value.endswith('\"'):\n            return hex(ord(value[1:-1]))\n        elif value.startswith('{') and value.endswith('}'):\n            valuelist = []\n            if ',' not in value:\n                return value[1:-1]\n            for ch in value[1:-1].split(','):\n                ch = ch.strip()\n                if ch.startswith('0x') or ch.startswith('0X'):\n                    valuelist.append(ch)\n                    continue\n                try:\n                    valuelist.append(hex(int(ch.strip())))\n                except:\n                    pass\n            return valuelist\n        else:\n            return value"
        ]
    },
    {
        "func_name": "IsStructurePcd",
        "original": "def IsStructurePcd(self, PcdToken, PcdTokenSpaceGuid):\n    if GlobalData.gStructurePcd and self.Arch in GlobalData.gStructurePcd and ((PcdToken, PcdTokenSpaceGuid) in GlobalData.gStructurePcd[self.Arch]):\n        return True\n    else:\n        return False",
        "mutated": [
            "def IsStructurePcd(self, PcdToken, PcdTokenSpaceGuid):\n    if False:\n        i = 10\n    if GlobalData.gStructurePcd and self.Arch in GlobalData.gStructurePcd and ((PcdToken, PcdTokenSpaceGuid) in GlobalData.gStructurePcd[self.Arch]):\n        return True\n    else:\n        return False",
            "def IsStructurePcd(self, PcdToken, PcdTokenSpaceGuid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if GlobalData.gStructurePcd and self.Arch in GlobalData.gStructurePcd and ((PcdToken, PcdTokenSpaceGuid) in GlobalData.gStructurePcd[self.Arch]):\n        return True\n    else:\n        return False",
            "def IsStructurePcd(self, PcdToken, PcdTokenSpaceGuid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if GlobalData.gStructurePcd and self.Arch in GlobalData.gStructurePcd and ((PcdToken, PcdTokenSpaceGuid) in GlobalData.gStructurePcd[self.Arch]):\n        return True\n    else:\n        return False",
            "def IsStructurePcd(self, PcdToken, PcdTokenSpaceGuid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if GlobalData.gStructurePcd and self.Arch in GlobalData.gStructurePcd and ((PcdToken, PcdTokenSpaceGuid) in GlobalData.gStructurePcd[self.Arch]):\n        return True\n    else:\n        return False",
            "def IsStructurePcd(self, PcdToken, PcdTokenSpaceGuid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if GlobalData.gStructurePcd and self.Arch in GlobalData.gStructurePcd and ((PcdToken, PcdTokenSpaceGuid) in GlobalData.gStructurePcd[self.Arch]):\n        return True\n    else:\n        return False"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, Wa):\n    self._MapFileName = os.path.join(Wa.BuildDir, Wa.Name + '.map')\n    self._MapFileParsed = False\n    self._EotToolInvoked = False\n    self._FvDir = Wa.FvDir\n    self._EotDir = Wa.BuildDir\n    self._FfsEntryPoint = {}\n    self._GuidMap = {}\n    self._SourceList = []\n    self.FixedMapDict = {}\n    self.ItemList = []\n    self.MaxLen = 0\n    for Pa in Wa.AutoGenObjectList:\n        for Module in Pa.LibraryAutoGenList + Pa.ModuleAutoGenList:\n            if Module.ModuleType == SUP_MODULE_BASE:\n                continue\n            self._SourceList.append(str(Module))\n            IncludeList = {}\n            for Source in Module.SourceFileList:\n                if os.path.splitext(str(Source))[1].lower() == '.c':\n                    self._SourceList.append('  ' + str(Source))\n                    FindIncludeFiles(Source.Path, Module.IncludePathList, IncludeList)\n            for IncludeFile in IncludeList.values():\n                self._SourceList.append('  ' + IncludeFile)\n            for Guid in Module.PpiList:\n                self._GuidMap[Guid] = GuidStructureStringToGuidString(Module.PpiList[Guid])\n            for Guid in Module.ProtocolList:\n                self._GuidMap[Guid] = GuidStructureStringToGuidString(Module.ProtocolList[Guid])\n            for Guid in Module.GuidList:\n                self._GuidMap[Guid] = GuidStructureStringToGuidString(Module.GuidList[Guid])\n            if Module.Guid and (not Module.IsLibrary):\n                EntryPoint = ' '.join(Module.Module.ModuleEntryPointList)\n                RealEntryPoint = '_ModuleEntryPoint'\n                self._FfsEntryPoint[Module.Guid.upper()] = (EntryPoint, RealEntryPoint)\n    self._FvList = []\n    if Wa.FdfProfile:\n        for Fd in Wa.FdfProfile.FdDict:\n            for FdRegion in Wa.FdfProfile.FdDict[Fd].RegionList:\n                if FdRegion.RegionType != BINARY_FILE_TYPE_FV:\n                    continue\n                for FvName in FdRegion.RegionDataList:\n                    if FvName in self._FvList:\n                        continue\n                    self._FvList.append(FvName)\n                    for Ffs in Wa.FdfProfile.FvDict[FvName.upper()].FfsList:\n                        for Section in Ffs.SectionList:\n                            try:\n                                for FvSection in Section.SectionList:\n                                    if FvSection.FvName in self._FvList:\n                                        continue\n                                    self._FvList.append(FvSection.FvName)\n                            except AttributeError:\n                                pass",
        "mutated": [
            "def __init__(self, Wa):\n    if False:\n        i = 10\n    self._MapFileName = os.path.join(Wa.BuildDir, Wa.Name + '.map')\n    self._MapFileParsed = False\n    self._EotToolInvoked = False\n    self._FvDir = Wa.FvDir\n    self._EotDir = Wa.BuildDir\n    self._FfsEntryPoint = {}\n    self._GuidMap = {}\n    self._SourceList = []\n    self.FixedMapDict = {}\n    self.ItemList = []\n    self.MaxLen = 0\n    for Pa in Wa.AutoGenObjectList:\n        for Module in Pa.LibraryAutoGenList + Pa.ModuleAutoGenList:\n            if Module.ModuleType == SUP_MODULE_BASE:\n                continue\n            self._SourceList.append(str(Module))\n            IncludeList = {}\n            for Source in Module.SourceFileList:\n                if os.path.splitext(str(Source))[1].lower() == '.c':\n                    self._SourceList.append('  ' + str(Source))\n                    FindIncludeFiles(Source.Path, Module.IncludePathList, IncludeList)\n            for IncludeFile in IncludeList.values():\n                self._SourceList.append('  ' + IncludeFile)\n            for Guid in Module.PpiList:\n                self._GuidMap[Guid] = GuidStructureStringToGuidString(Module.PpiList[Guid])\n            for Guid in Module.ProtocolList:\n                self._GuidMap[Guid] = GuidStructureStringToGuidString(Module.ProtocolList[Guid])\n            for Guid in Module.GuidList:\n                self._GuidMap[Guid] = GuidStructureStringToGuidString(Module.GuidList[Guid])\n            if Module.Guid and (not Module.IsLibrary):\n                EntryPoint = ' '.join(Module.Module.ModuleEntryPointList)\n                RealEntryPoint = '_ModuleEntryPoint'\n                self._FfsEntryPoint[Module.Guid.upper()] = (EntryPoint, RealEntryPoint)\n    self._FvList = []\n    if Wa.FdfProfile:\n        for Fd in Wa.FdfProfile.FdDict:\n            for FdRegion in Wa.FdfProfile.FdDict[Fd].RegionList:\n                if FdRegion.RegionType != BINARY_FILE_TYPE_FV:\n                    continue\n                for FvName in FdRegion.RegionDataList:\n                    if FvName in self._FvList:\n                        continue\n                    self._FvList.append(FvName)\n                    for Ffs in Wa.FdfProfile.FvDict[FvName.upper()].FfsList:\n                        for Section in Ffs.SectionList:\n                            try:\n                                for FvSection in Section.SectionList:\n                                    if FvSection.FvName in self._FvList:\n                                        continue\n                                    self._FvList.append(FvSection.FvName)\n                            except AttributeError:\n                                pass",
            "def __init__(self, Wa):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._MapFileName = os.path.join(Wa.BuildDir, Wa.Name + '.map')\n    self._MapFileParsed = False\n    self._EotToolInvoked = False\n    self._FvDir = Wa.FvDir\n    self._EotDir = Wa.BuildDir\n    self._FfsEntryPoint = {}\n    self._GuidMap = {}\n    self._SourceList = []\n    self.FixedMapDict = {}\n    self.ItemList = []\n    self.MaxLen = 0\n    for Pa in Wa.AutoGenObjectList:\n        for Module in Pa.LibraryAutoGenList + Pa.ModuleAutoGenList:\n            if Module.ModuleType == SUP_MODULE_BASE:\n                continue\n            self._SourceList.append(str(Module))\n            IncludeList = {}\n            for Source in Module.SourceFileList:\n                if os.path.splitext(str(Source))[1].lower() == '.c':\n                    self._SourceList.append('  ' + str(Source))\n                    FindIncludeFiles(Source.Path, Module.IncludePathList, IncludeList)\n            for IncludeFile in IncludeList.values():\n                self._SourceList.append('  ' + IncludeFile)\n            for Guid in Module.PpiList:\n                self._GuidMap[Guid] = GuidStructureStringToGuidString(Module.PpiList[Guid])\n            for Guid in Module.ProtocolList:\n                self._GuidMap[Guid] = GuidStructureStringToGuidString(Module.ProtocolList[Guid])\n            for Guid in Module.GuidList:\n                self._GuidMap[Guid] = GuidStructureStringToGuidString(Module.GuidList[Guid])\n            if Module.Guid and (not Module.IsLibrary):\n                EntryPoint = ' '.join(Module.Module.ModuleEntryPointList)\n                RealEntryPoint = '_ModuleEntryPoint'\n                self._FfsEntryPoint[Module.Guid.upper()] = (EntryPoint, RealEntryPoint)\n    self._FvList = []\n    if Wa.FdfProfile:\n        for Fd in Wa.FdfProfile.FdDict:\n            for FdRegion in Wa.FdfProfile.FdDict[Fd].RegionList:\n                if FdRegion.RegionType != BINARY_FILE_TYPE_FV:\n                    continue\n                for FvName in FdRegion.RegionDataList:\n                    if FvName in self._FvList:\n                        continue\n                    self._FvList.append(FvName)\n                    for Ffs in Wa.FdfProfile.FvDict[FvName.upper()].FfsList:\n                        for Section in Ffs.SectionList:\n                            try:\n                                for FvSection in Section.SectionList:\n                                    if FvSection.FvName in self._FvList:\n                                        continue\n                                    self._FvList.append(FvSection.FvName)\n                            except AttributeError:\n                                pass",
            "def __init__(self, Wa):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._MapFileName = os.path.join(Wa.BuildDir, Wa.Name + '.map')\n    self._MapFileParsed = False\n    self._EotToolInvoked = False\n    self._FvDir = Wa.FvDir\n    self._EotDir = Wa.BuildDir\n    self._FfsEntryPoint = {}\n    self._GuidMap = {}\n    self._SourceList = []\n    self.FixedMapDict = {}\n    self.ItemList = []\n    self.MaxLen = 0\n    for Pa in Wa.AutoGenObjectList:\n        for Module in Pa.LibraryAutoGenList + Pa.ModuleAutoGenList:\n            if Module.ModuleType == SUP_MODULE_BASE:\n                continue\n            self._SourceList.append(str(Module))\n            IncludeList = {}\n            for Source in Module.SourceFileList:\n                if os.path.splitext(str(Source))[1].lower() == '.c':\n                    self._SourceList.append('  ' + str(Source))\n                    FindIncludeFiles(Source.Path, Module.IncludePathList, IncludeList)\n            for IncludeFile in IncludeList.values():\n                self._SourceList.append('  ' + IncludeFile)\n            for Guid in Module.PpiList:\n                self._GuidMap[Guid] = GuidStructureStringToGuidString(Module.PpiList[Guid])\n            for Guid in Module.ProtocolList:\n                self._GuidMap[Guid] = GuidStructureStringToGuidString(Module.ProtocolList[Guid])\n            for Guid in Module.GuidList:\n                self._GuidMap[Guid] = GuidStructureStringToGuidString(Module.GuidList[Guid])\n            if Module.Guid and (not Module.IsLibrary):\n                EntryPoint = ' '.join(Module.Module.ModuleEntryPointList)\n                RealEntryPoint = '_ModuleEntryPoint'\n                self._FfsEntryPoint[Module.Guid.upper()] = (EntryPoint, RealEntryPoint)\n    self._FvList = []\n    if Wa.FdfProfile:\n        for Fd in Wa.FdfProfile.FdDict:\n            for FdRegion in Wa.FdfProfile.FdDict[Fd].RegionList:\n                if FdRegion.RegionType != BINARY_FILE_TYPE_FV:\n                    continue\n                for FvName in FdRegion.RegionDataList:\n                    if FvName in self._FvList:\n                        continue\n                    self._FvList.append(FvName)\n                    for Ffs in Wa.FdfProfile.FvDict[FvName.upper()].FfsList:\n                        for Section in Ffs.SectionList:\n                            try:\n                                for FvSection in Section.SectionList:\n                                    if FvSection.FvName in self._FvList:\n                                        continue\n                                    self._FvList.append(FvSection.FvName)\n                            except AttributeError:\n                                pass",
            "def __init__(self, Wa):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._MapFileName = os.path.join(Wa.BuildDir, Wa.Name + '.map')\n    self._MapFileParsed = False\n    self._EotToolInvoked = False\n    self._FvDir = Wa.FvDir\n    self._EotDir = Wa.BuildDir\n    self._FfsEntryPoint = {}\n    self._GuidMap = {}\n    self._SourceList = []\n    self.FixedMapDict = {}\n    self.ItemList = []\n    self.MaxLen = 0\n    for Pa in Wa.AutoGenObjectList:\n        for Module in Pa.LibraryAutoGenList + Pa.ModuleAutoGenList:\n            if Module.ModuleType == SUP_MODULE_BASE:\n                continue\n            self._SourceList.append(str(Module))\n            IncludeList = {}\n            for Source in Module.SourceFileList:\n                if os.path.splitext(str(Source))[1].lower() == '.c':\n                    self._SourceList.append('  ' + str(Source))\n                    FindIncludeFiles(Source.Path, Module.IncludePathList, IncludeList)\n            for IncludeFile in IncludeList.values():\n                self._SourceList.append('  ' + IncludeFile)\n            for Guid in Module.PpiList:\n                self._GuidMap[Guid] = GuidStructureStringToGuidString(Module.PpiList[Guid])\n            for Guid in Module.ProtocolList:\n                self._GuidMap[Guid] = GuidStructureStringToGuidString(Module.ProtocolList[Guid])\n            for Guid in Module.GuidList:\n                self._GuidMap[Guid] = GuidStructureStringToGuidString(Module.GuidList[Guid])\n            if Module.Guid and (not Module.IsLibrary):\n                EntryPoint = ' '.join(Module.Module.ModuleEntryPointList)\n                RealEntryPoint = '_ModuleEntryPoint'\n                self._FfsEntryPoint[Module.Guid.upper()] = (EntryPoint, RealEntryPoint)\n    self._FvList = []\n    if Wa.FdfProfile:\n        for Fd in Wa.FdfProfile.FdDict:\n            for FdRegion in Wa.FdfProfile.FdDict[Fd].RegionList:\n                if FdRegion.RegionType != BINARY_FILE_TYPE_FV:\n                    continue\n                for FvName in FdRegion.RegionDataList:\n                    if FvName in self._FvList:\n                        continue\n                    self._FvList.append(FvName)\n                    for Ffs in Wa.FdfProfile.FvDict[FvName.upper()].FfsList:\n                        for Section in Ffs.SectionList:\n                            try:\n                                for FvSection in Section.SectionList:\n                                    if FvSection.FvName in self._FvList:\n                                        continue\n                                    self._FvList.append(FvSection.FvName)\n                            except AttributeError:\n                                pass",
            "def __init__(self, Wa):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._MapFileName = os.path.join(Wa.BuildDir, Wa.Name + '.map')\n    self._MapFileParsed = False\n    self._EotToolInvoked = False\n    self._FvDir = Wa.FvDir\n    self._EotDir = Wa.BuildDir\n    self._FfsEntryPoint = {}\n    self._GuidMap = {}\n    self._SourceList = []\n    self.FixedMapDict = {}\n    self.ItemList = []\n    self.MaxLen = 0\n    for Pa in Wa.AutoGenObjectList:\n        for Module in Pa.LibraryAutoGenList + Pa.ModuleAutoGenList:\n            if Module.ModuleType == SUP_MODULE_BASE:\n                continue\n            self._SourceList.append(str(Module))\n            IncludeList = {}\n            for Source in Module.SourceFileList:\n                if os.path.splitext(str(Source))[1].lower() == '.c':\n                    self._SourceList.append('  ' + str(Source))\n                    FindIncludeFiles(Source.Path, Module.IncludePathList, IncludeList)\n            for IncludeFile in IncludeList.values():\n                self._SourceList.append('  ' + IncludeFile)\n            for Guid in Module.PpiList:\n                self._GuidMap[Guid] = GuidStructureStringToGuidString(Module.PpiList[Guid])\n            for Guid in Module.ProtocolList:\n                self._GuidMap[Guid] = GuidStructureStringToGuidString(Module.ProtocolList[Guid])\n            for Guid in Module.GuidList:\n                self._GuidMap[Guid] = GuidStructureStringToGuidString(Module.GuidList[Guid])\n            if Module.Guid and (not Module.IsLibrary):\n                EntryPoint = ' '.join(Module.Module.ModuleEntryPointList)\n                RealEntryPoint = '_ModuleEntryPoint'\n                self._FfsEntryPoint[Module.Guid.upper()] = (EntryPoint, RealEntryPoint)\n    self._FvList = []\n    if Wa.FdfProfile:\n        for Fd in Wa.FdfProfile.FdDict:\n            for FdRegion in Wa.FdfProfile.FdDict[Fd].RegionList:\n                if FdRegion.RegionType != BINARY_FILE_TYPE_FV:\n                    continue\n                for FvName in FdRegion.RegionDataList:\n                    if FvName in self._FvList:\n                        continue\n                    self._FvList.append(FvName)\n                    for Ffs in Wa.FdfProfile.FvDict[FvName.upper()].FfsList:\n                        for Section in Ffs.SectionList:\n                            try:\n                                for FvSection in Section.SectionList:\n                                    if FvSection.FvName in self._FvList:\n                                        continue\n                                    self._FvList.append(FvSection.FvName)\n                            except AttributeError:\n                                pass"
        ]
    },
    {
        "func_name": "_ParseMapFile",
        "original": "def _ParseMapFile(self):\n    if self._MapFileParsed:\n        return\n    self._MapFileParsed = True\n    if os.path.isfile(self._MapFileName):\n        try:\n            FileContents = open(self._MapFileName).read()\n            for Match in gMapFileItemPattern.finditer(FileContents):\n                AddressType = Match.group(1)\n                BaseAddress = Match.group(2)\n                EntryPoint = Match.group(3)\n                Guid = Match.group(4).upper()\n                List = self.FixedMapDict.setdefault(Guid, [])\n                List.append((AddressType, BaseAddress, '*I'))\n                List.append((AddressType, EntryPoint, '*E'))\n        except:\n            EdkLogger.warn(None, 'Cannot open file to read', self._MapFileName)",
        "mutated": [
            "def _ParseMapFile(self):\n    if False:\n        i = 10\n    if self._MapFileParsed:\n        return\n    self._MapFileParsed = True\n    if os.path.isfile(self._MapFileName):\n        try:\n            FileContents = open(self._MapFileName).read()\n            for Match in gMapFileItemPattern.finditer(FileContents):\n                AddressType = Match.group(1)\n                BaseAddress = Match.group(2)\n                EntryPoint = Match.group(3)\n                Guid = Match.group(4).upper()\n                List = self.FixedMapDict.setdefault(Guid, [])\n                List.append((AddressType, BaseAddress, '*I'))\n                List.append((AddressType, EntryPoint, '*E'))\n        except:\n            EdkLogger.warn(None, 'Cannot open file to read', self._MapFileName)",
            "def _ParseMapFile(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._MapFileParsed:\n        return\n    self._MapFileParsed = True\n    if os.path.isfile(self._MapFileName):\n        try:\n            FileContents = open(self._MapFileName).read()\n            for Match in gMapFileItemPattern.finditer(FileContents):\n                AddressType = Match.group(1)\n                BaseAddress = Match.group(2)\n                EntryPoint = Match.group(3)\n                Guid = Match.group(4).upper()\n                List = self.FixedMapDict.setdefault(Guid, [])\n                List.append((AddressType, BaseAddress, '*I'))\n                List.append((AddressType, EntryPoint, '*E'))\n        except:\n            EdkLogger.warn(None, 'Cannot open file to read', self._MapFileName)",
            "def _ParseMapFile(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._MapFileParsed:\n        return\n    self._MapFileParsed = True\n    if os.path.isfile(self._MapFileName):\n        try:\n            FileContents = open(self._MapFileName).read()\n            for Match in gMapFileItemPattern.finditer(FileContents):\n                AddressType = Match.group(1)\n                BaseAddress = Match.group(2)\n                EntryPoint = Match.group(3)\n                Guid = Match.group(4).upper()\n                List = self.FixedMapDict.setdefault(Guid, [])\n                List.append((AddressType, BaseAddress, '*I'))\n                List.append((AddressType, EntryPoint, '*E'))\n        except:\n            EdkLogger.warn(None, 'Cannot open file to read', self._MapFileName)",
            "def _ParseMapFile(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._MapFileParsed:\n        return\n    self._MapFileParsed = True\n    if os.path.isfile(self._MapFileName):\n        try:\n            FileContents = open(self._MapFileName).read()\n            for Match in gMapFileItemPattern.finditer(FileContents):\n                AddressType = Match.group(1)\n                BaseAddress = Match.group(2)\n                EntryPoint = Match.group(3)\n                Guid = Match.group(4).upper()\n                List = self.FixedMapDict.setdefault(Guid, [])\n                List.append((AddressType, BaseAddress, '*I'))\n                List.append((AddressType, EntryPoint, '*E'))\n        except:\n            EdkLogger.warn(None, 'Cannot open file to read', self._MapFileName)",
            "def _ParseMapFile(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._MapFileParsed:\n        return\n    self._MapFileParsed = True\n    if os.path.isfile(self._MapFileName):\n        try:\n            FileContents = open(self._MapFileName).read()\n            for Match in gMapFileItemPattern.finditer(FileContents):\n                AddressType = Match.group(1)\n                BaseAddress = Match.group(2)\n                EntryPoint = Match.group(3)\n                Guid = Match.group(4).upper()\n                List = self.FixedMapDict.setdefault(Guid, [])\n                List.append((AddressType, BaseAddress, '*I'))\n                List.append((AddressType, EntryPoint, '*E'))\n        except:\n            EdkLogger.warn(None, 'Cannot open file to read', self._MapFileName)"
        ]
    },
    {
        "func_name": "_InvokeEotTool",
        "original": "def _InvokeEotTool(self):\n    if self._EotToolInvoked:\n        return\n    self._EotToolInvoked = True\n    FvFileList = []\n    for FvName in self._FvList:\n        FvFile = os.path.join(self._FvDir, FvName + '.Fv')\n        if os.path.isfile(FvFile):\n            FvFileList.append(FvFile)\n    if len(FvFileList) == 0:\n        return\n    SourceList = os.path.join(self._EotDir, 'SourceFile.txt')\n    GuidList = os.path.join(self._EotDir, 'GuidList.txt')\n    DispatchList = os.path.join(self._EotDir, 'Dispatch.txt')\n    TempFile = []\n    for Item in self._SourceList:\n        FileWrite(TempFile, Item)\n    SaveFileOnChange(SourceList, ''.join(TempFile), False)\n    TempFile = []\n    for Key in self._GuidMap:\n        FileWrite(TempFile, '%s %s' % (Key, self._GuidMap[Key]))\n    SaveFileOnChange(GuidList, ''.join(TempFile), False)\n    try:\n        from Eot.EotMain import Eot\n        EotStartTime = time.time()\n        Eot(CommandLineOption=False, SourceFileList=SourceList, GuidList=GuidList, FvFileList=' '.join(FvFileList), Dispatch=DispatchList, IsInit=True)\n        EotEndTime = time.time()\n        EotDuration = time.strftime('%H:%M:%S', time.gmtime(int(round(EotEndTime - EotStartTime))))\n        EdkLogger.quiet('EOT run time: %s\\n' % EotDuration)\n        for Line in open(DispatchList):\n            if len(Line.split()) < 4:\n                continue\n            (Guid, Phase, FfsName, FilePath) = Line.split()\n            Symbol = self._FfsEntryPoint.get(Guid, [FfsName, ''])[0]\n            if len(Symbol) > self.MaxLen:\n                self.MaxLen = len(Symbol)\n            self.ItemList.append((Phase, Symbol, FilePath))\n    except:\n        EdkLogger.quiet('(Python %s on %s\\n%s)' % (platform.python_version(), sys.platform, traceback.format_exc()))\n        EdkLogger.warn(None, 'Failed to generate execution order prediction report, for some error occurred in executing EOT.')",
        "mutated": [
            "def _InvokeEotTool(self):\n    if False:\n        i = 10\n    if self._EotToolInvoked:\n        return\n    self._EotToolInvoked = True\n    FvFileList = []\n    for FvName in self._FvList:\n        FvFile = os.path.join(self._FvDir, FvName + '.Fv')\n        if os.path.isfile(FvFile):\n            FvFileList.append(FvFile)\n    if len(FvFileList) == 0:\n        return\n    SourceList = os.path.join(self._EotDir, 'SourceFile.txt')\n    GuidList = os.path.join(self._EotDir, 'GuidList.txt')\n    DispatchList = os.path.join(self._EotDir, 'Dispatch.txt')\n    TempFile = []\n    for Item in self._SourceList:\n        FileWrite(TempFile, Item)\n    SaveFileOnChange(SourceList, ''.join(TempFile), False)\n    TempFile = []\n    for Key in self._GuidMap:\n        FileWrite(TempFile, '%s %s' % (Key, self._GuidMap[Key]))\n    SaveFileOnChange(GuidList, ''.join(TempFile), False)\n    try:\n        from Eot.EotMain import Eot\n        EotStartTime = time.time()\n        Eot(CommandLineOption=False, SourceFileList=SourceList, GuidList=GuidList, FvFileList=' '.join(FvFileList), Dispatch=DispatchList, IsInit=True)\n        EotEndTime = time.time()\n        EotDuration = time.strftime('%H:%M:%S', time.gmtime(int(round(EotEndTime - EotStartTime))))\n        EdkLogger.quiet('EOT run time: %s\\n' % EotDuration)\n        for Line in open(DispatchList):\n            if len(Line.split()) < 4:\n                continue\n            (Guid, Phase, FfsName, FilePath) = Line.split()\n            Symbol = self._FfsEntryPoint.get(Guid, [FfsName, ''])[0]\n            if len(Symbol) > self.MaxLen:\n                self.MaxLen = len(Symbol)\n            self.ItemList.append((Phase, Symbol, FilePath))\n    except:\n        EdkLogger.quiet('(Python %s on %s\\n%s)' % (platform.python_version(), sys.platform, traceback.format_exc()))\n        EdkLogger.warn(None, 'Failed to generate execution order prediction report, for some error occurred in executing EOT.')",
            "def _InvokeEotTool(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._EotToolInvoked:\n        return\n    self._EotToolInvoked = True\n    FvFileList = []\n    for FvName in self._FvList:\n        FvFile = os.path.join(self._FvDir, FvName + '.Fv')\n        if os.path.isfile(FvFile):\n            FvFileList.append(FvFile)\n    if len(FvFileList) == 0:\n        return\n    SourceList = os.path.join(self._EotDir, 'SourceFile.txt')\n    GuidList = os.path.join(self._EotDir, 'GuidList.txt')\n    DispatchList = os.path.join(self._EotDir, 'Dispatch.txt')\n    TempFile = []\n    for Item in self._SourceList:\n        FileWrite(TempFile, Item)\n    SaveFileOnChange(SourceList, ''.join(TempFile), False)\n    TempFile = []\n    for Key in self._GuidMap:\n        FileWrite(TempFile, '%s %s' % (Key, self._GuidMap[Key]))\n    SaveFileOnChange(GuidList, ''.join(TempFile), False)\n    try:\n        from Eot.EotMain import Eot\n        EotStartTime = time.time()\n        Eot(CommandLineOption=False, SourceFileList=SourceList, GuidList=GuidList, FvFileList=' '.join(FvFileList), Dispatch=DispatchList, IsInit=True)\n        EotEndTime = time.time()\n        EotDuration = time.strftime('%H:%M:%S', time.gmtime(int(round(EotEndTime - EotStartTime))))\n        EdkLogger.quiet('EOT run time: %s\\n' % EotDuration)\n        for Line in open(DispatchList):\n            if len(Line.split()) < 4:\n                continue\n            (Guid, Phase, FfsName, FilePath) = Line.split()\n            Symbol = self._FfsEntryPoint.get(Guid, [FfsName, ''])[0]\n            if len(Symbol) > self.MaxLen:\n                self.MaxLen = len(Symbol)\n            self.ItemList.append((Phase, Symbol, FilePath))\n    except:\n        EdkLogger.quiet('(Python %s on %s\\n%s)' % (platform.python_version(), sys.platform, traceback.format_exc()))\n        EdkLogger.warn(None, 'Failed to generate execution order prediction report, for some error occurred in executing EOT.')",
            "def _InvokeEotTool(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._EotToolInvoked:\n        return\n    self._EotToolInvoked = True\n    FvFileList = []\n    for FvName in self._FvList:\n        FvFile = os.path.join(self._FvDir, FvName + '.Fv')\n        if os.path.isfile(FvFile):\n            FvFileList.append(FvFile)\n    if len(FvFileList) == 0:\n        return\n    SourceList = os.path.join(self._EotDir, 'SourceFile.txt')\n    GuidList = os.path.join(self._EotDir, 'GuidList.txt')\n    DispatchList = os.path.join(self._EotDir, 'Dispatch.txt')\n    TempFile = []\n    for Item in self._SourceList:\n        FileWrite(TempFile, Item)\n    SaveFileOnChange(SourceList, ''.join(TempFile), False)\n    TempFile = []\n    for Key in self._GuidMap:\n        FileWrite(TempFile, '%s %s' % (Key, self._GuidMap[Key]))\n    SaveFileOnChange(GuidList, ''.join(TempFile), False)\n    try:\n        from Eot.EotMain import Eot\n        EotStartTime = time.time()\n        Eot(CommandLineOption=False, SourceFileList=SourceList, GuidList=GuidList, FvFileList=' '.join(FvFileList), Dispatch=DispatchList, IsInit=True)\n        EotEndTime = time.time()\n        EotDuration = time.strftime('%H:%M:%S', time.gmtime(int(round(EotEndTime - EotStartTime))))\n        EdkLogger.quiet('EOT run time: %s\\n' % EotDuration)\n        for Line in open(DispatchList):\n            if len(Line.split()) < 4:\n                continue\n            (Guid, Phase, FfsName, FilePath) = Line.split()\n            Symbol = self._FfsEntryPoint.get(Guid, [FfsName, ''])[0]\n            if len(Symbol) > self.MaxLen:\n                self.MaxLen = len(Symbol)\n            self.ItemList.append((Phase, Symbol, FilePath))\n    except:\n        EdkLogger.quiet('(Python %s on %s\\n%s)' % (platform.python_version(), sys.platform, traceback.format_exc()))\n        EdkLogger.warn(None, 'Failed to generate execution order prediction report, for some error occurred in executing EOT.')",
            "def _InvokeEotTool(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._EotToolInvoked:\n        return\n    self._EotToolInvoked = True\n    FvFileList = []\n    for FvName in self._FvList:\n        FvFile = os.path.join(self._FvDir, FvName + '.Fv')\n        if os.path.isfile(FvFile):\n            FvFileList.append(FvFile)\n    if len(FvFileList) == 0:\n        return\n    SourceList = os.path.join(self._EotDir, 'SourceFile.txt')\n    GuidList = os.path.join(self._EotDir, 'GuidList.txt')\n    DispatchList = os.path.join(self._EotDir, 'Dispatch.txt')\n    TempFile = []\n    for Item in self._SourceList:\n        FileWrite(TempFile, Item)\n    SaveFileOnChange(SourceList, ''.join(TempFile), False)\n    TempFile = []\n    for Key in self._GuidMap:\n        FileWrite(TempFile, '%s %s' % (Key, self._GuidMap[Key]))\n    SaveFileOnChange(GuidList, ''.join(TempFile), False)\n    try:\n        from Eot.EotMain import Eot\n        EotStartTime = time.time()\n        Eot(CommandLineOption=False, SourceFileList=SourceList, GuidList=GuidList, FvFileList=' '.join(FvFileList), Dispatch=DispatchList, IsInit=True)\n        EotEndTime = time.time()\n        EotDuration = time.strftime('%H:%M:%S', time.gmtime(int(round(EotEndTime - EotStartTime))))\n        EdkLogger.quiet('EOT run time: %s\\n' % EotDuration)\n        for Line in open(DispatchList):\n            if len(Line.split()) < 4:\n                continue\n            (Guid, Phase, FfsName, FilePath) = Line.split()\n            Symbol = self._FfsEntryPoint.get(Guid, [FfsName, ''])[0]\n            if len(Symbol) > self.MaxLen:\n                self.MaxLen = len(Symbol)\n            self.ItemList.append((Phase, Symbol, FilePath))\n    except:\n        EdkLogger.quiet('(Python %s on %s\\n%s)' % (platform.python_version(), sys.platform, traceback.format_exc()))\n        EdkLogger.warn(None, 'Failed to generate execution order prediction report, for some error occurred in executing EOT.')",
            "def _InvokeEotTool(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._EotToolInvoked:\n        return\n    self._EotToolInvoked = True\n    FvFileList = []\n    for FvName in self._FvList:\n        FvFile = os.path.join(self._FvDir, FvName + '.Fv')\n        if os.path.isfile(FvFile):\n            FvFileList.append(FvFile)\n    if len(FvFileList) == 0:\n        return\n    SourceList = os.path.join(self._EotDir, 'SourceFile.txt')\n    GuidList = os.path.join(self._EotDir, 'GuidList.txt')\n    DispatchList = os.path.join(self._EotDir, 'Dispatch.txt')\n    TempFile = []\n    for Item in self._SourceList:\n        FileWrite(TempFile, Item)\n    SaveFileOnChange(SourceList, ''.join(TempFile), False)\n    TempFile = []\n    for Key in self._GuidMap:\n        FileWrite(TempFile, '%s %s' % (Key, self._GuidMap[Key]))\n    SaveFileOnChange(GuidList, ''.join(TempFile), False)\n    try:\n        from Eot.EotMain import Eot\n        EotStartTime = time.time()\n        Eot(CommandLineOption=False, SourceFileList=SourceList, GuidList=GuidList, FvFileList=' '.join(FvFileList), Dispatch=DispatchList, IsInit=True)\n        EotEndTime = time.time()\n        EotDuration = time.strftime('%H:%M:%S', time.gmtime(int(round(EotEndTime - EotStartTime))))\n        EdkLogger.quiet('EOT run time: %s\\n' % EotDuration)\n        for Line in open(DispatchList):\n            if len(Line.split()) < 4:\n                continue\n            (Guid, Phase, FfsName, FilePath) = Line.split()\n            Symbol = self._FfsEntryPoint.get(Guid, [FfsName, ''])[0]\n            if len(Symbol) > self.MaxLen:\n                self.MaxLen = len(Symbol)\n            self.ItemList.append((Phase, Symbol, FilePath))\n    except:\n        EdkLogger.quiet('(Python %s on %s\\n%s)' % (platform.python_version(), sys.platform, traceback.format_exc()))\n        EdkLogger.warn(None, 'Failed to generate execution order prediction report, for some error occurred in executing EOT.')"
        ]
    },
    {
        "func_name": "_GenerateExecutionOrderReport",
        "original": "def _GenerateExecutionOrderReport(self, File):\n    self._InvokeEotTool()\n    if len(self.ItemList) == 0:\n        return\n    FileWrite(File, gSectionStart)\n    FileWrite(File, 'Execution Order Prediction')\n    FileWrite(File, '*P PEI phase')\n    FileWrite(File, '*D DXE phase')\n    FileWrite(File, '*E Module INF entry point name')\n    FileWrite(File, '*N Module notification function name')\n    FileWrite(File, 'Type %-*s %s' % (self.MaxLen, 'Symbol', 'Module INF Path'))\n    FileWrite(File, gSectionSep)\n    for Item in self.ItemList:\n        FileWrite(File, '*%sE  %-*s %s' % (Item[0], self.MaxLen, Item[1], Item[2]))\n    FileWrite(File, gSectionStart)",
        "mutated": [
            "def _GenerateExecutionOrderReport(self, File):\n    if False:\n        i = 10\n    self._InvokeEotTool()\n    if len(self.ItemList) == 0:\n        return\n    FileWrite(File, gSectionStart)\n    FileWrite(File, 'Execution Order Prediction')\n    FileWrite(File, '*P PEI phase')\n    FileWrite(File, '*D DXE phase')\n    FileWrite(File, '*E Module INF entry point name')\n    FileWrite(File, '*N Module notification function name')\n    FileWrite(File, 'Type %-*s %s' % (self.MaxLen, 'Symbol', 'Module INF Path'))\n    FileWrite(File, gSectionSep)\n    for Item in self.ItemList:\n        FileWrite(File, '*%sE  %-*s %s' % (Item[0], self.MaxLen, Item[1], Item[2]))\n    FileWrite(File, gSectionStart)",
            "def _GenerateExecutionOrderReport(self, File):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._InvokeEotTool()\n    if len(self.ItemList) == 0:\n        return\n    FileWrite(File, gSectionStart)\n    FileWrite(File, 'Execution Order Prediction')\n    FileWrite(File, '*P PEI phase')\n    FileWrite(File, '*D DXE phase')\n    FileWrite(File, '*E Module INF entry point name')\n    FileWrite(File, '*N Module notification function name')\n    FileWrite(File, 'Type %-*s %s' % (self.MaxLen, 'Symbol', 'Module INF Path'))\n    FileWrite(File, gSectionSep)\n    for Item in self.ItemList:\n        FileWrite(File, '*%sE  %-*s %s' % (Item[0], self.MaxLen, Item[1], Item[2]))\n    FileWrite(File, gSectionStart)",
            "def _GenerateExecutionOrderReport(self, File):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._InvokeEotTool()\n    if len(self.ItemList) == 0:\n        return\n    FileWrite(File, gSectionStart)\n    FileWrite(File, 'Execution Order Prediction')\n    FileWrite(File, '*P PEI phase')\n    FileWrite(File, '*D DXE phase')\n    FileWrite(File, '*E Module INF entry point name')\n    FileWrite(File, '*N Module notification function name')\n    FileWrite(File, 'Type %-*s %s' % (self.MaxLen, 'Symbol', 'Module INF Path'))\n    FileWrite(File, gSectionSep)\n    for Item in self.ItemList:\n        FileWrite(File, '*%sE  %-*s %s' % (Item[0], self.MaxLen, Item[1], Item[2]))\n    FileWrite(File, gSectionStart)",
            "def _GenerateExecutionOrderReport(self, File):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._InvokeEotTool()\n    if len(self.ItemList) == 0:\n        return\n    FileWrite(File, gSectionStart)\n    FileWrite(File, 'Execution Order Prediction')\n    FileWrite(File, '*P PEI phase')\n    FileWrite(File, '*D DXE phase')\n    FileWrite(File, '*E Module INF entry point name')\n    FileWrite(File, '*N Module notification function name')\n    FileWrite(File, 'Type %-*s %s' % (self.MaxLen, 'Symbol', 'Module INF Path'))\n    FileWrite(File, gSectionSep)\n    for Item in self.ItemList:\n        FileWrite(File, '*%sE  %-*s %s' % (Item[0], self.MaxLen, Item[1], Item[2]))\n    FileWrite(File, gSectionStart)",
            "def _GenerateExecutionOrderReport(self, File):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._InvokeEotTool()\n    if len(self.ItemList) == 0:\n        return\n    FileWrite(File, gSectionStart)\n    FileWrite(File, 'Execution Order Prediction')\n    FileWrite(File, '*P PEI phase')\n    FileWrite(File, '*D DXE phase')\n    FileWrite(File, '*E Module INF entry point name')\n    FileWrite(File, '*N Module notification function name')\n    FileWrite(File, 'Type %-*s %s' % (self.MaxLen, 'Symbol', 'Module INF Path'))\n    FileWrite(File, gSectionSep)\n    for Item in self.ItemList:\n        FileWrite(File, '*%sE  %-*s %s' % (Item[0], self.MaxLen, Item[1], Item[2]))\n    FileWrite(File, gSectionStart)"
        ]
    },
    {
        "func_name": "_GenerateFixedAddressReport",
        "original": "def _GenerateFixedAddressReport(self, File, Guid, NotifyList):\n    self._ParseMapFile()\n    FixedAddressList = self.FixedMapDict.get(Guid)\n    if not FixedAddressList:\n        return\n    FileWrite(File, gSubSectionStart)\n    FileWrite(File, 'Fixed Address Prediction')\n    FileWrite(File, '*I  Image Loading Address')\n    FileWrite(File, '*E  Entry Point Address')\n    FileWrite(File, '*N  Notification Function Address')\n    FileWrite(File, '*F  Flash Address')\n    FileWrite(File, '*M  Memory Address')\n    FileWrite(File, '*S  SMM RAM Offset')\n    FileWrite(File, 'TOM Top of Memory')\n    FileWrite(File, 'Type Address           Name')\n    FileWrite(File, gSubSectionSep)\n    for Item in FixedAddressList:\n        Type = Item[0]\n        Value = Item[1]\n        Symbol = Item[2]\n        if Symbol == '*I':\n            Name = '(Image Base)'\n        elif Symbol == '*E':\n            Name = self._FfsEntryPoint.get(Guid, ['', '_ModuleEntryPoint'])[1]\n        elif Symbol in NotifyList:\n            Name = Symbol\n            Symbol = '*N'\n        else:\n            continue\n        if 'Flash' in Type:\n            Symbol += 'F'\n        elif 'Memory' in Type:\n            Symbol += 'M'\n        else:\n            Symbol += 'S'\n        if Value[0] == '-':\n            Value = 'TOM' + Value\n        FileWrite(File, '%s  %-16s  %s' % (Symbol, Value, Name))",
        "mutated": [
            "def _GenerateFixedAddressReport(self, File, Guid, NotifyList):\n    if False:\n        i = 10\n    self._ParseMapFile()\n    FixedAddressList = self.FixedMapDict.get(Guid)\n    if not FixedAddressList:\n        return\n    FileWrite(File, gSubSectionStart)\n    FileWrite(File, 'Fixed Address Prediction')\n    FileWrite(File, '*I  Image Loading Address')\n    FileWrite(File, '*E  Entry Point Address')\n    FileWrite(File, '*N  Notification Function Address')\n    FileWrite(File, '*F  Flash Address')\n    FileWrite(File, '*M  Memory Address')\n    FileWrite(File, '*S  SMM RAM Offset')\n    FileWrite(File, 'TOM Top of Memory')\n    FileWrite(File, 'Type Address           Name')\n    FileWrite(File, gSubSectionSep)\n    for Item in FixedAddressList:\n        Type = Item[0]\n        Value = Item[1]\n        Symbol = Item[2]\n        if Symbol == '*I':\n            Name = '(Image Base)'\n        elif Symbol == '*E':\n            Name = self._FfsEntryPoint.get(Guid, ['', '_ModuleEntryPoint'])[1]\n        elif Symbol in NotifyList:\n            Name = Symbol\n            Symbol = '*N'\n        else:\n            continue\n        if 'Flash' in Type:\n            Symbol += 'F'\n        elif 'Memory' in Type:\n            Symbol += 'M'\n        else:\n            Symbol += 'S'\n        if Value[0] == '-':\n            Value = 'TOM' + Value\n        FileWrite(File, '%s  %-16s  %s' % (Symbol, Value, Name))",
            "def _GenerateFixedAddressReport(self, File, Guid, NotifyList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._ParseMapFile()\n    FixedAddressList = self.FixedMapDict.get(Guid)\n    if not FixedAddressList:\n        return\n    FileWrite(File, gSubSectionStart)\n    FileWrite(File, 'Fixed Address Prediction')\n    FileWrite(File, '*I  Image Loading Address')\n    FileWrite(File, '*E  Entry Point Address')\n    FileWrite(File, '*N  Notification Function Address')\n    FileWrite(File, '*F  Flash Address')\n    FileWrite(File, '*M  Memory Address')\n    FileWrite(File, '*S  SMM RAM Offset')\n    FileWrite(File, 'TOM Top of Memory')\n    FileWrite(File, 'Type Address           Name')\n    FileWrite(File, gSubSectionSep)\n    for Item in FixedAddressList:\n        Type = Item[0]\n        Value = Item[1]\n        Symbol = Item[2]\n        if Symbol == '*I':\n            Name = '(Image Base)'\n        elif Symbol == '*E':\n            Name = self._FfsEntryPoint.get(Guid, ['', '_ModuleEntryPoint'])[1]\n        elif Symbol in NotifyList:\n            Name = Symbol\n            Symbol = '*N'\n        else:\n            continue\n        if 'Flash' in Type:\n            Symbol += 'F'\n        elif 'Memory' in Type:\n            Symbol += 'M'\n        else:\n            Symbol += 'S'\n        if Value[0] == '-':\n            Value = 'TOM' + Value\n        FileWrite(File, '%s  %-16s  %s' % (Symbol, Value, Name))",
            "def _GenerateFixedAddressReport(self, File, Guid, NotifyList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._ParseMapFile()\n    FixedAddressList = self.FixedMapDict.get(Guid)\n    if not FixedAddressList:\n        return\n    FileWrite(File, gSubSectionStart)\n    FileWrite(File, 'Fixed Address Prediction')\n    FileWrite(File, '*I  Image Loading Address')\n    FileWrite(File, '*E  Entry Point Address')\n    FileWrite(File, '*N  Notification Function Address')\n    FileWrite(File, '*F  Flash Address')\n    FileWrite(File, '*M  Memory Address')\n    FileWrite(File, '*S  SMM RAM Offset')\n    FileWrite(File, 'TOM Top of Memory')\n    FileWrite(File, 'Type Address           Name')\n    FileWrite(File, gSubSectionSep)\n    for Item in FixedAddressList:\n        Type = Item[0]\n        Value = Item[1]\n        Symbol = Item[2]\n        if Symbol == '*I':\n            Name = '(Image Base)'\n        elif Symbol == '*E':\n            Name = self._FfsEntryPoint.get(Guid, ['', '_ModuleEntryPoint'])[1]\n        elif Symbol in NotifyList:\n            Name = Symbol\n            Symbol = '*N'\n        else:\n            continue\n        if 'Flash' in Type:\n            Symbol += 'F'\n        elif 'Memory' in Type:\n            Symbol += 'M'\n        else:\n            Symbol += 'S'\n        if Value[0] == '-':\n            Value = 'TOM' + Value\n        FileWrite(File, '%s  %-16s  %s' % (Symbol, Value, Name))",
            "def _GenerateFixedAddressReport(self, File, Guid, NotifyList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._ParseMapFile()\n    FixedAddressList = self.FixedMapDict.get(Guid)\n    if not FixedAddressList:\n        return\n    FileWrite(File, gSubSectionStart)\n    FileWrite(File, 'Fixed Address Prediction')\n    FileWrite(File, '*I  Image Loading Address')\n    FileWrite(File, '*E  Entry Point Address')\n    FileWrite(File, '*N  Notification Function Address')\n    FileWrite(File, '*F  Flash Address')\n    FileWrite(File, '*M  Memory Address')\n    FileWrite(File, '*S  SMM RAM Offset')\n    FileWrite(File, 'TOM Top of Memory')\n    FileWrite(File, 'Type Address           Name')\n    FileWrite(File, gSubSectionSep)\n    for Item in FixedAddressList:\n        Type = Item[0]\n        Value = Item[1]\n        Symbol = Item[2]\n        if Symbol == '*I':\n            Name = '(Image Base)'\n        elif Symbol == '*E':\n            Name = self._FfsEntryPoint.get(Guid, ['', '_ModuleEntryPoint'])[1]\n        elif Symbol in NotifyList:\n            Name = Symbol\n            Symbol = '*N'\n        else:\n            continue\n        if 'Flash' in Type:\n            Symbol += 'F'\n        elif 'Memory' in Type:\n            Symbol += 'M'\n        else:\n            Symbol += 'S'\n        if Value[0] == '-':\n            Value = 'TOM' + Value\n        FileWrite(File, '%s  %-16s  %s' % (Symbol, Value, Name))",
            "def _GenerateFixedAddressReport(self, File, Guid, NotifyList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._ParseMapFile()\n    FixedAddressList = self.FixedMapDict.get(Guid)\n    if not FixedAddressList:\n        return\n    FileWrite(File, gSubSectionStart)\n    FileWrite(File, 'Fixed Address Prediction')\n    FileWrite(File, '*I  Image Loading Address')\n    FileWrite(File, '*E  Entry Point Address')\n    FileWrite(File, '*N  Notification Function Address')\n    FileWrite(File, '*F  Flash Address')\n    FileWrite(File, '*M  Memory Address')\n    FileWrite(File, '*S  SMM RAM Offset')\n    FileWrite(File, 'TOM Top of Memory')\n    FileWrite(File, 'Type Address           Name')\n    FileWrite(File, gSubSectionSep)\n    for Item in FixedAddressList:\n        Type = Item[0]\n        Value = Item[1]\n        Symbol = Item[2]\n        if Symbol == '*I':\n            Name = '(Image Base)'\n        elif Symbol == '*E':\n            Name = self._FfsEntryPoint.get(Guid, ['', '_ModuleEntryPoint'])[1]\n        elif Symbol in NotifyList:\n            Name = Symbol\n            Symbol = '*N'\n        else:\n            continue\n        if 'Flash' in Type:\n            Symbol += 'F'\n        elif 'Memory' in Type:\n            Symbol += 'M'\n        else:\n            Symbol += 'S'\n        if Value[0] == '-':\n            Value = 'TOM' + Value\n        FileWrite(File, '%s  %-16s  %s' % (Symbol, Value, Name))"
        ]
    },
    {
        "func_name": "GenerateReport",
        "original": "def GenerateReport(self, File, Guid):\n    if Guid:\n        self._GenerateFixedAddressReport(File, Guid.upper(), [])\n    else:\n        self._GenerateExecutionOrderReport(File)",
        "mutated": [
            "def GenerateReport(self, File, Guid):\n    if False:\n        i = 10\n    if Guid:\n        self._GenerateFixedAddressReport(File, Guid.upper(), [])\n    else:\n        self._GenerateExecutionOrderReport(File)",
            "def GenerateReport(self, File, Guid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if Guid:\n        self._GenerateFixedAddressReport(File, Guid.upper(), [])\n    else:\n        self._GenerateExecutionOrderReport(File)",
            "def GenerateReport(self, File, Guid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if Guid:\n        self._GenerateFixedAddressReport(File, Guid.upper(), [])\n    else:\n        self._GenerateExecutionOrderReport(File)",
            "def GenerateReport(self, File, Guid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if Guid:\n        self._GenerateFixedAddressReport(File, Guid.upper(), [])\n    else:\n        self._GenerateExecutionOrderReport(File)",
            "def GenerateReport(self, File, Guid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if Guid:\n        self._GenerateFixedAddressReport(File, Guid.upper(), [])\n    else:\n        self._GenerateExecutionOrderReport(File)"
        ]
    },
    {
        "func_name": "_DiscoverNestedFvList",
        "original": "def _DiscoverNestedFvList(self, FvName, Wa):\n    FvDictKey = FvName.upper()\n    if FvDictKey in Wa.FdfProfile.FvDict:\n        for Ffs in Wa.FdfProfile.FvDict[FvName.upper()].FfsList:\n            for Section in Ffs.SectionList:\n                try:\n                    for FvSection in Section.SectionList:\n                        if FvSection.FvName in self.FvList:\n                            continue\n                        self._GuidsDb[Ffs.NameGuid.upper()] = FvSection.FvName\n                        self.FvList.append(FvSection.FvName)\n                        self.FvInfo[FvSection.FvName] = ('Nested FV', 0, 0)\n                        self._DiscoverNestedFvList(FvSection.FvName, Wa)\n                except AttributeError:\n                    pass",
        "mutated": [
            "def _DiscoverNestedFvList(self, FvName, Wa):\n    if False:\n        i = 10\n    FvDictKey = FvName.upper()\n    if FvDictKey in Wa.FdfProfile.FvDict:\n        for Ffs in Wa.FdfProfile.FvDict[FvName.upper()].FfsList:\n            for Section in Ffs.SectionList:\n                try:\n                    for FvSection in Section.SectionList:\n                        if FvSection.FvName in self.FvList:\n                            continue\n                        self._GuidsDb[Ffs.NameGuid.upper()] = FvSection.FvName\n                        self.FvList.append(FvSection.FvName)\n                        self.FvInfo[FvSection.FvName] = ('Nested FV', 0, 0)\n                        self._DiscoverNestedFvList(FvSection.FvName, Wa)\n                except AttributeError:\n                    pass",
            "def _DiscoverNestedFvList(self, FvName, Wa):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    FvDictKey = FvName.upper()\n    if FvDictKey in Wa.FdfProfile.FvDict:\n        for Ffs in Wa.FdfProfile.FvDict[FvName.upper()].FfsList:\n            for Section in Ffs.SectionList:\n                try:\n                    for FvSection in Section.SectionList:\n                        if FvSection.FvName in self.FvList:\n                            continue\n                        self._GuidsDb[Ffs.NameGuid.upper()] = FvSection.FvName\n                        self.FvList.append(FvSection.FvName)\n                        self.FvInfo[FvSection.FvName] = ('Nested FV', 0, 0)\n                        self._DiscoverNestedFvList(FvSection.FvName, Wa)\n                except AttributeError:\n                    pass",
            "def _DiscoverNestedFvList(self, FvName, Wa):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    FvDictKey = FvName.upper()\n    if FvDictKey in Wa.FdfProfile.FvDict:\n        for Ffs in Wa.FdfProfile.FvDict[FvName.upper()].FfsList:\n            for Section in Ffs.SectionList:\n                try:\n                    for FvSection in Section.SectionList:\n                        if FvSection.FvName in self.FvList:\n                            continue\n                        self._GuidsDb[Ffs.NameGuid.upper()] = FvSection.FvName\n                        self.FvList.append(FvSection.FvName)\n                        self.FvInfo[FvSection.FvName] = ('Nested FV', 0, 0)\n                        self._DiscoverNestedFvList(FvSection.FvName, Wa)\n                except AttributeError:\n                    pass",
            "def _DiscoverNestedFvList(self, FvName, Wa):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    FvDictKey = FvName.upper()\n    if FvDictKey in Wa.FdfProfile.FvDict:\n        for Ffs in Wa.FdfProfile.FvDict[FvName.upper()].FfsList:\n            for Section in Ffs.SectionList:\n                try:\n                    for FvSection in Section.SectionList:\n                        if FvSection.FvName in self.FvList:\n                            continue\n                        self._GuidsDb[Ffs.NameGuid.upper()] = FvSection.FvName\n                        self.FvList.append(FvSection.FvName)\n                        self.FvInfo[FvSection.FvName] = ('Nested FV', 0, 0)\n                        self._DiscoverNestedFvList(FvSection.FvName, Wa)\n                except AttributeError:\n                    pass",
            "def _DiscoverNestedFvList(self, FvName, Wa):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    FvDictKey = FvName.upper()\n    if FvDictKey in Wa.FdfProfile.FvDict:\n        for Ffs in Wa.FdfProfile.FvDict[FvName.upper()].FfsList:\n            for Section in Ffs.SectionList:\n                try:\n                    for FvSection in Section.SectionList:\n                        if FvSection.FvName in self.FvList:\n                            continue\n                        self._GuidsDb[Ffs.NameGuid.upper()] = FvSection.FvName\n                        self.FvList.append(FvSection.FvName)\n                        self.FvInfo[FvSection.FvName] = ('Nested FV', 0, 0)\n                        self._DiscoverNestedFvList(FvSection.FvName, Wa)\n                except AttributeError:\n                    pass"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, FdRegion, Wa):\n    self.Type = FdRegion.RegionType\n    self.BaseAddress = FdRegion.Offset\n    self.Size = FdRegion.Size\n    self.FvList = []\n    self.FvInfo = {}\n    self._GuidsDb = {}\n    self._FvDir = Wa.FvDir\n    self._WorkspaceDir = Wa.WorkspaceDir\n    if self.Type != BINARY_FILE_TYPE_FV:\n        return\n    for FvName in FdRegion.RegionDataList:\n        if FvName in self.FvList:\n            continue\n        self.FvList.append(FvName)\n        self.FvInfo[FvName] = ('Fd Region', self.BaseAddress, self.Size)\n        self._DiscoverNestedFvList(FvName, Wa)\n    PlatformPcds = {}\n    for Pa in Wa.AutoGenObjectList:\n        for Package in Pa.PackageList:\n            for (TokenCName, TokenSpaceGuidCName, DecType) in Package.Pcds:\n                DecDefaultValue = Package.Pcds[TokenCName, TokenSpaceGuidCName, DecType].DefaultValue\n                PlatformPcds[TokenCName, TokenSpaceGuidCName] = DecDefaultValue\n    for Pa in Wa.AutoGenObjectList:\n        for (TokenCName, TokenSpaceGuidCName) in Pa.Platform.Pcds:\n            DscDefaultValue = Pa.Platform.Pcds[TokenCName, TokenSpaceGuidCName].DefaultValue\n            PlatformPcds[TokenCName, TokenSpaceGuidCName] = DscDefaultValue\n    self._GuidsDb[PEI_APRIORI_GUID] = 'PEI Apriori'\n    self._GuidsDb[DXE_APRIORI_GUID] = 'DXE Apriori'\n    self._GuidsDb['7E374E25-8E01-4FEE-87F2-390C23C606CD'] = 'ACPI table storage'\n    for Pa in Wa.AutoGenObjectList:\n        for ModuleKey in Pa.Platform.Modules:\n            M = Pa.Platform.Modules[ModuleKey].M\n            InfPath = mws.join(Wa.WorkspaceDir, M.MetaFile.File)\n            self._GuidsDb[M.Guid.upper()] = '%s (%s)' % (M.Module.BaseName, InfPath)\n    for FvName in self.FvList:\n        FvDictKey = FvName.upper()\n        if FvDictKey in Wa.FdfProfile.FvDict:\n            for Ffs in Wa.FdfProfile.FvDict[FvName.upper()].FfsList:\n                try:\n                    Guid = Ffs.NameGuid.upper()\n                    Match = gPcdGuidPattern.match(Ffs.NameGuid)\n                    if Match:\n                        PcdTokenspace = Match.group(1)\n                        PcdToken = Match.group(2)\n                        if (PcdToken, PcdTokenspace) in PlatformPcds:\n                            GuidValue = PlatformPcds[PcdToken, PcdTokenspace]\n                            Guid = GuidStructureByteArrayToGuidString(GuidValue).upper()\n                    for Section in Ffs.SectionList:\n                        try:\n                            ModuleSectFile = mws.join(Wa.WorkspaceDir, Section.SectFileName)\n                            self._GuidsDb[Guid] = ModuleSectFile\n                        except AttributeError:\n                            pass\n                except AttributeError:\n                    pass",
        "mutated": [
            "def __init__(self, FdRegion, Wa):\n    if False:\n        i = 10\n    self.Type = FdRegion.RegionType\n    self.BaseAddress = FdRegion.Offset\n    self.Size = FdRegion.Size\n    self.FvList = []\n    self.FvInfo = {}\n    self._GuidsDb = {}\n    self._FvDir = Wa.FvDir\n    self._WorkspaceDir = Wa.WorkspaceDir\n    if self.Type != BINARY_FILE_TYPE_FV:\n        return\n    for FvName in FdRegion.RegionDataList:\n        if FvName in self.FvList:\n            continue\n        self.FvList.append(FvName)\n        self.FvInfo[FvName] = ('Fd Region', self.BaseAddress, self.Size)\n        self._DiscoverNestedFvList(FvName, Wa)\n    PlatformPcds = {}\n    for Pa in Wa.AutoGenObjectList:\n        for Package in Pa.PackageList:\n            for (TokenCName, TokenSpaceGuidCName, DecType) in Package.Pcds:\n                DecDefaultValue = Package.Pcds[TokenCName, TokenSpaceGuidCName, DecType].DefaultValue\n                PlatformPcds[TokenCName, TokenSpaceGuidCName] = DecDefaultValue\n    for Pa in Wa.AutoGenObjectList:\n        for (TokenCName, TokenSpaceGuidCName) in Pa.Platform.Pcds:\n            DscDefaultValue = Pa.Platform.Pcds[TokenCName, TokenSpaceGuidCName].DefaultValue\n            PlatformPcds[TokenCName, TokenSpaceGuidCName] = DscDefaultValue\n    self._GuidsDb[PEI_APRIORI_GUID] = 'PEI Apriori'\n    self._GuidsDb[DXE_APRIORI_GUID] = 'DXE Apriori'\n    self._GuidsDb['7E374E25-8E01-4FEE-87F2-390C23C606CD'] = 'ACPI table storage'\n    for Pa in Wa.AutoGenObjectList:\n        for ModuleKey in Pa.Platform.Modules:\n            M = Pa.Platform.Modules[ModuleKey].M\n            InfPath = mws.join(Wa.WorkspaceDir, M.MetaFile.File)\n            self._GuidsDb[M.Guid.upper()] = '%s (%s)' % (M.Module.BaseName, InfPath)\n    for FvName in self.FvList:\n        FvDictKey = FvName.upper()\n        if FvDictKey in Wa.FdfProfile.FvDict:\n            for Ffs in Wa.FdfProfile.FvDict[FvName.upper()].FfsList:\n                try:\n                    Guid = Ffs.NameGuid.upper()\n                    Match = gPcdGuidPattern.match(Ffs.NameGuid)\n                    if Match:\n                        PcdTokenspace = Match.group(1)\n                        PcdToken = Match.group(2)\n                        if (PcdToken, PcdTokenspace) in PlatformPcds:\n                            GuidValue = PlatformPcds[PcdToken, PcdTokenspace]\n                            Guid = GuidStructureByteArrayToGuidString(GuidValue).upper()\n                    for Section in Ffs.SectionList:\n                        try:\n                            ModuleSectFile = mws.join(Wa.WorkspaceDir, Section.SectFileName)\n                            self._GuidsDb[Guid] = ModuleSectFile\n                        except AttributeError:\n                            pass\n                except AttributeError:\n                    pass",
            "def __init__(self, FdRegion, Wa):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.Type = FdRegion.RegionType\n    self.BaseAddress = FdRegion.Offset\n    self.Size = FdRegion.Size\n    self.FvList = []\n    self.FvInfo = {}\n    self._GuidsDb = {}\n    self._FvDir = Wa.FvDir\n    self._WorkspaceDir = Wa.WorkspaceDir\n    if self.Type != BINARY_FILE_TYPE_FV:\n        return\n    for FvName in FdRegion.RegionDataList:\n        if FvName in self.FvList:\n            continue\n        self.FvList.append(FvName)\n        self.FvInfo[FvName] = ('Fd Region', self.BaseAddress, self.Size)\n        self._DiscoverNestedFvList(FvName, Wa)\n    PlatformPcds = {}\n    for Pa in Wa.AutoGenObjectList:\n        for Package in Pa.PackageList:\n            for (TokenCName, TokenSpaceGuidCName, DecType) in Package.Pcds:\n                DecDefaultValue = Package.Pcds[TokenCName, TokenSpaceGuidCName, DecType].DefaultValue\n                PlatformPcds[TokenCName, TokenSpaceGuidCName] = DecDefaultValue\n    for Pa in Wa.AutoGenObjectList:\n        for (TokenCName, TokenSpaceGuidCName) in Pa.Platform.Pcds:\n            DscDefaultValue = Pa.Platform.Pcds[TokenCName, TokenSpaceGuidCName].DefaultValue\n            PlatformPcds[TokenCName, TokenSpaceGuidCName] = DscDefaultValue\n    self._GuidsDb[PEI_APRIORI_GUID] = 'PEI Apriori'\n    self._GuidsDb[DXE_APRIORI_GUID] = 'DXE Apriori'\n    self._GuidsDb['7E374E25-8E01-4FEE-87F2-390C23C606CD'] = 'ACPI table storage'\n    for Pa in Wa.AutoGenObjectList:\n        for ModuleKey in Pa.Platform.Modules:\n            M = Pa.Platform.Modules[ModuleKey].M\n            InfPath = mws.join(Wa.WorkspaceDir, M.MetaFile.File)\n            self._GuidsDb[M.Guid.upper()] = '%s (%s)' % (M.Module.BaseName, InfPath)\n    for FvName in self.FvList:\n        FvDictKey = FvName.upper()\n        if FvDictKey in Wa.FdfProfile.FvDict:\n            for Ffs in Wa.FdfProfile.FvDict[FvName.upper()].FfsList:\n                try:\n                    Guid = Ffs.NameGuid.upper()\n                    Match = gPcdGuidPattern.match(Ffs.NameGuid)\n                    if Match:\n                        PcdTokenspace = Match.group(1)\n                        PcdToken = Match.group(2)\n                        if (PcdToken, PcdTokenspace) in PlatformPcds:\n                            GuidValue = PlatformPcds[PcdToken, PcdTokenspace]\n                            Guid = GuidStructureByteArrayToGuidString(GuidValue).upper()\n                    for Section in Ffs.SectionList:\n                        try:\n                            ModuleSectFile = mws.join(Wa.WorkspaceDir, Section.SectFileName)\n                            self._GuidsDb[Guid] = ModuleSectFile\n                        except AttributeError:\n                            pass\n                except AttributeError:\n                    pass",
            "def __init__(self, FdRegion, Wa):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.Type = FdRegion.RegionType\n    self.BaseAddress = FdRegion.Offset\n    self.Size = FdRegion.Size\n    self.FvList = []\n    self.FvInfo = {}\n    self._GuidsDb = {}\n    self._FvDir = Wa.FvDir\n    self._WorkspaceDir = Wa.WorkspaceDir\n    if self.Type != BINARY_FILE_TYPE_FV:\n        return\n    for FvName in FdRegion.RegionDataList:\n        if FvName in self.FvList:\n            continue\n        self.FvList.append(FvName)\n        self.FvInfo[FvName] = ('Fd Region', self.BaseAddress, self.Size)\n        self._DiscoverNestedFvList(FvName, Wa)\n    PlatformPcds = {}\n    for Pa in Wa.AutoGenObjectList:\n        for Package in Pa.PackageList:\n            for (TokenCName, TokenSpaceGuidCName, DecType) in Package.Pcds:\n                DecDefaultValue = Package.Pcds[TokenCName, TokenSpaceGuidCName, DecType].DefaultValue\n                PlatformPcds[TokenCName, TokenSpaceGuidCName] = DecDefaultValue\n    for Pa in Wa.AutoGenObjectList:\n        for (TokenCName, TokenSpaceGuidCName) in Pa.Platform.Pcds:\n            DscDefaultValue = Pa.Platform.Pcds[TokenCName, TokenSpaceGuidCName].DefaultValue\n            PlatformPcds[TokenCName, TokenSpaceGuidCName] = DscDefaultValue\n    self._GuidsDb[PEI_APRIORI_GUID] = 'PEI Apriori'\n    self._GuidsDb[DXE_APRIORI_GUID] = 'DXE Apriori'\n    self._GuidsDb['7E374E25-8E01-4FEE-87F2-390C23C606CD'] = 'ACPI table storage'\n    for Pa in Wa.AutoGenObjectList:\n        for ModuleKey in Pa.Platform.Modules:\n            M = Pa.Platform.Modules[ModuleKey].M\n            InfPath = mws.join(Wa.WorkspaceDir, M.MetaFile.File)\n            self._GuidsDb[M.Guid.upper()] = '%s (%s)' % (M.Module.BaseName, InfPath)\n    for FvName in self.FvList:\n        FvDictKey = FvName.upper()\n        if FvDictKey in Wa.FdfProfile.FvDict:\n            for Ffs in Wa.FdfProfile.FvDict[FvName.upper()].FfsList:\n                try:\n                    Guid = Ffs.NameGuid.upper()\n                    Match = gPcdGuidPattern.match(Ffs.NameGuid)\n                    if Match:\n                        PcdTokenspace = Match.group(1)\n                        PcdToken = Match.group(2)\n                        if (PcdToken, PcdTokenspace) in PlatformPcds:\n                            GuidValue = PlatformPcds[PcdToken, PcdTokenspace]\n                            Guid = GuidStructureByteArrayToGuidString(GuidValue).upper()\n                    for Section in Ffs.SectionList:\n                        try:\n                            ModuleSectFile = mws.join(Wa.WorkspaceDir, Section.SectFileName)\n                            self._GuidsDb[Guid] = ModuleSectFile\n                        except AttributeError:\n                            pass\n                except AttributeError:\n                    pass",
            "def __init__(self, FdRegion, Wa):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.Type = FdRegion.RegionType\n    self.BaseAddress = FdRegion.Offset\n    self.Size = FdRegion.Size\n    self.FvList = []\n    self.FvInfo = {}\n    self._GuidsDb = {}\n    self._FvDir = Wa.FvDir\n    self._WorkspaceDir = Wa.WorkspaceDir\n    if self.Type != BINARY_FILE_TYPE_FV:\n        return\n    for FvName in FdRegion.RegionDataList:\n        if FvName in self.FvList:\n            continue\n        self.FvList.append(FvName)\n        self.FvInfo[FvName] = ('Fd Region', self.BaseAddress, self.Size)\n        self._DiscoverNestedFvList(FvName, Wa)\n    PlatformPcds = {}\n    for Pa in Wa.AutoGenObjectList:\n        for Package in Pa.PackageList:\n            for (TokenCName, TokenSpaceGuidCName, DecType) in Package.Pcds:\n                DecDefaultValue = Package.Pcds[TokenCName, TokenSpaceGuidCName, DecType].DefaultValue\n                PlatformPcds[TokenCName, TokenSpaceGuidCName] = DecDefaultValue\n    for Pa in Wa.AutoGenObjectList:\n        for (TokenCName, TokenSpaceGuidCName) in Pa.Platform.Pcds:\n            DscDefaultValue = Pa.Platform.Pcds[TokenCName, TokenSpaceGuidCName].DefaultValue\n            PlatformPcds[TokenCName, TokenSpaceGuidCName] = DscDefaultValue\n    self._GuidsDb[PEI_APRIORI_GUID] = 'PEI Apriori'\n    self._GuidsDb[DXE_APRIORI_GUID] = 'DXE Apriori'\n    self._GuidsDb['7E374E25-8E01-4FEE-87F2-390C23C606CD'] = 'ACPI table storage'\n    for Pa in Wa.AutoGenObjectList:\n        for ModuleKey in Pa.Platform.Modules:\n            M = Pa.Platform.Modules[ModuleKey].M\n            InfPath = mws.join(Wa.WorkspaceDir, M.MetaFile.File)\n            self._GuidsDb[M.Guid.upper()] = '%s (%s)' % (M.Module.BaseName, InfPath)\n    for FvName in self.FvList:\n        FvDictKey = FvName.upper()\n        if FvDictKey in Wa.FdfProfile.FvDict:\n            for Ffs in Wa.FdfProfile.FvDict[FvName.upper()].FfsList:\n                try:\n                    Guid = Ffs.NameGuid.upper()\n                    Match = gPcdGuidPattern.match(Ffs.NameGuid)\n                    if Match:\n                        PcdTokenspace = Match.group(1)\n                        PcdToken = Match.group(2)\n                        if (PcdToken, PcdTokenspace) in PlatformPcds:\n                            GuidValue = PlatformPcds[PcdToken, PcdTokenspace]\n                            Guid = GuidStructureByteArrayToGuidString(GuidValue).upper()\n                    for Section in Ffs.SectionList:\n                        try:\n                            ModuleSectFile = mws.join(Wa.WorkspaceDir, Section.SectFileName)\n                            self._GuidsDb[Guid] = ModuleSectFile\n                        except AttributeError:\n                            pass\n                except AttributeError:\n                    pass",
            "def __init__(self, FdRegion, Wa):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.Type = FdRegion.RegionType\n    self.BaseAddress = FdRegion.Offset\n    self.Size = FdRegion.Size\n    self.FvList = []\n    self.FvInfo = {}\n    self._GuidsDb = {}\n    self._FvDir = Wa.FvDir\n    self._WorkspaceDir = Wa.WorkspaceDir\n    if self.Type != BINARY_FILE_TYPE_FV:\n        return\n    for FvName in FdRegion.RegionDataList:\n        if FvName in self.FvList:\n            continue\n        self.FvList.append(FvName)\n        self.FvInfo[FvName] = ('Fd Region', self.BaseAddress, self.Size)\n        self._DiscoverNestedFvList(FvName, Wa)\n    PlatformPcds = {}\n    for Pa in Wa.AutoGenObjectList:\n        for Package in Pa.PackageList:\n            for (TokenCName, TokenSpaceGuidCName, DecType) in Package.Pcds:\n                DecDefaultValue = Package.Pcds[TokenCName, TokenSpaceGuidCName, DecType].DefaultValue\n                PlatformPcds[TokenCName, TokenSpaceGuidCName] = DecDefaultValue\n    for Pa in Wa.AutoGenObjectList:\n        for (TokenCName, TokenSpaceGuidCName) in Pa.Platform.Pcds:\n            DscDefaultValue = Pa.Platform.Pcds[TokenCName, TokenSpaceGuidCName].DefaultValue\n            PlatformPcds[TokenCName, TokenSpaceGuidCName] = DscDefaultValue\n    self._GuidsDb[PEI_APRIORI_GUID] = 'PEI Apriori'\n    self._GuidsDb[DXE_APRIORI_GUID] = 'DXE Apriori'\n    self._GuidsDb['7E374E25-8E01-4FEE-87F2-390C23C606CD'] = 'ACPI table storage'\n    for Pa in Wa.AutoGenObjectList:\n        for ModuleKey in Pa.Platform.Modules:\n            M = Pa.Platform.Modules[ModuleKey].M\n            InfPath = mws.join(Wa.WorkspaceDir, M.MetaFile.File)\n            self._GuidsDb[M.Guid.upper()] = '%s (%s)' % (M.Module.BaseName, InfPath)\n    for FvName in self.FvList:\n        FvDictKey = FvName.upper()\n        if FvDictKey in Wa.FdfProfile.FvDict:\n            for Ffs in Wa.FdfProfile.FvDict[FvName.upper()].FfsList:\n                try:\n                    Guid = Ffs.NameGuid.upper()\n                    Match = gPcdGuidPattern.match(Ffs.NameGuid)\n                    if Match:\n                        PcdTokenspace = Match.group(1)\n                        PcdToken = Match.group(2)\n                        if (PcdToken, PcdTokenspace) in PlatformPcds:\n                            GuidValue = PlatformPcds[PcdToken, PcdTokenspace]\n                            Guid = GuidStructureByteArrayToGuidString(GuidValue).upper()\n                    for Section in Ffs.SectionList:\n                        try:\n                            ModuleSectFile = mws.join(Wa.WorkspaceDir, Section.SectFileName)\n                            self._GuidsDb[Guid] = ModuleSectFile\n                        except AttributeError:\n                            pass\n                except AttributeError:\n                    pass"
        ]
    },
    {
        "func_name": "_GenerateReport",
        "original": "def _GenerateReport(self, File, Title, Type, BaseAddress, Size=0, FvName=None):\n    FileWrite(File, gSubSectionStart)\n    FileWrite(File, Title)\n    FileWrite(File, 'Type:               %s' % Type)\n    FileWrite(File, 'Base Address:       0x%X' % BaseAddress)\n    if self.Type == BINARY_FILE_TYPE_FV:\n        FvTotalSize = 0\n        FvTakenSize = 0\n        FvFreeSize = 0\n        if FvName.upper().endswith('.FV'):\n            FileExt = FvName + '.txt'\n        else:\n            FileExt = FvName + '.Fv.txt'\n        if not os.path.isfile(FileExt):\n            FvReportFileName = mws.join(self._WorkspaceDir, FileExt)\n            if not os.path.isfile(FvReportFileName):\n                FvReportFileName = os.path.join(self._FvDir, FileExt)\n        try:\n            FvReport = open(FvReportFileName).read()\n            Match = gFvTotalSizePattern.search(FvReport)\n            if Match:\n                FvTotalSize = int(Match.group(1), 16)\n            Match = gFvTakenSizePattern.search(FvReport)\n            if Match:\n                FvTakenSize = int(Match.group(1), 16)\n            FvFreeSize = FvTotalSize - FvTakenSize\n            FileWrite(File, 'Size:               0x%X (%.0fK)' % (FvTotalSize, FvTotalSize / 1024.0))\n            FileWrite(File, 'Fv Name:            %s (%.1f%% Full)' % (FvName, FvTakenSize * 100.0 / FvTotalSize))\n            FileWrite(File, 'Occupied Size:      0x%X (%.0fK)' % (FvTakenSize, FvTakenSize / 1024.0))\n            FileWrite(File, 'Free Size:          0x%X (%.0fK)' % (FvFreeSize, FvFreeSize / 1024.0))\n            FileWrite(File, 'Offset     Module')\n            FileWrite(File, gSubSectionSep)\n            OffsetInfo = {}\n            for Match in gOffsetGuidPattern.finditer(FvReport):\n                Guid = Match.group(2).upper()\n                OffsetInfo[Match.group(1)] = self._GuidsDb.get(Guid, Guid)\n            OffsetList = sorted(OffsetInfo.keys())\n            for Offset in OffsetList:\n                FileWrite(File, '%s %s' % (Offset, OffsetInfo[Offset]))\n        except IOError:\n            EdkLogger.warn(None, 'Fail to read report file', FvReportFileName)\n    else:\n        FileWrite(File, 'Size:               0x%X (%.0fK)' % (Size, Size / 1024.0))\n    FileWrite(File, gSubSectionEnd)",
        "mutated": [
            "def _GenerateReport(self, File, Title, Type, BaseAddress, Size=0, FvName=None):\n    if False:\n        i = 10\n    FileWrite(File, gSubSectionStart)\n    FileWrite(File, Title)\n    FileWrite(File, 'Type:               %s' % Type)\n    FileWrite(File, 'Base Address:       0x%X' % BaseAddress)\n    if self.Type == BINARY_FILE_TYPE_FV:\n        FvTotalSize = 0\n        FvTakenSize = 0\n        FvFreeSize = 0\n        if FvName.upper().endswith('.FV'):\n            FileExt = FvName + '.txt'\n        else:\n            FileExt = FvName + '.Fv.txt'\n        if not os.path.isfile(FileExt):\n            FvReportFileName = mws.join(self._WorkspaceDir, FileExt)\n            if not os.path.isfile(FvReportFileName):\n                FvReportFileName = os.path.join(self._FvDir, FileExt)\n        try:\n            FvReport = open(FvReportFileName).read()\n            Match = gFvTotalSizePattern.search(FvReport)\n            if Match:\n                FvTotalSize = int(Match.group(1), 16)\n            Match = gFvTakenSizePattern.search(FvReport)\n            if Match:\n                FvTakenSize = int(Match.group(1), 16)\n            FvFreeSize = FvTotalSize - FvTakenSize\n            FileWrite(File, 'Size:               0x%X (%.0fK)' % (FvTotalSize, FvTotalSize / 1024.0))\n            FileWrite(File, 'Fv Name:            %s (%.1f%% Full)' % (FvName, FvTakenSize * 100.0 / FvTotalSize))\n            FileWrite(File, 'Occupied Size:      0x%X (%.0fK)' % (FvTakenSize, FvTakenSize / 1024.0))\n            FileWrite(File, 'Free Size:          0x%X (%.0fK)' % (FvFreeSize, FvFreeSize / 1024.0))\n            FileWrite(File, 'Offset     Module')\n            FileWrite(File, gSubSectionSep)\n            OffsetInfo = {}\n            for Match in gOffsetGuidPattern.finditer(FvReport):\n                Guid = Match.group(2).upper()\n                OffsetInfo[Match.group(1)] = self._GuidsDb.get(Guid, Guid)\n            OffsetList = sorted(OffsetInfo.keys())\n            for Offset in OffsetList:\n                FileWrite(File, '%s %s' % (Offset, OffsetInfo[Offset]))\n        except IOError:\n            EdkLogger.warn(None, 'Fail to read report file', FvReportFileName)\n    else:\n        FileWrite(File, 'Size:               0x%X (%.0fK)' % (Size, Size / 1024.0))\n    FileWrite(File, gSubSectionEnd)",
            "def _GenerateReport(self, File, Title, Type, BaseAddress, Size=0, FvName=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    FileWrite(File, gSubSectionStart)\n    FileWrite(File, Title)\n    FileWrite(File, 'Type:               %s' % Type)\n    FileWrite(File, 'Base Address:       0x%X' % BaseAddress)\n    if self.Type == BINARY_FILE_TYPE_FV:\n        FvTotalSize = 0\n        FvTakenSize = 0\n        FvFreeSize = 0\n        if FvName.upper().endswith('.FV'):\n            FileExt = FvName + '.txt'\n        else:\n            FileExt = FvName + '.Fv.txt'\n        if not os.path.isfile(FileExt):\n            FvReportFileName = mws.join(self._WorkspaceDir, FileExt)\n            if not os.path.isfile(FvReportFileName):\n                FvReportFileName = os.path.join(self._FvDir, FileExt)\n        try:\n            FvReport = open(FvReportFileName).read()\n            Match = gFvTotalSizePattern.search(FvReport)\n            if Match:\n                FvTotalSize = int(Match.group(1), 16)\n            Match = gFvTakenSizePattern.search(FvReport)\n            if Match:\n                FvTakenSize = int(Match.group(1), 16)\n            FvFreeSize = FvTotalSize - FvTakenSize\n            FileWrite(File, 'Size:               0x%X (%.0fK)' % (FvTotalSize, FvTotalSize / 1024.0))\n            FileWrite(File, 'Fv Name:            %s (%.1f%% Full)' % (FvName, FvTakenSize * 100.0 / FvTotalSize))\n            FileWrite(File, 'Occupied Size:      0x%X (%.0fK)' % (FvTakenSize, FvTakenSize / 1024.0))\n            FileWrite(File, 'Free Size:          0x%X (%.0fK)' % (FvFreeSize, FvFreeSize / 1024.0))\n            FileWrite(File, 'Offset     Module')\n            FileWrite(File, gSubSectionSep)\n            OffsetInfo = {}\n            for Match in gOffsetGuidPattern.finditer(FvReport):\n                Guid = Match.group(2).upper()\n                OffsetInfo[Match.group(1)] = self._GuidsDb.get(Guid, Guid)\n            OffsetList = sorted(OffsetInfo.keys())\n            for Offset in OffsetList:\n                FileWrite(File, '%s %s' % (Offset, OffsetInfo[Offset]))\n        except IOError:\n            EdkLogger.warn(None, 'Fail to read report file', FvReportFileName)\n    else:\n        FileWrite(File, 'Size:               0x%X (%.0fK)' % (Size, Size / 1024.0))\n    FileWrite(File, gSubSectionEnd)",
            "def _GenerateReport(self, File, Title, Type, BaseAddress, Size=0, FvName=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    FileWrite(File, gSubSectionStart)\n    FileWrite(File, Title)\n    FileWrite(File, 'Type:               %s' % Type)\n    FileWrite(File, 'Base Address:       0x%X' % BaseAddress)\n    if self.Type == BINARY_FILE_TYPE_FV:\n        FvTotalSize = 0\n        FvTakenSize = 0\n        FvFreeSize = 0\n        if FvName.upper().endswith('.FV'):\n            FileExt = FvName + '.txt'\n        else:\n            FileExt = FvName + '.Fv.txt'\n        if not os.path.isfile(FileExt):\n            FvReportFileName = mws.join(self._WorkspaceDir, FileExt)\n            if not os.path.isfile(FvReportFileName):\n                FvReportFileName = os.path.join(self._FvDir, FileExt)\n        try:\n            FvReport = open(FvReportFileName).read()\n            Match = gFvTotalSizePattern.search(FvReport)\n            if Match:\n                FvTotalSize = int(Match.group(1), 16)\n            Match = gFvTakenSizePattern.search(FvReport)\n            if Match:\n                FvTakenSize = int(Match.group(1), 16)\n            FvFreeSize = FvTotalSize - FvTakenSize\n            FileWrite(File, 'Size:               0x%X (%.0fK)' % (FvTotalSize, FvTotalSize / 1024.0))\n            FileWrite(File, 'Fv Name:            %s (%.1f%% Full)' % (FvName, FvTakenSize * 100.0 / FvTotalSize))\n            FileWrite(File, 'Occupied Size:      0x%X (%.0fK)' % (FvTakenSize, FvTakenSize / 1024.0))\n            FileWrite(File, 'Free Size:          0x%X (%.0fK)' % (FvFreeSize, FvFreeSize / 1024.0))\n            FileWrite(File, 'Offset     Module')\n            FileWrite(File, gSubSectionSep)\n            OffsetInfo = {}\n            for Match in gOffsetGuidPattern.finditer(FvReport):\n                Guid = Match.group(2).upper()\n                OffsetInfo[Match.group(1)] = self._GuidsDb.get(Guid, Guid)\n            OffsetList = sorted(OffsetInfo.keys())\n            for Offset in OffsetList:\n                FileWrite(File, '%s %s' % (Offset, OffsetInfo[Offset]))\n        except IOError:\n            EdkLogger.warn(None, 'Fail to read report file', FvReportFileName)\n    else:\n        FileWrite(File, 'Size:               0x%X (%.0fK)' % (Size, Size / 1024.0))\n    FileWrite(File, gSubSectionEnd)",
            "def _GenerateReport(self, File, Title, Type, BaseAddress, Size=0, FvName=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    FileWrite(File, gSubSectionStart)\n    FileWrite(File, Title)\n    FileWrite(File, 'Type:               %s' % Type)\n    FileWrite(File, 'Base Address:       0x%X' % BaseAddress)\n    if self.Type == BINARY_FILE_TYPE_FV:\n        FvTotalSize = 0\n        FvTakenSize = 0\n        FvFreeSize = 0\n        if FvName.upper().endswith('.FV'):\n            FileExt = FvName + '.txt'\n        else:\n            FileExt = FvName + '.Fv.txt'\n        if not os.path.isfile(FileExt):\n            FvReportFileName = mws.join(self._WorkspaceDir, FileExt)\n            if not os.path.isfile(FvReportFileName):\n                FvReportFileName = os.path.join(self._FvDir, FileExt)\n        try:\n            FvReport = open(FvReportFileName).read()\n            Match = gFvTotalSizePattern.search(FvReport)\n            if Match:\n                FvTotalSize = int(Match.group(1), 16)\n            Match = gFvTakenSizePattern.search(FvReport)\n            if Match:\n                FvTakenSize = int(Match.group(1), 16)\n            FvFreeSize = FvTotalSize - FvTakenSize\n            FileWrite(File, 'Size:               0x%X (%.0fK)' % (FvTotalSize, FvTotalSize / 1024.0))\n            FileWrite(File, 'Fv Name:            %s (%.1f%% Full)' % (FvName, FvTakenSize * 100.0 / FvTotalSize))\n            FileWrite(File, 'Occupied Size:      0x%X (%.0fK)' % (FvTakenSize, FvTakenSize / 1024.0))\n            FileWrite(File, 'Free Size:          0x%X (%.0fK)' % (FvFreeSize, FvFreeSize / 1024.0))\n            FileWrite(File, 'Offset     Module')\n            FileWrite(File, gSubSectionSep)\n            OffsetInfo = {}\n            for Match in gOffsetGuidPattern.finditer(FvReport):\n                Guid = Match.group(2).upper()\n                OffsetInfo[Match.group(1)] = self._GuidsDb.get(Guid, Guid)\n            OffsetList = sorted(OffsetInfo.keys())\n            for Offset in OffsetList:\n                FileWrite(File, '%s %s' % (Offset, OffsetInfo[Offset]))\n        except IOError:\n            EdkLogger.warn(None, 'Fail to read report file', FvReportFileName)\n    else:\n        FileWrite(File, 'Size:               0x%X (%.0fK)' % (Size, Size / 1024.0))\n    FileWrite(File, gSubSectionEnd)",
            "def _GenerateReport(self, File, Title, Type, BaseAddress, Size=0, FvName=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    FileWrite(File, gSubSectionStart)\n    FileWrite(File, Title)\n    FileWrite(File, 'Type:               %s' % Type)\n    FileWrite(File, 'Base Address:       0x%X' % BaseAddress)\n    if self.Type == BINARY_FILE_TYPE_FV:\n        FvTotalSize = 0\n        FvTakenSize = 0\n        FvFreeSize = 0\n        if FvName.upper().endswith('.FV'):\n            FileExt = FvName + '.txt'\n        else:\n            FileExt = FvName + '.Fv.txt'\n        if not os.path.isfile(FileExt):\n            FvReportFileName = mws.join(self._WorkspaceDir, FileExt)\n            if not os.path.isfile(FvReportFileName):\n                FvReportFileName = os.path.join(self._FvDir, FileExt)\n        try:\n            FvReport = open(FvReportFileName).read()\n            Match = gFvTotalSizePattern.search(FvReport)\n            if Match:\n                FvTotalSize = int(Match.group(1), 16)\n            Match = gFvTakenSizePattern.search(FvReport)\n            if Match:\n                FvTakenSize = int(Match.group(1), 16)\n            FvFreeSize = FvTotalSize - FvTakenSize\n            FileWrite(File, 'Size:               0x%X (%.0fK)' % (FvTotalSize, FvTotalSize / 1024.0))\n            FileWrite(File, 'Fv Name:            %s (%.1f%% Full)' % (FvName, FvTakenSize * 100.0 / FvTotalSize))\n            FileWrite(File, 'Occupied Size:      0x%X (%.0fK)' % (FvTakenSize, FvTakenSize / 1024.0))\n            FileWrite(File, 'Free Size:          0x%X (%.0fK)' % (FvFreeSize, FvFreeSize / 1024.0))\n            FileWrite(File, 'Offset     Module')\n            FileWrite(File, gSubSectionSep)\n            OffsetInfo = {}\n            for Match in gOffsetGuidPattern.finditer(FvReport):\n                Guid = Match.group(2).upper()\n                OffsetInfo[Match.group(1)] = self._GuidsDb.get(Guid, Guid)\n            OffsetList = sorted(OffsetInfo.keys())\n            for Offset in OffsetList:\n                FileWrite(File, '%s %s' % (Offset, OffsetInfo[Offset]))\n        except IOError:\n            EdkLogger.warn(None, 'Fail to read report file', FvReportFileName)\n    else:\n        FileWrite(File, 'Size:               0x%X (%.0fK)' % (Size, Size / 1024.0))\n    FileWrite(File, gSubSectionEnd)"
        ]
    },
    {
        "func_name": "GenerateReport",
        "original": "def GenerateReport(self, File):\n    if len(self.FvList) > 0:\n        for FvItem in self.FvList:\n            Info = self.FvInfo[FvItem]\n            self._GenerateReport(File, Info[0], TAB_FV_DIRECTORY, Info[1], Info[2], FvItem)\n    else:\n        self._GenerateReport(File, 'FD Region', self.Type, self.BaseAddress, self.Size)",
        "mutated": [
            "def GenerateReport(self, File):\n    if False:\n        i = 10\n    if len(self.FvList) > 0:\n        for FvItem in self.FvList:\n            Info = self.FvInfo[FvItem]\n            self._GenerateReport(File, Info[0], TAB_FV_DIRECTORY, Info[1], Info[2], FvItem)\n    else:\n        self._GenerateReport(File, 'FD Region', self.Type, self.BaseAddress, self.Size)",
            "def GenerateReport(self, File):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if len(self.FvList) > 0:\n        for FvItem in self.FvList:\n            Info = self.FvInfo[FvItem]\n            self._GenerateReport(File, Info[0], TAB_FV_DIRECTORY, Info[1], Info[2], FvItem)\n    else:\n        self._GenerateReport(File, 'FD Region', self.Type, self.BaseAddress, self.Size)",
            "def GenerateReport(self, File):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if len(self.FvList) > 0:\n        for FvItem in self.FvList:\n            Info = self.FvInfo[FvItem]\n            self._GenerateReport(File, Info[0], TAB_FV_DIRECTORY, Info[1], Info[2], FvItem)\n    else:\n        self._GenerateReport(File, 'FD Region', self.Type, self.BaseAddress, self.Size)",
            "def GenerateReport(self, File):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if len(self.FvList) > 0:\n        for FvItem in self.FvList:\n            Info = self.FvInfo[FvItem]\n            self._GenerateReport(File, Info[0], TAB_FV_DIRECTORY, Info[1], Info[2], FvItem)\n    else:\n        self._GenerateReport(File, 'FD Region', self.Type, self.BaseAddress, self.Size)",
            "def GenerateReport(self, File):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if len(self.FvList) > 0:\n        for FvItem in self.FvList:\n            Info = self.FvInfo[FvItem]\n            self._GenerateReport(File, Info[0], TAB_FV_DIRECTORY, Info[1], Info[2], FvItem)\n    else:\n        self._GenerateReport(File, 'FD Region', self.Type, self.BaseAddress, self.Size)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, Fd, Wa):\n    self.FdName = Fd.FdUiName\n    self.BaseAddress = Fd.BaseAddress\n    self.Size = Fd.Size\n    self.FdRegionList = [FdRegionReport(FdRegion, Wa) for FdRegion in Fd.RegionList]\n    self.FvPath = os.path.join(Wa.BuildDir, TAB_FV_DIRECTORY)\n    self.VPDBaseAddress = 0\n    self.VPDSize = 0\n    for (index, FdRegion) in enumerate(Fd.RegionList):\n        if str(FdRegion.RegionType) == 'FILE' and Wa.Platform.VpdToolGuid in str(FdRegion.RegionDataList):\n            self.VPDBaseAddress = self.FdRegionList[index].BaseAddress\n            self.VPDSize = self.FdRegionList[index].Size\n            break",
        "mutated": [
            "def __init__(self, Fd, Wa):\n    if False:\n        i = 10\n    self.FdName = Fd.FdUiName\n    self.BaseAddress = Fd.BaseAddress\n    self.Size = Fd.Size\n    self.FdRegionList = [FdRegionReport(FdRegion, Wa) for FdRegion in Fd.RegionList]\n    self.FvPath = os.path.join(Wa.BuildDir, TAB_FV_DIRECTORY)\n    self.VPDBaseAddress = 0\n    self.VPDSize = 0\n    for (index, FdRegion) in enumerate(Fd.RegionList):\n        if str(FdRegion.RegionType) == 'FILE' and Wa.Platform.VpdToolGuid in str(FdRegion.RegionDataList):\n            self.VPDBaseAddress = self.FdRegionList[index].BaseAddress\n            self.VPDSize = self.FdRegionList[index].Size\n            break",
            "def __init__(self, Fd, Wa):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.FdName = Fd.FdUiName\n    self.BaseAddress = Fd.BaseAddress\n    self.Size = Fd.Size\n    self.FdRegionList = [FdRegionReport(FdRegion, Wa) for FdRegion in Fd.RegionList]\n    self.FvPath = os.path.join(Wa.BuildDir, TAB_FV_DIRECTORY)\n    self.VPDBaseAddress = 0\n    self.VPDSize = 0\n    for (index, FdRegion) in enumerate(Fd.RegionList):\n        if str(FdRegion.RegionType) == 'FILE' and Wa.Platform.VpdToolGuid in str(FdRegion.RegionDataList):\n            self.VPDBaseAddress = self.FdRegionList[index].BaseAddress\n            self.VPDSize = self.FdRegionList[index].Size\n            break",
            "def __init__(self, Fd, Wa):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.FdName = Fd.FdUiName\n    self.BaseAddress = Fd.BaseAddress\n    self.Size = Fd.Size\n    self.FdRegionList = [FdRegionReport(FdRegion, Wa) for FdRegion in Fd.RegionList]\n    self.FvPath = os.path.join(Wa.BuildDir, TAB_FV_DIRECTORY)\n    self.VPDBaseAddress = 0\n    self.VPDSize = 0\n    for (index, FdRegion) in enumerate(Fd.RegionList):\n        if str(FdRegion.RegionType) == 'FILE' and Wa.Platform.VpdToolGuid in str(FdRegion.RegionDataList):\n            self.VPDBaseAddress = self.FdRegionList[index].BaseAddress\n            self.VPDSize = self.FdRegionList[index].Size\n            break",
            "def __init__(self, Fd, Wa):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.FdName = Fd.FdUiName\n    self.BaseAddress = Fd.BaseAddress\n    self.Size = Fd.Size\n    self.FdRegionList = [FdRegionReport(FdRegion, Wa) for FdRegion in Fd.RegionList]\n    self.FvPath = os.path.join(Wa.BuildDir, TAB_FV_DIRECTORY)\n    self.VPDBaseAddress = 0\n    self.VPDSize = 0\n    for (index, FdRegion) in enumerate(Fd.RegionList):\n        if str(FdRegion.RegionType) == 'FILE' and Wa.Platform.VpdToolGuid in str(FdRegion.RegionDataList):\n            self.VPDBaseAddress = self.FdRegionList[index].BaseAddress\n            self.VPDSize = self.FdRegionList[index].Size\n            break",
            "def __init__(self, Fd, Wa):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.FdName = Fd.FdUiName\n    self.BaseAddress = Fd.BaseAddress\n    self.Size = Fd.Size\n    self.FdRegionList = [FdRegionReport(FdRegion, Wa) for FdRegion in Fd.RegionList]\n    self.FvPath = os.path.join(Wa.BuildDir, TAB_FV_DIRECTORY)\n    self.VPDBaseAddress = 0\n    self.VPDSize = 0\n    for (index, FdRegion) in enumerate(Fd.RegionList):\n        if str(FdRegion.RegionType) == 'FILE' and Wa.Platform.VpdToolGuid in str(FdRegion.RegionDataList):\n            self.VPDBaseAddress = self.FdRegionList[index].BaseAddress\n            self.VPDSize = self.FdRegionList[index].Size\n            break"
        ]
    },
    {
        "func_name": "GenerateReport",
        "original": "def GenerateReport(self, File):\n    FileWrite(File, gSectionStart)\n    FileWrite(File, 'Firmware Device (FD)')\n    FileWrite(File, 'FD Name:            %s' % self.FdName)\n    FileWrite(File, 'Base Address:       %s' % self.BaseAddress)\n    FileWrite(File, 'Size:               0x%X (%.0fK)' % (self.Size, self.Size / 1024.0))\n    if len(self.FdRegionList) > 0:\n        FileWrite(File, gSectionSep)\n        for FdRegionItem in self.FdRegionList:\n            FdRegionItem.GenerateReport(File)\n    if VPDPcdList:\n        VPDPcdList.sort(key=lambda x: int(x[2], 0))\n        FileWrite(File, gSubSectionStart)\n        FileWrite(File, 'FD VPD Region')\n        FileWrite(File, 'Base Address:       0x%X' % self.VPDBaseAddress)\n        FileWrite(File, 'Size:               0x%X (%.0fK)' % (self.VPDSize, self.VPDSize / 1024.0))\n        FileWrite(File, gSubSectionSep)\n        for item in VPDPcdList:\n            Offset = '0x%08X' % (int(item[2], 16) + self.VPDBaseAddress)\n            (IsByteArray, ArrayList) = ByteArrayForamt(item[-1])\n            Skuinfo = item[1]\n            if len(GlobalData.gSkuids) == 1:\n                Skuinfo = GlobalData.gSkuids[0]\n            if IsByteArray:\n                FileWrite(File, '%s | %s | %s | %s | %s' % (item[0], Skuinfo, Offset, item[3], '{'))\n                for Array in ArrayList:\n                    FileWrite(File, Array)\n            else:\n                FileWrite(File, '%s | %s | %s | %s | %s' % (item[0], Skuinfo, Offset, item[3], item[-1]))\n        FileWrite(File, gSubSectionEnd)\n    FileWrite(File, gSectionEnd)",
        "mutated": [
            "def GenerateReport(self, File):\n    if False:\n        i = 10\n    FileWrite(File, gSectionStart)\n    FileWrite(File, 'Firmware Device (FD)')\n    FileWrite(File, 'FD Name:            %s' % self.FdName)\n    FileWrite(File, 'Base Address:       %s' % self.BaseAddress)\n    FileWrite(File, 'Size:               0x%X (%.0fK)' % (self.Size, self.Size / 1024.0))\n    if len(self.FdRegionList) > 0:\n        FileWrite(File, gSectionSep)\n        for FdRegionItem in self.FdRegionList:\n            FdRegionItem.GenerateReport(File)\n    if VPDPcdList:\n        VPDPcdList.sort(key=lambda x: int(x[2], 0))\n        FileWrite(File, gSubSectionStart)\n        FileWrite(File, 'FD VPD Region')\n        FileWrite(File, 'Base Address:       0x%X' % self.VPDBaseAddress)\n        FileWrite(File, 'Size:               0x%X (%.0fK)' % (self.VPDSize, self.VPDSize / 1024.0))\n        FileWrite(File, gSubSectionSep)\n        for item in VPDPcdList:\n            Offset = '0x%08X' % (int(item[2], 16) + self.VPDBaseAddress)\n            (IsByteArray, ArrayList) = ByteArrayForamt(item[-1])\n            Skuinfo = item[1]\n            if len(GlobalData.gSkuids) == 1:\n                Skuinfo = GlobalData.gSkuids[0]\n            if IsByteArray:\n                FileWrite(File, '%s | %s | %s | %s | %s' % (item[0], Skuinfo, Offset, item[3], '{'))\n                for Array in ArrayList:\n                    FileWrite(File, Array)\n            else:\n                FileWrite(File, '%s | %s | %s | %s | %s' % (item[0], Skuinfo, Offset, item[3], item[-1]))\n        FileWrite(File, gSubSectionEnd)\n    FileWrite(File, gSectionEnd)",
            "def GenerateReport(self, File):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    FileWrite(File, gSectionStart)\n    FileWrite(File, 'Firmware Device (FD)')\n    FileWrite(File, 'FD Name:            %s' % self.FdName)\n    FileWrite(File, 'Base Address:       %s' % self.BaseAddress)\n    FileWrite(File, 'Size:               0x%X (%.0fK)' % (self.Size, self.Size / 1024.0))\n    if len(self.FdRegionList) > 0:\n        FileWrite(File, gSectionSep)\n        for FdRegionItem in self.FdRegionList:\n            FdRegionItem.GenerateReport(File)\n    if VPDPcdList:\n        VPDPcdList.sort(key=lambda x: int(x[2], 0))\n        FileWrite(File, gSubSectionStart)\n        FileWrite(File, 'FD VPD Region')\n        FileWrite(File, 'Base Address:       0x%X' % self.VPDBaseAddress)\n        FileWrite(File, 'Size:               0x%X (%.0fK)' % (self.VPDSize, self.VPDSize / 1024.0))\n        FileWrite(File, gSubSectionSep)\n        for item in VPDPcdList:\n            Offset = '0x%08X' % (int(item[2], 16) + self.VPDBaseAddress)\n            (IsByteArray, ArrayList) = ByteArrayForamt(item[-1])\n            Skuinfo = item[1]\n            if len(GlobalData.gSkuids) == 1:\n                Skuinfo = GlobalData.gSkuids[0]\n            if IsByteArray:\n                FileWrite(File, '%s | %s | %s | %s | %s' % (item[0], Skuinfo, Offset, item[3], '{'))\n                for Array in ArrayList:\n                    FileWrite(File, Array)\n            else:\n                FileWrite(File, '%s | %s | %s | %s | %s' % (item[0], Skuinfo, Offset, item[3], item[-1]))\n        FileWrite(File, gSubSectionEnd)\n    FileWrite(File, gSectionEnd)",
            "def GenerateReport(self, File):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    FileWrite(File, gSectionStart)\n    FileWrite(File, 'Firmware Device (FD)')\n    FileWrite(File, 'FD Name:            %s' % self.FdName)\n    FileWrite(File, 'Base Address:       %s' % self.BaseAddress)\n    FileWrite(File, 'Size:               0x%X (%.0fK)' % (self.Size, self.Size / 1024.0))\n    if len(self.FdRegionList) > 0:\n        FileWrite(File, gSectionSep)\n        for FdRegionItem in self.FdRegionList:\n            FdRegionItem.GenerateReport(File)\n    if VPDPcdList:\n        VPDPcdList.sort(key=lambda x: int(x[2], 0))\n        FileWrite(File, gSubSectionStart)\n        FileWrite(File, 'FD VPD Region')\n        FileWrite(File, 'Base Address:       0x%X' % self.VPDBaseAddress)\n        FileWrite(File, 'Size:               0x%X (%.0fK)' % (self.VPDSize, self.VPDSize / 1024.0))\n        FileWrite(File, gSubSectionSep)\n        for item in VPDPcdList:\n            Offset = '0x%08X' % (int(item[2], 16) + self.VPDBaseAddress)\n            (IsByteArray, ArrayList) = ByteArrayForamt(item[-1])\n            Skuinfo = item[1]\n            if len(GlobalData.gSkuids) == 1:\n                Skuinfo = GlobalData.gSkuids[0]\n            if IsByteArray:\n                FileWrite(File, '%s | %s | %s | %s | %s' % (item[0], Skuinfo, Offset, item[3], '{'))\n                for Array in ArrayList:\n                    FileWrite(File, Array)\n            else:\n                FileWrite(File, '%s | %s | %s | %s | %s' % (item[0], Skuinfo, Offset, item[3], item[-1]))\n        FileWrite(File, gSubSectionEnd)\n    FileWrite(File, gSectionEnd)",
            "def GenerateReport(self, File):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    FileWrite(File, gSectionStart)\n    FileWrite(File, 'Firmware Device (FD)')\n    FileWrite(File, 'FD Name:            %s' % self.FdName)\n    FileWrite(File, 'Base Address:       %s' % self.BaseAddress)\n    FileWrite(File, 'Size:               0x%X (%.0fK)' % (self.Size, self.Size / 1024.0))\n    if len(self.FdRegionList) > 0:\n        FileWrite(File, gSectionSep)\n        for FdRegionItem in self.FdRegionList:\n            FdRegionItem.GenerateReport(File)\n    if VPDPcdList:\n        VPDPcdList.sort(key=lambda x: int(x[2], 0))\n        FileWrite(File, gSubSectionStart)\n        FileWrite(File, 'FD VPD Region')\n        FileWrite(File, 'Base Address:       0x%X' % self.VPDBaseAddress)\n        FileWrite(File, 'Size:               0x%X (%.0fK)' % (self.VPDSize, self.VPDSize / 1024.0))\n        FileWrite(File, gSubSectionSep)\n        for item in VPDPcdList:\n            Offset = '0x%08X' % (int(item[2], 16) + self.VPDBaseAddress)\n            (IsByteArray, ArrayList) = ByteArrayForamt(item[-1])\n            Skuinfo = item[1]\n            if len(GlobalData.gSkuids) == 1:\n                Skuinfo = GlobalData.gSkuids[0]\n            if IsByteArray:\n                FileWrite(File, '%s | %s | %s | %s | %s' % (item[0], Skuinfo, Offset, item[3], '{'))\n                for Array in ArrayList:\n                    FileWrite(File, Array)\n            else:\n                FileWrite(File, '%s | %s | %s | %s | %s' % (item[0], Skuinfo, Offset, item[3], item[-1]))\n        FileWrite(File, gSubSectionEnd)\n    FileWrite(File, gSectionEnd)",
            "def GenerateReport(self, File):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    FileWrite(File, gSectionStart)\n    FileWrite(File, 'Firmware Device (FD)')\n    FileWrite(File, 'FD Name:            %s' % self.FdName)\n    FileWrite(File, 'Base Address:       %s' % self.BaseAddress)\n    FileWrite(File, 'Size:               0x%X (%.0fK)' % (self.Size, self.Size / 1024.0))\n    if len(self.FdRegionList) > 0:\n        FileWrite(File, gSectionSep)\n        for FdRegionItem in self.FdRegionList:\n            FdRegionItem.GenerateReport(File)\n    if VPDPcdList:\n        VPDPcdList.sort(key=lambda x: int(x[2], 0))\n        FileWrite(File, gSubSectionStart)\n        FileWrite(File, 'FD VPD Region')\n        FileWrite(File, 'Base Address:       0x%X' % self.VPDBaseAddress)\n        FileWrite(File, 'Size:               0x%X (%.0fK)' % (self.VPDSize, self.VPDSize / 1024.0))\n        FileWrite(File, gSubSectionSep)\n        for item in VPDPcdList:\n            Offset = '0x%08X' % (int(item[2], 16) + self.VPDBaseAddress)\n            (IsByteArray, ArrayList) = ByteArrayForamt(item[-1])\n            Skuinfo = item[1]\n            if len(GlobalData.gSkuids) == 1:\n                Skuinfo = GlobalData.gSkuids[0]\n            if IsByteArray:\n                FileWrite(File, '%s | %s | %s | %s | %s' % (item[0], Skuinfo, Offset, item[3], '{'))\n                for Array in ArrayList:\n                    FileWrite(File, Array)\n            else:\n                FileWrite(File, '%s | %s | %s | %s | %s' % (item[0], Skuinfo, Offset, item[3], item[-1]))\n        FileWrite(File, gSubSectionEnd)\n    FileWrite(File, gSectionEnd)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, Wa, MaList, ReportType):\n    self._WorkspaceDir = Wa.WorkspaceDir\n    self.PlatformName = Wa.Name\n    self.PlatformDscPath = Wa.Platform\n    self.Architectures = ' '.join(Wa.ArchList)\n    self.ToolChain = Wa.ToolChain\n    self.Target = Wa.BuildTarget\n    self.OutputPath = os.path.join(Wa.WorkspaceDir, Wa.OutputDir)\n    self.BuildEnvironment = platform.platform()\n    self.PcdReport = None\n    if 'PCD' in ReportType:\n        self.PcdReport = PcdReport(Wa)\n    self.FdReportList = []\n    if 'FLASH' in ReportType and Wa.FdfProfile and (MaList is None):\n        for Fd in Wa.FdfProfile.FdDict:\n            self.FdReportList.append(FdReport(Wa.FdfProfile.FdDict[Fd], Wa))\n    self.PredictionReport = None\n    if 'FIXED_ADDRESS' in ReportType or 'EXECUTION_ORDER' in ReportType:\n        self.PredictionReport = PredictionReport(Wa)\n    self.DepexParser = None\n    if 'DEPEX' in ReportType:\n        self.DepexParser = DepexParser(Wa)\n    self.ModuleReportList = []\n    if MaList is not None:\n        self._IsModuleBuild = True\n        for Ma in MaList:\n            self.ModuleReportList.append(ModuleReport(Ma, ReportType))\n    else:\n        self._IsModuleBuild = False\n        for Pa in Wa.AutoGenObjectList:\n            ModuleAutoGenList = []\n            for ModuleKey in Pa.Platform.Modules:\n                ModuleAutoGenList.append(Pa.Platform.Modules[ModuleKey].M)\n            if GlobalData.gFdfParser is not None:\n                if Pa.Arch in GlobalData.gFdfParser.Profile.InfDict:\n                    INFList = GlobalData.gFdfParser.Profile.InfDict[Pa.Arch]\n                    for InfName in INFList:\n                        InfClass = PathClass(NormPath(InfName), Wa.WorkspaceDir, Pa.Arch)\n                        Ma = ModuleAutoGen(Wa, InfClass, Pa.BuildTarget, Pa.ToolChain, Pa.Arch, Wa.MetaFile, Pa.DataPipe)\n                        if Ma is None:\n                            continue\n                        if Ma not in ModuleAutoGenList:\n                            ModuleAutoGenList.append(Ma)\n            for MGen in ModuleAutoGenList:\n                self.ModuleReportList.append(ModuleReport(MGen, ReportType))",
        "mutated": [
            "def __init__(self, Wa, MaList, ReportType):\n    if False:\n        i = 10\n    self._WorkspaceDir = Wa.WorkspaceDir\n    self.PlatformName = Wa.Name\n    self.PlatformDscPath = Wa.Platform\n    self.Architectures = ' '.join(Wa.ArchList)\n    self.ToolChain = Wa.ToolChain\n    self.Target = Wa.BuildTarget\n    self.OutputPath = os.path.join(Wa.WorkspaceDir, Wa.OutputDir)\n    self.BuildEnvironment = platform.platform()\n    self.PcdReport = None\n    if 'PCD' in ReportType:\n        self.PcdReport = PcdReport(Wa)\n    self.FdReportList = []\n    if 'FLASH' in ReportType and Wa.FdfProfile and (MaList is None):\n        for Fd in Wa.FdfProfile.FdDict:\n            self.FdReportList.append(FdReport(Wa.FdfProfile.FdDict[Fd], Wa))\n    self.PredictionReport = None\n    if 'FIXED_ADDRESS' in ReportType or 'EXECUTION_ORDER' in ReportType:\n        self.PredictionReport = PredictionReport(Wa)\n    self.DepexParser = None\n    if 'DEPEX' in ReportType:\n        self.DepexParser = DepexParser(Wa)\n    self.ModuleReportList = []\n    if MaList is not None:\n        self._IsModuleBuild = True\n        for Ma in MaList:\n            self.ModuleReportList.append(ModuleReport(Ma, ReportType))\n    else:\n        self._IsModuleBuild = False\n        for Pa in Wa.AutoGenObjectList:\n            ModuleAutoGenList = []\n            for ModuleKey in Pa.Platform.Modules:\n                ModuleAutoGenList.append(Pa.Platform.Modules[ModuleKey].M)\n            if GlobalData.gFdfParser is not None:\n                if Pa.Arch in GlobalData.gFdfParser.Profile.InfDict:\n                    INFList = GlobalData.gFdfParser.Profile.InfDict[Pa.Arch]\n                    for InfName in INFList:\n                        InfClass = PathClass(NormPath(InfName), Wa.WorkspaceDir, Pa.Arch)\n                        Ma = ModuleAutoGen(Wa, InfClass, Pa.BuildTarget, Pa.ToolChain, Pa.Arch, Wa.MetaFile, Pa.DataPipe)\n                        if Ma is None:\n                            continue\n                        if Ma not in ModuleAutoGenList:\n                            ModuleAutoGenList.append(Ma)\n            for MGen in ModuleAutoGenList:\n                self.ModuleReportList.append(ModuleReport(MGen, ReportType))",
            "def __init__(self, Wa, MaList, ReportType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._WorkspaceDir = Wa.WorkspaceDir\n    self.PlatformName = Wa.Name\n    self.PlatformDscPath = Wa.Platform\n    self.Architectures = ' '.join(Wa.ArchList)\n    self.ToolChain = Wa.ToolChain\n    self.Target = Wa.BuildTarget\n    self.OutputPath = os.path.join(Wa.WorkspaceDir, Wa.OutputDir)\n    self.BuildEnvironment = platform.platform()\n    self.PcdReport = None\n    if 'PCD' in ReportType:\n        self.PcdReport = PcdReport(Wa)\n    self.FdReportList = []\n    if 'FLASH' in ReportType and Wa.FdfProfile and (MaList is None):\n        for Fd in Wa.FdfProfile.FdDict:\n            self.FdReportList.append(FdReport(Wa.FdfProfile.FdDict[Fd], Wa))\n    self.PredictionReport = None\n    if 'FIXED_ADDRESS' in ReportType or 'EXECUTION_ORDER' in ReportType:\n        self.PredictionReport = PredictionReport(Wa)\n    self.DepexParser = None\n    if 'DEPEX' in ReportType:\n        self.DepexParser = DepexParser(Wa)\n    self.ModuleReportList = []\n    if MaList is not None:\n        self._IsModuleBuild = True\n        for Ma in MaList:\n            self.ModuleReportList.append(ModuleReport(Ma, ReportType))\n    else:\n        self._IsModuleBuild = False\n        for Pa in Wa.AutoGenObjectList:\n            ModuleAutoGenList = []\n            for ModuleKey in Pa.Platform.Modules:\n                ModuleAutoGenList.append(Pa.Platform.Modules[ModuleKey].M)\n            if GlobalData.gFdfParser is not None:\n                if Pa.Arch in GlobalData.gFdfParser.Profile.InfDict:\n                    INFList = GlobalData.gFdfParser.Profile.InfDict[Pa.Arch]\n                    for InfName in INFList:\n                        InfClass = PathClass(NormPath(InfName), Wa.WorkspaceDir, Pa.Arch)\n                        Ma = ModuleAutoGen(Wa, InfClass, Pa.BuildTarget, Pa.ToolChain, Pa.Arch, Wa.MetaFile, Pa.DataPipe)\n                        if Ma is None:\n                            continue\n                        if Ma not in ModuleAutoGenList:\n                            ModuleAutoGenList.append(Ma)\n            for MGen in ModuleAutoGenList:\n                self.ModuleReportList.append(ModuleReport(MGen, ReportType))",
            "def __init__(self, Wa, MaList, ReportType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._WorkspaceDir = Wa.WorkspaceDir\n    self.PlatformName = Wa.Name\n    self.PlatformDscPath = Wa.Platform\n    self.Architectures = ' '.join(Wa.ArchList)\n    self.ToolChain = Wa.ToolChain\n    self.Target = Wa.BuildTarget\n    self.OutputPath = os.path.join(Wa.WorkspaceDir, Wa.OutputDir)\n    self.BuildEnvironment = platform.platform()\n    self.PcdReport = None\n    if 'PCD' in ReportType:\n        self.PcdReport = PcdReport(Wa)\n    self.FdReportList = []\n    if 'FLASH' in ReportType and Wa.FdfProfile and (MaList is None):\n        for Fd in Wa.FdfProfile.FdDict:\n            self.FdReportList.append(FdReport(Wa.FdfProfile.FdDict[Fd], Wa))\n    self.PredictionReport = None\n    if 'FIXED_ADDRESS' in ReportType or 'EXECUTION_ORDER' in ReportType:\n        self.PredictionReport = PredictionReport(Wa)\n    self.DepexParser = None\n    if 'DEPEX' in ReportType:\n        self.DepexParser = DepexParser(Wa)\n    self.ModuleReportList = []\n    if MaList is not None:\n        self._IsModuleBuild = True\n        for Ma in MaList:\n            self.ModuleReportList.append(ModuleReport(Ma, ReportType))\n    else:\n        self._IsModuleBuild = False\n        for Pa in Wa.AutoGenObjectList:\n            ModuleAutoGenList = []\n            for ModuleKey in Pa.Platform.Modules:\n                ModuleAutoGenList.append(Pa.Platform.Modules[ModuleKey].M)\n            if GlobalData.gFdfParser is not None:\n                if Pa.Arch in GlobalData.gFdfParser.Profile.InfDict:\n                    INFList = GlobalData.gFdfParser.Profile.InfDict[Pa.Arch]\n                    for InfName in INFList:\n                        InfClass = PathClass(NormPath(InfName), Wa.WorkspaceDir, Pa.Arch)\n                        Ma = ModuleAutoGen(Wa, InfClass, Pa.BuildTarget, Pa.ToolChain, Pa.Arch, Wa.MetaFile, Pa.DataPipe)\n                        if Ma is None:\n                            continue\n                        if Ma not in ModuleAutoGenList:\n                            ModuleAutoGenList.append(Ma)\n            for MGen in ModuleAutoGenList:\n                self.ModuleReportList.append(ModuleReport(MGen, ReportType))",
            "def __init__(self, Wa, MaList, ReportType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._WorkspaceDir = Wa.WorkspaceDir\n    self.PlatformName = Wa.Name\n    self.PlatformDscPath = Wa.Platform\n    self.Architectures = ' '.join(Wa.ArchList)\n    self.ToolChain = Wa.ToolChain\n    self.Target = Wa.BuildTarget\n    self.OutputPath = os.path.join(Wa.WorkspaceDir, Wa.OutputDir)\n    self.BuildEnvironment = platform.platform()\n    self.PcdReport = None\n    if 'PCD' in ReportType:\n        self.PcdReport = PcdReport(Wa)\n    self.FdReportList = []\n    if 'FLASH' in ReportType and Wa.FdfProfile and (MaList is None):\n        for Fd in Wa.FdfProfile.FdDict:\n            self.FdReportList.append(FdReport(Wa.FdfProfile.FdDict[Fd], Wa))\n    self.PredictionReport = None\n    if 'FIXED_ADDRESS' in ReportType or 'EXECUTION_ORDER' in ReportType:\n        self.PredictionReport = PredictionReport(Wa)\n    self.DepexParser = None\n    if 'DEPEX' in ReportType:\n        self.DepexParser = DepexParser(Wa)\n    self.ModuleReportList = []\n    if MaList is not None:\n        self._IsModuleBuild = True\n        for Ma in MaList:\n            self.ModuleReportList.append(ModuleReport(Ma, ReportType))\n    else:\n        self._IsModuleBuild = False\n        for Pa in Wa.AutoGenObjectList:\n            ModuleAutoGenList = []\n            for ModuleKey in Pa.Platform.Modules:\n                ModuleAutoGenList.append(Pa.Platform.Modules[ModuleKey].M)\n            if GlobalData.gFdfParser is not None:\n                if Pa.Arch in GlobalData.gFdfParser.Profile.InfDict:\n                    INFList = GlobalData.gFdfParser.Profile.InfDict[Pa.Arch]\n                    for InfName in INFList:\n                        InfClass = PathClass(NormPath(InfName), Wa.WorkspaceDir, Pa.Arch)\n                        Ma = ModuleAutoGen(Wa, InfClass, Pa.BuildTarget, Pa.ToolChain, Pa.Arch, Wa.MetaFile, Pa.DataPipe)\n                        if Ma is None:\n                            continue\n                        if Ma not in ModuleAutoGenList:\n                            ModuleAutoGenList.append(Ma)\n            for MGen in ModuleAutoGenList:\n                self.ModuleReportList.append(ModuleReport(MGen, ReportType))",
            "def __init__(self, Wa, MaList, ReportType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._WorkspaceDir = Wa.WorkspaceDir\n    self.PlatformName = Wa.Name\n    self.PlatformDscPath = Wa.Platform\n    self.Architectures = ' '.join(Wa.ArchList)\n    self.ToolChain = Wa.ToolChain\n    self.Target = Wa.BuildTarget\n    self.OutputPath = os.path.join(Wa.WorkspaceDir, Wa.OutputDir)\n    self.BuildEnvironment = platform.platform()\n    self.PcdReport = None\n    if 'PCD' in ReportType:\n        self.PcdReport = PcdReport(Wa)\n    self.FdReportList = []\n    if 'FLASH' in ReportType and Wa.FdfProfile and (MaList is None):\n        for Fd in Wa.FdfProfile.FdDict:\n            self.FdReportList.append(FdReport(Wa.FdfProfile.FdDict[Fd], Wa))\n    self.PredictionReport = None\n    if 'FIXED_ADDRESS' in ReportType or 'EXECUTION_ORDER' in ReportType:\n        self.PredictionReport = PredictionReport(Wa)\n    self.DepexParser = None\n    if 'DEPEX' in ReportType:\n        self.DepexParser = DepexParser(Wa)\n    self.ModuleReportList = []\n    if MaList is not None:\n        self._IsModuleBuild = True\n        for Ma in MaList:\n            self.ModuleReportList.append(ModuleReport(Ma, ReportType))\n    else:\n        self._IsModuleBuild = False\n        for Pa in Wa.AutoGenObjectList:\n            ModuleAutoGenList = []\n            for ModuleKey in Pa.Platform.Modules:\n                ModuleAutoGenList.append(Pa.Platform.Modules[ModuleKey].M)\n            if GlobalData.gFdfParser is not None:\n                if Pa.Arch in GlobalData.gFdfParser.Profile.InfDict:\n                    INFList = GlobalData.gFdfParser.Profile.InfDict[Pa.Arch]\n                    for InfName in INFList:\n                        InfClass = PathClass(NormPath(InfName), Wa.WorkspaceDir, Pa.Arch)\n                        Ma = ModuleAutoGen(Wa, InfClass, Pa.BuildTarget, Pa.ToolChain, Pa.Arch, Wa.MetaFile, Pa.DataPipe)\n                        if Ma is None:\n                            continue\n                        if Ma not in ModuleAutoGenList:\n                            ModuleAutoGenList.append(Ma)\n            for MGen in ModuleAutoGenList:\n                self.ModuleReportList.append(ModuleReport(MGen, ReportType))"
        ]
    },
    {
        "func_name": "GenerateReport",
        "original": "def GenerateReport(self, File, BuildDuration, AutoGenTime, MakeTime, GenFdsTime, ReportType):\n    FileWrite(File, 'Platform Summary')\n    FileWrite(File, 'Platform Name:        %s' % self.PlatformName)\n    FileWrite(File, 'Platform DSC Path:    %s' % self.PlatformDscPath)\n    FileWrite(File, 'Architectures:        %s' % self.Architectures)\n    FileWrite(File, 'Tool Chain:           %s' % self.ToolChain)\n    FileWrite(File, 'Target:               %s' % self.Target)\n    if GlobalData.gSkuids:\n        FileWrite(File, 'SKUID:                %s' % ' '.join(GlobalData.gSkuids))\n    if GlobalData.gDefaultStores:\n        FileWrite(File, 'DefaultStore:         %s' % ' '.join(GlobalData.gDefaultStores))\n    FileWrite(File, 'Output Path:          %s' % self.OutputPath)\n    FileWrite(File, 'Build Environment:    %s' % self.BuildEnvironment)\n    FileWrite(File, 'Build Duration:       %s' % BuildDuration)\n    if AutoGenTime:\n        FileWrite(File, 'AutoGen Duration:     %s' % AutoGenTime)\n    if MakeTime:\n        FileWrite(File, 'Make Duration:        %s' % MakeTime)\n    if GenFdsTime:\n        FileWrite(File, 'GenFds Duration:      %s' % GenFdsTime)\n    FileWrite(File, 'Report Content:       %s' % ', '.join(ReportType))\n    if GlobalData.MixedPcd:\n        FileWrite(File, gSectionStart)\n        FileWrite(File, 'The following PCDs use different access methods:')\n        FileWrite(File, gSectionSep)\n        for PcdItem in GlobalData.MixedPcd:\n            FileWrite(File, '%s.%s' % (str(PcdItem[1]), str(PcdItem[0])))\n        FileWrite(File, gSectionEnd)\n    if not self._IsModuleBuild:\n        if 'PCD' in ReportType:\n            self.PcdReport.GenerateReport(File, None)\n        if 'FLASH' in ReportType:\n            for FdReportListItem in self.FdReportList:\n                FdReportListItem.GenerateReport(File)\n    for ModuleReportItem in self.ModuleReportList:\n        ModuleReportItem.GenerateReport(File, self.PcdReport, self.PredictionReport, self.DepexParser, ReportType)\n    if not self._IsModuleBuild:\n        if 'EXECUTION_ORDER' in ReportType:\n            self.PredictionReport.GenerateReport(File, None)",
        "mutated": [
            "def GenerateReport(self, File, BuildDuration, AutoGenTime, MakeTime, GenFdsTime, ReportType):\n    if False:\n        i = 10\n    FileWrite(File, 'Platform Summary')\n    FileWrite(File, 'Platform Name:        %s' % self.PlatformName)\n    FileWrite(File, 'Platform DSC Path:    %s' % self.PlatformDscPath)\n    FileWrite(File, 'Architectures:        %s' % self.Architectures)\n    FileWrite(File, 'Tool Chain:           %s' % self.ToolChain)\n    FileWrite(File, 'Target:               %s' % self.Target)\n    if GlobalData.gSkuids:\n        FileWrite(File, 'SKUID:                %s' % ' '.join(GlobalData.gSkuids))\n    if GlobalData.gDefaultStores:\n        FileWrite(File, 'DefaultStore:         %s' % ' '.join(GlobalData.gDefaultStores))\n    FileWrite(File, 'Output Path:          %s' % self.OutputPath)\n    FileWrite(File, 'Build Environment:    %s' % self.BuildEnvironment)\n    FileWrite(File, 'Build Duration:       %s' % BuildDuration)\n    if AutoGenTime:\n        FileWrite(File, 'AutoGen Duration:     %s' % AutoGenTime)\n    if MakeTime:\n        FileWrite(File, 'Make Duration:        %s' % MakeTime)\n    if GenFdsTime:\n        FileWrite(File, 'GenFds Duration:      %s' % GenFdsTime)\n    FileWrite(File, 'Report Content:       %s' % ', '.join(ReportType))\n    if GlobalData.MixedPcd:\n        FileWrite(File, gSectionStart)\n        FileWrite(File, 'The following PCDs use different access methods:')\n        FileWrite(File, gSectionSep)\n        for PcdItem in GlobalData.MixedPcd:\n            FileWrite(File, '%s.%s' % (str(PcdItem[1]), str(PcdItem[0])))\n        FileWrite(File, gSectionEnd)\n    if not self._IsModuleBuild:\n        if 'PCD' in ReportType:\n            self.PcdReport.GenerateReport(File, None)\n        if 'FLASH' in ReportType:\n            for FdReportListItem in self.FdReportList:\n                FdReportListItem.GenerateReport(File)\n    for ModuleReportItem in self.ModuleReportList:\n        ModuleReportItem.GenerateReport(File, self.PcdReport, self.PredictionReport, self.DepexParser, ReportType)\n    if not self._IsModuleBuild:\n        if 'EXECUTION_ORDER' in ReportType:\n            self.PredictionReport.GenerateReport(File, None)",
            "def GenerateReport(self, File, BuildDuration, AutoGenTime, MakeTime, GenFdsTime, ReportType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    FileWrite(File, 'Platform Summary')\n    FileWrite(File, 'Platform Name:        %s' % self.PlatformName)\n    FileWrite(File, 'Platform DSC Path:    %s' % self.PlatformDscPath)\n    FileWrite(File, 'Architectures:        %s' % self.Architectures)\n    FileWrite(File, 'Tool Chain:           %s' % self.ToolChain)\n    FileWrite(File, 'Target:               %s' % self.Target)\n    if GlobalData.gSkuids:\n        FileWrite(File, 'SKUID:                %s' % ' '.join(GlobalData.gSkuids))\n    if GlobalData.gDefaultStores:\n        FileWrite(File, 'DefaultStore:         %s' % ' '.join(GlobalData.gDefaultStores))\n    FileWrite(File, 'Output Path:          %s' % self.OutputPath)\n    FileWrite(File, 'Build Environment:    %s' % self.BuildEnvironment)\n    FileWrite(File, 'Build Duration:       %s' % BuildDuration)\n    if AutoGenTime:\n        FileWrite(File, 'AutoGen Duration:     %s' % AutoGenTime)\n    if MakeTime:\n        FileWrite(File, 'Make Duration:        %s' % MakeTime)\n    if GenFdsTime:\n        FileWrite(File, 'GenFds Duration:      %s' % GenFdsTime)\n    FileWrite(File, 'Report Content:       %s' % ', '.join(ReportType))\n    if GlobalData.MixedPcd:\n        FileWrite(File, gSectionStart)\n        FileWrite(File, 'The following PCDs use different access methods:')\n        FileWrite(File, gSectionSep)\n        for PcdItem in GlobalData.MixedPcd:\n            FileWrite(File, '%s.%s' % (str(PcdItem[1]), str(PcdItem[0])))\n        FileWrite(File, gSectionEnd)\n    if not self._IsModuleBuild:\n        if 'PCD' in ReportType:\n            self.PcdReport.GenerateReport(File, None)\n        if 'FLASH' in ReportType:\n            for FdReportListItem in self.FdReportList:\n                FdReportListItem.GenerateReport(File)\n    for ModuleReportItem in self.ModuleReportList:\n        ModuleReportItem.GenerateReport(File, self.PcdReport, self.PredictionReport, self.DepexParser, ReportType)\n    if not self._IsModuleBuild:\n        if 'EXECUTION_ORDER' in ReportType:\n            self.PredictionReport.GenerateReport(File, None)",
            "def GenerateReport(self, File, BuildDuration, AutoGenTime, MakeTime, GenFdsTime, ReportType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    FileWrite(File, 'Platform Summary')\n    FileWrite(File, 'Platform Name:        %s' % self.PlatformName)\n    FileWrite(File, 'Platform DSC Path:    %s' % self.PlatformDscPath)\n    FileWrite(File, 'Architectures:        %s' % self.Architectures)\n    FileWrite(File, 'Tool Chain:           %s' % self.ToolChain)\n    FileWrite(File, 'Target:               %s' % self.Target)\n    if GlobalData.gSkuids:\n        FileWrite(File, 'SKUID:                %s' % ' '.join(GlobalData.gSkuids))\n    if GlobalData.gDefaultStores:\n        FileWrite(File, 'DefaultStore:         %s' % ' '.join(GlobalData.gDefaultStores))\n    FileWrite(File, 'Output Path:          %s' % self.OutputPath)\n    FileWrite(File, 'Build Environment:    %s' % self.BuildEnvironment)\n    FileWrite(File, 'Build Duration:       %s' % BuildDuration)\n    if AutoGenTime:\n        FileWrite(File, 'AutoGen Duration:     %s' % AutoGenTime)\n    if MakeTime:\n        FileWrite(File, 'Make Duration:        %s' % MakeTime)\n    if GenFdsTime:\n        FileWrite(File, 'GenFds Duration:      %s' % GenFdsTime)\n    FileWrite(File, 'Report Content:       %s' % ', '.join(ReportType))\n    if GlobalData.MixedPcd:\n        FileWrite(File, gSectionStart)\n        FileWrite(File, 'The following PCDs use different access methods:')\n        FileWrite(File, gSectionSep)\n        for PcdItem in GlobalData.MixedPcd:\n            FileWrite(File, '%s.%s' % (str(PcdItem[1]), str(PcdItem[0])))\n        FileWrite(File, gSectionEnd)\n    if not self._IsModuleBuild:\n        if 'PCD' in ReportType:\n            self.PcdReport.GenerateReport(File, None)\n        if 'FLASH' in ReportType:\n            for FdReportListItem in self.FdReportList:\n                FdReportListItem.GenerateReport(File)\n    for ModuleReportItem in self.ModuleReportList:\n        ModuleReportItem.GenerateReport(File, self.PcdReport, self.PredictionReport, self.DepexParser, ReportType)\n    if not self._IsModuleBuild:\n        if 'EXECUTION_ORDER' in ReportType:\n            self.PredictionReport.GenerateReport(File, None)",
            "def GenerateReport(self, File, BuildDuration, AutoGenTime, MakeTime, GenFdsTime, ReportType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    FileWrite(File, 'Platform Summary')\n    FileWrite(File, 'Platform Name:        %s' % self.PlatformName)\n    FileWrite(File, 'Platform DSC Path:    %s' % self.PlatformDscPath)\n    FileWrite(File, 'Architectures:        %s' % self.Architectures)\n    FileWrite(File, 'Tool Chain:           %s' % self.ToolChain)\n    FileWrite(File, 'Target:               %s' % self.Target)\n    if GlobalData.gSkuids:\n        FileWrite(File, 'SKUID:                %s' % ' '.join(GlobalData.gSkuids))\n    if GlobalData.gDefaultStores:\n        FileWrite(File, 'DefaultStore:         %s' % ' '.join(GlobalData.gDefaultStores))\n    FileWrite(File, 'Output Path:          %s' % self.OutputPath)\n    FileWrite(File, 'Build Environment:    %s' % self.BuildEnvironment)\n    FileWrite(File, 'Build Duration:       %s' % BuildDuration)\n    if AutoGenTime:\n        FileWrite(File, 'AutoGen Duration:     %s' % AutoGenTime)\n    if MakeTime:\n        FileWrite(File, 'Make Duration:        %s' % MakeTime)\n    if GenFdsTime:\n        FileWrite(File, 'GenFds Duration:      %s' % GenFdsTime)\n    FileWrite(File, 'Report Content:       %s' % ', '.join(ReportType))\n    if GlobalData.MixedPcd:\n        FileWrite(File, gSectionStart)\n        FileWrite(File, 'The following PCDs use different access methods:')\n        FileWrite(File, gSectionSep)\n        for PcdItem in GlobalData.MixedPcd:\n            FileWrite(File, '%s.%s' % (str(PcdItem[1]), str(PcdItem[0])))\n        FileWrite(File, gSectionEnd)\n    if not self._IsModuleBuild:\n        if 'PCD' in ReportType:\n            self.PcdReport.GenerateReport(File, None)\n        if 'FLASH' in ReportType:\n            for FdReportListItem in self.FdReportList:\n                FdReportListItem.GenerateReport(File)\n    for ModuleReportItem in self.ModuleReportList:\n        ModuleReportItem.GenerateReport(File, self.PcdReport, self.PredictionReport, self.DepexParser, ReportType)\n    if not self._IsModuleBuild:\n        if 'EXECUTION_ORDER' in ReportType:\n            self.PredictionReport.GenerateReport(File, None)",
            "def GenerateReport(self, File, BuildDuration, AutoGenTime, MakeTime, GenFdsTime, ReportType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    FileWrite(File, 'Platform Summary')\n    FileWrite(File, 'Platform Name:        %s' % self.PlatformName)\n    FileWrite(File, 'Platform DSC Path:    %s' % self.PlatformDscPath)\n    FileWrite(File, 'Architectures:        %s' % self.Architectures)\n    FileWrite(File, 'Tool Chain:           %s' % self.ToolChain)\n    FileWrite(File, 'Target:               %s' % self.Target)\n    if GlobalData.gSkuids:\n        FileWrite(File, 'SKUID:                %s' % ' '.join(GlobalData.gSkuids))\n    if GlobalData.gDefaultStores:\n        FileWrite(File, 'DefaultStore:         %s' % ' '.join(GlobalData.gDefaultStores))\n    FileWrite(File, 'Output Path:          %s' % self.OutputPath)\n    FileWrite(File, 'Build Environment:    %s' % self.BuildEnvironment)\n    FileWrite(File, 'Build Duration:       %s' % BuildDuration)\n    if AutoGenTime:\n        FileWrite(File, 'AutoGen Duration:     %s' % AutoGenTime)\n    if MakeTime:\n        FileWrite(File, 'Make Duration:        %s' % MakeTime)\n    if GenFdsTime:\n        FileWrite(File, 'GenFds Duration:      %s' % GenFdsTime)\n    FileWrite(File, 'Report Content:       %s' % ', '.join(ReportType))\n    if GlobalData.MixedPcd:\n        FileWrite(File, gSectionStart)\n        FileWrite(File, 'The following PCDs use different access methods:')\n        FileWrite(File, gSectionSep)\n        for PcdItem in GlobalData.MixedPcd:\n            FileWrite(File, '%s.%s' % (str(PcdItem[1]), str(PcdItem[0])))\n        FileWrite(File, gSectionEnd)\n    if not self._IsModuleBuild:\n        if 'PCD' in ReportType:\n            self.PcdReport.GenerateReport(File, None)\n        if 'FLASH' in ReportType:\n            for FdReportListItem in self.FdReportList:\n                FdReportListItem.GenerateReport(File)\n    for ModuleReportItem in self.ModuleReportList:\n        ModuleReportItem.GenerateReport(File, self.PcdReport, self.PredictionReport, self.DepexParser, ReportType)\n    if not self._IsModuleBuild:\n        if 'EXECUTION_ORDER' in ReportType:\n            self.PredictionReport.GenerateReport(File, None)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, ReportFile, ReportType):\n    self.ReportFile = ReportFile\n    if ReportFile:\n        self.ReportList = []\n        self.ReportType = []\n        if ReportType:\n            for ReportTypeItem in ReportType:\n                if ReportTypeItem not in self.ReportType:\n                    self.ReportType.append(ReportTypeItem)\n        else:\n            self.ReportType = ['PCD', 'LIBRARY', 'BUILD_FLAGS', 'DEPEX', 'HASH', 'FLASH', 'FIXED_ADDRESS']",
        "mutated": [
            "def __init__(self, ReportFile, ReportType):\n    if False:\n        i = 10\n    self.ReportFile = ReportFile\n    if ReportFile:\n        self.ReportList = []\n        self.ReportType = []\n        if ReportType:\n            for ReportTypeItem in ReportType:\n                if ReportTypeItem not in self.ReportType:\n                    self.ReportType.append(ReportTypeItem)\n        else:\n            self.ReportType = ['PCD', 'LIBRARY', 'BUILD_FLAGS', 'DEPEX', 'HASH', 'FLASH', 'FIXED_ADDRESS']",
            "def __init__(self, ReportFile, ReportType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.ReportFile = ReportFile\n    if ReportFile:\n        self.ReportList = []\n        self.ReportType = []\n        if ReportType:\n            for ReportTypeItem in ReportType:\n                if ReportTypeItem not in self.ReportType:\n                    self.ReportType.append(ReportTypeItem)\n        else:\n            self.ReportType = ['PCD', 'LIBRARY', 'BUILD_FLAGS', 'DEPEX', 'HASH', 'FLASH', 'FIXED_ADDRESS']",
            "def __init__(self, ReportFile, ReportType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.ReportFile = ReportFile\n    if ReportFile:\n        self.ReportList = []\n        self.ReportType = []\n        if ReportType:\n            for ReportTypeItem in ReportType:\n                if ReportTypeItem not in self.ReportType:\n                    self.ReportType.append(ReportTypeItem)\n        else:\n            self.ReportType = ['PCD', 'LIBRARY', 'BUILD_FLAGS', 'DEPEX', 'HASH', 'FLASH', 'FIXED_ADDRESS']",
            "def __init__(self, ReportFile, ReportType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.ReportFile = ReportFile\n    if ReportFile:\n        self.ReportList = []\n        self.ReportType = []\n        if ReportType:\n            for ReportTypeItem in ReportType:\n                if ReportTypeItem not in self.ReportType:\n                    self.ReportType.append(ReportTypeItem)\n        else:\n            self.ReportType = ['PCD', 'LIBRARY', 'BUILD_FLAGS', 'DEPEX', 'HASH', 'FLASH', 'FIXED_ADDRESS']",
            "def __init__(self, ReportFile, ReportType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.ReportFile = ReportFile\n    if ReportFile:\n        self.ReportList = []\n        self.ReportType = []\n        if ReportType:\n            for ReportTypeItem in ReportType:\n                if ReportTypeItem not in self.ReportType:\n                    self.ReportType.append(ReportTypeItem)\n        else:\n            self.ReportType = ['PCD', 'LIBRARY', 'BUILD_FLAGS', 'DEPEX', 'HASH', 'FLASH', 'FIXED_ADDRESS']"
        ]
    },
    {
        "func_name": "AddPlatformReport",
        "original": "def AddPlatformReport(self, Wa, MaList=None):\n    if self.ReportFile:\n        self.ReportList.append((Wa, MaList))",
        "mutated": [
            "def AddPlatformReport(self, Wa, MaList=None):\n    if False:\n        i = 10\n    if self.ReportFile:\n        self.ReportList.append((Wa, MaList))",
            "def AddPlatformReport(self, Wa, MaList=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.ReportFile:\n        self.ReportList.append((Wa, MaList))",
            "def AddPlatformReport(self, Wa, MaList=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.ReportFile:\n        self.ReportList.append((Wa, MaList))",
            "def AddPlatformReport(self, Wa, MaList=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.ReportFile:\n        self.ReportList.append((Wa, MaList))",
            "def AddPlatformReport(self, Wa, MaList=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.ReportFile:\n        self.ReportList.append((Wa, MaList))"
        ]
    },
    {
        "func_name": "GenerateReport",
        "original": "def GenerateReport(self, BuildDuration, AutoGenTime, MakeTime, GenFdsTime):\n    if self.ReportFile:\n        try:\n            if 'COMPILE_INFO' in self.ReportType:\n                self.GenerateCompileInfo()\n            File = []\n            for (Wa, MaList) in self.ReportList:\n                PlatformReport(Wa, MaList, self.ReportType).GenerateReport(File, BuildDuration, AutoGenTime, MakeTime, GenFdsTime, self.ReportType)\n            Content = FileLinesSplit(''.join(File), gLineMaxLength)\n            SaveFileOnChange(self.ReportFile, Content, False)\n            EdkLogger.quiet('Build report can be found at %s' % os.path.abspath(self.ReportFile))\n        except IOError:\n            EdkLogger.error(None, FILE_WRITE_FAILURE, ExtraData=self.ReportFile)\n        except:\n            EdkLogger.error('BuildReport', CODE_ERROR, 'Unknown fatal error when generating build report', ExtraData=self.ReportFile, RaiseError=False)\n            EdkLogger.quiet('(Python %s on %s\\n%s)' % (platform.python_version(), sys.platform, traceback.format_exc()))",
        "mutated": [
            "def GenerateReport(self, BuildDuration, AutoGenTime, MakeTime, GenFdsTime):\n    if False:\n        i = 10\n    if self.ReportFile:\n        try:\n            if 'COMPILE_INFO' in self.ReportType:\n                self.GenerateCompileInfo()\n            File = []\n            for (Wa, MaList) in self.ReportList:\n                PlatformReport(Wa, MaList, self.ReportType).GenerateReport(File, BuildDuration, AutoGenTime, MakeTime, GenFdsTime, self.ReportType)\n            Content = FileLinesSplit(''.join(File), gLineMaxLength)\n            SaveFileOnChange(self.ReportFile, Content, False)\n            EdkLogger.quiet('Build report can be found at %s' % os.path.abspath(self.ReportFile))\n        except IOError:\n            EdkLogger.error(None, FILE_WRITE_FAILURE, ExtraData=self.ReportFile)\n        except:\n            EdkLogger.error('BuildReport', CODE_ERROR, 'Unknown fatal error when generating build report', ExtraData=self.ReportFile, RaiseError=False)\n            EdkLogger.quiet('(Python %s on %s\\n%s)' % (platform.python_version(), sys.platform, traceback.format_exc()))",
            "def GenerateReport(self, BuildDuration, AutoGenTime, MakeTime, GenFdsTime):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.ReportFile:\n        try:\n            if 'COMPILE_INFO' in self.ReportType:\n                self.GenerateCompileInfo()\n            File = []\n            for (Wa, MaList) in self.ReportList:\n                PlatformReport(Wa, MaList, self.ReportType).GenerateReport(File, BuildDuration, AutoGenTime, MakeTime, GenFdsTime, self.ReportType)\n            Content = FileLinesSplit(''.join(File), gLineMaxLength)\n            SaveFileOnChange(self.ReportFile, Content, False)\n            EdkLogger.quiet('Build report can be found at %s' % os.path.abspath(self.ReportFile))\n        except IOError:\n            EdkLogger.error(None, FILE_WRITE_FAILURE, ExtraData=self.ReportFile)\n        except:\n            EdkLogger.error('BuildReport', CODE_ERROR, 'Unknown fatal error when generating build report', ExtraData=self.ReportFile, RaiseError=False)\n            EdkLogger.quiet('(Python %s on %s\\n%s)' % (platform.python_version(), sys.platform, traceback.format_exc()))",
            "def GenerateReport(self, BuildDuration, AutoGenTime, MakeTime, GenFdsTime):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.ReportFile:\n        try:\n            if 'COMPILE_INFO' in self.ReportType:\n                self.GenerateCompileInfo()\n            File = []\n            for (Wa, MaList) in self.ReportList:\n                PlatformReport(Wa, MaList, self.ReportType).GenerateReport(File, BuildDuration, AutoGenTime, MakeTime, GenFdsTime, self.ReportType)\n            Content = FileLinesSplit(''.join(File), gLineMaxLength)\n            SaveFileOnChange(self.ReportFile, Content, False)\n            EdkLogger.quiet('Build report can be found at %s' % os.path.abspath(self.ReportFile))\n        except IOError:\n            EdkLogger.error(None, FILE_WRITE_FAILURE, ExtraData=self.ReportFile)\n        except:\n            EdkLogger.error('BuildReport', CODE_ERROR, 'Unknown fatal error when generating build report', ExtraData=self.ReportFile, RaiseError=False)\n            EdkLogger.quiet('(Python %s on %s\\n%s)' % (platform.python_version(), sys.platform, traceback.format_exc()))",
            "def GenerateReport(self, BuildDuration, AutoGenTime, MakeTime, GenFdsTime):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.ReportFile:\n        try:\n            if 'COMPILE_INFO' in self.ReportType:\n                self.GenerateCompileInfo()\n            File = []\n            for (Wa, MaList) in self.ReportList:\n                PlatformReport(Wa, MaList, self.ReportType).GenerateReport(File, BuildDuration, AutoGenTime, MakeTime, GenFdsTime, self.ReportType)\n            Content = FileLinesSplit(''.join(File), gLineMaxLength)\n            SaveFileOnChange(self.ReportFile, Content, False)\n            EdkLogger.quiet('Build report can be found at %s' % os.path.abspath(self.ReportFile))\n        except IOError:\n            EdkLogger.error(None, FILE_WRITE_FAILURE, ExtraData=self.ReportFile)\n        except:\n            EdkLogger.error('BuildReport', CODE_ERROR, 'Unknown fatal error when generating build report', ExtraData=self.ReportFile, RaiseError=False)\n            EdkLogger.quiet('(Python %s on %s\\n%s)' % (platform.python_version(), sys.platform, traceback.format_exc()))",
            "def GenerateReport(self, BuildDuration, AutoGenTime, MakeTime, GenFdsTime):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.ReportFile:\n        try:\n            if 'COMPILE_INFO' in self.ReportType:\n                self.GenerateCompileInfo()\n            File = []\n            for (Wa, MaList) in self.ReportList:\n                PlatformReport(Wa, MaList, self.ReportType).GenerateReport(File, BuildDuration, AutoGenTime, MakeTime, GenFdsTime, self.ReportType)\n            Content = FileLinesSplit(''.join(File), gLineMaxLength)\n            SaveFileOnChange(self.ReportFile, Content, False)\n            EdkLogger.quiet('Build report can be found at %s' % os.path.abspath(self.ReportFile))\n        except IOError:\n            EdkLogger.error(None, FILE_WRITE_FAILURE, ExtraData=self.ReportFile)\n        except:\n            EdkLogger.error('BuildReport', CODE_ERROR, 'Unknown fatal error when generating build report', ExtraData=self.ReportFile, RaiseError=False)\n            EdkLogger.quiet('(Python %s on %s\\n%s)' % (platform.python_version(), sys.platform, traceback.format_exc()))"
        ]
    },
    {
        "func_name": "GenerateCompileInfo",
        "original": "def GenerateCompileInfo(self):\n    try:\n        compile_commands = []\n        used_files = set()\n        module_report = []\n        for (Wa, MaList) in self.ReportList:\n            for file_path in Wa._GetMetaFiles(Wa.BuildTarget, Wa.ToolChain):\n                used_files.add(file_path)\n            for autoGen in Wa.AutoGenObjectList:\n                for module in autoGen.LibraryAutoGenList + autoGen.ModuleAutoGenList:\n                    used_files.add(module.MetaFile.Path)\n                    module_report_data = {}\n                    module_report_data['Name'] = module.Name\n                    module_report_data['Arch'] = module.Arch\n                    module_report_data['Path'] = module.MetaFile.Path\n                    module_report_data['Guid'] = module.Guid\n                    module_report_data['BuildType'] = module.BuildType\n                    module_report_data['IsLibrary'] = module.IsLibrary\n                    module_report_data['SourceDir'] = module.SourceDir\n                    module_report_data['Files'] = []\n                    module_report_data['LibraryClass'] = module.Module.LibraryClass\n                    module_report_data['ModuleEntryPointList'] = module.Module.ModuleEntryPointList\n                    module_report_data['ConstructorList'] = module.Module.ConstructorList\n                    module_report_data['DestructorList'] = module.Module.DestructorList\n                    for data_file in module.SourceFileList:\n                        module_report_data['Files'].append({'Name': data_file.Name, 'Path': data_file.Path})\n                    module_report_data['Libraries'] = []\n                    for data_library in module.LibraryAutoGenList:\n                        module_report_data['Libraries'].append({'Path': data_library.MetaFile.Path})\n                    module_report_data['Packages'] = []\n                    for data_package in module.PackageList:\n                        module_report_data['Packages'].append({'Path': data_package.MetaFile.Path, 'Includes': []})\n                        for data_package_include in data_package.Includes:\n                            module_report_data['Packages'][-1]['Includes'].append(data_package_include.Path)\n                    module_report_data['PPI'] = []\n                    for data_ppi in module.PpiList.keys():\n                        module_report_data['PPI'].append({'Name': data_ppi, 'Guid': module.PpiList[data_ppi]})\n                    module_report_data['Protocol'] = []\n                    for data_protocol in module.ProtocolList.keys():\n                        module_report_data['Protocol'].append({'Name': data_protocol, 'Guid': module.ProtocolList[data_protocol]})\n                    module_report_data['Pcd'] = []\n                    for data_pcd in module.LibraryPcdList:\n                        module_report_data['Pcd'].append({'Space': data_pcd.TokenSpaceGuidCName, 'Name': data_pcd.TokenCName, 'Value': data_pcd.TokenValue, 'Guid': data_pcd.TokenSpaceGuidValue, 'DatumType': data_pcd.DatumType, 'Type': data_pcd.Type, 'DefaultValue': data_pcd.DefaultValue})\n                    module_report.append(module_report_data)\n                    includes_autogen = IncludesAutoGen(module.MakeFileDir, module)\n                    for dep in includes_autogen.DepsCollection:\n                        used_files.add(dep)\n                    inc_flag = '-I'\n                    if module.BuildRuleFamily == TAB_COMPILER_MSFT:\n                        inc_flag = '/I'\n                    for source in module.SourceFileList:\n                        used_files.add(source.Path)\n                        compile_command = {}\n                        if source.Ext in ['.c', '.cc', '.cpp']:\n                            compile_command['file'] = source.Path\n                            compile_command['directory'] = source.Dir\n                            build_command = module.BuildRules[source.Ext].CommandList[0]\n                            build_command_variables = re.findall('\\\\$\\\\((.*?)\\\\)', build_command)\n                            for var in build_command_variables:\n                                var_tokens = var.split('_')\n                                var_main = var_tokens[0]\n                                if len(var_tokens) == 1:\n                                    var_value = module.BuildOption[var_main]['PATH']\n                                else:\n                                    var_value = module.BuildOption[var_main][var_tokens[1]]\n                                build_command = build_command.replace(f'$({var})', var_value)\n                                include_files = f' {inc_flag}'.join(module.IncludePathList)\n                                build_command = build_command.replace('${src}', include_files)\n                                build_command = build_command.replace('${dst}', module.OutputDir)\n                            compile_command['command'] = re.sub('\\\\$\\\\(.*?\\\\)', '', build_command)\n                            compile_commands.append(compile_command)\n            compile_info_folder = Path(Wa.BuildDir).joinpath('CompileInfo')\n            compile_info_folder.mkdir(exist_ok=True)\n            compile_commands.sort(key=lambda x: x['file'])\n            SaveFileOnChange(compile_info_folder.joinpath(f'compile_commands.json'), json.dumps(compile_commands, indent=2), False)\n            SaveFileOnChange(compile_info_folder.joinpath(f'cscope.files'), '\\n'.join(sorted(used_files)), False)\n            module_report.sort(key=lambda x: x['Path'])\n            SaveFileOnChange(compile_info_folder.joinpath(f'module_report.json'), json.dumps(module_report, indent=2), False)\n    except:\n        EdkLogger.error('BuildReport', CODE_ERROR, 'Unknown fatal error when generating build report compile information', ExtraData=self.ReportFile, RaiseError=False)\n        EdkLogger.quiet('(Python %s on %s\\n%s)' % (platform.python_version(), sys.platform, traceback.format_exc()))",
        "mutated": [
            "def GenerateCompileInfo(self):\n    if False:\n        i = 10\n    try:\n        compile_commands = []\n        used_files = set()\n        module_report = []\n        for (Wa, MaList) in self.ReportList:\n            for file_path in Wa._GetMetaFiles(Wa.BuildTarget, Wa.ToolChain):\n                used_files.add(file_path)\n            for autoGen in Wa.AutoGenObjectList:\n                for module in autoGen.LibraryAutoGenList + autoGen.ModuleAutoGenList:\n                    used_files.add(module.MetaFile.Path)\n                    module_report_data = {}\n                    module_report_data['Name'] = module.Name\n                    module_report_data['Arch'] = module.Arch\n                    module_report_data['Path'] = module.MetaFile.Path\n                    module_report_data['Guid'] = module.Guid\n                    module_report_data['BuildType'] = module.BuildType\n                    module_report_data['IsLibrary'] = module.IsLibrary\n                    module_report_data['SourceDir'] = module.SourceDir\n                    module_report_data['Files'] = []\n                    module_report_data['LibraryClass'] = module.Module.LibraryClass\n                    module_report_data['ModuleEntryPointList'] = module.Module.ModuleEntryPointList\n                    module_report_data['ConstructorList'] = module.Module.ConstructorList\n                    module_report_data['DestructorList'] = module.Module.DestructorList\n                    for data_file in module.SourceFileList:\n                        module_report_data['Files'].append({'Name': data_file.Name, 'Path': data_file.Path})\n                    module_report_data['Libraries'] = []\n                    for data_library in module.LibraryAutoGenList:\n                        module_report_data['Libraries'].append({'Path': data_library.MetaFile.Path})\n                    module_report_data['Packages'] = []\n                    for data_package in module.PackageList:\n                        module_report_data['Packages'].append({'Path': data_package.MetaFile.Path, 'Includes': []})\n                        for data_package_include in data_package.Includes:\n                            module_report_data['Packages'][-1]['Includes'].append(data_package_include.Path)\n                    module_report_data['PPI'] = []\n                    for data_ppi in module.PpiList.keys():\n                        module_report_data['PPI'].append({'Name': data_ppi, 'Guid': module.PpiList[data_ppi]})\n                    module_report_data['Protocol'] = []\n                    for data_protocol in module.ProtocolList.keys():\n                        module_report_data['Protocol'].append({'Name': data_protocol, 'Guid': module.ProtocolList[data_protocol]})\n                    module_report_data['Pcd'] = []\n                    for data_pcd in module.LibraryPcdList:\n                        module_report_data['Pcd'].append({'Space': data_pcd.TokenSpaceGuidCName, 'Name': data_pcd.TokenCName, 'Value': data_pcd.TokenValue, 'Guid': data_pcd.TokenSpaceGuidValue, 'DatumType': data_pcd.DatumType, 'Type': data_pcd.Type, 'DefaultValue': data_pcd.DefaultValue})\n                    module_report.append(module_report_data)\n                    includes_autogen = IncludesAutoGen(module.MakeFileDir, module)\n                    for dep in includes_autogen.DepsCollection:\n                        used_files.add(dep)\n                    inc_flag = '-I'\n                    if module.BuildRuleFamily == TAB_COMPILER_MSFT:\n                        inc_flag = '/I'\n                    for source in module.SourceFileList:\n                        used_files.add(source.Path)\n                        compile_command = {}\n                        if source.Ext in ['.c', '.cc', '.cpp']:\n                            compile_command['file'] = source.Path\n                            compile_command['directory'] = source.Dir\n                            build_command = module.BuildRules[source.Ext].CommandList[0]\n                            build_command_variables = re.findall('\\\\$\\\\((.*?)\\\\)', build_command)\n                            for var in build_command_variables:\n                                var_tokens = var.split('_')\n                                var_main = var_tokens[0]\n                                if len(var_tokens) == 1:\n                                    var_value = module.BuildOption[var_main]['PATH']\n                                else:\n                                    var_value = module.BuildOption[var_main][var_tokens[1]]\n                                build_command = build_command.replace(f'$({var})', var_value)\n                                include_files = f' {inc_flag}'.join(module.IncludePathList)\n                                build_command = build_command.replace('${src}', include_files)\n                                build_command = build_command.replace('${dst}', module.OutputDir)\n                            compile_command['command'] = re.sub('\\\\$\\\\(.*?\\\\)', '', build_command)\n                            compile_commands.append(compile_command)\n            compile_info_folder = Path(Wa.BuildDir).joinpath('CompileInfo')\n            compile_info_folder.mkdir(exist_ok=True)\n            compile_commands.sort(key=lambda x: x['file'])\n            SaveFileOnChange(compile_info_folder.joinpath(f'compile_commands.json'), json.dumps(compile_commands, indent=2), False)\n            SaveFileOnChange(compile_info_folder.joinpath(f'cscope.files'), '\\n'.join(sorted(used_files)), False)\n            module_report.sort(key=lambda x: x['Path'])\n            SaveFileOnChange(compile_info_folder.joinpath(f'module_report.json'), json.dumps(module_report, indent=2), False)\n    except:\n        EdkLogger.error('BuildReport', CODE_ERROR, 'Unknown fatal error when generating build report compile information', ExtraData=self.ReportFile, RaiseError=False)\n        EdkLogger.quiet('(Python %s on %s\\n%s)' % (platform.python_version(), sys.platform, traceback.format_exc()))",
            "def GenerateCompileInfo(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        compile_commands = []\n        used_files = set()\n        module_report = []\n        for (Wa, MaList) in self.ReportList:\n            for file_path in Wa._GetMetaFiles(Wa.BuildTarget, Wa.ToolChain):\n                used_files.add(file_path)\n            for autoGen in Wa.AutoGenObjectList:\n                for module in autoGen.LibraryAutoGenList + autoGen.ModuleAutoGenList:\n                    used_files.add(module.MetaFile.Path)\n                    module_report_data = {}\n                    module_report_data['Name'] = module.Name\n                    module_report_data['Arch'] = module.Arch\n                    module_report_data['Path'] = module.MetaFile.Path\n                    module_report_data['Guid'] = module.Guid\n                    module_report_data['BuildType'] = module.BuildType\n                    module_report_data['IsLibrary'] = module.IsLibrary\n                    module_report_data['SourceDir'] = module.SourceDir\n                    module_report_data['Files'] = []\n                    module_report_data['LibraryClass'] = module.Module.LibraryClass\n                    module_report_data['ModuleEntryPointList'] = module.Module.ModuleEntryPointList\n                    module_report_data['ConstructorList'] = module.Module.ConstructorList\n                    module_report_data['DestructorList'] = module.Module.DestructorList\n                    for data_file in module.SourceFileList:\n                        module_report_data['Files'].append({'Name': data_file.Name, 'Path': data_file.Path})\n                    module_report_data['Libraries'] = []\n                    for data_library in module.LibraryAutoGenList:\n                        module_report_data['Libraries'].append({'Path': data_library.MetaFile.Path})\n                    module_report_data['Packages'] = []\n                    for data_package in module.PackageList:\n                        module_report_data['Packages'].append({'Path': data_package.MetaFile.Path, 'Includes': []})\n                        for data_package_include in data_package.Includes:\n                            module_report_data['Packages'][-1]['Includes'].append(data_package_include.Path)\n                    module_report_data['PPI'] = []\n                    for data_ppi in module.PpiList.keys():\n                        module_report_data['PPI'].append({'Name': data_ppi, 'Guid': module.PpiList[data_ppi]})\n                    module_report_data['Protocol'] = []\n                    for data_protocol in module.ProtocolList.keys():\n                        module_report_data['Protocol'].append({'Name': data_protocol, 'Guid': module.ProtocolList[data_protocol]})\n                    module_report_data['Pcd'] = []\n                    for data_pcd in module.LibraryPcdList:\n                        module_report_data['Pcd'].append({'Space': data_pcd.TokenSpaceGuidCName, 'Name': data_pcd.TokenCName, 'Value': data_pcd.TokenValue, 'Guid': data_pcd.TokenSpaceGuidValue, 'DatumType': data_pcd.DatumType, 'Type': data_pcd.Type, 'DefaultValue': data_pcd.DefaultValue})\n                    module_report.append(module_report_data)\n                    includes_autogen = IncludesAutoGen(module.MakeFileDir, module)\n                    for dep in includes_autogen.DepsCollection:\n                        used_files.add(dep)\n                    inc_flag = '-I'\n                    if module.BuildRuleFamily == TAB_COMPILER_MSFT:\n                        inc_flag = '/I'\n                    for source in module.SourceFileList:\n                        used_files.add(source.Path)\n                        compile_command = {}\n                        if source.Ext in ['.c', '.cc', '.cpp']:\n                            compile_command['file'] = source.Path\n                            compile_command['directory'] = source.Dir\n                            build_command = module.BuildRules[source.Ext].CommandList[0]\n                            build_command_variables = re.findall('\\\\$\\\\((.*?)\\\\)', build_command)\n                            for var in build_command_variables:\n                                var_tokens = var.split('_')\n                                var_main = var_tokens[0]\n                                if len(var_tokens) == 1:\n                                    var_value = module.BuildOption[var_main]['PATH']\n                                else:\n                                    var_value = module.BuildOption[var_main][var_tokens[1]]\n                                build_command = build_command.replace(f'$({var})', var_value)\n                                include_files = f' {inc_flag}'.join(module.IncludePathList)\n                                build_command = build_command.replace('${src}', include_files)\n                                build_command = build_command.replace('${dst}', module.OutputDir)\n                            compile_command['command'] = re.sub('\\\\$\\\\(.*?\\\\)', '', build_command)\n                            compile_commands.append(compile_command)\n            compile_info_folder = Path(Wa.BuildDir).joinpath('CompileInfo')\n            compile_info_folder.mkdir(exist_ok=True)\n            compile_commands.sort(key=lambda x: x['file'])\n            SaveFileOnChange(compile_info_folder.joinpath(f'compile_commands.json'), json.dumps(compile_commands, indent=2), False)\n            SaveFileOnChange(compile_info_folder.joinpath(f'cscope.files'), '\\n'.join(sorted(used_files)), False)\n            module_report.sort(key=lambda x: x['Path'])\n            SaveFileOnChange(compile_info_folder.joinpath(f'module_report.json'), json.dumps(module_report, indent=2), False)\n    except:\n        EdkLogger.error('BuildReport', CODE_ERROR, 'Unknown fatal error when generating build report compile information', ExtraData=self.ReportFile, RaiseError=False)\n        EdkLogger.quiet('(Python %s on %s\\n%s)' % (platform.python_version(), sys.platform, traceback.format_exc()))",
            "def GenerateCompileInfo(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        compile_commands = []\n        used_files = set()\n        module_report = []\n        for (Wa, MaList) in self.ReportList:\n            for file_path in Wa._GetMetaFiles(Wa.BuildTarget, Wa.ToolChain):\n                used_files.add(file_path)\n            for autoGen in Wa.AutoGenObjectList:\n                for module in autoGen.LibraryAutoGenList + autoGen.ModuleAutoGenList:\n                    used_files.add(module.MetaFile.Path)\n                    module_report_data = {}\n                    module_report_data['Name'] = module.Name\n                    module_report_data['Arch'] = module.Arch\n                    module_report_data['Path'] = module.MetaFile.Path\n                    module_report_data['Guid'] = module.Guid\n                    module_report_data['BuildType'] = module.BuildType\n                    module_report_data['IsLibrary'] = module.IsLibrary\n                    module_report_data['SourceDir'] = module.SourceDir\n                    module_report_data['Files'] = []\n                    module_report_data['LibraryClass'] = module.Module.LibraryClass\n                    module_report_data['ModuleEntryPointList'] = module.Module.ModuleEntryPointList\n                    module_report_data['ConstructorList'] = module.Module.ConstructorList\n                    module_report_data['DestructorList'] = module.Module.DestructorList\n                    for data_file in module.SourceFileList:\n                        module_report_data['Files'].append({'Name': data_file.Name, 'Path': data_file.Path})\n                    module_report_data['Libraries'] = []\n                    for data_library in module.LibraryAutoGenList:\n                        module_report_data['Libraries'].append({'Path': data_library.MetaFile.Path})\n                    module_report_data['Packages'] = []\n                    for data_package in module.PackageList:\n                        module_report_data['Packages'].append({'Path': data_package.MetaFile.Path, 'Includes': []})\n                        for data_package_include in data_package.Includes:\n                            module_report_data['Packages'][-1]['Includes'].append(data_package_include.Path)\n                    module_report_data['PPI'] = []\n                    for data_ppi in module.PpiList.keys():\n                        module_report_data['PPI'].append({'Name': data_ppi, 'Guid': module.PpiList[data_ppi]})\n                    module_report_data['Protocol'] = []\n                    for data_protocol in module.ProtocolList.keys():\n                        module_report_data['Protocol'].append({'Name': data_protocol, 'Guid': module.ProtocolList[data_protocol]})\n                    module_report_data['Pcd'] = []\n                    for data_pcd in module.LibraryPcdList:\n                        module_report_data['Pcd'].append({'Space': data_pcd.TokenSpaceGuidCName, 'Name': data_pcd.TokenCName, 'Value': data_pcd.TokenValue, 'Guid': data_pcd.TokenSpaceGuidValue, 'DatumType': data_pcd.DatumType, 'Type': data_pcd.Type, 'DefaultValue': data_pcd.DefaultValue})\n                    module_report.append(module_report_data)\n                    includes_autogen = IncludesAutoGen(module.MakeFileDir, module)\n                    for dep in includes_autogen.DepsCollection:\n                        used_files.add(dep)\n                    inc_flag = '-I'\n                    if module.BuildRuleFamily == TAB_COMPILER_MSFT:\n                        inc_flag = '/I'\n                    for source in module.SourceFileList:\n                        used_files.add(source.Path)\n                        compile_command = {}\n                        if source.Ext in ['.c', '.cc', '.cpp']:\n                            compile_command['file'] = source.Path\n                            compile_command['directory'] = source.Dir\n                            build_command = module.BuildRules[source.Ext].CommandList[0]\n                            build_command_variables = re.findall('\\\\$\\\\((.*?)\\\\)', build_command)\n                            for var in build_command_variables:\n                                var_tokens = var.split('_')\n                                var_main = var_tokens[0]\n                                if len(var_tokens) == 1:\n                                    var_value = module.BuildOption[var_main]['PATH']\n                                else:\n                                    var_value = module.BuildOption[var_main][var_tokens[1]]\n                                build_command = build_command.replace(f'$({var})', var_value)\n                                include_files = f' {inc_flag}'.join(module.IncludePathList)\n                                build_command = build_command.replace('${src}', include_files)\n                                build_command = build_command.replace('${dst}', module.OutputDir)\n                            compile_command['command'] = re.sub('\\\\$\\\\(.*?\\\\)', '', build_command)\n                            compile_commands.append(compile_command)\n            compile_info_folder = Path(Wa.BuildDir).joinpath('CompileInfo')\n            compile_info_folder.mkdir(exist_ok=True)\n            compile_commands.sort(key=lambda x: x['file'])\n            SaveFileOnChange(compile_info_folder.joinpath(f'compile_commands.json'), json.dumps(compile_commands, indent=2), False)\n            SaveFileOnChange(compile_info_folder.joinpath(f'cscope.files'), '\\n'.join(sorted(used_files)), False)\n            module_report.sort(key=lambda x: x['Path'])\n            SaveFileOnChange(compile_info_folder.joinpath(f'module_report.json'), json.dumps(module_report, indent=2), False)\n    except:\n        EdkLogger.error('BuildReport', CODE_ERROR, 'Unknown fatal error when generating build report compile information', ExtraData=self.ReportFile, RaiseError=False)\n        EdkLogger.quiet('(Python %s on %s\\n%s)' % (platform.python_version(), sys.platform, traceback.format_exc()))",
            "def GenerateCompileInfo(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        compile_commands = []\n        used_files = set()\n        module_report = []\n        for (Wa, MaList) in self.ReportList:\n            for file_path in Wa._GetMetaFiles(Wa.BuildTarget, Wa.ToolChain):\n                used_files.add(file_path)\n            for autoGen in Wa.AutoGenObjectList:\n                for module in autoGen.LibraryAutoGenList + autoGen.ModuleAutoGenList:\n                    used_files.add(module.MetaFile.Path)\n                    module_report_data = {}\n                    module_report_data['Name'] = module.Name\n                    module_report_data['Arch'] = module.Arch\n                    module_report_data['Path'] = module.MetaFile.Path\n                    module_report_data['Guid'] = module.Guid\n                    module_report_data['BuildType'] = module.BuildType\n                    module_report_data['IsLibrary'] = module.IsLibrary\n                    module_report_data['SourceDir'] = module.SourceDir\n                    module_report_data['Files'] = []\n                    module_report_data['LibraryClass'] = module.Module.LibraryClass\n                    module_report_data['ModuleEntryPointList'] = module.Module.ModuleEntryPointList\n                    module_report_data['ConstructorList'] = module.Module.ConstructorList\n                    module_report_data['DestructorList'] = module.Module.DestructorList\n                    for data_file in module.SourceFileList:\n                        module_report_data['Files'].append({'Name': data_file.Name, 'Path': data_file.Path})\n                    module_report_data['Libraries'] = []\n                    for data_library in module.LibraryAutoGenList:\n                        module_report_data['Libraries'].append({'Path': data_library.MetaFile.Path})\n                    module_report_data['Packages'] = []\n                    for data_package in module.PackageList:\n                        module_report_data['Packages'].append({'Path': data_package.MetaFile.Path, 'Includes': []})\n                        for data_package_include in data_package.Includes:\n                            module_report_data['Packages'][-1]['Includes'].append(data_package_include.Path)\n                    module_report_data['PPI'] = []\n                    for data_ppi in module.PpiList.keys():\n                        module_report_data['PPI'].append({'Name': data_ppi, 'Guid': module.PpiList[data_ppi]})\n                    module_report_data['Protocol'] = []\n                    for data_protocol in module.ProtocolList.keys():\n                        module_report_data['Protocol'].append({'Name': data_protocol, 'Guid': module.ProtocolList[data_protocol]})\n                    module_report_data['Pcd'] = []\n                    for data_pcd in module.LibraryPcdList:\n                        module_report_data['Pcd'].append({'Space': data_pcd.TokenSpaceGuidCName, 'Name': data_pcd.TokenCName, 'Value': data_pcd.TokenValue, 'Guid': data_pcd.TokenSpaceGuidValue, 'DatumType': data_pcd.DatumType, 'Type': data_pcd.Type, 'DefaultValue': data_pcd.DefaultValue})\n                    module_report.append(module_report_data)\n                    includes_autogen = IncludesAutoGen(module.MakeFileDir, module)\n                    for dep in includes_autogen.DepsCollection:\n                        used_files.add(dep)\n                    inc_flag = '-I'\n                    if module.BuildRuleFamily == TAB_COMPILER_MSFT:\n                        inc_flag = '/I'\n                    for source in module.SourceFileList:\n                        used_files.add(source.Path)\n                        compile_command = {}\n                        if source.Ext in ['.c', '.cc', '.cpp']:\n                            compile_command['file'] = source.Path\n                            compile_command['directory'] = source.Dir\n                            build_command = module.BuildRules[source.Ext].CommandList[0]\n                            build_command_variables = re.findall('\\\\$\\\\((.*?)\\\\)', build_command)\n                            for var in build_command_variables:\n                                var_tokens = var.split('_')\n                                var_main = var_tokens[0]\n                                if len(var_tokens) == 1:\n                                    var_value = module.BuildOption[var_main]['PATH']\n                                else:\n                                    var_value = module.BuildOption[var_main][var_tokens[1]]\n                                build_command = build_command.replace(f'$({var})', var_value)\n                                include_files = f' {inc_flag}'.join(module.IncludePathList)\n                                build_command = build_command.replace('${src}', include_files)\n                                build_command = build_command.replace('${dst}', module.OutputDir)\n                            compile_command['command'] = re.sub('\\\\$\\\\(.*?\\\\)', '', build_command)\n                            compile_commands.append(compile_command)\n            compile_info_folder = Path(Wa.BuildDir).joinpath('CompileInfo')\n            compile_info_folder.mkdir(exist_ok=True)\n            compile_commands.sort(key=lambda x: x['file'])\n            SaveFileOnChange(compile_info_folder.joinpath(f'compile_commands.json'), json.dumps(compile_commands, indent=2), False)\n            SaveFileOnChange(compile_info_folder.joinpath(f'cscope.files'), '\\n'.join(sorted(used_files)), False)\n            module_report.sort(key=lambda x: x['Path'])\n            SaveFileOnChange(compile_info_folder.joinpath(f'module_report.json'), json.dumps(module_report, indent=2), False)\n    except:\n        EdkLogger.error('BuildReport', CODE_ERROR, 'Unknown fatal error when generating build report compile information', ExtraData=self.ReportFile, RaiseError=False)\n        EdkLogger.quiet('(Python %s on %s\\n%s)' % (platform.python_version(), sys.platform, traceback.format_exc()))",
            "def GenerateCompileInfo(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        compile_commands = []\n        used_files = set()\n        module_report = []\n        for (Wa, MaList) in self.ReportList:\n            for file_path in Wa._GetMetaFiles(Wa.BuildTarget, Wa.ToolChain):\n                used_files.add(file_path)\n            for autoGen in Wa.AutoGenObjectList:\n                for module in autoGen.LibraryAutoGenList + autoGen.ModuleAutoGenList:\n                    used_files.add(module.MetaFile.Path)\n                    module_report_data = {}\n                    module_report_data['Name'] = module.Name\n                    module_report_data['Arch'] = module.Arch\n                    module_report_data['Path'] = module.MetaFile.Path\n                    module_report_data['Guid'] = module.Guid\n                    module_report_data['BuildType'] = module.BuildType\n                    module_report_data['IsLibrary'] = module.IsLibrary\n                    module_report_data['SourceDir'] = module.SourceDir\n                    module_report_data['Files'] = []\n                    module_report_data['LibraryClass'] = module.Module.LibraryClass\n                    module_report_data['ModuleEntryPointList'] = module.Module.ModuleEntryPointList\n                    module_report_data['ConstructorList'] = module.Module.ConstructorList\n                    module_report_data['DestructorList'] = module.Module.DestructorList\n                    for data_file in module.SourceFileList:\n                        module_report_data['Files'].append({'Name': data_file.Name, 'Path': data_file.Path})\n                    module_report_data['Libraries'] = []\n                    for data_library in module.LibraryAutoGenList:\n                        module_report_data['Libraries'].append({'Path': data_library.MetaFile.Path})\n                    module_report_data['Packages'] = []\n                    for data_package in module.PackageList:\n                        module_report_data['Packages'].append({'Path': data_package.MetaFile.Path, 'Includes': []})\n                        for data_package_include in data_package.Includes:\n                            module_report_data['Packages'][-1]['Includes'].append(data_package_include.Path)\n                    module_report_data['PPI'] = []\n                    for data_ppi in module.PpiList.keys():\n                        module_report_data['PPI'].append({'Name': data_ppi, 'Guid': module.PpiList[data_ppi]})\n                    module_report_data['Protocol'] = []\n                    for data_protocol in module.ProtocolList.keys():\n                        module_report_data['Protocol'].append({'Name': data_protocol, 'Guid': module.ProtocolList[data_protocol]})\n                    module_report_data['Pcd'] = []\n                    for data_pcd in module.LibraryPcdList:\n                        module_report_data['Pcd'].append({'Space': data_pcd.TokenSpaceGuidCName, 'Name': data_pcd.TokenCName, 'Value': data_pcd.TokenValue, 'Guid': data_pcd.TokenSpaceGuidValue, 'DatumType': data_pcd.DatumType, 'Type': data_pcd.Type, 'DefaultValue': data_pcd.DefaultValue})\n                    module_report.append(module_report_data)\n                    includes_autogen = IncludesAutoGen(module.MakeFileDir, module)\n                    for dep in includes_autogen.DepsCollection:\n                        used_files.add(dep)\n                    inc_flag = '-I'\n                    if module.BuildRuleFamily == TAB_COMPILER_MSFT:\n                        inc_flag = '/I'\n                    for source in module.SourceFileList:\n                        used_files.add(source.Path)\n                        compile_command = {}\n                        if source.Ext in ['.c', '.cc', '.cpp']:\n                            compile_command['file'] = source.Path\n                            compile_command['directory'] = source.Dir\n                            build_command = module.BuildRules[source.Ext].CommandList[0]\n                            build_command_variables = re.findall('\\\\$\\\\((.*?)\\\\)', build_command)\n                            for var in build_command_variables:\n                                var_tokens = var.split('_')\n                                var_main = var_tokens[0]\n                                if len(var_tokens) == 1:\n                                    var_value = module.BuildOption[var_main]['PATH']\n                                else:\n                                    var_value = module.BuildOption[var_main][var_tokens[1]]\n                                build_command = build_command.replace(f'$({var})', var_value)\n                                include_files = f' {inc_flag}'.join(module.IncludePathList)\n                                build_command = build_command.replace('${src}', include_files)\n                                build_command = build_command.replace('${dst}', module.OutputDir)\n                            compile_command['command'] = re.sub('\\\\$\\\\(.*?\\\\)', '', build_command)\n                            compile_commands.append(compile_command)\n            compile_info_folder = Path(Wa.BuildDir).joinpath('CompileInfo')\n            compile_info_folder.mkdir(exist_ok=True)\n            compile_commands.sort(key=lambda x: x['file'])\n            SaveFileOnChange(compile_info_folder.joinpath(f'compile_commands.json'), json.dumps(compile_commands, indent=2), False)\n            SaveFileOnChange(compile_info_folder.joinpath(f'cscope.files'), '\\n'.join(sorted(used_files)), False)\n            module_report.sort(key=lambda x: x['Path'])\n            SaveFileOnChange(compile_info_folder.joinpath(f'module_report.json'), json.dumps(module_report, indent=2), False)\n    except:\n        EdkLogger.error('BuildReport', CODE_ERROR, 'Unknown fatal error when generating build report compile information', ExtraData=self.ReportFile, RaiseError=False)\n        EdkLogger.quiet('(Python %s on %s\\n%s)' % (platform.python_version(), sys.platform, traceback.format_exc()))"
        ]
    }
]