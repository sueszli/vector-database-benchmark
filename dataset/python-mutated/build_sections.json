[
    {
        "func_name": "converts_to_sections",
        "original": "def converts_to_sections(faults, f_lengths, f_areas, path, rupture_mesh_spacing, sectionning_param):\n    f_for_sherifs = {}\n    f_lons = []\n    f_lats = []\n    f_id = -1\n    sections_lengths_tot = []\n    sections_areas_tot = []\n    id_sections_fault = []\n    distance_resolution = sectionning_param['distance_resolution']\n    if not os.path.exists(path + '/qgis'):\n        os.makedirs(path + '/qgis')\n    file_section_tips = open(path + '/qgis/sect_tips.csv', 'w')\n    file_section_tips.write('lon,lat\\n')\n    error_msg = 'A fault is too small for the discretization. Min length :'\n    error_msg += str(round(min(f_lengths), 3))\n    error_msg += ' km.'\n    assert min(f_lengths) > 2.0 * rupture_mesh_spacing, error_msg\n    nb_faults = len(faults)\n    for fi in range(nb_faults):\n        lons_tot = [i[0] for i in faults[fi]['geometry']['coordinates']]\n        lats_tot = [i[1] for i in faults[fi]['geometry']['coordinates']]\n        id_sections_fault_i = []\n        if len(lons_tot) < f_lengths[fi] / distance_resolution:\n            (inter_lon_i, inter_lat_i) = ([], [])\n            for i in range(len(lons_tot) - 1):\n                di = distance(lons_tot[i], lats_tot[i], lons_tot[i + 1], lats_tot[i + 1])\n                nb_extra_pts = int(di / distance_resolution)\n                if i == len(lons_tot) - 2:\n                    if nb_extra_pts > 1:\n                        inter_lon_i += list(np.linspace(lons_tot[i], lons_tot[i + 1], nb_extra_pts))\n                        inter_lat_i += list(np.linspace(lats_tot[i], lats_tot[i + 1], nb_extra_pts))\n                    else:\n                        inter_lon_i += [lons_tot[i], lons_tot[i + 1]]\n                        inter_lat_i += [lats_tot[i], lats_tot[i + 1]]\n                elif nb_extra_pts > 1:\n                    inter_lon_i += list(np.linspace(lons_tot[i], lons_tot[i + 1], nb_extra_pts))[:-1]\n                    inter_lat_i += list(np.linspace(lats_tot[i], lats_tot[i + 1], nb_extra_pts))[:-1]\n                else:\n                    inter_lon_i += [lons_tot[i], lons_tot[i + 1]][:-1]\n                    inter_lat_i += [lats_tot[i], lats_tot[i + 1]][:-1]\n            (lons_tot, lats_tot) = (inter_lon_i, inter_lat_i)\n        f_name = str(fi)\n        f_id += 1\n        try:\n            oiler_name = faults[fi]['properties']['name']\n            oiler_fid = faults[fi]['properties']['fid']\n        except:\n            oiler_name = None\n            oiler_fid = f_id\n        f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons_tot, 'lats': lats_tot, 'oiler_id': oiler_fid, 'oiler_name': oiler_name, 'oiler_fid': oiler_fid, 'length': f_lengths[fi]}})\n        file_section_tips.write(str(lons_tot[0]) + ',' + str(lats_tot[0]) + '\\n')\n        file_section_tips.write(str(lons_tot[-1]) + ',' + str(lats_tot[-1]) + '\\n')\n        sections_lengths_tot.append(f_lengths[fi])\n        sections_areas_tot.append(f_areas[fi])\n        id_sections_fault_i.append(f_id)\n        id_sections_fault.append(id_sections_fault_i)\n    return (f_for_sherifs, id_sections_fault, sections_areas_tot, sections_lengths_tot)",
        "mutated": [
            "def converts_to_sections(faults, f_lengths, f_areas, path, rupture_mesh_spacing, sectionning_param):\n    if False:\n        i = 10\n    f_for_sherifs = {}\n    f_lons = []\n    f_lats = []\n    f_id = -1\n    sections_lengths_tot = []\n    sections_areas_tot = []\n    id_sections_fault = []\n    distance_resolution = sectionning_param['distance_resolution']\n    if not os.path.exists(path + '/qgis'):\n        os.makedirs(path + '/qgis')\n    file_section_tips = open(path + '/qgis/sect_tips.csv', 'w')\n    file_section_tips.write('lon,lat\\n')\n    error_msg = 'A fault is too small for the discretization. Min length :'\n    error_msg += str(round(min(f_lengths), 3))\n    error_msg += ' km.'\n    assert min(f_lengths) > 2.0 * rupture_mesh_spacing, error_msg\n    nb_faults = len(faults)\n    for fi in range(nb_faults):\n        lons_tot = [i[0] for i in faults[fi]['geometry']['coordinates']]\n        lats_tot = [i[1] for i in faults[fi]['geometry']['coordinates']]\n        id_sections_fault_i = []\n        if len(lons_tot) < f_lengths[fi] / distance_resolution:\n            (inter_lon_i, inter_lat_i) = ([], [])\n            for i in range(len(lons_tot) - 1):\n                di = distance(lons_tot[i], lats_tot[i], lons_tot[i + 1], lats_tot[i + 1])\n                nb_extra_pts = int(di / distance_resolution)\n                if i == len(lons_tot) - 2:\n                    if nb_extra_pts > 1:\n                        inter_lon_i += list(np.linspace(lons_tot[i], lons_tot[i + 1], nb_extra_pts))\n                        inter_lat_i += list(np.linspace(lats_tot[i], lats_tot[i + 1], nb_extra_pts))\n                    else:\n                        inter_lon_i += [lons_tot[i], lons_tot[i + 1]]\n                        inter_lat_i += [lats_tot[i], lats_tot[i + 1]]\n                elif nb_extra_pts > 1:\n                    inter_lon_i += list(np.linspace(lons_tot[i], lons_tot[i + 1], nb_extra_pts))[:-1]\n                    inter_lat_i += list(np.linspace(lats_tot[i], lats_tot[i + 1], nb_extra_pts))[:-1]\n                else:\n                    inter_lon_i += [lons_tot[i], lons_tot[i + 1]][:-1]\n                    inter_lat_i += [lats_tot[i], lats_tot[i + 1]][:-1]\n            (lons_tot, lats_tot) = (inter_lon_i, inter_lat_i)\n        f_name = str(fi)\n        f_id += 1\n        try:\n            oiler_name = faults[fi]['properties']['name']\n            oiler_fid = faults[fi]['properties']['fid']\n        except:\n            oiler_name = None\n            oiler_fid = f_id\n        f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons_tot, 'lats': lats_tot, 'oiler_id': oiler_fid, 'oiler_name': oiler_name, 'oiler_fid': oiler_fid, 'length': f_lengths[fi]}})\n        file_section_tips.write(str(lons_tot[0]) + ',' + str(lats_tot[0]) + '\\n')\n        file_section_tips.write(str(lons_tot[-1]) + ',' + str(lats_tot[-1]) + '\\n')\n        sections_lengths_tot.append(f_lengths[fi])\n        sections_areas_tot.append(f_areas[fi])\n        id_sections_fault_i.append(f_id)\n        id_sections_fault.append(id_sections_fault_i)\n    return (f_for_sherifs, id_sections_fault, sections_areas_tot, sections_lengths_tot)",
            "def converts_to_sections(faults, f_lengths, f_areas, path, rupture_mesh_spacing, sectionning_param):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    f_for_sherifs = {}\n    f_lons = []\n    f_lats = []\n    f_id = -1\n    sections_lengths_tot = []\n    sections_areas_tot = []\n    id_sections_fault = []\n    distance_resolution = sectionning_param['distance_resolution']\n    if not os.path.exists(path + '/qgis'):\n        os.makedirs(path + '/qgis')\n    file_section_tips = open(path + '/qgis/sect_tips.csv', 'w')\n    file_section_tips.write('lon,lat\\n')\n    error_msg = 'A fault is too small for the discretization. Min length :'\n    error_msg += str(round(min(f_lengths), 3))\n    error_msg += ' km.'\n    assert min(f_lengths) > 2.0 * rupture_mesh_spacing, error_msg\n    nb_faults = len(faults)\n    for fi in range(nb_faults):\n        lons_tot = [i[0] for i in faults[fi]['geometry']['coordinates']]\n        lats_tot = [i[1] for i in faults[fi]['geometry']['coordinates']]\n        id_sections_fault_i = []\n        if len(lons_tot) < f_lengths[fi] / distance_resolution:\n            (inter_lon_i, inter_lat_i) = ([], [])\n            for i in range(len(lons_tot) - 1):\n                di = distance(lons_tot[i], lats_tot[i], lons_tot[i + 1], lats_tot[i + 1])\n                nb_extra_pts = int(di / distance_resolution)\n                if i == len(lons_tot) - 2:\n                    if nb_extra_pts > 1:\n                        inter_lon_i += list(np.linspace(lons_tot[i], lons_tot[i + 1], nb_extra_pts))\n                        inter_lat_i += list(np.linspace(lats_tot[i], lats_tot[i + 1], nb_extra_pts))\n                    else:\n                        inter_lon_i += [lons_tot[i], lons_tot[i + 1]]\n                        inter_lat_i += [lats_tot[i], lats_tot[i + 1]]\n                elif nb_extra_pts > 1:\n                    inter_lon_i += list(np.linspace(lons_tot[i], lons_tot[i + 1], nb_extra_pts))[:-1]\n                    inter_lat_i += list(np.linspace(lats_tot[i], lats_tot[i + 1], nb_extra_pts))[:-1]\n                else:\n                    inter_lon_i += [lons_tot[i], lons_tot[i + 1]][:-1]\n                    inter_lat_i += [lats_tot[i], lats_tot[i + 1]][:-1]\n            (lons_tot, lats_tot) = (inter_lon_i, inter_lat_i)\n        f_name = str(fi)\n        f_id += 1\n        try:\n            oiler_name = faults[fi]['properties']['name']\n            oiler_fid = faults[fi]['properties']['fid']\n        except:\n            oiler_name = None\n            oiler_fid = f_id\n        f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons_tot, 'lats': lats_tot, 'oiler_id': oiler_fid, 'oiler_name': oiler_name, 'oiler_fid': oiler_fid, 'length': f_lengths[fi]}})\n        file_section_tips.write(str(lons_tot[0]) + ',' + str(lats_tot[0]) + '\\n')\n        file_section_tips.write(str(lons_tot[-1]) + ',' + str(lats_tot[-1]) + '\\n')\n        sections_lengths_tot.append(f_lengths[fi])\n        sections_areas_tot.append(f_areas[fi])\n        id_sections_fault_i.append(f_id)\n        id_sections_fault.append(id_sections_fault_i)\n    return (f_for_sherifs, id_sections_fault, sections_areas_tot, sections_lengths_tot)",
            "def converts_to_sections(faults, f_lengths, f_areas, path, rupture_mesh_spacing, sectionning_param):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    f_for_sherifs = {}\n    f_lons = []\n    f_lats = []\n    f_id = -1\n    sections_lengths_tot = []\n    sections_areas_tot = []\n    id_sections_fault = []\n    distance_resolution = sectionning_param['distance_resolution']\n    if not os.path.exists(path + '/qgis'):\n        os.makedirs(path + '/qgis')\n    file_section_tips = open(path + '/qgis/sect_tips.csv', 'w')\n    file_section_tips.write('lon,lat\\n')\n    error_msg = 'A fault is too small for the discretization. Min length :'\n    error_msg += str(round(min(f_lengths), 3))\n    error_msg += ' km.'\n    assert min(f_lengths) > 2.0 * rupture_mesh_spacing, error_msg\n    nb_faults = len(faults)\n    for fi in range(nb_faults):\n        lons_tot = [i[0] for i in faults[fi]['geometry']['coordinates']]\n        lats_tot = [i[1] for i in faults[fi]['geometry']['coordinates']]\n        id_sections_fault_i = []\n        if len(lons_tot) < f_lengths[fi] / distance_resolution:\n            (inter_lon_i, inter_lat_i) = ([], [])\n            for i in range(len(lons_tot) - 1):\n                di = distance(lons_tot[i], lats_tot[i], lons_tot[i + 1], lats_tot[i + 1])\n                nb_extra_pts = int(di / distance_resolution)\n                if i == len(lons_tot) - 2:\n                    if nb_extra_pts > 1:\n                        inter_lon_i += list(np.linspace(lons_tot[i], lons_tot[i + 1], nb_extra_pts))\n                        inter_lat_i += list(np.linspace(lats_tot[i], lats_tot[i + 1], nb_extra_pts))\n                    else:\n                        inter_lon_i += [lons_tot[i], lons_tot[i + 1]]\n                        inter_lat_i += [lats_tot[i], lats_tot[i + 1]]\n                elif nb_extra_pts > 1:\n                    inter_lon_i += list(np.linspace(lons_tot[i], lons_tot[i + 1], nb_extra_pts))[:-1]\n                    inter_lat_i += list(np.linspace(lats_tot[i], lats_tot[i + 1], nb_extra_pts))[:-1]\n                else:\n                    inter_lon_i += [lons_tot[i], lons_tot[i + 1]][:-1]\n                    inter_lat_i += [lats_tot[i], lats_tot[i + 1]][:-1]\n            (lons_tot, lats_tot) = (inter_lon_i, inter_lat_i)\n        f_name = str(fi)\n        f_id += 1\n        try:\n            oiler_name = faults[fi]['properties']['name']\n            oiler_fid = faults[fi]['properties']['fid']\n        except:\n            oiler_name = None\n            oiler_fid = f_id\n        f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons_tot, 'lats': lats_tot, 'oiler_id': oiler_fid, 'oiler_name': oiler_name, 'oiler_fid': oiler_fid, 'length': f_lengths[fi]}})\n        file_section_tips.write(str(lons_tot[0]) + ',' + str(lats_tot[0]) + '\\n')\n        file_section_tips.write(str(lons_tot[-1]) + ',' + str(lats_tot[-1]) + '\\n')\n        sections_lengths_tot.append(f_lengths[fi])\n        sections_areas_tot.append(f_areas[fi])\n        id_sections_fault_i.append(f_id)\n        id_sections_fault.append(id_sections_fault_i)\n    return (f_for_sherifs, id_sections_fault, sections_areas_tot, sections_lengths_tot)",
            "def converts_to_sections(faults, f_lengths, f_areas, path, rupture_mesh_spacing, sectionning_param):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    f_for_sherifs = {}\n    f_lons = []\n    f_lats = []\n    f_id = -1\n    sections_lengths_tot = []\n    sections_areas_tot = []\n    id_sections_fault = []\n    distance_resolution = sectionning_param['distance_resolution']\n    if not os.path.exists(path + '/qgis'):\n        os.makedirs(path + '/qgis')\n    file_section_tips = open(path + '/qgis/sect_tips.csv', 'w')\n    file_section_tips.write('lon,lat\\n')\n    error_msg = 'A fault is too small for the discretization. Min length :'\n    error_msg += str(round(min(f_lengths), 3))\n    error_msg += ' km.'\n    assert min(f_lengths) > 2.0 * rupture_mesh_spacing, error_msg\n    nb_faults = len(faults)\n    for fi in range(nb_faults):\n        lons_tot = [i[0] for i in faults[fi]['geometry']['coordinates']]\n        lats_tot = [i[1] for i in faults[fi]['geometry']['coordinates']]\n        id_sections_fault_i = []\n        if len(lons_tot) < f_lengths[fi] / distance_resolution:\n            (inter_lon_i, inter_lat_i) = ([], [])\n            for i in range(len(lons_tot) - 1):\n                di = distance(lons_tot[i], lats_tot[i], lons_tot[i + 1], lats_tot[i + 1])\n                nb_extra_pts = int(di / distance_resolution)\n                if i == len(lons_tot) - 2:\n                    if nb_extra_pts > 1:\n                        inter_lon_i += list(np.linspace(lons_tot[i], lons_tot[i + 1], nb_extra_pts))\n                        inter_lat_i += list(np.linspace(lats_tot[i], lats_tot[i + 1], nb_extra_pts))\n                    else:\n                        inter_lon_i += [lons_tot[i], lons_tot[i + 1]]\n                        inter_lat_i += [lats_tot[i], lats_tot[i + 1]]\n                elif nb_extra_pts > 1:\n                    inter_lon_i += list(np.linspace(lons_tot[i], lons_tot[i + 1], nb_extra_pts))[:-1]\n                    inter_lat_i += list(np.linspace(lats_tot[i], lats_tot[i + 1], nb_extra_pts))[:-1]\n                else:\n                    inter_lon_i += [lons_tot[i], lons_tot[i + 1]][:-1]\n                    inter_lat_i += [lats_tot[i], lats_tot[i + 1]][:-1]\n            (lons_tot, lats_tot) = (inter_lon_i, inter_lat_i)\n        f_name = str(fi)\n        f_id += 1\n        try:\n            oiler_name = faults[fi]['properties']['name']\n            oiler_fid = faults[fi]['properties']['fid']\n        except:\n            oiler_name = None\n            oiler_fid = f_id\n        f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons_tot, 'lats': lats_tot, 'oiler_id': oiler_fid, 'oiler_name': oiler_name, 'oiler_fid': oiler_fid, 'length': f_lengths[fi]}})\n        file_section_tips.write(str(lons_tot[0]) + ',' + str(lats_tot[0]) + '\\n')\n        file_section_tips.write(str(lons_tot[-1]) + ',' + str(lats_tot[-1]) + '\\n')\n        sections_lengths_tot.append(f_lengths[fi])\n        sections_areas_tot.append(f_areas[fi])\n        id_sections_fault_i.append(f_id)\n        id_sections_fault.append(id_sections_fault_i)\n    return (f_for_sherifs, id_sections_fault, sections_areas_tot, sections_lengths_tot)",
            "def converts_to_sections(faults, f_lengths, f_areas, path, rupture_mesh_spacing, sectionning_param):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    f_for_sherifs = {}\n    f_lons = []\n    f_lats = []\n    f_id = -1\n    sections_lengths_tot = []\n    sections_areas_tot = []\n    id_sections_fault = []\n    distance_resolution = sectionning_param['distance_resolution']\n    if not os.path.exists(path + '/qgis'):\n        os.makedirs(path + '/qgis')\n    file_section_tips = open(path + '/qgis/sect_tips.csv', 'w')\n    file_section_tips.write('lon,lat\\n')\n    error_msg = 'A fault is too small for the discretization. Min length :'\n    error_msg += str(round(min(f_lengths), 3))\n    error_msg += ' km.'\n    assert min(f_lengths) > 2.0 * rupture_mesh_spacing, error_msg\n    nb_faults = len(faults)\n    for fi in range(nb_faults):\n        lons_tot = [i[0] for i in faults[fi]['geometry']['coordinates']]\n        lats_tot = [i[1] for i in faults[fi]['geometry']['coordinates']]\n        id_sections_fault_i = []\n        if len(lons_tot) < f_lengths[fi] / distance_resolution:\n            (inter_lon_i, inter_lat_i) = ([], [])\n            for i in range(len(lons_tot) - 1):\n                di = distance(lons_tot[i], lats_tot[i], lons_tot[i + 1], lats_tot[i + 1])\n                nb_extra_pts = int(di / distance_resolution)\n                if i == len(lons_tot) - 2:\n                    if nb_extra_pts > 1:\n                        inter_lon_i += list(np.linspace(lons_tot[i], lons_tot[i + 1], nb_extra_pts))\n                        inter_lat_i += list(np.linspace(lats_tot[i], lats_tot[i + 1], nb_extra_pts))\n                    else:\n                        inter_lon_i += [lons_tot[i], lons_tot[i + 1]]\n                        inter_lat_i += [lats_tot[i], lats_tot[i + 1]]\n                elif nb_extra_pts > 1:\n                    inter_lon_i += list(np.linspace(lons_tot[i], lons_tot[i + 1], nb_extra_pts))[:-1]\n                    inter_lat_i += list(np.linspace(lats_tot[i], lats_tot[i + 1], nb_extra_pts))[:-1]\n                else:\n                    inter_lon_i += [lons_tot[i], lons_tot[i + 1]][:-1]\n                    inter_lat_i += [lats_tot[i], lats_tot[i + 1]][:-1]\n            (lons_tot, lats_tot) = (inter_lon_i, inter_lat_i)\n        f_name = str(fi)\n        f_id += 1\n        try:\n            oiler_name = faults[fi]['properties']['name']\n            oiler_fid = faults[fi]['properties']['fid']\n        except:\n            oiler_name = None\n            oiler_fid = f_id\n        f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons_tot, 'lats': lats_tot, 'oiler_id': oiler_fid, 'oiler_name': oiler_name, 'oiler_fid': oiler_fid, 'length': f_lengths[fi]}})\n        file_section_tips.write(str(lons_tot[0]) + ',' + str(lats_tot[0]) + '\\n')\n        file_section_tips.write(str(lons_tot[-1]) + ',' + str(lats_tot[-1]) + '\\n')\n        sections_lengths_tot.append(f_lengths[fi])\n        sections_areas_tot.append(f_areas[fi])\n        id_sections_fault_i.append(f_id)\n        id_sections_fault.append(id_sections_fault_i)\n    return (f_for_sherifs, id_sections_fault, sections_areas_tot, sections_lengths_tot)"
        ]
    },
    {
        "func_name": "cut_faults",
        "original": "def cut_faults(faults, f_lengths, f_areas, path, rupture_mesh_spacing, sectionning_param):\n    f_for_sherifs = {}\n    f_lons = []\n    f_lats = []\n    f_id = -1\n    sections_lengths_tot = []\n    sections_areas_tot = []\n    id_sections_fault = []\n    max_section_length = sectionning_param['max_section_length']\n    max_num_sections = sectionning_param['max_num_sections']\n    distance_resolution = sectionning_param['distance_resolution']\n    if not os.path.exists(path + '/qgis'):\n        os.makedirs(path + '/qgis')\n    file_section_tips = open(path + '/qgis/sect_tips.csv', 'w')\n    file_section_tips.write('lon,lat\\n')\n    error_msg = 'A fault is too small for the discretization. Min length :'\n    error_msg += str(round(min(f_lengths), 3))\n    error_msg += ' km.'\n    assert min(f_lengths) > 2.0 * rupture_mesh_spacing, error_msg\n    nb_faults = len(faults)\n    for fi in range(nb_faults):\n        lons_tot = [i[0] for i in faults[fi]['geometry']['coordinates']]\n        lats_tot = [i[1] for i in faults[fi]['geometry']['coordinates']]\n        id_sections_fault_i = []\n        if len(lons_tot) < f_lengths[fi] / distance_resolution:\n            (inter_lon_i, inter_lat_i) = ([], [])\n            for i in range(len(lons_tot) - 1):\n                di = distance(lons_tot[i], lats_tot[i], lons_tot[i + 1], lats_tot[i + 1])\n                nb_extra_pts = int(di / distance_resolution)\n                if i == len(lons_tot) - 2:\n                    if nb_extra_pts > 1:\n                        inter_lon_i += list(np.linspace(lons_tot[i], lons_tot[i + 1], nb_extra_pts))\n                        inter_lat_i += list(np.linspace(lats_tot[i], lats_tot[i + 1], nb_extra_pts))\n                    else:\n                        inter_lon_i += [lons_tot[i], lons_tot[i + 1]]\n                        inter_lat_i += [lats_tot[i], lats_tot[i + 1]]\n                elif nb_extra_pts > 1:\n                    inter_lon_i += list(np.linspace(lons_tot[i], lons_tot[i + 1], nb_extra_pts))[:-1]\n                    inter_lat_i += list(np.linspace(lats_tot[i], lats_tot[i + 1], nb_extra_pts))[:-1]\n                else:\n                    inter_lon_i += [lons_tot[i], lons_tot[i + 1]][:-1]\n                    inter_lat_i += [lats_tot[i], lats_tot[i + 1]][:-1]\n            (lons_tot, lats_tot) = (inter_lon_i, inter_lat_i)\n        if f_lengths[fi] < max_section_length:\n            f_name = str(fi)\n            f_id += 1\n            f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons_tot, 'lats': lats_tot, 'oiler_id': fi, 'oiler_name': faults[fi]['properties']['name'], 'oiler_fid': faults[fi]['properties']['fid'], 'length': f_lengths[fi]}})\n            file_section_tips.write(str(lons_tot[0]) + ',' + str(lats_tot[0]) + '\\n')\n            file_section_tips.write(str(lons_tot[-1]) + ',' + str(lats_tot[-1]) + '\\n')\n            sections_lengths_tot.append(f_lengths[fi])\n            sections_areas_tot.append(f_areas[fi])\n            id_sections_fault_i.append(f_id)\n        else:\n            dists = []\n            for i in range(len(lons_tot) - 1):\n                dists.append(distance(lons_tot[i], lats_tot[i], lons_tot[i + 1], lats_tot[i + 1]))\n            if f_lengths[fi] < max_section_length * max_num_sections:\n                if max(dists) > max_section_length:\n                    section_lenght = max(dists)\n                    nb_sections = int(round(f_lengths[fi] / section_lenght))\n                else:\n                    nb_sections = 1\n                    section_lenght = f_lengths[fi] / float(nb_sections)\n                    while section_lenght > max_section_length:\n                        nb_sections += 1\n                        section_lenght = f_lengths[fi] / float(nb_sections)\n            elif max(dists) > f_lengths[fi] / (max_num_sections - 1):\n                nb_sections = max_num_sections - 1\n            else:\n                nb_sections = max_num_sections\n            if nb_sections != 1:\n                av_section_len = f_lengths[fi] / float(nb_sections)\n                index_0 = 0\n                for cut in range(nb_sections - 1):\n                    dist = 0\n                    index_cut = 0 + index_0\n                    while dist < av_section_len:\n                        try:\n                            dist += distance(lons_tot[index_cut], lats_tot[index_cut], lons_tot[index_cut + 1], lats_tot[index_cut + 1])\n                            index_cut += 1\n                            do_last = True\n                            if dist > av_section_len * 0.3 and dist > 2.0 * rupture_mesh_spacing:\n                                az1 = calculate_initial_compass_bearing([lons_tot[index_cut - 1], lats_tot[index_cut - 1]], [lons_tot[index_cut], lats_tot[index_cut]])\n                                az2 = calculate_initial_compass_bearing([lons_tot[index_cut], lats_tot[index_cut]], [lons_tot[index_cut + 1], lats_tot[index_cut + 1]])\n                                if abs(az1 - az2) % 360 > 60.0:\n                                    dist = 100000.0\n                        except IndexError:\n                            index_cut = len(lons_tot) - 1\n                            do_last = False\n                            dist = 100000.0\n                    lons = lons_tot[index_0:index_cut + 1]\n                    lats = lats_tot[index_0:index_cut + 1]\n                    length = 0.0\n                    for i in range(len(lons) - 1):\n                        length += distance(lons[i], lats[i], lons[i + 1], lats[i + 1])\n                    if 'lsd' in faults[fi]['properties'].keys():\n                        width = (faults[fi]['properties']['lsd'] - faults[fi]['properties']['usd']) / sin(radians(faults[fi]['properties']['dip']))\n                    else:\n                        width = (faults[fi]['properties']['lo_s_d'] - faults[fi]['properties']['up_s_d']) / sin(radians(faults[fi]['properties']['dip']))\n                    area = length * width\n                    f_name = str(fi) + '_' + str(cut)\n                    f_id += 1\n                    f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons, 'lats': lats, 'oiler_id': fi, 'oiler_name': faults[fi]['properties']['name'], 'oiler_fid': faults[fi]['properties']['fid'], 'length': length}})\n                    file_section_tips.write(str(lons[0]) + ',' + str(lats[0]) + '\\n')\n                    file_section_tips.write(str(lons[-1]) + ',' + str(lats[-1]) + '\\n')\n                    index_0 = index_cut\n                    sections_lengths_tot.append(length)\n                    sections_areas_tot.append(area)\n                    id_sections_fault_i.append(f_id)\n                if do_last == True:\n                    lons = lons_tot[index_cut:]\n                    lats = lats_tot[index_cut:]\n                    f_name = str(fi) + '_' + str(cut)\n                    f_id += 1\n                    length = fault_length(lons, lats)\n                    if 'lsd' in faults[fi]['properties'].keys():\n                        width = (faults[fi]['properties']['lsd'] - faults[fi]['properties']['usd']) / sin(radians(faults[fi]['properties']['dip']))\n                    else:\n                        width = (faults[fi]['properties']['lo_s_d'] - faults[fi]['properties']['up_s_d']) / sin(radians(faults[fi]['properties']['dip']))\n                    error_msg = 'A fault is too thin for the discretization. Fault name :'\n                    error_msg += str(faults[fi]['properties']['fid'])\n                    error_msg += ' width : '\n                    error_msg += str(round(width, 2))\n                    error_msg += ' km.'\n                    assert width > 2.0 * rupture_mesh_spacing, error_msg\n                    area = length * width\n                    f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons, 'lats': lats, 'oiler_id': fi, 'oiler_name': faults[fi]['properties']['name'], 'oiler_fid': faults[fi]['properties']['fid'], 'length': length}})\n                    file_section_tips.write(str(lons[0]) + ',' + str(lats[0]) + '\\n')\n                    file_section_tips.write(str(lons[-1]) + ',' + str(lats[-1]) + '\\n')\n                    sections_lengths_tot.append(length)\n                    sections_areas_tot.append(area)\n                    id_sections_fault_i.append(f_id)\n            else:\n                f_name = str(fi)\n                f_id += 1\n                f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons_tot, 'lats': lats_tot, 'oiler_id': fi, 'oiler_name': faults[fi]['properties']['name'], 'oiler_fid': faults[fi]['properties']['fid'], 'length': f_lengths[fi]}})\n                file_section_tips.write(str(lons_tot[0]) + ',' + str(lats_tot[0]) + '\\n')\n                file_section_tips.write(str(lons_tot[-1]) + ',' + str(lats_tot[-1]) + '\\n')\n                sections_lengths_tot.append(f_lengths[fi])\n                sections_areas_tot.append(f_areas[fi])\n                id_sections_fault_i.append(f_id)\n            if round(sum(sections_lengths_tot[-nb_sections:])) != round(f_lengths[fi]):\n                print('#####\\n fault', fi)\n                print('Failing!')\n                print(round(sum(sections_lengths_tot[-nb_sections:])), round(f_lengths[fi]), 'missing', round(-sum(sections_lengths_tot[-nb_sections:])) + round(f_lengths[fi]))\n                print('sections:', nb_sections)\n        id_sections_fault.append(id_sections_fault_i)\n    plt_fig = False\n    if plt_fig == True:\n        plt.hist(sections_lengths_tot)\n        plt.ylabel('nb of sections')\n        plt.xlabel('Length of the section (km)')\n        plt.show()\n    file_section_tips.close()\n    print('And a total of ', len(f_for_sherifs), ' sections.')\n    if round(sum(sections_lengths_tot)) != round(sum(f_lengths)):\n        print('!!!!!\\n ERROR! There are ', round(sum(f_lengths) - sum(sections_lengths_tot)), ' km of faults missing.')\n    return (f_for_sherifs, id_sections_fault, sections_areas_tot, sections_lengths_tot)",
        "mutated": [
            "def cut_faults(faults, f_lengths, f_areas, path, rupture_mesh_spacing, sectionning_param):\n    if False:\n        i = 10\n    f_for_sherifs = {}\n    f_lons = []\n    f_lats = []\n    f_id = -1\n    sections_lengths_tot = []\n    sections_areas_tot = []\n    id_sections_fault = []\n    max_section_length = sectionning_param['max_section_length']\n    max_num_sections = sectionning_param['max_num_sections']\n    distance_resolution = sectionning_param['distance_resolution']\n    if not os.path.exists(path + '/qgis'):\n        os.makedirs(path + '/qgis')\n    file_section_tips = open(path + '/qgis/sect_tips.csv', 'w')\n    file_section_tips.write('lon,lat\\n')\n    error_msg = 'A fault is too small for the discretization. Min length :'\n    error_msg += str(round(min(f_lengths), 3))\n    error_msg += ' km.'\n    assert min(f_lengths) > 2.0 * rupture_mesh_spacing, error_msg\n    nb_faults = len(faults)\n    for fi in range(nb_faults):\n        lons_tot = [i[0] for i in faults[fi]['geometry']['coordinates']]\n        lats_tot = [i[1] for i in faults[fi]['geometry']['coordinates']]\n        id_sections_fault_i = []\n        if len(lons_tot) < f_lengths[fi] / distance_resolution:\n            (inter_lon_i, inter_lat_i) = ([], [])\n            for i in range(len(lons_tot) - 1):\n                di = distance(lons_tot[i], lats_tot[i], lons_tot[i + 1], lats_tot[i + 1])\n                nb_extra_pts = int(di / distance_resolution)\n                if i == len(lons_tot) - 2:\n                    if nb_extra_pts > 1:\n                        inter_lon_i += list(np.linspace(lons_tot[i], lons_tot[i + 1], nb_extra_pts))\n                        inter_lat_i += list(np.linspace(lats_tot[i], lats_tot[i + 1], nb_extra_pts))\n                    else:\n                        inter_lon_i += [lons_tot[i], lons_tot[i + 1]]\n                        inter_lat_i += [lats_tot[i], lats_tot[i + 1]]\n                elif nb_extra_pts > 1:\n                    inter_lon_i += list(np.linspace(lons_tot[i], lons_tot[i + 1], nb_extra_pts))[:-1]\n                    inter_lat_i += list(np.linspace(lats_tot[i], lats_tot[i + 1], nb_extra_pts))[:-1]\n                else:\n                    inter_lon_i += [lons_tot[i], lons_tot[i + 1]][:-1]\n                    inter_lat_i += [lats_tot[i], lats_tot[i + 1]][:-1]\n            (lons_tot, lats_tot) = (inter_lon_i, inter_lat_i)\n        if f_lengths[fi] < max_section_length:\n            f_name = str(fi)\n            f_id += 1\n            f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons_tot, 'lats': lats_tot, 'oiler_id': fi, 'oiler_name': faults[fi]['properties']['name'], 'oiler_fid': faults[fi]['properties']['fid'], 'length': f_lengths[fi]}})\n            file_section_tips.write(str(lons_tot[0]) + ',' + str(lats_tot[0]) + '\\n')\n            file_section_tips.write(str(lons_tot[-1]) + ',' + str(lats_tot[-1]) + '\\n')\n            sections_lengths_tot.append(f_lengths[fi])\n            sections_areas_tot.append(f_areas[fi])\n            id_sections_fault_i.append(f_id)\n        else:\n            dists = []\n            for i in range(len(lons_tot) - 1):\n                dists.append(distance(lons_tot[i], lats_tot[i], lons_tot[i + 1], lats_tot[i + 1]))\n            if f_lengths[fi] < max_section_length * max_num_sections:\n                if max(dists) > max_section_length:\n                    section_lenght = max(dists)\n                    nb_sections = int(round(f_lengths[fi] / section_lenght))\n                else:\n                    nb_sections = 1\n                    section_lenght = f_lengths[fi] / float(nb_sections)\n                    while section_lenght > max_section_length:\n                        nb_sections += 1\n                        section_lenght = f_lengths[fi] / float(nb_sections)\n            elif max(dists) > f_lengths[fi] / (max_num_sections - 1):\n                nb_sections = max_num_sections - 1\n            else:\n                nb_sections = max_num_sections\n            if nb_sections != 1:\n                av_section_len = f_lengths[fi] / float(nb_sections)\n                index_0 = 0\n                for cut in range(nb_sections - 1):\n                    dist = 0\n                    index_cut = 0 + index_0\n                    while dist < av_section_len:\n                        try:\n                            dist += distance(lons_tot[index_cut], lats_tot[index_cut], lons_tot[index_cut + 1], lats_tot[index_cut + 1])\n                            index_cut += 1\n                            do_last = True\n                            if dist > av_section_len * 0.3 and dist > 2.0 * rupture_mesh_spacing:\n                                az1 = calculate_initial_compass_bearing([lons_tot[index_cut - 1], lats_tot[index_cut - 1]], [lons_tot[index_cut], lats_tot[index_cut]])\n                                az2 = calculate_initial_compass_bearing([lons_tot[index_cut], lats_tot[index_cut]], [lons_tot[index_cut + 1], lats_tot[index_cut + 1]])\n                                if abs(az1 - az2) % 360 > 60.0:\n                                    dist = 100000.0\n                        except IndexError:\n                            index_cut = len(lons_tot) - 1\n                            do_last = False\n                            dist = 100000.0\n                    lons = lons_tot[index_0:index_cut + 1]\n                    lats = lats_tot[index_0:index_cut + 1]\n                    length = 0.0\n                    for i in range(len(lons) - 1):\n                        length += distance(lons[i], lats[i], lons[i + 1], lats[i + 1])\n                    if 'lsd' in faults[fi]['properties'].keys():\n                        width = (faults[fi]['properties']['lsd'] - faults[fi]['properties']['usd']) / sin(radians(faults[fi]['properties']['dip']))\n                    else:\n                        width = (faults[fi]['properties']['lo_s_d'] - faults[fi]['properties']['up_s_d']) / sin(radians(faults[fi]['properties']['dip']))\n                    area = length * width\n                    f_name = str(fi) + '_' + str(cut)\n                    f_id += 1\n                    f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons, 'lats': lats, 'oiler_id': fi, 'oiler_name': faults[fi]['properties']['name'], 'oiler_fid': faults[fi]['properties']['fid'], 'length': length}})\n                    file_section_tips.write(str(lons[0]) + ',' + str(lats[0]) + '\\n')\n                    file_section_tips.write(str(lons[-1]) + ',' + str(lats[-1]) + '\\n')\n                    index_0 = index_cut\n                    sections_lengths_tot.append(length)\n                    sections_areas_tot.append(area)\n                    id_sections_fault_i.append(f_id)\n                if do_last == True:\n                    lons = lons_tot[index_cut:]\n                    lats = lats_tot[index_cut:]\n                    f_name = str(fi) + '_' + str(cut)\n                    f_id += 1\n                    length = fault_length(lons, lats)\n                    if 'lsd' in faults[fi]['properties'].keys():\n                        width = (faults[fi]['properties']['lsd'] - faults[fi]['properties']['usd']) / sin(radians(faults[fi]['properties']['dip']))\n                    else:\n                        width = (faults[fi]['properties']['lo_s_d'] - faults[fi]['properties']['up_s_d']) / sin(radians(faults[fi]['properties']['dip']))\n                    error_msg = 'A fault is too thin for the discretization. Fault name :'\n                    error_msg += str(faults[fi]['properties']['fid'])\n                    error_msg += ' width : '\n                    error_msg += str(round(width, 2))\n                    error_msg += ' km.'\n                    assert width > 2.0 * rupture_mesh_spacing, error_msg\n                    area = length * width\n                    f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons, 'lats': lats, 'oiler_id': fi, 'oiler_name': faults[fi]['properties']['name'], 'oiler_fid': faults[fi]['properties']['fid'], 'length': length}})\n                    file_section_tips.write(str(lons[0]) + ',' + str(lats[0]) + '\\n')\n                    file_section_tips.write(str(lons[-1]) + ',' + str(lats[-1]) + '\\n')\n                    sections_lengths_tot.append(length)\n                    sections_areas_tot.append(area)\n                    id_sections_fault_i.append(f_id)\n            else:\n                f_name = str(fi)\n                f_id += 1\n                f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons_tot, 'lats': lats_tot, 'oiler_id': fi, 'oiler_name': faults[fi]['properties']['name'], 'oiler_fid': faults[fi]['properties']['fid'], 'length': f_lengths[fi]}})\n                file_section_tips.write(str(lons_tot[0]) + ',' + str(lats_tot[0]) + '\\n')\n                file_section_tips.write(str(lons_tot[-1]) + ',' + str(lats_tot[-1]) + '\\n')\n                sections_lengths_tot.append(f_lengths[fi])\n                sections_areas_tot.append(f_areas[fi])\n                id_sections_fault_i.append(f_id)\n            if round(sum(sections_lengths_tot[-nb_sections:])) != round(f_lengths[fi]):\n                print('#####\\n fault', fi)\n                print('Failing!')\n                print(round(sum(sections_lengths_tot[-nb_sections:])), round(f_lengths[fi]), 'missing', round(-sum(sections_lengths_tot[-nb_sections:])) + round(f_lengths[fi]))\n                print('sections:', nb_sections)\n        id_sections_fault.append(id_sections_fault_i)\n    plt_fig = False\n    if plt_fig == True:\n        plt.hist(sections_lengths_tot)\n        plt.ylabel('nb of sections')\n        plt.xlabel('Length of the section (km)')\n        plt.show()\n    file_section_tips.close()\n    print('And a total of ', len(f_for_sherifs), ' sections.')\n    if round(sum(sections_lengths_tot)) != round(sum(f_lengths)):\n        print('!!!!!\\n ERROR! There are ', round(sum(f_lengths) - sum(sections_lengths_tot)), ' km of faults missing.')\n    return (f_for_sherifs, id_sections_fault, sections_areas_tot, sections_lengths_tot)",
            "def cut_faults(faults, f_lengths, f_areas, path, rupture_mesh_spacing, sectionning_param):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    f_for_sherifs = {}\n    f_lons = []\n    f_lats = []\n    f_id = -1\n    sections_lengths_tot = []\n    sections_areas_tot = []\n    id_sections_fault = []\n    max_section_length = sectionning_param['max_section_length']\n    max_num_sections = sectionning_param['max_num_sections']\n    distance_resolution = sectionning_param['distance_resolution']\n    if not os.path.exists(path + '/qgis'):\n        os.makedirs(path + '/qgis')\n    file_section_tips = open(path + '/qgis/sect_tips.csv', 'w')\n    file_section_tips.write('lon,lat\\n')\n    error_msg = 'A fault is too small for the discretization. Min length :'\n    error_msg += str(round(min(f_lengths), 3))\n    error_msg += ' km.'\n    assert min(f_lengths) > 2.0 * rupture_mesh_spacing, error_msg\n    nb_faults = len(faults)\n    for fi in range(nb_faults):\n        lons_tot = [i[0] for i in faults[fi]['geometry']['coordinates']]\n        lats_tot = [i[1] for i in faults[fi]['geometry']['coordinates']]\n        id_sections_fault_i = []\n        if len(lons_tot) < f_lengths[fi] / distance_resolution:\n            (inter_lon_i, inter_lat_i) = ([], [])\n            for i in range(len(lons_tot) - 1):\n                di = distance(lons_tot[i], lats_tot[i], lons_tot[i + 1], lats_tot[i + 1])\n                nb_extra_pts = int(di / distance_resolution)\n                if i == len(lons_tot) - 2:\n                    if nb_extra_pts > 1:\n                        inter_lon_i += list(np.linspace(lons_tot[i], lons_tot[i + 1], nb_extra_pts))\n                        inter_lat_i += list(np.linspace(lats_tot[i], lats_tot[i + 1], nb_extra_pts))\n                    else:\n                        inter_lon_i += [lons_tot[i], lons_tot[i + 1]]\n                        inter_lat_i += [lats_tot[i], lats_tot[i + 1]]\n                elif nb_extra_pts > 1:\n                    inter_lon_i += list(np.linspace(lons_tot[i], lons_tot[i + 1], nb_extra_pts))[:-1]\n                    inter_lat_i += list(np.linspace(lats_tot[i], lats_tot[i + 1], nb_extra_pts))[:-1]\n                else:\n                    inter_lon_i += [lons_tot[i], lons_tot[i + 1]][:-1]\n                    inter_lat_i += [lats_tot[i], lats_tot[i + 1]][:-1]\n            (lons_tot, lats_tot) = (inter_lon_i, inter_lat_i)\n        if f_lengths[fi] < max_section_length:\n            f_name = str(fi)\n            f_id += 1\n            f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons_tot, 'lats': lats_tot, 'oiler_id': fi, 'oiler_name': faults[fi]['properties']['name'], 'oiler_fid': faults[fi]['properties']['fid'], 'length': f_lengths[fi]}})\n            file_section_tips.write(str(lons_tot[0]) + ',' + str(lats_tot[0]) + '\\n')\n            file_section_tips.write(str(lons_tot[-1]) + ',' + str(lats_tot[-1]) + '\\n')\n            sections_lengths_tot.append(f_lengths[fi])\n            sections_areas_tot.append(f_areas[fi])\n            id_sections_fault_i.append(f_id)\n        else:\n            dists = []\n            for i in range(len(lons_tot) - 1):\n                dists.append(distance(lons_tot[i], lats_tot[i], lons_tot[i + 1], lats_tot[i + 1]))\n            if f_lengths[fi] < max_section_length * max_num_sections:\n                if max(dists) > max_section_length:\n                    section_lenght = max(dists)\n                    nb_sections = int(round(f_lengths[fi] / section_lenght))\n                else:\n                    nb_sections = 1\n                    section_lenght = f_lengths[fi] / float(nb_sections)\n                    while section_lenght > max_section_length:\n                        nb_sections += 1\n                        section_lenght = f_lengths[fi] / float(nb_sections)\n            elif max(dists) > f_lengths[fi] / (max_num_sections - 1):\n                nb_sections = max_num_sections - 1\n            else:\n                nb_sections = max_num_sections\n            if nb_sections != 1:\n                av_section_len = f_lengths[fi] / float(nb_sections)\n                index_0 = 0\n                for cut in range(nb_sections - 1):\n                    dist = 0\n                    index_cut = 0 + index_0\n                    while dist < av_section_len:\n                        try:\n                            dist += distance(lons_tot[index_cut], lats_tot[index_cut], lons_tot[index_cut + 1], lats_tot[index_cut + 1])\n                            index_cut += 1\n                            do_last = True\n                            if dist > av_section_len * 0.3 and dist > 2.0 * rupture_mesh_spacing:\n                                az1 = calculate_initial_compass_bearing([lons_tot[index_cut - 1], lats_tot[index_cut - 1]], [lons_tot[index_cut], lats_tot[index_cut]])\n                                az2 = calculate_initial_compass_bearing([lons_tot[index_cut], lats_tot[index_cut]], [lons_tot[index_cut + 1], lats_tot[index_cut + 1]])\n                                if abs(az1 - az2) % 360 > 60.0:\n                                    dist = 100000.0\n                        except IndexError:\n                            index_cut = len(lons_tot) - 1\n                            do_last = False\n                            dist = 100000.0\n                    lons = lons_tot[index_0:index_cut + 1]\n                    lats = lats_tot[index_0:index_cut + 1]\n                    length = 0.0\n                    for i in range(len(lons) - 1):\n                        length += distance(lons[i], lats[i], lons[i + 1], lats[i + 1])\n                    if 'lsd' in faults[fi]['properties'].keys():\n                        width = (faults[fi]['properties']['lsd'] - faults[fi]['properties']['usd']) / sin(radians(faults[fi]['properties']['dip']))\n                    else:\n                        width = (faults[fi]['properties']['lo_s_d'] - faults[fi]['properties']['up_s_d']) / sin(radians(faults[fi]['properties']['dip']))\n                    area = length * width\n                    f_name = str(fi) + '_' + str(cut)\n                    f_id += 1\n                    f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons, 'lats': lats, 'oiler_id': fi, 'oiler_name': faults[fi]['properties']['name'], 'oiler_fid': faults[fi]['properties']['fid'], 'length': length}})\n                    file_section_tips.write(str(lons[0]) + ',' + str(lats[0]) + '\\n')\n                    file_section_tips.write(str(lons[-1]) + ',' + str(lats[-1]) + '\\n')\n                    index_0 = index_cut\n                    sections_lengths_tot.append(length)\n                    sections_areas_tot.append(area)\n                    id_sections_fault_i.append(f_id)\n                if do_last == True:\n                    lons = lons_tot[index_cut:]\n                    lats = lats_tot[index_cut:]\n                    f_name = str(fi) + '_' + str(cut)\n                    f_id += 1\n                    length = fault_length(lons, lats)\n                    if 'lsd' in faults[fi]['properties'].keys():\n                        width = (faults[fi]['properties']['lsd'] - faults[fi]['properties']['usd']) / sin(radians(faults[fi]['properties']['dip']))\n                    else:\n                        width = (faults[fi]['properties']['lo_s_d'] - faults[fi]['properties']['up_s_d']) / sin(radians(faults[fi]['properties']['dip']))\n                    error_msg = 'A fault is too thin for the discretization. Fault name :'\n                    error_msg += str(faults[fi]['properties']['fid'])\n                    error_msg += ' width : '\n                    error_msg += str(round(width, 2))\n                    error_msg += ' km.'\n                    assert width > 2.0 * rupture_mesh_spacing, error_msg\n                    area = length * width\n                    f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons, 'lats': lats, 'oiler_id': fi, 'oiler_name': faults[fi]['properties']['name'], 'oiler_fid': faults[fi]['properties']['fid'], 'length': length}})\n                    file_section_tips.write(str(lons[0]) + ',' + str(lats[0]) + '\\n')\n                    file_section_tips.write(str(lons[-1]) + ',' + str(lats[-1]) + '\\n')\n                    sections_lengths_tot.append(length)\n                    sections_areas_tot.append(area)\n                    id_sections_fault_i.append(f_id)\n            else:\n                f_name = str(fi)\n                f_id += 1\n                f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons_tot, 'lats': lats_tot, 'oiler_id': fi, 'oiler_name': faults[fi]['properties']['name'], 'oiler_fid': faults[fi]['properties']['fid'], 'length': f_lengths[fi]}})\n                file_section_tips.write(str(lons_tot[0]) + ',' + str(lats_tot[0]) + '\\n')\n                file_section_tips.write(str(lons_tot[-1]) + ',' + str(lats_tot[-1]) + '\\n')\n                sections_lengths_tot.append(f_lengths[fi])\n                sections_areas_tot.append(f_areas[fi])\n                id_sections_fault_i.append(f_id)\n            if round(sum(sections_lengths_tot[-nb_sections:])) != round(f_lengths[fi]):\n                print('#####\\n fault', fi)\n                print('Failing!')\n                print(round(sum(sections_lengths_tot[-nb_sections:])), round(f_lengths[fi]), 'missing', round(-sum(sections_lengths_tot[-nb_sections:])) + round(f_lengths[fi]))\n                print('sections:', nb_sections)\n        id_sections_fault.append(id_sections_fault_i)\n    plt_fig = False\n    if plt_fig == True:\n        plt.hist(sections_lengths_tot)\n        plt.ylabel('nb of sections')\n        plt.xlabel('Length of the section (km)')\n        plt.show()\n    file_section_tips.close()\n    print('And a total of ', len(f_for_sherifs), ' sections.')\n    if round(sum(sections_lengths_tot)) != round(sum(f_lengths)):\n        print('!!!!!\\n ERROR! There are ', round(sum(f_lengths) - sum(sections_lengths_tot)), ' km of faults missing.')\n    return (f_for_sherifs, id_sections_fault, sections_areas_tot, sections_lengths_tot)",
            "def cut_faults(faults, f_lengths, f_areas, path, rupture_mesh_spacing, sectionning_param):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    f_for_sherifs = {}\n    f_lons = []\n    f_lats = []\n    f_id = -1\n    sections_lengths_tot = []\n    sections_areas_tot = []\n    id_sections_fault = []\n    max_section_length = sectionning_param['max_section_length']\n    max_num_sections = sectionning_param['max_num_sections']\n    distance_resolution = sectionning_param['distance_resolution']\n    if not os.path.exists(path + '/qgis'):\n        os.makedirs(path + '/qgis')\n    file_section_tips = open(path + '/qgis/sect_tips.csv', 'w')\n    file_section_tips.write('lon,lat\\n')\n    error_msg = 'A fault is too small for the discretization. Min length :'\n    error_msg += str(round(min(f_lengths), 3))\n    error_msg += ' km.'\n    assert min(f_lengths) > 2.0 * rupture_mesh_spacing, error_msg\n    nb_faults = len(faults)\n    for fi in range(nb_faults):\n        lons_tot = [i[0] for i in faults[fi]['geometry']['coordinates']]\n        lats_tot = [i[1] for i in faults[fi]['geometry']['coordinates']]\n        id_sections_fault_i = []\n        if len(lons_tot) < f_lengths[fi] / distance_resolution:\n            (inter_lon_i, inter_lat_i) = ([], [])\n            for i in range(len(lons_tot) - 1):\n                di = distance(lons_tot[i], lats_tot[i], lons_tot[i + 1], lats_tot[i + 1])\n                nb_extra_pts = int(di / distance_resolution)\n                if i == len(lons_tot) - 2:\n                    if nb_extra_pts > 1:\n                        inter_lon_i += list(np.linspace(lons_tot[i], lons_tot[i + 1], nb_extra_pts))\n                        inter_lat_i += list(np.linspace(lats_tot[i], lats_tot[i + 1], nb_extra_pts))\n                    else:\n                        inter_lon_i += [lons_tot[i], lons_tot[i + 1]]\n                        inter_lat_i += [lats_tot[i], lats_tot[i + 1]]\n                elif nb_extra_pts > 1:\n                    inter_lon_i += list(np.linspace(lons_tot[i], lons_tot[i + 1], nb_extra_pts))[:-1]\n                    inter_lat_i += list(np.linspace(lats_tot[i], lats_tot[i + 1], nb_extra_pts))[:-1]\n                else:\n                    inter_lon_i += [lons_tot[i], lons_tot[i + 1]][:-1]\n                    inter_lat_i += [lats_tot[i], lats_tot[i + 1]][:-1]\n            (lons_tot, lats_tot) = (inter_lon_i, inter_lat_i)\n        if f_lengths[fi] < max_section_length:\n            f_name = str(fi)\n            f_id += 1\n            f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons_tot, 'lats': lats_tot, 'oiler_id': fi, 'oiler_name': faults[fi]['properties']['name'], 'oiler_fid': faults[fi]['properties']['fid'], 'length': f_lengths[fi]}})\n            file_section_tips.write(str(lons_tot[0]) + ',' + str(lats_tot[0]) + '\\n')\n            file_section_tips.write(str(lons_tot[-1]) + ',' + str(lats_tot[-1]) + '\\n')\n            sections_lengths_tot.append(f_lengths[fi])\n            sections_areas_tot.append(f_areas[fi])\n            id_sections_fault_i.append(f_id)\n        else:\n            dists = []\n            for i in range(len(lons_tot) - 1):\n                dists.append(distance(lons_tot[i], lats_tot[i], lons_tot[i + 1], lats_tot[i + 1]))\n            if f_lengths[fi] < max_section_length * max_num_sections:\n                if max(dists) > max_section_length:\n                    section_lenght = max(dists)\n                    nb_sections = int(round(f_lengths[fi] / section_lenght))\n                else:\n                    nb_sections = 1\n                    section_lenght = f_lengths[fi] / float(nb_sections)\n                    while section_lenght > max_section_length:\n                        nb_sections += 1\n                        section_lenght = f_lengths[fi] / float(nb_sections)\n            elif max(dists) > f_lengths[fi] / (max_num_sections - 1):\n                nb_sections = max_num_sections - 1\n            else:\n                nb_sections = max_num_sections\n            if nb_sections != 1:\n                av_section_len = f_lengths[fi] / float(nb_sections)\n                index_0 = 0\n                for cut in range(nb_sections - 1):\n                    dist = 0\n                    index_cut = 0 + index_0\n                    while dist < av_section_len:\n                        try:\n                            dist += distance(lons_tot[index_cut], lats_tot[index_cut], lons_tot[index_cut + 1], lats_tot[index_cut + 1])\n                            index_cut += 1\n                            do_last = True\n                            if dist > av_section_len * 0.3 and dist > 2.0 * rupture_mesh_spacing:\n                                az1 = calculate_initial_compass_bearing([lons_tot[index_cut - 1], lats_tot[index_cut - 1]], [lons_tot[index_cut], lats_tot[index_cut]])\n                                az2 = calculate_initial_compass_bearing([lons_tot[index_cut], lats_tot[index_cut]], [lons_tot[index_cut + 1], lats_tot[index_cut + 1]])\n                                if abs(az1 - az2) % 360 > 60.0:\n                                    dist = 100000.0\n                        except IndexError:\n                            index_cut = len(lons_tot) - 1\n                            do_last = False\n                            dist = 100000.0\n                    lons = lons_tot[index_0:index_cut + 1]\n                    lats = lats_tot[index_0:index_cut + 1]\n                    length = 0.0\n                    for i in range(len(lons) - 1):\n                        length += distance(lons[i], lats[i], lons[i + 1], lats[i + 1])\n                    if 'lsd' in faults[fi]['properties'].keys():\n                        width = (faults[fi]['properties']['lsd'] - faults[fi]['properties']['usd']) / sin(radians(faults[fi]['properties']['dip']))\n                    else:\n                        width = (faults[fi]['properties']['lo_s_d'] - faults[fi]['properties']['up_s_d']) / sin(radians(faults[fi]['properties']['dip']))\n                    area = length * width\n                    f_name = str(fi) + '_' + str(cut)\n                    f_id += 1\n                    f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons, 'lats': lats, 'oiler_id': fi, 'oiler_name': faults[fi]['properties']['name'], 'oiler_fid': faults[fi]['properties']['fid'], 'length': length}})\n                    file_section_tips.write(str(lons[0]) + ',' + str(lats[0]) + '\\n')\n                    file_section_tips.write(str(lons[-1]) + ',' + str(lats[-1]) + '\\n')\n                    index_0 = index_cut\n                    sections_lengths_tot.append(length)\n                    sections_areas_tot.append(area)\n                    id_sections_fault_i.append(f_id)\n                if do_last == True:\n                    lons = lons_tot[index_cut:]\n                    lats = lats_tot[index_cut:]\n                    f_name = str(fi) + '_' + str(cut)\n                    f_id += 1\n                    length = fault_length(lons, lats)\n                    if 'lsd' in faults[fi]['properties'].keys():\n                        width = (faults[fi]['properties']['lsd'] - faults[fi]['properties']['usd']) / sin(radians(faults[fi]['properties']['dip']))\n                    else:\n                        width = (faults[fi]['properties']['lo_s_d'] - faults[fi]['properties']['up_s_d']) / sin(radians(faults[fi]['properties']['dip']))\n                    error_msg = 'A fault is too thin for the discretization. Fault name :'\n                    error_msg += str(faults[fi]['properties']['fid'])\n                    error_msg += ' width : '\n                    error_msg += str(round(width, 2))\n                    error_msg += ' km.'\n                    assert width > 2.0 * rupture_mesh_spacing, error_msg\n                    area = length * width\n                    f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons, 'lats': lats, 'oiler_id': fi, 'oiler_name': faults[fi]['properties']['name'], 'oiler_fid': faults[fi]['properties']['fid'], 'length': length}})\n                    file_section_tips.write(str(lons[0]) + ',' + str(lats[0]) + '\\n')\n                    file_section_tips.write(str(lons[-1]) + ',' + str(lats[-1]) + '\\n')\n                    sections_lengths_tot.append(length)\n                    sections_areas_tot.append(area)\n                    id_sections_fault_i.append(f_id)\n            else:\n                f_name = str(fi)\n                f_id += 1\n                f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons_tot, 'lats': lats_tot, 'oiler_id': fi, 'oiler_name': faults[fi]['properties']['name'], 'oiler_fid': faults[fi]['properties']['fid'], 'length': f_lengths[fi]}})\n                file_section_tips.write(str(lons_tot[0]) + ',' + str(lats_tot[0]) + '\\n')\n                file_section_tips.write(str(lons_tot[-1]) + ',' + str(lats_tot[-1]) + '\\n')\n                sections_lengths_tot.append(f_lengths[fi])\n                sections_areas_tot.append(f_areas[fi])\n                id_sections_fault_i.append(f_id)\n            if round(sum(sections_lengths_tot[-nb_sections:])) != round(f_lengths[fi]):\n                print('#####\\n fault', fi)\n                print('Failing!')\n                print(round(sum(sections_lengths_tot[-nb_sections:])), round(f_lengths[fi]), 'missing', round(-sum(sections_lengths_tot[-nb_sections:])) + round(f_lengths[fi]))\n                print('sections:', nb_sections)\n        id_sections_fault.append(id_sections_fault_i)\n    plt_fig = False\n    if plt_fig == True:\n        plt.hist(sections_lengths_tot)\n        plt.ylabel('nb of sections')\n        plt.xlabel('Length of the section (km)')\n        plt.show()\n    file_section_tips.close()\n    print('And a total of ', len(f_for_sherifs), ' sections.')\n    if round(sum(sections_lengths_tot)) != round(sum(f_lengths)):\n        print('!!!!!\\n ERROR! There are ', round(sum(f_lengths) - sum(sections_lengths_tot)), ' km of faults missing.')\n    return (f_for_sherifs, id_sections_fault, sections_areas_tot, sections_lengths_tot)",
            "def cut_faults(faults, f_lengths, f_areas, path, rupture_mesh_spacing, sectionning_param):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    f_for_sherifs = {}\n    f_lons = []\n    f_lats = []\n    f_id = -1\n    sections_lengths_tot = []\n    sections_areas_tot = []\n    id_sections_fault = []\n    max_section_length = sectionning_param['max_section_length']\n    max_num_sections = sectionning_param['max_num_sections']\n    distance_resolution = sectionning_param['distance_resolution']\n    if not os.path.exists(path + '/qgis'):\n        os.makedirs(path + '/qgis')\n    file_section_tips = open(path + '/qgis/sect_tips.csv', 'w')\n    file_section_tips.write('lon,lat\\n')\n    error_msg = 'A fault is too small for the discretization. Min length :'\n    error_msg += str(round(min(f_lengths), 3))\n    error_msg += ' km.'\n    assert min(f_lengths) > 2.0 * rupture_mesh_spacing, error_msg\n    nb_faults = len(faults)\n    for fi in range(nb_faults):\n        lons_tot = [i[0] for i in faults[fi]['geometry']['coordinates']]\n        lats_tot = [i[1] for i in faults[fi]['geometry']['coordinates']]\n        id_sections_fault_i = []\n        if len(lons_tot) < f_lengths[fi] / distance_resolution:\n            (inter_lon_i, inter_lat_i) = ([], [])\n            for i in range(len(lons_tot) - 1):\n                di = distance(lons_tot[i], lats_tot[i], lons_tot[i + 1], lats_tot[i + 1])\n                nb_extra_pts = int(di / distance_resolution)\n                if i == len(lons_tot) - 2:\n                    if nb_extra_pts > 1:\n                        inter_lon_i += list(np.linspace(lons_tot[i], lons_tot[i + 1], nb_extra_pts))\n                        inter_lat_i += list(np.linspace(lats_tot[i], lats_tot[i + 1], nb_extra_pts))\n                    else:\n                        inter_lon_i += [lons_tot[i], lons_tot[i + 1]]\n                        inter_lat_i += [lats_tot[i], lats_tot[i + 1]]\n                elif nb_extra_pts > 1:\n                    inter_lon_i += list(np.linspace(lons_tot[i], lons_tot[i + 1], nb_extra_pts))[:-1]\n                    inter_lat_i += list(np.linspace(lats_tot[i], lats_tot[i + 1], nb_extra_pts))[:-1]\n                else:\n                    inter_lon_i += [lons_tot[i], lons_tot[i + 1]][:-1]\n                    inter_lat_i += [lats_tot[i], lats_tot[i + 1]][:-1]\n            (lons_tot, lats_tot) = (inter_lon_i, inter_lat_i)\n        if f_lengths[fi] < max_section_length:\n            f_name = str(fi)\n            f_id += 1\n            f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons_tot, 'lats': lats_tot, 'oiler_id': fi, 'oiler_name': faults[fi]['properties']['name'], 'oiler_fid': faults[fi]['properties']['fid'], 'length': f_lengths[fi]}})\n            file_section_tips.write(str(lons_tot[0]) + ',' + str(lats_tot[0]) + '\\n')\n            file_section_tips.write(str(lons_tot[-1]) + ',' + str(lats_tot[-1]) + '\\n')\n            sections_lengths_tot.append(f_lengths[fi])\n            sections_areas_tot.append(f_areas[fi])\n            id_sections_fault_i.append(f_id)\n        else:\n            dists = []\n            for i in range(len(lons_tot) - 1):\n                dists.append(distance(lons_tot[i], lats_tot[i], lons_tot[i + 1], lats_tot[i + 1]))\n            if f_lengths[fi] < max_section_length * max_num_sections:\n                if max(dists) > max_section_length:\n                    section_lenght = max(dists)\n                    nb_sections = int(round(f_lengths[fi] / section_lenght))\n                else:\n                    nb_sections = 1\n                    section_lenght = f_lengths[fi] / float(nb_sections)\n                    while section_lenght > max_section_length:\n                        nb_sections += 1\n                        section_lenght = f_lengths[fi] / float(nb_sections)\n            elif max(dists) > f_lengths[fi] / (max_num_sections - 1):\n                nb_sections = max_num_sections - 1\n            else:\n                nb_sections = max_num_sections\n            if nb_sections != 1:\n                av_section_len = f_lengths[fi] / float(nb_sections)\n                index_0 = 0\n                for cut in range(nb_sections - 1):\n                    dist = 0\n                    index_cut = 0 + index_0\n                    while dist < av_section_len:\n                        try:\n                            dist += distance(lons_tot[index_cut], lats_tot[index_cut], lons_tot[index_cut + 1], lats_tot[index_cut + 1])\n                            index_cut += 1\n                            do_last = True\n                            if dist > av_section_len * 0.3 and dist > 2.0 * rupture_mesh_spacing:\n                                az1 = calculate_initial_compass_bearing([lons_tot[index_cut - 1], lats_tot[index_cut - 1]], [lons_tot[index_cut], lats_tot[index_cut]])\n                                az2 = calculate_initial_compass_bearing([lons_tot[index_cut], lats_tot[index_cut]], [lons_tot[index_cut + 1], lats_tot[index_cut + 1]])\n                                if abs(az1 - az2) % 360 > 60.0:\n                                    dist = 100000.0\n                        except IndexError:\n                            index_cut = len(lons_tot) - 1\n                            do_last = False\n                            dist = 100000.0\n                    lons = lons_tot[index_0:index_cut + 1]\n                    lats = lats_tot[index_0:index_cut + 1]\n                    length = 0.0\n                    for i in range(len(lons) - 1):\n                        length += distance(lons[i], lats[i], lons[i + 1], lats[i + 1])\n                    if 'lsd' in faults[fi]['properties'].keys():\n                        width = (faults[fi]['properties']['lsd'] - faults[fi]['properties']['usd']) / sin(radians(faults[fi]['properties']['dip']))\n                    else:\n                        width = (faults[fi]['properties']['lo_s_d'] - faults[fi]['properties']['up_s_d']) / sin(radians(faults[fi]['properties']['dip']))\n                    area = length * width\n                    f_name = str(fi) + '_' + str(cut)\n                    f_id += 1\n                    f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons, 'lats': lats, 'oiler_id': fi, 'oiler_name': faults[fi]['properties']['name'], 'oiler_fid': faults[fi]['properties']['fid'], 'length': length}})\n                    file_section_tips.write(str(lons[0]) + ',' + str(lats[0]) + '\\n')\n                    file_section_tips.write(str(lons[-1]) + ',' + str(lats[-1]) + '\\n')\n                    index_0 = index_cut\n                    sections_lengths_tot.append(length)\n                    sections_areas_tot.append(area)\n                    id_sections_fault_i.append(f_id)\n                if do_last == True:\n                    lons = lons_tot[index_cut:]\n                    lats = lats_tot[index_cut:]\n                    f_name = str(fi) + '_' + str(cut)\n                    f_id += 1\n                    length = fault_length(lons, lats)\n                    if 'lsd' in faults[fi]['properties'].keys():\n                        width = (faults[fi]['properties']['lsd'] - faults[fi]['properties']['usd']) / sin(radians(faults[fi]['properties']['dip']))\n                    else:\n                        width = (faults[fi]['properties']['lo_s_d'] - faults[fi]['properties']['up_s_d']) / sin(radians(faults[fi]['properties']['dip']))\n                    error_msg = 'A fault is too thin for the discretization. Fault name :'\n                    error_msg += str(faults[fi]['properties']['fid'])\n                    error_msg += ' width : '\n                    error_msg += str(round(width, 2))\n                    error_msg += ' km.'\n                    assert width > 2.0 * rupture_mesh_spacing, error_msg\n                    area = length * width\n                    f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons, 'lats': lats, 'oiler_id': fi, 'oiler_name': faults[fi]['properties']['name'], 'oiler_fid': faults[fi]['properties']['fid'], 'length': length}})\n                    file_section_tips.write(str(lons[0]) + ',' + str(lats[0]) + '\\n')\n                    file_section_tips.write(str(lons[-1]) + ',' + str(lats[-1]) + '\\n')\n                    sections_lengths_tot.append(length)\n                    sections_areas_tot.append(area)\n                    id_sections_fault_i.append(f_id)\n            else:\n                f_name = str(fi)\n                f_id += 1\n                f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons_tot, 'lats': lats_tot, 'oiler_id': fi, 'oiler_name': faults[fi]['properties']['name'], 'oiler_fid': faults[fi]['properties']['fid'], 'length': f_lengths[fi]}})\n                file_section_tips.write(str(lons_tot[0]) + ',' + str(lats_tot[0]) + '\\n')\n                file_section_tips.write(str(lons_tot[-1]) + ',' + str(lats_tot[-1]) + '\\n')\n                sections_lengths_tot.append(f_lengths[fi])\n                sections_areas_tot.append(f_areas[fi])\n                id_sections_fault_i.append(f_id)\n            if round(sum(sections_lengths_tot[-nb_sections:])) != round(f_lengths[fi]):\n                print('#####\\n fault', fi)\n                print('Failing!')\n                print(round(sum(sections_lengths_tot[-nb_sections:])), round(f_lengths[fi]), 'missing', round(-sum(sections_lengths_tot[-nb_sections:])) + round(f_lengths[fi]))\n                print('sections:', nb_sections)\n        id_sections_fault.append(id_sections_fault_i)\n    plt_fig = False\n    if plt_fig == True:\n        plt.hist(sections_lengths_tot)\n        plt.ylabel('nb of sections')\n        plt.xlabel('Length of the section (km)')\n        plt.show()\n    file_section_tips.close()\n    print('And a total of ', len(f_for_sherifs), ' sections.')\n    if round(sum(sections_lengths_tot)) != round(sum(f_lengths)):\n        print('!!!!!\\n ERROR! There are ', round(sum(f_lengths) - sum(sections_lengths_tot)), ' km of faults missing.')\n    return (f_for_sherifs, id_sections_fault, sections_areas_tot, sections_lengths_tot)",
            "def cut_faults(faults, f_lengths, f_areas, path, rupture_mesh_spacing, sectionning_param):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    f_for_sherifs = {}\n    f_lons = []\n    f_lats = []\n    f_id = -1\n    sections_lengths_tot = []\n    sections_areas_tot = []\n    id_sections_fault = []\n    max_section_length = sectionning_param['max_section_length']\n    max_num_sections = sectionning_param['max_num_sections']\n    distance_resolution = sectionning_param['distance_resolution']\n    if not os.path.exists(path + '/qgis'):\n        os.makedirs(path + '/qgis')\n    file_section_tips = open(path + '/qgis/sect_tips.csv', 'w')\n    file_section_tips.write('lon,lat\\n')\n    error_msg = 'A fault is too small for the discretization. Min length :'\n    error_msg += str(round(min(f_lengths), 3))\n    error_msg += ' km.'\n    assert min(f_lengths) > 2.0 * rupture_mesh_spacing, error_msg\n    nb_faults = len(faults)\n    for fi in range(nb_faults):\n        lons_tot = [i[0] for i in faults[fi]['geometry']['coordinates']]\n        lats_tot = [i[1] for i in faults[fi]['geometry']['coordinates']]\n        id_sections_fault_i = []\n        if len(lons_tot) < f_lengths[fi] / distance_resolution:\n            (inter_lon_i, inter_lat_i) = ([], [])\n            for i in range(len(lons_tot) - 1):\n                di = distance(lons_tot[i], lats_tot[i], lons_tot[i + 1], lats_tot[i + 1])\n                nb_extra_pts = int(di / distance_resolution)\n                if i == len(lons_tot) - 2:\n                    if nb_extra_pts > 1:\n                        inter_lon_i += list(np.linspace(lons_tot[i], lons_tot[i + 1], nb_extra_pts))\n                        inter_lat_i += list(np.linspace(lats_tot[i], lats_tot[i + 1], nb_extra_pts))\n                    else:\n                        inter_lon_i += [lons_tot[i], lons_tot[i + 1]]\n                        inter_lat_i += [lats_tot[i], lats_tot[i + 1]]\n                elif nb_extra_pts > 1:\n                    inter_lon_i += list(np.linspace(lons_tot[i], lons_tot[i + 1], nb_extra_pts))[:-1]\n                    inter_lat_i += list(np.linspace(lats_tot[i], lats_tot[i + 1], nb_extra_pts))[:-1]\n                else:\n                    inter_lon_i += [lons_tot[i], lons_tot[i + 1]][:-1]\n                    inter_lat_i += [lats_tot[i], lats_tot[i + 1]][:-1]\n            (lons_tot, lats_tot) = (inter_lon_i, inter_lat_i)\n        if f_lengths[fi] < max_section_length:\n            f_name = str(fi)\n            f_id += 1\n            f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons_tot, 'lats': lats_tot, 'oiler_id': fi, 'oiler_name': faults[fi]['properties']['name'], 'oiler_fid': faults[fi]['properties']['fid'], 'length': f_lengths[fi]}})\n            file_section_tips.write(str(lons_tot[0]) + ',' + str(lats_tot[0]) + '\\n')\n            file_section_tips.write(str(lons_tot[-1]) + ',' + str(lats_tot[-1]) + '\\n')\n            sections_lengths_tot.append(f_lengths[fi])\n            sections_areas_tot.append(f_areas[fi])\n            id_sections_fault_i.append(f_id)\n        else:\n            dists = []\n            for i in range(len(lons_tot) - 1):\n                dists.append(distance(lons_tot[i], lats_tot[i], lons_tot[i + 1], lats_tot[i + 1]))\n            if f_lengths[fi] < max_section_length * max_num_sections:\n                if max(dists) > max_section_length:\n                    section_lenght = max(dists)\n                    nb_sections = int(round(f_lengths[fi] / section_lenght))\n                else:\n                    nb_sections = 1\n                    section_lenght = f_lengths[fi] / float(nb_sections)\n                    while section_lenght > max_section_length:\n                        nb_sections += 1\n                        section_lenght = f_lengths[fi] / float(nb_sections)\n            elif max(dists) > f_lengths[fi] / (max_num_sections - 1):\n                nb_sections = max_num_sections - 1\n            else:\n                nb_sections = max_num_sections\n            if nb_sections != 1:\n                av_section_len = f_lengths[fi] / float(nb_sections)\n                index_0 = 0\n                for cut in range(nb_sections - 1):\n                    dist = 0\n                    index_cut = 0 + index_0\n                    while dist < av_section_len:\n                        try:\n                            dist += distance(lons_tot[index_cut], lats_tot[index_cut], lons_tot[index_cut + 1], lats_tot[index_cut + 1])\n                            index_cut += 1\n                            do_last = True\n                            if dist > av_section_len * 0.3 and dist > 2.0 * rupture_mesh_spacing:\n                                az1 = calculate_initial_compass_bearing([lons_tot[index_cut - 1], lats_tot[index_cut - 1]], [lons_tot[index_cut], lats_tot[index_cut]])\n                                az2 = calculate_initial_compass_bearing([lons_tot[index_cut], lats_tot[index_cut]], [lons_tot[index_cut + 1], lats_tot[index_cut + 1]])\n                                if abs(az1 - az2) % 360 > 60.0:\n                                    dist = 100000.0\n                        except IndexError:\n                            index_cut = len(lons_tot) - 1\n                            do_last = False\n                            dist = 100000.0\n                    lons = lons_tot[index_0:index_cut + 1]\n                    lats = lats_tot[index_0:index_cut + 1]\n                    length = 0.0\n                    for i in range(len(lons) - 1):\n                        length += distance(lons[i], lats[i], lons[i + 1], lats[i + 1])\n                    if 'lsd' in faults[fi]['properties'].keys():\n                        width = (faults[fi]['properties']['lsd'] - faults[fi]['properties']['usd']) / sin(radians(faults[fi]['properties']['dip']))\n                    else:\n                        width = (faults[fi]['properties']['lo_s_d'] - faults[fi]['properties']['up_s_d']) / sin(radians(faults[fi]['properties']['dip']))\n                    area = length * width\n                    f_name = str(fi) + '_' + str(cut)\n                    f_id += 1\n                    f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons, 'lats': lats, 'oiler_id': fi, 'oiler_name': faults[fi]['properties']['name'], 'oiler_fid': faults[fi]['properties']['fid'], 'length': length}})\n                    file_section_tips.write(str(lons[0]) + ',' + str(lats[0]) + '\\n')\n                    file_section_tips.write(str(lons[-1]) + ',' + str(lats[-1]) + '\\n')\n                    index_0 = index_cut\n                    sections_lengths_tot.append(length)\n                    sections_areas_tot.append(area)\n                    id_sections_fault_i.append(f_id)\n                if do_last == True:\n                    lons = lons_tot[index_cut:]\n                    lats = lats_tot[index_cut:]\n                    f_name = str(fi) + '_' + str(cut)\n                    f_id += 1\n                    length = fault_length(lons, lats)\n                    if 'lsd' in faults[fi]['properties'].keys():\n                        width = (faults[fi]['properties']['lsd'] - faults[fi]['properties']['usd']) / sin(radians(faults[fi]['properties']['dip']))\n                    else:\n                        width = (faults[fi]['properties']['lo_s_d'] - faults[fi]['properties']['up_s_d']) / sin(radians(faults[fi]['properties']['dip']))\n                    error_msg = 'A fault is too thin for the discretization. Fault name :'\n                    error_msg += str(faults[fi]['properties']['fid'])\n                    error_msg += ' width : '\n                    error_msg += str(round(width, 2))\n                    error_msg += ' km.'\n                    assert width > 2.0 * rupture_mesh_spacing, error_msg\n                    area = length * width\n                    f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons, 'lats': lats, 'oiler_id': fi, 'oiler_name': faults[fi]['properties']['name'], 'oiler_fid': faults[fi]['properties']['fid'], 'length': length}})\n                    file_section_tips.write(str(lons[0]) + ',' + str(lats[0]) + '\\n')\n                    file_section_tips.write(str(lons[-1]) + ',' + str(lats[-1]) + '\\n')\n                    sections_lengths_tot.append(length)\n                    sections_areas_tot.append(area)\n                    id_sections_fault_i.append(f_id)\n            else:\n                f_name = str(fi)\n                f_id += 1\n                f_for_sherifs.update({f_id: {'f_name': f_name, 'lons': lons_tot, 'lats': lats_tot, 'oiler_id': fi, 'oiler_name': faults[fi]['properties']['name'], 'oiler_fid': faults[fi]['properties']['fid'], 'length': f_lengths[fi]}})\n                file_section_tips.write(str(lons_tot[0]) + ',' + str(lats_tot[0]) + '\\n')\n                file_section_tips.write(str(lons_tot[-1]) + ',' + str(lats_tot[-1]) + '\\n')\n                sections_lengths_tot.append(f_lengths[fi])\n                sections_areas_tot.append(f_areas[fi])\n                id_sections_fault_i.append(f_id)\n            if round(sum(sections_lengths_tot[-nb_sections:])) != round(f_lengths[fi]):\n                print('#####\\n fault', fi)\n                print('Failing!')\n                print(round(sum(sections_lengths_tot[-nb_sections:])), round(f_lengths[fi]), 'missing', round(-sum(sections_lengths_tot[-nb_sections:])) + round(f_lengths[fi]))\n                print('sections:', nb_sections)\n        id_sections_fault.append(id_sections_fault_i)\n    plt_fig = False\n    if plt_fig == True:\n        plt.hist(sections_lengths_tot)\n        plt.ylabel('nb of sections')\n        plt.xlabel('Length of the section (km)')\n        plt.show()\n    file_section_tips.close()\n    print('And a total of ', len(f_for_sherifs), ' sections.')\n    if round(sum(sections_lengths_tot)) != round(sum(f_lengths)):\n        print('!!!!!\\n ERROR! There are ', round(sum(f_lengths) - sum(sections_lengths_tot)), ' km of faults missing.')\n    return (f_for_sherifs, id_sections_fault, sections_areas_tot, sections_lengths_tot)"
        ]
    },
    {
        "func_name": "export_sections_pts",
        "original": "def export_sections_pts(f_for_sherifs, path):\n    sections_points = open(path + '/qgis/sections_pt.csv', 'w')\n    sections_points.write('lon,lat' + '\\n')\n    for si in range(len(f_for_sherifs)):\n        lons_i = f_for_sherifs[si]['lons']\n        lats_i = f_for_sherifs[si]['lats']\n        for (lon_i, lat_i) in zip(lons_i, lats_i):\n            sections_points.write(str(lon_i) + ',' + str(lat_i) + '\\n')\n    sections_points.close()\n    return",
        "mutated": [
            "def export_sections_pts(f_for_sherifs, path):\n    if False:\n        i = 10\n    sections_points = open(path + '/qgis/sections_pt.csv', 'w')\n    sections_points.write('lon,lat' + '\\n')\n    for si in range(len(f_for_sherifs)):\n        lons_i = f_for_sherifs[si]['lons']\n        lats_i = f_for_sherifs[si]['lats']\n        for (lon_i, lat_i) in zip(lons_i, lats_i):\n            sections_points.write(str(lon_i) + ',' + str(lat_i) + '\\n')\n    sections_points.close()\n    return",
            "def export_sections_pts(f_for_sherifs, path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    sections_points = open(path + '/qgis/sections_pt.csv', 'w')\n    sections_points.write('lon,lat' + '\\n')\n    for si in range(len(f_for_sherifs)):\n        lons_i = f_for_sherifs[si]['lons']\n        lats_i = f_for_sherifs[si]['lats']\n        for (lon_i, lat_i) in zip(lons_i, lats_i):\n            sections_points.write(str(lon_i) + ',' + str(lat_i) + '\\n')\n    sections_points.close()\n    return",
            "def export_sections_pts(f_for_sherifs, path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    sections_points = open(path + '/qgis/sections_pt.csv', 'w')\n    sections_points.write('lon,lat' + '\\n')\n    for si in range(len(f_for_sherifs)):\n        lons_i = f_for_sherifs[si]['lons']\n        lats_i = f_for_sherifs[si]['lats']\n        for (lon_i, lat_i) in zip(lons_i, lats_i):\n            sections_points.write(str(lon_i) + ',' + str(lat_i) + '\\n')\n    sections_points.close()\n    return",
            "def export_sections_pts(f_for_sherifs, path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    sections_points = open(path + '/qgis/sections_pt.csv', 'w')\n    sections_points.write('lon,lat' + '\\n')\n    for si in range(len(f_for_sherifs)):\n        lons_i = f_for_sherifs[si]['lons']\n        lats_i = f_for_sherifs[si]['lats']\n        for (lon_i, lat_i) in zip(lons_i, lats_i):\n            sections_points.write(str(lon_i) + ',' + str(lat_i) + '\\n')\n    sections_points.close()\n    return",
            "def export_sections_pts(f_for_sherifs, path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    sections_points = open(path + '/qgis/sections_pt.csv', 'w')\n    sections_points.write('lon,lat' + '\\n')\n    for si in range(len(f_for_sherifs)):\n        lons_i = f_for_sherifs[si]['lons']\n        lats_i = f_for_sherifs[si]['lats']\n        for (lon_i, lat_i) in zip(lons_i, lats_i):\n            sections_points.write(str(lon_i) + ',' + str(lat_i) + '\\n')\n    sections_points.close()\n    return"
        ]
    },
    {
        "func_name": "find_sections_Mmax",
        "original": "def find_sections_Mmax(f_for_sherifs, zones_json):\n    nb_sections = len(f_for_sherifs)\n    for si in range(nb_sections):\n        f_for_sherifs[si]['max_possible_length'] = 10000.0\n        f_for_sherifs[si]['max_possible_Mmax'] = 11.0\n    with open(zones_json) as f:\n        gj = geojson.load(f)\n    zones_length = gj['features']\n    for zone_i in zones_length:\n        poly = []\n        for pt in zone_i['geometry']['coordinates'][0][0]:\n            poly.append((pt[0], pt[1]))\n        polygon = Polygon(poly)\n        max_i = zone_i['properties']['max_length']\n        Mmax_i = zone_i['properties']['max_possible_Mmax']\n        for si in range(nb_sections):\n            if f_for_sherifs[si]['max_possible_length'] > max_i:\n                lons_si = f_for_sherifs[si]['lons']\n                lats_si = f_for_sherifs[si]['lats']\n                for (lon_i, lat_i) in zip(lons_si, lats_si):\n                    if polygon.contains(Point(lon_i, lat_i)):\n                        f_for_sherifs[si]['max_possible_length'] = max_i\n        for si in range(nb_sections):\n            if f_for_sherifs[si]['max_possible_Mmax'] > Mmax_i:\n                lons_si = f_for_sherifs[si]['lons']\n                lats_si = f_for_sherifs[si]['lats']\n                for (lon_i, lat_i) in zip(lons_si, lats_si):\n                    if polygon.contains(Point(lon_i, lat_i)):\n                        f_for_sherifs[si]['max_possible_Mmax'] = Mmax_i\n    return f_for_sherifs",
        "mutated": [
            "def find_sections_Mmax(f_for_sherifs, zones_json):\n    if False:\n        i = 10\n    nb_sections = len(f_for_sherifs)\n    for si in range(nb_sections):\n        f_for_sherifs[si]['max_possible_length'] = 10000.0\n        f_for_sherifs[si]['max_possible_Mmax'] = 11.0\n    with open(zones_json) as f:\n        gj = geojson.load(f)\n    zones_length = gj['features']\n    for zone_i in zones_length:\n        poly = []\n        for pt in zone_i['geometry']['coordinates'][0][0]:\n            poly.append((pt[0], pt[1]))\n        polygon = Polygon(poly)\n        max_i = zone_i['properties']['max_length']\n        Mmax_i = zone_i['properties']['max_possible_Mmax']\n        for si in range(nb_sections):\n            if f_for_sherifs[si]['max_possible_length'] > max_i:\n                lons_si = f_for_sherifs[si]['lons']\n                lats_si = f_for_sherifs[si]['lats']\n                for (lon_i, lat_i) in zip(lons_si, lats_si):\n                    if polygon.contains(Point(lon_i, lat_i)):\n                        f_for_sherifs[si]['max_possible_length'] = max_i\n        for si in range(nb_sections):\n            if f_for_sherifs[si]['max_possible_Mmax'] > Mmax_i:\n                lons_si = f_for_sherifs[si]['lons']\n                lats_si = f_for_sherifs[si]['lats']\n                for (lon_i, lat_i) in zip(lons_si, lats_si):\n                    if polygon.contains(Point(lon_i, lat_i)):\n                        f_for_sherifs[si]['max_possible_Mmax'] = Mmax_i\n    return f_for_sherifs",
            "def find_sections_Mmax(f_for_sherifs, zones_json):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    nb_sections = len(f_for_sherifs)\n    for si in range(nb_sections):\n        f_for_sherifs[si]['max_possible_length'] = 10000.0\n        f_for_sherifs[si]['max_possible_Mmax'] = 11.0\n    with open(zones_json) as f:\n        gj = geojson.load(f)\n    zones_length = gj['features']\n    for zone_i in zones_length:\n        poly = []\n        for pt in zone_i['geometry']['coordinates'][0][0]:\n            poly.append((pt[0], pt[1]))\n        polygon = Polygon(poly)\n        max_i = zone_i['properties']['max_length']\n        Mmax_i = zone_i['properties']['max_possible_Mmax']\n        for si in range(nb_sections):\n            if f_for_sherifs[si]['max_possible_length'] > max_i:\n                lons_si = f_for_sherifs[si]['lons']\n                lats_si = f_for_sherifs[si]['lats']\n                for (lon_i, lat_i) in zip(lons_si, lats_si):\n                    if polygon.contains(Point(lon_i, lat_i)):\n                        f_for_sherifs[si]['max_possible_length'] = max_i\n        for si in range(nb_sections):\n            if f_for_sherifs[si]['max_possible_Mmax'] > Mmax_i:\n                lons_si = f_for_sherifs[si]['lons']\n                lats_si = f_for_sherifs[si]['lats']\n                for (lon_i, lat_i) in zip(lons_si, lats_si):\n                    if polygon.contains(Point(lon_i, lat_i)):\n                        f_for_sherifs[si]['max_possible_Mmax'] = Mmax_i\n    return f_for_sherifs",
            "def find_sections_Mmax(f_for_sherifs, zones_json):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    nb_sections = len(f_for_sherifs)\n    for si in range(nb_sections):\n        f_for_sherifs[si]['max_possible_length'] = 10000.0\n        f_for_sherifs[si]['max_possible_Mmax'] = 11.0\n    with open(zones_json) as f:\n        gj = geojson.load(f)\n    zones_length = gj['features']\n    for zone_i in zones_length:\n        poly = []\n        for pt in zone_i['geometry']['coordinates'][0][0]:\n            poly.append((pt[0], pt[1]))\n        polygon = Polygon(poly)\n        max_i = zone_i['properties']['max_length']\n        Mmax_i = zone_i['properties']['max_possible_Mmax']\n        for si in range(nb_sections):\n            if f_for_sherifs[si]['max_possible_length'] > max_i:\n                lons_si = f_for_sherifs[si]['lons']\n                lats_si = f_for_sherifs[si]['lats']\n                for (lon_i, lat_i) in zip(lons_si, lats_si):\n                    if polygon.contains(Point(lon_i, lat_i)):\n                        f_for_sherifs[si]['max_possible_length'] = max_i\n        for si in range(nb_sections):\n            if f_for_sherifs[si]['max_possible_Mmax'] > Mmax_i:\n                lons_si = f_for_sherifs[si]['lons']\n                lats_si = f_for_sherifs[si]['lats']\n                for (lon_i, lat_i) in zip(lons_si, lats_si):\n                    if polygon.contains(Point(lon_i, lat_i)):\n                        f_for_sherifs[si]['max_possible_Mmax'] = Mmax_i\n    return f_for_sherifs",
            "def find_sections_Mmax(f_for_sherifs, zones_json):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    nb_sections = len(f_for_sherifs)\n    for si in range(nb_sections):\n        f_for_sherifs[si]['max_possible_length'] = 10000.0\n        f_for_sherifs[si]['max_possible_Mmax'] = 11.0\n    with open(zones_json) as f:\n        gj = geojson.load(f)\n    zones_length = gj['features']\n    for zone_i in zones_length:\n        poly = []\n        for pt in zone_i['geometry']['coordinates'][0][0]:\n            poly.append((pt[0], pt[1]))\n        polygon = Polygon(poly)\n        max_i = zone_i['properties']['max_length']\n        Mmax_i = zone_i['properties']['max_possible_Mmax']\n        for si in range(nb_sections):\n            if f_for_sherifs[si]['max_possible_length'] > max_i:\n                lons_si = f_for_sherifs[si]['lons']\n                lats_si = f_for_sherifs[si]['lats']\n                for (lon_i, lat_i) in zip(lons_si, lats_si):\n                    if polygon.contains(Point(lon_i, lat_i)):\n                        f_for_sherifs[si]['max_possible_length'] = max_i\n        for si in range(nb_sections):\n            if f_for_sherifs[si]['max_possible_Mmax'] > Mmax_i:\n                lons_si = f_for_sherifs[si]['lons']\n                lats_si = f_for_sherifs[si]['lats']\n                for (lon_i, lat_i) in zip(lons_si, lats_si):\n                    if polygon.contains(Point(lon_i, lat_i)):\n                        f_for_sherifs[si]['max_possible_Mmax'] = Mmax_i\n    return f_for_sherifs",
            "def find_sections_Mmax(f_for_sherifs, zones_json):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    nb_sections = len(f_for_sherifs)\n    for si in range(nb_sections):\n        f_for_sherifs[si]['max_possible_length'] = 10000.0\n        f_for_sherifs[si]['max_possible_Mmax'] = 11.0\n    with open(zones_json) as f:\n        gj = geojson.load(f)\n    zones_length = gj['features']\n    for zone_i in zones_length:\n        poly = []\n        for pt in zone_i['geometry']['coordinates'][0][0]:\n            poly.append((pt[0], pt[1]))\n        polygon = Polygon(poly)\n        max_i = zone_i['properties']['max_length']\n        Mmax_i = zone_i['properties']['max_possible_Mmax']\n        for si in range(nb_sections):\n            if f_for_sherifs[si]['max_possible_length'] > max_i:\n                lons_si = f_for_sherifs[si]['lons']\n                lats_si = f_for_sherifs[si]['lats']\n                for (lon_i, lat_i) in zip(lons_si, lats_si):\n                    if polygon.contains(Point(lon_i, lat_i)):\n                        f_for_sherifs[si]['max_possible_length'] = max_i\n        for si in range(nb_sections):\n            if f_for_sherifs[si]['max_possible_Mmax'] > Mmax_i:\n                lons_si = f_for_sherifs[si]['lons']\n                lats_si = f_for_sherifs[si]['lats']\n                for (lon_i, lat_i) in zip(lons_si, lats_si):\n                    if polygon.contains(Point(lon_i, lat_i)):\n                        f_for_sherifs[si]['max_possible_Mmax'] = Mmax_i\n    return f_for_sherifs"
        ]
    },
    {
        "func_name": "to_sherifs",
        "original": "def to_sherifs(f_for_sherifs, faults, Model_name, apply_sr_reduction, f_mu):\n    nb_sections = len(f_for_sherifs)\n    modify_mu = []\n    mu_value = []\n    if f_mu != None:\n        with open(f_mu) as f:\n            gj = geojson.load(f)\n        zones_mu = gj['features']\n        for zone_i in zones_mu:\n            poly = []\n            for pt in zone_i['geometry']['coordinates'][0][0]:\n                poly.append((pt[0], pt[1]))\n            polygon = Polygon(poly)\n            mu_i = zone_i['properties']['shear_mod']\n            for si in range(nb_sections):\n                lons_si = f_for_sherifs[si]['lons']\n                lats_si = f_for_sherifs[si]['lats']\n                isin = False\n                for (lon_i, lat_i) in zip(lons_si, lats_si):\n                    if isin == False and polygon.contains(Point(lon_i, lat_i)):\n                        isin = True\n                        modify_mu.append(si)\n                        mu_value.append(mu_i)\n    i_mu = 0\n    for si in range(nb_sections):\n        fi = f_for_sherifs[si]['oiler_id']\n        if 'usd' in faults[fi]['properties'].keys() and f_for_sherifs[si]['oiler_name'] != None:\n            f_for_sherifs[si]['up_s_d'] = faults[fi]['properties']['usd']\n            f_for_sherifs[si]['lo_s_d'] = faults[fi]['properties']['lsd']\n            f_for_sherifs[si]['dip'] = faults[fi]['properties']['dip']\n            f_for_sherifs[si]['oriented'] = faults[fi]['properties']['dip_dir']\n        else:\n            f_for_sherifs[si]['up_s_d'] = faults[fi]['properties']['up_s_d']\n            f_for_sherifs[si]['lo_s_d'] = faults[fi]['properties']['lo_s_d']\n            f_for_sherifs[si]['dip'] = faults[fi]['properties']['dip']\n            f_for_sherifs[si]['oriented'] = faults[fi]['properties']['oriented']\n        f_for_sherifs[si]['Domain'] = 'Active Shallow Crust'\n        if si in modify_mu:\n            f_for_sherifs[si]['shear_modulus'] = mu_value[i_mu]\n            i_mu += 1\n        else:\n            f_for_sherifs[si]['shear_modulus'] = '30'\n    for si in range(nb_sections):\n        fi = f_for_sherifs[si]['oiler_id']\n        if f_for_sherifs[si]['oiler_name'] == None:\n            fi = si\n            slip_rate_moy = abs(faults[fi]['properties']['sr_mean'])\n            slip_rate_min = abs(faults[fi]['properties']['sr_min'])\n            slip_rate_max = abs(faults[fi]['properties']['sr_max'])\n            rake = faults[fi]['properties']['rake']\n        elif 'v_rl' in faults[fi]['properties'].keys():\n            v_rl = abs(faults[fi]['properties']['v_rl'])\n            v_ex = faults[fi]['properties']['v_ex']\n            slip_rate_moy = (v_rl ** 2 + v_ex ** 2) ** 0.5\n            err = (faults[fi]['properties']['e_rl'] ** 2 + faults[fi]['properties']['e_ex'] ** 2) ** 0.5\n            slip_rate_min = slip_rate_moy - err\n            slip_rate_max = slip_rate_moy + err\n            if slip_rate_min < 0.0:\n                print('ERROR - slip rate min is negative !')\n            if v_ex != 0.0:\n                if abs(v_ex) < v_rl:\n                    rake = degrees(acos(abs(v_ex) / v_rl))\n                else:\n                    rake = degrees(acos(v_rl / abs(v_ex)))\n                if v_ex < 0:\n                    rake = -rake\n            else:\n                rake = 0.0\n        elif 'sr' in faults[fi]['properties'].keys():\n            slip_rate_moy = abs(faults[fi]['properties']['sr'])\n            err = abs(faults[fi]['properties']['e_sr'])\n            slip_rate_min = slip_rate_moy - err\n            slip_rate_max = slip_rate_moy + err\n            rake = abs(faults[fi]['properties']['rake'])\n        else:\n            print('Please check the format of the input geojson file')\n        if 'rake' in faults[fi]['properties'].keys():\n            f_for_sherifs[si]['rake'] = faults[fi]['properties']['rake']\n        else:\n            f_for_sherifs[si]['rake'] = rake\n        if 'sr_mean' in faults[fi]['properties'].keys():\n            f_for_sherifs[si]['slip_rate_min'] = faults[fi]['properties']['sr_min']\n            f_for_sherifs[si]['slip_rate_moy'] = faults[fi]['properties']['sr_mean']\n            f_for_sherifs[si]['slip_rate_max'] = faults[fi]['properties']['sr_max']\n        else:\n            f_for_sherifs[si]['slip_rate_min'] = slip_rate_min * (1.0 - apply_sr_reduction)\n            f_for_sherifs[si]['slip_rate_moy'] = slip_rate_moy * (1.0 - apply_sr_reduction)\n            f_for_sherifs[si]['slip_rate_max'] = slip_rate_max * (1.0 - apply_sr_reduction)\n        f_for_sherifs[si]['model'] = Model_name\n    return f_for_sherifs",
        "mutated": [
            "def to_sherifs(f_for_sherifs, faults, Model_name, apply_sr_reduction, f_mu):\n    if False:\n        i = 10\n    nb_sections = len(f_for_sherifs)\n    modify_mu = []\n    mu_value = []\n    if f_mu != None:\n        with open(f_mu) as f:\n            gj = geojson.load(f)\n        zones_mu = gj['features']\n        for zone_i in zones_mu:\n            poly = []\n            for pt in zone_i['geometry']['coordinates'][0][0]:\n                poly.append((pt[0], pt[1]))\n            polygon = Polygon(poly)\n            mu_i = zone_i['properties']['shear_mod']\n            for si in range(nb_sections):\n                lons_si = f_for_sherifs[si]['lons']\n                lats_si = f_for_sherifs[si]['lats']\n                isin = False\n                for (lon_i, lat_i) in zip(lons_si, lats_si):\n                    if isin == False and polygon.contains(Point(lon_i, lat_i)):\n                        isin = True\n                        modify_mu.append(si)\n                        mu_value.append(mu_i)\n    i_mu = 0\n    for si in range(nb_sections):\n        fi = f_for_sherifs[si]['oiler_id']\n        if 'usd' in faults[fi]['properties'].keys() and f_for_sherifs[si]['oiler_name'] != None:\n            f_for_sherifs[si]['up_s_d'] = faults[fi]['properties']['usd']\n            f_for_sherifs[si]['lo_s_d'] = faults[fi]['properties']['lsd']\n            f_for_sherifs[si]['dip'] = faults[fi]['properties']['dip']\n            f_for_sherifs[si]['oriented'] = faults[fi]['properties']['dip_dir']\n        else:\n            f_for_sherifs[si]['up_s_d'] = faults[fi]['properties']['up_s_d']\n            f_for_sherifs[si]['lo_s_d'] = faults[fi]['properties']['lo_s_d']\n            f_for_sherifs[si]['dip'] = faults[fi]['properties']['dip']\n            f_for_sherifs[si]['oriented'] = faults[fi]['properties']['oriented']\n        f_for_sherifs[si]['Domain'] = 'Active Shallow Crust'\n        if si in modify_mu:\n            f_for_sherifs[si]['shear_modulus'] = mu_value[i_mu]\n            i_mu += 1\n        else:\n            f_for_sherifs[si]['shear_modulus'] = '30'\n    for si in range(nb_sections):\n        fi = f_for_sherifs[si]['oiler_id']\n        if f_for_sherifs[si]['oiler_name'] == None:\n            fi = si\n            slip_rate_moy = abs(faults[fi]['properties']['sr_mean'])\n            slip_rate_min = abs(faults[fi]['properties']['sr_min'])\n            slip_rate_max = abs(faults[fi]['properties']['sr_max'])\n            rake = faults[fi]['properties']['rake']\n        elif 'v_rl' in faults[fi]['properties'].keys():\n            v_rl = abs(faults[fi]['properties']['v_rl'])\n            v_ex = faults[fi]['properties']['v_ex']\n            slip_rate_moy = (v_rl ** 2 + v_ex ** 2) ** 0.5\n            err = (faults[fi]['properties']['e_rl'] ** 2 + faults[fi]['properties']['e_ex'] ** 2) ** 0.5\n            slip_rate_min = slip_rate_moy - err\n            slip_rate_max = slip_rate_moy + err\n            if slip_rate_min < 0.0:\n                print('ERROR - slip rate min is negative !')\n            if v_ex != 0.0:\n                if abs(v_ex) < v_rl:\n                    rake = degrees(acos(abs(v_ex) / v_rl))\n                else:\n                    rake = degrees(acos(v_rl / abs(v_ex)))\n                if v_ex < 0:\n                    rake = -rake\n            else:\n                rake = 0.0\n        elif 'sr' in faults[fi]['properties'].keys():\n            slip_rate_moy = abs(faults[fi]['properties']['sr'])\n            err = abs(faults[fi]['properties']['e_sr'])\n            slip_rate_min = slip_rate_moy - err\n            slip_rate_max = slip_rate_moy + err\n            rake = abs(faults[fi]['properties']['rake'])\n        else:\n            print('Please check the format of the input geojson file')\n        if 'rake' in faults[fi]['properties'].keys():\n            f_for_sherifs[si]['rake'] = faults[fi]['properties']['rake']\n        else:\n            f_for_sherifs[si]['rake'] = rake\n        if 'sr_mean' in faults[fi]['properties'].keys():\n            f_for_sherifs[si]['slip_rate_min'] = faults[fi]['properties']['sr_min']\n            f_for_sherifs[si]['slip_rate_moy'] = faults[fi]['properties']['sr_mean']\n            f_for_sherifs[si]['slip_rate_max'] = faults[fi]['properties']['sr_max']\n        else:\n            f_for_sherifs[si]['slip_rate_min'] = slip_rate_min * (1.0 - apply_sr_reduction)\n            f_for_sherifs[si]['slip_rate_moy'] = slip_rate_moy * (1.0 - apply_sr_reduction)\n            f_for_sherifs[si]['slip_rate_max'] = slip_rate_max * (1.0 - apply_sr_reduction)\n        f_for_sherifs[si]['model'] = Model_name\n    return f_for_sherifs",
            "def to_sherifs(f_for_sherifs, faults, Model_name, apply_sr_reduction, f_mu):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    nb_sections = len(f_for_sherifs)\n    modify_mu = []\n    mu_value = []\n    if f_mu != None:\n        with open(f_mu) as f:\n            gj = geojson.load(f)\n        zones_mu = gj['features']\n        for zone_i in zones_mu:\n            poly = []\n            for pt in zone_i['geometry']['coordinates'][0][0]:\n                poly.append((pt[0], pt[1]))\n            polygon = Polygon(poly)\n            mu_i = zone_i['properties']['shear_mod']\n            for si in range(nb_sections):\n                lons_si = f_for_sherifs[si]['lons']\n                lats_si = f_for_sherifs[si]['lats']\n                isin = False\n                for (lon_i, lat_i) in zip(lons_si, lats_si):\n                    if isin == False and polygon.contains(Point(lon_i, lat_i)):\n                        isin = True\n                        modify_mu.append(si)\n                        mu_value.append(mu_i)\n    i_mu = 0\n    for si in range(nb_sections):\n        fi = f_for_sherifs[si]['oiler_id']\n        if 'usd' in faults[fi]['properties'].keys() and f_for_sherifs[si]['oiler_name'] != None:\n            f_for_sherifs[si]['up_s_d'] = faults[fi]['properties']['usd']\n            f_for_sherifs[si]['lo_s_d'] = faults[fi]['properties']['lsd']\n            f_for_sherifs[si]['dip'] = faults[fi]['properties']['dip']\n            f_for_sherifs[si]['oriented'] = faults[fi]['properties']['dip_dir']\n        else:\n            f_for_sherifs[si]['up_s_d'] = faults[fi]['properties']['up_s_d']\n            f_for_sherifs[si]['lo_s_d'] = faults[fi]['properties']['lo_s_d']\n            f_for_sherifs[si]['dip'] = faults[fi]['properties']['dip']\n            f_for_sherifs[si]['oriented'] = faults[fi]['properties']['oriented']\n        f_for_sherifs[si]['Domain'] = 'Active Shallow Crust'\n        if si in modify_mu:\n            f_for_sherifs[si]['shear_modulus'] = mu_value[i_mu]\n            i_mu += 1\n        else:\n            f_for_sherifs[si]['shear_modulus'] = '30'\n    for si in range(nb_sections):\n        fi = f_for_sherifs[si]['oiler_id']\n        if f_for_sherifs[si]['oiler_name'] == None:\n            fi = si\n            slip_rate_moy = abs(faults[fi]['properties']['sr_mean'])\n            slip_rate_min = abs(faults[fi]['properties']['sr_min'])\n            slip_rate_max = abs(faults[fi]['properties']['sr_max'])\n            rake = faults[fi]['properties']['rake']\n        elif 'v_rl' in faults[fi]['properties'].keys():\n            v_rl = abs(faults[fi]['properties']['v_rl'])\n            v_ex = faults[fi]['properties']['v_ex']\n            slip_rate_moy = (v_rl ** 2 + v_ex ** 2) ** 0.5\n            err = (faults[fi]['properties']['e_rl'] ** 2 + faults[fi]['properties']['e_ex'] ** 2) ** 0.5\n            slip_rate_min = slip_rate_moy - err\n            slip_rate_max = slip_rate_moy + err\n            if slip_rate_min < 0.0:\n                print('ERROR - slip rate min is negative !')\n            if v_ex != 0.0:\n                if abs(v_ex) < v_rl:\n                    rake = degrees(acos(abs(v_ex) / v_rl))\n                else:\n                    rake = degrees(acos(v_rl / abs(v_ex)))\n                if v_ex < 0:\n                    rake = -rake\n            else:\n                rake = 0.0\n        elif 'sr' in faults[fi]['properties'].keys():\n            slip_rate_moy = abs(faults[fi]['properties']['sr'])\n            err = abs(faults[fi]['properties']['e_sr'])\n            slip_rate_min = slip_rate_moy - err\n            slip_rate_max = slip_rate_moy + err\n            rake = abs(faults[fi]['properties']['rake'])\n        else:\n            print('Please check the format of the input geojson file')\n        if 'rake' in faults[fi]['properties'].keys():\n            f_for_sherifs[si]['rake'] = faults[fi]['properties']['rake']\n        else:\n            f_for_sherifs[si]['rake'] = rake\n        if 'sr_mean' in faults[fi]['properties'].keys():\n            f_for_sherifs[si]['slip_rate_min'] = faults[fi]['properties']['sr_min']\n            f_for_sherifs[si]['slip_rate_moy'] = faults[fi]['properties']['sr_mean']\n            f_for_sherifs[si]['slip_rate_max'] = faults[fi]['properties']['sr_max']\n        else:\n            f_for_sherifs[si]['slip_rate_min'] = slip_rate_min * (1.0 - apply_sr_reduction)\n            f_for_sherifs[si]['slip_rate_moy'] = slip_rate_moy * (1.0 - apply_sr_reduction)\n            f_for_sherifs[si]['slip_rate_max'] = slip_rate_max * (1.0 - apply_sr_reduction)\n        f_for_sherifs[si]['model'] = Model_name\n    return f_for_sherifs",
            "def to_sherifs(f_for_sherifs, faults, Model_name, apply_sr_reduction, f_mu):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    nb_sections = len(f_for_sherifs)\n    modify_mu = []\n    mu_value = []\n    if f_mu != None:\n        with open(f_mu) as f:\n            gj = geojson.load(f)\n        zones_mu = gj['features']\n        for zone_i in zones_mu:\n            poly = []\n            for pt in zone_i['geometry']['coordinates'][0][0]:\n                poly.append((pt[0], pt[1]))\n            polygon = Polygon(poly)\n            mu_i = zone_i['properties']['shear_mod']\n            for si in range(nb_sections):\n                lons_si = f_for_sherifs[si]['lons']\n                lats_si = f_for_sherifs[si]['lats']\n                isin = False\n                for (lon_i, lat_i) in zip(lons_si, lats_si):\n                    if isin == False and polygon.contains(Point(lon_i, lat_i)):\n                        isin = True\n                        modify_mu.append(si)\n                        mu_value.append(mu_i)\n    i_mu = 0\n    for si in range(nb_sections):\n        fi = f_for_sherifs[si]['oiler_id']\n        if 'usd' in faults[fi]['properties'].keys() and f_for_sherifs[si]['oiler_name'] != None:\n            f_for_sherifs[si]['up_s_d'] = faults[fi]['properties']['usd']\n            f_for_sherifs[si]['lo_s_d'] = faults[fi]['properties']['lsd']\n            f_for_sherifs[si]['dip'] = faults[fi]['properties']['dip']\n            f_for_sherifs[si]['oriented'] = faults[fi]['properties']['dip_dir']\n        else:\n            f_for_sherifs[si]['up_s_d'] = faults[fi]['properties']['up_s_d']\n            f_for_sherifs[si]['lo_s_d'] = faults[fi]['properties']['lo_s_d']\n            f_for_sherifs[si]['dip'] = faults[fi]['properties']['dip']\n            f_for_sherifs[si]['oriented'] = faults[fi]['properties']['oriented']\n        f_for_sherifs[si]['Domain'] = 'Active Shallow Crust'\n        if si in modify_mu:\n            f_for_sherifs[si]['shear_modulus'] = mu_value[i_mu]\n            i_mu += 1\n        else:\n            f_for_sherifs[si]['shear_modulus'] = '30'\n    for si in range(nb_sections):\n        fi = f_for_sherifs[si]['oiler_id']\n        if f_for_sherifs[si]['oiler_name'] == None:\n            fi = si\n            slip_rate_moy = abs(faults[fi]['properties']['sr_mean'])\n            slip_rate_min = abs(faults[fi]['properties']['sr_min'])\n            slip_rate_max = abs(faults[fi]['properties']['sr_max'])\n            rake = faults[fi]['properties']['rake']\n        elif 'v_rl' in faults[fi]['properties'].keys():\n            v_rl = abs(faults[fi]['properties']['v_rl'])\n            v_ex = faults[fi]['properties']['v_ex']\n            slip_rate_moy = (v_rl ** 2 + v_ex ** 2) ** 0.5\n            err = (faults[fi]['properties']['e_rl'] ** 2 + faults[fi]['properties']['e_ex'] ** 2) ** 0.5\n            slip_rate_min = slip_rate_moy - err\n            slip_rate_max = slip_rate_moy + err\n            if slip_rate_min < 0.0:\n                print('ERROR - slip rate min is negative !')\n            if v_ex != 0.0:\n                if abs(v_ex) < v_rl:\n                    rake = degrees(acos(abs(v_ex) / v_rl))\n                else:\n                    rake = degrees(acos(v_rl / abs(v_ex)))\n                if v_ex < 0:\n                    rake = -rake\n            else:\n                rake = 0.0\n        elif 'sr' in faults[fi]['properties'].keys():\n            slip_rate_moy = abs(faults[fi]['properties']['sr'])\n            err = abs(faults[fi]['properties']['e_sr'])\n            slip_rate_min = slip_rate_moy - err\n            slip_rate_max = slip_rate_moy + err\n            rake = abs(faults[fi]['properties']['rake'])\n        else:\n            print('Please check the format of the input geojson file')\n        if 'rake' in faults[fi]['properties'].keys():\n            f_for_sherifs[si]['rake'] = faults[fi]['properties']['rake']\n        else:\n            f_for_sherifs[si]['rake'] = rake\n        if 'sr_mean' in faults[fi]['properties'].keys():\n            f_for_sherifs[si]['slip_rate_min'] = faults[fi]['properties']['sr_min']\n            f_for_sherifs[si]['slip_rate_moy'] = faults[fi]['properties']['sr_mean']\n            f_for_sherifs[si]['slip_rate_max'] = faults[fi]['properties']['sr_max']\n        else:\n            f_for_sherifs[si]['slip_rate_min'] = slip_rate_min * (1.0 - apply_sr_reduction)\n            f_for_sherifs[si]['slip_rate_moy'] = slip_rate_moy * (1.0 - apply_sr_reduction)\n            f_for_sherifs[si]['slip_rate_max'] = slip_rate_max * (1.0 - apply_sr_reduction)\n        f_for_sherifs[si]['model'] = Model_name\n    return f_for_sherifs",
            "def to_sherifs(f_for_sherifs, faults, Model_name, apply_sr_reduction, f_mu):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    nb_sections = len(f_for_sherifs)\n    modify_mu = []\n    mu_value = []\n    if f_mu != None:\n        with open(f_mu) as f:\n            gj = geojson.load(f)\n        zones_mu = gj['features']\n        for zone_i in zones_mu:\n            poly = []\n            for pt in zone_i['geometry']['coordinates'][0][0]:\n                poly.append((pt[0], pt[1]))\n            polygon = Polygon(poly)\n            mu_i = zone_i['properties']['shear_mod']\n            for si in range(nb_sections):\n                lons_si = f_for_sherifs[si]['lons']\n                lats_si = f_for_sherifs[si]['lats']\n                isin = False\n                for (lon_i, lat_i) in zip(lons_si, lats_si):\n                    if isin == False and polygon.contains(Point(lon_i, lat_i)):\n                        isin = True\n                        modify_mu.append(si)\n                        mu_value.append(mu_i)\n    i_mu = 0\n    for si in range(nb_sections):\n        fi = f_for_sherifs[si]['oiler_id']\n        if 'usd' in faults[fi]['properties'].keys() and f_for_sherifs[si]['oiler_name'] != None:\n            f_for_sherifs[si]['up_s_d'] = faults[fi]['properties']['usd']\n            f_for_sherifs[si]['lo_s_d'] = faults[fi]['properties']['lsd']\n            f_for_sherifs[si]['dip'] = faults[fi]['properties']['dip']\n            f_for_sherifs[si]['oriented'] = faults[fi]['properties']['dip_dir']\n        else:\n            f_for_sherifs[si]['up_s_d'] = faults[fi]['properties']['up_s_d']\n            f_for_sherifs[si]['lo_s_d'] = faults[fi]['properties']['lo_s_d']\n            f_for_sherifs[si]['dip'] = faults[fi]['properties']['dip']\n            f_for_sherifs[si]['oriented'] = faults[fi]['properties']['oriented']\n        f_for_sherifs[si]['Domain'] = 'Active Shallow Crust'\n        if si in modify_mu:\n            f_for_sherifs[si]['shear_modulus'] = mu_value[i_mu]\n            i_mu += 1\n        else:\n            f_for_sherifs[si]['shear_modulus'] = '30'\n    for si in range(nb_sections):\n        fi = f_for_sherifs[si]['oiler_id']\n        if f_for_sherifs[si]['oiler_name'] == None:\n            fi = si\n            slip_rate_moy = abs(faults[fi]['properties']['sr_mean'])\n            slip_rate_min = abs(faults[fi]['properties']['sr_min'])\n            slip_rate_max = abs(faults[fi]['properties']['sr_max'])\n            rake = faults[fi]['properties']['rake']\n        elif 'v_rl' in faults[fi]['properties'].keys():\n            v_rl = abs(faults[fi]['properties']['v_rl'])\n            v_ex = faults[fi]['properties']['v_ex']\n            slip_rate_moy = (v_rl ** 2 + v_ex ** 2) ** 0.5\n            err = (faults[fi]['properties']['e_rl'] ** 2 + faults[fi]['properties']['e_ex'] ** 2) ** 0.5\n            slip_rate_min = slip_rate_moy - err\n            slip_rate_max = slip_rate_moy + err\n            if slip_rate_min < 0.0:\n                print('ERROR - slip rate min is negative !')\n            if v_ex != 0.0:\n                if abs(v_ex) < v_rl:\n                    rake = degrees(acos(abs(v_ex) / v_rl))\n                else:\n                    rake = degrees(acos(v_rl / abs(v_ex)))\n                if v_ex < 0:\n                    rake = -rake\n            else:\n                rake = 0.0\n        elif 'sr' in faults[fi]['properties'].keys():\n            slip_rate_moy = abs(faults[fi]['properties']['sr'])\n            err = abs(faults[fi]['properties']['e_sr'])\n            slip_rate_min = slip_rate_moy - err\n            slip_rate_max = slip_rate_moy + err\n            rake = abs(faults[fi]['properties']['rake'])\n        else:\n            print('Please check the format of the input geojson file')\n        if 'rake' in faults[fi]['properties'].keys():\n            f_for_sherifs[si]['rake'] = faults[fi]['properties']['rake']\n        else:\n            f_for_sherifs[si]['rake'] = rake\n        if 'sr_mean' in faults[fi]['properties'].keys():\n            f_for_sherifs[si]['slip_rate_min'] = faults[fi]['properties']['sr_min']\n            f_for_sherifs[si]['slip_rate_moy'] = faults[fi]['properties']['sr_mean']\n            f_for_sherifs[si]['slip_rate_max'] = faults[fi]['properties']['sr_max']\n        else:\n            f_for_sherifs[si]['slip_rate_min'] = slip_rate_min * (1.0 - apply_sr_reduction)\n            f_for_sherifs[si]['slip_rate_moy'] = slip_rate_moy * (1.0 - apply_sr_reduction)\n            f_for_sherifs[si]['slip_rate_max'] = slip_rate_max * (1.0 - apply_sr_reduction)\n        f_for_sherifs[si]['model'] = Model_name\n    return f_for_sherifs",
            "def to_sherifs(f_for_sherifs, faults, Model_name, apply_sr_reduction, f_mu):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    nb_sections = len(f_for_sherifs)\n    modify_mu = []\n    mu_value = []\n    if f_mu != None:\n        with open(f_mu) as f:\n            gj = geojson.load(f)\n        zones_mu = gj['features']\n        for zone_i in zones_mu:\n            poly = []\n            for pt in zone_i['geometry']['coordinates'][0][0]:\n                poly.append((pt[0], pt[1]))\n            polygon = Polygon(poly)\n            mu_i = zone_i['properties']['shear_mod']\n            for si in range(nb_sections):\n                lons_si = f_for_sherifs[si]['lons']\n                lats_si = f_for_sherifs[si]['lats']\n                isin = False\n                for (lon_i, lat_i) in zip(lons_si, lats_si):\n                    if isin == False and polygon.contains(Point(lon_i, lat_i)):\n                        isin = True\n                        modify_mu.append(si)\n                        mu_value.append(mu_i)\n    i_mu = 0\n    for si in range(nb_sections):\n        fi = f_for_sherifs[si]['oiler_id']\n        if 'usd' in faults[fi]['properties'].keys() and f_for_sherifs[si]['oiler_name'] != None:\n            f_for_sherifs[si]['up_s_d'] = faults[fi]['properties']['usd']\n            f_for_sherifs[si]['lo_s_d'] = faults[fi]['properties']['lsd']\n            f_for_sherifs[si]['dip'] = faults[fi]['properties']['dip']\n            f_for_sherifs[si]['oriented'] = faults[fi]['properties']['dip_dir']\n        else:\n            f_for_sherifs[si]['up_s_d'] = faults[fi]['properties']['up_s_d']\n            f_for_sherifs[si]['lo_s_d'] = faults[fi]['properties']['lo_s_d']\n            f_for_sherifs[si]['dip'] = faults[fi]['properties']['dip']\n            f_for_sherifs[si]['oriented'] = faults[fi]['properties']['oriented']\n        f_for_sherifs[si]['Domain'] = 'Active Shallow Crust'\n        if si in modify_mu:\n            f_for_sherifs[si]['shear_modulus'] = mu_value[i_mu]\n            i_mu += 1\n        else:\n            f_for_sherifs[si]['shear_modulus'] = '30'\n    for si in range(nb_sections):\n        fi = f_for_sherifs[si]['oiler_id']\n        if f_for_sherifs[si]['oiler_name'] == None:\n            fi = si\n            slip_rate_moy = abs(faults[fi]['properties']['sr_mean'])\n            slip_rate_min = abs(faults[fi]['properties']['sr_min'])\n            slip_rate_max = abs(faults[fi]['properties']['sr_max'])\n            rake = faults[fi]['properties']['rake']\n        elif 'v_rl' in faults[fi]['properties'].keys():\n            v_rl = abs(faults[fi]['properties']['v_rl'])\n            v_ex = faults[fi]['properties']['v_ex']\n            slip_rate_moy = (v_rl ** 2 + v_ex ** 2) ** 0.5\n            err = (faults[fi]['properties']['e_rl'] ** 2 + faults[fi]['properties']['e_ex'] ** 2) ** 0.5\n            slip_rate_min = slip_rate_moy - err\n            slip_rate_max = slip_rate_moy + err\n            if slip_rate_min < 0.0:\n                print('ERROR - slip rate min is negative !')\n            if v_ex != 0.0:\n                if abs(v_ex) < v_rl:\n                    rake = degrees(acos(abs(v_ex) / v_rl))\n                else:\n                    rake = degrees(acos(v_rl / abs(v_ex)))\n                if v_ex < 0:\n                    rake = -rake\n            else:\n                rake = 0.0\n        elif 'sr' in faults[fi]['properties'].keys():\n            slip_rate_moy = abs(faults[fi]['properties']['sr'])\n            err = abs(faults[fi]['properties']['e_sr'])\n            slip_rate_min = slip_rate_moy - err\n            slip_rate_max = slip_rate_moy + err\n            rake = abs(faults[fi]['properties']['rake'])\n        else:\n            print('Please check the format of the input geojson file')\n        if 'rake' in faults[fi]['properties'].keys():\n            f_for_sherifs[si]['rake'] = faults[fi]['properties']['rake']\n        else:\n            f_for_sherifs[si]['rake'] = rake\n        if 'sr_mean' in faults[fi]['properties'].keys():\n            f_for_sherifs[si]['slip_rate_min'] = faults[fi]['properties']['sr_min']\n            f_for_sherifs[si]['slip_rate_moy'] = faults[fi]['properties']['sr_mean']\n            f_for_sherifs[si]['slip_rate_max'] = faults[fi]['properties']['sr_max']\n        else:\n            f_for_sherifs[si]['slip_rate_min'] = slip_rate_min * (1.0 - apply_sr_reduction)\n            f_for_sherifs[si]['slip_rate_moy'] = slip_rate_moy * (1.0 - apply_sr_reduction)\n            f_for_sherifs[si]['slip_rate_max'] = slip_rate_max * (1.0 - apply_sr_reduction)\n        f_for_sherifs[si]['model'] = Model_name\n    return f_for_sherifs"
        ]
    },
    {
        "func_name": "write_section_json",
        "original": "def write_section_json(f_for_sherifs, f_name):\n    features = []\n    for si in range(len(f_for_sherifs)):\n        geom = []\n        for (lon_i, lat_i) in zip(f_for_sherifs[si]['lons'], f_for_sherifs[si]['lats']):\n            geom.append([lon_i, lat_i])\n        geom = LineString(geom)\n        nb_rup = len(f_for_sherifs[si]['rup_id'])\n        max_rup_length = f_for_sherifs[si]['max_length']\n        up_s_d = f_for_sherifs[si]['up_s_d']\n        lo_s_d = f_for_sherifs[si]['lo_s_d']\n        dip = f_for_sherifs[si]['dip']\n        oriented = f_for_sherifs[si]['oriented']\n        Domain = f_for_sherifs[si]['Domain']\n        shear_modulus = f_for_sherifs[si]['shear_modulus']\n        rake = f_for_sherifs[si]['rake']\n        sr_min = f_for_sherifs[si]['slip_rate_min']\n        sr_mean = f_for_sherifs[si]['slip_rate_moy']\n        sr_max = f_for_sherifs[si]['slip_rate_max']\n        model = f_for_sherifs[si]['model']\n        features.append(Feature(geometry=geom, properties={'si': si, 'nb_rup': nb_rup, 'max_rup_length': max_rup_length, 'up_s_d': up_s_d, 'lo_s_d': lo_s_d, 'dip': dip, 'oriented': oriented, 'Domain': Domain, 'shear_modulus': shear_modulus, 'rake': rake, 'sr_min': sr_min, 'sr_mean': sr_mean, 'sr_max': sr_max, 'model': model}))\n    feature_collection = FeatureCollection(features)\n    with open(f_name, 'w') as f:\n        dump(feature_collection, f)",
        "mutated": [
            "def write_section_json(f_for_sherifs, f_name):\n    if False:\n        i = 10\n    features = []\n    for si in range(len(f_for_sherifs)):\n        geom = []\n        for (lon_i, lat_i) in zip(f_for_sherifs[si]['lons'], f_for_sherifs[si]['lats']):\n            geom.append([lon_i, lat_i])\n        geom = LineString(geom)\n        nb_rup = len(f_for_sherifs[si]['rup_id'])\n        max_rup_length = f_for_sherifs[si]['max_length']\n        up_s_d = f_for_sherifs[si]['up_s_d']\n        lo_s_d = f_for_sherifs[si]['lo_s_d']\n        dip = f_for_sherifs[si]['dip']\n        oriented = f_for_sherifs[si]['oriented']\n        Domain = f_for_sherifs[si]['Domain']\n        shear_modulus = f_for_sherifs[si]['shear_modulus']\n        rake = f_for_sherifs[si]['rake']\n        sr_min = f_for_sherifs[si]['slip_rate_min']\n        sr_mean = f_for_sherifs[si]['slip_rate_moy']\n        sr_max = f_for_sherifs[si]['slip_rate_max']\n        model = f_for_sherifs[si]['model']\n        features.append(Feature(geometry=geom, properties={'si': si, 'nb_rup': nb_rup, 'max_rup_length': max_rup_length, 'up_s_d': up_s_d, 'lo_s_d': lo_s_d, 'dip': dip, 'oriented': oriented, 'Domain': Domain, 'shear_modulus': shear_modulus, 'rake': rake, 'sr_min': sr_min, 'sr_mean': sr_mean, 'sr_max': sr_max, 'model': model}))\n    feature_collection = FeatureCollection(features)\n    with open(f_name, 'w') as f:\n        dump(feature_collection, f)",
            "def write_section_json(f_for_sherifs, f_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    features = []\n    for si in range(len(f_for_sherifs)):\n        geom = []\n        for (lon_i, lat_i) in zip(f_for_sherifs[si]['lons'], f_for_sherifs[si]['lats']):\n            geom.append([lon_i, lat_i])\n        geom = LineString(geom)\n        nb_rup = len(f_for_sherifs[si]['rup_id'])\n        max_rup_length = f_for_sherifs[si]['max_length']\n        up_s_d = f_for_sherifs[si]['up_s_d']\n        lo_s_d = f_for_sherifs[si]['lo_s_d']\n        dip = f_for_sherifs[si]['dip']\n        oriented = f_for_sherifs[si]['oriented']\n        Domain = f_for_sherifs[si]['Domain']\n        shear_modulus = f_for_sherifs[si]['shear_modulus']\n        rake = f_for_sherifs[si]['rake']\n        sr_min = f_for_sherifs[si]['slip_rate_min']\n        sr_mean = f_for_sherifs[si]['slip_rate_moy']\n        sr_max = f_for_sherifs[si]['slip_rate_max']\n        model = f_for_sherifs[si]['model']\n        features.append(Feature(geometry=geom, properties={'si': si, 'nb_rup': nb_rup, 'max_rup_length': max_rup_length, 'up_s_d': up_s_d, 'lo_s_d': lo_s_d, 'dip': dip, 'oriented': oriented, 'Domain': Domain, 'shear_modulus': shear_modulus, 'rake': rake, 'sr_min': sr_min, 'sr_mean': sr_mean, 'sr_max': sr_max, 'model': model}))\n    feature_collection = FeatureCollection(features)\n    with open(f_name, 'w') as f:\n        dump(feature_collection, f)",
            "def write_section_json(f_for_sherifs, f_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    features = []\n    for si in range(len(f_for_sherifs)):\n        geom = []\n        for (lon_i, lat_i) in zip(f_for_sherifs[si]['lons'], f_for_sherifs[si]['lats']):\n            geom.append([lon_i, lat_i])\n        geom = LineString(geom)\n        nb_rup = len(f_for_sherifs[si]['rup_id'])\n        max_rup_length = f_for_sherifs[si]['max_length']\n        up_s_d = f_for_sherifs[si]['up_s_d']\n        lo_s_d = f_for_sherifs[si]['lo_s_d']\n        dip = f_for_sherifs[si]['dip']\n        oriented = f_for_sherifs[si]['oriented']\n        Domain = f_for_sherifs[si]['Domain']\n        shear_modulus = f_for_sherifs[si]['shear_modulus']\n        rake = f_for_sherifs[si]['rake']\n        sr_min = f_for_sherifs[si]['slip_rate_min']\n        sr_mean = f_for_sherifs[si]['slip_rate_moy']\n        sr_max = f_for_sherifs[si]['slip_rate_max']\n        model = f_for_sherifs[si]['model']\n        features.append(Feature(geometry=geom, properties={'si': si, 'nb_rup': nb_rup, 'max_rup_length': max_rup_length, 'up_s_d': up_s_d, 'lo_s_d': lo_s_d, 'dip': dip, 'oriented': oriented, 'Domain': Domain, 'shear_modulus': shear_modulus, 'rake': rake, 'sr_min': sr_min, 'sr_mean': sr_mean, 'sr_max': sr_max, 'model': model}))\n    feature_collection = FeatureCollection(features)\n    with open(f_name, 'w') as f:\n        dump(feature_collection, f)",
            "def write_section_json(f_for_sherifs, f_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    features = []\n    for si in range(len(f_for_sherifs)):\n        geom = []\n        for (lon_i, lat_i) in zip(f_for_sherifs[si]['lons'], f_for_sherifs[si]['lats']):\n            geom.append([lon_i, lat_i])\n        geom = LineString(geom)\n        nb_rup = len(f_for_sherifs[si]['rup_id'])\n        max_rup_length = f_for_sherifs[si]['max_length']\n        up_s_d = f_for_sherifs[si]['up_s_d']\n        lo_s_d = f_for_sherifs[si]['lo_s_d']\n        dip = f_for_sherifs[si]['dip']\n        oriented = f_for_sherifs[si]['oriented']\n        Domain = f_for_sherifs[si]['Domain']\n        shear_modulus = f_for_sherifs[si]['shear_modulus']\n        rake = f_for_sherifs[si]['rake']\n        sr_min = f_for_sherifs[si]['slip_rate_min']\n        sr_mean = f_for_sherifs[si]['slip_rate_moy']\n        sr_max = f_for_sherifs[si]['slip_rate_max']\n        model = f_for_sherifs[si]['model']\n        features.append(Feature(geometry=geom, properties={'si': si, 'nb_rup': nb_rup, 'max_rup_length': max_rup_length, 'up_s_d': up_s_d, 'lo_s_d': lo_s_d, 'dip': dip, 'oriented': oriented, 'Domain': Domain, 'shear_modulus': shear_modulus, 'rake': rake, 'sr_min': sr_min, 'sr_mean': sr_mean, 'sr_max': sr_max, 'model': model}))\n    feature_collection = FeatureCollection(features)\n    with open(f_name, 'w') as f:\n        dump(feature_collection, f)",
            "def write_section_json(f_for_sherifs, f_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    features = []\n    for si in range(len(f_for_sherifs)):\n        geom = []\n        for (lon_i, lat_i) in zip(f_for_sherifs[si]['lons'], f_for_sherifs[si]['lats']):\n            geom.append([lon_i, lat_i])\n        geom = LineString(geom)\n        nb_rup = len(f_for_sherifs[si]['rup_id'])\n        max_rup_length = f_for_sherifs[si]['max_length']\n        up_s_d = f_for_sherifs[si]['up_s_d']\n        lo_s_d = f_for_sherifs[si]['lo_s_d']\n        dip = f_for_sherifs[si]['dip']\n        oriented = f_for_sherifs[si]['oriented']\n        Domain = f_for_sherifs[si]['Domain']\n        shear_modulus = f_for_sherifs[si]['shear_modulus']\n        rake = f_for_sherifs[si]['rake']\n        sr_min = f_for_sherifs[si]['slip_rate_min']\n        sr_mean = f_for_sherifs[si]['slip_rate_moy']\n        sr_max = f_for_sherifs[si]['slip_rate_max']\n        model = f_for_sherifs[si]['model']\n        features.append(Feature(geometry=geom, properties={'si': si, 'nb_rup': nb_rup, 'max_rup_length': max_rup_length, 'up_s_d': up_s_d, 'lo_s_d': lo_s_d, 'dip': dip, 'oriented': oriented, 'Domain': Domain, 'shear_modulus': shear_modulus, 'rake': rake, 'sr_min': sr_min, 'sr_mean': sr_mean, 'sr_max': sr_max, 'model': model}))\n    feature_collection = FeatureCollection(features)\n    with open(f_name, 'w') as f:\n        dump(feature_collection, f)"
        ]
    }
]