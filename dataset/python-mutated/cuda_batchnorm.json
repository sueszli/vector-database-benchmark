[
    {
        "func_name": "_get_bn_fprop_kernel",
        "original": "@context_dependent_memoize\ndef _get_bn_fprop_kernel(dtype, threads, compute_capability):\n    if threads > 32:\n        shr_code = '__shared__ float sPartials[THREADS];'\n        red_code = '\\n    sPartials[tid] = xvar;\\n    __syncthreads();\\n\\n    #pragma unroll\\n    for (int a = THREADS >> 1; a > 32; a >>= 1)\\n    {\\n        if ( tid < a )\\n            sPartials[tid] += sPartials[tid + a];\\n        __syncthreads();\\n    }\\n    if ( tid < 32 )\\n    {\\n        xvar = sPartials[tid] + sPartials[tid + 32];\\n        #pragma unroll\\n        for (int i = 16; i > 0; i >>= 1)\\n            xvar += __shfl_xor(xvar, i);\\n\\n        sPartials[tid] = xvar * rcpN;\\n    }\\n    __syncthreads();\\n    xvar = sPartials[0];\\n'\n    else:\n        shr_code = ''\n        red_code = '\\n    #pragma unroll\\n    for (int i = 16; i > 0; i >>= 1)\\n        xvar += __shfl_xor(xvar, i);\\n    xvar *= rcpN;\\n'\n    code = '\\n#define THREADS %(threads)s\\n\\n%(common)s\\n%(binary)s\\n\\n__global__ void batchnorm_fprop (\\n    %(type)s* y_out, float* xvar_out, float* gmean_out, float* gvar_out,\\n    const %(type)s* x_in, const float* xsum_in, const float* gmean_in,\\n    const float* gvar_in, const float* gamma_in, const float* beta_in,\\n    const float eps, const float rho, const float accumbeta, const int N,\\n    const int relu, bool binary)\\n{\\n    %(share)s\\n\\n    const int tid  = threadIdx.x;\\n    const int bid  = blockIdx.x;\\n    int offset = bid * N;\\n\\n    const %(type)s* x_in0 = x_in + offset + tid;\\n\\n    const float rcpN = 1.0f/(float)N;\\n\\n    float xmean = __ldg(xsum_in + bid) * rcpN;\\n\\n    float xvar = 0.0f;\\n    for (int i = tid; i < N; i += THREADS)\\n    {\\n        float x = %(cvt)s(__ldg(x_in0));\\n        x_in0 += THREADS;\\n\\n        x -= xmean;\\n        if (binary) {\\n            xvar += shift_element(x, x, true);\\n        } else {\\n            xvar += x * x;\\n        }\\n    }\\n    %(red)s\\n\\n    float gamma = __ldg(gamma_in + bid);\\n    float beta  = __ldg(beta_in  + bid);\\n\\n    if ( tid == 0 )\\n    {\\n        float gmean = __ldg(gmean_in + bid);\\n        float gvar  = __ldg(gvar_in  + bid);\\n\\n        *(xvar_out  + bid) = xvar;\\n        *(gmean_out + bid) = gmean * rho + (1.0f - rho) * xmean;\\n        *(gvar_out  + bid) = gvar  * rho + (1.0f - rho) * xvar;\\n    }\\n\\n    float xvar_rcp_sqrt = 1.0f / sqrtf(xvar + eps);\\n\\n    int start = N - (THREADS*4 - tid);\\n    offset += start;\\n    x_in   += offset;\\n    y_out  += offset;\\n\\n    for (int i = start; i >= -THREADS*3; i -= THREADS*4)\\n    {\\n        float x0 = i >= -THREADS*0 ? %(cvt)s(__ldg(x_in + THREADS*0)) : 0.0f;\\n        float x1 = i >= -THREADS*1 ? %(cvt)s(__ldg(x_in + THREADS*1)) : 0.0f;\\n        float x2 = i >= -THREADS*2 ? %(cvt)s(__ldg(x_in + THREADS*2)) : 0.0f;\\n        float x3 =                   %(cvt)s(__ldg(x_in + THREADS*3));\\n\\n        x_in -= THREADS*4;\\n\\n        float xhat0 = 0.0f;\\n        float xhat1 = 0.0f;\\n        float xhat2 = 0.0f;\\n        float xhat3 = 0.0f;\\n\\n        float y0 = 0.0f;\\n        float y1 = 0.0f;\\n        float y2 = 0.0f;\\n        float y3 = 0.0f;\\n        if (binary) {\\n            xhat0 = shift_element(x0 - xmean, xvar_rcp_sqrt, true);\\n            xhat1 = shift_element(x1 - xmean, xvar_rcp_sqrt, true);\\n            xhat2 = shift_element(x2 - xmean, xvar_rcp_sqrt, true);\\n            xhat3 = shift_element(x3 - xmean, xvar_rcp_sqrt, true);\\n\\n            y0 = shift_element(xhat0, gamma, true) + beta;\\n            y1 = shift_element(xhat1, gamma, true) + beta;\\n            y2 = shift_element(xhat2, gamma, true) + beta;\\n            y3 = shift_element(xhat3, gamma, true) + beta;\\n        } else {\\n            xhat0 = (x0 - xmean) * xvar_rcp_sqrt;\\n            xhat1 = (x1 - xmean) * xvar_rcp_sqrt;\\n            xhat2 = (x2 - xmean) * xvar_rcp_sqrt;\\n            xhat3 = (x3 - xmean) * xvar_rcp_sqrt;\\n\\n            y0 = xhat0 * gamma + beta;\\n            y1 = xhat1 * gamma + beta;\\n            y2 = xhat2 * gamma + beta;\\n            y3 = xhat3 * gamma + beta;\\n        }\\n\\n        if (relu)\\n        {\\n            y0 = fmaxf(y0, 0.0f);\\n            y1 = fmaxf(y1, 0.0f);\\n            y2 = fmaxf(y2, 0.0f);\\n            y3 = fmaxf(y3, 0.0f);\\n        }\\n\\n        %(y0_out)s\\n        %(y1_out)s\\n        %(y2_out)s\\n        %(y3_out)s\\n        if (accumbeta == 0.0)\\n        {\\n            if (i >= -THREADS*0) *(y_out + THREADS*0) = y0_val;\\n            if (i >= -THREADS*1) *(y_out + THREADS*1) = y1_val;\\n            if (i >= -THREADS*2) *(y_out + THREADS*2) = y2_val;\\n                                 *(y_out + THREADS*3) = y3_val;\\n        }\\n        else\\n        {\\n            if (i >= -THREADS*0) *(y_out + THREADS*0) = y_out[THREADS*0] * accumbeta + y0_val;\\n            if (i >= -THREADS*1) *(y_out + THREADS*1) = y_out[THREADS*1] * accumbeta + y1_val;\\n            if (i >= -THREADS*2) *(y_out + THREADS*2) = y_out[THREADS*2] * accumbeta + y2_val;\\n                                 *(y_out + THREADS*3) = y_out[THREADS*3] * accumbeta + y3_val;\\n        }\\n        y_out -= THREADS*4;\\n    }\\n}\\n'\n    out_code = _ew_strings['round']['nearest'].get(dtype, 'float {0} = {1};')\n    common_code = _common_round['nearest'].get(dtype, '')\n    if dtype == 'f2':\n        common_code += _common_fp16_to_fp32\n    if compute_capability[0] == 3 and compute_capability[1] < 5 or compute_capability[0] < 3:\n        common_code += _common_kepler\n    code = code % {'common': common_code, 'binary': shift_element(), 'share': shr_code, 'red': red_code, 'threads': threads, 'type': _ew_types[dtype]['type'], 'cvt': _ew_types[dtype]['cvt'], 'y0_out': out_code.format('y0_val', 'y0'), 'y1_out': out_code.format('y1_val', 'y1'), 'y2_out': out_code.format('y2_val', 'y2'), 'y3_out': out_code.format('y3_val', 'y3')}\n    module = SourceModule(code, options=['--use_fast_math'])\n    kernel = module.get_function('batchnorm_fprop')\n    kernel.prepare('PPPPPPPPPPfffIII')\n    kernel.name = 'batchnorm_fprop'\n    return kernel",
        "mutated": [
            "@context_dependent_memoize\ndef _get_bn_fprop_kernel(dtype, threads, compute_capability):\n    if False:\n        i = 10\n    if threads > 32:\n        shr_code = '__shared__ float sPartials[THREADS];'\n        red_code = '\\n    sPartials[tid] = xvar;\\n    __syncthreads();\\n\\n    #pragma unroll\\n    for (int a = THREADS >> 1; a > 32; a >>= 1)\\n    {\\n        if ( tid < a )\\n            sPartials[tid] += sPartials[tid + a];\\n        __syncthreads();\\n    }\\n    if ( tid < 32 )\\n    {\\n        xvar = sPartials[tid] + sPartials[tid + 32];\\n        #pragma unroll\\n        for (int i = 16; i > 0; i >>= 1)\\n            xvar += __shfl_xor(xvar, i);\\n\\n        sPartials[tid] = xvar * rcpN;\\n    }\\n    __syncthreads();\\n    xvar = sPartials[0];\\n'\n    else:\n        shr_code = ''\n        red_code = '\\n    #pragma unroll\\n    for (int i = 16; i > 0; i >>= 1)\\n        xvar += __shfl_xor(xvar, i);\\n    xvar *= rcpN;\\n'\n    code = '\\n#define THREADS %(threads)s\\n\\n%(common)s\\n%(binary)s\\n\\n__global__ void batchnorm_fprop (\\n    %(type)s* y_out, float* xvar_out, float* gmean_out, float* gvar_out,\\n    const %(type)s* x_in, const float* xsum_in, const float* gmean_in,\\n    const float* gvar_in, const float* gamma_in, const float* beta_in,\\n    const float eps, const float rho, const float accumbeta, const int N,\\n    const int relu, bool binary)\\n{\\n    %(share)s\\n\\n    const int tid  = threadIdx.x;\\n    const int bid  = blockIdx.x;\\n    int offset = bid * N;\\n\\n    const %(type)s* x_in0 = x_in + offset + tid;\\n\\n    const float rcpN = 1.0f/(float)N;\\n\\n    float xmean = __ldg(xsum_in + bid) * rcpN;\\n\\n    float xvar = 0.0f;\\n    for (int i = tid; i < N; i += THREADS)\\n    {\\n        float x = %(cvt)s(__ldg(x_in0));\\n        x_in0 += THREADS;\\n\\n        x -= xmean;\\n        if (binary) {\\n            xvar += shift_element(x, x, true);\\n        } else {\\n            xvar += x * x;\\n        }\\n    }\\n    %(red)s\\n\\n    float gamma = __ldg(gamma_in + bid);\\n    float beta  = __ldg(beta_in  + bid);\\n\\n    if ( tid == 0 )\\n    {\\n        float gmean = __ldg(gmean_in + bid);\\n        float gvar  = __ldg(gvar_in  + bid);\\n\\n        *(xvar_out  + bid) = xvar;\\n        *(gmean_out + bid) = gmean * rho + (1.0f - rho) * xmean;\\n        *(gvar_out  + bid) = gvar  * rho + (1.0f - rho) * xvar;\\n    }\\n\\n    float xvar_rcp_sqrt = 1.0f / sqrtf(xvar + eps);\\n\\n    int start = N - (THREADS*4 - tid);\\n    offset += start;\\n    x_in   += offset;\\n    y_out  += offset;\\n\\n    for (int i = start; i >= -THREADS*3; i -= THREADS*4)\\n    {\\n        float x0 = i >= -THREADS*0 ? %(cvt)s(__ldg(x_in + THREADS*0)) : 0.0f;\\n        float x1 = i >= -THREADS*1 ? %(cvt)s(__ldg(x_in + THREADS*1)) : 0.0f;\\n        float x2 = i >= -THREADS*2 ? %(cvt)s(__ldg(x_in + THREADS*2)) : 0.0f;\\n        float x3 =                   %(cvt)s(__ldg(x_in + THREADS*3));\\n\\n        x_in -= THREADS*4;\\n\\n        float xhat0 = 0.0f;\\n        float xhat1 = 0.0f;\\n        float xhat2 = 0.0f;\\n        float xhat3 = 0.0f;\\n\\n        float y0 = 0.0f;\\n        float y1 = 0.0f;\\n        float y2 = 0.0f;\\n        float y3 = 0.0f;\\n        if (binary) {\\n            xhat0 = shift_element(x0 - xmean, xvar_rcp_sqrt, true);\\n            xhat1 = shift_element(x1 - xmean, xvar_rcp_sqrt, true);\\n            xhat2 = shift_element(x2 - xmean, xvar_rcp_sqrt, true);\\n            xhat3 = shift_element(x3 - xmean, xvar_rcp_sqrt, true);\\n\\n            y0 = shift_element(xhat0, gamma, true) + beta;\\n            y1 = shift_element(xhat1, gamma, true) + beta;\\n            y2 = shift_element(xhat2, gamma, true) + beta;\\n            y3 = shift_element(xhat3, gamma, true) + beta;\\n        } else {\\n            xhat0 = (x0 - xmean) * xvar_rcp_sqrt;\\n            xhat1 = (x1 - xmean) * xvar_rcp_sqrt;\\n            xhat2 = (x2 - xmean) * xvar_rcp_sqrt;\\n            xhat3 = (x3 - xmean) * xvar_rcp_sqrt;\\n\\n            y0 = xhat0 * gamma + beta;\\n            y1 = xhat1 * gamma + beta;\\n            y2 = xhat2 * gamma + beta;\\n            y3 = xhat3 * gamma + beta;\\n        }\\n\\n        if (relu)\\n        {\\n            y0 = fmaxf(y0, 0.0f);\\n            y1 = fmaxf(y1, 0.0f);\\n            y2 = fmaxf(y2, 0.0f);\\n            y3 = fmaxf(y3, 0.0f);\\n        }\\n\\n        %(y0_out)s\\n        %(y1_out)s\\n        %(y2_out)s\\n        %(y3_out)s\\n        if (accumbeta == 0.0)\\n        {\\n            if (i >= -THREADS*0) *(y_out + THREADS*0) = y0_val;\\n            if (i >= -THREADS*1) *(y_out + THREADS*1) = y1_val;\\n            if (i >= -THREADS*2) *(y_out + THREADS*2) = y2_val;\\n                                 *(y_out + THREADS*3) = y3_val;\\n        }\\n        else\\n        {\\n            if (i >= -THREADS*0) *(y_out + THREADS*0) = y_out[THREADS*0] * accumbeta + y0_val;\\n            if (i >= -THREADS*1) *(y_out + THREADS*1) = y_out[THREADS*1] * accumbeta + y1_val;\\n            if (i >= -THREADS*2) *(y_out + THREADS*2) = y_out[THREADS*2] * accumbeta + y2_val;\\n                                 *(y_out + THREADS*3) = y_out[THREADS*3] * accumbeta + y3_val;\\n        }\\n        y_out -= THREADS*4;\\n    }\\n}\\n'\n    out_code = _ew_strings['round']['nearest'].get(dtype, 'float {0} = {1};')\n    common_code = _common_round['nearest'].get(dtype, '')\n    if dtype == 'f2':\n        common_code += _common_fp16_to_fp32\n    if compute_capability[0] == 3 and compute_capability[1] < 5 or compute_capability[0] < 3:\n        common_code += _common_kepler\n    code = code % {'common': common_code, 'binary': shift_element(), 'share': shr_code, 'red': red_code, 'threads': threads, 'type': _ew_types[dtype]['type'], 'cvt': _ew_types[dtype]['cvt'], 'y0_out': out_code.format('y0_val', 'y0'), 'y1_out': out_code.format('y1_val', 'y1'), 'y2_out': out_code.format('y2_val', 'y2'), 'y3_out': out_code.format('y3_val', 'y3')}\n    module = SourceModule(code, options=['--use_fast_math'])\n    kernel = module.get_function('batchnorm_fprop')\n    kernel.prepare('PPPPPPPPPPfffIII')\n    kernel.name = 'batchnorm_fprop'\n    return kernel",
            "@context_dependent_memoize\ndef _get_bn_fprop_kernel(dtype, threads, compute_capability):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if threads > 32:\n        shr_code = '__shared__ float sPartials[THREADS];'\n        red_code = '\\n    sPartials[tid] = xvar;\\n    __syncthreads();\\n\\n    #pragma unroll\\n    for (int a = THREADS >> 1; a > 32; a >>= 1)\\n    {\\n        if ( tid < a )\\n            sPartials[tid] += sPartials[tid + a];\\n        __syncthreads();\\n    }\\n    if ( tid < 32 )\\n    {\\n        xvar = sPartials[tid] + sPartials[tid + 32];\\n        #pragma unroll\\n        for (int i = 16; i > 0; i >>= 1)\\n            xvar += __shfl_xor(xvar, i);\\n\\n        sPartials[tid] = xvar * rcpN;\\n    }\\n    __syncthreads();\\n    xvar = sPartials[0];\\n'\n    else:\n        shr_code = ''\n        red_code = '\\n    #pragma unroll\\n    for (int i = 16; i > 0; i >>= 1)\\n        xvar += __shfl_xor(xvar, i);\\n    xvar *= rcpN;\\n'\n    code = '\\n#define THREADS %(threads)s\\n\\n%(common)s\\n%(binary)s\\n\\n__global__ void batchnorm_fprop (\\n    %(type)s* y_out, float* xvar_out, float* gmean_out, float* gvar_out,\\n    const %(type)s* x_in, const float* xsum_in, const float* gmean_in,\\n    const float* gvar_in, const float* gamma_in, const float* beta_in,\\n    const float eps, const float rho, const float accumbeta, const int N,\\n    const int relu, bool binary)\\n{\\n    %(share)s\\n\\n    const int tid  = threadIdx.x;\\n    const int bid  = blockIdx.x;\\n    int offset = bid * N;\\n\\n    const %(type)s* x_in0 = x_in + offset + tid;\\n\\n    const float rcpN = 1.0f/(float)N;\\n\\n    float xmean = __ldg(xsum_in + bid) * rcpN;\\n\\n    float xvar = 0.0f;\\n    for (int i = tid; i < N; i += THREADS)\\n    {\\n        float x = %(cvt)s(__ldg(x_in0));\\n        x_in0 += THREADS;\\n\\n        x -= xmean;\\n        if (binary) {\\n            xvar += shift_element(x, x, true);\\n        } else {\\n            xvar += x * x;\\n        }\\n    }\\n    %(red)s\\n\\n    float gamma = __ldg(gamma_in + bid);\\n    float beta  = __ldg(beta_in  + bid);\\n\\n    if ( tid == 0 )\\n    {\\n        float gmean = __ldg(gmean_in + bid);\\n        float gvar  = __ldg(gvar_in  + bid);\\n\\n        *(xvar_out  + bid) = xvar;\\n        *(gmean_out + bid) = gmean * rho + (1.0f - rho) * xmean;\\n        *(gvar_out  + bid) = gvar  * rho + (1.0f - rho) * xvar;\\n    }\\n\\n    float xvar_rcp_sqrt = 1.0f / sqrtf(xvar + eps);\\n\\n    int start = N - (THREADS*4 - tid);\\n    offset += start;\\n    x_in   += offset;\\n    y_out  += offset;\\n\\n    for (int i = start; i >= -THREADS*3; i -= THREADS*4)\\n    {\\n        float x0 = i >= -THREADS*0 ? %(cvt)s(__ldg(x_in + THREADS*0)) : 0.0f;\\n        float x1 = i >= -THREADS*1 ? %(cvt)s(__ldg(x_in + THREADS*1)) : 0.0f;\\n        float x2 = i >= -THREADS*2 ? %(cvt)s(__ldg(x_in + THREADS*2)) : 0.0f;\\n        float x3 =                   %(cvt)s(__ldg(x_in + THREADS*3));\\n\\n        x_in -= THREADS*4;\\n\\n        float xhat0 = 0.0f;\\n        float xhat1 = 0.0f;\\n        float xhat2 = 0.0f;\\n        float xhat3 = 0.0f;\\n\\n        float y0 = 0.0f;\\n        float y1 = 0.0f;\\n        float y2 = 0.0f;\\n        float y3 = 0.0f;\\n        if (binary) {\\n            xhat0 = shift_element(x0 - xmean, xvar_rcp_sqrt, true);\\n            xhat1 = shift_element(x1 - xmean, xvar_rcp_sqrt, true);\\n            xhat2 = shift_element(x2 - xmean, xvar_rcp_sqrt, true);\\n            xhat3 = shift_element(x3 - xmean, xvar_rcp_sqrt, true);\\n\\n            y0 = shift_element(xhat0, gamma, true) + beta;\\n            y1 = shift_element(xhat1, gamma, true) + beta;\\n            y2 = shift_element(xhat2, gamma, true) + beta;\\n            y3 = shift_element(xhat3, gamma, true) + beta;\\n        } else {\\n            xhat0 = (x0 - xmean) * xvar_rcp_sqrt;\\n            xhat1 = (x1 - xmean) * xvar_rcp_sqrt;\\n            xhat2 = (x2 - xmean) * xvar_rcp_sqrt;\\n            xhat3 = (x3 - xmean) * xvar_rcp_sqrt;\\n\\n            y0 = xhat0 * gamma + beta;\\n            y1 = xhat1 * gamma + beta;\\n            y2 = xhat2 * gamma + beta;\\n            y3 = xhat3 * gamma + beta;\\n        }\\n\\n        if (relu)\\n        {\\n            y0 = fmaxf(y0, 0.0f);\\n            y1 = fmaxf(y1, 0.0f);\\n            y2 = fmaxf(y2, 0.0f);\\n            y3 = fmaxf(y3, 0.0f);\\n        }\\n\\n        %(y0_out)s\\n        %(y1_out)s\\n        %(y2_out)s\\n        %(y3_out)s\\n        if (accumbeta == 0.0)\\n        {\\n            if (i >= -THREADS*0) *(y_out + THREADS*0) = y0_val;\\n            if (i >= -THREADS*1) *(y_out + THREADS*1) = y1_val;\\n            if (i >= -THREADS*2) *(y_out + THREADS*2) = y2_val;\\n                                 *(y_out + THREADS*3) = y3_val;\\n        }\\n        else\\n        {\\n            if (i >= -THREADS*0) *(y_out + THREADS*0) = y_out[THREADS*0] * accumbeta + y0_val;\\n            if (i >= -THREADS*1) *(y_out + THREADS*1) = y_out[THREADS*1] * accumbeta + y1_val;\\n            if (i >= -THREADS*2) *(y_out + THREADS*2) = y_out[THREADS*2] * accumbeta + y2_val;\\n                                 *(y_out + THREADS*3) = y_out[THREADS*3] * accumbeta + y3_val;\\n        }\\n        y_out -= THREADS*4;\\n    }\\n}\\n'\n    out_code = _ew_strings['round']['nearest'].get(dtype, 'float {0} = {1};')\n    common_code = _common_round['nearest'].get(dtype, '')\n    if dtype == 'f2':\n        common_code += _common_fp16_to_fp32\n    if compute_capability[0] == 3 and compute_capability[1] < 5 or compute_capability[0] < 3:\n        common_code += _common_kepler\n    code = code % {'common': common_code, 'binary': shift_element(), 'share': shr_code, 'red': red_code, 'threads': threads, 'type': _ew_types[dtype]['type'], 'cvt': _ew_types[dtype]['cvt'], 'y0_out': out_code.format('y0_val', 'y0'), 'y1_out': out_code.format('y1_val', 'y1'), 'y2_out': out_code.format('y2_val', 'y2'), 'y3_out': out_code.format('y3_val', 'y3')}\n    module = SourceModule(code, options=['--use_fast_math'])\n    kernel = module.get_function('batchnorm_fprop')\n    kernel.prepare('PPPPPPPPPPfffIII')\n    kernel.name = 'batchnorm_fprop'\n    return kernel",
            "@context_dependent_memoize\ndef _get_bn_fprop_kernel(dtype, threads, compute_capability):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if threads > 32:\n        shr_code = '__shared__ float sPartials[THREADS];'\n        red_code = '\\n    sPartials[tid] = xvar;\\n    __syncthreads();\\n\\n    #pragma unroll\\n    for (int a = THREADS >> 1; a > 32; a >>= 1)\\n    {\\n        if ( tid < a )\\n            sPartials[tid] += sPartials[tid + a];\\n        __syncthreads();\\n    }\\n    if ( tid < 32 )\\n    {\\n        xvar = sPartials[tid] + sPartials[tid + 32];\\n        #pragma unroll\\n        for (int i = 16; i > 0; i >>= 1)\\n            xvar += __shfl_xor(xvar, i);\\n\\n        sPartials[tid] = xvar * rcpN;\\n    }\\n    __syncthreads();\\n    xvar = sPartials[0];\\n'\n    else:\n        shr_code = ''\n        red_code = '\\n    #pragma unroll\\n    for (int i = 16; i > 0; i >>= 1)\\n        xvar += __shfl_xor(xvar, i);\\n    xvar *= rcpN;\\n'\n    code = '\\n#define THREADS %(threads)s\\n\\n%(common)s\\n%(binary)s\\n\\n__global__ void batchnorm_fprop (\\n    %(type)s* y_out, float* xvar_out, float* gmean_out, float* gvar_out,\\n    const %(type)s* x_in, const float* xsum_in, const float* gmean_in,\\n    const float* gvar_in, const float* gamma_in, const float* beta_in,\\n    const float eps, const float rho, const float accumbeta, const int N,\\n    const int relu, bool binary)\\n{\\n    %(share)s\\n\\n    const int tid  = threadIdx.x;\\n    const int bid  = blockIdx.x;\\n    int offset = bid * N;\\n\\n    const %(type)s* x_in0 = x_in + offset + tid;\\n\\n    const float rcpN = 1.0f/(float)N;\\n\\n    float xmean = __ldg(xsum_in + bid) * rcpN;\\n\\n    float xvar = 0.0f;\\n    for (int i = tid; i < N; i += THREADS)\\n    {\\n        float x = %(cvt)s(__ldg(x_in0));\\n        x_in0 += THREADS;\\n\\n        x -= xmean;\\n        if (binary) {\\n            xvar += shift_element(x, x, true);\\n        } else {\\n            xvar += x * x;\\n        }\\n    }\\n    %(red)s\\n\\n    float gamma = __ldg(gamma_in + bid);\\n    float beta  = __ldg(beta_in  + bid);\\n\\n    if ( tid == 0 )\\n    {\\n        float gmean = __ldg(gmean_in + bid);\\n        float gvar  = __ldg(gvar_in  + bid);\\n\\n        *(xvar_out  + bid) = xvar;\\n        *(gmean_out + bid) = gmean * rho + (1.0f - rho) * xmean;\\n        *(gvar_out  + bid) = gvar  * rho + (1.0f - rho) * xvar;\\n    }\\n\\n    float xvar_rcp_sqrt = 1.0f / sqrtf(xvar + eps);\\n\\n    int start = N - (THREADS*4 - tid);\\n    offset += start;\\n    x_in   += offset;\\n    y_out  += offset;\\n\\n    for (int i = start; i >= -THREADS*3; i -= THREADS*4)\\n    {\\n        float x0 = i >= -THREADS*0 ? %(cvt)s(__ldg(x_in + THREADS*0)) : 0.0f;\\n        float x1 = i >= -THREADS*1 ? %(cvt)s(__ldg(x_in + THREADS*1)) : 0.0f;\\n        float x2 = i >= -THREADS*2 ? %(cvt)s(__ldg(x_in + THREADS*2)) : 0.0f;\\n        float x3 =                   %(cvt)s(__ldg(x_in + THREADS*3));\\n\\n        x_in -= THREADS*4;\\n\\n        float xhat0 = 0.0f;\\n        float xhat1 = 0.0f;\\n        float xhat2 = 0.0f;\\n        float xhat3 = 0.0f;\\n\\n        float y0 = 0.0f;\\n        float y1 = 0.0f;\\n        float y2 = 0.0f;\\n        float y3 = 0.0f;\\n        if (binary) {\\n            xhat0 = shift_element(x0 - xmean, xvar_rcp_sqrt, true);\\n            xhat1 = shift_element(x1 - xmean, xvar_rcp_sqrt, true);\\n            xhat2 = shift_element(x2 - xmean, xvar_rcp_sqrt, true);\\n            xhat3 = shift_element(x3 - xmean, xvar_rcp_sqrt, true);\\n\\n            y0 = shift_element(xhat0, gamma, true) + beta;\\n            y1 = shift_element(xhat1, gamma, true) + beta;\\n            y2 = shift_element(xhat2, gamma, true) + beta;\\n            y3 = shift_element(xhat3, gamma, true) + beta;\\n        } else {\\n            xhat0 = (x0 - xmean) * xvar_rcp_sqrt;\\n            xhat1 = (x1 - xmean) * xvar_rcp_sqrt;\\n            xhat2 = (x2 - xmean) * xvar_rcp_sqrt;\\n            xhat3 = (x3 - xmean) * xvar_rcp_sqrt;\\n\\n            y0 = xhat0 * gamma + beta;\\n            y1 = xhat1 * gamma + beta;\\n            y2 = xhat2 * gamma + beta;\\n            y3 = xhat3 * gamma + beta;\\n        }\\n\\n        if (relu)\\n        {\\n            y0 = fmaxf(y0, 0.0f);\\n            y1 = fmaxf(y1, 0.0f);\\n            y2 = fmaxf(y2, 0.0f);\\n            y3 = fmaxf(y3, 0.0f);\\n        }\\n\\n        %(y0_out)s\\n        %(y1_out)s\\n        %(y2_out)s\\n        %(y3_out)s\\n        if (accumbeta == 0.0)\\n        {\\n            if (i >= -THREADS*0) *(y_out + THREADS*0) = y0_val;\\n            if (i >= -THREADS*1) *(y_out + THREADS*1) = y1_val;\\n            if (i >= -THREADS*2) *(y_out + THREADS*2) = y2_val;\\n                                 *(y_out + THREADS*3) = y3_val;\\n        }\\n        else\\n        {\\n            if (i >= -THREADS*0) *(y_out + THREADS*0) = y_out[THREADS*0] * accumbeta + y0_val;\\n            if (i >= -THREADS*1) *(y_out + THREADS*1) = y_out[THREADS*1] * accumbeta + y1_val;\\n            if (i >= -THREADS*2) *(y_out + THREADS*2) = y_out[THREADS*2] * accumbeta + y2_val;\\n                                 *(y_out + THREADS*3) = y_out[THREADS*3] * accumbeta + y3_val;\\n        }\\n        y_out -= THREADS*4;\\n    }\\n}\\n'\n    out_code = _ew_strings['round']['nearest'].get(dtype, 'float {0} = {1};')\n    common_code = _common_round['nearest'].get(dtype, '')\n    if dtype == 'f2':\n        common_code += _common_fp16_to_fp32\n    if compute_capability[0] == 3 and compute_capability[1] < 5 or compute_capability[0] < 3:\n        common_code += _common_kepler\n    code = code % {'common': common_code, 'binary': shift_element(), 'share': shr_code, 'red': red_code, 'threads': threads, 'type': _ew_types[dtype]['type'], 'cvt': _ew_types[dtype]['cvt'], 'y0_out': out_code.format('y0_val', 'y0'), 'y1_out': out_code.format('y1_val', 'y1'), 'y2_out': out_code.format('y2_val', 'y2'), 'y3_out': out_code.format('y3_val', 'y3')}\n    module = SourceModule(code, options=['--use_fast_math'])\n    kernel = module.get_function('batchnorm_fprop')\n    kernel.prepare('PPPPPPPPPPfffIII')\n    kernel.name = 'batchnorm_fprop'\n    return kernel",
            "@context_dependent_memoize\ndef _get_bn_fprop_kernel(dtype, threads, compute_capability):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if threads > 32:\n        shr_code = '__shared__ float sPartials[THREADS];'\n        red_code = '\\n    sPartials[tid] = xvar;\\n    __syncthreads();\\n\\n    #pragma unroll\\n    for (int a = THREADS >> 1; a > 32; a >>= 1)\\n    {\\n        if ( tid < a )\\n            sPartials[tid] += sPartials[tid + a];\\n        __syncthreads();\\n    }\\n    if ( tid < 32 )\\n    {\\n        xvar = sPartials[tid] + sPartials[tid + 32];\\n        #pragma unroll\\n        for (int i = 16; i > 0; i >>= 1)\\n            xvar += __shfl_xor(xvar, i);\\n\\n        sPartials[tid] = xvar * rcpN;\\n    }\\n    __syncthreads();\\n    xvar = sPartials[0];\\n'\n    else:\n        shr_code = ''\n        red_code = '\\n    #pragma unroll\\n    for (int i = 16; i > 0; i >>= 1)\\n        xvar += __shfl_xor(xvar, i);\\n    xvar *= rcpN;\\n'\n    code = '\\n#define THREADS %(threads)s\\n\\n%(common)s\\n%(binary)s\\n\\n__global__ void batchnorm_fprop (\\n    %(type)s* y_out, float* xvar_out, float* gmean_out, float* gvar_out,\\n    const %(type)s* x_in, const float* xsum_in, const float* gmean_in,\\n    const float* gvar_in, const float* gamma_in, const float* beta_in,\\n    const float eps, const float rho, const float accumbeta, const int N,\\n    const int relu, bool binary)\\n{\\n    %(share)s\\n\\n    const int tid  = threadIdx.x;\\n    const int bid  = blockIdx.x;\\n    int offset = bid * N;\\n\\n    const %(type)s* x_in0 = x_in + offset + tid;\\n\\n    const float rcpN = 1.0f/(float)N;\\n\\n    float xmean = __ldg(xsum_in + bid) * rcpN;\\n\\n    float xvar = 0.0f;\\n    for (int i = tid; i < N; i += THREADS)\\n    {\\n        float x = %(cvt)s(__ldg(x_in0));\\n        x_in0 += THREADS;\\n\\n        x -= xmean;\\n        if (binary) {\\n            xvar += shift_element(x, x, true);\\n        } else {\\n            xvar += x * x;\\n        }\\n    }\\n    %(red)s\\n\\n    float gamma = __ldg(gamma_in + bid);\\n    float beta  = __ldg(beta_in  + bid);\\n\\n    if ( tid == 0 )\\n    {\\n        float gmean = __ldg(gmean_in + bid);\\n        float gvar  = __ldg(gvar_in  + bid);\\n\\n        *(xvar_out  + bid) = xvar;\\n        *(gmean_out + bid) = gmean * rho + (1.0f - rho) * xmean;\\n        *(gvar_out  + bid) = gvar  * rho + (1.0f - rho) * xvar;\\n    }\\n\\n    float xvar_rcp_sqrt = 1.0f / sqrtf(xvar + eps);\\n\\n    int start = N - (THREADS*4 - tid);\\n    offset += start;\\n    x_in   += offset;\\n    y_out  += offset;\\n\\n    for (int i = start; i >= -THREADS*3; i -= THREADS*4)\\n    {\\n        float x0 = i >= -THREADS*0 ? %(cvt)s(__ldg(x_in + THREADS*0)) : 0.0f;\\n        float x1 = i >= -THREADS*1 ? %(cvt)s(__ldg(x_in + THREADS*1)) : 0.0f;\\n        float x2 = i >= -THREADS*2 ? %(cvt)s(__ldg(x_in + THREADS*2)) : 0.0f;\\n        float x3 =                   %(cvt)s(__ldg(x_in + THREADS*3));\\n\\n        x_in -= THREADS*4;\\n\\n        float xhat0 = 0.0f;\\n        float xhat1 = 0.0f;\\n        float xhat2 = 0.0f;\\n        float xhat3 = 0.0f;\\n\\n        float y0 = 0.0f;\\n        float y1 = 0.0f;\\n        float y2 = 0.0f;\\n        float y3 = 0.0f;\\n        if (binary) {\\n            xhat0 = shift_element(x0 - xmean, xvar_rcp_sqrt, true);\\n            xhat1 = shift_element(x1 - xmean, xvar_rcp_sqrt, true);\\n            xhat2 = shift_element(x2 - xmean, xvar_rcp_sqrt, true);\\n            xhat3 = shift_element(x3 - xmean, xvar_rcp_sqrt, true);\\n\\n            y0 = shift_element(xhat0, gamma, true) + beta;\\n            y1 = shift_element(xhat1, gamma, true) + beta;\\n            y2 = shift_element(xhat2, gamma, true) + beta;\\n            y3 = shift_element(xhat3, gamma, true) + beta;\\n        } else {\\n            xhat0 = (x0 - xmean) * xvar_rcp_sqrt;\\n            xhat1 = (x1 - xmean) * xvar_rcp_sqrt;\\n            xhat2 = (x2 - xmean) * xvar_rcp_sqrt;\\n            xhat3 = (x3 - xmean) * xvar_rcp_sqrt;\\n\\n            y0 = xhat0 * gamma + beta;\\n            y1 = xhat1 * gamma + beta;\\n            y2 = xhat2 * gamma + beta;\\n            y3 = xhat3 * gamma + beta;\\n        }\\n\\n        if (relu)\\n        {\\n            y0 = fmaxf(y0, 0.0f);\\n            y1 = fmaxf(y1, 0.0f);\\n            y2 = fmaxf(y2, 0.0f);\\n            y3 = fmaxf(y3, 0.0f);\\n        }\\n\\n        %(y0_out)s\\n        %(y1_out)s\\n        %(y2_out)s\\n        %(y3_out)s\\n        if (accumbeta == 0.0)\\n        {\\n            if (i >= -THREADS*0) *(y_out + THREADS*0) = y0_val;\\n            if (i >= -THREADS*1) *(y_out + THREADS*1) = y1_val;\\n            if (i >= -THREADS*2) *(y_out + THREADS*2) = y2_val;\\n                                 *(y_out + THREADS*3) = y3_val;\\n        }\\n        else\\n        {\\n            if (i >= -THREADS*0) *(y_out + THREADS*0) = y_out[THREADS*0] * accumbeta + y0_val;\\n            if (i >= -THREADS*1) *(y_out + THREADS*1) = y_out[THREADS*1] * accumbeta + y1_val;\\n            if (i >= -THREADS*2) *(y_out + THREADS*2) = y_out[THREADS*2] * accumbeta + y2_val;\\n                                 *(y_out + THREADS*3) = y_out[THREADS*3] * accumbeta + y3_val;\\n        }\\n        y_out -= THREADS*4;\\n    }\\n}\\n'\n    out_code = _ew_strings['round']['nearest'].get(dtype, 'float {0} = {1};')\n    common_code = _common_round['nearest'].get(dtype, '')\n    if dtype == 'f2':\n        common_code += _common_fp16_to_fp32\n    if compute_capability[0] == 3 and compute_capability[1] < 5 or compute_capability[0] < 3:\n        common_code += _common_kepler\n    code = code % {'common': common_code, 'binary': shift_element(), 'share': shr_code, 'red': red_code, 'threads': threads, 'type': _ew_types[dtype]['type'], 'cvt': _ew_types[dtype]['cvt'], 'y0_out': out_code.format('y0_val', 'y0'), 'y1_out': out_code.format('y1_val', 'y1'), 'y2_out': out_code.format('y2_val', 'y2'), 'y3_out': out_code.format('y3_val', 'y3')}\n    module = SourceModule(code, options=['--use_fast_math'])\n    kernel = module.get_function('batchnorm_fprop')\n    kernel.prepare('PPPPPPPPPPfffIII')\n    kernel.name = 'batchnorm_fprop'\n    return kernel",
            "@context_dependent_memoize\ndef _get_bn_fprop_kernel(dtype, threads, compute_capability):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if threads > 32:\n        shr_code = '__shared__ float sPartials[THREADS];'\n        red_code = '\\n    sPartials[tid] = xvar;\\n    __syncthreads();\\n\\n    #pragma unroll\\n    for (int a = THREADS >> 1; a > 32; a >>= 1)\\n    {\\n        if ( tid < a )\\n            sPartials[tid] += sPartials[tid + a];\\n        __syncthreads();\\n    }\\n    if ( tid < 32 )\\n    {\\n        xvar = sPartials[tid] + sPartials[tid + 32];\\n        #pragma unroll\\n        for (int i = 16; i > 0; i >>= 1)\\n            xvar += __shfl_xor(xvar, i);\\n\\n        sPartials[tid] = xvar * rcpN;\\n    }\\n    __syncthreads();\\n    xvar = sPartials[0];\\n'\n    else:\n        shr_code = ''\n        red_code = '\\n    #pragma unroll\\n    for (int i = 16; i > 0; i >>= 1)\\n        xvar += __shfl_xor(xvar, i);\\n    xvar *= rcpN;\\n'\n    code = '\\n#define THREADS %(threads)s\\n\\n%(common)s\\n%(binary)s\\n\\n__global__ void batchnorm_fprop (\\n    %(type)s* y_out, float* xvar_out, float* gmean_out, float* gvar_out,\\n    const %(type)s* x_in, const float* xsum_in, const float* gmean_in,\\n    const float* gvar_in, const float* gamma_in, const float* beta_in,\\n    const float eps, const float rho, const float accumbeta, const int N,\\n    const int relu, bool binary)\\n{\\n    %(share)s\\n\\n    const int tid  = threadIdx.x;\\n    const int bid  = blockIdx.x;\\n    int offset = bid * N;\\n\\n    const %(type)s* x_in0 = x_in + offset + tid;\\n\\n    const float rcpN = 1.0f/(float)N;\\n\\n    float xmean = __ldg(xsum_in + bid) * rcpN;\\n\\n    float xvar = 0.0f;\\n    for (int i = tid; i < N; i += THREADS)\\n    {\\n        float x = %(cvt)s(__ldg(x_in0));\\n        x_in0 += THREADS;\\n\\n        x -= xmean;\\n        if (binary) {\\n            xvar += shift_element(x, x, true);\\n        } else {\\n            xvar += x * x;\\n        }\\n    }\\n    %(red)s\\n\\n    float gamma = __ldg(gamma_in + bid);\\n    float beta  = __ldg(beta_in  + bid);\\n\\n    if ( tid == 0 )\\n    {\\n        float gmean = __ldg(gmean_in + bid);\\n        float gvar  = __ldg(gvar_in  + bid);\\n\\n        *(xvar_out  + bid) = xvar;\\n        *(gmean_out + bid) = gmean * rho + (1.0f - rho) * xmean;\\n        *(gvar_out  + bid) = gvar  * rho + (1.0f - rho) * xvar;\\n    }\\n\\n    float xvar_rcp_sqrt = 1.0f / sqrtf(xvar + eps);\\n\\n    int start = N - (THREADS*4 - tid);\\n    offset += start;\\n    x_in   += offset;\\n    y_out  += offset;\\n\\n    for (int i = start; i >= -THREADS*3; i -= THREADS*4)\\n    {\\n        float x0 = i >= -THREADS*0 ? %(cvt)s(__ldg(x_in + THREADS*0)) : 0.0f;\\n        float x1 = i >= -THREADS*1 ? %(cvt)s(__ldg(x_in + THREADS*1)) : 0.0f;\\n        float x2 = i >= -THREADS*2 ? %(cvt)s(__ldg(x_in + THREADS*2)) : 0.0f;\\n        float x3 =                   %(cvt)s(__ldg(x_in + THREADS*3));\\n\\n        x_in -= THREADS*4;\\n\\n        float xhat0 = 0.0f;\\n        float xhat1 = 0.0f;\\n        float xhat2 = 0.0f;\\n        float xhat3 = 0.0f;\\n\\n        float y0 = 0.0f;\\n        float y1 = 0.0f;\\n        float y2 = 0.0f;\\n        float y3 = 0.0f;\\n        if (binary) {\\n            xhat0 = shift_element(x0 - xmean, xvar_rcp_sqrt, true);\\n            xhat1 = shift_element(x1 - xmean, xvar_rcp_sqrt, true);\\n            xhat2 = shift_element(x2 - xmean, xvar_rcp_sqrt, true);\\n            xhat3 = shift_element(x3 - xmean, xvar_rcp_sqrt, true);\\n\\n            y0 = shift_element(xhat0, gamma, true) + beta;\\n            y1 = shift_element(xhat1, gamma, true) + beta;\\n            y2 = shift_element(xhat2, gamma, true) + beta;\\n            y3 = shift_element(xhat3, gamma, true) + beta;\\n        } else {\\n            xhat0 = (x0 - xmean) * xvar_rcp_sqrt;\\n            xhat1 = (x1 - xmean) * xvar_rcp_sqrt;\\n            xhat2 = (x2 - xmean) * xvar_rcp_sqrt;\\n            xhat3 = (x3 - xmean) * xvar_rcp_sqrt;\\n\\n            y0 = xhat0 * gamma + beta;\\n            y1 = xhat1 * gamma + beta;\\n            y2 = xhat2 * gamma + beta;\\n            y3 = xhat3 * gamma + beta;\\n        }\\n\\n        if (relu)\\n        {\\n            y0 = fmaxf(y0, 0.0f);\\n            y1 = fmaxf(y1, 0.0f);\\n            y2 = fmaxf(y2, 0.0f);\\n            y3 = fmaxf(y3, 0.0f);\\n        }\\n\\n        %(y0_out)s\\n        %(y1_out)s\\n        %(y2_out)s\\n        %(y3_out)s\\n        if (accumbeta == 0.0)\\n        {\\n            if (i >= -THREADS*0) *(y_out + THREADS*0) = y0_val;\\n            if (i >= -THREADS*1) *(y_out + THREADS*1) = y1_val;\\n            if (i >= -THREADS*2) *(y_out + THREADS*2) = y2_val;\\n                                 *(y_out + THREADS*3) = y3_val;\\n        }\\n        else\\n        {\\n            if (i >= -THREADS*0) *(y_out + THREADS*0) = y_out[THREADS*0] * accumbeta + y0_val;\\n            if (i >= -THREADS*1) *(y_out + THREADS*1) = y_out[THREADS*1] * accumbeta + y1_val;\\n            if (i >= -THREADS*2) *(y_out + THREADS*2) = y_out[THREADS*2] * accumbeta + y2_val;\\n                                 *(y_out + THREADS*3) = y_out[THREADS*3] * accumbeta + y3_val;\\n        }\\n        y_out -= THREADS*4;\\n    }\\n}\\n'\n    out_code = _ew_strings['round']['nearest'].get(dtype, 'float {0} = {1};')\n    common_code = _common_round['nearest'].get(dtype, '')\n    if dtype == 'f2':\n        common_code += _common_fp16_to_fp32\n    if compute_capability[0] == 3 and compute_capability[1] < 5 or compute_capability[0] < 3:\n        common_code += _common_kepler\n    code = code % {'common': common_code, 'binary': shift_element(), 'share': shr_code, 'red': red_code, 'threads': threads, 'type': _ew_types[dtype]['type'], 'cvt': _ew_types[dtype]['cvt'], 'y0_out': out_code.format('y0_val', 'y0'), 'y1_out': out_code.format('y1_val', 'y1'), 'y2_out': out_code.format('y2_val', 'y2'), 'y3_out': out_code.format('y3_val', 'y3')}\n    module = SourceModule(code, options=['--use_fast_math'])\n    kernel = module.get_function('batchnorm_fprop')\n    kernel.prepare('PPPPPPPPPPfffIII')\n    kernel.name = 'batchnorm_fprop'\n    return kernel"
        ]
    },
    {
        "func_name": "_get_bn_bprop_kernel",
        "original": "@context_dependent_memoize\ndef _get_bn_bprop_kernel(dtype, threads, compute_capability):\n    if threads > 32:\n        shr_code = '__shared__ float sPartials[THREADS * 2];'\n        red_code = '\\n    sPartials[tid + THREADS*0] = grad_gamma;\\n    sPartials[tid + THREADS*1] = grad_beta;\\n    __syncthreads();\\n\\n    #pragma unroll\\n    for (int a = THREADS >> 1; a > 32; a >>= 1)\\n    {\\n        if ( tid < a )\\n        {\\n            sPartials[tid + THREADS*0] += sPartials[tid + a + THREADS*0];\\n            sPartials[tid + THREADS*1] += sPartials[tid + a + THREADS*1];\\n        }\\n        __syncthreads();\\n    }\\n    if ( tid < 32 )\\n    {\\n        grad_gamma = sPartials[tid + THREADS*0] + sPartials[tid + 32 + THREADS*0];\\n        grad_beta  = sPartials[tid + THREADS*1] + sPartials[tid + 32 + THREADS*1];\\n\\n        #pragma unroll\\n        for (int i = 16; i > 0; i >>= 1)\\n        {\\n            grad_gamma += __shfl_xor(grad_gamma, i);\\n            grad_beta  += __shfl_xor(grad_beta,  i);\\n        }\\n        sPartials[tid + THREADS*0] = grad_gamma;\\n        sPartials[tid + THREADS*1] = grad_beta;\\n    }\\n    __syncthreads();\\n    grad_gamma = sPartials[THREADS*0];\\n    grad_beta  = sPartials[THREADS*1];\\n'\n    else:\n        shr_code = ''\n        red_code = '\\n    #pragma unroll\\n    for (int i = 16; i > 0; i >>= 1)\\n    {\\n        grad_gamma += __shfl_xor(grad_gamma, i);\\n        grad_beta  += __shfl_xor(grad_beta,  i);\\n    }\\n'\n    code = '\\n#define THREADS %(threads)s\\n\\n%(common)s\\n%(binary)s\\n\\n__global__ void batchnorm_bprop (\\n    %(type)s* delta_out, float* grad_gamma_out, float* grad_beta_out,\\n    const %(type)s* delta_in, const %(type)s* x_in, const float* xsum_in,\\n    const float* xvar_in, const float* gamma_in,\\n    const float eps, const int N, bool binary)\\n{\\n    %(share)s\\n\\n    const int tid  = threadIdx.x;\\n    const int bid  = blockIdx.x;\\n    const float rcpN = 1.0f/(float)N;\\n    int offset = bid * N;\\n\\n    const %(type)s* x_in0 = x_in     + offset + tid;\\n    const %(type)s* d_in0 = delta_in + offset + tid;\\n\\n    float xmean = __ldg(xsum_in  + bid) * rcpN;\\n    float xvar  = __ldg(xvar_in  + bid);\\n    float gamma = __ldg(gamma_in + bid);\\n\\n    float xvar_rcp_sqrt = 1.0f / sqrtf(xvar + eps);\\n    float grad_gamma    = 0.0f;\\n    float grad_beta     = 0.0f;\\n\\n    for (int i = tid; i < N; i += THREADS)\\n    {\\n        float x = %(cvt)s(__ldg(x_in0));\\n        x_in0 += THREADS;\\n        float d = %(cvt)s(__ldg(d_in0));\\n        d_in0 += THREADS;\\n\\n        float xhat = 0.0f;\\n        if (binary) {\\n            xhat = shift_element(x - xmean, xvar_rcp_sqrt, true);\\n        } else {\\n            xhat = (x - xmean) * xvar_rcp_sqrt;\\n        }\\n\\n        grad_gamma += xhat * d;\\n        grad_beta  += d;\\n    }\\n    %(red)s\\n\\n    if ( tid == 0 )\\n    {\\n        *(grad_gamma_out + bid) = grad_gamma;\\n        *(grad_beta_out  + bid) = grad_beta;\\n    }\\n\\n    int start = N - (THREADS*4 - tid);\\n    offset += start;\\n    const %(type)s* x_in1 = x_in     + offset;\\n    const %(type)s* d_in1 = delta_in + offset;\\n    delta_out += offset;\\n\\n    for (int i = start; i >= -THREADS*3; i -= THREADS*4)\\n    {\\n        float x0 = i >= -THREADS*0 ? %(cvt)s(__ldg(x_in1 + THREADS*0)) : 0.0f;\\n        float x1 = i >= -THREADS*1 ? %(cvt)s(__ldg(x_in1 + THREADS*1)) : 0.0f;\\n        float x2 = i >= -THREADS*2 ? %(cvt)s(__ldg(x_in1 + THREADS*2)) : 0.0f;\\n        float x3 =                   %(cvt)s(__ldg(x_in1 + THREADS*3));\\n\\n        float d0 = i >= -THREADS*0 ? %(cvt)s(__ldg(d_in1 + THREADS*0)) : 0.0f;\\n        float d1 = i >= -THREADS*1 ? %(cvt)s(__ldg(d_in1 + THREADS*1)) : 0.0f;\\n        float d2 = i >= -THREADS*2 ? %(cvt)s(__ldg(d_in1 + THREADS*2)) : 0.0f;\\n        float d3 =                   %(cvt)s(__ldg(d_in1 + THREADS*3));\\n\\n        x_in1 -= THREADS*4;\\n        d_in1 -= THREADS*4;\\n\\n        float xhat0 = 0.0f;\\n        float xhat1 = 0.0f;\\n        float xhat2 = 0.0f;\\n        float xhat3 = 0.0f;\\n\\n        float xtmp0 = 0.0f;\\n        float xtmp1 = 0.0f;\\n        float xtmp2 = 0.0f;\\n        float xtmp3 = 0.0f;\\n\\n        float delta0 = 0.0f;\\n        float delta1 = 0.0f;\\n        float delta2 = 0.0f;\\n        float delta3 = 0.0f;\\n\\n        if (binary) {\\n            xhat0 = shift_element(x0 - xmean, xvar_rcp_sqrt, true);\\n            xhat1 = shift_element(x1 - xmean, xvar_rcp_sqrt, true);\\n            xhat2 = shift_element(x2 - xmean, xvar_rcp_sqrt, true);\\n            xhat3 = shift_element(x3 - xmean, xvar_rcp_sqrt, true);\\n\\n            xtmp0 = (shift_element(xhat0, grad_gamma, true) + grad_beta) * rcpN;\\n            xtmp1 = (shift_element(xhat1, grad_gamma, true) + grad_beta) * rcpN;\\n            xtmp2 = (shift_element(xhat2, grad_gamma, true) + grad_beta) * rcpN;\\n            xtmp3 = (shift_element(xhat3, grad_gamma, true) + grad_beta) * rcpN;\\n\\n            delta0 = shift_element(shift_element(d0 - xtmp0, gamma, true), xvar_rcp_sqrt, true);\\n            delta1 = shift_element(shift_element(d1 - xtmp1, gamma, true), xvar_rcp_sqrt, true);\\n            delta2 = shift_element(shift_element(d2 - xtmp2, gamma, true), xvar_rcp_sqrt, true);\\n            delta3 = shift_element(shift_element(d3 - xtmp3, gamma, true), xvar_rcp_sqrt, true);\\n        } else {\\n            xhat0 = (x0 - xmean) * xvar_rcp_sqrt;\\n            xhat1 = (x1 - xmean) * xvar_rcp_sqrt;\\n            xhat2 = (x2 - xmean) * xvar_rcp_sqrt;\\n            xhat3 = (x3 - xmean) * xvar_rcp_sqrt;\\n\\n            xtmp0 = (xhat0 * grad_gamma + grad_beta) * rcpN;\\n            xtmp1 = (xhat1 * grad_gamma + grad_beta) * rcpN;\\n            xtmp2 = (xhat2 * grad_gamma + grad_beta) * rcpN;\\n            xtmp3 = (xhat3 * grad_gamma + grad_beta) * rcpN;\\n\\n            delta0 = gamma * (d0 - xtmp0) * xvar_rcp_sqrt;\\n            delta1 = gamma * (d1 - xtmp1) * xvar_rcp_sqrt;\\n            delta2 = gamma * (d2 - xtmp2) * xvar_rcp_sqrt;\\n            delta3 = gamma * (d3 - xtmp3) * xvar_rcp_sqrt;\\n        }\\n\\n        %(delta0_out)s\\n        %(delta1_out)s\\n        %(delta2_out)s\\n        %(delta3_out)s\\n        if (i >= -THREADS*0) *(delta_out + THREADS*0) = delta0_val;\\n        if (i >= -THREADS*1) *(delta_out + THREADS*1) = delta1_val;\\n        if (i >= -THREADS*2) *(delta_out + THREADS*2) = delta2_val;\\n                             *(delta_out + THREADS*3) = delta3_val;\\n        delta_out -= THREADS*4;\\n    }\\n}\\n'\n    out_code = _ew_strings['round']['nearest'].get(dtype, 'float {0} = {1};')\n    common_code = _common_round['nearest'].get(dtype, '')\n    if dtype == 'f2':\n        common_code += _common_fp16_to_fp32\n    if compute_capability[0] == 3 and compute_capability[1] < 5 or compute_capability[0] < 3:\n        common_code += _common_kepler\n    code = code % {'common': common_code, 'binary': shift_element(), 'share': shr_code, 'red': red_code, 'threads': threads, 'type': _ew_types[dtype]['type'], 'cvt': _ew_types[dtype]['cvt'], 'delta0_out': out_code.format('delta0_val', 'delta0'), 'delta1_out': out_code.format('delta1_val', 'delta1'), 'delta2_out': out_code.format('delta2_val', 'delta2'), 'delta3_out': out_code.format('delta3_val', 'delta3')}\n    module = SourceModule(code, options=['--use_fast_math'])\n    kernel = module.get_function('batchnorm_bprop')\n    kernel.prepare('PPPPPPPPfII')\n    kernel.name = 'batchnorm_bprop'\n    return kernel",
        "mutated": [
            "@context_dependent_memoize\ndef _get_bn_bprop_kernel(dtype, threads, compute_capability):\n    if False:\n        i = 10\n    if threads > 32:\n        shr_code = '__shared__ float sPartials[THREADS * 2];'\n        red_code = '\\n    sPartials[tid + THREADS*0] = grad_gamma;\\n    sPartials[tid + THREADS*1] = grad_beta;\\n    __syncthreads();\\n\\n    #pragma unroll\\n    for (int a = THREADS >> 1; a > 32; a >>= 1)\\n    {\\n        if ( tid < a )\\n        {\\n            sPartials[tid + THREADS*0] += sPartials[tid + a + THREADS*0];\\n            sPartials[tid + THREADS*1] += sPartials[tid + a + THREADS*1];\\n        }\\n        __syncthreads();\\n    }\\n    if ( tid < 32 )\\n    {\\n        grad_gamma = sPartials[tid + THREADS*0] + sPartials[tid + 32 + THREADS*0];\\n        grad_beta  = sPartials[tid + THREADS*1] + sPartials[tid + 32 + THREADS*1];\\n\\n        #pragma unroll\\n        for (int i = 16; i > 0; i >>= 1)\\n        {\\n            grad_gamma += __shfl_xor(grad_gamma, i);\\n            grad_beta  += __shfl_xor(grad_beta,  i);\\n        }\\n        sPartials[tid + THREADS*0] = grad_gamma;\\n        sPartials[tid + THREADS*1] = grad_beta;\\n    }\\n    __syncthreads();\\n    grad_gamma = sPartials[THREADS*0];\\n    grad_beta  = sPartials[THREADS*1];\\n'\n    else:\n        shr_code = ''\n        red_code = '\\n    #pragma unroll\\n    for (int i = 16; i > 0; i >>= 1)\\n    {\\n        grad_gamma += __shfl_xor(grad_gamma, i);\\n        grad_beta  += __shfl_xor(grad_beta,  i);\\n    }\\n'\n    code = '\\n#define THREADS %(threads)s\\n\\n%(common)s\\n%(binary)s\\n\\n__global__ void batchnorm_bprop (\\n    %(type)s* delta_out, float* grad_gamma_out, float* grad_beta_out,\\n    const %(type)s* delta_in, const %(type)s* x_in, const float* xsum_in,\\n    const float* xvar_in, const float* gamma_in,\\n    const float eps, const int N, bool binary)\\n{\\n    %(share)s\\n\\n    const int tid  = threadIdx.x;\\n    const int bid  = blockIdx.x;\\n    const float rcpN = 1.0f/(float)N;\\n    int offset = bid * N;\\n\\n    const %(type)s* x_in0 = x_in     + offset + tid;\\n    const %(type)s* d_in0 = delta_in + offset + tid;\\n\\n    float xmean = __ldg(xsum_in  + bid) * rcpN;\\n    float xvar  = __ldg(xvar_in  + bid);\\n    float gamma = __ldg(gamma_in + bid);\\n\\n    float xvar_rcp_sqrt = 1.0f / sqrtf(xvar + eps);\\n    float grad_gamma    = 0.0f;\\n    float grad_beta     = 0.0f;\\n\\n    for (int i = tid; i < N; i += THREADS)\\n    {\\n        float x = %(cvt)s(__ldg(x_in0));\\n        x_in0 += THREADS;\\n        float d = %(cvt)s(__ldg(d_in0));\\n        d_in0 += THREADS;\\n\\n        float xhat = 0.0f;\\n        if (binary) {\\n            xhat = shift_element(x - xmean, xvar_rcp_sqrt, true);\\n        } else {\\n            xhat = (x - xmean) * xvar_rcp_sqrt;\\n        }\\n\\n        grad_gamma += xhat * d;\\n        grad_beta  += d;\\n    }\\n    %(red)s\\n\\n    if ( tid == 0 )\\n    {\\n        *(grad_gamma_out + bid) = grad_gamma;\\n        *(grad_beta_out  + bid) = grad_beta;\\n    }\\n\\n    int start = N - (THREADS*4 - tid);\\n    offset += start;\\n    const %(type)s* x_in1 = x_in     + offset;\\n    const %(type)s* d_in1 = delta_in + offset;\\n    delta_out += offset;\\n\\n    for (int i = start; i >= -THREADS*3; i -= THREADS*4)\\n    {\\n        float x0 = i >= -THREADS*0 ? %(cvt)s(__ldg(x_in1 + THREADS*0)) : 0.0f;\\n        float x1 = i >= -THREADS*1 ? %(cvt)s(__ldg(x_in1 + THREADS*1)) : 0.0f;\\n        float x2 = i >= -THREADS*2 ? %(cvt)s(__ldg(x_in1 + THREADS*2)) : 0.0f;\\n        float x3 =                   %(cvt)s(__ldg(x_in1 + THREADS*3));\\n\\n        float d0 = i >= -THREADS*0 ? %(cvt)s(__ldg(d_in1 + THREADS*0)) : 0.0f;\\n        float d1 = i >= -THREADS*1 ? %(cvt)s(__ldg(d_in1 + THREADS*1)) : 0.0f;\\n        float d2 = i >= -THREADS*2 ? %(cvt)s(__ldg(d_in1 + THREADS*2)) : 0.0f;\\n        float d3 =                   %(cvt)s(__ldg(d_in1 + THREADS*3));\\n\\n        x_in1 -= THREADS*4;\\n        d_in1 -= THREADS*4;\\n\\n        float xhat0 = 0.0f;\\n        float xhat1 = 0.0f;\\n        float xhat2 = 0.0f;\\n        float xhat3 = 0.0f;\\n\\n        float xtmp0 = 0.0f;\\n        float xtmp1 = 0.0f;\\n        float xtmp2 = 0.0f;\\n        float xtmp3 = 0.0f;\\n\\n        float delta0 = 0.0f;\\n        float delta1 = 0.0f;\\n        float delta2 = 0.0f;\\n        float delta3 = 0.0f;\\n\\n        if (binary) {\\n            xhat0 = shift_element(x0 - xmean, xvar_rcp_sqrt, true);\\n            xhat1 = shift_element(x1 - xmean, xvar_rcp_sqrt, true);\\n            xhat2 = shift_element(x2 - xmean, xvar_rcp_sqrt, true);\\n            xhat3 = shift_element(x3 - xmean, xvar_rcp_sqrt, true);\\n\\n            xtmp0 = (shift_element(xhat0, grad_gamma, true) + grad_beta) * rcpN;\\n            xtmp1 = (shift_element(xhat1, grad_gamma, true) + grad_beta) * rcpN;\\n            xtmp2 = (shift_element(xhat2, grad_gamma, true) + grad_beta) * rcpN;\\n            xtmp3 = (shift_element(xhat3, grad_gamma, true) + grad_beta) * rcpN;\\n\\n            delta0 = shift_element(shift_element(d0 - xtmp0, gamma, true), xvar_rcp_sqrt, true);\\n            delta1 = shift_element(shift_element(d1 - xtmp1, gamma, true), xvar_rcp_sqrt, true);\\n            delta2 = shift_element(shift_element(d2 - xtmp2, gamma, true), xvar_rcp_sqrt, true);\\n            delta3 = shift_element(shift_element(d3 - xtmp3, gamma, true), xvar_rcp_sqrt, true);\\n        } else {\\n            xhat0 = (x0 - xmean) * xvar_rcp_sqrt;\\n            xhat1 = (x1 - xmean) * xvar_rcp_sqrt;\\n            xhat2 = (x2 - xmean) * xvar_rcp_sqrt;\\n            xhat3 = (x3 - xmean) * xvar_rcp_sqrt;\\n\\n            xtmp0 = (xhat0 * grad_gamma + grad_beta) * rcpN;\\n            xtmp1 = (xhat1 * grad_gamma + grad_beta) * rcpN;\\n            xtmp2 = (xhat2 * grad_gamma + grad_beta) * rcpN;\\n            xtmp3 = (xhat3 * grad_gamma + grad_beta) * rcpN;\\n\\n            delta0 = gamma * (d0 - xtmp0) * xvar_rcp_sqrt;\\n            delta1 = gamma * (d1 - xtmp1) * xvar_rcp_sqrt;\\n            delta2 = gamma * (d2 - xtmp2) * xvar_rcp_sqrt;\\n            delta3 = gamma * (d3 - xtmp3) * xvar_rcp_sqrt;\\n        }\\n\\n        %(delta0_out)s\\n        %(delta1_out)s\\n        %(delta2_out)s\\n        %(delta3_out)s\\n        if (i >= -THREADS*0) *(delta_out + THREADS*0) = delta0_val;\\n        if (i >= -THREADS*1) *(delta_out + THREADS*1) = delta1_val;\\n        if (i >= -THREADS*2) *(delta_out + THREADS*2) = delta2_val;\\n                             *(delta_out + THREADS*3) = delta3_val;\\n        delta_out -= THREADS*4;\\n    }\\n}\\n'\n    out_code = _ew_strings['round']['nearest'].get(dtype, 'float {0} = {1};')\n    common_code = _common_round['nearest'].get(dtype, '')\n    if dtype == 'f2':\n        common_code += _common_fp16_to_fp32\n    if compute_capability[0] == 3 and compute_capability[1] < 5 or compute_capability[0] < 3:\n        common_code += _common_kepler\n    code = code % {'common': common_code, 'binary': shift_element(), 'share': shr_code, 'red': red_code, 'threads': threads, 'type': _ew_types[dtype]['type'], 'cvt': _ew_types[dtype]['cvt'], 'delta0_out': out_code.format('delta0_val', 'delta0'), 'delta1_out': out_code.format('delta1_val', 'delta1'), 'delta2_out': out_code.format('delta2_val', 'delta2'), 'delta3_out': out_code.format('delta3_val', 'delta3')}\n    module = SourceModule(code, options=['--use_fast_math'])\n    kernel = module.get_function('batchnorm_bprop')\n    kernel.prepare('PPPPPPPPfII')\n    kernel.name = 'batchnorm_bprop'\n    return kernel",
            "@context_dependent_memoize\ndef _get_bn_bprop_kernel(dtype, threads, compute_capability):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if threads > 32:\n        shr_code = '__shared__ float sPartials[THREADS * 2];'\n        red_code = '\\n    sPartials[tid + THREADS*0] = grad_gamma;\\n    sPartials[tid + THREADS*1] = grad_beta;\\n    __syncthreads();\\n\\n    #pragma unroll\\n    for (int a = THREADS >> 1; a > 32; a >>= 1)\\n    {\\n        if ( tid < a )\\n        {\\n            sPartials[tid + THREADS*0] += sPartials[tid + a + THREADS*0];\\n            sPartials[tid + THREADS*1] += sPartials[tid + a + THREADS*1];\\n        }\\n        __syncthreads();\\n    }\\n    if ( tid < 32 )\\n    {\\n        grad_gamma = sPartials[tid + THREADS*0] + sPartials[tid + 32 + THREADS*0];\\n        grad_beta  = sPartials[tid + THREADS*1] + sPartials[tid + 32 + THREADS*1];\\n\\n        #pragma unroll\\n        for (int i = 16; i > 0; i >>= 1)\\n        {\\n            grad_gamma += __shfl_xor(grad_gamma, i);\\n            grad_beta  += __shfl_xor(grad_beta,  i);\\n        }\\n        sPartials[tid + THREADS*0] = grad_gamma;\\n        sPartials[tid + THREADS*1] = grad_beta;\\n    }\\n    __syncthreads();\\n    grad_gamma = sPartials[THREADS*0];\\n    grad_beta  = sPartials[THREADS*1];\\n'\n    else:\n        shr_code = ''\n        red_code = '\\n    #pragma unroll\\n    for (int i = 16; i > 0; i >>= 1)\\n    {\\n        grad_gamma += __shfl_xor(grad_gamma, i);\\n        grad_beta  += __shfl_xor(grad_beta,  i);\\n    }\\n'\n    code = '\\n#define THREADS %(threads)s\\n\\n%(common)s\\n%(binary)s\\n\\n__global__ void batchnorm_bprop (\\n    %(type)s* delta_out, float* grad_gamma_out, float* grad_beta_out,\\n    const %(type)s* delta_in, const %(type)s* x_in, const float* xsum_in,\\n    const float* xvar_in, const float* gamma_in,\\n    const float eps, const int N, bool binary)\\n{\\n    %(share)s\\n\\n    const int tid  = threadIdx.x;\\n    const int bid  = blockIdx.x;\\n    const float rcpN = 1.0f/(float)N;\\n    int offset = bid * N;\\n\\n    const %(type)s* x_in0 = x_in     + offset + tid;\\n    const %(type)s* d_in0 = delta_in + offset + tid;\\n\\n    float xmean = __ldg(xsum_in  + bid) * rcpN;\\n    float xvar  = __ldg(xvar_in  + bid);\\n    float gamma = __ldg(gamma_in + bid);\\n\\n    float xvar_rcp_sqrt = 1.0f / sqrtf(xvar + eps);\\n    float grad_gamma    = 0.0f;\\n    float grad_beta     = 0.0f;\\n\\n    for (int i = tid; i < N; i += THREADS)\\n    {\\n        float x = %(cvt)s(__ldg(x_in0));\\n        x_in0 += THREADS;\\n        float d = %(cvt)s(__ldg(d_in0));\\n        d_in0 += THREADS;\\n\\n        float xhat = 0.0f;\\n        if (binary) {\\n            xhat = shift_element(x - xmean, xvar_rcp_sqrt, true);\\n        } else {\\n            xhat = (x - xmean) * xvar_rcp_sqrt;\\n        }\\n\\n        grad_gamma += xhat * d;\\n        grad_beta  += d;\\n    }\\n    %(red)s\\n\\n    if ( tid == 0 )\\n    {\\n        *(grad_gamma_out + bid) = grad_gamma;\\n        *(grad_beta_out  + bid) = grad_beta;\\n    }\\n\\n    int start = N - (THREADS*4 - tid);\\n    offset += start;\\n    const %(type)s* x_in1 = x_in     + offset;\\n    const %(type)s* d_in1 = delta_in + offset;\\n    delta_out += offset;\\n\\n    for (int i = start; i >= -THREADS*3; i -= THREADS*4)\\n    {\\n        float x0 = i >= -THREADS*0 ? %(cvt)s(__ldg(x_in1 + THREADS*0)) : 0.0f;\\n        float x1 = i >= -THREADS*1 ? %(cvt)s(__ldg(x_in1 + THREADS*1)) : 0.0f;\\n        float x2 = i >= -THREADS*2 ? %(cvt)s(__ldg(x_in1 + THREADS*2)) : 0.0f;\\n        float x3 =                   %(cvt)s(__ldg(x_in1 + THREADS*3));\\n\\n        float d0 = i >= -THREADS*0 ? %(cvt)s(__ldg(d_in1 + THREADS*0)) : 0.0f;\\n        float d1 = i >= -THREADS*1 ? %(cvt)s(__ldg(d_in1 + THREADS*1)) : 0.0f;\\n        float d2 = i >= -THREADS*2 ? %(cvt)s(__ldg(d_in1 + THREADS*2)) : 0.0f;\\n        float d3 =                   %(cvt)s(__ldg(d_in1 + THREADS*3));\\n\\n        x_in1 -= THREADS*4;\\n        d_in1 -= THREADS*4;\\n\\n        float xhat0 = 0.0f;\\n        float xhat1 = 0.0f;\\n        float xhat2 = 0.0f;\\n        float xhat3 = 0.0f;\\n\\n        float xtmp0 = 0.0f;\\n        float xtmp1 = 0.0f;\\n        float xtmp2 = 0.0f;\\n        float xtmp3 = 0.0f;\\n\\n        float delta0 = 0.0f;\\n        float delta1 = 0.0f;\\n        float delta2 = 0.0f;\\n        float delta3 = 0.0f;\\n\\n        if (binary) {\\n            xhat0 = shift_element(x0 - xmean, xvar_rcp_sqrt, true);\\n            xhat1 = shift_element(x1 - xmean, xvar_rcp_sqrt, true);\\n            xhat2 = shift_element(x2 - xmean, xvar_rcp_sqrt, true);\\n            xhat3 = shift_element(x3 - xmean, xvar_rcp_sqrt, true);\\n\\n            xtmp0 = (shift_element(xhat0, grad_gamma, true) + grad_beta) * rcpN;\\n            xtmp1 = (shift_element(xhat1, grad_gamma, true) + grad_beta) * rcpN;\\n            xtmp2 = (shift_element(xhat2, grad_gamma, true) + grad_beta) * rcpN;\\n            xtmp3 = (shift_element(xhat3, grad_gamma, true) + grad_beta) * rcpN;\\n\\n            delta0 = shift_element(shift_element(d0 - xtmp0, gamma, true), xvar_rcp_sqrt, true);\\n            delta1 = shift_element(shift_element(d1 - xtmp1, gamma, true), xvar_rcp_sqrt, true);\\n            delta2 = shift_element(shift_element(d2 - xtmp2, gamma, true), xvar_rcp_sqrt, true);\\n            delta3 = shift_element(shift_element(d3 - xtmp3, gamma, true), xvar_rcp_sqrt, true);\\n        } else {\\n            xhat0 = (x0 - xmean) * xvar_rcp_sqrt;\\n            xhat1 = (x1 - xmean) * xvar_rcp_sqrt;\\n            xhat2 = (x2 - xmean) * xvar_rcp_sqrt;\\n            xhat3 = (x3 - xmean) * xvar_rcp_sqrt;\\n\\n            xtmp0 = (xhat0 * grad_gamma + grad_beta) * rcpN;\\n            xtmp1 = (xhat1 * grad_gamma + grad_beta) * rcpN;\\n            xtmp2 = (xhat2 * grad_gamma + grad_beta) * rcpN;\\n            xtmp3 = (xhat3 * grad_gamma + grad_beta) * rcpN;\\n\\n            delta0 = gamma * (d0 - xtmp0) * xvar_rcp_sqrt;\\n            delta1 = gamma * (d1 - xtmp1) * xvar_rcp_sqrt;\\n            delta2 = gamma * (d2 - xtmp2) * xvar_rcp_sqrt;\\n            delta3 = gamma * (d3 - xtmp3) * xvar_rcp_sqrt;\\n        }\\n\\n        %(delta0_out)s\\n        %(delta1_out)s\\n        %(delta2_out)s\\n        %(delta3_out)s\\n        if (i >= -THREADS*0) *(delta_out + THREADS*0) = delta0_val;\\n        if (i >= -THREADS*1) *(delta_out + THREADS*1) = delta1_val;\\n        if (i >= -THREADS*2) *(delta_out + THREADS*2) = delta2_val;\\n                             *(delta_out + THREADS*3) = delta3_val;\\n        delta_out -= THREADS*4;\\n    }\\n}\\n'\n    out_code = _ew_strings['round']['nearest'].get(dtype, 'float {0} = {1};')\n    common_code = _common_round['nearest'].get(dtype, '')\n    if dtype == 'f2':\n        common_code += _common_fp16_to_fp32\n    if compute_capability[0] == 3 and compute_capability[1] < 5 or compute_capability[0] < 3:\n        common_code += _common_kepler\n    code = code % {'common': common_code, 'binary': shift_element(), 'share': shr_code, 'red': red_code, 'threads': threads, 'type': _ew_types[dtype]['type'], 'cvt': _ew_types[dtype]['cvt'], 'delta0_out': out_code.format('delta0_val', 'delta0'), 'delta1_out': out_code.format('delta1_val', 'delta1'), 'delta2_out': out_code.format('delta2_val', 'delta2'), 'delta3_out': out_code.format('delta3_val', 'delta3')}\n    module = SourceModule(code, options=['--use_fast_math'])\n    kernel = module.get_function('batchnorm_bprop')\n    kernel.prepare('PPPPPPPPfII')\n    kernel.name = 'batchnorm_bprop'\n    return kernel",
            "@context_dependent_memoize\ndef _get_bn_bprop_kernel(dtype, threads, compute_capability):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if threads > 32:\n        shr_code = '__shared__ float sPartials[THREADS * 2];'\n        red_code = '\\n    sPartials[tid + THREADS*0] = grad_gamma;\\n    sPartials[tid + THREADS*1] = grad_beta;\\n    __syncthreads();\\n\\n    #pragma unroll\\n    for (int a = THREADS >> 1; a > 32; a >>= 1)\\n    {\\n        if ( tid < a )\\n        {\\n            sPartials[tid + THREADS*0] += sPartials[tid + a + THREADS*0];\\n            sPartials[tid + THREADS*1] += sPartials[tid + a + THREADS*1];\\n        }\\n        __syncthreads();\\n    }\\n    if ( tid < 32 )\\n    {\\n        grad_gamma = sPartials[tid + THREADS*0] + sPartials[tid + 32 + THREADS*0];\\n        grad_beta  = sPartials[tid + THREADS*1] + sPartials[tid + 32 + THREADS*1];\\n\\n        #pragma unroll\\n        for (int i = 16; i > 0; i >>= 1)\\n        {\\n            grad_gamma += __shfl_xor(grad_gamma, i);\\n            grad_beta  += __shfl_xor(grad_beta,  i);\\n        }\\n        sPartials[tid + THREADS*0] = grad_gamma;\\n        sPartials[tid + THREADS*1] = grad_beta;\\n    }\\n    __syncthreads();\\n    grad_gamma = sPartials[THREADS*0];\\n    grad_beta  = sPartials[THREADS*1];\\n'\n    else:\n        shr_code = ''\n        red_code = '\\n    #pragma unroll\\n    for (int i = 16; i > 0; i >>= 1)\\n    {\\n        grad_gamma += __shfl_xor(grad_gamma, i);\\n        grad_beta  += __shfl_xor(grad_beta,  i);\\n    }\\n'\n    code = '\\n#define THREADS %(threads)s\\n\\n%(common)s\\n%(binary)s\\n\\n__global__ void batchnorm_bprop (\\n    %(type)s* delta_out, float* grad_gamma_out, float* grad_beta_out,\\n    const %(type)s* delta_in, const %(type)s* x_in, const float* xsum_in,\\n    const float* xvar_in, const float* gamma_in,\\n    const float eps, const int N, bool binary)\\n{\\n    %(share)s\\n\\n    const int tid  = threadIdx.x;\\n    const int bid  = blockIdx.x;\\n    const float rcpN = 1.0f/(float)N;\\n    int offset = bid * N;\\n\\n    const %(type)s* x_in0 = x_in     + offset + tid;\\n    const %(type)s* d_in0 = delta_in + offset + tid;\\n\\n    float xmean = __ldg(xsum_in  + bid) * rcpN;\\n    float xvar  = __ldg(xvar_in  + bid);\\n    float gamma = __ldg(gamma_in + bid);\\n\\n    float xvar_rcp_sqrt = 1.0f / sqrtf(xvar + eps);\\n    float grad_gamma    = 0.0f;\\n    float grad_beta     = 0.0f;\\n\\n    for (int i = tid; i < N; i += THREADS)\\n    {\\n        float x = %(cvt)s(__ldg(x_in0));\\n        x_in0 += THREADS;\\n        float d = %(cvt)s(__ldg(d_in0));\\n        d_in0 += THREADS;\\n\\n        float xhat = 0.0f;\\n        if (binary) {\\n            xhat = shift_element(x - xmean, xvar_rcp_sqrt, true);\\n        } else {\\n            xhat = (x - xmean) * xvar_rcp_sqrt;\\n        }\\n\\n        grad_gamma += xhat * d;\\n        grad_beta  += d;\\n    }\\n    %(red)s\\n\\n    if ( tid == 0 )\\n    {\\n        *(grad_gamma_out + bid) = grad_gamma;\\n        *(grad_beta_out  + bid) = grad_beta;\\n    }\\n\\n    int start = N - (THREADS*4 - tid);\\n    offset += start;\\n    const %(type)s* x_in1 = x_in     + offset;\\n    const %(type)s* d_in1 = delta_in + offset;\\n    delta_out += offset;\\n\\n    for (int i = start; i >= -THREADS*3; i -= THREADS*4)\\n    {\\n        float x0 = i >= -THREADS*0 ? %(cvt)s(__ldg(x_in1 + THREADS*0)) : 0.0f;\\n        float x1 = i >= -THREADS*1 ? %(cvt)s(__ldg(x_in1 + THREADS*1)) : 0.0f;\\n        float x2 = i >= -THREADS*2 ? %(cvt)s(__ldg(x_in1 + THREADS*2)) : 0.0f;\\n        float x3 =                   %(cvt)s(__ldg(x_in1 + THREADS*3));\\n\\n        float d0 = i >= -THREADS*0 ? %(cvt)s(__ldg(d_in1 + THREADS*0)) : 0.0f;\\n        float d1 = i >= -THREADS*1 ? %(cvt)s(__ldg(d_in1 + THREADS*1)) : 0.0f;\\n        float d2 = i >= -THREADS*2 ? %(cvt)s(__ldg(d_in1 + THREADS*2)) : 0.0f;\\n        float d3 =                   %(cvt)s(__ldg(d_in1 + THREADS*3));\\n\\n        x_in1 -= THREADS*4;\\n        d_in1 -= THREADS*4;\\n\\n        float xhat0 = 0.0f;\\n        float xhat1 = 0.0f;\\n        float xhat2 = 0.0f;\\n        float xhat3 = 0.0f;\\n\\n        float xtmp0 = 0.0f;\\n        float xtmp1 = 0.0f;\\n        float xtmp2 = 0.0f;\\n        float xtmp3 = 0.0f;\\n\\n        float delta0 = 0.0f;\\n        float delta1 = 0.0f;\\n        float delta2 = 0.0f;\\n        float delta3 = 0.0f;\\n\\n        if (binary) {\\n            xhat0 = shift_element(x0 - xmean, xvar_rcp_sqrt, true);\\n            xhat1 = shift_element(x1 - xmean, xvar_rcp_sqrt, true);\\n            xhat2 = shift_element(x2 - xmean, xvar_rcp_sqrt, true);\\n            xhat3 = shift_element(x3 - xmean, xvar_rcp_sqrt, true);\\n\\n            xtmp0 = (shift_element(xhat0, grad_gamma, true) + grad_beta) * rcpN;\\n            xtmp1 = (shift_element(xhat1, grad_gamma, true) + grad_beta) * rcpN;\\n            xtmp2 = (shift_element(xhat2, grad_gamma, true) + grad_beta) * rcpN;\\n            xtmp3 = (shift_element(xhat3, grad_gamma, true) + grad_beta) * rcpN;\\n\\n            delta0 = shift_element(shift_element(d0 - xtmp0, gamma, true), xvar_rcp_sqrt, true);\\n            delta1 = shift_element(shift_element(d1 - xtmp1, gamma, true), xvar_rcp_sqrt, true);\\n            delta2 = shift_element(shift_element(d2 - xtmp2, gamma, true), xvar_rcp_sqrt, true);\\n            delta3 = shift_element(shift_element(d3 - xtmp3, gamma, true), xvar_rcp_sqrt, true);\\n        } else {\\n            xhat0 = (x0 - xmean) * xvar_rcp_sqrt;\\n            xhat1 = (x1 - xmean) * xvar_rcp_sqrt;\\n            xhat2 = (x2 - xmean) * xvar_rcp_sqrt;\\n            xhat3 = (x3 - xmean) * xvar_rcp_sqrt;\\n\\n            xtmp0 = (xhat0 * grad_gamma + grad_beta) * rcpN;\\n            xtmp1 = (xhat1 * grad_gamma + grad_beta) * rcpN;\\n            xtmp2 = (xhat2 * grad_gamma + grad_beta) * rcpN;\\n            xtmp3 = (xhat3 * grad_gamma + grad_beta) * rcpN;\\n\\n            delta0 = gamma * (d0 - xtmp0) * xvar_rcp_sqrt;\\n            delta1 = gamma * (d1 - xtmp1) * xvar_rcp_sqrt;\\n            delta2 = gamma * (d2 - xtmp2) * xvar_rcp_sqrt;\\n            delta3 = gamma * (d3 - xtmp3) * xvar_rcp_sqrt;\\n        }\\n\\n        %(delta0_out)s\\n        %(delta1_out)s\\n        %(delta2_out)s\\n        %(delta3_out)s\\n        if (i >= -THREADS*0) *(delta_out + THREADS*0) = delta0_val;\\n        if (i >= -THREADS*1) *(delta_out + THREADS*1) = delta1_val;\\n        if (i >= -THREADS*2) *(delta_out + THREADS*2) = delta2_val;\\n                             *(delta_out + THREADS*3) = delta3_val;\\n        delta_out -= THREADS*4;\\n    }\\n}\\n'\n    out_code = _ew_strings['round']['nearest'].get(dtype, 'float {0} = {1};')\n    common_code = _common_round['nearest'].get(dtype, '')\n    if dtype == 'f2':\n        common_code += _common_fp16_to_fp32\n    if compute_capability[0] == 3 and compute_capability[1] < 5 or compute_capability[0] < 3:\n        common_code += _common_kepler\n    code = code % {'common': common_code, 'binary': shift_element(), 'share': shr_code, 'red': red_code, 'threads': threads, 'type': _ew_types[dtype]['type'], 'cvt': _ew_types[dtype]['cvt'], 'delta0_out': out_code.format('delta0_val', 'delta0'), 'delta1_out': out_code.format('delta1_val', 'delta1'), 'delta2_out': out_code.format('delta2_val', 'delta2'), 'delta3_out': out_code.format('delta3_val', 'delta3')}\n    module = SourceModule(code, options=['--use_fast_math'])\n    kernel = module.get_function('batchnorm_bprop')\n    kernel.prepare('PPPPPPPPfII')\n    kernel.name = 'batchnorm_bprop'\n    return kernel",
            "@context_dependent_memoize\ndef _get_bn_bprop_kernel(dtype, threads, compute_capability):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if threads > 32:\n        shr_code = '__shared__ float sPartials[THREADS * 2];'\n        red_code = '\\n    sPartials[tid + THREADS*0] = grad_gamma;\\n    sPartials[tid + THREADS*1] = grad_beta;\\n    __syncthreads();\\n\\n    #pragma unroll\\n    for (int a = THREADS >> 1; a > 32; a >>= 1)\\n    {\\n        if ( tid < a )\\n        {\\n            sPartials[tid + THREADS*0] += sPartials[tid + a + THREADS*0];\\n            sPartials[tid + THREADS*1] += sPartials[tid + a + THREADS*1];\\n        }\\n        __syncthreads();\\n    }\\n    if ( tid < 32 )\\n    {\\n        grad_gamma = sPartials[tid + THREADS*0] + sPartials[tid + 32 + THREADS*0];\\n        grad_beta  = sPartials[tid + THREADS*1] + sPartials[tid + 32 + THREADS*1];\\n\\n        #pragma unroll\\n        for (int i = 16; i > 0; i >>= 1)\\n        {\\n            grad_gamma += __shfl_xor(grad_gamma, i);\\n            grad_beta  += __shfl_xor(grad_beta,  i);\\n        }\\n        sPartials[tid + THREADS*0] = grad_gamma;\\n        sPartials[tid + THREADS*1] = grad_beta;\\n    }\\n    __syncthreads();\\n    grad_gamma = sPartials[THREADS*0];\\n    grad_beta  = sPartials[THREADS*1];\\n'\n    else:\n        shr_code = ''\n        red_code = '\\n    #pragma unroll\\n    for (int i = 16; i > 0; i >>= 1)\\n    {\\n        grad_gamma += __shfl_xor(grad_gamma, i);\\n        grad_beta  += __shfl_xor(grad_beta,  i);\\n    }\\n'\n    code = '\\n#define THREADS %(threads)s\\n\\n%(common)s\\n%(binary)s\\n\\n__global__ void batchnorm_bprop (\\n    %(type)s* delta_out, float* grad_gamma_out, float* grad_beta_out,\\n    const %(type)s* delta_in, const %(type)s* x_in, const float* xsum_in,\\n    const float* xvar_in, const float* gamma_in,\\n    const float eps, const int N, bool binary)\\n{\\n    %(share)s\\n\\n    const int tid  = threadIdx.x;\\n    const int bid  = blockIdx.x;\\n    const float rcpN = 1.0f/(float)N;\\n    int offset = bid * N;\\n\\n    const %(type)s* x_in0 = x_in     + offset + tid;\\n    const %(type)s* d_in0 = delta_in + offset + tid;\\n\\n    float xmean = __ldg(xsum_in  + bid) * rcpN;\\n    float xvar  = __ldg(xvar_in  + bid);\\n    float gamma = __ldg(gamma_in + bid);\\n\\n    float xvar_rcp_sqrt = 1.0f / sqrtf(xvar + eps);\\n    float grad_gamma    = 0.0f;\\n    float grad_beta     = 0.0f;\\n\\n    for (int i = tid; i < N; i += THREADS)\\n    {\\n        float x = %(cvt)s(__ldg(x_in0));\\n        x_in0 += THREADS;\\n        float d = %(cvt)s(__ldg(d_in0));\\n        d_in0 += THREADS;\\n\\n        float xhat = 0.0f;\\n        if (binary) {\\n            xhat = shift_element(x - xmean, xvar_rcp_sqrt, true);\\n        } else {\\n            xhat = (x - xmean) * xvar_rcp_sqrt;\\n        }\\n\\n        grad_gamma += xhat * d;\\n        grad_beta  += d;\\n    }\\n    %(red)s\\n\\n    if ( tid == 0 )\\n    {\\n        *(grad_gamma_out + bid) = grad_gamma;\\n        *(grad_beta_out  + bid) = grad_beta;\\n    }\\n\\n    int start = N - (THREADS*4 - tid);\\n    offset += start;\\n    const %(type)s* x_in1 = x_in     + offset;\\n    const %(type)s* d_in1 = delta_in + offset;\\n    delta_out += offset;\\n\\n    for (int i = start; i >= -THREADS*3; i -= THREADS*4)\\n    {\\n        float x0 = i >= -THREADS*0 ? %(cvt)s(__ldg(x_in1 + THREADS*0)) : 0.0f;\\n        float x1 = i >= -THREADS*1 ? %(cvt)s(__ldg(x_in1 + THREADS*1)) : 0.0f;\\n        float x2 = i >= -THREADS*2 ? %(cvt)s(__ldg(x_in1 + THREADS*2)) : 0.0f;\\n        float x3 =                   %(cvt)s(__ldg(x_in1 + THREADS*3));\\n\\n        float d0 = i >= -THREADS*0 ? %(cvt)s(__ldg(d_in1 + THREADS*0)) : 0.0f;\\n        float d1 = i >= -THREADS*1 ? %(cvt)s(__ldg(d_in1 + THREADS*1)) : 0.0f;\\n        float d2 = i >= -THREADS*2 ? %(cvt)s(__ldg(d_in1 + THREADS*2)) : 0.0f;\\n        float d3 =                   %(cvt)s(__ldg(d_in1 + THREADS*3));\\n\\n        x_in1 -= THREADS*4;\\n        d_in1 -= THREADS*4;\\n\\n        float xhat0 = 0.0f;\\n        float xhat1 = 0.0f;\\n        float xhat2 = 0.0f;\\n        float xhat3 = 0.0f;\\n\\n        float xtmp0 = 0.0f;\\n        float xtmp1 = 0.0f;\\n        float xtmp2 = 0.0f;\\n        float xtmp3 = 0.0f;\\n\\n        float delta0 = 0.0f;\\n        float delta1 = 0.0f;\\n        float delta2 = 0.0f;\\n        float delta3 = 0.0f;\\n\\n        if (binary) {\\n            xhat0 = shift_element(x0 - xmean, xvar_rcp_sqrt, true);\\n            xhat1 = shift_element(x1 - xmean, xvar_rcp_sqrt, true);\\n            xhat2 = shift_element(x2 - xmean, xvar_rcp_sqrt, true);\\n            xhat3 = shift_element(x3 - xmean, xvar_rcp_sqrt, true);\\n\\n            xtmp0 = (shift_element(xhat0, grad_gamma, true) + grad_beta) * rcpN;\\n            xtmp1 = (shift_element(xhat1, grad_gamma, true) + grad_beta) * rcpN;\\n            xtmp2 = (shift_element(xhat2, grad_gamma, true) + grad_beta) * rcpN;\\n            xtmp3 = (shift_element(xhat3, grad_gamma, true) + grad_beta) * rcpN;\\n\\n            delta0 = shift_element(shift_element(d0 - xtmp0, gamma, true), xvar_rcp_sqrt, true);\\n            delta1 = shift_element(shift_element(d1 - xtmp1, gamma, true), xvar_rcp_sqrt, true);\\n            delta2 = shift_element(shift_element(d2 - xtmp2, gamma, true), xvar_rcp_sqrt, true);\\n            delta3 = shift_element(shift_element(d3 - xtmp3, gamma, true), xvar_rcp_sqrt, true);\\n        } else {\\n            xhat0 = (x0 - xmean) * xvar_rcp_sqrt;\\n            xhat1 = (x1 - xmean) * xvar_rcp_sqrt;\\n            xhat2 = (x2 - xmean) * xvar_rcp_sqrt;\\n            xhat3 = (x3 - xmean) * xvar_rcp_sqrt;\\n\\n            xtmp0 = (xhat0 * grad_gamma + grad_beta) * rcpN;\\n            xtmp1 = (xhat1 * grad_gamma + grad_beta) * rcpN;\\n            xtmp2 = (xhat2 * grad_gamma + grad_beta) * rcpN;\\n            xtmp3 = (xhat3 * grad_gamma + grad_beta) * rcpN;\\n\\n            delta0 = gamma * (d0 - xtmp0) * xvar_rcp_sqrt;\\n            delta1 = gamma * (d1 - xtmp1) * xvar_rcp_sqrt;\\n            delta2 = gamma * (d2 - xtmp2) * xvar_rcp_sqrt;\\n            delta3 = gamma * (d3 - xtmp3) * xvar_rcp_sqrt;\\n        }\\n\\n        %(delta0_out)s\\n        %(delta1_out)s\\n        %(delta2_out)s\\n        %(delta3_out)s\\n        if (i >= -THREADS*0) *(delta_out + THREADS*0) = delta0_val;\\n        if (i >= -THREADS*1) *(delta_out + THREADS*1) = delta1_val;\\n        if (i >= -THREADS*2) *(delta_out + THREADS*2) = delta2_val;\\n                             *(delta_out + THREADS*3) = delta3_val;\\n        delta_out -= THREADS*4;\\n    }\\n}\\n'\n    out_code = _ew_strings['round']['nearest'].get(dtype, 'float {0} = {1};')\n    common_code = _common_round['nearest'].get(dtype, '')\n    if dtype == 'f2':\n        common_code += _common_fp16_to_fp32\n    if compute_capability[0] == 3 and compute_capability[1] < 5 or compute_capability[0] < 3:\n        common_code += _common_kepler\n    code = code % {'common': common_code, 'binary': shift_element(), 'share': shr_code, 'red': red_code, 'threads': threads, 'type': _ew_types[dtype]['type'], 'cvt': _ew_types[dtype]['cvt'], 'delta0_out': out_code.format('delta0_val', 'delta0'), 'delta1_out': out_code.format('delta1_val', 'delta1'), 'delta2_out': out_code.format('delta2_val', 'delta2'), 'delta3_out': out_code.format('delta3_val', 'delta3')}\n    module = SourceModule(code, options=['--use_fast_math'])\n    kernel = module.get_function('batchnorm_bprop')\n    kernel.prepare('PPPPPPPPfII')\n    kernel.name = 'batchnorm_bprop'\n    return kernel",
            "@context_dependent_memoize\ndef _get_bn_bprop_kernel(dtype, threads, compute_capability):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if threads > 32:\n        shr_code = '__shared__ float sPartials[THREADS * 2];'\n        red_code = '\\n    sPartials[tid + THREADS*0] = grad_gamma;\\n    sPartials[tid + THREADS*1] = grad_beta;\\n    __syncthreads();\\n\\n    #pragma unroll\\n    for (int a = THREADS >> 1; a > 32; a >>= 1)\\n    {\\n        if ( tid < a )\\n        {\\n            sPartials[tid + THREADS*0] += sPartials[tid + a + THREADS*0];\\n            sPartials[tid + THREADS*1] += sPartials[tid + a + THREADS*1];\\n        }\\n        __syncthreads();\\n    }\\n    if ( tid < 32 )\\n    {\\n        grad_gamma = sPartials[tid + THREADS*0] + sPartials[tid + 32 + THREADS*0];\\n        grad_beta  = sPartials[tid + THREADS*1] + sPartials[tid + 32 + THREADS*1];\\n\\n        #pragma unroll\\n        for (int i = 16; i > 0; i >>= 1)\\n        {\\n            grad_gamma += __shfl_xor(grad_gamma, i);\\n            grad_beta  += __shfl_xor(grad_beta,  i);\\n        }\\n        sPartials[tid + THREADS*0] = grad_gamma;\\n        sPartials[tid + THREADS*1] = grad_beta;\\n    }\\n    __syncthreads();\\n    grad_gamma = sPartials[THREADS*0];\\n    grad_beta  = sPartials[THREADS*1];\\n'\n    else:\n        shr_code = ''\n        red_code = '\\n    #pragma unroll\\n    for (int i = 16; i > 0; i >>= 1)\\n    {\\n        grad_gamma += __shfl_xor(grad_gamma, i);\\n        grad_beta  += __shfl_xor(grad_beta,  i);\\n    }\\n'\n    code = '\\n#define THREADS %(threads)s\\n\\n%(common)s\\n%(binary)s\\n\\n__global__ void batchnorm_bprop (\\n    %(type)s* delta_out, float* grad_gamma_out, float* grad_beta_out,\\n    const %(type)s* delta_in, const %(type)s* x_in, const float* xsum_in,\\n    const float* xvar_in, const float* gamma_in,\\n    const float eps, const int N, bool binary)\\n{\\n    %(share)s\\n\\n    const int tid  = threadIdx.x;\\n    const int bid  = blockIdx.x;\\n    const float rcpN = 1.0f/(float)N;\\n    int offset = bid * N;\\n\\n    const %(type)s* x_in0 = x_in     + offset + tid;\\n    const %(type)s* d_in0 = delta_in + offset + tid;\\n\\n    float xmean = __ldg(xsum_in  + bid) * rcpN;\\n    float xvar  = __ldg(xvar_in  + bid);\\n    float gamma = __ldg(gamma_in + bid);\\n\\n    float xvar_rcp_sqrt = 1.0f / sqrtf(xvar + eps);\\n    float grad_gamma    = 0.0f;\\n    float grad_beta     = 0.0f;\\n\\n    for (int i = tid; i < N; i += THREADS)\\n    {\\n        float x = %(cvt)s(__ldg(x_in0));\\n        x_in0 += THREADS;\\n        float d = %(cvt)s(__ldg(d_in0));\\n        d_in0 += THREADS;\\n\\n        float xhat = 0.0f;\\n        if (binary) {\\n            xhat = shift_element(x - xmean, xvar_rcp_sqrt, true);\\n        } else {\\n            xhat = (x - xmean) * xvar_rcp_sqrt;\\n        }\\n\\n        grad_gamma += xhat * d;\\n        grad_beta  += d;\\n    }\\n    %(red)s\\n\\n    if ( tid == 0 )\\n    {\\n        *(grad_gamma_out + bid) = grad_gamma;\\n        *(grad_beta_out  + bid) = grad_beta;\\n    }\\n\\n    int start = N - (THREADS*4 - tid);\\n    offset += start;\\n    const %(type)s* x_in1 = x_in     + offset;\\n    const %(type)s* d_in1 = delta_in + offset;\\n    delta_out += offset;\\n\\n    for (int i = start; i >= -THREADS*3; i -= THREADS*4)\\n    {\\n        float x0 = i >= -THREADS*0 ? %(cvt)s(__ldg(x_in1 + THREADS*0)) : 0.0f;\\n        float x1 = i >= -THREADS*1 ? %(cvt)s(__ldg(x_in1 + THREADS*1)) : 0.0f;\\n        float x2 = i >= -THREADS*2 ? %(cvt)s(__ldg(x_in1 + THREADS*2)) : 0.0f;\\n        float x3 =                   %(cvt)s(__ldg(x_in1 + THREADS*3));\\n\\n        float d0 = i >= -THREADS*0 ? %(cvt)s(__ldg(d_in1 + THREADS*0)) : 0.0f;\\n        float d1 = i >= -THREADS*1 ? %(cvt)s(__ldg(d_in1 + THREADS*1)) : 0.0f;\\n        float d2 = i >= -THREADS*2 ? %(cvt)s(__ldg(d_in1 + THREADS*2)) : 0.0f;\\n        float d3 =                   %(cvt)s(__ldg(d_in1 + THREADS*3));\\n\\n        x_in1 -= THREADS*4;\\n        d_in1 -= THREADS*4;\\n\\n        float xhat0 = 0.0f;\\n        float xhat1 = 0.0f;\\n        float xhat2 = 0.0f;\\n        float xhat3 = 0.0f;\\n\\n        float xtmp0 = 0.0f;\\n        float xtmp1 = 0.0f;\\n        float xtmp2 = 0.0f;\\n        float xtmp3 = 0.0f;\\n\\n        float delta0 = 0.0f;\\n        float delta1 = 0.0f;\\n        float delta2 = 0.0f;\\n        float delta3 = 0.0f;\\n\\n        if (binary) {\\n            xhat0 = shift_element(x0 - xmean, xvar_rcp_sqrt, true);\\n            xhat1 = shift_element(x1 - xmean, xvar_rcp_sqrt, true);\\n            xhat2 = shift_element(x2 - xmean, xvar_rcp_sqrt, true);\\n            xhat3 = shift_element(x3 - xmean, xvar_rcp_sqrt, true);\\n\\n            xtmp0 = (shift_element(xhat0, grad_gamma, true) + grad_beta) * rcpN;\\n            xtmp1 = (shift_element(xhat1, grad_gamma, true) + grad_beta) * rcpN;\\n            xtmp2 = (shift_element(xhat2, grad_gamma, true) + grad_beta) * rcpN;\\n            xtmp3 = (shift_element(xhat3, grad_gamma, true) + grad_beta) * rcpN;\\n\\n            delta0 = shift_element(shift_element(d0 - xtmp0, gamma, true), xvar_rcp_sqrt, true);\\n            delta1 = shift_element(shift_element(d1 - xtmp1, gamma, true), xvar_rcp_sqrt, true);\\n            delta2 = shift_element(shift_element(d2 - xtmp2, gamma, true), xvar_rcp_sqrt, true);\\n            delta3 = shift_element(shift_element(d3 - xtmp3, gamma, true), xvar_rcp_sqrt, true);\\n        } else {\\n            xhat0 = (x0 - xmean) * xvar_rcp_sqrt;\\n            xhat1 = (x1 - xmean) * xvar_rcp_sqrt;\\n            xhat2 = (x2 - xmean) * xvar_rcp_sqrt;\\n            xhat3 = (x3 - xmean) * xvar_rcp_sqrt;\\n\\n            xtmp0 = (xhat0 * grad_gamma + grad_beta) * rcpN;\\n            xtmp1 = (xhat1 * grad_gamma + grad_beta) * rcpN;\\n            xtmp2 = (xhat2 * grad_gamma + grad_beta) * rcpN;\\n            xtmp3 = (xhat3 * grad_gamma + grad_beta) * rcpN;\\n\\n            delta0 = gamma * (d0 - xtmp0) * xvar_rcp_sqrt;\\n            delta1 = gamma * (d1 - xtmp1) * xvar_rcp_sqrt;\\n            delta2 = gamma * (d2 - xtmp2) * xvar_rcp_sqrt;\\n            delta3 = gamma * (d3 - xtmp3) * xvar_rcp_sqrt;\\n        }\\n\\n        %(delta0_out)s\\n        %(delta1_out)s\\n        %(delta2_out)s\\n        %(delta3_out)s\\n        if (i >= -THREADS*0) *(delta_out + THREADS*0) = delta0_val;\\n        if (i >= -THREADS*1) *(delta_out + THREADS*1) = delta1_val;\\n        if (i >= -THREADS*2) *(delta_out + THREADS*2) = delta2_val;\\n                             *(delta_out + THREADS*3) = delta3_val;\\n        delta_out -= THREADS*4;\\n    }\\n}\\n'\n    out_code = _ew_strings['round']['nearest'].get(dtype, 'float {0} = {1};')\n    common_code = _common_round['nearest'].get(dtype, '')\n    if dtype == 'f2':\n        common_code += _common_fp16_to_fp32\n    if compute_capability[0] == 3 and compute_capability[1] < 5 or compute_capability[0] < 3:\n        common_code += _common_kepler\n    code = code % {'common': common_code, 'binary': shift_element(), 'share': shr_code, 'red': red_code, 'threads': threads, 'type': _ew_types[dtype]['type'], 'cvt': _ew_types[dtype]['cvt'], 'delta0_out': out_code.format('delta0_val', 'delta0'), 'delta1_out': out_code.format('delta1_val', 'delta1'), 'delta2_out': out_code.format('delta2_val', 'delta2'), 'delta3_out': out_code.format('delta3_val', 'delta3')}\n    module = SourceModule(code, options=['--use_fast_math'])\n    kernel = module.get_function('batchnorm_bprop')\n    kernel.prepare('PPPPPPPPfII')\n    kernel.name = 'batchnorm_bprop'\n    return kernel"
        ]
    }
]