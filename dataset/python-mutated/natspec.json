[
    {
        "func_name": "parse_natspec",
        "original": "def parse_natspec(vyper_module_folded: vy_ast.Module) -> Tuple[dict, dict]:\n    \"\"\"\n    Parses NatSpec documentation from a contract.\n\n    Arguments\n    ---------\n    vyper_module_folded : Module\n        Module-level vyper ast node.\n    interface_codes: Dict, optional\n        Dict containing relevant data for any import statements related to\n        this contract.\n\n    Returns\n    -------\n    dict\n        NatSpec user documentation\n    dict\n        NatSpec developer documentation\n    \"\"\"\n    from vyper.semantics.types.function import FunctionVisibility\n    (userdoc, devdoc) = ({}, {})\n    source: str = vyper_module_folded.full_source_code\n    docstring = vyper_module_folded.get('doc_string.value')\n    if docstring:\n        devdoc.update(_parse_docstring(source, docstring, ('param', 'return')))\n        if 'notice' in devdoc:\n            userdoc['notice'] = devdoc.pop('notice')\n    for node in [i for i in vyper_module_folded.body if i.get('doc_string.value')]:\n        docstring = node.doc_string.value\n        func_type = node._metadata['type']\n        if func_type.visibility != FunctionVisibility.EXTERNAL:\n            continue\n        if isinstance(node.returns, vy_ast.Tuple):\n            ret_len = len(node.returns.elements)\n        elif node.returns:\n            ret_len = 1\n        else:\n            ret_len = 0\n        args = tuple((i.arg for i in node.args.args))\n        invalid_fields = ('title', 'license')\n        fn_natspec = _parse_docstring(source, docstring, invalid_fields, args, ret_len)\n        for method_id in func_type.method_ids:\n            if 'notice' in fn_natspec:\n                userdoc.setdefault('methods', {})[method_id] = {'notice': fn_natspec.pop('notice')}\n            if fn_natspec:\n                devdoc.setdefault('methods', {})[method_id] = fn_natspec\n    return (userdoc, devdoc)",
        "mutated": [
            "def parse_natspec(vyper_module_folded: vy_ast.Module) -> Tuple[dict, dict]:\n    if False:\n        i = 10\n    '\\n    Parses NatSpec documentation from a contract.\\n\\n    Arguments\\n    ---------\\n    vyper_module_folded : Module\\n        Module-level vyper ast node.\\n    interface_codes: Dict, optional\\n        Dict containing relevant data for any import statements related to\\n        this contract.\\n\\n    Returns\\n    -------\\n    dict\\n        NatSpec user documentation\\n    dict\\n        NatSpec developer documentation\\n    '\n    from vyper.semantics.types.function import FunctionVisibility\n    (userdoc, devdoc) = ({}, {})\n    source: str = vyper_module_folded.full_source_code\n    docstring = vyper_module_folded.get('doc_string.value')\n    if docstring:\n        devdoc.update(_parse_docstring(source, docstring, ('param', 'return')))\n        if 'notice' in devdoc:\n            userdoc['notice'] = devdoc.pop('notice')\n    for node in [i for i in vyper_module_folded.body if i.get('doc_string.value')]:\n        docstring = node.doc_string.value\n        func_type = node._metadata['type']\n        if func_type.visibility != FunctionVisibility.EXTERNAL:\n            continue\n        if isinstance(node.returns, vy_ast.Tuple):\n            ret_len = len(node.returns.elements)\n        elif node.returns:\n            ret_len = 1\n        else:\n            ret_len = 0\n        args = tuple((i.arg for i in node.args.args))\n        invalid_fields = ('title', 'license')\n        fn_natspec = _parse_docstring(source, docstring, invalid_fields, args, ret_len)\n        for method_id in func_type.method_ids:\n            if 'notice' in fn_natspec:\n                userdoc.setdefault('methods', {})[method_id] = {'notice': fn_natspec.pop('notice')}\n            if fn_natspec:\n                devdoc.setdefault('methods', {})[method_id] = fn_natspec\n    return (userdoc, devdoc)",
            "def parse_natspec(vyper_module_folded: vy_ast.Module) -> Tuple[dict, dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Parses NatSpec documentation from a contract.\\n\\n    Arguments\\n    ---------\\n    vyper_module_folded : Module\\n        Module-level vyper ast node.\\n    interface_codes: Dict, optional\\n        Dict containing relevant data for any import statements related to\\n        this contract.\\n\\n    Returns\\n    -------\\n    dict\\n        NatSpec user documentation\\n    dict\\n        NatSpec developer documentation\\n    '\n    from vyper.semantics.types.function import FunctionVisibility\n    (userdoc, devdoc) = ({}, {})\n    source: str = vyper_module_folded.full_source_code\n    docstring = vyper_module_folded.get('doc_string.value')\n    if docstring:\n        devdoc.update(_parse_docstring(source, docstring, ('param', 'return')))\n        if 'notice' in devdoc:\n            userdoc['notice'] = devdoc.pop('notice')\n    for node in [i for i in vyper_module_folded.body if i.get('doc_string.value')]:\n        docstring = node.doc_string.value\n        func_type = node._metadata['type']\n        if func_type.visibility != FunctionVisibility.EXTERNAL:\n            continue\n        if isinstance(node.returns, vy_ast.Tuple):\n            ret_len = len(node.returns.elements)\n        elif node.returns:\n            ret_len = 1\n        else:\n            ret_len = 0\n        args = tuple((i.arg for i in node.args.args))\n        invalid_fields = ('title', 'license')\n        fn_natspec = _parse_docstring(source, docstring, invalid_fields, args, ret_len)\n        for method_id in func_type.method_ids:\n            if 'notice' in fn_natspec:\n                userdoc.setdefault('methods', {})[method_id] = {'notice': fn_natspec.pop('notice')}\n            if fn_natspec:\n                devdoc.setdefault('methods', {})[method_id] = fn_natspec\n    return (userdoc, devdoc)",
            "def parse_natspec(vyper_module_folded: vy_ast.Module) -> Tuple[dict, dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Parses NatSpec documentation from a contract.\\n\\n    Arguments\\n    ---------\\n    vyper_module_folded : Module\\n        Module-level vyper ast node.\\n    interface_codes: Dict, optional\\n        Dict containing relevant data for any import statements related to\\n        this contract.\\n\\n    Returns\\n    -------\\n    dict\\n        NatSpec user documentation\\n    dict\\n        NatSpec developer documentation\\n    '\n    from vyper.semantics.types.function import FunctionVisibility\n    (userdoc, devdoc) = ({}, {})\n    source: str = vyper_module_folded.full_source_code\n    docstring = vyper_module_folded.get('doc_string.value')\n    if docstring:\n        devdoc.update(_parse_docstring(source, docstring, ('param', 'return')))\n        if 'notice' in devdoc:\n            userdoc['notice'] = devdoc.pop('notice')\n    for node in [i for i in vyper_module_folded.body if i.get('doc_string.value')]:\n        docstring = node.doc_string.value\n        func_type = node._metadata['type']\n        if func_type.visibility != FunctionVisibility.EXTERNAL:\n            continue\n        if isinstance(node.returns, vy_ast.Tuple):\n            ret_len = len(node.returns.elements)\n        elif node.returns:\n            ret_len = 1\n        else:\n            ret_len = 0\n        args = tuple((i.arg for i in node.args.args))\n        invalid_fields = ('title', 'license')\n        fn_natspec = _parse_docstring(source, docstring, invalid_fields, args, ret_len)\n        for method_id in func_type.method_ids:\n            if 'notice' in fn_natspec:\n                userdoc.setdefault('methods', {})[method_id] = {'notice': fn_natspec.pop('notice')}\n            if fn_natspec:\n                devdoc.setdefault('methods', {})[method_id] = fn_natspec\n    return (userdoc, devdoc)",
            "def parse_natspec(vyper_module_folded: vy_ast.Module) -> Tuple[dict, dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Parses NatSpec documentation from a contract.\\n\\n    Arguments\\n    ---------\\n    vyper_module_folded : Module\\n        Module-level vyper ast node.\\n    interface_codes: Dict, optional\\n        Dict containing relevant data for any import statements related to\\n        this contract.\\n\\n    Returns\\n    -------\\n    dict\\n        NatSpec user documentation\\n    dict\\n        NatSpec developer documentation\\n    '\n    from vyper.semantics.types.function import FunctionVisibility\n    (userdoc, devdoc) = ({}, {})\n    source: str = vyper_module_folded.full_source_code\n    docstring = vyper_module_folded.get('doc_string.value')\n    if docstring:\n        devdoc.update(_parse_docstring(source, docstring, ('param', 'return')))\n        if 'notice' in devdoc:\n            userdoc['notice'] = devdoc.pop('notice')\n    for node in [i for i in vyper_module_folded.body if i.get('doc_string.value')]:\n        docstring = node.doc_string.value\n        func_type = node._metadata['type']\n        if func_type.visibility != FunctionVisibility.EXTERNAL:\n            continue\n        if isinstance(node.returns, vy_ast.Tuple):\n            ret_len = len(node.returns.elements)\n        elif node.returns:\n            ret_len = 1\n        else:\n            ret_len = 0\n        args = tuple((i.arg for i in node.args.args))\n        invalid_fields = ('title', 'license')\n        fn_natspec = _parse_docstring(source, docstring, invalid_fields, args, ret_len)\n        for method_id in func_type.method_ids:\n            if 'notice' in fn_natspec:\n                userdoc.setdefault('methods', {})[method_id] = {'notice': fn_natspec.pop('notice')}\n            if fn_natspec:\n                devdoc.setdefault('methods', {})[method_id] = fn_natspec\n    return (userdoc, devdoc)",
            "def parse_natspec(vyper_module_folded: vy_ast.Module) -> Tuple[dict, dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Parses NatSpec documentation from a contract.\\n\\n    Arguments\\n    ---------\\n    vyper_module_folded : Module\\n        Module-level vyper ast node.\\n    interface_codes: Dict, optional\\n        Dict containing relevant data for any import statements related to\\n        this contract.\\n\\n    Returns\\n    -------\\n    dict\\n        NatSpec user documentation\\n    dict\\n        NatSpec developer documentation\\n    '\n    from vyper.semantics.types.function import FunctionVisibility\n    (userdoc, devdoc) = ({}, {})\n    source: str = vyper_module_folded.full_source_code\n    docstring = vyper_module_folded.get('doc_string.value')\n    if docstring:\n        devdoc.update(_parse_docstring(source, docstring, ('param', 'return')))\n        if 'notice' in devdoc:\n            userdoc['notice'] = devdoc.pop('notice')\n    for node in [i for i in vyper_module_folded.body if i.get('doc_string.value')]:\n        docstring = node.doc_string.value\n        func_type = node._metadata['type']\n        if func_type.visibility != FunctionVisibility.EXTERNAL:\n            continue\n        if isinstance(node.returns, vy_ast.Tuple):\n            ret_len = len(node.returns.elements)\n        elif node.returns:\n            ret_len = 1\n        else:\n            ret_len = 0\n        args = tuple((i.arg for i in node.args.args))\n        invalid_fields = ('title', 'license')\n        fn_natspec = _parse_docstring(source, docstring, invalid_fields, args, ret_len)\n        for method_id in func_type.method_ids:\n            if 'notice' in fn_natspec:\n                userdoc.setdefault('methods', {})[method_id] = {'notice': fn_natspec.pop('notice')}\n            if fn_natspec:\n                devdoc.setdefault('methods', {})[method_id] = fn_natspec\n    return (userdoc, devdoc)"
        ]
    },
    {
        "func_name": "_parse_docstring",
        "original": "def _parse_docstring(source: str, docstring: str, invalid_fields: Tuple, params: Optional[Tuple]=None, return_length: int=0) -> dict:\n    natspec: dict = {}\n    if params is None:\n        params = tuple()\n    line_no = LineNumbers(source)\n    start = source.index(docstring)\n    translate_map = {'return': 'returns', 'dev': 'details', 'param': 'params'}\n    pattern = '(?:^|\\\\n)\\\\s*@(\\\\S+)\\\\s*([\\\\s\\\\S]*?)(?=\\\\n\\\\s*@\\\\S|\\\\s*$)'\n    for match in re.finditer(pattern, docstring):\n        (tag, value) = match.groups()\n        err_args = (source, *line_no.offset_to_line(start + match.start(1)))\n        if tag not in SINGLE_FIELDS + PARAM_FIELDS and (not tag.startswith('custom:')):\n            raise NatSpecSyntaxException(f\"Unknown NatSpec field '@{tag}'\", *err_args)\n        if tag in invalid_fields:\n            raise NatSpecSyntaxException(f\"'@{tag}' is not a valid field for this docstring\", *err_args)\n        if not value or value.startswith('@'):\n            raise NatSpecSyntaxException(f\"No description given for tag '@{tag}'\", *err_args)\n        if tag not in PARAM_FIELDS:\n            if tag in natspec:\n                raise NatSpecSyntaxException(f\"Duplicate NatSpec field '@{tag}'\", *err_args)\n            natspec[translate_map.get(tag, tag)] = ' '.join(value.split())\n            continue\n        tag = translate_map.get(tag, tag)\n        natspec.setdefault(tag, {})\n        if tag == 'params':\n            try:\n                (key, value) = value.split(maxsplit=1)\n            except ValueError as exc:\n                raise NatSpecSyntaxException(f\"No description given for parameter '{value}'\", *err_args) from exc\n            if key not in params:\n                raise NatSpecSyntaxException(f\"Method has no parameter '{key}'\", *err_args)\n        elif tag == 'returns':\n            if not return_length:\n                raise NatSpecSyntaxException('Method does not return any values', *err_args)\n            if len(natspec['returns']) >= return_length:\n                raise NatSpecSyntaxException('Number of documented return values exceeds actual number', *err_args)\n            key = f\"_{len(natspec['returns'])}\"\n        if key in natspec[tag]:\n            raise NatSpecSyntaxException(f\"Parameter '{key}' documented more than once\", *err_args)\n        natspec[tag][key] = ' '.join(value.split())\n    if not natspec:\n        natspec['notice'] = ' '.join(docstring.split())\n    elif not docstring.strip().startswith('@'):\n        raise NatSpecSyntaxException('NatSpec docstring opens with untagged comment', source, *line_no.offset_to_line(start))\n    return natspec",
        "mutated": [
            "def _parse_docstring(source: str, docstring: str, invalid_fields: Tuple, params: Optional[Tuple]=None, return_length: int=0) -> dict:\n    if False:\n        i = 10\n    natspec: dict = {}\n    if params is None:\n        params = tuple()\n    line_no = LineNumbers(source)\n    start = source.index(docstring)\n    translate_map = {'return': 'returns', 'dev': 'details', 'param': 'params'}\n    pattern = '(?:^|\\\\n)\\\\s*@(\\\\S+)\\\\s*([\\\\s\\\\S]*?)(?=\\\\n\\\\s*@\\\\S|\\\\s*$)'\n    for match in re.finditer(pattern, docstring):\n        (tag, value) = match.groups()\n        err_args = (source, *line_no.offset_to_line(start + match.start(1)))\n        if tag not in SINGLE_FIELDS + PARAM_FIELDS and (not tag.startswith('custom:')):\n            raise NatSpecSyntaxException(f\"Unknown NatSpec field '@{tag}'\", *err_args)\n        if tag in invalid_fields:\n            raise NatSpecSyntaxException(f\"'@{tag}' is not a valid field for this docstring\", *err_args)\n        if not value or value.startswith('@'):\n            raise NatSpecSyntaxException(f\"No description given for tag '@{tag}'\", *err_args)\n        if tag not in PARAM_FIELDS:\n            if tag in natspec:\n                raise NatSpecSyntaxException(f\"Duplicate NatSpec field '@{tag}'\", *err_args)\n            natspec[translate_map.get(tag, tag)] = ' '.join(value.split())\n            continue\n        tag = translate_map.get(tag, tag)\n        natspec.setdefault(tag, {})\n        if tag == 'params':\n            try:\n                (key, value) = value.split(maxsplit=1)\n            except ValueError as exc:\n                raise NatSpecSyntaxException(f\"No description given for parameter '{value}'\", *err_args) from exc\n            if key not in params:\n                raise NatSpecSyntaxException(f\"Method has no parameter '{key}'\", *err_args)\n        elif tag == 'returns':\n            if not return_length:\n                raise NatSpecSyntaxException('Method does not return any values', *err_args)\n            if len(natspec['returns']) >= return_length:\n                raise NatSpecSyntaxException('Number of documented return values exceeds actual number', *err_args)\n            key = f\"_{len(natspec['returns'])}\"\n        if key in natspec[tag]:\n            raise NatSpecSyntaxException(f\"Parameter '{key}' documented more than once\", *err_args)\n        natspec[tag][key] = ' '.join(value.split())\n    if not natspec:\n        natspec['notice'] = ' '.join(docstring.split())\n    elif not docstring.strip().startswith('@'):\n        raise NatSpecSyntaxException('NatSpec docstring opens with untagged comment', source, *line_no.offset_to_line(start))\n    return natspec",
            "def _parse_docstring(source: str, docstring: str, invalid_fields: Tuple, params: Optional[Tuple]=None, return_length: int=0) -> dict:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    natspec: dict = {}\n    if params is None:\n        params = tuple()\n    line_no = LineNumbers(source)\n    start = source.index(docstring)\n    translate_map = {'return': 'returns', 'dev': 'details', 'param': 'params'}\n    pattern = '(?:^|\\\\n)\\\\s*@(\\\\S+)\\\\s*([\\\\s\\\\S]*?)(?=\\\\n\\\\s*@\\\\S|\\\\s*$)'\n    for match in re.finditer(pattern, docstring):\n        (tag, value) = match.groups()\n        err_args = (source, *line_no.offset_to_line(start + match.start(1)))\n        if tag not in SINGLE_FIELDS + PARAM_FIELDS and (not tag.startswith('custom:')):\n            raise NatSpecSyntaxException(f\"Unknown NatSpec field '@{tag}'\", *err_args)\n        if tag in invalid_fields:\n            raise NatSpecSyntaxException(f\"'@{tag}' is not a valid field for this docstring\", *err_args)\n        if not value or value.startswith('@'):\n            raise NatSpecSyntaxException(f\"No description given for tag '@{tag}'\", *err_args)\n        if tag not in PARAM_FIELDS:\n            if tag in natspec:\n                raise NatSpecSyntaxException(f\"Duplicate NatSpec field '@{tag}'\", *err_args)\n            natspec[translate_map.get(tag, tag)] = ' '.join(value.split())\n            continue\n        tag = translate_map.get(tag, tag)\n        natspec.setdefault(tag, {})\n        if tag == 'params':\n            try:\n                (key, value) = value.split(maxsplit=1)\n            except ValueError as exc:\n                raise NatSpecSyntaxException(f\"No description given for parameter '{value}'\", *err_args) from exc\n            if key not in params:\n                raise NatSpecSyntaxException(f\"Method has no parameter '{key}'\", *err_args)\n        elif tag == 'returns':\n            if not return_length:\n                raise NatSpecSyntaxException('Method does not return any values', *err_args)\n            if len(natspec['returns']) >= return_length:\n                raise NatSpecSyntaxException('Number of documented return values exceeds actual number', *err_args)\n            key = f\"_{len(natspec['returns'])}\"\n        if key in natspec[tag]:\n            raise NatSpecSyntaxException(f\"Parameter '{key}' documented more than once\", *err_args)\n        natspec[tag][key] = ' '.join(value.split())\n    if not natspec:\n        natspec['notice'] = ' '.join(docstring.split())\n    elif not docstring.strip().startswith('@'):\n        raise NatSpecSyntaxException('NatSpec docstring opens with untagged comment', source, *line_no.offset_to_line(start))\n    return natspec",
            "def _parse_docstring(source: str, docstring: str, invalid_fields: Tuple, params: Optional[Tuple]=None, return_length: int=0) -> dict:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    natspec: dict = {}\n    if params is None:\n        params = tuple()\n    line_no = LineNumbers(source)\n    start = source.index(docstring)\n    translate_map = {'return': 'returns', 'dev': 'details', 'param': 'params'}\n    pattern = '(?:^|\\\\n)\\\\s*@(\\\\S+)\\\\s*([\\\\s\\\\S]*?)(?=\\\\n\\\\s*@\\\\S|\\\\s*$)'\n    for match in re.finditer(pattern, docstring):\n        (tag, value) = match.groups()\n        err_args = (source, *line_no.offset_to_line(start + match.start(1)))\n        if tag not in SINGLE_FIELDS + PARAM_FIELDS and (not tag.startswith('custom:')):\n            raise NatSpecSyntaxException(f\"Unknown NatSpec field '@{tag}'\", *err_args)\n        if tag in invalid_fields:\n            raise NatSpecSyntaxException(f\"'@{tag}' is not a valid field for this docstring\", *err_args)\n        if not value or value.startswith('@'):\n            raise NatSpecSyntaxException(f\"No description given for tag '@{tag}'\", *err_args)\n        if tag not in PARAM_FIELDS:\n            if tag in natspec:\n                raise NatSpecSyntaxException(f\"Duplicate NatSpec field '@{tag}'\", *err_args)\n            natspec[translate_map.get(tag, tag)] = ' '.join(value.split())\n            continue\n        tag = translate_map.get(tag, tag)\n        natspec.setdefault(tag, {})\n        if tag == 'params':\n            try:\n                (key, value) = value.split(maxsplit=1)\n            except ValueError as exc:\n                raise NatSpecSyntaxException(f\"No description given for parameter '{value}'\", *err_args) from exc\n            if key not in params:\n                raise NatSpecSyntaxException(f\"Method has no parameter '{key}'\", *err_args)\n        elif tag == 'returns':\n            if not return_length:\n                raise NatSpecSyntaxException('Method does not return any values', *err_args)\n            if len(natspec['returns']) >= return_length:\n                raise NatSpecSyntaxException('Number of documented return values exceeds actual number', *err_args)\n            key = f\"_{len(natspec['returns'])}\"\n        if key in natspec[tag]:\n            raise NatSpecSyntaxException(f\"Parameter '{key}' documented more than once\", *err_args)\n        natspec[tag][key] = ' '.join(value.split())\n    if not natspec:\n        natspec['notice'] = ' '.join(docstring.split())\n    elif not docstring.strip().startswith('@'):\n        raise NatSpecSyntaxException('NatSpec docstring opens with untagged comment', source, *line_no.offset_to_line(start))\n    return natspec",
            "def _parse_docstring(source: str, docstring: str, invalid_fields: Tuple, params: Optional[Tuple]=None, return_length: int=0) -> dict:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    natspec: dict = {}\n    if params is None:\n        params = tuple()\n    line_no = LineNumbers(source)\n    start = source.index(docstring)\n    translate_map = {'return': 'returns', 'dev': 'details', 'param': 'params'}\n    pattern = '(?:^|\\\\n)\\\\s*@(\\\\S+)\\\\s*([\\\\s\\\\S]*?)(?=\\\\n\\\\s*@\\\\S|\\\\s*$)'\n    for match in re.finditer(pattern, docstring):\n        (tag, value) = match.groups()\n        err_args = (source, *line_no.offset_to_line(start + match.start(1)))\n        if tag not in SINGLE_FIELDS + PARAM_FIELDS and (not tag.startswith('custom:')):\n            raise NatSpecSyntaxException(f\"Unknown NatSpec field '@{tag}'\", *err_args)\n        if tag in invalid_fields:\n            raise NatSpecSyntaxException(f\"'@{tag}' is not a valid field for this docstring\", *err_args)\n        if not value or value.startswith('@'):\n            raise NatSpecSyntaxException(f\"No description given for tag '@{tag}'\", *err_args)\n        if tag not in PARAM_FIELDS:\n            if tag in natspec:\n                raise NatSpecSyntaxException(f\"Duplicate NatSpec field '@{tag}'\", *err_args)\n            natspec[translate_map.get(tag, tag)] = ' '.join(value.split())\n            continue\n        tag = translate_map.get(tag, tag)\n        natspec.setdefault(tag, {})\n        if tag == 'params':\n            try:\n                (key, value) = value.split(maxsplit=1)\n            except ValueError as exc:\n                raise NatSpecSyntaxException(f\"No description given for parameter '{value}'\", *err_args) from exc\n            if key not in params:\n                raise NatSpecSyntaxException(f\"Method has no parameter '{key}'\", *err_args)\n        elif tag == 'returns':\n            if not return_length:\n                raise NatSpecSyntaxException('Method does not return any values', *err_args)\n            if len(natspec['returns']) >= return_length:\n                raise NatSpecSyntaxException('Number of documented return values exceeds actual number', *err_args)\n            key = f\"_{len(natspec['returns'])}\"\n        if key in natspec[tag]:\n            raise NatSpecSyntaxException(f\"Parameter '{key}' documented more than once\", *err_args)\n        natspec[tag][key] = ' '.join(value.split())\n    if not natspec:\n        natspec['notice'] = ' '.join(docstring.split())\n    elif not docstring.strip().startswith('@'):\n        raise NatSpecSyntaxException('NatSpec docstring opens with untagged comment', source, *line_no.offset_to_line(start))\n    return natspec",
            "def _parse_docstring(source: str, docstring: str, invalid_fields: Tuple, params: Optional[Tuple]=None, return_length: int=0) -> dict:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    natspec: dict = {}\n    if params is None:\n        params = tuple()\n    line_no = LineNumbers(source)\n    start = source.index(docstring)\n    translate_map = {'return': 'returns', 'dev': 'details', 'param': 'params'}\n    pattern = '(?:^|\\\\n)\\\\s*@(\\\\S+)\\\\s*([\\\\s\\\\S]*?)(?=\\\\n\\\\s*@\\\\S|\\\\s*$)'\n    for match in re.finditer(pattern, docstring):\n        (tag, value) = match.groups()\n        err_args = (source, *line_no.offset_to_line(start + match.start(1)))\n        if tag not in SINGLE_FIELDS + PARAM_FIELDS and (not tag.startswith('custom:')):\n            raise NatSpecSyntaxException(f\"Unknown NatSpec field '@{tag}'\", *err_args)\n        if tag in invalid_fields:\n            raise NatSpecSyntaxException(f\"'@{tag}' is not a valid field for this docstring\", *err_args)\n        if not value or value.startswith('@'):\n            raise NatSpecSyntaxException(f\"No description given for tag '@{tag}'\", *err_args)\n        if tag not in PARAM_FIELDS:\n            if tag in natspec:\n                raise NatSpecSyntaxException(f\"Duplicate NatSpec field '@{tag}'\", *err_args)\n            natspec[translate_map.get(tag, tag)] = ' '.join(value.split())\n            continue\n        tag = translate_map.get(tag, tag)\n        natspec.setdefault(tag, {})\n        if tag == 'params':\n            try:\n                (key, value) = value.split(maxsplit=1)\n            except ValueError as exc:\n                raise NatSpecSyntaxException(f\"No description given for parameter '{value}'\", *err_args) from exc\n            if key not in params:\n                raise NatSpecSyntaxException(f\"Method has no parameter '{key}'\", *err_args)\n        elif tag == 'returns':\n            if not return_length:\n                raise NatSpecSyntaxException('Method does not return any values', *err_args)\n            if len(natspec['returns']) >= return_length:\n                raise NatSpecSyntaxException('Number of documented return values exceeds actual number', *err_args)\n            key = f\"_{len(natspec['returns'])}\"\n        if key in natspec[tag]:\n            raise NatSpecSyntaxException(f\"Parameter '{key}' documented more than once\", *err_args)\n        natspec[tag][key] = ' '.join(value.split())\n    if not natspec:\n        natspec['notice'] = ' '.join(docstring.split())\n    elif not docstring.strip().startswith('@'):\n        raise NatSpecSyntaxException('NatSpec docstring opens with untagged comment', source, *line_no.offset_to_line(start))\n    return natspec"
        ]
    }
]