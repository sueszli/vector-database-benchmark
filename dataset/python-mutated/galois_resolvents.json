[
    {
        "func_name": "__init__",
        "original": "def __init__(self, F, X, s):\n    \"\"\"\n        Parameters\n        ==========\n\n        F : :py:class:`~.Expr`\n            polynomial in the symbols in *X*\n        X : list of :py:class:`~.Symbol`\n        s : list of :py:class:`~.Permutation`\n            representing the cosets of the stabilizer of *F* in\n            some subgroup $G$ of $S_n$, where $n$ is the length of *X*.\n        \"\"\"\n    self.F = F\n    self.X = X\n    self.s = s\n    self.m = len(s)\n    self.t = None\n    self.r = 0\n    for (monom, coeff) in Poly(F).terms():\n        if abs(coeff) != 1:\n            raise ResolventException('Resolvent class expects forms with unit coeffs')\n        t = sum(monom)\n        if t != self.t and self.t is not None:\n            raise ResolventException('Resolvent class expects homogeneous forms')\n        self.t = t\n        self.r += 1\n    (m, t, r) = (self.m, self.t, self.r)\n    if not m < r * 2 ** t:\n        raise ResolventException('Resolvent class expects m < r*2^t')\n    M = symbols('M')\n    self.coeff_prec_func = Poly(r ** m * (m * t + 1) * M ** (m * t - 1))\n    self.root_prec_func = Poly(r * (t + 1) * M ** (t - 1))\n    self.root_lambdas = [lambdify((~s[j])(X), F) for j in range(self.m)]\n    Y = symbols('Y')\n    R = symbols(' '.join((f'R{i}' for i in range(m))))\n    f = 1\n    for r in R:\n        f *= Y - r\n    C = Poly(f, Y).coeffs()\n    self.esf_lambdas = [lambdify(R, c) for c in C]",
        "mutated": [
            "def __init__(self, F, X, s):\n    if False:\n        i = 10\n    '\\n        Parameters\\n        ==========\\n\\n        F : :py:class:`~.Expr`\\n            polynomial in the symbols in *X*\\n        X : list of :py:class:`~.Symbol`\\n        s : list of :py:class:`~.Permutation`\\n            representing the cosets of the stabilizer of *F* in\\n            some subgroup $G$ of $S_n$, where $n$ is the length of *X*.\\n        '\n    self.F = F\n    self.X = X\n    self.s = s\n    self.m = len(s)\n    self.t = None\n    self.r = 0\n    for (monom, coeff) in Poly(F).terms():\n        if abs(coeff) != 1:\n            raise ResolventException('Resolvent class expects forms with unit coeffs')\n        t = sum(monom)\n        if t != self.t and self.t is not None:\n            raise ResolventException('Resolvent class expects homogeneous forms')\n        self.t = t\n        self.r += 1\n    (m, t, r) = (self.m, self.t, self.r)\n    if not m < r * 2 ** t:\n        raise ResolventException('Resolvent class expects m < r*2^t')\n    M = symbols('M')\n    self.coeff_prec_func = Poly(r ** m * (m * t + 1) * M ** (m * t - 1))\n    self.root_prec_func = Poly(r * (t + 1) * M ** (t - 1))\n    self.root_lambdas = [lambdify((~s[j])(X), F) for j in range(self.m)]\n    Y = symbols('Y')\n    R = symbols(' '.join((f'R{i}' for i in range(m))))\n    f = 1\n    for r in R:\n        f *= Y - r\n    C = Poly(f, Y).coeffs()\n    self.esf_lambdas = [lambdify(R, c) for c in C]",
            "def __init__(self, F, X, s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Parameters\\n        ==========\\n\\n        F : :py:class:`~.Expr`\\n            polynomial in the symbols in *X*\\n        X : list of :py:class:`~.Symbol`\\n        s : list of :py:class:`~.Permutation`\\n            representing the cosets of the stabilizer of *F* in\\n            some subgroup $G$ of $S_n$, where $n$ is the length of *X*.\\n        '\n    self.F = F\n    self.X = X\n    self.s = s\n    self.m = len(s)\n    self.t = None\n    self.r = 0\n    for (monom, coeff) in Poly(F).terms():\n        if abs(coeff) != 1:\n            raise ResolventException('Resolvent class expects forms with unit coeffs')\n        t = sum(monom)\n        if t != self.t and self.t is not None:\n            raise ResolventException('Resolvent class expects homogeneous forms')\n        self.t = t\n        self.r += 1\n    (m, t, r) = (self.m, self.t, self.r)\n    if not m < r * 2 ** t:\n        raise ResolventException('Resolvent class expects m < r*2^t')\n    M = symbols('M')\n    self.coeff_prec_func = Poly(r ** m * (m * t + 1) * M ** (m * t - 1))\n    self.root_prec_func = Poly(r * (t + 1) * M ** (t - 1))\n    self.root_lambdas = [lambdify((~s[j])(X), F) for j in range(self.m)]\n    Y = symbols('Y')\n    R = symbols(' '.join((f'R{i}' for i in range(m))))\n    f = 1\n    for r in R:\n        f *= Y - r\n    C = Poly(f, Y).coeffs()\n    self.esf_lambdas = [lambdify(R, c) for c in C]",
            "def __init__(self, F, X, s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Parameters\\n        ==========\\n\\n        F : :py:class:`~.Expr`\\n            polynomial in the symbols in *X*\\n        X : list of :py:class:`~.Symbol`\\n        s : list of :py:class:`~.Permutation`\\n            representing the cosets of the stabilizer of *F* in\\n            some subgroup $G$ of $S_n$, where $n$ is the length of *X*.\\n        '\n    self.F = F\n    self.X = X\n    self.s = s\n    self.m = len(s)\n    self.t = None\n    self.r = 0\n    for (monom, coeff) in Poly(F).terms():\n        if abs(coeff) != 1:\n            raise ResolventException('Resolvent class expects forms with unit coeffs')\n        t = sum(monom)\n        if t != self.t and self.t is not None:\n            raise ResolventException('Resolvent class expects homogeneous forms')\n        self.t = t\n        self.r += 1\n    (m, t, r) = (self.m, self.t, self.r)\n    if not m < r * 2 ** t:\n        raise ResolventException('Resolvent class expects m < r*2^t')\n    M = symbols('M')\n    self.coeff_prec_func = Poly(r ** m * (m * t + 1) * M ** (m * t - 1))\n    self.root_prec_func = Poly(r * (t + 1) * M ** (t - 1))\n    self.root_lambdas = [lambdify((~s[j])(X), F) for j in range(self.m)]\n    Y = symbols('Y')\n    R = symbols(' '.join((f'R{i}' for i in range(m))))\n    f = 1\n    for r in R:\n        f *= Y - r\n    C = Poly(f, Y).coeffs()\n    self.esf_lambdas = [lambdify(R, c) for c in C]",
            "def __init__(self, F, X, s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Parameters\\n        ==========\\n\\n        F : :py:class:`~.Expr`\\n            polynomial in the symbols in *X*\\n        X : list of :py:class:`~.Symbol`\\n        s : list of :py:class:`~.Permutation`\\n            representing the cosets of the stabilizer of *F* in\\n            some subgroup $G$ of $S_n$, where $n$ is the length of *X*.\\n        '\n    self.F = F\n    self.X = X\n    self.s = s\n    self.m = len(s)\n    self.t = None\n    self.r = 0\n    for (monom, coeff) in Poly(F).terms():\n        if abs(coeff) != 1:\n            raise ResolventException('Resolvent class expects forms with unit coeffs')\n        t = sum(monom)\n        if t != self.t and self.t is not None:\n            raise ResolventException('Resolvent class expects homogeneous forms')\n        self.t = t\n        self.r += 1\n    (m, t, r) = (self.m, self.t, self.r)\n    if not m < r * 2 ** t:\n        raise ResolventException('Resolvent class expects m < r*2^t')\n    M = symbols('M')\n    self.coeff_prec_func = Poly(r ** m * (m * t + 1) * M ** (m * t - 1))\n    self.root_prec_func = Poly(r * (t + 1) * M ** (t - 1))\n    self.root_lambdas = [lambdify((~s[j])(X), F) for j in range(self.m)]\n    Y = symbols('Y')\n    R = symbols(' '.join((f'R{i}' for i in range(m))))\n    f = 1\n    for r in R:\n        f *= Y - r\n    C = Poly(f, Y).coeffs()\n    self.esf_lambdas = [lambdify(R, c) for c in C]",
            "def __init__(self, F, X, s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Parameters\\n        ==========\\n\\n        F : :py:class:`~.Expr`\\n            polynomial in the symbols in *X*\\n        X : list of :py:class:`~.Symbol`\\n        s : list of :py:class:`~.Permutation`\\n            representing the cosets of the stabilizer of *F* in\\n            some subgroup $G$ of $S_n$, where $n$ is the length of *X*.\\n        '\n    self.F = F\n    self.X = X\n    self.s = s\n    self.m = len(s)\n    self.t = None\n    self.r = 0\n    for (monom, coeff) in Poly(F).terms():\n        if abs(coeff) != 1:\n            raise ResolventException('Resolvent class expects forms with unit coeffs')\n        t = sum(monom)\n        if t != self.t and self.t is not None:\n            raise ResolventException('Resolvent class expects homogeneous forms')\n        self.t = t\n        self.r += 1\n    (m, t, r) = (self.m, self.t, self.r)\n    if not m < r * 2 ** t:\n        raise ResolventException('Resolvent class expects m < r*2^t')\n    M = symbols('M')\n    self.coeff_prec_func = Poly(r ** m * (m * t + 1) * M ** (m * t - 1))\n    self.root_prec_func = Poly(r * (t + 1) * M ** (t - 1))\n    self.root_lambdas = [lambdify((~s[j])(X), F) for j in range(self.m)]\n    Y = symbols('Y')\n    R = symbols(' '.join((f'R{i}' for i in range(m))))\n    f = 1\n    for r in R:\n        f *= Y - r\n    C = Poly(f, Y).coeffs()\n    self.esf_lambdas = [lambdify(R, c) for c in C]"
        ]
    },
    {
        "func_name": "get_prec",
        "original": "def get_prec(self, M, target='coeffs'):\n    \"\"\"\n        For a given upper bound *M* on the magnitude of the complex numbers to\n        be plugged in for this resolvent's symbols, compute a sufficient\n        precision for evaluating those complex numbers, such that the\n        coefficients, or the integer roots, of the resolvent can be determined.\n\n        Parameters\n        ==========\n\n        M : real number\n            Upper bound on magnitude of the complex numbers to be plugged in.\n\n        target : str, 'coeffs' or 'roots', default='coeffs'\n            Name the task for which a sufficient precision is desired.\n            This is either determining the coefficients of the resolvent\n            ('coeffs') or determining its possible integer roots ('roots').\n            The latter may require significantly lower precision.\n\n        Returns\n        =======\n\n        int $m$\n            such that $2^{-m}$ is a sufficient upper bound on the\n            error in approximating the complex numbers to be plugged in.\n\n        \"\"\"\n    M = max(M, 2)\n    f = self.coeff_prec_func if target == 'coeffs' else self.root_prec_func\n    (r, _, _, _) = evalf(2 * f(M), 1, {})\n    return fastlog(r) + 1",
        "mutated": [
            "def get_prec(self, M, target='coeffs'):\n    if False:\n        i = 10\n    \"\\n        For a given upper bound *M* on the magnitude of the complex numbers to\\n        be plugged in for this resolvent's symbols, compute a sufficient\\n        precision for evaluating those complex numbers, such that the\\n        coefficients, or the integer roots, of the resolvent can be determined.\\n\\n        Parameters\\n        ==========\\n\\n        M : real number\\n            Upper bound on magnitude of the complex numbers to be plugged in.\\n\\n        target : str, 'coeffs' or 'roots', default='coeffs'\\n            Name the task for which a sufficient precision is desired.\\n            This is either determining the coefficients of the resolvent\\n            ('coeffs') or determining its possible integer roots ('roots').\\n            The latter may require significantly lower precision.\\n\\n        Returns\\n        =======\\n\\n        int $m$\\n            such that $2^{-m}$ is a sufficient upper bound on the\\n            error in approximating the complex numbers to be plugged in.\\n\\n        \"\n    M = max(M, 2)\n    f = self.coeff_prec_func if target == 'coeffs' else self.root_prec_func\n    (r, _, _, _) = evalf(2 * f(M), 1, {})\n    return fastlog(r) + 1",
            "def get_prec(self, M, target='coeffs'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        For a given upper bound *M* on the magnitude of the complex numbers to\\n        be plugged in for this resolvent's symbols, compute a sufficient\\n        precision for evaluating those complex numbers, such that the\\n        coefficients, or the integer roots, of the resolvent can be determined.\\n\\n        Parameters\\n        ==========\\n\\n        M : real number\\n            Upper bound on magnitude of the complex numbers to be plugged in.\\n\\n        target : str, 'coeffs' or 'roots', default='coeffs'\\n            Name the task for which a sufficient precision is desired.\\n            This is either determining the coefficients of the resolvent\\n            ('coeffs') or determining its possible integer roots ('roots').\\n            The latter may require significantly lower precision.\\n\\n        Returns\\n        =======\\n\\n        int $m$\\n            such that $2^{-m}$ is a sufficient upper bound on the\\n            error in approximating the complex numbers to be plugged in.\\n\\n        \"\n    M = max(M, 2)\n    f = self.coeff_prec_func if target == 'coeffs' else self.root_prec_func\n    (r, _, _, _) = evalf(2 * f(M), 1, {})\n    return fastlog(r) + 1",
            "def get_prec(self, M, target='coeffs'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        For a given upper bound *M* on the magnitude of the complex numbers to\\n        be plugged in for this resolvent's symbols, compute a sufficient\\n        precision for evaluating those complex numbers, such that the\\n        coefficients, or the integer roots, of the resolvent can be determined.\\n\\n        Parameters\\n        ==========\\n\\n        M : real number\\n            Upper bound on magnitude of the complex numbers to be plugged in.\\n\\n        target : str, 'coeffs' or 'roots', default='coeffs'\\n            Name the task for which a sufficient precision is desired.\\n            This is either determining the coefficients of the resolvent\\n            ('coeffs') or determining its possible integer roots ('roots').\\n            The latter may require significantly lower precision.\\n\\n        Returns\\n        =======\\n\\n        int $m$\\n            such that $2^{-m}$ is a sufficient upper bound on the\\n            error in approximating the complex numbers to be plugged in.\\n\\n        \"\n    M = max(M, 2)\n    f = self.coeff_prec_func if target == 'coeffs' else self.root_prec_func\n    (r, _, _, _) = evalf(2 * f(M), 1, {})\n    return fastlog(r) + 1",
            "def get_prec(self, M, target='coeffs'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        For a given upper bound *M* on the magnitude of the complex numbers to\\n        be plugged in for this resolvent's symbols, compute a sufficient\\n        precision for evaluating those complex numbers, such that the\\n        coefficients, or the integer roots, of the resolvent can be determined.\\n\\n        Parameters\\n        ==========\\n\\n        M : real number\\n            Upper bound on magnitude of the complex numbers to be plugged in.\\n\\n        target : str, 'coeffs' or 'roots', default='coeffs'\\n            Name the task for which a sufficient precision is desired.\\n            This is either determining the coefficients of the resolvent\\n            ('coeffs') or determining its possible integer roots ('roots').\\n            The latter may require significantly lower precision.\\n\\n        Returns\\n        =======\\n\\n        int $m$\\n            such that $2^{-m}$ is a sufficient upper bound on the\\n            error in approximating the complex numbers to be plugged in.\\n\\n        \"\n    M = max(M, 2)\n    f = self.coeff_prec_func if target == 'coeffs' else self.root_prec_func\n    (r, _, _, _) = evalf(2 * f(M), 1, {})\n    return fastlog(r) + 1",
            "def get_prec(self, M, target='coeffs'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        For a given upper bound *M* on the magnitude of the complex numbers to\\n        be plugged in for this resolvent's symbols, compute a sufficient\\n        precision for evaluating those complex numbers, such that the\\n        coefficients, or the integer roots, of the resolvent can be determined.\\n\\n        Parameters\\n        ==========\\n\\n        M : real number\\n            Upper bound on magnitude of the complex numbers to be plugged in.\\n\\n        target : str, 'coeffs' or 'roots', default='coeffs'\\n            Name the task for which a sufficient precision is desired.\\n            This is either determining the coefficients of the resolvent\\n            ('coeffs') or determining its possible integer roots ('roots').\\n            The latter may require significantly lower precision.\\n\\n        Returns\\n        =======\\n\\n        int $m$\\n            such that $2^{-m}$ is a sufficient upper bound on the\\n            error in approximating the complex numbers to be plugged in.\\n\\n        \"\n    M = max(M, 2)\n    f = self.coeff_prec_func if target == 'coeffs' else self.root_prec_func\n    (r, _, _, _) = evalf(2 * f(M), 1, {})\n    return fastlog(r) + 1"
        ]
    },
    {
        "func_name": "approximate_roots_of_poly",
        "original": "def approximate_roots_of_poly(self, T, target='coeffs'):\n    \"\"\"\n        Approximate the roots of a given polynomial *T* to sufficient precision\n        in order to evaluate this resolvent's coefficients, or determine\n        whether the resolvent has an integer root.\n\n        Parameters\n        ==========\n\n        T : :py:class:`~.Poly`\n\n        target : str, 'coeffs' or 'roots', default='coeffs'\n            Set the approximation precision to be sufficient for the desired\n            task, which is either determining the coefficients of the resolvent\n            ('coeffs') or determining its possible integer roots ('roots').\n            The latter may require significantly lower precision.\n\n        Returns\n        =======\n\n        list of elements of :ref:`CC`\n\n        \"\"\"\n    ctx = MPContext()\n    (coeff, T) = preprocess_roots(T)\n    coeff = ctx.mpf(str(coeff))\n    scaled_roots = T.all_roots(radicals=False)\n    approx0 = [coeff * quad_to_mpmath(_evalf_with_bounded_error(r, m=0)) for r in scaled_roots]\n    M = max((abs(b) for b in approx0)) + 1\n    m = self.get_prec(M, target=target)\n    n = fastlog(M._mpf_) + 1\n    p = m + n + 1\n    ctx.prec = p\n    d = prec_to_dps(p)\n    approx1 = [r.eval_approx(d, return_mpmath=True) for r in scaled_roots]\n    approx1 = [coeff * ctx.mpc(r) for r in approx1]\n    return approx1",
        "mutated": [
            "def approximate_roots_of_poly(self, T, target='coeffs'):\n    if False:\n        i = 10\n    \"\\n        Approximate the roots of a given polynomial *T* to sufficient precision\\n        in order to evaluate this resolvent's coefficients, or determine\\n        whether the resolvent has an integer root.\\n\\n        Parameters\\n        ==========\\n\\n        T : :py:class:`~.Poly`\\n\\n        target : str, 'coeffs' or 'roots', default='coeffs'\\n            Set the approximation precision to be sufficient for the desired\\n            task, which is either determining the coefficients of the resolvent\\n            ('coeffs') or determining its possible integer roots ('roots').\\n            The latter may require significantly lower precision.\\n\\n        Returns\\n        =======\\n\\n        list of elements of :ref:`CC`\\n\\n        \"\n    ctx = MPContext()\n    (coeff, T) = preprocess_roots(T)\n    coeff = ctx.mpf(str(coeff))\n    scaled_roots = T.all_roots(radicals=False)\n    approx0 = [coeff * quad_to_mpmath(_evalf_with_bounded_error(r, m=0)) for r in scaled_roots]\n    M = max((abs(b) for b in approx0)) + 1\n    m = self.get_prec(M, target=target)\n    n = fastlog(M._mpf_) + 1\n    p = m + n + 1\n    ctx.prec = p\n    d = prec_to_dps(p)\n    approx1 = [r.eval_approx(d, return_mpmath=True) for r in scaled_roots]\n    approx1 = [coeff * ctx.mpc(r) for r in approx1]\n    return approx1",
            "def approximate_roots_of_poly(self, T, target='coeffs'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Approximate the roots of a given polynomial *T* to sufficient precision\\n        in order to evaluate this resolvent's coefficients, or determine\\n        whether the resolvent has an integer root.\\n\\n        Parameters\\n        ==========\\n\\n        T : :py:class:`~.Poly`\\n\\n        target : str, 'coeffs' or 'roots', default='coeffs'\\n            Set the approximation precision to be sufficient for the desired\\n            task, which is either determining the coefficients of the resolvent\\n            ('coeffs') or determining its possible integer roots ('roots').\\n            The latter may require significantly lower precision.\\n\\n        Returns\\n        =======\\n\\n        list of elements of :ref:`CC`\\n\\n        \"\n    ctx = MPContext()\n    (coeff, T) = preprocess_roots(T)\n    coeff = ctx.mpf(str(coeff))\n    scaled_roots = T.all_roots(radicals=False)\n    approx0 = [coeff * quad_to_mpmath(_evalf_with_bounded_error(r, m=0)) for r in scaled_roots]\n    M = max((abs(b) for b in approx0)) + 1\n    m = self.get_prec(M, target=target)\n    n = fastlog(M._mpf_) + 1\n    p = m + n + 1\n    ctx.prec = p\n    d = prec_to_dps(p)\n    approx1 = [r.eval_approx(d, return_mpmath=True) for r in scaled_roots]\n    approx1 = [coeff * ctx.mpc(r) for r in approx1]\n    return approx1",
            "def approximate_roots_of_poly(self, T, target='coeffs'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Approximate the roots of a given polynomial *T* to sufficient precision\\n        in order to evaluate this resolvent's coefficients, or determine\\n        whether the resolvent has an integer root.\\n\\n        Parameters\\n        ==========\\n\\n        T : :py:class:`~.Poly`\\n\\n        target : str, 'coeffs' or 'roots', default='coeffs'\\n            Set the approximation precision to be sufficient for the desired\\n            task, which is either determining the coefficients of the resolvent\\n            ('coeffs') or determining its possible integer roots ('roots').\\n            The latter may require significantly lower precision.\\n\\n        Returns\\n        =======\\n\\n        list of elements of :ref:`CC`\\n\\n        \"\n    ctx = MPContext()\n    (coeff, T) = preprocess_roots(T)\n    coeff = ctx.mpf(str(coeff))\n    scaled_roots = T.all_roots(radicals=False)\n    approx0 = [coeff * quad_to_mpmath(_evalf_with_bounded_error(r, m=0)) for r in scaled_roots]\n    M = max((abs(b) for b in approx0)) + 1\n    m = self.get_prec(M, target=target)\n    n = fastlog(M._mpf_) + 1\n    p = m + n + 1\n    ctx.prec = p\n    d = prec_to_dps(p)\n    approx1 = [r.eval_approx(d, return_mpmath=True) for r in scaled_roots]\n    approx1 = [coeff * ctx.mpc(r) for r in approx1]\n    return approx1",
            "def approximate_roots_of_poly(self, T, target='coeffs'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Approximate the roots of a given polynomial *T* to sufficient precision\\n        in order to evaluate this resolvent's coefficients, or determine\\n        whether the resolvent has an integer root.\\n\\n        Parameters\\n        ==========\\n\\n        T : :py:class:`~.Poly`\\n\\n        target : str, 'coeffs' or 'roots', default='coeffs'\\n            Set the approximation precision to be sufficient for the desired\\n            task, which is either determining the coefficients of the resolvent\\n            ('coeffs') or determining its possible integer roots ('roots').\\n            The latter may require significantly lower precision.\\n\\n        Returns\\n        =======\\n\\n        list of elements of :ref:`CC`\\n\\n        \"\n    ctx = MPContext()\n    (coeff, T) = preprocess_roots(T)\n    coeff = ctx.mpf(str(coeff))\n    scaled_roots = T.all_roots(radicals=False)\n    approx0 = [coeff * quad_to_mpmath(_evalf_with_bounded_error(r, m=0)) for r in scaled_roots]\n    M = max((abs(b) for b in approx0)) + 1\n    m = self.get_prec(M, target=target)\n    n = fastlog(M._mpf_) + 1\n    p = m + n + 1\n    ctx.prec = p\n    d = prec_to_dps(p)\n    approx1 = [r.eval_approx(d, return_mpmath=True) for r in scaled_roots]\n    approx1 = [coeff * ctx.mpc(r) for r in approx1]\n    return approx1",
            "def approximate_roots_of_poly(self, T, target='coeffs'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Approximate the roots of a given polynomial *T* to sufficient precision\\n        in order to evaluate this resolvent's coefficients, or determine\\n        whether the resolvent has an integer root.\\n\\n        Parameters\\n        ==========\\n\\n        T : :py:class:`~.Poly`\\n\\n        target : str, 'coeffs' or 'roots', default='coeffs'\\n            Set the approximation precision to be sufficient for the desired\\n            task, which is either determining the coefficients of the resolvent\\n            ('coeffs') or determining its possible integer roots ('roots').\\n            The latter may require significantly lower precision.\\n\\n        Returns\\n        =======\\n\\n        list of elements of :ref:`CC`\\n\\n        \"\n    ctx = MPContext()\n    (coeff, T) = preprocess_roots(T)\n    coeff = ctx.mpf(str(coeff))\n    scaled_roots = T.all_roots(radicals=False)\n    approx0 = [coeff * quad_to_mpmath(_evalf_with_bounded_error(r, m=0)) for r in scaled_roots]\n    M = max((abs(b) for b in approx0)) + 1\n    m = self.get_prec(M, target=target)\n    n = fastlog(M._mpf_) + 1\n    p = m + n + 1\n    ctx.prec = p\n    d = prec_to_dps(p)\n    approx1 = [r.eval_approx(d, return_mpmath=True) for r in scaled_roots]\n    approx1 = [coeff * ctx.mpc(r) for r in approx1]\n    return approx1"
        ]
    },
    {
        "func_name": "round_mpf",
        "original": "@staticmethod\ndef round_mpf(a):\n    if isinstance(a, int):\n        return a\n    return ZZ(int(a.context.nint(a)))",
        "mutated": [
            "@staticmethod\ndef round_mpf(a):\n    if False:\n        i = 10\n    if isinstance(a, int):\n        return a\n    return ZZ(int(a.context.nint(a)))",
            "@staticmethod\ndef round_mpf(a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if isinstance(a, int):\n        return a\n    return ZZ(int(a.context.nint(a)))",
            "@staticmethod\ndef round_mpf(a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if isinstance(a, int):\n        return a\n    return ZZ(int(a.context.nint(a)))",
            "@staticmethod\ndef round_mpf(a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if isinstance(a, int):\n        return a\n    return ZZ(int(a.context.nint(a)))",
            "@staticmethod\ndef round_mpf(a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if isinstance(a, int):\n        return a\n    return ZZ(int(a.context.nint(a)))"
        ]
    },
    {
        "func_name": "round_roots_to_integers_for_poly",
        "original": "def round_roots_to_integers_for_poly(self, T):\n    \"\"\"\n        For a given polynomial *T*, round the roots of this resolvent to the\n        nearest integers.\n\n        Explanation\n        ===========\n\n        None of the integers returned by this method is guaranteed to be a\n        root of the resolvent; however, if the resolvent has any integer roots\n        (for the given polynomial *T*), then they must be among these.\n\n        If the coefficients of the resolvent are also desired, then this method\n        should not be used. Instead, use the ``eval_for_poly`` method. This\n        method may be significantly faster than ``eval_for_poly``.\n\n        Parameters\n        ==========\n\n        T : :py:class:`~.Poly`\n\n        Returns\n        =======\n\n        dict\n            Keys are the indices of those permutations in ``self.s`` such that\n            the corresponding root did round to a rational integer.\n\n            Values are :ref:`ZZ`.\n\n\n        \"\"\"\n    approx_roots_of_T = self.approximate_roots_of_poly(T, target='roots')\n    approx_roots_of_self = [r(*approx_roots_of_T) for r in self.root_lambdas]\n    return {i: self.round_mpf(r.real) for (i, r) in enumerate(approx_roots_of_self) if self.round_mpf(r.imag) == 0}",
        "mutated": [
            "def round_roots_to_integers_for_poly(self, T):\n    if False:\n        i = 10\n    '\\n        For a given polynomial *T*, round the roots of this resolvent to the\\n        nearest integers.\\n\\n        Explanation\\n        ===========\\n\\n        None of the integers returned by this method is guaranteed to be a\\n        root of the resolvent; however, if the resolvent has any integer roots\\n        (for the given polynomial *T*), then they must be among these.\\n\\n        If the coefficients of the resolvent are also desired, then this method\\n        should not be used. Instead, use the ``eval_for_poly`` method. This\\n        method may be significantly faster than ``eval_for_poly``.\\n\\n        Parameters\\n        ==========\\n\\n        T : :py:class:`~.Poly`\\n\\n        Returns\\n        =======\\n\\n        dict\\n            Keys are the indices of those permutations in ``self.s`` such that\\n            the corresponding root did round to a rational integer.\\n\\n            Values are :ref:`ZZ`.\\n\\n\\n        '\n    approx_roots_of_T = self.approximate_roots_of_poly(T, target='roots')\n    approx_roots_of_self = [r(*approx_roots_of_T) for r in self.root_lambdas]\n    return {i: self.round_mpf(r.real) for (i, r) in enumerate(approx_roots_of_self) if self.round_mpf(r.imag) == 0}",
            "def round_roots_to_integers_for_poly(self, T):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        For a given polynomial *T*, round the roots of this resolvent to the\\n        nearest integers.\\n\\n        Explanation\\n        ===========\\n\\n        None of the integers returned by this method is guaranteed to be a\\n        root of the resolvent; however, if the resolvent has any integer roots\\n        (for the given polynomial *T*), then they must be among these.\\n\\n        If the coefficients of the resolvent are also desired, then this method\\n        should not be used. Instead, use the ``eval_for_poly`` method. This\\n        method may be significantly faster than ``eval_for_poly``.\\n\\n        Parameters\\n        ==========\\n\\n        T : :py:class:`~.Poly`\\n\\n        Returns\\n        =======\\n\\n        dict\\n            Keys are the indices of those permutations in ``self.s`` such that\\n            the corresponding root did round to a rational integer.\\n\\n            Values are :ref:`ZZ`.\\n\\n\\n        '\n    approx_roots_of_T = self.approximate_roots_of_poly(T, target='roots')\n    approx_roots_of_self = [r(*approx_roots_of_T) for r in self.root_lambdas]\n    return {i: self.round_mpf(r.real) for (i, r) in enumerate(approx_roots_of_self) if self.round_mpf(r.imag) == 0}",
            "def round_roots_to_integers_for_poly(self, T):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        For a given polynomial *T*, round the roots of this resolvent to the\\n        nearest integers.\\n\\n        Explanation\\n        ===========\\n\\n        None of the integers returned by this method is guaranteed to be a\\n        root of the resolvent; however, if the resolvent has any integer roots\\n        (for the given polynomial *T*), then they must be among these.\\n\\n        If the coefficients of the resolvent are also desired, then this method\\n        should not be used. Instead, use the ``eval_for_poly`` method. This\\n        method may be significantly faster than ``eval_for_poly``.\\n\\n        Parameters\\n        ==========\\n\\n        T : :py:class:`~.Poly`\\n\\n        Returns\\n        =======\\n\\n        dict\\n            Keys are the indices of those permutations in ``self.s`` such that\\n            the corresponding root did round to a rational integer.\\n\\n            Values are :ref:`ZZ`.\\n\\n\\n        '\n    approx_roots_of_T = self.approximate_roots_of_poly(T, target='roots')\n    approx_roots_of_self = [r(*approx_roots_of_T) for r in self.root_lambdas]\n    return {i: self.round_mpf(r.real) for (i, r) in enumerate(approx_roots_of_self) if self.round_mpf(r.imag) == 0}",
            "def round_roots_to_integers_for_poly(self, T):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        For a given polynomial *T*, round the roots of this resolvent to the\\n        nearest integers.\\n\\n        Explanation\\n        ===========\\n\\n        None of the integers returned by this method is guaranteed to be a\\n        root of the resolvent; however, if the resolvent has any integer roots\\n        (for the given polynomial *T*), then they must be among these.\\n\\n        If the coefficients of the resolvent are also desired, then this method\\n        should not be used. Instead, use the ``eval_for_poly`` method. This\\n        method may be significantly faster than ``eval_for_poly``.\\n\\n        Parameters\\n        ==========\\n\\n        T : :py:class:`~.Poly`\\n\\n        Returns\\n        =======\\n\\n        dict\\n            Keys are the indices of those permutations in ``self.s`` such that\\n            the corresponding root did round to a rational integer.\\n\\n            Values are :ref:`ZZ`.\\n\\n\\n        '\n    approx_roots_of_T = self.approximate_roots_of_poly(T, target='roots')\n    approx_roots_of_self = [r(*approx_roots_of_T) for r in self.root_lambdas]\n    return {i: self.round_mpf(r.real) for (i, r) in enumerate(approx_roots_of_self) if self.round_mpf(r.imag) == 0}",
            "def round_roots_to_integers_for_poly(self, T):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        For a given polynomial *T*, round the roots of this resolvent to the\\n        nearest integers.\\n\\n        Explanation\\n        ===========\\n\\n        None of the integers returned by this method is guaranteed to be a\\n        root of the resolvent; however, if the resolvent has any integer roots\\n        (for the given polynomial *T*), then they must be among these.\\n\\n        If the coefficients of the resolvent are also desired, then this method\\n        should not be used. Instead, use the ``eval_for_poly`` method. This\\n        method may be significantly faster than ``eval_for_poly``.\\n\\n        Parameters\\n        ==========\\n\\n        T : :py:class:`~.Poly`\\n\\n        Returns\\n        =======\\n\\n        dict\\n            Keys are the indices of those permutations in ``self.s`` such that\\n            the corresponding root did round to a rational integer.\\n\\n            Values are :ref:`ZZ`.\\n\\n\\n        '\n    approx_roots_of_T = self.approximate_roots_of_poly(T, target='roots')\n    approx_roots_of_self = [r(*approx_roots_of_T) for r in self.root_lambdas]\n    return {i: self.round_mpf(r.real) for (i, r) in enumerate(approx_roots_of_self) if self.round_mpf(r.imag) == 0}"
        ]
    },
    {
        "func_name": "eval_for_poly",
        "original": "def eval_for_poly(self, T, find_integer_root=False):\n    \"\"\"\n        Compute the integer values of the coefficients of this resolvent, when\n        plugging in the roots of a given polynomial.\n\n        Parameters\n        ==========\n\n        T : :py:class:`~.Poly`\n\n        find_integer_root : ``bool``, default ``False``\n            If ``True``, then also determine whether the resolvent has an\n            integer root, and return the first one found, along with its\n            index, i.e. the index of the permutation ``self.s[i]`` it\n            corresponds to.\n\n        Returns\n        =======\n\n        Tuple ``(R, a, i)``\n\n            ``R`` is this resolvent as a dense univariate polynomial over\n            :ref:`ZZ`, i.e. a list of :ref:`ZZ`.\n\n            If *find_integer_root* was ``True``, then ``a`` and ``i`` are the\n            first integer root found, and its index, if one exists.\n            Otherwise ``a`` and ``i`` are both ``None``.\n\n        \"\"\"\n    approx_roots_of_T = self.approximate_roots_of_poly(T, target='coeffs')\n    approx_roots_of_self = [r(*approx_roots_of_T) for r in self.root_lambdas]\n    approx_coeffs_of_self = [c(*approx_roots_of_self) for c in self.esf_lambdas]\n    R = []\n    for c in approx_coeffs_of_self:\n        if self.round_mpf(c.imag) != 0:\n            raise ResolventException(f'Got non-integer coeff for resolvent: {c}')\n        R.append(self.round_mpf(c.real))\n    (a0, i0) = (None, None)\n    if find_integer_root:\n        for (i, r) in enumerate(approx_roots_of_self):\n            if self.round_mpf(r.imag) != 0:\n                continue\n            if not dup_eval(R, (a := self.round_mpf(r.real)), ZZ):\n                (a0, i0) = (a, i)\n                break\n    return (R, a0, i0)",
        "mutated": [
            "def eval_for_poly(self, T, find_integer_root=False):\n    if False:\n        i = 10\n    '\\n        Compute the integer values of the coefficients of this resolvent, when\\n        plugging in the roots of a given polynomial.\\n\\n        Parameters\\n        ==========\\n\\n        T : :py:class:`~.Poly`\\n\\n        find_integer_root : ``bool``, default ``False``\\n            If ``True``, then also determine whether the resolvent has an\\n            integer root, and return the first one found, along with its\\n            index, i.e. the index of the permutation ``self.s[i]`` it\\n            corresponds to.\\n\\n        Returns\\n        =======\\n\\n        Tuple ``(R, a, i)``\\n\\n            ``R`` is this resolvent as a dense univariate polynomial over\\n            :ref:`ZZ`, i.e. a list of :ref:`ZZ`.\\n\\n            If *find_integer_root* was ``True``, then ``a`` and ``i`` are the\\n            first integer root found, and its index, if one exists.\\n            Otherwise ``a`` and ``i`` are both ``None``.\\n\\n        '\n    approx_roots_of_T = self.approximate_roots_of_poly(T, target='coeffs')\n    approx_roots_of_self = [r(*approx_roots_of_T) for r in self.root_lambdas]\n    approx_coeffs_of_self = [c(*approx_roots_of_self) for c in self.esf_lambdas]\n    R = []\n    for c in approx_coeffs_of_self:\n        if self.round_mpf(c.imag) != 0:\n            raise ResolventException(f'Got non-integer coeff for resolvent: {c}')\n        R.append(self.round_mpf(c.real))\n    (a0, i0) = (None, None)\n    if find_integer_root:\n        for (i, r) in enumerate(approx_roots_of_self):\n            if self.round_mpf(r.imag) != 0:\n                continue\n            if not dup_eval(R, (a := self.round_mpf(r.real)), ZZ):\n                (a0, i0) = (a, i)\n                break\n    return (R, a0, i0)",
            "def eval_for_poly(self, T, find_integer_root=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Compute the integer values of the coefficients of this resolvent, when\\n        plugging in the roots of a given polynomial.\\n\\n        Parameters\\n        ==========\\n\\n        T : :py:class:`~.Poly`\\n\\n        find_integer_root : ``bool``, default ``False``\\n            If ``True``, then also determine whether the resolvent has an\\n            integer root, and return the first one found, along with its\\n            index, i.e. the index of the permutation ``self.s[i]`` it\\n            corresponds to.\\n\\n        Returns\\n        =======\\n\\n        Tuple ``(R, a, i)``\\n\\n            ``R`` is this resolvent as a dense univariate polynomial over\\n            :ref:`ZZ`, i.e. a list of :ref:`ZZ`.\\n\\n            If *find_integer_root* was ``True``, then ``a`` and ``i`` are the\\n            first integer root found, and its index, if one exists.\\n            Otherwise ``a`` and ``i`` are both ``None``.\\n\\n        '\n    approx_roots_of_T = self.approximate_roots_of_poly(T, target='coeffs')\n    approx_roots_of_self = [r(*approx_roots_of_T) for r in self.root_lambdas]\n    approx_coeffs_of_self = [c(*approx_roots_of_self) for c in self.esf_lambdas]\n    R = []\n    for c in approx_coeffs_of_self:\n        if self.round_mpf(c.imag) != 0:\n            raise ResolventException(f'Got non-integer coeff for resolvent: {c}')\n        R.append(self.round_mpf(c.real))\n    (a0, i0) = (None, None)\n    if find_integer_root:\n        for (i, r) in enumerate(approx_roots_of_self):\n            if self.round_mpf(r.imag) != 0:\n                continue\n            if not dup_eval(R, (a := self.round_mpf(r.real)), ZZ):\n                (a0, i0) = (a, i)\n                break\n    return (R, a0, i0)",
            "def eval_for_poly(self, T, find_integer_root=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Compute the integer values of the coefficients of this resolvent, when\\n        plugging in the roots of a given polynomial.\\n\\n        Parameters\\n        ==========\\n\\n        T : :py:class:`~.Poly`\\n\\n        find_integer_root : ``bool``, default ``False``\\n            If ``True``, then also determine whether the resolvent has an\\n            integer root, and return the first one found, along with its\\n            index, i.e. the index of the permutation ``self.s[i]`` it\\n            corresponds to.\\n\\n        Returns\\n        =======\\n\\n        Tuple ``(R, a, i)``\\n\\n            ``R`` is this resolvent as a dense univariate polynomial over\\n            :ref:`ZZ`, i.e. a list of :ref:`ZZ`.\\n\\n            If *find_integer_root* was ``True``, then ``a`` and ``i`` are the\\n            first integer root found, and its index, if one exists.\\n            Otherwise ``a`` and ``i`` are both ``None``.\\n\\n        '\n    approx_roots_of_T = self.approximate_roots_of_poly(T, target='coeffs')\n    approx_roots_of_self = [r(*approx_roots_of_T) for r in self.root_lambdas]\n    approx_coeffs_of_self = [c(*approx_roots_of_self) for c in self.esf_lambdas]\n    R = []\n    for c in approx_coeffs_of_self:\n        if self.round_mpf(c.imag) != 0:\n            raise ResolventException(f'Got non-integer coeff for resolvent: {c}')\n        R.append(self.round_mpf(c.real))\n    (a0, i0) = (None, None)\n    if find_integer_root:\n        for (i, r) in enumerate(approx_roots_of_self):\n            if self.round_mpf(r.imag) != 0:\n                continue\n            if not dup_eval(R, (a := self.round_mpf(r.real)), ZZ):\n                (a0, i0) = (a, i)\n                break\n    return (R, a0, i0)",
            "def eval_for_poly(self, T, find_integer_root=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Compute the integer values of the coefficients of this resolvent, when\\n        plugging in the roots of a given polynomial.\\n\\n        Parameters\\n        ==========\\n\\n        T : :py:class:`~.Poly`\\n\\n        find_integer_root : ``bool``, default ``False``\\n            If ``True``, then also determine whether the resolvent has an\\n            integer root, and return the first one found, along with its\\n            index, i.e. the index of the permutation ``self.s[i]`` it\\n            corresponds to.\\n\\n        Returns\\n        =======\\n\\n        Tuple ``(R, a, i)``\\n\\n            ``R`` is this resolvent as a dense univariate polynomial over\\n            :ref:`ZZ`, i.e. a list of :ref:`ZZ`.\\n\\n            If *find_integer_root* was ``True``, then ``a`` and ``i`` are the\\n            first integer root found, and its index, if one exists.\\n            Otherwise ``a`` and ``i`` are both ``None``.\\n\\n        '\n    approx_roots_of_T = self.approximate_roots_of_poly(T, target='coeffs')\n    approx_roots_of_self = [r(*approx_roots_of_T) for r in self.root_lambdas]\n    approx_coeffs_of_self = [c(*approx_roots_of_self) for c in self.esf_lambdas]\n    R = []\n    for c in approx_coeffs_of_self:\n        if self.round_mpf(c.imag) != 0:\n            raise ResolventException(f'Got non-integer coeff for resolvent: {c}')\n        R.append(self.round_mpf(c.real))\n    (a0, i0) = (None, None)\n    if find_integer_root:\n        for (i, r) in enumerate(approx_roots_of_self):\n            if self.round_mpf(r.imag) != 0:\n                continue\n            if not dup_eval(R, (a := self.round_mpf(r.real)), ZZ):\n                (a0, i0) = (a, i)\n                break\n    return (R, a0, i0)",
            "def eval_for_poly(self, T, find_integer_root=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Compute the integer values of the coefficients of this resolvent, when\\n        plugging in the roots of a given polynomial.\\n\\n        Parameters\\n        ==========\\n\\n        T : :py:class:`~.Poly`\\n\\n        find_integer_root : ``bool``, default ``False``\\n            If ``True``, then also determine whether the resolvent has an\\n            integer root, and return the first one found, along with its\\n            index, i.e. the index of the permutation ``self.s[i]`` it\\n            corresponds to.\\n\\n        Returns\\n        =======\\n\\n        Tuple ``(R, a, i)``\\n\\n            ``R`` is this resolvent as a dense univariate polynomial over\\n            :ref:`ZZ`, i.e. a list of :ref:`ZZ`.\\n\\n            If *find_integer_root* was ``True``, then ``a`` and ``i`` are the\\n            first integer root found, and its index, if one exists.\\n            Otherwise ``a`` and ``i`` are both ``None``.\\n\\n        '\n    approx_roots_of_T = self.approximate_roots_of_poly(T, target='coeffs')\n    approx_roots_of_self = [r(*approx_roots_of_T) for r in self.root_lambdas]\n    approx_coeffs_of_self = [c(*approx_roots_of_self) for c in self.esf_lambdas]\n    R = []\n    for c in approx_coeffs_of_self:\n        if self.round_mpf(c.imag) != 0:\n            raise ResolventException(f'Got non-integer coeff for resolvent: {c}')\n        R.append(self.round_mpf(c.real))\n    (a0, i0) = (None, None)\n    if find_integer_root:\n        for (i, r) in enumerate(approx_roots_of_self):\n            if self.round_mpf(r.imag) != 0:\n                continue\n            if not dup_eval(R, (a := self.round_mpf(r.real)), ZZ):\n                (a0, i0) = (a, i)\n                break\n    return (R, a0, i0)"
        ]
    },
    {
        "func_name": "wrap",
        "original": "def wrap(text, width=80):\n    \"\"\"Line wrap a polynomial expression. \"\"\"\n    out = ''\n    col = 0\n    for c in text:\n        if c == ' ' and col > width:\n            (c, col) = ('\\n', 0)\n        else:\n            col += 1\n        out += c\n    return out",
        "mutated": [
            "def wrap(text, width=80):\n    if False:\n        i = 10\n    'Line wrap a polynomial expression. '\n    out = ''\n    col = 0\n    for c in text:\n        if c == ' ' and col > width:\n            (c, col) = ('\\n', 0)\n        else:\n            col += 1\n        out += c\n    return out",
            "def wrap(text, width=80):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Line wrap a polynomial expression. '\n    out = ''\n    col = 0\n    for c in text:\n        if c == ' ' and col > width:\n            (c, col) = ('\\n', 0)\n        else:\n            col += 1\n        out += c\n    return out",
            "def wrap(text, width=80):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Line wrap a polynomial expression. '\n    out = ''\n    col = 0\n    for c in text:\n        if c == ' ' and col > width:\n            (c, col) = ('\\n', 0)\n        else:\n            col += 1\n        out += c\n    return out",
            "def wrap(text, width=80):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Line wrap a polynomial expression. '\n    out = ''\n    col = 0\n    for c in text:\n        if c == ' ' and col > width:\n            (c, col) = ('\\n', 0)\n        else:\n            col += 1\n        out += c\n    return out",
            "def wrap(text, width=80):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Line wrap a polynomial expression. '\n    out = ''\n    col = 0\n    for c in text:\n        if c == ' ' and col > width:\n            (c, col) = ('\\n', 0)\n        else:\n            col += 1\n        out += c\n    return out"
        ]
    },
    {
        "func_name": "s_vars",
        "original": "def s_vars(n):\n    \"\"\"Form the symbols s1, s2, ..., sn to stand for elem. symm. polys. \"\"\"\n    return symbols([f's{i + 1}' for i in range(n)])",
        "mutated": [
            "def s_vars(n):\n    if False:\n        i = 10\n    'Form the symbols s1, s2, ..., sn to stand for elem. symm. polys. '\n    return symbols([f's{i + 1}' for i in range(n)])",
            "def s_vars(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Form the symbols s1, s2, ..., sn to stand for elem. symm. polys. '\n    return symbols([f's{i + 1}' for i in range(n)])",
            "def s_vars(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Form the symbols s1, s2, ..., sn to stand for elem. symm. polys. '\n    return symbols([f's{i + 1}' for i in range(n)])",
            "def s_vars(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Form the symbols s1, s2, ..., sn to stand for elem. symm. polys. '\n    return symbols([f's{i + 1}' for i in range(n)])",
            "def s_vars(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Form the symbols s1, s2, ..., sn to stand for elem. symm. polys. '\n    return symbols([f's{i + 1}' for i in range(n)])"
        ]
    },
    {
        "func_name": "sparse_symmetrize_resolvent_coeffs",
        "original": "def sparse_symmetrize_resolvent_coeffs(F, X, s, verbose=False):\n    \"\"\"\n    Compute the coefficients of a resolvent as functions of the coefficients of\n    the associated polynomial.\n\n    F must be a sparse polynomial.\n    \"\"\"\n    import time, sys\n    root_forms = [F.compose(list(zip(X, sigma(X)))) for sigma in s]\n    Y = [Dummy(f'Y{i}') for i in range(len(s))]\n    coeff_forms = []\n    for i in range(1, len(s) + 1):\n        if verbose:\n            print('----')\n            print(f'Computing symmetric poly of degree {i}...')\n            sys.stdout.flush()\n        t0 = time.time()\n        G = symmetric_poly(i, *Y)\n        t1 = time.time()\n        if verbose:\n            print(f'took {t1 - t0} seconds')\n            print('lambdifying...')\n            sys.stdout.flush()\n        t0 = time.time()\n        C = lambdify(Y, (-1) ** i * G)\n        t1 = time.time()\n        if verbose:\n            print(f'took {t1 - t0} seconds')\n            sys.stdout.flush()\n        coeff_forms.append(C)\n    coeffs = []\n    for (i, f) in enumerate(coeff_forms):\n        if verbose:\n            print('----')\n            print(f'Plugging root forms into elem symm poly {i + 1}...')\n            sys.stdout.flush()\n        t0 = time.time()\n        g = f(*root_forms)\n        t1 = time.time()\n        coeffs.append(g)\n        if verbose:\n            print(f'took {t1 - t0} seconds')\n            sys.stdout.flush()\n    symmetrized = []\n    symmetrization_times = []\n    ss = s_vars(len(X))\n    for (i, A) in list(enumerate(coeffs)):\n        if verbose:\n            print('-----')\n            print(f'Coeff {i + 1}...')\n            sys.stdout.flush()\n        t0 = time.time()\n        (B, rem, _) = A.symmetrize()\n        t1 = time.time()\n        if rem != 0:\n            msg = f'Got nonzero remainder {rem} for resolvent (F, X, s) = ({F}, {X}, {s})'\n            raise ResolventException(msg)\n        B_str = str(B.as_expr(*ss))\n        symmetrized.append(B_str)\n        symmetrization_times.append(t1 - t0)\n        if verbose:\n            print(wrap(B_str))\n            print(f'took {t1 - t0} seconds')\n            sys.stdout.flush()\n    return (symmetrized, symmetrization_times)",
        "mutated": [
            "def sparse_symmetrize_resolvent_coeffs(F, X, s, verbose=False):\n    if False:\n        i = 10\n    '\\n    Compute the coefficients of a resolvent as functions of the coefficients of\\n    the associated polynomial.\\n\\n    F must be a sparse polynomial.\\n    '\n    import time, sys\n    root_forms = [F.compose(list(zip(X, sigma(X)))) for sigma in s]\n    Y = [Dummy(f'Y{i}') for i in range(len(s))]\n    coeff_forms = []\n    for i in range(1, len(s) + 1):\n        if verbose:\n            print('----')\n            print(f'Computing symmetric poly of degree {i}...')\n            sys.stdout.flush()\n        t0 = time.time()\n        G = symmetric_poly(i, *Y)\n        t1 = time.time()\n        if verbose:\n            print(f'took {t1 - t0} seconds')\n            print('lambdifying...')\n            sys.stdout.flush()\n        t0 = time.time()\n        C = lambdify(Y, (-1) ** i * G)\n        t1 = time.time()\n        if verbose:\n            print(f'took {t1 - t0} seconds')\n            sys.stdout.flush()\n        coeff_forms.append(C)\n    coeffs = []\n    for (i, f) in enumerate(coeff_forms):\n        if verbose:\n            print('----')\n            print(f'Plugging root forms into elem symm poly {i + 1}...')\n            sys.stdout.flush()\n        t0 = time.time()\n        g = f(*root_forms)\n        t1 = time.time()\n        coeffs.append(g)\n        if verbose:\n            print(f'took {t1 - t0} seconds')\n            sys.stdout.flush()\n    symmetrized = []\n    symmetrization_times = []\n    ss = s_vars(len(X))\n    for (i, A) in list(enumerate(coeffs)):\n        if verbose:\n            print('-----')\n            print(f'Coeff {i + 1}...')\n            sys.stdout.flush()\n        t0 = time.time()\n        (B, rem, _) = A.symmetrize()\n        t1 = time.time()\n        if rem != 0:\n            msg = f'Got nonzero remainder {rem} for resolvent (F, X, s) = ({F}, {X}, {s})'\n            raise ResolventException(msg)\n        B_str = str(B.as_expr(*ss))\n        symmetrized.append(B_str)\n        symmetrization_times.append(t1 - t0)\n        if verbose:\n            print(wrap(B_str))\n            print(f'took {t1 - t0} seconds')\n            sys.stdout.flush()\n    return (symmetrized, symmetrization_times)",
            "def sparse_symmetrize_resolvent_coeffs(F, X, s, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the coefficients of a resolvent as functions of the coefficients of\\n    the associated polynomial.\\n\\n    F must be a sparse polynomial.\\n    '\n    import time, sys\n    root_forms = [F.compose(list(zip(X, sigma(X)))) for sigma in s]\n    Y = [Dummy(f'Y{i}') for i in range(len(s))]\n    coeff_forms = []\n    for i in range(1, len(s) + 1):\n        if verbose:\n            print('----')\n            print(f'Computing symmetric poly of degree {i}...')\n            sys.stdout.flush()\n        t0 = time.time()\n        G = symmetric_poly(i, *Y)\n        t1 = time.time()\n        if verbose:\n            print(f'took {t1 - t0} seconds')\n            print('lambdifying...')\n            sys.stdout.flush()\n        t0 = time.time()\n        C = lambdify(Y, (-1) ** i * G)\n        t1 = time.time()\n        if verbose:\n            print(f'took {t1 - t0} seconds')\n            sys.stdout.flush()\n        coeff_forms.append(C)\n    coeffs = []\n    for (i, f) in enumerate(coeff_forms):\n        if verbose:\n            print('----')\n            print(f'Plugging root forms into elem symm poly {i + 1}...')\n            sys.stdout.flush()\n        t0 = time.time()\n        g = f(*root_forms)\n        t1 = time.time()\n        coeffs.append(g)\n        if verbose:\n            print(f'took {t1 - t0} seconds')\n            sys.stdout.flush()\n    symmetrized = []\n    symmetrization_times = []\n    ss = s_vars(len(X))\n    for (i, A) in list(enumerate(coeffs)):\n        if verbose:\n            print('-----')\n            print(f'Coeff {i + 1}...')\n            sys.stdout.flush()\n        t0 = time.time()\n        (B, rem, _) = A.symmetrize()\n        t1 = time.time()\n        if rem != 0:\n            msg = f'Got nonzero remainder {rem} for resolvent (F, X, s) = ({F}, {X}, {s})'\n            raise ResolventException(msg)\n        B_str = str(B.as_expr(*ss))\n        symmetrized.append(B_str)\n        symmetrization_times.append(t1 - t0)\n        if verbose:\n            print(wrap(B_str))\n            print(f'took {t1 - t0} seconds')\n            sys.stdout.flush()\n    return (symmetrized, symmetrization_times)",
            "def sparse_symmetrize_resolvent_coeffs(F, X, s, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the coefficients of a resolvent as functions of the coefficients of\\n    the associated polynomial.\\n\\n    F must be a sparse polynomial.\\n    '\n    import time, sys\n    root_forms = [F.compose(list(zip(X, sigma(X)))) for sigma in s]\n    Y = [Dummy(f'Y{i}') for i in range(len(s))]\n    coeff_forms = []\n    for i in range(1, len(s) + 1):\n        if verbose:\n            print('----')\n            print(f'Computing symmetric poly of degree {i}...')\n            sys.stdout.flush()\n        t0 = time.time()\n        G = symmetric_poly(i, *Y)\n        t1 = time.time()\n        if verbose:\n            print(f'took {t1 - t0} seconds')\n            print('lambdifying...')\n            sys.stdout.flush()\n        t0 = time.time()\n        C = lambdify(Y, (-1) ** i * G)\n        t1 = time.time()\n        if verbose:\n            print(f'took {t1 - t0} seconds')\n            sys.stdout.flush()\n        coeff_forms.append(C)\n    coeffs = []\n    for (i, f) in enumerate(coeff_forms):\n        if verbose:\n            print('----')\n            print(f'Plugging root forms into elem symm poly {i + 1}...')\n            sys.stdout.flush()\n        t0 = time.time()\n        g = f(*root_forms)\n        t1 = time.time()\n        coeffs.append(g)\n        if verbose:\n            print(f'took {t1 - t0} seconds')\n            sys.stdout.flush()\n    symmetrized = []\n    symmetrization_times = []\n    ss = s_vars(len(X))\n    for (i, A) in list(enumerate(coeffs)):\n        if verbose:\n            print('-----')\n            print(f'Coeff {i + 1}...')\n            sys.stdout.flush()\n        t0 = time.time()\n        (B, rem, _) = A.symmetrize()\n        t1 = time.time()\n        if rem != 0:\n            msg = f'Got nonzero remainder {rem} for resolvent (F, X, s) = ({F}, {X}, {s})'\n            raise ResolventException(msg)\n        B_str = str(B.as_expr(*ss))\n        symmetrized.append(B_str)\n        symmetrization_times.append(t1 - t0)\n        if verbose:\n            print(wrap(B_str))\n            print(f'took {t1 - t0} seconds')\n            sys.stdout.flush()\n    return (symmetrized, symmetrization_times)",
            "def sparse_symmetrize_resolvent_coeffs(F, X, s, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the coefficients of a resolvent as functions of the coefficients of\\n    the associated polynomial.\\n\\n    F must be a sparse polynomial.\\n    '\n    import time, sys\n    root_forms = [F.compose(list(zip(X, sigma(X)))) for sigma in s]\n    Y = [Dummy(f'Y{i}') for i in range(len(s))]\n    coeff_forms = []\n    for i in range(1, len(s) + 1):\n        if verbose:\n            print('----')\n            print(f'Computing symmetric poly of degree {i}...')\n            sys.stdout.flush()\n        t0 = time.time()\n        G = symmetric_poly(i, *Y)\n        t1 = time.time()\n        if verbose:\n            print(f'took {t1 - t0} seconds')\n            print('lambdifying...')\n            sys.stdout.flush()\n        t0 = time.time()\n        C = lambdify(Y, (-1) ** i * G)\n        t1 = time.time()\n        if verbose:\n            print(f'took {t1 - t0} seconds')\n            sys.stdout.flush()\n        coeff_forms.append(C)\n    coeffs = []\n    for (i, f) in enumerate(coeff_forms):\n        if verbose:\n            print('----')\n            print(f'Plugging root forms into elem symm poly {i + 1}...')\n            sys.stdout.flush()\n        t0 = time.time()\n        g = f(*root_forms)\n        t1 = time.time()\n        coeffs.append(g)\n        if verbose:\n            print(f'took {t1 - t0} seconds')\n            sys.stdout.flush()\n    symmetrized = []\n    symmetrization_times = []\n    ss = s_vars(len(X))\n    for (i, A) in list(enumerate(coeffs)):\n        if verbose:\n            print('-----')\n            print(f'Coeff {i + 1}...')\n            sys.stdout.flush()\n        t0 = time.time()\n        (B, rem, _) = A.symmetrize()\n        t1 = time.time()\n        if rem != 0:\n            msg = f'Got nonzero remainder {rem} for resolvent (F, X, s) = ({F}, {X}, {s})'\n            raise ResolventException(msg)\n        B_str = str(B.as_expr(*ss))\n        symmetrized.append(B_str)\n        symmetrization_times.append(t1 - t0)\n        if verbose:\n            print(wrap(B_str))\n            print(f'took {t1 - t0} seconds')\n            sys.stdout.flush()\n    return (symmetrized, symmetrization_times)",
            "def sparse_symmetrize_resolvent_coeffs(F, X, s, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the coefficients of a resolvent as functions of the coefficients of\\n    the associated polynomial.\\n\\n    F must be a sparse polynomial.\\n    '\n    import time, sys\n    root_forms = [F.compose(list(zip(X, sigma(X)))) for sigma in s]\n    Y = [Dummy(f'Y{i}') for i in range(len(s))]\n    coeff_forms = []\n    for i in range(1, len(s) + 1):\n        if verbose:\n            print('----')\n            print(f'Computing symmetric poly of degree {i}...')\n            sys.stdout.flush()\n        t0 = time.time()\n        G = symmetric_poly(i, *Y)\n        t1 = time.time()\n        if verbose:\n            print(f'took {t1 - t0} seconds')\n            print('lambdifying...')\n            sys.stdout.flush()\n        t0 = time.time()\n        C = lambdify(Y, (-1) ** i * G)\n        t1 = time.time()\n        if verbose:\n            print(f'took {t1 - t0} seconds')\n            sys.stdout.flush()\n        coeff_forms.append(C)\n    coeffs = []\n    for (i, f) in enumerate(coeff_forms):\n        if verbose:\n            print('----')\n            print(f'Plugging root forms into elem symm poly {i + 1}...')\n            sys.stdout.flush()\n        t0 = time.time()\n        g = f(*root_forms)\n        t1 = time.time()\n        coeffs.append(g)\n        if verbose:\n            print(f'took {t1 - t0} seconds')\n            sys.stdout.flush()\n    symmetrized = []\n    symmetrization_times = []\n    ss = s_vars(len(X))\n    for (i, A) in list(enumerate(coeffs)):\n        if verbose:\n            print('-----')\n            print(f'Coeff {i + 1}...')\n            sys.stdout.flush()\n        t0 = time.time()\n        (B, rem, _) = A.symmetrize()\n        t1 = time.time()\n        if rem != 0:\n            msg = f'Got nonzero remainder {rem} for resolvent (F, X, s) = ({F}, {X}, {s})'\n            raise ResolventException(msg)\n        B_str = str(B.as_expr(*ss))\n        symmetrized.append(B_str)\n        symmetrization_times.append(t1 - t0)\n        if verbose:\n            print(wrap(B_str))\n            print(f'took {t1 - t0} seconds')\n            sys.stdout.flush()\n    return (symmetrized, symmetrization_times)"
        ]
    },
    {
        "func_name": "define_resolvents",
        "original": "def define_resolvents():\n    \"\"\"Define all the resolvents for polys T of degree 4 through 6. \"\"\"\n    from sympy.combinatorics.galois import PGL2F5\n    from sympy.combinatorics.permutations import Permutation\n    (R4, X4) = xring('X0,X1,X2,X3', ZZ, lex)\n    X = X4\n    F40 = X[0] * X[1] ** 2 + X[1] * X[2] ** 2 + X[2] * X[3] ** 2 + X[3] * X[0] ** 2\n    s40 = [Permutation(3), Permutation(3)(0, 1), Permutation(3)(0, 2), Permutation(3)(0, 3), Permutation(3)(1, 2), Permutation(3)(2, 3)]\n    F41 = X[0] * X[2] + X[1] * X[3]\n    s41 = [Permutation(3), Permutation(3)(0, 1), Permutation(3)(0, 3)]\n    (R5, X5) = xring('X0,X1,X2,X3,X4', ZZ, lex)\n    X = X5\n    F51 = X[0] ** 2 * (X[1] * X[4] + X[2] * X[3]) + X[1] ** 2 * (X[2] * X[0] + X[3] * X[4]) + X[2] ** 2 * (X[3] * X[1] + X[4] * X[0]) + X[3] ** 2 * (X[4] * X[2] + X[0] * X[1]) + X[4] ** 2 * (X[0] * X[3] + X[1] * X[2])\n    s51 = [Permutation(4), Permutation(4)(0, 1), Permutation(4)(0, 2), Permutation(4)(0, 3), Permutation(4)(0, 4), Permutation(4)(1, 4)]\n    (R6, X6) = xring('X0,X1,X2,X3,X4,X5', ZZ, lex)\n    X = X6\n    H = PGL2F5()\n    term0 = X[0] ** 2 * X[5] ** 2 * (X[1] * X[4] + X[2] * X[3])\n    terms = {term0.compose(list(zip(X, s(X)))) for s in H.elements}\n    F61 = sum(terms)\n    s61 = [Permutation(5)] + [Permutation(5)(0, n) for n in range(1, 6)]\n    F62 = X[0] * X[1] * X[2] + X[3] * X[4] * X[5]\n    s62 = [Permutation(5)] + [Permutation(5)(i, j + 3) for i in range(3) for j in range(3)]\n    return {(4, 0): (F40, X4, s40), (4, 1): (F41, X4, s41), (5, 1): (F51, X5, s51), (6, 1): (F61, X6, s61), (6, 2): (F62, X6, s62)}",
        "mutated": [
            "def define_resolvents():\n    if False:\n        i = 10\n    'Define all the resolvents for polys T of degree 4 through 6. '\n    from sympy.combinatorics.galois import PGL2F5\n    from sympy.combinatorics.permutations import Permutation\n    (R4, X4) = xring('X0,X1,X2,X3', ZZ, lex)\n    X = X4\n    F40 = X[0] * X[1] ** 2 + X[1] * X[2] ** 2 + X[2] * X[3] ** 2 + X[3] * X[0] ** 2\n    s40 = [Permutation(3), Permutation(3)(0, 1), Permutation(3)(0, 2), Permutation(3)(0, 3), Permutation(3)(1, 2), Permutation(3)(2, 3)]\n    F41 = X[0] * X[2] + X[1] * X[3]\n    s41 = [Permutation(3), Permutation(3)(0, 1), Permutation(3)(0, 3)]\n    (R5, X5) = xring('X0,X1,X2,X3,X4', ZZ, lex)\n    X = X5\n    F51 = X[0] ** 2 * (X[1] * X[4] + X[2] * X[3]) + X[1] ** 2 * (X[2] * X[0] + X[3] * X[4]) + X[2] ** 2 * (X[3] * X[1] + X[4] * X[0]) + X[3] ** 2 * (X[4] * X[2] + X[0] * X[1]) + X[4] ** 2 * (X[0] * X[3] + X[1] * X[2])\n    s51 = [Permutation(4), Permutation(4)(0, 1), Permutation(4)(0, 2), Permutation(4)(0, 3), Permutation(4)(0, 4), Permutation(4)(1, 4)]\n    (R6, X6) = xring('X0,X1,X2,X3,X4,X5', ZZ, lex)\n    X = X6\n    H = PGL2F5()\n    term0 = X[0] ** 2 * X[5] ** 2 * (X[1] * X[4] + X[2] * X[3])\n    terms = {term0.compose(list(zip(X, s(X)))) for s in H.elements}\n    F61 = sum(terms)\n    s61 = [Permutation(5)] + [Permutation(5)(0, n) for n in range(1, 6)]\n    F62 = X[0] * X[1] * X[2] + X[3] * X[4] * X[5]\n    s62 = [Permutation(5)] + [Permutation(5)(i, j + 3) for i in range(3) for j in range(3)]\n    return {(4, 0): (F40, X4, s40), (4, 1): (F41, X4, s41), (5, 1): (F51, X5, s51), (6, 1): (F61, X6, s61), (6, 2): (F62, X6, s62)}",
            "def define_resolvents():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Define all the resolvents for polys T of degree 4 through 6. '\n    from sympy.combinatorics.galois import PGL2F5\n    from sympy.combinatorics.permutations import Permutation\n    (R4, X4) = xring('X0,X1,X2,X3', ZZ, lex)\n    X = X4\n    F40 = X[0] * X[1] ** 2 + X[1] * X[2] ** 2 + X[2] * X[3] ** 2 + X[3] * X[0] ** 2\n    s40 = [Permutation(3), Permutation(3)(0, 1), Permutation(3)(0, 2), Permutation(3)(0, 3), Permutation(3)(1, 2), Permutation(3)(2, 3)]\n    F41 = X[0] * X[2] + X[1] * X[3]\n    s41 = [Permutation(3), Permutation(3)(0, 1), Permutation(3)(0, 3)]\n    (R5, X5) = xring('X0,X1,X2,X3,X4', ZZ, lex)\n    X = X5\n    F51 = X[0] ** 2 * (X[1] * X[4] + X[2] * X[3]) + X[1] ** 2 * (X[2] * X[0] + X[3] * X[4]) + X[2] ** 2 * (X[3] * X[1] + X[4] * X[0]) + X[3] ** 2 * (X[4] * X[2] + X[0] * X[1]) + X[4] ** 2 * (X[0] * X[3] + X[1] * X[2])\n    s51 = [Permutation(4), Permutation(4)(0, 1), Permutation(4)(0, 2), Permutation(4)(0, 3), Permutation(4)(0, 4), Permutation(4)(1, 4)]\n    (R6, X6) = xring('X0,X1,X2,X3,X4,X5', ZZ, lex)\n    X = X6\n    H = PGL2F5()\n    term0 = X[0] ** 2 * X[5] ** 2 * (X[1] * X[4] + X[2] * X[3])\n    terms = {term0.compose(list(zip(X, s(X)))) for s in H.elements}\n    F61 = sum(terms)\n    s61 = [Permutation(5)] + [Permutation(5)(0, n) for n in range(1, 6)]\n    F62 = X[0] * X[1] * X[2] + X[3] * X[4] * X[5]\n    s62 = [Permutation(5)] + [Permutation(5)(i, j + 3) for i in range(3) for j in range(3)]\n    return {(4, 0): (F40, X4, s40), (4, 1): (F41, X4, s41), (5, 1): (F51, X5, s51), (6, 1): (F61, X6, s61), (6, 2): (F62, X6, s62)}",
            "def define_resolvents():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Define all the resolvents for polys T of degree 4 through 6. '\n    from sympy.combinatorics.galois import PGL2F5\n    from sympy.combinatorics.permutations import Permutation\n    (R4, X4) = xring('X0,X1,X2,X3', ZZ, lex)\n    X = X4\n    F40 = X[0] * X[1] ** 2 + X[1] * X[2] ** 2 + X[2] * X[3] ** 2 + X[3] * X[0] ** 2\n    s40 = [Permutation(3), Permutation(3)(0, 1), Permutation(3)(0, 2), Permutation(3)(0, 3), Permutation(3)(1, 2), Permutation(3)(2, 3)]\n    F41 = X[0] * X[2] + X[1] * X[3]\n    s41 = [Permutation(3), Permutation(3)(0, 1), Permutation(3)(0, 3)]\n    (R5, X5) = xring('X0,X1,X2,X3,X4', ZZ, lex)\n    X = X5\n    F51 = X[0] ** 2 * (X[1] * X[4] + X[2] * X[3]) + X[1] ** 2 * (X[2] * X[0] + X[3] * X[4]) + X[2] ** 2 * (X[3] * X[1] + X[4] * X[0]) + X[3] ** 2 * (X[4] * X[2] + X[0] * X[1]) + X[4] ** 2 * (X[0] * X[3] + X[1] * X[2])\n    s51 = [Permutation(4), Permutation(4)(0, 1), Permutation(4)(0, 2), Permutation(4)(0, 3), Permutation(4)(0, 4), Permutation(4)(1, 4)]\n    (R6, X6) = xring('X0,X1,X2,X3,X4,X5', ZZ, lex)\n    X = X6\n    H = PGL2F5()\n    term0 = X[0] ** 2 * X[5] ** 2 * (X[1] * X[4] + X[2] * X[3])\n    terms = {term0.compose(list(zip(X, s(X)))) for s in H.elements}\n    F61 = sum(terms)\n    s61 = [Permutation(5)] + [Permutation(5)(0, n) for n in range(1, 6)]\n    F62 = X[0] * X[1] * X[2] + X[3] * X[4] * X[5]\n    s62 = [Permutation(5)] + [Permutation(5)(i, j + 3) for i in range(3) for j in range(3)]\n    return {(4, 0): (F40, X4, s40), (4, 1): (F41, X4, s41), (5, 1): (F51, X5, s51), (6, 1): (F61, X6, s61), (6, 2): (F62, X6, s62)}",
            "def define_resolvents():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Define all the resolvents for polys T of degree 4 through 6. '\n    from sympy.combinatorics.galois import PGL2F5\n    from sympy.combinatorics.permutations import Permutation\n    (R4, X4) = xring('X0,X1,X2,X3', ZZ, lex)\n    X = X4\n    F40 = X[0] * X[1] ** 2 + X[1] * X[2] ** 2 + X[2] * X[3] ** 2 + X[3] * X[0] ** 2\n    s40 = [Permutation(3), Permutation(3)(0, 1), Permutation(3)(0, 2), Permutation(3)(0, 3), Permutation(3)(1, 2), Permutation(3)(2, 3)]\n    F41 = X[0] * X[2] + X[1] * X[3]\n    s41 = [Permutation(3), Permutation(3)(0, 1), Permutation(3)(0, 3)]\n    (R5, X5) = xring('X0,X1,X2,X3,X4', ZZ, lex)\n    X = X5\n    F51 = X[0] ** 2 * (X[1] * X[4] + X[2] * X[3]) + X[1] ** 2 * (X[2] * X[0] + X[3] * X[4]) + X[2] ** 2 * (X[3] * X[1] + X[4] * X[0]) + X[3] ** 2 * (X[4] * X[2] + X[0] * X[1]) + X[4] ** 2 * (X[0] * X[3] + X[1] * X[2])\n    s51 = [Permutation(4), Permutation(4)(0, 1), Permutation(4)(0, 2), Permutation(4)(0, 3), Permutation(4)(0, 4), Permutation(4)(1, 4)]\n    (R6, X6) = xring('X0,X1,X2,X3,X4,X5', ZZ, lex)\n    X = X6\n    H = PGL2F5()\n    term0 = X[0] ** 2 * X[5] ** 2 * (X[1] * X[4] + X[2] * X[3])\n    terms = {term0.compose(list(zip(X, s(X)))) for s in H.elements}\n    F61 = sum(terms)\n    s61 = [Permutation(5)] + [Permutation(5)(0, n) for n in range(1, 6)]\n    F62 = X[0] * X[1] * X[2] + X[3] * X[4] * X[5]\n    s62 = [Permutation(5)] + [Permutation(5)(i, j + 3) for i in range(3) for j in range(3)]\n    return {(4, 0): (F40, X4, s40), (4, 1): (F41, X4, s41), (5, 1): (F51, X5, s51), (6, 1): (F61, X6, s61), (6, 2): (F62, X6, s62)}",
            "def define_resolvents():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Define all the resolvents for polys T of degree 4 through 6. '\n    from sympy.combinatorics.galois import PGL2F5\n    from sympy.combinatorics.permutations import Permutation\n    (R4, X4) = xring('X0,X1,X2,X3', ZZ, lex)\n    X = X4\n    F40 = X[0] * X[1] ** 2 + X[1] * X[2] ** 2 + X[2] * X[3] ** 2 + X[3] * X[0] ** 2\n    s40 = [Permutation(3), Permutation(3)(0, 1), Permutation(3)(0, 2), Permutation(3)(0, 3), Permutation(3)(1, 2), Permutation(3)(2, 3)]\n    F41 = X[0] * X[2] + X[1] * X[3]\n    s41 = [Permutation(3), Permutation(3)(0, 1), Permutation(3)(0, 3)]\n    (R5, X5) = xring('X0,X1,X2,X3,X4', ZZ, lex)\n    X = X5\n    F51 = X[0] ** 2 * (X[1] * X[4] + X[2] * X[3]) + X[1] ** 2 * (X[2] * X[0] + X[3] * X[4]) + X[2] ** 2 * (X[3] * X[1] + X[4] * X[0]) + X[3] ** 2 * (X[4] * X[2] + X[0] * X[1]) + X[4] ** 2 * (X[0] * X[3] + X[1] * X[2])\n    s51 = [Permutation(4), Permutation(4)(0, 1), Permutation(4)(0, 2), Permutation(4)(0, 3), Permutation(4)(0, 4), Permutation(4)(1, 4)]\n    (R6, X6) = xring('X0,X1,X2,X3,X4,X5', ZZ, lex)\n    X = X6\n    H = PGL2F5()\n    term0 = X[0] ** 2 * X[5] ** 2 * (X[1] * X[4] + X[2] * X[3])\n    terms = {term0.compose(list(zip(X, s(X)))) for s in H.elements}\n    F61 = sum(terms)\n    s61 = [Permutation(5)] + [Permutation(5)(0, n) for n in range(1, 6)]\n    F62 = X[0] * X[1] * X[2] + X[3] * X[4] * X[5]\n    s62 = [Permutation(5)] + [Permutation(5)(i, j + 3) for i in range(3) for j in range(3)]\n    return {(4, 0): (F40, X4, s40), (4, 1): (F41, X4, s41), (5, 1): (F51, X5, s51), (6, 1): (F61, X6, s61), (6, 2): (F62, X6, s62)}"
        ]
    },
    {
        "func_name": "generate_lambda_lookup",
        "original": "def generate_lambda_lookup(verbose=False, trial_run=False):\n    \"\"\"\n    Generate the whole lookup table of coeff lambdas, for all resolvents.\n    \"\"\"\n    jobs = define_resolvents()\n    lambda_lists = {}\n    total_time = 0\n    time_for_61 = 0\n    time_for_61_last = 0\n    for (k, (F, X, s)) in jobs.items():\n        (symmetrized, times) = sparse_symmetrize_resolvent_coeffs(F, X, s, verbose=verbose)\n        total_time += sum(times)\n        if k == (6, 1):\n            time_for_61 = sum(times)\n            time_for_61_last = times[-1]\n        sv = s_vars(len(X))\n        head = f\"lambda {', '.join((str(v) for v in sv))}:\"\n        lambda_lists[k] = ',\\n        '.join([f'{head} ({wrap(f)})' for f in symmetrized])\n        if trial_run:\n            break\n    table = f'# This table was generated by a call to\\n# `sympy.polys.numberfields.galois_resolvents.generate_lambda_lookup()`.\\n# The entire job took {total_time:.2f}s.\\n# Of this, Case (6, 1) took {time_for_61:.2f}s.\\n# The final polynomial of Case (6, 1) alone took {time_for_61_last:.2f}s.\\nresolvent_coeff_lambdas = {{\\n'\n    for (k, L) in lambda_lists.items():\n        table += f'    {k}: [\\n'\n        table += '        ' + L + '\\n'\n        table += '    ],\\n'\n    table += '}\\n'\n    return table",
        "mutated": [
            "def generate_lambda_lookup(verbose=False, trial_run=False):\n    if False:\n        i = 10\n    '\\n    Generate the whole lookup table of coeff lambdas, for all resolvents.\\n    '\n    jobs = define_resolvents()\n    lambda_lists = {}\n    total_time = 0\n    time_for_61 = 0\n    time_for_61_last = 0\n    for (k, (F, X, s)) in jobs.items():\n        (symmetrized, times) = sparse_symmetrize_resolvent_coeffs(F, X, s, verbose=verbose)\n        total_time += sum(times)\n        if k == (6, 1):\n            time_for_61 = sum(times)\n            time_for_61_last = times[-1]\n        sv = s_vars(len(X))\n        head = f\"lambda {', '.join((str(v) for v in sv))}:\"\n        lambda_lists[k] = ',\\n        '.join([f'{head} ({wrap(f)})' for f in symmetrized])\n        if trial_run:\n            break\n    table = f'# This table was generated by a call to\\n# `sympy.polys.numberfields.galois_resolvents.generate_lambda_lookup()`.\\n# The entire job took {total_time:.2f}s.\\n# Of this, Case (6, 1) took {time_for_61:.2f}s.\\n# The final polynomial of Case (6, 1) alone took {time_for_61_last:.2f}s.\\nresolvent_coeff_lambdas = {{\\n'\n    for (k, L) in lambda_lists.items():\n        table += f'    {k}: [\\n'\n        table += '        ' + L + '\\n'\n        table += '    ],\\n'\n    table += '}\\n'\n    return table",
            "def generate_lambda_lookup(verbose=False, trial_run=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Generate the whole lookup table of coeff lambdas, for all resolvents.\\n    '\n    jobs = define_resolvents()\n    lambda_lists = {}\n    total_time = 0\n    time_for_61 = 0\n    time_for_61_last = 0\n    for (k, (F, X, s)) in jobs.items():\n        (symmetrized, times) = sparse_symmetrize_resolvent_coeffs(F, X, s, verbose=verbose)\n        total_time += sum(times)\n        if k == (6, 1):\n            time_for_61 = sum(times)\n            time_for_61_last = times[-1]\n        sv = s_vars(len(X))\n        head = f\"lambda {', '.join((str(v) for v in sv))}:\"\n        lambda_lists[k] = ',\\n        '.join([f'{head} ({wrap(f)})' for f in symmetrized])\n        if trial_run:\n            break\n    table = f'# This table was generated by a call to\\n# `sympy.polys.numberfields.galois_resolvents.generate_lambda_lookup()`.\\n# The entire job took {total_time:.2f}s.\\n# Of this, Case (6, 1) took {time_for_61:.2f}s.\\n# The final polynomial of Case (6, 1) alone took {time_for_61_last:.2f}s.\\nresolvent_coeff_lambdas = {{\\n'\n    for (k, L) in lambda_lists.items():\n        table += f'    {k}: [\\n'\n        table += '        ' + L + '\\n'\n        table += '    ],\\n'\n    table += '}\\n'\n    return table",
            "def generate_lambda_lookup(verbose=False, trial_run=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Generate the whole lookup table of coeff lambdas, for all resolvents.\\n    '\n    jobs = define_resolvents()\n    lambda_lists = {}\n    total_time = 0\n    time_for_61 = 0\n    time_for_61_last = 0\n    for (k, (F, X, s)) in jobs.items():\n        (symmetrized, times) = sparse_symmetrize_resolvent_coeffs(F, X, s, verbose=verbose)\n        total_time += sum(times)\n        if k == (6, 1):\n            time_for_61 = sum(times)\n            time_for_61_last = times[-1]\n        sv = s_vars(len(X))\n        head = f\"lambda {', '.join((str(v) for v in sv))}:\"\n        lambda_lists[k] = ',\\n        '.join([f'{head} ({wrap(f)})' for f in symmetrized])\n        if trial_run:\n            break\n    table = f'# This table was generated by a call to\\n# `sympy.polys.numberfields.galois_resolvents.generate_lambda_lookup()`.\\n# The entire job took {total_time:.2f}s.\\n# Of this, Case (6, 1) took {time_for_61:.2f}s.\\n# The final polynomial of Case (6, 1) alone took {time_for_61_last:.2f}s.\\nresolvent_coeff_lambdas = {{\\n'\n    for (k, L) in lambda_lists.items():\n        table += f'    {k}: [\\n'\n        table += '        ' + L + '\\n'\n        table += '    ],\\n'\n    table += '}\\n'\n    return table",
            "def generate_lambda_lookup(verbose=False, trial_run=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Generate the whole lookup table of coeff lambdas, for all resolvents.\\n    '\n    jobs = define_resolvents()\n    lambda_lists = {}\n    total_time = 0\n    time_for_61 = 0\n    time_for_61_last = 0\n    for (k, (F, X, s)) in jobs.items():\n        (symmetrized, times) = sparse_symmetrize_resolvent_coeffs(F, X, s, verbose=verbose)\n        total_time += sum(times)\n        if k == (6, 1):\n            time_for_61 = sum(times)\n            time_for_61_last = times[-1]\n        sv = s_vars(len(X))\n        head = f\"lambda {', '.join((str(v) for v in sv))}:\"\n        lambda_lists[k] = ',\\n        '.join([f'{head} ({wrap(f)})' for f in symmetrized])\n        if trial_run:\n            break\n    table = f'# This table was generated by a call to\\n# `sympy.polys.numberfields.galois_resolvents.generate_lambda_lookup()`.\\n# The entire job took {total_time:.2f}s.\\n# Of this, Case (6, 1) took {time_for_61:.2f}s.\\n# The final polynomial of Case (6, 1) alone took {time_for_61_last:.2f}s.\\nresolvent_coeff_lambdas = {{\\n'\n    for (k, L) in lambda_lists.items():\n        table += f'    {k}: [\\n'\n        table += '        ' + L + '\\n'\n        table += '    ],\\n'\n    table += '}\\n'\n    return table",
            "def generate_lambda_lookup(verbose=False, trial_run=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Generate the whole lookup table of coeff lambdas, for all resolvents.\\n    '\n    jobs = define_resolvents()\n    lambda_lists = {}\n    total_time = 0\n    time_for_61 = 0\n    time_for_61_last = 0\n    for (k, (F, X, s)) in jobs.items():\n        (symmetrized, times) = sparse_symmetrize_resolvent_coeffs(F, X, s, verbose=verbose)\n        total_time += sum(times)\n        if k == (6, 1):\n            time_for_61 = sum(times)\n            time_for_61_last = times[-1]\n        sv = s_vars(len(X))\n        head = f\"lambda {', '.join((str(v) for v in sv))}:\"\n        lambda_lists[k] = ',\\n        '.join([f'{head} ({wrap(f)})' for f in symmetrized])\n        if trial_run:\n            break\n    table = f'# This table was generated by a call to\\n# `sympy.polys.numberfields.galois_resolvents.generate_lambda_lookup()`.\\n# The entire job took {total_time:.2f}s.\\n# Of this, Case (6, 1) took {time_for_61:.2f}s.\\n# The final polynomial of Case (6, 1) alone took {time_for_61_last:.2f}s.\\nresolvent_coeff_lambdas = {{\\n'\n    for (k, L) in lambda_lists.items():\n        table += f'    {k}: [\\n'\n        table += '        ' + L + '\\n'\n        table += '    ],\\n'\n    table += '}\\n'\n    return table"
        ]
    },
    {
        "func_name": "get_resolvent_by_lookup",
        "original": "def get_resolvent_by_lookup(T, number):\n    \"\"\"\n    Use the lookup table, to return a resolvent (as dup) for a given\n    polynomial *T*.\n\n    Parameters\n    ==========\n\n    T : Poly\n        The polynomial whose resolvent is needed\n\n    number : int\n        For some degrees, there are multiple resolvents.\n        Use this to indicate which one you want.\n\n    Returns\n    =======\n\n    dup\n\n    \"\"\"\n    degree = T.degree()\n    L = resolvent_coeff_lambdas[degree, number]\n    T_coeffs = T.rep.to_list()[1:]\n    return [ZZ(1)] + [c(*T_coeffs) for c in L]",
        "mutated": [
            "def get_resolvent_by_lookup(T, number):\n    if False:\n        i = 10\n    '\\n    Use the lookup table, to return a resolvent (as dup) for a given\\n    polynomial *T*.\\n\\n    Parameters\\n    ==========\\n\\n    T : Poly\\n        The polynomial whose resolvent is needed\\n\\n    number : int\\n        For some degrees, there are multiple resolvents.\\n        Use this to indicate which one you want.\\n\\n    Returns\\n    =======\\n\\n    dup\\n\\n    '\n    degree = T.degree()\n    L = resolvent_coeff_lambdas[degree, number]\n    T_coeffs = T.rep.to_list()[1:]\n    return [ZZ(1)] + [c(*T_coeffs) for c in L]",
            "def get_resolvent_by_lookup(T, number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Use the lookup table, to return a resolvent (as dup) for a given\\n    polynomial *T*.\\n\\n    Parameters\\n    ==========\\n\\n    T : Poly\\n        The polynomial whose resolvent is needed\\n\\n    number : int\\n        For some degrees, there are multiple resolvents.\\n        Use this to indicate which one you want.\\n\\n    Returns\\n    =======\\n\\n    dup\\n\\n    '\n    degree = T.degree()\n    L = resolvent_coeff_lambdas[degree, number]\n    T_coeffs = T.rep.to_list()[1:]\n    return [ZZ(1)] + [c(*T_coeffs) for c in L]",
            "def get_resolvent_by_lookup(T, number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Use the lookup table, to return a resolvent (as dup) for a given\\n    polynomial *T*.\\n\\n    Parameters\\n    ==========\\n\\n    T : Poly\\n        The polynomial whose resolvent is needed\\n\\n    number : int\\n        For some degrees, there are multiple resolvents.\\n        Use this to indicate which one you want.\\n\\n    Returns\\n    =======\\n\\n    dup\\n\\n    '\n    degree = T.degree()\n    L = resolvent_coeff_lambdas[degree, number]\n    T_coeffs = T.rep.to_list()[1:]\n    return [ZZ(1)] + [c(*T_coeffs) for c in L]",
            "def get_resolvent_by_lookup(T, number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Use the lookup table, to return a resolvent (as dup) for a given\\n    polynomial *T*.\\n\\n    Parameters\\n    ==========\\n\\n    T : Poly\\n        The polynomial whose resolvent is needed\\n\\n    number : int\\n        For some degrees, there are multiple resolvents.\\n        Use this to indicate which one you want.\\n\\n    Returns\\n    =======\\n\\n    dup\\n\\n    '\n    degree = T.degree()\n    L = resolvent_coeff_lambdas[degree, number]\n    T_coeffs = T.rep.to_list()[1:]\n    return [ZZ(1)] + [c(*T_coeffs) for c in L]",
            "def get_resolvent_by_lookup(T, number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Use the lookup table, to return a resolvent (as dup) for a given\\n    polynomial *T*.\\n\\n    Parameters\\n    ==========\\n\\n    T : Poly\\n        The polynomial whose resolvent is needed\\n\\n    number : int\\n        For some degrees, there are multiple resolvents.\\n        Use this to indicate which one you want.\\n\\n    Returns\\n    =======\\n\\n    dup\\n\\n    '\n    degree = T.degree()\n    L = resolvent_coeff_lambdas[degree, number]\n    T_coeffs = T.rep.to_list()[1:]\n    return [ZZ(1)] + [c(*T_coeffs) for c in L]"
        ]
    }
]