[
    {
        "func_name": "current_flow_closeness_centrality",
        "original": "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef current_flow_closeness_centrality(G, weight=None, dtype=float, solver='lu'):\n    \"\"\"Compute current-flow closeness centrality for nodes.\n\n    Current-flow closeness centrality is variant of closeness\n    centrality based on effective resistance between nodes in\n    a network. This metric is also known as information centrality.\n\n    Parameters\n    ----------\n    G : graph\n      A NetworkX graph.\n\n    weight : None or string, optional (default=None)\n      If None, all edge weights are considered equal.\n      Otherwise holds the name of the edge attribute used as weight.\n      The weight reflects the capacity or the strength of the\n      edge.\n\n    dtype: data type (default=float)\n      Default data type for internal matrices.\n      Set to np.float32 for lower memory consumption.\n\n    solver: string (default='lu')\n       Type of linear solver to use for computing the flow matrix.\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\n       \"cg\" (uses least memory).\n\n    Returns\n    -------\n    nodes : dictionary\n       Dictionary of nodes with current flow closeness centrality as the value.\n\n    See Also\n    --------\n    closeness_centrality\n\n    Notes\n    -----\n    The algorithm is from Brandes [1]_.\n\n    See also [2]_ for the original definition of information centrality.\n\n    References\n    ----------\n    .. [1] Ulrik Brandes and Daniel Fleischer,\n       Centrality Measures Based on Current Flow.\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS '05).\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\n       https://doi.org/10.1007/978-3-540-31856-9_44\n\n    .. [2] Karen Stephenson and Marvin Zelen:\n       Rethinking centrality: Methods and examples.\n       Social Networks 11(1):1-37, 1989.\n       https://doi.org/10.1016/0378-8733(89)90016-6\n    \"\"\"\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    solvername = {'full': FullInverseLaplacian, 'lu': SuperLUInverseLaplacian, 'cg': CGInverseLaplacian}\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))\n    betweenness = dict.fromkeys(H, 0.0)\n    n = H.number_of_nodes()\n    L = nx.laplacian_matrix(H, nodelist=range(n), weight=weight).asformat('csc')\n    L = L.astype(dtype)\n    C2 = solvername[solver](L, width=1, dtype=dtype)\n    for v in H:\n        col = C2.get_row(v)\n        for w in H:\n            betweenness[v] += col[v] - 2 * col[w]\n            betweenness[w] += col[v]\n    for v in H:\n        betweenness[v] = 1 / betweenness[v]\n    return {ordering[k]: v for (k, v) in betweenness.items()}",
        "mutated": [
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef current_flow_closeness_centrality(G, weight=None, dtype=float, solver='lu'):\n    if False:\n        i = 10\n    'Compute current-flow closeness centrality for nodes.\\n\\n    Current-flow closeness centrality is variant of closeness\\n    centrality based on effective resistance between nodes in\\n    a network. This metric is also known as information centrality.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph.\\n\\n    weight : None or string, optional (default=None)\\n      If None, all edge weights are considered equal.\\n      Otherwise holds the name of the edge attribute used as weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype: data type (default=float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver: string (default=\\'lu\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of nodes with current flow closeness centrality as the value.\\n\\n    See Also\\n    --------\\n    closeness_centrality\\n\\n    Notes\\n    -----\\n    The algorithm is from Brandes [1]_.\\n\\n    See also [2]_ for the original definition of information centrality.\\n\\n    References\\n    ----------\\n    .. [1] Ulrik Brandes and Daniel Fleischer,\\n       Centrality Measures Based on Current Flow.\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] Karen Stephenson and Marvin Zelen:\\n       Rethinking centrality: Methods and examples.\\n       Social Networks 11(1):1-37, 1989.\\n       https://doi.org/10.1016/0378-8733(89)90016-6\\n    '\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    solvername = {'full': FullInverseLaplacian, 'lu': SuperLUInverseLaplacian, 'cg': CGInverseLaplacian}\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))\n    betweenness = dict.fromkeys(H, 0.0)\n    n = H.number_of_nodes()\n    L = nx.laplacian_matrix(H, nodelist=range(n), weight=weight).asformat('csc')\n    L = L.astype(dtype)\n    C2 = solvername[solver](L, width=1, dtype=dtype)\n    for v in H:\n        col = C2.get_row(v)\n        for w in H:\n            betweenness[v] += col[v] - 2 * col[w]\n            betweenness[w] += col[v]\n    for v in H:\n        betweenness[v] = 1 / betweenness[v]\n    return {ordering[k]: v for (k, v) in betweenness.items()}",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef current_flow_closeness_centrality(G, weight=None, dtype=float, solver='lu'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute current-flow closeness centrality for nodes.\\n\\n    Current-flow closeness centrality is variant of closeness\\n    centrality based on effective resistance between nodes in\\n    a network. This metric is also known as information centrality.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph.\\n\\n    weight : None or string, optional (default=None)\\n      If None, all edge weights are considered equal.\\n      Otherwise holds the name of the edge attribute used as weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype: data type (default=float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver: string (default=\\'lu\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of nodes with current flow closeness centrality as the value.\\n\\n    See Also\\n    --------\\n    closeness_centrality\\n\\n    Notes\\n    -----\\n    The algorithm is from Brandes [1]_.\\n\\n    See also [2]_ for the original definition of information centrality.\\n\\n    References\\n    ----------\\n    .. [1] Ulrik Brandes and Daniel Fleischer,\\n       Centrality Measures Based on Current Flow.\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] Karen Stephenson and Marvin Zelen:\\n       Rethinking centrality: Methods and examples.\\n       Social Networks 11(1):1-37, 1989.\\n       https://doi.org/10.1016/0378-8733(89)90016-6\\n    '\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    solvername = {'full': FullInverseLaplacian, 'lu': SuperLUInverseLaplacian, 'cg': CGInverseLaplacian}\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))\n    betweenness = dict.fromkeys(H, 0.0)\n    n = H.number_of_nodes()\n    L = nx.laplacian_matrix(H, nodelist=range(n), weight=weight).asformat('csc')\n    L = L.astype(dtype)\n    C2 = solvername[solver](L, width=1, dtype=dtype)\n    for v in H:\n        col = C2.get_row(v)\n        for w in H:\n            betweenness[v] += col[v] - 2 * col[w]\n            betweenness[w] += col[v]\n    for v in H:\n        betweenness[v] = 1 / betweenness[v]\n    return {ordering[k]: v for (k, v) in betweenness.items()}",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef current_flow_closeness_centrality(G, weight=None, dtype=float, solver='lu'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute current-flow closeness centrality for nodes.\\n\\n    Current-flow closeness centrality is variant of closeness\\n    centrality based on effective resistance between nodes in\\n    a network. This metric is also known as information centrality.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph.\\n\\n    weight : None or string, optional (default=None)\\n      If None, all edge weights are considered equal.\\n      Otherwise holds the name of the edge attribute used as weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype: data type (default=float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver: string (default=\\'lu\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of nodes with current flow closeness centrality as the value.\\n\\n    See Also\\n    --------\\n    closeness_centrality\\n\\n    Notes\\n    -----\\n    The algorithm is from Brandes [1]_.\\n\\n    See also [2]_ for the original definition of information centrality.\\n\\n    References\\n    ----------\\n    .. [1] Ulrik Brandes and Daniel Fleischer,\\n       Centrality Measures Based on Current Flow.\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] Karen Stephenson and Marvin Zelen:\\n       Rethinking centrality: Methods and examples.\\n       Social Networks 11(1):1-37, 1989.\\n       https://doi.org/10.1016/0378-8733(89)90016-6\\n    '\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    solvername = {'full': FullInverseLaplacian, 'lu': SuperLUInverseLaplacian, 'cg': CGInverseLaplacian}\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))\n    betweenness = dict.fromkeys(H, 0.0)\n    n = H.number_of_nodes()\n    L = nx.laplacian_matrix(H, nodelist=range(n), weight=weight).asformat('csc')\n    L = L.astype(dtype)\n    C2 = solvername[solver](L, width=1, dtype=dtype)\n    for v in H:\n        col = C2.get_row(v)\n        for w in H:\n            betweenness[v] += col[v] - 2 * col[w]\n            betweenness[w] += col[v]\n    for v in H:\n        betweenness[v] = 1 / betweenness[v]\n    return {ordering[k]: v for (k, v) in betweenness.items()}",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef current_flow_closeness_centrality(G, weight=None, dtype=float, solver='lu'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute current-flow closeness centrality for nodes.\\n\\n    Current-flow closeness centrality is variant of closeness\\n    centrality based on effective resistance between nodes in\\n    a network. This metric is also known as information centrality.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph.\\n\\n    weight : None or string, optional (default=None)\\n      If None, all edge weights are considered equal.\\n      Otherwise holds the name of the edge attribute used as weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype: data type (default=float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver: string (default=\\'lu\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of nodes with current flow closeness centrality as the value.\\n\\n    See Also\\n    --------\\n    closeness_centrality\\n\\n    Notes\\n    -----\\n    The algorithm is from Brandes [1]_.\\n\\n    See also [2]_ for the original definition of information centrality.\\n\\n    References\\n    ----------\\n    .. [1] Ulrik Brandes and Daniel Fleischer,\\n       Centrality Measures Based on Current Flow.\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] Karen Stephenson and Marvin Zelen:\\n       Rethinking centrality: Methods and examples.\\n       Social Networks 11(1):1-37, 1989.\\n       https://doi.org/10.1016/0378-8733(89)90016-6\\n    '\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    solvername = {'full': FullInverseLaplacian, 'lu': SuperLUInverseLaplacian, 'cg': CGInverseLaplacian}\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))\n    betweenness = dict.fromkeys(H, 0.0)\n    n = H.number_of_nodes()\n    L = nx.laplacian_matrix(H, nodelist=range(n), weight=weight).asformat('csc')\n    L = L.astype(dtype)\n    C2 = solvername[solver](L, width=1, dtype=dtype)\n    for v in H:\n        col = C2.get_row(v)\n        for w in H:\n            betweenness[v] += col[v] - 2 * col[w]\n            betweenness[w] += col[v]\n    for v in H:\n        betweenness[v] = 1 / betweenness[v]\n    return {ordering[k]: v for (k, v) in betweenness.items()}",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef current_flow_closeness_centrality(G, weight=None, dtype=float, solver='lu'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute current-flow closeness centrality for nodes.\\n\\n    Current-flow closeness centrality is variant of closeness\\n    centrality based on effective resistance between nodes in\\n    a network. This metric is also known as information centrality.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph.\\n\\n    weight : None or string, optional (default=None)\\n      If None, all edge weights are considered equal.\\n      Otherwise holds the name of the edge attribute used as weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype: data type (default=float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver: string (default=\\'lu\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of nodes with current flow closeness centrality as the value.\\n\\n    See Also\\n    --------\\n    closeness_centrality\\n\\n    Notes\\n    -----\\n    The algorithm is from Brandes [1]_.\\n\\n    See also [2]_ for the original definition of information centrality.\\n\\n    References\\n    ----------\\n    .. [1] Ulrik Brandes and Daniel Fleischer,\\n       Centrality Measures Based on Current Flow.\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] Karen Stephenson and Marvin Zelen:\\n       Rethinking centrality: Methods and examples.\\n       Social Networks 11(1):1-37, 1989.\\n       https://doi.org/10.1016/0378-8733(89)90016-6\\n    '\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    solvername = {'full': FullInverseLaplacian, 'lu': SuperLUInverseLaplacian, 'cg': CGInverseLaplacian}\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))\n    betweenness = dict.fromkeys(H, 0.0)\n    n = H.number_of_nodes()\n    L = nx.laplacian_matrix(H, nodelist=range(n), weight=weight).asformat('csc')\n    L = L.astype(dtype)\n    C2 = solvername[solver](L, width=1, dtype=dtype)\n    for v in H:\n        col = C2.get_row(v)\n        for w in H:\n            betweenness[v] += col[v] - 2 * col[w]\n            betweenness[w] += col[v]\n    for v in H:\n        betweenness[v] = 1 / betweenness[v]\n    return {ordering[k]: v for (k, v) in betweenness.items()}"
        ]
    }
]