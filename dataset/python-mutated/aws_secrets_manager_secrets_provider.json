[
    {
        "func_name": "_sanitize_key_as_env_var",
        "original": "def _sanitize_key_as_env_var(key):\n    \"\"\"\n    Sanitize a key as an environment variable name.\n    This is purely a convenience trade-off to cover common cases well, vs. introducing\n    ambiguities (e.g. did the final '_' come from '.', or '-' or is original?).\n\n    1/27/2023(jackie):\n\n    We start with few rules and should *sparingly* add more over time.\n    Also, it's TBD whether all possible providers will share the same sanitization logic.\n    Therefore we will keep this function private for now\n    \"\"\"\n    return key.replace('-', '_').replace('.', '_').replace('/', '_')",
        "mutated": [
            "def _sanitize_key_as_env_var(key):\n    if False:\n        i = 10\n    \"\\n    Sanitize a key as an environment variable name.\\n    This is purely a convenience trade-off to cover common cases well, vs. introducing\\n    ambiguities (e.g. did the final '_' come from '.', or '-' or is original?).\\n\\n    1/27/2023(jackie):\\n\\n    We start with few rules and should *sparingly* add more over time.\\n    Also, it's TBD whether all possible providers will share the same sanitization logic.\\n    Therefore we will keep this function private for now\\n    \"\n    return key.replace('-', '_').replace('.', '_').replace('/', '_')",
            "def _sanitize_key_as_env_var(key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Sanitize a key as an environment variable name.\\n    This is purely a convenience trade-off to cover common cases well, vs. introducing\\n    ambiguities (e.g. did the final '_' come from '.', or '-' or is original?).\\n\\n    1/27/2023(jackie):\\n\\n    We start with few rules and should *sparingly* add more over time.\\n    Also, it's TBD whether all possible providers will share the same sanitization logic.\\n    Therefore we will keep this function private for now\\n    \"\n    return key.replace('-', '_').replace('.', '_').replace('/', '_')",
            "def _sanitize_key_as_env_var(key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Sanitize a key as an environment variable name.\\n    This is purely a convenience trade-off to cover common cases well, vs. introducing\\n    ambiguities (e.g. did the final '_' come from '.', or '-' or is original?).\\n\\n    1/27/2023(jackie):\\n\\n    We start with few rules and should *sparingly* add more over time.\\n    Also, it's TBD whether all possible providers will share the same sanitization logic.\\n    Therefore we will keep this function private for now\\n    \"\n    return key.replace('-', '_').replace('.', '_').replace('/', '_')",
            "def _sanitize_key_as_env_var(key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Sanitize a key as an environment variable name.\\n    This is purely a convenience trade-off to cover common cases well, vs. introducing\\n    ambiguities (e.g. did the final '_' come from '.', or '-' or is original?).\\n\\n    1/27/2023(jackie):\\n\\n    We start with few rules and should *sparingly* add more over time.\\n    Also, it's TBD whether all possible providers will share the same sanitization logic.\\n    Therefore we will keep this function private for now\\n    \"\n    return key.replace('-', '_').replace('.', '_').replace('/', '_')",
            "def _sanitize_key_as_env_var(key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Sanitize a key as an environment variable name.\\n    This is purely a convenience trade-off to cover common cases well, vs. introducing\\n    ambiguities (e.g. did the final '_' come from '.', or '-' or is original?).\\n\\n    1/27/2023(jackie):\\n\\n    We start with few rules and should *sparingly* add more over time.\\n    Also, it's TBD whether all possible providers will share the same sanitization logic.\\n    Therefore we will keep this function private for now\\n    \"\n    return key.replace('-', '_').replace('.', '_').replace('/', '_')"
        ]
    },
    {
        "func_name": "_sanitize_and_add_entry_to_result",
        "original": "def _sanitize_and_add_entry_to_result(k, v):\n    sanitized_k = _sanitize_key_as_env_var(k)\n    if sanitized_k in result:\n        raise MetaflowAWSSecretsManagerDuplicateKey(\"Duplicate key in secret: '%s' (sanitizes to '%s')\" % (k, sanitized_k))\n    result[sanitized_k] = v",
        "mutated": [
            "def _sanitize_and_add_entry_to_result(k, v):\n    if False:\n        i = 10\n    sanitized_k = _sanitize_key_as_env_var(k)\n    if sanitized_k in result:\n        raise MetaflowAWSSecretsManagerDuplicateKey(\"Duplicate key in secret: '%s' (sanitizes to '%s')\" % (k, sanitized_k))\n    result[sanitized_k] = v",
            "def _sanitize_and_add_entry_to_result(k, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    sanitized_k = _sanitize_key_as_env_var(k)\n    if sanitized_k in result:\n        raise MetaflowAWSSecretsManagerDuplicateKey(\"Duplicate key in secret: '%s' (sanitizes to '%s')\" % (k, sanitized_k))\n    result[sanitized_k] = v",
            "def _sanitize_and_add_entry_to_result(k, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    sanitized_k = _sanitize_key_as_env_var(k)\n    if sanitized_k in result:\n        raise MetaflowAWSSecretsManagerDuplicateKey(\"Duplicate key in secret: '%s' (sanitizes to '%s')\" % (k, sanitized_k))\n    result[sanitized_k] = v",
            "def _sanitize_and_add_entry_to_result(k, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    sanitized_k = _sanitize_key_as_env_var(k)\n    if sanitized_k in result:\n        raise MetaflowAWSSecretsManagerDuplicateKey(\"Duplicate key in secret: '%s' (sanitizes to '%s')\" % (k, sanitized_k))\n    result[sanitized_k] = v",
            "def _sanitize_and_add_entry_to_result(k, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    sanitized_k = _sanitize_key_as_env_var(k)\n    if sanitized_k in result:\n        raise MetaflowAWSSecretsManagerDuplicateKey(\"Duplicate key in secret: '%s' (sanitizes to '%s')\" % (k, sanitized_k))\n    result[sanitized_k] = v"
        ]
    },
    {
        "func_name": "get_secret_as_dict",
        "original": "def get_secret_as_dict(self, secret_id, options={}, role=None):\n    \"\"\"\n        Reads a secret from AWS Secrets Manager and returns it as a dictionary of environment variables.\n\n        The secret payload from AWS is EITHER a string OR a binary blob.\n\n        If the secret contains a string payload (\"SecretString\"):\n        - if the `parse_secret_string_as_json` option is True (default):\n            {SecretString} will be parsed as a JSON. If successfully parsed, AND the JSON contains a\n            top-level object, each entry K/V in the object will also be converted to an entry in the result. V will\n            always be casted to a string (if not already a string).\n        - If `parse_secret_string_as_json` option is False:\n            {SecretString} will be returned as a single entry in the result, with the key being the secret_id.\n\n        Otherwise, the secret contains a binary blob payload (\"SecretBinary\"). In this case\n        - The result dic contains '{SecretName}': '{SecretBinary}', where {SecretBinary} is a base64-encoded string\n\n        All keys in the result are sanitized to be more valid environment variable names. This is done on a best effort\n        basis. Further validation is expected to be done by the invoking @secrets decorator itself.\n\n        :param secret_id: ARN or friendly name of the secret\n        :param options: unused\n        :param role: AWS IAM Role ARN to assume before reading the secret\n        :return: dict of environment variables. All keys and values are strings.\n        \"\"\"\n    import botocore\n    from metaflow.plugins.aws.aws_client import get_aws_client\n    effective_aws_region = None\n    m = re.match('arn:aws:secretsmanager:([^:]+):', secret_id)\n    if m:\n        effective_aws_region = m.group(1)\n    elif 'region' in options:\n        effective_aws_region = options['region']\n    else:\n        effective_aws_region = AWS_SECRETS_MANAGER_DEFAULT_REGION\n    try:\n        secrets_manager_client = get_aws_client('secretsmanager', client_params={'region_name': effective_aws_region}, role_arn=role)\n    except botocore.exceptions.NoRegionError:\n        raise MetaflowException('Default region is not specified for AWS Secrets Manager. Please set METAFLOW_AWS_SECRETS_MANAGER_DEFAULT_REGION')\n    result = {}\n\n    def _sanitize_and_add_entry_to_result(k, v):\n        sanitized_k = _sanitize_key_as_env_var(k)\n        if sanitized_k in result:\n            raise MetaflowAWSSecretsManagerDuplicateKey(\"Duplicate key in secret: '%s' (sanitizes to '%s')\" % (k, sanitized_k))\n        result[sanitized_k] = v\n    \"\\n        These are the exceptions that can be raised by the AWS SDK:\\n        \\n        SecretsManager.Client.exceptions.ResourceNotFoundException\\n        SecretsManager.Client.exceptions.InvalidParameterException\\n        SecretsManager.Client.exceptions.InvalidRequestException\\n        SecretsManager.Client.exceptions.DecryptionFailure\\n        SecretsManager.Client.exceptions.InternalServiceError\\n        \\n        Looks pretty informative already, so we won't catch here directly.\\n        \\n        1/27/2023(jackie) - We will evolve this over time as we learn more.\\n        \"\n    response = secrets_manager_client.get_secret_value(SecretId=secret_id)\n    if 'Name' not in response:\n        raise MetaflowAWSSecretsManagerBadResponse(\"Secret 'Name' is missing in response\")\n    secret_name = response['Name']\n    if 'SecretString' in response:\n        secret_str = response['SecretString']\n        if options.get('json', True):\n            try:\n                obj = json.loads(secret_str)\n                if type(obj) == dict:\n                    for (k, v) in obj.items():\n                        _sanitize_and_add_entry_to_result(k, str(v))\n                else:\n                    raise MetaflowAWSSecretsManagerNotJSONObject('Secret string is a JSON, but not an object (dict-like) - actual type %s.' % type(obj))\n            except JSONDecodeError:\n                raise MetaflowAWSSecretsManagerJSONParseError('Secret string could not be parsed as JSON')\n        else:\n            if options.get('env_var_name'):\n                env_var_name = options['env_var_name']\n            else:\n                env_var_name = secret_name\n            _sanitize_and_add_entry_to_result(env_var_name, secret_str)\n    elif 'SecretBinary' in response:\n        if options.get('env_var_name'):\n            env_var_name = options['env_var_name']\n        else:\n            env_var_name = secret_name\n        _sanitize_and_add_entry_to_result(env_var_name, base64.b64encode(response['SecretBinary']).decode())\n    else:\n        raise MetaflowAWSSecretsManagerBadResponse(\"Secret response is missing both 'SecretString' and 'SecretBinary'\")\n    return result",
        "mutated": [
            "def get_secret_as_dict(self, secret_id, options={}, role=None):\n    if False:\n        i = 10\n    '\\n        Reads a secret from AWS Secrets Manager and returns it as a dictionary of environment variables.\\n\\n        The secret payload from AWS is EITHER a string OR a binary blob.\\n\\n        If the secret contains a string payload (\"SecretString\"):\\n        - if the `parse_secret_string_as_json` option is True (default):\\n            {SecretString} will be parsed as a JSON. If successfully parsed, AND the JSON contains a\\n            top-level object, each entry K/V in the object will also be converted to an entry in the result. V will\\n            always be casted to a string (if not already a string).\\n        - If `parse_secret_string_as_json` option is False:\\n            {SecretString} will be returned as a single entry in the result, with the key being the secret_id.\\n\\n        Otherwise, the secret contains a binary blob payload (\"SecretBinary\"). In this case\\n        - The result dic contains \\'{SecretName}\\': \\'{SecretBinary}\\', where {SecretBinary} is a base64-encoded string\\n\\n        All keys in the result are sanitized to be more valid environment variable names. This is done on a best effort\\n        basis. Further validation is expected to be done by the invoking @secrets decorator itself.\\n\\n        :param secret_id: ARN or friendly name of the secret\\n        :param options: unused\\n        :param role: AWS IAM Role ARN to assume before reading the secret\\n        :return: dict of environment variables. All keys and values are strings.\\n        '\n    import botocore\n    from metaflow.plugins.aws.aws_client import get_aws_client\n    effective_aws_region = None\n    m = re.match('arn:aws:secretsmanager:([^:]+):', secret_id)\n    if m:\n        effective_aws_region = m.group(1)\n    elif 'region' in options:\n        effective_aws_region = options['region']\n    else:\n        effective_aws_region = AWS_SECRETS_MANAGER_DEFAULT_REGION\n    try:\n        secrets_manager_client = get_aws_client('secretsmanager', client_params={'region_name': effective_aws_region}, role_arn=role)\n    except botocore.exceptions.NoRegionError:\n        raise MetaflowException('Default region is not specified for AWS Secrets Manager. Please set METAFLOW_AWS_SECRETS_MANAGER_DEFAULT_REGION')\n    result = {}\n\n    def _sanitize_and_add_entry_to_result(k, v):\n        sanitized_k = _sanitize_key_as_env_var(k)\n        if sanitized_k in result:\n            raise MetaflowAWSSecretsManagerDuplicateKey(\"Duplicate key in secret: '%s' (sanitizes to '%s')\" % (k, sanitized_k))\n        result[sanitized_k] = v\n    \"\\n        These are the exceptions that can be raised by the AWS SDK:\\n        \\n        SecretsManager.Client.exceptions.ResourceNotFoundException\\n        SecretsManager.Client.exceptions.InvalidParameterException\\n        SecretsManager.Client.exceptions.InvalidRequestException\\n        SecretsManager.Client.exceptions.DecryptionFailure\\n        SecretsManager.Client.exceptions.InternalServiceError\\n        \\n        Looks pretty informative already, so we won't catch here directly.\\n        \\n        1/27/2023(jackie) - We will evolve this over time as we learn more.\\n        \"\n    response = secrets_manager_client.get_secret_value(SecretId=secret_id)\n    if 'Name' not in response:\n        raise MetaflowAWSSecretsManagerBadResponse(\"Secret 'Name' is missing in response\")\n    secret_name = response['Name']\n    if 'SecretString' in response:\n        secret_str = response['SecretString']\n        if options.get('json', True):\n            try:\n                obj = json.loads(secret_str)\n                if type(obj) == dict:\n                    for (k, v) in obj.items():\n                        _sanitize_and_add_entry_to_result(k, str(v))\n                else:\n                    raise MetaflowAWSSecretsManagerNotJSONObject('Secret string is a JSON, but not an object (dict-like) - actual type %s.' % type(obj))\n            except JSONDecodeError:\n                raise MetaflowAWSSecretsManagerJSONParseError('Secret string could not be parsed as JSON')\n        else:\n            if options.get('env_var_name'):\n                env_var_name = options['env_var_name']\n            else:\n                env_var_name = secret_name\n            _sanitize_and_add_entry_to_result(env_var_name, secret_str)\n    elif 'SecretBinary' in response:\n        if options.get('env_var_name'):\n            env_var_name = options['env_var_name']\n        else:\n            env_var_name = secret_name\n        _sanitize_and_add_entry_to_result(env_var_name, base64.b64encode(response['SecretBinary']).decode())\n    else:\n        raise MetaflowAWSSecretsManagerBadResponse(\"Secret response is missing both 'SecretString' and 'SecretBinary'\")\n    return result",
            "def get_secret_as_dict(self, secret_id, options={}, role=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Reads a secret from AWS Secrets Manager and returns it as a dictionary of environment variables.\\n\\n        The secret payload from AWS is EITHER a string OR a binary blob.\\n\\n        If the secret contains a string payload (\"SecretString\"):\\n        - if the `parse_secret_string_as_json` option is True (default):\\n            {SecretString} will be parsed as a JSON. If successfully parsed, AND the JSON contains a\\n            top-level object, each entry K/V in the object will also be converted to an entry in the result. V will\\n            always be casted to a string (if not already a string).\\n        - If `parse_secret_string_as_json` option is False:\\n            {SecretString} will be returned as a single entry in the result, with the key being the secret_id.\\n\\n        Otherwise, the secret contains a binary blob payload (\"SecretBinary\"). In this case\\n        - The result dic contains \\'{SecretName}\\': \\'{SecretBinary}\\', where {SecretBinary} is a base64-encoded string\\n\\n        All keys in the result are sanitized to be more valid environment variable names. This is done on a best effort\\n        basis. Further validation is expected to be done by the invoking @secrets decorator itself.\\n\\n        :param secret_id: ARN or friendly name of the secret\\n        :param options: unused\\n        :param role: AWS IAM Role ARN to assume before reading the secret\\n        :return: dict of environment variables. All keys and values are strings.\\n        '\n    import botocore\n    from metaflow.plugins.aws.aws_client import get_aws_client\n    effective_aws_region = None\n    m = re.match('arn:aws:secretsmanager:([^:]+):', secret_id)\n    if m:\n        effective_aws_region = m.group(1)\n    elif 'region' in options:\n        effective_aws_region = options['region']\n    else:\n        effective_aws_region = AWS_SECRETS_MANAGER_DEFAULT_REGION\n    try:\n        secrets_manager_client = get_aws_client('secretsmanager', client_params={'region_name': effective_aws_region}, role_arn=role)\n    except botocore.exceptions.NoRegionError:\n        raise MetaflowException('Default region is not specified for AWS Secrets Manager. Please set METAFLOW_AWS_SECRETS_MANAGER_DEFAULT_REGION')\n    result = {}\n\n    def _sanitize_and_add_entry_to_result(k, v):\n        sanitized_k = _sanitize_key_as_env_var(k)\n        if sanitized_k in result:\n            raise MetaflowAWSSecretsManagerDuplicateKey(\"Duplicate key in secret: '%s' (sanitizes to '%s')\" % (k, sanitized_k))\n        result[sanitized_k] = v\n    \"\\n        These are the exceptions that can be raised by the AWS SDK:\\n        \\n        SecretsManager.Client.exceptions.ResourceNotFoundException\\n        SecretsManager.Client.exceptions.InvalidParameterException\\n        SecretsManager.Client.exceptions.InvalidRequestException\\n        SecretsManager.Client.exceptions.DecryptionFailure\\n        SecretsManager.Client.exceptions.InternalServiceError\\n        \\n        Looks pretty informative already, so we won't catch here directly.\\n        \\n        1/27/2023(jackie) - We will evolve this over time as we learn more.\\n        \"\n    response = secrets_manager_client.get_secret_value(SecretId=secret_id)\n    if 'Name' not in response:\n        raise MetaflowAWSSecretsManagerBadResponse(\"Secret 'Name' is missing in response\")\n    secret_name = response['Name']\n    if 'SecretString' in response:\n        secret_str = response['SecretString']\n        if options.get('json', True):\n            try:\n                obj = json.loads(secret_str)\n                if type(obj) == dict:\n                    for (k, v) in obj.items():\n                        _sanitize_and_add_entry_to_result(k, str(v))\n                else:\n                    raise MetaflowAWSSecretsManagerNotJSONObject('Secret string is a JSON, but not an object (dict-like) - actual type %s.' % type(obj))\n            except JSONDecodeError:\n                raise MetaflowAWSSecretsManagerJSONParseError('Secret string could not be parsed as JSON')\n        else:\n            if options.get('env_var_name'):\n                env_var_name = options['env_var_name']\n            else:\n                env_var_name = secret_name\n            _sanitize_and_add_entry_to_result(env_var_name, secret_str)\n    elif 'SecretBinary' in response:\n        if options.get('env_var_name'):\n            env_var_name = options['env_var_name']\n        else:\n            env_var_name = secret_name\n        _sanitize_and_add_entry_to_result(env_var_name, base64.b64encode(response['SecretBinary']).decode())\n    else:\n        raise MetaflowAWSSecretsManagerBadResponse(\"Secret response is missing both 'SecretString' and 'SecretBinary'\")\n    return result",
            "def get_secret_as_dict(self, secret_id, options={}, role=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Reads a secret from AWS Secrets Manager and returns it as a dictionary of environment variables.\\n\\n        The secret payload from AWS is EITHER a string OR a binary blob.\\n\\n        If the secret contains a string payload (\"SecretString\"):\\n        - if the `parse_secret_string_as_json` option is True (default):\\n            {SecretString} will be parsed as a JSON. If successfully parsed, AND the JSON contains a\\n            top-level object, each entry K/V in the object will also be converted to an entry in the result. V will\\n            always be casted to a string (if not already a string).\\n        - If `parse_secret_string_as_json` option is False:\\n            {SecretString} will be returned as a single entry in the result, with the key being the secret_id.\\n\\n        Otherwise, the secret contains a binary blob payload (\"SecretBinary\"). In this case\\n        - The result dic contains \\'{SecretName}\\': \\'{SecretBinary}\\', where {SecretBinary} is a base64-encoded string\\n\\n        All keys in the result are sanitized to be more valid environment variable names. This is done on a best effort\\n        basis. Further validation is expected to be done by the invoking @secrets decorator itself.\\n\\n        :param secret_id: ARN or friendly name of the secret\\n        :param options: unused\\n        :param role: AWS IAM Role ARN to assume before reading the secret\\n        :return: dict of environment variables. All keys and values are strings.\\n        '\n    import botocore\n    from metaflow.plugins.aws.aws_client import get_aws_client\n    effective_aws_region = None\n    m = re.match('arn:aws:secretsmanager:([^:]+):', secret_id)\n    if m:\n        effective_aws_region = m.group(1)\n    elif 'region' in options:\n        effective_aws_region = options['region']\n    else:\n        effective_aws_region = AWS_SECRETS_MANAGER_DEFAULT_REGION\n    try:\n        secrets_manager_client = get_aws_client('secretsmanager', client_params={'region_name': effective_aws_region}, role_arn=role)\n    except botocore.exceptions.NoRegionError:\n        raise MetaflowException('Default region is not specified for AWS Secrets Manager. Please set METAFLOW_AWS_SECRETS_MANAGER_DEFAULT_REGION')\n    result = {}\n\n    def _sanitize_and_add_entry_to_result(k, v):\n        sanitized_k = _sanitize_key_as_env_var(k)\n        if sanitized_k in result:\n            raise MetaflowAWSSecretsManagerDuplicateKey(\"Duplicate key in secret: '%s' (sanitizes to '%s')\" % (k, sanitized_k))\n        result[sanitized_k] = v\n    \"\\n        These are the exceptions that can be raised by the AWS SDK:\\n        \\n        SecretsManager.Client.exceptions.ResourceNotFoundException\\n        SecretsManager.Client.exceptions.InvalidParameterException\\n        SecretsManager.Client.exceptions.InvalidRequestException\\n        SecretsManager.Client.exceptions.DecryptionFailure\\n        SecretsManager.Client.exceptions.InternalServiceError\\n        \\n        Looks pretty informative already, so we won't catch here directly.\\n        \\n        1/27/2023(jackie) - We will evolve this over time as we learn more.\\n        \"\n    response = secrets_manager_client.get_secret_value(SecretId=secret_id)\n    if 'Name' not in response:\n        raise MetaflowAWSSecretsManagerBadResponse(\"Secret 'Name' is missing in response\")\n    secret_name = response['Name']\n    if 'SecretString' in response:\n        secret_str = response['SecretString']\n        if options.get('json', True):\n            try:\n                obj = json.loads(secret_str)\n                if type(obj) == dict:\n                    for (k, v) in obj.items():\n                        _sanitize_and_add_entry_to_result(k, str(v))\n                else:\n                    raise MetaflowAWSSecretsManagerNotJSONObject('Secret string is a JSON, but not an object (dict-like) - actual type %s.' % type(obj))\n            except JSONDecodeError:\n                raise MetaflowAWSSecretsManagerJSONParseError('Secret string could not be parsed as JSON')\n        else:\n            if options.get('env_var_name'):\n                env_var_name = options['env_var_name']\n            else:\n                env_var_name = secret_name\n            _sanitize_and_add_entry_to_result(env_var_name, secret_str)\n    elif 'SecretBinary' in response:\n        if options.get('env_var_name'):\n            env_var_name = options['env_var_name']\n        else:\n            env_var_name = secret_name\n        _sanitize_and_add_entry_to_result(env_var_name, base64.b64encode(response['SecretBinary']).decode())\n    else:\n        raise MetaflowAWSSecretsManagerBadResponse(\"Secret response is missing both 'SecretString' and 'SecretBinary'\")\n    return result",
            "def get_secret_as_dict(self, secret_id, options={}, role=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Reads a secret from AWS Secrets Manager and returns it as a dictionary of environment variables.\\n\\n        The secret payload from AWS is EITHER a string OR a binary blob.\\n\\n        If the secret contains a string payload (\"SecretString\"):\\n        - if the `parse_secret_string_as_json` option is True (default):\\n            {SecretString} will be parsed as a JSON. If successfully parsed, AND the JSON contains a\\n            top-level object, each entry K/V in the object will also be converted to an entry in the result. V will\\n            always be casted to a string (if not already a string).\\n        - If `parse_secret_string_as_json` option is False:\\n            {SecretString} will be returned as a single entry in the result, with the key being the secret_id.\\n\\n        Otherwise, the secret contains a binary blob payload (\"SecretBinary\"). In this case\\n        - The result dic contains \\'{SecretName}\\': \\'{SecretBinary}\\', where {SecretBinary} is a base64-encoded string\\n\\n        All keys in the result are sanitized to be more valid environment variable names. This is done on a best effort\\n        basis. Further validation is expected to be done by the invoking @secrets decorator itself.\\n\\n        :param secret_id: ARN or friendly name of the secret\\n        :param options: unused\\n        :param role: AWS IAM Role ARN to assume before reading the secret\\n        :return: dict of environment variables. All keys and values are strings.\\n        '\n    import botocore\n    from metaflow.plugins.aws.aws_client import get_aws_client\n    effective_aws_region = None\n    m = re.match('arn:aws:secretsmanager:([^:]+):', secret_id)\n    if m:\n        effective_aws_region = m.group(1)\n    elif 'region' in options:\n        effective_aws_region = options['region']\n    else:\n        effective_aws_region = AWS_SECRETS_MANAGER_DEFAULT_REGION\n    try:\n        secrets_manager_client = get_aws_client('secretsmanager', client_params={'region_name': effective_aws_region}, role_arn=role)\n    except botocore.exceptions.NoRegionError:\n        raise MetaflowException('Default region is not specified for AWS Secrets Manager. Please set METAFLOW_AWS_SECRETS_MANAGER_DEFAULT_REGION')\n    result = {}\n\n    def _sanitize_and_add_entry_to_result(k, v):\n        sanitized_k = _sanitize_key_as_env_var(k)\n        if sanitized_k in result:\n            raise MetaflowAWSSecretsManagerDuplicateKey(\"Duplicate key in secret: '%s' (sanitizes to '%s')\" % (k, sanitized_k))\n        result[sanitized_k] = v\n    \"\\n        These are the exceptions that can be raised by the AWS SDK:\\n        \\n        SecretsManager.Client.exceptions.ResourceNotFoundException\\n        SecretsManager.Client.exceptions.InvalidParameterException\\n        SecretsManager.Client.exceptions.InvalidRequestException\\n        SecretsManager.Client.exceptions.DecryptionFailure\\n        SecretsManager.Client.exceptions.InternalServiceError\\n        \\n        Looks pretty informative already, so we won't catch here directly.\\n        \\n        1/27/2023(jackie) - We will evolve this over time as we learn more.\\n        \"\n    response = secrets_manager_client.get_secret_value(SecretId=secret_id)\n    if 'Name' not in response:\n        raise MetaflowAWSSecretsManagerBadResponse(\"Secret 'Name' is missing in response\")\n    secret_name = response['Name']\n    if 'SecretString' in response:\n        secret_str = response['SecretString']\n        if options.get('json', True):\n            try:\n                obj = json.loads(secret_str)\n                if type(obj) == dict:\n                    for (k, v) in obj.items():\n                        _sanitize_and_add_entry_to_result(k, str(v))\n                else:\n                    raise MetaflowAWSSecretsManagerNotJSONObject('Secret string is a JSON, but not an object (dict-like) - actual type %s.' % type(obj))\n            except JSONDecodeError:\n                raise MetaflowAWSSecretsManagerJSONParseError('Secret string could not be parsed as JSON')\n        else:\n            if options.get('env_var_name'):\n                env_var_name = options['env_var_name']\n            else:\n                env_var_name = secret_name\n            _sanitize_and_add_entry_to_result(env_var_name, secret_str)\n    elif 'SecretBinary' in response:\n        if options.get('env_var_name'):\n            env_var_name = options['env_var_name']\n        else:\n            env_var_name = secret_name\n        _sanitize_and_add_entry_to_result(env_var_name, base64.b64encode(response['SecretBinary']).decode())\n    else:\n        raise MetaflowAWSSecretsManagerBadResponse(\"Secret response is missing both 'SecretString' and 'SecretBinary'\")\n    return result",
            "def get_secret_as_dict(self, secret_id, options={}, role=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Reads a secret from AWS Secrets Manager and returns it as a dictionary of environment variables.\\n\\n        The secret payload from AWS is EITHER a string OR a binary blob.\\n\\n        If the secret contains a string payload (\"SecretString\"):\\n        - if the `parse_secret_string_as_json` option is True (default):\\n            {SecretString} will be parsed as a JSON. If successfully parsed, AND the JSON contains a\\n            top-level object, each entry K/V in the object will also be converted to an entry in the result. V will\\n            always be casted to a string (if not already a string).\\n        - If `parse_secret_string_as_json` option is False:\\n            {SecretString} will be returned as a single entry in the result, with the key being the secret_id.\\n\\n        Otherwise, the secret contains a binary blob payload (\"SecretBinary\"). In this case\\n        - The result dic contains \\'{SecretName}\\': \\'{SecretBinary}\\', where {SecretBinary} is a base64-encoded string\\n\\n        All keys in the result are sanitized to be more valid environment variable names. This is done on a best effort\\n        basis. Further validation is expected to be done by the invoking @secrets decorator itself.\\n\\n        :param secret_id: ARN or friendly name of the secret\\n        :param options: unused\\n        :param role: AWS IAM Role ARN to assume before reading the secret\\n        :return: dict of environment variables. All keys and values are strings.\\n        '\n    import botocore\n    from metaflow.plugins.aws.aws_client import get_aws_client\n    effective_aws_region = None\n    m = re.match('arn:aws:secretsmanager:([^:]+):', secret_id)\n    if m:\n        effective_aws_region = m.group(1)\n    elif 'region' in options:\n        effective_aws_region = options['region']\n    else:\n        effective_aws_region = AWS_SECRETS_MANAGER_DEFAULT_REGION\n    try:\n        secrets_manager_client = get_aws_client('secretsmanager', client_params={'region_name': effective_aws_region}, role_arn=role)\n    except botocore.exceptions.NoRegionError:\n        raise MetaflowException('Default region is not specified for AWS Secrets Manager. Please set METAFLOW_AWS_SECRETS_MANAGER_DEFAULT_REGION')\n    result = {}\n\n    def _sanitize_and_add_entry_to_result(k, v):\n        sanitized_k = _sanitize_key_as_env_var(k)\n        if sanitized_k in result:\n            raise MetaflowAWSSecretsManagerDuplicateKey(\"Duplicate key in secret: '%s' (sanitizes to '%s')\" % (k, sanitized_k))\n        result[sanitized_k] = v\n    \"\\n        These are the exceptions that can be raised by the AWS SDK:\\n        \\n        SecretsManager.Client.exceptions.ResourceNotFoundException\\n        SecretsManager.Client.exceptions.InvalidParameterException\\n        SecretsManager.Client.exceptions.InvalidRequestException\\n        SecretsManager.Client.exceptions.DecryptionFailure\\n        SecretsManager.Client.exceptions.InternalServiceError\\n        \\n        Looks pretty informative already, so we won't catch here directly.\\n        \\n        1/27/2023(jackie) - We will evolve this over time as we learn more.\\n        \"\n    response = secrets_manager_client.get_secret_value(SecretId=secret_id)\n    if 'Name' not in response:\n        raise MetaflowAWSSecretsManagerBadResponse(\"Secret 'Name' is missing in response\")\n    secret_name = response['Name']\n    if 'SecretString' in response:\n        secret_str = response['SecretString']\n        if options.get('json', True):\n            try:\n                obj = json.loads(secret_str)\n                if type(obj) == dict:\n                    for (k, v) in obj.items():\n                        _sanitize_and_add_entry_to_result(k, str(v))\n                else:\n                    raise MetaflowAWSSecretsManagerNotJSONObject('Secret string is a JSON, but not an object (dict-like) - actual type %s.' % type(obj))\n            except JSONDecodeError:\n                raise MetaflowAWSSecretsManagerJSONParseError('Secret string could not be parsed as JSON')\n        else:\n            if options.get('env_var_name'):\n                env_var_name = options['env_var_name']\n            else:\n                env_var_name = secret_name\n            _sanitize_and_add_entry_to_result(env_var_name, secret_str)\n    elif 'SecretBinary' in response:\n        if options.get('env_var_name'):\n            env_var_name = options['env_var_name']\n        else:\n            env_var_name = secret_name\n        _sanitize_and_add_entry_to_result(env_var_name, base64.b64encode(response['SecretBinary']).decode())\n    else:\n        raise MetaflowAWSSecretsManagerBadResponse(\"Secret response is missing both 'SecretString' and 'SecretBinary'\")\n    return result"
        ]
    }
]