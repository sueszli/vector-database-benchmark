[
    {
        "func_name": "_string",
        "original": "def _string(s):\n    out = []\n    for co in bytearray(s):\n        c = chr(co)\n        if co >= 32 and co <= 126 and (c not in '/$\\'\"`'):\n            out.append(c)\n        else:\n            out.append('\\\\x%02x' % co)\n    return '\"' + ''.join(out) + '\"\\n'",
        "mutated": [
            "def _string(s):\n    if False:\n        i = 10\n    out = []\n    for co in bytearray(s):\n        c = chr(co)\n        if co >= 32 and co <= 126 and (c not in '/$\\'\"`'):\n            out.append(c)\n        else:\n            out.append('\\\\x%02x' % co)\n    return '\"' + ''.join(out) + '\"\\n'",
            "def _string(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    out = []\n    for co in bytearray(s):\n        c = chr(co)\n        if co >= 32 and co <= 126 and (c not in '/$\\'\"`'):\n            out.append(c)\n        else:\n            out.append('\\\\x%02x' % co)\n    return '\"' + ''.join(out) + '\"\\n'",
            "def _string(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    out = []\n    for co in bytearray(s):\n        c = chr(co)\n        if co >= 32 and co <= 126 and (c not in '/$\\'\"`'):\n            out.append(c)\n        else:\n            out.append('\\\\x%02x' % co)\n    return '\"' + ''.join(out) + '\"\\n'",
            "def _string(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    out = []\n    for co in bytearray(s):\n        c = chr(co)\n        if co >= 32 and co <= 126 and (c not in '/$\\'\"`'):\n            out.append(c)\n        else:\n            out.append('\\\\x%02x' % co)\n    return '\"' + ''.join(out) + '\"\\n'",
            "def _string(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    out = []\n    for co in bytearray(s):\n        c = chr(co)\n        if co >= 32 and co <= 126 and (c not in '/$\\'\"`'):\n            out.append(c)\n        else:\n            out.append('\\\\x%02x' % co)\n    return '\"' + ''.join(out) + '\"\\n'"
        ]
    },
    {
        "func_name": "get_template",
        "original": "def get_template(name):\n    func = shellcraft\n    for attr in name.split('.'):\n        func = getattr(func, attr)\n    return func",
        "mutated": [
            "def get_template(name):\n    if False:\n        i = 10\n    func = shellcraft\n    for attr in name.split('.'):\n        func = getattr(func, attr)\n    return func",
            "def get_template(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    func = shellcraft\n    for attr in name.split('.'):\n        func = getattr(func, attr)\n    return func",
            "def get_template(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    func = shellcraft\n    for attr in name.split('.'):\n        func = getattr(func, attr)\n    return func",
            "def get_template(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    func = shellcraft\n    for attr in name.split('.'):\n        func = getattr(func, attr)\n    return func",
            "def get_template(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    func = shellcraft\n    for attr in name.split('.'):\n        func = getattr(func, attr)\n    return func"
        ]
    },
    {
        "func_name": "is_not_a_syscall_template",
        "original": "def is_not_a_syscall_template(name):\n    template_src = shellcraft._get_source(name)\n    return '/syscalls' not in template_src",
        "mutated": [
            "def is_not_a_syscall_template(name):\n    if False:\n        i = 10\n    template_src = shellcraft._get_source(name)\n    return '/syscalls' not in template_src",
            "def is_not_a_syscall_template(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    template_src = shellcraft._get_source(name)\n    return '/syscalls' not in template_src",
            "def is_not_a_syscall_template(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    template_src = shellcraft._get_source(name)\n    return '/syscalls' not in template_src",
            "def is_not_a_syscall_template(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    template_src = shellcraft._get_source(name)\n    return '/syscalls' not in template_src",
            "def is_not_a_syscall_template(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    template_src = shellcraft._get_source(name)\n    return '/syscalls' not in template_src"
        ]
    },
    {
        "func_name": "main",
        "original": "def main(args):\n    if args.list:\n        templates = shellcraft.templates\n        if args.shellcode:\n            templates = filter(lambda a: args.shellcode in a, templates)\n        elif not args.syscalls:\n            templates = filter(is_not_a_syscall_template, templates)\n        print('\\n'.join(templates))\n        exit()\n    if not args.shellcode:\n        common.parser.print_usage()\n        exit()\n    try:\n        func = get_template(args.shellcode)\n    except AttributeError:\n        log.error('Unknown shellcraft template %r. Use --list to see available shellcodes.' % args.shellcode)\n    if args.show:\n        doc = []\n        in_doctest = False\n        block_indent = None\n        caption = None\n        lines = func.__doc__.splitlines()\n        i = 0\n        while i < len(lines):\n            line = lines[i]\n            if line.lstrip().startswith('>>>'):\n                in_doctest = True\n                block_indent = None\n                if caption:\n                    doc = doc[:caption - i]\n                    caption = None\n            elif line == '':\n                pass\n            elif in_doctest:\n                indent = len(line) - len(line.lstrip())\n                if block_indent is None:\n                    if not line.lstrip().startswith('...'):\n                        block_indent = indent\n                elif indent < block_indent:\n                    in_doctest = False\n                    block_indent = None\n                    continue\n            elif line.endswith(':'):\n                caption = i\n            else:\n                caption = None\n            if not in_doctest:\n                doc.append(line)\n            i += 1\n        print('\\n'.join(doc).rstrip())\n        exit()\n    defargs = len(six.get_function_defaults(func) or ())\n    reqargs = six.get_function_code(func).co_argcount - defargs\n    if len(args.args) < reqargs:\n        if defargs > 0:\n            log.critical('%s takes at least %d arguments' % (args.shellcode, reqargs))\n            sys.exit(1)\n        else:\n            log.critical('%s takes exactly %d arguments' % (args.shellcode, reqargs))\n            sys.exit(1)\n    for (i, val) in enumerate(args.args):\n        try:\n            args.args[i] = util.safeeval.expr(val)\n        except ValueError:\n            pass\n    list(map(common.context_arg, args.shellcode.split('.')))\n    code = func(*args.args)\n    if args.before:\n        code = shellcraft.trap() + code\n    if args.after:\n        code = code + shellcraft.trap()\n    if args.format in ['a', 'asm', 'assembly']:\n        if args.color:\n            from pygments import highlight\n            from pygments.formatters import TerminalFormatter\n            from pwnlib.lexer import PwntoolsLexer\n            code = highlight(code, PwntoolsLexer(), TerminalFormatter())\n        print(code)\n        exit()\n    if args.format == 'p':\n        print(cpp(code))\n        exit()\n    assembly = code\n    vma = args.address\n    if vma:\n        vma = pwnlib.util.safeeval.expr(vma)\n    if args.format in ['e', 'elf']:\n        args.format = 'default'\n        try:\n            os.fchmod(args.out.fileno(), 448)\n        except OSError:\n            pass\n        if not args.avoid:\n            code = read(make_elf_from_assembly(assembly, vma=vma, shared=args.shared))\n        else:\n            code = asm(assembly)\n            code = encode(code, args.avoid)\n            code = make_elf(code, vma=vma, shared=args.shared)\n    else:\n        code = encode(asm(assembly), args.avoid)\n    if args.format == 'default':\n        if args.out.isatty():\n            args.format = 'hex'\n        else:\n            args.format = 'raw'\n    arch = args.shellcode.split('.')[0]\n    if args.debug:\n        if not args.avoid:\n            proc = gdb.debug_assembly(assembly, arch=arch, vma=vma)\n        else:\n            proc = gdb.debug_shellcode(code, arch=arch, vma=vma)\n        proc.interactive()\n        sys.exit(0)\n    if args.run:\n        proc = run_shellcode(code, arch=arch)\n        proc.interactive()\n        sys.exit(0)\n    if args.format in ['s', 'str', 'string']:\n        code = _string(code)\n    elif args.format == 'c':\n        code = '{' + ', '.join(map(hex, bytearray(code))) + '}' + '\\n'\n    elif args.format in ['h', 'hex']:\n        code = pwnlib.util.fiddling.enhex(code) + '\\n'\n    elif args.format in ['i', 'hexii']:\n        code = hexii(code) + '\\n'\n    elif args.format in ['d', 'escaped']:\n        code = ''.join(('\\\\x%02x' % c for c in bytearray(code))) + '\\n'\n    if not sys.stdin.isatty():\n        args.out.write(getattr(sys.stdin, 'buffer', sys.stdin).read())\n    if not hasattr(code, 'decode'):\n        code = code.encode()\n    args.out.write(code)",
        "mutated": [
            "def main(args):\n    if False:\n        i = 10\n    if args.list:\n        templates = shellcraft.templates\n        if args.shellcode:\n            templates = filter(lambda a: args.shellcode in a, templates)\n        elif not args.syscalls:\n            templates = filter(is_not_a_syscall_template, templates)\n        print('\\n'.join(templates))\n        exit()\n    if not args.shellcode:\n        common.parser.print_usage()\n        exit()\n    try:\n        func = get_template(args.shellcode)\n    except AttributeError:\n        log.error('Unknown shellcraft template %r. Use --list to see available shellcodes.' % args.shellcode)\n    if args.show:\n        doc = []\n        in_doctest = False\n        block_indent = None\n        caption = None\n        lines = func.__doc__.splitlines()\n        i = 0\n        while i < len(lines):\n            line = lines[i]\n            if line.lstrip().startswith('>>>'):\n                in_doctest = True\n                block_indent = None\n                if caption:\n                    doc = doc[:caption - i]\n                    caption = None\n            elif line == '':\n                pass\n            elif in_doctest:\n                indent = len(line) - len(line.lstrip())\n                if block_indent is None:\n                    if not line.lstrip().startswith('...'):\n                        block_indent = indent\n                elif indent < block_indent:\n                    in_doctest = False\n                    block_indent = None\n                    continue\n            elif line.endswith(':'):\n                caption = i\n            else:\n                caption = None\n            if not in_doctest:\n                doc.append(line)\n            i += 1\n        print('\\n'.join(doc).rstrip())\n        exit()\n    defargs = len(six.get_function_defaults(func) or ())\n    reqargs = six.get_function_code(func).co_argcount - defargs\n    if len(args.args) < reqargs:\n        if defargs > 0:\n            log.critical('%s takes at least %d arguments' % (args.shellcode, reqargs))\n            sys.exit(1)\n        else:\n            log.critical('%s takes exactly %d arguments' % (args.shellcode, reqargs))\n            sys.exit(1)\n    for (i, val) in enumerate(args.args):\n        try:\n            args.args[i] = util.safeeval.expr(val)\n        except ValueError:\n            pass\n    list(map(common.context_arg, args.shellcode.split('.')))\n    code = func(*args.args)\n    if args.before:\n        code = shellcraft.trap() + code\n    if args.after:\n        code = code + shellcraft.trap()\n    if args.format in ['a', 'asm', 'assembly']:\n        if args.color:\n            from pygments import highlight\n            from pygments.formatters import TerminalFormatter\n            from pwnlib.lexer import PwntoolsLexer\n            code = highlight(code, PwntoolsLexer(), TerminalFormatter())\n        print(code)\n        exit()\n    if args.format == 'p':\n        print(cpp(code))\n        exit()\n    assembly = code\n    vma = args.address\n    if vma:\n        vma = pwnlib.util.safeeval.expr(vma)\n    if args.format in ['e', 'elf']:\n        args.format = 'default'\n        try:\n            os.fchmod(args.out.fileno(), 448)\n        except OSError:\n            pass\n        if not args.avoid:\n            code = read(make_elf_from_assembly(assembly, vma=vma, shared=args.shared))\n        else:\n            code = asm(assembly)\n            code = encode(code, args.avoid)\n            code = make_elf(code, vma=vma, shared=args.shared)\n    else:\n        code = encode(asm(assembly), args.avoid)\n    if args.format == 'default':\n        if args.out.isatty():\n            args.format = 'hex'\n        else:\n            args.format = 'raw'\n    arch = args.shellcode.split('.')[0]\n    if args.debug:\n        if not args.avoid:\n            proc = gdb.debug_assembly(assembly, arch=arch, vma=vma)\n        else:\n            proc = gdb.debug_shellcode(code, arch=arch, vma=vma)\n        proc.interactive()\n        sys.exit(0)\n    if args.run:\n        proc = run_shellcode(code, arch=arch)\n        proc.interactive()\n        sys.exit(0)\n    if args.format in ['s', 'str', 'string']:\n        code = _string(code)\n    elif args.format == 'c':\n        code = '{' + ', '.join(map(hex, bytearray(code))) + '}' + '\\n'\n    elif args.format in ['h', 'hex']:\n        code = pwnlib.util.fiddling.enhex(code) + '\\n'\n    elif args.format in ['i', 'hexii']:\n        code = hexii(code) + '\\n'\n    elif args.format in ['d', 'escaped']:\n        code = ''.join(('\\\\x%02x' % c for c in bytearray(code))) + '\\n'\n    if not sys.stdin.isatty():\n        args.out.write(getattr(sys.stdin, 'buffer', sys.stdin).read())\n    if not hasattr(code, 'decode'):\n        code = code.encode()\n    args.out.write(code)",
            "def main(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if args.list:\n        templates = shellcraft.templates\n        if args.shellcode:\n            templates = filter(lambda a: args.shellcode in a, templates)\n        elif not args.syscalls:\n            templates = filter(is_not_a_syscall_template, templates)\n        print('\\n'.join(templates))\n        exit()\n    if not args.shellcode:\n        common.parser.print_usage()\n        exit()\n    try:\n        func = get_template(args.shellcode)\n    except AttributeError:\n        log.error('Unknown shellcraft template %r. Use --list to see available shellcodes.' % args.shellcode)\n    if args.show:\n        doc = []\n        in_doctest = False\n        block_indent = None\n        caption = None\n        lines = func.__doc__.splitlines()\n        i = 0\n        while i < len(lines):\n            line = lines[i]\n            if line.lstrip().startswith('>>>'):\n                in_doctest = True\n                block_indent = None\n                if caption:\n                    doc = doc[:caption - i]\n                    caption = None\n            elif line == '':\n                pass\n            elif in_doctest:\n                indent = len(line) - len(line.lstrip())\n                if block_indent is None:\n                    if not line.lstrip().startswith('...'):\n                        block_indent = indent\n                elif indent < block_indent:\n                    in_doctest = False\n                    block_indent = None\n                    continue\n            elif line.endswith(':'):\n                caption = i\n            else:\n                caption = None\n            if not in_doctest:\n                doc.append(line)\n            i += 1\n        print('\\n'.join(doc).rstrip())\n        exit()\n    defargs = len(six.get_function_defaults(func) or ())\n    reqargs = six.get_function_code(func).co_argcount - defargs\n    if len(args.args) < reqargs:\n        if defargs > 0:\n            log.critical('%s takes at least %d arguments' % (args.shellcode, reqargs))\n            sys.exit(1)\n        else:\n            log.critical('%s takes exactly %d arguments' % (args.shellcode, reqargs))\n            sys.exit(1)\n    for (i, val) in enumerate(args.args):\n        try:\n            args.args[i] = util.safeeval.expr(val)\n        except ValueError:\n            pass\n    list(map(common.context_arg, args.shellcode.split('.')))\n    code = func(*args.args)\n    if args.before:\n        code = shellcraft.trap() + code\n    if args.after:\n        code = code + shellcraft.trap()\n    if args.format in ['a', 'asm', 'assembly']:\n        if args.color:\n            from pygments import highlight\n            from pygments.formatters import TerminalFormatter\n            from pwnlib.lexer import PwntoolsLexer\n            code = highlight(code, PwntoolsLexer(), TerminalFormatter())\n        print(code)\n        exit()\n    if args.format == 'p':\n        print(cpp(code))\n        exit()\n    assembly = code\n    vma = args.address\n    if vma:\n        vma = pwnlib.util.safeeval.expr(vma)\n    if args.format in ['e', 'elf']:\n        args.format = 'default'\n        try:\n            os.fchmod(args.out.fileno(), 448)\n        except OSError:\n            pass\n        if not args.avoid:\n            code = read(make_elf_from_assembly(assembly, vma=vma, shared=args.shared))\n        else:\n            code = asm(assembly)\n            code = encode(code, args.avoid)\n            code = make_elf(code, vma=vma, shared=args.shared)\n    else:\n        code = encode(asm(assembly), args.avoid)\n    if args.format == 'default':\n        if args.out.isatty():\n            args.format = 'hex'\n        else:\n            args.format = 'raw'\n    arch = args.shellcode.split('.')[0]\n    if args.debug:\n        if not args.avoid:\n            proc = gdb.debug_assembly(assembly, arch=arch, vma=vma)\n        else:\n            proc = gdb.debug_shellcode(code, arch=arch, vma=vma)\n        proc.interactive()\n        sys.exit(0)\n    if args.run:\n        proc = run_shellcode(code, arch=arch)\n        proc.interactive()\n        sys.exit(0)\n    if args.format in ['s', 'str', 'string']:\n        code = _string(code)\n    elif args.format == 'c':\n        code = '{' + ', '.join(map(hex, bytearray(code))) + '}' + '\\n'\n    elif args.format in ['h', 'hex']:\n        code = pwnlib.util.fiddling.enhex(code) + '\\n'\n    elif args.format in ['i', 'hexii']:\n        code = hexii(code) + '\\n'\n    elif args.format in ['d', 'escaped']:\n        code = ''.join(('\\\\x%02x' % c for c in bytearray(code))) + '\\n'\n    if not sys.stdin.isatty():\n        args.out.write(getattr(sys.stdin, 'buffer', sys.stdin).read())\n    if not hasattr(code, 'decode'):\n        code = code.encode()\n    args.out.write(code)",
            "def main(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if args.list:\n        templates = shellcraft.templates\n        if args.shellcode:\n            templates = filter(lambda a: args.shellcode in a, templates)\n        elif not args.syscalls:\n            templates = filter(is_not_a_syscall_template, templates)\n        print('\\n'.join(templates))\n        exit()\n    if not args.shellcode:\n        common.parser.print_usage()\n        exit()\n    try:\n        func = get_template(args.shellcode)\n    except AttributeError:\n        log.error('Unknown shellcraft template %r. Use --list to see available shellcodes.' % args.shellcode)\n    if args.show:\n        doc = []\n        in_doctest = False\n        block_indent = None\n        caption = None\n        lines = func.__doc__.splitlines()\n        i = 0\n        while i < len(lines):\n            line = lines[i]\n            if line.lstrip().startswith('>>>'):\n                in_doctest = True\n                block_indent = None\n                if caption:\n                    doc = doc[:caption - i]\n                    caption = None\n            elif line == '':\n                pass\n            elif in_doctest:\n                indent = len(line) - len(line.lstrip())\n                if block_indent is None:\n                    if not line.lstrip().startswith('...'):\n                        block_indent = indent\n                elif indent < block_indent:\n                    in_doctest = False\n                    block_indent = None\n                    continue\n            elif line.endswith(':'):\n                caption = i\n            else:\n                caption = None\n            if not in_doctest:\n                doc.append(line)\n            i += 1\n        print('\\n'.join(doc).rstrip())\n        exit()\n    defargs = len(six.get_function_defaults(func) or ())\n    reqargs = six.get_function_code(func).co_argcount - defargs\n    if len(args.args) < reqargs:\n        if defargs > 0:\n            log.critical('%s takes at least %d arguments' % (args.shellcode, reqargs))\n            sys.exit(1)\n        else:\n            log.critical('%s takes exactly %d arguments' % (args.shellcode, reqargs))\n            sys.exit(1)\n    for (i, val) in enumerate(args.args):\n        try:\n            args.args[i] = util.safeeval.expr(val)\n        except ValueError:\n            pass\n    list(map(common.context_arg, args.shellcode.split('.')))\n    code = func(*args.args)\n    if args.before:\n        code = shellcraft.trap() + code\n    if args.after:\n        code = code + shellcraft.trap()\n    if args.format in ['a', 'asm', 'assembly']:\n        if args.color:\n            from pygments import highlight\n            from pygments.formatters import TerminalFormatter\n            from pwnlib.lexer import PwntoolsLexer\n            code = highlight(code, PwntoolsLexer(), TerminalFormatter())\n        print(code)\n        exit()\n    if args.format == 'p':\n        print(cpp(code))\n        exit()\n    assembly = code\n    vma = args.address\n    if vma:\n        vma = pwnlib.util.safeeval.expr(vma)\n    if args.format in ['e', 'elf']:\n        args.format = 'default'\n        try:\n            os.fchmod(args.out.fileno(), 448)\n        except OSError:\n            pass\n        if not args.avoid:\n            code = read(make_elf_from_assembly(assembly, vma=vma, shared=args.shared))\n        else:\n            code = asm(assembly)\n            code = encode(code, args.avoid)\n            code = make_elf(code, vma=vma, shared=args.shared)\n    else:\n        code = encode(asm(assembly), args.avoid)\n    if args.format == 'default':\n        if args.out.isatty():\n            args.format = 'hex'\n        else:\n            args.format = 'raw'\n    arch = args.shellcode.split('.')[0]\n    if args.debug:\n        if not args.avoid:\n            proc = gdb.debug_assembly(assembly, arch=arch, vma=vma)\n        else:\n            proc = gdb.debug_shellcode(code, arch=arch, vma=vma)\n        proc.interactive()\n        sys.exit(0)\n    if args.run:\n        proc = run_shellcode(code, arch=arch)\n        proc.interactive()\n        sys.exit(0)\n    if args.format in ['s', 'str', 'string']:\n        code = _string(code)\n    elif args.format == 'c':\n        code = '{' + ', '.join(map(hex, bytearray(code))) + '}' + '\\n'\n    elif args.format in ['h', 'hex']:\n        code = pwnlib.util.fiddling.enhex(code) + '\\n'\n    elif args.format in ['i', 'hexii']:\n        code = hexii(code) + '\\n'\n    elif args.format in ['d', 'escaped']:\n        code = ''.join(('\\\\x%02x' % c for c in bytearray(code))) + '\\n'\n    if not sys.stdin.isatty():\n        args.out.write(getattr(sys.stdin, 'buffer', sys.stdin).read())\n    if not hasattr(code, 'decode'):\n        code = code.encode()\n    args.out.write(code)",
            "def main(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if args.list:\n        templates = shellcraft.templates\n        if args.shellcode:\n            templates = filter(lambda a: args.shellcode in a, templates)\n        elif not args.syscalls:\n            templates = filter(is_not_a_syscall_template, templates)\n        print('\\n'.join(templates))\n        exit()\n    if not args.shellcode:\n        common.parser.print_usage()\n        exit()\n    try:\n        func = get_template(args.shellcode)\n    except AttributeError:\n        log.error('Unknown shellcraft template %r. Use --list to see available shellcodes.' % args.shellcode)\n    if args.show:\n        doc = []\n        in_doctest = False\n        block_indent = None\n        caption = None\n        lines = func.__doc__.splitlines()\n        i = 0\n        while i < len(lines):\n            line = lines[i]\n            if line.lstrip().startswith('>>>'):\n                in_doctest = True\n                block_indent = None\n                if caption:\n                    doc = doc[:caption - i]\n                    caption = None\n            elif line == '':\n                pass\n            elif in_doctest:\n                indent = len(line) - len(line.lstrip())\n                if block_indent is None:\n                    if not line.lstrip().startswith('...'):\n                        block_indent = indent\n                elif indent < block_indent:\n                    in_doctest = False\n                    block_indent = None\n                    continue\n            elif line.endswith(':'):\n                caption = i\n            else:\n                caption = None\n            if not in_doctest:\n                doc.append(line)\n            i += 1\n        print('\\n'.join(doc).rstrip())\n        exit()\n    defargs = len(six.get_function_defaults(func) or ())\n    reqargs = six.get_function_code(func).co_argcount - defargs\n    if len(args.args) < reqargs:\n        if defargs > 0:\n            log.critical('%s takes at least %d arguments' % (args.shellcode, reqargs))\n            sys.exit(1)\n        else:\n            log.critical('%s takes exactly %d arguments' % (args.shellcode, reqargs))\n            sys.exit(1)\n    for (i, val) in enumerate(args.args):\n        try:\n            args.args[i] = util.safeeval.expr(val)\n        except ValueError:\n            pass\n    list(map(common.context_arg, args.shellcode.split('.')))\n    code = func(*args.args)\n    if args.before:\n        code = shellcraft.trap() + code\n    if args.after:\n        code = code + shellcraft.trap()\n    if args.format in ['a', 'asm', 'assembly']:\n        if args.color:\n            from pygments import highlight\n            from pygments.formatters import TerminalFormatter\n            from pwnlib.lexer import PwntoolsLexer\n            code = highlight(code, PwntoolsLexer(), TerminalFormatter())\n        print(code)\n        exit()\n    if args.format == 'p':\n        print(cpp(code))\n        exit()\n    assembly = code\n    vma = args.address\n    if vma:\n        vma = pwnlib.util.safeeval.expr(vma)\n    if args.format in ['e', 'elf']:\n        args.format = 'default'\n        try:\n            os.fchmod(args.out.fileno(), 448)\n        except OSError:\n            pass\n        if not args.avoid:\n            code = read(make_elf_from_assembly(assembly, vma=vma, shared=args.shared))\n        else:\n            code = asm(assembly)\n            code = encode(code, args.avoid)\n            code = make_elf(code, vma=vma, shared=args.shared)\n    else:\n        code = encode(asm(assembly), args.avoid)\n    if args.format == 'default':\n        if args.out.isatty():\n            args.format = 'hex'\n        else:\n            args.format = 'raw'\n    arch = args.shellcode.split('.')[0]\n    if args.debug:\n        if not args.avoid:\n            proc = gdb.debug_assembly(assembly, arch=arch, vma=vma)\n        else:\n            proc = gdb.debug_shellcode(code, arch=arch, vma=vma)\n        proc.interactive()\n        sys.exit(0)\n    if args.run:\n        proc = run_shellcode(code, arch=arch)\n        proc.interactive()\n        sys.exit(0)\n    if args.format in ['s', 'str', 'string']:\n        code = _string(code)\n    elif args.format == 'c':\n        code = '{' + ', '.join(map(hex, bytearray(code))) + '}' + '\\n'\n    elif args.format in ['h', 'hex']:\n        code = pwnlib.util.fiddling.enhex(code) + '\\n'\n    elif args.format in ['i', 'hexii']:\n        code = hexii(code) + '\\n'\n    elif args.format in ['d', 'escaped']:\n        code = ''.join(('\\\\x%02x' % c for c in bytearray(code))) + '\\n'\n    if not sys.stdin.isatty():\n        args.out.write(getattr(sys.stdin, 'buffer', sys.stdin).read())\n    if not hasattr(code, 'decode'):\n        code = code.encode()\n    args.out.write(code)",
            "def main(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if args.list:\n        templates = shellcraft.templates\n        if args.shellcode:\n            templates = filter(lambda a: args.shellcode in a, templates)\n        elif not args.syscalls:\n            templates = filter(is_not_a_syscall_template, templates)\n        print('\\n'.join(templates))\n        exit()\n    if not args.shellcode:\n        common.parser.print_usage()\n        exit()\n    try:\n        func = get_template(args.shellcode)\n    except AttributeError:\n        log.error('Unknown shellcraft template %r. Use --list to see available shellcodes.' % args.shellcode)\n    if args.show:\n        doc = []\n        in_doctest = False\n        block_indent = None\n        caption = None\n        lines = func.__doc__.splitlines()\n        i = 0\n        while i < len(lines):\n            line = lines[i]\n            if line.lstrip().startswith('>>>'):\n                in_doctest = True\n                block_indent = None\n                if caption:\n                    doc = doc[:caption - i]\n                    caption = None\n            elif line == '':\n                pass\n            elif in_doctest:\n                indent = len(line) - len(line.lstrip())\n                if block_indent is None:\n                    if not line.lstrip().startswith('...'):\n                        block_indent = indent\n                elif indent < block_indent:\n                    in_doctest = False\n                    block_indent = None\n                    continue\n            elif line.endswith(':'):\n                caption = i\n            else:\n                caption = None\n            if not in_doctest:\n                doc.append(line)\n            i += 1\n        print('\\n'.join(doc).rstrip())\n        exit()\n    defargs = len(six.get_function_defaults(func) or ())\n    reqargs = six.get_function_code(func).co_argcount - defargs\n    if len(args.args) < reqargs:\n        if defargs > 0:\n            log.critical('%s takes at least %d arguments' % (args.shellcode, reqargs))\n            sys.exit(1)\n        else:\n            log.critical('%s takes exactly %d arguments' % (args.shellcode, reqargs))\n            sys.exit(1)\n    for (i, val) in enumerate(args.args):\n        try:\n            args.args[i] = util.safeeval.expr(val)\n        except ValueError:\n            pass\n    list(map(common.context_arg, args.shellcode.split('.')))\n    code = func(*args.args)\n    if args.before:\n        code = shellcraft.trap() + code\n    if args.after:\n        code = code + shellcraft.trap()\n    if args.format in ['a', 'asm', 'assembly']:\n        if args.color:\n            from pygments import highlight\n            from pygments.formatters import TerminalFormatter\n            from pwnlib.lexer import PwntoolsLexer\n            code = highlight(code, PwntoolsLexer(), TerminalFormatter())\n        print(code)\n        exit()\n    if args.format == 'p':\n        print(cpp(code))\n        exit()\n    assembly = code\n    vma = args.address\n    if vma:\n        vma = pwnlib.util.safeeval.expr(vma)\n    if args.format in ['e', 'elf']:\n        args.format = 'default'\n        try:\n            os.fchmod(args.out.fileno(), 448)\n        except OSError:\n            pass\n        if not args.avoid:\n            code = read(make_elf_from_assembly(assembly, vma=vma, shared=args.shared))\n        else:\n            code = asm(assembly)\n            code = encode(code, args.avoid)\n            code = make_elf(code, vma=vma, shared=args.shared)\n    else:\n        code = encode(asm(assembly), args.avoid)\n    if args.format == 'default':\n        if args.out.isatty():\n            args.format = 'hex'\n        else:\n            args.format = 'raw'\n    arch = args.shellcode.split('.')[0]\n    if args.debug:\n        if not args.avoid:\n            proc = gdb.debug_assembly(assembly, arch=arch, vma=vma)\n        else:\n            proc = gdb.debug_shellcode(code, arch=arch, vma=vma)\n        proc.interactive()\n        sys.exit(0)\n    if args.run:\n        proc = run_shellcode(code, arch=arch)\n        proc.interactive()\n        sys.exit(0)\n    if args.format in ['s', 'str', 'string']:\n        code = _string(code)\n    elif args.format == 'c':\n        code = '{' + ', '.join(map(hex, bytearray(code))) + '}' + '\\n'\n    elif args.format in ['h', 'hex']:\n        code = pwnlib.util.fiddling.enhex(code) + '\\n'\n    elif args.format in ['i', 'hexii']:\n        code = hexii(code) + '\\n'\n    elif args.format in ['d', 'escaped']:\n        code = ''.join(('\\\\x%02x' % c for c in bytearray(code))) + '\\n'\n    if not sys.stdin.isatty():\n        args.out.write(getattr(sys.stdin, 'buffer', sys.stdin).read())\n    if not hasattr(code, 'decode'):\n        code = code.encode()\n    args.out.write(code)"
        ]
    }
]