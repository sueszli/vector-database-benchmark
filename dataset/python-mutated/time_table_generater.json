[
    {
        "func_name": "twap_table",
        "original": "def twap_table(api: TqApi, symbol: str, target_pos: int, duration: int, min_volume_each_step: int, max_volume_each_step: int, account: Optional[Union[TqAccount, TqKq, TqSim]]=None):\n    \"\"\"\n    \u8fd4\u56de\u57fa\u4e8e twap \u7b56\u7565\u7684\u8ba1\u5212\u4efb\u52a1\u65f6\u95f4\u8868\u3002\u4e0b\u5355\u9700\u8981\u914d\u5408 TargetPosScheduler \u4f7f\u7528\u3002\n\n    Args:\n        api (TqApi): TqApi\u5b9e\u4f8b\uff0c\u8be5task\u4f9d\u6258\u4e8e\u6307\u5b9aapi\u4e0b\u5355/\u64a4\u5355\n\n        symbol (str): \u62df\u4e0b\u5355\u7684\u5408\u7ea6 symbol, \u683c\u5f0f\u4e3a \u4ea4\u6613\u6240\u4ee3\u7801.\u5408\u7ea6\u4ee3\u7801,  \u4f8b\u5982 \"SHFE.cu1801\"\n\n        target_pos (int): \u76ee\u6807\u6301\u4ed3\u624b\u6570\n\n        duration (int): \u7b97\u6cd5\u6267\u884c\u7684\u65f6\u957f\uff0c\u4ee5\u79d2\u4e3a\u5355\u4f4d\uff0c\u65f6\u957f\u53ef\u4ee5\u8de8\u975e\u4ea4\u6613\u65f6\u95f4\u6bb5\uff0c\u4f46\u662f\u4e0d\u53ef\u4ee5\u8de8\u4ea4\u6613\u65e5\n        * \u8bbe\u7f6e\u4e3a 60*10, \u53ef\u4ee5\u662f 10:10\uff5e10:15 + 10:30~10:35\n\n        min_volume_each_step (int): \u8c03\u6574\u6301\u4ed3\u624b\u6570\u6700\u5c0f\u503c\uff0c\u6bcf\u6b65\u8c03\u6574\u7684\u6301\u4ed3\u624b\u6570\u9ed8\u8ba4\u5728\u6700\u5c0f\u548c\u6700\u5927\u503c\u4e2d\u4ea7\u751f\n\n        max_volume_each_step (int): \u8c03\u6574\u6301\u4ed3\u624b\u6570\u6700\u5927\u503c\uff0c\u6bcf\u6b65\u8c03\u6574\u7684\u6301\u4ed3\u624b\u6570\u9ed8\u8ba4\u5728\u6700\u5c0f\u548c\u6700\u5927\u503c\u4e2d\u4ea7\u751f\n\n        account (TqAccount/TqKq/TqSim): [\u53ef\u9009]\u6307\u5b9a\u53d1\u9001\u4e0b\u5355\u6307\u4ee4\u7684\u8d26\u6237\u5b9e\u4f8b, \u591a\u8d26\u6237\u6a21\u5f0f\u4e0b\uff0c\u8be5\u53c2\u6570\u5fc5\u987b\u6307\u5b9a\n\n    Returns:\n        pandas.DataFrame: \u672c\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a pandas.DataFrame \u5b9e\u4f8b. \u8868\u793a\u4e00\u4efd\u8ba1\u5212\u4efb\u52a1\u65f6\u95f4\u8868\u3002\u6bcf\u4e00\u884c\u8868\u793a\u4e00\u9879\u76ee\u6807\u6301\u4ed3\u4efb\u52a1\uff0c\u5305\u542b\u4ee5\u4e0b\u5217:\n\n            + interval: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u6301\u7eed\u65f6\u95f4\u957f\u5ea6\uff0c\u5355\u4f4d\u4e3a\u79d2\n            + target_pos: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u76ee\u6807\u6301\u4ed3\n            + price: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u4e0b\u5355\u4ef7\u683c\u6a21\u5f0f\uff0c\u652f\u6301 PASSIVE\uff08\u6392\u961f\u4ef7\uff09\uff0cACTIVE\uff08\u5bf9\u4ef7\uff09\uff0cNone\uff08\u4e0d\u4e0b\u5355\uff0c\u8868\u793a\u6682\u505c\u4e00\u6bb5\u65f6\u95f4\uff09\n\n    Example1::\n\n        from tqsdk import TqApi, TargetPosScheduler\n        from tqsdk.algorithm import twap_table\n\n        api = TqApi(auth=\"\u5feb\u671f\u8d26\u6237,\u7528\u6237\u5bc6\u7801\")\n        quote = api.get_quote(\"CZCE.MA109\")\n\n        # \u8bbe\u7f6etwap\u4efb\u52a1\u53c2\u6570\n        time_table = twap_table(api, \"CZCE.MA109\", -100, 600, 1, 5)  # \u76ee\u6807\u6301\u4ed3 -100 \u624b\uff0c600s \u5185\u5b8c\u6210\n        print(time_table.to_string())\n\n        target_pos_sch = TargetPosScheduler(api, \"CZCE.MA109\", time_table)\n        # \u542f\u52a8\u5faa\u73af\n        while not target_pos_sch.is_finished():\n            api.wait_update()\n        api.close()\n\n\n    Example2::\n\n        from tqsdk import TqApi, TargetPosScheduler\n        from tqsdk.algorithm import twap_table\n\n        api = TqApi(auth=\"\u5feb\u671f\u8d26\u6237,\u7528\u6237\u5bc6\u7801\")\n        quote = api.get_quote(\"CZCE.MA109\")\n\n        # \u8bbe\u7f6e twap \u4efb\u52a1\u53c2\u6570\uff0c\n        time_table = twap_table(api, \"CZCE.MA109\", -100, 600, 1, 5)  # \u76ee\u6807\u6301\u4ed3 -100 \u624b\uff0c600s \u5185\u5b8c\u6210\n\n        # \u5b9a\u5236\u5316\u8c03\u6574 time_table\uff0c\u4f8b\u5982\u5e0c\u671b\u7b2c\u4e00\u9879\u4efb\u52a1\u5ef6\u8fdf 10s \u518d\u5f00\u59cb\u4e0b\u5355\n        # \u53ef\u4ee5\u5728 time_table \u7684\u5934\u90e8\u52a0\u4e00\u884c\n        time_table = pandas.concat([\n            DataFrame([[10, 10, None]], columns=['interval', 'target_pos', 'price']),\n            time_table\n        ], ignore_index=True)\n\n        target_pos_sch = TargetPosScheduler(api, \"CZCE.MA109\", time_table)\n        while not target_pos_sch.is_finished():\n            api.wait_update()\n\n        # \u83b7\u53d6 target_pos_sch \u5b9e\u4f8b\u6240\u6709\u7684\u6210\u4ea4\u5217\u8868\n        print(target_pos_sch.trades_df)\n\n        # \u5229\u7528\u6210\u4ea4\u5217\u8868\uff0c\u60a8\u53ef\u4ee5\u8ba1\u7b97\u51fa\u7b56\u7565\u7684\u5404\u79cd\u8868\u73b0\u6307\u6807\uff0c\u4f8b\u5982\uff1a\n        average_trade_price = sum(scheduler.trades_df['price'] * scheduler.trades_df['volume']) / sum(scheduler.trades_df['volume'])\n        print(\"\u6210\u4ea4\u5747\u4ef7:\", average_trade_price)\n        api.close()\n\n    \"\"\"\n    account = api._account._check_valid(account)\n    if account is None:\n        raise Exception(f'\u591a\u8d26\u6237\u6a21\u5f0f\u4e0b, \u9700\u8981\u6307\u5b9a\u8d26\u6237\u5b9e\u4f8b account')\n    min_volume_each_step = int(min_volume_each_step)\n    max_volume_each_step = int(max_volume_each_step)\n    if max_volume_each_step <= 0 or min_volume_each_step <= 0:\n        raise Exception('\u8bf7\u8c03\u6574\u53c2\u6570, min_volume_each_step\u3001max_volume_each_step \u5fc5\u987b\u662f\u5927\u4e8e 0 \u7684\u6574\u6570\u3002')\n    if min_volume_each_step > max_volume_each_step:\n        raise Exception('\u8bf7\u8c03\u6574\u53c2\u6570, min_volume_each_step \u5fc5\u987b\u5c0f\u4e8e max_volume_each_step\u3002')\n    pos = api.get_position(symbol, account)\n    target_pos = int(target_pos)\n    delta_pos = target_pos - pos.pos\n    volume = abs(delta_pos)\n    if volume < max_volume_each_step:\n        (interval_list, volume_list) = ([duration], [volume])\n    else:\n        volume_list = _gen_random_list(sum_val=volume, min_val=min_volume_each_step, max_val=max_volume_each_step)\n        interval = int(duration / len(volume_list))\n        if interval < 3:\n            raise Exception('\u8bf7\u8c03\u6574\u53c2\u6570, \u6bcf\u6b21\u4e0b\u5355\u65f6\u95f4\u95f4\u9694\u4e0d\u80fd\u5c0f\u4e8e3s, \u5c06\u5355\u6b21\u4e0b\u5355\u624b\u6570\u9608\u503c\u8c03\u5927\u6216\u8005\u589e\u957f\u4e0b\u5355\u65f6\u95f4\u3002')\n        min_interval = int(max(3, interval - 2))\n        max_interval = int(interval * 2 - max(3, interval - 2)) + 1\n        interval_list = _gen_random_list(sum_val=duration, min_val=min_interval, max_val=max_interval, length=len(volume_list))\n    time_table = DataFrame(columns=['interval', 'volume', 'price'])\n    for (index, volume) in enumerate(volume_list):\n        assert interval_list[index] >= 3\n        active_interval = 2\n        append_time_table = pd.DataFrame([{'interval': interval_list[index] - active_interval, 'volume': volume, 'price': 'PASSIVE'}, {'interval': active_interval, 'volume': 0, 'price': 'ACTIVE'}])\n        time_table = pd.concat([time_table, append_time_table], ignore_index=True)\n    time_table['volume'] = time_table['volume'].mul(-1 if delta_pos < 0 else 1)\n    time_table['target_pos'] = time_table['volume'].cumsum()\n    time_table['target_pos'] = time_table['target_pos'].add(pos.pos)\n    time_table.drop(columns=['volume'], inplace=True)\n    time_table = time_table.astype({'target_pos': 'int64', 'interval': 'float64'})\n    return time_table",
        "mutated": [
            "def twap_table(api: TqApi, symbol: str, target_pos: int, duration: int, min_volume_each_step: int, max_volume_each_step: int, account: Optional[Union[TqAccount, TqKq, TqSim]]=None):\n    if False:\n        i = 10\n    '\\n    \u8fd4\u56de\u57fa\u4e8e twap \u7b56\u7565\u7684\u8ba1\u5212\u4efb\u52a1\u65f6\u95f4\u8868\u3002\u4e0b\u5355\u9700\u8981\u914d\u5408 TargetPosScheduler \u4f7f\u7528\u3002\\n\\n    Args:\\n        api (TqApi): TqApi\u5b9e\u4f8b\uff0c\u8be5task\u4f9d\u6258\u4e8e\u6307\u5b9aapi\u4e0b\u5355/\u64a4\u5355\\n\\n        symbol (str): \u62df\u4e0b\u5355\u7684\u5408\u7ea6 symbol, \u683c\u5f0f\u4e3a \u4ea4\u6613\u6240\u4ee3\u7801.\u5408\u7ea6\u4ee3\u7801,  \u4f8b\u5982 \"SHFE.cu1801\"\\n\\n        target_pos (int): \u76ee\u6807\u6301\u4ed3\u624b\u6570\\n\\n        duration (int): \u7b97\u6cd5\u6267\u884c\u7684\u65f6\u957f\uff0c\u4ee5\u79d2\u4e3a\u5355\u4f4d\uff0c\u65f6\u957f\u53ef\u4ee5\u8de8\u975e\u4ea4\u6613\u65f6\u95f4\u6bb5\uff0c\u4f46\u662f\u4e0d\u53ef\u4ee5\u8de8\u4ea4\u6613\u65e5\\n        * \u8bbe\u7f6e\u4e3a 60*10, \u53ef\u4ee5\u662f 10:10\uff5e10:15 + 10:30~10:35\\n\\n        min_volume_each_step (int): \u8c03\u6574\u6301\u4ed3\u624b\u6570\u6700\u5c0f\u503c\uff0c\u6bcf\u6b65\u8c03\u6574\u7684\u6301\u4ed3\u624b\u6570\u9ed8\u8ba4\u5728\u6700\u5c0f\u548c\u6700\u5927\u503c\u4e2d\u4ea7\u751f\\n\\n        max_volume_each_step (int): \u8c03\u6574\u6301\u4ed3\u624b\u6570\u6700\u5927\u503c\uff0c\u6bcf\u6b65\u8c03\u6574\u7684\u6301\u4ed3\u624b\u6570\u9ed8\u8ba4\u5728\u6700\u5c0f\u548c\u6700\u5927\u503c\u4e2d\u4ea7\u751f\\n\\n        account (TqAccount/TqKq/TqSim): [\u53ef\u9009]\u6307\u5b9a\u53d1\u9001\u4e0b\u5355\u6307\u4ee4\u7684\u8d26\u6237\u5b9e\u4f8b, \u591a\u8d26\u6237\u6a21\u5f0f\u4e0b\uff0c\u8be5\u53c2\u6570\u5fc5\u987b\u6307\u5b9a\\n\\n    Returns:\\n        pandas.DataFrame: \u672c\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a pandas.DataFrame \u5b9e\u4f8b. \u8868\u793a\u4e00\u4efd\u8ba1\u5212\u4efb\u52a1\u65f6\u95f4\u8868\u3002\u6bcf\u4e00\u884c\u8868\u793a\u4e00\u9879\u76ee\u6807\u6301\u4ed3\u4efb\u52a1\uff0c\u5305\u542b\u4ee5\u4e0b\u5217:\\n\\n            + interval: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u6301\u7eed\u65f6\u95f4\u957f\u5ea6\uff0c\u5355\u4f4d\u4e3a\u79d2\\n            + target_pos: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u76ee\u6807\u6301\u4ed3\\n            + price: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u4e0b\u5355\u4ef7\u683c\u6a21\u5f0f\uff0c\u652f\u6301 PASSIVE\uff08\u6392\u961f\u4ef7\uff09\uff0cACTIVE\uff08\u5bf9\u4ef7\uff09\uff0cNone\uff08\u4e0d\u4e0b\u5355\uff0c\u8868\u793a\u6682\u505c\u4e00\u6bb5\u65f6\u95f4\uff09\\n\\n    Example1::\\n\\n        from tqsdk import TqApi, TargetPosScheduler\\n        from tqsdk.algorithm import twap_table\\n\\n        api = TqApi(auth=\"\u5feb\u671f\u8d26\u6237,\u7528\u6237\u5bc6\u7801\")\\n        quote = api.get_quote(\"CZCE.MA109\")\\n\\n        # \u8bbe\u7f6etwap\u4efb\u52a1\u53c2\u6570\\n        time_table = twap_table(api, \"CZCE.MA109\", -100, 600, 1, 5)  # \u76ee\u6807\u6301\u4ed3 -100 \u624b\uff0c600s \u5185\u5b8c\u6210\\n        print(time_table.to_string())\\n\\n        target_pos_sch = TargetPosScheduler(api, \"CZCE.MA109\", time_table)\\n        # \u542f\u52a8\u5faa\u73af\\n        while not target_pos_sch.is_finished():\\n            api.wait_update()\\n        api.close()\\n\\n\\n    Example2::\\n\\n        from tqsdk import TqApi, TargetPosScheduler\\n        from tqsdk.algorithm import twap_table\\n\\n        api = TqApi(auth=\"\u5feb\u671f\u8d26\u6237,\u7528\u6237\u5bc6\u7801\")\\n        quote = api.get_quote(\"CZCE.MA109\")\\n\\n        # \u8bbe\u7f6e twap \u4efb\u52a1\u53c2\u6570\uff0c\\n        time_table = twap_table(api, \"CZCE.MA109\", -100, 600, 1, 5)  # \u76ee\u6807\u6301\u4ed3 -100 \u624b\uff0c600s \u5185\u5b8c\u6210\\n\\n        # \u5b9a\u5236\u5316\u8c03\u6574 time_table\uff0c\u4f8b\u5982\u5e0c\u671b\u7b2c\u4e00\u9879\u4efb\u52a1\u5ef6\u8fdf 10s \u518d\u5f00\u59cb\u4e0b\u5355\\n        # \u53ef\u4ee5\u5728 time_table \u7684\u5934\u90e8\u52a0\u4e00\u884c\\n        time_table = pandas.concat([\\n            DataFrame([[10, 10, None]], columns=[\\'interval\\', \\'target_pos\\', \\'price\\']),\\n            time_table\\n        ], ignore_index=True)\\n\\n        target_pos_sch = TargetPosScheduler(api, \"CZCE.MA109\", time_table)\\n        while not target_pos_sch.is_finished():\\n            api.wait_update()\\n\\n        # \u83b7\u53d6 target_pos_sch \u5b9e\u4f8b\u6240\u6709\u7684\u6210\u4ea4\u5217\u8868\\n        print(target_pos_sch.trades_df)\\n\\n        # \u5229\u7528\u6210\u4ea4\u5217\u8868\uff0c\u60a8\u53ef\u4ee5\u8ba1\u7b97\u51fa\u7b56\u7565\u7684\u5404\u79cd\u8868\u73b0\u6307\u6807\uff0c\u4f8b\u5982\uff1a\\n        average_trade_price = sum(scheduler.trades_df[\\'price\\'] * scheduler.trades_df[\\'volume\\']) / sum(scheduler.trades_df[\\'volume\\'])\\n        print(\"\u6210\u4ea4\u5747\u4ef7:\", average_trade_price)\\n        api.close()\\n\\n    '\n    account = api._account._check_valid(account)\n    if account is None:\n        raise Exception(f'\u591a\u8d26\u6237\u6a21\u5f0f\u4e0b, \u9700\u8981\u6307\u5b9a\u8d26\u6237\u5b9e\u4f8b account')\n    min_volume_each_step = int(min_volume_each_step)\n    max_volume_each_step = int(max_volume_each_step)\n    if max_volume_each_step <= 0 or min_volume_each_step <= 0:\n        raise Exception('\u8bf7\u8c03\u6574\u53c2\u6570, min_volume_each_step\u3001max_volume_each_step \u5fc5\u987b\u662f\u5927\u4e8e 0 \u7684\u6574\u6570\u3002')\n    if min_volume_each_step > max_volume_each_step:\n        raise Exception('\u8bf7\u8c03\u6574\u53c2\u6570, min_volume_each_step \u5fc5\u987b\u5c0f\u4e8e max_volume_each_step\u3002')\n    pos = api.get_position(symbol, account)\n    target_pos = int(target_pos)\n    delta_pos = target_pos - pos.pos\n    volume = abs(delta_pos)\n    if volume < max_volume_each_step:\n        (interval_list, volume_list) = ([duration], [volume])\n    else:\n        volume_list = _gen_random_list(sum_val=volume, min_val=min_volume_each_step, max_val=max_volume_each_step)\n        interval = int(duration / len(volume_list))\n        if interval < 3:\n            raise Exception('\u8bf7\u8c03\u6574\u53c2\u6570, \u6bcf\u6b21\u4e0b\u5355\u65f6\u95f4\u95f4\u9694\u4e0d\u80fd\u5c0f\u4e8e3s, \u5c06\u5355\u6b21\u4e0b\u5355\u624b\u6570\u9608\u503c\u8c03\u5927\u6216\u8005\u589e\u957f\u4e0b\u5355\u65f6\u95f4\u3002')\n        min_interval = int(max(3, interval - 2))\n        max_interval = int(interval * 2 - max(3, interval - 2)) + 1\n        interval_list = _gen_random_list(sum_val=duration, min_val=min_interval, max_val=max_interval, length=len(volume_list))\n    time_table = DataFrame(columns=['interval', 'volume', 'price'])\n    for (index, volume) in enumerate(volume_list):\n        assert interval_list[index] >= 3\n        active_interval = 2\n        append_time_table = pd.DataFrame([{'interval': interval_list[index] - active_interval, 'volume': volume, 'price': 'PASSIVE'}, {'interval': active_interval, 'volume': 0, 'price': 'ACTIVE'}])\n        time_table = pd.concat([time_table, append_time_table], ignore_index=True)\n    time_table['volume'] = time_table['volume'].mul(-1 if delta_pos < 0 else 1)\n    time_table['target_pos'] = time_table['volume'].cumsum()\n    time_table['target_pos'] = time_table['target_pos'].add(pos.pos)\n    time_table.drop(columns=['volume'], inplace=True)\n    time_table = time_table.astype({'target_pos': 'int64', 'interval': 'float64'})\n    return time_table",
            "def twap_table(api: TqApi, symbol: str, target_pos: int, duration: int, min_volume_each_step: int, max_volume_each_step: int, account: Optional[Union[TqAccount, TqKq, TqSim]]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    \u8fd4\u56de\u57fa\u4e8e twap \u7b56\u7565\u7684\u8ba1\u5212\u4efb\u52a1\u65f6\u95f4\u8868\u3002\u4e0b\u5355\u9700\u8981\u914d\u5408 TargetPosScheduler \u4f7f\u7528\u3002\\n\\n    Args:\\n        api (TqApi): TqApi\u5b9e\u4f8b\uff0c\u8be5task\u4f9d\u6258\u4e8e\u6307\u5b9aapi\u4e0b\u5355/\u64a4\u5355\\n\\n        symbol (str): \u62df\u4e0b\u5355\u7684\u5408\u7ea6 symbol, \u683c\u5f0f\u4e3a \u4ea4\u6613\u6240\u4ee3\u7801.\u5408\u7ea6\u4ee3\u7801,  \u4f8b\u5982 \"SHFE.cu1801\"\\n\\n        target_pos (int): \u76ee\u6807\u6301\u4ed3\u624b\u6570\\n\\n        duration (int): \u7b97\u6cd5\u6267\u884c\u7684\u65f6\u957f\uff0c\u4ee5\u79d2\u4e3a\u5355\u4f4d\uff0c\u65f6\u957f\u53ef\u4ee5\u8de8\u975e\u4ea4\u6613\u65f6\u95f4\u6bb5\uff0c\u4f46\u662f\u4e0d\u53ef\u4ee5\u8de8\u4ea4\u6613\u65e5\\n        * \u8bbe\u7f6e\u4e3a 60*10, \u53ef\u4ee5\u662f 10:10\uff5e10:15 + 10:30~10:35\\n\\n        min_volume_each_step (int): \u8c03\u6574\u6301\u4ed3\u624b\u6570\u6700\u5c0f\u503c\uff0c\u6bcf\u6b65\u8c03\u6574\u7684\u6301\u4ed3\u624b\u6570\u9ed8\u8ba4\u5728\u6700\u5c0f\u548c\u6700\u5927\u503c\u4e2d\u4ea7\u751f\\n\\n        max_volume_each_step (int): \u8c03\u6574\u6301\u4ed3\u624b\u6570\u6700\u5927\u503c\uff0c\u6bcf\u6b65\u8c03\u6574\u7684\u6301\u4ed3\u624b\u6570\u9ed8\u8ba4\u5728\u6700\u5c0f\u548c\u6700\u5927\u503c\u4e2d\u4ea7\u751f\\n\\n        account (TqAccount/TqKq/TqSim): [\u53ef\u9009]\u6307\u5b9a\u53d1\u9001\u4e0b\u5355\u6307\u4ee4\u7684\u8d26\u6237\u5b9e\u4f8b, \u591a\u8d26\u6237\u6a21\u5f0f\u4e0b\uff0c\u8be5\u53c2\u6570\u5fc5\u987b\u6307\u5b9a\\n\\n    Returns:\\n        pandas.DataFrame: \u672c\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a pandas.DataFrame \u5b9e\u4f8b. \u8868\u793a\u4e00\u4efd\u8ba1\u5212\u4efb\u52a1\u65f6\u95f4\u8868\u3002\u6bcf\u4e00\u884c\u8868\u793a\u4e00\u9879\u76ee\u6807\u6301\u4ed3\u4efb\u52a1\uff0c\u5305\u542b\u4ee5\u4e0b\u5217:\\n\\n            + interval: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u6301\u7eed\u65f6\u95f4\u957f\u5ea6\uff0c\u5355\u4f4d\u4e3a\u79d2\\n            + target_pos: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u76ee\u6807\u6301\u4ed3\\n            + price: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u4e0b\u5355\u4ef7\u683c\u6a21\u5f0f\uff0c\u652f\u6301 PASSIVE\uff08\u6392\u961f\u4ef7\uff09\uff0cACTIVE\uff08\u5bf9\u4ef7\uff09\uff0cNone\uff08\u4e0d\u4e0b\u5355\uff0c\u8868\u793a\u6682\u505c\u4e00\u6bb5\u65f6\u95f4\uff09\\n\\n    Example1::\\n\\n        from tqsdk import TqApi, TargetPosScheduler\\n        from tqsdk.algorithm import twap_table\\n\\n        api = TqApi(auth=\"\u5feb\u671f\u8d26\u6237,\u7528\u6237\u5bc6\u7801\")\\n        quote = api.get_quote(\"CZCE.MA109\")\\n\\n        # \u8bbe\u7f6etwap\u4efb\u52a1\u53c2\u6570\\n        time_table = twap_table(api, \"CZCE.MA109\", -100, 600, 1, 5)  # \u76ee\u6807\u6301\u4ed3 -100 \u624b\uff0c600s \u5185\u5b8c\u6210\\n        print(time_table.to_string())\\n\\n        target_pos_sch = TargetPosScheduler(api, \"CZCE.MA109\", time_table)\\n        # \u542f\u52a8\u5faa\u73af\\n        while not target_pos_sch.is_finished():\\n            api.wait_update()\\n        api.close()\\n\\n\\n    Example2::\\n\\n        from tqsdk import TqApi, TargetPosScheduler\\n        from tqsdk.algorithm import twap_table\\n\\n        api = TqApi(auth=\"\u5feb\u671f\u8d26\u6237,\u7528\u6237\u5bc6\u7801\")\\n        quote = api.get_quote(\"CZCE.MA109\")\\n\\n        # \u8bbe\u7f6e twap \u4efb\u52a1\u53c2\u6570\uff0c\\n        time_table = twap_table(api, \"CZCE.MA109\", -100, 600, 1, 5)  # \u76ee\u6807\u6301\u4ed3 -100 \u624b\uff0c600s \u5185\u5b8c\u6210\\n\\n        # \u5b9a\u5236\u5316\u8c03\u6574 time_table\uff0c\u4f8b\u5982\u5e0c\u671b\u7b2c\u4e00\u9879\u4efb\u52a1\u5ef6\u8fdf 10s \u518d\u5f00\u59cb\u4e0b\u5355\\n        # \u53ef\u4ee5\u5728 time_table \u7684\u5934\u90e8\u52a0\u4e00\u884c\\n        time_table = pandas.concat([\\n            DataFrame([[10, 10, None]], columns=[\\'interval\\', \\'target_pos\\', \\'price\\']),\\n            time_table\\n        ], ignore_index=True)\\n\\n        target_pos_sch = TargetPosScheduler(api, \"CZCE.MA109\", time_table)\\n        while not target_pos_sch.is_finished():\\n            api.wait_update()\\n\\n        # \u83b7\u53d6 target_pos_sch \u5b9e\u4f8b\u6240\u6709\u7684\u6210\u4ea4\u5217\u8868\\n        print(target_pos_sch.trades_df)\\n\\n        # \u5229\u7528\u6210\u4ea4\u5217\u8868\uff0c\u60a8\u53ef\u4ee5\u8ba1\u7b97\u51fa\u7b56\u7565\u7684\u5404\u79cd\u8868\u73b0\u6307\u6807\uff0c\u4f8b\u5982\uff1a\\n        average_trade_price = sum(scheduler.trades_df[\\'price\\'] * scheduler.trades_df[\\'volume\\']) / sum(scheduler.trades_df[\\'volume\\'])\\n        print(\"\u6210\u4ea4\u5747\u4ef7:\", average_trade_price)\\n        api.close()\\n\\n    '\n    account = api._account._check_valid(account)\n    if account is None:\n        raise Exception(f'\u591a\u8d26\u6237\u6a21\u5f0f\u4e0b, \u9700\u8981\u6307\u5b9a\u8d26\u6237\u5b9e\u4f8b account')\n    min_volume_each_step = int(min_volume_each_step)\n    max_volume_each_step = int(max_volume_each_step)\n    if max_volume_each_step <= 0 or min_volume_each_step <= 0:\n        raise Exception('\u8bf7\u8c03\u6574\u53c2\u6570, min_volume_each_step\u3001max_volume_each_step \u5fc5\u987b\u662f\u5927\u4e8e 0 \u7684\u6574\u6570\u3002')\n    if min_volume_each_step > max_volume_each_step:\n        raise Exception('\u8bf7\u8c03\u6574\u53c2\u6570, min_volume_each_step \u5fc5\u987b\u5c0f\u4e8e max_volume_each_step\u3002')\n    pos = api.get_position(symbol, account)\n    target_pos = int(target_pos)\n    delta_pos = target_pos - pos.pos\n    volume = abs(delta_pos)\n    if volume < max_volume_each_step:\n        (interval_list, volume_list) = ([duration], [volume])\n    else:\n        volume_list = _gen_random_list(sum_val=volume, min_val=min_volume_each_step, max_val=max_volume_each_step)\n        interval = int(duration / len(volume_list))\n        if interval < 3:\n            raise Exception('\u8bf7\u8c03\u6574\u53c2\u6570, \u6bcf\u6b21\u4e0b\u5355\u65f6\u95f4\u95f4\u9694\u4e0d\u80fd\u5c0f\u4e8e3s, \u5c06\u5355\u6b21\u4e0b\u5355\u624b\u6570\u9608\u503c\u8c03\u5927\u6216\u8005\u589e\u957f\u4e0b\u5355\u65f6\u95f4\u3002')\n        min_interval = int(max(3, interval - 2))\n        max_interval = int(interval * 2 - max(3, interval - 2)) + 1\n        interval_list = _gen_random_list(sum_val=duration, min_val=min_interval, max_val=max_interval, length=len(volume_list))\n    time_table = DataFrame(columns=['interval', 'volume', 'price'])\n    for (index, volume) in enumerate(volume_list):\n        assert interval_list[index] >= 3\n        active_interval = 2\n        append_time_table = pd.DataFrame([{'interval': interval_list[index] - active_interval, 'volume': volume, 'price': 'PASSIVE'}, {'interval': active_interval, 'volume': 0, 'price': 'ACTIVE'}])\n        time_table = pd.concat([time_table, append_time_table], ignore_index=True)\n    time_table['volume'] = time_table['volume'].mul(-1 if delta_pos < 0 else 1)\n    time_table['target_pos'] = time_table['volume'].cumsum()\n    time_table['target_pos'] = time_table['target_pos'].add(pos.pos)\n    time_table.drop(columns=['volume'], inplace=True)\n    time_table = time_table.astype({'target_pos': 'int64', 'interval': 'float64'})\n    return time_table",
            "def twap_table(api: TqApi, symbol: str, target_pos: int, duration: int, min_volume_each_step: int, max_volume_each_step: int, account: Optional[Union[TqAccount, TqKq, TqSim]]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    \u8fd4\u56de\u57fa\u4e8e twap \u7b56\u7565\u7684\u8ba1\u5212\u4efb\u52a1\u65f6\u95f4\u8868\u3002\u4e0b\u5355\u9700\u8981\u914d\u5408 TargetPosScheduler \u4f7f\u7528\u3002\\n\\n    Args:\\n        api (TqApi): TqApi\u5b9e\u4f8b\uff0c\u8be5task\u4f9d\u6258\u4e8e\u6307\u5b9aapi\u4e0b\u5355/\u64a4\u5355\\n\\n        symbol (str): \u62df\u4e0b\u5355\u7684\u5408\u7ea6 symbol, \u683c\u5f0f\u4e3a \u4ea4\u6613\u6240\u4ee3\u7801.\u5408\u7ea6\u4ee3\u7801,  \u4f8b\u5982 \"SHFE.cu1801\"\\n\\n        target_pos (int): \u76ee\u6807\u6301\u4ed3\u624b\u6570\\n\\n        duration (int): \u7b97\u6cd5\u6267\u884c\u7684\u65f6\u957f\uff0c\u4ee5\u79d2\u4e3a\u5355\u4f4d\uff0c\u65f6\u957f\u53ef\u4ee5\u8de8\u975e\u4ea4\u6613\u65f6\u95f4\u6bb5\uff0c\u4f46\u662f\u4e0d\u53ef\u4ee5\u8de8\u4ea4\u6613\u65e5\\n        * \u8bbe\u7f6e\u4e3a 60*10, \u53ef\u4ee5\u662f 10:10\uff5e10:15 + 10:30~10:35\\n\\n        min_volume_each_step (int): \u8c03\u6574\u6301\u4ed3\u624b\u6570\u6700\u5c0f\u503c\uff0c\u6bcf\u6b65\u8c03\u6574\u7684\u6301\u4ed3\u624b\u6570\u9ed8\u8ba4\u5728\u6700\u5c0f\u548c\u6700\u5927\u503c\u4e2d\u4ea7\u751f\\n\\n        max_volume_each_step (int): \u8c03\u6574\u6301\u4ed3\u624b\u6570\u6700\u5927\u503c\uff0c\u6bcf\u6b65\u8c03\u6574\u7684\u6301\u4ed3\u624b\u6570\u9ed8\u8ba4\u5728\u6700\u5c0f\u548c\u6700\u5927\u503c\u4e2d\u4ea7\u751f\\n\\n        account (TqAccount/TqKq/TqSim): [\u53ef\u9009]\u6307\u5b9a\u53d1\u9001\u4e0b\u5355\u6307\u4ee4\u7684\u8d26\u6237\u5b9e\u4f8b, \u591a\u8d26\u6237\u6a21\u5f0f\u4e0b\uff0c\u8be5\u53c2\u6570\u5fc5\u987b\u6307\u5b9a\\n\\n    Returns:\\n        pandas.DataFrame: \u672c\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a pandas.DataFrame \u5b9e\u4f8b. \u8868\u793a\u4e00\u4efd\u8ba1\u5212\u4efb\u52a1\u65f6\u95f4\u8868\u3002\u6bcf\u4e00\u884c\u8868\u793a\u4e00\u9879\u76ee\u6807\u6301\u4ed3\u4efb\u52a1\uff0c\u5305\u542b\u4ee5\u4e0b\u5217:\\n\\n            + interval: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u6301\u7eed\u65f6\u95f4\u957f\u5ea6\uff0c\u5355\u4f4d\u4e3a\u79d2\\n            + target_pos: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u76ee\u6807\u6301\u4ed3\\n            + price: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u4e0b\u5355\u4ef7\u683c\u6a21\u5f0f\uff0c\u652f\u6301 PASSIVE\uff08\u6392\u961f\u4ef7\uff09\uff0cACTIVE\uff08\u5bf9\u4ef7\uff09\uff0cNone\uff08\u4e0d\u4e0b\u5355\uff0c\u8868\u793a\u6682\u505c\u4e00\u6bb5\u65f6\u95f4\uff09\\n\\n    Example1::\\n\\n        from tqsdk import TqApi, TargetPosScheduler\\n        from tqsdk.algorithm import twap_table\\n\\n        api = TqApi(auth=\"\u5feb\u671f\u8d26\u6237,\u7528\u6237\u5bc6\u7801\")\\n        quote = api.get_quote(\"CZCE.MA109\")\\n\\n        # \u8bbe\u7f6etwap\u4efb\u52a1\u53c2\u6570\\n        time_table = twap_table(api, \"CZCE.MA109\", -100, 600, 1, 5)  # \u76ee\u6807\u6301\u4ed3 -100 \u624b\uff0c600s \u5185\u5b8c\u6210\\n        print(time_table.to_string())\\n\\n        target_pos_sch = TargetPosScheduler(api, \"CZCE.MA109\", time_table)\\n        # \u542f\u52a8\u5faa\u73af\\n        while not target_pos_sch.is_finished():\\n            api.wait_update()\\n        api.close()\\n\\n\\n    Example2::\\n\\n        from tqsdk import TqApi, TargetPosScheduler\\n        from tqsdk.algorithm import twap_table\\n\\n        api = TqApi(auth=\"\u5feb\u671f\u8d26\u6237,\u7528\u6237\u5bc6\u7801\")\\n        quote = api.get_quote(\"CZCE.MA109\")\\n\\n        # \u8bbe\u7f6e twap \u4efb\u52a1\u53c2\u6570\uff0c\\n        time_table = twap_table(api, \"CZCE.MA109\", -100, 600, 1, 5)  # \u76ee\u6807\u6301\u4ed3 -100 \u624b\uff0c600s \u5185\u5b8c\u6210\\n\\n        # \u5b9a\u5236\u5316\u8c03\u6574 time_table\uff0c\u4f8b\u5982\u5e0c\u671b\u7b2c\u4e00\u9879\u4efb\u52a1\u5ef6\u8fdf 10s \u518d\u5f00\u59cb\u4e0b\u5355\\n        # \u53ef\u4ee5\u5728 time_table \u7684\u5934\u90e8\u52a0\u4e00\u884c\\n        time_table = pandas.concat([\\n            DataFrame([[10, 10, None]], columns=[\\'interval\\', \\'target_pos\\', \\'price\\']),\\n            time_table\\n        ], ignore_index=True)\\n\\n        target_pos_sch = TargetPosScheduler(api, \"CZCE.MA109\", time_table)\\n        while not target_pos_sch.is_finished():\\n            api.wait_update()\\n\\n        # \u83b7\u53d6 target_pos_sch \u5b9e\u4f8b\u6240\u6709\u7684\u6210\u4ea4\u5217\u8868\\n        print(target_pos_sch.trades_df)\\n\\n        # \u5229\u7528\u6210\u4ea4\u5217\u8868\uff0c\u60a8\u53ef\u4ee5\u8ba1\u7b97\u51fa\u7b56\u7565\u7684\u5404\u79cd\u8868\u73b0\u6307\u6807\uff0c\u4f8b\u5982\uff1a\\n        average_trade_price = sum(scheduler.trades_df[\\'price\\'] * scheduler.trades_df[\\'volume\\']) / sum(scheduler.trades_df[\\'volume\\'])\\n        print(\"\u6210\u4ea4\u5747\u4ef7:\", average_trade_price)\\n        api.close()\\n\\n    '\n    account = api._account._check_valid(account)\n    if account is None:\n        raise Exception(f'\u591a\u8d26\u6237\u6a21\u5f0f\u4e0b, \u9700\u8981\u6307\u5b9a\u8d26\u6237\u5b9e\u4f8b account')\n    min_volume_each_step = int(min_volume_each_step)\n    max_volume_each_step = int(max_volume_each_step)\n    if max_volume_each_step <= 0 or min_volume_each_step <= 0:\n        raise Exception('\u8bf7\u8c03\u6574\u53c2\u6570, min_volume_each_step\u3001max_volume_each_step \u5fc5\u987b\u662f\u5927\u4e8e 0 \u7684\u6574\u6570\u3002')\n    if min_volume_each_step > max_volume_each_step:\n        raise Exception('\u8bf7\u8c03\u6574\u53c2\u6570, min_volume_each_step \u5fc5\u987b\u5c0f\u4e8e max_volume_each_step\u3002')\n    pos = api.get_position(symbol, account)\n    target_pos = int(target_pos)\n    delta_pos = target_pos - pos.pos\n    volume = abs(delta_pos)\n    if volume < max_volume_each_step:\n        (interval_list, volume_list) = ([duration], [volume])\n    else:\n        volume_list = _gen_random_list(sum_val=volume, min_val=min_volume_each_step, max_val=max_volume_each_step)\n        interval = int(duration / len(volume_list))\n        if interval < 3:\n            raise Exception('\u8bf7\u8c03\u6574\u53c2\u6570, \u6bcf\u6b21\u4e0b\u5355\u65f6\u95f4\u95f4\u9694\u4e0d\u80fd\u5c0f\u4e8e3s, \u5c06\u5355\u6b21\u4e0b\u5355\u624b\u6570\u9608\u503c\u8c03\u5927\u6216\u8005\u589e\u957f\u4e0b\u5355\u65f6\u95f4\u3002')\n        min_interval = int(max(3, interval - 2))\n        max_interval = int(interval * 2 - max(3, interval - 2)) + 1\n        interval_list = _gen_random_list(sum_val=duration, min_val=min_interval, max_val=max_interval, length=len(volume_list))\n    time_table = DataFrame(columns=['interval', 'volume', 'price'])\n    for (index, volume) in enumerate(volume_list):\n        assert interval_list[index] >= 3\n        active_interval = 2\n        append_time_table = pd.DataFrame([{'interval': interval_list[index] - active_interval, 'volume': volume, 'price': 'PASSIVE'}, {'interval': active_interval, 'volume': 0, 'price': 'ACTIVE'}])\n        time_table = pd.concat([time_table, append_time_table], ignore_index=True)\n    time_table['volume'] = time_table['volume'].mul(-1 if delta_pos < 0 else 1)\n    time_table['target_pos'] = time_table['volume'].cumsum()\n    time_table['target_pos'] = time_table['target_pos'].add(pos.pos)\n    time_table.drop(columns=['volume'], inplace=True)\n    time_table = time_table.astype({'target_pos': 'int64', 'interval': 'float64'})\n    return time_table",
            "def twap_table(api: TqApi, symbol: str, target_pos: int, duration: int, min_volume_each_step: int, max_volume_each_step: int, account: Optional[Union[TqAccount, TqKq, TqSim]]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    \u8fd4\u56de\u57fa\u4e8e twap \u7b56\u7565\u7684\u8ba1\u5212\u4efb\u52a1\u65f6\u95f4\u8868\u3002\u4e0b\u5355\u9700\u8981\u914d\u5408 TargetPosScheduler \u4f7f\u7528\u3002\\n\\n    Args:\\n        api (TqApi): TqApi\u5b9e\u4f8b\uff0c\u8be5task\u4f9d\u6258\u4e8e\u6307\u5b9aapi\u4e0b\u5355/\u64a4\u5355\\n\\n        symbol (str): \u62df\u4e0b\u5355\u7684\u5408\u7ea6 symbol, \u683c\u5f0f\u4e3a \u4ea4\u6613\u6240\u4ee3\u7801.\u5408\u7ea6\u4ee3\u7801,  \u4f8b\u5982 \"SHFE.cu1801\"\\n\\n        target_pos (int): \u76ee\u6807\u6301\u4ed3\u624b\u6570\\n\\n        duration (int): \u7b97\u6cd5\u6267\u884c\u7684\u65f6\u957f\uff0c\u4ee5\u79d2\u4e3a\u5355\u4f4d\uff0c\u65f6\u957f\u53ef\u4ee5\u8de8\u975e\u4ea4\u6613\u65f6\u95f4\u6bb5\uff0c\u4f46\u662f\u4e0d\u53ef\u4ee5\u8de8\u4ea4\u6613\u65e5\\n        * \u8bbe\u7f6e\u4e3a 60*10, \u53ef\u4ee5\u662f 10:10\uff5e10:15 + 10:30~10:35\\n\\n        min_volume_each_step (int): \u8c03\u6574\u6301\u4ed3\u624b\u6570\u6700\u5c0f\u503c\uff0c\u6bcf\u6b65\u8c03\u6574\u7684\u6301\u4ed3\u624b\u6570\u9ed8\u8ba4\u5728\u6700\u5c0f\u548c\u6700\u5927\u503c\u4e2d\u4ea7\u751f\\n\\n        max_volume_each_step (int): \u8c03\u6574\u6301\u4ed3\u624b\u6570\u6700\u5927\u503c\uff0c\u6bcf\u6b65\u8c03\u6574\u7684\u6301\u4ed3\u624b\u6570\u9ed8\u8ba4\u5728\u6700\u5c0f\u548c\u6700\u5927\u503c\u4e2d\u4ea7\u751f\\n\\n        account (TqAccount/TqKq/TqSim): [\u53ef\u9009]\u6307\u5b9a\u53d1\u9001\u4e0b\u5355\u6307\u4ee4\u7684\u8d26\u6237\u5b9e\u4f8b, \u591a\u8d26\u6237\u6a21\u5f0f\u4e0b\uff0c\u8be5\u53c2\u6570\u5fc5\u987b\u6307\u5b9a\\n\\n    Returns:\\n        pandas.DataFrame: \u672c\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a pandas.DataFrame \u5b9e\u4f8b. \u8868\u793a\u4e00\u4efd\u8ba1\u5212\u4efb\u52a1\u65f6\u95f4\u8868\u3002\u6bcf\u4e00\u884c\u8868\u793a\u4e00\u9879\u76ee\u6807\u6301\u4ed3\u4efb\u52a1\uff0c\u5305\u542b\u4ee5\u4e0b\u5217:\\n\\n            + interval: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u6301\u7eed\u65f6\u95f4\u957f\u5ea6\uff0c\u5355\u4f4d\u4e3a\u79d2\\n            + target_pos: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u76ee\u6807\u6301\u4ed3\\n            + price: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u4e0b\u5355\u4ef7\u683c\u6a21\u5f0f\uff0c\u652f\u6301 PASSIVE\uff08\u6392\u961f\u4ef7\uff09\uff0cACTIVE\uff08\u5bf9\u4ef7\uff09\uff0cNone\uff08\u4e0d\u4e0b\u5355\uff0c\u8868\u793a\u6682\u505c\u4e00\u6bb5\u65f6\u95f4\uff09\\n\\n    Example1::\\n\\n        from tqsdk import TqApi, TargetPosScheduler\\n        from tqsdk.algorithm import twap_table\\n\\n        api = TqApi(auth=\"\u5feb\u671f\u8d26\u6237,\u7528\u6237\u5bc6\u7801\")\\n        quote = api.get_quote(\"CZCE.MA109\")\\n\\n        # \u8bbe\u7f6etwap\u4efb\u52a1\u53c2\u6570\\n        time_table = twap_table(api, \"CZCE.MA109\", -100, 600, 1, 5)  # \u76ee\u6807\u6301\u4ed3 -100 \u624b\uff0c600s \u5185\u5b8c\u6210\\n        print(time_table.to_string())\\n\\n        target_pos_sch = TargetPosScheduler(api, \"CZCE.MA109\", time_table)\\n        # \u542f\u52a8\u5faa\u73af\\n        while not target_pos_sch.is_finished():\\n            api.wait_update()\\n        api.close()\\n\\n\\n    Example2::\\n\\n        from tqsdk import TqApi, TargetPosScheduler\\n        from tqsdk.algorithm import twap_table\\n\\n        api = TqApi(auth=\"\u5feb\u671f\u8d26\u6237,\u7528\u6237\u5bc6\u7801\")\\n        quote = api.get_quote(\"CZCE.MA109\")\\n\\n        # \u8bbe\u7f6e twap \u4efb\u52a1\u53c2\u6570\uff0c\\n        time_table = twap_table(api, \"CZCE.MA109\", -100, 600, 1, 5)  # \u76ee\u6807\u6301\u4ed3 -100 \u624b\uff0c600s \u5185\u5b8c\u6210\\n\\n        # \u5b9a\u5236\u5316\u8c03\u6574 time_table\uff0c\u4f8b\u5982\u5e0c\u671b\u7b2c\u4e00\u9879\u4efb\u52a1\u5ef6\u8fdf 10s \u518d\u5f00\u59cb\u4e0b\u5355\\n        # \u53ef\u4ee5\u5728 time_table \u7684\u5934\u90e8\u52a0\u4e00\u884c\\n        time_table = pandas.concat([\\n            DataFrame([[10, 10, None]], columns=[\\'interval\\', \\'target_pos\\', \\'price\\']),\\n            time_table\\n        ], ignore_index=True)\\n\\n        target_pos_sch = TargetPosScheduler(api, \"CZCE.MA109\", time_table)\\n        while not target_pos_sch.is_finished():\\n            api.wait_update()\\n\\n        # \u83b7\u53d6 target_pos_sch \u5b9e\u4f8b\u6240\u6709\u7684\u6210\u4ea4\u5217\u8868\\n        print(target_pos_sch.trades_df)\\n\\n        # \u5229\u7528\u6210\u4ea4\u5217\u8868\uff0c\u60a8\u53ef\u4ee5\u8ba1\u7b97\u51fa\u7b56\u7565\u7684\u5404\u79cd\u8868\u73b0\u6307\u6807\uff0c\u4f8b\u5982\uff1a\\n        average_trade_price = sum(scheduler.trades_df[\\'price\\'] * scheduler.trades_df[\\'volume\\']) / sum(scheduler.trades_df[\\'volume\\'])\\n        print(\"\u6210\u4ea4\u5747\u4ef7:\", average_trade_price)\\n        api.close()\\n\\n    '\n    account = api._account._check_valid(account)\n    if account is None:\n        raise Exception(f'\u591a\u8d26\u6237\u6a21\u5f0f\u4e0b, \u9700\u8981\u6307\u5b9a\u8d26\u6237\u5b9e\u4f8b account')\n    min_volume_each_step = int(min_volume_each_step)\n    max_volume_each_step = int(max_volume_each_step)\n    if max_volume_each_step <= 0 or min_volume_each_step <= 0:\n        raise Exception('\u8bf7\u8c03\u6574\u53c2\u6570, min_volume_each_step\u3001max_volume_each_step \u5fc5\u987b\u662f\u5927\u4e8e 0 \u7684\u6574\u6570\u3002')\n    if min_volume_each_step > max_volume_each_step:\n        raise Exception('\u8bf7\u8c03\u6574\u53c2\u6570, min_volume_each_step \u5fc5\u987b\u5c0f\u4e8e max_volume_each_step\u3002')\n    pos = api.get_position(symbol, account)\n    target_pos = int(target_pos)\n    delta_pos = target_pos - pos.pos\n    volume = abs(delta_pos)\n    if volume < max_volume_each_step:\n        (interval_list, volume_list) = ([duration], [volume])\n    else:\n        volume_list = _gen_random_list(sum_val=volume, min_val=min_volume_each_step, max_val=max_volume_each_step)\n        interval = int(duration / len(volume_list))\n        if interval < 3:\n            raise Exception('\u8bf7\u8c03\u6574\u53c2\u6570, \u6bcf\u6b21\u4e0b\u5355\u65f6\u95f4\u95f4\u9694\u4e0d\u80fd\u5c0f\u4e8e3s, \u5c06\u5355\u6b21\u4e0b\u5355\u624b\u6570\u9608\u503c\u8c03\u5927\u6216\u8005\u589e\u957f\u4e0b\u5355\u65f6\u95f4\u3002')\n        min_interval = int(max(3, interval - 2))\n        max_interval = int(interval * 2 - max(3, interval - 2)) + 1\n        interval_list = _gen_random_list(sum_val=duration, min_val=min_interval, max_val=max_interval, length=len(volume_list))\n    time_table = DataFrame(columns=['interval', 'volume', 'price'])\n    for (index, volume) in enumerate(volume_list):\n        assert interval_list[index] >= 3\n        active_interval = 2\n        append_time_table = pd.DataFrame([{'interval': interval_list[index] - active_interval, 'volume': volume, 'price': 'PASSIVE'}, {'interval': active_interval, 'volume': 0, 'price': 'ACTIVE'}])\n        time_table = pd.concat([time_table, append_time_table], ignore_index=True)\n    time_table['volume'] = time_table['volume'].mul(-1 if delta_pos < 0 else 1)\n    time_table['target_pos'] = time_table['volume'].cumsum()\n    time_table['target_pos'] = time_table['target_pos'].add(pos.pos)\n    time_table.drop(columns=['volume'], inplace=True)\n    time_table = time_table.astype({'target_pos': 'int64', 'interval': 'float64'})\n    return time_table",
            "def twap_table(api: TqApi, symbol: str, target_pos: int, duration: int, min_volume_each_step: int, max_volume_each_step: int, account: Optional[Union[TqAccount, TqKq, TqSim]]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    \u8fd4\u56de\u57fa\u4e8e twap \u7b56\u7565\u7684\u8ba1\u5212\u4efb\u52a1\u65f6\u95f4\u8868\u3002\u4e0b\u5355\u9700\u8981\u914d\u5408 TargetPosScheduler \u4f7f\u7528\u3002\\n\\n    Args:\\n        api (TqApi): TqApi\u5b9e\u4f8b\uff0c\u8be5task\u4f9d\u6258\u4e8e\u6307\u5b9aapi\u4e0b\u5355/\u64a4\u5355\\n\\n        symbol (str): \u62df\u4e0b\u5355\u7684\u5408\u7ea6 symbol, \u683c\u5f0f\u4e3a \u4ea4\u6613\u6240\u4ee3\u7801.\u5408\u7ea6\u4ee3\u7801,  \u4f8b\u5982 \"SHFE.cu1801\"\\n\\n        target_pos (int): \u76ee\u6807\u6301\u4ed3\u624b\u6570\\n\\n        duration (int): \u7b97\u6cd5\u6267\u884c\u7684\u65f6\u957f\uff0c\u4ee5\u79d2\u4e3a\u5355\u4f4d\uff0c\u65f6\u957f\u53ef\u4ee5\u8de8\u975e\u4ea4\u6613\u65f6\u95f4\u6bb5\uff0c\u4f46\u662f\u4e0d\u53ef\u4ee5\u8de8\u4ea4\u6613\u65e5\\n        * \u8bbe\u7f6e\u4e3a 60*10, \u53ef\u4ee5\u662f 10:10\uff5e10:15 + 10:30~10:35\\n\\n        min_volume_each_step (int): \u8c03\u6574\u6301\u4ed3\u624b\u6570\u6700\u5c0f\u503c\uff0c\u6bcf\u6b65\u8c03\u6574\u7684\u6301\u4ed3\u624b\u6570\u9ed8\u8ba4\u5728\u6700\u5c0f\u548c\u6700\u5927\u503c\u4e2d\u4ea7\u751f\\n\\n        max_volume_each_step (int): \u8c03\u6574\u6301\u4ed3\u624b\u6570\u6700\u5927\u503c\uff0c\u6bcf\u6b65\u8c03\u6574\u7684\u6301\u4ed3\u624b\u6570\u9ed8\u8ba4\u5728\u6700\u5c0f\u548c\u6700\u5927\u503c\u4e2d\u4ea7\u751f\\n\\n        account (TqAccount/TqKq/TqSim): [\u53ef\u9009]\u6307\u5b9a\u53d1\u9001\u4e0b\u5355\u6307\u4ee4\u7684\u8d26\u6237\u5b9e\u4f8b, \u591a\u8d26\u6237\u6a21\u5f0f\u4e0b\uff0c\u8be5\u53c2\u6570\u5fc5\u987b\u6307\u5b9a\\n\\n    Returns:\\n        pandas.DataFrame: \u672c\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a pandas.DataFrame \u5b9e\u4f8b. \u8868\u793a\u4e00\u4efd\u8ba1\u5212\u4efb\u52a1\u65f6\u95f4\u8868\u3002\u6bcf\u4e00\u884c\u8868\u793a\u4e00\u9879\u76ee\u6807\u6301\u4ed3\u4efb\u52a1\uff0c\u5305\u542b\u4ee5\u4e0b\u5217:\\n\\n            + interval: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u6301\u7eed\u65f6\u95f4\u957f\u5ea6\uff0c\u5355\u4f4d\u4e3a\u79d2\\n            + target_pos: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u76ee\u6807\u6301\u4ed3\\n            + price: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u4e0b\u5355\u4ef7\u683c\u6a21\u5f0f\uff0c\u652f\u6301 PASSIVE\uff08\u6392\u961f\u4ef7\uff09\uff0cACTIVE\uff08\u5bf9\u4ef7\uff09\uff0cNone\uff08\u4e0d\u4e0b\u5355\uff0c\u8868\u793a\u6682\u505c\u4e00\u6bb5\u65f6\u95f4\uff09\\n\\n    Example1::\\n\\n        from tqsdk import TqApi, TargetPosScheduler\\n        from tqsdk.algorithm import twap_table\\n\\n        api = TqApi(auth=\"\u5feb\u671f\u8d26\u6237,\u7528\u6237\u5bc6\u7801\")\\n        quote = api.get_quote(\"CZCE.MA109\")\\n\\n        # \u8bbe\u7f6etwap\u4efb\u52a1\u53c2\u6570\\n        time_table = twap_table(api, \"CZCE.MA109\", -100, 600, 1, 5)  # \u76ee\u6807\u6301\u4ed3 -100 \u624b\uff0c600s \u5185\u5b8c\u6210\\n        print(time_table.to_string())\\n\\n        target_pos_sch = TargetPosScheduler(api, \"CZCE.MA109\", time_table)\\n        # \u542f\u52a8\u5faa\u73af\\n        while not target_pos_sch.is_finished():\\n            api.wait_update()\\n        api.close()\\n\\n\\n    Example2::\\n\\n        from tqsdk import TqApi, TargetPosScheduler\\n        from tqsdk.algorithm import twap_table\\n\\n        api = TqApi(auth=\"\u5feb\u671f\u8d26\u6237,\u7528\u6237\u5bc6\u7801\")\\n        quote = api.get_quote(\"CZCE.MA109\")\\n\\n        # \u8bbe\u7f6e twap \u4efb\u52a1\u53c2\u6570\uff0c\\n        time_table = twap_table(api, \"CZCE.MA109\", -100, 600, 1, 5)  # \u76ee\u6807\u6301\u4ed3 -100 \u624b\uff0c600s \u5185\u5b8c\u6210\\n\\n        # \u5b9a\u5236\u5316\u8c03\u6574 time_table\uff0c\u4f8b\u5982\u5e0c\u671b\u7b2c\u4e00\u9879\u4efb\u52a1\u5ef6\u8fdf 10s \u518d\u5f00\u59cb\u4e0b\u5355\\n        # \u53ef\u4ee5\u5728 time_table \u7684\u5934\u90e8\u52a0\u4e00\u884c\\n        time_table = pandas.concat([\\n            DataFrame([[10, 10, None]], columns=[\\'interval\\', \\'target_pos\\', \\'price\\']),\\n            time_table\\n        ], ignore_index=True)\\n\\n        target_pos_sch = TargetPosScheduler(api, \"CZCE.MA109\", time_table)\\n        while not target_pos_sch.is_finished():\\n            api.wait_update()\\n\\n        # \u83b7\u53d6 target_pos_sch \u5b9e\u4f8b\u6240\u6709\u7684\u6210\u4ea4\u5217\u8868\\n        print(target_pos_sch.trades_df)\\n\\n        # \u5229\u7528\u6210\u4ea4\u5217\u8868\uff0c\u60a8\u53ef\u4ee5\u8ba1\u7b97\u51fa\u7b56\u7565\u7684\u5404\u79cd\u8868\u73b0\u6307\u6807\uff0c\u4f8b\u5982\uff1a\\n        average_trade_price = sum(scheduler.trades_df[\\'price\\'] * scheduler.trades_df[\\'volume\\']) / sum(scheduler.trades_df[\\'volume\\'])\\n        print(\"\u6210\u4ea4\u5747\u4ef7:\", average_trade_price)\\n        api.close()\\n\\n    '\n    account = api._account._check_valid(account)\n    if account is None:\n        raise Exception(f'\u591a\u8d26\u6237\u6a21\u5f0f\u4e0b, \u9700\u8981\u6307\u5b9a\u8d26\u6237\u5b9e\u4f8b account')\n    min_volume_each_step = int(min_volume_each_step)\n    max_volume_each_step = int(max_volume_each_step)\n    if max_volume_each_step <= 0 or min_volume_each_step <= 0:\n        raise Exception('\u8bf7\u8c03\u6574\u53c2\u6570, min_volume_each_step\u3001max_volume_each_step \u5fc5\u987b\u662f\u5927\u4e8e 0 \u7684\u6574\u6570\u3002')\n    if min_volume_each_step > max_volume_each_step:\n        raise Exception('\u8bf7\u8c03\u6574\u53c2\u6570, min_volume_each_step \u5fc5\u987b\u5c0f\u4e8e max_volume_each_step\u3002')\n    pos = api.get_position(symbol, account)\n    target_pos = int(target_pos)\n    delta_pos = target_pos - pos.pos\n    volume = abs(delta_pos)\n    if volume < max_volume_each_step:\n        (interval_list, volume_list) = ([duration], [volume])\n    else:\n        volume_list = _gen_random_list(sum_val=volume, min_val=min_volume_each_step, max_val=max_volume_each_step)\n        interval = int(duration / len(volume_list))\n        if interval < 3:\n            raise Exception('\u8bf7\u8c03\u6574\u53c2\u6570, \u6bcf\u6b21\u4e0b\u5355\u65f6\u95f4\u95f4\u9694\u4e0d\u80fd\u5c0f\u4e8e3s, \u5c06\u5355\u6b21\u4e0b\u5355\u624b\u6570\u9608\u503c\u8c03\u5927\u6216\u8005\u589e\u957f\u4e0b\u5355\u65f6\u95f4\u3002')\n        min_interval = int(max(3, interval - 2))\n        max_interval = int(interval * 2 - max(3, interval - 2)) + 1\n        interval_list = _gen_random_list(sum_val=duration, min_val=min_interval, max_val=max_interval, length=len(volume_list))\n    time_table = DataFrame(columns=['interval', 'volume', 'price'])\n    for (index, volume) in enumerate(volume_list):\n        assert interval_list[index] >= 3\n        active_interval = 2\n        append_time_table = pd.DataFrame([{'interval': interval_list[index] - active_interval, 'volume': volume, 'price': 'PASSIVE'}, {'interval': active_interval, 'volume': 0, 'price': 'ACTIVE'}])\n        time_table = pd.concat([time_table, append_time_table], ignore_index=True)\n    time_table['volume'] = time_table['volume'].mul(-1 if delta_pos < 0 else 1)\n    time_table['target_pos'] = time_table['volume'].cumsum()\n    time_table['target_pos'] = time_table['target_pos'].add(pos.pos)\n    time_table.drop(columns=['volume'], inplace=True)\n    time_table = time_table.astype({'target_pos': 'int64', 'interval': 'float64'})\n    return time_table"
        ]
    },
    {
        "func_name": "vwap_table",
        "original": "def vwap_table(api: TqApi, symbol: str, target_pos: int, duration: float, account: Optional[Union[TqAccount, TqKq, TqSim]]=None):\n    \"\"\"\n    \u8fd4\u56de\u57fa\u4e8e vwap \u7b56\u7565\u7684\u8ba1\u5212\u4efb\u52a1\u65f6\u95f4\u8868\u3002\u4e0b\u5355\u9700\u8981\u914d\u5408 TargetPosScheduler \u4f7f\u7528\u3002\n\n    \u8c03\u7528 vwap_table \u51fd\u6570\uff0c\u6839\u636e\u4ee5\u4e0b\u903b\u8f91\u751f\u6210 time_table\uff1a\n\n    1. \u6839\u636e target_pos - \u5f53\u524d\u5408\u7ea6\u7684\u51c0\u6301\u4ed3\uff0c\u5f97\u5230\u603b\u7684\u9700\u8981\u8c03\u6574\u624b\u6570\n    2. \u8bf7\u6c42 symbol \u5408\u7ea6\u7684 ``1min`` K \u7ebf\n    3. \u91c7\u6837\u53d6\u7528\u6700\u8fd1 10 \u65e5\u5185\uff0c\u4ee5\u5408\u7ea6\u5f53\u524d\u884c\u60c5\u65f6\u95f4\u7684\u4e0b\u4e00\u5206\u949f\u4e3a\u8d77\u70b9\uff0c\u6bcf\u65e5 duration / 60 \u6839 K \u7ebf,     \u4f8b\u5982\u5f53\u524d\u5408\u7ea6\u65f6\u95f4\u4e3a 14:35:35\uff0c\u90a3\u4e48\u91c7\u6837\u662f\u4f1a\u4f7f\u7528 14:36:00 \u5f00\u59cb\u7684\u5206\u949f\u7ebf K \u7ebf\n    4. \u6309\u65e5\u671f\u5206\u7ec4\uff0c\u5206\u522b\u8ba1\u7b97\u4ea4\u6613\u65e5\u5185\uff0c\u6bcf\u6839 K \u7ebf\u6210\u4ea4\u91cf\u5360\u603b\u6210\u4ea4\u91cf\u7684\u6bd4\u4f8b\n    5. \u8ba1\u7b97\u6700\u8fd1 10 \u65e5\u5185\u76f8\u540c\u5206\u949f\u5185\u7684\u6210\u4ea4\u91cf\u5360\u6bd4\u7684\u7b97\u672f\u5e73\u5747\u6570\uff0c\u5c06\u7b2c 1 \u6b65\u5f97\u5230\u7684\u603b\u8c03\u6574\u624b\u6570\u6309\u7167\u5f97\u5230\u7684\u6bd4\u4f8b\u5206\u914d\n    6. \u6bcf\u4e00\u5206\u949f\uff0c\u524d 58s \u4ee5\u8ffd\u52a0\u4ef7\u683c\u4e0b\u5355\uff0c\u540e 2s \u4ee5\u5bf9\u4ef7\u4ef7\u683c\u4e0b\u5355\n\n    Args:\n        api (TqApi): TqApi\u5b9e\u4f8b\uff0c\u8be5task\u4f9d\u6258\u4e8e\u6307\u5b9aapi\u4e0b\u5355/\u64a4\u5355\n\n        symbol (str): \u62df\u4e0b\u5355\u7684\u5408\u7ea6 symbol, \u683c\u5f0f\u4e3a \u4ea4\u6613\u6240\u4ee3\u7801.\u5408\u7ea6\u4ee3\u7801,  \u4f8b\u5982 \"SHFE.cu2201\"\n\n        target_pos (int): \u76ee\u6807\u6301\u4ed3\u624b\u6570\n\n        duration (int): \u7b97\u6cd5\u6267\u884c\u7684\u65f6\u957f\uff0c\u4ee5\u79d2\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u662f 60 \u7684\u6574\u6570\u500d\uff0c\u65f6\u957f\u53ef\u4ee5\u8de8\u975e\u4ea4\u6613\u65f6\u95f4\u6bb5\uff0c\u4f46\u662f\u4e0d\u53ef\u4ee5\u8de8\u4ea4\u6613\u65e5\n        * \u8bbe\u7f6e\u4e3a 60*10, \u53ef\u4ee5\u662f 10:10\uff5e10:15 + 10:30~10:35\n\n        account (TqAccount/TqKq/TqSim): [\u53ef\u9009]\u6307\u5b9a\u53d1\u9001\u4e0b\u5355\u6307\u4ee4\u7684\u8d26\u6237\u5b9e\u4f8b, \u591a\u8d26\u6237\u6a21\u5f0f\u4e0b\uff0c\u8be5\u53c2\u6570\u5fc5\u987b\u6307\u5b9a\n\n    Returns:\n        pandas.DataFrame: \u672c\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a pandas.DataFrame \u5b9e\u4f8b. \u8868\u793a\u4e00\u4efd\u8ba1\u5212\u4efb\u52a1\u65f6\u95f4\u8868\u3002\u6bcf\u4e00\u884c\u8868\u793a\u4e00\u9879\u76ee\u6807\u6301\u4ed3\u4efb\u52a1\uff0c\u5305\u542b\u4ee5\u4e0b\u5217:\n\n            + interval: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u6301\u7eed\u65f6\u95f4\u957f\u5ea6\uff0c\u5355\u4f4d\u4e3a\u79d2\n            + target_pos: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u76ee\u6807\u6301\u4ed3\n            + price: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u4e0b\u5355\u4ef7\u683c\u6a21\u5f0f\uff0c\u652f\u6301 PASSIVE\uff08\u6392\u961f\u4ef7\uff09\uff0cACTIVE\uff08\u5bf9\u4ef7\uff09\uff0cNone\uff08\u4e0d\u4e0b\u5355\uff0c\u8868\u793a\u6682\u505c\u4e00\u6bb5\u65f6\u95f4\uff09\n\n    Example1::\n\n        from tqsdk import TqApi, TargetPosScheduler\n        from tqsdk.algorithm import vwap_table\n\n        api = TqApi(auth=\"\u5feb\u671f\u8d26\u6237,\u7528\u6237\u5bc6\u7801\")\n        quote = api.get_quote(\"CZCE.MA109\")\n\n        # \u8bbe\u7f6e vwap \u4efb\u52a1\u53c2\u6570\n        time_table = vwap_table(api, \"CZCE.MA109\", -100, 600)  # \u76ee\u6807\u6301\u4ed3 -100 \u624b\uff0c600s \u5185\u5b8c\u6210\n        print(time_table.to_string())\n\n        target_pos_sch = TargetPosScheduler(api, \"CZCE.MA109\", time_table)\n        # \u542f\u52a8\u5faa\u73af\n        while not target_pos_sch.is_finished():\n            api.wait_update()\n        api.close()\n\n\n    \"\"\"\n    account = api._account._check_valid(account)\n    if account is None:\n        raise Exception(f'\u591a\u8d26\u6237\u6a21\u5f0f\u4e0b, \u9700\u8981\u6307\u5b9a\u8d26\u6237\u5b9e\u4f8b account')\n    TIME_CELL = 60\n    HISTORY_DAY_LENGTH = 10\n    if duration % TIME_CELL or duration < 60:\n        raise Exception(f'duration {duration} \u53c2\u6570\u5e94\u8be5\u4e3a {TIME_CELL} \u7684\u6574\u6570\u500d')\n    pos = account.get_position(symbol)\n    target_pos = int(target_pos)\n    delta_pos = target_pos - pos.pos\n    target_volume = abs(delta_pos)\n    if target_volume == 0:\n        return DataFrame(columns=['interval', 'target_pos', 'price'])\n    klines = api.get_kline_serial(symbol, TIME_CELL, data_length=int(10 * 60 * 60 / TIME_CELL * HISTORY_DAY_LENGTH))\n    klines['time'] = klines.datetime.apply(lambda x: datetime.fromtimestamp(x // 1000000000).time())\n    klines['date'] = klines.datetime.apply(lambda x: datetime.fromtimestamp(_get_trading_day_from_timestamp(x) // 1000000000).date())\n    quote = api.get_quote(symbol)\n    trading_timestamp = _get_trading_timestamp(quote, quote.datetime)\n    trading_timestamp_nano_range = trading_timestamp['night'] + trading_timestamp['day']\n    current_timestamp_nano = _get_trade_timestamp(quote.datetime, float('nan'))\n    if not trading_timestamp_nano_range[0][0] <= current_timestamp_nano < trading_timestamp_nano_range[-1][1]:\n        raise Exception('\u5f53\u524d\u65f6\u95f4\u4e0d\u5728\u6307\u5b9a\u7684\u4ea4\u6613\u65f6\u95f4\u6bb5\u5185')\n    current_datetime = datetime.fromtimestamp(current_timestamp_nano // 1000000000)\n    next_datetime = current_datetime.replace(second=0) + timedelta(minutes=1)\n    start_datetime_nano = _datetime_to_timestamp_nano(next_datetime)\n    r = _rangeset_head(_rangeset_slice(trading_timestamp_nano_range, start_datetime_nano), int(duration * 1000000000.0))\n    if not (r and trading_timestamp_nano_range[0][0] <= r[-1][-1] < trading_timestamp_nano_range[-1][1]):\n        raise Exception('\u6307\u5b9a\u65f6\u95f4\u6bb5\u8d85\u51fa\u5f53\u524d\u4ea4\u6613\u65e5')\n    start_datetime = datetime.fromtimestamp(start_datetime_nano // 1000000000)\n    end_datetime = datetime.fromtimestamp((r[-1][-1] - 1) // 1000000000)\n    time_slot_start = time(start_datetime.hour, start_datetime.minute)\n    time_slot_end = time(end_datetime.hour, end_datetime.minute)\n    if time_slot_end > time_slot_start:\n        klines = klines[(klines['time'] >= time_slot_start) & (klines['time'] <= time_slot_end)]\n    else:\n        klines = klines[(klines['time'] >= time_slot_start) | (klines['time'] <= time_slot_end)]\n    need_date = klines['date'].drop_duplicates()[-HISTORY_DAY_LENGTH:]\n    klines = klines[klines['date'].isin(need_date)]\n    grouped_datetime = klines.groupby(['date', 'time'])['volume'].sum()\n    volume_percent = grouped_datetime / grouped_datetime.groupby(level=0).sum()\n    predicted_percent = volume_percent.groupby(level=1).mean()\n    time_table = DataFrame(columns=['interval', 'volume', 'price'])\n    volume_left = target_volume\n    percent_left = 1\n    for (index, value) in predicted_percent.items():\n        volume = round(volume_left * (value / percent_left))\n        volume_left -= volume\n        percent_left -= value\n        append_time_table = pd.DataFrame([{'interval': TIME_CELL - 2, 'volume': volume, 'price': 'PASSIVE'}, {'interval': 2, 'volume': 0, 'price': 'ACTIVE'}])\n        time_table = pd.concat([time_table, append_time_table], ignore_index=True)\n    time_table['volume'] = time_table['volume'].mul(np.sign(delta_pos))\n    time_table['target_pos'] = time_table['volume'].cumsum()\n    time_table['target_pos'] = time_table['target_pos'].add(pos.pos)\n    time_table.drop(columns=['volume'], inplace=True)\n    time_table = time_table.astype({'target_pos': 'int64', 'interval': 'float64'})\n    return time_table",
        "mutated": [
            "def vwap_table(api: TqApi, symbol: str, target_pos: int, duration: float, account: Optional[Union[TqAccount, TqKq, TqSim]]=None):\n    if False:\n        i = 10\n    '\\n    \u8fd4\u56de\u57fa\u4e8e vwap \u7b56\u7565\u7684\u8ba1\u5212\u4efb\u52a1\u65f6\u95f4\u8868\u3002\u4e0b\u5355\u9700\u8981\u914d\u5408 TargetPosScheduler \u4f7f\u7528\u3002\\n\\n    \u8c03\u7528 vwap_table \u51fd\u6570\uff0c\u6839\u636e\u4ee5\u4e0b\u903b\u8f91\u751f\u6210 time_table\uff1a\\n\\n    1. \u6839\u636e target_pos - \u5f53\u524d\u5408\u7ea6\u7684\u51c0\u6301\u4ed3\uff0c\u5f97\u5230\u603b\u7684\u9700\u8981\u8c03\u6574\u624b\u6570\\n    2. \u8bf7\u6c42 symbol \u5408\u7ea6\u7684 ``1min`` K \u7ebf\\n    3. \u91c7\u6837\u53d6\u7528\u6700\u8fd1 10 \u65e5\u5185\uff0c\u4ee5\u5408\u7ea6\u5f53\u524d\u884c\u60c5\u65f6\u95f4\u7684\u4e0b\u4e00\u5206\u949f\u4e3a\u8d77\u70b9\uff0c\u6bcf\u65e5 duration / 60 \u6839 K \u7ebf,     \u4f8b\u5982\u5f53\u524d\u5408\u7ea6\u65f6\u95f4\u4e3a 14:35:35\uff0c\u90a3\u4e48\u91c7\u6837\u662f\u4f1a\u4f7f\u7528 14:36:00 \u5f00\u59cb\u7684\u5206\u949f\u7ebf K \u7ebf\\n    4. \u6309\u65e5\u671f\u5206\u7ec4\uff0c\u5206\u522b\u8ba1\u7b97\u4ea4\u6613\u65e5\u5185\uff0c\u6bcf\u6839 K \u7ebf\u6210\u4ea4\u91cf\u5360\u603b\u6210\u4ea4\u91cf\u7684\u6bd4\u4f8b\\n    5. \u8ba1\u7b97\u6700\u8fd1 10 \u65e5\u5185\u76f8\u540c\u5206\u949f\u5185\u7684\u6210\u4ea4\u91cf\u5360\u6bd4\u7684\u7b97\u672f\u5e73\u5747\u6570\uff0c\u5c06\u7b2c 1 \u6b65\u5f97\u5230\u7684\u603b\u8c03\u6574\u624b\u6570\u6309\u7167\u5f97\u5230\u7684\u6bd4\u4f8b\u5206\u914d\\n    6. \u6bcf\u4e00\u5206\u949f\uff0c\u524d 58s \u4ee5\u8ffd\u52a0\u4ef7\u683c\u4e0b\u5355\uff0c\u540e 2s \u4ee5\u5bf9\u4ef7\u4ef7\u683c\u4e0b\u5355\\n\\n    Args:\\n        api (TqApi): TqApi\u5b9e\u4f8b\uff0c\u8be5task\u4f9d\u6258\u4e8e\u6307\u5b9aapi\u4e0b\u5355/\u64a4\u5355\\n\\n        symbol (str): \u62df\u4e0b\u5355\u7684\u5408\u7ea6 symbol, \u683c\u5f0f\u4e3a \u4ea4\u6613\u6240\u4ee3\u7801.\u5408\u7ea6\u4ee3\u7801,  \u4f8b\u5982 \"SHFE.cu2201\"\\n\\n        target_pos (int): \u76ee\u6807\u6301\u4ed3\u624b\u6570\\n\\n        duration (int): \u7b97\u6cd5\u6267\u884c\u7684\u65f6\u957f\uff0c\u4ee5\u79d2\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u662f 60 \u7684\u6574\u6570\u500d\uff0c\u65f6\u957f\u53ef\u4ee5\u8de8\u975e\u4ea4\u6613\u65f6\u95f4\u6bb5\uff0c\u4f46\u662f\u4e0d\u53ef\u4ee5\u8de8\u4ea4\u6613\u65e5\\n        * \u8bbe\u7f6e\u4e3a 60*10, \u53ef\u4ee5\u662f 10:10\uff5e10:15 + 10:30~10:35\\n\\n        account (TqAccount/TqKq/TqSim): [\u53ef\u9009]\u6307\u5b9a\u53d1\u9001\u4e0b\u5355\u6307\u4ee4\u7684\u8d26\u6237\u5b9e\u4f8b, \u591a\u8d26\u6237\u6a21\u5f0f\u4e0b\uff0c\u8be5\u53c2\u6570\u5fc5\u987b\u6307\u5b9a\\n\\n    Returns:\\n        pandas.DataFrame: \u672c\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a pandas.DataFrame \u5b9e\u4f8b. \u8868\u793a\u4e00\u4efd\u8ba1\u5212\u4efb\u52a1\u65f6\u95f4\u8868\u3002\u6bcf\u4e00\u884c\u8868\u793a\u4e00\u9879\u76ee\u6807\u6301\u4ed3\u4efb\u52a1\uff0c\u5305\u542b\u4ee5\u4e0b\u5217:\\n\\n            + interval: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u6301\u7eed\u65f6\u95f4\u957f\u5ea6\uff0c\u5355\u4f4d\u4e3a\u79d2\\n            + target_pos: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u76ee\u6807\u6301\u4ed3\\n            + price: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u4e0b\u5355\u4ef7\u683c\u6a21\u5f0f\uff0c\u652f\u6301 PASSIVE\uff08\u6392\u961f\u4ef7\uff09\uff0cACTIVE\uff08\u5bf9\u4ef7\uff09\uff0cNone\uff08\u4e0d\u4e0b\u5355\uff0c\u8868\u793a\u6682\u505c\u4e00\u6bb5\u65f6\u95f4\uff09\\n\\n    Example1::\\n\\n        from tqsdk import TqApi, TargetPosScheduler\\n        from tqsdk.algorithm import vwap_table\\n\\n        api = TqApi(auth=\"\u5feb\u671f\u8d26\u6237,\u7528\u6237\u5bc6\u7801\")\\n        quote = api.get_quote(\"CZCE.MA109\")\\n\\n        # \u8bbe\u7f6e vwap \u4efb\u52a1\u53c2\u6570\\n        time_table = vwap_table(api, \"CZCE.MA109\", -100, 600)  # \u76ee\u6807\u6301\u4ed3 -100 \u624b\uff0c600s \u5185\u5b8c\u6210\\n        print(time_table.to_string())\\n\\n        target_pos_sch = TargetPosScheduler(api, \"CZCE.MA109\", time_table)\\n        # \u542f\u52a8\u5faa\u73af\\n        while not target_pos_sch.is_finished():\\n            api.wait_update()\\n        api.close()\\n\\n\\n    '\n    account = api._account._check_valid(account)\n    if account is None:\n        raise Exception(f'\u591a\u8d26\u6237\u6a21\u5f0f\u4e0b, \u9700\u8981\u6307\u5b9a\u8d26\u6237\u5b9e\u4f8b account')\n    TIME_CELL = 60\n    HISTORY_DAY_LENGTH = 10\n    if duration % TIME_CELL or duration < 60:\n        raise Exception(f'duration {duration} \u53c2\u6570\u5e94\u8be5\u4e3a {TIME_CELL} \u7684\u6574\u6570\u500d')\n    pos = account.get_position(symbol)\n    target_pos = int(target_pos)\n    delta_pos = target_pos - pos.pos\n    target_volume = abs(delta_pos)\n    if target_volume == 0:\n        return DataFrame(columns=['interval', 'target_pos', 'price'])\n    klines = api.get_kline_serial(symbol, TIME_CELL, data_length=int(10 * 60 * 60 / TIME_CELL * HISTORY_DAY_LENGTH))\n    klines['time'] = klines.datetime.apply(lambda x: datetime.fromtimestamp(x // 1000000000).time())\n    klines['date'] = klines.datetime.apply(lambda x: datetime.fromtimestamp(_get_trading_day_from_timestamp(x) // 1000000000).date())\n    quote = api.get_quote(symbol)\n    trading_timestamp = _get_trading_timestamp(quote, quote.datetime)\n    trading_timestamp_nano_range = trading_timestamp['night'] + trading_timestamp['day']\n    current_timestamp_nano = _get_trade_timestamp(quote.datetime, float('nan'))\n    if not trading_timestamp_nano_range[0][0] <= current_timestamp_nano < trading_timestamp_nano_range[-1][1]:\n        raise Exception('\u5f53\u524d\u65f6\u95f4\u4e0d\u5728\u6307\u5b9a\u7684\u4ea4\u6613\u65f6\u95f4\u6bb5\u5185')\n    current_datetime = datetime.fromtimestamp(current_timestamp_nano // 1000000000)\n    next_datetime = current_datetime.replace(second=0) + timedelta(minutes=1)\n    start_datetime_nano = _datetime_to_timestamp_nano(next_datetime)\n    r = _rangeset_head(_rangeset_slice(trading_timestamp_nano_range, start_datetime_nano), int(duration * 1000000000.0))\n    if not (r and trading_timestamp_nano_range[0][0] <= r[-1][-1] < trading_timestamp_nano_range[-1][1]):\n        raise Exception('\u6307\u5b9a\u65f6\u95f4\u6bb5\u8d85\u51fa\u5f53\u524d\u4ea4\u6613\u65e5')\n    start_datetime = datetime.fromtimestamp(start_datetime_nano // 1000000000)\n    end_datetime = datetime.fromtimestamp((r[-1][-1] - 1) // 1000000000)\n    time_slot_start = time(start_datetime.hour, start_datetime.minute)\n    time_slot_end = time(end_datetime.hour, end_datetime.minute)\n    if time_slot_end > time_slot_start:\n        klines = klines[(klines['time'] >= time_slot_start) & (klines['time'] <= time_slot_end)]\n    else:\n        klines = klines[(klines['time'] >= time_slot_start) | (klines['time'] <= time_slot_end)]\n    need_date = klines['date'].drop_duplicates()[-HISTORY_DAY_LENGTH:]\n    klines = klines[klines['date'].isin(need_date)]\n    grouped_datetime = klines.groupby(['date', 'time'])['volume'].sum()\n    volume_percent = grouped_datetime / grouped_datetime.groupby(level=0).sum()\n    predicted_percent = volume_percent.groupby(level=1).mean()\n    time_table = DataFrame(columns=['interval', 'volume', 'price'])\n    volume_left = target_volume\n    percent_left = 1\n    for (index, value) in predicted_percent.items():\n        volume = round(volume_left * (value / percent_left))\n        volume_left -= volume\n        percent_left -= value\n        append_time_table = pd.DataFrame([{'interval': TIME_CELL - 2, 'volume': volume, 'price': 'PASSIVE'}, {'interval': 2, 'volume': 0, 'price': 'ACTIVE'}])\n        time_table = pd.concat([time_table, append_time_table], ignore_index=True)\n    time_table['volume'] = time_table['volume'].mul(np.sign(delta_pos))\n    time_table['target_pos'] = time_table['volume'].cumsum()\n    time_table['target_pos'] = time_table['target_pos'].add(pos.pos)\n    time_table.drop(columns=['volume'], inplace=True)\n    time_table = time_table.astype({'target_pos': 'int64', 'interval': 'float64'})\n    return time_table",
            "def vwap_table(api: TqApi, symbol: str, target_pos: int, duration: float, account: Optional[Union[TqAccount, TqKq, TqSim]]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    \u8fd4\u56de\u57fa\u4e8e vwap \u7b56\u7565\u7684\u8ba1\u5212\u4efb\u52a1\u65f6\u95f4\u8868\u3002\u4e0b\u5355\u9700\u8981\u914d\u5408 TargetPosScheduler \u4f7f\u7528\u3002\\n\\n    \u8c03\u7528 vwap_table \u51fd\u6570\uff0c\u6839\u636e\u4ee5\u4e0b\u903b\u8f91\u751f\u6210 time_table\uff1a\\n\\n    1. \u6839\u636e target_pos - \u5f53\u524d\u5408\u7ea6\u7684\u51c0\u6301\u4ed3\uff0c\u5f97\u5230\u603b\u7684\u9700\u8981\u8c03\u6574\u624b\u6570\\n    2. \u8bf7\u6c42 symbol \u5408\u7ea6\u7684 ``1min`` K \u7ebf\\n    3. \u91c7\u6837\u53d6\u7528\u6700\u8fd1 10 \u65e5\u5185\uff0c\u4ee5\u5408\u7ea6\u5f53\u524d\u884c\u60c5\u65f6\u95f4\u7684\u4e0b\u4e00\u5206\u949f\u4e3a\u8d77\u70b9\uff0c\u6bcf\u65e5 duration / 60 \u6839 K \u7ebf,     \u4f8b\u5982\u5f53\u524d\u5408\u7ea6\u65f6\u95f4\u4e3a 14:35:35\uff0c\u90a3\u4e48\u91c7\u6837\u662f\u4f1a\u4f7f\u7528 14:36:00 \u5f00\u59cb\u7684\u5206\u949f\u7ebf K \u7ebf\\n    4. \u6309\u65e5\u671f\u5206\u7ec4\uff0c\u5206\u522b\u8ba1\u7b97\u4ea4\u6613\u65e5\u5185\uff0c\u6bcf\u6839 K \u7ebf\u6210\u4ea4\u91cf\u5360\u603b\u6210\u4ea4\u91cf\u7684\u6bd4\u4f8b\\n    5. \u8ba1\u7b97\u6700\u8fd1 10 \u65e5\u5185\u76f8\u540c\u5206\u949f\u5185\u7684\u6210\u4ea4\u91cf\u5360\u6bd4\u7684\u7b97\u672f\u5e73\u5747\u6570\uff0c\u5c06\u7b2c 1 \u6b65\u5f97\u5230\u7684\u603b\u8c03\u6574\u624b\u6570\u6309\u7167\u5f97\u5230\u7684\u6bd4\u4f8b\u5206\u914d\\n    6. \u6bcf\u4e00\u5206\u949f\uff0c\u524d 58s \u4ee5\u8ffd\u52a0\u4ef7\u683c\u4e0b\u5355\uff0c\u540e 2s \u4ee5\u5bf9\u4ef7\u4ef7\u683c\u4e0b\u5355\\n\\n    Args:\\n        api (TqApi): TqApi\u5b9e\u4f8b\uff0c\u8be5task\u4f9d\u6258\u4e8e\u6307\u5b9aapi\u4e0b\u5355/\u64a4\u5355\\n\\n        symbol (str): \u62df\u4e0b\u5355\u7684\u5408\u7ea6 symbol, \u683c\u5f0f\u4e3a \u4ea4\u6613\u6240\u4ee3\u7801.\u5408\u7ea6\u4ee3\u7801,  \u4f8b\u5982 \"SHFE.cu2201\"\\n\\n        target_pos (int): \u76ee\u6807\u6301\u4ed3\u624b\u6570\\n\\n        duration (int): \u7b97\u6cd5\u6267\u884c\u7684\u65f6\u957f\uff0c\u4ee5\u79d2\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u662f 60 \u7684\u6574\u6570\u500d\uff0c\u65f6\u957f\u53ef\u4ee5\u8de8\u975e\u4ea4\u6613\u65f6\u95f4\u6bb5\uff0c\u4f46\u662f\u4e0d\u53ef\u4ee5\u8de8\u4ea4\u6613\u65e5\\n        * \u8bbe\u7f6e\u4e3a 60*10, \u53ef\u4ee5\u662f 10:10\uff5e10:15 + 10:30~10:35\\n\\n        account (TqAccount/TqKq/TqSim): [\u53ef\u9009]\u6307\u5b9a\u53d1\u9001\u4e0b\u5355\u6307\u4ee4\u7684\u8d26\u6237\u5b9e\u4f8b, \u591a\u8d26\u6237\u6a21\u5f0f\u4e0b\uff0c\u8be5\u53c2\u6570\u5fc5\u987b\u6307\u5b9a\\n\\n    Returns:\\n        pandas.DataFrame: \u672c\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a pandas.DataFrame \u5b9e\u4f8b. \u8868\u793a\u4e00\u4efd\u8ba1\u5212\u4efb\u52a1\u65f6\u95f4\u8868\u3002\u6bcf\u4e00\u884c\u8868\u793a\u4e00\u9879\u76ee\u6807\u6301\u4ed3\u4efb\u52a1\uff0c\u5305\u542b\u4ee5\u4e0b\u5217:\\n\\n            + interval: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u6301\u7eed\u65f6\u95f4\u957f\u5ea6\uff0c\u5355\u4f4d\u4e3a\u79d2\\n            + target_pos: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u76ee\u6807\u6301\u4ed3\\n            + price: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u4e0b\u5355\u4ef7\u683c\u6a21\u5f0f\uff0c\u652f\u6301 PASSIVE\uff08\u6392\u961f\u4ef7\uff09\uff0cACTIVE\uff08\u5bf9\u4ef7\uff09\uff0cNone\uff08\u4e0d\u4e0b\u5355\uff0c\u8868\u793a\u6682\u505c\u4e00\u6bb5\u65f6\u95f4\uff09\\n\\n    Example1::\\n\\n        from tqsdk import TqApi, TargetPosScheduler\\n        from tqsdk.algorithm import vwap_table\\n\\n        api = TqApi(auth=\"\u5feb\u671f\u8d26\u6237,\u7528\u6237\u5bc6\u7801\")\\n        quote = api.get_quote(\"CZCE.MA109\")\\n\\n        # \u8bbe\u7f6e vwap \u4efb\u52a1\u53c2\u6570\\n        time_table = vwap_table(api, \"CZCE.MA109\", -100, 600)  # \u76ee\u6807\u6301\u4ed3 -100 \u624b\uff0c600s \u5185\u5b8c\u6210\\n        print(time_table.to_string())\\n\\n        target_pos_sch = TargetPosScheduler(api, \"CZCE.MA109\", time_table)\\n        # \u542f\u52a8\u5faa\u73af\\n        while not target_pos_sch.is_finished():\\n            api.wait_update()\\n        api.close()\\n\\n\\n    '\n    account = api._account._check_valid(account)\n    if account is None:\n        raise Exception(f'\u591a\u8d26\u6237\u6a21\u5f0f\u4e0b, \u9700\u8981\u6307\u5b9a\u8d26\u6237\u5b9e\u4f8b account')\n    TIME_CELL = 60\n    HISTORY_DAY_LENGTH = 10\n    if duration % TIME_CELL or duration < 60:\n        raise Exception(f'duration {duration} \u53c2\u6570\u5e94\u8be5\u4e3a {TIME_CELL} \u7684\u6574\u6570\u500d')\n    pos = account.get_position(symbol)\n    target_pos = int(target_pos)\n    delta_pos = target_pos - pos.pos\n    target_volume = abs(delta_pos)\n    if target_volume == 0:\n        return DataFrame(columns=['interval', 'target_pos', 'price'])\n    klines = api.get_kline_serial(symbol, TIME_CELL, data_length=int(10 * 60 * 60 / TIME_CELL * HISTORY_DAY_LENGTH))\n    klines['time'] = klines.datetime.apply(lambda x: datetime.fromtimestamp(x // 1000000000).time())\n    klines['date'] = klines.datetime.apply(lambda x: datetime.fromtimestamp(_get_trading_day_from_timestamp(x) // 1000000000).date())\n    quote = api.get_quote(symbol)\n    trading_timestamp = _get_trading_timestamp(quote, quote.datetime)\n    trading_timestamp_nano_range = trading_timestamp['night'] + trading_timestamp['day']\n    current_timestamp_nano = _get_trade_timestamp(quote.datetime, float('nan'))\n    if not trading_timestamp_nano_range[0][0] <= current_timestamp_nano < trading_timestamp_nano_range[-1][1]:\n        raise Exception('\u5f53\u524d\u65f6\u95f4\u4e0d\u5728\u6307\u5b9a\u7684\u4ea4\u6613\u65f6\u95f4\u6bb5\u5185')\n    current_datetime = datetime.fromtimestamp(current_timestamp_nano // 1000000000)\n    next_datetime = current_datetime.replace(second=0) + timedelta(minutes=1)\n    start_datetime_nano = _datetime_to_timestamp_nano(next_datetime)\n    r = _rangeset_head(_rangeset_slice(trading_timestamp_nano_range, start_datetime_nano), int(duration * 1000000000.0))\n    if not (r and trading_timestamp_nano_range[0][0] <= r[-1][-1] < trading_timestamp_nano_range[-1][1]):\n        raise Exception('\u6307\u5b9a\u65f6\u95f4\u6bb5\u8d85\u51fa\u5f53\u524d\u4ea4\u6613\u65e5')\n    start_datetime = datetime.fromtimestamp(start_datetime_nano // 1000000000)\n    end_datetime = datetime.fromtimestamp((r[-1][-1] - 1) // 1000000000)\n    time_slot_start = time(start_datetime.hour, start_datetime.minute)\n    time_slot_end = time(end_datetime.hour, end_datetime.minute)\n    if time_slot_end > time_slot_start:\n        klines = klines[(klines['time'] >= time_slot_start) & (klines['time'] <= time_slot_end)]\n    else:\n        klines = klines[(klines['time'] >= time_slot_start) | (klines['time'] <= time_slot_end)]\n    need_date = klines['date'].drop_duplicates()[-HISTORY_DAY_LENGTH:]\n    klines = klines[klines['date'].isin(need_date)]\n    grouped_datetime = klines.groupby(['date', 'time'])['volume'].sum()\n    volume_percent = grouped_datetime / grouped_datetime.groupby(level=0).sum()\n    predicted_percent = volume_percent.groupby(level=1).mean()\n    time_table = DataFrame(columns=['interval', 'volume', 'price'])\n    volume_left = target_volume\n    percent_left = 1\n    for (index, value) in predicted_percent.items():\n        volume = round(volume_left * (value / percent_left))\n        volume_left -= volume\n        percent_left -= value\n        append_time_table = pd.DataFrame([{'interval': TIME_CELL - 2, 'volume': volume, 'price': 'PASSIVE'}, {'interval': 2, 'volume': 0, 'price': 'ACTIVE'}])\n        time_table = pd.concat([time_table, append_time_table], ignore_index=True)\n    time_table['volume'] = time_table['volume'].mul(np.sign(delta_pos))\n    time_table['target_pos'] = time_table['volume'].cumsum()\n    time_table['target_pos'] = time_table['target_pos'].add(pos.pos)\n    time_table.drop(columns=['volume'], inplace=True)\n    time_table = time_table.astype({'target_pos': 'int64', 'interval': 'float64'})\n    return time_table",
            "def vwap_table(api: TqApi, symbol: str, target_pos: int, duration: float, account: Optional[Union[TqAccount, TqKq, TqSim]]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    \u8fd4\u56de\u57fa\u4e8e vwap \u7b56\u7565\u7684\u8ba1\u5212\u4efb\u52a1\u65f6\u95f4\u8868\u3002\u4e0b\u5355\u9700\u8981\u914d\u5408 TargetPosScheduler \u4f7f\u7528\u3002\\n\\n    \u8c03\u7528 vwap_table \u51fd\u6570\uff0c\u6839\u636e\u4ee5\u4e0b\u903b\u8f91\u751f\u6210 time_table\uff1a\\n\\n    1. \u6839\u636e target_pos - \u5f53\u524d\u5408\u7ea6\u7684\u51c0\u6301\u4ed3\uff0c\u5f97\u5230\u603b\u7684\u9700\u8981\u8c03\u6574\u624b\u6570\\n    2. \u8bf7\u6c42 symbol \u5408\u7ea6\u7684 ``1min`` K \u7ebf\\n    3. \u91c7\u6837\u53d6\u7528\u6700\u8fd1 10 \u65e5\u5185\uff0c\u4ee5\u5408\u7ea6\u5f53\u524d\u884c\u60c5\u65f6\u95f4\u7684\u4e0b\u4e00\u5206\u949f\u4e3a\u8d77\u70b9\uff0c\u6bcf\u65e5 duration / 60 \u6839 K \u7ebf,     \u4f8b\u5982\u5f53\u524d\u5408\u7ea6\u65f6\u95f4\u4e3a 14:35:35\uff0c\u90a3\u4e48\u91c7\u6837\u662f\u4f1a\u4f7f\u7528 14:36:00 \u5f00\u59cb\u7684\u5206\u949f\u7ebf K \u7ebf\\n    4. \u6309\u65e5\u671f\u5206\u7ec4\uff0c\u5206\u522b\u8ba1\u7b97\u4ea4\u6613\u65e5\u5185\uff0c\u6bcf\u6839 K \u7ebf\u6210\u4ea4\u91cf\u5360\u603b\u6210\u4ea4\u91cf\u7684\u6bd4\u4f8b\\n    5. \u8ba1\u7b97\u6700\u8fd1 10 \u65e5\u5185\u76f8\u540c\u5206\u949f\u5185\u7684\u6210\u4ea4\u91cf\u5360\u6bd4\u7684\u7b97\u672f\u5e73\u5747\u6570\uff0c\u5c06\u7b2c 1 \u6b65\u5f97\u5230\u7684\u603b\u8c03\u6574\u624b\u6570\u6309\u7167\u5f97\u5230\u7684\u6bd4\u4f8b\u5206\u914d\\n    6. \u6bcf\u4e00\u5206\u949f\uff0c\u524d 58s \u4ee5\u8ffd\u52a0\u4ef7\u683c\u4e0b\u5355\uff0c\u540e 2s \u4ee5\u5bf9\u4ef7\u4ef7\u683c\u4e0b\u5355\\n\\n    Args:\\n        api (TqApi): TqApi\u5b9e\u4f8b\uff0c\u8be5task\u4f9d\u6258\u4e8e\u6307\u5b9aapi\u4e0b\u5355/\u64a4\u5355\\n\\n        symbol (str): \u62df\u4e0b\u5355\u7684\u5408\u7ea6 symbol, \u683c\u5f0f\u4e3a \u4ea4\u6613\u6240\u4ee3\u7801.\u5408\u7ea6\u4ee3\u7801,  \u4f8b\u5982 \"SHFE.cu2201\"\\n\\n        target_pos (int): \u76ee\u6807\u6301\u4ed3\u624b\u6570\\n\\n        duration (int): \u7b97\u6cd5\u6267\u884c\u7684\u65f6\u957f\uff0c\u4ee5\u79d2\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u662f 60 \u7684\u6574\u6570\u500d\uff0c\u65f6\u957f\u53ef\u4ee5\u8de8\u975e\u4ea4\u6613\u65f6\u95f4\u6bb5\uff0c\u4f46\u662f\u4e0d\u53ef\u4ee5\u8de8\u4ea4\u6613\u65e5\\n        * \u8bbe\u7f6e\u4e3a 60*10, \u53ef\u4ee5\u662f 10:10\uff5e10:15 + 10:30~10:35\\n\\n        account (TqAccount/TqKq/TqSim): [\u53ef\u9009]\u6307\u5b9a\u53d1\u9001\u4e0b\u5355\u6307\u4ee4\u7684\u8d26\u6237\u5b9e\u4f8b, \u591a\u8d26\u6237\u6a21\u5f0f\u4e0b\uff0c\u8be5\u53c2\u6570\u5fc5\u987b\u6307\u5b9a\\n\\n    Returns:\\n        pandas.DataFrame: \u672c\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a pandas.DataFrame \u5b9e\u4f8b. \u8868\u793a\u4e00\u4efd\u8ba1\u5212\u4efb\u52a1\u65f6\u95f4\u8868\u3002\u6bcf\u4e00\u884c\u8868\u793a\u4e00\u9879\u76ee\u6807\u6301\u4ed3\u4efb\u52a1\uff0c\u5305\u542b\u4ee5\u4e0b\u5217:\\n\\n            + interval: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u6301\u7eed\u65f6\u95f4\u957f\u5ea6\uff0c\u5355\u4f4d\u4e3a\u79d2\\n            + target_pos: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u76ee\u6807\u6301\u4ed3\\n            + price: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u4e0b\u5355\u4ef7\u683c\u6a21\u5f0f\uff0c\u652f\u6301 PASSIVE\uff08\u6392\u961f\u4ef7\uff09\uff0cACTIVE\uff08\u5bf9\u4ef7\uff09\uff0cNone\uff08\u4e0d\u4e0b\u5355\uff0c\u8868\u793a\u6682\u505c\u4e00\u6bb5\u65f6\u95f4\uff09\\n\\n    Example1::\\n\\n        from tqsdk import TqApi, TargetPosScheduler\\n        from tqsdk.algorithm import vwap_table\\n\\n        api = TqApi(auth=\"\u5feb\u671f\u8d26\u6237,\u7528\u6237\u5bc6\u7801\")\\n        quote = api.get_quote(\"CZCE.MA109\")\\n\\n        # \u8bbe\u7f6e vwap \u4efb\u52a1\u53c2\u6570\\n        time_table = vwap_table(api, \"CZCE.MA109\", -100, 600)  # \u76ee\u6807\u6301\u4ed3 -100 \u624b\uff0c600s \u5185\u5b8c\u6210\\n        print(time_table.to_string())\\n\\n        target_pos_sch = TargetPosScheduler(api, \"CZCE.MA109\", time_table)\\n        # \u542f\u52a8\u5faa\u73af\\n        while not target_pos_sch.is_finished():\\n            api.wait_update()\\n        api.close()\\n\\n\\n    '\n    account = api._account._check_valid(account)\n    if account is None:\n        raise Exception(f'\u591a\u8d26\u6237\u6a21\u5f0f\u4e0b, \u9700\u8981\u6307\u5b9a\u8d26\u6237\u5b9e\u4f8b account')\n    TIME_CELL = 60\n    HISTORY_DAY_LENGTH = 10\n    if duration % TIME_CELL or duration < 60:\n        raise Exception(f'duration {duration} \u53c2\u6570\u5e94\u8be5\u4e3a {TIME_CELL} \u7684\u6574\u6570\u500d')\n    pos = account.get_position(symbol)\n    target_pos = int(target_pos)\n    delta_pos = target_pos - pos.pos\n    target_volume = abs(delta_pos)\n    if target_volume == 0:\n        return DataFrame(columns=['interval', 'target_pos', 'price'])\n    klines = api.get_kline_serial(symbol, TIME_CELL, data_length=int(10 * 60 * 60 / TIME_CELL * HISTORY_DAY_LENGTH))\n    klines['time'] = klines.datetime.apply(lambda x: datetime.fromtimestamp(x // 1000000000).time())\n    klines['date'] = klines.datetime.apply(lambda x: datetime.fromtimestamp(_get_trading_day_from_timestamp(x) // 1000000000).date())\n    quote = api.get_quote(symbol)\n    trading_timestamp = _get_trading_timestamp(quote, quote.datetime)\n    trading_timestamp_nano_range = trading_timestamp['night'] + trading_timestamp['day']\n    current_timestamp_nano = _get_trade_timestamp(quote.datetime, float('nan'))\n    if not trading_timestamp_nano_range[0][0] <= current_timestamp_nano < trading_timestamp_nano_range[-1][1]:\n        raise Exception('\u5f53\u524d\u65f6\u95f4\u4e0d\u5728\u6307\u5b9a\u7684\u4ea4\u6613\u65f6\u95f4\u6bb5\u5185')\n    current_datetime = datetime.fromtimestamp(current_timestamp_nano // 1000000000)\n    next_datetime = current_datetime.replace(second=0) + timedelta(minutes=1)\n    start_datetime_nano = _datetime_to_timestamp_nano(next_datetime)\n    r = _rangeset_head(_rangeset_slice(trading_timestamp_nano_range, start_datetime_nano), int(duration * 1000000000.0))\n    if not (r and trading_timestamp_nano_range[0][0] <= r[-1][-1] < trading_timestamp_nano_range[-1][1]):\n        raise Exception('\u6307\u5b9a\u65f6\u95f4\u6bb5\u8d85\u51fa\u5f53\u524d\u4ea4\u6613\u65e5')\n    start_datetime = datetime.fromtimestamp(start_datetime_nano // 1000000000)\n    end_datetime = datetime.fromtimestamp((r[-1][-1] - 1) // 1000000000)\n    time_slot_start = time(start_datetime.hour, start_datetime.minute)\n    time_slot_end = time(end_datetime.hour, end_datetime.minute)\n    if time_slot_end > time_slot_start:\n        klines = klines[(klines['time'] >= time_slot_start) & (klines['time'] <= time_slot_end)]\n    else:\n        klines = klines[(klines['time'] >= time_slot_start) | (klines['time'] <= time_slot_end)]\n    need_date = klines['date'].drop_duplicates()[-HISTORY_DAY_LENGTH:]\n    klines = klines[klines['date'].isin(need_date)]\n    grouped_datetime = klines.groupby(['date', 'time'])['volume'].sum()\n    volume_percent = grouped_datetime / grouped_datetime.groupby(level=0).sum()\n    predicted_percent = volume_percent.groupby(level=1).mean()\n    time_table = DataFrame(columns=['interval', 'volume', 'price'])\n    volume_left = target_volume\n    percent_left = 1\n    for (index, value) in predicted_percent.items():\n        volume = round(volume_left * (value / percent_left))\n        volume_left -= volume\n        percent_left -= value\n        append_time_table = pd.DataFrame([{'interval': TIME_CELL - 2, 'volume': volume, 'price': 'PASSIVE'}, {'interval': 2, 'volume': 0, 'price': 'ACTIVE'}])\n        time_table = pd.concat([time_table, append_time_table], ignore_index=True)\n    time_table['volume'] = time_table['volume'].mul(np.sign(delta_pos))\n    time_table['target_pos'] = time_table['volume'].cumsum()\n    time_table['target_pos'] = time_table['target_pos'].add(pos.pos)\n    time_table.drop(columns=['volume'], inplace=True)\n    time_table = time_table.astype({'target_pos': 'int64', 'interval': 'float64'})\n    return time_table",
            "def vwap_table(api: TqApi, symbol: str, target_pos: int, duration: float, account: Optional[Union[TqAccount, TqKq, TqSim]]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    \u8fd4\u56de\u57fa\u4e8e vwap \u7b56\u7565\u7684\u8ba1\u5212\u4efb\u52a1\u65f6\u95f4\u8868\u3002\u4e0b\u5355\u9700\u8981\u914d\u5408 TargetPosScheduler \u4f7f\u7528\u3002\\n\\n    \u8c03\u7528 vwap_table \u51fd\u6570\uff0c\u6839\u636e\u4ee5\u4e0b\u903b\u8f91\u751f\u6210 time_table\uff1a\\n\\n    1. \u6839\u636e target_pos - \u5f53\u524d\u5408\u7ea6\u7684\u51c0\u6301\u4ed3\uff0c\u5f97\u5230\u603b\u7684\u9700\u8981\u8c03\u6574\u624b\u6570\\n    2. \u8bf7\u6c42 symbol \u5408\u7ea6\u7684 ``1min`` K \u7ebf\\n    3. \u91c7\u6837\u53d6\u7528\u6700\u8fd1 10 \u65e5\u5185\uff0c\u4ee5\u5408\u7ea6\u5f53\u524d\u884c\u60c5\u65f6\u95f4\u7684\u4e0b\u4e00\u5206\u949f\u4e3a\u8d77\u70b9\uff0c\u6bcf\u65e5 duration / 60 \u6839 K \u7ebf,     \u4f8b\u5982\u5f53\u524d\u5408\u7ea6\u65f6\u95f4\u4e3a 14:35:35\uff0c\u90a3\u4e48\u91c7\u6837\u662f\u4f1a\u4f7f\u7528 14:36:00 \u5f00\u59cb\u7684\u5206\u949f\u7ebf K \u7ebf\\n    4. \u6309\u65e5\u671f\u5206\u7ec4\uff0c\u5206\u522b\u8ba1\u7b97\u4ea4\u6613\u65e5\u5185\uff0c\u6bcf\u6839 K \u7ebf\u6210\u4ea4\u91cf\u5360\u603b\u6210\u4ea4\u91cf\u7684\u6bd4\u4f8b\\n    5. \u8ba1\u7b97\u6700\u8fd1 10 \u65e5\u5185\u76f8\u540c\u5206\u949f\u5185\u7684\u6210\u4ea4\u91cf\u5360\u6bd4\u7684\u7b97\u672f\u5e73\u5747\u6570\uff0c\u5c06\u7b2c 1 \u6b65\u5f97\u5230\u7684\u603b\u8c03\u6574\u624b\u6570\u6309\u7167\u5f97\u5230\u7684\u6bd4\u4f8b\u5206\u914d\\n    6. \u6bcf\u4e00\u5206\u949f\uff0c\u524d 58s \u4ee5\u8ffd\u52a0\u4ef7\u683c\u4e0b\u5355\uff0c\u540e 2s \u4ee5\u5bf9\u4ef7\u4ef7\u683c\u4e0b\u5355\\n\\n    Args:\\n        api (TqApi): TqApi\u5b9e\u4f8b\uff0c\u8be5task\u4f9d\u6258\u4e8e\u6307\u5b9aapi\u4e0b\u5355/\u64a4\u5355\\n\\n        symbol (str): \u62df\u4e0b\u5355\u7684\u5408\u7ea6 symbol, \u683c\u5f0f\u4e3a \u4ea4\u6613\u6240\u4ee3\u7801.\u5408\u7ea6\u4ee3\u7801,  \u4f8b\u5982 \"SHFE.cu2201\"\\n\\n        target_pos (int): \u76ee\u6807\u6301\u4ed3\u624b\u6570\\n\\n        duration (int): \u7b97\u6cd5\u6267\u884c\u7684\u65f6\u957f\uff0c\u4ee5\u79d2\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u662f 60 \u7684\u6574\u6570\u500d\uff0c\u65f6\u957f\u53ef\u4ee5\u8de8\u975e\u4ea4\u6613\u65f6\u95f4\u6bb5\uff0c\u4f46\u662f\u4e0d\u53ef\u4ee5\u8de8\u4ea4\u6613\u65e5\\n        * \u8bbe\u7f6e\u4e3a 60*10, \u53ef\u4ee5\u662f 10:10\uff5e10:15 + 10:30~10:35\\n\\n        account (TqAccount/TqKq/TqSim): [\u53ef\u9009]\u6307\u5b9a\u53d1\u9001\u4e0b\u5355\u6307\u4ee4\u7684\u8d26\u6237\u5b9e\u4f8b, \u591a\u8d26\u6237\u6a21\u5f0f\u4e0b\uff0c\u8be5\u53c2\u6570\u5fc5\u987b\u6307\u5b9a\\n\\n    Returns:\\n        pandas.DataFrame: \u672c\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a pandas.DataFrame \u5b9e\u4f8b. \u8868\u793a\u4e00\u4efd\u8ba1\u5212\u4efb\u52a1\u65f6\u95f4\u8868\u3002\u6bcf\u4e00\u884c\u8868\u793a\u4e00\u9879\u76ee\u6807\u6301\u4ed3\u4efb\u52a1\uff0c\u5305\u542b\u4ee5\u4e0b\u5217:\\n\\n            + interval: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u6301\u7eed\u65f6\u95f4\u957f\u5ea6\uff0c\u5355\u4f4d\u4e3a\u79d2\\n            + target_pos: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u76ee\u6807\u6301\u4ed3\\n            + price: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u4e0b\u5355\u4ef7\u683c\u6a21\u5f0f\uff0c\u652f\u6301 PASSIVE\uff08\u6392\u961f\u4ef7\uff09\uff0cACTIVE\uff08\u5bf9\u4ef7\uff09\uff0cNone\uff08\u4e0d\u4e0b\u5355\uff0c\u8868\u793a\u6682\u505c\u4e00\u6bb5\u65f6\u95f4\uff09\\n\\n    Example1::\\n\\n        from tqsdk import TqApi, TargetPosScheduler\\n        from tqsdk.algorithm import vwap_table\\n\\n        api = TqApi(auth=\"\u5feb\u671f\u8d26\u6237,\u7528\u6237\u5bc6\u7801\")\\n        quote = api.get_quote(\"CZCE.MA109\")\\n\\n        # \u8bbe\u7f6e vwap \u4efb\u52a1\u53c2\u6570\\n        time_table = vwap_table(api, \"CZCE.MA109\", -100, 600)  # \u76ee\u6807\u6301\u4ed3 -100 \u624b\uff0c600s \u5185\u5b8c\u6210\\n        print(time_table.to_string())\\n\\n        target_pos_sch = TargetPosScheduler(api, \"CZCE.MA109\", time_table)\\n        # \u542f\u52a8\u5faa\u73af\\n        while not target_pos_sch.is_finished():\\n            api.wait_update()\\n        api.close()\\n\\n\\n    '\n    account = api._account._check_valid(account)\n    if account is None:\n        raise Exception(f'\u591a\u8d26\u6237\u6a21\u5f0f\u4e0b, \u9700\u8981\u6307\u5b9a\u8d26\u6237\u5b9e\u4f8b account')\n    TIME_CELL = 60\n    HISTORY_DAY_LENGTH = 10\n    if duration % TIME_CELL or duration < 60:\n        raise Exception(f'duration {duration} \u53c2\u6570\u5e94\u8be5\u4e3a {TIME_CELL} \u7684\u6574\u6570\u500d')\n    pos = account.get_position(symbol)\n    target_pos = int(target_pos)\n    delta_pos = target_pos - pos.pos\n    target_volume = abs(delta_pos)\n    if target_volume == 0:\n        return DataFrame(columns=['interval', 'target_pos', 'price'])\n    klines = api.get_kline_serial(symbol, TIME_CELL, data_length=int(10 * 60 * 60 / TIME_CELL * HISTORY_DAY_LENGTH))\n    klines['time'] = klines.datetime.apply(lambda x: datetime.fromtimestamp(x // 1000000000).time())\n    klines['date'] = klines.datetime.apply(lambda x: datetime.fromtimestamp(_get_trading_day_from_timestamp(x) // 1000000000).date())\n    quote = api.get_quote(symbol)\n    trading_timestamp = _get_trading_timestamp(quote, quote.datetime)\n    trading_timestamp_nano_range = trading_timestamp['night'] + trading_timestamp['day']\n    current_timestamp_nano = _get_trade_timestamp(quote.datetime, float('nan'))\n    if not trading_timestamp_nano_range[0][0] <= current_timestamp_nano < trading_timestamp_nano_range[-1][1]:\n        raise Exception('\u5f53\u524d\u65f6\u95f4\u4e0d\u5728\u6307\u5b9a\u7684\u4ea4\u6613\u65f6\u95f4\u6bb5\u5185')\n    current_datetime = datetime.fromtimestamp(current_timestamp_nano // 1000000000)\n    next_datetime = current_datetime.replace(second=0) + timedelta(minutes=1)\n    start_datetime_nano = _datetime_to_timestamp_nano(next_datetime)\n    r = _rangeset_head(_rangeset_slice(trading_timestamp_nano_range, start_datetime_nano), int(duration * 1000000000.0))\n    if not (r and trading_timestamp_nano_range[0][0] <= r[-1][-1] < trading_timestamp_nano_range[-1][1]):\n        raise Exception('\u6307\u5b9a\u65f6\u95f4\u6bb5\u8d85\u51fa\u5f53\u524d\u4ea4\u6613\u65e5')\n    start_datetime = datetime.fromtimestamp(start_datetime_nano // 1000000000)\n    end_datetime = datetime.fromtimestamp((r[-1][-1] - 1) // 1000000000)\n    time_slot_start = time(start_datetime.hour, start_datetime.minute)\n    time_slot_end = time(end_datetime.hour, end_datetime.minute)\n    if time_slot_end > time_slot_start:\n        klines = klines[(klines['time'] >= time_slot_start) & (klines['time'] <= time_slot_end)]\n    else:\n        klines = klines[(klines['time'] >= time_slot_start) | (klines['time'] <= time_slot_end)]\n    need_date = klines['date'].drop_duplicates()[-HISTORY_DAY_LENGTH:]\n    klines = klines[klines['date'].isin(need_date)]\n    grouped_datetime = klines.groupby(['date', 'time'])['volume'].sum()\n    volume_percent = grouped_datetime / grouped_datetime.groupby(level=0).sum()\n    predicted_percent = volume_percent.groupby(level=1).mean()\n    time_table = DataFrame(columns=['interval', 'volume', 'price'])\n    volume_left = target_volume\n    percent_left = 1\n    for (index, value) in predicted_percent.items():\n        volume = round(volume_left * (value / percent_left))\n        volume_left -= volume\n        percent_left -= value\n        append_time_table = pd.DataFrame([{'interval': TIME_CELL - 2, 'volume': volume, 'price': 'PASSIVE'}, {'interval': 2, 'volume': 0, 'price': 'ACTIVE'}])\n        time_table = pd.concat([time_table, append_time_table], ignore_index=True)\n    time_table['volume'] = time_table['volume'].mul(np.sign(delta_pos))\n    time_table['target_pos'] = time_table['volume'].cumsum()\n    time_table['target_pos'] = time_table['target_pos'].add(pos.pos)\n    time_table.drop(columns=['volume'], inplace=True)\n    time_table = time_table.astype({'target_pos': 'int64', 'interval': 'float64'})\n    return time_table",
            "def vwap_table(api: TqApi, symbol: str, target_pos: int, duration: float, account: Optional[Union[TqAccount, TqKq, TqSim]]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    \u8fd4\u56de\u57fa\u4e8e vwap \u7b56\u7565\u7684\u8ba1\u5212\u4efb\u52a1\u65f6\u95f4\u8868\u3002\u4e0b\u5355\u9700\u8981\u914d\u5408 TargetPosScheduler \u4f7f\u7528\u3002\\n\\n    \u8c03\u7528 vwap_table \u51fd\u6570\uff0c\u6839\u636e\u4ee5\u4e0b\u903b\u8f91\u751f\u6210 time_table\uff1a\\n\\n    1. \u6839\u636e target_pos - \u5f53\u524d\u5408\u7ea6\u7684\u51c0\u6301\u4ed3\uff0c\u5f97\u5230\u603b\u7684\u9700\u8981\u8c03\u6574\u624b\u6570\\n    2. \u8bf7\u6c42 symbol \u5408\u7ea6\u7684 ``1min`` K \u7ebf\\n    3. \u91c7\u6837\u53d6\u7528\u6700\u8fd1 10 \u65e5\u5185\uff0c\u4ee5\u5408\u7ea6\u5f53\u524d\u884c\u60c5\u65f6\u95f4\u7684\u4e0b\u4e00\u5206\u949f\u4e3a\u8d77\u70b9\uff0c\u6bcf\u65e5 duration / 60 \u6839 K \u7ebf,     \u4f8b\u5982\u5f53\u524d\u5408\u7ea6\u65f6\u95f4\u4e3a 14:35:35\uff0c\u90a3\u4e48\u91c7\u6837\u662f\u4f1a\u4f7f\u7528 14:36:00 \u5f00\u59cb\u7684\u5206\u949f\u7ebf K \u7ebf\\n    4. \u6309\u65e5\u671f\u5206\u7ec4\uff0c\u5206\u522b\u8ba1\u7b97\u4ea4\u6613\u65e5\u5185\uff0c\u6bcf\u6839 K \u7ebf\u6210\u4ea4\u91cf\u5360\u603b\u6210\u4ea4\u91cf\u7684\u6bd4\u4f8b\\n    5. \u8ba1\u7b97\u6700\u8fd1 10 \u65e5\u5185\u76f8\u540c\u5206\u949f\u5185\u7684\u6210\u4ea4\u91cf\u5360\u6bd4\u7684\u7b97\u672f\u5e73\u5747\u6570\uff0c\u5c06\u7b2c 1 \u6b65\u5f97\u5230\u7684\u603b\u8c03\u6574\u624b\u6570\u6309\u7167\u5f97\u5230\u7684\u6bd4\u4f8b\u5206\u914d\\n    6. \u6bcf\u4e00\u5206\u949f\uff0c\u524d 58s \u4ee5\u8ffd\u52a0\u4ef7\u683c\u4e0b\u5355\uff0c\u540e 2s \u4ee5\u5bf9\u4ef7\u4ef7\u683c\u4e0b\u5355\\n\\n    Args:\\n        api (TqApi): TqApi\u5b9e\u4f8b\uff0c\u8be5task\u4f9d\u6258\u4e8e\u6307\u5b9aapi\u4e0b\u5355/\u64a4\u5355\\n\\n        symbol (str): \u62df\u4e0b\u5355\u7684\u5408\u7ea6 symbol, \u683c\u5f0f\u4e3a \u4ea4\u6613\u6240\u4ee3\u7801.\u5408\u7ea6\u4ee3\u7801,  \u4f8b\u5982 \"SHFE.cu2201\"\\n\\n        target_pos (int): \u76ee\u6807\u6301\u4ed3\u624b\u6570\\n\\n        duration (int): \u7b97\u6cd5\u6267\u884c\u7684\u65f6\u957f\uff0c\u4ee5\u79d2\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u662f 60 \u7684\u6574\u6570\u500d\uff0c\u65f6\u957f\u53ef\u4ee5\u8de8\u975e\u4ea4\u6613\u65f6\u95f4\u6bb5\uff0c\u4f46\u662f\u4e0d\u53ef\u4ee5\u8de8\u4ea4\u6613\u65e5\\n        * \u8bbe\u7f6e\u4e3a 60*10, \u53ef\u4ee5\u662f 10:10\uff5e10:15 + 10:30~10:35\\n\\n        account (TqAccount/TqKq/TqSim): [\u53ef\u9009]\u6307\u5b9a\u53d1\u9001\u4e0b\u5355\u6307\u4ee4\u7684\u8d26\u6237\u5b9e\u4f8b, \u591a\u8d26\u6237\u6a21\u5f0f\u4e0b\uff0c\u8be5\u53c2\u6570\u5fc5\u987b\u6307\u5b9a\\n\\n    Returns:\\n        pandas.DataFrame: \u672c\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a pandas.DataFrame \u5b9e\u4f8b. \u8868\u793a\u4e00\u4efd\u8ba1\u5212\u4efb\u52a1\u65f6\u95f4\u8868\u3002\u6bcf\u4e00\u884c\u8868\u793a\u4e00\u9879\u76ee\u6807\u6301\u4ed3\u4efb\u52a1\uff0c\u5305\u542b\u4ee5\u4e0b\u5217:\\n\\n            + interval: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u6301\u7eed\u65f6\u95f4\u957f\u5ea6\uff0c\u5355\u4f4d\u4e3a\u79d2\\n            + target_pos: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u76ee\u6807\u6301\u4ed3\\n            + price: \u5f53\u524d\u8fd9\u9879\u4efb\u52a1\u7684\u4e0b\u5355\u4ef7\u683c\u6a21\u5f0f\uff0c\u652f\u6301 PASSIVE\uff08\u6392\u961f\u4ef7\uff09\uff0cACTIVE\uff08\u5bf9\u4ef7\uff09\uff0cNone\uff08\u4e0d\u4e0b\u5355\uff0c\u8868\u793a\u6682\u505c\u4e00\u6bb5\u65f6\u95f4\uff09\\n\\n    Example1::\\n\\n        from tqsdk import TqApi, TargetPosScheduler\\n        from tqsdk.algorithm import vwap_table\\n\\n        api = TqApi(auth=\"\u5feb\u671f\u8d26\u6237,\u7528\u6237\u5bc6\u7801\")\\n        quote = api.get_quote(\"CZCE.MA109\")\\n\\n        # \u8bbe\u7f6e vwap \u4efb\u52a1\u53c2\u6570\\n        time_table = vwap_table(api, \"CZCE.MA109\", -100, 600)  # \u76ee\u6807\u6301\u4ed3 -100 \u624b\uff0c600s \u5185\u5b8c\u6210\\n        print(time_table.to_string())\\n\\n        target_pos_sch = TargetPosScheduler(api, \"CZCE.MA109\", time_table)\\n        # \u542f\u52a8\u5faa\u73af\\n        while not target_pos_sch.is_finished():\\n            api.wait_update()\\n        api.close()\\n\\n\\n    '\n    account = api._account._check_valid(account)\n    if account is None:\n        raise Exception(f'\u591a\u8d26\u6237\u6a21\u5f0f\u4e0b, \u9700\u8981\u6307\u5b9a\u8d26\u6237\u5b9e\u4f8b account')\n    TIME_CELL = 60\n    HISTORY_DAY_LENGTH = 10\n    if duration % TIME_CELL or duration < 60:\n        raise Exception(f'duration {duration} \u53c2\u6570\u5e94\u8be5\u4e3a {TIME_CELL} \u7684\u6574\u6570\u500d')\n    pos = account.get_position(symbol)\n    target_pos = int(target_pos)\n    delta_pos = target_pos - pos.pos\n    target_volume = abs(delta_pos)\n    if target_volume == 0:\n        return DataFrame(columns=['interval', 'target_pos', 'price'])\n    klines = api.get_kline_serial(symbol, TIME_CELL, data_length=int(10 * 60 * 60 / TIME_CELL * HISTORY_DAY_LENGTH))\n    klines['time'] = klines.datetime.apply(lambda x: datetime.fromtimestamp(x // 1000000000).time())\n    klines['date'] = klines.datetime.apply(lambda x: datetime.fromtimestamp(_get_trading_day_from_timestamp(x) // 1000000000).date())\n    quote = api.get_quote(symbol)\n    trading_timestamp = _get_trading_timestamp(quote, quote.datetime)\n    trading_timestamp_nano_range = trading_timestamp['night'] + trading_timestamp['day']\n    current_timestamp_nano = _get_trade_timestamp(quote.datetime, float('nan'))\n    if not trading_timestamp_nano_range[0][0] <= current_timestamp_nano < trading_timestamp_nano_range[-1][1]:\n        raise Exception('\u5f53\u524d\u65f6\u95f4\u4e0d\u5728\u6307\u5b9a\u7684\u4ea4\u6613\u65f6\u95f4\u6bb5\u5185')\n    current_datetime = datetime.fromtimestamp(current_timestamp_nano // 1000000000)\n    next_datetime = current_datetime.replace(second=0) + timedelta(minutes=1)\n    start_datetime_nano = _datetime_to_timestamp_nano(next_datetime)\n    r = _rangeset_head(_rangeset_slice(trading_timestamp_nano_range, start_datetime_nano), int(duration * 1000000000.0))\n    if not (r and trading_timestamp_nano_range[0][0] <= r[-1][-1] < trading_timestamp_nano_range[-1][1]):\n        raise Exception('\u6307\u5b9a\u65f6\u95f4\u6bb5\u8d85\u51fa\u5f53\u524d\u4ea4\u6613\u65e5')\n    start_datetime = datetime.fromtimestamp(start_datetime_nano // 1000000000)\n    end_datetime = datetime.fromtimestamp((r[-1][-1] - 1) // 1000000000)\n    time_slot_start = time(start_datetime.hour, start_datetime.minute)\n    time_slot_end = time(end_datetime.hour, end_datetime.minute)\n    if time_slot_end > time_slot_start:\n        klines = klines[(klines['time'] >= time_slot_start) & (klines['time'] <= time_slot_end)]\n    else:\n        klines = klines[(klines['time'] >= time_slot_start) | (klines['time'] <= time_slot_end)]\n    need_date = klines['date'].drop_duplicates()[-HISTORY_DAY_LENGTH:]\n    klines = klines[klines['date'].isin(need_date)]\n    grouped_datetime = klines.groupby(['date', 'time'])['volume'].sum()\n    volume_percent = grouped_datetime / grouped_datetime.groupby(level=0).sum()\n    predicted_percent = volume_percent.groupby(level=1).mean()\n    time_table = DataFrame(columns=['interval', 'volume', 'price'])\n    volume_left = target_volume\n    percent_left = 1\n    for (index, value) in predicted_percent.items():\n        volume = round(volume_left * (value / percent_left))\n        volume_left -= volume\n        percent_left -= value\n        append_time_table = pd.DataFrame([{'interval': TIME_CELL - 2, 'volume': volume, 'price': 'PASSIVE'}, {'interval': 2, 'volume': 0, 'price': 'ACTIVE'}])\n        time_table = pd.concat([time_table, append_time_table], ignore_index=True)\n    time_table['volume'] = time_table['volume'].mul(np.sign(delta_pos))\n    time_table['target_pos'] = time_table['volume'].cumsum()\n    time_table['target_pos'] = time_table['target_pos'].add(pos.pos)\n    time_table.drop(columns=['volume'], inplace=True)\n    time_table = time_table.astype({'target_pos': 'int64', 'interval': 'float64'})\n    return time_table"
        ]
    },
    {
        "func_name": "_gen_random_list",
        "original": "def _gen_random_list(sum_val: int, min_val: int, max_val: int, length: int=None):\n    \"\"\"\n    \u751f\u6210\u968f\u673a\u5217\u8868\uff0c\u53c2\u6570\u5e94\u8be5\u6ee1\u8db3\uff1amin_val * length <= sum_val <= max_val * length\n    :param int sum_val: \u5217\u8868\u5143\u7d20\u4e4b\u548c\n    :param int min_val: \u5217\u8868\u5143\u7d20\u6700\u5c0f\u503c\n    :param int max_val: \u5217\u8868\u5143\u7d20\u6700\u5927\u503c\n    :param int length: \u5217\u8868\u957f\u5ea6\uff0c\u5982\u679c\u6ca1\u6709\u6307\u5b9a\uff0c\u5219\u8fd4\u56de\u7684\u5217\u8868\u957f\u5ea6\u6ca1\u6709\u6307\u5b9a\n    :return: \u6574\u578b\u5217\u8868\uff0c\u6ee1\u8db3 sum(list) = sum_val, len(list) == length, min_val < any_item(list) < max_val\n    \"\"\"\n    if length is None:\n        length = sum_val * 2 // (min_val + max_val)\n        assert min_val * length <= sum_val <= max_val * length + min_val\n    else:\n        assert min_val * length <= sum_val <= max_val * length\n    result_list = [min_val for _ in range(length)]\n    if sum(result_list) == sum_val:\n        return result_list\n    result_rest_value = sum_val - min_val * length\n    result_rest_position = (max_val - min_val) * length\n    if sum_val > max_val * length:\n        result_list.append(0)\n        result_rest_position += min_val\n    result_rest_list = _gen_shuffle_list(result_rest_value, result_rest_position)\n    for i in range(len(result_list)):\n        start = (max_val - min_val) * i\n        end = (max_val - min_val) * (i + 1) if start < (max_val - min_val) * length else result_rest_position\n        result_list[i] += sum(result_rest_list[start:end])\n    assert len(result_list) == length or len(result_list) == length + 1\n    assert sum(result_list) == sum_val\n    return result_list",
        "mutated": [
            "def _gen_random_list(sum_val: int, min_val: int, max_val: int, length: int=None):\n    if False:\n        i = 10\n    '\\n    \u751f\u6210\u968f\u673a\u5217\u8868\uff0c\u53c2\u6570\u5e94\u8be5\u6ee1\u8db3\uff1amin_val * length <= sum_val <= max_val * length\\n    :param int sum_val: \u5217\u8868\u5143\u7d20\u4e4b\u548c\\n    :param int min_val: \u5217\u8868\u5143\u7d20\u6700\u5c0f\u503c\\n    :param int max_val: \u5217\u8868\u5143\u7d20\u6700\u5927\u503c\\n    :param int length: \u5217\u8868\u957f\u5ea6\uff0c\u5982\u679c\u6ca1\u6709\u6307\u5b9a\uff0c\u5219\u8fd4\u56de\u7684\u5217\u8868\u957f\u5ea6\u6ca1\u6709\u6307\u5b9a\\n    :return: \u6574\u578b\u5217\u8868\uff0c\u6ee1\u8db3 sum(list) = sum_val, len(list) == length, min_val < any_item(list) < max_val\\n    '\n    if length is None:\n        length = sum_val * 2 // (min_val + max_val)\n        assert min_val * length <= sum_val <= max_val * length + min_val\n    else:\n        assert min_val * length <= sum_val <= max_val * length\n    result_list = [min_val for _ in range(length)]\n    if sum(result_list) == sum_val:\n        return result_list\n    result_rest_value = sum_val - min_val * length\n    result_rest_position = (max_val - min_val) * length\n    if sum_val > max_val * length:\n        result_list.append(0)\n        result_rest_position += min_val\n    result_rest_list = _gen_shuffle_list(result_rest_value, result_rest_position)\n    for i in range(len(result_list)):\n        start = (max_val - min_val) * i\n        end = (max_val - min_val) * (i + 1) if start < (max_val - min_val) * length else result_rest_position\n        result_list[i] += sum(result_rest_list[start:end])\n    assert len(result_list) == length or len(result_list) == length + 1\n    assert sum(result_list) == sum_val\n    return result_list",
            "def _gen_random_list(sum_val: int, min_val: int, max_val: int, length: int=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    \u751f\u6210\u968f\u673a\u5217\u8868\uff0c\u53c2\u6570\u5e94\u8be5\u6ee1\u8db3\uff1amin_val * length <= sum_val <= max_val * length\\n    :param int sum_val: \u5217\u8868\u5143\u7d20\u4e4b\u548c\\n    :param int min_val: \u5217\u8868\u5143\u7d20\u6700\u5c0f\u503c\\n    :param int max_val: \u5217\u8868\u5143\u7d20\u6700\u5927\u503c\\n    :param int length: \u5217\u8868\u957f\u5ea6\uff0c\u5982\u679c\u6ca1\u6709\u6307\u5b9a\uff0c\u5219\u8fd4\u56de\u7684\u5217\u8868\u957f\u5ea6\u6ca1\u6709\u6307\u5b9a\\n    :return: \u6574\u578b\u5217\u8868\uff0c\u6ee1\u8db3 sum(list) = sum_val, len(list) == length, min_val < any_item(list) < max_val\\n    '\n    if length is None:\n        length = sum_val * 2 // (min_val + max_val)\n        assert min_val * length <= sum_val <= max_val * length + min_val\n    else:\n        assert min_val * length <= sum_val <= max_val * length\n    result_list = [min_val for _ in range(length)]\n    if sum(result_list) == sum_val:\n        return result_list\n    result_rest_value = sum_val - min_val * length\n    result_rest_position = (max_val - min_val) * length\n    if sum_val > max_val * length:\n        result_list.append(0)\n        result_rest_position += min_val\n    result_rest_list = _gen_shuffle_list(result_rest_value, result_rest_position)\n    for i in range(len(result_list)):\n        start = (max_val - min_val) * i\n        end = (max_val - min_val) * (i + 1) if start < (max_val - min_val) * length else result_rest_position\n        result_list[i] += sum(result_rest_list[start:end])\n    assert len(result_list) == length or len(result_list) == length + 1\n    assert sum(result_list) == sum_val\n    return result_list",
            "def _gen_random_list(sum_val: int, min_val: int, max_val: int, length: int=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    \u751f\u6210\u968f\u673a\u5217\u8868\uff0c\u53c2\u6570\u5e94\u8be5\u6ee1\u8db3\uff1amin_val * length <= sum_val <= max_val * length\\n    :param int sum_val: \u5217\u8868\u5143\u7d20\u4e4b\u548c\\n    :param int min_val: \u5217\u8868\u5143\u7d20\u6700\u5c0f\u503c\\n    :param int max_val: \u5217\u8868\u5143\u7d20\u6700\u5927\u503c\\n    :param int length: \u5217\u8868\u957f\u5ea6\uff0c\u5982\u679c\u6ca1\u6709\u6307\u5b9a\uff0c\u5219\u8fd4\u56de\u7684\u5217\u8868\u957f\u5ea6\u6ca1\u6709\u6307\u5b9a\\n    :return: \u6574\u578b\u5217\u8868\uff0c\u6ee1\u8db3 sum(list) = sum_val, len(list) == length, min_val < any_item(list) < max_val\\n    '\n    if length is None:\n        length = sum_val * 2 // (min_val + max_val)\n        assert min_val * length <= sum_val <= max_val * length + min_val\n    else:\n        assert min_val * length <= sum_val <= max_val * length\n    result_list = [min_val for _ in range(length)]\n    if sum(result_list) == sum_val:\n        return result_list\n    result_rest_value = sum_val - min_val * length\n    result_rest_position = (max_val - min_val) * length\n    if sum_val > max_val * length:\n        result_list.append(0)\n        result_rest_position += min_val\n    result_rest_list = _gen_shuffle_list(result_rest_value, result_rest_position)\n    for i in range(len(result_list)):\n        start = (max_val - min_val) * i\n        end = (max_val - min_val) * (i + 1) if start < (max_val - min_val) * length else result_rest_position\n        result_list[i] += sum(result_rest_list[start:end])\n    assert len(result_list) == length or len(result_list) == length + 1\n    assert sum(result_list) == sum_val\n    return result_list",
            "def _gen_random_list(sum_val: int, min_val: int, max_val: int, length: int=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    \u751f\u6210\u968f\u673a\u5217\u8868\uff0c\u53c2\u6570\u5e94\u8be5\u6ee1\u8db3\uff1amin_val * length <= sum_val <= max_val * length\\n    :param int sum_val: \u5217\u8868\u5143\u7d20\u4e4b\u548c\\n    :param int min_val: \u5217\u8868\u5143\u7d20\u6700\u5c0f\u503c\\n    :param int max_val: \u5217\u8868\u5143\u7d20\u6700\u5927\u503c\\n    :param int length: \u5217\u8868\u957f\u5ea6\uff0c\u5982\u679c\u6ca1\u6709\u6307\u5b9a\uff0c\u5219\u8fd4\u56de\u7684\u5217\u8868\u957f\u5ea6\u6ca1\u6709\u6307\u5b9a\\n    :return: \u6574\u578b\u5217\u8868\uff0c\u6ee1\u8db3 sum(list) = sum_val, len(list) == length, min_val < any_item(list) < max_val\\n    '\n    if length is None:\n        length = sum_val * 2 // (min_val + max_val)\n        assert min_val * length <= sum_val <= max_val * length + min_val\n    else:\n        assert min_val * length <= sum_val <= max_val * length\n    result_list = [min_val for _ in range(length)]\n    if sum(result_list) == sum_val:\n        return result_list\n    result_rest_value = sum_val - min_val * length\n    result_rest_position = (max_val - min_val) * length\n    if sum_val > max_val * length:\n        result_list.append(0)\n        result_rest_position += min_val\n    result_rest_list = _gen_shuffle_list(result_rest_value, result_rest_position)\n    for i in range(len(result_list)):\n        start = (max_val - min_val) * i\n        end = (max_val - min_val) * (i + 1) if start < (max_val - min_val) * length else result_rest_position\n        result_list[i] += sum(result_rest_list[start:end])\n    assert len(result_list) == length or len(result_list) == length + 1\n    assert sum(result_list) == sum_val\n    return result_list",
            "def _gen_random_list(sum_val: int, min_val: int, max_val: int, length: int=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    \u751f\u6210\u968f\u673a\u5217\u8868\uff0c\u53c2\u6570\u5e94\u8be5\u6ee1\u8db3\uff1amin_val * length <= sum_val <= max_val * length\\n    :param int sum_val: \u5217\u8868\u5143\u7d20\u4e4b\u548c\\n    :param int min_val: \u5217\u8868\u5143\u7d20\u6700\u5c0f\u503c\\n    :param int max_val: \u5217\u8868\u5143\u7d20\u6700\u5927\u503c\\n    :param int length: \u5217\u8868\u957f\u5ea6\uff0c\u5982\u679c\u6ca1\u6709\u6307\u5b9a\uff0c\u5219\u8fd4\u56de\u7684\u5217\u8868\u957f\u5ea6\u6ca1\u6709\u6307\u5b9a\\n    :return: \u6574\u578b\u5217\u8868\uff0c\u6ee1\u8db3 sum(list) = sum_val, len(list) == length, min_val < any_item(list) < max_val\\n    '\n    if length is None:\n        length = sum_val * 2 // (min_val + max_val)\n        assert min_val * length <= sum_val <= max_val * length + min_val\n    else:\n        assert min_val * length <= sum_val <= max_val * length\n    result_list = [min_val for _ in range(length)]\n    if sum(result_list) == sum_val:\n        return result_list\n    result_rest_value = sum_val - min_val * length\n    result_rest_position = (max_val - min_val) * length\n    if sum_val > max_val * length:\n        result_list.append(0)\n        result_rest_position += min_val\n    result_rest_list = _gen_shuffle_list(result_rest_value, result_rest_position)\n    for i in range(len(result_list)):\n        start = (max_val - min_val) * i\n        end = (max_val - min_val) * (i + 1) if start < (max_val - min_val) * length else result_rest_position\n        result_list[i] += sum(result_rest_list[start:end])\n    assert len(result_list) == length or len(result_list) == length + 1\n    assert sum(result_list) == sum_val\n    return result_list"
        ]
    },
    {
        "func_name": "_gen_shuffle_list",
        "original": "def _gen_shuffle_list(x: int, n: int):\n    \"\"\"\u4ece n \u4e2a\u4f4d\u7f6e\u4e2d\u968f\u673a\u9009\u4e2d x \u4e2a\"\"\"\n    assert x <= n\n    result_list = [1 for _ in range(x)] + [0 for _ in range(n - x)]\n    utils.RD.shuffle(result_list)\n    return result_list",
        "mutated": [
            "def _gen_shuffle_list(x: int, n: int):\n    if False:\n        i = 10\n    '\u4ece n \u4e2a\u4f4d\u7f6e\u4e2d\u968f\u673a\u9009\u4e2d x \u4e2a'\n    assert x <= n\n    result_list = [1 for _ in range(x)] + [0 for _ in range(n - x)]\n    utils.RD.shuffle(result_list)\n    return result_list",
            "def _gen_shuffle_list(x: int, n: int):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\u4ece n \u4e2a\u4f4d\u7f6e\u4e2d\u968f\u673a\u9009\u4e2d x \u4e2a'\n    assert x <= n\n    result_list = [1 for _ in range(x)] + [0 for _ in range(n - x)]\n    utils.RD.shuffle(result_list)\n    return result_list",
            "def _gen_shuffle_list(x: int, n: int):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\u4ece n \u4e2a\u4f4d\u7f6e\u4e2d\u968f\u673a\u9009\u4e2d x \u4e2a'\n    assert x <= n\n    result_list = [1 for _ in range(x)] + [0 for _ in range(n - x)]\n    utils.RD.shuffle(result_list)\n    return result_list",
            "def _gen_shuffle_list(x: int, n: int):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\u4ece n \u4e2a\u4f4d\u7f6e\u4e2d\u968f\u673a\u9009\u4e2d x \u4e2a'\n    assert x <= n\n    result_list = [1 for _ in range(x)] + [0 for _ in range(n - x)]\n    utils.RD.shuffle(result_list)\n    return result_list",
            "def _gen_shuffle_list(x: int, n: int):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\u4ece n \u4e2a\u4f4d\u7f6e\u4e2d\u968f\u673a\u9009\u4e2d x \u4e2a'\n    assert x <= n\n    result_list = [1 for _ in range(x)] + [0 for _ in range(n - x)]\n    utils.RD.shuffle(result_list)\n    return result_list"
        ]
    }
]