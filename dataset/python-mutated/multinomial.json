[
    {
        "func_name": "binomial_coefficients",
        "original": "def binomial_coefficients(n):\n    \"\"\"Return a dictionary containing pairs :math:`{(k1,k2) : C_kn}` where\n    :math:`C_kn` are binomial coefficients and :math:`n=k1+k2`.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import binomial_coefficients\n    >>> binomial_coefficients(9)\n    {(0, 9): 1, (1, 8): 9, (2, 7): 36, (3, 6): 84,\n     (4, 5): 126, (5, 4): 126, (6, 3): 84, (7, 2): 36, (8, 1): 9, (9, 0): 1}\n\n    See Also\n    ========\n\n    binomial_coefficients_list, multinomial_coefficients\n    \"\"\"\n    n = as_int(n)\n    d = {(0, n): 1, (n, 0): 1}\n    a = 1\n    for k in range(1, n // 2 + 1):\n        a = a * (n - k + 1) // k\n        d[k, n - k] = d[n - k, k] = a\n    return d",
        "mutated": [
            "def binomial_coefficients(n):\n    if False:\n        i = 10\n    'Return a dictionary containing pairs :math:`{(k1,k2) : C_kn}` where\\n    :math:`C_kn` are binomial coefficients and :math:`n=k1+k2`.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import binomial_coefficients\\n    >>> binomial_coefficients(9)\\n    {(0, 9): 1, (1, 8): 9, (2, 7): 36, (3, 6): 84,\\n     (4, 5): 126, (5, 4): 126, (6, 3): 84, (7, 2): 36, (8, 1): 9, (9, 0): 1}\\n\\n    See Also\\n    ========\\n\\n    binomial_coefficients_list, multinomial_coefficients\\n    '\n    n = as_int(n)\n    d = {(0, n): 1, (n, 0): 1}\n    a = 1\n    for k in range(1, n // 2 + 1):\n        a = a * (n - k + 1) // k\n        d[k, n - k] = d[n - k, k] = a\n    return d",
            "def binomial_coefficients(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return a dictionary containing pairs :math:`{(k1,k2) : C_kn}` where\\n    :math:`C_kn` are binomial coefficients and :math:`n=k1+k2`.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import binomial_coefficients\\n    >>> binomial_coefficients(9)\\n    {(0, 9): 1, (1, 8): 9, (2, 7): 36, (3, 6): 84,\\n     (4, 5): 126, (5, 4): 126, (6, 3): 84, (7, 2): 36, (8, 1): 9, (9, 0): 1}\\n\\n    See Also\\n    ========\\n\\n    binomial_coefficients_list, multinomial_coefficients\\n    '\n    n = as_int(n)\n    d = {(0, n): 1, (n, 0): 1}\n    a = 1\n    for k in range(1, n // 2 + 1):\n        a = a * (n - k + 1) // k\n        d[k, n - k] = d[n - k, k] = a\n    return d",
            "def binomial_coefficients(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return a dictionary containing pairs :math:`{(k1,k2) : C_kn}` where\\n    :math:`C_kn` are binomial coefficients and :math:`n=k1+k2`.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import binomial_coefficients\\n    >>> binomial_coefficients(9)\\n    {(0, 9): 1, (1, 8): 9, (2, 7): 36, (3, 6): 84,\\n     (4, 5): 126, (5, 4): 126, (6, 3): 84, (7, 2): 36, (8, 1): 9, (9, 0): 1}\\n\\n    See Also\\n    ========\\n\\n    binomial_coefficients_list, multinomial_coefficients\\n    '\n    n = as_int(n)\n    d = {(0, n): 1, (n, 0): 1}\n    a = 1\n    for k in range(1, n // 2 + 1):\n        a = a * (n - k + 1) // k\n        d[k, n - k] = d[n - k, k] = a\n    return d",
            "def binomial_coefficients(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return a dictionary containing pairs :math:`{(k1,k2) : C_kn}` where\\n    :math:`C_kn` are binomial coefficients and :math:`n=k1+k2`.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import binomial_coefficients\\n    >>> binomial_coefficients(9)\\n    {(0, 9): 1, (1, 8): 9, (2, 7): 36, (3, 6): 84,\\n     (4, 5): 126, (5, 4): 126, (6, 3): 84, (7, 2): 36, (8, 1): 9, (9, 0): 1}\\n\\n    See Also\\n    ========\\n\\n    binomial_coefficients_list, multinomial_coefficients\\n    '\n    n = as_int(n)\n    d = {(0, n): 1, (n, 0): 1}\n    a = 1\n    for k in range(1, n // 2 + 1):\n        a = a * (n - k + 1) // k\n        d[k, n - k] = d[n - k, k] = a\n    return d",
            "def binomial_coefficients(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return a dictionary containing pairs :math:`{(k1,k2) : C_kn}` where\\n    :math:`C_kn` are binomial coefficients and :math:`n=k1+k2`.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import binomial_coefficients\\n    >>> binomial_coefficients(9)\\n    {(0, 9): 1, (1, 8): 9, (2, 7): 36, (3, 6): 84,\\n     (4, 5): 126, (5, 4): 126, (6, 3): 84, (7, 2): 36, (8, 1): 9, (9, 0): 1}\\n\\n    See Also\\n    ========\\n\\n    binomial_coefficients_list, multinomial_coefficients\\n    '\n    n = as_int(n)\n    d = {(0, n): 1, (n, 0): 1}\n    a = 1\n    for k in range(1, n // 2 + 1):\n        a = a * (n - k + 1) // k\n        d[k, n - k] = d[n - k, k] = a\n    return d"
        ]
    },
    {
        "func_name": "binomial_coefficients_list",
        "original": "def binomial_coefficients_list(n):\n    \"\"\" Return a list of binomial coefficients as rows of the Pascal's\n    triangle.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import binomial_coefficients_list\n    >>> binomial_coefficients_list(9)\n    [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]\n\n    See Also\n    ========\n\n    binomial_coefficients, multinomial_coefficients\n    \"\"\"\n    n = as_int(n)\n    d = [1] * (n + 1)\n    a = 1\n    for k in range(1, n // 2 + 1):\n        a = a * (n - k + 1) // k\n        d[k] = d[n - k] = a\n    return d",
        "mutated": [
            "def binomial_coefficients_list(n):\n    if False:\n        i = 10\n    \" Return a list of binomial coefficients as rows of the Pascal's\\n    triangle.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import binomial_coefficients_list\\n    >>> binomial_coefficients_list(9)\\n    [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]\\n\\n    See Also\\n    ========\\n\\n    binomial_coefficients, multinomial_coefficients\\n    \"\n    n = as_int(n)\n    d = [1] * (n + 1)\n    a = 1\n    for k in range(1, n // 2 + 1):\n        a = a * (n - k + 1) // k\n        d[k] = d[n - k] = a\n    return d",
            "def binomial_coefficients_list(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \" Return a list of binomial coefficients as rows of the Pascal's\\n    triangle.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import binomial_coefficients_list\\n    >>> binomial_coefficients_list(9)\\n    [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]\\n\\n    See Also\\n    ========\\n\\n    binomial_coefficients, multinomial_coefficients\\n    \"\n    n = as_int(n)\n    d = [1] * (n + 1)\n    a = 1\n    for k in range(1, n // 2 + 1):\n        a = a * (n - k + 1) // k\n        d[k] = d[n - k] = a\n    return d",
            "def binomial_coefficients_list(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \" Return a list of binomial coefficients as rows of the Pascal's\\n    triangle.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import binomial_coefficients_list\\n    >>> binomial_coefficients_list(9)\\n    [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]\\n\\n    See Also\\n    ========\\n\\n    binomial_coefficients, multinomial_coefficients\\n    \"\n    n = as_int(n)\n    d = [1] * (n + 1)\n    a = 1\n    for k in range(1, n // 2 + 1):\n        a = a * (n - k + 1) // k\n        d[k] = d[n - k] = a\n    return d",
            "def binomial_coefficients_list(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \" Return a list of binomial coefficients as rows of the Pascal's\\n    triangle.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import binomial_coefficients_list\\n    >>> binomial_coefficients_list(9)\\n    [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]\\n\\n    See Also\\n    ========\\n\\n    binomial_coefficients, multinomial_coefficients\\n    \"\n    n = as_int(n)\n    d = [1] * (n + 1)\n    a = 1\n    for k in range(1, n // 2 + 1):\n        a = a * (n - k + 1) // k\n        d[k] = d[n - k] = a\n    return d",
            "def binomial_coefficients_list(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \" Return a list of binomial coefficients as rows of the Pascal's\\n    triangle.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import binomial_coefficients_list\\n    >>> binomial_coefficients_list(9)\\n    [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]\\n\\n    See Also\\n    ========\\n\\n    binomial_coefficients, multinomial_coefficients\\n    \"\n    n = as_int(n)\n    d = [1] * (n + 1)\n    a = 1\n    for k in range(1, n // 2 + 1):\n        a = a * (n - k + 1) // k\n        d[k] = d[n - k] = a\n    return d"
        ]
    },
    {
        "func_name": "multinomial_coefficients",
        "original": "def multinomial_coefficients(m, n):\n    \"\"\"Return a dictionary containing pairs ``{(k1,k2,..,km) : C_kn}``\n    where ``C_kn`` are multinomial coefficients such that\n    ``n=k1+k2+..+km``.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import multinomial_coefficients\n    >>> multinomial_coefficients(2, 5) # indirect doctest\n    {(0, 5): 1, (1, 4): 5, (2, 3): 10, (3, 2): 10, (4, 1): 5, (5, 0): 1}\n\n    Notes\n    =====\n\n    The algorithm is based on the following result:\n\n    .. math::\n        \\\\binom{n}{k_1, \\\\ldots, k_m} =\n        \\\\frac{k_1 + 1}{n - k_1} \\\\sum_{i=2}^m \\\\binom{n}{k_1 + 1, \\\\ldots, k_i - 1, \\\\ldots}\n\n    Code contributed to Sage by Yann Laigle-Chapuy, copied with permission\n    of the author.\n\n    See Also\n    ========\n\n    binomial_coefficients_list, binomial_coefficients\n    \"\"\"\n    m = as_int(m)\n    n = as_int(n)\n    if not m:\n        if n:\n            return {}\n        return {(): 1}\n    if m == 2:\n        return binomial_coefficients(n)\n    if m >= 2 * n and n > 1:\n        return dict(multinomial_coefficients_iterator(m, n))\n    t = [n] + [0] * (m - 1)\n    r = {tuple(t): 1}\n    if n:\n        j = 0\n    else:\n        j = m\n    while j < m - 1:\n        tj = t[j]\n        if j:\n            t[j] = 0\n            t[0] = tj\n        if tj > 1:\n            t[j + 1] += 1\n            j = 0\n            start = 1\n            v = 0\n        else:\n            j += 1\n            start = j + 1\n            v = r[tuple(t)]\n            t[j] += 1\n        for k in range(start, m):\n            if t[k]:\n                t[k] -= 1\n                v += r[tuple(t)]\n                t[k] += 1\n        t[0] -= 1\n        r[tuple(t)] = v * tj // (n - t[0])\n    return r",
        "mutated": [
            "def multinomial_coefficients(m, n):\n    if False:\n        i = 10\n    'Return a dictionary containing pairs ``{(k1,k2,..,km) : C_kn}``\\n    where ``C_kn`` are multinomial coefficients such that\\n    ``n=k1+k2+..+km``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import multinomial_coefficients\\n    >>> multinomial_coefficients(2, 5) # indirect doctest\\n    {(0, 5): 1, (1, 4): 5, (2, 3): 10, (3, 2): 10, (4, 1): 5, (5, 0): 1}\\n\\n    Notes\\n    =====\\n\\n    The algorithm is based on the following result:\\n\\n    .. math::\\n        \\\\binom{n}{k_1, \\\\ldots, k_m} =\\n        \\\\frac{k_1 + 1}{n - k_1} \\\\sum_{i=2}^m \\\\binom{n}{k_1 + 1, \\\\ldots, k_i - 1, \\\\ldots}\\n\\n    Code contributed to Sage by Yann Laigle-Chapuy, copied with permission\\n    of the author.\\n\\n    See Also\\n    ========\\n\\n    binomial_coefficients_list, binomial_coefficients\\n    '\n    m = as_int(m)\n    n = as_int(n)\n    if not m:\n        if n:\n            return {}\n        return {(): 1}\n    if m == 2:\n        return binomial_coefficients(n)\n    if m >= 2 * n and n > 1:\n        return dict(multinomial_coefficients_iterator(m, n))\n    t = [n] + [0] * (m - 1)\n    r = {tuple(t): 1}\n    if n:\n        j = 0\n    else:\n        j = m\n    while j < m - 1:\n        tj = t[j]\n        if j:\n            t[j] = 0\n            t[0] = tj\n        if tj > 1:\n            t[j + 1] += 1\n            j = 0\n            start = 1\n            v = 0\n        else:\n            j += 1\n            start = j + 1\n            v = r[tuple(t)]\n            t[j] += 1\n        for k in range(start, m):\n            if t[k]:\n                t[k] -= 1\n                v += r[tuple(t)]\n                t[k] += 1\n        t[0] -= 1\n        r[tuple(t)] = v * tj // (n - t[0])\n    return r",
            "def multinomial_coefficients(m, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return a dictionary containing pairs ``{(k1,k2,..,km) : C_kn}``\\n    where ``C_kn`` are multinomial coefficients such that\\n    ``n=k1+k2+..+km``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import multinomial_coefficients\\n    >>> multinomial_coefficients(2, 5) # indirect doctest\\n    {(0, 5): 1, (1, 4): 5, (2, 3): 10, (3, 2): 10, (4, 1): 5, (5, 0): 1}\\n\\n    Notes\\n    =====\\n\\n    The algorithm is based on the following result:\\n\\n    .. math::\\n        \\\\binom{n}{k_1, \\\\ldots, k_m} =\\n        \\\\frac{k_1 + 1}{n - k_1} \\\\sum_{i=2}^m \\\\binom{n}{k_1 + 1, \\\\ldots, k_i - 1, \\\\ldots}\\n\\n    Code contributed to Sage by Yann Laigle-Chapuy, copied with permission\\n    of the author.\\n\\n    See Also\\n    ========\\n\\n    binomial_coefficients_list, binomial_coefficients\\n    '\n    m = as_int(m)\n    n = as_int(n)\n    if not m:\n        if n:\n            return {}\n        return {(): 1}\n    if m == 2:\n        return binomial_coefficients(n)\n    if m >= 2 * n and n > 1:\n        return dict(multinomial_coefficients_iterator(m, n))\n    t = [n] + [0] * (m - 1)\n    r = {tuple(t): 1}\n    if n:\n        j = 0\n    else:\n        j = m\n    while j < m - 1:\n        tj = t[j]\n        if j:\n            t[j] = 0\n            t[0] = tj\n        if tj > 1:\n            t[j + 1] += 1\n            j = 0\n            start = 1\n            v = 0\n        else:\n            j += 1\n            start = j + 1\n            v = r[tuple(t)]\n            t[j] += 1\n        for k in range(start, m):\n            if t[k]:\n                t[k] -= 1\n                v += r[tuple(t)]\n                t[k] += 1\n        t[0] -= 1\n        r[tuple(t)] = v * tj // (n - t[0])\n    return r",
            "def multinomial_coefficients(m, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return a dictionary containing pairs ``{(k1,k2,..,km) : C_kn}``\\n    where ``C_kn`` are multinomial coefficients such that\\n    ``n=k1+k2+..+km``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import multinomial_coefficients\\n    >>> multinomial_coefficients(2, 5) # indirect doctest\\n    {(0, 5): 1, (1, 4): 5, (2, 3): 10, (3, 2): 10, (4, 1): 5, (5, 0): 1}\\n\\n    Notes\\n    =====\\n\\n    The algorithm is based on the following result:\\n\\n    .. math::\\n        \\\\binom{n}{k_1, \\\\ldots, k_m} =\\n        \\\\frac{k_1 + 1}{n - k_1} \\\\sum_{i=2}^m \\\\binom{n}{k_1 + 1, \\\\ldots, k_i - 1, \\\\ldots}\\n\\n    Code contributed to Sage by Yann Laigle-Chapuy, copied with permission\\n    of the author.\\n\\n    See Also\\n    ========\\n\\n    binomial_coefficients_list, binomial_coefficients\\n    '\n    m = as_int(m)\n    n = as_int(n)\n    if not m:\n        if n:\n            return {}\n        return {(): 1}\n    if m == 2:\n        return binomial_coefficients(n)\n    if m >= 2 * n and n > 1:\n        return dict(multinomial_coefficients_iterator(m, n))\n    t = [n] + [0] * (m - 1)\n    r = {tuple(t): 1}\n    if n:\n        j = 0\n    else:\n        j = m\n    while j < m - 1:\n        tj = t[j]\n        if j:\n            t[j] = 0\n            t[0] = tj\n        if tj > 1:\n            t[j + 1] += 1\n            j = 0\n            start = 1\n            v = 0\n        else:\n            j += 1\n            start = j + 1\n            v = r[tuple(t)]\n            t[j] += 1\n        for k in range(start, m):\n            if t[k]:\n                t[k] -= 1\n                v += r[tuple(t)]\n                t[k] += 1\n        t[0] -= 1\n        r[tuple(t)] = v * tj // (n - t[0])\n    return r",
            "def multinomial_coefficients(m, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return a dictionary containing pairs ``{(k1,k2,..,km) : C_kn}``\\n    where ``C_kn`` are multinomial coefficients such that\\n    ``n=k1+k2+..+km``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import multinomial_coefficients\\n    >>> multinomial_coefficients(2, 5) # indirect doctest\\n    {(0, 5): 1, (1, 4): 5, (2, 3): 10, (3, 2): 10, (4, 1): 5, (5, 0): 1}\\n\\n    Notes\\n    =====\\n\\n    The algorithm is based on the following result:\\n\\n    .. math::\\n        \\\\binom{n}{k_1, \\\\ldots, k_m} =\\n        \\\\frac{k_1 + 1}{n - k_1} \\\\sum_{i=2}^m \\\\binom{n}{k_1 + 1, \\\\ldots, k_i - 1, \\\\ldots}\\n\\n    Code contributed to Sage by Yann Laigle-Chapuy, copied with permission\\n    of the author.\\n\\n    See Also\\n    ========\\n\\n    binomial_coefficients_list, binomial_coefficients\\n    '\n    m = as_int(m)\n    n = as_int(n)\n    if not m:\n        if n:\n            return {}\n        return {(): 1}\n    if m == 2:\n        return binomial_coefficients(n)\n    if m >= 2 * n and n > 1:\n        return dict(multinomial_coefficients_iterator(m, n))\n    t = [n] + [0] * (m - 1)\n    r = {tuple(t): 1}\n    if n:\n        j = 0\n    else:\n        j = m\n    while j < m - 1:\n        tj = t[j]\n        if j:\n            t[j] = 0\n            t[0] = tj\n        if tj > 1:\n            t[j + 1] += 1\n            j = 0\n            start = 1\n            v = 0\n        else:\n            j += 1\n            start = j + 1\n            v = r[tuple(t)]\n            t[j] += 1\n        for k in range(start, m):\n            if t[k]:\n                t[k] -= 1\n                v += r[tuple(t)]\n                t[k] += 1\n        t[0] -= 1\n        r[tuple(t)] = v * tj // (n - t[0])\n    return r",
            "def multinomial_coefficients(m, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return a dictionary containing pairs ``{(k1,k2,..,km) : C_kn}``\\n    where ``C_kn`` are multinomial coefficients such that\\n    ``n=k1+k2+..+km``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import multinomial_coefficients\\n    >>> multinomial_coefficients(2, 5) # indirect doctest\\n    {(0, 5): 1, (1, 4): 5, (2, 3): 10, (3, 2): 10, (4, 1): 5, (5, 0): 1}\\n\\n    Notes\\n    =====\\n\\n    The algorithm is based on the following result:\\n\\n    .. math::\\n        \\\\binom{n}{k_1, \\\\ldots, k_m} =\\n        \\\\frac{k_1 + 1}{n - k_1} \\\\sum_{i=2}^m \\\\binom{n}{k_1 + 1, \\\\ldots, k_i - 1, \\\\ldots}\\n\\n    Code contributed to Sage by Yann Laigle-Chapuy, copied with permission\\n    of the author.\\n\\n    See Also\\n    ========\\n\\n    binomial_coefficients_list, binomial_coefficients\\n    '\n    m = as_int(m)\n    n = as_int(n)\n    if not m:\n        if n:\n            return {}\n        return {(): 1}\n    if m == 2:\n        return binomial_coefficients(n)\n    if m >= 2 * n and n > 1:\n        return dict(multinomial_coefficients_iterator(m, n))\n    t = [n] + [0] * (m - 1)\n    r = {tuple(t): 1}\n    if n:\n        j = 0\n    else:\n        j = m\n    while j < m - 1:\n        tj = t[j]\n        if j:\n            t[j] = 0\n            t[0] = tj\n        if tj > 1:\n            t[j + 1] += 1\n            j = 0\n            start = 1\n            v = 0\n        else:\n            j += 1\n            start = j + 1\n            v = r[tuple(t)]\n            t[j] += 1\n        for k in range(start, m):\n            if t[k]:\n                t[k] -= 1\n                v += r[tuple(t)]\n                t[k] += 1\n        t[0] -= 1\n        r[tuple(t)] = v * tj // (n - t[0])\n    return r"
        ]
    },
    {
        "func_name": "multinomial_coefficients_iterator",
        "original": "def multinomial_coefficients_iterator(m, n, _tuple=tuple):\n    \"\"\"multinomial coefficient iterator\n\n    This routine has been optimized for `m` large with respect to `n` by taking\n    advantage of the fact that when the monomial tuples `t` are stripped of\n    zeros, their coefficient is the same as that of the monomial tuples from\n    ``multinomial_coefficients(n, n)``. Therefore, the latter coefficients are\n    precomputed to save memory and time.\n\n    >>> from sympy.ntheory.multinomial import multinomial_coefficients\n    >>> m53, m33 = multinomial_coefficients(5,3), multinomial_coefficients(3,3)\n    >>> m53[(0,0,0,1,2)] == m53[(0,0,1,0,2)] == m53[(1,0,2,0,0)] == m33[(0,1,2)]\n    True\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.multinomial import multinomial_coefficients_iterator\n    >>> it = multinomial_coefficients_iterator(20,3)\n    >>> next(it)\n    ((3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), 1)\n    \"\"\"\n    m = as_int(m)\n    n = as_int(n)\n    if m < 2 * n or n == 1:\n        mc = multinomial_coefficients(m, n)\n        yield from mc.items()\n    else:\n        mc = multinomial_coefficients(n, n)\n        mc1 = {}\n        for (k, v) in mc.items():\n            mc1[_tuple(filter(None, k))] = v\n        mc = mc1\n        t = [n] + [0] * (m - 1)\n        t1 = _tuple(t)\n        b = _tuple(filter(None, t1))\n        yield (t1, mc[b])\n        if n:\n            j = 0\n        else:\n            j = m\n        while j < m - 1:\n            tj = t[j]\n            if j:\n                t[j] = 0\n                t[0] = tj\n            if tj > 1:\n                t[j + 1] += 1\n                j = 0\n            else:\n                j += 1\n                t[j] += 1\n            t[0] -= 1\n            t1 = _tuple(t)\n            b = _tuple(filter(None, t1))\n            yield (t1, mc[b])",
        "mutated": [
            "def multinomial_coefficients_iterator(m, n, _tuple=tuple):\n    if False:\n        i = 10\n    'multinomial coefficient iterator\\n\\n    This routine has been optimized for `m` large with respect to `n` by taking\\n    advantage of the fact that when the monomial tuples `t` are stripped of\\n    zeros, their coefficient is the same as that of the monomial tuples from\\n    ``multinomial_coefficients(n, n)``. Therefore, the latter coefficients are\\n    precomputed to save memory and time.\\n\\n    >>> from sympy.ntheory.multinomial import multinomial_coefficients\\n    >>> m53, m33 = multinomial_coefficients(5,3), multinomial_coefficients(3,3)\\n    >>> m53[(0,0,0,1,2)] == m53[(0,0,1,0,2)] == m53[(1,0,2,0,0)] == m33[(0,1,2)]\\n    True\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.multinomial import multinomial_coefficients_iterator\\n    >>> it = multinomial_coefficients_iterator(20,3)\\n    >>> next(it)\\n    ((3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), 1)\\n    '\n    m = as_int(m)\n    n = as_int(n)\n    if m < 2 * n or n == 1:\n        mc = multinomial_coefficients(m, n)\n        yield from mc.items()\n    else:\n        mc = multinomial_coefficients(n, n)\n        mc1 = {}\n        for (k, v) in mc.items():\n            mc1[_tuple(filter(None, k))] = v\n        mc = mc1\n        t = [n] + [0] * (m - 1)\n        t1 = _tuple(t)\n        b = _tuple(filter(None, t1))\n        yield (t1, mc[b])\n        if n:\n            j = 0\n        else:\n            j = m\n        while j < m - 1:\n            tj = t[j]\n            if j:\n                t[j] = 0\n                t[0] = tj\n            if tj > 1:\n                t[j + 1] += 1\n                j = 0\n            else:\n                j += 1\n                t[j] += 1\n            t[0] -= 1\n            t1 = _tuple(t)\n            b = _tuple(filter(None, t1))\n            yield (t1, mc[b])",
            "def multinomial_coefficients_iterator(m, n, _tuple=tuple):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'multinomial coefficient iterator\\n\\n    This routine has been optimized for `m` large with respect to `n` by taking\\n    advantage of the fact that when the monomial tuples `t` are stripped of\\n    zeros, their coefficient is the same as that of the monomial tuples from\\n    ``multinomial_coefficients(n, n)``. Therefore, the latter coefficients are\\n    precomputed to save memory and time.\\n\\n    >>> from sympy.ntheory.multinomial import multinomial_coefficients\\n    >>> m53, m33 = multinomial_coefficients(5,3), multinomial_coefficients(3,3)\\n    >>> m53[(0,0,0,1,2)] == m53[(0,0,1,0,2)] == m53[(1,0,2,0,0)] == m33[(0,1,2)]\\n    True\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.multinomial import multinomial_coefficients_iterator\\n    >>> it = multinomial_coefficients_iterator(20,3)\\n    >>> next(it)\\n    ((3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), 1)\\n    '\n    m = as_int(m)\n    n = as_int(n)\n    if m < 2 * n or n == 1:\n        mc = multinomial_coefficients(m, n)\n        yield from mc.items()\n    else:\n        mc = multinomial_coefficients(n, n)\n        mc1 = {}\n        for (k, v) in mc.items():\n            mc1[_tuple(filter(None, k))] = v\n        mc = mc1\n        t = [n] + [0] * (m - 1)\n        t1 = _tuple(t)\n        b = _tuple(filter(None, t1))\n        yield (t1, mc[b])\n        if n:\n            j = 0\n        else:\n            j = m\n        while j < m - 1:\n            tj = t[j]\n            if j:\n                t[j] = 0\n                t[0] = tj\n            if tj > 1:\n                t[j + 1] += 1\n                j = 0\n            else:\n                j += 1\n                t[j] += 1\n            t[0] -= 1\n            t1 = _tuple(t)\n            b = _tuple(filter(None, t1))\n            yield (t1, mc[b])",
            "def multinomial_coefficients_iterator(m, n, _tuple=tuple):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'multinomial coefficient iterator\\n\\n    This routine has been optimized for `m` large with respect to `n` by taking\\n    advantage of the fact that when the monomial tuples `t` are stripped of\\n    zeros, their coefficient is the same as that of the monomial tuples from\\n    ``multinomial_coefficients(n, n)``. Therefore, the latter coefficients are\\n    precomputed to save memory and time.\\n\\n    >>> from sympy.ntheory.multinomial import multinomial_coefficients\\n    >>> m53, m33 = multinomial_coefficients(5,3), multinomial_coefficients(3,3)\\n    >>> m53[(0,0,0,1,2)] == m53[(0,0,1,0,2)] == m53[(1,0,2,0,0)] == m33[(0,1,2)]\\n    True\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.multinomial import multinomial_coefficients_iterator\\n    >>> it = multinomial_coefficients_iterator(20,3)\\n    >>> next(it)\\n    ((3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), 1)\\n    '\n    m = as_int(m)\n    n = as_int(n)\n    if m < 2 * n or n == 1:\n        mc = multinomial_coefficients(m, n)\n        yield from mc.items()\n    else:\n        mc = multinomial_coefficients(n, n)\n        mc1 = {}\n        for (k, v) in mc.items():\n            mc1[_tuple(filter(None, k))] = v\n        mc = mc1\n        t = [n] + [0] * (m - 1)\n        t1 = _tuple(t)\n        b = _tuple(filter(None, t1))\n        yield (t1, mc[b])\n        if n:\n            j = 0\n        else:\n            j = m\n        while j < m - 1:\n            tj = t[j]\n            if j:\n                t[j] = 0\n                t[0] = tj\n            if tj > 1:\n                t[j + 1] += 1\n                j = 0\n            else:\n                j += 1\n                t[j] += 1\n            t[0] -= 1\n            t1 = _tuple(t)\n            b = _tuple(filter(None, t1))\n            yield (t1, mc[b])",
            "def multinomial_coefficients_iterator(m, n, _tuple=tuple):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'multinomial coefficient iterator\\n\\n    This routine has been optimized for `m` large with respect to `n` by taking\\n    advantage of the fact that when the monomial tuples `t` are stripped of\\n    zeros, their coefficient is the same as that of the monomial tuples from\\n    ``multinomial_coefficients(n, n)``. Therefore, the latter coefficients are\\n    precomputed to save memory and time.\\n\\n    >>> from sympy.ntheory.multinomial import multinomial_coefficients\\n    >>> m53, m33 = multinomial_coefficients(5,3), multinomial_coefficients(3,3)\\n    >>> m53[(0,0,0,1,2)] == m53[(0,0,1,0,2)] == m53[(1,0,2,0,0)] == m33[(0,1,2)]\\n    True\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.multinomial import multinomial_coefficients_iterator\\n    >>> it = multinomial_coefficients_iterator(20,3)\\n    >>> next(it)\\n    ((3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), 1)\\n    '\n    m = as_int(m)\n    n = as_int(n)\n    if m < 2 * n or n == 1:\n        mc = multinomial_coefficients(m, n)\n        yield from mc.items()\n    else:\n        mc = multinomial_coefficients(n, n)\n        mc1 = {}\n        for (k, v) in mc.items():\n            mc1[_tuple(filter(None, k))] = v\n        mc = mc1\n        t = [n] + [0] * (m - 1)\n        t1 = _tuple(t)\n        b = _tuple(filter(None, t1))\n        yield (t1, mc[b])\n        if n:\n            j = 0\n        else:\n            j = m\n        while j < m - 1:\n            tj = t[j]\n            if j:\n                t[j] = 0\n                t[0] = tj\n            if tj > 1:\n                t[j + 1] += 1\n                j = 0\n            else:\n                j += 1\n                t[j] += 1\n            t[0] -= 1\n            t1 = _tuple(t)\n            b = _tuple(filter(None, t1))\n            yield (t1, mc[b])",
            "def multinomial_coefficients_iterator(m, n, _tuple=tuple):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'multinomial coefficient iterator\\n\\n    This routine has been optimized for `m` large with respect to `n` by taking\\n    advantage of the fact that when the monomial tuples `t` are stripped of\\n    zeros, their coefficient is the same as that of the monomial tuples from\\n    ``multinomial_coefficients(n, n)``. Therefore, the latter coefficients are\\n    precomputed to save memory and time.\\n\\n    >>> from sympy.ntheory.multinomial import multinomial_coefficients\\n    >>> m53, m33 = multinomial_coefficients(5,3), multinomial_coefficients(3,3)\\n    >>> m53[(0,0,0,1,2)] == m53[(0,0,1,0,2)] == m53[(1,0,2,0,0)] == m33[(0,1,2)]\\n    True\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.multinomial import multinomial_coefficients_iterator\\n    >>> it = multinomial_coefficients_iterator(20,3)\\n    >>> next(it)\\n    ((3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), 1)\\n    '\n    m = as_int(m)\n    n = as_int(n)\n    if m < 2 * n or n == 1:\n        mc = multinomial_coefficients(m, n)\n        yield from mc.items()\n    else:\n        mc = multinomial_coefficients(n, n)\n        mc1 = {}\n        for (k, v) in mc.items():\n            mc1[_tuple(filter(None, k))] = v\n        mc = mc1\n        t = [n] + [0] * (m - 1)\n        t1 = _tuple(t)\n        b = _tuple(filter(None, t1))\n        yield (t1, mc[b])\n        if n:\n            j = 0\n        else:\n            j = m\n        while j < m - 1:\n            tj = t[j]\n            if j:\n                t[j] = 0\n                t[0] = tj\n            if tj > 1:\n                t[j + 1] += 1\n                j = 0\n            else:\n                j += 1\n                t[j] += 1\n            t[0] -= 1\n            t1 = _tuple(t)\n            b = _tuple(filter(None, t1))\n            yield (t1, mc[b])"
        ]
    }
]