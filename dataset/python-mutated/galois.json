[
    {
        "func_name": "get_perm_group",
        "original": "def get_perm_group(self):\n    return SymmetricGroup(1)",
        "mutated": [
            "def get_perm_group(self):\n    if False:\n        i = 10\n    return SymmetricGroup(1)",
            "def get_perm_group(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return SymmetricGroup(1)",
            "def get_perm_group(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return SymmetricGroup(1)",
            "def get_perm_group(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return SymmetricGroup(1)",
            "def get_perm_group(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return SymmetricGroup(1)"
        ]
    },
    {
        "func_name": "get_perm_group",
        "original": "def get_perm_group(self):\n    return SymmetricGroup(2)",
        "mutated": [
            "def get_perm_group(self):\n    if False:\n        i = 10\n    return SymmetricGroup(2)",
            "def get_perm_group(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return SymmetricGroup(2)",
            "def get_perm_group(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return SymmetricGroup(2)",
            "def get_perm_group(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return SymmetricGroup(2)",
            "def get_perm_group(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return SymmetricGroup(2)"
        ]
    },
    {
        "func_name": "get_perm_group",
        "original": "def get_perm_group(self):\n    if self == S3TransitiveSubgroups.A3:\n        return AlternatingGroup(3)\n    elif self == S3TransitiveSubgroups.S3:\n        return SymmetricGroup(3)",
        "mutated": [
            "def get_perm_group(self):\n    if False:\n        i = 10\n    if self == S3TransitiveSubgroups.A3:\n        return AlternatingGroup(3)\n    elif self == S3TransitiveSubgroups.S3:\n        return SymmetricGroup(3)",
            "def get_perm_group(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self == S3TransitiveSubgroups.A3:\n        return AlternatingGroup(3)\n    elif self == S3TransitiveSubgroups.S3:\n        return SymmetricGroup(3)",
            "def get_perm_group(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self == S3TransitiveSubgroups.A3:\n        return AlternatingGroup(3)\n    elif self == S3TransitiveSubgroups.S3:\n        return SymmetricGroup(3)",
            "def get_perm_group(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self == S3TransitiveSubgroups.A3:\n        return AlternatingGroup(3)\n    elif self == S3TransitiveSubgroups.S3:\n        return SymmetricGroup(3)",
            "def get_perm_group(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self == S3TransitiveSubgroups.A3:\n        return AlternatingGroup(3)\n    elif self == S3TransitiveSubgroups.S3:\n        return SymmetricGroup(3)"
        ]
    },
    {
        "func_name": "get_perm_group",
        "original": "def get_perm_group(self):\n    if self == S4TransitiveSubgroups.C4:\n        return CyclicGroup(4)\n    elif self == S4TransitiveSubgroups.V:\n        return four_group()\n    elif self == S4TransitiveSubgroups.D4:\n        return DihedralGroup(4)\n    elif self == S4TransitiveSubgroups.A4:\n        return AlternatingGroup(4)\n    elif self == S4TransitiveSubgroups.S4:\n        return SymmetricGroup(4)",
        "mutated": [
            "def get_perm_group(self):\n    if False:\n        i = 10\n    if self == S4TransitiveSubgroups.C4:\n        return CyclicGroup(4)\n    elif self == S4TransitiveSubgroups.V:\n        return four_group()\n    elif self == S4TransitiveSubgroups.D4:\n        return DihedralGroup(4)\n    elif self == S4TransitiveSubgroups.A4:\n        return AlternatingGroup(4)\n    elif self == S4TransitiveSubgroups.S4:\n        return SymmetricGroup(4)",
            "def get_perm_group(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self == S4TransitiveSubgroups.C4:\n        return CyclicGroup(4)\n    elif self == S4TransitiveSubgroups.V:\n        return four_group()\n    elif self == S4TransitiveSubgroups.D4:\n        return DihedralGroup(4)\n    elif self == S4TransitiveSubgroups.A4:\n        return AlternatingGroup(4)\n    elif self == S4TransitiveSubgroups.S4:\n        return SymmetricGroup(4)",
            "def get_perm_group(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self == S4TransitiveSubgroups.C4:\n        return CyclicGroup(4)\n    elif self == S4TransitiveSubgroups.V:\n        return four_group()\n    elif self == S4TransitiveSubgroups.D4:\n        return DihedralGroup(4)\n    elif self == S4TransitiveSubgroups.A4:\n        return AlternatingGroup(4)\n    elif self == S4TransitiveSubgroups.S4:\n        return SymmetricGroup(4)",
            "def get_perm_group(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self == S4TransitiveSubgroups.C4:\n        return CyclicGroup(4)\n    elif self == S4TransitiveSubgroups.V:\n        return four_group()\n    elif self == S4TransitiveSubgroups.D4:\n        return DihedralGroup(4)\n    elif self == S4TransitiveSubgroups.A4:\n        return AlternatingGroup(4)\n    elif self == S4TransitiveSubgroups.S4:\n        return SymmetricGroup(4)",
            "def get_perm_group(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self == S4TransitiveSubgroups.C4:\n        return CyclicGroup(4)\n    elif self == S4TransitiveSubgroups.V:\n        return four_group()\n    elif self == S4TransitiveSubgroups.D4:\n        return DihedralGroup(4)\n    elif self == S4TransitiveSubgroups.A4:\n        return AlternatingGroup(4)\n    elif self == S4TransitiveSubgroups.S4:\n        return SymmetricGroup(4)"
        ]
    },
    {
        "func_name": "get_perm_group",
        "original": "def get_perm_group(self):\n    if self == S5TransitiveSubgroups.C5:\n        return CyclicGroup(5)\n    elif self == S5TransitiveSubgroups.D5:\n        return DihedralGroup(5)\n    elif self == S5TransitiveSubgroups.M20:\n        return M20()\n    elif self == S5TransitiveSubgroups.A5:\n        return AlternatingGroup(5)\n    elif self == S5TransitiveSubgroups.S5:\n        return SymmetricGroup(5)",
        "mutated": [
            "def get_perm_group(self):\n    if False:\n        i = 10\n    if self == S5TransitiveSubgroups.C5:\n        return CyclicGroup(5)\n    elif self == S5TransitiveSubgroups.D5:\n        return DihedralGroup(5)\n    elif self == S5TransitiveSubgroups.M20:\n        return M20()\n    elif self == S5TransitiveSubgroups.A5:\n        return AlternatingGroup(5)\n    elif self == S5TransitiveSubgroups.S5:\n        return SymmetricGroup(5)",
            "def get_perm_group(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self == S5TransitiveSubgroups.C5:\n        return CyclicGroup(5)\n    elif self == S5TransitiveSubgroups.D5:\n        return DihedralGroup(5)\n    elif self == S5TransitiveSubgroups.M20:\n        return M20()\n    elif self == S5TransitiveSubgroups.A5:\n        return AlternatingGroup(5)\n    elif self == S5TransitiveSubgroups.S5:\n        return SymmetricGroup(5)",
            "def get_perm_group(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self == S5TransitiveSubgroups.C5:\n        return CyclicGroup(5)\n    elif self == S5TransitiveSubgroups.D5:\n        return DihedralGroup(5)\n    elif self == S5TransitiveSubgroups.M20:\n        return M20()\n    elif self == S5TransitiveSubgroups.A5:\n        return AlternatingGroup(5)\n    elif self == S5TransitiveSubgroups.S5:\n        return SymmetricGroup(5)",
            "def get_perm_group(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self == S5TransitiveSubgroups.C5:\n        return CyclicGroup(5)\n    elif self == S5TransitiveSubgroups.D5:\n        return DihedralGroup(5)\n    elif self == S5TransitiveSubgroups.M20:\n        return M20()\n    elif self == S5TransitiveSubgroups.A5:\n        return AlternatingGroup(5)\n    elif self == S5TransitiveSubgroups.S5:\n        return SymmetricGroup(5)",
            "def get_perm_group(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self == S5TransitiveSubgroups.C5:\n        return CyclicGroup(5)\n    elif self == S5TransitiveSubgroups.D5:\n        return DihedralGroup(5)\n    elif self == S5TransitiveSubgroups.M20:\n        return M20()\n    elif self == S5TransitiveSubgroups.A5:\n        return AlternatingGroup(5)\n    elif self == S5TransitiveSubgroups.S5:\n        return SymmetricGroup(5)"
        ]
    },
    {
        "func_name": "get_perm_group",
        "original": "def get_perm_group(self):\n    if self == S6TransitiveSubgroups.C6:\n        return CyclicGroup(6)\n    elif self == S6TransitiveSubgroups.S3:\n        return S3_in_S6()\n    elif self == S6TransitiveSubgroups.D6:\n        return DihedralGroup(6)\n    elif self == S6TransitiveSubgroups.A4:\n        return A4_in_S6()\n    elif self == S6TransitiveSubgroups.G18:\n        return G18()\n    elif self == S6TransitiveSubgroups.A4xC2:\n        return A4xC2()\n    elif self == S6TransitiveSubgroups.S4m:\n        return S4m()\n    elif self == S6TransitiveSubgroups.S4p:\n        return S4p()\n    elif self == S6TransitiveSubgroups.G36m:\n        return G36m()\n    elif self == S6TransitiveSubgroups.G36p:\n        return G36p()\n    elif self == S6TransitiveSubgroups.S4xC2:\n        return S4xC2()\n    elif self == S6TransitiveSubgroups.PSL2F5:\n        return PSL2F5()\n    elif self == S6TransitiveSubgroups.G72:\n        return G72()\n    elif self == S6TransitiveSubgroups.PGL2F5:\n        return PGL2F5()\n    elif self == S6TransitiveSubgroups.A6:\n        return AlternatingGroup(6)\n    elif self == S6TransitiveSubgroups.S6:\n        return SymmetricGroup(6)",
        "mutated": [
            "def get_perm_group(self):\n    if False:\n        i = 10\n    if self == S6TransitiveSubgroups.C6:\n        return CyclicGroup(6)\n    elif self == S6TransitiveSubgroups.S3:\n        return S3_in_S6()\n    elif self == S6TransitiveSubgroups.D6:\n        return DihedralGroup(6)\n    elif self == S6TransitiveSubgroups.A4:\n        return A4_in_S6()\n    elif self == S6TransitiveSubgroups.G18:\n        return G18()\n    elif self == S6TransitiveSubgroups.A4xC2:\n        return A4xC2()\n    elif self == S6TransitiveSubgroups.S4m:\n        return S4m()\n    elif self == S6TransitiveSubgroups.S4p:\n        return S4p()\n    elif self == S6TransitiveSubgroups.G36m:\n        return G36m()\n    elif self == S6TransitiveSubgroups.G36p:\n        return G36p()\n    elif self == S6TransitiveSubgroups.S4xC2:\n        return S4xC2()\n    elif self == S6TransitiveSubgroups.PSL2F5:\n        return PSL2F5()\n    elif self == S6TransitiveSubgroups.G72:\n        return G72()\n    elif self == S6TransitiveSubgroups.PGL2F5:\n        return PGL2F5()\n    elif self == S6TransitiveSubgroups.A6:\n        return AlternatingGroup(6)\n    elif self == S6TransitiveSubgroups.S6:\n        return SymmetricGroup(6)",
            "def get_perm_group(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self == S6TransitiveSubgroups.C6:\n        return CyclicGroup(6)\n    elif self == S6TransitiveSubgroups.S3:\n        return S3_in_S6()\n    elif self == S6TransitiveSubgroups.D6:\n        return DihedralGroup(6)\n    elif self == S6TransitiveSubgroups.A4:\n        return A4_in_S6()\n    elif self == S6TransitiveSubgroups.G18:\n        return G18()\n    elif self == S6TransitiveSubgroups.A4xC2:\n        return A4xC2()\n    elif self == S6TransitiveSubgroups.S4m:\n        return S4m()\n    elif self == S6TransitiveSubgroups.S4p:\n        return S4p()\n    elif self == S6TransitiveSubgroups.G36m:\n        return G36m()\n    elif self == S6TransitiveSubgroups.G36p:\n        return G36p()\n    elif self == S6TransitiveSubgroups.S4xC2:\n        return S4xC2()\n    elif self == S6TransitiveSubgroups.PSL2F5:\n        return PSL2F5()\n    elif self == S6TransitiveSubgroups.G72:\n        return G72()\n    elif self == S6TransitiveSubgroups.PGL2F5:\n        return PGL2F5()\n    elif self == S6TransitiveSubgroups.A6:\n        return AlternatingGroup(6)\n    elif self == S6TransitiveSubgroups.S6:\n        return SymmetricGroup(6)",
            "def get_perm_group(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self == S6TransitiveSubgroups.C6:\n        return CyclicGroup(6)\n    elif self == S6TransitiveSubgroups.S3:\n        return S3_in_S6()\n    elif self == S6TransitiveSubgroups.D6:\n        return DihedralGroup(6)\n    elif self == S6TransitiveSubgroups.A4:\n        return A4_in_S6()\n    elif self == S6TransitiveSubgroups.G18:\n        return G18()\n    elif self == S6TransitiveSubgroups.A4xC2:\n        return A4xC2()\n    elif self == S6TransitiveSubgroups.S4m:\n        return S4m()\n    elif self == S6TransitiveSubgroups.S4p:\n        return S4p()\n    elif self == S6TransitiveSubgroups.G36m:\n        return G36m()\n    elif self == S6TransitiveSubgroups.G36p:\n        return G36p()\n    elif self == S6TransitiveSubgroups.S4xC2:\n        return S4xC2()\n    elif self == S6TransitiveSubgroups.PSL2F5:\n        return PSL2F5()\n    elif self == S6TransitiveSubgroups.G72:\n        return G72()\n    elif self == S6TransitiveSubgroups.PGL2F5:\n        return PGL2F5()\n    elif self == S6TransitiveSubgroups.A6:\n        return AlternatingGroup(6)\n    elif self == S6TransitiveSubgroups.S6:\n        return SymmetricGroup(6)",
            "def get_perm_group(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self == S6TransitiveSubgroups.C6:\n        return CyclicGroup(6)\n    elif self == S6TransitiveSubgroups.S3:\n        return S3_in_S6()\n    elif self == S6TransitiveSubgroups.D6:\n        return DihedralGroup(6)\n    elif self == S6TransitiveSubgroups.A4:\n        return A4_in_S6()\n    elif self == S6TransitiveSubgroups.G18:\n        return G18()\n    elif self == S6TransitiveSubgroups.A4xC2:\n        return A4xC2()\n    elif self == S6TransitiveSubgroups.S4m:\n        return S4m()\n    elif self == S6TransitiveSubgroups.S4p:\n        return S4p()\n    elif self == S6TransitiveSubgroups.G36m:\n        return G36m()\n    elif self == S6TransitiveSubgroups.G36p:\n        return G36p()\n    elif self == S6TransitiveSubgroups.S4xC2:\n        return S4xC2()\n    elif self == S6TransitiveSubgroups.PSL2F5:\n        return PSL2F5()\n    elif self == S6TransitiveSubgroups.G72:\n        return G72()\n    elif self == S6TransitiveSubgroups.PGL2F5:\n        return PGL2F5()\n    elif self == S6TransitiveSubgroups.A6:\n        return AlternatingGroup(6)\n    elif self == S6TransitiveSubgroups.S6:\n        return SymmetricGroup(6)",
            "def get_perm_group(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self == S6TransitiveSubgroups.C6:\n        return CyclicGroup(6)\n    elif self == S6TransitiveSubgroups.S3:\n        return S3_in_S6()\n    elif self == S6TransitiveSubgroups.D6:\n        return DihedralGroup(6)\n    elif self == S6TransitiveSubgroups.A4:\n        return A4_in_S6()\n    elif self == S6TransitiveSubgroups.G18:\n        return G18()\n    elif self == S6TransitiveSubgroups.A4xC2:\n        return A4xC2()\n    elif self == S6TransitiveSubgroups.S4m:\n        return S4m()\n    elif self == S6TransitiveSubgroups.S4p:\n        return S4p()\n    elif self == S6TransitiveSubgroups.G36m:\n        return G36m()\n    elif self == S6TransitiveSubgroups.G36p:\n        return G36p()\n    elif self == S6TransitiveSubgroups.S4xC2:\n        return S4xC2()\n    elif self == S6TransitiveSubgroups.PSL2F5:\n        return PSL2F5()\n    elif self == S6TransitiveSubgroups.G72:\n        return G72()\n    elif self == S6TransitiveSubgroups.PGL2F5:\n        return PGL2F5()\n    elif self == S6TransitiveSubgroups.A6:\n        return AlternatingGroup(6)\n    elif self == S6TransitiveSubgroups.S6:\n        return SymmetricGroup(6)"
        ]
    },
    {
        "func_name": "four_group",
        "original": "def four_group():\n    \"\"\"\n    Return a representation of the Klein four-group as a transitive subgroup\n    of S4.\n    \"\"\"\n    return PermutationGroup(Permutation(0, 1)(2, 3), Permutation(0, 2)(1, 3))",
        "mutated": [
            "def four_group():\n    if False:\n        i = 10\n    '\\n    Return a representation of the Klein four-group as a transitive subgroup\\n    of S4.\\n    '\n    return PermutationGroup(Permutation(0, 1)(2, 3), Permutation(0, 2)(1, 3))",
            "def four_group():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return a representation of the Klein four-group as a transitive subgroup\\n    of S4.\\n    '\n    return PermutationGroup(Permutation(0, 1)(2, 3), Permutation(0, 2)(1, 3))",
            "def four_group():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return a representation of the Klein four-group as a transitive subgroup\\n    of S4.\\n    '\n    return PermutationGroup(Permutation(0, 1)(2, 3), Permutation(0, 2)(1, 3))",
            "def four_group():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return a representation of the Klein four-group as a transitive subgroup\\n    of S4.\\n    '\n    return PermutationGroup(Permutation(0, 1)(2, 3), Permutation(0, 2)(1, 3))",
            "def four_group():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return a representation of the Klein four-group as a transitive subgroup\\n    of S4.\\n    '\n    return PermutationGroup(Permutation(0, 1)(2, 3), Permutation(0, 2)(1, 3))"
        ]
    },
    {
        "func_name": "M20",
        "original": "def M20():\n    \"\"\"\n    Return a representation of the metacyclic group M20, a transitive subgroup\n    of S5 that is one of the possible Galois groups for polys of degree 5.\n\n    Notes\n    =====\n\n    See [1], Page 323.\n\n    \"\"\"\n    G = PermutationGroup(Permutation(0, 1, 2, 3, 4), Permutation(1, 2, 4, 3))\n    G._degree = 5\n    G._order = 20\n    G._is_transitive = True\n    G._is_sym = False\n    G._is_alt = False\n    G._is_cyclic = False\n    G._is_dihedral = False\n    return G",
        "mutated": [
            "def M20():\n    if False:\n        i = 10\n    '\\n    Return a representation of the metacyclic group M20, a transitive subgroup\\n    of S5 that is one of the possible Galois groups for polys of degree 5.\\n\\n    Notes\\n    =====\\n\\n    See [1], Page 323.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 1, 2, 3, 4), Permutation(1, 2, 4, 3))\n    G._degree = 5\n    G._order = 20\n    G._is_transitive = True\n    G._is_sym = False\n    G._is_alt = False\n    G._is_cyclic = False\n    G._is_dihedral = False\n    return G",
            "def M20():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return a representation of the metacyclic group M20, a transitive subgroup\\n    of S5 that is one of the possible Galois groups for polys of degree 5.\\n\\n    Notes\\n    =====\\n\\n    See [1], Page 323.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 1, 2, 3, 4), Permutation(1, 2, 4, 3))\n    G._degree = 5\n    G._order = 20\n    G._is_transitive = True\n    G._is_sym = False\n    G._is_alt = False\n    G._is_cyclic = False\n    G._is_dihedral = False\n    return G",
            "def M20():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return a representation of the metacyclic group M20, a transitive subgroup\\n    of S5 that is one of the possible Galois groups for polys of degree 5.\\n\\n    Notes\\n    =====\\n\\n    See [1], Page 323.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 1, 2, 3, 4), Permutation(1, 2, 4, 3))\n    G._degree = 5\n    G._order = 20\n    G._is_transitive = True\n    G._is_sym = False\n    G._is_alt = False\n    G._is_cyclic = False\n    G._is_dihedral = False\n    return G",
            "def M20():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return a representation of the metacyclic group M20, a transitive subgroup\\n    of S5 that is one of the possible Galois groups for polys of degree 5.\\n\\n    Notes\\n    =====\\n\\n    See [1], Page 323.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 1, 2, 3, 4), Permutation(1, 2, 4, 3))\n    G._degree = 5\n    G._order = 20\n    G._is_transitive = True\n    G._is_sym = False\n    G._is_alt = False\n    G._is_cyclic = False\n    G._is_dihedral = False\n    return G",
            "def M20():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return a representation of the metacyclic group M20, a transitive subgroup\\n    of S5 that is one of the possible Galois groups for polys of degree 5.\\n\\n    Notes\\n    =====\\n\\n    See [1], Page 323.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 1, 2, 3, 4), Permutation(1, 2, 4, 3))\n    G._degree = 5\n    G._order = 20\n    G._is_transitive = True\n    G._is_sym = False\n    G._is_alt = False\n    G._is_cyclic = False\n    G._is_dihedral = False\n    return G"
        ]
    },
    {
        "func_name": "S3_in_S6",
        "original": "def S3_in_S6():\n    \"\"\"\n    Return a representation of S3 as a transitive subgroup of S6.\n\n    Notes\n    =====\n\n    The representation is found by viewing the group as the symmetries of a\n    triangular prism.\n\n    \"\"\"\n    G = PermutationGroup(Permutation(0, 1, 2)(3, 4, 5), Permutation(0, 3)(2, 4)(1, 5))\n    set_symmetric_group_properties(G, 3, 6)\n    return G",
        "mutated": [
            "def S3_in_S6():\n    if False:\n        i = 10\n    '\\n    Return a representation of S3 as a transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    The representation is found by viewing the group as the symmetries of a\\n    triangular prism.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 1, 2)(3, 4, 5), Permutation(0, 3)(2, 4)(1, 5))\n    set_symmetric_group_properties(G, 3, 6)\n    return G",
            "def S3_in_S6():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return a representation of S3 as a transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    The representation is found by viewing the group as the symmetries of a\\n    triangular prism.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 1, 2)(3, 4, 5), Permutation(0, 3)(2, 4)(1, 5))\n    set_symmetric_group_properties(G, 3, 6)\n    return G",
            "def S3_in_S6():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return a representation of S3 as a transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    The representation is found by viewing the group as the symmetries of a\\n    triangular prism.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 1, 2)(3, 4, 5), Permutation(0, 3)(2, 4)(1, 5))\n    set_symmetric_group_properties(G, 3, 6)\n    return G",
            "def S3_in_S6():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return a representation of S3 as a transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    The representation is found by viewing the group as the symmetries of a\\n    triangular prism.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 1, 2)(3, 4, 5), Permutation(0, 3)(2, 4)(1, 5))\n    set_symmetric_group_properties(G, 3, 6)\n    return G",
            "def S3_in_S6():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return a representation of S3 as a transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    The representation is found by viewing the group as the symmetries of a\\n    triangular prism.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 1, 2)(3, 4, 5), Permutation(0, 3)(2, 4)(1, 5))\n    set_symmetric_group_properties(G, 3, 6)\n    return G"
        ]
    },
    {
        "func_name": "A4_in_S6",
        "original": "def A4_in_S6():\n    \"\"\"\n    Return a representation of A4 as a transitive subgroup of S6.\n\n    Notes\n    =====\n\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\n\n    \"\"\"\n    G = PermutationGroup(Permutation(0, 4, 5)(1, 3, 2), Permutation(0, 1, 2)(3, 5, 4))\n    set_alternating_group_properties(G, 4, 6)\n    return G",
        "mutated": [
            "def A4_in_S6():\n    if False:\n        i = 10\n    '\\n    Return a representation of A4 as a transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 4, 5)(1, 3, 2), Permutation(0, 1, 2)(3, 5, 4))\n    set_alternating_group_properties(G, 4, 6)\n    return G",
            "def A4_in_S6():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return a representation of A4 as a transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 4, 5)(1, 3, 2), Permutation(0, 1, 2)(3, 5, 4))\n    set_alternating_group_properties(G, 4, 6)\n    return G",
            "def A4_in_S6():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return a representation of A4 as a transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 4, 5)(1, 3, 2), Permutation(0, 1, 2)(3, 5, 4))\n    set_alternating_group_properties(G, 4, 6)\n    return G",
            "def A4_in_S6():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return a representation of A4 as a transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 4, 5)(1, 3, 2), Permutation(0, 1, 2)(3, 5, 4))\n    set_alternating_group_properties(G, 4, 6)\n    return G",
            "def A4_in_S6():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return a representation of A4 as a transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 4, 5)(1, 3, 2), Permutation(0, 1, 2)(3, 5, 4))\n    set_alternating_group_properties(G, 4, 6)\n    return G"
        ]
    },
    {
        "func_name": "S4m",
        "original": "def S4m():\n    \"\"\"\n    Return a representation of the S4- transitive subgroup of S6.\n\n    Notes\n    =====\n\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\n\n    \"\"\"\n    G = PermutationGroup(Permutation(1, 4, 5, 3), Permutation(0, 4)(1, 5)(2, 3))\n    set_symmetric_group_properties(G, 4, 6)\n    return G",
        "mutated": [
            "def S4m():\n    if False:\n        i = 10\n    '\\n    Return a representation of the S4- transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    G = PermutationGroup(Permutation(1, 4, 5, 3), Permutation(0, 4)(1, 5)(2, 3))\n    set_symmetric_group_properties(G, 4, 6)\n    return G",
            "def S4m():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return a representation of the S4- transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    G = PermutationGroup(Permutation(1, 4, 5, 3), Permutation(0, 4)(1, 5)(2, 3))\n    set_symmetric_group_properties(G, 4, 6)\n    return G",
            "def S4m():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return a representation of the S4- transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    G = PermutationGroup(Permutation(1, 4, 5, 3), Permutation(0, 4)(1, 5)(2, 3))\n    set_symmetric_group_properties(G, 4, 6)\n    return G",
            "def S4m():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return a representation of the S4- transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    G = PermutationGroup(Permutation(1, 4, 5, 3), Permutation(0, 4)(1, 5)(2, 3))\n    set_symmetric_group_properties(G, 4, 6)\n    return G",
            "def S4m():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return a representation of the S4- transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    G = PermutationGroup(Permutation(1, 4, 5, 3), Permutation(0, 4)(1, 5)(2, 3))\n    set_symmetric_group_properties(G, 4, 6)\n    return G"
        ]
    },
    {
        "func_name": "S4p",
        "original": "def S4p():\n    \"\"\"\n    Return a representation of the S4+ transitive subgroup of S6.\n\n    Notes\n    =====\n\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\n\n    \"\"\"\n    G = PermutationGroup(Permutation(0, 2, 4, 1)(3, 5), Permutation(0, 3)(4, 5))\n    set_symmetric_group_properties(G, 4, 6)\n    return G",
        "mutated": [
            "def S4p():\n    if False:\n        i = 10\n    '\\n    Return a representation of the S4+ transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 2, 4, 1)(3, 5), Permutation(0, 3)(4, 5))\n    set_symmetric_group_properties(G, 4, 6)\n    return G",
            "def S4p():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return a representation of the S4+ transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 2, 4, 1)(3, 5), Permutation(0, 3)(4, 5))\n    set_symmetric_group_properties(G, 4, 6)\n    return G",
            "def S4p():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return a representation of the S4+ transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 2, 4, 1)(3, 5), Permutation(0, 3)(4, 5))\n    set_symmetric_group_properties(G, 4, 6)\n    return G",
            "def S4p():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return a representation of the S4+ transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 2, 4, 1)(3, 5), Permutation(0, 3)(4, 5))\n    set_symmetric_group_properties(G, 4, 6)\n    return G",
            "def S4p():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return a representation of the S4+ transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 2, 4, 1)(3, 5), Permutation(0, 3)(4, 5))\n    set_symmetric_group_properties(G, 4, 6)\n    return G"
        ]
    },
    {
        "func_name": "A4xC2",
        "original": "def A4xC2():\n    \"\"\"\n    Return a representation of the (A4 x C2) transitive subgroup of S6.\n\n    Notes\n    =====\n\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\n\n    \"\"\"\n    return PermutationGroup(Permutation(0, 4, 5)(1, 3, 2), Permutation(0, 1, 2)(3, 5, 4), Permutation(5)(2, 4))",
        "mutated": [
            "def A4xC2():\n    if False:\n        i = 10\n    '\\n    Return a representation of the (A4 x C2) transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(0, 4, 5)(1, 3, 2), Permutation(0, 1, 2)(3, 5, 4), Permutation(5)(2, 4))",
            "def A4xC2():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return a representation of the (A4 x C2) transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(0, 4, 5)(1, 3, 2), Permutation(0, 1, 2)(3, 5, 4), Permutation(5)(2, 4))",
            "def A4xC2():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return a representation of the (A4 x C2) transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(0, 4, 5)(1, 3, 2), Permutation(0, 1, 2)(3, 5, 4), Permutation(5)(2, 4))",
            "def A4xC2():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return a representation of the (A4 x C2) transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(0, 4, 5)(1, 3, 2), Permutation(0, 1, 2)(3, 5, 4), Permutation(5)(2, 4))",
            "def A4xC2():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return a representation of the (A4 x C2) transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(0, 4, 5)(1, 3, 2), Permutation(0, 1, 2)(3, 5, 4), Permutation(5)(2, 4))"
        ]
    },
    {
        "func_name": "S4xC2",
        "original": "def S4xC2():\n    \"\"\"\n    Return a representation of the (S4 x C2) transitive subgroup of S6.\n\n    Notes\n    =====\n\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\n\n    \"\"\"\n    return PermutationGroup(Permutation(1, 4, 5, 3), Permutation(0, 4)(1, 5)(2, 3), Permutation(1, 4)(3, 5))",
        "mutated": [
            "def S4xC2():\n    if False:\n        i = 10\n    '\\n    Return a representation of the (S4 x C2) transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(1, 4, 5, 3), Permutation(0, 4)(1, 5)(2, 3), Permutation(1, 4)(3, 5))",
            "def S4xC2():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return a representation of the (S4 x C2) transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(1, 4, 5, 3), Permutation(0, 4)(1, 5)(2, 3), Permutation(1, 4)(3, 5))",
            "def S4xC2():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return a representation of the (S4 x C2) transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(1, 4, 5, 3), Permutation(0, 4)(1, 5)(2, 3), Permutation(1, 4)(3, 5))",
            "def S4xC2():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return a representation of the (S4 x C2) transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(1, 4, 5, 3), Permutation(0, 4)(1, 5)(2, 3), Permutation(1, 4)(3, 5))",
            "def S4xC2():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return a representation of the (S4 x C2) transitive subgroup of S6.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(1, 4, 5, 3), Permutation(0, 4)(1, 5)(2, 3), Permutation(1, 4)(3, 5))"
        ]
    },
    {
        "func_name": "G18",
        "original": "def G18():\n    \"\"\"\n    Return a representation of the group G18, a transitive subgroup of S6\n    isomorphic to the semidirect product of C3^2 with C2.\n\n    Notes\n    =====\n\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\n\n    \"\"\"\n    return PermutationGroup(Permutation(5)(0, 1, 2), Permutation(3, 4, 5), Permutation(0, 4)(1, 5)(2, 3))",
        "mutated": [
            "def G18():\n    if False:\n        i = 10\n    '\\n    Return a representation of the group G18, a transitive subgroup of S6\\n    isomorphic to the semidirect product of C3^2 with C2.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(5)(0, 1, 2), Permutation(3, 4, 5), Permutation(0, 4)(1, 5)(2, 3))",
            "def G18():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return a representation of the group G18, a transitive subgroup of S6\\n    isomorphic to the semidirect product of C3^2 with C2.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(5)(0, 1, 2), Permutation(3, 4, 5), Permutation(0, 4)(1, 5)(2, 3))",
            "def G18():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return a representation of the group G18, a transitive subgroup of S6\\n    isomorphic to the semidirect product of C3^2 with C2.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(5)(0, 1, 2), Permutation(3, 4, 5), Permutation(0, 4)(1, 5)(2, 3))",
            "def G18():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return a representation of the group G18, a transitive subgroup of S6\\n    isomorphic to the semidirect product of C3^2 with C2.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(5)(0, 1, 2), Permutation(3, 4, 5), Permutation(0, 4)(1, 5)(2, 3))",
            "def G18():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return a representation of the group G18, a transitive subgroup of S6\\n    isomorphic to the semidirect product of C3^2 with C2.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(5)(0, 1, 2), Permutation(3, 4, 5), Permutation(0, 4)(1, 5)(2, 3))"
        ]
    },
    {
        "func_name": "G36m",
        "original": "def G36m():\n    \"\"\"\n    Return a representation of the group G36-, a transitive subgroup of S6\n    isomorphic to the semidirect product of C3^2 with C2^2.\n\n    Notes\n    =====\n\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\n\n    \"\"\"\n    return PermutationGroup(Permutation(5)(0, 1, 2), Permutation(3, 4, 5), Permutation(1, 2)(3, 5), Permutation(0, 4)(1, 5)(2, 3))",
        "mutated": [
            "def G36m():\n    if False:\n        i = 10\n    '\\n    Return a representation of the group G36-, a transitive subgroup of S6\\n    isomorphic to the semidirect product of C3^2 with C2^2.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(5)(0, 1, 2), Permutation(3, 4, 5), Permutation(1, 2)(3, 5), Permutation(0, 4)(1, 5)(2, 3))",
            "def G36m():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return a representation of the group G36-, a transitive subgroup of S6\\n    isomorphic to the semidirect product of C3^2 with C2^2.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(5)(0, 1, 2), Permutation(3, 4, 5), Permutation(1, 2)(3, 5), Permutation(0, 4)(1, 5)(2, 3))",
            "def G36m():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return a representation of the group G36-, a transitive subgroup of S6\\n    isomorphic to the semidirect product of C3^2 with C2^2.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(5)(0, 1, 2), Permutation(3, 4, 5), Permutation(1, 2)(3, 5), Permutation(0, 4)(1, 5)(2, 3))",
            "def G36m():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return a representation of the group G36-, a transitive subgroup of S6\\n    isomorphic to the semidirect product of C3^2 with C2^2.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(5)(0, 1, 2), Permutation(3, 4, 5), Permutation(1, 2)(3, 5), Permutation(0, 4)(1, 5)(2, 3))",
            "def G36m():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return a representation of the group G36-, a transitive subgroup of S6\\n    isomorphic to the semidirect product of C3^2 with C2^2.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(5)(0, 1, 2), Permutation(3, 4, 5), Permutation(1, 2)(3, 5), Permutation(0, 4)(1, 5)(2, 3))"
        ]
    },
    {
        "func_name": "G36p",
        "original": "def G36p():\n    \"\"\"\n    Return a representation of the group G36+, a transitive subgroup of S6\n    isomorphic to the semidirect product of C3^2 with C4.\n\n    Notes\n    =====\n\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\n\n    \"\"\"\n    return PermutationGroup(Permutation(5)(0, 1, 2), Permutation(3, 4, 5), Permutation(0, 5, 2, 3)(1, 4))",
        "mutated": [
            "def G36p():\n    if False:\n        i = 10\n    '\\n    Return a representation of the group G36+, a transitive subgroup of S6\\n    isomorphic to the semidirect product of C3^2 with C4.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(5)(0, 1, 2), Permutation(3, 4, 5), Permutation(0, 5, 2, 3)(1, 4))",
            "def G36p():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return a representation of the group G36+, a transitive subgroup of S6\\n    isomorphic to the semidirect product of C3^2 with C4.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(5)(0, 1, 2), Permutation(3, 4, 5), Permutation(0, 5, 2, 3)(1, 4))",
            "def G36p():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return a representation of the group G36+, a transitive subgroup of S6\\n    isomorphic to the semidirect product of C3^2 with C4.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(5)(0, 1, 2), Permutation(3, 4, 5), Permutation(0, 5, 2, 3)(1, 4))",
            "def G36p():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return a representation of the group G36+, a transitive subgroup of S6\\n    isomorphic to the semidirect product of C3^2 with C4.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(5)(0, 1, 2), Permutation(3, 4, 5), Permutation(0, 5, 2, 3)(1, 4))",
            "def G36p():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return a representation of the group G36+, a transitive subgroup of S6\\n    isomorphic to the semidirect product of C3^2 with C4.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    return PermutationGroup(Permutation(5)(0, 1, 2), Permutation(3, 4, 5), Permutation(0, 5, 2, 3)(1, 4))"
        ]
    },
    {
        "func_name": "G72",
        "original": "def G72():\n    \"\"\"\n    Return a representation of the group G72, a transitive subgroup of S6\n    isomorphic to the semidirect product of C3^2 with D4.\n\n    Notes\n    =====\n\n    See [1], Page 325.\n\n    \"\"\"\n    return PermutationGroup(Permutation(5)(0, 1, 2), Permutation(0, 4, 1, 3)(2, 5), Permutation(0, 3)(1, 4)(2, 5))",
        "mutated": [
            "def G72():\n    if False:\n        i = 10\n    '\\n    Return a representation of the group G72, a transitive subgroup of S6\\n    isomorphic to the semidirect product of C3^2 with D4.\\n\\n    Notes\\n    =====\\n\\n    See [1], Page 325.\\n\\n    '\n    return PermutationGroup(Permutation(5)(0, 1, 2), Permutation(0, 4, 1, 3)(2, 5), Permutation(0, 3)(1, 4)(2, 5))",
            "def G72():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return a representation of the group G72, a transitive subgroup of S6\\n    isomorphic to the semidirect product of C3^2 with D4.\\n\\n    Notes\\n    =====\\n\\n    See [1], Page 325.\\n\\n    '\n    return PermutationGroup(Permutation(5)(0, 1, 2), Permutation(0, 4, 1, 3)(2, 5), Permutation(0, 3)(1, 4)(2, 5))",
            "def G72():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return a representation of the group G72, a transitive subgroup of S6\\n    isomorphic to the semidirect product of C3^2 with D4.\\n\\n    Notes\\n    =====\\n\\n    See [1], Page 325.\\n\\n    '\n    return PermutationGroup(Permutation(5)(0, 1, 2), Permutation(0, 4, 1, 3)(2, 5), Permutation(0, 3)(1, 4)(2, 5))",
            "def G72():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return a representation of the group G72, a transitive subgroup of S6\\n    isomorphic to the semidirect product of C3^2 with D4.\\n\\n    Notes\\n    =====\\n\\n    See [1], Page 325.\\n\\n    '\n    return PermutationGroup(Permutation(5)(0, 1, 2), Permutation(0, 4, 1, 3)(2, 5), Permutation(0, 3)(1, 4)(2, 5))",
            "def G72():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return a representation of the group G72, a transitive subgroup of S6\\n    isomorphic to the semidirect product of C3^2 with D4.\\n\\n    Notes\\n    =====\\n\\n    See [1], Page 325.\\n\\n    '\n    return PermutationGroup(Permutation(5)(0, 1, 2), Permutation(0, 4, 1, 3)(2, 5), Permutation(0, 3)(1, 4)(2, 5))"
        ]
    },
    {
        "func_name": "PSL2F5",
        "original": "def PSL2F5():\n    \"\"\"\n    Return a representation of the group $PSL_2(\\\\mathbb{F}_5)$, as a transitive\n    subgroup of S6, isomorphic to $A_5$.\n\n    Notes\n    =====\n\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\n\n    \"\"\"\n    G = PermutationGroup(Permutation(0, 4, 5)(1, 3, 2), Permutation(0, 4, 3, 1, 5))\n    set_alternating_group_properties(G, 5, 6)\n    return G",
        "mutated": [
            "def PSL2F5():\n    if False:\n        i = 10\n    '\\n    Return a representation of the group $PSL_2(\\\\mathbb{F}_5)$, as a transitive\\n    subgroup of S6, isomorphic to $A_5$.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 4, 5)(1, 3, 2), Permutation(0, 4, 3, 1, 5))\n    set_alternating_group_properties(G, 5, 6)\n    return G",
            "def PSL2F5():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return a representation of the group $PSL_2(\\\\mathbb{F}_5)$, as a transitive\\n    subgroup of S6, isomorphic to $A_5$.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 4, 5)(1, 3, 2), Permutation(0, 4, 3, 1, 5))\n    set_alternating_group_properties(G, 5, 6)\n    return G",
            "def PSL2F5():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return a representation of the group $PSL_2(\\\\mathbb{F}_5)$, as a transitive\\n    subgroup of S6, isomorphic to $A_5$.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 4, 5)(1, 3, 2), Permutation(0, 4, 3, 1, 5))\n    set_alternating_group_properties(G, 5, 6)\n    return G",
            "def PSL2F5():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return a representation of the group $PSL_2(\\\\mathbb{F}_5)$, as a transitive\\n    subgroup of S6, isomorphic to $A_5$.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 4, 5)(1, 3, 2), Permutation(0, 4, 3, 1, 5))\n    set_alternating_group_properties(G, 5, 6)\n    return G",
            "def PSL2F5():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return a representation of the group $PSL_2(\\\\mathbb{F}_5)$, as a transitive\\n    subgroup of S6, isomorphic to $A_5$.\\n\\n    Notes\\n    =====\\n\\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 4, 5)(1, 3, 2), Permutation(0, 4, 3, 1, 5))\n    set_alternating_group_properties(G, 5, 6)\n    return G"
        ]
    },
    {
        "func_name": "PGL2F5",
        "original": "def PGL2F5():\n    \"\"\"\n    Return a representation of the group $PGL_2(\\\\mathbb{F}_5)$, as a transitive\n    subgroup of S6, isomorphic to $S_5$.\n\n    Notes\n    =====\n\n    See [1], Page 325.\n\n    \"\"\"\n    G = PermutationGroup(Permutation(0, 1, 2, 3, 4), Permutation(0, 5)(1, 2)(3, 4))\n    set_symmetric_group_properties(G, 5, 6)\n    return G",
        "mutated": [
            "def PGL2F5():\n    if False:\n        i = 10\n    '\\n    Return a representation of the group $PGL_2(\\\\mathbb{F}_5)$, as a transitive\\n    subgroup of S6, isomorphic to $S_5$.\\n\\n    Notes\\n    =====\\n\\n    See [1], Page 325.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 1, 2, 3, 4), Permutation(0, 5)(1, 2)(3, 4))\n    set_symmetric_group_properties(G, 5, 6)\n    return G",
            "def PGL2F5():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return a representation of the group $PGL_2(\\\\mathbb{F}_5)$, as a transitive\\n    subgroup of S6, isomorphic to $S_5$.\\n\\n    Notes\\n    =====\\n\\n    See [1], Page 325.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 1, 2, 3, 4), Permutation(0, 5)(1, 2)(3, 4))\n    set_symmetric_group_properties(G, 5, 6)\n    return G",
            "def PGL2F5():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return a representation of the group $PGL_2(\\\\mathbb{F}_5)$, as a transitive\\n    subgroup of S6, isomorphic to $S_5$.\\n\\n    Notes\\n    =====\\n\\n    See [1], Page 325.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 1, 2, 3, 4), Permutation(0, 5)(1, 2)(3, 4))\n    set_symmetric_group_properties(G, 5, 6)\n    return G",
            "def PGL2F5():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return a representation of the group $PGL_2(\\\\mathbb{F}_5)$, as a transitive\\n    subgroup of S6, isomorphic to $S_5$.\\n\\n    Notes\\n    =====\\n\\n    See [1], Page 325.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 1, 2, 3, 4), Permutation(0, 5)(1, 2)(3, 4))\n    set_symmetric_group_properties(G, 5, 6)\n    return G",
            "def PGL2F5():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return a representation of the group $PGL_2(\\\\mathbb{F}_5)$, as a transitive\\n    subgroup of S6, isomorphic to $S_5$.\\n\\n    Notes\\n    =====\\n\\n    See [1], Page 325.\\n\\n    '\n    G = PermutationGroup(Permutation(0, 1, 2, 3, 4), Permutation(0, 5)(1, 2)(3, 4))\n    set_symmetric_group_properties(G, 5, 6)\n    return G"
        ]
    },
    {
        "func_name": "elts_by_order",
        "original": "def elts_by_order(G):\n    \"\"\"Sort the elements of a group by their order. \"\"\"\n    elts = defaultdict(list)\n    for g in G.elements:\n        elts[g.order()].append(g)\n    return elts",
        "mutated": [
            "def elts_by_order(G):\n    if False:\n        i = 10\n    'Sort the elements of a group by their order. '\n    elts = defaultdict(list)\n    for g in G.elements:\n        elts[g.order()].append(g)\n    return elts",
            "def elts_by_order(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Sort the elements of a group by their order. '\n    elts = defaultdict(list)\n    for g in G.elements:\n        elts[g.order()].append(g)\n    return elts",
            "def elts_by_order(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Sort the elements of a group by their order. '\n    elts = defaultdict(list)\n    for g in G.elements:\n        elts[g.order()].append(g)\n    return elts",
            "def elts_by_order(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Sort the elements of a group by their order. '\n    elts = defaultdict(list)\n    for g in G.elements:\n        elts[g.order()].append(g)\n    return elts",
            "def elts_by_order(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Sort the elements of a group by their order. '\n    elts = defaultdict(list)\n    for g in G.elements:\n        elts[g.order()].append(g)\n    return elts"
        ]
    },
    {
        "func_name": "order_profile",
        "original": "def order_profile(G, name=None):\n    \"\"\"Determine how many elements a group has, of each order. \"\"\"\n    elts = elts_by_order(G)\n    profile = {o: len(e) for (o, e) in elts.items()}\n    if name:\n        print(f'{name}: ' + ' '.join((f'{len(profile[r])}@{r}' for r in sorted(profile.keys()))))\n    return profile",
        "mutated": [
            "def order_profile(G, name=None):\n    if False:\n        i = 10\n    'Determine how many elements a group has, of each order. '\n    elts = elts_by_order(G)\n    profile = {o: len(e) for (o, e) in elts.items()}\n    if name:\n        print(f'{name}: ' + ' '.join((f'{len(profile[r])}@{r}' for r in sorted(profile.keys()))))\n    return profile",
            "def order_profile(G, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Determine how many elements a group has, of each order. '\n    elts = elts_by_order(G)\n    profile = {o: len(e) for (o, e) in elts.items()}\n    if name:\n        print(f'{name}: ' + ' '.join((f'{len(profile[r])}@{r}' for r in sorted(profile.keys()))))\n    return profile",
            "def order_profile(G, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Determine how many elements a group has, of each order. '\n    elts = elts_by_order(G)\n    profile = {o: len(e) for (o, e) in elts.items()}\n    if name:\n        print(f'{name}: ' + ' '.join((f'{len(profile[r])}@{r}' for r in sorted(profile.keys()))))\n    return profile",
            "def order_profile(G, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Determine how many elements a group has, of each order. '\n    elts = elts_by_order(G)\n    profile = {o: len(e) for (o, e) in elts.items()}\n    if name:\n        print(f'{name}: ' + ' '.join((f'{len(profile[r])}@{r}' for r in sorted(profile.keys()))))\n    return profile",
            "def order_profile(G, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Determine how many elements a group has, of each order. '\n    elts = elts_by_order(G)\n    profile = {o: len(e) for (o, e) in elts.items()}\n    if name:\n        print(f'{name}: ' + ' '.join((f'{len(profile[r])}@{r}' for r in sorted(profile.keys()))))\n    return profile"
        ]
    },
    {
        "func_name": "search",
        "original": "def search(existing_gens, needed_gen_orders, order, alt=None, profile=None, anti_profile=None):\n    \"\"\"\n        Find a transitive subgroup of S6.\n\n        Parameters\n        ==========\n\n        existing_gens : list of Permutation\n            Optionally empty list of generators that must be in the group.\n\n        needed_gen_orders : list of positive int\n            Nonempty list of the orders of the additional generators that are\n            to be found.\n\n        order: int\n            The order of the group being sought.\n\n        alt: bool, None\n            If True, require the group to be contained in A6.\n            If False, require the group not to be contained in A6.\n\n        profile : dict\n            If given, the group's order profile must equal this.\n\n        anti_profile : dict\n            If given, the group's order profile must *not* equal this.\n\n        \"\"\"\n    for gens in itertools.product(*[S6_by_order[n] for n in needed_gen_orders]):\n        if len(set(gens)) < len(gens):\n            continue\n        G = PermutationGroup(existing_gens + list(gens))\n        if G.order() == order and G.is_transitive():\n            if alt is not None and G.is_subgroup(A6) != alt:\n                continue\n            if profile and order_profile(G) != profile:\n                continue\n            if anti_profile and order_profile(G) == anti_profile:\n                continue\n            return G",
        "mutated": [
            "def search(existing_gens, needed_gen_orders, order, alt=None, profile=None, anti_profile=None):\n    if False:\n        i = 10\n    \"\\n        Find a transitive subgroup of S6.\\n\\n        Parameters\\n        ==========\\n\\n        existing_gens : list of Permutation\\n            Optionally empty list of generators that must be in the group.\\n\\n        needed_gen_orders : list of positive int\\n            Nonempty list of the orders of the additional generators that are\\n            to be found.\\n\\n        order: int\\n            The order of the group being sought.\\n\\n        alt: bool, None\\n            If True, require the group to be contained in A6.\\n            If False, require the group not to be contained in A6.\\n\\n        profile : dict\\n            If given, the group's order profile must equal this.\\n\\n        anti_profile : dict\\n            If given, the group's order profile must *not* equal this.\\n\\n        \"\n    for gens in itertools.product(*[S6_by_order[n] for n in needed_gen_orders]):\n        if len(set(gens)) < len(gens):\n            continue\n        G = PermutationGroup(existing_gens + list(gens))\n        if G.order() == order and G.is_transitive():\n            if alt is not None and G.is_subgroup(A6) != alt:\n                continue\n            if profile and order_profile(G) != profile:\n                continue\n            if anti_profile and order_profile(G) == anti_profile:\n                continue\n            return G",
            "def search(existing_gens, needed_gen_orders, order, alt=None, profile=None, anti_profile=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Find a transitive subgroup of S6.\\n\\n        Parameters\\n        ==========\\n\\n        existing_gens : list of Permutation\\n            Optionally empty list of generators that must be in the group.\\n\\n        needed_gen_orders : list of positive int\\n            Nonempty list of the orders of the additional generators that are\\n            to be found.\\n\\n        order: int\\n            The order of the group being sought.\\n\\n        alt: bool, None\\n            If True, require the group to be contained in A6.\\n            If False, require the group not to be contained in A6.\\n\\n        profile : dict\\n            If given, the group's order profile must equal this.\\n\\n        anti_profile : dict\\n            If given, the group's order profile must *not* equal this.\\n\\n        \"\n    for gens in itertools.product(*[S6_by_order[n] for n in needed_gen_orders]):\n        if len(set(gens)) < len(gens):\n            continue\n        G = PermutationGroup(existing_gens + list(gens))\n        if G.order() == order and G.is_transitive():\n            if alt is not None and G.is_subgroup(A6) != alt:\n                continue\n            if profile and order_profile(G) != profile:\n                continue\n            if anti_profile and order_profile(G) == anti_profile:\n                continue\n            return G",
            "def search(existing_gens, needed_gen_orders, order, alt=None, profile=None, anti_profile=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Find a transitive subgroup of S6.\\n\\n        Parameters\\n        ==========\\n\\n        existing_gens : list of Permutation\\n            Optionally empty list of generators that must be in the group.\\n\\n        needed_gen_orders : list of positive int\\n            Nonempty list of the orders of the additional generators that are\\n            to be found.\\n\\n        order: int\\n            The order of the group being sought.\\n\\n        alt: bool, None\\n            If True, require the group to be contained in A6.\\n            If False, require the group not to be contained in A6.\\n\\n        profile : dict\\n            If given, the group's order profile must equal this.\\n\\n        anti_profile : dict\\n            If given, the group's order profile must *not* equal this.\\n\\n        \"\n    for gens in itertools.product(*[S6_by_order[n] for n in needed_gen_orders]):\n        if len(set(gens)) < len(gens):\n            continue\n        G = PermutationGroup(existing_gens + list(gens))\n        if G.order() == order and G.is_transitive():\n            if alt is not None and G.is_subgroup(A6) != alt:\n                continue\n            if profile and order_profile(G) != profile:\n                continue\n            if anti_profile and order_profile(G) == anti_profile:\n                continue\n            return G",
            "def search(existing_gens, needed_gen_orders, order, alt=None, profile=None, anti_profile=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Find a transitive subgroup of S6.\\n\\n        Parameters\\n        ==========\\n\\n        existing_gens : list of Permutation\\n            Optionally empty list of generators that must be in the group.\\n\\n        needed_gen_orders : list of positive int\\n            Nonempty list of the orders of the additional generators that are\\n            to be found.\\n\\n        order: int\\n            The order of the group being sought.\\n\\n        alt: bool, None\\n            If True, require the group to be contained in A6.\\n            If False, require the group not to be contained in A6.\\n\\n        profile : dict\\n            If given, the group's order profile must equal this.\\n\\n        anti_profile : dict\\n            If given, the group's order profile must *not* equal this.\\n\\n        \"\n    for gens in itertools.product(*[S6_by_order[n] for n in needed_gen_orders]):\n        if len(set(gens)) < len(gens):\n            continue\n        G = PermutationGroup(existing_gens + list(gens))\n        if G.order() == order and G.is_transitive():\n            if alt is not None and G.is_subgroup(A6) != alt:\n                continue\n            if profile and order_profile(G) != profile:\n                continue\n            if anti_profile and order_profile(G) == anti_profile:\n                continue\n            return G",
            "def search(existing_gens, needed_gen_orders, order, alt=None, profile=None, anti_profile=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Find a transitive subgroup of S6.\\n\\n        Parameters\\n        ==========\\n\\n        existing_gens : list of Permutation\\n            Optionally empty list of generators that must be in the group.\\n\\n        needed_gen_orders : list of positive int\\n            Nonempty list of the orders of the additional generators that are\\n            to be found.\\n\\n        order: int\\n            The order of the group being sought.\\n\\n        alt: bool, None\\n            If True, require the group to be contained in A6.\\n            If False, require the group not to be contained in A6.\\n\\n        profile : dict\\n            If given, the group's order profile must equal this.\\n\\n        anti_profile : dict\\n            If given, the group's order profile must *not* equal this.\\n\\n        \"\n    for gens in itertools.product(*[S6_by_order[n] for n in needed_gen_orders]):\n        if len(set(gens)) < len(gens):\n            continue\n        G = PermutationGroup(existing_gens + list(gens))\n        if G.order() == order and G.is_transitive():\n            if alt is not None and G.is_subgroup(A6) != alt:\n                continue\n            if profile and order_profile(G) != profile:\n                continue\n            if anti_profile and order_profile(G) == anti_profile:\n                continue\n            return G"
        ]
    },
    {
        "func_name": "match_known_group",
        "original": "def match_known_group(G, alt=None):\n    needed = [g.order() for g in G.generators]\n    return search([], needed, G.order(), alt=alt, profile=order_profile(G))",
        "mutated": [
            "def match_known_group(G, alt=None):\n    if False:\n        i = 10\n    needed = [g.order() for g in G.generators]\n    return search([], needed, G.order(), alt=alt, profile=order_profile(G))",
            "def match_known_group(G, alt=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    needed = [g.order() for g in G.generators]\n    return search([], needed, G.order(), alt=alt, profile=order_profile(G))",
            "def match_known_group(G, alt=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    needed = [g.order() for g in G.generators]\n    return search([], needed, G.order(), alt=alt, profile=order_profile(G))",
            "def match_known_group(G, alt=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    needed = [g.order() for g in G.generators]\n    return search([], needed, G.order(), alt=alt, profile=order_profile(G))",
            "def match_known_group(G, alt=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    needed = [g.order() for g in G.generators]\n    return search([], needed, G.order(), alt=alt, profile=order_profile(G))"
        ]
    },
    {
        "func_name": "finish_up",
        "original": "def finish_up(name, G):\n    found[name] = G\n    if print_report:\n        print('=' * 40)\n        print(f'{name}:')\n        print(G.generators)",
        "mutated": [
            "def finish_up(name, G):\n    if False:\n        i = 10\n    found[name] = G\n    if print_report:\n        print('=' * 40)\n        print(f'{name}:')\n        print(G.generators)",
            "def finish_up(name, G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    found[name] = G\n    if print_report:\n        print('=' * 40)\n        print(f'{name}:')\n        print(G.generators)",
            "def finish_up(name, G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    found[name] = G\n    if print_report:\n        print('=' * 40)\n        print(f'{name}:')\n        print(G.generators)",
            "def finish_up(name, G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    found[name] = G\n    if print_report:\n        print('=' * 40)\n        print(f'{name}:')\n        print(G.generators)",
            "def finish_up(name, G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    found[name] = G\n    if print_report:\n        print('=' * 40)\n        print(f'{name}:')\n        print(G.generators)"
        ]
    },
    {
        "func_name": "find_transitive_subgroups_of_S6",
        "original": "def find_transitive_subgroups_of_S6(*targets, print_report=False):\n    \"\"\"\n    Search for certain transitive subgroups of $S_6$.\n\n    The symmetric group $S_6$ has 16 different transitive subgroups, up to\n    conjugacy. Some are more easily constructed than others. For example, the\n    dihedral group $D_6$ is immediately found, but it is not at all obvious how\n    to realize $S_4$ or $S_5$ *transitively* within $S_6$.\n\n    In some cases there are well-known constructions that can be used. For\n    example, $S_5$ is isomorphic to $PGL_2(\\\\mathbb{F}_5)$, which acts in a\n    natural way on the projective line $P^1(\\\\mathbb{F}_5)$, a set of order 6.\n\n    In absence of such special constructions however, we can simply search for\n    generators. For example, transitive instances of $A_4$ and $S_4$ can be\n    found within $S_6$ in this way.\n\n    Once we are engaged in such searches, it may then be easier (if less\n    elegant) to find even those groups like $S_5$ that do have special\n    constructions, by mere search.\n\n    This function locates generators for transitive instances in $S_6$ of the\n    following subgroups:\n\n    * $A_4$\n    * $S_4^-$ ($S_4$ not contained within $A_6$)\n    * $S_4^+$ ($S_4$ contained within $A_6$)\n    * $A_4 \\\\times C_2$\n    * $S_4 \\\\times C_2$\n    * $G_{18}   = C_3^2 \\\\rtimes C_2$\n    * $G_{36}^- = C_3^2 \\\\rtimes C_2^2$\n    * $G_{36}^+ = C_3^2 \\\\rtimes C_4$\n    * $G_{72}   = C_3^2 \\\\rtimes D_4$\n    * $A_5$\n    * $S_5$\n\n    Note: Each of these groups also has a dedicated function in this module\n    that returns the group immediately, using generators that were found by\n    this search procedure.\n\n    The search procedure serves as a record of how these generators were\n    found. Also, due to randomness in the generation of the elements of\n    permutation groups, it can be called again, in order to (probably) get\n    different generators for the same groups.\n\n    Parameters\n    ==========\n\n    targets : list of :py:class:`~.S6TransitiveSubgroups` values\n        The groups you want to find.\n\n    print_report : bool (default False)\n        If True, print to stdout the generators found for each group.\n\n    Returns\n    =======\n\n    dict\n        mapping each name in *targets* to the :py:class:`~.PermutationGroup`\n        that was found\n\n    References\n    ==========\n\n    .. [2] https://en.wikipedia.org/wiki/Projective_linear_group#Exceptional_isomorphisms\n    .. [3] https://en.wikipedia.org/wiki/Automorphisms_of_the_symmetric_and_alternating_groups#PGL%282,5%29\n\n    \"\"\"\n\n    def elts_by_order(G):\n        \"\"\"Sort the elements of a group by their order. \"\"\"\n        elts = defaultdict(list)\n        for g in G.elements:\n            elts[g.order()].append(g)\n        return elts\n\n    def order_profile(G, name=None):\n        \"\"\"Determine how many elements a group has, of each order. \"\"\"\n        elts = elts_by_order(G)\n        profile = {o: len(e) for (o, e) in elts.items()}\n        if name:\n            print(f'{name}: ' + ' '.join((f'{len(profile[r])}@{r}' for r in sorted(profile.keys()))))\n        return profile\n    S6 = SymmetricGroup(6)\n    A6 = AlternatingGroup(6)\n    S6_by_order = elts_by_order(S6)\n\n    def search(existing_gens, needed_gen_orders, order, alt=None, profile=None, anti_profile=None):\n        \"\"\"\n        Find a transitive subgroup of S6.\n\n        Parameters\n        ==========\n\n        existing_gens : list of Permutation\n            Optionally empty list of generators that must be in the group.\n\n        needed_gen_orders : list of positive int\n            Nonempty list of the orders of the additional generators that are\n            to be found.\n\n        order: int\n            The order of the group being sought.\n\n        alt: bool, None\n            If True, require the group to be contained in A6.\n            If False, require the group not to be contained in A6.\n\n        profile : dict\n            If given, the group's order profile must equal this.\n\n        anti_profile : dict\n            If given, the group's order profile must *not* equal this.\n\n        \"\"\"\n        for gens in itertools.product(*[S6_by_order[n] for n in needed_gen_orders]):\n            if len(set(gens)) < len(gens):\n                continue\n            G = PermutationGroup(existing_gens + list(gens))\n            if G.order() == order and G.is_transitive():\n                if alt is not None and G.is_subgroup(A6) != alt:\n                    continue\n                if profile and order_profile(G) != profile:\n                    continue\n                if anti_profile and order_profile(G) == anti_profile:\n                    continue\n                return G\n\n    def match_known_group(G, alt=None):\n        needed = [g.order() for g in G.generators]\n        return search([], needed, G.order(), alt=alt, profile=order_profile(G))\n    found = {}\n\n    def finish_up(name, G):\n        found[name] = G\n        if print_report:\n            print('=' * 40)\n            print(f'{name}:')\n            print(G.generators)\n    if S6TransitiveSubgroups.A4 in targets or S6TransitiveSubgroups.A4xC2 in targets:\n        A4_in_S6 = match_known_group(AlternatingGroup(4))\n        finish_up(S6TransitiveSubgroups.A4, A4_in_S6)\n    if S6TransitiveSubgroups.S4m in targets or S6TransitiveSubgroups.S4xC2 in targets:\n        S4m_in_S6 = match_known_group(SymmetricGroup(4), alt=False)\n        finish_up(S6TransitiveSubgroups.S4m, S4m_in_S6)\n    if S6TransitiveSubgroups.S4p in targets:\n        S4p_in_S6 = match_known_group(SymmetricGroup(4), alt=True)\n        finish_up(S6TransitiveSubgroups.S4p, S4p_in_S6)\n    if S6TransitiveSubgroups.A4xC2 in targets:\n        A4xC2_in_S6 = search(A4_in_S6.generators, [2], 24, anti_profile=order_profile(SymmetricGroup(4)))\n        finish_up(S6TransitiveSubgroups.A4xC2, A4xC2_in_S6)\n    if S6TransitiveSubgroups.S4xC2 in targets:\n        S4xC2_in_S6 = search(S4m_in_S6.generators, [2], 48)\n        finish_up(S6TransitiveSubgroups.S4xC2, S4xC2_in_S6)\n    N_gens = [Permutation(5)(0, 1, 2), Permutation(5)(3, 4, 5)]\n    if S6TransitiveSubgroups.G18 in targets:\n        G18_in_S6 = search(N_gens, [2], 18)\n        finish_up(S6TransitiveSubgroups.G18, G18_in_S6)\n    if S6TransitiveSubgroups.G36m in targets:\n        G36m_in_S6 = search(N_gens, [2, 2], 36, alt=False)\n        finish_up(S6TransitiveSubgroups.G36m, G36m_in_S6)\n    if S6TransitiveSubgroups.G36p in targets:\n        G36p_in_S6 = search(N_gens, [4], 36, alt=True)\n        finish_up(S6TransitiveSubgroups.G36p, G36p_in_S6)\n    if S6TransitiveSubgroups.G72 in targets:\n        G72_in_S6 = search(N_gens, [4, 2], 72)\n        finish_up(S6TransitiveSubgroups.G72, G72_in_S6)\n    if S6TransitiveSubgroups.PSL2F5 in targets:\n        PSL2F5_in_S6 = match_known_group(AlternatingGroup(5))\n        finish_up(S6TransitiveSubgroups.PSL2F5, PSL2F5_in_S6)\n    if S6TransitiveSubgroups.PGL2F5 in targets:\n        PGL2F5_in_S6 = match_known_group(SymmetricGroup(5))\n        finish_up(S6TransitiveSubgroups.PGL2F5, PGL2F5_in_S6)\n    if S6TransitiveSubgroups.C6 in targets:\n        C6 = match_known_group(CyclicGroup(6))\n        finish_up(S6TransitiveSubgroups.C6, C6)\n    if S6TransitiveSubgroups.S3 in targets:\n        S3 = match_known_group(SymmetricGroup(3))\n        finish_up(S6TransitiveSubgroups.S3, S3)\n    if S6TransitiveSubgroups.D6 in targets:\n        D6 = match_known_group(DihedralGroup(6))\n        finish_up(S6TransitiveSubgroups.D6, D6)\n    if S6TransitiveSubgroups.A6 in targets:\n        A6 = match_known_group(A6)\n        finish_up(S6TransitiveSubgroups.A6, A6)\n    if S6TransitiveSubgroups.S6 in targets:\n        S6 = match_known_group(S6)\n        finish_up(S6TransitiveSubgroups.S6, S6)\n    return found",
        "mutated": [
            "def find_transitive_subgroups_of_S6(*targets, print_report=False):\n    if False:\n        i = 10\n    '\\n    Search for certain transitive subgroups of $S_6$.\\n\\n    The symmetric group $S_6$ has 16 different transitive subgroups, up to\\n    conjugacy. Some are more easily constructed than others. For example, the\\n    dihedral group $D_6$ is immediately found, but it is not at all obvious how\\n    to realize $S_4$ or $S_5$ *transitively* within $S_6$.\\n\\n    In some cases there are well-known constructions that can be used. For\\n    example, $S_5$ is isomorphic to $PGL_2(\\\\mathbb{F}_5)$, which acts in a\\n    natural way on the projective line $P^1(\\\\mathbb{F}_5)$, a set of order 6.\\n\\n    In absence of such special constructions however, we can simply search for\\n    generators. For example, transitive instances of $A_4$ and $S_4$ can be\\n    found within $S_6$ in this way.\\n\\n    Once we are engaged in such searches, it may then be easier (if less\\n    elegant) to find even those groups like $S_5$ that do have special\\n    constructions, by mere search.\\n\\n    This function locates generators for transitive instances in $S_6$ of the\\n    following subgroups:\\n\\n    * $A_4$\\n    * $S_4^-$ ($S_4$ not contained within $A_6$)\\n    * $S_4^+$ ($S_4$ contained within $A_6$)\\n    * $A_4 \\\\times C_2$\\n    * $S_4 \\\\times C_2$\\n    * $G_{18}   = C_3^2 \\\\rtimes C_2$\\n    * $G_{36}^- = C_3^2 \\\\rtimes C_2^2$\\n    * $G_{36}^+ = C_3^2 \\\\rtimes C_4$\\n    * $G_{72}   = C_3^2 \\\\rtimes D_4$\\n    * $A_5$\\n    * $S_5$\\n\\n    Note: Each of these groups also has a dedicated function in this module\\n    that returns the group immediately, using generators that were found by\\n    this search procedure.\\n\\n    The search procedure serves as a record of how these generators were\\n    found. Also, due to randomness in the generation of the elements of\\n    permutation groups, it can be called again, in order to (probably) get\\n    different generators for the same groups.\\n\\n    Parameters\\n    ==========\\n\\n    targets : list of :py:class:`~.S6TransitiveSubgroups` values\\n        The groups you want to find.\\n\\n    print_report : bool (default False)\\n        If True, print to stdout the generators found for each group.\\n\\n    Returns\\n    =======\\n\\n    dict\\n        mapping each name in *targets* to the :py:class:`~.PermutationGroup`\\n        that was found\\n\\n    References\\n    ==========\\n\\n    .. [2] https://en.wikipedia.org/wiki/Projective_linear_group#Exceptional_isomorphisms\\n    .. [3] https://en.wikipedia.org/wiki/Automorphisms_of_the_symmetric_and_alternating_groups#PGL%282,5%29\\n\\n    '\n\n    def elts_by_order(G):\n        \"\"\"Sort the elements of a group by their order. \"\"\"\n        elts = defaultdict(list)\n        for g in G.elements:\n            elts[g.order()].append(g)\n        return elts\n\n    def order_profile(G, name=None):\n        \"\"\"Determine how many elements a group has, of each order. \"\"\"\n        elts = elts_by_order(G)\n        profile = {o: len(e) for (o, e) in elts.items()}\n        if name:\n            print(f'{name}: ' + ' '.join((f'{len(profile[r])}@{r}' for r in sorted(profile.keys()))))\n        return profile\n    S6 = SymmetricGroup(6)\n    A6 = AlternatingGroup(6)\n    S6_by_order = elts_by_order(S6)\n\n    def search(existing_gens, needed_gen_orders, order, alt=None, profile=None, anti_profile=None):\n        \"\"\"\n        Find a transitive subgroup of S6.\n\n        Parameters\n        ==========\n\n        existing_gens : list of Permutation\n            Optionally empty list of generators that must be in the group.\n\n        needed_gen_orders : list of positive int\n            Nonempty list of the orders of the additional generators that are\n            to be found.\n\n        order: int\n            The order of the group being sought.\n\n        alt: bool, None\n            If True, require the group to be contained in A6.\n            If False, require the group not to be contained in A6.\n\n        profile : dict\n            If given, the group's order profile must equal this.\n\n        anti_profile : dict\n            If given, the group's order profile must *not* equal this.\n\n        \"\"\"\n        for gens in itertools.product(*[S6_by_order[n] for n in needed_gen_orders]):\n            if len(set(gens)) < len(gens):\n                continue\n            G = PermutationGroup(existing_gens + list(gens))\n            if G.order() == order and G.is_transitive():\n                if alt is not None and G.is_subgroup(A6) != alt:\n                    continue\n                if profile and order_profile(G) != profile:\n                    continue\n                if anti_profile and order_profile(G) == anti_profile:\n                    continue\n                return G\n\n    def match_known_group(G, alt=None):\n        needed = [g.order() for g in G.generators]\n        return search([], needed, G.order(), alt=alt, profile=order_profile(G))\n    found = {}\n\n    def finish_up(name, G):\n        found[name] = G\n        if print_report:\n            print('=' * 40)\n            print(f'{name}:')\n            print(G.generators)\n    if S6TransitiveSubgroups.A4 in targets or S6TransitiveSubgroups.A4xC2 in targets:\n        A4_in_S6 = match_known_group(AlternatingGroup(4))\n        finish_up(S6TransitiveSubgroups.A4, A4_in_S6)\n    if S6TransitiveSubgroups.S4m in targets or S6TransitiveSubgroups.S4xC2 in targets:\n        S4m_in_S6 = match_known_group(SymmetricGroup(4), alt=False)\n        finish_up(S6TransitiveSubgroups.S4m, S4m_in_S6)\n    if S6TransitiveSubgroups.S4p in targets:\n        S4p_in_S6 = match_known_group(SymmetricGroup(4), alt=True)\n        finish_up(S6TransitiveSubgroups.S4p, S4p_in_S6)\n    if S6TransitiveSubgroups.A4xC2 in targets:\n        A4xC2_in_S6 = search(A4_in_S6.generators, [2], 24, anti_profile=order_profile(SymmetricGroup(4)))\n        finish_up(S6TransitiveSubgroups.A4xC2, A4xC2_in_S6)\n    if S6TransitiveSubgroups.S4xC2 in targets:\n        S4xC2_in_S6 = search(S4m_in_S6.generators, [2], 48)\n        finish_up(S6TransitiveSubgroups.S4xC2, S4xC2_in_S6)\n    N_gens = [Permutation(5)(0, 1, 2), Permutation(5)(3, 4, 5)]\n    if S6TransitiveSubgroups.G18 in targets:\n        G18_in_S6 = search(N_gens, [2], 18)\n        finish_up(S6TransitiveSubgroups.G18, G18_in_S6)\n    if S6TransitiveSubgroups.G36m in targets:\n        G36m_in_S6 = search(N_gens, [2, 2], 36, alt=False)\n        finish_up(S6TransitiveSubgroups.G36m, G36m_in_S6)\n    if S6TransitiveSubgroups.G36p in targets:\n        G36p_in_S6 = search(N_gens, [4], 36, alt=True)\n        finish_up(S6TransitiveSubgroups.G36p, G36p_in_S6)\n    if S6TransitiveSubgroups.G72 in targets:\n        G72_in_S6 = search(N_gens, [4, 2], 72)\n        finish_up(S6TransitiveSubgroups.G72, G72_in_S6)\n    if S6TransitiveSubgroups.PSL2F5 in targets:\n        PSL2F5_in_S6 = match_known_group(AlternatingGroup(5))\n        finish_up(S6TransitiveSubgroups.PSL2F5, PSL2F5_in_S6)\n    if S6TransitiveSubgroups.PGL2F5 in targets:\n        PGL2F5_in_S6 = match_known_group(SymmetricGroup(5))\n        finish_up(S6TransitiveSubgroups.PGL2F5, PGL2F5_in_S6)\n    if S6TransitiveSubgroups.C6 in targets:\n        C6 = match_known_group(CyclicGroup(6))\n        finish_up(S6TransitiveSubgroups.C6, C6)\n    if S6TransitiveSubgroups.S3 in targets:\n        S3 = match_known_group(SymmetricGroup(3))\n        finish_up(S6TransitiveSubgroups.S3, S3)\n    if S6TransitiveSubgroups.D6 in targets:\n        D6 = match_known_group(DihedralGroup(6))\n        finish_up(S6TransitiveSubgroups.D6, D6)\n    if S6TransitiveSubgroups.A6 in targets:\n        A6 = match_known_group(A6)\n        finish_up(S6TransitiveSubgroups.A6, A6)\n    if S6TransitiveSubgroups.S6 in targets:\n        S6 = match_known_group(S6)\n        finish_up(S6TransitiveSubgroups.S6, S6)\n    return found",
            "def find_transitive_subgroups_of_S6(*targets, print_report=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Search for certain transitive subgroups of $S_6$.\\n\\n    The symmetric group $S_6$ has 16 different transitive subgroups, up to\\n    conjugacy. Some are more easily constructed than others. For example, the\\n    dihedral group $D_6$ is immediately found, but it is not at all obvious how\\n    to realize $S_4$ or $S_5$ *transitively* within $S_6$.\\n\\n    In some cases there are well-known constructions that can be used. For\\n    example, $S_5$ is isomorphic to $PGL_2(\\\\mathbb{F}_5)$, which acts in a\\n    natural way on the projective line $P^1(\\\\mathbb{F}_5)$, a set of order 6.\\n\\n    In absence of such special constructions however, we can simply search for\\n    generators. For example, transitive instances of $A_4$ and $S_4$ can be\\n    found within $S_6$ in this way.\\n\\n    Once we are engaged in such searches, it may then be easier (if less\\n    elegant) to find even those groups like $S_5$ that do have special\\n    constructions, by mere search.\\n\\n    This function locates generators for transitive instances in $S_6$ of the\\n    following subgroups:\\n\\n    * $A_4$\\n    * $S_4^-$ ($S_4$ not contained within $A_6$)\\n    * $S_4^+$ ($S_4$ contained within $A_6$)\\n    * $A_4 \\\\times C_2$\\n    * $S_4 \\\\times C_2$\\n    * $G_{18}   = C_3^2 \\\\rtimes C_2$\\n    * $G_{36}^- = C_3^2 \\\\rtimes C_2^2$\\n    * $G_{36}^+ = C_3^2 \\\\rtimes C_4$\\n    * $G_{72}   = C_3^2 \\\\rtimes D_4$\\n    * $A_5$\\n    * $S_5$\\n\\n    Note: Each of these groups also has a dedicated function in this module\\n    that returns the group immediately, using generators that were found by\\n    this search procedure.\\n\\n    The search procedure serves as a record of how these generators were\\n    found. Also, due to randomness in the generation of the elements of\\n    permutation groups, it can be called again, in order to (probably) get\\n    different generators for the same groups.\\n\\n    Parameters\\n    ==========\\n\\n    targets : list of :py:class:`~.S6TransitiveSubgroups` values\\n        The groups you want to find.\\n\\n    print_report : bool (default False)\\n        If True, print to stdout the generators found for each group.\\n\\n    Returns\\n    =======\\n\\n    dict\\n        mapping each name in *targets* to the :py:class:`~.PermutationGroup`\\n        that was found\\n\\n    References\\n    ==========\\n\\n    .. [2] https://en.wikipedia.org/wiki/Projective_linear_group#Exceptional_isomorphisms\\n    .. [3] https://en.wikipedia.org/wiki/Automorphisms_of_the_symmetric_and_alternating_groups#PGL%282,5%29\\n\\n    '\n\n    def elts_by_order(G):\n        \"\"\"Sort the elements of a group by their order. \"\"\"\n        elts = defaultdict(list)\n        for g in G.elements:\n            elts[g.order()].append(g)\n        return elts\n\n    def order_profile(G, name=None):\n        \"\"\"Determine how many elements a group has, of each order. \"\"\"\n        elts = elts_by_order(G)\n        profile = {o: len(e) for (o, e) in elts.items()}\n        if name:\n            print(f'{name}: ' + ' '.join((f'{len(profile[r])}@{r}' for r in sorted(profile.keys()))))\n        return profile\n    S6 = SymmetricGroup(6)\n    A6 = AlternatingGroup(6)\n    S6_by_order = elts_by_order(S6)\n\n    def search(existing_gens, needed_gen_orders, order, alt=None, profile=None, anti_profile=None):\n        \"\"\"\n        Find a transitive subgroup of S6.\n\n        Parameters\n        ==========\n\n        existing_gens : list of Permutation\n            Optionally empty list of generators that must be in the group.\n\n        needed_gen_orders : list of positive int\n            Nonempty list of the orders of the additional generators that are\n            to be found.\n\n        order: int\n            The order of the group being sought.\n\n        alt: bool, None\n            If True, require the group to be contained in A6.\n            If False, require the group not to be contained in A6.\n\n        profile : dict\n            If given, the group's order profile must equal this.\n\n        anti_profile : dict\n            If given, the group's order profile must *not* equal this.\n\n        \"\"\"\n        for gens in itertools.product(*[S6_by_order[n] for n in needed_gen_orders]):\n            if len(set(gens)) < len(gens):\n                continue\n            G = PermutationGroup(existing_gens + list(gens))\n            if G.order() == order and G.is_transitive():\n                if alt is not None and G.is_subgroup(A6) != alt:\n                    continue\n                if profile and order_profile(G) != profile:\n                    continue\n                if anti_profile and order_profile(G) == anti_profile:\n                    continue\n                return G\n\n    def match_known_group(G, alt=None):\n        needed = [g.order() for g in G.generators]\n        return search([], needed, G.order(), alt=alt, profile=order_profile(G))\n    found = {}\n\n    def finish_up(name, G):\n        found[name] = G\n        if print_report:\n            print('=' * 40)\n            print(f'{name}:')\n            print(G.generators)\n    if S6TransitiveSubgroups.A4 in targets or S6TransitiveSubgroups.A4xC2 in targets:\n        A4_in_S6 = match_known_group(AlternatingGroup(4))\n        finish_up(S6TransitiveSubgroups.A4, A4_in_S6)\n    if S6TransitiveSubgroups.S4m in targets or S6TransitiveSubgroups.S4xC2 in targets:\n        S4m_in_S6 = match_known_group(SymmetricGroup(4), alt=False)\n        finish_up(S6TransitiveSubgroups.S4m, S4m_in_S6)\n    if S6TransitiveSubgroups.S4p in targets:\n        S4p_in_S6 = match_known_group(SymmetricGroup(4), alt=True)\n        finish_up(S6TransitiveSubgroups.S4p, S4p_in_S6)\n    if S6TransitiveSubgroups.A4xC2 in targets:\n        A4xC2_in_S6 = search(A4_in_S6.generators, [2], 24, anti_profile=order_profile(SymmetricGroup(4)))\n        finish_up(S6TransitiveSubgroups.A4xC2, A4xC2_in_S6)\n    if S6TransitiveSubgroups.S4xC2 in targets:\n        S4xC2_in_S6 = search(S4m_in_S6.generators, [2], 48)\n        finish_up(S6TransitiveSubgroups.S4xC2, S4xC2_in_S6)\n    N_gens = [Permutation(5)(0, 1, 2), Permutation(5)(3, 4, 5)]\n    if S6TransitiveSubgroups.G18 in targets:\n        G18_in_S6 = search(N_gens, [2], 18)\n        finish_up(S6TransitiveSubgroups.G18, G18_in_S6)\n    if S6TransitiveSubgroups.G36m in targets:\n        G36m_in_S6 = search(N_gens, [2, 2], 36, alt=False)\n        finish_up(S6TransitiveSubgroups.G36m, G36m_in_S6)\n    if S6TransitiveSubgroups.G36p in targets:\n        G36p_in_S6 = search(N_gens, [4], 36, alt=True)\n        finish_up(S6TransitiveSubgroups.G36p, G36p_in_S6)\n    if S6TransitiveSubgroups.G72 in targets:\n        G72_in_S6 = search(N_gens, [4, 2], 72)\n        finish_up(S6TransitiveSubgroups.G72, G72_in_S6)\n    if S6TransitiveSubgroups.PSL2F5 in targets:\n        PSL2F5_in_S6 = match_known_group(AlternatingGroup(5))\n        finish_up(S6TransitiveSubgroups.PSL2F5, PSL2F5_in_S6)\n    if S6TransitiveSubgroups.PGL2F5 in targets:\n        PGL2F5_in_S6 = match_known_group(SymmetricGroup(5))\n        finish_up(S6TransitiveSubgroups.PGL2F5, PGL2F5_in_S6)\n    if S6TransitiveSubgroups.C6 in targets:\n        C6 = match_known_group(CyclicGroup(6))\n        finish_up(S6TransitiveSubgroups.C6, C6)\n    if S6TransitiveSubgroups.S3 in targets:\n        S3 = match_known_group(SymmetricGroup(3))\n        finish_up(S6TransitiveSubgroups.S3, S3)\n    if S6TransitiveSubgroups.D6 in targets:\n        D6 = match_known_group(DihedralGroup(6))\n        finish_up(S6TransitiveSubgroups.D6, D6)\n    if S6TransitiveSubgroups.A6 in targets:\n        A6 = match_known_group(A6)\n        finish_up(S6TransitiveSubgroups.A6, A6)\n    if S6TransitiveSubgroups.S6 in targets:\n        S6 = match_known_group(S6)\n        finish_up(S6TransitiveSubgroups.S6, S6)\n    return found",
            "def find_transitive_subgroups_of_S6(*targets, print_report=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Search for certain transitive subgroups of $S_6$.\\n\\n    The symmetric group $S_6$ has 16 different transitive subgroups, up to\\n    conjugacy. Some are more easily constructed than others. For example, the\\n    dihedral group $D_6$ is immediately found, but it is not at all obvious how\\n    to realize $S_4$ or $S_5$ *transitively* within $S_6$.\\n\\n    In some cases there are well-known constructions that can be used. For\\n    example, $S_5$ is isomorphic to $PGL_2(\\\\mathbb{F}_5)$, which acts in a\\n    natural way on the projective line $P^1(\\\\mathbb{F}_5)$, a set of order 6.\\n\\n    In absence of such special constructions however, we can simply search for\\n    generators. For example, transitive instances of $A_4$ and $S_4$ can be\\n    found within $S_6$ in this way.\\n\\n    Once we are engaged in such searches, it may then be easier (if less\\n    elegant) to find even those groups like $S_5$ that do have special\\n    constructions, by mere search.\\n\\n    This function locates generators for transitive instances in $S_6$ of the\\n    following subgroups:\\n\\n    * $A_4$\\n    * $S_4^-$ ($S_4$ not contained within $A_6$)\\n    * $S_4^+$ ($S_4$ contained within $A_6$)\\n    * $A_4 \\\\times C_2$\\n    * $S_4 \\\\times C_2$\\n    * $G_{18}   = C_3^2 \\\\rtimes C_2$\\n    * $G_{36}^- = C_3^2 \\\\rtimes C_2^2$\\n    * $G_{36}^+ = C_3^2 \\\\rtimes C_4$\\n    * $G_{72}   = C_3^2 \\\\rtimes D_4$\\n    * $A_5$\\n    * $S_5$\\n\\n    Note: Each of these groups also has a dedicated function in this module\\n    that returns the group immediately, using generators that were found by\\n    this search procedure.\\n\\n    The search procedure serves as a record of how these generators were\\n    found. Also, due to randomness in the generation of the elements of\\n    permutation groups, it can be called again, in order to (probably) get\\n    different generators for the same groups.\\n\\n    Parameters\\n    ==========\\n\\n    targets : list of :py:class:`~.S6TransitiveSubgroups` values\\n        The groups you want to find.\\n\\n    print_report : bool (default False)\\n        If True, print to stdout the generators found for each group.\\n\\n    Returns\\n    =======\\n\\n    dict\\n        mapping each name in *targets* to the :py:class:`~.PermutationGroup`\\n        that was found\\n\\n    References\\n    ==========\\n\\n    .. [2] https://en.wikipedia.org/wiki/Projective_linear_group#Exceptional_isomorphisms\\n    .. [3] https://en.wikipedia.org/wiki/Automorphisms_of_the_symmetric_and_alternating_groups#PGL%282,5%29\\n\\n    '\n\n    def elts_by_order(G):\n        \"\"\"Sort the elements of a group by their order. \"\"\"\n        elts = defaultdict(list)\n        for g in G.elements:\n            elts[g.order()].append(g)\n        return elts\n\n    def order_profile(G, name=None):\n        \"\"\"Determine how many elements a group has, of each order. \"\"\"\n        elts = elts_by_order(G)\n        profile = {o: len(e) for (o, e) in elts.items()}\n        if name:\n            print(f'{name}: ' + ' '.join((f'{len(profile[r])}@{r}' for r in sorted(profile.keys()))))\n        return profile\n    S6 = SymmetricGroup(6)\n    A6 = AlternatingGroup(6)\n    S6_by_order = elts_by_order(S6)\n\n    def search(existing_gens, needed_gen_orders, order, alt=None, profile=None, anti_profile=None):\n        \"\"\"\n        Find a transitive subgroup of S6.\n\n        Parameters\n        ==========\n\n        existing_gens : list of Permutation\n            Optionally empty list of generators that must be in the group.\n\n        needed_gen_orders : list of positive int\n            Nonempty list of the orders of the additional generators that are\n            to be found.\n\n        order: int\n            The order of the group being sought.\n\n        alt: bool, None\n            If True, require the group to be contained in A6.\n            If False, require the group not to be contained in A6.\n\n        profile : dict\n            If given, the group's order profile must equal this.\n\n        anti_profile : dict\n            If given, the group's order profile must *not* equal this.\n\n        \"\"\"\n        for gens in itertools.product(*[S6_by_order[n] for n in needed_gen_orders]):\n            if len(set(gens)) < len(gens):\n                continue\n            G = PermutationGroup(existing_gens + list(gens))\n            if G.order() == order and G.is_transitive():\n                if alt is not None and G.is_subgroup(A6) != alt:\n                    continue\n                if profile and order_profile(G) != profile:\n                    continue\n                if anti_profile and order_profile(G) == anti_profile:\n                    continue\n                return G\n\n    def match_known_group(G, alt=None):\n        needed = [g.order() for g in G.generators]\n        return search([], needed, G.order(), alt=alt, profile=order_profile(G))\n    found = {}\n\n    def finish_up(name, G):\n        found[name] = G\n        if print_report:\n            print('=' * 40)\n            print(f'{name}:')\n            print(G.generators)\n    if S6TransitiveSubgroups.A4 in targets or S6TransitiveSubgroups.A4xC2 in targets:\n        A4_in_S6 = match_known_group(AlternatingGroup(4))\n        finish_up(S6TransitiveSubgroups.A4, A4_in_S6)\n    if S6TransitiveSubgroups.S4m in targets or S6TransitiveSubgroups.S4xC2 in targets:\n        S4m_in_S6 = match_known_group(SymmetricGroup(4), alt=False)\n        finish_up(S6TransitiveSubgroups.S4m, S4m_in_S6)\n    if S6TransitiveSubgroups.S4p in targets:\n        S4p_in_S6 = match_known_group(SymmetricGroup(4), alt=True)\n        finish_up(S6TransitiveSubgroups.S4p, S4p_in_S6)\n    if S6TransitiveSubgroups.A4xC2 in targets:\n        A4xC2_in_S6 = search(A4_in_S6.generators, [2], 24, anti_profile=order_profile(SymmetricGroup(4)))\n        finish_up(S6TransitiveSubgroups.A4xC2, A4xC2_in_S6)\n    if S6TransitiveSubgroups.S4xC2 in targets:\n        S4xC2_in_S6 = search(S4m_in_S6.generators, [2], 48)\n        finish_up(S6TransitiveSubgroups.S4xC2, S4xC2_in_S6)\n    N_gens = [Permutation(5)(0, 1, 2), Permutation(5)(3, 4, 5)]\n    if S6TransitiveSubgroups.G18 in targets:\n        G18_in_S6 = search(N_gens, [2], 18)\n        finish_up(S6TransitiveSubgroups.G18, G18_in_S6)\n    if S6TransitiveSubgroups.G36m in targets:\n        G36m_in_S6 = search(N_gens, [2, 2], 36, alt=False)\n        finish_up(S6TransitiveSubgroups.G36m, G36m_in_S6)\n    if S6TransitiveSubgroups.G36p in targets:\n        G36p_in_S6 = search(N_gens, [4], 36, alt=True)\n        finish_up(S6TransitiveSubgroups.G36p, G36p_in_S6)\n    if S6TransitiveSubgroups.G72 in targets:\n        G72_in_S6 = search(N_gens, [4, 2], 72)\n        finish_up(S6TransitiveSubgroups.G72, G72_in_S6)\n    if S6TransitiveSubgroups.PSL2F5 in targets:\n        PSL2F5_in_S6 = match_known_group(AlternatingGroup(5))\n        finish_up(S6TransitiveSubgroups.PSL2F5, PSL2F5_in_S6)\n    if S6TransitiveSubgroups.PGL2F5 in targets:\n        PGL2F5_in_S6 = match_known_group(SymmetricGroup(5))\n        finish_up(S6TransitiveSubgroups.PGL2F5, PGL2F5_in_S6)\n    if S6TransitiveSubgroups.C6 in targets:\n        C6 = match_known_group(CyclicGroup(6))\n        finish_up(S6TransitiveSubgroups.C6, C6)\n    if S6TransitiveSubgroups.S3 in targets:\n        S3 = match_known_group(SymmetricGroup(3))\n        finish_up(S6TransitiveSubgroups.S3, S3)\n    if S6TransitiveSubgroups.D6 in targets:\n        D6 = match_known_group(DihedralGroup(6))\n        finish_up(S6TransitiveSubgroups.D6, D6)\n    if S6TransitiveSubgroups.A6 in targets:\n        A6 = match_known_group(A6)\n        finish_up(S6TransitiveSubgroups.A6, A6)\n    if S6TransitiveSubgroups.S6 in targets:\n        S6 = match_known_group(S6)\n        finish_up(S6TransitiveSubgroups.S6, S6)\n    return found",
            "def find_transitive_subgroups_of_S6(*targets, print_report=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Search for certain transitive subgroups of $S_6$.\\n\\n    The symmetric group $S_6$ has 16 different transitive subgroups, up to\\n    conjugacy. Some are more easily constructed than others. For example, the\\n    dihedral group $D_6$ is immediately found, but it is not at all obvious how\\n    to realize $S_4$ or $S_5$ *transitively* within $S_6$.\\n\\n    In some cases there are well-known constructions that can be used. For\\n    example, $S_5$ is isomorphic to $PGL_2(\\\\mathbb{F}_5)$, which acts in a\\n    natural way on the projective line $P^1(\\\\mathbb{F}_5)$, a set of order 6.\\n\\n    In absence of such special constructions however, we can simply search for\\n    generators. For example, transitive instances of $A_4$ and $S_4$ can be\\n    found within $S_6$ in this way.\\n\\n    Once we are engaged in such searches, it may then be easier (if less\\n    elegant) to find even those groups like $S_5$ that do have special\\n    constructions, by mere search.\\n\\n    This function locates generators for transitive instances in $S_6$ of the\\n    following subgroups:\\n\\n    * $A_4$\\n    * $S_4^-$ ($S_4$ not contained within $A_6$)\\n    * $S_4^+$ ($S_4$ contained within $A_6$)\\n    * $A_4 \\\\times C_2$\\n    * $S_4 \\\\times C_2$\\n    * $G_{18}   = C_3^2 \\\\rtimes C_2$\\n    * $G_{36}^- = C_3^2 \\\\rtimes C_2^2$\\n    * $G_{36}^+ = C_3^2 \\\\rtimes C_4$\\n    * $G_{72}   = C_3^2 \\\\rtimes D_4$\\n    * $A_5$\\n    * $S_5$\\n\\n    Note: Each of these groups also has a dedicated function in this module\\n    that returns the group immediately, using generators that were found by\\n    this search procedure.\\n\\n    The search procedure serves as a record of how these generators were\\n    found. Also, due to randomness in the generation of the elements of\\n    permutation groups, it can be called again, in order to (probably) get\\n    different generators for the same groups.\\n\\n    Parameters\\n    ==========\\n\\n    targets : list of :py:class:`~.S6TransitiveSubgroups` values\\n        The groups you want to find.\\n\\n    print_report : bool (default False)\\n        If True, print to stdout the generators found for each group.\\n\\n    Returns\\n    =======\\n\\n    dict\\n        mapping each name in *targets* to the :py:class:`~.PermutationGroup`\\n        that was found\\n\\n    References\\n    ==========\\n\\n    .. [2] https://en.wikipedia.org/wiki/Projective_linear_group#Exceptional_isomorphisms\\n    .. [3] https://en.wikipedia.org/wiki/Automorphisms_of_the_symmetric_and_alternating_groups#PGL%282,5%29\\n\\n    '\n\n    def elts_by_order(G):\n        \"\"\"Sort the elements of a group by their order. \"\"\"\n        elts = defaultdict(list)\n        for g in G.elements:\n            elts[g.order()].append(g)\n        return elts\n\n    def order_profile(G, name=None):\n        \"\"\"Determine how many elements a group has, of each order. \"\"\"\n        elts = elts_by_order(G)\n        profile = {o: len(e) for (o, e) in elts.items()}\n        if name:\n            print(f'{name}: ' + ' '.join((f'{len(profile[r])}@{r}' for r in sorted(profile.keys()))))\n        return profile\n    S6 = SymmetricGroup(6)\n    A6 = AlternatingGroup(6)\n    S6_by_order = elts_by_order(S6)\n\n    def search(existing_gens, needed_gen_orders, order, alt=None, profile=None, anti_profile=None):\n        \"\"\"\n        Find a transitive subgroup of S6.\n\n        Parameters\n        ==========\n\n        existing_gens : list of Permutation\n            Optionally empty list of generators that must be in the group.\n\n        needed_gen_orders : list of positive int\n            Nonempty list of the orders of the additional generators that are\n            to be found.\n\n        order: int\n            The order of the group being sought.\n\n        alt: bool, None\n            If True, require the group to be contained in A6.\n            If False, require the group not to be contained in A6.\n\n        profile : dict\n            If given, the group's order profile must equal this.\n\n        anti_profile : dict\n            If given, the group's order profile must *not* equal this.\n\n        \"\"\"\n        for gens in itertools.product(*[S6_by_order[n] for n in needed_gen_orders]):\n            if len(set(gens)) < len(gens):\n                continue\n            G = PermutationGroup(existing_gens + list(gens))\n            if G.order() == order and G.is_transitive():\n                if alt is not None and G.is_subgroup(A6) != alt:\n                    continue\n                if profile and order_profile(G) != profile:\n                    continue\n                if anti_profile and order_profile(G) == anti_profile:\n                    continue\n                return G\n\n    def match_known_group(G, alt=None):\n        needed = [g.order() for g in G.generators]\n        return search([], needed, G.order(), alt=alt, profile=order_profile(G))\n    found = {}\n\n    def finish_up(name, G):\n        found[name] = G\n        if print_report:\n            print('=' * 40)\n            print(f'{name}:')\n            print(G.generators)\n    if S6TransitiveSubgroups.A4 in targets or S6TransitiveSubgroups.A4xC2 in targets:\n        A4_in_S6 = match_known_group(AlternatingGroup(4))\n        finish_up(S6TransitiveSubgroups.A4, A4_in_S6)\n    if S6TransitiveSubgroups.S4m in targets or S6TransitiveSubgroups.S4xC2 in targets:\n        S4m_in_S6 = match_known_group(SymmetricGroup(4), alt=False)\n        finish_up(S6TransitiveSubgroups.S4m, S4m_in_S6)\n    if S6TransitiveSubgroups.S4p in targets:\n        S4p_in_S6 = match_known_group(SymmetricGroup(4), alt=True)\n        finish_up(S6TransitiveSubgroups.S4p, S4p_in_S6)\n    if S6TransitiveSubgroups.A4xC2 in targets:\n        A4xC2_in_S6 = search(A4_in_S6.generators, [2], 24, anti_profile=order_profile(SymmetricGroup(4)))\n        finish_up(S6TransitiveSubgroups.A4xC2, A4xC2_in_S6)\n    if S6TransitiveSubgroups.S4xC2 in targets:\n        S4xC2_in_S6 = search(S4m_in_S6.generators, [2], 48)\n        finish_up(S6TransitiveSubgroups.S4xC2, S4xC2_in_S6)\n    N_gens = [Permutation(5)(0, 1, 2), Permutation(5)(3, 4, 5)]\n    if S6TransitiveSubgroups.G18 in targets:\n        G18_in_S6 = search(N_gens, [2], 18)\n        finish_up(S6TransitiveSubgroups.G18, G18_in_S6)\n    if S6TransitiveSubgroups.G36m in targets:\n        G36m_in_S6 = search(N_gens, [2, 2], 36, alt=False)\n        finish_up(S6TransitiveSubgroups.G36m, G36m_in_S6)\n    if S6TransitiveSubgroups.G36p in targets:\n        G36p_in_S6 = search(N_gens, [4], 36, alt=True)\n        finish_up(S6TransitiveSubgroups.G36p, G36p_in_S6)\n    if S6TransitiveSubgroups.G72 in targets:\n        G72_in_S6 = search(N_gens, [4, 2], 72)\n        finish_up(S6TransitiveSubgroups.G72, G72_in_S6)\n    if S6TransitiveSubgroups.PSL2F5 in targets:\n        PSL2F5_in_S6 = match_known_group(AlternatingGroup(5))\n        finish_up(S6TransitiveSubgroups.PSL2F5, PSL2F5_in_S6)\n    if S6TransitiveSubgroups.PGL2F5 in targets:\n        PGL2F5_in_S6 = match_known_group(SymmetricGroup(5))\n        finish_up(S6TransitiveSubgroups.PGL2F5, PGL2F5_in_S6)\n    if S6TransitiveSubgroups.C6 in targets:\n        C6 = match_known_group(CyclicGroup(6))\n        finish_up(S6TransitiveSubgroups.C6, C6)\n    if S6TransitiveSubgroups.S3 in targets:\n        S3 = match_known_group(SymmetricGroup(3))\n        finish_up(S6TransitiveSubgroups.S3, S3)\n    if S6TransitiveSubgroups.D6 in targets:\n        D6 = match_known_group(DihedralGroup(6))\n        finish_up(S6TransitiveSubgroups.D6, D6)\n    if S6TransitiveSubgroups.A6 in targets:\n        A6 = match_known_group(A6)\n        finish_up(S6TransitiveSubgroups.A6, A6)\n    if S6TransitiveSubgroups.S6 in targets:\n        S6 = match_known_group(S6)\n        finish_up(S6TransitiveSubgroups.S6, S6)\n    return found",
            "def find_transitive_subgroups_of_S6(*targets, print_report=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Search for certain transitive subgroups of $S_6$.\\n\\n    The symmetric group $S_6$ has 16 different transitive subgroups, up to\\n    conjugacy. Some are more easily constructed than others. For example, the\\n    dihedral group $D_6$ is immediately found, but it is not at all obvious how\\n    to realize $S_4$ or $S_5$ *transitively* within $S_6$.\\n\\n    In some cases there are well-known constructions that can be used. For\\n    example, $S_5$ is isomorphic to $PGL_2(\\\\mathbb{F}_5)$, which acts in a\\n    natural way on the projective line $P^1(\\\\mathbb{F}_5)$, a set of order 6.\\n\\n    In absence of such special constructions however, we can simply search for\\n    generators. For example, transitive instances of $A_4$ and $S_4$ can be\\n    found within $S_6$ in this way.\\n\\n    Once we are engaged in such searches, it may then be easier (if less\\n    elegant) to find even those groups like $S_5$ that do have special\\n    constructions, by mere search.\\n\\n    This function locates generators for transitive instances in $S_6$ of the\\n    following subgroups:\\n\\n    * $A_4$\\n    * $S_4^-$ ($S_4$ not contained within $A_6$)\\n    * $S_4^+$ ($S_4$ contained within $A_6$)\\n    * $A_4 \\\\times C_2$\\n    * $S_4 \\\\times C_2$\\n    * $G_{18}   = C_3^2 \\\\rtimes C_2$\\n    * $G_{36}^- = C_3^2 \\\\rtimes C_2^2$\\n    * $G_{36}^+ = C_3^2 \\\\rtimes C_4$\\n    * $G_{72}   = C_3^2 \\\\rtimes D_4$\\n    * $A_5$\\n    * $S_5$\\n\\n    Note: Each of these groups also has a dedicated function in this module\\n    that returns the group immediately, using generators that were found by\\n    this search procedure.\\n\\n    The search procedure serves as a record of how these generators were\\n    found. Also, due to randomness in the generation of the elements of\\n    permutation groups, it can be called again, in order to (probably) get\\n    different generators for the same groups.\\n\\n    Parameters\\n    ==========\\n\\n    targets : list of :py:class:`~.S6TransitiveSubgroups` values\\n        The groups you want to find.\\n\\n    print_report : bool (default False)\\n        If True, print to stdout the generators found for each group.\\n\\n    Returns\\n    =======\\n\\n    dict\\n        mapping each name in *targets* to the :py:class:`~.PermutationGroup`\\n        that was found\\n\\n    References\\n    ==========\\n\\n    .. [2] https://en.wikipedia.org/wiki/Projective_linear_group#Exceptional_isomorphisms\\n    .. [3] https://en.wikipedia.org/wiki/Automorphisms_of_the_symmetric_and_alternating_groups#PGL%282,5%29\\n\\n    '\n\n    def elts_by_order(G):\n        \"\"\"Sort the elements of a group by their order. \"\"\"\n        elts = defaultdict(list)\n        for g in G.elements:\n            elts[g.order()].append(g)\n        return elts\n\n    def order_profile(G, name=None):\n        \"\"\"Determine how many elements a group has, of each order. \"\"\"\n        elts = elts_by_order(G)\n        profile = {o: len(e) for (o, e) in elts.items()}\n        if name:\n            print(f'{name}: ' + ' '.join((f'{len(profile[r])}@{r}' for r in sorted(profile.keys()))))\n        return profile\n    S6 = SymmetricGroup(6)\n    A6 = AlternatingGroup(6)\n    S6_by_order = elts_by_order(S6)\n\n    def search(existing_gens, needed_gen_orders, order, alt=None, profile=None, anti_profile=None):\n        \"\"\"\n        Find a transitive subgroup of S6.\n\n        Parameters\n        ==========\n\n        existing_gens : list of Permutation\n            Optionally empty list of generators that must be in the group.\n\n        needed_gen_orders : list of positive int\n            Nonempty list of the orders of the additional generators that are\n            to be found.\n\n        order: int\n            The order of the group being sought.\n\n        alt: bool, None\n            If True, require the group to be contained in A6.\n            If False, require the group not to be contained in A6.\n\n        profile : dict\n            If given, the group's order profile must equal this.\n\n        anti_profile : dict\n            If given, the group's order profile must *not* equal this.\n\n        \"\"\"\n        for gens in itertools.product(*[S6_by_order[n] for n in needed_gen_orders]):\n            if len(set(gens)) < len(gens):\n                continue\n            G = PermutationGroup(existing_gens + list(gens))\n            if G.order() == order and G.is_transitive():\n                if alt is not None and G.is_subgroup(A6) != alt:\n                    continue\n                if profile and order_profile(G) != profile:\n                    continue\n                if anti_profile and order_profile(G) == anti_profile:\n                    continue\n                return G\n\n    def match_known_group(G, alt=None):\n        needed = [g.order() for g in G.generators]\n        return search([], needed, G.order(), alt=alt, profile=order_profile(G))\n    found = {}\n\n    def finish_up(name, G):\n        found[name] = G\n        if print_report:\n            print('=' * 40)\n            print(f'{name}:')\n            print(G.generators)\n    if S6TransitiveSubgroups.A4 in targets or S6TransitiveSubgroups.A4xC2 in targets:\n        A4_in_S6 = match_known_group(AlternatingGroup(4))\n        finish_up(S6TransitiveSubgroups.A4, A4_in_S6)\n    if S6TransitiveSubgroups.S4m in targets or S6TransitiveSubgroups.S4xC2 in targets:\n        S4m_in_S6 = match_known_group(SymmetricGroup(4), alt=False)\n        finish_up(S6TransitiveSubgroups.S4m, S4m_in_S6)\n    if S6TransitiveSubgroups.S4p in targets:\n        S4p_in_S6 = match_known_group(SymmetricGroup(4), alt=True)\n        finish_up(S6TransitiveSubgroups.S4p, S4p_in_S6)\n    if S6TransitiveSubgroups.A4xC2 in targets:\n        A4xC2_in_S6 = search(A4_in_S6.generators, [2], 24, anti_profile=order_profile(SymmetricGroup(4)))\n        finish_up(S6TransitiveSubgroups.A4xC2, A4xC2_in_S6)\n    if S6TransitiveSubgroups.S4xC2 in targets:\n        S4xC2_in_S6 = search(S4m_in_S6.generators, [2], 48)\n        finish_up(S6TransitiveSubgroups.S4xC2, S4xC2_in_S6)\n    N_gens = [Permutation(5)(0, 1, 2), Permutation(5)(3, 4, 5)]\n    if S6TransitiveSubgroups.G18 in targets:\n        G18_in_S6 = search(N_gens, [2], 18)\n        finish_up(S6TransitiveSubgroups.G18, G18_in_S6)\n    if S6TransitiveSubgroups.G36m in targets:\n        G36m_in_S6 = search(N_gens, [2, 2], 36, alt=False)\n        finish_up(S6TransitiveSubgroups.G36m, G36m_in_S6)\n    if S6TransitiveSubgroups.G36p in targets:\n        G36p_in_S6 = search(N_gens, [4], 36, alt=True)\n        finish_up(S6TransitiveSubgroups.G36p, G36p_in_S6)\n    if S6TransitiveSubgroups.G72 in targets:\n        G72_in_S6 = search(N_gens, [4, 2], 72)\n        finish_up(S6TransitiveSubgroups.G72, G72_in_S6)\n    if S6TransitiveSubgroups.PSL2F5 in targets:\n        PSL2F5_in_S6 = match_known_group(AlternatingGroup(5))\n        finish_up(S6TransitiveSubgroups.PSL2F5, PSL2F5_in_S6)\n    if S6TransitiveSubgroups.PGL2F5 in targets:\n        PGL2F5_in_S6 = match_known_group(SymmetricGroup(5))\n        finish_up(S6TransitiveSubgroups.PGL2F5, PGL2F5_in_S6)\n    if S6TransitiveSubgroups.C6 in targets:\n        C6 = match_known_group(CyclicGroup(6))\n        finish_up(S6TransitiveSubgroups.C6, C6)\n    if S6TransitiveSubgroups.S3 in targets:\n        S3 = match_known_group(SymmetricGroup(3))\n        finish_up(S6TransitiveSubgroups.S3, S3)\n    if S6TransitiveSubgroups.D6 in targets:\n        D6 = match_known_group(DihedralGroup(6))\n        finish_up(S6TransitiveSubgroups.D6, D6)\n    if S6TransitiveSubgroups.A6 in targets:\n        A6 = match_known_group(A6)\n        finish_up(S6TransitiveSubgroups.A6, A6)\n    if S6TransitiveSubgroups.S6 in targets:\n        S6 = match_known_group(S6)\n        finish_up(S6TransitiveSubgroups.S6, S6)\n    return found"
        ]
    }
]