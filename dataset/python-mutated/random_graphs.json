[
    {
        "func_name": "fast_gnp_random_graph",
        "original": "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef fast_gnp_random_graph(n, p, seed=None, directed=False):\n    \"\"\"Returns a $G_{n,p}$ random graph, also known as an Erd\u0151s-R\u00e9nyi graph or\n    a binomial graph.\n\n    Parameters\n    ----------\n    n : int\n        The number of nodes.\n    p : float\n        Probability for edge creation.\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n    directed : bool, optional (default=False)\n        If True, this function returns a directed graph.\n\n    Notes\n    -----\n    The $G_{n,p}$ graph algorithm chooses each of the $[n (n - 1)] / 2$\n    (undirected) or $n (n - 1)$ (directed) possible edges with probability $p$.\n\n    This algorithm [1]_ runs in $O(n + m)$ time, where `m` is the expected number of\n    edges, which equals $p n (n - 1) / 2$. This should be faster than\n    :func:`gnp_random_graph` when $p$ is small and the expected number of edges\n    is small (that is, the graph is sparse).\n\n    See Also\n    --------\n    gnp_random_graph\n\n    References\n    ----------\n    .. [1] Vladimir Batagelj and Ulrik Brandes,\n       \"Efficient generation of large random networks\",\n       Phys. Rev. E, 71, 036113, 2005.\n    \"\"\"\n    G = empty_graph(n)\n    if p <= 0 or p >= 1:\n        return nx.gnp_random_graph(n, p, seed=seed, directed=directed)\n    lp = math.log(1.0 - p)\n    if directed:\n        G = nx.DiGraph(G)\n        v = 1\n        w = -1\n        while v < n:\n            lr = math.log(1.0 - seed.random())\n            w = w + 1 + int(lr / lp)\n            while w >= v and v < n:\n                w = w - v\n                v = v + 1\n            if v < n:\n                G.add_edge(w, v)\n    v = 1\n    w = -1\n    while v < n:\n        lr = math.log(1.0 - seed.random())\n        w = w + 1 + int(lr / lp)\n        while w >= v and v < n:\n            w = w - v\n            v = v + 1\n        if v < n:\n            G.add_edge(v, w)\n    return G",
        "mutated": [
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef fast_gnp_random_graph(n, p, seed=None, directed=False):\n    if False:\n        i = 10\n    'Returns a $G_{n,p}$ random graph, also known as an Erd\u0151s-R\u00e9nyi graph or\\n    a binomial graph.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    p : float\\n        Probability for edge creation.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    directed : bool, optional (default=False)\\n        If True, this function returns a directed graph.\\n\\n    Notes\\n    -----\\n    The $G_{n,p}$ graph algorithm chooses each of the $[n (n - 1)] / 2$\\n    (undirected) or $n (n - 1)$ (directed) possible edges with probability $p$.\\n\\n    This algorithm [1]_ runs in $O(n + m)$ time, where `m` is the expected number of\\n    edges, which equals $p n (n - 1) / 2$. This should be faster than\\n    :func:`gnp_random_graph` when $p$ is small and the expected number of edges\\n    is small (that is, the graph is sparse).\\n\\n    See Also\\n    --------\\n    gnp_random_graph\\n\\n    References\\n    ----------\\n    .. [1] Vladimir Batagelj and Ulrik Brandes,\\n       \"Efficient generation of large random networks\",\\n       Phys. Rev. E, 71, 036113, 2005.\\n    '\n    G = empty_graph(n)\n    if p <= 0 or p >= 1:\n        return nx.gnp_random_graph(n, p, seed=seed, directed=directed)\n    lp = math.log(1.0 - p)\n    if directed:\n        G = nx.DiGraph(G)\n        v = 1\n        w = -1\n        while v < n:\n            lr = math.log(1.0 - seed.random())\n            w = w + 1 + int(lr / lp)\n            while w >= v and v < n:\n                w = w - v\n                v = v + 1\n            if v < n:\n                G.add_edge(w, v)\n    v = 1\n    w = -1\n    while v < n:\n        lr = math.log(1.0 - seed.random())\n        w = w + 1 + int(lr / lp)\n        while w >= v and v < n:\n            w = w - v\n            v = v + 1\n        if v < n:\n            G.add_edge(v, w)\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef fast_gnp_random_graph(n, p, seed=None, directed=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a $G_{n,p}$ random graph, also known as an Erd\u0151s-R\u00e9nyi graph or\\n    a binomial graph.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    p : float\\n        Probability for edge creation.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    directed : bool, optional (default=False)\\n        If True, this function returns a directed graph.\\n\\n    Notes\\n    -----\\n    The $G_{n,p}$ graph algorithm chooses each of the $[n (n - 1)] / 2$\\n    (undirected) or $n (n - 1)$ (directed) possible edges with probability $p$.\\n\\n    This algorithm [1]_ runs in $O(n + m)$ time, where `m` is the expected number of\\n    edges, which equals $p n (n - 1) / 2$. This should be faster than\\n    :func:`gnp_random_graph` when $p$ is small and the expected number of edges\\n    is small (that is, the graph is sparse).\\n\\n    See Also\\n    --------\\n    gnp_random_graph\\n\\n    References\\n    ----------\\n    .. [1] Vladimir Batagelj and Ulrik Brandes,\\n       \"Efficient generation of large random networks\",\\n       Phys. Rev. E, 71, 036113, 2005.\\n    '\n    G = empty_graph(n)\n    if p <= 0 or p >= 1:\n        return nx.gnp_random_graph(n, p, seed=seed, directed=directed)\n    lp = math.log(1.0 - p)\n    if directed:\n        G = nx.DiGraph(G)\n        v = 1\n        w = -1\n        while v < n:\n            lr = math.log(1.0 - seed.random())\n            w = w + 1 + int(lr / lp)\n            while w >= v and v < n:\n                w = w - v\n                v = v + 1\n            if v < n:\n                G.add_edge(w, v)\n    v = 1\n    w = -1\n    while v < n:\n        lr = math.log(1.0 - seed.random())\n        w = w + 1 + int(lr / lp)\n        while w >= v and v < n:\n            w = w - v\n            v = v + 1\n        if v < n:\n            G.add_edge(v, w)\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef fast_gnp_random_graph(n, p, seed=None, directed=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a $G_{n,p}$ random graph, also known as an Erd\u0151s-R\u00e9nyi graph or\\n    a binomial graph.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    p : float\\n        Probability for edge creation.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    directed : bool, optional (default=False)\\n        If True, this function returns a directed graph.\\n\\n    Notes\\n    -----\\n    The $G_{n,p}$ graph algorithm chooses each of the $[n (n - 1)] / 2$\\n    (undirected) or $n (n - 1)$ (directed) possible edges with probability $p$.\\n\\n    This algorithm [1]_ runs in $O(n + m)$ time, where `m` is the expected number of\\n    edges, which equals $p n (n - 1) / 2$. This should be faster than\\n    :func:`gnp_random_graph` when $p$ is small and the expected number of edges\\n    is small (that is, the graph is sparse).\\n\\n    See Also\\n    --------\\n    gnp_random_graph\\n\\n    References\\n    ----------\\n    .. [1] Vladimir Batagelj and Ulrik Brandes,\\n       \"Efficient generation of large random networks\",\\n       Phys. Rev. E, 71, 036113, 2005.\\n    '\n    G = empty_graph(n)\n    if p <= 0 or p >= 1:\n        return nx.gnp_random_graph(n, p, seed=seed, directed=directed)\n    lp = math.log(1.0 - p)\n    if directed:\n        G = nx.DiGraph(G)\n        v = 1\n        w = -1\n        while v < n:\n            lr = math.log(1.0 - seed.random())\n            w = w + 1 + int(lr / lp)\n            while w >= v and v < n:\n                w = w - v\n                v = v + 1\n            if v < n:\n                G.add_edge(w, v)\n    v = 1\n    w = -1\n    while v < n:\n        lr = math.log(1.0 - seed.random())\n        w = w + 1 + int(lr / lp)\n        while w >= v and v < n:\n            w = w - v\n            v = v + 1\n        if v < n:\n            G.add_edge(v, w)\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef fast_gnp_random_graph(n, p, seed=None, directed=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a $G_{n,p}$ random graph, also known as an Erd\u0151s-R\u00e9nyi graph or\\n    a binomial graph.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    p : float\\n        Probability for edge creation.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    directed : bool, optional (default=False)\\n        If True, this function returns a directed graph.\\n\\n    Notes\\n    -----\\n    The $G_{n,p}$ graph algorithm chooses each of the $[n (n - 1)] / 2$\\n    (undirected) or $n (n - 1)$ (directed) possible edges with probability $p$.\\n\\n    This algorithm [1]_ runs in $O(n + m)$ time, where `m` is the expected number of\\n    edges, which equals $p n (n - 1) / 2$. This should be faster than\\n    :func:`gnp_random_graph` when $p$ is small and the expected number of edges\\n    is small (that is, the graph is sparse).\\n\\n    See Also\\n    --------\\n    gnp_random_graph\\n\\n    References\\n    ----------\\n    .. [1] Vladimir Batagelj and Ulrik Brandes,\\n       \"Efficient generation of large random networks\",\\n       Phys. Rev. E, 71, 036113, 2005.\\n    '\n    G = empty_graph(n)\n    if p <= 0 or p >= 1:\n        return nx.gnp_random_graph(n, p, seed=seed, directed=directed)\n    lp = math.log(1.0 - p)\n    if directed:\n        G = nx.DiGraph(G)\n        v = 1\n        w = -1\n        while v < n:\n            lr = math.log(1.0 - seed.random())\n            w = w + 1 + int(lr / lp)\n            while w >= v and v < n:\n                w = w - v\n                v = v + 1\n            if v < n:\n                G.add_edge(w, v)\n    v = 1\n    w = -1\n    while v < n:\n        lr = math.log(1.0 - seed.random())\n        w = w + 1 + int(lr / lp)\n        while w >= v and v < n:\n            w = w - v\n            v = v + 1\n        if v < n:\n            G.add_edge(v, w)\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef fast_gnp_random_graph(n, p, seed=None, directed=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a $G_{n,p}$ random graph, also known as an Erd\u0151s-R\u00e9nyi graph or\\n    a binomial graph.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    p : float\\n        Probability for edge creation.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    directed : bool, optional (default=False)\\n        If True, this function returns a directed graph.\\n\\n    Notes\\n    -----\\n    The $G_{n,p}$ graph algorithm chooses each of the $[n (n - 1)] / 2$\\n    (undirected) or $n (n - 1)$ (directed) possible edges with probability $p$.\\n\\n    This algorithm [1]_ runs in $O(n + m)$ time, where `m` is the expected number of\\n    edges, which equals $p n (n - 1) / 2$. This should be faster than\\n    :func:`gnp_random_graph` when $p$ is small and the expected number of edges\\n    is small (that is, the graph is sparse).\\n\\n    See Also\\n    --------\\n    gnp_random_graph\\n\\n    References\\n    ----------\\n    .. [1] Vladimir Batagelj and Ulrik Brandes,\\n       \"Efficient generation of large random networks\",\\n       Phys. Rev. E, 71, 036113, 2005.\\n    '\n    G = empty_graph(n)\n    if p <= 0 or p >= 1:\n        return nx.gnp_random_graph(n, p, seed=seed, directed=directed)\n    lp = math.log(1.0 - p)\n    if directed:\n        G = nx.DiGraph(G)\n        v = 1\n        w = -1\n        while v < n:\n            lr = math.log(1.0 - seed.random())\n            w = w + 1 + int(lr / lp)\n            while w >= v and v < n:\n                w = w - v\n                v = v + 1\n            if v < n:\n                G.add_edge(w, v)\n    v = 1\n    w = -1\n    while v < n:\n        lr = math.log(1.0 - seed.random())\n        w = w + 1 + int(lr / lp)\n        while w >= v and v < n:\n            w = w - v\n            v = v + 1\n        if v < n:\n            G.add_edge(v, w)\n    return G"
        ]
    },
    {
        "func_name": "gnp_random_graph",
        "original": "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef gnp_random_graph(n, p, seed=None, directed=False):\n    \"\"\"Returns a $G_{n,p}$ random graph, also known as an Erd\u0151s-R\u00e9nyi graph\n    or a binomial graph.\n\n    The $G_{n,p}$ model chooses each of the possible edges with probability $p$.\n\n    Parameters\n    ----------\n    n : int\n        The number of nodes.\n    p : float\n        Probability for edge creation.\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n    directed : bool, optional (default=False)\n        If True, this function returns a directed graph.\n\n    See Also\n    --------\n    fast_gnp_random_graph\n\n    Notes\n    -----\n    This algorithm [2]_ runs in $O(n^2)$ time.  For sparse graphs (that is, for\n    small values of $p$), :func:`fast_gnp_random_graph` is a faster algorithm.\n\n    :func:`binomial_graph` and :func:`erdos_renyi_graph` are\n    aliases for :func:`gnp_random_graph`.\n\n    >>> nx.binomial_graph is nx.gnp_random_graph\n    True\n    >>> nx.erdos_renyi_graph is nx.gnp_random_graph\n    True\n\n    References\n    ----------\n    .. [1] P. Erd\u0151s and A. R\u00e9nyi, On Random Graphs, Publ. Math. 6, 290 (1959).\n    .. [2] E. N. Gilbert, Random Graphs, Ann. Math. Stat., 30, 1141 (1959).\n    \"\"\"\n    if directed:\n        edges = itertools.permutations(range(n), 2)\n        G = nx.DiGraph()\n    else:\n        edges = itertools.combinations(range(n), 2)\n        G = nx.Graph()\n    G.add_nodes_from(range(n))\n    if p <= 0:\n        return G\n    if p >= 1:\n        return complete_graph(n, create_using=G)\n    for e in edges:\n        if seed.random() < p:\n            G.add_edge(*e)\n    return G",
        "mutated": [
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef gnp_random_graph(n, p, seed=None, directed=False):\n    if False:\n        i = 10\n    'Returns a $G_{n,p}$ random graph, also known as an Erd\u0151s-R\u00e9nyi graph\\n    or a binomial graph.\\n\\n    The $G_{n,p}$ model chooses each of the possible edges with probability $p$.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    p : float\\n        Probability for edge creation.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    directed : bool, optional (default=False)\\n        If True, this function returns a directed graph.\\n\\n    See Also\\n    --------\\n    fast_gnp_random_graph\\n\\n    Notes\\n    -----\\n    This algorithm [2]_ runs in $O(n^2)$ time.  For sparse graphs (that is, for\\n    small values of $p$), :func:`fast_gnp_random_graph` is a faster algorithm.\\n\\n    :func:`binomial_graph` and :func:`erdos_renyi_graph` are\\n    aliases for :func:`gnp_random_graph`.\\n\\n    >>> nx.binomial_graph is nx.gnp_random_graph\\n    True\\n    >>> nx.erdos_renyi_graph is nx.gnp_random_graph\\n    True\\n\\n    References\\n    ----------\\n    .. [1] P. Erd\u0151s and A. R\u00e9nyi, On Random Graphs, Publ. Math. 6, 290 (1959).\\n    .. [2] E. N. Gilbert, Random Graphs, Ann. Math. Stat., 30, 1141 (1959).\\n    '\n    if directed:\n        edges = itertools.permutations(range(n), 2)\n        G = nx.DiGraph()\n    else:\n        edges = itertools.combinations(range(n), 2)\n        G = nx.Graph()\n    G.add_nodes_from(range(n))\n    if p <= 0:\n        return G\n    if p >= 1:\n        return complete_graph(n, create_using=G)\n    for e in edges:\n        if seed.random() < p:\n            G.add_edge(*e)\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef gnp_random_graph(n, p, seed=None, directed=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a $G_{n,p}$ random graph, also known as an Erd\u0151s-R\u00e9nyi graph\\n    or a binomial graph.\\n\\n    The $G_{n,p}$ model chooses each of the possible edges with probability $p$.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    p : float\\n        Probability for edge creation.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    directed : bool, optional (default=False)\\n        If True, this function returns a directed graph.\\n\\n    See Also\\n    --------\\n    fast_gnp_random_graph\\n\\n    Notes\\n    -----\\n    This algorithm [2]_ runs in $O(n^2)$ time.  For sparse graphs (that is, for\\n    small values of $p$), :func:`fast_gnp_random_graph` is a faster algorithm.\\n\\n    :func:`binomial_graph` and :func:`erdos_renyi_graph` are\\n    aliases for :func:`gnp_random_graph`.\\n\\n    >>> nx.binomial_graph is nx.gnp_random_graph\\n    True\\n    >>> nx.erdos_renyi_graph is nx.gnp_random_graph\\n    True\\n\\n    References\\n    ----------\\n    .. [1] P. Erd\u0151s and A. R\u00e9nyi, On Random Graphs, Publ. Math. 6, 290 (1959).\\n    .. [2] E. N. Gilbert, Random Graphs, Ann. Math. Stat., 30, 1141 (1959).\\n    '\n    if directed:\n        edges = itertools.permutations(range(n), 2)\n        G = nx.DiGraph()\n    else:\n        edges = itertools.combinations(range(n), 2)\n        G = nx.Graph()\n    G.add_nodes_from(range(n))\n    if p <= 0:\n        return G\n    if p >= 1:\n        return complete_graph(n, create_using=G)\n    for e in edges:\n        if seed.random() < p:\n            G.add_edge(*e)\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef gnp_random_graph(n, p, seed=None, directed=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a $G_{n,p}$ random graph, also known as an Erd\u0151s-R\u00e9nyi graph\\n    or a binomial graph.\\n\\n    The $G_{n,p}$ model chooses each of the possible edges with probability $p$.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    p : float\\n        Probability for edge creation.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    directed : bool, optional (default=False)\\n        If True, this function returns a directed graph.\\n\\n    See Also\\n    --------\\n    fast_gnp_random_graph\\n\\n    Notes\\n    -----\\n    This algorithm [2]_ runs in $O(n^2)$ time.  For sparse graphs (that is, for\\n    small values of $p$), :func:`fast_gnp_random_graph` is a faster algorithm.\\n\\n    :func:`binomial_graph` and :func:`erdos_renyi_graph` are\\n    aliases for :func:`gnp_random_graph`.\\n\\n    >>> nx.binomial_graph is nx.gnp_random_graph\\n    True\\n    >>> nx.erdos_renyi_graph is nx.gnp_random_graph\\n    True\\n\\n    References\\n    ----------\\n    .. [1] P. Erd\u0151s and A. R\u00e9nyi, On Random Graphs, Publ. Math. 6, 290 (1959).\\n    .. [2] E. N. Gilbert, Random Graphs, Ann. Math. Stat., 30, 1141 (1959).\\n    '\n    if directed:\n        edges = itertools.permutations(range(n), 2)\n        G = nx.DiGraph()\n    else:\n        edges = itertools.combinations(range(n), 2)\n        G = nx.Graph()\n    G.add_nodes_from(range(n))\n    if p <= 0:\n        return G\n    if p >= 1:\n        return complete_graph(n, create_using=G)\n    for e in edges:\n        if seed.random() < p:\n            G.add_edge(*e)\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef gnp_random_graph(n, p, seed=None, directed=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a $G_{n,p}$ random graph, also known as an Erd\u0151s-R\u00e9nyi graph\\n    or a binomial graph.\\n\\n    The $G_{n,p}$ model chooses each of the possible edges with probability $p$.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    p : float\\n        Probability for edge creation.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    directed : bool, optional (default=False)\\n        If True, this function returns a directed graph.\\n\\n    See Also\\n    --------\\n    fast_gnp_random_graph\\n\\n    Notes\\n    -----\\n    This algorithm [2]_ runs in $O(n^2)$ time.  For sparse graphs (that is, for\\n    small values of $p$), :func:`fast_gnp_random_graph` is a faster algorithm.\\n\\n    :func:`binomial_graph` and :func:`erdos_renyi_graph` are\\n    aliases for :func:`gnp_random_graph`.\\n\\n    >>> nx.binomial_graph is nx.gnp_random_graph\\n    True\\n    >>> nx.erdos_renyi_graph is nx.gnp_random_graph\\n    True\\n\\n    References\\n    ----------\\n    .. [1] P. Erd\u0151s and A. R\u00e9nyi, On Random Graphs, Publ. Math. 6, 290 (1959).\\n    .. [2] E. N. Gilbert, Random Graphs, Ann. Math. Stat., 30, 1141 (1959).\\n    '\n    if directed:\n        edges = itertools.permutations(range(n), 2)\n        G = nx.DiGraph()\n    else:\n        edges = itertools.combinations(range(n), 2)\n        G = nx.Graph()\n    G.add_nodes_from(range(n))\n    if p <= 0:\n        return G\n    if p >= 1:\n        return complete_graph(n, create_using=G)\n    for e in edges:\n        if seed.random() < p:\n            G.add_edge(*e)\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef gnp_random_graph(n, p, seed=None, directed=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a $G_{n,p}$ random graph, also known as an Erd\u0151s-R\u00e9nyi graph\\n    or a binomial graph.\\n\\n    The $G_{n,p}$ model chooses each of the possible edges with probability $p$.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    p : float\\n        Probability for edge creation.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    directed : bool, optional (default=False)\\n        If True, this function returns a directed graph.\\n\\n    See Also\\n    --------\\n    fast_gnp_random_graph\\n\\n    Notes\\n    -----\\n    This algorithm [2]_ runs in $O(n^2)$ time.  For sparse graphs (that is, for\\n    small values of $p$), :func:`fast_gnp_random_graph` is a faster algorithm.\\n\\n    :func:`binomial_graph` and :func:`erdos_renyi_graph` are\\n    aliases for :func:`gnp_random_graph`.\\n\\n    >>> nx.binomial_graph is nx.gnp_random_graph\\n    True\\n    >>> nx.erdos_renyi_graph is nx.gnp_random_graph\\n    True\\n\\n    References\\n    ----------\\n    .. [1] P. Erd\u0151s and A. R\u00e9nyi, On Random Graphs, Publ. Math. 6, 290 (1959).\\n    .. [2] E. N. Gilbert, Random Graphs, Ann. Math. Stat., 30, 1141 (1959).\\n    '\n    if directed:\n        edges = itertools.permutations(range(n), 2)\n        G = nx.DiGraph()\n    else:\n        edges = itertools.combinations(range(n), 2)\n        G = nx.Graph()\n    G.add_nodes_from(range(n))\n    if p <= 0:\n        return G\n    if p >= 1:\n        return complete_graph(n, create_using=G)\n    for e in edges:\n        if seed.random() < p:\n            G.add_edge(*e)\n    return G"
        ]
    },
    {
        "func_name": "dense_gnm_random_graph",
        "original": "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef dense_gnm_random_graph(n, m, seed=None):\n    \"\"\"Returns a $G_{n,m}$ random graph.\n\n    In the $G_{n,m}$ model, a graph is chosen uniformly at random from the set\n    of all graphs with $n$ nodes and $m$ edges.\n\n    This algorithm should be faster than :func:`gnm_random_graph` for dense\n    graphs.\n\n    Parameters\n    ----------\n    n : int\n        The number of nodes.\n    m : int\n        The number of edges.\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    See Also\n    --------\n    gnm_random_graph\n\n    Notes\n    -----\n    Algorithm by Keith M. Briggs Mar 31, 2006.\n    Inspired by Knuth's Algorithm S (Selection sampling technique),\n    in section 3.4.2 of [1]_.\n\n    References\n    ----------\n    .. [1] Donald E. Knuth, The Art of Computer Programming,\n        Volume 2/Seminumerical algorithms, Third Edition, Addison-Wesley, 1997.\n    \"\"\"\n    mmax = n * (n - 1) // 2\n    if m >= mmax:\n        G = complete_graph(n)\n    else:\n        G = empty_graph(n)\n    if n == 1 or m >= mmax:\n        return G\n    u = 0\n    v = 1\n    t = 0\n    k = 0\n    while True:\n        if seed.randrange(mmax - t) < m - k:\n            G.add_edge(u, v)\n            k += 1\n            if k == m:\n                return G\n        t += 1\n        v += 1\n        if v == n:\n            u += 1\n            v = u + 1",
        "mutated": [
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef dense_gnm_random_graph(n, m, seed=None):\n    if False:\n        i = 10\n    \"Returns a $G_{n,m}$ random graph.\\n\\n    In the $G_{n,m}$ model, a graph is chosen uniformly at random from the set\\n    of all graphs with $n$ nodes and $m$ edges.\\n\\n    This algorithm should be faster than :func:`gnm_random_graph` for dense\\n    graphs.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    m : int\\n        The number of edges.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    See Also\\n    --------\\n    gnm_random_graph\\n\\n    Notes\\n    -----\\n    Algorithm by Keith M. Briggs Mar 31, 2006.\\n    Inspired by Knuth's Algorithm S (Selection sampling technique),\\n    in section 3.4.2 of [1]_.\\n\\n    References\\n    ----------\\n    .. [1] Donald E. Knuth, The Art of Computer Programming,\\n        Volume 2/Seminumerical algorithms, Third Edition, Addison-Wesley, 1997.\\n    \"\n    mmax = n * (n - 1) // 2\n    if m >= mmax:\n        G = complete_graph(n)\n    else:\n        G = empty_graph(n)\n    if n == 1 or m >= mmax:\n        return G\n    u = 0\n    v = 1\n    t = 0\n    k = 0\n    while True:\n        if seed.randrange(mmax - t) < m - k:\n            G.add_edge(u, v)\n            k += 1\n            if k == m:\n                return G\n        t += 1\n        v += 1\n        if v == n:\n            u += 1\n            v = u + 1",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef dense_gnm_random_graph(n, m, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Returns a $G_{n,m}$ random graph.\\n\\n    In the $G_{n,m}$ model, a graph is chosen uniformly at random from the set\\n    of all graphs with $n$ nodes and $m$ edges.\\n\\n    This algorithm should be faster than :func:`gnm_random_graph` for dense\\n    graphs.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    m : int\\n        The number of edges.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    See Also\\n    --------\\n    gnm_random_graph\\n\\n    Notes\\n    -----\\n    Algorithm by Keith M. Briggs Mar 31, 2006.\\n    Inspired by Knuth's Algorithm S (Selection sampling technique),\\n    in section 3.4.2 of [1]_.\\n\\n    References\\n    ----------\\n    .. [1] Donald E. Knuth, The Art of Computer Programming,\\n        Volume 2/Seminumerical algorithms, Third Edition, Addison-Wesley, 1997.\\n    \"\n    mmax = n * (n - 1) // 2\n    if m >= mmax:\n        G = complete_graph(n)\n    else:\n        G = empty_graph(n)\n    if n == 1 or m >= mmax:\n        return G\n    u = 0\n    v = 1\n    t = 0\n    k = 0\n    while True:\n        if seed.randrange(mmax - t) < m - k:\n            G.add_edge(u, v)\n            k += 1\n            if k == m:\n                return G\n        t += 1\n        v += 1\n        if v == n:\n            u += 1\n            v = u + 1",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef dense_gnm_random_graph(n, m, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Returns a $G_{n,m}$ random graph.\\n\\n    In the $G_{n,m}$ model, a graph is chosen uniformly at random from the set\\n    of all graphs with $n$ nodes and $m$ edges.\\n\\n    This algorithm should be faster than :func:`gnm_random_graph` for dense\\n    graphs.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    m : int\\n        The number of edges.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    See Also\\n    --------\\n    gnm_random_graph\\n\\n    Notes\\n    -----\\n    Algorithm by Keith M. Briggs Mar 31, 2006.\\n    Inspired by Knuth's Algorithm S (Selection sampling technique),\\n    in section 3.4.2 of [1]_.\\n\\n    References\\n    ----------\\n    .. [1] Donald E. Knuth, The Art of Computer Programming,\\n        Volume 2/Seminumerical algorithms, Third Edition, Addison-Wesley, 1997.\\n    \"\n    mmax = n * (n - 1) // 2\n    if m >= mmax:\n        G = complete_graph(n)\n    else:\n        G = empty_graph(n)\n    if n == 1 or m >= mmax:\n        return G\n    u = 0\n    v = 1\n    t = 0\n    k = 0\n    while True:\n        if seed.randrange(mmax - t) < m - k:\n            G.add_edge(u, v)\n            k += 1\n            if k == m:\n                return G\n        t += 1\n        v += 1\n        if v == n:\n            u += 1\n            v = u + 1",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef dense_gnm_random_graph(n, m, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Returns a $G_{n,m}$ random graph.\\n\\n    In the $G_{n,m}$ model, a graph is chosen uniformly at random from the set\\n    of all graphs with $n$ nodes and $m$ edges.\\n\\n    This algorithm should be faster than :func:`gnm_random_graph` for dense\\n    graphs.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    m : int\\n        The number of edges.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    See Also\\n    --------\\n    gnm_random_graph\\n\\n    Notes\\n    -----\\n    Algorithm by Keith M. Briggs Mar 31, 2006.\\n    Inspired by Knuth's Algorithm S (Selection sampling technique),\\n    in section 3.4.2 of [1]_.\\n\\n    References\\n    ----------\\n    .. [1] Donald E. Knuth, The Art of Computer Programming,\\n        Volume 2/Seminumerical algorithms, Third Edition, Addison-Wesley, 1997.\\n    \"\n    mmax = n * (n - 1) // 2\n    if m >= mmax:\n        G = complete_graph(n)\n    else:\n        G = empty_graph(n)\n    if n == 1 or m >= mmax:\n        return G\n    u = 0\n    v = 1\n    t = 0\n    k = 0\n    while True:\n        if seed.randrange(mmax - t) < m - k:\n            G.add_edge(u, v)\n            k += 1\n            if k == m:\n                return G\n        t += 1\n        v += 1\n        if v == n:\n            u += 1\n            v = u + 1",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef dense_gnm_random_graph(n, m, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Returns a $G_{n,m}$ random graph.\\n\\n    In the $G_{n,m}$ model, a graph is chosen uniformly at random from the set\\n    of all graphs with $n$ nodes and $m$ edges.\\n\\n    This algorithm should be faster than :func:`gnm_random_graph` for dense\\n    graphs.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    m : int\\n        The number of edges.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    See Also\\n    --------\\n    gnm_random_graph\\n\\n    Notes\\n    -----\\n    Algorithm by Keith M. Briggs Mar 31, 2006.\\n    Inspired by Knuth's Algorithm S (Selection sampling technique),\\n    in section 3.4.2 of [1]_.\\n\\n    References\\n    ----------\\n    .. [1] Donald E. Knuth, The Art of Computer Programming,\\n        Volume 2/Seminumerical algorithms, Third Edition, Addison-Wesley, 1997.\\n    \"\n    mmax = n * (n - 1) // 2\n    if m >= mmax:\n        G = complete_graph(n)\n    else:\n        G = empty_graph(n)\n    if n == 1 or m >= mmax:\n        return G\n    u = 0\n    v = 1\n    t = 0\n    k = 0\n    while True:\n        if seed.randrange(mmax - t) < m - k:\n            G.add_edge(u, v)\n            k += 1\n            if k == m:\n                return G\n        t += 1\n        v += 1\n        if v == n:\n            u += 1\n            v = u + 1"
        ]
    },
    {
        "func_name": "gnm_random_graph",
        "original": "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef gnm_random_graph(n, m, seed=None, directed=False):\n    \"\"\"Returns a $G_{n,m}$ random graph.\n\n    In the $G_{n,m}$ model, a graph is chosen uniformly at random from the set\n    of all graphs with $n$ nodes and $m$ edges.\n\n    This algorithm should be faster than :func:`dense_gnm_random_graph` for\n    sparse graphs.\n\n    Parameters\n    ----------\n    n : int\n        The number of nodes.\n    m : int\n        The number of edges.\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n    directed : bool, optional (default=False)\n        If True return a directed graph\n\n    See also\n    --------\n    dense_gnm_random_graph\n\n    \"\"\"\n    if directed:\n        G = nx.DiGraph()\n    else:\n        G = nx.Graph()\n    G.add_nodes_from(range(n))\n    if n == 1:\n        return G\n    max_edges = n * (n - 1)\n    if not directed:\n        max_edges /= 2.0\n    if m >= max_edges:\n        return complete_graph(n, create_using=G)\n    nlist = list(G)\n    edge_count = 0\n    while edge_count < m:\n        u = seed.choice(nlist)\n        v = seed.choice(nlist)\n        if u == v or G.has_edge(u, v):\n            continue\n        else:\n            G.add_edge(u, v)\n            edge_count = edge_count + 1\n    return G",
        "mutated": [
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef gnm_random_graph(n, m, seed=None, directed=False):\n    if False:\n        i = 10\n    'Returns a $G_{n,m}$ random graph.\\n\\n    In the $G_{n,m}$ model, a graph is chosen uniformly at random from the set\\n    of all graphs with $n$ nodes and $m$ edges.\\n\\n    This algorithm should be faster than :func:`dense_gnm_random_graph` for\\n    sparse graphs.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    m : int\\n        The number of edges.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    directed : bool, optional (default=False)\\n        If True return a directed graph\\n\\n    See also\\n    --------\\n    dense_gnm_random_graph\\n\\n    '\n    if directed:\n        G = nx.DiGraph()\n    else:\n        G = nx.Graph()\n    G.add_nodes_from(range(n))\n    if n == 1:\n        return G\n    max_edges = n * (n - 1)\n    if not directed:\n        max_edges /= 2.0\n    if m >= max_edges:\n        return complete_graph(n, create_using=G)\n    nlist = list(G)\n    edge_count = 0\n    while edge_count < m:\n        u = seed.choice(nlist)\n        v = seed.choice(nlist)\n        if u == v or G.has_edge(u, v):\n            continue\n        else:\n            G.add_edge(u, v)\n            edge_count = edge_count + 1\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef gnm_random_graph(n, m, seed=None, directed=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a $G_{n,m}$ random graph.\\n\\n    In the $G_{n,m}$ model, a graph is chosen uniformly at random from the set\\n    of all graphs with $n$ nodes and $m$ edges.\\n\\n    This algorithm should be faster than :func:`dense_gnm_random_graph` for\\n    sparse graphs.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    m : int\\n        The number of edges.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    directed : bool, optional (default=False)\\n        If True return a directed graph\\n\\n    See also\\n    --------\\n    dense_gnm_random_graph\\n\\n    '\n    if directed:\n        G = nx.DiGraph()\n    else:\n        G = nx.Graph()\n    G.add_nodes_from(range(n))\n    if n == 1:\n        return G\n    max_edges = n * (n - 1)\n    if not directed:\n        max_edges /= 2.0\n    if m >= max_edges:\n        return complete_graph(n, create_using=G)\n    nlist = list(G)\n    edge_count = 0\n    while edge_count < m:\n        u = seed.choice(nlist)\n        v = seed.choice(nlist)\n        if u == v or G.has_edge(u, v):\n            continue\n        else:\n            G.add_edge(u, v)\n            edge_count = edge_count + 1\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef gnm_random_graph(n, m, seed=None, directed=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a $G_{n,m}$ random graph.\\n\\n    In the $G_{n,m}$ model, a graph is chosen uniformly at random from the set\\n    of all graphs with $n$ nodes and $m$ edges.\\n\\n    This algorithm should be faster than :func:`dense_gnm_random_graph` for\\n    sparse graphs.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    m : int\\n        The number of edges.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    directed : bool, optional (default=False)\\n        If True return a directed graph\\n\\n    See also\\n    --------\\n    dense_gnm_random_graph\\n\\n    '\n    if directed:\n        G = nx.DiGraph()\n    else:\n        G = nx.Graph()\n    G.add_nodes_from(range(n))\n    if n == 1:\n        return G\n    max_edges = n * (n - 1)\n    if not directed:\n        max_edges /= 2.0\n    if m >= max_edges:\n        return complete_graph(n, create_using=G)\n    nlist = list(G)\n    edge_count = 0\n    while edge_count < m:\n        u = seed.choice(nlist)\n        v = seed.choice(nlist)\n        if u == v or G.has_edge(u, v):\n            continue\n        else:\n            G.add_edge(u, v)\n            edge_count = edge_count + 1\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef gnm_random_graph(n, m, seed=None, directed=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a $G_{n,m}$ random graph.\\n\\n    In the $G_{n,m}$ model, a graph is chosen uniformly at random from the set\\n    of all graphs with $n$ nodes and $m$ edges.\\n\\n    This algorithm should be faster than :func:`dense_gnm_random_graph` for\\n    sparse graphs.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    m : int\\n        The number of edges.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    directed : bool, optional (default=False)\\n        If True return a directed graph\\n\\n    See also\\n    --------\\n    dense_gnm_random_graph\\n\\n    '\n    if directed:\n        G = nx.DiGraph()\n    else:\n        G = nx.Graph()\n    G.add_nodes_from(range(n))\n    if n == 1:\n        return G\n    max_edges = n * (n - 1)\n    if not directed:\n        max_edges /= 2.0\n    if m >= max_edges:\n        return complete_graph(n, create_using=G)\n    nlist = list(G)\n    edge_count = 0\n    while edge_count < m:\n        u = seed.choice(nlist)\n        v = seed.choice(nlist)\n        if u == v or G.has_edge(u, v):\n            continue\n        else:\n            G.add_edge(u, v)\n            edge_count = edge_count + 1\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef gnm_random_graph(n, m, seed=None, directed=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a $G_{n,m}$ random graph.\\n\\n    In the $G_{n,m}$ model, a graph is chosen uniformly at random from the set\\n    of all graphs with $n$ nodes and $m$ edges.\\n\\n    This algorithm should be faster than :func:`dense_gnm_random_graph` for\\n    sparse graphs.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    m : int\\n        The number of edges.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    directed : bool, optional (default=False)\\n        If True return a directed graph\\n\\n    See also\\n    --------\\n    dense_gnm_random_graph\\n\\n    '\n    if directed:\n        G = nx.DiGraph()\n    else:\n        G = nx.Graph()\n    G.add_nodes_from(range(n))\n    if n == 1:\n        return G\n    max_edges = n * (n - 1)\n    if not directed:\n        max_edges /= 2.0\n    if m >= max_edges:\n        return complete_graph(n, create_using=G)\n    nlist = list(G)\n    edge_count = 0\n    while edge_count < m:\n        u = seed.choice(nlist)\n        v = seed.choice(nlist)\n        if u == v or G.has_edge(u, v):\n            continue\n        else:\n            G.add_edge(u, v)\n            edge_count = edge_count + 1\n    return G"
        ]
    },
    {
        "func_name": "newman_watts_strogatz_graph",
        "original": "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef newman_watts_strogatz_graph(n, k, p, seed=None):\n    \"\"\"Returns a Newman\u2013Watts\u2013Strogatz small-world graph.\n\n    Parameters\n    ----------\n    n : int\n        The number of nodes.\n    k : int\n        Each node is joined with its `k` nearest neighbors in a ring\n        topology.\n    p : float\n        The probability of adding a new edge for each edge.\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Notes\n    -----\n    First create a ring over $n$ nodes [1]_.  Then each node in the ring is\n    connected with its $k$ nearest neighbors (or $k - 1$ neighbors if $k$\n    is odd).  Then shortcuts are created by adding new edges as follows: for\n    each edge $(u, v)$ in the underlying \"$n$-ring with $k$ nearest\n    neighbors\" with probability $p$ add a new edge $(u, w)$ with\n    randomly-chosen existing node $w$.  In contrast with\n    :func:`watts_strogatz_graph`, no edges are removed.\n\n    See Also\n    --------\n    watts_strogatz_graph\n\n    References\n    ----------\n    .. [1] M. E. J. Newman and D. J. Watts,\n       Renormalization group analysis of the small-world network model,\n       Physics Letters A, 263, 341, 1999.\n       https://doi.org/10.1016/S0375-9601(99)00757-4\n    \"\"\"\n    if k > n:\n        raise nx.NetworkXError('k>=n, choose smaller k or larger n')\n    if k == n:\n        return nx.complete_graph(n)\n    G = empty_graph(n)\n    nlist = list(G.nodes())\n    fromv = nlist\n    for j in range(1, k // 2 + 1):\n        tov = fromv[j:] + fromv[0:j]\n        for i in range(len(fromv)):\n            G.add_edge(fromv[i], tov[i])\n    e = list(G.edges())\n    for (u, v) in e:\n        if seed.random() < p:\n            w = seed.choice(nlist)\n            while w == u or G.has_edge(u, w):\n                w = seed.choice(nlist)\n                if G.degree(u) >= n - 1:\n                    break\n            else:\n                G.add_edge(u, w)\n    return G",
        "mutated": [
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef newman_watts_strogatz_graph(n, k, p, seed=None):\n    if False:\n        i = 10\n    'Returns a Newman\u2013Watts\u2013Strogatz small-world graph.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    k : int\\n        Each node is joined with its `k` nearest neighbors in a ring\\n        topology.\\n    p : float\\n        The probability of adding a new edge for each edge.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    First create a ring over $n$ nodes [1]_.  Then each node in the ring is\\n    connected with its $k$ nearest neighbors (or $k - 1$ neighbors if $k$\\n    is odd).  Then shortcuts are created by adding new edges as follows: for\\n    each edge $(u, v)$ in the underlying \"$n$-ring with $k$ nearest\\n    neighbors\" with probability $p$ add a new edge $(u, w)$ with\\n    randomly-chosen existing node $w$.  In contrast with\\n    :func:`watts_strogatz_graph`, no edges are removed.\\n\\n    See Also\\n    --------\\n    watts_strogatz_graph\\n\\n    References\\n    ----------\\n    .. [1] M. E. J. Newman and D. J. Watts,\\n       Renormalization group analysis of the small-world network model,\\n       Physics Letters A, 263, 341, 1999.\\n       https://doi.org/10.1016/S0375-9601(99)00757-4\\n    '\n    if k > n:\n        raise nx.NetworkXError('k>=n, choose smaller k or larger n')\n    if k == n:\n        return nx.complete_graph(n)\n    G = empty_graph(n)\n    nlist = list(G.nodes())\n    fromv = nlist\n    for j in range(1, k // 2 + 1):\n        tov = fromv[j:] + fromv[0:j]\n        for i in range(len(fromv)):\n            G.add_edge(fromv[i], tov[i])\n    e = list(G.edges())\n    for (u, v) in e:\n        if seed.random() < p:\n            w = seed.choice(nlist)\n            while w == u or G.has_edge(u, w):\n                w = seed.choice(nlist)\n                if G.degree(u) >= n - 1:\n                    break\n            else:\n                G.add_edge(u, w)\n    return G",
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef newman_watts_strogatz_graph(n, k, p, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a Newman\u2013Watts\u2013Strogatz small-world graph.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    k : int\\n        Each node is joined with its `k` nearest neighbors in a ring\\n        topology.\\n    p : float\\n        The probability of adding a new edge for each edge.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    First create a ring over $n$ nodes [1]_.  Then each node in the ring is\\n    connected with its $k$ nearest neighbors (or $k - 1$ neighbors if $k$\\n    is odd).  Then shortcuts are created by adding new edges as follows: for\\n    each edge $(u, v)$ in the underlying \"$n$-ring with $k$ nearest\\n    neighbors\" with probability $p$ add a new edge $(u, w)$ with\\n    randomly-chosen existing node $w$.  In contrast with\\n    :func:`watts_strogatz_graph`, no edges are removed.\\n\\n    See Also\\n    --------\\n    watts_strogatz_graph\\n\\n    References\\n    ----------\\n    .. [1] M. E. J. Newman and D. J. Watts,\\n       Renormalization group analysis of the small-world network model,\\n       Physics Letters A, 263, 341, 1999.\\n       https://doi.org/10.1016/S0375-9601(99)00757-4\\n    '\n    if k > n:\n        raise nx.NetworkXError('k>=n, choose smaller k or larger n')\n    if k == n:\n        return nx.complete_graph(n)\n    G = empty_graph(n)\n    nlist = list(G.nodes())\n    fromv = nlist\n    for j in range(1, k // 2 + 1):\n        tov = fromv[j:] + fromv[0:j]\n        for i in range(len(fromv)):\n            G.add_edge(fromv[i], tov[i])\n    e = list(G.edges())\n    for (u, v) in e:\n        if seed.random() < p:\n            w = seed.choice(nlist)\n            while w == u or G.has_edge(u, w):\n                w = seed.choice(nlist)\n                if G.degree(u) >= n - 1:\n                    break\n            else:\n                G.add_edge(u, w)\n    return G",
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef newman_watts_strogatz_graph(n, k, p, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a Newman\u2013Watts\u2013Strogatz small-world graph.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    k : int\\n        Each node is joined with its `k` nearest neighbors in a ring\\n        topology.\\n    p : float\\n        The probability of adding a new edge for each edge.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    First create a ring over $n$ nodes [1]_.  Then each node in the ring is\\n    connected with its $k$ nearest neighbors (or $k - 1$ neighbors if $k$\\n    is odd).  Then shortcuts are created by adding new edges as follows: for\\n    each edge $(u, v)$ in the underlying \"$n$-ring with $k$ nearest\\n    neighbors\" with probability $p$ add a new edge $(u, w)$ with\\n    randomly-chosen existing node $w$.  In contrast with\\n    :func:`watts_strogatz_graph`, no edges are removed.\\n\\n    See Also\\n    --------\\n    watts_strogatz_graph\\n\\n    References\\n    ----------\\n    .. [1] M. E. J. Newman and D. J. Watts,\\n       Renormalization group analysis of the small-world network model,\\n       Physics Letters A, 263, 341, 1999.\\n       https://doi.org/10.1016/S0375-9601(99)00757-4\\n    '\n    if k > n:\n        raise nx.NetworkXError('k>=n, choose smaller k or larger n')\n    if k == n:\n        return nx.complete_graph(n)\n    G = empty_graph(n)\n    nlist = list(G.nodes())\n    fromv = nlist\n    for j in range(1, k // 2 + 1):\n        tov = fromv[j:] + fromv[0:j]\n        for i in range(len(fromv)):\n            G.add_edge(fromv[i], tov[i])\n    e = list(G.edges())\n    for (u, v) in e:\n        if seed.random() < p:\n            w = seed.choice(nlist)\n            while w == u or G.has_edge(u, w):\n                w = seed.choice(nlist)\n                if G.degree(u) >= n - 1:\n                    break\n            else:\n                G.add_edge(u, w)\n    return G",
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef newman_watts_strogatz_graph(n, k, p, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a Newman\u2013Watts\u2013Strogatz small-world graph.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    k : int\\n        Each node is joined with its `k` nearest neighbors in a ring\\n        topology.\\n    p : float\\n        The probability of adding a new edge for each edge.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    First create a ring over $n$ nodes [1]_.  Then each node in the ring is\\n    connected with its $k$ nearest neighbors (or $k - 1$ neighbors if $k$\\n    is odd).  Then shortcuts are created by adding new edges as follows: for\\n    each edge $(u, v)$ in the underlying \"$n$-ring with $k$ nearest\\n    neighbors\" with probability $p$ add a new edge $(u, w)$ with\\n    randomly-chosen existing node $w$.  In contrast with\\n    :func:`watts_strogatz_graph`, no edges are removed.\\n\\n    See Also\\n    --------\\n    watts_strogatz_graph\\n\\n    References\\n    ----------\\n    .. [1] M. E. J. Newman and D. J. Watts,\\n       Renormalization group analysis of the small-world network model,\\n       Physics Letters A, 263, 341, 1999.\\n       https://doi.org/10.1016/S0375-9601(99)00757-4\\n    '\n    if k > n:\n        raise nx.NetworkXError('k>=n, choose smaller k or larger n')\n    if k == n:\n        return nx.complete_graph(n)\n    G = empty_graph(n)\n    nlist = list(G.nodes())\n    fromv = nlist\n    for j in range(1, k // 2 + 1):\n        tov = fromv[j:] + fromv[0:j]\n        for i in range(len(fromv)):\n            G.add_edge(fromv[i], tov[i])\n    e = list(G.edges())\n    for (u, v) in e:\n        if seed.random() < p:\n            w = seed.choice(nlist)\n            while w == u or G.has_edge(u, w):\n                w = seed.choice(nlist)\n                if G.degree(u) >= n - 1:\n                    break\n            else:\n                G.add_edge(u, w)\n    return G",
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef newman_watts_strogatz_graph(n, k, p, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a Newman\u2013Watts\u2013Strogatz small-world graph.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    k : int\\n        Each node is joined with its `k` nearest neighbors in a ring\\n        topology.\\n    p : float\\n        The probability of adding a new edge for each edge.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    First create a ring over $n$ nodes [1]_.  Then each node in the ring is\\n    connected with its $k$ nearest neighbors (or $k - 1$ neighbors if $k$\\n    is odd).  Then shortcuts are created by adding new edges as follows: for\\n    each edge $(u, v)$ in the underlying \"$n$-ring with $k$ nearest\\n    neighbors\" with probability $p$ add a new edge $(u, w)$ with\\n    randomly-chosen existing node $w$.  In contrast with\\n    :func:`watts_strogatz_graph`, no edges are removed.\\n\\n    See Also\\n    --------\\n    watts_strogatz_graph\\n\\n    References\\n    ----------\\n    .. [1] M. E. J. Newman and D. J. Watts,\\n       Renormalization group analysis of the small-world network model,\\n       Physics Letters A, 263, 341, 1999.\\n       https://doi.org/10.1016/S0375-9601(99)00757-4\\n    '\n    if k > n:\n        raise nx.NetworkXError('k>=n, choose smaller k or larger n')\n    if k == n:\n        return nx.complete_graph(n)\n    G = empty_graph(n)\n    nlist = list(G.nodes())\n    fromv = nlist\n    for j in range(1, k // 2 + 1):\n        tov = fromv[j:] + fromv[0:j]\n        for i in range(len(fromv)):\n            G.add_edge(fromv[i], tov[i])\n    e = list(G.edges())\n    for (u, v) in e:\n        if seed.random() < p:\n            w = seed.choice(nlist)\n            while w == u or G.has_edge(u, w):\n                w = seed.choice(nlist)\n                if G.degree(u) >= n - 1:\n                    break\n            else:\n                G.add_edge(u, w)\n    return G"
        ]
    },
    {
        "func_name": "watts_strogatz_graph",
        "original": "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef watts_strogatz_graph(n, k, p, seed=None):\n    \"\"\"Returns a Watts\u2013Strogatz small-world graph.\n\n    Parameters\n    ----------\n    n : int\n        The number of nodes\n    k : int\n        Each node is joined with its `k` nearest neighbors in a ring\n        topology.\n    p : float\n        The probability of rewiring each edge\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    See Also\n    --------\n    newman_watts_strogatz_graph\n    connected_watts_strogatz_graph\n\n    Notes\n    -----\n    First create a ring over $n$ nodes [1]_.  Then each node in the ring is joined\n    to its $k$ nearest neighbors (or $k - 1$ neighbors if $k$ is odd).\n    Then shortcuts are created by replacing some edges as follows: for each\n    edge $(u, v)$ in the underlying \"$n$-ring with $k$ nearest neighbors\"\n    with probability $p$ replace it with a new edge $(u, w)$ with uniformly\n    random choice of existing node $w$.\n\n    In contrast with :func:`newman_watts_strogatz_graph`, the random rewiring\n    does not increase the number of edges. The rewired graph is not guaranteed\n    to be connected as in :func:`connected_watts_strogatz_graph`.\n\n    References\n    ----------\n    .. [1] Duncan J. Watts and Steven H. Strogatz,\n       Collective dynamics of small-world networks,\n       Nature, 393, pp. 440--442, 1998.\n    \"\"\"\n    if k > n:\n        raise nx.NetworkXError('k>n, choose smaller k or larger n')\n    if k == n:\n        return nx.complete_graph(n)\n    G = nx.Graph()\n    nodes = list(range(n))\n    for j in range(1, k // 2 + 1):\n        targets = nodes[j:] + nodes[0:j]\n        G.add_edges_from(zip(nodes, targets))\n    for j in range(1, k // 2 + 1):\n        targets = nodes[j:] + nodes[0:j]\n        for (u, v) in zip(nodes, targets):\n            if seed.random() < p:\n                w = seed.choice(nodes)\n                while w == u or G.has_edge(u, w):\n                    w = seed.choice(nodes)\n                    if G.degree(u) >= n - 1:\n                        break\n                else:\n                    G.remove_edge(u, v)\n                    G.add_edge(u, w)\n    return G",
        "mutated": [
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef watts_strogatz_graph(n, k, p, seed=None):\n    if False:\n        i = 10\n    'Returns a Watts\u2013Strogatz small-world graph.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes\\n    k : int\\n        Each node is joined with its `k` nearest neighbors in a ring\\n        topology.\\n    p : float\\n        The probability of rewiring each edge\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    See Also\\n    --------\\n    newman_watts_strogatz_graph\\n    connected_watts_strogatz_graph\\n\\n    Notes\\n    -----\\n    First create a ring over $n$ nodes [1]_.  Then each node in the ring is joined\\n    to its $k$ nearest neighbors (or $k - 1$ neighbors if $k$ is odd).\\n    Then shortcuts are created by replacing some edges as follows: for each\\n    edge $(u, v)$ in the underlying \"$n$-ring with $k$ nearest neighbors\"\\n    with probability $p$ replace it with a new edge $(u, w)$ with uniformly\\n    random choice of existing node $w$.\\n\\n    In contrast with :func:`newman_watts_strogatz_graph`, the random rewiring\\n    does not increase the number of edges. The rewired graph is not guaranteed\\n    to be connected as in :func:`connected_watts_strogatz_graph`.\\n\\n    References\\n    ----------\\n    .. [1] Duncan J. Watts and Steven H. Strogatz,\\n       Collective dynamics of small-world networks,\\n       Nature, 393, pp. 440--442, 1998.\\n    '\n    if k > n:\n        raise nx.NetworkXError('k>n, choose smaller k or larger n')\n    if k == n:\n        return nx.complete_graph(n)\n    G = nx.Graph()\n    nodes = list(range(n))\n    for j in range(1, k // 2 + 1):\n        targets = nodes[j:] + nodes[0:j]\n        G.add_edges_from(zip(nodes, targets))\n    for j in range(1, k // 2 + 1):\n        targets = nodes[j:] + nodes[0:j]\n        for (u, v) in zip(nodes, targets):\n            if seed.random() < p:\n                w = seed.choice(nodes)\n                while w == u or G.has_edge(u, w):\n                    w = seed.choice(nodes)\n                    if G.degree(u) >= n - 1:\n                        break\n                else:\n                    G.remove_edge(u, v)\n                    G.add_edge(u, w)\n    return G",
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef watts_strogatz_graph(n, k, p, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a Watts\u2013Strogatz small-world graph.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes\\n    k : int\\n        Each node is joined with its `k` nearest neighbors in a ring\\n        topology.\\n    p : float\\n        The probability of rewiring each edge\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    See Also\\n    --------\\n    newman_watts_strogatz_graph\\n    connected_watts_strogatz_graph\\n\\n    Notes\\n    -----\\n    First create a ring over $n$ nodes [1]_.  Then each node in the ring is joined\\n    to its $k$ nearest neighbors (or $k - 1$ neighbors if $k$ is odd).\\n    Then shortcuts are created by replacing some edges as follows: for each\\n    edge $(u, v)$ in the underlying \"$n$-ring with $k$ nearest neighbors\"\\n    with probability $p$ replace it with a new edge $(u, w)$ with uniformly\\n    random choice of existing node $w$.\\n\\n    In contrast with :func:`newman_watts_strogatz_graph`, the random rewiring\\n    does not increase the number of edges. The rewired graph is not guaranteed\\n    to be connected as in :func:`connected_watts_strogatz_graph`.\\n\\n    References\\n    ----------\\n    .. [1] Duncan J. Watts and Steven H. Strogatz,\\n       Collective dynamics of small-world networks,\\n       Nature, 393, pp. 440--442, 1998.\\n    '\n    if k > n:\n        raise nx.NetworkXError('k>n, choose smaller k or larger n')\n    if k == n:\n        return nx.complete_graph(n)\n    G = nx.Graph()\n    nodes = list(range(n))\n    for j in range(1, k // 2 + 1):\n        targets = nodes[j:] + nodes[0:j]\n        G.add_edges_from(zip(nodes, targets))\n    for j in range(1, k // 2 + 1):\n        targets = nodes[j:] + nodes[0:j]\n        for (u, v) in zip(nodes, targets):\n            if seed.random() < p:\n                w = seed.choice(nodes)\n                while w == u or G.has_edge(u, w):\n                    w = seed.choice(nodes)\n                    if G.degree(u) >= n - 1:\n                        break\n                else:\n                    G.remove_edge(u, v)\n                    G.add_edge(u, w)\n    return G",
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef watts_strogatz_graph(n, k, p, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a Watts\u2013Strogatz small-world graph.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes\\n    k : int\\n        Each node is joined with its `k` nearest neighbors in a ring\\n        topology.\\n    p : float\\n        The probability of rewiring each edge\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    See Also\\n    --------\\n    newman_watts_strogatz_graph\\n    connected_watts_strogatz_graph\\n\\n    Notes\\n    -----\\n    First create a ring over $n$ nodes [1]_.  Then each node in the ring is joined\\n    to its $k$ nearest neighbors (or $k - 1$ neighbors if $k$ is odd).\\n    Then shortcuts are created by replacing some edges as follows: for each\\n    edge $(u, v)$ in the underlying \"$n$-ring with $k$ nearest neighbors\"\\n    with probability $p$ replace it with a new edge $(u, w)$ with uniformly\\n    random choice of existing node $w$.\\n\\n    In contrast with :func:`newman_watts_strogatz_graph`, the random rewiring\\n    does not increase the number of edges. The rewired graph is not guaranteed\\n    to be connected as in :func:`connected_watts_strogatz_graph`.\\n\\n    References\\n    ----------\\n    .. [1] Duncan J. Watts and Steven H. Strogatz,\\n       Collective dynamics of small-world networks,\\n       Nature, 393, pp. 440--442, 1998.\\n    '\n    if k > n:\n        raise nx.NetworkXError('k>n, choose smaller k or larger n')\n    if k == n:\n        return nx.complete_graph(n)\n    G = nx.Graph()\n    nodes = list(range(n))\n    for j in range(1, k // 2 + 1):\n        targets = nodes[j:] + nodes[0:j]\n        G.add_edges_from(zip(nodes, targets))\n    for j in range(1, k // 2 + 1):\n        targets = nodes[j:] + nodes[0:j]\n        for (u, v) in zip(nodes, targets):\n            if seed.random() < p:\n                w = seed.choice(nodes)\n                while w == u or G.has_edge(u, w):\n                    w = seed.choice(nodes)\n                    if G.degree(u) >= n - 1:\n                        break\n                else:\n                    G.remove_edge(u, v)\n                    G.add_edge(u, w)\n    return G",
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef watts_strogatz_graph(n, k, p, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a Watts\u2013Strogatz small-world graph.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes\\n    k : int\\n        Each node is joined with its `k` nearest neighbors in a ring\\n        topology.\\n    p : float\\n        The probability of rewiring each edge\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    See Also\\n    --------\\n    newman_watts_strogatz_graph\\n    connected_watts_strogatz_graph\\n\\n    Notes\\n    -----\\n    First create a ring over $n$ nodes [1]_.  Then each node in the ring is joined\\n    to its $k$ nearest neighbors (or $k - 1$ neighbors if $k$ is odd).\\n    Then shortcuts are created by replacing some edges as follows: for each\\n    edge $(u, v)$ in the underlying \"$n$-ring with $k$ nearest neighbors\"\\n    with probability $p$ replace it with a new edge $(u, w)$ with uniformly\\n    random choice of existing node $w$.\\n\\n    In contrast with :func:`newman_watts_strogatz_graph`, the random rewiring\\n    does not increase the number of edges. The rewired graph is not guaranteed\\n    to be connected as in :func:`connected_watts_strogatz_graph`.\\n\\n    References\\n    ----------\\n    .. [1] Duncan J. Watts and Steven H. Strogatz,\\n       Collective dynamics of small-world networks,\\n       Nature, 393, pp. 440--442, 1998.\\n    '\n    if k > n:\n        raise nx.NetworkXError('k>n, choose smaller k or larger n')\n    if k == n:\n        return nx.complete_graph(n)\n    G = nx.Graph()\n    nodes = list(range(n))\n    for j in range(1, k // 2 + 1):\n        targets = nodes[j:] + nodes[0:j]\n        G.add_edges_from(zip(nodes, targets))\n    for j in range(1, k // 2 + 1):\n        targets = nodes[j:] + nodes[0:j]\n        for (u, v) in zip(nodes, targets):\n            if seed.random() < p:\n                w = seed.choice(nodes)\n                while w == u or G.has_edge(u, w):\n                    w = seed.choice(nodes)\n                    if G.degree(u) >= n - 1:\n                        break\n                else:\n                    G.remove_edge(u, v)\n                    G.add_edge(u, w)\n    return G",
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef watts_strogatz_graph(n, k, p, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a Watts\u2013Strogatz small-world graph.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes\\n    k : int\\n        Each node is joined with its `k` nearest neighbors in a ring\\n        topology.\\n    p : float\\n        The probability of rewiring each edge\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    See Also\\n    --------\\n    newman_watts_strogatz_graph\\n    connected_watts_strogatz_graph\\n\\n    Notes\\n    -----\\n    First create a ring over $n$ nodes [1]_.  Then each node in the ring is joined\\n    to its $k$ nearest neighbors (or $k - 1$ neighbors if $k$ is odd).\\n    Then shortcuts are created by replacing some edges as follows: for each\\n    edge $(u, v)$ in the underlying \"$n$-ring with $k$ nearest neighbors\"\\n    with probability $p$ replace it with a new edge $(u, w)$ with uniformly\\n    random choice of existing node $w$.\\n\\n    In contrast with :func:`newman_watts_strogatz_graph`, the random rewiring\\n    does not increase the number of edges. The rewired graph is not guaranteed\\n    to be connected as in :func:`connected_watts_strogatz_graph`.\\n\\n    References\\n    ----------\\n    .. [1] Duncan J. Watts and Steven H. Strogatz,\\n       Collective dynamics of small-world networks,\\n       Nature, 393, pp. 440--442, 1998.\\n    '\n    if k > n:\n        raise nx.NetworkXError('k>n, choose smaller k or larger n')\n    if k == n:\n        return nx.complete_graph(n)\n    G = nx.Graph()\n    nodes = list(range(n))\n    for j in range(1, k // 2 + 1):\n        targets = nodes[j:] + nodes[0:j]\n        G.add_edges_from(zip(nodes, targets))\n    for j in range(1, k // 2 + 1):\n        targets = nodes[j:] + nodes[0:j]\n        for (u, v) in zip(nodes, targets):\n            if seed.random() < p:\n                w = seed.choice(nodes)\n                while w == u or G.has_edge(u, w):\n                    w = seed.choice(nodes)\n                    if G.degree(u) >= n - 1:\n                        break\n                else:\n                    G.remove_edge(u, v)\n                    G.add_edge(u, w)\n    return G"
        ]
    },
    {
        "func_name": "connected_watts_strogatz_graph",
        "original": "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef connected_watts_strogatz_graph(n, k, p, tries=100, seed=None):\n    \"\"\"Returns a connected Watts\u2013Strogatz small-world graph.\n\n    Attempts to generate a connected graph by repeated generation of\n    Watts\u2013Strogatz small-world graphs.  An exception is raised if the maximum\n    number of tries is exceeded.\n\n    Parameters\n    ----------\n    n : int\n        The number of nodes\n    k : int\n        Each node is joined with its `k` nearest neighbors in a ring\n        topology.\n    p : float\n        The probability of rewiring each edge\n    tries : int\n        Number of attempts to generate a connected graph.\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Notes\n    -----\n    First create a ring over $n$ nodes [1]_.  Then each node in the ring is joined\n    to its $k$ nearest neighbors (or $k - 1$ neighbors if $k$ is odd).\n    Then shortcuts are created by replacing some edges as follows: for each\n    edge $(u, v)$ in the underlying \"$n$-ring with $k$ nearest neighbors\"\n    with probability $p$ replace it with a new edge $(u, w)$ with uniformly\n    random choice of existing node $w$.\n    The entire process is repeated until a connected graph results.\n\n    See Also\n    --------\n    newman_watts_strogatz_graph\n    watts_strogatz_graph\n\n    References\n    ----------\n    .. [1] Duncan J. Watts and Steven H. Strogatz,\n       Collective dynamics of small-world networks,\n       Nature, 393, pp. 440--442, 1998.\n    \"\"\"\n    for i in range(tries):\n        G = watts_strogatz_graph(n, k, p, seed)\n        if nx.is_connected(G):\n            return G\n    raise nx.NetworkXError('Maximum number of tries exceeded')",
        "mutated": [
            "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef connected_watts_strogatz_graph(n, k, p, tries=100, seed=None):\n    if False:\n        i = 10\n    'Returns a connected Watts\u2013Strogatz small-world graph.\\n\\n    Attempts to generate a connected graph by repeated generation of\\n    Watts\u2013Strogatz small-world graphs.  An exception is raised if the maximum\\n    number of tries is exceeded.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes\\n    k : int\\n        Each node is joined with its `k` nearest neighbors in a ring\\n        topology.\\n    p : float\\n        The probability of rewiring each edge\\n    tries : int\\n        Number of attempts to generate a connected graph.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    First create a ring over $n$ nodes [1]_.  Then each node in the ring is joined\\n    to its $k$ nearest neighbors (or $k - 1$ neighbors if $k$ is odd).\\n    Then shortcuts are created by replacing some edges as follows: for each\\n    edge $(u, v)$ in the underlying \"$n$-ring with $k$ nearest neighbors\"\\n    with probability $p$ replace it with a new edge $(u, w)$ with uniformly\\n    random choice of existing node $w$.\\n    The entire process is repeated until a connected graph results.\\n\\n    See Also\\n    --------\\n    newman_watts_strogatz_graph\\n    watts_strogatz_graph\\n\\n    References\\n    ----------\\n    .. [1] Duncan J. Watts and Steven H. Strogatz,\\n       Collective dynamics of small-world networks,\\n       Nature, 393, pp. 440--442, 1998.\\n    '\n    for i in range(tries):\n        G = watts_strogatz_graph(n, k, p, seed)\n        if nx.is_connected(G):\n            return G\n    raise nx.NetworkXError('Maximum number of tries exceeded')",
            "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef connected_watts_strogatz_graph(n, k, p, tries=100, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a connected Watts\u2013Strogatz small-world graph.\\n\\n    Attempts to generate a connected graph by repeated generation of\\n    Watts\u2013Strogatz small-world graphs.  An exception is raised if the maximum\\n    number of tries is exceeded.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes\\n    k : int\\n        Each node is joined with its `k` nearest neighbors in a ring\\n        topology.\\n    p : float\\n        The probability of rewiring each edge\\n    tries : int\\n        Number of attempts to generate a connected graph.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    First create a ring over $n$ nodes [1]_.  Then each node in the ring is joined\\n    to its $k$ nearest neighbors (or $k - 1$ neighbors if $k$ is odd).\\n    Then shortcuts are created by replacing some edges as follows: for each\\n    edge $(u, v)$ in the underlying \"$n$-ring with $k$ nearest neighbors\"\\n    with probability $p$ replace it with a new edge $(u, w)$ with uniformly\\n    random choice of existing node $w$.\\n    The entire process is repeated until a connected graph results.\\n\\n    See Also\\n    --------\\n    newman_watts_strogatz_graph\\n    watts_strogatz_graph\\n\\n    References\\n    ----------\\n    .. [1] Duncan J. Watts and Steven H. Strogatz,\\n       Collective dynamics of small-world networks,\\n       Nature, 393, pp. 440--442, 1998.\\n    '\n    for i in range(tries):\n        G = watts_strogatz_graph(n, k, p, seed)\n        if nx.is_connected(G):\n            return G\n    raise nx.NetworkXError('Maximum number of tries exceeded')",
            "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef connected_watts_strogatz_graph(n, k, p, tries=100, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a connected Watts\u2013Strogatz small-world graph.\\n\\n    Attempts to generate a connected graph by repeated generation of\\n    Watts\u2013Strogatz small-world graphs.  An exception is raised if the maximum\\n    number of tries is exceeded.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes\\n    k : int\\n        Each node is joined with its `k` nearest neighbors in a ring\\n        topology.\\n    p : float\\n        The probability of rewiring each edge\\n    tries : int\\n        Number of attempts to generate a connected graph.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    First create a ring over $n$ nodes [1]_.  Then each node in the ring is joined\\n    to its $k$ nearest neighbors (or $k - 1$ neighbors if $k$ is odd).\\n    Then shortcuts are created by replacing some edges as follows: for each\\n    edge $(u, v)$ in the underlying \"$n$-ring with $k$ nearest neighbors\"\\n    with probability $p$ replace it with a new edge $(u, w)$ with uniformly\\n    random choice of existing node $w$.\\n    The entire process is repeated until a connected graph results.\\n\\n    See Also\\n    --------\\n    newman_watts_strogatz_graph\\n    watts_strogatz_graph\\n\\n    References\\n    ----------\\n    .. [1] Duncan J. Watts and Steven H. Strogatz,\\n       Collective dynamics of small-world networks,\\n       Nature, 393, pp. 440--442, 1998.\\n    '\n    for i in range(tries):\n        G = watts_strogatz_graph(n, k, p, seed)\n        if nx.is_connected(G):\n            return G\n    raise nx.NetworkXError('Maximum number of tries exceeded')",
            "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef connected_watts_strogatz_graph(n, k, p, tries=100, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a connected Watts\u2013Strogatz small-world graph.\\n\\n    Attempts to generate a connected graph by repeated generation of\\n    Watts\u2013Strogatz small-world graphs.  An exception is raised if the maximum\\n    number of tries is exceeded.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes\\n    k : int\\n        Each node is joined with its `k` nearest neighbors in a ring\\n        topology.\\n    p : float\\n        The probability of rewiring each edge\\n    tries : int\\n        Number of attempts to generate a connected graph.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    First create a ring over $n$ nodes [1]_.  Then each node in the ring is joined\\n    to its $k$ nearest neighbors (or $k - 1$ neighbors if $k$ is odd).\\n    Then shortcuts are created by replacing some edges as follows: for each\\n    edge $(u, v)$ in the underlying \"$n$-ring with $k$ nearest neighbors\"\\n    with probability $p$ replace it with a new edge $(u, w)$ with uniformly\\n    random choice of existing node $w$.\\n    The entire process is repeated until a connected graph results.\\n\\n    See Also\\n    --------\\n    newman_watts_strogatz_graph\\n    watts_strogatz_graph\\n\\n    References\\n    ----------\\n    .. [1] Duncan J. Watts and Steven H. Strogatz,\\n       Collective dynamics of small-world networks,\\n       Nature, 393, pp. 440--442, 1998.\\n    '\n    for i in range(tries):\n        G = watts_strogatz_graph(n, k, p, seed)\n        if nx.is_connected(G):\n            return G\n    raise nx.NetworkXError('Maximum number of tries exceeded')",
            "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef connected_watts_strogatz_graph(n, k, p, tries=100, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a connected Watts\u2013Strogatz small-world graph.\\n\\n    Attempts to generate a connected graph by repeated generation of\\n    Watts\u2013Strogatz small-world graphs.  An exception is raised if the maximum\\n    number of tries is exceeded.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes\\n    k : int\\n        Each node is joined with its `k` nearest neighbors in a ring\\n        topology.\\n    p : float\\n        The probability of rewiring each edge\\n    tries : int\\n        Number of attempts to generate a connected graph.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    First create a ring over $n$ nodes [1]_.  Then each node in the ring is joined\\n    to its $k$ nearest neighbors (or $k - 1$ neighbors if $k$ is odd).\\n    Then shortcuts are created by replacing some edges as follows: for each\\n    edge $(u, v)$ in the underlying \"$n$-ring with $k$ nearest neighbors\"\\n    with probability $p$ replace it with a new edge $(u, w)$ with uniformly\\n    random choice of existing node $w$.\\n    The entire process is repeated until a connected graph results.\\n\\n    See Also\\n    --------\\n    newman_watts_strogatz_graph\\n    watts_strogatz_graph\\n\\n    References\\n    ----------\\n    .. [1] Duncan J. Watts and Steven H. Strogatz,\\n       Collective dynamics of small-world networks,\\n       Nature, 393, pp. 440--442, 1998.\\n    '\n    for i in range(tries):\n        G = watts_strogatz_graph(n, k, p, seed)\n        if nx.is_connected(G):\n            return G\n    raise nx.NetworkXError('Maximum number of tries exceeded')"
        ]
    },
    {
        "func_name": "_suitable",
        "original": "def _suitable(edges, potential_edges):\n    if not potential_edges:\n        return True\n    for s1 in potential_edges:\n        for s2 in potential_edges:\n            if s1 == s2:\n                break\n            if s1 > s2:\n                (s1, s2) = (s2, s1)\n            if (s1, s2) not in edges:\n                return True\n    return False",
        "mutated": [
            "def _suitable(edges, potential_edges):\n    if False:\n        i = 10\n    if not potential_edges:\n        return True\n    for s1 in potential_edges:\n        for s2 in potential_edges:\n            if s1 == s2:\n                break\n            if s1 > s2:\n                (s1, s2) = (s2, s1)\n            if (s1, s2) not in edges:\n                return True\n    return False",
            "def _suitable(edges, potential_edges):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not potential_edges:\n        return True\n    for s1 in potential_edges:\n        for s2 in potential_edges:\n            if s1 == s2:\n                break\n            if s1 > s2:\n                (s1, s2) = (s2, s1)\n            if (s1, s2) not in edges:\n                return True\n    return False",
            "def _suitable(edges, potential_edges):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not potential_edges:\n        return True\n    for s1 in potential_edges:\n        for s2 in potential_edges:\n            if s1 == s2:\n                break\n            if s1 > s2:\n                (s1, s2) = (s2, s1)\n            if (s1, s2) not in edges:\n                return True\n    return False",
            "def _suitable(edges, potential_edges):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not potential_edges:\n        return True\n    for s1 in potential_edges:\n        for s2 in potential_edges:\n            if s1 == s2:\n                break\n            if s1 > s2:\n                (s1, s2) = (s2, s1)\n            if (s1, s2) not in edges:\n                return True\n    return False",
            "def _suitable(edges, potential_edges):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not potential_edges:\n        return True\n    for s1 in potential_edges:\n        for s2 in potential_edges:\n            if s1 == s2:\n                break\n            if s1 > s2:\n                (s1, s2) = (s2, s1)\n            if (s1, s2) not in edges:\n                return True\n    return False"
        ]
    },
    {
        "func_name": "_try_creation",
        "original": "def _try_creation():\n    edges = set()\n    stubs = list(range(n)) * d\n    while stubs:\n        potential_edges = defaultdict(lambda : 0)\n        seed.shuffle(stubs)\n        stubiter = iter(stubs)\n        for (s1, s2) in zip(stubiter, stubiter):\n            if s1 > s2:\n                (s1, s2) = (s2, s1)\n            if s1 != s2 and (s1, s2) not in edges:\n                edges.add((s1, s2))\n            else:\n                potential_edges[s1] += 1\n                potential_edges[s2] += 1\n        if not _suitable(edges, potential_edges):\n            return None\n        stubs = [node for (node, potential) in potential_edges.items() for _ in range(potential)]\n    return edges",
        "mutated": [
            "def _try_creation():\n    if False:\n        i = 10\n    edges = set()\n    stubs = list(range(n)) * d\n    while stubs:\n        potential_edges = defaultdict(lambda : 0)\n        seed.shuffle(stubs)\n        stubiter = iter(stubs)\n        for (s1, s2) in zip(stubiter, stubiter):\n            if s1 > s2:\n                (s1, s2) = (s2, s1)\n            if s1 != s2 and (s1, s2) not in edges:\n                edges.add((s1, s2))\n            else:\n                potential_edges[s1] += 1\n                potential_edges[s2] += 1\n        if not _suitable(edges, potential_edges):\n            return None\n        stubs = [node for (node, potential) in potential_edges.items() for _ in range(potential)]\n    return edges",
            "def _try_creation():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    edges = set()\n    stubs = list(range(n)) * d\n    while stubs:\n        potential_edges = defaultdict(lambda : 0)\n        seed.shuffle(stubs)\n        stubiter = iter(stubs)\n        for (s1, s2) in zip(stubiter, stubiter):\n            if s1 > s2:\n                (s1, s2) = (s2, s1)\n            if s1 != s2 and (s1, s2) not in edges:\n                edges.add((s1, s2))\n            else:\n                potential_edges[s1] += 1\n                potential_edges[s2] += 1\n        if not _suitable(edges, potential_edges):\n            return None\n        stubs = [node for (node, potential) in potential_edges.items() for _ in range(potential)]\n    return edges",
            "def _try_creation():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    edges = set()\n    stubs = list(range(n)) * d\n    while stubs:\n        potential_edges = defaultdict(lambda : 0)\n        seed.shuffle(stubs)\n        stubiter = iter(stubs)\n        for (s1, s2) in zip(stubiter, stubiter):\n            if s1 > s2:\n                (s1, s2) = (s2, s1)\n            if s1 != s2 and (s1, s2) not in edges:\n                edges.add((s1, s2))\n            else:\n                potential_edges[s1] += 1\n                potential_edges[s2] += 1\n        if not _suitable(edges, potential_edges):\n            return None\n        stubs = [node for (node, potential) in potential_edges.items() for _ in range(potential)]\n    return edges",
            "def _try_creation():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    edges = set()\n    stubs = list(range(n)) * d\n    while stubs:\n        potential_edges = defaultdict(lambda : 0)\n        seed.shuffle(stubs)\n        stubiter = iter(stubs)\n        for (s1, s2) in zip(stubiter, stubiter):\n            if s1 > s2:\n                (s1, s2) = (s2, s1)\n            if s1 != s2 and (s1, s2) not in edges:\n                edges.add((s1, s2))\n            else:\n                potential_edges[s1] += 1\n                potential_edges[s2] += 1\n        if not _suitable(edges, potential_edges):\n            return None\n        stubs = [node for (node, potential) in potential_edges.items() for _ in range(potential)]\n    return edges",
            "def _try_creation():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    edges = set()\n    stubs = list(range(n)) * d\n    while stubs:\n        potential_edges = defaultdict(lambda : 0)\n        seed.shuffle(stubs)\n        stubiter = iter(stubs)\n        for (s1, s2) in zip(stubiter, stubiter):\n            if s1 > s2:\n                (s1, s2) = (s2, s1)\n            if s1 != s2 and (s1, s2) not in edges:\n                edges.add((s1, s2))\n            else:\n                potential_edges[s1] += 1\n                potential_edges[s2] += 1\n        if not _suitable(edges, potential_edges):\n            return None\n        stubs = [node for (node, potential) in potential_edges.items() for _ in range(potential)]\n    return edges"
        ]
    },
    {
        "func_name": "random_regular_graph",
        "original": "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef random_regular_graph(d, n, seed=None):\n    \"\"\"Returns a random $d$-regular graph on $n$ nodes.\n\n    A regular graph is a graph where each node has the same number of neighbors.\n\n    The resulting graph has no self-loops or parallel edges.\n\n    Parameters\n    ----------\n    d : int\n      The degree of each node.\n    n : integer\n      The number of nodes. The value of $n \\\\times d$ must be even.\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Notes\n    -----\n    The nodes are numbered from $0$ to $n - 1$.\n\n    Kim and Vu's paper [2]_ shows that this algorithm samples in an\n    asymptotically uniform way from the space of random graphs when\n    $d = O(n^{1 / 3 - \\\\epsilon})$.\n\n    Raises\n    ------\n\n    NetworkXError\n        If $n \\\\times d$ is odd or $d$ is greater than or equal to $n$.\n\n    References\n    ----------\n    .. [1] A. Steger and N. Wormald,\n       Generating random regular graphs quickly,\n       Probability and Computing 8 (1999), 377-396, 1999.\n       https://doi.org/10.1017/S0963548399003867\n\n    .. [2] Jeong Han Kim and Van H. Vu,\n       Generating random regular graphs,\n       Proceedings of the thirty-fifth ACM symposium on Theory of computing,\n       San Diego, CA, USA, pp 213--222, 2003.\n       http://portal.acm.org/citation.cfm?id=780542.780576\n    \"\"\"\n    if n * d % 2 != 0:\n        raise nx.NetworkXError('n * d must be even')\n    if not 0 <= d < n:\n        raise nx.NetworkXError('the 0 <= d < n inequality must be satisfied')\n    if d == 0:\n        return empty_graph(n)\n\n    def _suitable(edges, potential_edges):\n        if not potential_edges:\n            return True\n        for s1 in potential_edges:\n            for s2 in potential_edges:\n                if s1 == s2:\n                    break\n                if s1 > s2:\n                    (s1, s2) = (s2, s1)\n                if (s1, s2) not in edges:\n                    return True\n        return False\n\n    def _try_creation():\n        edges = set()\n        stubs = list(range(n)) * d\n        while stubs:\n            potential_edges = defaultdict(lambda : 0)\n            seed.shuffle(stubs)\n            stubiter = iter(stubs)\n            for (s1, s2) in zip(stubiter, stubiter):\n                if s1 > s2:\n                    (s1, s2) = (s2, s1)\n                if s1 != s2 and (s1, s2) not in edges:\n                    edges.add((s1, s2))\n                else:\n                    potential_edges[s1] += 1\n                    potential_edges[s2] += 1\n            if not _suitable(edges, potential_edges):\n                return None\n            stubs = [node for (node, potential) in potential_edges.items() for _ in range(potential)]\n        return edges\n    edges = _try_creation()\n    while edges is None:\n        edges = _try_creation()\n    G = nx.Graph()\n    G.add_edges_from(edges)\n    return G",
        "mutated": [
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef random_regular_graph(d, n, seed=None):\n    if False:\n        i = 10\n    \"Returns a random $d$-regular graph on $n$ nodes.\\n\\n    A regular graph is a graph where each node has the same number of neighbors.\\n\\n    The resulting graph has no self-loops or parallel edges.\\n\\n    Parameters\\n    ----------\\n    d : int\\n      The degree of each node.\\n    n : integer\\n      The number of nodes. The value of $n \\\\times d$ must be even.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    The nodes are numbered from $0$ to $n - 1$.\\n\\n    Kim and Vu's paper [2]_ shows that this algorithm samples in an\\n    asymptotically uniform way from the space of random graphs when\\n    $d = O(n^{1 / 3 - \\\\epsilon})$.\\n\\n    Raises\\n    ------\\n\\n    NetworkXError\\n        If $n \\\\times d$ is odd or $d$ is greater than or equal to $n$.\\n\\n    References\\n    ----------\\n    .. [1] A. Steger and N. Wormald,\\n       Generating random regular graphs quickly,\\n       Probability and Computing 8 (1999), 377-396, 1999.\\n       https://doi.org/10.1017/S0963548399003867\\n\\n    .. [2] Jeong Han Kim and Van H. Vu,\\n       Generating random regular graphs,\\n       Proceedings of the thirty-fifth ACM symposium on Theory of computing,\\n       San Diego, CA, USA, pp 213--222, 2003.\\n       http://portal.acm.org/citation.cfm?id=780542.780576\\n    \"\n    if n * d % 2 != 0:\n        raise nx.NetworkXError('n * d must be even')\n    if not 0 <= d < n:\n        raise nx.NetworkXError('the 0 <= d < n inequality must be satisfied')\n    if d == 0:\n        return empty_graph(n)\n\n    def _suitable(edges, potential_edges):\n        if not potential_edges:\n            return True\n        for s1 in potential_edges:\n            for s2 in potential_edges:\n                if s1 == s2:\n                    break\n                if s1 > s2:\n                    (s1, s2) = (s2, s1)\n                if (s1, s2) not in edges:\n                    return True\n        return False\n\n    def _try_creation():\n        edges = set()\n        stubs = list(range(n)) * d\n        while stubs:\n            potential_edges = defaultdict(lambda : 0)\n            seed.shuffle(stubs)\n            stubiter = iter(stubs)\n            for (s1, s2) in zip(stubiter, stubiter):\n                if s1 > s2:\n                    (s1, s2) = (s2, s1)\n                if s1 != s2 and (s1, s2) not in edges:\n                    edges.add((s1, s2))\n                else:\n                    potential_edges[s1] += 1\n                    potential_edges[s2] += 1\n            if not _suitable(edges, potential_edges):\n                return None\n            stubs = [node for (node, potential) in potential_edges.items() for _ in range(potential)]\n        return edges\n    edges = _try_creation()\n    while edges is None:\n        edges = _try_creation()\n    G = nx.Graph()\n    G.add_edges_from(edges)\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef random_regular_graph(d, n, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Returns a random $d$-regular graph on $n$ nodes.\\n\\n    A regular graph is a graph where each node has the same number of neighbors.\\n\\n    The resulting graph has no self-loops or parallel edges.\\n\\n    Parameters\\n    ----------\\n    d : int\\n      The degree of each node.\\n    n : integer\\n      The number of nodes. The value of $n \\\\times d$ must be even.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    The nodes are numbered from $0$ to $n - 1$.\\n\\n    Kim and Vu's paper [2]_ shows that this algorithm samples in an\\n    asymptotically uniform way from the space of random graphs when\\n    $d = O(n^{1 / 3 - \\\\epsilon})$.\\n\\n    Raises\\n    ------\\n\\n    NetworkXError\\n        If $n \\\\times d$ is odd or $d$ is greater than or equal to $n$.\\n\\n    References\\n    ----------\\n    .. [1] A. Steger and N. Wormald,\\n       Generating random regular graphs quickly,\\n       Probability and Computing 8 (1999), 377-396, 1999.\\n       https://doi.org/10.1017/S0963548399003867\\n\\n    .. [2] Jeong Han Kim and Van H. Vu,\\n       Generating random regular graphs,\\n       Proceedings of the thirty-fifth ACM symposium on Theory of computing,\\n       San Diego, CA, USA, pp 213--222, 2003.\\n       http://portal.acm.org/citation.cfm?id=780542.780576\\n    \"\n    if n * d % 2 != 0:\n        raise nx.NetworkXError('n * d must be even')\n    if not 0 <= d < n:\n        raise nx.NetworkXError('the 0 <= d < n inequality must be satisfied')\n    if d == 0:\n        return empty_graph(n)\n\n    def _suitable(edges, potential_edges):\n        if not potential_edges:\n            return True\n        for s1 in potential_edges:\n            for s2 in potential_edges:\n                if s1 == s2:\n                    break\n                if s1 > s2:\n                    (s1, s2) = (s2, s1)\n                if (s1, s2) not in edges:\n                    return True\n        return False\n\n    def _try_creation():\n        edges = set()\n        stubs = list(range(n)) * d\n        while stubs:\n            potential_edges = defaultdict(lambda : 0)\n            seed.shuffle(stubs)\n            stubiter = iter(stubs)\n            for (s1, s2) in zip(stubiter, stubiter):\n                if s1 > s2:\n                    (s1, s2) = (s2, s1)\n                if s1 != s2 and (s1, s2) not in edges:\n                    edges.add((s1, s2))\n                else:\n                    potential_edges[s1] += 1\n                    potential_edges[s2] += 1\n            if not _suitable(edges, potential_edges):\n                return None\n            stubs = [node for (node, potential) in potential_edges.items() for _ in range(potential)]\n        return edges\n    edges = _try_creation()\n    while edges is None:\n        edges = _try_creation()\n    G = nx.Graph()\n    G.add_edges_from(edges)\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef random_regular_graph(d, n, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Returns a random $d$-regular graph on $n$ nodes.\\n\\n    A regular graph is a graph where each node has the same number of neighbors.\\n\\n    The resulting graph has no self-loops or parallel edges.\\n\\n    Parameters\\n    ----------\\n    d : int\\n      The degree of each node.\\n    n : integer\\n      The number of nodes. The value of $n \\\\times d$ must be even.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    The nodes are numbered from $0$ to $n - 1$.\\n\\n    Kim and Vu's paper [2]_ shows that this algorithm samples in an\\n    asymptotically uniform way from the space of random graphs when\\n    $d = O(n^{1 / 3 - \\\\epsilon})$.\\n\\n    Raises\\n    ------\\n\\n    NetworkXError\\n        If $n \\\\times d$ is odd or $d$ is greater than or equal to $n$.\\n\\n    References\\n    ----------\\n    .. [1] A. Steger and N. Wormald,\\n       Generating random regular graphs quickly,\\n       Probability and Computing 8 (1999), 377-396, 1999.\\n       https://doi.org/10.1017/S0963548399003867\\n\\n    .. [2] Jeong Han Kim and Van H. Vu,\\n       Generating random regular graphs,\\n       Proceedings of the thirty-fifth ACM symposium on Theory of computing,\\n       San Diego, CA, USA, pp 213--222, 2003.\\n       http://portal.acm.org/citation.cfm?id=780542.780576\\n    \"\n    if n * d % 2 != 0:\n        raise nx.NetworkXError('n * d must be even')\n    if not 0 <= d < n:\n        raise nx.NetworkXError('the 0 <= d < n inequality must be satisfied')\n    if d == 0:\n        return empty_graph(n)\n\n    def _suitable(edges, potential_edges):\n        if not potential_edges:\n            return True\n        for s1 in potential_edges:\n            for s2 in potential_edges:\n                if s1 == s2:\n                    break\n                if s1 > s2:\n                    (s1, s2) = (s2, s1)\n                if (s1, s2) not in edges:\n                    return True\n        return False\n\n    def _try_creation():\n        edges = set()\n        stubs = list(range(n)) * d\n        while stubs:\n            potential_edges = defaultdict(lambda : 0)\n            seed.shuffle(stubs)\n            stubiter = iter(stubs)\n            for (s1, s2) in zip(stubiter, stubiter):\n                if s1 > s2:\n                    (s1, s2) = (s2, s1)\n                if s1 != s2 and (s1, s2) not in edges:\n                    edges.add((s1, s2))\n                else:\n                    potential_edges[s1] += 1\n                    potential_edges[s2] += 1\n            if not _suitable(edges, potential_edges):\n                return None\n            stubs = [node for (node, potential) in potential_edges.items() for _ in range(potential)]\n        return edges\n    edges = _try_creation()\n    while edges is None:\n        edges = _try_creation()\n    G = nx.Graph()\n    G.add_edges_from(edges)\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef random_regular_graph(d, n, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Returns a random $d$-regular graph on $n$ nodes.\\n\\n    A regular graph is a graph where each node has the same number of neighbors.\\n\\n    The resulting graph has no self-loops or parallel edges.\\n\\n    Parameters\\n    ----------\\n    d : int\\n      The degree of each node.\\n    n : integer\\n      The number of nodes. The value of $n \\\\times d$ must be even.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    The nodes are numbered from $0$ to $n - 1$.\\n\\n    Kim and Vu's paper [2]_ shows that this algorithm samples in an\\n    asymptotically uniform way from the space of random graphs when\\n    $d = O(n^{1 / 3 - \\\\epsilon})$.\\n\\n    Raises\\n    ------\\n\\n    NetworkXError\\n        If $n \\\\times d$ is odd or $d$ is greater than or equal to $n$.\\n\\n    References\\n    ----------\\n    .. [1] A. Steger and N. Wormald,\\n       Generating random regular graphs quickly,\\n       Probability and Computing 8 (1999), 377-396, 1999.\\n       https://doi.org/10.1017/S0963548399003867\\n\\n    .. [2] Jeong Han Kim and Van H. Vu,\\n       Generating random regular graphs,\\n       Proceedings of the thirty-fifth ACM symposium on Theory of computing,\\n       San Diego, CA, USA, pp 213--222, 2003.\\n       http://portal.acm.org/citation.cfm?id=780542.780576\\n    \"\n    if n * d % 2 != 0:\n        raise nx.NetworkXError('n * d must be even')\n    if not 0 <= d < n:\n        raise nx.NetworkXError('the 0 <= d < n inequality must be satisfied')\n    if d == 0:\n        return empty_graph(n)\n\n    def _suitable(edges, potential_edges):\n        if not potential_edges:\n            return True\n        for s1 in potential_edges:\n            for s2 in potential_edges:\n                if s1 == s2:\n                    break\n                if s1 > s2:\n                    (s1, s2) = (s2, s1)\n                if (s1, s2) not in edges:\n                    return True\n        return False\n\n    def _try_creation():\n        edges = set()\n        stubs = list(range(n)) * d\n        while stubs:\n            potential_edges = defaultdict(lambda : 0)\n            seed.shuffle(stubs)\n            stubiter = iter(stubs)\n            for (s1, s2) in zip(stubiter, stubiter):\n                if s1 > s2:\n                    (s1, s2) = (s2, s1)\n                if s1 != s2 and (s1, s2) not in edges:\n                    edges.add((s1, s2))\n                else:\n                    potential_edges[s1] += 1\n                    potential_edges[s2] += 1\n            if not _suitable(edges, potential_edges):\n                return None\n            stubs = [node for (node, potential) in potential_edges.items() for _ in range(potential)]\n        return edges\n    edges = _try_creation()\n    while edges is None:\n        edges = _try_creation()\n    G = nx.Graph()\n    G.add_edges_from(edges)\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef random_regular_graph(d, n, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Returns a random $d$-regular graph on $n$ nodes.\\n\\n    A regular graph is a graph where each node has the same number of neighbors.\\n\\n    The resulting graph has no self-loops or parallel edges.\\n\\n    Parameters\\n    ----------\\n    d : int\\n      The degree of each node.\\n    n : integer\\n      The number of nodes. The value of $n \\\\times d$ must be even.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    The nodes are numbered from $0$ to $n - 1$.\\n\\n    Kim and Vu's paper [2]_ shows that this algorithm samples in an\\n    asymptotically uniform way from the space of random graphs when\\n    $d = O(n^{1 / 3 - \\\\epsilon})$.\\n\\n    Raises\\n    ------\\n\\n    NetworkXError\\n        If $n \\\\times d$ is odd or $d$ is greater than or equal to $n$.\\n\\n    References\\n    ----------\\n    .. [1] A. Steger and N. Wormald,\\n       Generating random regular graphs quickly,\\n       Probability and Computing 8 (1999), 377-396, 1999.\\n       https://doi.org/10.1017/S0963548399003867\\n\\n    .. [2] Jeong Han Kim and Van H. Vu,\\n       Generating random regular graphs,\\n       Proceedings of the thirty-fifth ACM symposium on Theory of computing,\\n       San Diego, CA, USA, pp 213--222, 2003.\\n       http://portal.acm.org/citation.cfm?id=780542.780576\\n    \"\n    if n * d % 2 != 0:\n        raise nx.NetworkXError('n * d must be even')\n    if not 0 <= d < n:\n        raise nx.NetworkXError('the 0 <= d < n inequality must be satisfied')\n    if d == 0:\n        return empty_graph(n)\n\n    def _suitable(edges, potential_edges):\n        if not potential_edges:\n            return True\n        for s1 in potential_edges:\n            for s2 in potential_edges:\n                if s1 == s2:\n                    break\n                if s1 > s2:\n                    (s1, s2) = (s2, s1)\n                if (s1, s2) not in edges:\n                    return True\n        return False\n\n    def _try_creation():\n        edges = set()\n        stubs = list(range(n)) * d\n        while stubs:\n            potential_edges = defaultdict(lambda : 0)\n            seed.shuffle(stubs)\n            stubiter = iter(stubs)\n            for (s1, s2) in zip(stubiter, stubiter):\n                if s1 > s2:\n                    (s1, s2) = (s2, s1)\n                if s1 != s2 and (s1, s2) not in edges:\n                    edges.add((s1, s2))\n                else:\n                    potential_edges[s1] += 1\n                    potential_edges[s2] += 1\n            if not _suitable(edges, potential_edges):\n                return None\n            stubs = [node for (node, potential) in potential_edges.items() for _ in range(potential)]\n        return edges\n    edges = _try_creation()\n    while edges is None:\n        edges = _try_creation()\n    G = nx.Graph()\n    G.add_edges_from(edges)\n    return G"
        ]
    },
    {
        "func_name": "_random_subset",
        "original": "def _random_subset(seq, m, rng):\n    \"\"\"Return m unique elements from seq.\n\n    This differs from random.sample which can return repeated\n    elements if seq holds repeated elements.\n\n    Note: rng is a random.Random or numpy.random.RandomState instance.\n    \"\"\"\n    targets = set()\n    while len(targets) < m:\n        x = rng.choice(seq)\n        targets.add(x)\n    return targets",
        "mutated": [
            "def _random_subset(seq, m, rng):\n    if False:\n        i = 10\n    'Return m unique elements from seq.\\n\\n    This differs from random.sample which can return repeated\\n    elements if seq holds repeated elements.\\n\\n    Note: rng is a random.Random or numpy.random.RandomState instance.\\n    '\n    targets = set()\n    while len(targets) < m:\n        x = rng.choice(seq)\n        targets.add(x)\n    return targets",
            "def _random_subset(seq, m, rng):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return m unique elements from seq.\\n\\n    This differs from random.sample which can return repeated\\n    elements if seq holds repeated elements.\\n\\n    Note: rng is a random.Random or numpy.random.RandomState instance.\\n    '\n    targets = set()\n    while len(targets) < m:\n        x = rng.choice(seq)\n        targets.add(x)\n    return targets",
            "def _random_subset(seq, m, rng):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return m unique elements from seq.\\n\\n    This differs from random.sample which can return repeated\\n    elements if seq holds repeated elements.\\n\\n    Note: rng is a random.Random or numpy.random.RandomState instance.\\n    '\n    targets = set()\n    while len(targets) < m:\n        x = rng.choice(seq)\n        targets.add(x)\n    return targets",
            "def _random_subset(seq, m, rng):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return m unique elements from seq.\\n\\n    This differs from random.sample which can return repeated\\n    elements if seq holds repeated elements.\\n\\n    Note: rng is a random.Random or numpy.random.RandomState instance.\\n    '\n    targets = set()\n    while len(targets) < m:\n        x = rng.choice(seq)\n        targets.add(x)\n    return targets",
            "def _random_subset(seq, m, rng):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return m unique elements from seq.\\n\\n    This differs from random.sample which can return repeated\\n    elements if seq holds repeated elements.\\n\\n    Note: rng is a random.Random or numpy.random.RandomState instance.\\n    '\n    targets = set()\n    while len(targets) < m:\n        x = rng.choice(seq)\n        targets.add(x)\n    return targets"
        ]
    },
    {
        "func_name": "barabasi_albert_graph",
        "original": "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef barabasi_albert_graph(n, m, seed=None, initial_graph=None):\n    \"\"\"Returns a random graph using Barab\u00e1si\u2013Albert preferential attachment\n\n    A graph of $n$ nodes is grown by attaching new nodes each with $m$\n    edges that are preferentially attached to existing nodes with high degree.\n\n    Parameters\n    ----------\n    n : int\n        Number of nodes\n    m : int\n        Number of edges to attach from a new node to existing nodes\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n    initial_graph : Graph or None (default)\n        Initial network for Barab\u00e1si\u2013Albert algorithm.\n        It should be a connected graph for most use cases.\n        A copy of `initial_graph` is used.\n        If None, starts from a star graph on (m+1) nodes.\n\n    Returns\n    -------\n    G : Graph\n\n    Raises\n    ------\n    NetworkXError\n        If `m` does not satisfy ``1 <= m < n``, or\n        the initial graph number of nodes m0 does not satisfy ``m <= m0 <= n``.\n\n    References\n    ----------\n    .. [1] A. L. Barab\u00e1si and R. Albert \"Emergence of scaling in\n       random networks\", Science 286, pp 509-512, 1999.\n    \"\"\"\n    if m < 1 or m >= n:\n        raise nx.NetworkXError(f'Barab\u00e1si\u2013Albert network must have m >= 1 and m < n, m = {m}, n = {n}')\n    if initial_graph is None:\n        G = star_graph(m)\n    else:\n        if len(initial_graph) < m or len(initial_graph) > n:\n            raise nx.NetworkXError(f'Barab\u00e1si\u2013Albert initial graph needs between m={m} and n={n} nodes')\n        G = initial_graph.copy()\n    repeated_nodes = [n for (n, d) in G.degree() for _ in range(d)]\n    source = len(G)\n    while source < n:\n        targets = _random_subset(repeated_nodes, m, seed)\n        G.add_edges_from(zip([source] * m, targets))\n        repeated_nodes.extend(targets)\n        repeated_nodes.extend([source] * m)\n        source += 1\n    return G",
        "mutated": [
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef barabasi_albert_graph(n, m, seed=None, initial_graph=None):\n    if False:\n        i = 10\n    'Returns a random graph using Barab\u00e1si\u2013Albert preferential attachment\\n\\n    A graph of $n$ nodes is grown by attaching new nodes each with $m$\\n    edges that are preferentially attached to existing nodes with high degree.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        Number of nodes\\n    m : int\\n        Number of edges to attach from a new node to existing nodes\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    initial_graph : Graph or None (default)\\n        Initial network for Barab\u00e1si\u2013Albert algorithm.\\n        It should be a connected graph for most use cases.\\n        A copy of `initial_graph` is used.\\n        If None, starts from a star graph on (m+1) nodes.\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `m` does not satisfy ``1 <= m < n``, or\\n        the initial graph number of nodes m0 does not satisfy ``m <= m0 <= n``.\\n\\n    References\\n    ----------\\n    .. [1] A. L. Barab\u00e1si and R. Albert \"Emergence of scaling in\\n       random networks\", Science 286, pp 509-512, 1999.\\n    '\n    if m < 1 or m >= n:\n        raise nx.NetworkXError(f'Barab\u00e1si\u2013Albert network must have m >= 1 and m < n, m = {m}, n = {n}')\n    if initial_graph is None:\n        G = star_graph(m)\n    else:\n        if len(initial_graph) < m or len(initial_graph) > n:\n            raise nx.NetworkXError(f'Barab\u00e1si\u2013Albert initial graph needs between m={m} and n={n} nodes')\n        G = initial_graph.copy()\n    repeated_nodes = [n for (n, d) in G.degree() for _ in range(d)]\n    source = len(G)\n    while source < n:\n        targets = _random_subset(repeated_nodes, m, seed)\n        G.add_edges_from(zip([source] * m, targets))\n        repeated_nodes.extend(targets)\n        repeated_nodes.extend([source] * m)\n        source += 1\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef barabasi_albert_graph(n, m, seed=None, initial_graph=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a random graph using Barab\u00e1si\u2013Albert preferential attachment\\n\\n    A graph of $n$ nodes is grown by attaching new nodes each with $m$\\n    edges that are preferentially attached to existing nodes with high degree.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        Number of nodes\\n    m : int\\n        Number of edges to attach from a new node to existing nodes\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    initial_graph : Graph or None (default)\\n        Initial network for Barab\u00e1si\u2013Albert algorithm.\\n        It should be a connected graph for most use cases.\\n        A copy of `initial_graph` is used.\\n        If None, starts from a star graph on (m+1) nodes.\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `m` does not satisfy ``1 <= m < n``, or\\n        the initial graph number of nodes m0 does not satisfy ``m <= m0 <= n``.\\n\\n    References\\n    ----------\\n    .. [1] A. L. Barab\u00e1si and R. Albert \"Emergence of scaling in\\n       random networks\", Science 286, pp 509-512, 1999.\\n    '\n    if m < 1 or m >= n:\n        raise nx.NetworkXError(f'Barab\u00e1si\u2013Albert network must have m >= 1 and m < n, m = {m}, n = {n}')\n    if initial_graph is None:\n        G = star_graph(m)\n    else:\n        if len(initial_graph) < m or len(initial_graph) > n:\n            raise nx.NetworkXError(f'Barab\u00e1si\u2013Albert initial graph needs between m={m} and n={n} nodes')\n        G = initial_graph.copy()\n    repeated_nodes = [n for (n, d) in G.degree() for _ in range(d)]\n    source = len(G)\n    while source < n:\n        targets = _random_subset(repeated_nodes, m, seed)\n        G.add_edges_from(zip([source] * m, targets))\n        repeated_nodes.extend(targets)\n        repeated_nodes.extend([source] * m)\n        source += 1\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef barabasi_albert_graph(n, m, seed=None, initial_graph=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a random graph using Barab\u00e1si\u2013Albert preferential attachment\\n\\n    A graph of $n$ nodes is grown by attaching new nodes each with $m$\\n    edges that are preferentially attached to existing nodes with high degree.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        Number of nodes\\n    m : int\\n        Number of edges to attach from a new node to existing nodes\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    initial_graph : Graph or None (default)\\n        Initial network for Barab\u00e1si\u2013Albert algorithm.\\n        It should be a connected graph for most use cases.\\n        A copy of `initial_graph` is used.\\n        If None, starts from a star graph on (m+1) nodes.\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `m` does not satisfy ``1 <= m < n``, or\\n        the initial graph number of nodes m0 does not satisfy ``m <= m0 <= n``.\\n\\n    References\\n    ----------\\n    .. [1] A. L. Barab\u00e1si and R. Albert \"Emergence of scaling in\\n       random networks\", Science 286, pp 509-512, 1999.\\n    '\n    if m < 1 or m >= n:\n        raise nx.NetworkXError(f'Barab\u00e1si\u2013Albert network must have m >= 1 and m < n, m = {m}, n = {n}')\n    if initial_graph is None:\n        G = star_graph(m)\n    else:\n        if len(initial_graph) < m or len(initial_graph) > n:\n            raise nx.NetworkXError(f'Barab\u00e1si\u2013Albert initial graph needs between m={m} and n={n} nodes')\n        G = initial_graph.copy()\n    repeated_nodes = [n for (n, d) in G.degree() for _ in range(d)]\n    source = len(G)\n    while source < n:\n        targets = _random_subset(repeated_nodes, m, seed)\n        G.add_edges_from(zip([source] * m, targets))\n        repeated_nodes.extend(targets)\n        repeated_nodes.extend([source] * m)\n        source += 1\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef barabasi_albert_graph(n, m, seed=None, initial_graph=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a random graph using Barab\u00e1si\u2013Albert preferential attachment\\n\\n    A graph of $n$ nodes is grown by attaching new nodes each with $m$\\n    edges that are preferentially attached to existing nodes with high degree.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        Number of nodes\\n    m : int\\n        Number of edges to attach from a new node to existing nodes\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    initial_graph : Graph or None (default)\\n        Initial network for Barab\u00e1si\u2013Albert algorithm.\\n        It should be a connected graph for most use cases.\\n        A copy of `initial_graph` is used.\\n        If None, starts from a star graph on (m+1) nodes.\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `m` does not satisfy ``1 <= m < n``, or\\n        the initial graph number of nodes m0 does not satisfy ``m <= m0 <= n``.\\n\\n    References\\n    ----------\\n    .. [1] A. L. Barab\u00e1si and R. Albert \"Emergence of scaling in\\n       random networks\", Science 286, pp 509-512, 1999.\\n    '\n    if m < 1 or m >= n:\n        raise nx.NetworkXError(f'Barab\u00e1si\u2013Albert network must have m >= 1 and m < n, m = {m}, n = {n}')\n    if initial_graph is None:\n        G = star_graph(m)\n    else:\n        if len(initial_graph) < m or len(initial_graph) > n:\n            raise nx.NetworkXError(f'Barab\u00e1si\u2013Albert initial graph needs between m={m} and n={n} nodes')\n        G = initial_graph.copy()\n    repeated_nodes = [n for (n, d) in G.degree() for _ in range(d)]\n    source = len(G)\n    while source < n:\n        targets = _random_subset(repeated_nodes, m, seed)\n        G.add_edges_from(zip([source] * m, targets))\n        repeated_nodes.extend(targets)\n        repeated_nodes.extend([source] * m)\n        source += 1\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef barabasi_albert_graph(n, m, seed=None, initial_graph=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a random graph using Barab\u00e1si\u2013Albert preferential attachment\\n\\n    A graph of $n$ nodes is grown by attaching new nodes each with $m$\\n    edges that are preferentially attached to existing nodes with high degree.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        Number of nodes\\n    m : int\\n        Number of edges to attach from a new node to existing nodes\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    initial_graph : Graph or None (default)\\n        Initial network for Barab\u00e1si\u2013Albert algorithm.\\n        It should be a connected graph for most use cases.\\n        A copy of `initial_graph` is used.\\n        If None, starts from a star graph on (m+1) nodes.\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `m` does not satisfy ``1 <= m < n``, or\\n        the initial graph number of nodes m0 does not satisfy ``m <= m0 <= n``.\\n\\n    References\\n    ----------\\n    .. [1] A. L. Barab\u00e1si and R. Albert \"Emergence of scaling in\\n       random networks\", Science 286, pp 509-512, 1999.\\n    '\n    if m < 1 or m >= n:\n        raise nx.NetworkXError(f'Barab\u00e1si\u2013Albert network must have m >= 1 and m < n, m = {m}, n = {n}')\n    if initial_graph is None:\n        G = star_graph(m)\n    else:\n        if len(initial_graph) < m or len(initial_graph) > n:\n            raise nx.NetworkXError(f'Barab\u00e1si\u2013Albert initial graph needs between m={m} and n={n} nodes')\n        G = initial_graph.copy()\n    repeated_nodes = [n for (n, d) in G.degree() for _ in range(d)]\n    source = len(G)\n    while source < n:\n        targets = _random_subset(repeated_nodes, m, seed)\n        G.add_edges_from(zip([source] * m, targets))\n        repeated_nodes.extend(targets)\n        repeated_nodes.extend([source] * m)\n        source += 1\n    return G"
        ]
    },
    {
        "func_name": "dual_barabasi_albert_graph",
        "original": "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef dual_barabasi_albert_graph(n, m1, m2, p, seed=None, initial_graph=None):\n    \"\"\"Returns a random graph using dual Barab\u00e1si\u2013Albert preferential attachment\n\n    A graph of $n$ nodes is grown by attaching new nodes each with either $m_1$\n    edges (with probability $p$) or $m_2$ edges (with probability $1-p$) that\n    are preferentially attached to existing nodes with high degree.\n\n    Parameters\n    ----------\n    n : int\n        Number of nodes\n    m1 : int\n        Number of edges to link each new node to existing nodes with probability $p$\n    m2 : int\n        Number of edges to link each new node to existing nodes with probability $1-p$\n    p : float\n        The probability of attaching $m_1$ edges (as opposed to $m_2$ edges)\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n    initial_graph : Graph or None (default)\n        Initial network for Barab\u00e1si\u2013Albert algorithm.\n        A copy of `initial_graph` is used.\n        It should be connected for most use cases.\n        If None, starts from an star graph on max(m1, m2) + 1 nodes.\n\n    Returns\n    -------\n    G : Graph\n\n    Raises\n    ------\n    NetworkXError\n        If `m1` and `m2` do not satisfy ``1 <= m1,m2 < n``, or\n        `p` does not satisfy ``0 <= p <= 1``, or\n        the initial graph number of nodes m0 does not satisfy m1, m2 <= m0 <= n.\n\n    References\n    ----------\n    .. [1] N. Moshiri \"The dual-Barabasi-Albert model\", arXiv:1810.10538.\n    \"\"\"\n    if m1 < 1 or m1 >= n:\n        raise nx.NetworkXError(f'Dual Barab\u00e1si\u2013Albert must have m1 >= 1 and m1 < n, m1 = {m1}, n = {n}')\n    if m2 < 1 or m2 >= n:\n        raise nx.NetworkXError(f'Dual Barab\u00e1si\u2013Albert must have m2 >= 1 and m2 < n, m2 = {m2}, n = {n}')\n    if p < 0 or p > 1:\n        raise nx.NetworkXError(f'Dual Barab\u00e1si\u2013Albert network must have 0 <= p <= 1, p = {p}')\n    if p == 1:\n        return barabasi_albert_graph(n, m1, seed)\n    elif p == 0:\n        return barabasi_albert_graph(n, m2, seed)\n    if initial_graph is None:\n        G = star_graph(max(m1, m2))\n    else:\n        if len(initial_graph) < max(m1, m2) or len(initial_graph) > n:\n            raise nx.NetworkXError(f'Barab\u00e1si\u2013Albert initial graph must have between max(m1, m2) = {max(m1, m2)} and n = {n} nodes')\n        G = initial_graph.copy()\n    targets = list(G)\n    repeated_nodes = [n for (n, d) in G.degree() for _ in range(d)]\n    source = len(G)\n    while source < n:\n        if seed.random() < p:\n            m = m1\n        else:\n            m = m2\n        targets = _random_subset(repeated_nodes, m, seed)\n        G.add_edges_from(zip([source] * m, targets))\n        repeated_nodes.extend(targets)\n        repeated_nodes.extend([source] * m)\n        source += 1\n    return G",
        "mutated": [
            "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef dual_barabasi_albert_graph(n, m1, m2, p, seed=None, initial_graph=None):\n    if False:\n        i = 10\n    'Returns a random graph using dual Barab\u00e1si\u2013Albert preferential attachment\\n\\n    A graph of $n$ nodes is grown by attaching new nodes each with either $m_1$\\n    edges (with probability $p$) or $m_2$ edges (with probability $1-p$) that\\n    are preferentially attached to existing nodes with high degree.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        Number of nodes\\n    m1 : int\\n        Number of edges to link each new node to existing nodes with probability $p$\\n    m2 : int\\n        Number of edges to link each new node to existing nodes with probability $1-p$\\n    p : float\\n        The probability of attaching $m_1$ edges (as opposed to $m_2$ edges)\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    initial_graph : Graph or None (default)\\n        Initial network for Barab\u00e1si\u2013Albert algorithm.\\n        A copy of `initial_graph` is used.\\n        It should be connected for most use cases.\\n        If None, starts from an star graph on max(m1, m2) + 1 nodes.\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `m1` and `m2` do not satisfy ``1 <= m1,m2 < n``, or\\n        `p` does not satisfy ``0 <= p <= 1``, or\\n        the initial graph number of nodes m0 does not satisfy m1, m2 <= m0 <= n.\\n\\n    References\\n    ----------\\n    .. [1] N. Moshiri \"The dual-Barabasi-Albert model\", arXiv:1810.10538.\\n    '\n    if m1 < 1 or m1 >= n:\n        raise nx.NetworkXError(f'Dual Barab\u00e1si\u2013Albert must have m1 >= 1 and m1 < n, m1 = {m1}, n = {n}')\n    if m2 < 1 or m2 >= n:\n        raise nx.NetworkXError(f'Dual Barab\u00e1si\u2013Albert must have m2 >= 1 and m2 < n, m2 = {m2}, n = {n}')\n    if p < 0 or p > 1:\n        raise nx.NetworkXError(f'Dual Barab\u00e1si\u2013Albert network must have 0 <= p <= 1, p = {p}')\n    if p == 1:\n        return barabasi_albert_graph(n, m1, seed)\n    elif p == 0:\n        return barabasi_albert_graph(n, m2, seed)\n    if initial_graph is None:\n        G = star_graph(max(m1, m2))\n    else:\n        if len(initial_graph) < max(m1, m2) or len(initial_graph) > n:\n            raise nx.NetworkXError(f'Barab\u00e1si\u2013Albert initial graph must have between max(m1, m2) = {max(m1, m2)} and n = {n} nodes')\n        G = initial_graph.copy()\n    targets = list(G)\n    repeated_nodes = [n for (n, d) in G.degree() for _ in range(d)]\n    source = len(G)\n    while source < n:\n        if seed.random() < p:\n            m = m1\n        else:\n            m = m2\n        targets = _random_subset(repeated_nodes, m, seed)\n        G.add_edges_from(zip([source] * m, targets))\n        repeated_nodes.extend(targets)\n        repeated_nodes.extend([source] * m)\n        source += 1\n    return G",
            "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef dual_barabasi_albert_graph(n, m1, m2, p, seed=None, initial_graph=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a random graph using dual Barab\u00e1si\u2013Albert preferential attachment\\n\\n    A graph of $n$ nodes is grown by attaching new nodes each with either $m_1$\\n    edges (with probability $p$) or $m_2$ edges (with probability $1-p$) that\\n    are preferentially attached to existing nodes with high degree.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        Number of nodes\\n    m1 : int\\n        Number of edges to link each new node to existing nodes with probability $p$\\n    m2 : int\\n        Number of edges to link each new node to existing nodes with probability $1-p$\\n    p : float\\n        The probability of attaching $m_1$ edges (as opposed to $m_2$ edges)\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    initial_graph : Graph or None (default)\\n        Initial network for Barab\u00e1si\u2013Albert algorithm.\\n        A copy of `initial_graph` is used.\\n        It should be connected for most use cases.\\n        If None, starts from an star graph on max(m1, m2) + 1 nodes.\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `m1` and `m2` do not satisfy ``1 <= m1,m2 < n``, or\\n        `p` does not satisfy ``0 <= p <= 1``, or\\n        the initial graph number of nodes m0 does not satisfy m1, m2 <= m0 <= n.\\n\\n    References\\n    ----------\\n    .. [1] N. Moshiri \"The dual-Barabasi-Albert model\", arXiv:1810.10538.\\n    '\n    if m1 < 1 or m1 >= n:\n        raise nx.NetworkXError(f'Dual Barab\u00e1si\u2013Albert must have m1 >= 1 and m1 < n, m1 = {m1}, n = {n}')\n    if m2 < 1 or m2 >= n:\n        raise nx.NetworkXError(f'Dual Barab\u00e1si\u2013Albert must have m2 >= 1 and m2 < n, m2 = {m2}, n = {n}')\n    if p < 0 or p > 1:\n        raise nx.NetworkXError(f'Dual Barab\u00e1si\u2013Albert network must have 0 <= p <= 1, p = {p}')\n    if p == 1:\n        return barabasi_albert_graph(n, m1, seed)\n    elif p == 0:\n        return barabasi_albert_graph(n, m2, seed)\n    if initial_graph is None:\n        G = star_graph(max(m1, m2))\n    else:\n        if len(initial_graph) < max(m1, m2) or len(initial_graph) > n:\n            raise nx.NetworkXError(f'Barab\u00e1si\u2013Albert initial graph must have between max(m1, m2) = {max(m1, m2)} and n = {n} nodes')\n        G = initial_graph.copy()\n    targets = list(G)\n    repeated_nodes = [n for (n, d) in G.degree() for _ in range(d)]\n    source = len(G)\n    while source < n:\n        if seed.random() < p:\n            m = m1\n        else:\n            m = m2\n        targets = _random_subset(repeated_nodes, m, seed)\n        G.add_edges_from(zip([source] * m, targets))\n        repeated_nodes.extend(targets)\n        repeated_nodes.extend([source] * m)\n        source += 1\n    return G",
            "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef dual_barabasi_albert_graph(n, m1, m2, p, seed=None, initial_graph=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a random graph using dual Barab\u00e1si\u2013Albert preferential attachment\\n\\n    A graph of $n$ nodes is grown by attaching new nodes each with either $m_1$\\n    edges (with probability $p$) or $m_2$ edges (with probability $1-p$) that\\n    are preferentially attached to existing nodes with high degree.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        Number of nodes\\n    m1 : int\\n        Number of edges to link each new node to existing nodes with probability $p$\\n    m2 : int\\n        Number of edges to link each new node to existing nodes with probability $1-p$\\n    p : float\\n        The probability of attaching $m_1$ edges (as opposed to $m_2$ edges)\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    initial_graph : Graph or None (default)\\n        Initial network for Barab\u00e1si\u2013Albert algorithm.\\n        A copy of `initial_graph` is used.\\n        It should be connected for most use cases.\\n        If None, starts from an star graph on max(m1, m2) + 1 nodes.\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `m1` and `m2` do not satisfy ``1 <= m1,m2 < n``, or\\n        `p` does not satisfy ``0 <= p <= 1``, or\\n        the initial graph number of nodes m0 does not satisfy m1, m2 <= m0 <= n.\\n\\n    References\\n    ----------\\n    .. [1] N. Moshiri \"The dual-Barabasi-Albert model\", arXiv:1810.10538.\\n    '\n    if m1 < 1 or m1 >= n:\n        raise nx.NetworkXError(f'Dual Barab\u00e1si\u2013Albert must have m1 >= 1 and m1 < n, m1 = {m1}, n = {n}')\n    if m2 < 1 or m2 >= n:\n        raise nx.NetworkXError(f'Dual Barab\u00e1si\u2013Albert must have m2 >= 1 and m2 < n, m2 = {m2}, n = {n}')\n    if p < 0 or p > 1:\n        raise nx.NetworkXError(f'Dual Barab\u00e1si\u2013Albert network must have 0 <= p <= 1, p = {p}')\n    if p == 1:\n        return barabasi_albert_graph(n, m1, seed)\n    elif p == 0:\n        return barabasi_albert_graph(n, m2, seed)\n    if initial_graph is None:\n        G = star_graph(max(m1, m2))\n    else:\n        if len(initial_graph) < max(m1, m2) or len(initial_graph) > n:\n            raise nx.NetworkXError(f'Barab\u00e1si\u2013Albert initial graph must have between max(m1, m2) = {max(m1, m2)} and n = {n} nodes')\n        G = initial_graph.copy()\n    targets = list(G)\n    repeated_nodes = [n for (n, d) in G.degree() for _ in range(d)]\n    source = len(G)\n    while source < n:\n        if seed.random() < p:\n            m = m1\n        else:\n            m = m2\n        targets = _random_subset(repeated_nodes, m, seed)\n        G.add_edges_from(zip([source] * m, targets))\n        repeated_nodes.extend(targets)\n        repeated_nodes.extend([source] * m)\n        source += 1\n    return G",
            "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef dual_barabasi_albert_graph(n, m1, m2, p, seed=None, initial_graph=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a random graph using dual Barab\u00e1si\u2013Albert preferential attachment\\n\\n    A graph of $n$ nodes is grown by attaching new nodes each with either $m_1$\\n    edges (with probability $p$) or $m_2$ edges (with probability $1-p$) that\\n    are preferentially attached to existing nodes with high degree.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        Number of nodes\\n    m1 : int\\n        Number of edges to link each new node to existing nodes with probability $p$\\n    m2 : int\\n        Number of edges to link each new node to existing nodes with probability $1-p$\\n    p : float\\n        The probability of attaching $m_1$ edges (as opposed to $m_2$ edges)\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    initial_graph : Graph or None (default)\\n        Initial network for Barab\u00e1si\u2013Albert algorithm.\\n        A copy of `initial_graph` is used.\\n        It should be connected for most use cases.\\n        If None, starts from an star graph on max(m1, m2) + 1 nodes.\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `m1` and `m2` do not satisfy ``1 <= m1,m2 < n``, or\\n        `p` does not satisfy ``0 <= p <= 1``, or\\n        the initial graph number of nodes m0 does not satisfy m1, m2 <= m0 <= n.\\n\\n    References\\n    ----------\\n    .. [1] N. Moshiri \"The dual-Barabasi-Albert model\", arXiv:1810.10538.\\n    '\n    if m1 < 1 or m1 >= n:\n        raise nx.NetworkXError(f'Dual Barab\u00e1si\u2013Albert must have m1 >= 1 and m1 < n, m1 = {m1}, n = {n}')\n    if m2 < 1 or m2 >= n:\n        raise nx.NetworkXError(f'Dual Barab\u00e1si\u2013Albert must have m2 >= 1 and m2 < n, m2 = {m2}, n = {n}')\n    if p < 0 or p > 1:\n        raise nx.NetworkXError(f'Dual Barab\u00e1si\u2013Albert network must have 0 <= p <= 1, p = {p}')\n    if p == 1:\n        return barabasi_albert_graph(n, m1, seed)\n    elif p == 0:\n        return barabasi_albert_graph(n, m2, seed)\n    if initial_graph is None:\n        G = star_graph(max(m1, m2))\n    else:\n        if len(initial_graph) < max(m1, m2) or len(initial_graph) > n:\n            raise nx.NetworkXError(f'Barab\u00e1si\u2013Albert initial graph must have between max(m1, m2) = {max(m1, m2)} and n = {n} nodes')\n        G = initial_graph.copy()\n    targets = list(G)\n    repeated_nodes = [n for (n, d) in G.degree() for _ in range(d)]\n    source = len(G)\n    while source < n:\n        if seed.random() < p:\n            m = m1\n        else:\n            m = m2\n        targets = _random_subset(repeated_nodes, m, seed)\n        G.add_edges_from(zip([source] * m, targets))\n        repeated_nodes.extend(targets)\n        repeated_nodes.extend([source] * m)\n        source += 1\n    return G",
            "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef dual_barabasi_albert_graph(n, m1, m2, p, seed=None, initial_graph=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a random graph using dual Barab\u00e1si\u2013Albert preferential attachment\\n\\n    A graph of $n$ nodes is grown by attaching new nodes each with either $m_1$\\n    edges (with probability $p$) or $m_2$ edges (with probability $1-p$) that\\n    are preferentially attached to existing nodes with high degree.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        Number of nodes\\n    m1 : int\\n        Number of edges to link each new node to existing nodes with probability $p$\\n    m2 : int\\n        Number of edges to link each new node to existing nodes with probability $1-p$\\n    p : float\\n        The probability of attaching $m_1$ edges (as opposed to $m_2$ edges)\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    initial_graph : Graph or None (default)\\n        Initial network for Barab\u00e1si\u2013Albert algorithm.\\n        A copy of `initial_graph` is used.\\n        It should be connected for most use cases.\\n        If None, starts from an star graph on max(m1, m2) + 1 nodes.\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `m1` and `m2` do not satisfy ``1 <= m1,m2 < n``, or\\n        `p` does not satisfy ``0 <= p <= 1``, or\\n        the initial graph number of nodes m0 does not satisfy m1, m2 <= m0 <= n.\\n\\n    References\\n    ----------\\n    .. [1] N. Moshiri \"The dual-Barabasi-Albert model\", arXiv:1810.10538.\\n    '\n    if m1 < 1 or m1 >= n:\n        raise nx.NetworkXError(f'Dual Barab\u00e1si\u2013Albert must have m1 >= 1 and m1 < n, m1 = {m1}, n = {n}')\n    if m2 < 1 or m2 >= n:\n        raise nx.NetworkXError(f'Dual Barab\u00e1si\u2013Albert must have m2 >= 1 and m2 < n, m2 = {m2}, n = {n}')\n    if p < 0 or p > 1:\n        raise nx.NetworkXError(f'Dual Barab\u00e1si\u2013Albert network must have 0 <= p <= 1, p = {p}')\n    if p == 1:\n        return barabasi_albert_graph(n, m1, seed)\n    elif p == 0:\n        return barabasi_albert_graph(n, m2, seed)\n    if initial_graph is None:\n        G = star_graph(max(m1, m2))\n    else:\n        if len(initial_graph) < max(m1, m2) or len(initial_graph) > n:\n            raise nx.NetworkXError(f'Barab\u00e1si\u2013Albert initial graph must have between max(m1, m2) = {max(m1, m2)} and n = {n} nodes')\n        G = initial_graph.copy()\n    targets = list(G)\n    repeated_nodes = [n for (n, d) in G.degree() for _ in range(d)]\n    source = len(G)\n    while source < n:\n        if seed.random() < p:\n            m = m1\n        else:\n            m = m2\n        targets = _random_subset(repeated_nodes, m, seed)\n        G.add_edges_from(zip([source] * m, targets))\n        repeated_nodes.extend(targets)\n        repeated_nodes.extend([source] * m)\n        source += 1\n    return G"
        ]
    },
    {
        "func_name": "extended_barabasi_albert_graph",
        "original": "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef extended_barabasi_albert_graph(n, m, p, q, seed=None):\n    \"\"\"Returns an extended Barab\u00e1si\u2013Albert model graph.\n\n    An extended Barab\u00e1si\u2013Albert model graph is a random graph constructed\n    using preferential attachment. The extended model allows new edges,\n    rewired edges or new nodes. Based on the probabilities $p$ and $q$\n    with $p + q < 1$, the growing behavior of the graph is determined as:\n\n    1) With $p$ probability, $m$ new edges are added to the graph,\n    starting from randomly chosen existing nodes and attached preferentially at the other end.\n\n    2) With $q$ probability, $m$ existing edges are rewired\n    by randomly choosing an edge and rewiring one end to a preferentially chosen node.\n\n    3) With $(1 - p - q)$ probability, $m$ new nodes are added to the graph\n    with edges attached preferentially.\n\n    When $p = q = 0$, the model behaves just like the Barab\u00e1si\u2013Alber model.\n\n    Parameters\n    ----------\n    n : int\n        Number of nodes\n    m : int\n        Number of edges with which a new node attaches to existing nodes\n    p : float\n        Probability value for adding an edge between existing nodes. p + q < 1\n    q : float\n        Probability value of rewiring of existing edges. p + q < 1\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Returns\n    -------\n    G : Graph\n\n    Raises\n    ------\n    NetworkXError\n        If `m` does not satisfy ``1 <= m < n`` or ``1 >= p + q``\n\n    References\n    ----------\n    .. [1] Albert, R., & Barab\u00e1si, A. L. (2000)\n       Topology of evolving networks: local events and universality\n       Physical review letters, 85(24), 5234.\n    \"\"\"\n    if m < 1 or m >= n:\n        msg = f'Extended Barabasi-Albert network needs m>=1 and m<n, m={m}, n={n}'\n        raise nx.NetworkXError(msg)\n    if p + q >= 1:\n        msg = f'Extended Barabasi-Albert network needs p + q <= 1, p={p}, q={q}'\n        raise nx.NetworkXError(msg)\n    G = empty_graph(m)\n    attachment_preference = []\n    attachment_preference.extend(range(m))\n    new_node = m\n    while new_node < n:\n        a_probability = seed.random()\n        clique_degree = len(G) - 1\n        clique_size = len(G) * clique_degree / 2\n        if a_probability < p and G.size() <= clique_size - m:\n            eligible_nodes = [nd for (nd, deg) in G.degree() if deg < clique_degree]\n            for i in range(m):\n                src_node = seed.choice(eligible_nodes)\n                prohibited_nodes = list(G[src_node])\n                prohibited_nodes.append(src_node)\n                dest_node = seed.choice([nd for nd in attachment_preference if nd not in prohibited_nodes])\n                G.add_edge(src_node, dest_node)\n                attachment_preference.append(src_node)\n                attachment_preference.append(dest_node)\n                if G.degree(src_node) == clique_degree:\n                    eligible_nodes.remove(src_node)\n                if G.degree(dest_node) == clique_degree and dest_node in eligible_nodes:\n                    eligible_nodes.remove(dest_node)\n        elif p <= a_probability < p + q and m <= G.size() < clique_size:\n            eligible_nodes = [nd for (nd, deg) in G.degree() if 0 < deg < clique_degree]\n            for i in range(m):\n                node = seed.choice(eligible_nodes)\n                neighbor_nodes = list(G[node])\n                src_node = seed.choice(neighbor_nodes)\n                neighbor_nodes.append(node)\n                dest_node = seed.choice([nd for nd in attachment_preference if nd not in neighbor_nodes])\n                G.remove_edge(node, src_node)\n                G.add_edge(node, dest_node)\n                attachment_preference.remove(src_node)\n                attachment_preference.append(dest_node)\n                if G.degree(src_node) == 0 and src_node in eligible_nodes:\n                    eligible_nodes.remove(src_node)\n                if dest_node in eligible_nodes:\n                    if G.degree(dest_node) == clique_degree:\n                        eligible_nodes.remove(dest_node)\n                elif G.degree(dest_node) == 1:\n                    eligible_nodes.append(dest_node)\n        else:\n            targets = _random_subset(attachment_preference, m, seed)\n            G.add_edges_from(zip([new_node] * m, targets))\n            attachment_preference.extend(targets)\n            attachment_preference.extend([new_node] * (m + 1))\n            new_node += 1\n    return G",
        "mutated": [
            "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef extended_barabasi_albert_graph(n, m, p, q, seed=None):\n    if False:\n        i = 10\n    'Returns an extended Barab\u00e1si\u2013Albert model graph.\\n\\n    An extended Barab\u00e1si\u2013Albert model graph is a random graph constructed\\n    using preferential attachment. The extended model allows new edges,\\n    rewired edges or new nodes. Based on the probabilities $p$ and $q$\\n    with $p + q < 1$, the growing behavior of the graph is determined as:\\n\\n    1) With $p$ probability, $m$ new edges are added to the graph,\\n    starting from randomly chosen existing nodes and attached preferentially at the other end.\\n\\n    2) With $q$ probability, $m$ existing edges are rewired\\n    by randomly choosing an edge and rewiring one end to a preferentially chosen node.\\n\\n    3) With $(1 - p - q)$ probability, $m$ new nodes are added to the graph\\n    with edges attached preferentially.\\n\\n    When $p = q = 0$, the model behaves just like the Barab\u00e1si\u2013Alber model.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        Number of nodes\\n    m : int\\n        Number of edges with which a new node attaches to existing nodes\\n    p : float\\n        Probability value for adding an edge between existing nodes. p + q < 1\\n    q : float\\n        Probability value of rewiring of existing edges. p + q < 1\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `m` does not satisfy ``1 <= m < n`` or ``1 >= p + q``\\n\\n    References\\n    ----------\\n    .. [1] Albert, R., & Barab\u00e1si, A. L. (2000)\\n       Topology of evolving networks: local events and universality\\n       Physical review letters, 85(24), 5234.\\n    '\n    if m < 1 or m >= n:\n        msg = f'Extended Barabasi-Albert network needs m>=1 and m<n, m={m}, n={n}'\n        raise nx.NetworkXError(msg)\n    if p + q >= 1:\n        msg = f'Extended Barabasi-Albert network needs p + q <= 1, p={p}, q={q}'\n        raise nx.NetworkXError(msg)\n    G = empty_graph(m)\n    attachment_preference = []\n    attachment_preference.extend(range(m))\n    new_node = m\n    while new_node < n:\n        a_probability = seed.random()\n        clique_degree = len(G) - 1\n        clique_size = len(G) * clique_degree / 2\n        if a_probability < p and G.size() <= clique_size - m:\n            eligible_nodes = [nd for (nd, deg) in G.degree() if deg < clique_degree]\n            for i in range(m):\n                src_node = seed.choice(eligible_nodes)\n                prohibited_nodes = list(G[src_node])\n                prohibited_nodes.append(src_node)\n                dest_node = seed.choice([nd for nd in attachment_preference if nd not in prohibited_nodes])\n                G.add_edge(src_node, dest_node)\n                attachment_preference.append(src_node)\n                attachment_preference.append(dest_node)\n                if G.degree(src_node) == clique_degree:\n                    eligible_nodes.remove(src_node)\n                if G.degree(dest_node) == clique_degree and dest_node in eligible_nodes:\n                    eligible_nodes.remove(dest_node)\n        elif p <= a_probability < p + q and m <= G.size() < clique_size:\n            eligible_nodes = [nd for (nd, deg) in G.degree() if 0 < deg < clique_degree]\n            for i in range(m):\n                node = seed.choice(eligible_nodes)\n                neighbor_nodes = list(G[node])\n                src_node = seed.choice(neighbor_nodes)\n                neighbor_nodes.append(node)\n                dest_node = seed.choice([nd for nd in attachment_preference if nd not in neighbor_nodes])\n                G.remove_edge(node, src_node)\n                G.add_edge(node, dest_node)\n                attachment_preference.remove(src_node)\n                attachment_preference.append(dest_node)\n                if G.degree(src_node) == 0 and src_node in eligible_nodes:\n                    eligible_nodes.remove(src_node)\n                if dest_node in eligible_nodes:\n                    if G.degree(dest_node) == clique_degree:\n                        eligible_nodes.remove(dest_node)\n                elif G.degree(dest_node) == 1:\n                    eligible_nodes.append(dest_node)\n        else:\n            targets = _random_subset(attachment_preference, m, seed)\n            G.add_edges_from(zip([new_node] * m, targets))\n            attachment_preference.extend(targets)\n            attachment_preference.extend([new_node] * (m + 1))\n            new_node += 1\n    return G",
            "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef extended_barabasi_albert_graph(n, m, p, q, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns an extended Barab\u00e1si\u2013Albert model graph.\\n\\n    An extended Barab\u00e1si\u2013Albert model graph is a random graph constructed\\n    using preferential attachment. The extended model allows new edges,\\n    rewired edges or new nodes. Based on the probabilities $p$ and $q$\\n    with $p + q < 1$, the growing behavior of the graph is determined as:\\n\\n    1) With $p$ probability, $m$ new edges are added to the graph,\\n    starting from randomly chosen existing nodes and attached preferentially at the other end.\\n\\n    2) With $q$ probability, $m$ existing edges are rewired\\n    by randomly choosing an edge and rewiring one end to a preferentially chosen node.\\n\\n    3) With $(1 - p - q)$ probability, $m$ new nodes are added to the graph\\n    with edges attached preferentially.\\n\\n    When $p = q = 0$, the model behaves just like the Barab\u00e1si\u2013Alber model.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        Number of nodes\\n    m : int\\n        Number of edges with which a new node attaches to existing nodes\\n    p : float\\n        Probability value for adding an edge between existing nodes. p + q < 1\\n    q : float\\n        Probability value of rewiring of existing edges. p + q < 1\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `m` does not satisfy ``1 <= m < n`` or ``1 >= p + q``\\n\\n    References\\n    ----------\\n    .. [1] Albert, R., & Barab\u00e1si, A. L. (2000)\\n       Topology of evolving networks: local events and universality\\n       Physical review letters, 85(24), 5234.\\n    '\n    if m < 1 or m >= n:\n        msg = f'Extended Barabasi-Albert network needs m>=1 and m<n, m={m}, n={n}'\n        raise nx.NetworkXError(msg)\n    if p + q >= 1:\n        msg = f'Extended Barabasi-Albert network needs p + q <= 1, p={p}, q={q}'\n        raise nx.NetworkXError(msg)\n    G = empty_graph(m)\n    attachment_preference = []\n    attachment_preference.extend(range(m))\n    new_node = m\n    while new_node < n:\n        a_probability = seed.random()\n        clique_degree = len(G) - 1\n        clique_size = len(G) * clique_degree / 2\n        if a_probability < p and G.size() <= clique_size - m:\n            eligible_nodes = [nd for (nd, deg) in G.degree() if deg < clique_degree]\n            for i in range(m):\n                src_node = seed.choice(eligible_nodes)\n                prohibited_nodes = list(G[src_node])\n                prohibited_nodes.append(src_node)\n                dest_node = seed.choice([nd for nd in attachment_preference if nd not in prohibited_nodes])\n                G.add_edge(src_node, dest_node)\n                attachment_preference.append(src_node)\n                attachment_preference.append(dest_node)\n                if G.degree(src_node) == clique_degree:\n                    eligible_nodes.remove(src_node)\n                if G.degree(dest_node) == clique_degree and dest_node in eligible_nodes:\n                    eligible_nodes.remove(dest_node)\n        elif p <= a_probability < p + q and m <= G.size() < clique_size:\n            eligible_nodes = [nd for (nd, deg) in G.degree() if 0 < deg < clique_degree]\n            for i in range(m):\n                node = seed.choice(eligible_nodes)\n                neighbor_nodes = list(G[node])\n                src_node = seed.choice(neighbor_nodes)\n                neighbor_nodes.append(node)\n                dest_node = seed.choice([nd for nd in attachment_preference if nd not in neighbor_nodes])\n                G.remove_edge(node, src_node)\n                G.add_edge(node, dest_node)\n                attachment_preference.remove(src_node)\n                attachment_preference.append(dest_node)\n                if G.degree(src_node) == 0 and src_node in eligible_nodes:\n                    eligible_nodes.remove(src_node)\n                if dest_node in eligible_nodes:\n                    if G.degree(dest_node) == clique_degree:\n                        eligible_nodes.remove(dest_node)\n                elif G.degree(dest_node) == 1:\n                    eligible_nodes.append(dest_node)\n        else:\n            targets = _random_subset(attachment_preference, m, seed)\n            G.add_edges_from(zip([new_node] * m, targets))\n            attachment_preference.extend(targets)\n            attachment_preference.extend([new_node] * (m + 1))\n            new_node += 1\n    return G",
            "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef extended_barabasi_albert_graph(n, m, p, q, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns an extended Barab\u00e1si\u2013Albert model graph.\\n\\n    An extended Barab\u00e1si\u2013Albert model graph is a random graph constructed\\n    using preferential attachment. The extended model allows new edges,\\n    rewired edges or new nodes. Based on the probabilities $p$ and $q$\\n    with $p + q < 1$, the growing behavior of the graph is determined as:\\n\\n    1) With $p$ probability, $m$ new edges are added to the graph,\\n    starting from randomly chosen existing nodes and attached preferentially at the other end.\\n\\n    2) With $q$ probability, $m$ existing edges are rewired\\n    by randomly choosing an edge and rewiring one end to a preferentially chosen node.\\n\\n    3) With $(1 - p - q)$ probability, $m$ new nodes are added to the graph\\n    with edges attached preferentially.\\n\\n    When $p = q = 0$, the model behaves just like the Barab\u00e1si\u2013Alber model.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        Number of nodes\\n    m : int\\n        Number of edges with which a new node attaches to existing nodes\\n    p : float\\n        Probability value for adding an edge between existing nodes. p + q < 1\\n    q : float\\n        Probability value of rewiring of existing edges. p + q < 1\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `m` does not satisfy ``1 <= m < n`` or ``1 >= p + q``\\n\\n    References\\n    ----------\\n    .. [1] Albert, R., & Barab\u00e1si, A. L. (2000)\\n       Topology of evolving networks: local events and universality\\n       Physical review letters, 85(24), 5234.\\n    '\n    if m < 1 or m >= n:\n        msg = f'Extended Barabasi-Albert network needs m>=1 and m<n, m={m}, n={n}'\n        raise nx.NetworkXError(msg)\n    if p + q >= 1:\n        msg = f'Extended Barabasi-Albert network needs p + q <= 1, p={p}, q={q}'\n        raise nx.NetworkXError(msg)\n    G = empty_graph(m)\n    attachment_preference = []\n    attachment_preference.extend(range(m))\n    new_node = m\n    while new_node < n:\n        a_probability = seed.random()\n        clique_degree = len(G) - 1\n        clique_size = len(G) * clique_degree / 2\n        if a_probability < p and G.size() <= clique_size - m:\n            eligible_nodes = [nd for (nd, deg) in G.degree() if deg < clique_degree]\n            for i in range(m):\n                src_node = seed.choice(eligible_nodes)\n                prohibited_nodes = list(G[src_node])\n                prohibited_nodes.append(src_node)\n                dest_node = seed.choice([nd for nd in attachment_preference if nd not in prohibited_nodes])\n                G.add_edge(src_node, dest_node)\n                attachment_preference.append(src_node)\n                attachment_preference.append(dest_node)\n                if G.degree(src_node) == clique_degree:\n                    eligible_nodes.remove(src_node)\n                if G.degree(dest_node) == clique_degree and dest_node in eligible_nodes:\n                    eligible_nodes.remove(dest_node)\n        elif p <= a_probability < p + q and m <= G.size() < clique_size:\n            eligible_nodes = [nd for (nd, deg) in G.degree() if 0 < deg < clique_degree]\n            for i in range(m):\n                node = seed.choice(eligible_nodes)\n                neighbor_nodes = list(G[node])\n                src_node = seed.choice(neighbor_nodes)\n                neighbor_nodes.append(node)\n                dest_node = seed.choice([nd for nd in attachment_preference if nd not in neighbor_nodes])\n                G.remove_edge(node, src_node)\n                G.add_edge(node, dest_node)\n                attachment_preference.remove(src_node)\n                attachment_preference.append(dest_node)\n                if G.degree(src_node) == 0 and src_node in eligible_nodes:\n                    eligible_nodes.remove(src_node)\n                if dest_node in eligible_nodes:\n                    if G.degree(dest_node) == clique_degree:\n                        eligible_nodes.remove(dest_node)\n                elif G.degree(dest_node) == 1:\n                    eligible_nodes.append(dest_node)\n        else:\n            targets = _random_subset(attachment_preference, m, seed)\n            G.add_edges_from(zip([new_node] * m, targets))\n            attachment_preference.extend(targets)\n            attachment_preference.extend([new_node] * (m + 1))\n            new_node += 1\n    return G",
            "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef extended_barabasi_albert_graph(n, m, p, q, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns an extended Barab\u00e1si\u2013Albert model graph.\\n\\n    An extended Barab\u00e1si\u2013Albert model graph is a random graph constructed\\n    using preferential attachment. The extended model allows new edges,\\n    rewired edges or new nodes. Based on the probabilities $p$ and $q$\\n    with $p + q < 1$, the growing behavior of the graph is determined as:\\n\\n    1) With $p$ probability, $m$ new edges are added to the graph,\\n    starting from randomly chosen existing nodes and attached preferentially at the other end.\\n\\n    2) With $q$ probability, $m$ existing edges are rewired\\n    by randomly choosing an edge and rewiring one end to a preferentially chosen node.\\n\\n    3) With $(1 - p - q)$ probability, $m$ new nodes are added to the graph\\n    with edges attached preferentially.\\n\\n    When $p = q = 0$, the model behaves just like the Barab\u00e1si\u2013Alber model.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        Number of nodes\\n    m : int\\n        Number of edges with which a new node attaches to existing nodes\\n    p : float\\n        Probability value for adding an edge between existing nodes. p + q < 1\\n    q : float\\n        Probability value of rewiring of existing edges. p + q < 1\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `m` does not satisfy ``1 <= m < n`` or ``1 >= p + q``\\n\\n    References\\n    ----------\\n    .. [1] Albert, R., & Barab\u00e1si, A. L. (2000)\\n       Topology of evolving networks: local events and universality\\n       Physical review letters, 85(24), 5234.\\n    '\n    if m < 1 or m >= n:\n        msg = f'Extended Barabasi-Albert network needs m>=1 and m<n, m={m}, n={n}'\n        raise nx.NetworkXError(msg)\n    if p + q >= 1:\n        msg = f'Extended Barabasi-Albert network needs p + q <= 1, p={p}, q={q}'\n        raise nx.NetworkXError(msg)\n    G = empty_graph(m)\n    attachment_preference = []\n    attachment_preference.extend(range(m))\n    new_node = m\n    while new_node < n:\n        a_probability = seed.random()\n        clique_degree = len(G) - 1\n        clique_size = len(G) * clique_degree / 2\n        if a_probability < p and G.size() <= clique_size - m:\n            eligible_nodes = [nd for (nd, deg) in G.degree() if deg < clique_degree]\n            for i in range(m):\n                src_node = seed.choice(eligible_nodes)\n                prohibited_nodes = list(G[src_node])\n                prohibited_nodes.append(src_node)\n                dest_node = seed.choice([nd for nd in attachment_preference if nd not in prohibited_nodes])\n                G.add_edge(src_node, dest_node)\n                attachment_preference.append(src_node)\n                attachment_preference.append(dest_node)\n                if G.degree(src_node) == clique_degree:\n                    eligible_nodes.remove(src_node)\n                if G.degree(dest_node) == clique_degree and dest_node in eligible_nodes:\n                    eligible_nodes.remove(dest_node)\n        elif p <= a_probability < p + q and m <= G.size() < clique_size:\n            eligible_nodes = [nd for (nd, deg) in G.degree() if 0 < deg < clique_degree]\n            for i in range(m):\n                node = seed.choice(eligible_nodes)\n                neighbor_nodes = list(G[node])\n                src_node = seed.choice(neighbor_nodes)\n                neighbor_nodes.append(node)\n                dest_node = seed.choice([nd for nd in attachment_preference if nd not in neighbor_nodes])\n                G.remove_edge(node, src_node)\n                G.add_edge(node, dest_node)\n                attachment_preference.remove(src_node)\n                attachment_preference.append(dest_node)\n                if G.degree(src_node) == 0 and src_node in eligible_nodes:\n                    eligible_nodes.remove(src_node)\n                if dest_node in eligible_nodes:\n                    if G.degree(dest_node) == clique_degree:\n                        eligible_nodes.remove(dest_node)\n                elif G.degree(dest_node) == 1:\n                    eligible_nodes.append(dest_node)\n        else:\n            targets = _random_subset(attachment_preference, m, seed)\n            G.add_edges_from(zip([new_node] * m, targets))\n            attachment_preference.extend(targets)\n            attachment_preference.extend([new_node] * (m + 1))\n            new_node += 1\n    return G",
            "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef extended_barabasi_albert_graph(n, m, p, q, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns an extended Barab\u00e1si\u2013Albert model graph.\\n\\n    An extended Barab\u00e1si\u2013Albert model graph is a random graph constructed\\n    using preferential attachment. The extended model allows new edges,\\n    rewired edges or new nodes. Based on the probabilities $p$ and $q$\\n    with $p + q < 1$, the growing behavior of the graph is determined as:\\n\\n    1) With $p$ probability, $m$ new edges are added to the graph,\\n    starting from randomly chosen existing nodes and attached preferentially at the other end.\\n\\n    2) With $q$ probability, $m$ existing edges are rewired\\n    by randomly choosing an edge and rewiring one end to a preferentially chosen node.\\n\\n    3) With $(1 - p - q)$ probability, $m$ new nodes are added to the graph\\n    with edges attached preferentially.\\n\\n    When $p = q = 0$, the model behaves just like the Barab\u00e1si\u2013Alber model.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        Number of nodes\\n    m : int\\n        Number of edges with which a new node attaches to existing nodes\\n    p : float\\n        Probability value for adding an edge between existing nodes. p + q < 1\\n    q : float\\n        Probability value of rewiring of existing edges. p + q < 1\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `m` does not satisfy ``1 <= m < n`` or ``1 >= p + q``\\n\\n    References\\n    ----------\\n    .. [1] Albert, R., & Barab\u00e1si, A. L. (2000)\\n       Topology of evolving networks: local events and universality\\n       Physical review letters, 85(24), 5234.\\n    '\n    if m < 1 or m >= n:\n        msg = f'Extended Barabasi-Albert network needs m>=1 and m<n, m={m}, n={n}'\n        raise nx.NetworkXError(msg)\n    if p + q >= 1:\n        msg = f'Extended Barabasi-Albert network needs p + q <= 1, p={p}, q={q}'\n        raise nx.NetworkXError(msg)\n    G = empty_graph(m)\n    attachment_preference = []\n    attachment_preference.extend(range(m))\n    new_node = m\n    while new_node < n:\n        a_probability = seed.random()\n        clique_degree = len(G) - 1\n        clique_size = len(G) * clique_degree / 2\n        if a_probability < p and G.size() <= clique_size - m:\n            eligible_nodes = [nd for (nd, deg) in G.degree() if deg < clique_degree]\n            for i in range(m):\n                src_node = seed.choice(eligible_nodes)\n                prohibited_nodes = list(G[src_node])\n                prohibited_nodes.append(src_node)\n                dest_node = seed.choice([nd for nd in attachment_preference if nd not in prohibited_nodes])\n                G.add_edge(src_node, dest_node)\n                attachment_preference.append(src_node)\n                attachment_preference.append(dest_node)\n                if G.degree(src_node) == clique_degree:\n                    eligible_nodes.remove(src_node)\n                if G.degree(dest_node) == clique_degree and dest_node in eligible_nodes:\n                    eligible_nodes.remove(dest_node)\n        elif p <= a_probability < p + q and m <= G.size() < clique_size:\n            eligible_nodes = [nd for (nd, deg) in G.degree() if 0 < deg < clique_degree]\n            for i in range(m):\n                node = seed.choice(eligible_nodes)\n                neighbor_nodes = list(G[node])\n                src_node = seed.choice(neighbor_nodes)\n                neighbor_nodes.append(node)\n                dest_node = seed.choice([nd for nd in attachment_preference if nd not in neighbor_nodes])\n                G.remove_edge(node, src_node)\n                G.add_edge(node, dest_node)\n                attachment_preference.remove(src_node)\n                attachment_preference.append(dest_node)\n                if G.degree(src_node) == 0 and src_node in eligible_nodes:\n                    eligible_nodes.remove(src_node)\n                if dest_node in eligible_nodes:\n                    if G.degree(dest_node) == clique_degree:\n                        eligible_nodes.remove(dest_node)\n                elif G.degree(dest_node) == 1:\n                    eligible_nodes.append(dest_node)\n        else:\n            targets = _random_subset(attachment_preference, m, seed)\n            G.add_edges_from(zip([new_node] * m, targets))\n            attachment_preference.extend(targets)\n            attachment_preference.extend([new_node] * (m + 1))\n            new_node += 1\n    return G"
        ]
    },
    {
        "func_name": "powerlaw_cluster_graph",
        "original": "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef powerlaw_cluster_graph(n, m, p, seed=None):\n    \"\"\"Holme and Kim algorithm for growing graphs with powerlaw\n    degree distribution and approximate average clustering.\n\n    Parameters\n    ----------\n    n : int\n        the number of nodes\n    m : int\n        the number of random edges to add for each new node\n    p : float,\n        Probability of adding a triangle after adding a random edge\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Notes\n    -----\n    The average clustering has a hard time getting above a certain\n    cutoff that depends on `m`.  This cutoff is often quite low.  The\n    transitivity (fraction of triangles to possible triangles) seems to\n    decrease with network size.\n\n    It is essentially the Barab\u00e1si\u2013Albert (BA) growth model with an\n    extra step that each random edge is followed by a chance of\n    making an edge to one of its neighbors too (and thus a triangle).\n\n    This algorithm improves on BA in the sense that it enables a\n    higher average clustering to be attained if desired.\n\n    It seems possible to have a disconnected graph with this algorithm\n    since the initial `m` nodes may not be all linked to a new node\n    on the first iteration like the BA model.\n\n    Raises\n    ------\n    NetworkXError\n        If `m` does not satisfy ``1 <= m <= n`` or `p` does not\n        satisfy ``0 <= p <= 1``.\n\n    References\n    ----------\n    .. [1] P. Holme and B. J. Kim,\n       \"Growing scale-free networks with tunable clustering\",\n       Phys. Rev. E, 65, 026107, 2002.\n    \"\"\"\n    if m < 1 or n < m:\n        raise nx.NetworkXError(f'NetworkXError must have m>1 and m<n, m={m},n={n}')\n    if p > 1 or p < 0:\n        raise nx.NetworkXError(f'NetworkXError p must be in [0,1], p={p}')\n    G = empty_graph(m)\n    repeated_nodes = list(G.nodes())\n    source = m\n    while source < n:\n        possible_targets = _random_subset(repeated_nodes, m, seed)\n        target = possible_targets.pop()\n        G.add_edge(source, target)\n        repeated_nodes.append(target)\n        count = 1\n        while count < m:\n            if seed.random() < p:\n                neighborhood = [nbr for nbr in G.neighbors(target) if not G.has_edge(source, nbr) and nbr != source]\n                if neighborhood:\n                    nbr = seed.choice(neighborhood)\n                    G.add_edge(source, nbr)\n                    repeated_nodes.append(nbr)\n                    count = count + 1\n                    continue\n            target = possible_targets.pop()\n            G.add_edge(source, target)\n            repeated_nodes.append(target)\n            count = count + 1\n        repeated_nodes.extend([source] * m)\n        source += 1\n    return G",
        "mutated": [
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef powerlaw_cluster_graph(n, m, p, seed=None):\n    if False:\n        i = 10\n    'Holme and Kim algorithm for growing graphs with powerlaw\\n    degree distribution and approximate average clustering.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        the number of nodes\\n    m : int\\n        the number of random edges to add for each new node\\n    p : float,\\n        Probability of adding a triangle after adding a random edge\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    The average clustering has a hard time getting above a certain\\n    cutoff that depends on `m`.  This cutoff is often quite low.  The\\n    transitivity (fraction of triangles to possible triangles) seems to\\n    decrease with network size.\\n\\n    It is essentially the Barab\u00e1si\u2013Albert (BA) growth model with an\\n    extra step that each random edge is followed by a chance of\\n    making an edge to one of its neighbors too (and thus a triangle).\\n\\n    This algorithm improves on BA in the sense that it enables a\\n    higher average clustering to be attained if desired.\\n\\n    It seems possible to have a disconnected graph with this algorithm\\n    since the initial `m` nodes may not be all linked to a new node\\n    on the first iteration like the BA model.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `m` does not satisfy ``1 <= m <= n`` or `p` does not\\n        satisfy ``0 <= p <= 1``.\\n\\n    References\\n    ----------\\n    .. [1] P. Holme and B. J. Kim,\\n       \"Growing scale-free networks with tunable clustering\",\\n       Phys. Rev. E, 65, 026107, 2002.\\n    '\n    if m < 1 or n < m:\n        raise nx.NetworkXError(f'NetworkXError must have m>1 and m<n, m={m},n={n}')\n    if p > 1 or p < 0:\n        raise nx.NetworkXError(f'NetworkXError p must be in [0,1], p={p}')\n    G = empty_graph(m)\n    repeated_nodes = list(G.nodes())\n    source = m\n    while source < n:\n        possible_targets = _random_subset(repeated_nodes, m, seed)\n        target = possible_targets.pop()\n        G.add_edge(source, target)\n        repeated_nodes.append(target)\n        count = 1\n        while count < m:\n            if seed.random() < p:\n                neighborhood = [nbr for nbr in G.neighbors(target) if not G.has_edge(source, nbr) and nbr != source]\n                if neighborhood:\n                    nbr = seed.choice(neighborhood)\n                    G.add_edge(source, nbr)\n                    repeated_nodes.append(nbr)\n                    count = count + 1\n                    continue\n            target = possible_targets.pop()\n            G.add_edge(source, target)\n            repeated_nodes.append(target)\n            count = count + 1\n        repeated_nodes.extend([source] * m)\n        source += 1\n    return G",
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef powerlaw_cluster_graph(n, m, p, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Holme and Kim algorithm for growing graphs with powerlaw\\n    degree distribution and approximate average clustering.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        the number of nodes\\n    m : int\\n        the number of random edges to add for each new node\\n    p : float,\\n        Probability of adding a triangle after adding a random edge\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    The average clustering has a hard time getting above a certain\\n    cutoff that depends on `m`.  This cutoff is often quite low.  The\\n    transitivity (fraction of triangles to possible triangles) seems to\\n    decrease with network size.\\n\\n    It is essentially the Barab\u00e1si\u2013Albert (BA) growth model with an\\n    extra step that each random edge is followed by a chance of\\n    making an edge to one of its neighbors too (and thus a triangle).\\n\\n    This algorithm improves on BA in the sense that it enables a\\n    higher average clustering to be attained if desired.\\n\\n    It seems possible to have a disconnected graph with this algorithm\\n    since the initial `m` nodes may not be all linked to a new node\\n    on the first iteration like the BA model.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `m` does not satisfy ``1 <= m <= n`` or `p` does not\\n        satisfy ``0 <= p <= 1``.\\n\\n    References\\n    ----------\\n    .. [1] P. Holme and B. J. Kim,\\n       \"Growing scale-free networks with tunable clustering\",\\n       Phys. Rev. E, 65, 026107, 2002.\\n    '\n    if m < 1 or n < m:\n        raise nx.NetworkXError(f'NetworkXError must have m>1 and m<n, m={m},n={n}')\n    if p > 1 or p < 0:\n        raise nx.NetworkXError(f'NetworkXError p must be in [0,1], p={p}')\n    G = empty_graph(m)\n    repeated_nodes = list(G.nodes())\n    source = m\n    while source < n:\n        possible_targets = _random_subset(repeated_nodes, m, seed)\n        target = possible_targets.pop()\n        G.add_edge(source, target)\n        repeated_nodes.append(target)\n        count = 1\n        while count < m:\n            if seed.random() < p:\n                neighborhood = [nbr for nbr in G.neighbors(target) if not G.has_edge(source, nbr) and nbr != source]\n                if neighborhood:\n                    nbr = seed.choice(neighborhood)\n                    G.add_edge(source, nbr)\n                    repeated_nodes.append(nbr)\n                    count = count + 1\n                    continue\n            target = possible_targets.pop()\n            G.add_edge(source, target)\n            repeated_nodes.append(target)\n            count = count + 1\n        repeated_nodes.extend([source] * m)\n        source += 1\n    return G",
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef powerlaw_cluster_graph(n, m, p, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Holme and Kim algorithm for growing graphs with powerlaw\\n    degree distribution and approximate average clustering.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        the number of nodes\\n    m : int\\n        the number of random edges to add for each new node\\n    p : float,\\n        Probability of adding a triangle after adding a random edge\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    The average clustering has a hard time getting above a certain\\n    cutoff that depends on `m`.  This cutoff is often quite low.  The\\n    transitivity (fraction of triangles to possible triangles) seems to\\n    decrease with network size.\\n\\n    It is essentially the Barab\u00e1si\u2013Albert (BA) growth model with an\\n    extra step that each random edge is followed by a chance of\\n    making an edge to one of its neighbors too (and thus a triangle).\\n\\n    This algorithm improves on BA in the sense that it enables a\\n    higher average clustering to be attained if desired.\\n\\n    It seems possible to have a disconnected graph with this algorithm\\n    since the initial `m` nodes may not be all linked to a new node\\n    on the first iteration like the BA model.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `m` does not satisfy ``1 <= m <= n`` or `p` does not\\n        satisfy ``0 <= p <= 1``.\\n\\n    References\\n    ----------\\n    .. [1] P. Holme and B. J. Kim,\\n       \"Growing scale-free networks with tunable clustering\",\\n       Phys. Rev. E, 65, 026107, 2002.\\n    '\n    if m < 1 or n < m:\n        raise nx.NetworkXError(f'NetworkXError must have m>1 and m<n, m={m},n={n}')\n    if p > 1 or p < 0:\n        raise nx.NetworkXError(f'NetworkXError p must be in [0,1], p={p}')\n    G = empty_graph(m)\n    repeated_nodes = list(G.nodes())\n    source = m\n    while source < n:\n        possible_targets = _random_subset(repeated_nodes, m, seed)\n        target = possible_targets.pop()\n        G.add_edge(source, target)\n        repeated_nodes.append(target)\n        count = 1\n        while count < m:\n            if seed.random() < p:\n                neighborhood = [nbr for nbr in G.neighbors(target) if not G.has_edge(source, nbr) and nbr != source]\n                if neighborhood:\n                    nbr = seed.choice(neighborhood)\n                    G.add_edge(source, nbr)\n                    repeated_nodes.append(nbr)\n                    count = count + 1\n                    continue\n            target = possible_targets.pop()\n            G.add_edge(source, target)\n            repeated_nodes.append(target)\n            count = count + 1\n        repeated_nodes.extend([source] * m)\n        source += 1\n    return G",
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef powerlaw_cluster_graph(n, m, p, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Holme and Kim algorithm for growing graphs with powerlaw\\n    degree distribution and approximate average clustering.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        the number of nodes\\n    m : int\\n        the number of random edges to add for each new node\\n    p : float,\\n        Probability of adding a triangle after adding a random edge\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    The average clustering has a hard time getting above a certain\\n    cutoff that depends on `m`.  This cutoff is often quite low.  The\\n    transitivity (fraction of triangles to possible triangles) seems to\\n    decrease with network size.\\n\\n    It is essentially the Barab\u00e1si\u2013Albert (BA) growth model with an\\n    extra step that each random edge is followed by a chance of\\n    making an edge to one of its neighbors too (and thus a triangle).\\n\\n    This algorithm improves on BA in the sense that it enables a\\n    higher average clustering to be attained if desired.\\n\\n    It seems possible to have a disconnected graph with this algorithm\\n    since the initial `m` nodes may not be all linked to a new node\\n    on the first iteration like the BA model.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `m` does not satisfy ``1 <= m <= n`` or `p` does not\\n        satisfy ``0 <= p <= 1``.\\n\\n    References\\n    ----------\\n    .. [1] P. Holme and B. J. Kim,\\n       \"Growing scale-free networks with tunable clustering\",\\n       Phys. Rev. E, 65, 026107, 2002.\\n    '\n    if m < 1 or n < m:\n        raise nx.NetworkXError(f'NetworkXError must have m>1 and m<n, m={m},n={n}')\n    if p > 1 or p < 0:\n        raise nx.NetworkXError(f'NetworkXError p must be in [0,1], p={p}')\n    G = empty_graph(m)\n    repeated_nodes = list(G.nodes())\n    source = m\n    while source < n:\n        possible_targets = _random_subset(repeated_nodes, m, seed)\n        target = possible_targets.pop()\n        G.add_edge(source, target)\n        repeated_nodes.append(target)\n        count = 1\n        while count < m:\n            if seed.random() < p:\n                neighborhood = [nbr for nbr in G.neighbors(target) if not G.has_edge(source, nbr) and nbr != source]\n                if neighborhood:\n                    nbr = seed.choice(neighborhood)\n                    G.add_edge(source, nbr)\n                    repeated_nodes.append(nbr)\n                    count = count + 1\n                    continue\n            target = possible_targets.pop()\n            G.add_edge(source, target)\n            repeated_nodes.append(target)\n            count = count + 1\n        repeated_nodes.extend([source] * m)\n        source += 1\n    return G",
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef powerlaw_cluster_graph(n, m, p, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Holme and Kim algorithm for growing graphs with powerlaw\\n    degree distribution and approximate average clustering.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        the number of nodes\\n    m : int\\n        the number of random edges to add for each new node\\n    p : float,\\n        Probability of adding a triangle after adding a random edge\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    The average clustering has a hard time getting above a certain\\n    cutoff that depends on `m`.  This cutoff is often quite low.  The\\n    transitivity (fraction of triangles to possible triangles) seems to\\n    decrease with network size.\\n\\n    It is essentially the Barab\u00e1si\u2013Albert (BA) growth model with an\\n    extra step that each random edge is followed by a chance of\\n    making an edge to one of its neighbors too (and thus a triangle).\\n\\n    This algorithm improves on BA in the sense that it enables a\\n    higher average clustering to be attained if desired.\\n\\n    It seems possible to have a disconnected graph with this algorithm\\n    since the initial `m` nodes may not be all linked to a new node\\n    on the first iteration like the BA model.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `m` does not satisfy ``1 <= m <= n`` or `p` does not\\n        satisfy ``0 <= p <= 1``.\\n\\n    References\\n    ----------\\n    .. [1] P. Holme and B. J. Kim,\\n       \"Growing scale-free networks with tunable clustering\",\\n       Phys. Rev. E, 65, 026107, 2002.\\n    '\n    if m < 1 or n < m:\n        raise nx.NetworkXError(f'NetworkXError must have m>1 and m<n, m={m},n={n}')\n    if p > 1 or p < 0:\n        raise nx.NetworkXError(f'NetworkXError p must be in [0,1], p={p}')\n    G = empty_graph(m)\n    repeated_nodes = list(G.nodes())\n    source = m\n    while source < n:\n        possible_targets = _random_subset(repeated_nodes, m, seed)\n        target = possible_targets.pop()\n        G.add_edge(source, target)\n        repeated_nodes.append(target)\n        count = 1\n        while count < m:\n            if seed.random() < p:\n                neighborhood = [nbr for nbr in G.neighbors(target) if not G.has_edge(source, nbr) and nbr != source]\n                if neighborhood:\n                    nbr = seed.choice(neighborhood)\n                    G.add_edge(source, nbr)\n                    repeated_nodes.append(nbr)\n                    count = count + 1\n                    continue\n            target = possible_targets.pop()\n            G.add_edge(source, target)\n            repeated_nodes.append(target)\n            count = count + 1\n        repeated_nodes.extend([source] * m)\n        source += 1\n    return G"
        ]
    },
    {
        "func_name": "random_lobster",
        "original": "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef random_lobster(n, p1, p2, seed=None):\n    \"\"\"Returns a random lobster graph.\n\n    A lobster is a tree that reduces to a caterpillar when pruning all\n    leaf nodes. A caterpillar is a tree that reduces to a path graph\n    when pruning all leaf nodes; setting `p2` to zero produces a caterpillar.\n\n    This implementation iterates on the probabilities `p1` and `p2` to add\n    edges at levels 1 and 2, respectively. Graphs are therefore constructed\n    iteratively with uniform randomness at each level rather than being selected\n    uniformly at random from the set of all possible lobsters.\n\n    Parameters\n    ----------\n    n : int\n        The expected number of nodes in the backbone\n    p1 : float\n        Probability of adding an edge to the backbone\n    p2 : float\n        Probability of adding an edge one level beyond backbone\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Raises\n    ------\n    NetworkXError\n        If `p1` or `p2` parameters are >= 1 because the while loops would never finish.\n    \"\"\"\n    (p1, p2) = (abs(p1), abs(p2))\n    if any((p >= 1 for p in [p1, p2])):\n        raise nx.NetworkXError('Probability values for `p1` and `p2` must both be < 1.')\n    llen = int(2 * seed.random() * n + 0.5)\n    L = path_graph(llen)\n    current_node = llen - 1\n    for n in range(llen):\n        while seed.random() < p1:\n            current_node += 1\n            L.add_edge(n, current_node)\n            cat_node = current_node\n            while seed.random() < p2:\n                current_node += 1\n                L.add_edge(cat_node, current_node)\n    return L",
        "mutated": [
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef random_lobster(n, p1, p2, seed=None):\n    if False:\n        i = 10\n    'Returns a random lobster graph.\\n\\n    A lobster is a tree that reduces to a caterpillar when pruning all\\n    leaf nodes. A caterpillar is a tree that reduces to a path graph\\n    when pruning all leaf nodes; setting `p2` to zero produces a caterpillar.\\n\\n    This implementation iterates on the probabilities `p1` and `p2` to add\\n    edges at levels 1 and 2, respectively. Graphs are therefore constructed\\n    iteratively with uniform randomness at each level rather than being selected\\n    uniformly at random from the set of all possible lobsters.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The expected number of nodes in the backbone\\n    p1 : float\\n        Probability of adding an edge to the backbone\\n    p2 : float\\n        Probability of adding an edge one level beyond backbone\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `p1` or `p2` parameters are >= 1 because the while loops would never finish.\\n    '\n    (p1, p2) = (abs(p1), abs(p2))\n    if any((p >= 1 for p in [p1, p2])):\n        raise nx.NetworkXError('Probability values for `p1` and `p2` must both be < 1.')\n    llen = int(2 * seed.random() * n + 0.5)\n    L = path_graph(llen)\n    current_node = llen - 1\n    for n in range(llen):\n        while seed.random() < p1:\n            current_node += 1\n            L.add_edge(n, current_node)\n            cat_node = current_node\n            while seed.random() < p2:\n                current_node += 1\n                L.add_edge(cat_node, current_node)\n    return L",
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef random_lobster(n, p1, p2, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a random lobster graph.\\n\\n    A lobster is a tree that reduces to a caterpillar when pruning all\\n    leaf nodes. A caterpillar is a tree that reduces to a path graph\\n    when pruning all leaf nodes; setting `p2` to zero produces a caterpillar.\\n\\n    This implementation iterates on the probabilities `p1` and `p2` to add\\n    edges at levels 1 and 2, respectively. Graphs are therefore constructed\\n    iteratively with uniform randomness at each level rather than being selected\\n    uniformly at random from the set of all possible lobsters.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The expected number of nodes in the backbone\\n    p1 : float\\n        Probability of adding an edge to the backbone\\n    p2 : float\\n        Probability of adding an edge one level beyond backbone\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `p1` or `p2` parameters are >= 1 because the while loops would never finish.\\n    '\n    (p1, p2) = (abs(p1), abs(p2))\n    if any((p >= 1 for p in [p1, p2])):\n        raise nx.NetworkXError('Probability values for `p1` and `p2` must both be < 1.')\n    llen = int(2 * seed.random() * n + 0.5)\n    L = path_graph(llen)\n    current_node = llen - 1\n    for n in range(llen):\n        while seed.random() < p1:\n            current_node += 1\n            L.add_edge(n, current_node)\n            cat_node = current_node\n            while seed.random() < p2:\n                current_node += 1\n                L.add_edge(cat_node, current_node)\n    return L",
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef random_lobster(n, p1, p2, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a random lobster graph.\\n\\n    A lobster is a tree that reduces to a caterpillar when pruning all\\n    leaf nodes. A caterpillar is a tree that reduces to a path graph\\n    when pruning all leaf nodes; setting `p2` to zero produces a caterpillar.\\n\\n    This implementation iterates on the probabilities `p1` and `p2` to add\\n    edges at levels 1 and 2, respectively. Graphs are therefore constructed\\n    iteratively with uniform randomness at each level rather than being selected\\n    uniformly at random from the set of all possible lobsters.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The expected number of nodes in the backbone\\n    p1 : float\\n        Probability of adding an edge to the backbone\\n    p2 : float\\n        Probability of adding an edge one level beyond backbone\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `p1` or `p2` parameters are >= 1 because the while loops would never finish.\\n    '\n    (p1, p2) = (abs(p1), abs(p2))\n    if any((p >= 1 for p in [p1, p2])):\n        raise nx.NetworkXError('Probability values for `p1` and `p2` must both be < 1.')\n    llen = int(2 * seed.random() * n + 0.5)\n    L = path_graph(llen)\n    current_node = llen - 1\n    for n in range(llen):\n        while seed.random() < p1:\n            current_node += 1\n            L.add_edge(n, current_node)\n            cat_node = current_node\n            while seed.random() < p2:\n                current_node += 1\n                L.add_edge(cat_node, current_node)\n    return L",
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef random_lobster(n, p1, p2, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a random lobster graph.\\n\\n    A lobster is a tree that reduces to a caterpillar when pruning all\\n    leaf nodes. A caterpillar is a tree that reduces to a path graph\\n    when pruning all leaf nodes; setting `p2` to zero produces a caterpillar.\\n\\n    This implementation iterates on the probabilities `p1` and `p2` to add\\n    edges at levels 1 and 2, respectively. Graphs are therefore constructed\\n    iteratively with uniform randomness at each level rather than being selected\\n    uniformly at random from the set of all possible lobsters.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The expected number of nodes in the backbone\\n    p1 : float\\n        Probability of adding an edge to the backbone\\n    p2 : float\\n        Probability of adding an edge one level beyond backbone\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `p1` or `p2` parameters are >= 1 because the while loops would never finish.\\n    '\n    (p1, p2) = (abs(p1), abs(p2))\n    if any((p >= 1 for p in [p1, p2])):\n        raise nx.NetworkXError('Probability values for `p1` and `p2` must both be < 1.')\n    llen = int(2 * seed.random() * n + 0.5)\n    L = path_graph(llen)\n    current_node = llen - 1\n    for n in range(llen):\n        while seed.random() < p1:\n            current_node += 1\n            L.add_edge(n, current_node)\n            cat_node = current_node\n            while seed.random() < p2:\n                current_node += 1\n                L.add_edge(cat_node, current_node)\n    return L",
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef random_lobster(n, p1, p2, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a random lobster graph.\\n\\n    A lobster is a tree that reduces to a caterpillar when pruning all\\n    leaf nodes. A caterpillar is a tree that reduces to a path graph\\n    when pruning all leaf nodes; setting `p2` to zero produces a caterpillar.\\n\\n    This implementation iterates on the probabilities `p1` and `p2` to add\\n    edges at levels 1 and 2, respectively. Graphs are therefore constructed\\n    iteratively with uniform randomness at each level rather than being selected\\n    uniformly at random from the set of all possible lobsters.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The expected number of nodes in the backbone\\n    p1 : float\\n        Probability of adding an edge to the backbone\\n    p2 : float\\n        Probability of adding an edge one level beyond backbone\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `p1` or `p2` parameters are >= 1 because the while loops would never finish.\\n    '\n    (p1, p2) = (abs(p1), abs(p2))\n    if any((p >= 1 for p in [p1, p2])):\n        raise nx.NetworkXError('Probability values for `p1` and `p2` must both be < 1.')\n    llen = int(2 * seed.random() * n + 0.5)\n    L = path_graph(llen)\n    current_node = llen - 1\n    for n in range(llen):\n        while seed.random() < p1:\n            current_node += 1\n            L.add_edge(n, current_node)\n            cat_node = current_node\n            while seed.random() < p2:\n                current_node += 1\n                L.add_edge(cat_node, current_node)\n    return L"
        ]
    },
    {
        "func_name": "random_shell_graph",
        "original": "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef random_shell_graph(constructor, seed=None):\n    \"\"\"Returns a random shell graph for the constructor given.\n\n    Parameters\n    ----------\n    constructor : list of three-tuples\n        Represents the parameters for a shell, starting at the center\n        shell.  Each element of the list must be of the form `(n, m,\n        d)`, where `n` is the number of nodes in the shell, `m` is\n        the number of edges in the shell, and `d` is the ratio of\n        inter-shell (next) edges to intra-shell edges. If `d` is zero,\n        there will be no intra-shell edges, and if `d` is one there\n        will be all possible intra-shell edges.\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Examples\n    --------\n    >>> constructor = [(10, 20, 0.8), (20, 40, 0.8)]\n    >>> G = nx.random_shell_graph(constructor)\n\n    \"\"\"\n    G = empty_graph(0)\n    glist = []\n    intra_edges = []\n    nnodes = 0\n    for (n, m, d) in constructor:\n        inter_edges = int(m * d)\n        intra_edges.append(m - inter_edges)\n        g = nx.convert_node_labels_to_integers(gnm_random_graph(n, inter_edges, seed=seed), first_label=nnodes)\n        glist.append(g)\n        nnodes += n\n        G = nx.operators.union(G, g)\n    for gi in range(len(glist) - 1):\n        nlist1 = list(glist[gi])\n        nlist2 = list(glist[gi + 1])\n        total_edges = intra_edges[gi]\n        edge_count = 0\n        while edge_count < total_edges:\n            u = seed.choice(nlist1)\n            v = seed.choice(nlist2)\n            if u == v or G.has_edge(u, v):\n                continue\n            else:\n                G.add_edge(u, v)\n                edge_count = edge_count + 1\n    return G",
        "mutated": [
            "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef random_shell_graph(constructor, seed=None):\n    if False:\n        i = 10\n    'Returns a random shell graph for the constructor given.\\n\\n    Parameters\\n    ----------\\n    constructor : list of three-tuples\\n        Represents the parameters for a shell, starting at the center\\n        shell.  Each element of the list must be of the form `(n, m,\\n        d)`, where `n` is the number of nodes in the shell, `m` is\\n        the number of edges in the shell, and `d` is the ratio of\\n        inter-shell (next) edges to intra-shell edges. If `d` is zero,\\n        there will be no intra-shell edges, and if `d` is one there\\n        will be all possible intra-shell edges.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Examples\\n    --------\\n    >>> constructor = [(10, 20, 0.8), (20, 40, 0.8)]\\n    >>> G = nx.random_shell_graph(constructor)\\n\\n    '\n    G = empty_graph(0)\n    glist = []\n    intra_edges = []\n    nnodes = 0\n    for (n, m, d) in constructor:\n        inter_edges = int(m * d)\n        intra_edges.append(m - inter_edges)\n        g = nx.convert_node_labels_to_integers(gnm_random_graph(n, inter_edges, seed=seed), first_label=nnodes)\n        glist.append(g)\n        nnodes += n\n        G = nx.operators.union(G, g)\n    for gi in range(len(glist) - 1):\n        nlist1 = list(glist[gi])\n        nlist2 = list(glist[gi + 1])\n        total_edges = intra_edges[gi]\n        edge_count = 0\n        while edge_count < total_edges:\n            u = seed.choice(nlist1)\n            v = seed.choice(nlist2)\n            if u == v or G.has_edge(u, v):\n                continue\n            else:\n                G.add_edge(u, v)\n                edge_count = edge_count + 1\n    return G",
            "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef random_shell_graph(constructor, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a random shell graph for the constructor given.\\n\\n    Parameters\\n    ----------\\n    constructor : list of three-tuples\\n        Represents the parameters for a shell, starting at the center\\n        shell.  Each element of the list must be of the form `(n, m,\\n        d)`, where `n` is the number of nodes in the shell, `m` is\\n        the number of edges in the shell, and `d` is the ratio of\\n        inter-shell (next) edges to intra-shell edges. If `d` is zero,\\n        there will be no intra-shell edges, and if `d` is one there\\n        will be all possible intra-shell edges.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Examples\\n    --------\\n    >>> constructor = [(10, 20, 0.8), (20, 40, 0.8)]\\n    >>> G = nx.random_shell_graph(constructor)\\n\\n    '\n    G = empty_graph(0)\n    glist = []\n    intra_edges = []\n    nnodes = 0\n    for (n, m, d) in constructor:\n        inter_edges = int(m * d)\n        intra_edges.append(m - inter_edges)\n        g = nx.convert_node_labels_to_integers(gnm_random_graph(n, inter_edges, seed=seed), first_label=nnodes)\n        glist.append(g)\n        nnodes += n\n        G = nx.operators.union(G, g)\n    for gi in range(len(glist) - 1):\n        nlist1 = list(glist[gi])\n        nlist2 = list(glist[gi + 1])\n        total_edges = intra_edges[gi]\n        edge_count = 0\n        while edge_count < total_edges:\n            u = seed.choice(nlist1)\n            v = seed.choice(nlist2)\n            if u == v or G.has_edge(u, v):\n                continue\n            else:\n                G.add_edge(u, v)\n                edge_count = edge_count + 1\n    return G",
            "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef random_shell_graph(constructor, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a random shell graph for the constructor given.\\n\\n    Parameters\\n    ----------\\n    constructor : list of three-tuples\\n        Represents the parameters for a shell, starting at the center\\n        shell.  Each element of the list must be of the form `(n, m,\\n        d)`, where `n` is the number of nodes in the shell, `m` is\\n        the number of edges in the shell, and `d` is the ratio of\\n        inter-shell (next) edges to intra-shell edges. If `d` is zero,\\n        there will be no intra-shell edges, and if `d` is one there\\n        will be all possible intra-shell edges.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Examples\\n    --------\\n    >>> constructor = [(10, 20, 0.8), (20, 40, 0.8)]\\n    >>> G = nx.random_shell_graph(constructor)\\n\\n    '\n    G = empty_graph(0)\n    glist = []\n    intra_edges = []\n    nnodes = 0\n    for (n, m, d) in constructor:\n        inter_edges = int(m * d)\n        intra_edges.append(m - inter_edges)\n        g = nx.convert_node_labels_to_integers(gnm_random_graph(n, inter_edges, seed=seed), first_label=nnodes)\n        glist.append(g)\n        nnodes += n\n        G = nx.operators.union(G, g)\n    for gi in range(len(glist) - 1):\n        nlist1 = list(glist[gi])\n        nlist2 = list(glist[gi + 1])\n        total_edges = intra_edges[gi]\n        edge_count = 0\n        while edge_count < total_edges:\n            u = seed.choice(nlist1)\n            v = seed.choice(nlist2)\n            if u == v or G.has_edge(u, v):\n                continue\n            else:\n                G.add_edge(u, v)\n                edge_count = edge_count + 1\n    return G",
            "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef random_shell_graph(constructor, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a random shell graph for the constructor given.\\n\\n    Parameters\\n    ----------\\n    constructor : list of three-tuples\\n        Represents the parameters for a shell, starting at the center\\n        shell.  Each element of the list must be of the form `(n, m,\\n        d)`, where `n` is the number of nodes in the shell, `m` is\\n        the number of edges in the shell, and `d` is the ratio of\\n        inter-shell (next) edges to intra-shell edges. If `d` is zero,\\n        there will be no intra-shell edges, and if `d` is one there\\n        will be all possible intra-shell edges.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Examples\\n    --------\\n    >>> constructor = [(10, 20, 0.8), (20, 40, 0.8)]\\n    >>> G = nx.random_shell_graph(constructor)\\n\\n    '\n    G = empty_graph(0)\n    glist = []\n    intra_edges = []\n    nnodes = 0\n    for (n, m, d) in constructor:\n        inter_edges = int(m * d)\n        intra_edges.append(m - inter_edges)\n        g = nx.convert_node_labels_to_integers(gnm_random_graph(n, inter_edges, seed=seed), first_label=nnodes)\n        glist.append(g)\n        nnodes += n\n        G = nx.operators.union(G, g)\n    for gi in range(len(glist) - 1):\n        nlist1 = list(glist[gi])\n        nlist2 = list(glist[gi + 1])\n        total_edges = intra_edges[gi]\n        edge_count = 0\n        while edge_count < total_edges:\n            u = seed.choice(nlist1)\n            v = seed.choice(nlist2)\n            if u == v or G.has_edge(u, v):\n                continue\n            else:\n                G.add_edge(u, v)\n                edge_count = edge_count + 1\n    return G",
            "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef random_shell_graph(constructor, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a random shell graph for the constructor given.\\n\\n    Parameters\\n    ----------\\n    constructor : list of three-tuples\\n        Represents the parameters for a shell, starting at the center\\n        shell.  Each element of the list must be of the form `(n, m,\\n        d)`, where `n` is the number of nodes in the shell, `m` is\\n        the number of edges in the shell, and `d` is the ratio of\\n        inter-shell (next) edges to intra-shell edges. If `d` is zero,\\n        there will be no intra-shell edges, and if `d` is one there\\n        will be all possible intra-shell edges.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Examples\\n    --------\\n    >>> constructor = [(10, 20, 0.8), (20, 40, 0.8)]\\n    >>> G = nx.random_shell_graph(constructor)\\n\\n    '\n    G = empty_graph(0)\n    glist = []\n    intra_edges = []\n    nnodes = 0\n    for (n, m, d) in constructor:\n        inter_edges = int(m * d)\n        intra_edges.append(m - inter_edges)\n        g = nx.convert_node_labels_to_integers(gnm_random_graph(n, inter_edges, seed=seed), first_label=nnodes)\n        glist.append(g)\n        nnodes += n\n        G = nx.operators.union(G, g)\n    for gi in range(len(glist) - 1):\n        nlist1 = list(glist[gi])\n        nlist2 = list(glist[gi + 1])\n        total_edges = intra_edges[gi]\n        edge_count = 0\n        while edge_count < total_edges:\n            u = seed.choice(nlist1)\n            v = seed.choice(nlist2)\n            if u == v or G.has_edge(u, v):\n                continue\n            else:\n                G.add_edge(u, v)\n                edge_count = edge_count + 1\n    return G"
        ]
    },
    {
        "func_name": "random_powerlaw_tree",
        "original": "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef random_powerlaw_tree(n, gamma=3, seed=None, tries=100):\n    \"\"\"Returns a tree with a power law degree distribution.\n\n    Parameters\n    ----------\n    n : int\n        The number of nodes.\n    gamma : float\n        Exponent of the power law.\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n    tries : int\n        Number of attempts to adjust the sequence to make it a tree.\n\n    Raises\n    ------\n    NetworkXError\n        If no valid sequence is found within the maximum number of\n        attempts.\n\n    Notes\n    -----\n    A trial power law degree sequence is chosen and then elements are\n    swapped with new elements from a powerlaw distribution until the\n    sequence makes a tree (by checking, for example, that the number of\n    edges is one smaller than the number of nodes).\n\n    \"\"\"\n    seq = random_powerlaw_tree_sequence(n, gamma=gamma, seed=seed, tries=tries)\n    G = degree_sequence_tree(seq)\n    return G",
        "mutated": [
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef random_powerlaw_tree(n, gamma=3, seed=None, tries=100):\n    if False:\n        i = 10\n    'Returns a tree with a power law degree distribution.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    gamma : float\\n        Exponent of the power law.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    tries : int\\n        Number of attempts to adjust the sequence to make it a tree.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If no valid sequence is found within the maximum number of\\n        attempts.\\n\\n    Notes\\n    -----\\n    A trial power law degree sequence is chosen and then elements are\\n    swapped with new elements from a powerlaw distribution until the\\n    sequence makes a tree (by checking, for example, that the number of\\n    edges is one smaller than the number of nodes).\\n\\n    '\n    seq = random_powerlaw_tree_sequence(n, gamma=gamma, seed=seed, tries=tries)\n    G = degree_sequence_tree(seq)\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef random_powerlaw_tree(n, gamma=3, seed=None, tries=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a tree with a power law degree distribution.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    gamma : float\\n        Exponent of the power law.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    tries : int\\n        Number of attempts to adjust the sequence to make it a tree.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If no valid sequence is found within the maximum number of\\n        attempts.\\n\\n    Notes\\n    -----\\n    A trial power law degree sequence is chosen and then elements are\\n    swapped with new elements from a powerlaw distribution until the\\n    sequence makes a tree (by checking, for example, that the number of\\n    edges is one smaller than the number of nodes).\\n\\n    '\n    seq = random_powerlaw_tree_sequence(n, gamma=gamma, seed=seed, tries=tries)\n    G = degree_sequence_tree(seq)\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef random_powerlaw_tree(n, gamma=3, seed=None, tries=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a tree with a power law degree distribution.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    gamma : float\\n        Exponent of the power law.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    tries : int\\n        Number of attempts to adjust the sequence to make it a tree.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If no valid sequence is found within the maximum number of\\n        attempts.\\n\\n    Notes\\n    -----\\n    A trial power law degree sequence is chosen and then elements are\\n    swapped with new elements from a powerlaw distribution until the\\n    sequence makes a tree (by checking, for example, that the number of\\n    edges is one smaller than the number of nodes).\\n\\n    '\n    seq = random_powerlaw_tree_sequence(n, gamma=gamma, seed=seed, tries=tries)\n    G = degree_sequence_tree(seq)\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef random_powerlaw_tree(n, gamma=3, seed=None, tries=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a tree with a power law degree distribution.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    gamma : float\\n        Exponent of the power law.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    tries : int\\n        Number of attempts to adjust the sequence to make it a tree.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If no valid sequence is found within the maximum number of\\n        attempts.\\n\\n    Notes\\n    -----\\n    A trial power law degree sequence is chosen and then elements are\\n    swapped with new elements from a powerlaw distribution until the\\n    sequence makes a tree (by checking, for example, that the number of\\n    edges is one smaller than the number of nodes).\\n\\n    '\n    seq = random_powerlaw_tree_sequence(n, gamma=gamma, seed=seed, tries=tries)\n    G = degree_sequence_tree(seq)\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef random_powerlaw_tree(n, gamma=3, seed=None, tries=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a tree with a power law degree distribution.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes.\\n    gamma : float\\n        Exponent of the power law.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    tries : int\\n        Number of attempts to adjust the sequence to make it a tree.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If no valid sequence is found within the maximum number of\\n        attempts.\\n\\n    Notes\\n    -----\\n    A trial power law degree sequence is chosen and then elements are\\n    swapped with new elements from a powerlaw distribution until the\\n    sequence makes a tree (by checking, for example, that the number of\\n    edges is one smaller than the number of nodes).\\n\\n    '\n    seq = random_powerlaw_tree_sequence(n, gamma=gamma, seed=seed, tries=tries)\n    G = degree_sequence_tree(seq)\n    return G"
        ]
    },
    {
        "func_name": "random_powerlaw_tree_sequence",
        "original": "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef random_powerlaw_tree_sequence(n, gamma=3, seed=None, tries=100):\n    \"\"\"Returns a degree sequence for a tree with a power law distribution.\n\n    Parameters\n    ----------\n    n : int,\n        The number of nodes.\n    gamma : float\n        Exponent of the power law.\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n    tries : int\n        Number of attempts to adjust the sequence to make it a tree.\n\n    Raises\n    ------\n    NetworkXError\n        If no valid sequence is found within the maximum number of\n        attempts.\n\n    Notes\n    -----\n    A trial power law degree sequence is chosen and then elements are\n    swapped with new elements from a power law distribution until\n    the sequence makes a tree (by checking, for example, that the number of\n    edges is one smaller than the number of nodes).\n\n    \"\"\"\n    z = nx.utils.powerlaw_sequence(n, exponent=gamma, seed=seed)\n    zseq = [min(n, max(round(s), 0)) for s in z]\n    z = nx.utils.powerlaw_sequence(tries, exponent=gamma, seed=seed)\n    swap = [min(n, max(round(s), 0)) for s in z]\n    for deg in swap:\n        if 2 * n - sum(zseq) == 2:\n            return zseq\n        index = seed.randint(0, n - 1)\n        zseq[index] = swap.pop()\n    raise nx.NetworkXError(f'Exceeded max ({tries}) attempts for a valid tree sequence.')",
        "mutated": [
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef random_powerlaw_tree_sequence(n, gamma=3, seed=None, tries=100):\n    if False:\n        i = 10\n    'Returns a degree sequence for a tree with a power law distribution.\\n\\n    Parameters\\n    ----------\\n    n : int,\\n        The number of nodes.\\n    gamma : float\\n        Exponent of the power law.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    tries : int\\n        Number of attempts to adjust the sequence to make it a tree.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If no valid sequence is found within the maximum number of\\n        attempts.\\n\\n    Notes\\n    -----\\n    A trial power law degree sequence is chosen and then elements are\\n    swapped with new elements from a power law distribution until\\n    the sequence makes a tree (by checking, for example, that the number of\\n    edges is one smaller than the number of nodes).\\n\\n    '\n    z = nx.utils.powerlaw_sequence(n, exponent=gamma, seed=seed)\n    zseq = [min(n, max(round(s), 0)) for s in z]\n    z = nx.utils.powerlaw_sequence(tries, exponent=gamma, seed=seed)\n    swap = [min(n, max(round(s), 0)) for s in z]\n    for deg in swap:\n        if 2 * n - sum(zseq) == 2:\n            return zseq\n        index = seed.randint(0, n - 1)\n        zseq[index] = swap.pop()\n    raise nx.NetworkXError(f'Exceeded max ({tries}) attempts for a valid tree sequence.')",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef random_powerlaw_tree_sequence(n, gamma=3, seed=None, tries=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a degree sequence for a tree with a power law distribution.\\n\\n    Parameters\\n    ----------\\n    n : int,\\n        The number of nodes.\\n    gamma : float\\n        Exponent of the power law.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    tries : int\\n        Number of attempts to adjust the sequence to make it a tree.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If no valid sequence is found within the maximum number of\\n        attempts.\\n\\n    Notes\\n    -----\\n    A trial power law degree sequence is chosen and then elements are\\n    swapped with new elements from a power law distribution until\\n    the sequence makes a tree (by checking, for example, that the number of\\n    edges is one smaller than the number of nodes).\\n\\n    '\n    z = nx.utils.powerlaw_sequence(n, exponent=gamma, seed=seed)\n    zseq = [min(n, max(round(s), 0)) for s in z]\n    z = nx.utils.powerlaw_sequence(tries, exponent=gamma, seed=seed)\n    swap = [min(n, max(round(s), 0)) for s in z]\n    for deg in swap:\n        if 2 * n - sum(zseq) == 2:\n            return zseq\n        index = seed.randint(0, n - 1)\n        zseq[index] = swap.pop()\n    raise nx.NetworkXError(f'Exceeded max ({tries}) attempts for a valid tree sequence.')",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef random_powerlaw_tree_sequence(n, gamma=3, seed=None, tries=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a degree sequence for a tree with a power law distribution.\\n\\n    Parameters\\n    ----------\\n    n : int,\\n        The number of nodes.\\n    gamma : float\\n        Exponent of the power law.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    tries : int\\n        Number of attempts to adjust the sequence to make it a tree.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If no valid sequence is found within the maximum number of\\n        attempts.\\n\\n    Notes\\n    -----\\n    A trial power law degree sequence is chosen and then elements are\\n    swapped with new elements from a power law distribution until\\n    the sequence makes a tree (by checking, for example, that the number of\\n    edges is one smaller than the number of nodes).\\n\\n    '\n    z = nx.utils.powerlaw_sequence(n, exponent=gamma, seed=seed)\n    zseq = [min(n, max(round(s), 0)) for s in z]\n    z = nx.utils.powerlaw_sequence(tries, exponent=gamma, seed=seed)\n    swap = [min(n, max(round(s), 0)) for s in z]\n    for deg in swap:\n        if 2 * n - sum(zseq) == 2:\n            return zseq\n        index = seed.randint(0, n - 1)\n        zseq[index] = swap.pop()\n    raise nx.NetworkXError(f'Exceeded max ({tries}) attempts for a valid tree sequence.')",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef random_powerlaw_tree_sequence(n, gamma=3, seed=None, tries=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a degree sequence for a tree with a power law distribution.\\n\\n    Parameters\\n    ----------\\n    n : int,\\n        The number of nodes.\\n    gamma : float\\n        Exponent of the power law.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    tries : int\\n        Number of attempts to adjust the sequence to make it a tree.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If no valid sequence is found within the maximum number of\\n        attempts.\\n\\n    Notes\\n    -----\\n    A trial power law degree sequence is chosen and then elements are\\n    swapped with new elements from a power law distribution until\\n    the sequence makes a tree (by checking, for example, that the number of\\n    edges is one smaller than the number of nodes).\\n\\n    '\n    z = nx.utils.powerlaw_sequence(n, exponent=gamma, seed=seed)\n    zseq = [min(n, max(round(s), 0)) for s in z]\n    z = nx.utils.powerlaw_sequence(tries, exponent=gamma, seed=seed)\n    swap = [min(n, max(round(s), 0)) for s in z]\n    for deg in swap:\n        if 2 * n - sum(zseq) == 2:\n            return zseq\n        index = seed.randint(0, n - 1)\n        zseq[index] = swap.pop()\n    raise nx.NetworkXError(f'Exceeded max ({tries}) attempts for a valid tree sequence.')",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef random_powerlaw_tree_sequence(n, gamma=3, seed=None, tries=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a degree sequence for a tree with a power law distribution.\\n\\n    Parameters\\n    ----------\\n    n : int,\\n        The number of nodes.\\n    gamma : float\\n        Exponent of the power law.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n    tries : int\\n        Number of attempts to adjust the sequence to make it a tree.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If no valid sequence is found within the maximum number of\\n        attempts.\\n\\n    Notes\\n    -----\\n    A trial power law degree sequence is chosen and then elements are\\n    swapped with new elements from a power law distribution until\\n    the sequence makes a tree (by checking, for example, that the number of\\n    edges is one smaller than the number of nodes).\\n\\n    '\n    z = nx.utils.powerlaw_sequence(n, exponent=gamma, seed=seed)\n    zseq = [min(n, max(round(s), 0)) for s in z]\n    z = nx.utils.powerlaw_sequence(tries, exponent=gamma, seed=seed)\n    swap = [min(n, max(round(s), 0)) for s in z]\n    for deg in swap:\n        if 2 * n - sum(zseq) == 2:\n            return zseq\n        index = seed.randint(0, n - 1)\n        zseq[index] = swap.pop()\n    raise nx.NetworkXError(f'Exceeded max ({tries}) attempts for a valid tree sequence.')"
        ]
    },
    {
        "func_name": "my_function",
        "original": "def my_function(b):\n    return kernel_integral(y, a, b) - r",
        "mutated": [
            "def my_function(b):\n    if False:\n        i = 10\n    return kernel_integral(y, a, b) - r",
            "def my_function(b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return kernel_integral(y, a, b) - r",
            "def my_function(b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return kernel_integral(y, a, b) - r",
            "def my_function(b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return kernel_integral(y, a, b) - r",
            "def my_function(b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return kernel_integral(y, a, b) - r"
        ]
    },
    {
        "func_name": "kernel_root",
        "original": "def kernel_root(y, a, r):\n\n    def my_function(b):\n        return kernel_integral(y, a, b) - r\n    return sp.optimize.brentq(my_function, a, 1)",
        "mutated": [
            "def kernel_root(y, a, r):\n    if False:\n        i = 10\n\n    def my_function(b):\n        return kernel_integral(y, a, b) - r\n    return sp.optimize.brentq(my_function, a, 1)",
            "def kernel_root(y, a, r):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def my_function(b):\n        return kernel_integral(y, a, b) - r\n    return sp.optimize.brentq(my_function, a, 1)",
            "def kernel_root(y, a, r):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def my_function(b):\n        return kernel_integral(y, a, b) - r\n    return sp.optimize.brentq(my_function, a, 1)",
            "def kernel_root(y, a, r):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def my_function(b):\n        return kernel_integral(y, a, b) - r\n    return sp.optimize.brentq(my_function, a, 1)",
            "def kernel_root(y, a, r):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def my_function(b):\n        return kernel_integral(y, a, b) - r\n    return sp.optimize.brentq(my_function, a, 1)"
        ]
    },
    {
        "func_name": "random_kernel_graph",
        "original": "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef random_kernel_graph(n, kernel_integral, kernel_root=None, seed=None):\n    \"\"\"Returns an random graph based on the specified kernel.\n\n    The algorithm chooses each of the $[n(n-1)]/2$ possible edges with\n    probability specified by a kernel $\\\\kappa(x,y)$ [1]_.  The kernel\n    $\\\\kappa(x,y)$ must be a symmetric (in $x,y$), non-negative,\n    bounded function.\n\n    Parameters\n    ----------\n    n : int\n        The number of nodes\n    kernel_integral : function\n        Function that returns the definite integral of the kernel $\\\\kappa(x,y)$,\n        $F(y,a,b) := \\\\int_a^b \\\\kappa(x,y)dx$\n    kernel_root: function (optional)\n        Function that returns the root $b$ of the equation $F(y,a,b) = r$.\n        If None, the root is found using :func:`scipy.optimize.brentq`\n        (this requires SciPy).\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Notes\n    -----\n    The kernel is specified through its definite integral which must be\n    provided as one of the arguments. If the integral and root of the\n    kernel integral can be found in $O(1)$ time then this algorithm runs in\n    time $O(n+m)$ where m is the expected number of edges [2]_.\n\n    The nodes are set to integers from $0$ to $n-1$.\n\n    Examples\n    --------\n    Generate an Erd\u0151s\u2013R\u00e9nyi random graph $G(n,c/n)$, with kernel\n    $\\\\kappa(x,y)=c$ where $c$ is the mean expected degree.\n\n    >>> def integral(u, w, z):\n    ...     return c * (z - w)\n    >>> def root(u, w, r):\n    ...     return r / c + w\n    >>> c = 1\n    >>> graph = nx.random_kernel_graph(1000, integral, root)\n\n    See Also\n    --------\n    gnp_random_graph\n    expected_degree_graph\n\n    References\n    ----------\n    .. [1] Bollob\u00e1s, B\u00e9la,  Janson, S. and Riordan, O.\n       \"The phase transition in inhomogeneous random graphs\",\n       *Random Structures Algorithms*, 31, 3--122, 2007.\n\n    .. [2] Hagberg A, Lemons N (2015),\n       \"Fast Generation of Sparse Random Kernel Graphs\".\n       PLoS ONE 10(9): e0135177, 2015. doi:10.1371/journal.pone.0135177\n    \"\"\"\n    if kernel_root is None:\n        import scipy as sp\n\n        def kernel_root(y, a, r):\n\n            def my_function(b):\n                return kernel_integral(y, a, b) - r\n            return sp.optimize.brentq(my_function, a, 1)\n    graph = nx.Graph()\n    graph.add_nodes_from(range(n))\n    (i, j) = (1, 1)\n    while i < n:\n        r = -math.log(1 - seed.random())\n        if kernel_integral(i / n, j / n, 1) <= r:\n            (i, j) = (i + 1, i + 1)\n        else:\n            j = math.ceil(n * kernel_root(i / n, j / n, r))\n            graph.add_edge(i - 1, j - 1)\n    return graph",
        "mutated": [
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef random_kernel_graph(n, kernel_integral, kernel_root=None, seed=None):\n    if False:\n        i = 10\n    'Returns an random graph based on the specified kernel.\\n\\n    The algorithm chooses each of the $[n(n-1)]/2$ possible edges with\\n    probability specified by a kernel $\\\\kappa(x,y)$ [1]_.  The kernel\\n    $\\\\kappa(x,y)$ must be a symmetric (in $x,y$), non-negative,\\n    bounded function.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes\\n    kernel_integral : function\\n        Function that returns the definite integral of the kernel $\\\\kappa(x,y)$,\\n        $F(y,a,b) := \\\\int_a^b \\\\kappa(x,y)dx$\\n    kernel_root: function (optional)\\n        Function that returns the root $b$ of the equation $F(y,a,b) = r$.\\n        If None, the root is found using :func:`scipy.optimize.brentq`\\n        (this requires SciPy).\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    The kernel is specified through its definite integral which must be\\n    provided as one of the arguments. If the integral and root of the\\n    kernel integral can be found in $O(1)$ time then this algorithm runs in\\n    time $O(n+m)$ where m is the expected number of edges [2]_.\\n\\n    The nodes are set to integers from $0$ to $n-1$.\\n\\n    Examples\\n    --------\\n    Generate an Erd\u0151s\u2013R\u00e9nyi random graph $G(n,c/n)$, with kernel\\n    $\\\\kappa(x,y)=c$ where $c$ is the mean expected degree.\\n\\n    >>> def integral(u, w, z):\\n    ...     return c * (z - w)\\n    >>> def root(u, w, r):\\n    ...     return r / c + w\\n    >>> c = 1\\n    >>> graph = nx.random_kernel_graph(1000, integral, root)\\n\\n    See Also\\n    --------\\n    gnp_random_graph\\n    expected_degree_graph\\n\\n    References\\n    ----------\\n    .. [1] Bollob\u00e1s, B\u00e9la,  Janson, S. and Riordan, O.\\n       \"The phase transition in inhomogeneous random graphs\",\\n       *Random Structures Algorithms*, 31, 3--122, 2007.\\n\\n    .. [2] Hagberg A, Lemons N (2015),\\n       \"Fast Generation of Sparse Random Kernel Graphs\".\\n       PLoS ONE 10(9): e0135177, 2015. doi:10.1371/journal.pone.0135177\\n    '\n    if kernel_root is None:\n        import scipy as sp\n\n        def kernel_root(y, a, r):\n\n            def my_function(b):\n                return kernel_integral(y, a, b) - r\n            return sp.optimize.brentq(my_function, a, 1)\n    graph = nx.Graph()\n    graph.add_nodes_from(range(n))\n    (i, j) = (1, 1)\n    while i < n:\n        r = -math.log(1 - seed.random())\n        if kernel_integral(i / n, j / n, 1) <= r:\n            (i, j) = (i + 1, i + 1)\n        else:\n            j = math.ceil(n * kernel_root(i / n, j / n, r))\n            graph.add_edge(i - 1, j - 1)\n    return graph",
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef random_kernel_graph(n, kernel_integral, kernel_root=None, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns an random graph based on the specified kernel.\\n\\n    The algorithm chooses each of the $[n(n-1)]/2$ possible edges with\\n    probability specified by a kernel $\\\\kappa(x,y)$ [1]_.  The kernel\\n    $\\\\kappa(x,y)$ must be a symmetric (in $x,y$), non-negative,\\n    bounded function.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes\\n    kernel_integral : function\\n        Function that returns the definite integral of the kernel $\\\\kappa(x,y)$,\\n        $F(y,a,b) := \\\\int_a^b \\\\kappa(x,y)dx$\\n    kernel_root: function (optional)\\n        Function that returns the root $b$ of the equation $F(y,a,b) = r$.\\n        If None, the root is found using :func:`scipy.optimize.brentq`\\n        (this requires SciPy).\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    The kernel is specified through its definite integral which must be\\n    provided as one of the arguments. If the integral and root of the\\n    kernel integral can be found in $O(1)$ time then this algorithm runs in\\n    time $O(n+m)$ where m is the expected number of edges [2]_.\\n\\n    The nodes are set to integers from $0$ to $n-1$.\\n\\n    Examples\\n    --------\\n    Generate an Erd\u0151s\u2013R\u00e9nyi random graph $G(n,c/n)$, with kernel\\n    $\\\\kappa(x,y)=c$ where $c$ is the mean expected degree.\\n\\n    >>> def integral(u, w, z):\\n    ...     return c * (z - w)\\n    >>> def root(u, w, r):\\n    ...     return r / c + w\\n    >>> c = 1\\n    >>> graph = nx.random_kernel_graph(1000, integral, root)\\n\\n    See Also\\n    --------\\n    gnp_random_graph\\n    expected_degree_graph\\n\\n    References\\n    ----------\\n    .. [1] Bollob\u00e1s, B\u00e9la,  Janson, S. and Riordan, O.\\n       \"The phase transition in inhomogeneous random graphs\",\\n       *Random Structures Algorithms*, 31, 3--122, 2007.\\n\\n    .. [2] Hagberg A, Lemons N (2015),\\n       \"Fast Generation of Sparse Random Kernel Graphs\".\\n       PLoS ONE 10(9): e0135177, 2015. doi:10.1371/journal.pone.0135177\\n    '\n    if kernel_root is None:\n        import scipy as sp\n\n        def kernel_root(y, a, r):\n\n            def my_function(b):\n                return kernel_integral(y, a, b) - r\n            return sp.optimize.brentq(my_function, a, 1)\n    graph = nx.Graph()\n    graph.add_nodes_from(range(n))\n    (i, j) = (1, 1)\n    while i < n:\n        r = -math.log(1 - seed.random())\n        if kernel_integral(i / n, j / n, 1) <= r:\n            (i, j) = (i + 1, i + 1)\n        else:\n            j = math.ceil(n * kernel_root(i / n, j / n, r))\n            graph.add_edge(i - 1, j - 1)\n    return graph",
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef random_kernel_graph(n, kernel_integral, kernel_root=None, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns an random graph based on the specified kernel.\\n\\n    The algorithm chooses each of the $[n(n-1)]/2$ possible edges with\\n    probability specified by a kernel $\\\\kappa(x,y)$ [1]_.  The kernel\\n    $\\\\kappa(x,y)$ must be a symmetric (in $x,y$), non-negative,\\n    bounded function.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes\\n    kernel_integral : function\\n        Function that returns the definite integral of the kernel $\\\\kappa(x,y)$,\\n        $F(y,a,b) := \\\\int_a^b \\\\kappa(x,y)dx$\\n    kernel_root: function (optional)\\n        Function that returns the root $b$ of the equation $F(y,a,b) = r$.\\n        If None, the root is found using :func:`scipy.optimize.brentq`\\n        (this requires SciPy).\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    The kernel is specified through its definite integral which must be\\n    provided as one of the arguments. If the integral and root of the\\n    kernel integral can be found in $O(1)$ time then this algorithm runs in\\n    time $O(n+m)$ where m is the expected number of edges [2]_.\\n\\n    The nodes are set to integers from $0$ to $n-1$.\\n\\n    Examples\\n    --------\\n    Generate an Erd\u0151s\u2013R\u00e9nyi random graph $G(n,c/n)$, with kernel\\n    $\\\\kappa(x,y)=c$ where $c$ is the mean expected degree.\\n\\n    >>> def integral(u, w, z):\\n    ...     return c * (z - w)\\n    >>> def root(u, w, r):\\n    ...     return r / c + w\\n    >>> c = 1\\n    >>> graph = nx.random_kernel_graph(1000, integral, root)\\n\\n    See Also\\n    --------\\n    gnp_random_graph\\n    expected_degree_graph\\n\\n    References\\n    ----------\\n    .. [1] Bollob\u00e1s, B\u00e9la,  Janson, S. and Riordan, O.\\n       \"The phase transition in inhomogeneous random graphs\",\\n       *Random Structures Algorithms*, 31, 3--122, 2007.\\n\\n    .. [2] Hagberg A, Lemons N (2015),\\n       \"Fast Generation of Sparse Random Kernel Graphs\".\\n       PLoS ONE 10(9): e0135177, 2015. doi:10.1371/journal.pone.0135177\\n    '\n    if kernel_root is None:\n        import scipy as sp\n\n        def kernel_root(y, a, r):\n\n            def my_function(b):\n                return kernel_integral(y, a, b) - r\n            return sp.optimize.brentq(my_function, a, 1)\n    graph = nx.Graph()\n    graph.add_nodes_from(range(n))\n    (i, j) = (1, 1)\n    while i < n:\n        r = -math.log(1 - seed.random())\n        if kernel_integral(i / n, j / n, 1) <= r:\n            (i, j) = (i + 1, i + 1)\n        else:\n            j = math.ceil(n * kernel_root(i / n, j / n, r))\n            graph.add_edge(i - 1, j - 1)\n    return graph",
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef random_kernel_graph(n, kernel_integral, kernel_root=None, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns an random graph based on the specified kernel.\\n\\n    The algorithm chooses each of the $[n(n-1)]/2$ possible edges with\\n    probability specified by a kernel $\\\\kappa(x,y)$ [1]_.  The kernel\\n    $\\\\kappa(x,y)$ must be a symmetric (in $x,y$), non-negative,\\n    bounded function.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes\\n    kernel_integral : function\\n        Function that returns the definite integral of the kernel $\\\\kappa(x,y)$,\\n        $F(y,a,b) := \\\\int_a^b \\\\kappa(x,y)dx$\\n    kernel_root: function (optional)\\n        Function that returns the root $b$ of the equation $F(y,a,b) = r$.\\n        If None, the root is found using :func:`scipy.optimize.brentq`\\n        (this requires SciPy).\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    The kernel is specified through its definite integral which must be\\n    provided as one of the arguments. If the integral and root of the\\n    kernel integral can be found in $O(1)$ time then this algorithm runs in\\n    time $O(n+m)$ where m is the expected number of edges [2]_.\\n\\n    The nodes are set to integers from $0$ to $n-1$.\\n\\n    Examples\\n    --------\\n    Generate an Erd\u0151s\u2013R\u00e9nyi random graph $G(n,c/n)$, with kernel\\n    $\\\\kappa(x,y)=c$ where $c$ is the mean expected degree.\\n\\n    >>> def integral(u, w, z):\\n    ...     return c * (z - w)\\n    >>> def root(u, w, r):\\n    ...     return r / c + w\\n    >>> c = 1\\n    >>> graph = nx.random_kernel_graph(1000, integral, root)\\n\\n    See Also\\n    --------\\n    gnp_random_graph\\n    expected_degree_graph\\n\\n    References\\n    ----------\\n    .. [1] Bollob\u00e1s, B\u00e9la,  Janson, S. and Riordan, O.\\n       \"The phase transition in inhomogeneous random graphs\",\\n       *Random Structures Algorithms*, 31, 3--122, 2007.\\n\\n    .. [2] Hagberg A, Lemons N (2015),\\n       \"Fast Generation of Sparse Random Kernel Graphs\".\\n       PLoS ONE 10(9): e0135177, 2015. doi:10.1371/journal.pone.0135177\\n    '\n    if kernel_root is None:\n        import scipy as sp\n\n        def kernel_root(y, a, r):\n\n            def my_function(b):\n                return kernel_integral(y, a, b) - r\n            return sp.optimize.brentq(my_function, a, 1)\n    graph = nx.Graph()\n    graph.add_nodes_from(range(n))\n    (i, j) = (1, 1)\n    while i < n:\n        r = -math.log(1 - seed.random())\n        if kernel_integral(i / n, j / n, 1) <= r:\n            (i, j) = (i + 1, i + 1)\n        else:\n            j = math.ceil(n * kernel_root(i / n, j / n, r))\n            graph.add_edge(i - 1, j - 1)\n    return graph",
            "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef random_kernel_graph(n, kernel_integral, kernel_root=None, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns an random graph based on the specified kernel.\\n\\n    The algorithm chooses each of the $[n(n-1)]/2$ possible edges with\\n    probability specified by a kernel $\\\\kappa(x,y)$ [1]_.  The kernel\\n    $\\\\kappa(x,y)$ must be a symmetric (in $x,y$), non-negative,\\n    bounded function.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The number of nodes\\n    kernel_integral : function\\n        Function that returns the definite integral of the kernel $\\\\kappa(x,y)$,\\n        $F(y,a,b) := \\\\int_a^b \\\\kappa(x,y)dx$\\n    kernel_root: function (optional)\\n        Function that returns the root $b$ of the equation $F(y,a,b) = r$.\\n        If None, the root is found using :func:`scipy.optimize.brentq`\\n        (this requires SciPy).\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    The kernel is specified through its definite integral which must be\\n    provided as one of the arguments. If the integral and root of the\\n    kernel integral can be found in $O(1)$ time then this algorithm runs in\\n    time $O(n+m)$ where m is the expected number of edges [2]_.\\n\\n    The nodes are set to integers from $0$ to $n-1$.\\n\\n    Examples\\n    --------\\n    Generate an Erd\u0151s\u2013R\u00e9nyi random graph $G(n,c/n)$, with kernel\\n    $\\\\kappa(x,y)=c$ where $c$ is the mean expected degree.\\n\\n    >>> def integral(u, w, z):\\n    ...     return c * (z - w)\\n    >>> def root(u, w, r):\\n    ...     return r / c + w\\n    >>> c = 1\\n    >>> graph = nx.random_kernel_graph(1000, integral, root)\\n\\n    See Also\\n    --------\\n    gnp_random_graph\\n    expected_degree_graph\\n\\n    References\\n    ----------\\n    .. [1] Bollob\u00e1s, B\u00e9la,  Janson, S. and Riordan, O.\\n       \"The phase transition in inhomogeneous random graphs\",\\n       *Random Structures Algorithms*, 31, 3--122, 2007.\\n\\n    .. [2] Hagberg A, Lemons N (2015),\\n       \"Fast Generation of Sparse Random Kernel Graphs\".\\n       PLoS ONE 10(9): e0135177, 2015. doi:10.1371/journal.pone.0135177\\n    '\n    if kernel_root is None:\n        import scipy as sp\n\n        def kernel_root(y, a, r):\n\n            def my_function(b):\n                return kernel_integral(y, a, b) - r\n            return sp.optimize.brentq(my_function, a, 1)\n    graph = nx.Graph()\n    graph.add_nodes_from(range(n))\n    (i, j) = (1, 1)\n    while i < n:\n        r = -math.log(1 - seed.random())\n        if kernel_integral(i / n, j / n, 1) <= r:\n            (i, j) = (i + 1, i + 1)\n        else:\n            j = math.ceil(n * kernel_root(i / n, j / n, r))\n            graph.add_edge(i - 1, j - 1)\n    return graph"
        ]
    }
]