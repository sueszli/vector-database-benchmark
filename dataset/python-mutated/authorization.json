[
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    self.helper = ACLHelper()",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    self.helper = ACLHelper()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.helper = ACLHelper()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.helper = ACLHelper()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.helper = ACLHelper()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.helper = ACLHelper()"
        ]
    },
    {
        "func_name": "permits",
        "original": "def permits(self, context, principals, permission):\n    \"\"\"Return an instance of\n        :class:`pyramid.authorization.ACLAllowed` instance if the policy\n        permits access, return an instance of\n        :class:`pyramid.authorization.ACLDenied` if not.\"\"\"\n    return self.helper.permits(context, principals, permission)",
        "mutated": [
            "def permits(self, context, principals, permission):\n    if False:\n        i = 10\n    'Return an instance of\\n        :class:`pyramid.authorization.ACLAllowed` instance if the policy\\n        permits access, return an instance of\\n        :class:`pyramid.authorization.ACLDenied` if not.'\n    return self.helper.permits(context, principals, permission)",
            "def permits(self, context, principals, permission):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return an instance of\\n        :class:`pyramid.authorization.ACLAllowed` instance if the policy\\n        permits access, return an instance of\\n        :class:`pyramid.authorization.ACLDenied` if not.'\n    return self.helper.permits(context, principals, permission)",
            "def permits(self, context, principals, permission):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return an instance of\\n        :class:`pyramid.authorization.ACLAllowed` instance if the policy\\n        permits access, return an instance of\\n        :class:`pyramid.authorization.ACLDenied` if not.'\n    return self.helper.permits(context, principals, permission)",
            "def permits(self, context, principals, permission):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return an instance of\\n        :class:`pyramid.authorization.ACLAllowed` instance if the policy\\n        permits access, return an instance of\\n        :class:`pyramid.authorization.ACLDenied` if not.'\n    return self.helper.permits(context, principals, permission)",
            "def permits(self, context, principals, permission):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return an instance of\\n        :class:`pyramid.authorization.ACLAllowed` instance if the policy\\n        permits access, return an instance of\\n        :class:`pyramid.authorization.ACLDenied` if not.'\n    return self.helper.permits(context, principals, permission)"
        ]
    },
    {
        "func_name": "principals_allowed_by_permission",
        "original": "def principals_allowed_by_permission(self, context, permission):\n    \"\"\"Return the set of principals explicitly granted the\n        permission named ``permission`` according to the ACL directly\n        attached to the ``context`` as well as inherited ACLs based on\n        the :term:`lineage`.\"\"\"\n    return self.helper.principals_allowed_by_permission(context, permission)",
        "mutated": [
            "def principals_allowed_by_permission(self, context, permission):\n    if False:\n        i = 10\n    'Return the set of principals explicitly granted the\\n        permission named ``permission`` according to the ACL directly\\n        attached to the ``context`` as well as inherited ACLs based on\\n        the :term:`lineage`.'\n    return self.helper.principals_allowed_by_permission(context, permission)",
            "def principals_allowed_by_permission(self, context, permission):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return the set of principals explicitly granted the\\n        permission named ``permission`` according to the ACL directly\\n        attached to the ``context`` as well as inherited ACLs based on\\n        the :term:`lineage`.'\n    return self.helper.principals_allowed_by_permission(context, permission)",
            "def principals_allowed_by_permission(self, context, permission):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return the set of principals explicitly granted the\\n        permission named ``permission`` according to the ACL directly\\n        attached to the ``context`` as well as inherited ACLs based on\\n        the :term:`lineage`.'\n    return self.helper.principals_allowed_by_permission(context, permission)",
            "def principals_allowed_by_permission(self, context, permission):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return the set of principals explicitly granted the\\n        permission named ``permission`` according to the ACL directly\\n        attached to the ``context`` as well as inherited ACLs based on\\n        the :term:`lineage`.'\n    return self.helper.principals_allowed_by_permission(context, permission)",
            "def principals_allowed_by_permission(self, context, permission):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return the set of principals explicitly granted the\\n        permission named ``permission`` according to the ACL directly\\n        attached to the ``context`` as well as inherited ACLs based on\\n        the :term:`lineage`.'\n    return self.helper.principals_allowed_by_permission(context, permission)"
        ]
    },
    {
        "func_name": "permits",
        "original": "def permits(self, context, principals, permission):\n    \"\"\"Return an instance of :class:`pyramid.authorization.ACLAllowed` if\n        the ACL allows access a user with the given principals, return an\n        instance of :class:`pyramid.authorization.ACLDenied` if not.\n\n        When checking if principals are allowed, the security policy consults\n        the ``context`` for an ACL first.  If no ACL exists on the context, or\n        one does exist but the ACL does not explicitly allow or deny access for\n        any of the effective principals, consult the context's parent ACL, and\n        so on, until the lineage is exhausted or we determine that the policy\n        permits or denies.\n\n        During this processing, if any :data:`pyramid.authorization.Deny`\n        ACE is found matching any principal in ``principals``, stop\n        processing by returning an\n        :class:`pyramid.authorization.ACLDenied` instance (equals\n        ``False``) immediately.  If any\n        :data:`pyramid.authorization.Allow` ACE is found matching any\n        principal, stop processing by returning an\n        :class:`pyramid.authorization.ACLAllowed` instance (equals\n        ``True``) immediately.  If we exhaust the context's\n        :term:`lineage`, and no ACE has explicitly permitted or denied\n        access, return an instance of\n        :class:`pyramid.authorization.ACLDenied` (equals ``False``).\n\n        \"\"\"\n    acl = '<No ACL found on any object in resource lineage>'\n    for location in lineage(context):\n        try:\n            acl = location.__acl__\n        except AttributeError:\n            continue\n        if acl and callable(acl):\n            acl = acl()\n        for ace in acl:\n            (ace_action, ace_principal, ace_permissions) = ace\n            if ace_principal in principals:\n                if not is_nonstr_iter(ace_permissions):\n                    ace_permissions = [ace_permissions]\n                if permission in ace_permissions:\n                    if ace_action == Allow:\n                        return ACLAllowed(ace, acl, permission, principals, location)\n                    else:\n                        return ACLDenied(ace, acl, permission, principals, location)\n    return ACLDenied('<default deny>', acl, permission, principals, context)",
        "mutated": [
            "def permits(self, context, principals, permission):\n    if False:\n        i = 10\n    \"Return an instance of :class:`pyramid.authorization.ACLAllowed` if\\n        the ACL allows access a user with the given principals, return an\\n        instance of :class:`pyramid.authorization.ACLDenied` if not.\\n\\n        When checking if principals are allowed, the security policy consults\\n        the ``context`` for an ACL first.  If no ACL exists on the context, or\\n        one does exist but the ACL does not explicitly allow or deny access for\\n        any of the effective principals, consult the context's parent ACL, and\\n        so on, until the lineage is exhausted or we determine that the policy\\n        permits or denies.\\n\\n        During this processing, if any :data:`pyramid.authorization.Deny`\\n        ACE is found matching any principal in ``principals``, stop\\n        processing by returning an\\n        :class:`pyramid.authorization.ACLDenied` instance (equals\\n        ``False``) immediately.  If any\\n        :data:`pyramid.authorization.Allow` ACE is found matching any\\n        principal, stop processing by returning an\\n        :class:`pyramid.authorization.ACLAllowed` instance (equals\\n        ``True``) immediately.  If we exhaust the context's\\n        :term:`lineage`, and no ACE has explicitly permitted or denied\\n        access, return an instance of\\n        :class:`pyramid.authorization.ACLDenied` (equals ``False``).\\n\\n        \"\n    acl = '<No ACL found on any object in resource lineage>'\n    for location in lineage(context):\n        try:\n            acl = location.__acl__\n        except AttributeError:\n            continue\n        if acl and callable(acl):\n            acl = acl()\n        for ace in acl:\n            (ace_action, ace_principal, ace_permissions) = ace\n            if ace_principal in principals:\n                if not is_nonstr_iter(ace_permissions):\n                    ace_permissions = [ace_permissions]\n                if permission in ace_permissions:\n                    if ace_action == Allow:\n                        return ACLAllowed(ace, acl, permission, principals, location)\n                    else:\n                        return ACLDenied(ace, acl, permission, principals, location)\n    return ACLDenied('<default deny>', acl, permission, principals, context)",
            "def permits(self, context, principals, permission):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Return an instance of :class:`pyramid.authorization.ACLAllowed` if\\n        the ACL allows access a user with the given principals, return an\\n        instance of :class:`pyramid.authorization.ACLDenied` if not.\\n\\n        When checking if principals are allowed, the security policy consults\\n        the ``context`` for an ACL first.  If no ACL exists on the context, or\\n        one does exist but the ACL does not explicitly allow or deny access for\\n        any of the effective principals, consult the context's parent ACL, and\\n        so on, until the lineage is exhausted or we determine that the policy\\n        permits or denies.\\n\\n        During this processing, if any :data:`pyramid.authorization.Deny`\\n        ACE is found matching any principal in ``principals``, stop\\n        processing by returning an\\n        :class:`pyramid.authorization.ACLDenied` instance (equals\\n        ``False``) immediately.  If any\\n        :data:`pyramid.authorization.Allow` ACE is found matching any\\n        principal, stop processing by returning an\\n        :class:`pyramid.authorization.ACLAllowed` instance (equals\\n        ``True``) immediately.  If we exhaust the context's\\n        :term:`lineage`, and no ACE has explicitly permitted or denied\\n        access, return an instance of\\n        :class:`pyramid.authorization.ACLDenied` (equals ``False``).\\n\\n        \"\n    acl = '<No ACL found on any object in resource lineage>'\n    for location in lineage(context):\n        try:\n            acl = location.__acl__\n        except AttributeError:\n            continue\n        if acl and callable(acl):\n            acl = acl()\n        for ace in acl:\n            (ace_action, ace_principal, ace_permissions) = ace\n            if ace_principal in principals:\n                if not is_nonstr_iter(ace_permissions):\n                    ace_permissions = [ace_permissions]\n                if permission in ace_permissions:\n                    if ace_action == Allow:\n                        return ACLAllowed(ace, acl, permission, principals, location)\n                    else:\n                        return ACLDenied(ace, acl, permission, principals, location)\n    return ACLDenied('<default deny>', acl, permission, principals, context)",
            "def permits(self, context, principals, permission):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Return an instance of :class:`pyramid.authorization.ACLAllowed` if\\n        the ACL allows access a user with the given principals, return an\\n        instance of :class:`pyramid.authorization.ACLDenied` if not.\\n\\n        When checking if principals are allowed, the security policy consults\\n        the ``context`` for an ACL first.  If no ACL exists on the context, or\\n        one does exist but the ACL does not explicitly allow or deny access for\\n        any of the effective principals, consult the context's parent ACL, and\\n        so on, until the lineage is exhausted or we determine that the policy\\n        permits or denies.\\n\\n        During this processing, if any :data:`pyramid.authorization.Deny`\\n        ACE is found matching any principal in ``principals``, stop\\n        processing by returning an\\n        :class:`pyramid.authorization.ACLDenied` instance (equals\\n        ``False``) immediately.  If any\\n        :data:`pyramid.authorization.Allow` ACE is found matching any\\n        principal, stop processing by returning an\\n        :class:`pyramid.authorization.ACLAllowed` instance (equals\\n        ``True``) immediately.  If we exhaust the context's\\n        :term:`lineage`, and no ACE has explicitly permitted or denied\\n        access, return an instance of\\n        :class:`pyramid.authorization.ACLDenied` (equals ``False``).\\n\\n        \"\n    acl = '<No ACL found on any object in resource lineage>'\n    for location in lineage(context):\n        try:\n            acl = location.__acl__\n        except AttributeError:\n            continue\n        if acl and callable(acl):\n            acl = acl()\n        for ace in acl:\n            (ace_action, ace_principal, ace_permissions) = ace\n            if ace_principal in principals:\n                if not is_nonstr_iter(ace_permissions):\n                    ace_permissions = [ace_permissions]\n                if permission in ace_permissions:\n                    if ace_action == Allow:\n                        return ACLAllowed(ace, acl, permission, principals, location)\n                    else:\n                        return ACLDenied(ace, acl, permission, principals, location)\n    return ACLDenied('<default deny>', acl, permission, principals, context)",
            "def permits(self, context, principals, permission):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Return an instance of :class:`pyramid.authorization.ACLAllowed` if\\n        the ACL allows access a user with the given principals, return an\\n        instance of :class:`pyramid.authorization.ACLDenied` if not.\\n\\n        When checking if principals are allowed, the security policy consults\\n        the ``context`` for an ACL first.  If no ACL exists on the context, or\\n        one does exist but the ACL does not explicitly allow or deny access for\\n        any of the effective principals, consult the context's parent ACL, and\\n        so on, until the lineage is exhausted or we determine that the policy\\n        permits or denies.\\n\\n        During this processing, if any :data:`pyramid.authorization.Deny`\\n        ACE is found matching any principal in ``principals``, stop\\n        processing by returning an\\n        :class:`pyramid.authorization.ACLDenied` instance (equals\\n        ``False``) immediately.  If any\\n        :data:`pyramid.authorization.Allow` ACE is found matching any\\n        principal, stop processing by returning an\\n        :class:`pyramid.authorization.ACLAllowed` instance (equals\\n        ``True``) immediately.  If we exhaust the context's\\n        :term:`lineage`, and no ACE has explicitly permitted or denied\\n        access, return an instance of\\n        :class:`pyramid.authorization.ACLDenied` (equals ``False``).\\n\\n        \"\n    acl = '<No ACL found on any object in resource lineage>'\n    for location in lineage(context):\n        try:\n            acl = location.__acl__\n        except AttributeError:\n            continue\n        if acl and callable(acl):\n            acl = acl()\n        for ace in acl:\n            (ace_action, ace_principal, ace_permissions) = ace\n            if ace_principal in principals:\n                if not is_nonstr_iter(ace_permissions):\n                    ace_permissions = [ace_permissions]\n                if permission in ace_permissions:\n                    if ace_action == Allow:\n                        return ACLAllowed(ace, acl, permission, principals, location)\n                    else:\n                        return ACLDenied(ace, acl, permission, principals, location)\n    return ACLDenied('<default deny>', acl, permission, principals, context)",
            "def permits(self, context, principals, permission):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Return an instance of :class:`pyramid.authorization.ACLAllowed` if\\n        the ACL allows access a user with the given principals, return an\\n        instance of :class:`pyramid.authorization.ACLDenied` if not.\\n\\n        When checking if principals are allowed, the security policy consults\\n        the ``context`` for an ACL first.  If no ACL exists on the context, or\\n        one does exist but the ACL does not explicitly allow or deny access for\\n        any of the effective principals, consult the context's parent ACL, and\\n        so on, until the lineage is exhausted or we determine that the policy\\n        permits or denies.\\n\\n        During this processing, if any :data:`pyramid.authorization.Deny`\\n        ACE is found matching any principal in ``principals``, stop\\n        processing by returning an\\n        :class:`pyramid.authorization.ACLDenied` instance (equals\\n        ``False``) immediately.  If any\\n        :data:`pyramid.authorization.Allow` ACE is found matching any\\n        principal, stop processing by returning an\\n        :class:`pyramid.authorization.ACLAllowed` instance (equals\\n        ``True``) immediately.  If we exhaust the context's\\n        :term:`lineage`, and no ACE has explicitly permitted or denied\\n        access, return an instance of\\n        :class:`pyramid.authorization.ACLDenied` (equals ``False``).\\n\\n        \"\n    acl = '<No ACL found on any object in resource lineage>'\n    for location in lineage(context):\n        try:\n            acl = location.__acl__\n        except AttributeError:\n            continue\n        if acl and callable(acl):\n            acl = acl()\n        for ace in acl:\n            (ace_action, ace_principal, ace_permissions) = ace\n            if ace_principal in principals:\n                if not is_nonstr_iter(ace_permissions):\n                    ace_permissions = [ace_permissions]\n                if permission in ace_permissions:\n                    if ace_action == Allow:\n                        return ACLAllowed(ace, acl, permission, principals, location)\n                    else:\n                        return ACLDenied(ace, acl, permission, principals, location)\n    return ACLDenied('<default deny>', acl, permission, principals, context)"
        ]
    },
    {
        "func_name": "principals_allowed_by_permission",
        "original": "def principals_allowed_by_permission(self, context, permission):\n    \"\"\"Return the set of principals explicitly granted the permission\n        named ``permission`` according to the ACL directly attached to the\n        ``context`` as well as inherited ACLs based on the :term:`lineage`.\n\n        When computing principals allowed by a permission, we compute the set\n        of principals that are explicitly granted the ``permission`` in the\n        provided ``context``.  We do this by walking 'up' the object graph\n        *from the root* to the context.  During this walking process, if we\n        find an explicit :data:`pyramid.authorization.Allow` ACE for a\n        principal that matches the ``permission``, the principal is included in\n        the allow list.  However, if later in the walking process that\n        principal is mentioned in any :data:`pyramid.authorization.Deny` ACE\n        for the permission, the principal is removed from the allow list.  If\n        a :data:`pyramid.authorization.Deny` to the principal\n        :data:`pyramid.authorization.Everyone` is encountered during the\n        walking process that matches the ``permission``, the allow list is\n        cleared for all principals encountered in previous ACLs.  The walking\n        process ends after we've processed the any ACL directly attached to\n        ``context``; a set of principals is returned.\n\n        \"\"\"\n    allowed = set()\n    for location in reversed(list(lineage(context))):\n        try:\n            acl = location.__acl__\n        except AttributeError:\n            continue\n        allowed_here = set()\n        denied_here = set()\n        if acl and callable(acl):\n            acl = acl()\n        for (ace_action, ace_principal, ace_permissions) in acl:\n            if not is_nonstr_iter(ace_permissions):\n                ace_permissions = [ace_permissions]\n            if ace_action == Allow and permission in ace_permissions:\n                if ace_principal not in denied_here:\n                    allowed_here.add(ace_principal)\n            if ace_action == Deny and permission in ace_permissions:\n                denied_here.add(ace_principal)\n                if ace_principal == Everyone:\n                    allowed = set()\n                    break\n                elif ace_principal in allowed:\n                    allowed.remove(ace_principal)\n        allowed.update(allowed_here)\n    return allowed",
        "mutated": [
            "def principals_allowed_by_permission(self, context, permission):\n    if False:\n        i = 10\n    \"Return the set of principals explicitly granted the permission\\n        named ``permission`` according to the ACL directly attached to the\\n        ``context`` as well as inherited ACLs based on the :term:`lineage`.\\n\\n        When computing principals allowed by a permission, we compute the set\\n        of principals that are explicitly granted the ``permission`` in the\\n        provided ``context``.  We do this by walking 'up' the object graph\\n        *from the root* to the context.  During this walking process, if we\\n        find an explicit :data:`pyramid.authorization.Allow` ACE for a\\n        principal that matches the ``permission``, the principal is included in\\n        the allow list.  However, if later in the walking process that\\n        principal is mentioned in any :data:`pyramid.authorization.Deny` ACE\\n        for the permission, the principal is removed from the allow list.  If\\n        a :data:`pyramid.authorization.Deny` to the principal\\n        :data:`pyramid.authorization.Everyone` is encountered during the\\n        walking process that matches the ``permission``, the allow list is\\n        cleared for all principals encountered in previous ACLs.  The walking\\n        process ends after we've processed the any ACL directly attached to\\n        ``context``; a set of principals is returned.\\n\\n        \"\n    allowed = set()\n    for location in reversed(list(lineage(context))):\n        try:\n            acl = location.__acl__\n        except AttributeError:\n            continue\n        allowed_here = set()\n        denied_here = set()\n        if acl and callable(acl):\n            acl = acl()\n        for (ace_action, ace_principal, ace_permissions) in acl:\n            if not is_nonstr_iter(ace_permissions):\n                ace_permissions = [ace_permissions]\n            if ace_action == Allow and permission in ace_permissions:\n                if ace_principal not in denied_here:\n                    allowed_here.add(ace_principal)\n            if ace_action == Deny and permission in ace_permissions:\n                denied_here.add(ace_principal)\n                if ace_principal == Everyone:\n                    allowed = set()\n                    break\n                elif ace_principal in allowed:\n                    allowed.remove(ace_principal)\n        allowed.update(allowed_here)\n    return allowed",
            "def principals_allowed_by_permission(self, context, permission):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Return the set of principals explicitly granted the permission\\n        named ``permission`` according to the ACL directly attached to the\\n        ``context`` as well as inherited ACLs based on the :term:`lineage`.\\n\\n        When computing principals allowed by a permission, we compute the set\\n        of principals that are explicitly granted the ``permission`` in the\\n        provided ``context``.  We do this by walking 'up' the object graph\\n        *from the root* to the context.  During this walking process, if we\\n        find an explicit :data:`pyramid.authorization.Allow` ACE for a\\n        principal that matches the ``permission``, the principal is included in\\n        the allow list.  However, if later in the walking process that\\n        principal is mentioned in any :data:`pyramid.authorization.Deny` ACE\\n        for the permission, the principal is removed from the allow list.  If\\n        a :data:`pyramid.authorization.Deny` to the principal\\n        :data:`pyramid.authorization.Everyone` is encountered during the\\n        walking process that matches the ``permission``, the allow list is\\n        cleared for all principals encountered in previous ACLs.  The walking\\n        process ends after we've processed the any ACL directly attached to\\n        ``context``; a set of principals is returned.\\n\\n        \"\n    allowed = set()\n    for location in reversed(list(lineage(context))):\n        try:\n            acl = location.__acl__\n        except AttributeError:\n            continue\n        allowed_here = set()\n        denied_here = set()\n        if acl and callable(acl):\n            acl = acl()\n        for (ace_action, ace_principal, ace_permissions) in acl:\n            if not is_nonstr_iter(ace_permissions):\n                ace_permissions = [ace_permissions]\n            if ace_action == Allow and permission in ace_permissions:\n                if ace_principal not in denied_here:\n                    allowed_here.add(ace_principal)\n            if ace_action == Deny and permission in ace_permissions:\n                denied_here.add(ace_principal)\n                if ace_principal == Everyone:\n                    allowed = set()\n                    break\n                elif ace_principal in allowed:\n                    allowed.remove(ace_principal)\n        allowed.update(allowed_here)\n    return allowed",
            "def principals_allowed_by_permission(self, context, permission):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Return the set of principals explicitly granted the permission\\n        named ``permission`` according to the ACL directly attached to the\\n        ``context`` as well as inherited ACLs based on the :term:`lineage`.\\n\\n        When computing principals allowed by a permission, we compute the set\\n        of principals that are explicitly granted the ``permission`` in the\\n        provided ``context``.  We do this by walking 'up' the object graph\\n        *from the root* to the context.  During this walking process, if we\\n        find an explicit :data:`pyramid.authorization.Allow` ACE for a\\n        principal that matches the ``permission``, the principal is included in\\n        the allow list.  However, if later in the walking process that\\n        principal is mentioned in any :data:`pyramid.authorization.Deny` ACE\\n        for the permission, the principal is removed from the allow list.  If\\n        a :data:`pyramid.authorization.Deny` to the principal\\n        :data:`pyramid.authorization.Everyone` is encountered during the\\n        walking process that matches the ``permission``, the allow list is\\n        cleared for all principals encountered in previous ACLs.  The walking\\n        process ends after we've processed the any ACL directly attached to\\n        ``context``; a set of principals is returned.\\n\\n        \"\n    allowed = set()\n    for location in reversed(list(lineage(context))):\n        try:\n            acl = location.__acl__\n        except AttributeError:\n            continue\n        allowed_here = set()\n        denied_here = set()\n        if acl and callable(acl):\n            acl = acl()\n        for (ace_action, ace_principal, ace_permissions) in acl:\n            if not is_nonstr_iter(ace_permissions):\n                ace_permissions = [ace_permissions]\n            if ace_action == Allow and permission in ace_permissions:\n                if ace_principal not in denied_here:\n                    allowed_here.add(ace_principal)\n            if ace_action == Deny and permission in ace_permissions:\n                denied_here.add(ace_principal)\n                if ace_principal == Everyone:\n                    allowed = set()\n                    break\n                elif ace_principal in allowed:\n                    allowed.remove(ace_principal)\n        allowed.update(allowed_here)\n    return allowed",
            "def principals_allowed_by_permission(self, context, permission):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Return the set of principals explicitly granted the permission\\n        named ``permission`` according to the ACL directly attached to the\\n        ``context`` as well as inherited ACLs based on the :term:`lineage`.\\n\\n        When computing principals allowed by a permission, we compute the set\\n        of principals that are explicitly granted the ``permission`` in the\\n        provided ``context``.  We do this by walking 'up' the object graph\\n        *from the root* to the context.  During this walking process, if we\\n        find an explicit :data:`pyramid.authorization.Allow` ACE for a\\n        principal that matches the ``permission``, the principal is included in\\n        the allow list.  However, if later in the walking process that\\n        principal is mentioned in any :data:`pyramid.authorization.Deny` ACE\\n        for the permission, the principal is removed from the allow list.  If\\n        a :data:`pyramid.authorization.Deny` to the principal\\n        :data:`pyramid.authorization.Everyone` is encountered during the\\n        walking process that matches the ``permission``, the allow list is\\n        cleared for all principals encountered in previous ACLs.  The walking\\n        process ends after we've processed the any ACL directly attached to\\n        ``context``; a set of principals is returned.\\n\\n        \"\n    allowed = set()\n    for location in reversed(list(lineage(context))):\n        try:\n            acl = location.__acl__\n        except AttributeError:\n            continue\n        allowed_here = set()\n        denied_here = set()\n        if acl and callable(acl):\n            acl = acl()\n        for (ace_action, ace_principal, ace_permissions) in acl:\n            if not is_nonstr_iter(ace_permissions):\n                ace_permissions = [ace_permissions]\n            if ace_action == Allow and permission in ace_permissions:\n                if ace_principal not in denied_here:\n                    allowed_here.add(ace_principal)\n            if ace_action == Deny and permission in ace_permissions:\n                denied_here.add(ace_principal)\n                if ace_principal == Everyone:\n                    allowed = set()\n                    break\n                elif ace_principal in allowed:\n                    allowed.remove(ace_principal)\n        allowed.update(allowed_here)\n    return allowed",
            "def principals_allowed_by_permission(self, context, permission):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Return the set of principals explicitly granted the permission\\n        named ``permission`` according to the ACL directly attached to the\\n        ``context`` as well as inherited ACLs based on the :term:`lineage`.\\n\\n        When computing principals allowed by a permission, we compute the set\\n        of principals that are explicitly granted the ``permission`` in the\\n        provided ``context``.  We do this by walking 'up' the object graph\\n        *from the root* to the context.  During this walking process, if we\\n        find an explicit :data:`pyramid.authorization.Allow` ACE for a\\n        principal that matches the ``permission``, the principal is included in\\n        the allow list.  However, if later in the walking process that\\n        principal is mentioned in any :data:`pyramid.authorization.Deny` ACE\\n        for the permission, the principal is removed from the allow list.  If\\n        a :data:`pyramid.authorization.Deny` to the principal\\n        :data:`pyramid.authorization.Everyone` is encountered during the\\n        walking process that matches the ``permission``, the allow list is\\n        cleared for all principals encountered in previous ACLs.  The walking\\n        process ends after we've processed the any ACL directly attached to\\n        ``context``; a set of principals is returned.\\n\\n        \"\n    allowed = set()\n    for location in reversed(list(lineage(context))):\n        try:\n            acl = location.__acl__\n        except AttributeError:\n            continue\n        allowed_here = set()\n        denied_here = set()\n        if acl and callable(acl):\n            acl = acl()\n        for (ace_action, ace_principal, ace_permissions) in acl:\n            if not is_nonstr_iter(ace_permissions):\n                ace_permissions = [ace_permissions]\n            if ace_action == Allow and permission in ace_permissions:\n                if ace_principal not in denied_here:\n                    allowed_here.add(ace_principal)\n            if ace_action == Deny and permission in ace_permissions:\n                denied_here.add(ace_principal)\n                if ace_principal == Everyone:\n                    allowed = set()\n                    break\n                elif ace_principal in allowed:\n                    allowed.remove(ace_principal)\n        allowed.update(allowed_here)\n    return allowed"
        ]
    }
]