[
    {
        "func_name": "test_gray_synth",
        "original": "@ddt.data(synth_cnot_phase_aam, graysynth)\ndef test_gray_synth(self, synth_func):\n    \"\"\"Test synthesis of a small parity network via gray_synth.\n\n        The algorithm should take the following matrix as an input:\n        S =\n        [[0, 1, 1, 0, 1, 1],\n         [0, 1, 1, 0, 1, 0],\n         [0, 0, 0, 1, 1, 0],\n         [1, 0, 0, 1, 1, 1],\n         [0, 1, 0, 0, 1, 0],\n         [0, 1, 0, 0, 1, 0]]\n\n        Along with some rotation angles:\n        ['s', 't', 'z', 's', 't', 't'])\n\n        which together specify the Fourier expansion in the sum-over-paths representation\n        of a quantum circuit.\n\n        And should return the following circuit (or an equivalent one):\n                          \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\n        q_0: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 X \u251c\u2524 X \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 X \u251c\u2524 Z \u251c\u2524 X \u251c\n                          \u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\n        q_1: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\n                            \u2502    \u2502              \u2502    \u2502    \u2502         \u2502         \u2502    \u2502\n        q_2: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510  \u2502                   \u2502    \u2502         \u2502  \u250c\u2500\u2534\u2500\u2510  \u2502    \u2502\n        q_3: |0>\u2524 S \u251c\u2524 X \u251c\u2524 S \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518                      \u2502    \u2502            \u2514\u2500\u2500\u2500\u2518  \u2502    \u2502\n        q_4: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                                          \u2502                        \u2502\n        q_5: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n        \"\"\"\n    cnots = [[0, 1, 1, 0, 1, 1], [0, 1, 1, 0, 1, 0], [0, 0, 0, 1, 1, 0], [1, 0, 0, 1, 1, 1], [0, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0]]\n    angles = ['s', 't', 'z', 's', 't', 't']\n    c_gray = synth_func(cnots, angles)\n    unitary_gray = UnitaryGate(Operator(c_gray))\n    q = QuantumRegister(6, 'q')\n    c_compare = QuantumCircuit(q)\n    c_compare.s(q[3])\n    c_compare.cx(q[2], q[3])\n    c_compare.s(q[3])\n    c_compare.cx(q[2], q[0])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[1], q[0])\n    c_compare.cx(q[2], q[0])\n    c_compare.cx(q[4], q[0])\n    c_compare.cx(q[5], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[2], q[3])\n    c_compare.cx(q[4], q[0])\n    c_compare.cx(q[5], q[0])\n    c_compare.z(q[0])\n    c_compare.cx(q[1], q[0])\n    unitary_compare = UnitaryGate(Operator(c_compare))\n    self.assertEqual(unitary_gray, unitary_compare)",
        "mutated": [
            "@ddt.data(synth_cnot_phase_aam, graysynth)\ndef test_gray_synth(self, synth_func):\n    if False:\n        i = 10\n    \"Test synthesis of a small parity network via gray_synth.\\n\\n        The algorithm should take the following matrix as an input:\\n        S =\\n        [[0, 1, 1, 0, 1, 1],\\n         [0, 1, 1, 0, 1, 0],\\n         [0, 0, 0, 1, 1, 0],\\n         [1, 0, 0, 1, 1, 1],\\n         [0, 1, 0, 0, 1, 0],\\n         [0, 1, 0, 0, 1, 0]]\\n\\n        Along with some rotation angles:\\n        ['s', 't', 'z', 's', 't', 't'])\\n\\n        which together specify the Fourier expansion in the sum-over-paths representation\\n        of a quantum circuit.\\n\\n        And should return the following circuit (or an equivalent one):\\n                          \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\\n        q_0: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 X \u251c\u2524 X \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 X \u251c\u2524 Z \u251c\u2524 X \u251c\\n                          \u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\\n        q_1: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\\n                            \u2502    \u2502              \u2502    \u2502    \u2502         \u2502         \u2502    \u2502\\n        q_2: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n                \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510  \u2502                   \u2502    \u2502         \u2502  \u250c\u2500\u2534\u2500\u2510  \u2502    \u2502\\n        q_3: |0>\u2524 S \u251c\u2524 X \u251c\u2524 S \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n                \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518                      \u2502    \u2502            \u2514\u2500\u2500\u2500\u2518  \u2502    \u2502\\n        q_4: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n                                                          \u2502                        \u2502\\n        q_5: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n\\n        \"\n    cnots = [[0, 1, 1, 0, 1, 1], [0, 1, 1, 0, 1, 0], [0, 0, 0, 1, 1, 0], [1, 0, 0, 1, 1, 1], [0, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0]]\n    angles = ['s', 't', 'z', 's', 't', 't']\n    c_gray = synth_func(cnots, angles)\n    unitary_gray = UnitaryGate(Operator(c_gray))\n    q = QuantumRegister(6, 'q')\n    c_compare = QuantumCircuit(q)\n    c_compare.s(q[3])\n    c_compare.cx(q[2], q[3])\n    c_compare.s(q[3])\n    c_compare.cx(q[2], q[0])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[1], q[0])\n    c_compare.cx(q[2], q[0])\n    c_compare.cx(q[4], q[0])\n    c_compare.cx(q[5], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[2], q[3])\n    c_compare.cx(q[4], q[0])\n    c_compare.cx(q[5], q[0])\n    c_compare.z(q[0])\n    c_compare.cx(q[1], q[0])\n    unitary_compare = UnitaryGate(Operator(c_compare))\n    self.assertEqual(unitary_gray, unitary_compare)",
            "@ddt.data(synth_cnot_phase_aam, graysynth)\ndef test_gray_synth(self, synth_func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Test synthesis of a small parity network via gray_synth.\\n\\n        The algorithm should take the following matrix as an input:\\n        S =\\n        [[0, 1, 1, 0, 1, 1],\\n         [0, 1, 1, 0, 1, 0],\\n         [0, 0, 0, 1, 1, 0],\\n         [1, 0, 0, 1, 1, 1],\\n         [0, 1, 0, 0, 1, 0],\\n         [0, 1, 0, 0, 1, 0]]\\n\\n        Along with some rotation angles:\\n        ['s', 't', 'z', 's', 't', 't'])\\n\\n        which together specify the Fourier expansion in the sum-over-paths representation\\n        of a quantum circuit.\\n\\n        And should return the following circuit (or an equivalent one):\\n                          \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\\n        q_0: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 X \u251c\u2524 X \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 X \u251c\u2524 Z \u251c\u2524 X \u251c\\n                          \u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\\n        q_1: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\\n                            \u2502    \u2502              \u2502    \u2502    \u2502         \u2502         \u2502    \u2502\\n        q_2: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n                \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510  \u2502                   \u2502    \u2502         \u2502  \u250c\u2500\u2534\u2500\u2510  \u2502    \u2502\\n        q_3: |0>\u2524 S \u251c\u2524 X \u251c\u2524 S \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n                \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518                      \u2502    \u2502            \u2514\u2500\u2500\u2500\u2518  \u2502    \u2502\\n        q_4: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n                                                          \u2502                        \u2502\\n        q_5: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n\\n        \"\n    cnots = [[0, 1, 1, 0, 1, 1], [0, 1, 1, 0, 1, 0], [0, 0, 0, 1, 1, 0], [1, 0, 0, 1, 1, 1], [0, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0]]\n    angles = ['s', 't', 'z', 's', 't', 't']\n    c_gray = synth_func(cnots, angles)\n    unitary_gray = UnitaryGate(Operator(c_gray))\n    q = QuantumRegister(6, 'q')\n    c_compare = QuantumCircuit(q)\n    c_compare.s(q[3])\n    c_compare.cx(q[2], q[3])\n    c_compare.s(q[3])\n    c_compare.cx(q[2], q[0])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[1], q[0])\n    c_compare.cx(q[2], q[0])\n    c_compare.cx(q[4], q[0])\n    c_compare.cx(q[5], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[2], q[3])\n    c_compare.cx(q[4], q[0])\n    c_compare.cx(q[5], q[0])\n    c_compare.z(q[0])\n    c_compare.cx(q[1], q[0])\n    unitary_compare = UnitaryGate(Operator(c_compare))\n    self.assertEqual(unitary_gray, unitary_compare)",
            "@ddt.data(synth_cnot_phase_aam, graysynth)\ndef test_gray_synth(self, synth_func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Test synthesis of a small parity network via gray_synth.\\n\\n        The algorithm should take the following matrix as an input:\\n        S =\\n        [[0, 1, 1, 0, 1, 1],\\n         [0, 1, 1, 0, 1, 0],\\n         [0, 0, 0, 1, 1, 0],\\n         [1, 0, 0, 1, 1, 1],\\n         [0, 1, 0, 0, 1, 0],\\n         [0, 1, 0, 0, 1, 0]]\\n\\n        Along with some rotation angles:\\n        ['s', 't', 'z', 's', 't', 't'])\\n\\n        which together specify the Fourier expansion in the sum-over-paths representation\\n        of a quantum circuit.\\n\\n        And should return the following circuit (or an equivalent one):\\n                          \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\\n        q_0: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 X \u251c\u2524 X \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 X \u251c\u2524 Z \u251c\u2524 X \u251c\\n                          \u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\\n        q_1: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\\n                            \u2502    \u2502              \u2502    \u2502    \u2502         \u2502         \u2502    \u2502\\n        q_2: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n                \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510  \u2502                   \u2502    \u2502         \u2502  \u250c\u2500\u2534\u2500\u2510  \u2502    \u2502\\n        q_3: |0>\u2524 S \u251c\u2524 X \u251c\u2524 S \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n                \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518                      \u2502    \u2502            \u2514\u2500\u2500\u2500\u2518  \u2502    \u2502\\n        q_4: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n                                                          \u2502                        \u2502\\n        q_5: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n\\n        \"\n    cnots = [[0, 1, 1, 0, 1, 1], [0, 1, 1, 0, 1, 0], [0, 0, 0, 1, 1, 0], [1, 0, 0, 1, 1, 1], [0, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0]]\n    angles = ['s', 't', 'z', 's', 't', 't']\n    c_gray = synth_func(cnots, angles)\n    unitary_gray = UnitaryGate(Operator(c_gray))\n    q = QuantumRegister(6, 'q')\n    c_compare = QuantumCircuit(q)\n    c_compare.s(q[3])\n    c_compare.cx(q[2], q[3])\n    c_compare.s(q[3])\n    c_compare.cx(q[2], q[0])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[1], q[0])\n    c_compare.cx(q[2], q[0])\n    c_compare.cx(q[4], q[0])\n    c_compare.cx(q[5], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[2], q[3])\n    c_compare.cx(q[4], q[0])\n    c_compare.cx(q[5], q[0])\n    c_compare.z(q[0])\n    c_compare.cx(q[1], q[0])\n    unitary_compare = UnitaryGate(Operator(c_compare))\n    self.assertEqual(unitary_gray, unitary_compare)",
            "@ddt.data(synth_cnot_phase_aam, graysynth)\ndef test_gray_synth(self, synth_func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Test synthesis of a small parity network via gray_synth.\\n\\n        The algorithm should take the following matrix as an input:\\n        S =\\n        [[0, 1, 1, 0, 1, 1],\\n         [0, 1, 1, 0, 1, 0],\\n         [0, 0, 0, 1, 1, 0],\\n         [1, 0, 0, 1, 1, 1],\\n         [0, 1, 0, 0, 1, 0],\\n         [0, 1, 0, 0, 1, 0]]\\n\\n        Along with some rotation angles:\\n        ['s', 't', 'z', 's', 't', 't'])\\n\\n        which together specify the Fourier expansion in the sum-over-paths representation\\n        of a quantum circuit.\\n\\n        And should return the following circuit (or an equivalent one):\\n                          \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\\n        q_0: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 X \u251c\u2524 X \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 X \u251c\u2524 Z \u251c\u2524 X \u251c\\n                          \u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\\n        q_1: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\\n                            \u2502    \u2502              \u2502    \u2502    \u2502         \u2502         \u2502    \u2502\\n        q_2: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n                \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510  \u2502                   \u2502    \u2502         \u2502  \u250c\u2500\u2534\u2500\u2510  \u2502    \u2502\\n        q_3: |0>\u2524 S \u251c\u2524 X \u251c\u2524 S \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n                \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518                      \u2502    \u2502            \u2514\u2500\u2500\u2500\u2518  \u2502    \u2502\\n        q_4: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n                                                          \u2502                        \u2502\\n        q_5: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n\\n        \"\n    cnots = [[0, 1, 1, 0, 1, 1], [0, 1, 1, 0, 1, 0], [0, 0, 0, 1, 1, 0], [1, 0, 0, 1, 1, 1], [0, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0]]\n    angles = ['s', 't', 'z', 's', 't', 't']\n    c_gray = synth_func(cnots, angles)\n    unitary_gray = UnitaryGate(Operator(c_gray))\n    q = QuantumRegister(6, 'q')\n    c_compare = QuantumCircuit(q)\n    c_compare.s(q[3])\n    c_compare.cx(q[2], q[3])\n    c_compare.s(q[3])\n    c_compare.cx(q[2], q[0])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[1], q[0])\n    c_compare.cx(q[2], q[0])\n    c_compare.cx(q[4], q[0])\n    c_compare.cx(q[5], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[2], q[3])\n    c_compare.cx(q[4], q[0])\n    c_compare.cx(q[5], q[0])\n    c_compare.z(q[0])\n    c_compare.cx(q[1], q[0])\n    unitary_compare = UnitaryGate(Operator(c_compare))\n    self.assertEqual(unitary_gray, unitary_compare)",
            "@ddt.data(synth_cnot_phase_aam, graysynth)\ndef test_gray_synth(self, synth_func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Test synthesis of a small parity network via gray_synth.\\n\\n        The algorithm should take the following matrix as an input:\\n        S =\\n        [[0, 1, 1, 0, 1, 1],\\n         [0, 1, 1, 0, 1, 0],\\n         [0, 0, 0, 1, 1, 0],\\n         [1, 0, 0, 1, 1, 1],\\n         [0, 1, 0, 0, 1, 0],\\n         [0, 1, 0, 0, 1, 0]]\\n\\n        Along with some rotation angles:\\n        ['s', 't', 'z', 's', 't', 't'])\\n\\n        which together specify the Fourier expansion in the sum-over-paths representation\\n        of a quantum circuit.\\n\\n        And should return the following circuit (or an equivalent one):\\n                          \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\\n        q_0: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 X \u251c\u2524 X \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 X \u251c\u2524 Z \u251c\u2524 X \u251c\\n                          \u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\\n        q_1: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\\n                            \u2502    \u2502              \u2502    \u2502    \u2502         \u2502         \u2502    \u2502\\n        q_2: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n                \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510  \u2502                   \u2502    \u2502         \u2502  \u250c\u2500\u2534\u2500\u2510  \u2502    \u2502\\n        q_3: |0>\u2524 S \u251c\u2524 X \u251c\u2524 S \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n                \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518                      \u2502    \u2502            \u2514\u2500\u2500\u2500\u2518  \u2502    \u2502\\n        q_4: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n                                                          \u2502                        \u2502\\n        q_5: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n\\n        \"\n    cnots = [[0, 1, 1, 0, 1, 1], [0, 1, 1, 0, 1, 0], [0, 0, 0, 1, 1, 0], [1, 0, 0, 1, 1, 1], [0, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0]]\n    angles = ['s', 't', 'z', 's', 't', 't']\n    c_gray = synth_func(cnots, angles)\n    unitary_gray = UnitaryGate(Operator(c_gray))\n    q = QuantumRegister(6, 'q')\n    c_compare = QuantumCircuit(q)\n    c_compare.s(q[3])\n    c_compare.cx(q[2], q[3])\n    c_compare.s(q[3])\n    c_compare.cx(q[2], q[0])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[1], q[0])\n    c_compare.cx(q[2], q[0])\n    c_compare.cx(q[4], q[0])\n    c_compare.cx(q[5], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[2], q[3])\n    c_compare.cx(q[4], q[0])\n    c_compare.cx(q[5], q[0])\n    c_compare.z(q[0])\n    c_compare.cx(q[1], q[0])\n    unitary_compare = UnitaryGate(Operator(c_compare))\n    self.assertEqual(unitary_gray, unitary_compare)"
        ]
    },
    {
        "func_name": "test_paper_example",
        "original": "@ddt.data(synth_cnot_phase_aam, graysynth)\ndef test_paper_example(self, synth_func):\n    \"\"\"Test synthesis of a diagonal operator from the paper.\n\n        The diagonal operator in Example 4.2\n            U|x> = e^(2.pi.i.f(x))|x>,\n        where\n            f(x) = 1/8*(x1^x2 + x0 + x0^x3 + x0^x1^x2 + x0^x1^x3 + x0^x1)\n\n        The algorithm should take the following matrix as an input:\n        S = [[0, 1, 1, 1, 1, 1],\n             [1, 0, 0, 1, 1, 1],\n             [1, 0, 0, 1, 0, 0],\n             [0, 0, 1, 0, 1, 0]]\n\n        and only T gates as phase rotations,\n\n        And should return the following circuit (or an equivalent one):\n                \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\n        q_0: |0>\u2524 T \u251c\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2524 T \u251c\u2524 X \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 T \u251c\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2524 X \u251c\n                \u251c\u2500\u2500\u2500\u2524\u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\n        q_1: |0>\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2524 T \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\n                \u2514\u2500\u252c\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2518            \u2502         \u2502         \u2502       \u2514\u2500\u252c\u2500\u2518       \u2502\n        q_2: |0>\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\n                       \u2502                   \u2502                   \u2502                   \u2502\n        q_3: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\n        \"\"\"\n    cnots = [[0, 1, 1, 1, 1, 1], [1, 0, 0, 1, 1, 1], [1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0]]\n    angles = ['t'] * 6\n    c_gray = synth_func(cnots, angles)\n    unitary_gray = UnitaryGate(Operator(c_gray))\n    q = QuantumRegister(4, 'q')\n    c_compare = QuantumCircuit(q)\n    c_compare.t(q[0])\n    c_compare.cx(q[2], q[1])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.t(q[1])\n    c_compare.cx(q[1], q[0])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[2], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[2], q[1])\n    c_compare.cx(q[1], q[0])\n    c_compare.cx(q[3], q[0])\n    unitary_compare = UnitaryGate(Operator(c_compare))\n    self.assertEqual(unitary_gray, unitary_compare)",
        "mutated": [
            "@ddt.data(synth_cnot_phase_aam, graysynth)\ndef test_paper_example(self, synth_func):\n    if False:\n        i = 10\n    'Test synthesis of a diagonal operator from the paper.\\n\\n        The diagonal operator in Example 4.2\\n            U|x> = e^(2.pi.i.f(x))|x>,\\n        where\\n            f(x) = 1/8*(x1^x2 + x0 + x0^x3 + x0^x1^x2 + x0^x1^x3 + x0^x1)\\n\\n        The algorithm should take the following matrix as an input:\\n        S = [[0, 1, 1, 1, 1, 1],\\n             [1, 0, 0, 1, 1, 1],\\n             [1, 0, 0, 1, 0, 0],\\n             [0, 0, 1, 0, 1, 0]]\\n\\n        and only T gates as phase rotations,\\n\\n        And should return the following circuit (or an equivalent one):\\n                \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\\n        q_0: |0>\u2524 T \u251c\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2524 T \u251c\u2524 X \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 T \u251c\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2524 X \u251c\\n                \u251c\u2500\u2500\u2500\u2524\u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\\n        q_1: |0>\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2524 T \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\\n                \u2514\u2500\u252c\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2518            \u2502         \u2502         \u2502       \u2514\u2500\u252c\u2500\u2518       \u2502\\n        q_2: |0>\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\\n                       \u2502                   \u2502                   \u2502                   \u2502\\n        q_3: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\\n        '\n    cnots = [[0, 1, 1, 1, 1, 1], [1, 0, 0, 1, 1, 1], [1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0]]\n    angles = ['t'] * 6\n    c_gray = synth_func(cnots, angles)\n    unitary_gray = UnitaryGate(Operator(c_gray))\n    q = QuantumRegister(4, 'q')\n    c_compare = QuantumCircuit(q)\n    c_compare.t(q[0])\n    c_compare.cx(q[2], q[1])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.t(q[1])\n    c_compare.cx(q[1], q[0])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[2], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[2], q[1])\n    c_compare.cx(q[1], q[0])\n    c_compare.cx(q[3], q[0])\n    unitary_compare = UnitaryGate(Operator(c_compare))\n    self.assertEqual(unitary_gray, unitary_compare)",
            "@ddt.data(synth_cnot_phase_aam, graysynth)\ndef test_paper_example(self, synth_func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test synthesis of a diagonal operator from the paper.\\n\\n        The diagonal operator in Example 4.2\\n            U|x> = e^(2.pi.i.f(x))|x>,\\n        where\\n            f(x) = 1/8*(x1^x2 + x0 + x0^x3 + x0^x1^x2 + x0^x1^x3 + x0^x1)\\n\\n        The algorithm should take the following matrix as an input:\\n        S = [[0, 1, 1, 1, 1, 1],\\n             [1, 0, 0, 1, 1, 1],\\n             [1, 0, 0, 1, 0, 0],\\n             [0, 0, 1, 0, 1, 0]]\\n\\n        and only T gates as phase rotations,\\n\\n        And should return the following circuit (or an equivalent one):\\n                \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\\n        q_0: |0>\u2524 T \u251c\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2524 T \u251c\u2524 X \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 T \u251c\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2524 X \u251c\\n                \u251c\u2500\u2500\u2500\u2524\u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\\n        q_1: |0>\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2524 T \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\\n                \u2514\u2500\u252c\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2518            \u2502         \u2502         \u2502       \u2514\u2500\u252c\u2500\u2518       \u2502\\n        q_2: |0>\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\\n                       \u2502                   \u2502                   \u2502                   \u2502\\n        q_3: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\\n        '\n    cnots = [[0, 1, 1, 1, 1, 1], [1, 0, 0, 1, 1, 1], [1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0]]\n    angles = ['t'] * 6\n    c_gray = synth_func(cnots, angles)\n    unitary_gray = UnitaryGate(Operator(c_gray))\n    q = QuantumRegister(4, 'q')\n    c_compare = QuantumCircuit(q)\n    c_compare.t(q[0])\n    c_compare.cx(q[2], q[1])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.t(q[1])\n    c_compare.cx(q[1], q[0])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[2], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[2], q[1])\n    c_compare.cx(q[1], q[0])\n    c_compare.cx(q[3], q[0])\n    unitary_compare = UnitaryGate(Operator(c_compare))\n    self.assertEqual(unitary_gray, unitary_compare)",
            "@ddt.data(synth_cnot_phase_aam, graysynth)\ndef test_paper_example(self, synth_func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test synthesis of a diagonal operator from the paper.\\n\\n        The diagonal operator in Example 4.2\\n            U|x> = e^(2.pi.i.f(x))|x>,\\n        where\\n            f(x) = 1/8*(x1^x2 + x0 + x0^x3 + x0^x1^x2 + x0^x1^x3 + x0^x1)\\n\\n        The algorithm should take the following matrix as an input:\\n        S = [[0, 1, 1, 1, 1, 1],\\n             [1, 0, 0, 1, 1, 1],\\n             [1, 0, 0, 1, 0, 0],\\n             [0, 0, 1, 0, 1, 0]]\\n\\n        and only T gates as phase rotations,\\n\\n        And should return the following circuit (or an equivalent one):\\n                \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\\n        q_0: |0>\u2524 T \u251c\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2524 T \u251c\u2524 X \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 T \u251c\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2524 X \u251c\\n                \u251c\u2500\u2500\u2500\u2524\u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\\n        q_1: |0>\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2524 T \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\\n                \u2514\u2500\u252c\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2518            \u2502         \u2502         \u2502       \u2514\u2500\u252c\u2500\u2518       \u2502\\n        q_2: |0>\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\\n                       \u2502                   \u2502                   \u2502                   \u2502\\n        q_3: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\\n        '\n    cnots = [[0, 1, 1, 1, 1, 1], [1, 0, 0, 1, 1, 1], [1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0]]\n    angles = ['t'] * 6\n    c_gray = synth_func(cnots, angles)\n    unitary_gray = UnitaryGate(Operator(c_gray))\n    q = QuantumRegister(4, 'q')\n    c_compare = QuantumCircuit(q)\n    c_compare.t(q[0])\n    c_compare.cx(q[2], q[1])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.t(q[1])\n    c_compare.cx(q[1], q[0])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[2], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[2], q[1])\n    c_compare.cx(q[1], q[0])\n    c_compare.cx(q[3], q[0])\n    unitary_compare = UnitaryGate(Operator(c_compare))\n    self.assertEqual(unitary_gray, unitary_compare)",
            "@ddt.data(synth_cnot_phase_aam, graysynth)\ndef test_paper_example(self, synth_func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test synthesis of a diagonal operator from the paper.\\n\\n        The diagonal operator in Example 4.2\\n            U|x> = e^(2.pi.i.f(x))|x>,\\n        where\\n            f(x) = 1/8*(x1^x2 + x0 + x0^x3 + x0^x1^x2 + x0^x1^x3 + x0^x1)\\n\\n        The algorithm should take the following matrix as an input:\\n        S = [[0, 1, 1, 1, 1, 1],\\n             [1, 0, 0, 1, 1, 1],\\n             [1, 0, 0, 1, 0, 0],\\n             [0, 0, 1, 0, 1, 0]]\\n\\n        and only T gates as phase rotations,\\n\\n        And should return the following circuit (or an equivalent one):\\n                \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\\n        q_0: |0>\u2524 T \u251c\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2524 T \u251c\u2524 X \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 T \u251c\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2524 X \u251c\\n                \u251c\u2500\u2500\u2500\u2524\u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\\n        q_1: |0>\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2524 T \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\\n                \u2514\u2500\u252c\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2518            \u2502         \u2502         \u2502       \u2514\u2500\u252c\u2500\u2518       \u2502\\n        q_2: |0>\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\\n                       \u2502                   \u2502                   \u2502                   \u2502\\n        q_3: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\\n        '\n    cnots = [[0, 1, 1, 1, 1, 1], [1, 0, 0, 1, 1, 1], [1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0]]\n    angles = ['t'] * 6\n    c_gray = synth_func(cnots, angles)\n    unitary_gray = UnitaryGate(Operator(c_gray))\n    q = QuantumRegister(4, 'q')\n    c_compare = QuantumCircuit(q)\n    c_compare.t(q[0])\n    c_compare.cx(q[2], q[1])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.t(q[1])\n    c_compare.cx(q[1], q[0])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[2], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[2], q[1])\n    c_compare.cx(q[1], q[0])\n    c_compare.cx(q[3], q[0])\n    unitary_compare = UnitaryGate(Operator(c_compare))\n    self.assertEqual(unitary_gray, unitary_compare)",
            "@ddt.data(synth_cnot_phase_aam, graysynth)\ndef test_paper_example(self, synth_func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test synthesis of a diagonal operator from the paper.\\n\\n        The diagonal operator in Example 4.2\\n            U|x> = e^(2.pi.i.f(x))|x>,\\n        where\\n            f(x) = 1/8*(x1^x2 + x0 + x0^x3 + x0^x1^x2 + x0^x1^x3 + x0^x1)\\n\\n        The algorithm should take the following matrix as an input:\\n        S = [[0, 1, 1, 1, 1, 1],\\n             [1, 0, 0, 1, 1, 1],\\n             [1, 0, 0, 1, 0, 0],\\n             [0, 0, 1, 0, 1, 0]]\\n\\n        and only T gates as phase rotations,\\n\\n        And should return the following circuit (or an equivalent one):\\n                \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\\n        q_0: |0>\u2524 T \u251c\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2524 T \u251c\u2524 X \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2524 T \u251c\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2524 X \u251c\\n                \u251c\u2500\u2500\u2500\u2524\u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\\n        q_1: |0>\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2524 T \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\\n                \u2514\u2500\u252c\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2518            \u2502         \u2502         \u2502       \u2514\u2500\u252c\u2500\u2518       \u2502\\n        q_2: |0>\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\\n                       \u2502                   \u2502                   \u2502                   \u2502\\n        q_3: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\\n        '\n    cnots = [[0, 1, 1, 1, 1, 1], [1, 0, 0, 1, 1, 1], [1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0]]\n    angles = ['t'] * 6\n    c_gray = synth_func(cnots, angles)\n    unitary_gray = UnitaryGate(Operator(c_gray))\n    q = QuantumRegister(4, 'q')\n    c_compare = QuantumCircuit(q)\n    c_compare.t(q[0])\n    c_compare.cx(q[2], q[1])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.t(q[1])\n    c_compare.cx(q[1], q[0])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[2], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[3], q[0])\n    c_compare.t(q[0])\n    c_compare.cx(q[2], q[1])\n    c_compare.cx(q[1], q[0])\n    c_compare.cx(q[3], q[0])\n    unitary_compare = UnitaryGate(Operator(c_compare))\n    self.assertEqual(unitary_gray, unitary_compare)"
        ]
    },
    {
        "func_name": "test_ccz",
        "original": "@ddt.data(synth_cnot_phase_aam, graysynth)\ndef test_ccz(self, synth_func):\n    \"\"\"Test synthesis of the doubly-controlled Z gate.\n\n        The diagonal operator in Example 4.3\n            U|x> = e^(2.pi.i.f(x))|x>,\n        where\n            f(x) = 1/8*(x0 + x1 + x2 - x0^x1 - x0^x2 - x1^x2 + x0^x1^x2)\n\n        The algorithm should take the following matrix as an input:\n        S = [[1, 0, 0, 1, 1, 0, 1],\n             [0, 1, 0, 1, 0, 1, 1],\n             [0, 0, 1, 0, 1, 1, 1]]\n\n        and only T and T* gates as phase rotations,\n\n        And should return the following circuit (or an equivalent one):\n                \u250c\u2500\u2500\u2500\u2510\n        q_0: |0>\u2524 T \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\n                \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510       \u2502                   \u2502            \u250c\u2500\u2534\u2500\u2510\n        q_1: |0>\u2500\u2500\u2500\u2500\u2500\u2524 T \u251c\u2524 X \u251c\u2524 T*\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\n                     \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518\n        q_2: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 T \u251c\u2524 X \u251c\u2524 T*\u251c\u2524 X \u251c\u2524 T*\u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\n                                    \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\n        \"\"\"\n    cnots = [[1, 0, 0, 1, 1, 0, 1], [0, 1, 0, 1, 0, 1, 1], [0, 0, 1, 0, 1, 1, 1]]\n    angles = ['t', 't', 't', 'tdg', 'tdg', 'tdg', 't']\n    c_gray = synth_func(cnots, angles)\n    unitary_gray = UnitaryGate(Operator(c_gray))\n    q = QuantumRegister(3, 'q')\n    c_compare = QuantumCircuit(q)\n    c_compare.t(q[0])\n    c_compare.t(q[1])\n    c_compare.cx(q[0], q[1])\n    c_compare.tdg(q[1])\n    c_compare.t(q[2])\n    c_compare.cx(q[0], q[2])\n    c_compare.tdg(q[2])\n    c_compare.cx(q[1], q[2])\n    c_compare.tdg(q[2])\n    c_compare.cx(q[0], q[2])\n    c_compare.t(q[2])\n    c_compare.cx(q[1], q[2])\n    c_compare.cx(q[0], q[1])\n    unitary_compare = UnitaryGate(Operator(c_compare))\n    self.assertEqual(unitary_gray, unitary_compare)",
        "mutated": [
            "@ddt.data(synth_cnot_phase_aam, graysynth)\ndef test_ccz(self, synth_func):\n    if False:\n        i = 10\n    'Test synthesis of the doubly-controlled Z gate.\\n\\n        The diagonal operator in Example 4.3\\n            U|x> = e^(2.pi.i.f(x))|x>,\\n        where\\n            f(x) = 1/8*(x0 + x1 + x2 - x0^x1 - x0^x2 - x1^x2 + x0^x1^x2)\\n\\n        The algorithm should take the following matrix as an input:\\n        S = [[1, 0, 0, 1, 1, 0, 1],\\n             [0, 1, 0, 1, 0, 1, 1],\\n             [0, 0, 1, 0, 1, 1, 1]]\\n\\n        and only T and T* gates as phase rotations,\\n\\n        And should return the following circuit (or an equivalent one):\\n                \u250c\u2500\u2500\u2500\u2510\\n        q_0: |0>\u2524 T \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\\n                \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510       \u2502                   \u2502            \u250c\u2500\u2534\u2500\u2510\\n        q_1: |0>\u2500\u2500\u2500\u2500\u2500\u2524 T \u251c\u2524 X \u251c\u2524 T*\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\\n                     \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518\\n        q_2: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 T \u251c\u2524 X \u251c\u2524 T*\u251c\u2524 X \u251c\u2524 T*\u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\\n                                    \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\\n        '\n    cnots = [[1, 0, 0, 1, 1, 0, 1], [0, 1, 0, 1, 0, 1, 1], [0, 0, 1, 0, 1, 1, 1]]\n    angles = ['t', 't', 't', 'tdg', 'tdg', 'tdg', 't']\n    c_gray = synth_func(cnots, angles)\n    unitary_gray = UnitaryGate(Operator(c_gray))\n    q = QuantumRegister(3, 'q')\n    c_compare = QuantumCircuit(q)\n    c_compare.t(q[0])\n    c_compare.t(q[1])\n    c_compare.cx(q[0], q[1])\n    c_compare.tdg(q[1])\n    c_compare.t(q[2])\n    c_compare.cx(q[0], q[2])\n    c_compare.tdg(q[2])\n    c_compare.cx(q[1], q[2])\n    c_compare.tdg(q[2])\n    c_compare.cx(q[0], q[2])\n    c_compare.t(q[2])\n    c_compare.cx(q[1], q[2])\n    c_compare.cx(q[0], q[1])\n    unitary_compare = UnitaryGate(Operator(c_compare))\n    self.assertEqual(unitary_gray, unitary_compare)",
            "@ddt.data(synth_cnot_phase_aam, graysynth)\ndef test_ccz(self, synth_func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test synthesis of the doubly-controlled Z gate.\\n\\n        The diagonal operator in Example 4.3\\n            U|x> = e^(2.pi.i.f(x))|x>,\\n        where\\n            f(x) = 1/8*(x0 + x1 + x2 - x0^x1 - x0^x2 - x1^x2 + x0^x1^x2)\\n\\n        The algorithm should take the following matrix as an input:\\n        S = [[1, 0, 0, 1, 1, 0, 1],\\n             [0, 1, 0, 1, 0, 1, 1],\\n             [0, 0, 1, 0, 1, 1, 1]]\\n\\n        and only T and T* gates as phase rotations,\\n\\n        And should return the following circuit (or an equivalent one):\\n                \u250c\u2500\u2500\u2500\u2510\\n        q_0: |0>\u2524 T \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\\n                \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510       \u2502                   \u2502            \u250c\u2500\u2534\u2500\u2510\\n        q_1: |0>\u2500\u2500\u2500\u2500\u2500\u2524 T \u251c\u2524 X \u251c\u2524 T*\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\\n                     \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518\\n        q_2: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 T \u251c\u2524 X \u251c\u2524 T*\u251c\u2524 X \u251c\u2524 T*\u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\\n                                    \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\\n        '\n    cnots = [[1, 0, 0, 1, 1, 0, 1], [0, 1, 0, 1, 0, 1, 1], [0, 0, 1, 0, 1, 1, 1]]\n    angles = ['t', 't', 't', 'tdg', 'tdg', 'tdg', 't']\n    c_gray = synth_func(cnots, angles)\n    unitary_gray = UnitaryGate(Operator(c_gray))\n    q = QuantumRegister(3, 'q')\n    c_compare = QuantumCircuit(q)\n    c_compare.t(q[0])\n    c_compare.t(q[1])\n    c_compare.cx(q[0], q[1])\n    c_compare.tdg(q[1])\n    c_compare.t(q[2])\n    c_compare.cx(q[0], q[2])\n    c_compare.tdg(q[2])\n    c_compare.cx(q[1], q[2])\n    c_compare.tdg(q[2])\n    c_compare.cx(q[0], q[2])\n    c_compare.t(q[2])\n    c_compare.cx(q[1], q[2])\n    c_compare.cx(q[0], q[1])\n    unitary_compare = UnitaryGate(Operator(c_compare))\n    self.assertEqual(unitary_gray, unitary_compare)",
            "@ddt.data(synth_cnot_phase_aam, graysynth)\ndef test_ccz(self, synth_func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test synthesis of the doubly-controlled Z gate.\\n\\n        The diagonal operator in Example 4.3\\n            U|x> = e^(2.pi.i.f(x))|x>,\\n        where\\n            f(x) = 1/8*(x0 + x1 + x2 - x0^x1 - x0^x2 - x1^x2 + x0^x1^x2)\\n\\n        The algorithm should take the following matrix as an input:\\n        S = [[1, 0, 0, 1, 1, 0, 1],\\n             [0, 1, 0, 1, 0, 1, 1],\\n             [0, 0, 1, 0, 1, 1, 1]]\\n\\n        and only T and T* gates as phase rotations,\\n\\n        And should return the following circuit (or an equivalent one):\\n                \u250c\u2500\u2500\u2500\u2510\\n        q_0: |0>\u2524 T \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\\n                \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510       \u2502                   \u2502            \u250c\u2500\u2534\u2500\u2510\\n        q_1: |0>\u2500\u2500\u2500\u2500\u2500\u2524 T \u251c\u2524 X \u251c\u2524 T*\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\\n                     \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518\\n        q_2: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 T \u251c\u2524 X \u251c\u2524 T*\u251c\u2524 X \u251c\u2524 T*\u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\\n                                    \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\\n        '\n    cnots = [[1, 0, 0, 1, 1, 0, 1], [0, 1, 0, 1, 0, 1, 1], [0, 0, 1, 0, 1, 1, 1]]\n    angles = ['t', 't', 't', 'tdg', 'tdg', 'tdg', 't']\n    c_gray = synth_func(cnots, angles)\n    unitary_gray = UnitaryGate(Operator(c_gray))\n    q = QuantumRegister(3, 'q')\n    c_compare = QuantumCircuit(q)\n    c_compare.t(q[0])\n    c_compare.t(q[1])\n    c_compare.cx(q[0], q[1])\n    c_compare.tdg(q[1])\n    c_compare.t(q[2])\n    c_compare.cx(q[0], q[2])\n    c_compare.tdg(q[2])\n    c_compare.cx(q[1], q[2])\n    c_compare.tdg(q[2])\n    c_compare.cx(q[0], q[2])\n    c_compare.t(q[2])\n    c_compare.cx(q[1], q[2])\n    c_compare.cx(q[0], q[1])\n    unitary_compare = UnitaryGate(Operator(c_compare))\n    self.assertEqual(unitary_gray, unitary_compare)",
            "@ddt.data(synth_cnot_phase_aam, graysynth)\ndef test_ccz(self, synth_func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test synthesis of the doubly-controlled Z gate.\\n\\n        The diagonal operator in Example 4.3\\n            U|x> = e^(2.pi.i.f(x))|x>,\\n        where\\n            f(x) = 1/8*(x0 + x1 + x2 - x0^x1 - x0^x2 - x1^x2 + x0^x1^x2)\\n\\n        The algorithm should take the following matrix as an input:\\n        S = [[1, 0, 0, 1, 1, 0, 1],\\n             [0, 1, 0, 1, 0, 1, 1],\\n             [0, 0, 1, 0, 1, 1, 1]]\\n\\n        and only T and T* gates as phase rotations,\\n\\n        And should return the following circuit (or an equivalent one):\\n                \u250c\u2500\u2500\u2500\u2510\\n        q_0: |0>\u2524 T \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\\n                \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510       \u2502                   \u2502            \u250c\u2500\u2534\u2500\u2510\\n        q_1: |0>\u2500\u2500\u2500\u2500\u2500\u2524 T \u251c\u2524 X \u251c\u2524 T*\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\\n                     \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518\\n        q_2: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 T \u251c\u2524 X \u251c\u2524 T*\u251c\u2524 X \u251c\u2524 T*\u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\\n                                    \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\\n        '\n    cnots = [[1, 0, 0, 1, 1, 0, 1], [0, 1, 0, 1, 0, 1, 1], [0, 0, 1, 0, 1, 1, 1]]\n    angles = ['t', 't', 't', 'tdg', 'tdg', 'tdg', 't']\n    c_gray = synth_func(cnots, angles)\n    unitary_gray = UnitaryGate(Operator(c_gray))\n    q = QuantumRegister(3, 'q')\n    c_compare = QuantumCircuit(q)\n    c_compare.t(q[0])\n    c_compare.t(q[1])\n    c_compare.cx(q[0], q[1])\n    c_compare.tdg(q[1])\n    c_compare.t(q[2])\n    c_compare.cx(q[0], q[2])\n    c_compare.tdg(q[2])\n    c_compare.cx(q[1], q[2])\n    c_compare.tdg(q[2])\n    c_compare.cx(q[0], q[2])\n    c_compare.t(q[2])\n    c_compare.cx(q[1], q[2])\n    c_compare.cx(q[0], q[1])\n    unitary_compare = UnitaryGate(Operator(c_compare))\n    self.assertEqual(unitary_gray, unitary_compare)",
            "@ddt.data(synth_cnot_phase_aam, graysynth)\ndef test_ccz(self, synth_func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test synthesis of the doubly-controlled Z gate.\\n\\n        The diagonal operator in Example 4.3\\n            U|x> = e^(2.pi.i.f(x))|x>,\\n        where\\n            f(x) = 1/8*(x0 + x1 + x2 - x0^x1 - x0^x2 - x1^x2 + x0^x1^x2)\\n\\n        The algorithm should take the following matrix as an input:\\n        S = [[1, 0, 0, 1, 1, 0, 1],\\n             [0, 1, 0, 1, 0, 1, 1],\\n             [0, 0, 1, 0, 1, 1, 1]]\\n\\n        and only T and T* gates as phase rotations,\\n\\n        And should return the following circuit (or an equivalent one):\\n                \u250c\u2500\u2500\u2500\u2510\\n        q_0: |0>\u2524 T \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\\n                \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510       \u2502                   \u2502            \u250c\u2500\u2534\u2500\u2510\\n        q_1: |0>\u2500\u2500\u2500\u2500\u2500\u2524 T \u251c\u2524 X \u251c\u2524 T*\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\\n                     \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518\\n        q_2: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 T \u251c\u2524 X \u251c\u2524 T*\u251c\u2524 X \u251c\u2524 T*\u251c\u2524 X \u251c\u2524 T \u251c\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\\n                                    \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\\n        '\n    cnots = [[1, 0, 0, 1, 1, 0, 1], [0, 1, 0, 1, 0, 1, 1], [0, 0, 1, 0, 1, 1, 1]]\n    angles = ['t', 't', 't', 'tdg', 'tdg', 'tdg', 't']\n    c_gray = synth_func(cnots, angles)\n    unitary_gray = UnitaryGate(Operator(c_gray))\n    q = QuantumRegister(3, 'q')\n    c_compare = QuantumCircuit(q)\n    c_compare.t(q[0])\n    c_compare.t(q[1])\n    c_compare.cx(q[0], q[1])\n    c_compare.tdg(q[1])\n    c_compare.t(q[2])\n    c_compare.cx(q[0], q[2])\n    c_compare.tdg(q[2])\n    c_compare.cx(q[1], q[2])\n    c_compare.tdg(q[2])\n    c_compare.cx(q[0], q[2])\n    c_compare.t(q[2])\n    c_compare.cx(q[1], q[2])\n    c_compare.cx(q[0], q[1])\n    unitary_compare = UnitaryGate(Operator(c_compare))\n    self.assertEqual(unitary_gray, unitary_compare)"
        ]
    },
    {
        "func_name": "test_patel_markov_hayes",
        "original": "@ddt.data(synth_cnot_count_full_pmh, cnot_synth)\ndef test_patel_markov_hayes(self, synth_func):\n    \"\"\"Test synthesis of a small linear circuit\n        (example from paper, Figure 3).\n\n        The algorithm should take the following matrix as an input:\n        S = [[1, 1, 0, 0, 0, 0],\n             [1, 0, 0, 1, 1, 0],\n             [0, 1, 0, 0, 1, 0],\n             [1, 1, 1, 1, 1, 1],\n             [1, 1, 0, 1, 1, 1],\n             [0, 0, 1, 1, 1, 0]]\n\n        And should return the following circuit (or an equivalent one):\n                          \u250c\u2500\u2500\u2500\u2510\n        q_0: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\n                          \u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510                                   \u250c\u2500\u2534\u2500\u2510  \u2502    \u2502\n        q_1: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\n                     \u250c\u2500\u2500\u2500\u2510     \u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2510          \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518  \u2502    \u2502\n        q_2: |0>\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\n                \u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518       \u2502  \u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u2514\u2500\u252c\u2500\u2518       \u2502  \u2514\u2500\u2500\u2500\u2518       \u2502  \u250c\u2500\u2534\u2500\u2510\n        q_3: |0>\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\n                \u2514\u2500\u252c\u2500\u2518  \u2502              \u2502  \u2514\u2500\u252c\u2500\u2518\u251c\u2500\u2500\u2500\u2524       \u2502  \u250c\u2500\u2534\u2500\u2510          \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518\n        q_4: |0>\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\n                       \u2502                      \u2514\u2500\u252c\u2500\u2518     \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2518\n        q_5: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                                        \u2514\u2500\u2500\u2500\u2518\n        \"\"\"\n    state = [[1, 1, 0, 0, 0, 0], [1, 0, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0], [1, 1, 1, 1, 1, 1], [1, 1, 0, 1, 1, 1], [0, 0, 1, 1, 1, 0]]\n    c_patel = synth_func(state)\n    unitary_patel = UnitaryGate(Operator(c_patel))\n    q = QuantumRegister(6, 'q')\n    c_compare = QuantumCircuit(q)\n    c_compare.cx(q[4], q[3])\n    c_compare.cx(q[5], q[2])\n    c_compare.cx(q[1], q[0])\n    c_compare.cx(q[3], q[1])\n    c_compare.cx(q[4], q[2])\n    c_compare.cx(q[4], q[3])\n    c_compare.cx(q[5], q[4])\n    c_compare.cx(q[2], q[3])\n    c_compare.cx(q[3], q[2])\n    c_compare.cx(q[3], q[5])\n    c_compare.cx(q[2], q[4])\n    c_compare.cx(q[1], q[2])\n    c_compare.cx(q[0], q[1])\n    c_compare.cx(q[0], q[4])\n    c_compare.cx(q[0], q[3])\n    unitary_compare = UnitaryGate(Operator(c_compare))\n    self.assertEqual(unitary_patel, unitary_compare)",
        "mutated": [
            "@ddt.data(synth_cnot_count_full_pmh, cnot_synth)\ndef test_patel_markov_hayes(self, synth_func):\n    if False:\n        i = 10\n    'Test synthesis of a small linear circuit\\n        (example from paper, Figure 3).\\n\\n        The algorithm should take the following matrix as an input:\\n        S = [[1, 1, 0, 0, 0, 0],\\n             [1, 0, 0, 1, 1, 0],\\n             [0, 1, 0, 0, 1, 0],\\n             [1, 1, 1, 1, 1, 1],\\n             [1, 1, 0, 1, 1, 1],\\n             [0, 0, 1, 1, 1, 0]]\\n\\n        And should return the following circuit (or an equivalent one):\\n                          \u250c\u2500\u2500\u2500\u2510\\n        q_0: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\\n                          \u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510                                   \u250c\u2500\u2534\u2500\u2510  \u2502    \u2502\\n        q_1: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\\n                     \u250c\u2500\u2500\u2500\u2510     \u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2510          \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518  \u2502    \u2502\\n        q_2: |0>\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\\n                \u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518       \u2502  \u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u2514\u2500\u252c\u2500\u2518       \u2502  \u2514\u2500\u2500\u2500\u2518       \u2502  \u250c\u2500\u2534\u2500\u2510\\n        q_3: |0>\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\\n                \u2514\u2500\u252c\u2500\u2518  \u2502              \u2502  \u2514\u2500\u252c\u2500\u2518\u251c\u2500\u2500\u2500\u2524       \u2502  \u250c\u2500\u2534\u2500\u2510          \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518\\n        q_4: |0>\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\\n                       \u2502                      \u2514\u2500\u252c\u2500\u2518     \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2518\\n        q_5: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n                                                        \u2514\u2500\u2500\u2500\u2518\\n        '\n    state = [[1, 1, 0, 0, 0, 0], [1, 0, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0], [1, 1, 1, 1, 1, 1], [1, 1, 0, 1, 1, 1], [0, 0, 1, 1, 1, 0]]\n    c_patel = synth_func(state)\n    unitary_patel = UnitaryGate(Operator(c_patel))\n    q = QuantumRegister(6, 'q')\n    c_compare = QuantumCircuit(q)\n    c_compare.cx(q[4], q[3])\n    c_compare.cx(q[5], q[2])\n    c_compare.cx(q[1], q[0])\n    c_compare.cx(q[3], q[1])\n    c_compare.cx(q[4], q[2])\n    c_compare.cx(q[4], q[3])\n    c_compare.cx(q[5], q[4])\n    c_compare.cx(q[2], q[3])\n    c_compare.cx(q[3], q[2])\n    c_compare.cx(q[3], q[5])\n    c_compare.cx(q[2], q[4])\n    c_compare.cx(q[1], q[2])\n    c_compare.cx(q[0], q[1])\n    c_compare.cx(q[0], q[4])\n    c_compare.cx(q[0], q[3])\n    unitary_compare = UnitaryGate(Operator(c_compare))\n    self.assertEqual(unitary_patel, unitary_compare)",
            "@ddt.data(synth_cnot_count_full_pmh, cnot_synth)\ndef test_patel_markov_hayes(self, synth_func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test synthesis of a small linear circuit\\n        (example from paper, Figure 3).\\n\\n        The algorithm should take the following matrix as an input:\\n        S = [[1, 1, 0, 0, 0, 0],\\n             [1, 0, 0, 1, 1, 0],\\n             [0, 1, 0, 0, 1, 0],\\n             [1, 1, 1, 1, 1, 1],\\n             [1, 1, 0, 1, 1, 1],\\n             [0, 0, 1, 1, 1, 0]]\\n\\n        And should return the following circuit (or an equivalent one):\\n                          \u250c\u2500\u2500\u2500\u2510\\n        q_0: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\\n                          \u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510                                   \u250c\u2500\u2534\u2500\u2510  \u2502    \u2502\\n        q_1: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\\n                     \u250c\u2500\u2500\u2500\u2510     \u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2510          \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518  \u2502    \u2502\\n        q_2: |0>\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\\n                \u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518       \u2502  \u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u2514\u2500\u252c\u2500\u2518       \u2502  \u2514\u2500\u2500\u2500\u2518       \u2502  \u250c\u2500\u2534\u2500\u2510\\n        q_3: |0>\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\\n                \u2514\u2500\u252c\u2500\u2518  \u2502              \u2502  \u2514\u2500\u252c\u2500\u2518\u251c\u2500\u2500\u2500\u2524       \u2502  \u250c\u2500\u2534\u2500\u2510          \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518\\n        q_4: |0>\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\\n                       \u2502                      \u2514\u2500\u252c\u2500\u2518     \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2518\\n        q_5: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n                                                        \u2514\u2500\u2500\u2500\u2518\\n        '\n    state = [[1, 1, 0, 0, 0, 0], [1, 0, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0], [1, 1, 1, 1, 1, 1], [1, 1, 0, 1, 1, 1], [0, 0, 1, 1, 1, 0]]\n    c_patel = synth_func(state)\n    unitary_patel = UnitaryGate(Operator(c_patel))\n    q = QuantumRegister(6, 'q')\n    c_compare = QuantumCircuit(q)\n    c_compare.cx(q[4], q[3])\n    c_compare.cx(q[5], q[2])\n    c_compare.cx(q[1], q[0])\n    c_compare.cx(q[3], q[1])\n    c_compare.cx(q[4], q[2])\n    c_compare.cx(q[4], q[3])\n    c_compare.cx(q[5], q[4])\n    c_compare.cx(q[2], q[3])\n    c_compare.cx(q[3], q[2])\n    c_compare.cx(q[3], q[5])\n    c_compare.cx(q[2], q[4])\n    c_compare.cx(q[1], q[2])\n    c_compare.cx(q[0], q[1])\n    c_compare.cx(q[0], q[4])\n    c_compare.cx(q[0], q[3])\n    unitary_compare = UnitaryGate(Operator(c_compare))\n    self.assertEqual(unitary_patel, unitary_compare)",
            "@ddt.data(synth_cnot_count_full_pmh, cnot_synth)\ndef test_patel_markov_hayes(self, synth_func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test synthesis of a small linear circuit\\n        (example from paper, Figure 3).\\n\\n        The algorithm should take the following matrix as an input:\\n        S = [[1, 1, 0, 0, 0, 0],\\n             [1, 0, 0, 1, 1, 0],\\n             [0, 1, 0, 0, 1, 0],\\n             [1, 1, 1, 1, 1, 1],\\n             [1, 1, 0, 1, 1, 1],\\n             [0, 0, 1, 1, 1, 0]]\\n\\n        And should return the following circuit (or an equivalent one):\\n                          \u250c\u2500\u2500\u2500\u2510\\n        q_0: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\\n                          \u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510                                   \u250c\u2500\u2534\u2500\u2510  \u2502    \u2502\\n        q_1: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\\n                     \u250c\u2500\u2500\u2500\u2510     \u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2510          \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518  \u2502    \u2502\\n        q_2: |0>\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\\n                \u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518       \u2502  \u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u2514\u2500\u252c\u2500\u2518       \u2502  \u2514\u2500\u2500\u2500\u2518       \u2502  \u250c\u2500\u2534\u2500\u2510\\n        q_3: |0>\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\\n                \u2514\u2500\u252c\u2500\u2518  \u2502              \u2502  \u2514\u2500\u252c\u2500\u2518\u251c\u2500\u2500\u2500\u2524       \u2502  \u250c\u2500\u2534\u2500\u2510          \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518\\n        q_4: |0>\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\\n                       \u2502                      \u2514\u2500\u252c\u2500\u2518     \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2518\\n        q_5: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n                                                        \u2514\u2500\u2500\u2500\u2518\\n        '\n    state = [[1, 1, 0, 0, 0, 0], [1, 0, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0], [1, 1, 1, 1, 1, 1], [1, 1, 0, 1, 1, 1], [0, 0, 1, 1, 1, 0]]\n    c_patel = synth_func(state)\n    unitary_patel = UnitaryGate(Operator(c_patel))\n    q = QuantumRegister(6, 'q')\n    c_compare = QuantumCircuit(q)\n    c_compare.cx(q[4], q[3])\n    c_compare.cx(q[5], q[2])\n    c_compare.cx(q[1], q[0])\n    c_compare.cx(q[3], q[1])\n    c_compare.cx(q[4], q[2])\n    c_compare.cx(q[4], q[3])\n    c_compare.cx(q[5], q[4])\n    c_compare.cx(q[2], q[3])\n    c_compare.cx(q[3], q[2])\n    c_compare.cx(q[3], q[5])\n    c_compare.cx(q[2], q[4])\n    c_compare.cx(q[1], q[2])\n    c_compare.cx(q[0], q[1])\n    c_compare.cx(q[0], q[4])\n    c_compare.cx(q[0], q[3])\n    unitary_compare = UnitaryGate(Operator(c_compare))\n    self.assertEqual(unitary_patel, unitary_compare)",
            "@ddt.data(synth_cnot_count_full_pmh, cnot_synth)\ndef test_patel_markov_hayes(self, synth_func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test synthesis of a small linear circuit\\n        (example from paper, Figure 3).\\n\\n        The algorithm should take the following matrix as an input:\\n        S = [[1, 1, 0, 0, 0, 0],\\n             [1, 0, 0, 1, 1, 0],\\n             [0, 1, 0, 0, 1, 0],\\n             [1, 1, 1, 1, 1, 1],\\n             [1, 1, 0, 1, 1, 1],\\n             [0, 0, 1, 1, 1, 0]]\\n\\n        And should return the following circuit (or an equivalent one):\\n                          \u250c\u2500\u2500\u2500\u2510\\n        q_0: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\\n                          \u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510                                   \u250c\u2500\u2534\u2500\u2510  \u2502    \u2502\\n        q_1: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\\n                     \u250c\u2500\u2500\u2500\u2510     \u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2510          \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518  \u2502    \u2502\\n        q_2: |0>\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\\n                \u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518       \u2502  \u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u2514\u2500\u252c\u2500\u2518       \u2502  \u2514\u2500\u2500\u2500\u2518       \u2502  \u250c\u2500\u2534\u2500\u2510\\n        q_3: |0>\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\\n                \u2514\u2500\u252c\u2500\u2518  \u2502              \u2502  \u2514\u2500\u252c\u2500\u2518\u251c\u2500\u2500\u2500\u2524       \u2502  \u250c\u2500\u2534\u2500\u2510          \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518\\n        q_4: |0>\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\\n                       \u2502                      \u2514\u2500\u252c\u2500\u2518     \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2518\\n        q_5: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n                                                        \u2514\u2500\u2500\u2500\u2518\\n        '\n    state = [[1, 1, 0, 0, 0, 0], [1, 0, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0], [1, 1, 1, 1, 1, 1], [1, 1, 0, 1, 1, 1], [0, 0, 1, 1, 1, 0]]\n    c_patel = synth_func(state)\n    unitary_patel = UnitaryGate(Operator(c_patel))\n    q = QuantumRegister(6, 'q')\n    c_compare = QuantumCircuit(q)\n    c_compare.cx(q[4], q[3])\n    c_compare.cx(q[5], q[2])\n    c_compare.cx(q[1], q[0])\n    c_compare.cx(q[3], q[1])\n    c_compare.cx(q[4], q[2])\n    c_compare.cx(q[4], q[3])\n    c_compare.cx(q[5], q[4])\n    c_compare.cx(q[2], q[3])\n    c_compare.cx(q[3], q[2])\n    c_compare.cx(q[3], q[5])\n    c_compare.cx(q[2], q[4])\n    c_compare.cx(q[1], q[2])\n    c_compare.cx(q[0], q[1])\n    c_compare.cx(q[0], q[4])\n    c_compare.cx(q[0], q[3])\n    unitary_compare = UnitaryGate(Operator(c_compare))\n    self.assertEqual(unitary_patel, unitary_compare)",
            "@ddt.data(synth_cnot_count_full_pmh, cnot_synth)\ndef test_patel_markov_hayes(self, synth_func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test synthesis of a small linear circuit\\n        (example from paper, Figure 3).\\n\\n        The algorithm should take the following matrix as an input:\\n        S = [[1, 1, 0, 0, 0, 0],\\n             [1, 0, 0, 1, 1, 0],\\n             [0, 1, 0, 0, 1, 0],\\n             [1, 1, 1, 1, 1, 1],\\n             [1, 1, 0, 1, 1, 1],\\n             [0, 0, 1, 1, 1, 0]]\\n\\n        And should return the following circuit (or an equivalent one):\\n                          \u250c\u2500\u2500\u2500\u2510\\n        q_0: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\\n                          \u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510                                   \u250c\u2500\u2534\u2500\u2510  \u2502    \u2502\\n        q_1: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\\n                     \u250c\u2500\u2500\u2500\u2510     \u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2510          \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518  \u2502    \u2502\\n        q_2: |0>\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\\n                \u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518       \u2502  \u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u2514\u2500\u252c\u2500\u2518       \u2502  \u2514\u2500\u2500\u2500\u2518       \u2502  \u250c\u2500\u2534\u2500\u2510\\n        q_3: |0>\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\\n                \u2514\u2500\u252c\u2500\u2518  \u2502              \u2502  \u2514\u2500\u252c\u2500\u2518\u251c\u2500\u2500\u2500\u2524       \u2502  \u250c\u2500\u2534\u2500\u2510          \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518\\n        q_4: |0>\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\\n                       \u2502                      \u2514\u2500\u252c\u2500\u2518     \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2518\\n        q_5: |0>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n                                                        \u2514\u2500\u2500\u2500\u2518\\n        '\n    state = [[1, 1, 0, 0, 0, 0], [1, 0, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0], [1, 1, 1, 1, 1, 1], [1, 1, 0, 1, 1, 1], [0, 0, 1, 1, 1, 0]]\n    c_patel = synth_func(state)\n    unitary_patel = UnitaryGate(Operator(c_patel))\n    q = QuantumRegister(6, 'q')\n    c_compare = QuantumCircuit(q)\n    c_compare.cx(q[4], q[3])\n    c_compare.cx(q[5], q[2])\n    c_compare.cx(q[1], q[0])\n    c_compare.cx(q[3], q[1])\n    c_compare.cx(q[4], q[2])\n    c_compare.cx(q[4], q[3])\n    c_compare.cx(q[5], q[4])\n    c_compare.cx(q[2], q[3])\n    c_compare.cx(q[3], q[2])\n    c_compare.cx(q[3], q[5])\n    c_compare.cx(q[2], q[4])\n    c_compare.cx(q[1], q[2])\n    c_compare.cx(q[0], q[1])\n    c_compare.cx(q[0], q[4])\n    c_compare.cx(q[0], q[3])\n    unitary_compare = UnitaryGate(Operator(c_compare))\n    self.assertEqual(unitary_patel, unitary_compare)"
        ]
    }
]