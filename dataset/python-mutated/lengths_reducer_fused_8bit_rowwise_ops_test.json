[
    {
        "func_name": "compare_rowwise",
        "original": "def compare_rowwise(emb_orig, emb_reconstructed, fp16):\n    assert emb_orig.shape == emb_reconstructed.shape\n    rtol = 1e-08\n    if fp16:\n        rtol = 0.001\n    erange = np.amax(emb_orig, axis=1) - np.amin(emb_orig, axis=1)\n    threshold = erange / 255.0 / 1.9\n    for i in range(emb_orig.shape[0]):\n        r_orig = emb_orig[i, :]\n        r_reconstructed = emb_reconstructed[i, :]\n        isclose = np.isclose(r_orig, r_reconstructed, atol=threshold[i], rtol=rtol)\n        n_violated = isclose.size - isclose.sum()\n        if n_violated > 0:\n            print(isclose, threshold[i])\n            print(i, r_orig, r_reconstructed, threshold[i], r_orig - r_reconstructed)\n        assert n_violated == 0",
        "mutated": [
            "def compare_rowwise(emb_orig, emb_reconstructed, fp16):\n    if False:\n        i = 10\n    assert emb_orig.shape == emb_reconstructed.shape\n    rtol = 1e-08\n    if fp16:\n        rtol = 0.001\n    erange = np.amax(emb_orig, axis=1) - np.amin(emb_orig, axis=1)\n    threshold = erange / 255.0 / 1.9\n    for i in range(emb_orig.shape[0]):\n        r_orig = emb_orig[i, :]\n        r_reconstructed = emb_reconstructed[i, :]\n        isclose = np.isclose(r_orig, r_reconstructed, atol=threshold[i], rtol=rtol)\n        n_violated = isclose.size - isclose.sum()\n        if n_violated > 0:\n            print(isclose, threshold[i])\n            print(i, r_orig, r_reconstructed, threshold[i], r_orig - r_reconstructed)\n        assert n_violated == 0",
            "def compare_rowwise(emb_orig, emb_reconstructed, fp16):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert emb_orig.shape == emb_reconstructed.shape\n    rtol = 1e-08\n    if fp16:\n        rtol = 0.001\n    erange = np.amax(emb_orig, axis=1) - np.amin(emb_orig, axis=1)\n    threshold = erange / 255.0 / 1.9\n    for i in range(emb_orig.shape[0]):\n        r_orig = emb_orig[i, :]\n        r_reconstructed = emb_reconstructed[i, :]\n        isclose = np.isclose(r_orig, r_reconstructed, atol=threshold[i], rtol=rtol)\n        n_violated = isclose.size - isclose.sum()\n        if n_violated > 0:\n            print(isclose, threshold[i])\n            print(i, r_orig, r_reconstructed, threshold[i], r_orig - r_reconstructed)\n        assert n_violated == 0",
            "def compare_rowwise(emb_orig, emb_reconstructed, fp16):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert emb_orig.shape == emb_reconstructed.shape\n    rtol = 1e-08\n    if fp16:\n        rtol = 0.001\n    erange = np.amax(emb_orig, axis=1) - np.amin(emb_orig, axis=1)\n    threshold = erange / 255.0 / 1.9\n    for i in range(emb_orig.shape[0]):\n        r_orig = emb_orig[i, :]\n        r_reconstructed = emb_reconstructed[i, :]\n        isclose = np.isclose(r_orig, r_reconstructed, atol=threshold[i], rtol=rtol)\n        n_violated = isclose.size - isclose.sum()\n        if n_violated > 0:\n            print(isclose, threshold[i])\n            print(i, r_orig, r_reconstructed, threshold[i], r_orig - r_reconstructed)\n        assert n_violated == 0",
            "def compare_rowwise(emb_orig, emb_reconstructed, fp16):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert emb_orig.shape == emb_reconstructed.shape\n    rtol = 1e-08\n    if fp16:\n        rtol = 0.001\n    erange = np.amax(emb_orig, axis=1) - np.amin(emb_orig, axis=1)\n    threshold = erange / 255.0 / 1.9\n    for i in range(emb_orig.shape[0]):\n        r_orig = emb_orig[i, :]\n        r_reconstructed = emb_reconstructed[i, :]\n        isclose = np.isclose(r_orig, r_reconstructed, atol=threshold[i], rtol=rtol)\n        n_violated = isclose.size - isclose.sum()\n        if n_violated > 0:\n            print(isclose, threshold[i])\n            print(i, r_orig, r_reconstructed, threshold[i], r_orig - r_reconstructed)\n        assert n_violated == 0",
            "def compare_rowwise(emb_orig, emb_reconstructed, fp16):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert emb_orig.shape == emb_reconstructed.shape\n    rtol = 1e-08\n    if fp16:\n        rtol = 0.001\n    erange = np.amax(emb_orig, axis=1) - np.amin(emb_orig, axis=1)\n    threshold = erange / 255.0 / 1.9\n    for i in range(emb_orig.shape[0]):\n        r_orig = emb_orig[i, :]\n        r_reconstructed = emb_reconstructed[i, :]\n        isclose = np.isclose(r_orig, r_reconstructed, atol=threshold[i], rtol=rtol)\n        n_violated = isclose.size - isclose.sum()\n        if n_violated > 0:\n            print(isclose, threshold[i])\n            print(i, r_orig, r_reconstructed, threshold[i], r_orig - r_reconstructed)\n        assert n_violated == 0"
        ]
    },
    {
        "func_name": "test_sparse_lengths_sum",
        "original": "@given(num_rows=st.integers(1, 20), blocksize=st.sampled_from([8, 16, 32, 64, 85, 96, 128, 163]), weighted=st.booleans(), seed=st.integers(0, 2 ** 32 - 1), empty_indices=st.booleans(), fp16=st.booleans())\ndef test_sparse_lengths_sum(self, num_rows, blocksize, weighted, seed, empty_indices, fp16):\n    net = core.Net('bench')\n    np.random.seed(seed)\n    if fp16:\n        input_data = np.random.rand(num_rows, blocksize).astype(np.float16)\n    else:\n        input_data = np.random.rand(num_rows, blocksize).astype(np.float32)\n    if empty_indices:\n        lengths = np.zeros(num_rows, dtype=np.int32)\n        num_indices = 0\n    else:\n        num_indices = np.random.randint(len(input_data))\n        lengths_split = np.clip(num_indices // 2, 1, 10)\n        lengths = np.ones([num_indices // lengths_split], dtype=np.int32) * lengths_split\n        num_indices = num_indices // lengths_split * lengths_split\n    indices = np.random.randint(low=0, high=len(input_data), size=[num_indices], dtype=np.int32)\n    weights = np.random.uniform(size=[len(indices)]).astype(np.float32)\n    if fp16:\n        quantized_data = net.HalfFloatToFused8BitRowwiseQuantized('input_data', 'quantized_data')\n        dequantized_data = net.Fused8BitRowwiseQuantizedToHalfFloat(quantized_data, 'dequantized_data')\n    else:\n        quantized_data = net.FloatToFused8BitRowwiseQuantized('input_data', 'quantized_data')\n        dequantized_data = net.Fused8BitRowwiseQuantizedToFloat(quantized_data, 'dequantized_data')\n    if weighted:\n        net.SparseLengthsWeightedSum([dequantized_data, 'weights', 'indices', 'lengths'], 'sum_reference')\n        net.SparseLengthsWeightedSumFused8BitRowwise([quantized_data, 'weights', 'indices', 'lengths'], 'sum_quantized')\n    else:\n        net.SparseLengthsSum([dequantized_data, 'indices', 'lengths'], 'sum_reference')\n        net.SparseLengthsSumFused8BitRowwise([quantized_data, 'indices', 'lengths'], 'sum_quantized')\n    workspace.FeedBlob('input_data', input_data)\n    workspace.FeedBlob('weights', weights)\n    workspace.FeedBlob('indices', indices)\n    workspace.FeedBlob('lengths', lengths)\n    workspace.GlobalInit(['caffe2', '--caffe2_log_level=0'])\n    workspace.CreateNet(net)\n    workspace.RunNetOnce(net)\n    dequantized_data = workspace.FetchBlob('dequantized_data')\n    np.testing.assert_array_almost_equal(input_data, workspace.FetchBlob('input_data'))\n    compare_rowwise(input_data, dequantized_data, fp16)\n    sum_reference = workspace.FetchBlob('sum_reference')\n    sum_quantized = workspace.FetchBlob('sum_quantized')\n    if fp16:\n        np.testing.assert_array_almost_equal(sum_reference, sum_quantized, decimal=3)\n    else:\n        np.testing.assert_array_almost_equal(sum_reference, sum_quantized)",
        "mutated": [
            "@given(num_rows=st.integers(1, 20), blocksize=st.sampled_from([8, 16, 32, 64, 85, 96, 128, 163]), weighted=st.booleans(), seed=st.integers(0, 2 ** 32 - 1), empty_indices=st.booleans(), fp16=st.booleans())\ndef test_sparse_lengths_sum(self, num_rows, blocksize, weighted, seed, empty_indices, fp16):\n    if False:\n        i = 10\n    net = core.Net('bench')\n    np.random.seed(seed)\n    if fp16:\n        input_data = np.random.rand(num_rows, blocksize).astype(np.float16)\n    else:\n        input_data = np.random.rand(num_rows, blocksize).astype(np.float32)\n    if empty_indices:\n        lengths = np.zeros(num_rows, dtype=np.int32)\n        num_indices = 0\n    else:\n        num_indices = np.random.randint(len(input_data))\n        lengths_split = np.clip(num_indices // 2, 1, 10)\n        lengths = np.ones([num_indices // lengths_split], dtype=np.int32) * lengths_split\n        num_indices = num_indices // lengths_split * lengths_split\n    indices = np.random.randint(low=0, high=len(input_data), size=[num_indices], dtype=np.int32)\n    weights = np.random.uniform(size=[len(indices)]).astype(np.float32)\n    if fp16:\n        quantized_data = net.HalfFloatToFused8BitRowwiseQuantized('input_data', 'quantized_data')\n        dequantized_data = net.Fused8BitRowwiseQuantizedToHalfFloat(quantized_data, 'dequantized_data')\n    else:\n        quantized_data = net.FloatToFused8BitRowwiseQuantized('input_data', 'quantized_data')\n        dequantized_data = net.Fused8BitRowwiseQuantizedToFloat(quantized_data, 'dequantized_data')\n    if weighted:\n        net.SparseLengthsWeightedSum([dequantized_data, 'weights', 'indices', 'lengths'], 'sum_reference')\n        net.SparseLengthsWeightedSumFused8BitRowwise([quantized_data, 'weights', 'indices', 'lengths'], 'sum_quantized')\n    else:\n        net.SparseLengthsSum([dequantized_data, 'indices', 'lengths'], 'sum_reference')\n        net.SparseLengthsSumFused8BitRowwise([quantized_data, 'indices', 'lengths'], 'sum_quantized')\n    workspace.FeedBlob('input_data', input_data)\n    workspace.FeedBlob('weights', weights)\n    workspace.FeedBlob('indices', indices)\n    workspace.FeedBlob('lengths', lengths)\n    workspace.GlobalInit(['caffe2', '--caffe2_log_level=0'])\n    workspace.CreateNet(net)\n    workspace.RunNetOnce(net)\n    dequantized_data = workspace.FetchBlob('dequantized_data')\n    np.testing.assert_array_almost_equal(input_data, workspace.FetchBlob('input_data'))\n    compare_rowwise(input_data, dequantized_data, fp16)\n    sum_reference = workspace.FetchBlob('sum_reference')\n    sum_quantized = workspace.FetchBlob('sum_quantized')\n    if fp16:\n        np.testing.assert_array_almost_equal(sum_reference, sum_quantized, decimal=3)\n    else:\n        np.testing.assert_array_almost_equal(sum_reference, sum_quantized)",
            "@given(num_rows=st.integers(1, 20), blocksize=st.sampled_from([8, 16, 32, 64, 85, 96, 128, 163]), weighted=st.booleans(), seed=st.integers(0, 2 ** 32 - 1), empty_indices=st.booleans(), fp16=st.booleans())\ndef test_sparse_lengths_sum(self, num_rows, blocksize, weighted, seed, empty_indices, fp16):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    net = core.Net('bench')\n    np.random.seed(seed)\n    if fp16:\n        input_data = np.random.rand(num_rows, blocksize).astype(np.float16)\n    else:\n        input_data = np.random.rand(num_rows, blocksize).astype(np.float32)\n    if empty_indices:\n        lengths = np.zeros(num_rows, dtype=np.int32)\n        num_indices = 0\n    else:\n        num_indices = np.random.randint(len(input_data))\n        lengths_split = np.clip(num_indices // 2, 1, 10)\n        lengths = np.ones([num_indices // lengths_split], dtype=np.int32) * lengths_split\n        num_indices = num_indices // lengths_split * lengths_split\n    indices = np.random.randint(low=0, high=len(input_data), size=[num_indices], dtype=np.int32)\n    weights = np.random.uniform(size=[len(indices)]).astype(np.float32)\n    if fp16:\n        quantized_data = net.HalfFloatToFused8BitRowwiseQuantized('input_data', 'quantized_data')\n        dequantized_data = net.Fused8BitRowwiseQuantizedToHalfFloat(quantized_data, 'dequantized_data')\n    else:\n        quantized_data = net.FloatToFused8BitRowwiseQuantized('input_data', 'quantized_data')\n        dequantized_data = net.Fused8BitRowwiseQuantizedToFloat(quantized_data, 'dequantized_data')\n    if weighted:\n        net.SparseLengthsWeightedSum([dequantized_data, 'weights', 'indices', 'lengths'], 'sum_reference')\n        net.SparseLengthsWeightedSumFused8BitRowwise([quantized_data, 'weights', 'indices', 'lengths'], 'sum_quantized')\n    else:\n        net.SparseLengthsSum([dequantized_data, 'indices', 'lengths'], 'sum_reference')\n        net.SparseLengthsSumFused8BitRowwise([quantized_data, 'indices', 'lengths'], 'sum_quantized')\n    workspace.FeedBlob('input_data', input_data)\n    workspace.FeedBlob('weights', weights)\n    workspace.FeedBlob('indices', indices)\n    workspace.FeedBlob('lengths', lengths)\n    workspace.GlobalInit(['caffe2', '--caffe2_log_level=0'])\n    workspace.CreateNet(net)\n    workspace.RunNetOnce(net)\n    dequantized_data = workspace.FetchBlob('dequantized_data')\n    np.testing.assert_array_almost_equal(input_data, workspace.FetchBlob('input_data'))\n    compare_rowwise(input_data, dequantized_data, fp16)\n    sum_reference = workspace.FetchBlob('sum_reference')\n    sum_quantized = workspace.FetchBlob('sum_quantized')\n    if fp16:\n        np.testing.assert_array_almost_equal(sum_reference, sum_quantized, decimal=3)\n    else:\n        np.testing.assert_array_almost_equal(sum_reference, sum_quantized)",
            "@given(num_rows=st.integers(1, 20), blocksize=st.sampled_from([8, 16, 32, 64, 85, 96, 128, 163]), weighted=st.booleans(), seed=st.integers(0, 2 ** 32 - 1), empty_indices=st.booleans(), fp16=st.booleans())\ndef test_sparse_lengths_sum(self, num_rows, blocksize, weighted, seed, empty_indices, fp16):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    net = core.Net('bench')\n    np.random.seed(seed)\n    if fp16:\n        input_data = np.random.rand(num_rows, blocksize).astype(np.float16)\n    else:\n        input_data = np.random.rand(num_rows, blocksize).astype(np.float32)\n    if empty_indices:\n        lengths = np.zeros(num_rows, dtype=np.int32)\n        num_indices = 0\n    else:\n        num_indices = np.random.randint(len(input_data))\n        lengths_split = np.clip(num_indices // 2, 1, 10)\n        lengths = np.ones([num_indices // lengths_split], dtype=np.int32) * lengths_split\n        num_indices = num_indices // lengths_split * lengths_split\n    indices = np.random.randint(low=0, high=len(input_data), size=[num_indices], dtype=np.int32)\n    weights = np.random.uniform(size=[len(indices)]).astype(np.float32)\n    if fp16:\n        quantized_data = net.HalfFloatToFused8BitRowwiseQuantized('input_data', 'quantized_data')\n        dequantized_data = net.Fused8BitRowwiseQuantizedToHalfFloat(quantized_data, 'dequantized_data')\n    else:\n        quantized_data = net.FloatToFused8BitRowwiseQuantized('input_data', 'quantized_data')\n        dequantized_data = net.Fused8BitRowwiseQuantizedToFloat(quantized_data, 'dequantized_data')\n    if weighted:\n        net.SparseLengthsWeightedSum([dequantized_data, 'weights', 'indices', 'lengths'], 'sum_reference')\n        net.SparseLengthsWeightedSumFused8BitRowwise([quantized_data, 'weights', 'indices', 'lengths'], 'sum_quantized')\n    else:\n        net.SparseLengthsSum([dequantized_data, 'indices', 'lengths'], 'sum_reference')\n        net.SparseLengthsSumFused8BitRowwise([quantized_data, 'indices', 'lengths'], 'sum_quantized')\n    workspace.FeedBlob('input_data', input_data)\n    workspace.FeedBlob('weights', weights)\n    workspace.FeedBlob('indices', indices)\n    workspace.FeedBlob('lengths', lengths)\n    workspace.GlobalInit(['caffe2', '--caffe2_log_level=0'])\n    workspace.CreateNet(net)\n    workspace.RunNetOnce(net)\n    dequantized_data = workspace.FetchBlob('dequantized_data')\n    np.testing.assert_array_almost_equal(input_data, workspace.FetchBlob('input_data'))\n    compare_rowwise(input_data, dequantized_data, fp16)\n    sum_reference = workspace.FetchBlob('sum_reference')\n    sum_quantized = workspace.FetchBlob('sum_quantized')\n    if fp16:\n        np.testing.assert_array_almost_equal(sum_reference, sum_quantized, decimal=3)\n    else:\n        np.testing.assert_array_almost_equal(sum_reference, sum_quantized)",
            "@given(num_rows=st.integers(1, 20), blocksize=st.sampled_from([8, 16, 32, 64, 85, 96, 128, 163]), weighted=st.booleans(), seed=st.integers(0, 2 ** 32 - 1), empty_indices=st.booleans(), fp16=st.booleans())\ndef test_sparse_lengths_sum(self, num_rows, blocksize, weighted, seed, empty_indices, fp16):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    net = core.Net('bench')\n    np.random.seed(seed)\n    if fp16:\n        input_data = np.random.rand(num_rows, blocksize).astype(np.float16)\n    else:\n        input_data = np.random.rand(num_rows, blocksize).astype(np.float32)\n    if empty_indices:\n        lengths = np.zeros(num_rows, dtype=np.int32)\n        num_indices = 0\n    else:\n        num_indices = np.random.randint(len(input_data))\n        lengths_split = np.clip(num_indices // 2, 1, 10)\n        lengths = np.ones([num_indices // lengths_split], dtype=np.int32) * lengths_split\n        num_indices = num_indices // lengths_split * lengths_split\n    indices = np.random.randint(low=0, high=len(input_data), size=[num_indices], dtype=np.int32)\n    weights = np.random.uniform(size=[len(indices)]).astype(np.float32)\n    if fp16:\n        quantized_data = net.HalfFloatToFused8BitRowwiseQuantized('input_data', 'quantized_data')\n        dequantized_data = net.Fused8BitRowwiseQuantizedToHalfFloat(quantized_data, 'dequantized_data')\n    else:\n        quantized_data = net.FloatToFused8BitRowwiseQuantized('input_data', 'quantized_data')\n        dequantized_data = net.Fused8BitRowwiseQuantizedToFloat(quantized_data, 'dequantized_data')\n    if weighted:\n        net.SparseLengthsWeightedSum([dequantized_data, 'weights', 'indices', 'lengths'], 'sum_reference')\n        net.SparseLengthsWeightedSumFused8BitRowwise([quantized_data, 'weights', 'indices', 'lengths'], 'sum_quantized')\n    else:\n        net.SparseLengthsSum([dequantized_data, 'indices', 'lengths'], 'sum_reference')\n        net.SparseLengthsSumFused8BitRowwise([quantized_data, 'indices', 'lengths'], 'sum_quantized')\n    workspace.FeedBlob('input_data', input_data)\n    workspace.FeedBlob('weights', weights)\n    workspace.FeedBlob('indices', indices)\n    workspace.FeedBlob('lengths', lengths)\n    workspace.GlobalInit(['caffe2', '--caffe2_log_level=0'])\n    workspace.CreateNet(net)\n    workspace.RunNetOnce(net)\n    dequantized_data = workspace.FetchBlob('dequantized_data')\n    np.testing.assert_array_almost_equal(input_data, workspace.FetchBlob('input_data'))\n    compare_rowwise(input_data, dequantized_data, fp16)\n    sum_reference = workspace.FetchBlob('sum_reference')\n    sum_quantized = workspace.FetchBlob('sum_quantized')\n    if fp16:\n        np.testing.assert_array_almost_equal(sum_reference, sum_quantized, decimal=3)\n    else:\n        np.testing.assert_array_almost_equal(sum_reference, sum_quantized)",
            "@given(num_rows=st.integers(1, 20), blocksize=st.sampled_from([8, 16, 32, 64, 85, 96, 128, 163]), weighted=st.booleans(), seed=st.integers(0, 2 ** 32 - 1), empty_indices=st.booleans(), fp16=st.booleans())\ndef test_sparse_lengths_sum(self, num_rows, blocksize, weighted, seed, empty_indices, fp16):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    net = core.Net('bench')\n    np.random.seed(seed)\n    if fp16:\n        input_data = np.random.rand(num_rows, blocksize).astype(np.float16)\n    else:\n        input_data = np.random.rand(num_rows, blocksize).astype(np.float32)\n    if empty_indices:\n        lengths = np.zeros(num_rows, dtype=np.int32)\n        num_indices = 0\n    else:\n        num_indices = np.random.randint(len(input_data))\n        lengths_split = np.clip(num_indices // 2, 1, 10)\n        lengths = np.ones([num_indices // lengths_split], dtype=np.int32) * lengths_split\n        num_indices = num_indices // lengths_split * lengths_split\n    indices = np.random.randint(low=0, high=len(input_data), size=[num_indices], dtype=np.int32)\n    weights = np.random.uniform(size=[len(indices)]).astype(np.float32)\n    if fp16:\n        quantized_data = net.HalfFloatToFused8BitRowwiseQuantized('input_data', 'quantized_data')\n        dequantized_data = net.Fused8BitRowwiseQuantizedToHalfFloat(quantized_data, 'dequantized_data')\n    else:\n        quantized_data = net.FloatToFused8BitRowwiseQuantized('input_data', 'quantized_data')\n        dequantized_data = net.Fused8BitRowwiseQuantizedToFloat(quantized_data, 'dequantized_data')\n    if weighted:\n        net.SparseLengthsWeightedSum([dequantized_data, 'weights', 'indices', 'lengths'], 'sum_reference')\n        net.SparseLengthsWeightedSumFused8BitRowwise([quantized_data, 'weights', 'indices', 'lengths'], 'sum_quantized')\n    else:\n        net.SparseLengthsSum([dequantized_data, 'indices', 'lengths'], 'sum_reference')\n        net.SparseLengthsSumFused8BitRowwise([quantized_data, 'indices', 'lengths'], 'sum_quantized')\n    workspace.FeedBlob('input_data', input_data)\n    workspace.FeedBlob('weights', weights)\n    workspace.FeedBlob('indices', indices)\n    workspace.FeedBlob('lengths', lengths)\n    workspace.GlobalInit(['caffe2', '--caffe2_log_level=0'])\n    workspace.CreateNet(net)\n    workspace.RunNetOnce(net)\n    dequantized_data = workspace.FetchBlob('dequantized_data')\n    np.testing.assert_array_almost_equal(input_data, workspace.FetchBlob('input_data'))\n    compare_rowwise(input_data, dequantized_data, fp16)\n    sum_reference = workspace.FetchBlob('sum_reference')\n    sum_quantized = workspace.FetchBlob('sum_quantized')\n    if fp16:\n        np.testing.assert_array_almost_equal(sum_reference, sum_quantized, decimal=3)\n    else:\n        np.testing.assert_array_almost_equal(sum_reference, sum_quantized)"
        ]
    },
    {
        "func_name": "test_sparse_lengths_mean",
        "original": "@given(num_rows=st.integers(1, 20), blocksize=st.sampled_from([8, 16, 32, 64, 85, 96, 128, 163]), seed=st.integers(0, 2 ** 32 - 1), empty_indices=st.booleans(), fp16=st.booleans())\ndef test_sparse_lengths_mean(self, num_rows, blocksize, seed, empty_indices, fp16):\n    net = core.Net('bench')\n    np.random.seed(seed)\n    if fp16:\n        input_data = np.random.rand(num_rows, blocksize).astype(np.float16)\n    else:\n        input_data = np.random.rand(num_rows, blocksize).astype(np.float32)\n    if empty_indices:\n        lengths = np.zeros(num_rows, dtype=np.int32)\n        num_indices = 0\n    else:\n        num_indices = np.random.randint(len(input_data))\n        lengths_split = np.clip(num_indices // 2, 1, 10)\n        lengths = np.ones([num_indices // lengths_split], dtype=np.int32) * lengths_split\n        num_indices = num_indices // lengths_split * lengths_split\n    indices = np.random.randint(low=0, high=len(input_data), size=[num_indices], dtype=np.int32)\n    print(indices, lengths)\n    if fp16:\n        quantized_data = net.HalfFloatToFused8BitRowwiseQuantized('input_data', 'quantized_data')\n        dequantized_data = net.Fused8BitRowwiseQuantizedToHalfFloat(quantized_data, 'dequantized_data')\n    else:\n        quantized_data = net.FloatToFused8BitRowwiseQuantized('input_data', 'quantized_data')\n        dequantized_data = net.Fused8BitRowwiseQuantizedToFloat(quantized_data, 'dequantized_data')\n    net.SparseLengthsMean([dequantized_data, 'indices', 'lengths'], 'mean_reference')\n    net.SparseLengthsMeanFused8BitRowwise([quantized_data, 'indices', 'lengths'], 'mean_quantized')\n    workspace.FeedBlob('input_data', input_data)\n    workspace.FeedBlob('indices', indices)\n    workspace.FeedBlob('lengths', lengths)\n    workspace.GlobalInit(['caffe2', '--caffe2_log_level=0'])\n    workspace.CreateNet(net)\n    workspace.RunNetOnce(net)\n    dequantized_data = workspace.FetchBlob('dequantized_data')\n    np.testing.assert_array_almost_equal(input_data, workspace.FetchBlob('input_data'))\n    compare_rowwise(input_data, dequantized_data, fp16)\n    mean_reference = workspace.FetchBlob('mean_reference')\n    mean_quantized = workspace.FetchBlob('mean_quantized')\n    if fp16:\n        np.testing.assert_array_almost_equal(mean_reference, mean_quantized, decimal=3)\n    else:\n        np.testing.assert_array_almost_equal(mean_reference, mean_quantized)",
        "mutated": [
            "@given(num_rows=st.integers(1, 20), blocksize=st.sampled_from([8, 16, 32, 64, 85, 96, 128, 163]), seed=st.integers(0, 2 ** 32 - 1), empty_indices=st.booleans(), fp16=st.booleans())\ndef test_sparse_lengths_mean(self, num_rows, blocksize, seed, empty_indices, fp16):\n    if False:\n        i = 10\n    net = core.Net('bench')\n    np.random.seed(seed)\n    if fp16:\n        input_data = np.random.rand(num_rows, blocksize).astype(np.float16)\n    else:\n        input_data = np.random.rand(num_rows, blocksize).astype(np.float32)\n    if empty_indices:\n        lengths = np.zeros(num_rows, dtype=np.int32)\n        num_indices = 0\n    else:\n        num_indices = np.random.randint(len(input_data))\n        lengths_split = np.clip(num_indices // 2, 1, 10)\n        lengths = np.ones([num_indices // lengths_split], dtype=np.int32) * lengths_split\n        num_indices = num_indices // lengths_split * lengths_split\n    indices = np.random.randint(low=0, high=len(input_data), size=[num_indices], dtype=np.int32)\n    print(indices, lengths)\n    if fp16:\n        quantized_data = net.HalfFloatToFused8BitRowwiseQuantized('input_data', 'quantized_data')\n        dequantized_data = net.Fused8BitRowwiseQuantizedToHalfFloat(quantized_data, 'dequantized_data')\n    else:\n        quantized_data = net.FloatToFused8BitRowwiseQuantized('input_data', 'quantized_data')\n        dequantized_data = net.Fused8BitRowwiseQuantizedToFloat(quantized_data, 'dequantized_data')\n    net.SparseLengthsMean([dequantized_data, 'indices', 'lengths'], 'mean_reference')\n    net.SparseLengthsMeanFused8BitRowwise([quantized_data, 'indices', 'lengths'], 'mean_quantized')\n    workspace.FeedBlob('input_data', input_data)\n    workspace.FeedBlob('indices', indices)\n    workspace.FeedBlob('lengths', lengths)\n    workspace.GlobalInit(['caffe2', '--caffe2_log_level=0'])\n    workspace.CreateNet(net)\n    workspace.RunNetOnce(net)\n    dequantized_data = workspace.FetchBlob('dequantized_data')\n    np.testing.assert_array_almost_equal(input_data, workspace.FetchBlob('input_data'))\n    compare_rowwise(input_data, dequantized_data, fp16)\n    mean_reference = workspace.FetchBlob('mean_reference')\n    mean_quantized = workspace.FetchBlob('mean_quantized')\n    if fp16:\n        np.testing.assert_array_almost_equal(mean_reference, mean_quantized, decimal=3)\n    else:\n        np.testing.assert_array_almost_equal(mean_reference, mean_quantized)",
            "@given(num_rows=st.integers(1, 20), blocksize=st.sampled_from([8, 16, 32, 64, 85, 96, 128, 163]), seed=st.integers(0, 2 ** 32 - 1), empty_indices=st.booleans(), fp16=st.booleans())\ndef test_sparse_lengths_mean(self, num_rows, blocksize, seed, empty_indices, fp16):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    net = core.Net('bench')\n    np.random.seed(seed)\n    if fp16:\n        input_data = np.random.rand(num_rows, blocksize).astype(np.float16)\n    else:\n        input_data = np.random.rand(num_rows, blocksize).astype(np.float32)\n    if empty_indices:\n        lengths = np.zeros(num_rows, dtype=np.int32)\n        num_indices = 0\n    else:\n        num_indices = np.random.randint(len(input_data))\n        lengths_split = np.clip(num_indices // 2, 1, 10)\n        lengths = np.ones([num_indices // lengths_split], dtype=np.int32) * lengths_split\n        num_indices = num_indices // lengths_split * lengths_split\n    indices = np.random.randint(low=0, high=len(input_data), size=[num_indices], dtype=np.int32)\n    print(indices, lengths)\n    if fp16:\n        quantized_data = net.HalfFloatToFused8BitRowwiseQuantized('input_data', 'quantized_data')\n        dequantized_data = net.Fused8BitRowwiseQuantizedToHalfFloat(quantized_data, 'dequantized_data')\n    else:\n        quantized_data = net.FloatToFused8BitRowwiseQuantized('input_data', 'quantized_data')\n        dequantized_data = net.Fused8BitRowwiseQuantizedToFloat(quantized_data, 'dequantized_data')\n    net.SparseLengthsMean([dequantized_data, 'indices', 'lengths'], 'mean_reference')\n    net.SparseLengthsMeanFused8BitRowwise([quantized_data, 'indices', 'lengths'], 'mean_quantized')\n    workspace.FeedBlob('input_data', input_data)\n    workspace.FeedBlob('indices', indices)\n    workspace.FeedBlob('lengths', lengths)\n    workspace.GlobalInit(['caffe2', '--caffe2_log_level=0'])\n    workspace.CreateNet(net)\n    workspace.RunNetOnce(net)\n    dequantized_data = workspace.FetchBlob('dequantized_data')\n    np.testing.assert_array_almost_equal(input_data, workspace.FetchBlob('input_data'))\n    compare_rowwise(input_data, dequantized_data, fp16)\n    mean_reference = workspace.FetchBlob('mean_reference')\n    mean_quantized = workspace.FetchBlob('mean_quantized')\n    if fp16:\n        np.testing.assert_array_almost_equal(mean_reference, mean_quantized, decimal=3)\n    else:\n        np.testing.assert_array_almost_equal(mean_reference, mean_quantized)",
            "@given(num_rows=st.integers(1, 20), blocksize=st.sampled_from([8, 16, 32, 64, 85, 96, 128, 163]), seed=st.integers(0, 2 ** 32 - 1), empty_indices=st.booleans(), fp16=st.booleans())\ndef test_sparse_lengths_mean(self, num_rows, blocksize, seed, empty_indices, fp16):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    net = core.Net('bench')\n    np.random.seed(seed)\n    if fp16:\n        input_data = np.random.rand(num_rows, blocksize).astype(np.float16)\n    else:\n        input_data = np.random.rand(num_rows, blocksize).astype(np.float32)\n    if empty_indices:\n        lengths = np.zeros(num_rows, dtype=np.int32)\n        num_indices = 0\n    else:\n        num_indices = np.random.randint(len(input_data))\n        lengths_split = np.clip(num_indices // 2, 1, 10)\n        lengths = np.ones([num_indices // lengths_split], dtype=np.int32) * lengths_split\n        num_indices = num_indices // lengths_split * lengths_split\n    indices = np.random.randint(low=0, high=len(input_data), size=[num_indices], dtype=np.int32)\n    print(indices, lengths)\n    if fp16:\n        quantized_data = net.HalfFloatToFused8BitRowwiseQuantized('input_data', 'quantized_data')\n        dequantized_data = net.Fused8BitRowwiseQuantizedToHalfFloat(quantized_data, 'dequantized_data')\n    else:\n        quantized_data = net.FloatToFused8BitRowwiseQuantized('input_data', 'quantized_data')\n        dequantized_data = net.Fused8BitRowwiseQuantizedToFloat(quantized_data, 'dequantized_data')\n    net.SparseLengthsMean([dequantized_data, 'indices', 'lengths'], 'mean_reference')\n    net.SparseLengthsMeanFused8BitRowwise([quantized_data, 'indices', 'lengths'], 'mean_quantized')\n    workspace.FeedBlob('input_data', input_data)\n    workspace.FeedBlob('indices', indices)\n    workspace.FeedBlob('lengths', lengths)\n    workspace.GlobalInit(['caffe2', '--caffe2_log_level=0'])\n    workspace.CreateNet(net)\n    workspace.RunNetOnce(net)\n    dequantized_data = workspace.FetchBlob('dequantized_data')\n    np.testing.assert_array_almost_equal(input_data, workspace.FetchBlob('input_data'))\n    compare_rowwise(input_data, dequantized_data, fp16)\n    mean_reference = workspace.FetchBlob('mean_reference')\n    mean_quantized = workspace.FetchBlob('mean_quantized')\n    if fp16:\n        np.testing.assert_array_almost_equal(mean_reference, mean_quantized, decimal=3)\n    else:\n        np.testing.assert_array_almost_equal(mean_reference, mean_quantized)",
            "@given(num_rows=st.integers(1, 20), blocksize=st.sampled_from([8, 16, 32, 64, 85, 96, 128, 163]), seed=st.integers(0, 2 ** 32 - 1), empty_indices=st.booleans(), fp16=st.booleans())\ndef test_sparse_lengths_mean(self, num_rows, blocksize, seed, empty_indices, fp16):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    net = core.Net('bench')\n    np.random.seed(seed)\n    if fp16:\n        input_data = np.random.rand(num_rows, blocksize).astype(np.float16)\n    else:\n        input_data = np.random.rand(num_rows, blocksize).astype(np.float32)\n    if empty_indices:\n        lengths = np.zeros(num_rows, dtype=np.int32)\n        num_indices = 0\n    else:\n        num_indices = np.random.randint(len(input_data))\n        lengths_split = np.clip(num_indices // 2, 1, 10)\n        lengths = np.ones([num_indices // lengths_split], dtype=np.int32) * lengths_split\n        num_indices = num_indices // lengths_split * lengths_split\n    indices = np.random.randint(low=0, high=len(input_data), size=[num_indices], dtype=np.int32)\n    print(indices, lengths)\n    if fp16:\n        quantized_data = net.HalfFloatToFused8BitRowwiseQuantized('input_data', 'quantized_data')\n        dequantized_data = net.Fused8BitRowwiseQuantizedToHalfFloat(quantized_data, 'dequantized_data')\n    else:\n        quantized_data = net.FloatToFused8BitRowwiseQuantized('input_data', 'quantized_data')\n        dequantized_data = net.Fused8BitRowwiseQuantizedToFloat(quantized_data, 'dequantized_data')\n    net.SparseLengthsMean([dequantized_data, 'indices', 'lengths'], 'mean_reference')\n    net.SparseLengthsMeanFused8BitRowwise([quantized_data, 'indices', 'lengths'], 'mean_quantized')\n    workspace.FeedBlob('input_data', input_data)\n    workspace.FeedBlob('indices', indices)\n    workspace.FeedBlob('lengths', lengths)\n    workspace.GlobalInit(['caffe2', '--caffe2_log_level=0'])\n    workspace.CreateNet(net)\n    workspace.RunNetOnce(net)\n    dequantized_data = workspace.FetchBlob('dequantized_data')\n    np.testing.assert_array_almost_equal(input_data, workspace.FetchBlob('input_data'))\n    compare_rowwise(input_data, dequantized_data, fp16)\n    mean_reference = workspace.FetchBlob('mean_reference')\n    mean_quantized = workspace.FetchBlob('mean_quantized')\n    if fp16:\n        np.testing.assert_array_almost_equal(mean_reference, mean_quantized, decimal=3)\n    else:\n        np.testing.assert_array_almost_equal(mean_reference, mean_quantized)",
            "@given(num_rows=st.integers(1, 20), blocksize=st.sampled_from([8, 16, 32, 64, 85, 96, 128, 163]), seed=st.integers(0, 2 ** 32 - 1), empty_indices=st.booleans(), fp16=st.booleans())\ndef test_sparse_lengths_mean(self, num_rows, blocksize, seed, empty_indices, fp16):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    net = core.Net('bench')\n    np.random.seed(seed)\n    if fp16:\n        input_data = np.random.rand(num_rows, blocksize).astype(np.float16)\n    else:\n        input_data = np.random.rand(num_rows, blocksize).astype(np.float32)\n    if empty_indices:\n        lengths = np.zeros(num_rows, dtype=np.int32)\n        num_indices = 0\n    else:\n        num_indices = np.random.randint(len(input_data))\n        lengths_split = np.clip(num_indices // 2, 1, 10)\n        lengths = np.ones([num_indices // lengths_split], dtype=np.int32) * lengths_split\n        num_indices = num_indices // lengths_split * lengths_split\n    indices = np.random.randint(low=0, high=len(input_data), size=[num_indices], dtype=np.int32)\n    print(indices, lengths)\n    if fp16:\n        quantized_data = net.HalfFloatToFused8BitRowwiseQuantized('input_data', 'quantized_data')\n        dequantized_data = net.Fused8BitRowwiseQuantizedToHalfFloat(quantized_data, 'dequantized_data')\n    else:\n        quantized_data = net.FloatToFused8BitRowwiseQuantized('input_data', 'quantized_data')\n        dequantized_data = net.Fused8BitRowwiseQuantizedToFloat(quantized_data, 'dequantized_data')\n    net.SparseLengthsMean([dequantized_data, 'indices', 'lengths'], 'mean_reference')\n    net.SparseLengthsMeanFused8BitRowwise([quantized_data, 'indices', 'lengths'], 'mean_quantized')\n    workspace.FeedBlob('input_data', input_data)\n    workspace.FeedBlob('indices', indices)\n    workspace.FeedBlob('lengths', lengths)\n    workspace.GlobalInit(['caffe2', '--caffe2_log_level=0'])\n    workspace.CreateNet(net)\n    workspace.RunNetOnce(net)\n    dequantized_data = workspace.FetchBlob('dequantized_data')\n    np.testing.assert_array_almost_equal(input_data, workspace.FetchBlob('input_data'))\n    compare_rowwise(input_data, dequantized_data, fp16)\n    mean_reference = workspace.FetchBlob('mean_reference')\n    mean_quantized = workspace.FetchBlob('mean_quantized')\n    if fp16:\n        np.testing.assert_array_almost_equal(mean_reference, mean_quantized, decimal=3)\n    else:\n        np.testing.assert_array_almost_equal(mean_reference, mean_quantized)"
        ]
    }
]