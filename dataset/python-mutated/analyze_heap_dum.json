[
    {
        "func_name": "add_symbol",
        "original": "def add_symbol(name, address=None, size=None):\n    if 'lto_priv' in name:\n        name = name.split('.')[0]\n    if address:\n        address = int(address, 0)\n    if size:\n        size = int(size, 0)\n    if name in symbols:\n        if address and symbols[name][0] and (symbols[name][0] != address):\n            if print_conflicting_symbols:\n                print('Conflicting symbol: {} at addresses 0x{:08x} and 0x{:08x}'.format(name, address, symbols[name][0]))\n            return\n        if not address:\n            address = symbols[name][0]\n        if not size:\n            size = symbols[name][1]\n    symbols[name] = (address, size)\n    if address:\n        if not size:\n            size = 4\n        for offset in range(0, size, 4):\n            symbol_lookup[address + offset] = '{}+{}'.format(name, offset)",
        "mutated": [
            "def add_symbol(name, address=None, size=None):\n    if False:\n        i = 10\n    if 'lto_priv' in name:\n        name = name.split('.')[0]\n    if address:\n        address = int(address, 0)\n    if size:\n        size = int(size, 0)\n    if name in symbols:\n        if address and symbols[name][0] and (symbols[name][0] != address):\n            if print_conflicting_symbols:\n                print('Conflicting symbol: {} at addresses 0x{:08x} and 0x{:08x}'.format(name, address, symbols[name][0]))\n            return\n        if not address:\n            address = symbols[name][0]\n        if not size:\n            size = symbols[name][1]\n    symbols[name] = (address, size)\n    if address:\n        if not size:\n            size = 4\n        for offset in range(0, size, 4):\n            symbol_lookup[address + offset] = '{}+{}'.format(name, offset)",
            "def add_symbol(name, address=None, size=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if 'lto_priv' in name:\n        name = name.split('.')[0]\n    if address:\n        address = int(address, 0)\n    if size:\n        size = int(size, 0)\n    if name in symbols:\n        if address and symbols[name][0] and (symbols[name][0] != address):\n            if print_conflicting_symbols:\n                print('Conflicting symbol: {} at addresses 0x{:08x} and 0x{:08x}'.format(name, address, symbols[name][0]))\n            return\n        if not address:\n            address = symbols[name][0]\n        if not size:\n            size = symbols[name][1]\n    symbols[name] = (address, size)\n    if address:\n        if not size:\n            size = 4\n        for offset in range(0, size, 4):\n            symbol_lookup[address + offset] = '{}+{}'.format(name, offset)",
            "def add_symbol(name, address=None, size=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if 'lto_priv' in name:\n        name = name.split('.')[0]\n    if address:\n        address = int(address, 0)\n    if size:\n        size = int(size, 0)\n    if name in symbols:\n        if address and symbols[name][0] and (symbols[name][0] != address):\n            if print_conflicting_symbols:\n                print('Conflicting symbol: {} at addresses 0x{:08x} and 0x{:08x}'.format(name, address, symbols[name][0]))\n            return\n        if not address:\n            address = symbols[name][0]\n        if not size:\n            size = symbols[name][1]\n    symbols[name] = (address, size)\n    if address:\n        if not size:\n            size = 4\n        for offset in range(0, size, 4):\n            symbol_lookup[address + offset] = '{}+{}'.format(name, offset)",
            "def add_symbol(name, address=None, size=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if 'lto_priv' in name:\n        name = name.split('.')[0]\n    if address:\n        address = int(address, 0)\n    if size:\n        size = int(size, 0)\n    if name in symbols:\n        if address and symbols[name][0] and (symbols[name][0] != address):\n            if print_conflicting_symbols:\n                print('Conflicting symbol: {} at addresses 0x{:08x} and 0x{:08x}'.format(name, address, symbols[name][0]))\n            return\n        if not address:\n            address = symbols[name][0]\n        if not size:\n            size = symbols[name][1]\n    symbols[name] = (address, size)\n    if address:\n        if not size:\n            size = 4\n        for offset in range(0, size, 4):\n            symbol_lookup[address + offset] = '{}+{}'.format(name, offset)",
            "def add_symbol(name, address=None, size=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if 'lto_priv' in name:\n        name = name.split('.')[0]\n    if address:\n        address = int(address, 0)\n    if size:\n        size = int(size, 0)\n    if name in symbols:\n        if address and symbols[name][0] and (symbols[name][0] != address):\n            if print_conflicting_symbols:\n                print('Conflicting symbol: {} at addresses 0x{:08x} and 0x{:08x}'.format(name, address, symbols[name][0]))\n            return\n        if not address:\n            address = symbols[name][0]\n        if not size:\n            size = symbols[name][1]\n    symbols[name] = (address, size)\n    if address:\n        if not size:\n            size = 4\n        for offset in range(0, size, 4):\n            symbol_lookup[address + offset] = '{}+{}'.format(name, offset)"
        ]
    },
    {
        "func_name": "load",
        "original": "def load(address, size=4):\n    if size is None:\n        raise ValueError('You must provide a size')\n    if address > ram_start:\n        ram_address = address - ram_start\n        if ram_address + size > len(ram):\n            raise ValueError('Unable to read 0x{:08x} from ram.'.format(address))\n        return ram[ram_address:ram_address + size]\n    elif address < len(rom):\n        if address + size > len(rom):\n            raise ValueError('Unable to read 0x{:08x} from rom.'.format(address))\n        return rom[address:address + size]",
        "mutated": [
            "def load(address, size=4):\n    if False:\n        i = 10\n    if size is None:\n        raise ValueError('You must provide a size')\n    if address > ram_start:\n        ram_address = address - ram_start\n        if ram_address + size > len(ram):\n            raise ValueError('Unable to read 0x{:08x} from ram.'.format(address))\n        return ram[ram_address:ram_address + size]\n    elif address < len(rom):\n        if address + size > len(rom):\n            raise ValueError('Unable to read 0x{:08x} from rom.'.format(address))\n        return rom[address:address + size]",
            "def load(address, size=4):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if size is None:\n        raise ValueError('You must provide a size')\n    if address > ram_start:\n        ram_address = address - ram_start\n        if ram_address + size > len(ram):\n            raise ValueError('Unable to read 0x{:08x} from ram.'.format(address))\n        return ram[ram_address:ram_address + size]\n    elif address < len(rom):\n        if address + size > len(rom):\n            raise ValueError('Unable to read 0x{:08x} from rom.'.format(address))\n        return rom[address:address + size]",
            "def load(address, size=4):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if size is None:\n        raise ValueError('You must provide a size')\n    if address > ram_start:\n        ram_address = address - ram_start\n        if ram_address + size > len(ram):\n            raise ValueError('Unable to read 0x{:08x} from ram.'.format(address))\n        return ram[ram_address:ram_address + size]\n    elif address < len(rom):\n        if address + size > len(rom):\n            raise ValueError('Unable to read 0x{:08x} from rom.'.format(address))\n        return rom[address:address + size]",
            "def load(address, size=4):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if size is None:\n        raise ValueError('You must provide a size')\n    if address > ram_start:\n        ram_address = address - ram_start\n        if ram_address + size > len(ram):\n            raise ValueError('Unable to read 0x{:08x} from ram.'.format(address))\n        return ram[ram_address:ram_address + size]\n    elif address < len(rom):\n        if address + size > len(rom):\n            raise ValueError('Unable to read 0x{:08x} from rom.'.format(address))\n        return rom[address:address + size]",
            "def load(address, size=4):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if size is None:\n        raise ValueError('You must provide a size')\n    if address > ram_start:\n        ram_address = address - ram_start\n        if ram_address + size > len(ram):\n            raise ValueError('Unable to read 0x{:08x} from ram.'.format(address))\n        return ram[ram_address:ram_address + size]\n    elif address < len(rom):\n        if address + size > len(rom):\n            raise ValueError('Unable to read 0x{:08x} from rom.'.format(address))\n        return rom[address:address + size]"
        ]
    },
    {
        "func_name": "load_pointer",
        "original": "def load_pointer(address):\n    return struct.unpack('<I', load(address))[0]",
        "mutated": [
            "def load_pointer(address):\n    if False:\n        i = 10\n    return struct.unpack('<I', load(address))[0]",
            "def load_pointer(address):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return struct.unpack('<I', load(address))[0]",
            "def load_pointer(address):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return struct.unpack('<I', load(address))[0]",
            "def load_pointer(address):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return struct.unpack('<I', load(address))[0]",
            "def load_pointer(address):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return struct.unpack('<I', load(address))[0]"
        ]
    },
    {
        "func_name": "save_allocated_block",
        "original": "def save_allocated_block(end, current_allocation):\n    allocation_length = current_allocation * BYTES_PER_BLOCK\n    start = end - allocation_length\n    address = pool_start + start\n    data = pool[start:end]\n    if print_block_state:\n        print('0x{:x} {} bytes allocated'.format(address, allocation_length))\n    if print_block_contents:\n        print(data)\n    rows = ''\n    for k in range(current_allocation - 1):\n        rows += '<tr>'\n        for l in range(4):\n            rows += '<td port=\"{}\" height=\"18\" width=\"20\"></td>'.format(4 * (k + 1) + l)\n        rows += '</tr>'\n    table = '<<table bgcolor=\"gray\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\"><tr><td colspan=\"4\" port=\"0\" height=\"18\" width=\"80\">0x{:08x}</td></tr>{}</table>>'.format(address, rows)\n    ownership_graph.add_node(address, label=table, style='invisible', shape='plaintext')\n    print('add  0x{:08x}'.format(address))\n    potential_type = None\n    node = ownership_graph.get_node(address)\n    node.attr['height'] = 0.25 * current_allocation\n    node.attr['fontcolor'] = 'black'\n    block_data[address] = data\n    for k in range(len(data) // 4):\n        word = struct.unpack_from('<I', data, offset=k * 4)[0]\n        if word < len(rom) and k == 0 or address in qstr_pools:\n            potential_type = word\n            bgcolor = 'gray'\n            if address in qstr_pools:\n                bgcolor = 'tomato'\n            elif potential_type in function_types:\n                bgcolor = 'green'\n            elif potential_type in type_colors:\n                bgcolor = type_colors[potential_type]\n            elif print_unknown_types:\n                print('unknown type', hex(potential_type))\n            node.attr['label'] = '<' + node.attr['label'].replace('\"gray\"', '\"' + bgcolor + '\"') + '>'\n        if potential_type == str_type and k == 3:\n            string_blocks.append(word)\n        if potential_type == dict_type:\n            if k == 3:\n                map_element_blocks.append(word)\n        if ram_start < word < ram_start + len(ram) and word % 16 == 0:\n            port = k\n            if k < 4:\n                port = 0\n            ownership_graph.add_edge(address, word, tailport=str(port) + ':_')\n            print('  0x{:08x}'.format(word))\n            if address in qstr_pools:\n                if k > 0:\n                    qstr_chunks.append(word)\n            if k == 0:\n                potential_type = dynamic_type\n        if potential_type == dynamic_type:\n            if k == 0:\n                node.attr['fillcolor'] = 'plum'\n            if k == 3 and ram_start < word < ram_end:\n                map_element_blocks.append(word)\n        if potential_type in function_types:\n            if k == 2 and ram_start < word < ram_end:\n                bytecode_blocks.append(word)",
        "mutated": [
            "def save_allocated_block(end, current_allocation):\n    if False:\n        i = 10\n    allocation_length = current_allocation * BYTES_PER_BLOCK\n    start = end - allocation_length\n    address = pool_start + start\n    data = pool[start:end]\n    if print_block_state:\n        print('0x{:x} {} bytes allocated'.format(address, allocation_length))\n    if print_block_contents:\n        print(data)\n    rows = ''\n    for k in range(current_allocation - 1):\n        rows += '<tr>'\n        for l in range(4):\n            rows += '<td port=\"{}\" height=\"18\" width=\"20\"></td>'.format(4 * (k + 1) + l)\n        rows += '</tr>'\n    table = '<<table bgcolor=\"gray\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\"><tr><td colspan=\"4\" port=\"0\" height=\"18\" width=\"80\">0x{:08x}</td></tr>{}</table>>'.format(address, rows)\n    ownership_graph.add_node(address, label=table, style='invisible', shape='plaintext')\n    print('add  0x{:08x}'.format(address))\n    potential_type = None\n    node = ownership_graph.get_node(address)\n    node.attr['height'] = 0.25 * current_allocation\n    node.attr['fontcolor'] = 'black'\n    block_data[address] = data\n    for k in range(len(data) // 4):\n        word = struct.unpack_from('<I', data, offset=k * 4)[0]\n        if word < len(rom) and k == 0 or address in qstr_pools:\n            potential_type = word\n            bgcolor = 'gray'\n            if address in qstr_pools:\n                bgcolor = 'tomato'\n            elif potential_type in function_types:\n                bgcolor = 'green'\n            elif potential_type in type_colors:\n                bgcolor = type_colors[potential_type]\n            elif print_unknown_types:\n                print('unknown type', hex(potential_type))\n            node.attr['label'] = '<' + node.attr['label'].replace('\"gray\"', '\"' + bgcolor + '\"') + '>'\n        if potential_type == str_type and k == 3:\n            string_blocks.append(word)\n        if potential_type == dict_type:\n            if k == 3:\n                map_element_blocks.append(word)\n        if ram_start < word < ram_start + len(ram) and word % 16 == 0:\n            port = k\n            if k < 4:\n                port = 0\n            ownership_graph.add_edge(address, word, tailport=str(port) + ':_')\n            print('  0x{:08x}'.format(word))\n            if address in qstr_pools:\n                if k > 0:\n                    qstr_chunks.append(word)\n            if k == 0:\n                potential_type = dynamic_type\n        if potential_type == dynamic_type:\n            if k == 0:\n                node.attr['fillcolor'] = 'plum'\n            if k == 3 and ram_start < word < ram_end:\n                map_element_blocks.append(word)\n        if potential_type in function_types:\n            if k == 2 and ram_start < word < ram_end:\n                bytecode_blocks.append(word)",
            "def save_allocated_block(end, current_allocation):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    allocation_length = current_allocation * BYTES_PER_BLOCK\n    start = end - allocation_length\n    address = pool_start + start\n    data = pool[start:end]\n    if print_block_state:\n        print('0x{:x} {} bytes allocated'.format(address, allocation_length))\n    if print_block_contents:\n        print(data)\n    rows = ''\n    for k in range(current_allocation - 1):\n        rows += '<tr>'\n        for l in range(4):\n            rows += '<td port=\"{}\" height=\"18\" width=\"20\"></td>'.format(4 * (k + 1) + l)\n        rows += '</tr>'\n    table = '<<table bgcolor=\"gray\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\"><tr><td colspan=\"4\" port=\"0\" height=\"18\" width=\"80\">0x{:08x}</td></tr>{}</table>>'.format(address, rows)\n    ownership_graph.add_node(address, label=table, style='invisible', shape='plaintext')\n    print('add  0x{:08x}'.format(address))\n    potential_type = None\n    node = ownership_graph.get_node(address)\n    node.attr['height'] = 0.25 * current_allocation\n    node.attr['fontcolor'] = 'black'\n    block_data[address] = data\n    for k in range(len(data) // 4):\n        word = struct.unpack_from('<I', data, offset=k * 4)[0]\n        if word < len(rom) and k == 0 or address in qstr_pools:\n            potential_type = word\n            bgcolor = 'gray'\n            if address in qstr_pools:\n                bgcolor = 'tomato'\n            elif potential_type in function_types:\n                bgcolor = 'green'\n            elif potential_type in type_colors:\n                bgcolor = type_colors[potential_type]\n            elif print_unknown_types:\n                print('unknown type', hex(potential_type))\n            node.attr['label'] = '<' + node.attr['label'].replace('\"gray\"', '\"' + bgcolor + '\"') + '>'\n        if potential_type == str_type and k == 3:\n            string_blocks.append(word)\n        if potential_type == dict_type:\n            if k == 3:\n                map_element_blocks.append(word)\n        if ram_start < word < ram_start + len(ram) and word % 16 == 0:\n            port = k\n            if k < 4:\n                port = 0\n            ownership_graph.add_edge(address, word, tailport=str(port) + ':_')\n            print('  0x{:08x}'.format(word))\n            if address in qstr_pools:\n                if k > 0:\n                    qstr_chunks.append(word)\n            if k == 0:\n                potential_type = dynamic_type\n        if potential_type == dynamic_type:\n            if k == 0:\n                node.attr['fillcolor'] = 'plum'\n            if k == 3 and ram_start < word < ram_end:\n                map_element_blocks.append(word)\n        if potential_type in function_types:\n            if k == 2 and ram_start < word < ram_end:\n                bytecode_blocks.append(word)",
            "def save_allocated_block(end, current_allocation):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    allocation_length = current_allocation * BYTES_PER_BLOCK\n    start = end - allocation_length\n    address = pool_start + start\n    data = pool[start:end]\n    if print_block_state:\n        print('0x{:x} {} bytes allocated'.format(address, allocation_length))\n    if print_block_contents:\n        print(data)\n    rows = ''\n    for k in range(current_allocation - 1):\n        rows += '<tr>'\n        for l in range(4):\n            rows += '<td port=\"{}\" height=\"18\" width=\"20\"></td>'.format(4 * (k + 1) + l)\n        rows += '</tr>'\n    table = '<<table bgcolor=\"gray\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\"><tr><td colspan=\"4\" port=\"0\" height=\"18\" width=\"80\">0x{:08x}</td></tr>{}</table>>'.format(address, rows)\n    ownership_graph.add_node(address, label=table, style='invisible', shape='plaintext')\n    print('add  0x{:08x}'.format(address))\n    potential_type = None\n    node = ownership_graph.get_node(address)\n    node.attr['height'] = 0.25 * current_allocation\n    node.attr['fontcolor'] = 'black'\n    block_data[address] = data\n    for k in range(len(data) // 4):\n        word = struct.unpack_from('<I', data, offset=k * 4)[0]\n        if word < len(rom) and k == 0 or address in qstr_pools:\n            potential_type = word\n            bgcolor = 'gray'\n            if address in qstr_pools:\n                bgcolor = 'tomato'\n            elif potential_type in function_types:\n                bgcolor = 'green'\n            elif potential_type in type_colors:\n                bgcolor = type_colors[potential_type]\n            elif print_unknown_types:\n                print('unknown type', hex(potential_type))\n            node.attr['label'] = '<' + node.attr['label'].replace('\"gray\"', '\"' + bgcolor + '\"') + '>'\n        if potential_type == str_type and k == 3:\n            string_blocks.append(word)\n        if potential_type == dict_type:\n            if k == 3:\n                map_element_blocks.append(word)\n        if ram_start < word < ram_start + len(ram) and word % 16 == 0:\n            port = k\n            if k < 4:\n                port = 0\n            ownership_graph.add_edge(address, word, tailport=str(port) + ':_')\n            print('  0x{:08x}'.format(word))\n            if address in qstr_pools:\n                if k > 0:\n                    qstr_chunks.append(word)\n            if k == 0:\n                potential_type = dynamic_type\n        if potential_type == dynamic_type:\n            if k == 0:\n                node.attr['fillcolor'] = 'plum'\n            if k == 3 and ram_start < word < ram_end:\n                map_element_blocks.append(word)\n        if potential_type in function_types:\n            if k == 2 and ram_start < word < ram_end:\n                bytecode_blocks.append(word)",
            "def save_allocated_block(end, current_allocation):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    allocation_length = current_allocation * BYTES_PER_BLOCK\n    start = end - allocation_length\n    address = pool_start + start\n    data = pool[start:end]\n    if print_block_state:\n        print('0x{:x} {} bytes allocated'.format(address, allocation_length))\n    if print_block_contents:\n        print(data)\n    rows = ''\n    for k in range(current_allocation - 1):\n        rows += '<tr>'\n        for l in range(4):\n            rows += '<td port=\"{}\" height=\"18\" width=\"20\"></td>'.format(4 * (k + 1) + l)\n        rows += '</tr>'\n    table = '<<table bgcolor=\"gray\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\"><tr><td colspan=\"4\" port=\"0\" height=\"18\" width=\"80\">0x{:08x}</td></tr>{}</table>>'.format(address, rows)\n    ownership_graph.add_node(address, label=table, style='invisible', shape='plaintext')\n    print('add  0x{:08x}'.format(address))\n    potential_type = None\n    node = ownership_graph.get_node(address)\n    node.attr['height'] = 0.25 * current_allocation\n    node.attr['fontcolor'] = 'black'\n    block_data[address] = data\n    for k in range(len(data) // 4):\n        word = struct.unpack_from('<I', data, offset=k * 4)[0]\n        if word < len(rom) and k == 0 or address in qstr_pools:\n            potential_type = word\n            bgcolor = 'gray'\n            if address in qstr_pools:\n                bgcolor = 'tomato'\n            elif potential_type in function_types:\n                bgcolor = 'green'\n            elif potential_type in type_colors:\n                bgcolor = type_colors[potential_type]\n            elif print_unknown_types:\n                print('unknown type', hex(potential_type))\n            node.attr['label'] = '<' + node.attr['label'].replace('\"gray\"', '\"' + bgcolor + '\"') + '>'\n        if potential_type == str_type and k == 3:\n            string_blocks.append(word)\n        if potential_type == dict_type:\n            if k == 3:\n                map_element_blocks.append(word)\n        if ram_start < word < ram_start + len(ram) and word % 16 == 0:\n            port = k\n            if k < 4:\n                port = 0\n            ownership_graph.add_edge(address, word, tailport=str(port) + ':_')\n            print('  0x{:08x}'.format(word))\n            if address in qstr_pools:\n                if k > 0:\n                    qstr_chunks.append(word)\n            if k == 0:\n                potential_type = dynamic_type\n        if potential_type == dynamic_type:\n            if k == 0:\n                node.attr['fillcolor'] = 'plum'\n            if k == 3 and ram_start < word < ram_end:\n                map_element_blocks.append(word)\n        if potential_type in function_types:\n            if k == 2 and ram_start < word < ram_end:\n                bytecode_blocks.append(word)",
            "def save_allocated_block(end, current_allocation):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    allocation_length = current_allocation * BYTES_PER_BLOCK\n    start = end - allocation_length\n    address = pool_start + start\n    data = pool[start:end]\n    if print_block_state:\n        print('0x{:x} {} bytes allocated'.format(address, allocation_length))\n    if print_block_contents:\n        print(data)\n    rows = ''\n    for k in range(current_allocation - 1):\n        rows += '<tr>'\n        for l in range(4):\n            rows += '<td port=\"{}\" height=\"18\" width=\"20\"></td>'.format(4 * (k + 1) + l)\n        rows += '</tr>'\n    table = '<<table bgcolor=\"gray\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\"><tr><td colspan=\"4\" port=\"0\" height=\"18\" width=\"80\">0x{:08x}</td></tr>{}</table>>'.format(address, rows)\n    ownership_graph.add_node(address, label=table, style='invisible', shape='plaintext')\n    print('add  0x{:08x}'.format(address))\n    potential_type = None\n    node = ownership_graph.get_node(address)\n    node.attr['height'] = 0.25 * current_allocation\n    node.attr['fontcolor'] = 'black'\n    block_data[address] = data\n    for k in range(len(data) // 4):\n        word = struct.unpack_from('<I', data, offset=k * 4)[0]\n        if word < len(rom) and k == 0 or address in qstr_pools:\n            potential_type = word\n            bgcolor = 'gray'\n            if address in qstr_pools:\n                bgcolor = 'tomato'\n            elif potential_type in function_types:\n                bgcolor = 'green'\n            elif potential_type in type_colors:\n                bgcolor = type_colors[potential_type]\n            elif print_unknown_types:\n                print('unknown type', hex(potential_type))\n            node.attr['label'] = '<' + node.attr['label'].replace('\"gray\"', '\"' + bgcolor + '\"') + '>'\n        if potential_type == str_type and k == 3:\n            string_blocks.append(word)\n        if potential_type == dict_type:\n            if k == 3:\n                map_element_blocks.append(word)\n        if ram_start < word < ram_start + len(ram) and word % 16 == 0:\n            port = k\n            if k < 4:\n                port = 0\n            ownership_graph.add_edge(address, word, tailport=str(port) + ':_')\n            print('  0x{:08x}'.format(word))\n            if address in qstr_pools:\n                if k > 0:\n                    qstr_chunks.append(word)\n            if k == 0:\n                potential_type = dynamic_type\n        if potential_type == dynamic_type:\n            if k == 0:\n                node.attr['fillcolor'] = 'plum'\n            if k == 3 and ram_start < word < ram_end:\n                map_element_blocks.append(word)\n        if potential_type in function_types:\n            if k == 2 and ram_start < word < ram_end:\n                bytecode_blocks.append(word)"
        ]
    },
    {
        "func_name": "is_qstr",
        "original": "def is_qstr(obj):\n    return obj & 4286578695 == 6",
        "mutated": [
            "def is_qstr(obj):\n    if False:\n        i = 10\n    return obj & 4286578695 == 6",
            "def is_qstr(obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return obj & 4286578695 == 6",
            "def is_qstr(obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return obj & 4286578695 == 6",
            "def is_qstr(obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return obj & 4286578695 == 6",
            "def is_qstr(obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return obj & 4286578695 == 6"
        ]
    },
    {
        "func_name": "find_qstr",
        "original": "def find_qstr(qstr_index):\n    pool_ptr = last_pool\n    if not is_qstr(qstr_index):\n        return 'object'\n    pool = block_data[pool_ptr]\n    (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', pool)\n    qstr_index >>= 3\n    if qstr_index > total_prev_len + alloc:\n        return 'invalid'\n    while pool_ptr != 0:\n        if pool_ptr > ram_start:\n            if pool_ptr in block_data:\n                pool = block_data[pool_ptr]\n                (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', pool)\n            else:\n                print('missing qstr pool: {:08x}'.format(pool_ptr))\n                return 'missing'\n        else:\n            rom_offset = pool_ptr - rom_start\n            (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', rom[rom_offset:rom_offset + 32])\n            pool = rom[rom_offset:rom_offset + 32 + length * 4]\n        if qstr_index >= total_prev_len:\n            offset = (qstr_index - total_prev_len) * 4 + 16\n            start = struct.unpack_from('<I', pool, offset=offset)[0]\n            if start < heap_start:\n                start -= rom_start\n                if start > len(rom):\n                    return 'more than rom: {:x}'.format(start + rom_start)\n                (qstr_hash, qstr_len) = struct.unpack('<BB', rom[start:start + 2])\n                return rom[start + 2:start + 2 + qstr_len].decode('utf-8')\n            else:\n                if start > heap_start + len(heap):\n                    return 'out of range: {:x}'.format(start)\n                local = start - heap_start\n                (qstr_hash, qstr_len) = struct.unpack('<BB', heap[local:local + 2])\n                return heap[local + 2:local + 2 + qstr_len].decode('utf-8')\n        pool_ptr = prev\n    return 'unknown'",
        "mutated": [
            "def find_qstr(qstr_index):\n    if False:\n        i = 10\n    pool_ptr = last_pool\n    if not is_qstr(qstr_index):\n        return 'object'\n    pool = block_data[pool_ptr]\n    (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', pool)\n    qstr_index >>= 3\n    if qstr_index > total_prev_len + alloc:\n        return 'invalid'\n    while pool_ptr != 0:\n        if pool_ptr > ram_start:\n            if pool_ptr in block_data:\n                pool = block_data[pool_ptr]\n                (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', pool)\n            else:\n                print('missing qstr pool: {:08x}'.format(pool_ptr))\n                return 'missing'\n        else:\n            rom_offset = pool_ptr - rom_start\n            (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', rom[rom_offset:rom_offset + 32])\n            pool = rom[rom_offset:rom_offset + 32 + length * 4]\n        if qstr_index >= total_prev_len:\n            offset = (qstr_index - total_prev_len) * 4 + 16\n            start = struct.unpack_from('<I', pool, offset=offset)[0]\n            if start < heap_start:\n                start -= rom_start\n                if start > len(rom):\n                    return 'more than rom: {:x}'.format(start + rom_start)\n                (qstr_hash, qstr_len) = struct.unpack('<BB', rom[start:start + 2])\n                return rom[start + 2:start + 2 + qstr_len].decode('utf-8')\n            else:\n                if start > heap_start + len(heap):\n                    return 'out of range: {:x}'.format(start)\n                local = start - heap_start\n                (qstr_hash, qstr_len) = struct.unpack('<BB', heap[local:local + 2])\n                return heap[local + 2:local + 2 + qstr_len].decode('utf-8')\n        pool_ptr = prev\n    return 'unknown'",
            "def find_qstr(qstr_index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pool_ptr = last_pool\n    if not is_qstr(qstr_index):\n        return 'object'\n    pool = block_data[pool_ptr]\n    (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', pool)\n    qstr_index >>= 3\n    if qstr_index > total_prev_len + alloc:\n        return 'invalid'\n    while pool_ptr != 0:\n        if pool_ptr > ram_start:\n            if pool_ptr in block_data:\n                pool = block_data[pool_ptr]\n                (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', pool)\n            else:\n                print('missing qstr pool: {:08x}'.format(pool_ptr))\n                return 'missing'\n        else:\n            rom_offset = pool_ptr - rom_start\n            (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', rom[rom_offset:rom_offset + 32])\n            pool = rom[rom_offset:rom_offset + 32 + length * 4]\n        if qstr_index >= total_prev_len:\n            offset = (qstr_index - total_prev_len) * 4 + 16\n            start = struct.unpack_from('<I', pool, offset=offset)[0]\n            if start < heap_start:\n                start -= rom_start\n                if start > len(rom):\n                    return 'more than rom: {:x}'.format(start + rom_start)\n                (qstr_hash, qstr_len) = struct.unpack('<BB', rom[start:start + 2])\n                return rom[start + 2:start + 2 + qstr_len].decode('utf-8')\n            else:\n                if start > heap_start + len(heap):\n                    return 'out of range: {:x}'.format(start)\n                local = start - heap_start\n                (qstr_hash, qstr_len) = struct.unpack('<BB', heap[local:local + 2])\n                return heap[local + 2:local + 2 + qstr_len].decode('utf-8')\n        pool_ptr = prev\n    return 'unknown'",
            "def find_qstr(qstr_index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pool_ptr = last_pool\n    if not is_qstr(qstr_index):\n        return 'object'\n    pool = block_data[pool_ptr]\n    (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', pool)\n    qstr_index >>= 3\n    if qstr_index > total_prev_len + alloc:\n        return 'invalid'\n    while pool_ptr != 0:\n        if pool_ptr > ram_start:\n            if pool_ptr in block_data:\n                pool = block_data[pool_ptr]\n                (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', pool)\n            else:\n                print('missing qstr pool: {:08x}'.format(pool_ptr))\n                return 'missing'\n        else:\n            rom_offset = pool_ptr - rom_start\n            (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', rom[rom_offset:rom_offset + 32])\n            pool = rom[rom_offset:rom_offset + 32 + length * 4]\n        if qstr_index >= total_prev_len:\n            offset = (qstr_index - total_prev_len) * 4 + 16\n            start = struct.unpack_from('<I', pool, offset=offset)[0]\n            if start < heap_start:\n                start -= rom_start\n                if start > len(rom):\n                    return 'more than rom: {:x}'.format(start + rom_start)\n                (qstr_hash, qstr_len) = struct.unpack('<BB', rom[start:start + 2])\n                return rom[start + 2:start + 2 + qstr_len].decode('utf-8')\n            else:\n                if start > heap_start + len(heap):\n                    return 'out of range: {:x}'.format(start)\n                local = start - heap_start\n                (qstr_hash, qstr_len) = struct.unpack('<BB', heap[local:local + 2])\n                return heap[local + 2:local + 2 + qstr_len].decode('utf-8')\n        pool_ptr = prev\n    return 'unknown'",
            "def find_qstr(qstr_index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pool_ptr = last_pool\n    if not is_qstr(qstr_index):\n        return 'object'\n    pool = block_data[pool_ptr]\n    (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', pool)\n    qstr_index >>= 3\n    if qstr_index > total_prev_len + alloc:\n        return 'invalid'\n    while pool_ptr != 0:\n        if pool_ptr > ram_start:\n            if pool_ptr in block_data:\n                pool = block_data[pool_ptr]\n                (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', pool)\n            else:\n                print('missing qstr pool: {:08x}'.format(pool_ptr))\n                return 'missing'\n        else:\n            rom_offset = pool_ptr - rom_start\n            (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', rom[rom_offset:rom_offset + 32])\n            pool = rom[rom_offset:rom_offset + 32 + length * 4]\n        if qstr_index >= total_prev_len:\n            offset = (qstr_index - total_prev_len) * 4 + 16\n            start = struct.unpack_from('<I', pool, offset=offset)[0]\n            if start < heap_start:\n                start -= rom_start\n                if start > len(rom):\n                    return 'more than rom: {:x}'.format(start + rom_start)\n                (qstr_hash, qstr_len) = struct.unpack('<BB', rom[start:start + 2])\n                return rom[start + 2:start + 2 + qstr_len].decode('utf-8')\n            else:\n                if start > heap_start + len(heap):\n                    return 'out of range: {:x}'.format(start)\n                local = start - heap_start\n                (qstr_hash, qstr_len) = struct.unpack('<BB', heap[local:local + 2])\n                return heap[local + 2:local + 2 + qstr_len].decode('utf-8')\n        pool_ptr = prev\n    return 'unknown'",
            "def find_qstr(qstr_index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pool_ptr = last_pool\n    if not is_qstr(qstr_index):\n        return 'object'\n    pool = block_data[pool_ptr]\n    (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', pool)\n    qstr_index >>= 3\n    if qstr_index > total_prev_len + alloc:\n        return 'invalid'\n    while pool_ptr != 0:\n        if pool_ptr > ram_start:\n            if pool_ptr in block_data:\n                pool = block_data[pool_ptr]\n                (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', pool)\n            else:\n                print('missing qstr pool: {:08x}'.format(pool_ptr))\n                return 'missing'\n        else:\n            rom_offset = pool_ptr - rom_start\n            (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', rom[rom_offset:rom_offset + 32])\n            pool = rom[rom_offset:rom_offset + 32 + length * 4]\n        if qstr_index >= total_prev_len:\n            offset = (qstr_index - total_prev_len) * 4 + 16\n            start = struct.unpack_from('<I', pool, offset=offset)[0]\n            if start < heap_start:\n                start -= rom_start\n                if start > len(rom):\n                    return 'more than rom: {:x}'.format(start + rom_start)\n                (qstr_hash, qstr_len) = struct.unpack('<BB', rom[start:start + 2])\n                return rom[start + 2:start + 2 + qstr_len].decode('utf-8')\n            else:\n                if start > heap_start + len(heap):\n                    return 'out of range: {:x}'.format(start)\n                local = start - heap_start\n                (qstr_hash, qstr_len) = struct.unpack('<BB', heap[local:local + 2])\n                return heap[local + 2:local + 2 + qstr_len].decode('utf-8')\n        pool_ptr = prev\n    return 'unknown'"
        ]
    },
    {
        "func_name": "format",
        "original": "def format(obj):\n    if obj & 1 != 0:\n        return obj >> 1\n    if is_qstr(obj):\n        return find_qstr(obj)\n    else:\n        return '0x{:08x}'.format(obj)",
        "mutated": [
            "def format(obj):\n    if False:\n        i = 10\n    if obj & 1 != 0:\n        return obj >> 1\n    if is_qstr(obj):\n        return find_qstr(obj)\n    else:\n        return '0x{:08x}'.format(obj)",
            "def format(obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if obj & 1 != 0:\n        return obj >> 1\n    if is_qstr(obj):\n        return find_qstr(obj)\n    else:\n        return '0x{:08x}'.format(obj)",
            "def format(obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if obj & 1 != 0:\n        return obj >> 1\n    if is_qstr(obj):\n        return find_qstr(obj)\n    else:\n        return '0x{:08x}'.format(obj)",
            "def format(obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if obj & 1 != 0:\n        return obj >> 1\n    if is_qstr(obj):\n        return find_qstr(obj)\n    else:\n        return '0x{:08x}'.format(obj)",
            "def format(obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if obj & 1 != 0:\n        return obj >> 1\n    if is_qstr(obj):\n        return find_qstr(obj)\n    else:\n        return '0x{:08x}'.format(obj)"
        ]
    },
    {
        "func_name": "do_all_the_things",
        "original": "@click.command()\n@click.argument('ram_filename')\n@click.argument('bin_filename')\n@click.argument('map_filename')\n@click.option('--print_block_contents', default=False, help='Prints the contents of each allocated block')\n@click.option('--print_unknown_types', default=False, help=\"Prints the micropython base type if we don't understand it.\")\n@click.option('--print_block_state', default=False, help='Prints the heap block states (allocated or free)')\n@click.option('--print_conflicting_symbols', default=False, help='Prints conflicting symbols from the map')\n@click.option('--print-heap-structure/--no-print-heap-structure', default=False, help='Print heap structure')\n@click.option('--output_directory', default='heapvis', help='Destination for rendered output')\n@click.option('--draw-heap-layout/--no-draw-heap-layout', default=True, help='Draw the heap layout')\n@click.option('--draw-heap-ownership/--no-draw-heap-ownership', default=False, help='Draw the ownership graph of blocks on the heap')\n@click.option('--analyze-snapshots', default='last', type=click.Choice(['all', 'last']))\ndef do_all_the_things(ram_filename, bin_filename, map_filename, print_block_contents, print_unknown_types, print_block_state, print_conflicting_symbols, print_heap_structure, output_directory, draw_heap_layout, draw_heap_ownership, analyze_snapshots):\n    with open(ram_filename, 'rb') as f:\n        ram_dump = f.read()\n    with open(bin_filename, 'rb') as f:\n        rom = f.read()\n    symbols = {}\n    symbol_lookup = {}\n    manual_symbol_map = {}\n\n    def add_symbol(name, address=None, size=None):\n        if 'lto_priv' in name:\n            name = name.split('.')[0]\n        if address:\n            address = int(address, 0)\n        if size:\n            size = int(size, 0)\n        if name in symbols:\n            if address and symbols[name][0] and (symbols[name][0] != address):\n                if print_conflicting_symbols:\n                    print('Conflicting symbol: {} at addresses 0x{:08x} and 0x{:08x}'.format(name, address, symbols[name][0]))\n                return\n            if not address:\n                address = symbols[name][0]\n            if not size:\n                size = symbols[name][1]\n        symbols[name] = (address, size)\n        if address:\n            if not size:\n                size = 4\n            for offset in range(0, size, 4):\n                symbol_lookup[address + offset] = '{}+{}'.format(name, offset)\n    with open(map_filename, 'r') as f:\n        common_symbols = False\n        name = None\n        for line in f:\n            line = line.strip()\n            parts = line.split()\n            if line.startswith('Common symbol'):\n                common_symbols = True\n            if line == 'Discarded input sections':\n                common_symbols = False\n            if common_symbols:\n                if len(parts) == 1:\n                    name = parts[0]\n                elif len(parts) == 2 and name:\n                    add_symbol(name, size=parts[0])\n                    name = None\n                elif len(parts) == 3:\n                    add_symbol(parts[0], size=parts[1])\n                    name = None\n            else:\n                if len(parts) == 1 and parts[0].startswith(('.text', '.rodata', '.bss')) and (parts[0].count('.') > 1) and (not parts[0].isnumeric()) and ('.str' not in parts[0]):\n                    name = parts[0].split('.')[2]\n                if len(parts) == 3 and parts[0].startswith('0x') and parts[1].startswith('0x') and name:\n                    add_symbol(name, parts[0], parts[1])\n                    name = None\n                if len(parts) == 2 and parts[0].startswith('0x') and (not parts[1].startswith('0x')):\n                    add_symbol(parts[1], parts[0])\n                if len(parts) == 4 and parts[0] not in SKIP_SYMBOLS and parts[1].startswith('0x') and parts[2].startswith('0x'):\n                    (name, address, size, source) = parts\n                    if name.startswith(('.text', '.rodata', '.bss')) and name.count('.') > 1:\n                        name = name.split('.')[-1]\n                        add_symbol(name, address, size)\n                    name = None\n                if len(parts) >= 4 and parts[0].startswith('0x') and (parts[2] == '=') and (parts[1] != '.'):\n                    add_symbol(parts[1], parts[0])\n    rom_start = symbols['_sfixed'][0]\n    ram_start = symbols['_srelocate'][0]\n    ram_end = symbols['_estack'][0]\n    ram_length = ram_end - ram_start\n    if analyze_snapshots == 'all':\n        snapshots = range(len(ram_dump) // ram_length - 1, -1, -1)\n    elif analyze_snapshots == 'last':\n        snapshots = range(len(ram_dump) // ram_length - 1, len(ram_dump) // ram_length - 2, -1)\n    for snapshot_num in snapshots:\n        ram = ram_dump[ram_length * snapshot_num:ram_length * (snapshot_num + 1)]\n        ownership_graph = pgv.AGraph(directed=True)\n\n        def load(address, size=4):\n            if size is None:\n                raise ValueError('You must provide a size')\n            if address > ram_start:\n                ram_address = address - ram_start\n                if ram_address + size > len(ram):\n                    raise ValueError('Unable to read 0x{:08x} from ram.'.format(address))\n                return ram[ram_address:ram_address + size]\n            elif address < len(rom):\n                if address + size > len(rom):\n                    raise ValueError('Unable to read 0x{:08x} from rom.'.format(address))\n                return rom[address:address + size]\n\n        def load_pointer(address):\n            return struct.unpack('<I', load(address))[0]\n        if 'heap' in symbols:\n            (heap_start, heap_size) = symbols['heap']\n        else:\n            print('no static heap')\n            (allocations_start, allocations_size) = symbols['allocations']\n            allocations = load(allocations_start, allocations_size)\n            first_zero = True\n            potential_heap = None\n            for (address, size) in struct.iter_unpack('<II', allocations):\n                print(address, size)\n                if address == 0 and first_zero:\n                    first_zero = False\n                if first_zero:\n                    potential_heap = (address, size)\n                if not first_zero and address != 0:\n                    if address != potential_heap[0] + potential_heap[1]:\n                        print('no active heap')\n                        return\n                    else:\n                        (heap_start, heap_size) = potential_heap\n                        break\n        print('found heap', heap_start, heap_size)\n        heap = load(heap_start, heap_size)\n        total_byte_len = len(heap)\n        mp_state_ctx = symbols['mp_state_ctx'][0]\n        manual_symbol_map['mp_state_ctx+20'] = 'mp_state_ctx.vm.last_pool'\n        last_pool = load_pointer(mp_state_ctx + 20)\n        manual_symbol_map['mp_state_ctx+108'] = 'mp_state_ctx.vm.dict_main.map.table'\n        dict_main_table = load_pointer(mp_state_ctx + 108)\n        manual_symbol_map['mp_state_ctx+84'] = 'mp_state_ctx.vm.mp_loaded_modules_dict.map.table'\n        imports_table = load_pointer(mp_state_ctx + 84)\n        manual_symbol_map['mp_state_ctx+124'] = 'mp_state_ctx.vm.mp_sys_path_obj.items'\n        manual_symbol_map['mp_state_ctx+140'] = 'mp_state_ctx.vm.mp_sys_argv_obj.items'\n        manual_symbol_map['mp_state_ctx+96'] = 'mp_state_ctx.vm.dict_main'\n        manual_symbol_map['0x200015e0'] = 'mp_state_ctx.vm.dict_main'\n        for i in range(READLINE_HIST_SIZE):\n            manual_symbol_map['mp_state_ctx+{}'.format(148 + i * 4)] = 'mp_state_ctx.vm.readline_hist[{}]'.format(i)\n        tuple_type = symbols['mp_type_tuple'][0]\n        type_type = symbols['mp_type_type'][0]\n        map_type = symbols['mp_type_map'][0]\n        dict_type = symbols['mp_type_dict'][0]\n        property_type = symbols['mp_type_property'][0]\n        str_type = symbols['mp_type_str'][0]\n        function_types = [symbols['mp_type_fun_' + x][0] for x in ['bc', 'builtin_0', 'builtin_1', 'builtin_2', 'builtin_3', 'builtin_var']]\n        bytearray_type = symbols['mp_type_bytearray'][0]\n        dynamic_type = 1073741824\n        type_colors = {dict_type: 'red', property_type: 'yellow', map_type: 'blue', type_type: 'orange', tuple_type: 'skyblue', str_type: 'pink', bytearray_type: 'purple'}\n        pool_shift = heap_start % BYTES_PER_BLOCK\n        atb_length = total_byte_len * BITS_PER_BYTE // (BITS_PER_BYTE + BITS_PER_BYTE * BLOCKS_PER_ATB // BLOCKS_PER_FTB + BITS_PER_BYTE * BLOCKS_PER_ATB * BYTES_PER_BLOCK)\n        pool_length = atb_length * BLOCKS_PER_ATB * BYTES_PER_BLOCK\n        gc_finaliser_table_byte_len = (atb_length * BLOCKS_PER_ATB + BLOCKS_PER_FTB - 1) // BLOCKS_PER_FTB\n        if print_heap_structure:\n            print('mp_state_ctx at 0x{:08x} and length {}'.format(*symbols['mp_state_ctx']))\n            print('Total heap length:', total_byte_len)\n            print('ATB length:', atb_length)\n            print('Total allocatable:', pool_length)\n            print('FTB length:', gc_finaliser_table_byte_len)\n        pool_start = heap_start + total_byte_len - pool_length - pool_shift\n        pool = heap[-pool_length - pool_shift:]\n        total_height = 128 * 18\n        total_width = pool_length // (128 * 16) * 85\n        map_element_blocks = [dict_main_table, imports_table]\n        string_blocks = []\n        bytecode_blocks = []\n        qstr_pools = []\n        qstr_chunks = []\n        block_data = {}\n        prev_pool = last_pool\n        while prev_pool > ram_start:\n            qstr_pools.append(prev_pool)\n            prev_pool = load_pointer(prev_pool)\n\n        def save_allocated_block(end, current_allocation):\n            allocation_length = current_allocation * BYTES_PER_BLOCK\n            start = end - allocation_length\n            address = pool_start + start\n            data = pool[start:end]\n            if print_block_state:\n                print('0x{:x} {} bytes allocated'.format(address, allocation_length))\n            if print_block_contents:\n                print(data)\n            rows = ''\n            for k in range(current_allocation - 1):\n                rows += '<tr>'\n                for l in range(4):\n                    rows += '<td port=\"{}\" height=\"18\" width=\"20\"></td>'.format(4 * (k + 1) + l)\n                rows += '</tr>'\n            table = '<<table bgcolor=\"gray\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\"><tr><td colspan=\"4\" port=\"0\" height=\"18\" width=\"80\">0x{:08x}</td></tr>{}</table>>'.format(address, rows)\n            ownership_graph.add_node(address, label=table, style='invisible', shape='plaintext')\n            print('add  0x{:08x}'.format(address))\n            potential_type = None\n            node = ownership_graph.get_node(address)\n            node.attr['height'] = 0.25 * current_allocation\n            node.attr['fontcolor'] = 'black'\n            block_data[address] = data\n            for k in range(len(data) // 4):\n                word = struct.unpack_from('<I', data, offset=k * 4)[0]\n                if word < len(rom) and k == 0 or address in qstr_pools:\n                    potential_type = word\n                    bgcolor = 'gray'\n                    if address in qstr_pools:\n                        bgcolor = 'tomato'\n                    elif potential_type in function_types:\n                        bgcolor = 'green'\n                    elif potential_type in type_colors:\n                        bgcolor = type_colors[potential_type]\n                    elif print_unknown_types:\n                        print('unknown type', hex(potential_type))\n                    node.attr['label'] = '<' + node.attr['label'].replace('\"gray\"', '\"' + bgcolor + '\"') + '>'\n                if potential_type == str_type and k == 3:\n                    string_blocks.append(word)\n                if potential_type == dict_type:\n                    if k == 3:\n                        map_element_blocks.append(word)\n                if ram_start < word < ram_start + len(ram) and word % 16 == 0:\n                    port = k\n                    if k < 4:\n                        port = 0\n                    ownership_graph.add_edge(address, word, tailport=str(port) + ':_')\n                    print('  0x{:08x}'.format(word))\n                    if address in qstr_pools:\n                        if k > 0:\n                            qstr_chunks.append(word)\n                    if k == 0:\n                        potential_type = dynamic_type\n                if potential_type == dynamic_type:\n                    if k == 0:\n                        node.attr['fillcolor'] = 'plum'\n                    if k == 3 and ram_start < word < ram_end:\n                        map_element_blocks.append(word)\n                if potential_type in function_types:\n                    if k == 2 and ram_start < word < ram_end:\n                        bytecode_blocks.append(word)\n        longest_free = 0\n        current_free = 0\n        current_allocation = 0\n        total_free = 0\n        for i in range(atb_length):\n            atb = heap[i]\n            for j in range(4):\n                block_state = atb >> j * 2 & 3\n                if block_state != AT_FREE and current_free > 0:\n                    if print_block_state:\n                        print('{} bytes free'.format(current_free * BYTES_PER_BLOCK))\n                    current_free = 0\n                if block_state != AT_TAIL and current_allocation > 0:\n                    save_allocated_block((i * BLOCKS_PER_ATB + j) * BYTES_PER_BLOCK, current_allocation)\n                    current_allocation = 0\n                if block_state == AT_FREE:\n                    current_free += 1\n                    total_free += 1\n                elif block_state == AT_HEAD or block_state == AT_MARK:\n                    current_allocation = 1\n                elif block_state == AT_TAIL and current_allocation > 0:\n                    current_allocation += 1\n                longest_free = max(longest_free, current_free)\n        if current_allocation > 0:\n            save_allocated_block(pool_length, current_allocation)\n\n        def is_qstr(obj):\n            return obj & 4286578695 == 6\n\n        def find_qstr(qstr_index):\n            pool_ptr = last_pool\n            if not is_qstr(qstr_index):\n                return 'object'\n            pool = block_data[pool_ptr]\n            (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', pool)\n            qstr_index >>= 3\n            if qstr_index > total_prev_len + alloc:\n                return 'invalid'\n            while pool_ptr != 0:\n                if pool_ptr > ram_start:\n                    if pool_ptr in block_data:\n                        pool = block_data[pool_ptr]\n                        (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', pool)\n                    else:\n                        print('missing qstr pool: {:08x}'.format(pool_ptr))\n                        return 'missing'\n                else:\n                    rom_offset = pool_ptr - rom_start\n                    (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', rom[rom_offset:rom_offset + 32])\n                    pool = rom[rom_offset:rom_offset + 32 + length * 4]\n                if qstr_index >= total_prev_len:\n                    offset = (qstr_index - total_prev_len) * 4 + 16\n                    start = struct.unpack_from('<I', pool, offset=offset)[0]\n                    if start < heap_start:\n                        start -= rom_start\n                        if start > len(rom):\n                            return 'more than rom: {:x}'.format(start + rom_start)\n                        (qstr_hash, qstr_len) = struct.unpack('<BB', rom[start:start + 2])\n                        return rom[start + 2:start + 2 + qstr_len].decode('utf-8')\n                    else:\n                        if start > heap_start + len(heap):\n                            return 'out of range: {:x}'.format(start)\n                        local = start - heap_start\n                        (qstr_hash, qstr_len) = struct.unpack('<BB', heap[local:local + 2])\n                        return heap[local + 2:local + 2 + qstr_len].decode('utf-8')\n                pool_ptr = prev\n            return 'unknown'\n\n        def format(obj):\n            if obj & 1 != 0:\n                return obj >> 1\n            if is_qstr(obj):\n                return find_qstr(obj)\n            else:\n                return '0x{:08x}'.format(obj)\n        for block in sorted(map_element_blocks):\n            if block == 0:\n                continue\n            try:\n                node = ownership_graph.get_node(block)\n            except KeyError:\n                print('Unable to find memory block for 0x{:08x}. Is there something running?'.format(block))\n                continue\n            if block not in block_data:\n                continue\n            data = block_data[block]\n            cells = []\n            for i in range(len(data) // 8):\n                (key, value) = struct.unpack_from('<II', data, offset=i * 8)\n                if key == MP_OBJ_NULL or key == MP_OBJ_SENTINEL:\n                    cells.append(('', ' '))\n                else:\n                    cells.append((key, format(key)))\n                    if value in block_data:\n                        edge = ownership_graph.get_edge(block, value)\n                        edge.attr['tailport'] = str(key)\n            rows = ''\n            for i in range(len(cells) // 2):\n                rows += '<tr><td port=\"{}\">{}</td><td port=\"{}\">{}</td></tr>'.format(cells[2 * i][0], cells[2 * i][1], cells[2 * i + 1][0], cells[2 * i + 1][1])\n            node.attr['shape'] = 'plaintext'\n            node.attr['style'] = 'invisible'\n            node.attr['label'] = '<<table bgcolor=\"gold\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\"><tr><td colspan=\"2\">0x{:08x}</td></tr>{}</table>>'.format(block, rows)\n        for (node, degree) in ownership_graph.in_degree_iter():\n            print(node, degree)\n            if degree == 0:\n                address_bytes = struct.pack('<I', int(node))\n                location = -1\n                for _ in range(ram.count(address_bytes)):\n                    location = ram.find(address_bytes, location + 1)\n                    pointer_location = ram_start + location\n                    source = '0x{:08x}'.format(pointer_location)\n                    if pointer_location in symbol_lookup:\n                        source = symbol_lookup[pointer_location]\n                    if source in manual_symbol_map:\n                        source = manual_symbol_map[source]\n                    if 'readline_hist' in source:\n                        string_blocks.append(int(node))\n                    if pointer_location > heap_start + heap_size:\n                        source = 'stack ' + source\n                    ownership_graph.add_edge(source, node)\n        for block in string_blocks:\n            if block == 0:\n                continue\n            node = ownership_graph.get_node(block)\n            node.attr['fillcolor'] = 'hotpink'\n            if block in block_data:\n                raw_string = block_data[block]\n            else:\n                print('Unable to find memory block for string at 0x{:08x}.'.format(block))\n                continue\n            try:\n                raw_string = block_data[block].decode('utf-8')\n            except:\n                raw_string = str(block_data[block])\n            wrapped = []\n            for i in range(0, len(raw_string), 16):\n                wrapped.append(raw_string[i:i + 16])\n            node.attr['label'] = '\\n'.join(wrapped)\n            node.attr['style'] = 'filled'\n            node.attr['fontname'] = 'FiraCode-Medium'\n            node.attr['fontpath'] = '/Users/tannewt/Library/Fonts/'\n            node.attr['fontsize'] = 8\n            node.attr['height'] = len(wrapped) * 0.25\n        for block in bytecode_blocks:\n            node = ownership_graph.get_node(block)\n            node.attr['fillcolor'] = 'lightseagreen'\n            if block in block_data:\n                data = block_data[block]\n            else:\n                print('Unable to find memory block for bytecode at 0x{:08x}.'.format(block))\n                continue\n            prelude = Prelude(io.BufferedReader(io.BytesIO(data)))\n            node.attr['shape'] = 'plaintext'\n            node.attr['style'] = 'invisible'\n            code_info_size = prelude.code_info_size\n            rows = ''\n            remaining_bytecode = len(data) - 16\n            while code_info_size >= 16:\n                rows += '<tr><td colspan=\"16\" bgcolor=\"palegreen\" height=\"18\" width=\"80\"></td></tr>'\n                code_info_size -= 16\n                remaining_bytecode -= 16\n            if code_info_size > 0:\n                rows += '<tr><td colspan=\"{}\" bgcolor=\"palegreen\" height=\"18\" width=\"{}\"></td><td colspan=\"{}\" bgcolor=\"seagreen\" height=\"18\" width=\"{}\"></td></tr>'.format(code_info_size, code_info_size * (80 / 16), 16 - code_info_size, 80 / 16 * (16 - code_info_size))\n                remaining_bytecode -= 16\n            for i in range(remaining_bytecode // 16):\n                rows += '<tr><td colspan=\"16\" bgcolor=\"seagreen\" height=\"18\" width=\"80\"></td></tr>'\n            node.attr['label'] = '<<table border=\"1\" cellspacing=\"0\"><tr><td colspan=\"16\" bgcolor=\"lightseagreen\" height=\"18\" width=\"80\">0x{:08x}</td></tr>{}</table>>'.format(block, rows)\n        for block in qstr_chunks:\n            if block not in block_data:\n                ownership_graph.delete_node(block)\n                continue\n            data = block_data[block]\n            qstrs_in_chunk = ''\n            offset = 0\n            while offset < len(data) - 1:\n                (qstr_hash, qstr_len) = struct.unpack_from('<BB', data, offset=offset)\n                if qstr_hash == 0:\n                    qstrs_in_chunk += ' ' * (len(data) - offset)\n                    offset = len(data)\n                    continue\n                offset += 2 + qstr_len + 1\n                try:\n                    qstrs_in_chunk += '  ' + data[offset - qstr_len - 1:offset - 1].decode('utf-8')\n                except UnicodeDecodeError:\n                    qstrs_in_chunk += '  ' + '\u2591' * qstr_len\n            printable_qstrs = ''\n            for i in range(len(qstrs_in_chunk)):\n                c = qstrs_in_chunk[i]\n                if c not in string.printable or c in '\\x0b\\x0c':\n                    printable_qstrs += '\u2591'\n                else:\n                    printable_qstrs += qstrs_in_chunk[i]\n            wrapped = []\n            for i in range(0, len(printable_qstrs), 16):\n                wrapped.append(html.escape(printable_qstrs[i:i + 16]))\n            node = ownership_graph.get_node(block)\n            node.attr['label'] = '<<table border=\"1\" cellspacing=\"0\" bgcolor=\"lightsalmon\" width=\"80\"><tr><td height=\"18\" >0x{:08x}</td></tr><tr><td height=\"{}\" >{}</td></tr></table>>'.format(block, 18 * (len(wrapped) - 1), '<br/>'.join(wrapped))\n            node.attr['fontname'] = 'FiraCode-Bold'\n            node.attr['fontcolor'] = 'black'\n            node.attr['fontpath'] = '/Users/tannewt/Library/Fonts/'\n            node.attr['fontsize'] = 8\n        print('Total free space:', BYTES_PER_BLOCK * total_free)\n        print('Longest free space:', BYTES_PER_BLOCK * longest_free)\n        if draw_heap_ownership:\n            ownership_graph.layout(prog='dot')\n            fn = os.path.join(output_directory, 'heap_ownership{:04d}.svg'.format(snapshot_num))\n            print(fn)\n            ownership_graph.draw(fn)\n        if draw_heap_ownership:\n            for edge in ownership_graph.iteredges():\n                del edge.attr['pos']\n        else:\n            for edge in ownership_graph.edges():\n                ownership_graph.delete_edge(edge)\n        for node in ownership_graph.nodes():\n            try:\n                address = int(node.name)\n            except ValueError:\n                ownership_graph.remove_node(node.name)\n                continue\n            block = (address - pool_start) // 16\n            x = block // 128\n            y = 128 - block % 128\n            try:\n                height = float(node.attr['height'])\n            except:\n                height = 0.25\n            node.attr['pos'] = '{},{}'.format(x * 80, (y - (height - 0.25) * 2) * 18)\n        for block in sorted(map_element_blocks):\n            try:\n                node = ownership_graph.get_node(block)\n            except KeyError:\n                if block != 0:\n                    print('Unable to find memory block for 0x{:08x}. Is there something running?'.format(block))\n                continue\n            if block not in block_data:\n                continue\n            data = block_data[block]\n            cells = []\n            for i in range(len(data) // 8):\n                (key, value) = struct.unpack_from('<II', data, offset=i * 8)\n                if key == MP_OBJ_NULL or key == MP_OBJ_SENTINEL:\n                    cells.append(('', ' '))\n                else:\n                    cells.append((key, ''))\n            rows = ''\n            for i in range(len(cells) // 2):\n                rows += '<tr><td port=\"{}\" height=\"18\" width=\"40\">{}</td><td port=\"{}\" height=\"18\" width=\"40\">{}</td></tr>'.format(cells[2 * i][0], cells[2 * i][1], cells[2 * i + 1][0], cells[2 * i + 1][1])\n            node.attr['label'] = '<<table bgcolor=\"gold\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\">{}</table>>'.format(rows)\n        ownership_graph.add_node('center', pos='{},{}'.format(total_width // 2 - 40, total_height // 2), shape='plaintext', label=' ')\n        ownership_graph.graph_attr['viewport'] = '{},{},1,{}'.format(total_width, total_height, 'center')\n        ownership_graph.has_layout = True\n        if draw_heap_layout:\n            fn = os.path.join(output_directory, 'heap_layout{:04d}.png'.format(snapshot_num))\n            print(fn)\n            ownership_graph.draw(fn)",
        "mutated": [
            "@click.command()\n@click.argument('ram_filename')\n@click.argument('bin_filename')\n@click.argument('map_filename')\n@click.option('--print_block_contents', default=False, help='Prints the contents of each allocated block')\n@click.option('--print_unknown_types', default=False, help=\"Prints the micropython base type if we don't understand it.\")\n@click.option('--print_block_state', default=False, help='Prints the heap block states (allocated or free)')\n@click.option('--print_conflicting_symbols', default=False, help='Prints conflicting symbols from the map')\n@click.option('--print-heap-structure/--no-print-heap-structure', default=False, help='Print heap structure')\n@click.option('--output_directory', default='heapvis', help='Destination for rendered output')\n@click.option('--draw-heap-layout/--no-draw-heap-layout', default=True, help='Draw the heap layout')\n@click.option('--draw-heap-ownership/--no-draw-heap-ownership', default=False, help='Draw the ownership graph of blocks on the heap')\n@click.option('--analyze-snapshots', default='last', type=click.Choice(['all', 'last']))\ndef do_all_the_things(ram_filename, bin_filename, map_filename, print_block_contents, print_unknown_types, print_block_state, print_conflicting_symbols, print_heap_structure, output_directory, draw_heap_layout, draw_heap_ownership, analyze_snapshots):\n    if False:\n        i = 10\n    with open(ram_filename, 'rb') as f:\n        ram_dump = f.read()\n    with open(bin_filename, 'rb') as f:\n        rom = f.read()\n    symbols = {}\n    symbol_lookup = {}\n    manual_symbol_map = {}\n\n    def add_symbol(name, address=None, size=None):\n        if 'lto_priv' in name:\n            name = name.split('.')[0]\n        if address:\n            address = int(address, 0)\n        if size:\n            size = int(size, 0)\n        if name in symbols:\n            if address and symbols[name][0] and (symbols[name][0] != address):\n                if print_conflicting_symbols:\n                    print('Conflicting symbol: {} at addresses 0x{:08x} and 0x{:08x}'.format(name, address, symbols[name][0]))\n                return\n            if not address:\n                address = symbols[name][0]\n            if not size:\n                size = symbols[name][1]\n        symbols[name] = (address, size)\n        if address:\n            if not size:\n                size = 4\n            for offset in range(0, size, 4):\n                symbol_lookup[address + offset] = '{}+{}'.format(name, offset)\n    with open(map_filename, 'r') as f:\n        common_symbols = False\n        name = None\n        for line in f:\n            line = line.strip()\n            parts = line.split()\n            if line.startswith('Common symbol'):\n                common_symbols = True\n            if line == 'Discarded input sections':\n                common_symbols = False\n            if common_symbols:\n                if len(parts) == 1:\n                    name = parts[0]\n                elif len(parts) == 2 and name:\n                    add_symbol(name, size=parts[0])\n                    name = None\n                elif len(parts) == 3:\n                    add_symbol(parts[0], size=parts[1])\n                    name = None\n            else:\n                if len(parts) == 1 and parts[0].startswith(('.text', '.rodata', '.bss')) and (parts[0].count('.') > 1) and (not parts[0].isnumeric()) and ('.str' not in parts[0]):\n                    name = parts[0].split('.')[2]\n                if len(parts) == 3 and parts[0].startswith('0x') and parts[1].startswith('0x') and name:\n                    add_symbol(name, parts[0], parts[1])\n                    name = None\n                if len(parts) == 2 and parts[0].startswith('0x') and (not parts[1].startswith('0x')):\n                    add_symbol(parts[1], parts[0])\n                if len(parts) == 4 and parts[0] not in SKIP_SYMBOLS and parts[1].startswith('0x') and parts[2].startswith('0x'):\n                    (name, address, size, source) = parts\n                    if name.startswith(('.text', '.rodata', '.bss')) and name.count('.') > 1:\n                        name = name.split('.')[-1]\n                        add_symbol(name, address, size)\n                    name = None\n                if len(parts) >= 4 and parts[0].startswith('0x') and (parts[2] == '=') and (parts[1] != '.'):\n                    add_symbol(parts[1], parts[0])\n    rom_start = symbols['_sfixed'][0]\n    ram_start = symbols['_srelocate'][0]\n    ram_end = symbols['_estack'][0]\n    ram_length = ram_end - ram_start\n    if analyze_snapshots == 'all':\n        snapshots = range(len(ram_dump) // ram_length - 1, -1, -1)\n    elif analyze_snapshots == 'last':\n        snapshots = range(len(ram_dump) // ram_length - 1, len(ram_dump) // ram_length - 2, -1)\n    for snapshot_num in snapshots:\n        ram = ram_dump[ram_length * snapshot_num:ram_length * (snapshot_num + 1)]\n        ownership_graph = pgv.AGraph(directed=True)\n\n        def load(address, size=4):\n            if size is None:\n                raise ValueError('You must provide a size')\n            if address > ram_start:\n                ram_address = address - ram_start\n                if ram_address + size > len(ram):\n                    raise ValueError('Unable to read 0x{:08x} from ram.'.format(address))\n                return ram[ram_address:ram_address + size]\n            elif address < len(rom):\n                if address + size > len(rom):\n                    raise ValueError('Unable to read 0x{:08x} from rom.'.format(address))\n                return rom[address:address + size]\n\n        def load_pointer(address):\n            return struct.unpack('<I', load(address))[0]\n        if 'heap' in symbols:\n            (heap_start, heap_size) = symbols['heap']\n        else:\n            print('no static heap')\n            (allocations_start, allocations_size) = symbols['allocations']\n            allocations = load(allocations_start, allocations_size)\n            first_zero = True\n            potential_heap = None\n            for (address, size) in struct.iter_unpack('<II', allocations):\n                print(address, size)\n                if address == 0 and first_zero:\n                    first_zero = False\n                if first_zero:\n                    potential_heap = (address, size)\n                if not first_zero and address != 0:\n                    if address != potential_heap[0] + potential_heap[1]:\n                        print('no active heap')\n                        return\n                    else:\n                        (heap_start, heap_size) = potential_heap\n                        break\n        print('found heap', heap_start, heap_size)\n        heap = load(heap_start, heap_size)\n        total_byte_len = len(heap)\n        mp_state_ctx = symbols['mp_state_ctx'][0]\n        manual_symbol_map['mp_state_ctx+20'] = 'mp_state_ctx.vm.last_pool'\n        last_pool = load_pointer(mp_state_ctx + 20)\n        manual_symbol_map['mp_state_ctx+108'] = 'mp_state_ctx.vm.dict_main.map.table'\n        dict_main_table = load_pointer(mp_state_ctx + 108)\n        manual_symbol_map['mp_state_ctx+84'] = 'mp_state_ctx.vm.mp_loaded_modules_dict.map.table'\n        imports_table = load_pointer(mp_state_ctx + 84)\n        manual_symbol_map['mp_state_ctx+124'] = 'mp_state_ctx.vm.mp_sys_path_obj.items'\n        manual_symbol_map['mp_state_ctx+140'] = 'mp_state_ctx.vm.mp_sys_argv_obj.items'\n        manual_symbol_map['mp_state_ctx+96'] = 'mp_state_ctx.vm.dict_main'\n        manual_symbol_map['0x200015e0'] = 'mp_state_ctx.vm.dict_main'\n        for i in range(READLINE_HIST_SIZE):\n            manual_symbol_map['mp_state_ctx+{}'.format(148 + i * 4)] = 'mp_state_ctx.vm.readline_hist[{}]'.format(i)\n        tuple_type = symbols['mp_type_tuple'][0]\n        type_type = symbols['mp_type_type'][0]\n        map_type = symbols['mp_type_map'][0]\n        dict_type = symbols['mp_type_dict'][0]\n        property_type = symbols['mp_type_property'][0]\n        str_type = symbols['mp_type_str'][0]\n        function_types = [symbols['mp_type_fun_' + x][0] for x in ['bc', 'builtin_0', 'builtin_1', 'builtin_2', 'builtin_3', 'builtin_var']]\n        bytearray_type = symbols['mp_type_bytearray'][0]\n        dynamic_type = 1073741824\n        type_colors = {dict_type: 'red', property_type: 'yellow', map_type: 'blue', type_type: 'orange', tuple_type: 'skyblue', str_type: 'pink', bytearray_type: 'purple'}\n        pool_shift = heap_start % BYTES_PER_BLOCK\n        atb_length = total_byte_len * BITS_PER_BYTE // (BITS_PER_BYTE + BITS_PER_BYTE * BLOCKS_PER_ATB // BLOCKS_PER_FTB + BITS_PER_BYTE * BLOCKS_PER_ATB * BYTES_PER_BLOCK)\n        pool_length = atb_length * BLOCKS_PER_ATB * BYTES_PER_BLOCK\n        gc_finaliser_table_byte_len = (atb_length * BLOCKS_PER_ATB + BLOCKS_PER_FTB - 1) // BLOCKS_PER_FTB\n        if print_heap_structure:\n            print('mp_state_ctx at 0x{:08x} and length {}'.format(*symbols['mp_state_ctx']))\n            print('Total heap length:', total_byte_len)\n            print('ATB length:', atb_length)\n            print('Total allocatable:', pool_length)\n            print('FTB length:', gc_finaliser_table_byte_len)\n        pool_start = heap_start + total_byte_len - pool_length - pool_shift\n        pool = heap[-pool_length - pool_shift:]\n        total_height = 128 * 18\n        total_width = pool_length // (128 * 16) * 85\n        map_element_blocks = [dict_main_table, imports_table]\n        string_blocks = []\n        bytecode_blocks = []\n        qstr_pools = []\n        qstr_chunks = []\n        block_data = {}\n        prev_pool = last_pool\n        while prev_pool > ram_start:\n            qstr_pools.append(prev_pool)\n            prev_pool = load_pointer(prev_pool)\n\n        def save_allocated_block(end, current_allocation):\n            allocation_length = current_allocation * BYTES_PER_BLOCK\n            start = end - allocation_length\n            address = pool_start + start\n            data = pool[start:end]\n            if print_block_state:\n                print('0x{:x} {} bytes allocated'.format(address, allocation_length))\n            if print_block_contents:\n                print(data)\n            rows = ''\n            for k in range(current_allocation - 1):\n                rows += '<tr>'\n                for l in range(4):\n                    rows += '<td port=\"{}\" height=\"18\" width=\"20\"></td>'.format(4 * (k + 1) + l)\n                rows += '</tr>'\n            table = '<<table bgcolor=\"gray\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\"><tr><td colspan=\"4\" port=\"0\" height=\"18\" width=\"80\">0x{:08x}</td></tr>{}</table>>'.format(address, rows)\n            ownership_graph.add_node(address, label=table, style='invisible', shape='plaintext')\n            print('add  0x{:08x}'.format(address))\n            potential_type = None\n            node = ownership_graph.get_node(address)\n            node.attr['height'] = 0.25 * current_allocation\n            node.attr['fontcolor'] = 'black'\n            block_data[address] = data\n            for k in range(len(data) // 4):\n                word = struct.unpack_from('<I', data, offset=k * 4)[0]\n                if word < len(rom) and k == 0 or address in qstr_pools:\n                    potential_type = word\n                    bgcolor = 'gray'\n                    if address in qstr_pools:\n                        bgcolor = 'tomato'\n                    elif potential_type in function_types:\n                        bgcolor = 'green'\n                    elif potential_type in type_colors:\n                        bgcolor = type_colors[potential_type]\n                    elif print_unknown_types:\n                        print('unknown type', hex(potential_type))\n                    node.attr['label'] = '<' + node.attr['label'].replace('\"gray\"', '\"' + bgcolor + '\"') + '>'\n                if potential_type == str_type and k == 3:\n                    string_blocks.append(word)\n                if potential_type == dict_type:\n                    if k == 3:\n                        map_element_blocks.append(word)\n                if ram_start < word < ram_start + len(ram) and word % 16 == 0:\n                    port = k\n                    if k < 4:\n                        port = 0\n                    ownership_graph.add_edge(address, word, tailport=str(port) + ':_')\n                    print('  0x{:08x}'.format(word))\n                    if address in qstr_pools:\n                        if k > 0:\n                            qstr_chunks.append(word)\n                    if k == 0:\n                        potential_type = dynamic_type\n                if potential_type == dynamic_type:\n                    if k == 0:\n                        node.attr['fillcolor'] = 'plum'\n                    if k == 3 and ram_start < word < ram_end:\n                        map_element_blocks.append(word)\n                if potential_type in function_types:\n                    if k == 2 and ram_start < word < ram_end:\n                        bytecode_blocks.append(word)\n        longest_free = 0\n        current_free = 0\n        current_allocation = 0\n        total_free = 0\n        for i in range(atb_length):\n            atb = heap[i]\n            for j in range(4):\n                block_state = atb >> j * 2 & 3\n                if block_state != AT_FREE and current_free > 0:\n                    if print_block_state:\n                        print('{} bytes free'.format(current_free * BYTES_PER_BLOCK))\n                    current_free = 0\n                if block_state != AT_TAIL and current_allocation > 0:\n                    save_allocated_block((i * BLOCKS_PER_ATB + j) * BYTES_PER_BLOCK, current_allocation)\n                    current_allocation = 0\n                if block_state == AT_FREE:\n                    current_free += 1\n                    total_free += 1\n                elif block_state == AT_HEAD or block_state == AT_MARK:\n                    current_allocation = 1\n                elif block_state == AT_TAIL and current_allocation > 0:\n                    current_allocation += 1\n                longest_free = max(longest_free, current_free)\n        if current_allocation > 0:\n            save_allocated_block(pool_length, current_allocation)\n\n        def is_qstr(obj):\n            return obj & 4286578695 == 6\n\n        def find_qstr(qstr_index):\n            pool_ptr = last_pool\n            if not is_qstr(qstr_index):\n                return 'object'\n            pool = block_data[pool_ptr]\n            (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', pool)\n            qstr_index >>= 3\n            if qstr_index > total_prev_len + alloc:\n                return 'invalid'\n            while pool_ptr != 0:\n                if pool_ptr > ram_start:\n                    if pool_ptr in block_data:\n                        pool = block_data[pool_ptr]\n                        (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', pool)\n                    else:\n                        print('missing qstr pool: {:08x}'.format(pool_ptr))\n                        return 'missing'\n                else:\n                    rom_offset = pool_ptr - rom_start\n                    (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', rom[rom_offset:rom_offset + 32])\n                    pool = rom[rom_offset:rom_offset + 32 + length * 4]\n                if qstr_index >= total_prev_len:\n                    offset = (qstr_index - total_prev_len) * 4 + 16\n                    start = struct.unpack_from('<I', pool, offset=offset)[0]\n                    if start < heap_start:\n                        start -= rom_start\n                        if start > len(rom):\n                            return 'more than rom: {:x}'.format(start + rom_start)\n                        (qstr_hash, qstr_len) = struct.unpack('<BB', rom[start:start + 2])\n                        return rom[start + 2:start + 2 + qstr_len].decode('utf-8')\n                    else:\n                        if start > heap_start + len(heap):\n                            return 'out of range: {:x}'.format(start)\n                        local = start - heap_start\n                        (qstr_hash, qstr_len) = struct.unpack('<BB', heap[local:local + 2])\n                        return heap[local + 2:local + 2 + qstr_len].decode('utf-8')\n                pool_ptr = prev\n            return 'unknown'\n\n        def format(obj):\n            if obj & 1 != 0:\n                return obj >> 1\n            if is_qstr(obj):\n                return find_qstr(obj)\n            else:\n                return '0x{:08x}'.format(obj)\n        for block in sorted(map_element_blocks):\n            if block == 0:\n                continue\n            try:\n                node = ownership_graph.get_node(block)\n            except KeyError:\n                print('Unable to find memory block for 0x{:08x}. Is there something running?'.format(block))\n                continue\n            if block not in block_data:\n                continue\n            data = block_data[block]\n            cells = []\n            for i in range(len(data) // 8):\n                (key, value) = struct.unpack_from('<II', data, offset=i * 8)\n                if key == MP_OBJ_NULL or key == MP_OBJ_SENTINEL:\n                    cells.append(('', ' '))\n                else:\n                    cells.append((key, format(key)))\n                    if value in block_data:\n                        edge = ownership_graph.get_edge(block, value)\n                        edge.attr['tailport'] = str(key)\n            rows = ''\n            for i in range(len(cells) // 2):\n                rows += '<tr><td port=\"{}\">{}</td><td port=\"{}\">{}</td></tr>'.format(cells[2 * i][0], cells[2 * i][1], cells[2 * i + 1][0], cells[2 * i + 1][1])\n            node.attr['shape'] = 'plaintext'\n            node.attr['style'] = 'invisible'\n            node.attr['label'] = '<<table bgcolor=\"gold\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\"><tr><td colspan=\"2\">0x{:08x}</td></tr>{}</table>>'.format(block, rows)\n        for (node, degree) in ownership_graph.in_degree_iter():\n            print(node, degree)\n            if degree == 0:\n                address_bytes = struct.pack('<I', int(node))\n                location = -1\n                for _ in range(ram.count(address_bytes)):\n                    location = ram.find(address_bytes, location + 1)\n                    pointer_location = ram_start + location\n                    source = '0x{:08x}'.format(pointer_location)\n                    if pointer_location in symbol_lookup:\n                        source = symbol_lookup[pointer_location]\n                    if source in manual_symbol_map:\n                        source = manual_symbol_map[source]\n                    if 'readline_hist' in source:\n                        string_blocks.append(int(node))\n                    if pointer_location > heap_start + heap_size:\n                        source = 'stack ' + source\n                    ownership_graph.add_edge(source, node)\n        for block in string_blocks:\n            if block == 0:\n                continue\n            node = ownership_graph.get_node(block)\n            node.attr['fillcolor'] = 'hotpink'\n            if block in block_data:\n                raw_string = block_data[block]\n            else:\n                print('Unable to find memory block for string at 0x{:08x}.'.format(block))\n                continue\n            try:\n                raw_string = block_data[block].decode('utf-8')\n            except:\n                raw_string = str(block_data[block])\n            wrapped = []\n            for i in range(0, len(raw_string), 16):\n                wrapped.append(raw_string[i:i + 16])\n            node.attr['label'] = '\\n'.join(wrapped)\n            node.attr['style'] = 'filled'\n            node.attr['fontname'] = 'FiraCode-Medium'\n            node.attr['fontpath'] = '/Users/tannewt/Library/Fonts/'\n            node.attr['fontsize'] = 8\n            node.attr['height'] = len(wrapped) * 0.25\n        for block in bytecode_blocks:\n            node = ownership_graph.get_node(block)\n            node.attr['fillcolor'] = 'lightseagreen'\n            if block in block_data:\n                data = block_data[block]\n            else:\n                print('Unable to find memory block for bytecode at 0x{:08x}.'.format(block))\n                continue\n            prelude = Prelude(io.BufferedReader(io.BytesIO(data)))\n            node.attr['shape'] = 'plaintext'\n            node.attr['style'] = 'invisible'\n            code_info_size = prelude.code_info_size\n            rows = ''\n            remaining_bytecode = len(data) - 16\n            while code_info_size >= 16:\n                rows += '<tr><td colspan=\"16\" bgcolor=\"palegreen\" height=\"18\" width=\"80\"></td></tr>'\n                code_info_size -= 16\n                remaining_bytecode -= 16\n            if code_info_size > 0:\n                rows += '<tr><td colspan=\"{}\" bgcolor=\"palegreen\" height=\"18\" width=\"{}\"></td><td colspan=\"{}\" bgcolor=\"seagreen\" height=\"18\" width=\"{}\"></td></tr>'.format(code_info_size, code_info_size * (80 / 16), 16 - code_info_size, 80 / 16 * (16 - code_info_size))\n                remaining_bytecode -= 16\n            for i in range(remaining_bytecode // 16):\n                rows += '<tr><td colspan=\"16\" bgcolor=\"seagreen\" height=\"18\" width=\"80\"></td></tr>'\n            node.attr['label'] = '<<table border=\"1\" cellspacing=\"0\"><tr><td colspan=\"16\" bgcolor=\"lightseagreen\" height=\"18\" width=\"80\">0x{:08x}</td></tr>{}</table>>'.format(block, rows)\n        for block in qstr_chunks:\n            if block not in block_data:\n                ownership_graph.delete_node(block)\n                continue\n            data = block_data[block]\n            qstrs_in_chunk = ''\n            offset = 0\n            while offset < len(data) - 1:\n                (qstr_hash, qstr_len) = struct.unpack_from('<BB', data, offset=offset)\n                if qstr_hash == 0:\n                    qstrs_in_chunk += ' ' * (len(data) - offset)\n                    offset = len(data)\n                    continue\n                offset += 2 + qstr_len + 1\n                try:\n                    qstrs_in_chunk += '  ' + data[offset - qstr_len - 1:offset - 1].decode('utf-8')\n                except UnicodeDecodeError:\n                    qstrs_in_chunk += '  ' + '\u2591' * qstr_len\n            printable_qstrs = ''\n            for i in range(len(qstrs_in_chunk)):\n                c = qstrs_in_chunk[i]\n                if c not in string.printable or c in '\\x0b\\x0c':\n                    printable_qstrs += '\u2591'\n                else:\n                    printable_qstrs += qstrs_in_chunk[i]\n            wrapped = []\n            for i in range(0, len(printable_qstrs), 16):\n                wrapped.append(html.escape(printable_qstrs[i:i + 16]))\n            node = ownership_graph.get_node(block)\n            node.attr['label'] = '<<table border=\"1\" cellspacing=\"0\" bgcolor=\"lightsalmon\" width=\"80\"><tr><td height=\"18\" >0x{:08x}</td></tr><tr><td height=\"{}\" >{}</td></tr></table>>'.format(block, 18 * (len(wrapped) - 1), '<br/>'.join(wrapped))\n            node.attr['fontname'] = 'FiraCode-Bold'\n            node.attr['fontcolor'] = 'black'\n            node.attr['fontpath'] = '/Users/tannewt/Library/Fonts/'\n            node.attr['fontsize'] = 8\n        print('Total free space:', BYTES_PER_BLOCK * total_free)\n        print('Longest free space:', BYTES_PER_BLOCK * longest_free)\n        if draw_heap_ownership:\n            ownership_graph.layout(prog='dot')\n            fn = os.path.join(output_directory, 'heap_ownership{:04d}.svg'.format(snapshot_num))\n            print(fn)\n            ownership_graph.draw(fn)\n        if draw_heap_ownership:\n            for edge in ownership_graph.iteredges():\n                del edge.attr['pos']\n        else:\n            for edge in ownership_graph.edges():\n                ownership_graph.delete_edge(edge)\n        for node in ownership_graph.nodes():\n            try:\n                address = int(node.name)\n            except ValueError:\n                ownership_graph.remove_node(node.name)\n                continue\n            block = (address - pool_start) // 16\n            x = block // 128\n            y = 128 - block % 128\n            try:\n                height = float(node.attr['height'])\n            except:\n                height = 0.25\n            node.attr['pos'] = '{},{}'.format(x * 80, (y - (height - 0.25) * 2) * 18)\n        for block in sorted(map_element_blocks):\n            try:\n                node = ownership_graph.get_node(block)\n            except KeyError:\n                if block != 0:\n                    print('Unable to find memory block for 0x{:08x}. Is there something running?'.format(block))\n                continue\n            if block not in block_data:\n                continue\n            data = block_data[block]\n            cells = []\n            for i in range(len(data) // 8):\n                (key, value) = struct.unpack_from('<II', data, offset=i * 8)\n                if key == MP_OBJ_NULL or key == MP_OBJ_SENTINEL:\n                    cells.append(('', ' '))\n                else:\n                    cells.append((key, ''))\n            rows = ''\n            for i in range(len(cells) // 2):\n                rows += '<tr><td port=\"{}\" height=\"18\" width=\"40\">{}</td><td port=\"{}\" height=\"18\" width=\"40\">{}</td></tr>'.format(cells[2 * i][0], cells[2 * i][1], cells[2 * i + 1][0], cells[2 * i + 1][1])\n            node.attr['label'] = '<<table bgcolor=\"gold\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\">{}</table>>'.format(rows)\n        ownership_graph.add_node('center', pos='{},{}'.format(total_width // 2 - 40, total_height // 2), shape='plaintext', label=' ')\n        ownership_graph.graph_attr['viewport'] = '{},{},1,{}'.format(total_width, total_height, 'center')\n        ownership_graph.has_layout = True\n        if draw_heap_layout:\n            fn = os.path.join(output_directory, 'heap_layout{:04d}.png'.format(snapshot_num))\n            print(fn)\n            ownership_graph.draw(fn)",
            "@click.command()\n@click.argument('ram_filename')\n@click.argument('bin_filename')\n@click.argument('map_filename')\n@click.option('--print_block_contents', default=False, help='Prints the contents of each allocated block')\n@click.option('--print_unknown_types', default=False, help=\"Prints the micropython base type if we don't understand it.\")\n@click.option('--print_block_state', default=False, help='Prints the heap block states (allocated or free)')\n@click.option('--print_conflicting_symbols', default=False, help='Prints conflicting symbols from the map')\n@click.option('--print-heap-structure/--no-print-heap-structure', default=False, help='Print heap structure')\n@click.option('--output_directory', default='heapvis', help='Destination for rendered output')\n@click.option('--draw-heap-layout/--no-draw-heap-layout', default=True, help='Draw the heap layout')\n@click.option('--draw-heap-ownership/--no-draw-heap-ownership', default=False, help='Draw the ownership graph of blocks on the heap')\n@click.option('--analyze-snapshots', default='last', type=click.Choice(['all', 'last']))\ndef do_all_the_things(ram_filename, bin_filename, map_filename, print_block_contents, print_unknown_types, print_block_state, print_conflicting_symbols, print_heap_structure, output_directory, draw_heap_layout, draw_heap_ownership, analyze_snapshots):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with open(ram_filename, 'rb') as f:\n        ram_dump = f.read()\n    with open(bin_filename, 'rb') as f:\n        rom = f.read()\n    symbols = {}\n    symbol_lookup = {}\n    manual_symbol_map = {}\n\n    def add_symbol(name, address=None, size=None):\n        if 'lto_priv' in name:\n            name = name.split('.')[0]\n        if address:\n            address = int(address, 0)\n        if size:\n            size = int(size, 0)\n        if name in symbols:\n            if address and symbols[name][0] and (symbols[name][0] != address):\n                if print_conflicting_symbols:\n                    print('Conflicting symbol: {} at addresses 0x{:08x} and 0x{:08x}'.format(name, address, symbols[name][0]))\n                return\n            if not address:\n                address = symbols[name][0]\n            if not size:\n                size = symbols[name][1]\n        symbols[name] = (address, size)\n        if address:\n            if not size:\n                size = 4\n            for offset in range(0, size, 4):\n                symbol_lookup[address + offset] = '{}+{}'.format(name, offset)\n    with open(map_filename, 'r') as f:\n        common_symbols = False\n        name = None\n        for line in f:\n            line = line.strip()\n            parts = line.split()\n            if line.startswith('Common symbol'):\n                common_symbols = True\n            if line == 'Discarded input sections':\n                common_symbols = False\n            if common_symbols:\n                if len(parts) == 1:\n                    name = parts[0]\n                elif len(parts) == 2 and name:\n                    add_symbol(name, size=parts[0])\n                    name = None\n                elif len(parts) == 3:\n                    add_symbol(parts[0], size=parts[1])\n                    name = None\n            else:\n                if len(parts) == 1 and parts[0].startswith(('.text', '.rodata', '.bss')) and (parts[0].count('.') > 1) and (not parts[0].isnumeric()) and ('.str' not in parts[0]):\n                    name = parts[0].split('.')[2]\n                if len(parts) == 3 and parts[0].startswith('0x') and parts[1].startswith('0x') and name:\n                    add_symbol(name, parts[0], parts[1])\n                    name = None\n                if len(parts) == 2 and parts[0].startswith('0x') and (not parts[1].startswith('0x')):\n                    add_symbol(parts[1], parts[0])\n                if len(parts) == 4 and parts[0] not in SKIP_SYMBOLS and parts[1].startswith('0x') and parts[2].startswith('0x'):\n                    (name, address, size, source) = parts\n                    if name.startswith(('.text', '.rodata', '.bss')) and name.count('.') > 1:\n                        name = name.split('.')[-1]\n                        add_symbol(name, address, size)\n                    name = None\n                if len(parts) >= 4 and parts[0].startswith('0x') and (parts[2] == '=') and (parts[1] != '.'):\n                    add_symbol(parts[1], parts[0])\n    rom_start = symbols['_sfixed'][0]\n    ram_start = symbols['_srelocate'][0]\n    ram_end = symbols['_estack'][0]\n    ram_length = ram_end - ram_start\n    if analyze_snapshots == 'all':\n        snapshots = range(len(ram_dump) // ram_length - 1, -1, -1)\n    elif analyze_snapshots == 'last':\n        snapshots = range(len(ram_dump) // ram_length - 1, len(ram_dump) // ram_length - 2, -1)\n    for snapshot_num in snapshots:\n        ram = ram_dump[ram_length * snapshot_num:ram_length * (snapshot_num + 1)]\n        ownership_graph = pgv.AGraph(directed=True)\n\n        def load(address, size=4):\n            if size is None:\n                raise ValueError('You must provide a size')\n            if address > ram_start:\n                ram_address = address - ram_start\n                if ram_address + size > len(ram):\n                    raise ValueError('Unable to read 0x{:08x} from ram.'.format(address))\n                return ram[ram_address:ram_address + size]\n            elif address < len(rom):\n                if address + size > len(rom):\n                    raise ValueError('Unable to read 0x{:08x} from rom.'.format(address))\n                return rom[address:address + size]\n\n        def load_pointer(address):\n            return struct.unpack('<I', load(address))[0]\n        if 'heap' in symbols:\n            (heap_start, heap_size) = symbols['heap']\n        else:\n            print('no static heap')\n            (allocations_start, allocations_size) = symbols['allocations']\n            allocations = load(allocations_start, allocations_size)\n            first_zero = True\n            potential_heap = None\n            for (address, size) in struct.iter_unpack('<II', allocations):\n                print(address, size)\n                if address == 0 and first_zero:\n                    first_zero = False\n                if first_zero:\n                    potential_heap = (address, size)\n                if not first_zero and address != 0:\n                    if address != potential_heap[0] + potential_heap[1]:\n                        print('no active heap')\n                        return\n                    else:\n                        (heap_start, heap_size) = potential_heap\n                        break\n        print('found heap', heap_start, heap_size)\n        heap = load(heap_start, heap_size)\n        total_byte_len = len(heap)\n        mp_state_ctx = symbols['mp_state_ctx'][0]\n        manual_symbol_map['mp_state_ctx+20'] = 'mp_state_ctx.vm.last_pool'\n        last_pool = load_pointer(mp_state_ctx + 20)\n        manual_symbol_map['mp_state_ctx+108'] = 'mp_state_ctx.vm.dict_main.map.table'\n        dict_main_table = load_pointer(mp_state_ctx + 108)\n        manual_symbol_map['mp_state_ctx+84'] = 'mp_state_ctx.vm.mp_loaded_modules_dict.map.table'\n        imports_table = load_pointer(mp_state_ctx + 84)\n        manual_symbol_map['mp_state_ctx+124'] = 'mp_state_ctx.vm.mp_sys_path_obj.items'\n        manual_symbol_map['mp_state_ctx+140'] = 'mp_state_ctx.vm.mp_sys_argv_obj.items'\n        manual_symbol_map['mp_state_ctx+96'] = 'mp_state_ctx.vm.dict_main'\n        manual_symbol_map['0x200015e0'] = 'mp_state_ctx.vm.dict_main'\n        for i in range(READLINE_HIST_SIZE):\n            manual_symbol_map['mp_state_ctx+{}'.format(148 + i * 4)] = 'mp_state_ctx.vm.readline_hist[{}]'.format(i)\n        tuple_type = symbols['mp_type_tuple'][0]\n        type_type = symbols['mp_type_type'][0]\n        map_type = symbols['mp_type_map'][0]\n        dict_type = symbols['mp_type_dict'][0]\n        property_type = symbols['mp_type_property'][0]\n        str_type = symbols['mp_type_str'][0]\n        function_types = [symbols['mp_type_fun_' + x][0] for x in ['bc', 'builtin_0', 'builtin_1', 'builtin_2', 'builtin_3', 'builtin_var']]\n        bytearray_type = symbols['mp_type_bytearray'][0]\n        dynamic_type = 1073741824\n        type_colors = {dict_type: 'red', property_type: 'yellow', map_type: 'blue', type_type: 'orange', tuple_type: 'skyblue', str_type: 'pink', bytearray_type: 'purple'}\n        pool_shift = heap_start % BYTES_PER_BLOCK\n        atb_length = total_byte_len * BITS_PER_BYTE // (BITS_PER_BYTE + BITS_PER_BYTE * BLOCKS_PER_ATB // BLOCKS_PER_FTB + BITS_PER_BYTE * BLOCKS_PER_ATB * BYTES_PER_BLOCK)\n        pool_length = atb_length * BLOCKS_PER_ATB * BYTES_PER_BLOCK\n        gc_finaliser_table_byte_len = (atb_length * BLOCKS_PER_ATB + BLOCKS_PER_FTB - 1) // BLOCKS_PER_FTB\n        if print_heap_structure:\n            print('mp_state_ctx at 0x{:08x} and length {}'.format(*symbols['mp_state_ctx']))\n            print('Total heap length:', total_byte_len)\n            print('ATB length:', atb_length)\n            print('Total allocatable:', pool_length)\n            print('FTB length:', gc_finaliser_table_byte_len)\n        pool_start = heap_start + total_byte_len - pool_length - pool_shift\n        pool = heap[-pool_length - pool_shift:]\n        total_height = 128 * 18\n        total_width = pool_length // (128 * 16) * 85\n        map_element_blocks = [dict_main_table, imports_table]\n        string_blocks = []\n        bytecode_blocks = []\n        qstr_pools = []\n        qstr_chunks = []\n        block_data = {}\n        prev_pool = last_pool\n        while prev_pool > ram_start:\n            qstr_pools.append(prev_pool)\n            prev_pool = load_pointer(prev_pool)\n\n        def save_allocated_block(end, current_allocation):\n            allocation_length = current_allocation * BYTES_PER_BLOCK\n            start = end - allocation_length\n            address = pool_start + start\n            data = pool[start:end]\n            if print_block_state:\n                print('0x{:x} {} bytes allocated'.format(address, allocation_length))\n            if print_block_contents:\n                print(data)\n            rows = ''\n            for k in range(current_allocation - 1):\n                rows += '<tr>'\n                for l in range(4):\n                    rows += '<td port=\"{}\" height=\"18\" width=\"20\"></td>'.format(4 * (k + 1) + l)\n                rows += '</tr>'\n            table = '<<table bgcolor=\"gray\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\"><tr><td colspan=\"4\" port=\"0\" height=\"18\" width=\"80\">0x{:08x}</td></tr>{}</table>>'.format(address, rows)\n            ownership_graph.add_node(address, label=table, style='invisible', shape='plaintext')\n            print('add  0x{:08x}'.format(address))\n            potential_type = None\n            node = ownership_graph.get_node(address)\n            node.attr['height'] = 0.25 * current_allocation\n            node.attr['fontcolor'] = 'black'\n            block_data[address] = data\n            for k in range(len(data) // 4):\n                word = struct.unpack_from('<I', data, offset=k * 4)[0]\n                if word < len(rom) and k == 0 or address in qstr_pools:\n                    potential_type = word\n                    bgcolor = 'gray'\n                    if address in qstr_pools:\n                        bgcolor = 'tomato'\n                    elif potential_type in function_types:\n                        bgcolor = 'green'\n                    elif potential_type in type_colors:\n                        bgcolor = type_colors[potential_type]\n                    elif print_unknown_types:\n                        print('unknown type', hex(potential_type))\n                    node.attr['label'] = '<' + node.attr['label'].replace('\"gray\"', '\"' + bgcolor + '\"') + '>'\n                if potential_type == str_type and k == 3:\n                    string_blocks.append(word)\n                if potential_type == dict_type:\n                    if k == 3:\n                        map_element_blocks.append(word)\n                if ram_start < word < ram_start + len(ram) and word % 16 == 0:\n                    port = k\n                    if k < 4:\n                        port = 0\n                    ownership_graph.add_edge(address, word, tailport=str(port) + ':_')\n                    print('  0x{:08x}'.format(word))\n                    if address in qstr_pools:\n                        if k > 0:\n                            qstr_chunks.append(word)\n                    if k == 0:\n                        potential_type = dynamic_type\n                if potential_type == dynamic_type:\n                    if k == 0:\n                        node.attr['fillcolor'] = 'plum'\n                    if k == 3 and ram_start < word < ram_end:\n                        map_element_blocks.append(word)\n                if potential_type in function_types:\n                    if k == 2 and ram_start < word < ram_end:\n                        bytecode_blocks.append(word)\n        longest_free = 0\n        current_free = 0\n        current_allocation = 0\n        total_free = 0\n        for i in range(atb_length):\n            atb = heap[i]\n            for j in range(4):\n                block_state = atb >> j * 2 & 3\n                if block_state != AT_FREE and current_free > 0:\n                    if print_block_state:\n                        print('{} bytes free'.format(current_free * BYTES_PER_BLOCK))\n                    current_free = 0\n                if block_state != AT_TAIL and current_allocation > 0:\n                    save_allocated_block((i * BLOCKS_PER_ATB + j) * BYTES_PER_BLOCK, current_allocation)\n                    current_allocation = 0\n                if block_state == AT_FREE:\n                    current_free += 1\n                    total_free += 1\n                elif block_state == AT_HEAD or block_state == AT_MARK:\n                    current_allocation = 1\n                elif block_state == AT_TAIL and current_allocation > 0:\n                    current_allocation += 1\n                longest_free = max(longest_free, current_free)\n        if current_allocation > 0:\n            save_allocated_block(pool_length, current_allocation)\n\n        def is_qstr(obj):\n            return obj & 4286578695 == 6\n\n        def find_qstr(qstr_index):\n            pool_ptr = last_pool\n            if not is_qstr(qstr_index):\n                return 'object'\n            pool = block_data[pool_ptr]\n            (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', pool)\n            qstr_index >>= 3\n            if qstr_index > total_prev_len + alloc:\n                return 'invalid'\n            while pool_ptr != 0:\n                if pool_ptr > ram_start:\n                    if pool_ptr in block_data:\n                        pool = block_data[pool_ptr]\n                        (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', pool)\n                    else:\n                        print('missing qstr pool: {:08x}'.format(pool_ptr))\n                        return 'missing'\n                else:\n                    rom_offset = pool_ptr - rom_start\n                    (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', rom[rom_offset:rom_offset + 32])\n                    pool = rom[rom_offset:rom_offset + 32 + length * 4]\n                if qstr_index >= total_prev_len:\n                    offset = (qstr_index - total_prev_len) * 4 + 16\n                    start = struct.unpack_from('<I', pool, offset=offset)[0]\n                    if start < heap_start:\n                        start -= rom_start\n                        if start > len(rom):\n                            return 'more than rom: {:x}'.format(start + rom_start)\n                        (qstr_hash, qstr_len) = struct.unpack('<BB', rom[start:start + 2])\n                        return rom[start + 2:start + 2 + qstr_len].decode('utf-8')\n                    else:\n                        if start > heap_start + len(heap):\n                            return 'out of range: {:x}'.format(start)\n                        local = start - heap_start\n                        (qstr_hash, qstr_len) = struct.unpack('<BB', heap[local:local + 2])\n                        return heap[local + 2:local + 2 + qstr_len].decode('utf-8')\n                pool_ptr = prev\n            return 'unknown'\n\n        def format(obj):\n            if obj & 1 != 0:\n                return obj >> 1\n            if is_qstr(obj):\n                return find_qstr(obj)\n            else:\n                return '0x{:08x}'.format(obj)\n        for block in sorted(map_element_blocks):\n            if block == 0:\n                continue\n            try:\n                node = ownership_graph.get_node(block)\n            except KeyError:\n                print('Unable to find memory block for 0x{:08x}. Is there something running?'.format(block))\n                continue\n            if block not in block_data:\n                continue\n            data = block_data[block]\n            cells = []\n            for i in range(len(data) // 8):\n                (key, value) = struct.unpack_from('<II', data, offset=i * 8)\n                if key == MP_OBJ_NULL or key == MP_OBJ_SENTINEL:\n                    cells.append(('', ' '))\n                else:\n                    cells.append((key, format(key)))\n                    if value in block_data:\n                        edge = ownership_graph.get_edge(block, value)\n                        edge.attr['tailport'] = str(key)\n            rows = ''\n            for i in range(len(cells) // 2):\n                rows += '<tr><td port=\"{}\">{}</td><td port=\"{}\">{}</td></tr>'.format(cells[2 * i][0], cells[2 * i][1], cells[2 * i + 1][0], cells[2 * i + 1][1])\n            node.attr['shape'] = 'plaintext'\n            node.attr['style'] = 'invisible'\n            node.attr['label'] = '<<table bgcolor=\"gold\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\"><tr><td colspan=\"2\">0x{:08x}</td></tr>{}</table>>'.format(block, rows)\n        for (node, degree) in ownership_graph.in_degree_iter():\n            print(node, degree)\n            if degree == 0:\n                address_bytes = struct.pack('<I', int(node))\n                location = -1\n                for _ in range(ram.count(address_bytes)):\n                    location = ram.find(address_bytes, location + 1)\n                    pointer_location = ram_start + location\n                    source = '0x{:08x}'.format(pointer_location)\n                    if pointer_location in symbol_lookup:\n                        source = symbol_lookup[pointer_location]\n                    if source in manual_symbol_map:\n                        source = manual_symbol_map[source]\n                    if 'readline_hist' in source:\n                        string_blocks.append(int(node))\n                    if pointer_location > heap_start + heap_size:\n                        source = 'stack ' + source\n                    ownership_graph.add_edge(source, node)\n        for block in string_blocks:\n            if block == 0:\n                continue\n            node = ownership_graph.get_node(block)\n            node.attr['fillcolor'] = 'hotpink'\n            if block in block_data:\n                raw_string = block_data[block]\n            else:\n                print('Unable to find memory block for string at 0x{:08x}.'.format(block))\n                continue\n            try:\n                raw_string = block_data[block].decode('utf-8')\n            except:\n                raw_string = str(block_data[block])\n            wrapped = []\n            for i in range(0, len(raw_string), 16):\n                wrapped.append(raw_string[i:i + 16])\n            node.attr['label'] = '\\n'.join(wrapped)\n            node.attr['style'] = 'filled'\n            node.attr['fontname'] = 'FiraCode-Medium'\n            node.attr['fontpath'] = '/Users/tannewt/Library/Fonts/'\n            node.attr['fontsize'] = 8\n            node.attr['height'] = len(wrapped) * 0.25\n        for block in bytecode_blocks:\n            node = ownership_graph.get_node(block)\n            node.attr['fillcolor'] = 'lightseagreen'\n            if block in block_data:\n                data = block_data[block]\n            else:\n                print('Unable to find memory block for bytecode at 0x{:08x}.'.format(block))\n                continue\n            prelude = Prelude(io.BufferedReader(io.BytesIO(data)))\n            node.attr['shape'] = 'plaintext'\n            node.attr['style'] = 'invisible'\n            code_info_size = prelude.code_info_size\n            rows = ''\n            remaining_bytecode = len(data) - 16\n            while code_info_size >= 16:\n                rows += '<tr><td colspan=\"16\" bgcolor=\"palegreen\" height=\"18\" width=\"80\"></td></tr>'\n                code_info_size -= 16\n                remaining_bytecode -= 16\n            if code_info_size > 0:\n                rows += '<tr><td colspan=\"{}\" bgcolor=\"palegreen\" height=\"18\" width=\"{}\"></td><td colspan=\"{}\" bgcolor=\"seagreen\" height=\"18\" width=\"{}\"></td></tr>'.format(code_info_size, code_info_size * (80 / 16), 16 - code_info_size, 80 / 16 * (16 - code_info_size))\n                remaining_bytecode -= 16\n            for i in range(remaining_bytecode // 16):\n                rows += '<tr><td colspan=\"16\" bgcolor=\"seagreen\" height=\"18\" width=\"80\"></td></tr>'\n            node.attr['label'] = '<<table border=\"1\" cellspacing=\"0\"><tr><td colspan=\"16\" bgcolor=\"lightseagreen\" height=\"18\" width=\"80\">0x{:08x}</td></tr>{}</table>>'.format(block, rows)\n        for block in qstr_chunks:\n            if block not in block_data:\n                ownership_graph.delete_node(block)\n                continue\n            data = block_data[block]\n            qstrs_in_chunk = ''\n            offset = 0\n            while offset < len(data) - 1:\n                (qstr_hash, qstr_len) = struct.unpack_from('<BB', data, offset=offset)\n                if qstr_hash == 0:\n                    qstrs_in_chunk += ' ' * (len(data) - offset)\n                    offset = len(data)\n                    continue\n                offset += 2 + qstr_len + 1\n                try:\n                    qstrs_in_chunk += '  ' + data[offset - qstr_len - 1:offset - 1].decode('utf-8')\n                except UnicodeDecodeError:\n                    qstrs_in_chunk += '  ' + '\u2591' * qstr_len\n            printable_qstrs = ''\n            for i in range(len(qstrs_in_chunk)):\n                c = qstrs_in_chunk[i]\n                if c not in string.printable or c in '\\x0b\\x0c':\n                    printable_qstrs += '\u2591'\n                else:\n                    printable_qstrs += qstrs_in_chunk[i]\n            wrapped = []\n            for i in range(0, len(printable_qstrs), 16):\n                wrapped.append(html.escape(printable_qstrs[i:i + 16]))\n            node = ownership_graph.get_node(block)\n            node.attr['label'] = '<<table border=\"1\" cellspacing=\"0\" bgcolor=\"lightsalmon\" width=\"80\"><tr><td height=\"18\" >0x{:08x}</td></tr><tr><td height=\"{}\" >{}</td></tr></table>>'.format(block, 18 * (len(wrapped) - 1), '<br/>'.join(wrapped))\n            node.attr['fontname'] = 'FiraCode-Bold'\n            node.attr['fontcolor'] = 'black'\n            node.attr['fontpath'] = '/Users/tannewt/Library/Fonts/'\n            node.attr['fontsize'] = 8\n        print('Total free space:', BYTES_PER_BLOCK * total_free)\n        print('Longest free space:', BYTES_PER_BLOCK * longest_free)\n        if draw_heap_ownership:\n            ownership_graph.layout(prog='dot')\n            fn = os.path.join(output_directory, 'heap_ownership{:04d}.svg'.format(snapshot_num))\n            print(fn)\n            ownership_graph.draw(fn)\n        if draw_heap_ownership:\n            for edge in ownership_graph.iteredges():\n                del edge.attr['pos']\n        else:\n            for edge in ownership_graph.edges():\n                ownership_graph.delete_edge(edge)\n        for node in ownership_graph.nodes():\n            try:\n                address = int(node.name)\n            except ValueError:\n                ownership_graph.remove_node(node.name)\n                continue\n            block = (address - pool_start) // 16\n            x = block // 128\n            y = 128 - block % 128\n            try:\n                height = float(node.attr['height'])\n            except:\n                height = 0.25\n            node.attr['pos'] = '{},{}'.format(x * 80, (y - (height - 0.25) * 2) * 18)\n        for block in sorted(map_element_blocks):\n            try:\n                node = ownership_graph.get_node(block)\n            except KeyError:\n                if block != 0:\n                    print('Unable to find memory block for 0x{:08x}. Is there something running?'.format(block))\n                continue\n            if block not in block_data:\n                continue\n            data = block_data[block]\n            cells = []\n            for i in range(len(data) // 8):\n                (key, value) = struct.unpack_from('<II', data, offset=i * 8)\n                if key == MP_OBJ_NULL or key == MP_OBJ_SENTINEL:\n                    cells.append(('', ' '))\n                else:\n                    cells.append((key, ''))\n            rows = ''\n            for i in range(len(cells) // 2):\n                rows += '<tr><td port=\"{}\" height=\"18\" width=\"40\">{}</td><td port=\"{}\" height=\"18\" width=\"40\">{}</td></tr>'.format(cells[2 * i][0], cells[2 * i][1], cells[2 * i + 1][0], cells[2 * i + 1][1])\n            node.attr['label'] = '<<table bgcolor=\"gold\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\">{}</table>>'.format(rows)\n        ownership_graph.add_node('center', pos='{},{}'.format(total_width // 2 - 40, total_height // 2), shape='plaintext', label=' ')\n        ownership_graph.graph_attr['viewport'] = '{},{},1,{}'.format(total_width, total_height, 'center')\n        ownership_graph.has_layout = True\n        if draw_heap_layout:\n            fn = os.path.join(output_directory, 'heap_layout{:04d}.png'.format(snapshot_num))\n            print(fn)\n            ownership_graph.draw(fn)",
            "@click.command()\n@click.argument('ram_filename')\n@click.argument('bin_filename')\n@click.argument('map_filename')\n@click.option('--print_block_contents', default=False, help='Prints the contents of each allocated block')\n@click.option('--print_unknown_types', default=False, help=\"Prints the micropython base type if we don't understand it.\")\n@click.option('--print_block_state', default=False, help='Prints the heap block states (allocated or free)')\n@click.option('--print_conflicting_symbols', default=False, help='Prints conflicting symbols from the map')\n@click.option('--print-heap-structure/--no-print-heap-structure', default=False, help='Print heap structure')\n@click.option('--output_directory', default='heapvis', help='Destination for rendered output')\n@click.option('--draw-heap-layout/--no-draw-heap-layout', default=True, help='Draw the heap layout')\n@click.option('--draw-heap-ownership/--no-draw-heap-ownership', default=False, help='Draw the ownership graph of blocks on the heap')\n@click.option('--analyze-snapshots', default='last', type=click.Choice(['all', 'last']))\ndef do_all_the_things(ram_filename, bin_filename, map_filename, print_block_contents, print_unknown_types, print_block_state, print_conflicting_symbols, print_heap_structure, output_directory, draw_heap_layout, draw_heap_ownership, analyze_snapshots):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with open(ram_filename, 'rb') as f:\n        ram_dump = f.read()\n    with open(bin_filename, 'rb') as f:\n        rom = f.read()\n    symbols = {}\n    symbol_lookup = {}\n    manual_symbol_map = {}\n\n    def add_symbol(name, address=None, size=None):\n        if 'lto_priv' in name:\n            name = name.split('.')[0]\n        if address:\n            address = int(address, 0)\n        if size:\n            size = int(size, 0)\n        if name in symbols:\n            if address and symbols[name][0] and (symbols[name][0] != address):\n                if print_conflicting_symbols:\n                    print('Conflicting symbol: {} at addresses 0x{:08x} and 0x{:08x}'.format(name, address, symbols[name][0]))\n                return\n            if not address:\n                address = symbols[name][0]\n            if not size:\n                size = symbols[name][1]\n        symbols[name] = (address, size)\n        if address:\n            if not size:\n                size = 4\n            for offset in range(0, size, 4):\n                symbol_lookup[address + offset] = '{}+{}'.format(name, offset)\n    with open(map_filename, 'r') as f:\n        common_symbols = False\n        name = None\n        for line in f:\n            line = line.strip()\n            parts = line.split()\n            if line.startswith('Common symbol'):\n                common_symbols = True\n            if line == 'Discarded input sections':\n                common_symbols = False\n            if common_symbols:\n                if len(parts) == 1:\n                    name = parts[0]\n                elif len(parts) == 2 and name:\n                    add_symbol(name, size=parts[0])\n                    name = None\n                elif len(parts) == 3:\n                    add_symbol(parts[0], size=parts[1])\n                    name = None\n            else:\n                if len(parts) == 1 and parts[0].startswith(('.text', '.rodata', '.bss')) and (parts[0].count('.') > 1) and (not parts[0].isnumeric()) and ('.str' not in parts[0]):\n                    name = parts[0].split('.')[2]\n                if len(parts) == 3 and parts[0].startswith('0x') and parts[1].startswith('0x') and name:\n                    add_symbol(name, parts[0], parts[1])\n                    name = None\n                if len(parts) == 2 and parts[0].startswith('0x') and (not parts[1].startswith('0x')):\n                    add_symbol(parts[1], parts[0])\n                if len(parts) == 4 and parts[0] not in SKIP_SYMBOLS and parts[1].startswith('0x') and parts[2].startswith('0x'):\n                    (name, address, size, source) = parts\n                    if name.startswith(('.text', '.rodata', '.bss')) and name.count('.') > 1:\n                        name = name.split('.')[-1]\n                        add_symbol(name, address, size)\n                    name = None\n                if len(parts) >= 4 and parts[0].startswith('0x') and (parts[2] == '=') and (parts[1] != '.'):\n                    add_symbol(parts[1], parts[0])\n    rom_start = symbols['_sfixed'][0]\n    ram_start = symbols['_srelocate'][0]\n    ram_end = symbols['_estack'][0]\n    ram_length = ram_end - ram_start\n    if analyze_snapshots == 'all':\n        snapshots = range(len(ram_dump) // ram_length - 1, -1, -1)\n    elif analyze_snapshots == 'last':\n        snapshots = range(len(ram_dump) // ram_length - 1, len(ram_dump) // ram_length - 2, -1)\n    for snapshot_num in snapshots:\n        ram = ram_dump[ram_length * snapshot_num:ram_length * (snapshot_num + 1)]\n        ownership_graph = pgv.AGraph(directed=True)\n\n        def load(address, size=4):\n            if size is None:\n                raise ValueError('You must provide a size')\n            if address > ram_start:\n                ram_address = address - ram_start\n                if ram_address + size > len(ram):\n                    raise ValueError('Unable to read 0x{:08x} from ram.'.format(address))\n                return ram[ram_address:ram_address + size]\n            elif address < len(rom):\n                if address + size > len(rom):\n                    raise ValueError('Unable to read 0x{:08x} from rom.'.format(address))\n                return rom[address:address + size]\n\n        def load_pointer(address):\n            return struct.unpack('<I', load(address))[0]\n        if 'heap' in symbols:\n            (heap_start, heap_size) = symbols['heap']\n        else:\n            print('no static heap')\n            (allocations_start, allocations_size) = symbols['allocations']\n            allocations = load(allocations_start, allocations_size)\n            first_zero = True\n            potential_heap = None\n            for (address, size) in struct.iter_unpack('<II', allocations):\n                print(address, size)\n                if address == 0 and first_zero:\n                    first_zero = False\n                if first_zero:\n                    potential_heap = (address, size)\n                if not first_zero and address != 0:\n                    if address != potential_heap[0] + potential_heap[1]:\n                        print('no active heap')\n                        return\n                    else:\n                        (heap_start, heap_size) = potential_heap\n                        break\n        print('found heap', heap_start, heap_size)\n        heap = load(heap_start, heap_size)\n        total_byte_len = len(heap)\n        mp_state_ctx = symbols['mp_state_ctx'][0]\n        manual_symbol_map['mp_state_ctx+20'] = 'mp_state_ctx.vm.last_pool'\n        last_pool = load_pointer(mp_state_ctx + 20)\n        manual_symbol_map['mp_state_ctx+108'] = 'mp_state_ctx.vm.dict_main.map.table'\n        dict_main_table = load_pointer(mp_state_ctx + 108)\n        manual_symbol_map['mp_state_ctx+84'] = 'mp_state_ctx.vm.mp_loaded_modules_dict.map.table'\n        imports_table = load_pointer(mp_state_ctx + 84)\n        manual_symbol_map['mp_state_ctx+124'] = 'mp_state_ctx.vm.mp_sys_path_obj.items'\n        manual_symbol_map['mp_state_ctx+140'] = 'mp_state_ctx.vm.mp_sys_argv_obj.items'\n        manual_symbol_map['mp_state_ctx+96'] = 'mp_state_ctx.vm.dict_main'\n        manual_symbol_map['0x200015e0'] = 'mp_state_ctx.vm.dict_main'\n        for i in range(READLINE_HIST_SIZE):\n            manual_symbol_map['mp_state_ctx+{}'.format(148 + i * 4)] = 'mp_state_ctx.vm.readline_hist[{}]'.format(i)\n        tuple_type = symbols['mp_type_tuple'][0]\n        type_type = symbols['mp_type_type'][0]\n        map_type = symbols['mp_type_map'][0]\n        dict_type = symbols['mp_type_dict'][0]\n        property_type = symbols['mp_type_property'][0]\n        str_type = symbols['mp_type_str'][0]\n        function_types = [symbols['mp_type_fun_' + x][0] for x in ['bc', 'builtin_0', 'builtin_1', 'builtin_2', 'builtin_3', 'builtin_var']]\n        bytearray_type = symbols['mp_type_bytearray'][0]\n        dynamic_type = 1073741824\n        type_colors = {dict_type: 'red', property_type: 'yellow', map_type: 'blue', type_type: 'orange', tuple_type: 'skyblue', str_type: 'pink', bytearray_type: 'purple'}\n        pool_shift = heap_start % BYTES_PER_BLOCK\n        atb_length = total_byte_len * BITS_PER_BYTE // (BITS_PER_BYTE + BITS_PER_BYTE * BLOCKS_PER_ATB // BLOCKS_PER_FTB + BITS_PER_BYTE * BLOCKS_PER_ATB * BYTES_PER_BLOCK)\n        pool_length = atb_length * BLOCKS_PER_ATB * BYTES_PER_BLOCK\n        gc_finaliser_table_byte_len = (atb_length * BLOCKS_PER_ATB + BLOCKS_PER_FTB - 1) // BLOCKS_PER_FTB\n        if print_heap_structure:\n            print('mp_state_ctx at 0x{:08x} and length {}'.format(*symbols['mp_state_ctx']))\n            print('Total heap length:', total_byte_len)\n            print('ATB length:', atb_length)\n            print('Total allocatable:', pool_length)\n            print('FTB length:', gc_finaliser_table_byte_len)\n        pool_start = heap_start + total_byte_len - pool_length - pool_shift\n        pool = heap[-pool_length - pool_shift:]\n        total_height = 128 * 18\n        total_width = pool_length // (128 * 16) * 85\n        map_element_blocks = [dict_main_table, imports_table]\n        string_blocks = []\n        bytecode_blocks = []\n        qstr_pools = []\n        qstr_chunks = []\n        block_data = {}\n        prev_pool = last_pool\n        while prev_pool > ram_start:\n            qstr_pools.append(prev_pool)\n            prev_pool = load_pointer(prev_pool)\n\n        def save_allocated_block(end, current_allocation):\n            allocation_length = current_allocation * BYTES_PER_BLOCK\n            start = end - allocation_length\n            address = pool_start + start\n            data = pool[start:end]\n            if print_block_state:\n                print('0x{:x} {} bytes allocated'.format(address, allocation_length))\n            if print_block_contents:\n                print(data)\n            rows = ''\n            for k in range(current_allocation - 1):\n                rows += '<tr>'\n                for l in range(4):\n                    rows += '<td port=\"{}\" height=\"18\" width=\"20\"></td>'.format(4 * (k + 1) + l)\n                rows += '</tr>'\n            table = '<<table bgcolor=\"gray\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\"><tr><td colspan=\"4\" port=\"0\" height=\"18\" width=\"80\">0x{:08x}</td></tr>{}</table>>'.format(address, rows)\n            ownership_graph.add_node(address, label=table, style='invisible', shape='plaintext')\n            print('add  0x{:08x}'.format(address))\n            potential_type = None\n            node = ownership_graph.get_node(address)\n            node.attr['height'] = 0.25 * current_allocation\n            node.attr['fontcolor'] = 'black'\n            block_data[address] = data\n            for k in range(len(data) // 4):\n                word = struct.unpack_from('<I', data, offset=k * 4)[0]\n                if word < len(rom) and k == 0 or address in qstr_pools:\n                    potential_type = word\n                    bgcolor = 'gray'\n                    if address in qstr_pools:\n                        bgcolor = 'tomato'\n                    elif potential_type in function_types:\n                        bgcolor = 'green'\n                    elif potential_type in type_colors:\n                        bgcolor = type_colors[potential_type]\n                    elif print_unknown_types:\n                        print('unknown type', hex(potential_type))\n                    node.attr['label'] = '<' + node.attr['label'].replace('\"gray\"', '\"' + bgcolor + '\"') + '>'\n                if potential_type == str_type and k == 3:\n                    string_blocks.append(word)\n                if potential_type == dict_type:\n                    if k == 3:\n                        map_element_blocks.append(word)\n                if ram_start < word < ram_start + len(ram) and word % 16 == 0:\n                    port = k\n                    if k < 4:\n                        port = 0\n                    ownership_graph.add_edge(address, word, tailport=str(port) + ':_')\n                    print('  0x{:08x}'.format(word))\n                    if address in qstr_pools:\n                        if k > 0:\n                            qstr_chunks.append(word)\n                    if k == 0:\n                        potential_type = dynamic_type\n                if potential_type == dynamic_type:\n                    if k == 0:\n                        node.attr['fillcolor'] = 'plum'\n                    if k == 3 and ram_start < word < ram_end:\n                        map_element_blocks.append(word)\n                if potential_type in function_types:\n                    if k == 2 and ram_start < word < ram_end:\n                        bytecode_blocks.append(word)\n        longest_free = 0\n        current_free = 0\n        current_allocation = 0\n        total_free = 0\n        for i in range(atb_length):\n            atb = heap[i]\n            for j in range(4):\n                block_state = atb >> j * 2 & 3\n                if block_state != AT_FREE and current_free > 0:\n                    if print_block_state:\n                        print('{} bytes free'.format(current_free * BYTES_PER_BLOCK))\n                    current_free = 0\n                if block_state != AT_TAIL and current_allocation > 0:\n                    save_allocated_block((i * BLOCKS_PER_ATB + j) * BYTES_PER_BLOCK, current_allocation)\n                    current_allocation = 0\n                if block_state == AT_FREE:\n                    current_free += 1\n                    total_free += 1\n                elif block_state == AT_HEAD or block_state == AT_MARK:\n                    current_allocation = 1\n                elif block_state == AT_TAIL and current_allocation > 0:\n                    current_allocation += 1\n                longest_free = max(longest_free, current_free)\n        if current_allocation > 0:\n            save_allocated_block(pool_length, current_allocation)\n\n        def is_qstr(obj):\n            return obj & 4286578695 == 6\n\n        def find_qstr(qstr_index):\n            pool_ptr = last_pool\n            if not is_qstr(qstr_index):\n                return 'object'\n            pool = block_data[pool_ptr]\n            (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', pool)\n            qstr_index >>= 3\n            if qstr_index > total_prev_len + alloc:\n                return 'invalid'\n            while pool_ptr != 0:\n                if pool_ptr > ram_start:\n                    if pool_ptr in block_data:\n                        pool = block_data[pool_ptr]\n                        (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', pool)\n                    else:\n                        print('missing qstr pool: {:08x}'.format(pool_ptr))\n                        return 'missing'\n                else:\n                    rom_offset = pool_ptr - rom_start\n                    (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', rom[rom_offset:rom_offset + 32])\n                    pool = rom[rom_offset:rom_offset + 32 + length * 4]\n                if qstr_index >= total_prev_len:\n                    offset = (qstr_index - total_prev_len) * 4 + 16\n                    start = struct.unpack_from('<I', pool, offset=offset)[0]\n                    if start < heap_start:\n                        start -= rom_start\n                        if start > len(rom):\n                            return 'more than rom: {:x}'.format(start + rom_start)\n                        (qstr_hash, qstr_len) = struct.unpack('<BB', rom[start:start + 2])\n                        return rom[start + 2:start + 2 + qstr_len].decode('utf-8')\n                    else:\n                        if start > heap_start + len(heap):\n                            return 'out of range: {:x}'.format(start)\n                        local = start - heap_start\n                        (qstr_hash, qstr_len) = struct.unpack('<BB', heap[local:local + 2])\n                        return heap[local + 2:local + 2 + qstr_len].decode('utf-8')\n                pool_ptr = prev\n            return 'unknown'\n\n        def format(obj):\n            if obj & 1 != 0:\n                return obj >> 1\n            if is_qstr(obj):\n                return find_qstr(obj)\n            else:\n                return '0x{:08x}'.format(obj)\n        for block in sorted(map_element_blocks):\n            if block == 0:\n                continue\n            try:\n                node = ownership_graph.get_node(block)\n            except KeyError:\n                print('Unable to find memory block for 0x{:08x}. Is there something running?'.format(block))\n                continue\n            if block not in block_data:\n                continue\n            data = block_data[block]\n            cells = []\n            for i in range(len(data) // 8):\n                (key, value) = struct.unpack_from('<II', data, offset=i * 8)\n                if key == MP_OBJ_NULL or key == MP_OBJ_SENTINEL:\n                    cells.append(('', ' '))\n                else:\n                    cells.append((key, format(key)))\n                    if value in block_data:\n                        edge = ownership_graph.get_edge(block, value)\n                        edge.attr['tailport'] = str(key)\n            rows = ''\n            for i in range(len(cells) // 2):\n                rows += '<tr><td port=\"{}\">{}</td><td port=\"{}\">{}</td></tr>'.format(cells[2 * i][0], cells[2 * i][1], cells[2 * i + 1][0], cells[2 * i + 1][1])\n            node.attr['shape'] = 'plaintext'\n            node.attr['style'] = 'invisible'\n            node.attr['label'] = '<<table bgcolor=\"gold\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\"><tr><td colspan=\"2\">0x{:08x}</td></tr>{}</table>>'.format(block, rows)\n        for (node, degree) in ownership_graph.in_degree_iter():\n            print(node, degree)\n            if degree == 0:\n                address_bytes = struct.pack('<I', int(node))\n                location = -1\n                for _ in range(ram.count(address_bytes)):\n                    location = ram.find(address_bytes, location + 1)\n                    pointer_location = ram_start + location\n                    source = '0x{:08x}'.format(pointer_location)\n                    if pointer_location in symbol_lookup:\n                        source = symbol_lookup[pointer_location]\n                    if source in manual_symbol_map:\n                        source = manual_symbol_map[source]\n                    if 'readline_hist' in source:\n                        string_blocks.append(int(node))\n                    if pointer_location > heap_start + heap_size:\n                        source = 'stack ' + source\n                    ownership_graph.add_edge(source, node)\n        for block in string_blocks:\n            if block == 0:\n                continue\n            node = ownership_graph.get_node(block)\n            node.attr['fillcolor'] = 'hotpink'\n            if block in block_data:\n                raw_string = block_data[block]\n            else:\n                print('Unable to find memory block for string at 0x{:08x}.'.format(block))\n                continue\n            try:\n                raw_string = block_data[block].decode('utf-8')\n            except:\n                raw_string = str(block_data[block])\n            wrapped = []\n            for i in range(0, len(raw_string), 16):\n                wrapped.append(raw_string[i:i + 16])\n            node.attr['label'] = '\\n'.join(wrapped)\n            node.attr['style'] = 'filled'\n            node.attr['fontname'] = 'FiraCode-Medium'\n            node.attr['fontpath'] = '/Users/tannewt/Library/Fonts/'\n            node.attr['fontsize'] = 8\n            node.attr['height'] = len(wrapped) * 0.25\n        for block in bytecode_blocks:\n            node = ownership_graph.get_node(block)\n            node.attr['fillcolor'] = 'lightseagreen'\n            if block in block_data:\n                data = block_data[block]\n            else:\n                print('Unable to find memory block for bytecode at 0x{:08x}.'.format(block))\n                continue\n            prelude = Prelude(io.BufferedReader(io.BytesIO(data)))\n            node.attr['shape'] = 'plaintext'\n            node.attr['style'] = 'invisible'\n            code_info_size = prelude.code_info_size\n            rows = ''\n            remaining_bytecode = len(data) - 16\n            while code_info_size >= 16:\n                rows += '<tr><td colspan=\"16\" bgcolor=\"palegreen\" height=\"18\" width=\"80\"></td></tr>'\n                code_info_size -= 16\n                remaining_bytecode -= 16\n            if code_info_size > 0:\n                rows += '<tr><td colspan=\"{}\" bgcolor=\"palegreen\" height=\"18\" width=\"{}\"></td><td colspan=\"{}\" bgcolor=\"seagreen\" height=\"18\" width=\"{}\"></td></tr>'.format(code_info_size, code_info_size * (80 / 16), 16 - code_info_size, 80 / 16 * (16 - code_info_size))\n                remaining_bytecode -= 16\n            for i in range(remaining_bytecode // 16):\n                rows += '<tr><td colspan=\"16\" bgcolor=\"seagreen\" height=\"18\" width=\"80\"></td></tr>'\n            node.attr['label'] = '<<table border=\"1\" cellspacing=\"0\"><tr><td colspan=\"16\" bgcolor=\"lightseagreen\" height=\"18\" width=\"80\">0x{:08x}</td></tr>{}</table>>'.format(block, rows)\n        for block in qstr_chunks:\n            if block not in block_data:\n                ownership_graph.delete_node(block)\n                continue\n            data = block_data[block]\n            qstrs_in_chunk = ''\n            offset = 0\n            while offset < len(data) - 1:\n                (qstr_hash, qstr_len) = struct.unpack_from('<BB', data, offset=offset)\n                if qstr_hash == 0:\n                    qstrs_in_chunk += ' ' * (len(data) - offset)\n                    offset = len(data)\n                    continue\n                offset += 2 + qstr_len + 1\n                try:\n                    qstrs_in_chunk += '  ' + data[offset - qstr_len - 1:offset - 1].decode('utf-8')\n                except UnicodeDecodeError:\n                    qstrs_in_chunk += '  ' + '\u2591' * qstr_len\n            printable_qstrs = ''\n            for i in range(len(qstrs_in_chunk)):\n                c = qstrs_in_chunk[i]\n                if c not in string.printable or c in '\\x0b\\x0c':\n                    printable_qstrs += '\u2591'\n                else:\n                    printable_qstrs += qstrs_in_chunk[i]\n            wrapped = []\n            for i in range(0, len(printable_qstrs), 16):\n                wrapped.append(html.escape(printable_qstrs[i:i + 16]))\n            node = ownership_graph.get_node(block)\n            node.attr['label'] = '<<table border=\"1\" cellspacing=\"0\" bgcolor=\"lightsalmon\" width=\"80\"><tr><td height=\"18\" >0x{:08x}</td></tr><tr><td height=\"{}\" >{}</td></tr></table>>'.format(block, 18 * (len(wrapped) - 1), '<br/>'.join(wrapped))\n            node.attr['fontname'] = 'FiraCode-Bold'\n            node.attr['fontcolor'] = 'black'\n            node.attr['fontpath'] = '/Users/tannewt/Library/Fonts/'\n            node.attr['fontsize'] = 8\n        print('Total free space:', BYTES_PER_BLOCK * total_free)\n        print('Longest free space:', BYTES_PER_BLOCK * longest_free)\n        if draw_heap_ownership:\n            ownership_graph.layout(prog='dot')\n            fn = os.path.join(output_directory, 'heap_ownership{:04d}.svg'.format(snapshot_num))\n            print(fn)\n            ownership_graph.draw(fn)\n        if draw_heap_ownership:\n            for edge in ownership_graph.iteredges():\n                del edge.attr['pos']\n        else:\n            for edge in ownership_graph.edges():\n                ownership_graph.delete_edge(edge)\n        for node in ownership_graph.nodes():\n            try:\n                address = int(node.name)\n            except ValueError:\n                ownership_graph.remove_node(node.name)\n                continue\n            block = (address - pool_start) // 16\n            x = block // 128\n            y = 128 - block % 128\n            try:\n                height = float(node.attr['height'])\n            except:\n                height = 0.25\n            node.attr['pos'] = '{},{}'.format(x * 80, (y - (height - 0.25) * 2) * 18)\n        for block in sorted(map_element_blocks):\n            try:\n                node = ownership_graph.get_node(block)\n            except KeyError:\n                if block != 0:\n                    print('Unable to find memory block for 0x{:08x}. Is there something running?'.format(block))\n                continue\n            if block not in block_data:\n                continue\n            data = block_data[block]\n            cells = []\n            for i in range(len(data) // 8):\n                (key, value) = struct.unpack_from('<II', data, offset=i * 8)\n                if key == MP_OBJ_NULL or key == MP_OBJ_SENTINEL:\n                    cells.append(('', ' '))\n                else:\n                    cells.append((key, ''))\n            rows = ''\n            for i in range(len(cells) // 2):\n                rows += '<tr><td port=\"{}\" height=\"18\" width=\"40\">{}</td><td port=\"{}\" height=\"18\" width=\"40\">{}</td></tr>'.format(cells[2 * i][0], cells[2 * i][1], cells[2 * i + 1][0], cells[2 * i + 1][1])\n            node.attr['label'] = '<<table bgcolor=\"gold\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\">{}</table>>'.format(rows)\n        ownership_graph.add_node('center', pos='{},{}'.format(total_width // 2 - 40, total_height // 2), shape='plaintext', label=' ')\n        ownership_graph.graph_attr['viewport'] = '{},{},1,{}'.format(total_width, total_height, 'center')\n        ownership_graph.has_layout = True\n        if draw_heap_layout:\n            fn = os.path.join(output_directory, 'heap_layout{:04d}.png'.format(snapshot_num))\n            print(fn)\n            ownership_graph.draw(fn)",
            "@click.command()\n@click.argument('ram_filename')\n@click.argument('bin_filename')\n@click.argument('map_filename')\n@click.option('--print_block_contents', default=False, help='Prints the contents of each allocated block')\n@click.option('--print_unknown_types', default=False, help=\"Prints the micropython base type if we don't understand it.\")\n@click.option('--print_block_state', default=False, help='Prints the heap block states (allocated or free)')\n@click.option('--print_conflicting_symbols', default=False, help='Prints conflicting symbols from the map')\n@click.option('--print-heap-structure/--no-print-heap-structure', default=False, help='Print heap structure')\n@click.option('--output_directory', default='heapvis', help='Destination for rendered output')\n@click.option('--draw-heap-layout/--no-draw-heap-layout', default=True, help='Draw the heap layout')\n@click.option('--draw-heap-ownership/--no-draw-heap-ownership', default=False, help='Draw the ownership graph of blocks on the heap')\n@click.option('--analyze-snapshots', default='last', type=click.Choice(['all', 'last']))\ndef do_all_the_things(ram_filename, bin_filename, map_filename, print_block_contents, print_unknown_types, print_block_state, print_conflicting_symbols, print_heap_structure, output_directory, draw_heap_layout, draw_heap_ownership, analyze_snapshots):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with open(ram_filename, 'rb') as f:\n        ram_dump = f.read()\n    with open(bin_filename, 'rb') as f:\n        rom = f.read()\n    symbols = {}\n    symbol_lookup = {}\n    manual_symbol_map = {}\n\n    def add_symbol(name, address=None, size=None):\n        if 'lto_priv' in name:\n            name = name.split('.')[0]\n        if address:\n            address = int(address, 0)\n        if size:\n            size = int(size, 0)\n        if name in symbols:\n            if address and symbols[name][0] and (symbols[name][0] != address):\n                if print_conflicting_symbols:\n                    print('Conflicting symbol: {} at addresses 0x{:08x} and 0x{:08x}'.format(name, address, symbols[name][0]))\n                return\n            if not address:\n                address = symbols[name][0]\n            if not size:\n                size = symbols[name][1]\n        symbols[name] = (address, size)\n        if address:\n            if not size:\n                size = 4\n            for offset in range(0, size, 4):\n                symbol_lookup[address + offset] = '{}+{}'.format(name, offset)\n    with open(map_filename, 'r') as f:\n        common_symbols = False\n        name = None\n        for line in f:\n            line = line.strip()\n            parts = line.split()\n            if line.startswith('Common symbol'):\n                common_symbols = True\n            if line == 'Discarded input sections':\n                common_symbols = False\n            if common_symbols:\n                if len(parts) == 1:\n                    name = parts[0]\n                elif len(parts) == 2 and name:\n                    add_symbol(name, size=parts[0])\n                    name = None\n                elif len(parts) == 3:\n                    add_symbol(parts[0], size=parts[1])\n                    name = None\n            else:\n                if len(parts) == 1 and parts[0].startswith(('.text', '.rodata', '.bss')) and (parts[0].count('.') > 1) and (not parts[0].isnumeric()) and ('.str' not in parts[0]):\n                    name = parts[0].split('.')[2]\n                if len(parts) == 3 and parts[0].startswith('0x') and parts[1].startswith('0x') and name:\n                    add_symbol(name, parts[0], parts[1])\n                    name = None\n                if len(parts) == 2 and parts[0].startswith('0x') and (not parts[1].startswith('0x')):\n                    add_symbol(parts[1], parts[0])\n                if len(parts) == 4 and parts[0] not in SKIP_SYMBOLS and parts[1].startswith('0x') and parts[2].startswith('0x'):\n                    (name, address, size, source) = parts\n                    if name.startswith(('.text', '.rodata', '.bss')) and name.count('.') > 1:\n                        name = name.split('.')[-1]\n                        add_symbol(name, address, size)\n                    name = None\n                if len(parts) >= 4 and parts[0].startswith('0x') and (parts[2] == '=') and (parts[1] != '.'):\n                    add_symbol(parts[1], parts[0])\n    rom_start = symbols['_sfixed'][0]\n    ram_start = symbols['_srelocate'][0]\n    ram_end = symbols['_estack'][0]\n    ram_length = ram_end - ram_start\n    if analyze_snapshots == 'all':\n        snapshots = range(len(ram_dump) // ram_length - 1, -1, -1)\n    elif analyze_snapshots == 'last':\n        snapshots = range(len(ram_dump) // ram_length - 1, len(ram_dump) // ram_length - 2, -1)\n    for snapshot_num in snapshots:\n        ram = ram_dump[ram_length * snapshot_num:ram_length * (snapshot_num + 1)]\n        ownership_graph = pgv.AGraph(directed=True)\n\n        def load(address, size=4):\n            if size is None:\n                raise ValueError('You must provide a size')\n            if address > ram_start:\n                ram_address = address - ram_start\n                if ram_address + size > len(ram):\n                    raise ValueError('Unable to read 0x{:08x} from ram.'.format(address))\n                return ram[ram_address:ram_address + size]\n            elif address < len(rom):\n                if address + size > len(rom):\n                    raise ValueError('Unable to read 0x{:08x} from rom.'.format(address))\n                return rom[address:address + size]\n\n        def load_pointer(address):\n            return struct.unpack('<I', load(address))[0]\n        if 'heap' in symbols:\n            (heap_start, heap_size) = symbols['heap']\n        else:\n            print('no static heap')\n            (allocations_start, allocations_size) = symbols['allocations']\n            allocations = load(allocations_start, allocations_size)\n            first_zero = True\n            potential_heap = None\n            for (address, size) in struct.iter_unpack('<II', allocations):\n                print(address, size)\n                if address == 0 and first_zero:\n                    first_zero = False\n                if first_zero:\n                    potential_heap = (address, size)\n                if not first_zero and address != 0:\n                    if address != potential_heap[0] + potential_heap[1]:\n                        print('no active heap')\n                        return\n                    else:\n                        (heap_start, heap_size) = potential_heap\n                        break\n        print('found heap', heap_start, heap_size)\n        heap = load(heap_start, heap_size)\n        total_byte_len = len(heap)\n        mp_state_ctx = symbols['mp_state_ctx'][0]\n        manual_symbol_map['mp_state_ctx+20'] = 'mp_state_ctx.vm.last_pool'\n        last_pool = load_pointer(mp_state_ctx + 20)\n        manual_symbol_map['mp_state_ctx+108'] = 'mp_state_ctx.vm.dict_main.map.table'\n        dict_main_table = load_pointer(mp_state_ctx + 108)\n        manual_symbol_map['mp_state_ctx+84'] = 'mp_state_ctx.vm.mp_loaded_modules_dict.map.table'\n        imports_table = load_pointer(mp_state_ctx + 84)\n        manual_symbol_map['mp_state_ctx+124'] = 'mp_state_ctx.vm.mp_sys_path_obj.items'\n        manual_symbol_map['mp_state_ctx+140'] = 'mp_state_ctx.vm.mp_sys_argv_obj.items'\n        manual_symbol_map['mp_state_ctx+96'] = 'mp_state_ctx.vm.dict_main'\n        manual_symbol_map['0x200015e0'] = 'mp_state_ctx.vm.dict_main'\n        for i in range(READLINE_HIST_SIZE):\n            manual_symbol_map['mp_state_ctx+{}'.format(148 + i * 4)] = 'mp_state_ctx.vm.readline_hist[{}]'.format(i)\n        tuple_type = symbols['mp_type_tuple'][0]\n        type_type = symbols['mp_type_type'][0]\n        map_type = symbols['mp_type_map'][0]\n        dict_type = symbols['mp_type_dict'][0]\n        property_type = symbols['mp_type_property'][0]\n        str_type = symbols['mp_type_str'][0]\n        function_types = [symbols['mp_type_fun_' + x][0] for x in ['bc', 'builtin_0', 'builtin_1', 'builtin_2', 'builtin_3', 'builtin_var']]\n        bytearray_type = symbols['mp_type_bytearray'][0]\n        dynamic_type = 1073741824\n        type_colors = {dict_type: 'red', property_type: 'yellow', map_type: 'blue', type_type: 'orange', tuple_type: 'skyblue', str_type: 'pink', bytearray_type: 'purple'}\n        pool_shift = heap_start % BYTES_PER_BLOCK\n        atb_length = total_byte_len * BITS_PER_BYTE // (BITS_PER_BYTE + BITS_PER_BYTE * BLOCKS_PER_ATB // BLOCKS_PER_FTB + BITS_PER_BYTE * BLOCKS_PER_ATB * BYTES_PER_BLOCK)\n        pool_length = atb_length * BLOCKS_PER_ATB * BYTES_PER_BLOCK\n        gc_finaliser_table_byte_len = (atb_length * BLOCKS_PER_ATB + BLOCKS_PER_FTB - 1) // BLOCKS_PER_FTB\n        if print_heap_structure:\n            print('mp_state_ctx at 0x{:08x} and length {}'.format(*symbols['mp_state_ctx']))\n            print('Total heap length:', total_byte_len)\n            print('ATB length:', atb_length)\n            print('Total allocatable:', pool_length)\n            print('FTB length:', gc_finaliser_table_byte_len)\n        pool_start = heap_start + total_byte_len - pool_length - pool_shift\n        pool = heap[-pool_length - pool_shift:]\n        total_height = 128 * 18\n        total_width = pool_length // (128 * 16) * 85\n        map_element_blocks = [dict_main_table, imports_table]\n        string_blocks = []\n        bytecode_blocks = []\n        qstr_pools = []\n        qstr_chunks = []\n        block_data = {}\n        prev_pool = last_pool\n        while prev_pool > ram_start:\n            qstr_pools.append(prev_pool)\n            prev_pool = load_pointer(prev_pool)\n\n        def save_allocated_block(end, current_allocation):\n            allocation_length = current_allocation * BYTES_PER_BLOCK\n            start = end - allocation_length\n            address = pool_start + start\n            data = pool[start:end]\n            if print_block_state:\n                print('0x{:x} {} bytes allocated'.format(address, allocation_length))\n            if print_block_contents:\n                print(data)\n            rows = ''\n            for k in range(current_allocation - 1):\n                rows += '<tr>'\n                for l in range(4):\n                    rows += '<td port=\"{}\" height=\"18\" width=\"20\"></td>'.format(4 * (k + 1) + l)\n                rows += '</tr>'\n            table = '<<table bgcolor=\"gray\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\"><tr><td colspan=\"4\" port=\"0\" height=\"18\" width=\"80\">0x{:08x}</td></tr>{}</table>>'.format(address, rows)\n            ownership_graph.add_node(address, label=table, style='invisible', shape='plaintext')\n            print('add  0x{:08x}'.format(address))\n            potential_type = None\n            node = ownership_graph.get_node(address)\n            node.attr['height'] = 0.25 * current_allocation\n            node.attr['fontcolor'] = 'black'\n            block_data[address] = data\n            for k in range(len(data) // 4):\n                word = struct.unpack_from('<I', data, offset=k * 4)[0]\n                if word < len(rom) and k == 0 or address in qstr_pools:\n                    potential_type = word\n                    bgcolor = 'gray'\n                    if address in qstr_pools:\n                        bgcolor = 'tomato'\n                    elif potential_type in function_types:\n                        bgcolor = 'green'\n                    elif potential_type in type_colors:\n                        bgcolor = type_colors[potential_type]\n                    elif print_unknown_types:\n                        print('unknown type', hex(potential_type))\n                    node.attr['label'] = '<' + node.attr['label'].replace('\"gray\"', '\"' + bgcolor + '\"') + '>'\n                if potential_type == str_type and k == 3:\n                    string_blocks.append(word)\n                if potential_type == dict_type:\n                    if k == 3:\n                        map_element_blocks.append(word)\n                if ram_start < word < ram_start + len(ram) and word % 16 == 0:\n                    port = k\n                    if k < 4:\n                        port = 0\n                    ownership_graph.add_edge(address, word, tailport=str(port) + ':_')\n                    print('  0x{:08x}'.format(word))\n                    if address in qstr_pools:\n                        if k > 0:\n                            qstr_chunks.append(word)\n                    if k == 0:\n                        potential_type = dynamic_type\n                if potential_type == dynamic_type:\n                    if k == 0:\n                        node.attr['fillcolor'] = 'plum'\n                    if k == 3 and ram_start < word < ram_end:\n                        map_element_blocks.append(word)\n                if potential_type in function_types:\n                    if k == 2 and ram_start < word < ram_end:\n                        bytecode_blocks.append(word)\n        longest_free = 0\n        current_free = 0\n        current_allocation = 0\n        total_free = 0\n        for i in range(atb_length):\n            atb = heap[i]\n            for j in range(4):\n                block_state = atb >> j * 2 & 3\n                if block_state != AT_FREE and current_free > 0:\n                    if print_block_state:\n                        print('{} bytes free'.format(current_free * BYTES_PER_BLOCK))\n                    current_free = 0\n                if block_state != AT_TAIL and current_allocation > 0:\n                    save_allocated_block((i * BLOCKS_PER_ATB + j) * BYTES_PER_BLOCK, current_allocation)\n                    current_allocation = 0\n                if block_state == AT_FREE:\n                    current_free += 1\n                    total_free += 1\n                elif block_state == AT_HEAD or block_state == AT_MARK:\n                    current_allocation = 1\n                elif block_state == AT_TAIL and current_allocation > 0:\n                    current_allocation += 1\n                longest_free = max(longest_free, current_free)\n        if current_allocation > 0:\n            save_allocated_block(pool_length, current_allocation)\n\n        def is_qstr(obj):\n            return obj & 4286578695 == 6\n\n        def find_qstr(qstr_index):\n            pool_ptr = last_pool\n            if not is_qstr(qstr_index):\n                return 'object'\n            pool = block_data[pool_ptr]\n            (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', pool)\n            qstr_index >>= 3\n            if qstr_index > total_prev_len + alloc:\n                return 'invalid'\n            while pool_ptr != 0:\n                if pool_ptr > ram_start:\n                    if pool_ptr in block_data:\n                        pool = block_data[pool_ptr]\n                        (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', pool)\n                    else:\n                        print('missing qstr pool: {:08x}'.format(pool_ptr))\n                        return 'missing'\n                else:\n                    rom_offset = pool_ptr - rom_start\n                    (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', rom[rom_offset:rom_offset + 32])\n                    pool = rom[rom_offset:rom_offset + 32 + length * 4]\n                if qstr_index >= total_prev_len:\n                    offset = (qstr_index - total_prev_len) * 4 + 16\n                    start = struct.unpack_from('<I', pool, offset=offset)[0]\n                    if start < heap_start:\n                        start -= rom_start\n                        if start > len(rom):\n                            return 'more than rom: {:x}'.format(start + rom_start)\n                        (qstr_hash, qstr_len) = struct.unpack('<BB', rom[start:start + 2])\n                        return rom[start + 2:start + 2 + qstr_len].decode('utf-8')\n                    else:\n                        if start > heap_start + len(heap):\n                            return 'out of range: {:x}'.format(start)\n                        local = start - heap_start\n                        (qstr_hash, qstr_len) = struct.unpack('<BB', heap[local:local + 2])\n                        return heap[local + 2:local + 2 + qstr_len].decode('utf-8')\n                pool_ptr = prev\n            return 'unknown'\n\n        def format(obj):\n            if obj & 1 != 0:\n                return obj >> 1\n            if is_qstr(obj):\n                return find_qstr(obj)\n            else:\n                return '0x{:08x}'.format(obj)\n        for block in sorted(map_element_blocks):\n            if block == 0:\n                continue\n            try:\n                node = ownership_graph.get_node(block)\n            except KeyError:\n                print('Unable to find memory block for 0x{:08x}. Is there something running?'.format(block))\n                continue\n            if block not in block_data:\n                continue\n            data = block_data[block]\n            cells = []\n            for i in range(len(data) // 8):\n                (key, value) = struct.unpack_from('<II', data, offset=i * 8)\n                if key == MP_OBJ_NULL or key == MP_OBJ_SENTINEL:\n                    cells.append(('', ' '))\n                else:\n                    cells.append((key, format(key)))\n                    if value in block_data:\n                        edge = ownership_graph.get_edge(block, value)\n                        edge.attr['tailport'] = str(key)\n            rows = ''\n            for i in range(len(cells) // 2):\n                rows += '<tr><td port=\"{}\">{}</td><td port=\"{}\">{}</td></tr>'.format(cells[2 * i][0], cells[2 * i][1], cells[2 * i + 1][0], cells[2 * i + 1][1])\n            node.attr['shape'] = 'plaintext'\n            node.attr['style'] = 'invisible'\n            node.attr['label'] = '<<table bgcolor=\"gold\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\"><tr><td colspan=\"2\">0x{:08x}</td></tr>{}</table>>'.format(block, rows)\n        for (node, degree) in ownership_graph.in_degree_iter():\n            print(node, degree)\n            if degree == 0:\n                address_bytes = struct.pack('<I', int(node))\n                location = -1\n                for _ in range(ram.count(address_bytes)):\n                    location = ram.find(address_bytes, location + 1)\n                    pointer_location = ram_start + location\n                    source = '0x{:08x}'.format(pointer_location)\n                    if pointer_location in symbol_lookup:\n                        source = symbol_lookup[pointer_location]\n                    if source in manual_symbol_map:\n                        source = manual_symbol_map[source]\n                    if 'readline_hist' in source:\n                        string_blocks.append(int(node))\n                    if pointer_location > heap_start + heap_size:\n                        source = 'stack ' + source\n                    ownership_graph.add_edge(source, node)\n        for block in string_blocks:\n            if block == 0:\n                continue\n            node = ownership_graph.get_node(block)\n            node.attr['fillcolor'] = 'hotpink'\n            if block in block_data:\n                raw_string = block_data[block]\n            else:\n                print('Unable to find memory block for string at 0x{:08x}.'.format(block))\n                continue\n            try:\n                raw_string = block_data[block].decode('utf-8')\n            except:\n                raw_string = str(block_data[block])\n            wrapped = []\n            for i in range(0, len(raw_string), 16):\n                wrapped.append(raw_string[i:i + 16])\n            node.attr['label'] = '\\n'.join(wrapped)\n            node.attr['style'] = 'filled'\n            node.attr['fontname'] = 'FiraCode-Medium'\n            node.attr['fontpath'] = '/Users/tannewt/Library/Fonts/'\n            node.attr['fontsize'] = 8\n            node.attr['height'] = len(wrapped) * 0.25\n        for block in bytecode_blocks:\n            node = ownership_graph.get_node(block)\n            node.attr['fillcolor'] = 'lightseagreen'\n            if block in block_data:\n                data = block_data[block]\n            else:\n                print('Unable to find memory block for bytecode at 0x{:08x}.'.format(block))\n                continue\n            prelude = Prelude(io.BufferedReader(io.BytesIO(data)))\n            node.attr['shape'] = 'plaintext'\n            node.attr['style'] = 'invisible'\n            code_info_size = prelude.code_info_size\n            rows = ''\n            remaining_bytecode = len(data) - 16\n            while code_info_size >= 16:\n                rows += '<tr><td colspan=\"16\" bgcolor=\"palegreen\" height=\"18\" width=\"80\"></td></tr>'\n                code_info_size -= 16\n                remaining_bytecode -= 16\n            if code_info_size > 0:\n                rows += '<tr><td colspan=\"{}\" bgcolor=\"palegreen\" height=\"18\" width=\"{}\"></td><td colspan=\"{}\" bgcolor=\"seagreen\" height=\"18\" width=\"{}\"></td></tr>'.format(code_info_size, code_info_size * (80 / 16), 16 - code_info_size, 80 / 16 * (16 - code_info_size))\n                remaining_bytecode -= 16\n            for i in range(remaining_bytecode // 16):\n                rows += '<tr><td colspan=\"16\" bgcolor=\"seagreen\" height=\"18\" width=\"80\"></td></tr>'\n            node.attr['label'] = '<<table border=\"1\" cellspacing=\"0\"><tr><td colspan=\"16\" bgcolor=\"lightseagreen\" height=\"18\" width=\"80\">0x{:08x}</td></tr>{}</table>>'.format(block, rows)\n        for block in qstr_chunks:\n            if block not in block_data:\n                ownership_graph.delete_node(block)\n                continue\n            data = block_data[block]\n            qstrs_in_chunk = ''\n            offset = 0\n            while offset < len(data) - 1:\n                (qstr_hash, qstr_len) = struct.unpack_from('<BB', data, offset=offset)\n                if qstr_hash == 0:\n                    qstrs_in_chunk += ' ' * (len(data) - offset)\n                    offset = len(data)\n                    continue\n                offset += 2 + qstr_len + 1\n                try:\n                    qstrs_in_chunk += '  ' + data[offset - qstr_len - 1:offset - 1].decode('utf-8')\n                except UnicodeDecodeError:\n                    qstrs_in_chunk += '  ' + '\u2591' * qstr_len\n            printable_qstrs = ''\n            for i in range(len(qstrs_in_chunk)):\n                c = qstrs_in_chunk[i]\n                if c not in string.printable or c in '\\x0b\\x0c':\n                    printable_qstrs += '\u2591'\n                else:\n                    printable_qstrs += qstrs_in_chunk[i]\n            wrapped = []\n            for i in range(0, len(printable_qstrs), 16):\n                wrapped.append(html.escape(printable_qstrs[i:i + 16]))\n            node = ownership_graph.get_node(block)\n            node.attr['label'] = '<<table border=\"1\" cellspacing=\"0\" bgcolor=\"lightsalmon\" width=\"80\"><tr><td height=\"18\" >0x{:08x}</td></tr><tr><td height=\"{}\" >{}</td></tr></table>>'.format(block, 18 * (len(wrapped) - 1), '<br/>'.join(wrapped))\n            node.attr['fontname'] = 'FiraCode-Bold'\n            node.attr['fontcolor'] = 'black'\n            node.attr['fontpath'] = '/Users/tannewt/Library/Fonts/'\n            node.attr['fontsize'] = 8\n        print('Total free space:', BYTES_PER_BLOCK * total_free)\n        print('Longest free space:', BYTES_PER_BLOCK * longest_free)\n        if draw_heap_ownership:\n            ownership_graph.layout(prog='dot')\n            fn = os.path.join(output_directory, 'heap_ownership{:04d}.svg'.format(snapshot_num))\n            print(fn)\n            ownership_graph.draw(fn)\n        if draw_heap_ownership:\n            for edge in ownership_graph.iteredges():\n                del edge.attr['pos']\n        else:\n            for edge in ownership_graph.edges():\n                ownership_graph.delete_edge(edge)\n        for node in ownership_graph.nodes():\n            try:\n                address = int(node.name)\n            except ValueError:\n                ownership_graph.remove_node(node.name)\n                continue\n            block = (address - pool_start) // 16\n            x = block // 128\n            y = 128 - block % 128\n            try:\n                height = float(node.attr['height'])\n            except:\n                height = 0.25\n            node.attr['pos'] = '{},{}'.format(x * 80, (y - (height - 0.25) * 2) * 18)\n        for block in sorted(map_element_blocks):\n            try:\n                node = ownership_graph.get_node(block)\n            except KeyError:\n                if block != 0:\n                    print('Unable to find memory block for 0x{:08x}. Is there something running?'.format(block))\n                continue\n            if block not in block_data:\n                continue\n            data = block_data[block]\n            cells = []\n            for i in range(len(data) // 8):\n                (key, value) = struct.unpack_from('<II', data, offset=i * 8)\n                if key == MP_OBJ_NULL or key == MP_OBJ_SENTINEL:\n                    cells.append(('', ' '))\n                else:\n                    cells.append((key, ''))\n            rows = ''\n            for i in range(len(cells) // 2):\n                rows += '<tr><td port=\"{}\" height=\"18\" width=\"40\">{}</td><td port=\"{}\" height=\"18\" width=\"40\">{}</td></tr>'.format(cells[2 * i][0], cells[2 * i][1], cells[2 * i + 1][0], cells[2 * i + 1][1])\n            node.attr['label'] = '<<table bgcolor=\"gold\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\">{}</table>>'.format(rows)\n        ownership_graph.add_node('center', pos='{},{}'.format(total_width // 2 - 40, total_height // 2), shape='plaintext', label=' ')\n        ownership_graph.graph_attr['viewport'] = '{},{},1,{}'.format(total_width, total_height, 'center')\n        ownership_graph.has_layout = True\n        if draw_heap_layout:\n            fn = os.path.join(output_directory, 'heap_layout{:04d}.png'.format(snapshot_num))\n            print(fn)\n            ownership_graph.draw(fn)",
            "@click.command()\n@click.argument('ram_filename')\n@click.argument('bin_filename')\n@click.argument('map_filename')\n@click.option('--print_block_contents', default=False, help='Prints the contents of each allocated block')\n@click.option('--print_unknown_types', default=False, help=\"Prints the micropython base type if we don't understand it.\")\n@click.option('--print_block_state', default=False, help='Prints the heap block states (allocated or free)')\n@click.option('--print_conflicting_symbols', default=False, help='Prints conflicting symbols from the map')\n@click.option('--print-heap-structure/--no-print-heap-structure', default=False, help='Print heap structure')\n@click.option('--output_directory', default='heapvis', help='Destination for rendered output')\n@click.option('--draw-heap-layout/--no-draw-heap-layout', default=True, help='Draw the heap layout')\n@click.option('--draw-heap-ownership/--no-draw-heap-ownership', default=False, help='Draw the ownership graph of blocks on the heap')\n@click.option('--analyze-snapshots', default='last', type=click.Choice(['all', 'last']))\ndef do_all_the_things(ram_filename, bin_filename, map_filename, print_block_contents, print_unknown_types, print_block_state, print_conflicting_symbols, print_heap_structure, output_directory, draw_heap_layout, draw_heap_ownership, analyze_snapshots):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with open(ram_filename, 'rb') as f:\n        ram_dump = f.read()\n    with open(bin_filename, 'rb') as f:\n        rom = f.read()\n    symbols = {}\n    symbol_lookup = {}\n    manual_symbol_map = {}\n\n    def add_symbol(name, address=None, size=None):\n        if 'lto_priv' in name:\n            name = name.split('.')[0]\n        if address:\n            address = int(address, 0)\n        if size:\n            size = int(size, 0)\n        if name in symbols:\n            if address and symbols[name][0] and (symbols[name][0] != address):\n                if print_conflicting_symbols:\n                    print('Conflicting symbol: {} at addresses 0x{:08x} and 0x{:08x}'.format(name, address, symbols[name][0]))\n                return\n            if not address:\n                address = symbols[name][0]\n            if not size:\n                size = symbols[name][1]\n        symbols[name] = (address, size)\n        if address:\n            if not size:\n                size = 4\n            for offset in range(0, size, 4):\n                symbol_lookup[address + offset] = '{}+{}'.format(name, offset)\n    with open(map_filename, 'r') as f:\n        common_symbols = False\n        name = None\n        for line in f:\n            line = line.strip()\n            parts = line.split()\n            if line.startswith('Common symbol'):\n                common_symbols = True\n            if line == 'Discarded input sections':\n                common_symbols = False\n            if common_symbols:\n                if len(parts) == 1:\n                    name = parts[0]\n                elif len(parts) == 2 and name:\n                    add_symbol(name, size=parts[0])\n                    name = None\n                elif len(parts) == 3:\n                    add_symbol(parts[0], size=parts[1])\n                    name = None\n            else:\n                if len(parts) == 1 and parts[0].startswith(('.text', '.rodata', '.bss')) and (parts[0].count('.') > 1) and (not parts[0].isnumeric()) and ('.str' not in parts[0]):\n                    name = parts[0].split('.')[2]\n                if len(parts) == 3 and parts[0].startswith('0x') and parts[1].startswith('0x') and name:\n                    add_symbol(name, parts[0], parts[1])\n                    name = None\n                if len(parts) == 2 and parts[0].startswith('0x') and (not parts[1].startswith('0x')):\n                    add_symbol(parts[1], parts[0])\n                if len(parts) == 4 and parts[0] not in SKIP_SYMBOLS and parts[1].startswith('0x') and parts[2].startswith('0x'):\n                    (name, address, size, source) = parts\n                    if name.startswith(('.text', '.rodata', '.bss')) and name.count('.') > 1:\n                        name = name.split('.')[-1]\n                        add_symbol(name, address, size)\n                    name = None\n                if len(parts) >= 4 and parts[0].startswith('0x') and (parts[2] == '=') and (parts[1] != '.'):\n                    add_symbol(parts[1], parts[0])\n    rom_start = symbols['_sfixed'][0]\n    ram_start = symbols['_srelocate'][0]\n    ram_end = symbols['_estack'][0]\n    ram_length = ram_end - ram_start\n    if analyze_snapshots == 'all':\n        snapshots = range(len(ram_dump) // ram_length - 1, -1, -1)\n    elif analyze_snapshots == 'last':\n        snapshots = range(len(ram_dump) // ram_length - 1, len(ram_dump) // ram_length - 2, -1)\n    for snapshot_num in snapshots:\n        ram = ram_dump[ram_length * snapshot_num:ram_length * (snapshot_num + 1)]\n        ownership_graph = pgv.AGraph(directed=True)\n\n        def load(address, size=4):\n            if size is None:\n                raise ValueError('You must provide a size')\n            if address > ram_start:\n                ram_address = address - ram_start\n                if ram_address + size > len(ram):\n                    raise ValueError('Unable to read 0x{:08x} from ram.'.format(address))\n                return ram[ram_address:ram_address + size]\n            elif address < len(rom):\n                if address + size > len(rom):\n                    raise ValueError('Unable to read 0x{:08x} from rom.'.format(address))\n                return rom[address:address + size]\n\n        def load_pointer(address):\n            return struct.unpack('<I', load(address))[0]\n        if 'heap' in symbols:\n            (heap_start, heap_size) = symbols['heap']\n        else:\n            print('no static heap')\n            (allocations_start, allocations_size) = symbols['allocations']\n            allocations = load(allocations_start, allocations_size)\n            first_zero = True\n            potential_heap = None\n            for (address, size) in struct.iter_unpack('<II', allocations):\n                print(address, size)\n                if address == 0 and first_zero:\n                    first_zero = False\n                if first_zero:\n                    potential_heap = (address, size)\n                if not first_zero and address != 0:\n                    if address != potential_heap[0] + potential_heap[1]:\n                        print('no active heap')\n                        return\n                    else:\n                        (heap_start, heap_size) = potential_heap\n                        break\n        print('found heap', heap_start, heap_size)\n        heap = load(heap_start, heap_size)\n        total_byte_len = len(heap)\n        mp_state_ctx = symbols['mp_state_ctx'][0]\n        manual_symbol_map['mp_state_ctx+20'] = 'mp_state_ctx.vm.last_pool'\n        last_pool = load_pointer(mp_state_ctx + 20)\n        manual_symbol_map['mp_state_ctx+108'] = 'mp_state_ctx.vm.dict_main.map.table'\n        dict_main_table = load_pointer(mp_state_ctx + 108)\n        manual_symbol_map['mp_state_ctx+84'] = 'mp_state_ctx.vm.mp_loaded_modules_dict.map.table'\n        imports_table = load_pointer(mp_state_ctx + 84)\n        manual_symbol_map['mp_state_ctx+124'] = 'mp_state_ctx.vm.mp_sys_path_obj.items'\n        manual_symbol_map['mp_state_ctx+140'] = 'mp_state_ctx.vm.mp_sys_argv_obj.items'\n        manual_symbol_map['mp_state_ctx+96'] = 'mp_state_ctx.vm.dict_main'\n        manual_symbol_map['0x200015e0'] = 'mp_state_ctx.vm.dict_main'\n        for i in range(READLINE_HIST_SIZE):\n            manual_symbol_map['mp_state_ctx+{}'.format(148 + i * 4)] = 'mp_state_ctx.vm.readline_hist[{}]'.format(i)\n        tuple_type = symbols['mp_type_tuple'][0]\n        type_type = symbols['mp_type_type'][0]\n        map_type = symbols['mp_type_map'][0]\n        dict_type = symbols['mp_type_dict'][0]\n        property_type = symbols['mp_type_property'][0]\n        str_type = symbols['mp_type_str'][0]\n        function_types = [symbols['mp_type_fun_' + x][0] for x in ['bc', 'builtin_0', 'builtin_1', 'builtin_2', 'builtin_3', 'builtin_var']]\n        bytearray_type = symbols['mp_type_bytearray'][0]\n        dynamic_type = 1073741824\n        type_colors = {dict_type: 'red', property_type: 'yellow', map_type: 'blue', type_type: 'orange', tuple_type: 'skyblue', str_type: 'pink', bytearray_type: 'purple'}\n        pool_shift = heap_start % BYTES_PER_BLOCK\n        atb_length = total_byte_len * BITS_PER_BYTE // (BITS_PER_BYTE + BITS_PER_BYTE * BLOCKS_PER_ATB // BLOCKS_PER_FTB + BITS_PER_BYTE * BLOCKS_PER_ATB * BYTES_PER_BLOCK)\n        pool_length = atb_length * BLOCKS_PER_ATB * BYTES_PER_BLOCK\n        gc_finaliser_table_byte_len = (atb_length * BLOCKS_PER_ATB + BLOCKS_PER_FTB - 1) // BLOCKS_PER_FTB\n        if print_heap_structure:\n            print('mp_state_ctx at 0x{:08x} and length {}'.format(*symbols['mp_state_ctx']))\n            print('Total heap length:', total_byte_len)\n            print('ATB length:', atb_length)\n            print('Total allocatable:', pool_length)\n            print('FTB length:', gc_finaliser_table_byte_len)\n        pool_start = heap_start + total_byte_len - pool_length - pool_shift\n        pool = heap[-pool_length - pool_shift:]\n        total_height = 128 * 18\n        total_width = pool_length // (128 * 16) * 85\n        map_element_blocks = [dict_main_table, imports_table]\n        string_blocks = []\n        bytecode_blocks = []\n        qstr_pools = []\n        qstr_chunks = []\n        block_data = {}\n        prev_pool = last_pool\n        while prev_pool > ram_start:\n            qstr_pools.append(prev_pool)\n            prev_pool = load_pointer(prev_pool)\n\n        def save_allocated_block(end, current_allocation):\n            allocation_length = current_allocation * BYTES_PER_BLOCK\n            start = end - allocation_length\n            address = pool_start + start\n            data = pool[start:end]\n            if print_block_state:\n                print('0x{:x} {} bytes allocated'.format(address, allocation_length))\n            if print_block_contents:\n                print(data)\n            rows = ''\n            for k in range(current_allocation - 1):\n                rows += '<tr>'\n                for l in range(4):\n                    rows += '<td port=\"{}\" height=\"18\" width=\"20\"></td>'.format(4 * (k + 1) + l)\n                rows += '</tr>'\n            table = '<<table bgcolor=\"gray\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\"><tr><td colspan=\"4\" port=\"0\" height=\"18\" width=\"80\">0x{:08x}</td></tr>{}</table>>'.format(address, rows)\n            ownership_graph.add_node(address, label=table, style='invisible', shape='plaintext')\n            print('add  0x{:08x}'.format(address))\n            potential_type = None\n            node = ownership_graph.get_node(address)\n            node.attr['height'] = 0.25 * current_allocation\n            node.attr['fontcolor'] = 'black'\n            block_data[address] = data\n            for k in range(len(data) // 4):\n                word = struct.unpack_from('<I', data, offset=k * 4)[0]\n                if word < len(rom) and k == 0 or address in qstr_pools:\n                    potential_type = word\n                    bgcolor = 'gray'\n                    if address in qstr_pools:\n                        bgcolor = 'tomato'\n                    elif potential_type in function_types:\n                        bgcolor = 'green'\n                    elif potential_type in type_colors:\n                        bgcolor = type_colors[potential_type]\n                    elif print_unknown_types:\n                        print('unknown type', hex(potential_type))\n                    node.attr['label'] = '<' + node.attr['label'].replace('\"gray\"', '\"' + bgcolor + '\"') + '>'\n                if potential_type == str_type and k == 3:\n                    string_blocks.append(word)\n                if potential_type == dict_type:\n                    if k == 3:\n                        map_element_blocks.append(word)\n                if ram_start < word < ram_start + len(ram) and word % 16 == 0:\n                    port = k\n                    if k < 4:\n                        port = 0\n                    ownership_graph.add_edge(address, word, tailport=str(port) + ':_')\n                    print('  0x{:08x}'.format(word))\n                    if address in qstr_pools:\n                        if k > 0:\n                            qstr_chunks.append(word)\n                    if k == 0:\n                        potential_type = dynamic_type\n                if potential_type == dynamic_type:\n                    if k == 0:\n                        node.attr['fillcolor'] = 'plum'\n                    if k == 3 and ram_start < word < ram_end:\n                        map_element_blocks.append(word)\n                if potential_type in function_types:\n                    if k == 2 and ram_start < word < ram_end:\n                        bytecode_blocks.append(word)\n        longest_free = 0\n        current_free = 0\n        current_allocation = 0\n        total_free = 0\n        for i in range(atb_length):\n            atb = heap[i]\n            for j in range(4):\n                block_state = atb >> j * 2 & 3\n                if block_state != AT_FREE and current_free > 0:\n                    if print_block_state:\n                        print('{} bytes free'.format(current_free * BYTES_PER_BLOCK))\n                    current_free = 0\n                if block_state != AT_TAIL and current_allocation > 0:\n                    save_allocated_block((i * BLOCKS_PER_ATB + j) * BYTES_PER_BLOCK, current_allocation)\n                    current_allocation = 0\n                if block_state == AT_FREE:\n                    current_free += 1\n                    total_free += 1\n                elif block_state == AT_HEAD or block_state == AT_MARK:\n                    current_allocation = 1\n                elif block_state == AT_TAIL and current_allocation > 0:\n                    current_allocation += 1\n                longest_free = max(longest_free, current_free)\n        if current_allocation > 0:\n            save_allocated_block(pool_length, current_allocation)\n\n        def is_qstr(obj):\n            return obj & 4286578695 == 6\n\n        def find_qstr(qstr_index):\n            pool_ptr = last_pool\n            if not is_qstr(qstr_index):\n                return 'object'\n            pool = block_data[pool_ptr]\n            (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', pool)\n            qstr_index >>= 3\n            if qstr_index > total_prev_len + alloc:\n                return 'invalid'\n            while pool_ptr != 0:\n                if pool_ptr > ram_start:\n                    if pool_ptr in block_data:\n                        pool = block_data[pool_ptr]\n                        (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', pool)\n                    else:\n                        print('missing qstr pool: {:08x}'.format(pool_ptr))\n                        return 'missing'\n                else:\n                    rom_offset = pool_ptr - rom_start\n                    (prev, total_prev_len, alloc, length) = struct.unpack_from('<IIII', rom[rom_offset:rom_offset + 32])\n                    pool = rom[rom_offset:rom_offset + 32 + length * 4]\n                if qstr_index >= total_prev_len:\n                    offset = (qstr_index - total_prev_len) * 4 + 16\n                    start = struct.unpack_from('<I', pool, offset=offset)[0]\n                    if start < heap_start:\n                        start -= rom_start\n                        if start > len(rom):\n                            return 'more than rom: {:x}'.format(start + rom_start)\n                        (qstr_hash, qstr_len) = struct.unpack('<BB', rom[start:start + 2])\n                        return rom[start + 2:start + 2 + qstr_len].decode('utf-8')\n                    else:\n                        if start > heap_start + len(heap):\n                            return 'out of range: {:x}'.format(start)\n                        local = start - heap_start\n                        (qstr_hash, qstr_len) = struct.unpack('<BB', heap[local:local + 2])\n                        return heap[local + 2:local + 2 + qstr_len].decode('utf-8')\n                pool_ptr = prev\n            return 'unknown'\n\n        def format(obj):\n            if obj & 1 != 0:\n                return obj >> 1\n            if is_qstr(obj):\n                return find_qstr(obj)\n            else:\n                return '0x{:08x}'.format(obj)\n        for block in sorted(map_element_blocks):\n            if block == 0:\n                continue\n            try:\n                node = ownership_graph.get_node(block)\n            except KeyError:\n                print('Unable to find memory block for 0x{:08x}. Is there something running?'.format(block))\n                continue\n            if block not in block_data:\n                continue\n            data = block_data[block]\n            cells = []\n            for i in range(len(data) // 8):\n                (key, value) = struct.unpack_from('<II', data, offset=i * 8)\n                if key == MP_OBJ_NULL or key == MP_OBJ_SENTINEL:\n                    cells.append(('', ' '))\n                else:\n                    cells.append((key, format(key)))\n                    if value in block_data:\n                        edge = ownership_graph.get_edge(block, value)\n                        edge.attr['tailport'] = str(key)\n            rows = ''\n            for i in range(len(cells) // 2):\n                rows += '<tr><td port=\"{}\">{}</td><td port=\"{}\">{}</td></tr>'.format(cells[2 * i][0], cells[2 * i][1], cells[2 * i + 1][0], cells[2 * i + 1][1])\n            node.attr['shape'] = 'plaintext'\n            node.attr['style'] = 'invisible'\n            node.attr['label'] = '<<table bgcolor=\"gold\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\"><tr><td colspan=\"2\">0x{:08x}</td></tr>{}</table>>'.format(block, rows)\n        for (node, degree) in ownership_graph.in_degree_iter():\n            print(node, degree)\n            if degree == 0:\n                address_bytes = struct.pack('<I', int(node))\n                location = -1\n                for _ in range(ram.count(address_bytes)):\n                    location = ram.find(address_bytes, location + 1)\n                    pointer_location = ram_start + location\n                    source = '0x{:08x}'.format(pointer_location)\n                    if pointer_location in symbol_lookup:\n                        source = symbol_lookup[pointer_location]\n                    if source in manual_symbol_map:\n                        source = manual_symbol_map[source]\n                    if 'readline_hist' in source:\n                        string_blocks.append(int(node))\n                    if pointer_location > heap_start + heap_size:\n                        source = 'stack ' + source\n                    ownership_graph.add_edge(source, node)\n        for block in string_blocks:\n            if block == 0:\n                continue\n            node = ownership_graph.get_node(block)\n            node.attr['fillcolor'] = 'hotpink'\n            if block in block_data:\n                raw_string = block_data[block]\n            else:\n                print('Unable to find memory block for string at 0x{:08x}.'.format(block))\n                continue\n            try:\n                raw_string = block_data[block].decode('utf-8')\n            except:\n                raw_string = str(block_data[block])\n            wrapped = []\n            for i in range(0, len(raw_string), 16):\n                wrapped.append(raw_string[i:i + 16])\n            node.attr['label'] = '\\n'.join(wrapped)\n            node.attr['style'] = 'filled'\n            node.attr['fontname'] = 'FiraCode-Medium'\n            node.attr['fontpath'] = '/Users/tannewt/Library/Fonts/'\n            node.attr['fontsize'] = 8\n            node.attr['height'] = len(wrapped) * 0.25\n        for block in bytecode_blocks:\n            node = ownership_graph.get_node(block)\n            node.attr['fillcolor'] = 'lightseagreen'\n            if block in block_data:\n                data = block_data[block]\n            else:\n                print('Unable to find memory block for bytecode at 0x{:08x}.'.format(block))\n                continue\n            prelude = Prelude(io.BufferedReader(io.BytesIO(data)))\n            node.attr['shape'] = 'plaintext'\n            node.attr['style'] = 'invisible'\n            code_info_size = prelude.code_info_size\n            rows = ''\n            remaining_bytecode = len(data) - 16\n            while code_info_size >= 16:\n                rows += '<tr><td colspan=\"16\" bgcolor=\"palegreen\" height=\"18\" width=\"80\"></td></tr>'\n                code_info_size -= 16\n                remaining_bytecode -= 16\n            if code_info_size > 0:\n                rows += '<tr><td colspan=\"{}\" bgcolor=\"palegreen\" height=\"18\" width=\"{}\"></td><td colspan=\"{}\" bgcolor=\"seagreen\" height=\"18\" width=\"{}\"></td></tr>'.format(code_info_size, code_info_size * (80 / 16), 16 - code_info_size, 80 / 16 * (16 - code_info_size))\n                remaining_bytecode -= 16\n            for i in range(remaining_bytecode // 16):\n                rows += '<tr><td colspan=\"16\" bgcolor=\"seagreen\" height=\"18\" width=\"80\"></td></tr>'\n            node.attr['label'] = '<<table border=\"1\" cellspacing=\"0\"><tr><td colspan=\"16\" bgcolor=\"lightseagreen\" height=\"18\" width=\"80\">0x{:08x}</td></tr>{}</table>>'.format(block, rows)\n        for block in qstr_chunks:\n            if block not in block_data:\n                ownership_graph.delete_node(block)\n                continue\n            data = block_data[block]\n            qstrs_in_chunk = ''\n            offset = 0\n            while offset < len(data) - 1:\n                (qstr_hash, qstr_len) = struct.unpack_from('<BB', data, offset=offset)\n                if qstr_hash == 0:\n                    qstrs_in_chunk += ' ' * (len(data) - offset)\n                    offset = len(data)\n                    continue\n                offset += 2 + qstr_len + 1\n                try:\n                    qstrs_in_chunk += '  ' + data[offset - qstr_len - 1:offset - 1].decode('utf-8')\n                except UnicodeDecodeError:\n                    qstrs_in_chunk += '  ' + '\u2591' * qstr_len\n            printable_qstrs = ''\n            for i in range(len(qstrs_in_chunk)):\n                c = qstrs_in_chunk[i]\n                if c not in string.printable or c in '\\x0b\\x0c':\n                    printable_qstrs += '\u2591'\n                else:\n                    printable_qstrs += qstrs_in_chunk[i]\n            wrapped = []\n            for i in range(0, len(printable_qstrs), 16):\n                wrapped.append(html.escape(printable_qstrs[i:i + 16]))\n            node = ownership_graph.get_node(block)\n            node.attr['label'] = '<<table border=\"1\" cellspacing=\"0\" bgcolor=\"lightsalmon\" width=\"80\"><tr><td height=\"18\" >0x{:08x}</td></tr><tr><td height=\"{}\" >{}</td></tr></table>>'.format(block, 18 * (len(wrapped) - 1), '<br/>'.join(wrapped))\n            node.attr['fontname'] = 'FiraCode-Bold'\n            node.attr['fontcolor'] = 'black'\n            node.attr['fontpath'] = '/Users/tannewt/Library/Fonts/'\n            node.attr['fontsize'] = 8\n        print('Total free space:', BYTES_PER_BLOCK * total_free)\n        print('Longest free space:', BYTES_PER_BLOCK * longest_free)\n        if draw_heap_ownership:\n            ownership_graph.layout(prog='dot')\n            fn = os.path.join(output_directory, 'heap_ownership{:04d}.svg'.format(snapshot_num))\n            print(fn)\n            ownership_graph.draw(fn)\n        if draw_heap_ownership:\n            for edge in ownership_graph.iteredges():\n                del edge.attr['pos']\n        else:\n            for edge in ownership_graph.edges():\n                ownership_graph.delete_edge(edge)\n        for node in ownership_graph.nodes():\n            try:\n                address = int(node.name)\n            except ValueError:\n                ownership_graph.remove_node(node.name)\n                continue\n            block = (address - pool_start) // 16\n            x = block // 128\n            y = 128 - block % 128\n            try:\n                height = float(node.attr['height'])\n            except:\n                height = 0.25\n            node.attr['pos'] = '{},{}'.format(x * 80, (y - (height - 0.25) * 2) * 18)\n        for block in sorted(map_element_blocks):\n            try:\n                node = ownership_graph.get_node(block)\n            except KeyError:\n                if block != 0:\n                    print('Unable to find memory block for 0x{:08x}. Is there something running?'.format(block))\n                continue\n            if block not in block_data:\n                continue\n            data = block_data[block]\n            cells = []\n            for i in range(len(data) // 8):\n                (key, value) = struct.unpack_from('<II', data, offset=i * 8)\n                if key == MP_OBJ_NULL or key == MP_OBJ_SENTINEL:\n                    cells.append(('', ' '))\n                else:\n                    cells.append((key, ''))\n            rows = ''\n            for i in range(len(cells) // 2):\n                rows += '<tr><td port=\"{}\" height=\"18\" width=\"40\">{}</td><td port=\"{}\" height=\"18\" width=\"40\">{}</td></tr>'.format(cells[2 * i][0], cells[2 * i][1], cells[2 * i + 1][0], cells[2 * i + 1][1])\n            node.attr['label'] = '<<table bgcolor=\"gold\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\">{}</table>>'.format(rows)\n        ownership_graph.add_node('center', pos='{},{}'.format(total_width // 2 - 40, total_height // 2), shape='plaintext', label=' ')\n        ownership_graph.graph_attr['viewport'] = '{},{},1,{}'.format(total_width, total_height, 'center')\n        ownership_graph.has_layout = True\n        if draw_heap_layout:\n            fn = os.path.join(output_directory, 'heap_layout{:04d}.png'.format(snapshot_num))\n            print(fn)\n            ownership_graph.draw(fn)"
        ]
    }
]