[
    {
        "func_name": "multiplex_sparse",
        "original": "@tf.experimental.dispatch_for_api(examples_multiplex_dense)\ndef multiplex_sparse(cond: tf.SparseTensor, a: tf.SparseTensor, b: tf.SparseTensor, name=None):\n    \"\"\"Return elements chosen from `a` or `b` depending on `cond`.\n\n\n  This is similar to `np.where` and `tf.where`, but simplified to only handle\n  the case of rank 1 sparse tensors, no optional parameters, no broadcasting,\n  etc..\n\n  >>> cond = tf.SparseTensor(\n  ...     indices=[[1], [3], [6]], values=[True, False, True], dense_shape=[7])\n  >>> a = tf.sparse.from_dense(['', 'a0', '', 'a1', '', 'a2', ''])\n  >>> b = tf.sparse.from_dense(['b0', '', 'b1', 'b2', '', '', 'b3'])\n  >>> multiplex_3_op.multiplex_sparse(cond, a, b)\n  SparseTensorValue(indices=array([[0],\n    [1],\n    [2],\n    [3]]), values=array([b'b0', b'a0', b'b1', b'b2'], dtype=object),\n    dense_shape=array([7]))\n  Args:\n    cond: tf.SparseTensor of type bool. Where True, yield `a`, otherwise yield\n      `b`.\n    a: tf.SparseTensor with the same type and shape as `b`.\n    b: tf.SparseTensor with the same type and shape as `a`.\n    name: An optional name for the op.\n\n  Returns:\n    A tf.SparseTensor with elements from `a` where `cond` is True, and elements\n    from `b` elsewhere.\n  \"\"\"\n    (indices, values, shape) = examples_multiplex_sparse(cond_indices=cond.indices, cond_values=cond.values, cond_shape=cond.dense_shape, a_indices=a.indices, a_values=a.values, a_shape=a.dense_shape, b_indices=b.indices, b_values=b.values, b_shape=b.dense_shape, name=name)\n    return tf.SparseTensor(indices, values, shape)",
        "mutated": [
            "@tf.experimental.dispatch_for_api(examples_multiplex_dense)\ndef multiplex_sparse(cond: tf.SparseTensor, a: tf.SparseTensor, b: tf.SparseTensor, name=None):\n    if False:\n        i = 10\n    \"Return elements chosen from `a` or `b` depending on `cond`.\\n\\n\\n  This is similar to `np.where` and `tf.where`, but simplified to only handle\\n  the case of rank 1 sparse tensors, no optional parameters, no broadcasting,\\n  etc..\\n\\n  >>> cond = tf.SparseTensor(\\n  ...     indices=[[1], [3], [6]], values=[True, False, True], dense_shape=[7])\\n  >>> a = tf.sparse.from_dense(['', 'a0', '', 'a1', '', 'a2', ''])\\n  >>> b = tf.sparse.from_dense(['b0', '', 'b1', 'b2', '', '', 'b3'])\\n  >>> multiplex_3_op.multiplex_sparse(cond, a, b)\\n  SparseTensorValue(indices=array([[0],\\n    [1],\\n    [2],\\n    [3]]), values=array([b'b0', b'a0', b'b1', b'b2'], dtype=object),\\n    dense_shape=array([7]))\\n  Args:\\n    cond: tf.SparseTensor of type bool. Where True, yield `a`, otherwise yield\\n      `b`.\\n    a: tf.SparseTensor with the same type and shape as `b`.\\n    b: tf.SparseTensor with the same type and shape as `a`.\\n    name: An optional name for the op.\\n\\n  Returns:\\n    A tf.SparseTensor with elements from `a` where `cond` is True, and elements\\n    from `b` elsewhere.\\n  \"\n    (indices, values, shape) = examples_multiplex_sparse(cond_indices=cond.indices, cond_values=cond.values, cond_shape=cond.dense_shape, a_indices=a.indices, a_values=a.values, a_shape=a.dense_shape, b_indices=b.indices, b_values=b.values, b_shape=b.dense_shape, name=name)\n    return tf.SparseTensor(indices, values, shape)",
            "@tf.experimental.dispatch_for_api(examples_multiplex_dense)\ndef multiplex_sparse(cond: tf.SparseTensor, a: tf.SparseTensor, b: tf.SparseTensor, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Return elements chosen from `a` or `b` depending on `cond`.\\n\\n\\n  This is similar to `np.where` and `tf.where`, but simplified to only handle\\n  the case of rank 1 sparse tensors, no optional parameters, no broadcasting,\\n  etc..\\n\\n  >>> cond = tf.SparseTensor(\\n  ...     indices=[[1], [3], [6]], values=[True, False, True], dense_shape=[7])\\n  >>> a = tf.sparse.from_dense(['', 'a0', '', 'a1', '', 'a2', ''])\\n  >>> b = tf.sparse.from_dense(['b0', '', 'b1', 'b2', '', '', 'b3'])\\n  >>> multiplex_3_op.multiplex_sparse(cond, a, b)\\n  SparseTensorValue(indices=array([[0],\\n    [1],\\n    [2],\\n    [3]]), values=array([b'b0', b'a0', b'b1', b'b2'], dtype=object),\\n    dense_shape=array([7]))\\n  Args:\\n    cond: tf.SparseTensor of type bool. Where True, yield `a`, otherwise yield\\n      `b`.\\n    a: tf.SparseTensor with the same type and shape as `b`.\\n    b: tf.SparseTensor with the same type and shape as `a`.\\n    name: An optional name for the op.\\n\\n  Returns:\\n    A tf.SparseTensor with elements from `a` where `cond` is True, and elements\\n    from `b` elsewhere.\\n  \"\n    (indices, values, shape) = examples_multiplex_sparse(cond_indices=cond.indices, cond_values=cond.values, cond_shape=cond.dense_shape, a_indices=a.indices, a_values=a.values, a_shape=a.dense_shape, b_indices=b.indices, b_values=b.values, b_shape=b.dense_shape, name=name)\n    return tf.SparseTensor(indices, values, shape)",
            "@tf.experimental.dispatch_for_api(examples_multiplex_dense)\ndef multiplex_sparse(cond: tf.SparseTensor, a: tf.SparseTensor, b: tf.SparseTensor, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Return elements chosen from `a` or `b` depending on `cond`.\\n\\n\\n  This is similar to `np.where` and `tf.where`, but simplified to only handle\\n  the case of rank 1 sparse tensors, no optional parameters, no broadcasting,\\n  etc..\\n\\n  >>> cond = tf.SparseTensor(\\n  ...     indices=[[1], [3], [6]], values=[True, False, True], dense_shape=[7])\\n  >>> a = tf.sparse.from_dense(['', 'a0', '', 'a1', '', 'a2', ''])\\n  >>> b = tf.sparse.from_dense(['b0', '', 'b1', 'b2', '', '', 'b3'])\\n  >>> multiplex_3_op.multiplex_sparse(cond, a, b)\\n  SparseTensorValue(indices=array([[0],\\n    [1],\\n    [2],\\n    [3]]), values=array([b'b0', b'a0', b'b1', b'b2'], dtype=object),\\n    dense_shape=array([7]))\\n  Args:\\n    cond: tf.SparseTensor of type bool. Where True, yield `a`, otherwise yield\\n      `b`.\\n    a: tf.SparseTensor with the same type and shape as `b`.\\n    b: tf.SparseTensor with the same type and shape as `a`.\\n    name: An optional name for the op.\\n\\n  Returns:\\n    A tf.SparseTensor with elements from `a` where `cond` is True, and elements\\n    from `b` elsewhere.\\n  \"\n    (indices, values, shape) = examples_multiplex_sparse(cond_indices=cond.indices, cond_values=cond.values, cond_shape=cond.dense_shape, a_indices=a.indices, a_values=a.values, a_shape=a.dense_shape, b_indices=b.indices, b_values=b.values, b_shape=b.dense_shape, name=name)\n    return tf.SparseTensor(indices, values, shape)",
            "@tf.experimental.dispatch_for_api(examples_multiplex_dense)\ndef multiplex_sparse(cond: tf.SparseTensor, a: tf.SparseTensor, b: tf.SparseTensor, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Return elements chosen from `a` or `b` depending on `cond`.\\n\\n\\n  This is similar to `np.where` and `tf.where`, but simplified to only handle\\n  the case of rank 1 sparse tensors, no optional parameters, no broadcasting,\\n  etc..\\n\\n  >>> cond = tf.SparseTensor(\\n  ...     indices=[[1], [3], [6]], values=[True, False, True], dense_shape=[7])\\n  >>> a = tf.sparse.from_dense(['', 'a0', '', 'a1', '', 'a2', ''])\\n  >>> b = tf.sparse.from_dense(['b0', '', 'b1', 'b2', '', '', 'b3'])\\n  >>> multiplex_3_op.multiplex_sparse(cond, a, b)\\n  SparseTensorValue(indices=array([[0],\\n    [1],\\n    [2],\\n    [3]]), values=array([b'b0', b'a0', b'b1', b'b2'], dtype=object),\\n    dense_shape=array([7]))\\n  Args:\\n    cond: tf.SparseTensor of type bool. Where True, yield `a`, otherwise yield\\n      `b`.\\n    a: tf.SparseTensor with the same type and shape as `b`.\\n    b: tf.SparseTensor with the same type and shape as `a`.\\n    name: An optional name for the op.\\n\\n  Returns:\\n    A tf.SparseTensor with elements from `a` where `cond` is True, and elements\\n    from `b` elsewhere.\\n  \"\n    (indices, values, shape) = examples_multiplex_sparse(cond_indices=cond.indices, cond_values=cond.values, cond_shape=cond.dense_shape, a_indices=a.indices, a_values=a.values, a_shape=a.dense_shape, b_indices=b.indices, b_values=b.values, b_shape=b.dense_shape, name=name)\n    return tf.SparseTensor(indices, values, shape)",
            "@tf.experimental.dispatch_for_api(examples_multiplex_dense)\ndef multiplex_sparse(cond: tf.SparseTensor, a: tf.SparseTensor, b: tf.SparseTensor, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Return elements chosen from `a` or `b` depending on `cond`.\\n\\n\\n  This is similar to `np.where` and `tf.where`, but simplified to only handle\\n  the case of rank 1 sparse tensors, no optional parameters, no broadcasting,\\n  etc..\\n\\n  >>> cond = tf.SparseTensor(\\n  ...     indices=[[1], [3], [6]], values=[True, False, True], dense_shape=[7])\\n  >>> a = tf.sparse.from_dense(['', 'a0', '', 'a1', '', 'a2', ''])\\n  >>> b = tf.sparse.from_dense(['b0', '', 'b1', 'b2', '', '', 'b3'])\\n  >>> multiplex_3_op.multiplex_sparse(cond, a, b)\\n  SparseTensorValue(indices=array([[0],\\n    [1],\\n    [2],\\n    [3]]), values=array([b'b0', b'a0', b'b1', b'b2'], dtype=object),\\n    dense_shape=array([7]))\\n  Args:\\n    cond: tf.SparseTensor of type bool. Where True, yield `a`, otherwise yield\\n      `b`.\\n    a: tf.SparseTensor with the same type and shape as `b`.\\n    b: tf.SparseTensor with the same type and shape as `a`.\\n    name: An optional name for the op.\\n\\n  Returns:\\n    A tf.SparseTensor with elements from `a` where `cond` is True, and elements\\n    from `b` elsewhere.\\n  \"\n    (indices, values, shape) = examples_multiplex_sparse(cond_indices=cond.indices, cond_values=cond.values, cond_shape=cond.dense_shape, a_indices=a.indices, a_values=a.values, a_shape=a.dense_shape, b_indices=b.indices, b_values=b.values, b_shape=b.dense_shape, name=name)\n    return tf.SparseTensor(indices, values, shape)"
        ]
    }
]