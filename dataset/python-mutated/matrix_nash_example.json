[
    {
        "func_name": "gen",
        "original": "def gen():\n    (p0_sol, p1_sol, _, _) = lp_solver.solve_zero_sum_matrix_game(pyspiel.create_matrix_game(row_payoffs - col_payoffs, col_payoffs - row_payoffs))\n    yield (np.squeeze(p0_sol, 1), np.squeeze(p1_sol, 1))",
        "mutated": [
            "def gen():\n    if False:\n        i = 10\n    (p0_sol, p1_sol, _, _) = lp_solver.solve_zero_sum_matrix_game(pyspiel.create_matrix_game(row_payoffs - col_payoffs, col_payoffs - row_payoffs))\n    yield (np.squeeze(p0_sol, 1), np.squeeze(p1_sol, 1))",
            "def gen():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (p0_sol, p1_sol, _, _) = lp_solver.solve_zero_sum_matrix_game(pyspiel.create_matrix_game(row_payoffs - col_payoffs, col_payoffs - row_payoffs))\n    yield (np.squeeze(p0_sol, 1), np.squeeze(p1_sol, 1))",
            "def gen():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (p0_sol, p1_sol, _, _) = lp_solver.solve_zero_sum_matrix_game(pyspiel.create_matrix_game(row_payoffs - col_payoffs, col_payoffs - row_payoffs))\n    yield (np.squeeze(p0_sol, 1), np.squeeze(p1_sol, 1))",
            "def gen():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (p0_sol, p1_sol, _, _) = lp_solver.solve_zero_sum_matrix_game(pyspiel.create_matrix_game(row_payoffs - col_payoffs, col_payoffs - row_payoffs))\n    yield (np.squeeze(p0_sol, 1), np.squeeze(p1_sol, 1))",
            "def gen():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (p0_sol, p1_sol, _, _) = lp_solver.solve_zero_sum_matrix_game(pyspiel.create_matrix_game(row_payoffs - col_payoffs, col_payoffs - row_payoffs))\n    yield (np.squeeze(p0_sol, 1), np.squeeze(p1_sol, 1))"
        ]
    },
    {
        "func_name": "main",
        "original": "def main(_):\n    game = pyspiel.load_game(FLAGS.game)\n    print('loaded game')\n    if not isinstance(game, pyspiel.MatrixGame):\n        game = pyspiel.extensive_to_matrix_game(game)\n        (num_rows, num_cols) = (game.num_rows(), game.num_cols())\n        print('converted to matrix form with shape (%d, %d)' % (num_rows, num_cols))\n    if FLAGS.solver != 'linear':\n        if FLAGS.mode == 'all':\n            (game, _) = lp_solver.iterated_dominance(game, tol=FLAGS.tol, mode=lp_solver.DOMINANCE_STRICT)\n            (num_rows, num_cols) = (game.num_rows(), game.num_cols())\n            print('discarded strictly dominated actions yielding shape (%d, %d)' % (num_rows, num_cols))\n        if FLAGS.mode == 'one':\n            (game, _) = lp_solver.iterated_dominance(game, tol=FLAGS.tol, mode=lp_solver.DOMINANCE_VERY_WEAK)\n            (num_rows, num_cols) = (game.num_rows(), game.num_cols())\n            print('discarded very weakly dominated actions yielding shape (%d, %d)' % (num_rows, num_cols))\n    (num_rows, num_cols) = (game.num_rows(), game.num_cols())\n    row_actions = [game.row_action_name(row) for row in range(num_rows)]\n    col_actions = [game.col_action_name(col) for col in range(num_cols)]\n    (row_payoffs, col_payoffs) = utils.game_payoffs_array(game)\n    pure_nash = list(zip(*((row_payoffs >= row_payoffs.max(0, keepdims=True) - FLAGS.tol) & (col_payoffs >= col_payoffs.max(1, keepdims=True) - FLAGS.tol)).nonzero()))\n    if pure_nash:\n        print('found %d pure equilibria' % len(pure_nash))\n    if FLAGS.mode == 'pure':\n        if not pure_nash:\n            print('found no pure equilibria')\n            return\n        print('pure equilibria:')\n        for (row, col) in pure_nash:\n            print('payoffs %f, %f:' % (row_payoffs[row, col], col_payoffs[row, col]))\n            print('row action:')\n            print(row_actions[row])\n            print('col action:')\n            print(col_actions[col])\n            print('')\n        return\n    if FLAGS.mode == 'one' and pure_nash:\n        print('pure equilibrium:')\n        (row, col) = pure_nash[0]\n        print('payoffs %f, %f:' % (row_payoffs[row, col], col_payoffs[row, col]))\n        print('row action:')\n        print(row_actions[row])\n        print('col action:')\n        print(col_actions[col])\n        print('')\n        return\n    for (row, action) in enumerate(row_actions):\n        print('row action %s:' % row)\n        print(action)\n    print('--')\n    for (col, action) in enumerate(col_actions):\n        print('col action %s:' % col)\n        print(action)\n    print('--')\n    if num_rows == 1 or num_cols == 1:\n        equilibria = itertools.product(np.eye(num_rows), np.eye(num_cols))\n    elif FLAGS.solver == 'linear':\n        if FLAGS.mode != 'one' or (row_payoffs + col_payoffs).max() > (row_payoffs + col_payoffs).min() + FLAGS.tol:\n            raise ValueError(\"can't use linear solver for non-constant-sum game or for finding all optima!\")\n        print('using linear solver')\n\n        def gen():\n            (p0_sol, p1_sol, _, _) = lp_solver.solve_zero_sum_matrix_game(pyspiel.create_matrix_game(row_payoffs - col_payoffs, col_payoffs - row_payoffs))\n            yield (np.squeeze(p0_sol, 1), np.squeeze(p1_sol, 1))\n        equilibria = gen()\n    elif FLAGS.solver == 'lrsnash':\n        print('using lrsnash solver')\n        equilibria = matrix_nash.lrs_solve(row_payoffs, col_payoffs, FLAGS.lrsnash_max_denom, FLAGS.lrsnash_path)\n    elif FLAGS.solver == 'nashpy':\n        if FLAGS.mode == 'all':\n            print('using nashpy vertex enumeration')\n            equilibria = nashpy.Game(row_payoffs, col_payoffs).vertex_enumeration()\n        else:\n            print('using nashpy Lemke-Howson solver')\n            equilibria = matrix_nash.lemke_howson_solve(row_payoffs, col_payoffs)\n    print('equilibria:' if FLAGS.mode == 'all' else 'an equilibrium:')\n    equilibria = iter(equilibria)\n    try:\n        equilibria = itertools.chain([next(equilibria)], equilibria)\n    except StopIteration:\n        print('not found!')\n    for (row_mixture, col_mixture) in equilibria:\n        print('payoffs %f, %f for %s, %s' % (row_mixture.dot(row_payoffs.dot(col_mixture)), row_mixture.dot(col_payoffs.dot(col_mixture)), row_mixture, col_mixture))\n        if FLAGS.mode == 'one':\n            return",
        "mutated": [
            "def main(_):\n    if False:\n        i = 10\n    game = pyspiel.load_game(FLAGS.game)\n    print('loaded game')\n    if not isinstance(game, pyspiel.MatrixGame):\n        game = pyspiel.extensive_to_matrix_game(game)\n        (num_rows, num_cols) = (game.num_rows(), game.num_cols())\n        print('converted to matrix form with shape (%d, %d)' % (num_rows, num_cols))\n    if FLAGS.solver != 'linear':\n        if FLAGS.mode == 'all':\n            (game, _) = lp_solver.iterated_dominance(game, tol=FLAGS.tol, mode=lp_solver.DOMINANCE_STRICT)\n            (num_rows, num_cols) = (game.num_rows(), game.num_cols())\n            print('discarded strictly dominated actions yielding shape (%d, %d)' % (num_rows, num_cols))\n        if FLAGS.mode == 'one':\n            (game, _) = lp_solver.iterated_dominance(game, tol=FLAGS.tol, mode=lp_solver.DOMINANCE_VERY_WEAK)\n            (num_rows, num_cols) = (game.num_rows(), game.num_cols())\n            print('discarded very weakly dominated actions yielding shape (%d, %d)' % (num_rows, num_cols))\n    (num_rows, num_cols) = (game.num_rows(), game.num_cols())\n    row_actions = [game.row_action_name(row) for row in range(num_rows)]\n    col_actions = [game.col_action_name(col) for col in range(num_cols)]\n    (row_payoffs, col_payoffs) = utils.game_payoffs_array(game)\n    pure_nash = list(zip(*((row_payoffs >= row_payoffs.max(0, keepdims=True) - FLAGS.tol) & (col_payoffs >= col_payoffs.max(1, keepdims=True) - FLAGS.tol)).nonzero()))\n    if pure_nash:\n        print('found %d pure equilibria' % len(pure_nash))\n    if FLAGS.mode == 'pure':\n        if not pure_nash:\n            print('found no pure equilibria')\n            return\n        print('pure equilibria:')\n        for (row, col) in pure_nash:\n            print('payoffs %f, %f:' % (row_payoffs[row, col], col_payoffs[row, col]))\n            print('row action:')\n            print(row_actions[row])\n            print('col action:')\n            print(col_actions[col])\n            print('')\n        return\n    if FLAGS.mode == 'one' and pure_nash:\n        print('pure equilibrium:')\n        (row, col) = pure_nash[0]\n        print('payoffs %f, %f:' % (row_payoffs[row, col], col_payoffs[row, col]))\n        print('row action:')\n        print(row_actions[row])\n        print('col action:')\n        print(col_actions[col])\n        print('')\n        return\n    for (row, action) in enumerate(row_actions):\n        print('row action %s:' % row)\n        print(action)\n    print('--')\n    for (col, action) in enumerate(col_actions):\n        print('col action %s:' % col)\n        print(action)\n    print('--')\n    if num_rows == 1 or num_cols == 1:\n        equilibria = itertools.product(np.eye(num_rows), np.eye(num_cols))\n    elif FLAGS.solver == 'linear':\n        if FLAGS.mode != 'one' or (row_payoffs + col_payoffs).max() > (row_payoffs + col_payoffs).min() + FLAGS.tol:\n            raise ValueError(\"can't use linear solver for non-constant-sum game or for finding all optima!\")\n        print('using linear solver')\n\n        def gen():\n            (p0_sol, p1_sol, _, _) = lp_solver.solve_zero_sum_matrix_game(pyspiel.create_matrix_game(row_payoffs - col_payoffs, col_payoffs - row_payoffs))\n            yield (np.squeeze(p0_sol, 1), np.squeeze(p1_sol, 1))\n        equilibria = gen()\n    elif FLAGS.solver == 'lrsnash':\n        print('using lrsnash solver')\n        equilibria = matrix_nash.lrs_solve(row_payoffs, col_payoffs, FLAGS.lrsnash_max_denom, FLAGS.lrsnash_path)\n    elif FLAGS.solver == 'nashpy':\n        if FLAGS.mode == 'all':\n            print('using nashpy vertex enumeration')\n            equilibria = nashpy.Game(row_payoffs, col_payoffs).vertex_enumeration()\n        else:\n            print('using nashpy Lemke-Howson solver')\n            equilibria = matrix_nash.lemke_howson_solve(row_payoffs, col_payoffs)\n    print('equilibria:' if FLAGS.mode == 'all' else 'an equilibrium:')\n    equilibria = iter(equilibria)\n    try:\n        equilibria = itertools.chain([next(equilibria)], equilibria)\n    except StopIteration:\n        print('not found!')\n    for (row_mixture, col_mixture) in equilibria:\n        print('payoffs %f, %f for %s, %s' % (row_mixture.dot(row_payoffs.dot(col_mixture)), row_mixture.dot(col_payoffs.dot(col_mixture)), row_mixture, col_mixture))\n        if FLAGS.mode == 'one':\n            return",
            "def main(_):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    game = pyspiel.load_game(FLAGS.game)\n    print('loaded game')\n    if not isinstance(game, pyspiel.MatrixGame):\n        game = pyspiel.extensive_to_matrix_game(game)\n        (num_rows, num_cols) = (game.num_rows(), game.num_cols())\n        print('converted to matrix form with shape (%d, %d)' % (num_rows, num_cols))\n    if FLAGS.solver != 'linear':\n        if FLAGS.mode == 'all':\n            (game, _) = lp_solver.iterated_dominance(game, tol=FLAGS.tol, mode=lp_solver.DOMINANCE_STRICT)\n            (num_rows, num_cols) = (game.num_rows(), game.num_cols())\n            print('discarded strictly dominated actions yielding shape (%d, %d)' % (num_rows, num_cols))\n        if FLAGS.mode == 'one':\n            (game, _) = lp_solver.iterated_dominance(game, tol=FLAGS.tol, mode=lp_solver.DOMINANCE_VERY_WEAK)\n            (num_rows, num_cols) = (game.num_rows(), game.num_cols())\n            print('discarded very weakly dominated actions yielding shape (%d, %d)' % (num_rows, num_cols))\n    (num_rows, num_cols) = (game.num_rows(), game.num_cols())\n    row_actions = [game.row_action_name(row) for row in range(num_rows)]\n    col_actions = [game.col_action_name(col) for col in range(num_cols)]\n    (row_payoffs, col_payoffs) = utils.game_payoffs_array(game)\n    pure_nash = list(zip(*((row_payoffs >= row_payoffs.max(0, keepdims=True) - FLAGS.tol) & (col_payoffs >= col_payoffs.max(1, keepdims=True) - FLAGS.tol)).nonzero()))\n    if pure_nash:\n        print('found %d pure equilibria' % len(pure_nash))\n    if FLAGS.mode == 'pure':\n        if not pure_nash:\n            print('found no pure equilibria')\n            return\n        print('pure equilibria:')\n        for (row, col) in pure_nash:\n            print('payoffs %f, %f:' % (row_payoffs[row, col], col_payoffs[row, col]))\n            print('row action:')\n            print(row_actions[row])\n            print('col action:')\n            print(col_actions[col])\n            print('')\n        return\n    if FLAGS.mode == 'one' and pure_nash:\n        print('pure equilibrium:')\n        (row, col) = pure_nash[0]\n        print('payoffs %f, %f:' % (row_payoffs[row, col], col_payoffs[row, col]))\n        print('row action:')\n        print(row_actions[row])\n        print('col action:')\n        print(col_actions[col])\n        print('')\n        return\n    for (row, action) in enumerate(row_actions):\n        print('row action %s:' % row)\n        print(action)\n    print('--')\n    for (col, action) in enumerate(col_actions):\n        print('col action %s:' % col)\n        print(action)\n    print('--')\n    if num_rows == 1 or num_cols == 1:\n        equilibria = itertools.product(np.eye(num_rows), np.eye(num_cols))\n    elif FLAGS.solver == 'linear':\n        if FLAGS.mode != 'one' or (row_payoffs + col_payoffs).max() > (row_payoffs + col_payoffs).min() + FLAGS.tol:\n            raise ValueError(\"can't use linear solver for non-constant-sum game or for finding all optima!\")\n        print('using linear solver')\n\n        def gen():\n            (p0_sol, p1_sol, _, _) = lp_solver.solve_zero_sum_matrix_game(pyspiel.create_matrix_game(row_payoffs - col_payoffs, col_payoffs - row_payoffs))\n            yield (np.squeeze(p0_sol, 1), np.squeeze(p1_sol, 1))\n        equilibria = gen()\n    elif FLAGS.solver == 'lrsnash':\n        print('using lrsnash solver')\n        equilibria = matrix_nash.lrs_solve(row_payoffs, col_payoffs, FLAGS.lrsnash_max_denom, FLAGS.lrsnash_path)\n    elif FLAGS.solver == 'nashpy':\n        if FLAGS.mode == 'all':\n            print('using nashpy vertex enumeration')\n            equilibria = nashpy.Game(row_payoffs, col_payoffs).vertex_enumeration()\n        else:\n            print('using nashpy Lemke-Howson solver')\n            equilibria = matrix_nash.lemke_howson_solve(row_payoffs, col_payoffs)\n    print('equilibria:' if FLAGS.mode == 'all' else 'an equilibrium:')\n    equilibria = iter(equilibria)\n    try:\n        equilibria = itertools.chain([next(equilibria)], equilibria)\n    except StopIteration:\n        print('not found!')\n    for (row_mixture, col_mixture) in equilibria:\n        print('payoffs %f, %f for %s, %s' % (row_mixture.dot(row_payoffs.dot(col_mixture)), row_mixture.dot(col_payoffs.dot(col_mixture)), row_mixture, col_mixture))\n        if FLAGS.mode == 'one':\n            return",
            "def main(_):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    game = pyspiel.load_game(FLAGS.game)\n    print('loaded game')\n    if not isinstance(game, pyspiel.MatrixGame):\n        game = pyspiel.extensive_to_matrix_game(game)\n        (num_rows, num_cols) = (game.num_rows(), game.num_cols())\n        print('converted to matrix form with shape (%d, %d)' % (num_rows, num_cols))\n    if FLAGS.solver != 'linear':\n        if FLAGS.mode == 'all':\n            (game, _) = lp_solver.iterated_dominance(game, tol=FLAGS.tol, mode=lp_solver.DOMINANCE_STRICT)\n            (num_rows, num_cols) = (game.num_rows(), game.num_cols())\n            print('discarded strictly dominated actions yielding shape (%d, %d)' % (num_rows, num_cols))\n        if FLAGS.mode == 'one':\n            (game, _) = lp_solver.iterated_dominance(game, tol=FLAGS.tol, mode=lp_solver.DOMINANCE_VERY_WEAK)\n            (num_rows, num_cols) = (game.num_rows(), game.num_cols())\n            print('discarded very weakly dominated actions yielding shape (%d, %d)' % (num_rows, num_cols))\n    (num_rows, num_cols) = (game.num_rows(), game.num_cols())\n    row_actions = [game.row_action_name(row) for row in range(num_rows)]\n    col_actions = [game.col_action_name(col) for col in range(num_cols)]\n    (row_payoffs, col_payoffs) = utils.game_payoffs_array(game)\n    pure_nash = list(zip(*((row_payoffs >= row_payoffs.max(0, keepdims=True) - FLAGS.tol) & (col_payoffs >= col_payoffs.max(1, keepdims=True) - FLAGS.tol)).nonzero()))\n    if pure_nash:\n        print('found %d pure equilibria' % len(pure_nash))\n    if FLAGS.mode == 'pure':\n        if not pure_nash:\n            print('found no pure equilibria')\n            return\n        print('pure equilibria:')\n        for (row, col) in pure_nash:\n            print('payoffs %f, %f:' % (row_payoffs[row, col], col_payoffs[row, col]))\n            print('row action:')\n            print(row_actions[row])\n            print('col action:')\n            print(col_actions[col])\n            print('')\n        return\n    if FLAGS.mode == 'one' and pure_nash:\n        print('pure equilibrium:')\n        (row, col) = pure_nash[0]\n        print('payoffs %f, %f:' % (row_payoffs[row, col], col_payoffs[row, col]))\n        print('row action:')\n        print(row_actions[row])\n        print('col action:')\n        print(col_actions[col])\n        print('')\n        return\n    for (row, action) in enumerate(row_actions):\n        print('row action %s:' % row)\n        print(action)\n    print('--')\n    for (col, action) in enumerate(col_actions):\n        print('col action %s:' % col)\n        print(action)\n    print('--')\n    if num_rows == 1 or num_cols == 1:\n        equilibria = itertools.product(np.eye(num_rows), np.eye(num_cols))\n    elif FLAGS.solver == 'linear':\n        if FLAGS.mode != 'one' or (row_payoffs + col_payoffs).max() > (row_payoffs + col_payoffs).min() + FLAGS.tol:\n            raise ValueError(\"can't use linear solver for non-constant-sum game or for finding all optima!\")\n        print('using linear solver')\n\n        def gen():\n            (p0_sol, p1_sol, _, _) = lp_solver.solve_zero_sum_matrix_game(pyspiel.create_matrix_game(row_payoffs - col_payoffs, col_payoffs - row_payoffs))\n            yield (np.squeeze(p0_sol, 1), np.squeeze(p1_sol, 1))\n        equilibria = gen()\n    elif FLAGS.solver == 'lrsnash':\n        print('using lrsnash solver')\n        equilibria = matrix_nash.lrs_solve(row_payoffs, col_payoffs, FLAGS.lrsnash_max_denom, FLAGS.lrsnash_path)\n    elif FLAGS.solver == 'nashpy':\n        if FLAGS.mode == 'all':\n            print('using nashpy vertex enumeration')\n            equilibria = nashpy.Game(row_payoffs, col_payoffs).vertex_enumeration()\n        else:\n            print('using nashpy Lemke-Howson solver')\n            equilibria = matrix_nash.lemke_howson_solve(row_payoffs, col_payoffs)\n    print('equilibria:' if FLAGS.mode == 'all' else 'an equilibrium:')\n    equilibria = iter(equilibria)\n    try:\n        equilibria = itertools.chain([next(equilibria)], equilibria)\n    except StopIteration:\n        print('not found!')\n    for (row_mixture, col_mixture) in equilibria:\n        print('payoffs %f, %f for %s, %s' % (row_mixture.dot(row_payoffs.dot(col_mixture)), row_mixture.dot(col_payoffs.dot(col_mixture)), row_mixture, col_mixture))\n        if FLAGS.mode == 'one':\n            return",
            "def main(_):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    game = pyspiel.load_game(FLAGS.game)\n    print('loaded game')\n    if not isinstance(game, pyspiel.MatrixGame):\n        game = pyspiel.extensive_to_matrix_game(game)\n        (num_rows, num_cols) = (game.num_rows(), game.num_cols())\n        print('converted to matrix form with shape (%d, %d)' % (num_rows, num_cols))\n    if FLAGS.solver != 'linear':\n        if FLAGS.mode == 'all':\n            (game, _) = lp_solver.iterated_dominance(game, tol=FLAGS.tol, mode=lp_solver.DOMINANCE_STRICT)\n            (num_rows, num_cols) = (game.num_rows(), game.num_cols())\n            print('discarded strictly dominated actions yielding shape (%d, %d)' % (num_rows, num_cols))\n        if FLAGS.mode == 'one':\n            (game, _) = lp_solver.iterated_dominance(game, tol=FLAGS.tol, mode=lp_solver.DOMINANCE_VERY_WEAK)\n            (num_rows, num_cols) = (game.num_rows(), game.num_cols())\n            print('discarded very weakly dominated actions yielding shape (%d, %d)' % (num_rows, num_cols))\n    (num_rows, num_cols) = (game.num_rows(), game.num_cols())\n    row_actions = [game.row_action_name(row) for row in range(num_rows)]\n    col_actions = [game.col_action_name(col) for col in range(num_cols)]\n    (row_payoffs, col_payoffs) = utils.game_payoffs_array(game)\n    pure_nash = list(zip(*((row_payoffs >= row_payoffs.max(0, keepdims=True) - FLAGS.tol) & (col_payoffs >= col_payoffs.max(1, keepdims=True) - FLAGS.tol)).nonzero()))\n    if pure_nash:\n        print('found %d pure equilibria' % len(pure_nash))\n    if FLAGS.mode == 'pure':\n        if not pure_nash:\n            print('found no pure equilibria')\n            return\n        print('pure equilibria:')\n        for (row, col) in pure_nash:\n            print('payoffs %f, %f:' % (row_payoffs[row, col], col_payoffs[row, col]))\n            print('row action:')\n            print(row_actions[row])\n            print('col action:')\n            print(col_actions[col])\n            print('')\n        return\n    if FLAGS.mode == 'one' and pure_nash:\n        print('pure equilibrium:')\n        (row, col) = pure_nash[0]\n        print('payoffs %f, %f:' % (row_payoffs[row, col], col_payoffs[row, col]))\n        print('row action:')\n        print(row_actions[row])\n        print('col action:')\n        print(col_actions[col])\n        print('')\n        return\n    for (row, action) in enumerate(row_actions):\n        print('row action %s:' % row)\n        print(action)\n    print('--')\n    for (col, action) in enumerate(col_actions):\n        print('col action %s:' % col)\n        print(action)\n    print('--')\n    if num_rows == 1 or num_cols == 1:\n        equilibria = itertools.product(np.eye(num_rows), np.eye(num_cols))\n    elif FLAGS.solver == 'linear':\n        if FLAGS.mode != 'one' or (row_payoffs + col_payoffs).max() > (row_payoffs + col_payoffs).min() + FLAGS.tol:\n            raise ValueError(\"can't use linear solver for non-constant-sum game or for finding all optima!\")\n        print('using linear solver')\n\n        def gen():\n            (p0_sol, p1_sol, _, _) = lp_solver.solve_zero_sum_matrix_game(pyspiel.create_matrix_game(row_payoffs - col_payoffs, col_payoffs - row_payoffs))\n            yield (np.squeeze(p0_sol, 1), np.squeeze(p1_sol, 1))\n        equilibria = gen()\n    elif FLAGS.solver == 'lrsnash':\n        print('using lrsnash solver')\n        equilibria = matrix_nash.lrs_solve(row_payoffs, col_payoffs, FLAGS.lrsnash_max_denom, FLAGS.lrsnash_path)\n    elif FLAGS.solver == 'nashpy':\n        if FLAGS.mode == 'all':\n            print('using nashpy vertex enumeration')\n            equilibria = nashpy.Game(row_payoffs, col_payoffs).vertex_enumeration()\n        else:\n            print('using nashpy Lemke-Howson solver')\n            equilibria = matrix_nash.lemke_howson_solve(row_payoffs, col_payoffs)\n    print('equilibria:' if FLAGS.mode == 'all' else 'an equilibrium:')\n    equilibria = iter(equilibria)\n    try:\n        equilibria = itertools.chain([next(equilibria)], equilibria)\n    except StopIteration:\n        print('not found!')\n    for (row_mixture, col_mixture) in equilibria:\n        print('payoffs %f, %f for %s, %s' % (row_mixture.dot(row_payoffs.dot(col_mixture)), row_mixture.dot(col_payoffs.dot(col_mixture)), row_mixture, col_mixture))\n        if FLAGS.mode == 'one':\n            return",
            "def main(_):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    game = pyspiel.load_game(FLAGS.game)\n    print('loaded game')\n    if not isinstance(game, pyspiel.MatrixGame):\n        game = pyspiel.extensive_to_matrix_game(game)\n        (num_rows, num_cols) = (game.num_rows(), game.num_cols())\n        print('converted to matrix form with shape (%d, %d)' % (num_rows, num_cols))\n    if FLAGS.solver != 'linear':\n        if FLAGS.mode == 'all':\n            (game, _) = lp_solver.iterated_dominance(game, tol=FLAGS.tol, mode=lp_solver.DOMINANCE_STRICT)\n            (num_rows, num_cols) = (game.num_rows(), game.num_cols())\n            print('discarded strictly dominated actions yielding shape (%d, %d)' % (num_rows, num_cols))\n        if FLAGS.mode == 'one':\n            (game, _) = lp_solver.iterated_dominance(game, tol=FLAGS.tol, mode=lp_solver.DOMINANCE_VERY_WEAK)\n            (num_rows, num_cols) = (game.num_rows(), game.num_cols())\n            print('discarded very weakly dominated actions yielding shape (%d, %d)' % (num_rows, num_cols))\n    (num_rows, num_cols) = (game.num_rows(), game.num_cols())\n    row_actions = [game.row_action_name(row) for row in range(num_rows)]\n    col_actions = [game.col_action_name(col) for col in range(num_cols)]\n    (row_payoffs, col_payoffs) = utils.game_payoffs_array(game)\n    pure_nash = list(zip(*((row_payoffs >= row_payoffs.max(0, keepdims=True) - FLAGS.tol) & (col_payoffs >= col_payoffs.max(1, keepdims=True) - FLAGS.tol)).nonzero()))\n    if pure_nash:\n        print('found %d pure equilibria' % len(pure_nash))\n    if FLAGS.mode == 'pure':\n        if not pure_nash:\n            print('found no pure equilibria')\n            return\n        print('pure equilibria:')\n        for (row, col) in pure_nash:\n            print('payoffs %f, %f:' % (row_payoffs[row, col], col_payoffs[row, col]))\n            print('row action:')\n            print(row_actions[row])\n            print('col action:')\n            print(col_actions[col])\n            print('')\n        return\n    if FLAGS.mode == 'one' and pure_nash:\n        print('pure equilibrium:')\n        (row, col) = pure_nash[0]\n        print('payoffs %f, %f:' % (row_payoffs[row, col], col_payoffs[row, col]))\n        print('row action:')\n        print(row_actions[row])\n        print('col action:')\n        print(col_actions[col])\n        print('')\n        return\n    for (row, action) in enumerate(row_actions):\n        print('row action %s:' % row)\n        print(action)\n    print('--')\n    for (col, action) in enumerate(col_actions):\n        print('col action %s:' % col)\n        print(action)\n    print('--')\n    if num_rows == 1 or num_cols == 1:\n        equilibria = itertools.product(np.eye(num_rows), np.eye(num_cols))\n    elif FLAGS.solver == 'linear':\n        if FLAGS.mode != 'one' or (row_payoffs + col_payoffs).max() > (row_payoffs + col_payoffs).min() + FLAGS.tol:\n            raise ValueError(\"can't use linear solver for non-constant-sum game or for finding all optima!\")\n        print('using linear solver')\n\n        def gen():\n            (p0_sol, p1_sol, _, _) = lp_solver.solve_zero_sum_matrix_game(pyspiel.create_matrix_game(row_payoffs - col_payoffs, col_payoffs - row_payoffs))\n            yield (np.squeeze(p0_sol, 1), np.squeeze(p1_sol, 1))\n        equilibria = gen()\n    elif FLAGS.solver == 'lrsnash':\n        print('using lrsnash solver')\n        equilibria = matrix_nash.lrs_solve(row_payoffs, col_payoffs, FLAGS.lrsnash_max_denom, FLAGS.lrsnash_path)\n    elif FLAGS.solver == 'nashpy':\n        if FLAGS.mode == 'all':\n            print('using nashpy vertex enumeration')\n            equilibria = nashpy.Game(row_payoffs, col_payoffs).vertex_enumeration()\n        else:\n            print('using nashpy Lemke-Howson solver')\n            equilibria = matrix_nash.lemke_howson_solve(row_payoffs, col_payoffs)\n    print('equilibria:' if FLAGS.mode == 'all' else 'an equilibrium:')\n    equilibria = iter(equilibria)\n    try:\n        equilibria = itertools.chain([next(equilibria)], equilibria)\n    except StopIteration:\n        print('not found!')\n    for (row_mixture, col_mixture) in equilibria:\n        print('payoffs %f, %f for %s, %s' % (row_mixture.dot(row_payoffs.dot(col_mixture)), row_mixture.dot(col_payoffs.dot(col_mixture)), row_mixture, col_mixture))\n        if FLAGS.mode == 'one':\n            return"
        ]
    }
]