def _svds_arpack_doc(A, k=6, ncv=None, tol=0, which='LM', v0=None, maxiter=None, return_singular_vectors=True, solver='arpack', random_state=None):
    if False:
        while True:
            i = 10
    '\n    Partial singular value decomposition of a sparse matrix using ARPACK.\n\n    Compute the largest or smallest `k` singular values and corresponding\n    singular vectors of a sparse matrix `A`. The order in which the singular\n    values are returned is not guaranteed.\n\n    In the descriptions below, let ``M, N = A.shape``.\n\n    Parameters\n    ----------\n    A : sparse matrix or LinearOperator\n        Matrix to decompose.\n    k : int, optional\n        Number of singular values and singular vectors to compute.\n        Must satisfy ``1 <= k <= min(M, N) - 1``.\n        Default is 6.\n    ncv : int, optional\n        The number of Lanczos vectors generated.\n        The default is ``min(n, max(2*k + 1, 20))``.\n        If specified, must satistify ``k + 1 < ncv < min(M, N)``; ``ncv > 2*k``\n        is recommended.\n    tol : float, optional\n        Tolerance for singular values. Zero (default) means machine precision.\n    which : {\'LM\', \'SM\'}\n        Which `k` singular values to find: either the largest magnitude (\'LM\')\n        or smallest magnitude (\'SM\') singular values.\n    v0 : ndarray, optional\n        The starting vector for iteration:\n        an (approximate) left singular vector if ``N > M`` and a right singular\n        vector otherwise. Must be of length ``min(M, N)``.\n        Default: random\n    maxiter : int, optional\n        Maximum number of Arnoldi update iterations allowed;\n        default is ``min(M, N) * 10``.\n    return_singular_vectors : {True, False, "u", "vh"}\n        Singular values are always computed and returned; this parameter\n        controls the computation and return of singular vectors.\n\n        - ``True``: return singular vectors.\n        - ``False``: do not return singular vectors.\n        - ``"u"``: if ``M <= N``, compute only the left singular vectors and\n          return ``None`` for the right singular vectors. Otherwise, compute\n          all singular vectors.\n        - ``"vh"``: if ``M > N``, compute only the right singular vectors and\n          return ``None`` for the left singular vectors. Otherwise, compute\n          all singular vectors.\n\n    solver :  {\'arpack\', \'propack\', \'lobpcg\'}, optional\n            This is the solver-specific documentation for ``solver=\'arpack\'``.\n            :ref:`\'lobpcg\' <sparse.linalg.svds-lobpcg>` and\n            :ref:`\'propack\' <sparse.linalg.svds-propack>`\n            are also supported.\n    random_state : {None, int, `numpy.random.Generator`,\n                    `numpy.random.RandomState`}, optional\n\n        Pseudorandom number generator state used to generate resamples.\n\n        If `random_state` is ``None`` (or `np.random`), the\n        `numpy.random.RandomState` singleton is used.\n        If `random_state` is an int, a new ``RandomState`` instance is used,\n        seeded with `random_state`.\n        If `random_state` is already a ``Generator`` or ``RandomState``\n        instance then that instance is used.\n    options : dict, optional\n        A dictionary of solver-specific options. No solver-specific options\n        are currently supported; this parameter is reserved for future use.\n\n    Returns\n    -------\n    u : ndarray, shape=(M, k)\n        Unitary matrix having left singular vectors as columns.\n    s : ndarray, shape=(k,)\n        The singular values.\n    vh : ndarray, shape=(k, N)\n        Unitary matrix having right singular vectors as rows.\n\n    Notes\n    -----\n    This is a naive implementation using ARPACK as an eigensolver\n    on ``A.conj().T @ A`` or ``A @ A.conj().T``, depending on which one is more\n    efficient.\n\n    Examples\n    --------\n    Construct a matrix ``A`` from singular values and vectors.\n\n    >>> import numpy as np\n    >>> from scipy.stats import ortho_group\n    >>> from scipy.sparse import csc_matrix, diags\n    >>> from scipy.sparse.linalg import svds\n    >>> rng = np.random.default_rng()\n    >>> orthogonal = csc_matrix(ortho_group.rvs(10, random_state=rng))\n    >>> s = [0.0001, 0.001, 3, 4, 5]  # singular values\n    >>> u = orthogonal[:, :5]         # left singular vectors\n    >>> vT = orthogonal[:, 5:].T      # right singular vectors\n    >>> A = u @ diags(s) @ vT\n\n    With only three singular values/vectors, the SVD approximates the original\n    matrix.\n\n    >>> u2, s2, vT2 = svds(A, k=3, solver=\'arpack\')\n    >>> A2 = u2 @ np.diag(s2) @ vT2\n    >>> np.allclose(A2, A.toarray(), atol=1e-3)\n    True\n\n    With all five singular values/vectors, we can reproduce the original\n    matrix.\n\n    >>> u3, s3, vT3 = svds(A, k=5, solver=\'arpack\')\n    >>> A3 = u3 @ np.diag(s3) @ vT3\n    >>> np.allclose(A3, A.toarray())\n    True\n\n    The singular values match the expected singular values, and the singular\n    vectors are as expected up to a difference in sign.\n\n    >>> (np.allclose(s3, s) and\n    ...  np.allclose(np.abs(u3), np.abs(u.toarray())) and\n    ...  np.allclose(np.abs(vT3), np.abs(vT.toarray())))\n    True\n\n    The singular vectors are also orthogonal.\n\n    >>> (np.allclose(u3.T @ u3, np.eye(5)) and\n    ...  np.allclose(vT3 @ vT3.T, np.eye(5)))\n    True\n    '
    pass

def _svds_lobpcg_doc(A, k=6, ncv=None, tol=0, which='LM', v0=None, maxiter=None, return_singular_vectors=True, solver='lobpcg', random_state=None):
    if False:
        for i in range(10):
            print('nop')
    '\n    Partial singular value decomposition of a sparse matrix using LOBPCG.\n\n    Compute the largest or smallest `k` singular values and corresponding\n    singular vectors of a sparse matrix `A`. The order in which the singular\n    values are returned is not guaranteed.\n\n    In the descriptions below, let ``M, N = A.shape``.\n\n    Parameters\n    ----------\n    A : sparse matrix or LinearOperator\n        Matrix to decompose.\n    k : int, default: 6\n        Number of singular values and singular vectors to compute.\n        Must satisfy ``1 <= k <= min(M, N) - 1``.\n    ncv : int, optional\n        Ignored.\n    tol : float, optional\n        Tolerance for singular values. Zero (default) means machine precision.\n    which : {\'LM\', \'SM\'}\n        Which `k` singular values to find: either the largest magnitude (\'LM\')\n        or smallest magnitude (\'SM\') singular values.\n    v0 : ndarray, optional\n        If `k` is 1, the starting vector for iteration:\n        an (approximate) left singular vector if ``N > M`` and a right singular\n        vector otherwise. Must be of length ``min(M, N)``.\n        Ignored otherwise.\n        Default: random\n    maxiter : int, default: 20\n        Maximum number of iterations.\n    return_singular_vectors : {True, False, "u", "vh"}\n        Singular values are always computed and returned; this parameter\n        controls the computation and return of singular vectors.\n\n        - ``True``: return singular vectors.\n        - ``False``: do not return singular vectors.\n        - ``"u"``: if ``M <= N``, compute only the left singular vectors and\n          return ``None`` for the right singular vectors. Otherwise, compute\n          all singular vectors.\n        - ``"vh"``: if ``M > N``, compute only the right singular vectors and\n          return ``None`` for the left singular vectors. Otherwise, compute\n          all singular vectors.\n\n    solver :  {\'arpack\', \'propack\', \'lobpcg\'}, optional\n            This is the solver-specific documentation for ``solver=\'lobpcg\'``.\n            :ref:`\'arpack\' <sparse.linalg.svds-arpack>` and\n            :ref:`\'propack\' <sparse.linalg.svds-propack>`\n            are also supported.\n    random_state : {None, int, `numpy.random.Generator`,\n                    `numpy.random.RandomState`}, optional\n\n        Pseudorandom number generator state used to generate resamples.\n\n        If `random_state` is ``None`` (or `np.random`), the\n        `numpy.random.RandomState` singleton is used.\n        If `random_state` is an int, a new ``RandomState`` instance is used,\n        seeded with `random_state`.\n        If `random_state` is already a ``Generator`` or ``RandomState``\n        instance then that instance is used.\n    options : dict, optional\n        A dictionary of solver-specific options. No solver-specific options\n        are currently supported; this parameter is reserved for future use.\n\n    Returns\n    -------\n    u : ndarray, shape=(M, k)\n        Unitary matrix having left singular vectors as columns.\n    s : ndarray, shape=(k,)\n        The singular values.\n    vh : ndarray, shape=(k, N)\n        Unitary matrix having right singular vectors as rows.\n\n    Notes\n    -----\n    This is a naive implementation using LOBPCG as an eigensolver\n    on ``A.conj().T @ A`` or ``A @ A.conj().T``, depending on which one is more\n    efficient.\n\n    Examples\n    --------\n    Construct a matrix ``A`` from singular values and vectors.\n\n    >>> import numpy as np\n    >>> from scipy.stats import ortho_group\n    >>> from scipy.sparse import csc_matrix, diags\n    >>> from scipy.sparse.linalg import svds\n    >>> rng = np.random.default_rng()\n    >>> orthogonal = csc_matrix(ortho_group.rvs(10, random_state=rng))\n    >>> s = [0.0001, 0.001, 3, 4, 5]  # singular values\n    >>> u = orthogonal[:, :5]         # left singular vectors\n    >>> vT = orthogonal[:, 5:].T      # right singular vectors\n    >>> A = u @ diags(s) @ vT\n\n    With only three singular values/vectors, the SVD approximates the original\n    matrix.\n\n    >>> u2, s2, vT2 = svds(A, k=3, solver=\'lobpcg\')\n    >>> A2 = u2 @ np.diag(s2) @ vT2\n    >>> np.allclose(A2, A.toarray(), atol=1e-3)\n    True\n\n    With all five singular values/vectors, we can reproduce the original\n    matrix.\n\n    >>> u3, s3, vT3 = svds(A, k=5, solver=\'lobpcg\')\n    >>> A3 = u3 @ np.diag(s3) @ vT3\n    >>> np.allclose(A3, A.toarray())\n    True\n\n    The singular values match the expected singular values, and the singular\n    vectors are as expected up to a difference in sign.\n\n    >>> (np.allclose(s3, s) and\n    ...  np.allclose(np.abs(u3), np.abs(u.todense())) and\n    ...  np.allclose(np.abs(vT3), np.abs(vT.todense())))\n    True\n\n    The singular vectors are also orthogonal.\n\n    >>> (np.allclose(u3.T @ u3, np.eye(5)) and\n    ...  np.allclose(vT3 @ vT3.T, np.eye(5)))\n    True\n\n    '
    pass

def _svds_propack_doc(A, k=6, ncv=None, tol=0, which='LM', v0=None, maxiter=None, return_singular_vectors=True, solver='propack', random_state=None):
    if False:
        return 10
    '\n    Partial singular value decomposition of a sparse matrix using PROPACK.\n\n    Compute the largest or smallest `k` singular values and corresponding\n    singular vectors of a sparse matrix `A`. The order in which the singular\n    values are returned is not guaranteed.\n\n    In the descriptions below, let ``M, N = A.shape``.\n\n    Parameters\n    ----------\n    A : sparse matrix or LinearOperator\n        Matrix to decompose. If `A` is a ``LinearOperator``\n        object, it must define both ``matvec`` and ``rmatvec`` methods.\n    k : int, default: 6\n        Number of singular values and singular vectors to compute.\n        Must satisfy ``1 <= k <= min(M, N)``.\n    ncv : int, optional\n        Ignored.\n    tol : float, optional\n        The desired relative accuracy for computed singular values.\n        Zero (default) means machine precision.\n    which : {\'LM\', \'SM\'}\n        Which `k` singular values to find: either the largest magnitude (\'LM\')\n        or smallest magnitude (\'SM\') singular values. Note that choosing\n        ``which=\'SM\'`` will force the ``irl`` option to be set ``True``.\n    v0 : ndarray, optional\n        Starting vector for iterations: must be of length ``A.shape[0]``.\n        If not specified, PROPACK will generate a starting vector.\n    maxiter : int, optional\n        Maximum number of iterations / maximal dimension of the Krylov\n        subspace. Default is ``10 * k``.\n    return_singular_vectors : {True, False, "u", "vh"}\n        Singular values are always computed and returned; this parameter\n        controls the computation and return of singular vectors.\n\n        - ``True``: return singular vectors.\n        - ``False``: do not return singular vectors.\n        - ``"u"``: compute only the left singular vectors; return ``None`` for\n          the right singular vectors.\n        - ``"vh"``: compute only the right singular vectors; return ``None``\n          for the left singular vectors.\n\n    solver :  {\'arpack\', \'propack\', \'lobpcg\'}, optional\n            This is the solver-specific documentation for ``solver=\'propack\'``.\n            :ref:`\'arpack\' <sparse.linalg.svds-arpack>` and\n            :ref:`\'lobpcg\' <sparse.linalg.svds-lobpcg>`\n            are also supported.\n    random_state : {None, int, `numpy.random.Generator`,\n                    `numpy.random.RandomState`}, optional\n\n        Pseudorandom number generator state used to generate resamples.\n\n        If `random_state` is ``None`` (or `np.random`), the\n        `numpy.random.RandomState` singleton is used.\n        If `random_state` is an int, a new ``RandomState`` instance is used,\n        seeded with `random_state`.\n        If `random_state` is already a ``Generator`` or ``RandomState``\n        instance then that instance is used.\n    options : dict, optional\n        A dictionary of solver-specific options. No solver-specific options\n        are currently supported; this parameter is reserved for future use.\n\n    Returns\n    -------\n    u : ndarray, shape=(M, k)\n        Unitary matrix having left singular vectors as columns.\n    s : ndarray, shape=(k,)\n        The singular values.\n    vh : ndarray, shape=(k, N)\n        Unitary matrix having right singular vectors as rows.\n\n    Notes\n    -----\n    This is an interface to the Fortran library PROPACK [1]_.\n    The current default is to run with IRL mode disabled unless seeking the\n    smallest singular values/vectors (``which=\'SM\'``).\n\n    References\n    ----------\n\n    .. [1] Larsen, Rasmus Munk. "PROPACK-Software for large and sparse SVD\n       calculations." Available online. URL\n       http://sun.stanford.edu/~rmunk/PROPACK (2004): 2008-2009.\n\n    Examples\n    --------\n    Construct a matrix ``A`` from singular values and vectors.\n\n    >>> import numpy as np\n    >>> from scipy.stats import ortho_group\n    >>> from scipy.sparse import csc_matrix, diags\n    >>> from scipy.sparse.linalg import svds\n    >>> rng = np.random.default_rng()\n    >>> orthogonal = csc_matrix(ortho_group.rvs(10, random_state=rng))\n    >>> s = [0.0001, 0.001, 3, 4, 5]  # singular values\n    >>> u = orthogonal[:, :5]         # left singular vectors\n    >>> vT = orthogonal[:, 5:].T      # right singular vectors\n    >>> A = u @ diags(s) @ vT\n\n    With only three singular values/vectors, the SVD approximates the original\n    matrix.\n\n    >>> u2, s2, vT2 = svds(A, k=3, solver=\'propack\')\n    >>> A2 = u2 @ np.diag(s2) @ vT2\n    >>> np.allclose(A2, A.todense(), atol=1e-3)\n    True\n\n    With all five singular values/vectors, we can reproduce the original\n    matrix.\n\n    >>> u3, s3, vT3 = svds(A, k=5, solver=\'propack\')\n    >>> A3 = u3 @ np.diag(s3) @ vT3\n    >>> np.allclose(A3, A.todense())\n    True\n\n    The singular values match the expected singular values, and the singular\n    vectors are as expected up to a difference in sign.\n\n    >>> (np.allclose(s3, s) and\n    ...  np.allclose(np.abs(u3), np.abs(u.toarray())) and\n    ...  np.allclose(np.abs(vT3), np.abs(vT.toarray())))\n    True\n\n    The singular vectors are also orthogonal.\n\n    >>> (np.allclose(u3.T @ u3, np.eye(5)) and\n    ...  np.allclose(vT3 @ vT3.T, np.eye(5)))\n    True\n\n    '
    pass