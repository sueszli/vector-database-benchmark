[
    {
        "func_name": "numerical_gradient",
        "original": "@staticmethod\ndef numerical_gradient(fun, x, eps=np.sqrt(np.finfo(float).eps)):\n    fun_0 = fun(x)\n    num_grad = [np.zeros_like(xi) for xi in x]\n    x_plus_dx = [np.copy(xi) for xi in x]\n    for i in range(len(x)):\n        for j in range(len(x[i])):\n            x_plus_dx[i][j] = x[i][j] + eps\n            num_grad[i][j] = (fun(x_plus_dx) - fun_0) / eps\n            x_plus_dx[i][j] = x[i][j]\n    return num_grad",
        "mutated": [
            "@staticmethod\ndef numerical_gradient(fun, x, eps=np.sqrt(np.finfo(float).eps)):\n    if False:\n        i = 10\n    fun_0 = fun(x)\n    num_grad = [np.zeros_like(xi) for xi in x]\n    x_plus_dx = [np.copy(xi) for xi in x]\n    for i in range(len(x)):\n        for j in range(len(x[i])):\n            x_plus_dx[i][j] = x[i][j] + eps\n            num_grad[i][j] = (fun(x_plus_dx) - fun_0) / eps\n            x_plus_dx[i][j] = x[i][j]\n    return num_grad",
            "@staticmethod\ndef numerical_gradient(fun, x, eps=np.sqrt(np.finfo(float).eps)):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    fun_0 = fun(x)\n    num_grad = [np.zeros_like(xi) for xi in x]\n    x_plus_dx = [np.copy(xi) for xi in x]\n    for i in range(len(x)):\n        for j in range(len(x[i])):\n            x_plus_dx[i][j] = x[i][j] + eps\n            num_grad[i][j] = (fun(x_plus_dx) - fun_0) / eps\n            x_plus_dx[i][j] = x[i][j]\n    return num_grad",
            "@staticmethod\ndef numerical_gradient(fun, x, eps=np.sqrt(np.finfo(float).eps)):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    fun_0 = fun(x)\n    num_grad = [np.zeros_like(xi) for xi in x]\n    x_plus_dx = [np.copy(xi) for xi in x]\n    for i in range(len(x)):\n        for j in range(len(x[i])):\n            x_plus_dx[i][j] = x[i][j] + eps\n            num_grad[i][j] = (fun(x_plus_dx) - fun_0) / eps\n            x_plus_dx[i][j] = x[i][j]\n    return num_grad",
            "@staticmethod\ndef numerical_gradient(fun, x, eps=np.sqrt(np.finfo(float).eps)):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    fun_0 = fun(x)\n    num_grad = [np.zeros_like(xi) for xi in x]\n    x_plus_dx = [np.copy(xi) for xi in x]\n    for i in range(len(x)):\n        for j in range(len(x[i])):\n            x_plus_dx[i][j] = x[i][j] + eps\n            num_grad[i][j] = (fun(x_plus_dx) - fun_0) / eps\n            x_plus_dx[i][j] = x[i][j]\n    return num_grad",
            "@staticmethod\ndef numerical_gradient(fun, x, eps=np.sqrt(np.finfo(float).eps)):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    fun_0 = fun(x)\n    num_grad = [np.zeros_like(xi) for xi in x]\n    x_plus_dx = [np.copy(xi) for xi in x]\n    for i in range(len(x)):\n        for j in range(len(x[i])):\n            x_plus_dx[i][j] = x[i][j] + eps\n            num_grad[i][j] = (fun(x_plus_dx) - fun_0) / eps\n            x_plus_dx[i][j] = x[i][j]\n    return num_grad"
        ]
    },
    {
        "func_name": "prep_params",
        "original": "@staticmethod\ndef prep_params(dist, pt, num_params):\n    params = [dist]\n    if num_params > 1:\n        num_players = len(dist)\n        nabla = [misc.pt_reduce(pt[i], dist, [i]) for i in range(num_players)]\n        params += [nabla]\n    return tuple(params)",
        "mutated": [
            "@staticmethod\ndef prep_params(dist, pt, num_params):\n    if False:\n        i = 10\n    params = [dist]\n    if num_params > 1:\n        num_players = len(dist)\n        nabla = [misc.pt_reduce(pt[i], dist, [i]) for i in range(num_players)]\n        params += [nabla]\n    return tuple(params)",
            "@staticmethod\ndef prep_params(dist, pt, num_params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    params = [dist]\n    if num_params > 1:\n        num_players = len(dist)\n        nabla = [misc.pt_reduce(pt[i], dist, [i]) for i in range(num_players)]\n        params += [nabla]\n    return tuple(params)",
            "@staticmethod\ndef prep_params(dist, pt, num_params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    params = [dist]\n    if num_params > 1:\n        num_players = len(dist)\n        nabla = [misc.pt_reduce(pt[i], dist, [i]) for i in range(num_players)]\n        params += [nabla]\n    return tuple(params)",
            "@staticmethod\ndef prep_params(dist, pt, num_params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    params = [dist]\n    if num_params > 1:\n        num_players = len(dist)\n        nabla = [misc.pt_reduce(pt[i], dist, [i]) for i in range(num_players)]\n        params += [nabla]\n    return tuple(params)",
            "@staticmethod\ndef prep_params(dist, pt, num_params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    params = [dist]\n    if num_params > 1:\n        num_players = len(dist)\n        nabla = [misc.pt_reduce(pt[i], dist, [i]) for i in range(num_players)]\n        params += [nabla]\n    return tuple(params)"
        ]
    },
    {
        "func_name": "test_exploitability_gradient_on_nonsymmetric_three_player_matrix_games",
        "original": "@parameterized.named_parameters(('PED', (ped, False)), ('ATE_p=1', (ate, 1.0, False)), ('ATE_p=0.5', (ate, 0.5, False)), ('ATE_p=0.1', (ate, 0.1, False)), ('ATE_p=0', (ate, 0.0, False)), ('QRE_t=0.0', (qre, 0.0, False)), ('QRE_t=0.1', (qre, 0.1, False)))\ndef test_exploitability_gradient_on_nonsymmetric_three_player_matrix_games(self, solver_tuple, trials=100, max_num_strats=3, atol=0.1, rtol=0.1, seed=1234):\n    num_players = 3\n    solver = solver_tuple[0].Solver(*solver_tuple[1:])\n    random = np.random.RandomState(seed)\n    successes = []\n    for _ in range(trials):\n        num_strats = random.randint(low=2, high=max_num_strats + 1, size=num_players)\n        num_strats = tuple([int(ns) for ns in num_strats])\n        payoff_tensor = random.rand(num_players, *num_strats)\n        num_params = len(solver.init_vars(num_strats, num_players))\n        dirichlet_alpha = [np.ones(num_strats_i) for num_strats_i in num_strats]\n        dist = [random.dirichlet(alpha_i) for alpha_i in dirichlet_alpha]\n        params = self.prep_params(dist, payoff_tensor, num_params)\n        payoff_matrices = {}\n        for (pi, pj) in itertools.combinations(range(num_players), 2):\n            key = (pi, pj)\n            pt_i = misc.pt_reduce(payoff_tensor[pi], dist, [pi, pj])\n            pt_j = misc.pt_reduce(payoff_tensor[pj], dist, [pi, pj])\n            payoff_matrices[key] = np.stack((pt_i, pt_j), axis=0)\n        grad = solver.compute_gradients(params, payoff_matrices)[0][0]\n        grad = np.concatenate(grad) / float(num_players)\n        exp = lambda x: solver.exploitability(x, payoff_tensor)\n        num_grad = np.concatenate(self.numerical_gradient(exp, dist))\n        successes += [np.logical_and(np.allclose(grad, num_grad, rtol, atol), cosine(grad, num_grad) <= atol)]\n    perc = 100 * np.mean(successes)\n    logging.info('gradient accuracy success rate out of %d is %f', trials, perc)\n    self.assertGreaterEqual(perc, 95.0, 'exploitability gradient accuracy is too poor')",
        "mutated": [
            "@parameterized.named_parameters(('PED', (ped, False)), ('ATE_p=1', (ate, 1.0, False)), ('ATE_p=0.5', (ate, 0.5, False)), ('ATE_p=0.1', (ate, 0.1, False)), ('ATE_p=0', (ate, 0.0, False)), ('QRE_t=0.0', (qre, 0.0, False)), ('QRE_t=0.1', (qre, 0.1, False)))\ndef test_exploitability_gradient_on_nonsymmetric_three_player_matrix_games(self, solver_tuple, trials=100, max_num_strats=3, atol=0.1, rtol=0.1, seed=1234):\n    if False:\n        i = 10\n    num_players = 3\n    solver = solver_tuple[0].Solver(*solver_tuple[1:])\n    random = np.random.RandomState(seed)\n    successes = []\n    for _ in range(trials):\n        num_strats = random.randint(low=2, high=max_num_strats + 1, size=num_players)\n        num_strats = tuple([int(ns) for ns in num_strats])\n        payoff_tensor = random.rand(num_players, *num_strats)\n        num_params = len(solver.init_vars(num_strats, num_players))\n        dirichlet_alpha = [np.ones(num_strats_i) for num_strats_i in num_strats]\n        dist = [random.dirichlet(alpha_i) for alpha_i in dirichlet_alpha]\n        params = self.prep_params(dist, payoff_tensor, num_params)\n        payoff_matrices = {}\n        for (pi, pj) in itertools.combinations(range(num_players), 2):\n            key = (pi, pj)\n            pt_i = misc.pt_reduce(payoff_tensor[pi], dist, [pi, pj])\n            pt_j = misc.pt_reduce(payoff_tensor[pj], dist, [pi, pj])\n            payoff_matrices[key] = np.stack((pt_i, pt_j), axis=0)\n        grad = solver.compute_gradients(params, payoff_matrices)[0][0]\n        grad = np.concatenate(grad) / float(num_players)\n        exp = lambda x: solver.exploitability(x, payoff_tensor)\n        num_grad = np.concatenate(self.numerical_gradient(exp, dist))\n        successes += [np.logical_and(np.allclose(grad, num_grad, rtol, atol), cosine(grad, num_grad) <= atol)]\n    perc = 100 * np.mean(successes)\n    logging.info('gradient accuracy success rate out of %d is %f', trials, perc)\n    self.assertGreaterEqual(perc, 95.0, 'exploitability gradient accuracy is too poor')",
            "@parameterized.named_parameters(('PED', (ped, False)), ('ATE_p=1', (ate, 1.0, False)), ('ATE_p=0.5', (ate, 0.5, False)), ('ATE_p=0.1', (ate, 0.1, False)), ('ATE_p=0', (ate, 0.0, False)), ('QRE_t=0.0', (qre, 0.0, False)), ('QRE_t=0.1', (qre, 0.1, False)))\ndef test_exploitability_gradient_on_nonsymmetric_three_player_matrix_games(self, solver_tuple, trials=100, max_num_strats=3, atol=0.1, rtol=0.1, seed=1234):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    num_players = 3\n    solver = solver_tuple[0].Solver(*solver_tuple[1:])\n    random = np.random.RandomState(seed)\n    successes = []\n    for _ in range(trials):\n        num_strats = random.randint(low=2, high=max_num_strats + 1, size=num_players)\n        num_strats = tuple([int(ns) for ns in num_strats])\n        payoff_tensor = random.rand(num_players, *num_strats)\n        num_params = len(solver.init_vars(num_strats, num_players))\n        dirichlet_alpha = [np.ones(num_strats_i) for num_strats_i in num_strats]\n        dist = [random.dirichlet(alpha_i) for alpha_i in dirichlet_alpha]\n        params = self.prep_params(dist, payoff_tensor, num_params)\n        payoff_matrices = {}\n        for (pi, pj) in itertools.combinations(range(num_players), 2):\n            key = (pi, pj)\n            pt_i = misc.pt_reduce(payoff_tensor[pi], dist, [pi, pj])\n            pt_j = misc.pt_reduce(payoff_tensor[pj], dist, [pi, pj])\n            payoff_matrices[key] = np.stack((pt_i, pt_j), axis=0)\n        grad = solver.compute_gradients(params, payoff_matrices)[0][0]\n        grad = np.concatenate(grad) / float(num_players)\n        exp = lambda x: solver.exploitability(x, payoff_tensor)\n        num_grad = np.concatenate(self.numerical_gradient(exp, dist))\n        successes += [np.logical_and(np.allclose(grad, num_grad, rtol, atol), cosine(grad, num_grad) <= atol)]\n    perc = 100 * np.mean(successes)\n    logging.info('gradient accuracy success rate out of %d is %f', trials, perc)\n    self.assertGreaterEqual(perc, 95.0, 'exploitability gradient accuracy is too poor')",
            "@parameterized.named_parameters(('PED', (ped, False)), ('ATE_p=1', (ate, 1.0, False)), ('ATE_p=0.5', (ate, 0.5, False)), ('ATE_p=0.1', (ate, 0.1, False)), ('ATE_p=0', (ate, 0.0, False)), ('QRE_t=0.0', (qre, 0.0, False)), ('QRE_t=0.1', (qre, 0.1, False)))\ndef test_exploitability_gradient_on_nonsymmetric_three_player_matrix_games(self, solver_tuple, trials=100, max_num_strats=3, atol=0.1, rtol=0.1, seed=1234):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    num_players = 3\n    solver = solver_tuple[0].Solver(*solver_tuple[1:])\n    random = np.random.RandomState(seed)\n    successes = []\n    for _ in range(trials):\n        num_strats = random.randint(low=2, high=max_num_strats + 1, size=num_players)\n        num_strats = tuple([int(ns) for ns in num_strats])\n        payoff_tensor = random.rand(num_players, *num_strats)\n        num_params = len(solver.init_vars(num_strats, num_players))\n        dirichlet_alpha = [np.ones(num_strats_i) for num_strats_i in num_strats]\n        dist = [random.dirichlet(alpha_i) for alpha_i in dirichlet_alpha]\n        params = self.prep_params(dist, payoff_tensor, num_params)\n        payoff_matrices = {}\n        for (pi, pj) in itertools.combinations(range(num_players), 2):\n            key = (pi, pj)\n            pt_i = misc.pt_reduce(payoff_tensor[pi], dist, [pi, pj])\n            pt_j = misc.pt_reduce(payoff_tensor[pj], dist, [pi, pj])\n            payoff_matrices[key] = np.stack((pt_i, pt_j), axis=0)\n        grad = solver.compute_gradients(params, payoff_matrices)[0][0]\n        grad = np.concatenate(grad) / float(num_players)\n        exp = lambda x: solver.exploitability(x, payoff_tensor)\n        num_grad = np.concatenate(self.numerical_gradient(exp, dist))\n        successes += [np.logical_and(np.allclose(grad, num_grad, rtol, atol), cosine(grad, num_grad) <= atol)]\n    perc = 100 * np.mean(successes)\n    logging.info('gradient accuracy success rate out of %d is %f', trials, perc)\n    self.assertGreaterEqual(perc, 95.0, 'exploitability gradient accuracy is too poor')",
            "@parameterized.named_parameters(('PED', (ped, False)), ('ATE_p=1', (ate, 1.0, False)), ('ATE_p=0.5', (ate, 0.5, False)), ('ATE_p=0.1', (ate, 0.1, False)), ('ATE_p=0', (ate, 0.0, False)), ('QRE_t=0.0', (qre, 0.0, False)), ('QRE_t=0.1', (qre, 0.1, False)))\ndef test_exploitability_gradient_on_nonsymmetric_three_player_matrix_games(self, solver_tuple, trials=100, max_num_strats=3, atol=0.1, rtol=0.1, seed=1234):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    num_players = 3\n    solver = solver_tuple[0].Solver(*solver_tuple[1:])\n    random = np.random.RandomState(seed)\n    successes = []\n    for _ in range(trials):\n        num_strats = random.randint(low=2, high=max_num_strats + 1, size=num_players)\n        num_strats = tuple([int(ns) for ns in num_strats])\n        payoff_tensor = random.rand(num_players, *num_strats)\n        num_params = len(solver.init_vars(num_strats, num_players))\n        dirichlet_alpha = [np.ones(num_strats_i) for num_strats_i in num_strats]\n        dist = [random.dirichlet(alpha_i) for alpha_i in dirichlet_alpha]\n        params = self.prep_params(dist, payoff_tensor, num_params)\n        payoff_matrices = {}\n        for (pi, pj) in itertools.combinations(range(num_players), 2):\n            key = (pi, pj)\n            pt_i = misc.pt_reduce(payoff_tensor[pi], dist, [pi, pj])\n            pt_j = misc.pt_reduce(payoff_tensor[pj], dist, [pi, pj])\n            payoff_matrices[key] = np.stack((pt_i, pt_j), axis=0)\n        grad = solver.compute_gradients(params, payoff_matrices)[0][0]\n        grad = np.concatenate(grad) / float(num_players)\n        exp = lambda x: solver.exploitability(x, payoff_tensor)\n        num_grad = np.concatenate(self.numerical_gradient(exp, dist))\n        successes += [np.logical_and(np.allclose(grad, num_grad, rtol, atol), cosine(grad, num_grad) <= atol)]\n    perc = 100 * np.mean(successes)\n    logging.info('gradient accuracy success rate out of %d is %f', trials, perc)\n    self.assertGreaterEqual(perc, 95.0, 'exploitability gradient accuracy is too poor')",
            "@parameterized.named_parameters(('PED', (ped, False)), ('ATE_p=1', (ate, 1.0, False)), ('ATE_p=0.5', (ate, 0.5, False)), ('ATE_p=0.1', (ate, 0.1, False)), ('ATE_p=0', (ate, 0.0, False)), ('QRE_t=0.0', (qre, 0.0, False)), ('QRE_t=0.1', (qre, 0.1, False)))\ndef test_exploitability_gradient_on_nonsymmetric_three_player_matrix_games(self, solver_tuple, trials=100, max_num_strats=3, atol=0.1, rtol=0.1, seed=1234):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    num_players = 3\n    solver = solver_tuple[0].Solver(*solver_tuple[1:])\n    random = np.random.RandomState(seed)\n    successes = []\n    for _ in range(trials):\n        num_strats = random.randint(low=2, high=max_num_strats + 1, size=num_players)\n        num_strats = tuple([int(ns) for ns in num_strats])\n        payoff_tensor = random.rand(num_players, *num_strats)\n        num_params = len(solver.init_vars(num_strats, num_players))\n        dirichlet_alpha = [np.ones(num_strats_i) for num_strats_i in num_strats]\n        dist = [random.dirichlet(alpha_i) for alpha_i in dirichlet_alpha]\n        params = self.prep_params(dist, payoff_tensor, num_params)\n        payoff_matrices = {}\n        for (pi, pj) in itertools.combinations(range(num_players), 2):\n            key = (pi, pj)\n            pt_i = misc.pt_reduce(payoff_tensor[pi], dist, [pi, pj])\n            pt_j = misc.pt_reduce(payoff_tensor[pj], dist, [pi, pj])\n            payoff_matrices[key] = np.stack((pt_i, pt_j), axis=0)\n        grad = solver.compute_gradients(params, payoff_matrices)[0][0]\n        grad = np.concatenate(grad) / float(num_players)\n        exp = lambda x: solver.exploitability(x, payoff_tensor)\n        num_grad = np.concatenate(self.numerical_gradient(exp, dist))\n        successes += [np.logical_and(np.allclose(grad, num_grad, rtol, atol), cosine(grad, num_grad) <= atol)]\n    perc = 100 * np.mean(successes)\n    logging.info('gradient accuracy success rate out of %d is %f', trials, perc)\n    self.assertGreaterEqual(perc, 95.0, 'exploitability gradient accuracy is too poor')"
        ]
    }
]