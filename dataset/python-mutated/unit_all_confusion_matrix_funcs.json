[
    {
        "func_name": "dim_check",
        "original": "def dim_check(cm, m, t, v):\n    assert len(cm) == 2 and len(cm[0]) == 2 and (len(cm[1]) == 2), 'incorrect confusion matrix dimensions for metric/thresh: {0}, train: {1}, valid: {2}'.format(m, t, v)",
        "mutated": [
            "def dim_check(cm, m, t, v):\n    if False:\n        i = 10\n    assert len(cm) == 2 and len(cm[0]) == 2 and (len(cm[1]) == 2), 'incorrect confusion matrix dimensions for metric/thresh: {0}, train: {1}, valid: {2}'.format(m, t, v)",
            "def dim_check(cm, m, t, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert len(cm) == 2 and len(cm[0]) == 2 and (len(cm[1]) == 2), 'incorrect confusion matrix dimensions for metric/thresh: {0}, train: {1}, valid: {2}'.format(m, t, v)",
            "def dim_check(cm, m, t, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert len(cm) == 2 and len(cm[0]) == 2 and (len(cm[1]) == 2), 'incorrect confusion matrix dimensions for metric/thresh: {0}, train: {1}, valid: {2}'.format(m, t, v)",
            "def dim_check(cm, m, t, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert len(cm) == 2 and len(cm[0]) == 2 and (len(cm[1]) == 2), 'incorrect confusion matrix dimensions for metric/thresh: {0}, train: {1}, valid: {2}'.format(m, t, v)",
            "def dim_check(cm, m, t, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert len(cm) == 2 and len(cm[0]) == 2 and (len(cm[1]) == 2), 'incorrect confusion matrix dimensions for metric/thresh: {0}, train: {1}, valid: {2}'.format(m, t, v)"
        ]
    },
    {
        "func_name": "type_check",
        "original": "def type_check(cm, m, t, v):\n    assert isinstance(cm[0][0], (int, float)) and isinstance(cm[0][1], (int, float)) and isinstance(cm[1][0], (int, float)) and isinstance(cm[0][0], (int, float)), 'confusion matrix entries should be integers or floats but got {0}, {1}, {2}, {3}. metric/thresh: {4}, train: {5}, valid: {6}'.format(type(cm[0][0]), type(cm[0][1]), type(cm[1][0]), type(cm[1][1]), m, t, v)",
        "mutated": [
            "def type_check(cm, m, t, v):\n    if False:\n        i = 10\n    assert isinstance(cm[0][0], (int, float)) and isinstance(cm[0][1], (int, float)) and isinstance(cm[1][0], (int, float)) and isinstance(cm[0][0], (int, float)), 'confusion matrix entries should be integers or floats but got {0}, {1}, {2}, {3}. metric/thresh: {4}, train: {5}, valid: {6}'.format(type(cm[0][0]), type(cm[0][1]), type(cm[1][0]), type(cm[1][1]), m, t, v)",
            "def type_check(cm, m, t, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert isinstance(cm[0][0], (int, float)) and isinstance(cm[0][1], (int, float)) and isinstance(cm[1][0], (int, float)) and isinstance(cm[0][0], (int, float)), 'confusion matrix entries should be integers or floats but got {0}, {1}, {2}, {3}. metric/thresh: {4}, train: {5}, valid: {6}'.format(type(cm[0][0]), type(cm[0][1]), type(cm[1][0]), type(cm[1][1]), m, t, v)",
            "def type_check(cm, m, t, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert isinstance(cm[0][0], (int, float)) and isinstance(cm[0][1], (int, float)) and isinstance(cm[1][0], (int, float)) and isinstance(cm[0][0], (int, float)), 'confusion matrix entries should be integers or floats but got {0}, {1}, {2}, {3}. metric/thresh: {4}, train: {5}, valid: {6}'.format(type(cm[0][0]), type(cm[0][1]), type(cm[1][0]), type(cm[1][1]), m, t, v)",
            "def type_check(cm, m, t, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert isinstance(cm[0][0], (int, float)) and isinstance(cm[0][1], (int, float)) and isinstance(cm[1][0], (int, float)) and isinstance(cm[0][0], (int, float)), 'confusion matrix entries should be integers or floats but got {0}, {1}, {2}, {3}. metric/thresh: {4}, train: {5}, valid: {6}'.format(type(cm[0][0]), type(cm[0][1]), type(cm[1][0]), type(cm[1][1]), m, t, v)",
            "def type_check(cm, m, t, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert isinstance(cm[0][0], (int, float)) and isinstance(cm[0][1], (int, float)) and isinstance(cm[1][0], (int, float)) and isinstance(cm[0][0], (int, float)), 'confusion matrix entries should be integers or floats but got {0}, {1}, {2}, {3}. metric/thresh: {4}, train: {5}, valid: {6}'.format(type(cm[0][0]), type(cm[0][1]), type(cm[1][0]), type(cm[1][1]), m, t, v)"
        ]
    },
    {
        "func_name": "count_check",
        "original": "def count_check(cm, m, t, v):\n    if v:\n        assert cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1] == air_test.nrow, 'incorrect confusion matrix elements: {0}, {1}, {2}, {3}. Should sum to {4}. metric/thresh: {5}, train: {6}, valid: {7}'.format(cm[0][0], cm[0][1], cm[1][0], cm[1][1], air_test.nrow, m, t, v)\n    else:\n        assert cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1] == air_train.nrow, 'incorrect confusion matrix elements: {0}, {1}, {2}, {3}. Should sum to {4}. metric/thresh: {5}, train: {6}, valid: {7}'.format(cm[0][0], cm[0][1], cm[1][0], cm[1][1], air_train.nrow, m, t, v)",
        "mutated": [
            "def count_check(cm, m, t, v):\n    if False:\n        i = 10\n    if v:\n        assert cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1] == air_test.nrow, 'incorrect confusion matrix elements: {0}, {1}, {2}, {3}. Should sum to {4}. metric/thresh: {5}, train: {6}, valid: {7}'.format(cm[0][0], cm[0][1], cm[1][0], cm[1][1], air_test.nrow, m, t, v)\n    else:\n        assert cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1] == air_train.nrow, 'incorrect confusion matrix elements: {0}, {1}, {2}, {3}. Should sum to {4}. metric/thresh: {5}, train: {6}, valid: {7}'.format(cm[0][0], cm[0][1], cm[1][0], cm[1][1], air_train.nrow, m, t, v)",
            "def count_check(cm, m, t, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if v:\n        assert cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1] == air_test.nrow, 'incorrect confusion matrix elements: {0}, {1}, {2}, {3}. Should sum to {4}. metric/thresh: {5}, train: {6}, valid: {7}'.format(cm[0][0], cm[0][1], cm[1][0], cm[1][1], air_test.nrow, m, t, v)\n    else:\n        assert cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1] == air_train.nrow, 'incorrect confusion matrix elements: {0}, {1}, {2}, {3}. Should sum to {4}. metric/thresh: {5}, train: {6}, valid: {7}'.format(cm[0][0], cm[0][1], cm[1][0], cm[1][1], air_train.nrow, m, t, v)",
            "def count_check(cm, m, t, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if v:\n        assert cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1] == air_test.nrow, 'incorrect confusion matrix elements: {0}, {1}, {2}, {3}. Should sum to {4}. metric/thresh: {5}, train: {6}, valid: {7}'.format(cm[0][0], cm[0][1], cm[1][0], cm[1][1], air_test.nrow, m, t, v)\n    else:\n        assert cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1] == air_train.nrow, 'incorrect confusion matrix elements: {0}, {1}, {2}, {3}. Should sum to {4}. metric/thresh: {5}, train: {6}, valid: {7}'.format(cm[0][0], cm[0][1], cm[1][0], cm[1][1], air_train.nrow, m, t, v)",
            "def count_check(cm, m, t, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if v:\n        assert cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1] == air_test.nrow, 'incorrect confusion matrix elements: {0}, {1}, {2}, {3}. Should sum to {4}. metric/thresh: {5}, train: {6}, valid: {7}'.format(cm[0][0], cm[0][1], cm[1][0], cm[1][1], air_test.nrow, m, t, v)\n    else:\n        assert cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1] == air_train.nrow, 'incorrect confusion matrix elements: {0}, {1}, {2}, {3}. Should sum to {4}. metric/thresh: {5}, train: {6}, valid: {7}'.format(cm[0][0], cm[0][1], cm[1][0], cm[1][1], air_train.nrow, m, t, v)",
            "def count_check(cm, m, t, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if v:\n        assert cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1] == air_test.nrow, 'incorrect confusion matrix elements: {0}, {1}, {2}, {3}. Should sum to {4}. metric/thresh: {5}, train: {6}, valid: {7}'.format(cm[0][0], cm[0][1], cm[1][0], cm[1][1], air_test.nrow, m, t, v)\n    else:\n        assert cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1] == air_train.nrow, 'incorrect confusion matrix elements: {0}, {1}, {2}, {3}. Should sum to {4}. metric/thresh: {5}, train: {6}, valid: {7}'.format(cm[0][0], cm[0][1], cm[1][0], cm[1][1], air_train.nrow, m, t, v)"
        ]
    },
    {
        "func_name": "all_confusion_matrix_funcs",
        "original": "def all_confusion_matrix_funcs():\n    metrics = ['recall', 'specificity', 'min_per_class_accuracy', 'absolute_mcc', 'precision', 'accuracy', 'f0point5', 'f2', 'f1', 'mean_per_class_accuracy']\n    train = [True, False]\n    valid = [True, False]\n    print('PARSING TRAINING DATA')\n    air_train = h2o.import_file(path=pyunit_utils.locate('smalldata/airlines/AirlinesTrain.csv.zip'))\n    air_train['IsDepDelayed'] = air_train['IsDepDelayed'].asfactor()\n    print('PARSING TESTING DATA')\n    air_test = h2o.import_file(path=pyunit_utils.locate('smalldata/airlines/AirlinesTest.csv.zip'))\n    air_test['IsDepDelayed'] = air_test['IsDepDelayed'].asfactor()\n    print()\n    print('RUNNING FIRST GBM: ')\n    print()\n    gbm_bin = H2OGradientBoostingEstimator(distribution='bernoulli')\n    gbm_bin.train(x=['Origin', 'Dest', 'Distance', 'UniqueCarrier', 'fMonth', 'fDayofMonth', 'fDayOfWeek'], y='IsDepDelayed', training_frame=air_train, validation_frame=air_test)\n    print()\n    print('RUNNING SECOND GBM: ')\n    print()\n    air_train['fDayOfWeek'] = air_train['fDayOfWeek'].asfactor()\n    air_test['fDayOfWeek'] = air_test['fDayOfWeek'].asfactor()\n    gbm_mult = H2OGradientBoostingEstimator(distribution='multinomial')\n    gbm_mult.train(x=['Origin', 'Dest', 'Distance', 'UniqueCarrier', 'IsDepDelayed', 'fDayofMonth', 'fMonth'], y='fDayOfWeek', training_frame=air_train, validation_frame=air_test)\n\n    def dim_check(cm, m, t, v):\n        assert len(cm) == 2 and len(cm[0]) == 2 and (len(cm[1]) == 2), 'incorrect confusion matrix dimensions for metric/thresh: {0}, train: {1}, valid: {2}'.format(m, t, v)\n\n    def type_check(cm, m, t, v):\n        assert isinstance(cm[0][0], (int, float)) and isinstance(cm[0][1], (int, float)) and isinstance(cm[1][0], (int, float)) and isinstance(cm[0][0], (int, float)), 'confusion matrix entries should be integers or floats but got {0}, {1}, {2}, {3}. metric/thresh: {4}, train: {5}, valid: {6}'.format(type(cm[0][0]), type(cm[0][1]), type(cm[1][0]), type(cm[1][1]), m, t, v)\n\n    def count_check(cm, m, t, v):\n        if v:\n            assert cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1] == air_test.nrow, 'incorrect confusion matrix elements: {0}, {1}, {2}, {3}. Should sum to {4}. metric/thresh: {5}, train: {6}, valid: {7}'.format(cm[0][0], cm[0][1], cm[1][0], cm[1][1], air_test.nrow, m, t, v)\n        else:\n            assert cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1] == air_train.nrow, 'incorrect confusion matrix elements: {0}, {1}, {2}, {3}. Should sum to {4}. metric/thresh: {5}, train: {6}, valid: {7}'.format(cm[0][0], cm[0][1], cm[1][0], cm[1][1], air_train.nrow, m, t, v)\n    for m in metrics:\n        for t in train:\n            for v in valid:\n                if t and v:\n                    continue\n                cm = gbm_bin.confusion_matrix(metrics=m, train=t, valid=v)\n                if cm:\n                    cm = cm.to_list()\n                    dim_check(cm, m, t, v)\n                    type_check(cm, m, t, v)\n                    count_check(cm, m, t, v)\n    for x in range(10):\n        for t in train:\n            for v in valid:\n                if t and v:\n                    continue\n                thresholds = [gbm_bin.find_threshold_by_max_metric(m, t, v) for m in random.sample(metrics, random.randint(1, len(metrics)))]\n                cms = gbm_bin.confusion_matrix(thresholds=thresholds, train=t, valid=v)\n                if not isinstance(cms, list):\n                    cms = [cms]\n                for (idx, cm) in enumerate(cms):\n                    cm = cm.to_list()\n                    dim_check(cm, thresholds[idx], t, v)\n                    type_check(cm, thresholds[idx], t, v)\n                    count_check(cm, thresholds[idx], t, v)\n    cm = gbm_mult.confusion_matrix(data=air_test)\n    cm_count = 0\n    for r in range(7):\n        for c in range(7):\n            cm_count += cm.cell_values[r][c]\n    assert cm_count == air_test.nrow, 'incorrect confusion matrix elements. Should sum to {0}, but got {1}'.format(air_test.nrow, cm_count)\n    bin_perf = gbm_bin.model_performance(valid=True)\n    for metric in metrics:\n        cm = bin_perf.confusion_matrix(metrics=metric).to_list()\n        dim_check(cm, metric, False, True)\n        type_check(cm, metric, False, True)\n        count_check(cm, metric, False, True)\n    bin_perf = gbm_bin.model_performance(train=True)\n    for x in range(10):\n        thresholds = [gbm_bin.find_threshold_by_max_metric(m, t, v) for m in random.sample(metrics, random.randint(1, len(metrics)))]\n        cms = bin_perf.confusion_matrix(thresholds=thresholds)\n        if not isinstance(cms, list):\n            cms = [cms]\n        for (idx, cm) in enumerate(cms):\n            cm = cm.to_list()\n            dim_check(cm, thresholds[idx], True, False)\n            type_check(cm, thresholds[idx], True, False)\n            count_check(cm, thresholds[idx], True, False)\n    mult_perf = gbm_mult.model_performance(valid=True)\n    cm = mult_perf.confusion_matrix()\n    cm_count = 0\n    for r in range(7):\n        for c in range(7):\n            cm_count += cm.cell_values[r][c]\n    assert cm_count == air_test.nrow, 'incorrect confusion matrix elements. Should sum to {0}, but got {1}'.format(air_test.nrow, cm_count)",
        "mutated": [
            "def all_confusion_matrix_funcs():\n    if False:\n        i = 10\n    metrics = ['recall', 'specificity', 'min_per_class_accuracy', 'absolute_mcc', 'precision', 'accuracy', 'f0point5', 'f2', 'f1', 'mean_per_class_accuracy']\n    train = [True, False]\n    valid = [True, False]\n    print('PARSING TRAINING DATA')\n    air_train = h2o.import_file(path=pyunit_utils.locate('smalldata/airlines/AirlinesTrain.csv.zip'))\n    air_train['IsDepDelayed'] = air_train['IsDepDelayed'].asfactor()\n    print('PARSING TESTING DATA')\n    air_test = h2o.import_file(path=pyunit_utils.locate('smalldata/airlines/AirlinesTest.csv.zip'))\n    air_test['IsDepDelayed'] = air_test['IsDepDelayed'].asfactor()\n    print()\n    print('RUNNING FIRST GBM: ')\n    print()\n    gbm_bin = H2OGradientBoostingEstimator(distribution='bernoulli')\n    gbm_bin.train(x=['Origin', 'Dest', 'Distance', 'UniqueCarrier', 'fMonth', 'fDayofMonth', 'fDayOfWeek'], y='IsDepDelayed', training_frame=air_train, validation_frame=air_test)\n    print()\n    print('RUNNING SECOND GBM: ')\n    print()\n    air_train['fDayOfWeek'] = air_train['fDayOfWeek'].asfactor()\n    air_test['fDayOfWeek'] = air_test['fDayOfWeek'].asfactor()\n    gbm_mult = H2OGradientBoostingEstimator(distribution='multinomial')\n    gbm_mult.train(x=['Origin', 'Dest', 'Distance', 'UniqueCarrier', 'IsDepDelayed', 'fDayofMonth', 'fMonth'], y='fDayOfWeek', training_frame=air_train, validation_frame=air_test)\n\n    def dim_check(cm, m, t, v):\n        assert len(cm) == 2 and len(cm[0]) == 2 and (len(cm[1]) == 2), 'incorrect confusion matrix dimensions for metric/thresh: {0}, train: {1}, valid: {2}'.format(m, t, v)\n\n    def type_check(cm, m, t, v):\n        assert isinstance(cm[0][0], (int, float)) and isinstance(cm[0][1], (int, float)) and isinstance(cm[1][0], (int, float)) and isinstance(cm[0][0], (int, float)), 'confusion matrix entries should be integers or floats but got {0}, {1}, {2}, {3}. metric/thresh: {4}, train: {5}, valid: {6}'.format(type(cm[0][0]), type(cm[0][1]), type(cm[1][0]), type(cm[1][1]), m, t, v)\n\n    def count_check(cm, m, t, v):\n        if v:\n            assert cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1] == air_test.nrow, 'incorrect confusion matrix elements: {0}, {1}, {2}, {3}. Should sum to {4}. metric/thresh: {5}, train: {6}, valid: {7}'.format(cm[0][0], cm[0][1], cm[1][0], cm[1][1], air_test.nrow, m, t, v)\n        else:\n            assert cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1] == air_train.nrow, 'incorrect confusion matrix elements: {0}, {1}, {2}, {3}. Should sum to {4}. metric/thresh: {5}, train: {6}, valid: {7}'.format(cm[0][0], cm[0][1], cm[1][0], cm[1][1], air_train.nrow, m, t, v)\n    for m in metrics:\n        for t in train:\n            for v in valid:\n                if t and v:\n                    continue\n                cm = gbm_bin.confusion_matrix(metrics=m, train=t, valid=v)\n                if cm:\n                    cm = cm.to_list()\n                    dim_check(cm, m, t, v)\n                    type_check(cm, m, t, v)\n                    count_check(cm, m, t, v)\n    for x in range(10):\n        for t in train:\n            for v in valid:\n                if t and v:\n                    continue\n                thresholds = [gbm_bin.find_threshold_by_max_metric(m, t, v) for m in random.sample(metrics, random.randint(1, len(metrics)))]\n                cms = gbm_bin.confusion_matrix(thresholds=thresholds, train=t, valid=v)\n                if not isinstance(cms, list):\n                    cms = [cms]\n                for (idx, cm) in enumerate(cms):\n                    cm = cm.to_list()\n                    dim_check(cm, thresholds[idx], t, v)\n                    type_check(cm, thresholds[idx], t, v)\n                    count_check(cm, thresholds[idx], t, v)\n    cm = gbm_mult.confusion_matrix(data=air_test)\n    cm_count = 0\n    for r in range(7):\n        for c in range(7):\n            cm_count += cm.cell_values[r][c]\n    assert cm_count == air_test.nrow, 'incorrect confusion matrix elements. Should sum to {0}, but got {1}'.format(air_test.nrow, cm_count)\n    bin_perf = gbm_bin.model_performance(valid=True)\n    for metric in metrics:\n        cm = bin_perf.confusion_matrix(metrics=metric).to_list()\n        dim_check(cm, metric, False, True)\n        type_check(cm, metric, False, True)\n        count_check(cm, metric, False, True)\n    bin_perf = gbm_bin.model_performance(train=True)\n    for x in range(10):\n        thresholds = [gbm_bin.find_threshold_by_max_metric(m, t, v) for m in random.sample(metrics, random.randint(1, len(metrics)))]\n        cms = bin_perf.confusion_matrix(thresholds=thresholds)\n        if not isinstance(cms, list):\n            cms = [cms]\n        for (idx, cm) in enumerate(cms):\n            cm = cm.to_list()\n            dim_check(cm, thresholds[idx], True, False)\n            type_check(cm, thresholds[idx], True, False)\n            count_check(cm, thresholds[idx], True, False)\n    mult_perf = gbm_mult.model_performance(valid=True)\n    cm = mult_perf.confusion_matrix()\n    cm_count = 0\n    for r in range(7):\n        for c in range(7):\n            cm_count += cm.cell_values[r][c]\n    assert cm_count == air_test.nrow, 'incorrect confusion matrix elements. Should sum to {0}, but got {1}'.format(air_test.nrow, cm_count)",
            "def all_confusion_matrix_funcs():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    metrics = ['recall', 'specificity', 'min_per_class_accuracy', 'absolute_mcc', 'precision', 'accuracy', 'f0point5', 'f2', 'f1', 'mean_per_class_accuracy']\n    train = [True, False]\n    valid = [True, False]\n    print('PARSING TRAINING DATA')\n    air_train = h2o.import_file(path=pyunit_utils.locate('smalldata/airlines/AirlinesTrain.csv.zip'))\n    air_train['IsDepDelayed'] = air_train['IsDepDelayed'].asfactor()\n    print('PARSING TESTING DATA')\n    air_test = h2o.import_file(path=pyunit_utils.locate('smalldata/airlines/AirlinesTest.csv.zip'))\n    air_test['IsDepDelayed'] = air_test['IsDepDelayed'].asfactor()\n    print()\n    print('RUNNING FIRST GBM: ')\n    print()\n    gbm_bin = H2OGradientBoostingEstimator(distribution='bernoulli')\n    gbm_bin.train(x=['Origin', 'Dest', 'Distance', 'UniqueCarrier', 'fMonth', 'fDayofMonth', 'fDayOfWeek'], y='IsDepDelayed', training_frame=air_train, validation_frame=air_test)\n    print()\n    print('RUNNING SECOND GBM: ')\n    print()\n    air_train['fDayOfWeek'] = air_train['fDayOfWeek'].asfactor()\n    air_test['fDayOfWeek'] = air_test['fDayOfWeek'].asfactor()\n    gbm_mult = H2OGradientBoostingEstimator(distribution='multinomial')\n    gbm_mult.train(x=['Origin', 'Dest', 'Distance', 'UniqueCarrier', 'IsDepDelayed', 'fDayofMonth', 'fMonth'], y='fDayOfWeek', training_frame=air_train, validation_frame=air_test)\n\n    def dim_check(cm, m, t, v):\n        assert len(cm) == 2 and len(cm[0]) == 2 and (len(cm[1]) == 2), 'incorrect confusion matrix dimensions for metric/thresh: {0}, train: {1}, valid: {2}'.format(m, t, v)\n\n    def type_check(cm, m, t, v):\n        assert isinstance(cm[0][0], (int, float)) and isinstance(cm[0][1], (int, float)) and isinstance(cm[1][0], (int, float)) and isinstance(cm[0][0], (int, float)), 'confusion matrix entries should be integers or floats but got {0}, {1}, {2}, {3}. metric/thresh: {4}, train: {5}, valid: {6}'.format(type(cm[0][0]), type(cm[0][1]), type(cm[1][0]), type(cm[1][1]), m, t, v)\n\n    def count_check(cm, m, t, v):\n        if v:\n            assert cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1] == air_test.nrow, 'incorrect confusion matrix elements: {0}, {1}, {2}, {3}. Should sum to {4}. metric/thresh: {5}, train: {6}, valid: {7}'.format(cm[0][0], cm[0][1], cm[1][0], cm[1][1], air_test.nrow, m, t, v)\n        else:\n            assert cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1] == air_train.nrow, 'incorrect confusion matrix elements: {0}, {1}, {2}, {3}. Should sum to {4}. metric/thresh: {5}, train: {6}, valid: {7}'.format(cm[0][0], cm[0][1], cm[1][0], cm[1][1], air_train.nrow, m, t, v)\n    for m in metrics:\n        for t in train:\n            for v in valid:\n                if t and v:\n                    continue\n                cm = gbm_bin.confusion_matrix(metrics=m, train=t, valid=v)\n                if cm:\n                    cm = cm.to_list()\n                    dim_check(cm, m, t, v)\n                    type_check(cm, m, t, v)\n                    count_check(cm, m, t, v)\n    for x in range(10):\n        for t in train:\n            for v in valid:\n                if t and v:\n                    continue\n                thresholds = [gbm_bin.find_threshold_by_max_metric(m, t, v) for m in random.sample(metrics, random.randint(1, len(metrics)))]\n                cms = gbm_bin.confusion_matrix(thresholds=thresholds, train=t, valid=v)\n                if not isinstance(cms, list):\n                    cms = [cms]\n                for (idx, cm) in enumerate(cms):\n                    cm = cm.to_list()\n                    dim_check(cm, thresholds[idx], t, v)\n                    type_check(cm, thresholds[idx], t, v)\n                    count_check(cm, thresholds[idx], t, v)\n    cm = gbm_mult.confusion_matrix(data=air_test)\n    cm_count = 0\n    for r in range(7):\n        for c in range(7):\n            cm_count += cm.cell_values[r][c]\n    assert cm_count == air_test.nrow, 'incorrect confusion matrix elements. Should sum to {0}, but got {1}'.format(air_test.nrow, cm_count)\n    bin_perf = gbm_bin.model_performance(valid=True)\n    for metric in metrics:\n        cm = bin_perf.confusion_matrix(metrics=metric).to_list()\n        dim_check(cm, metric, False, True)\n        type_check(cm, metric, False, True)\n        count_check(cm, metric, False, True)\n    bin_perf = gbm_bin.model_performance(train=True)\n    for x in range(10):\n        thresholds = [gbm_bin.find_threshold_by_max_metric(m, t, v) for m in random.sample(metrics, random.randint(1, len(metrics)))]\n        cms = bin_perf.confusion_matrix(thresholds=thresholds)\n        if not isinstance(cms, list):\n            cms = [cms]\n        for (idx, cm) in enumerate(cms):\n            cm = cm.to_list()\n            dim_check(cm, thresholds[idx], True, False)\n            type_check(cm, thresholds[idx], True, False)\n            count_check(cm, thresholds[idx], True, False)\n    mult_perf = gbm_mult.model_performance(valid=True)\n    cm = mult_perf.confusion_matrix()\n    cm_count = 0\n    for r in range(7):\n        for c in range(7):\n            cm_count += cm.cell_values[r][c]\n    assert cm_count == air_test.nrow, 'incorrect confusion matrix elements. Should sum to {0}, but got {1}'.format(air_test.nrow, cm_count)",
            "def all_confusion_matrix_funcs():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    metrics = ['recall', 'specificity', 'min_per_class_accuracy', 'absolute_mcc', 'precision', 'accuracy', 'f0point5', 'f2', 'f1', 'mean_per_class_accuracy']\n    train = [True, False]\n    valid = [True, False]\n    print('PARSING TRAINING DATA')\n    air_train = h2o.import_file(path=pyunit_utils.locate('smalldata/airlines/AirlinesTrain.csv.zip'))\n    air_train['IsDepDelayed'] = air_train['IsDepDelayed'].asfactor()\n    print('PARSING TESTING DATA')\n    air_test = h2o.import_file(path=pyunit_utils.locate('smalldata/airlines/AirlinesTest.csv.zip'))\n    air_test['IsDepDelayed'] = air_test['IsDepDelayed'].asfactor()\n    print()\n    print('RUNNING FIRST GBM: ')\n    print()\n    gbm_bin = H2OGradientBoostingEstimator(distribution='bernoulli')\n    gbm_bin.train(x=['Origin', 'Dest', 'Distance', 'UniqueCarrier', 'fMonth', 'fDayofMonth', 'fDayOfWeek'], y='IsDepDelayed', training_frame=air_train, validation_frame=air_test)\n    print()\n    print('RUNNING SECOND GBM: ')\n    print()\n    air_train['fDayOfWeek'] = air_train['fDayOfWeek'].asfactor()\n    air_test['fDayOfWeek'] = air_test['fDayOfWeek'].asfactor()\n    gbm_mult = H2OGradientBoostingEstimator(distribution='multinomial')\n    gbm_mult.train(x=['Origin', 'Dest', 'Distance', 'UniqueCarrier', 'IsDepDelayed', 'fDayofMonth', 'fMonth'], y='fDayOfWeek', training_frame=air_train, validation_frame=air_test)\n\n    def dim_check(cm, m, t, v):\n        assert len(cm) == 2 and len(cm[0]) == 2 and (len(cm[1]) == 2), 'incorrect confusion matrix dimensions for metric/thresh: {0}, train: {1}, valid: {2}'.format(m, t, v)\n\n    def type_check(cm, m, t, v):\n        assert isinstance(cm[0][0], (int, float)) and isinstance(cm[0][1], (int, float)) and isinstance(cm[1][0], (int, float)) and isinstance(cm[0][0], (int, float)), 'confusion matrix entries should be integers or floats but got {0}, {1}, {2}, {3}. metric/thresh: {4}, train: {5}, valid: {6}'.format(type(cm[0][0]), type(cm[0][1]), type(cm[1][0]), type(cm[1][1]), m, t, v)\n\n    def count_check(cm, m, t, v):\n        if v:\n            assert cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1] == air_test.nrow, 'incorrect confusion matrix elements: {0}, {1}, {2}, {3}. Should sum to {4}. metric/thresh: {5}, train: {6}, valid: {7}'.format(cm[0][0], cm[0][1], cm[1][0], cm[1][1], air_test.nrow, m, t, v)\n        else:\n            assert cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1] == air_train.nrow, 'incorrect confusion matrix elements: {0}, {1}, {2}, {3}. Should sum to {4}. metric/thresh: {5}, train: {6}, valid: {7}'.format(cm[0][0], cm[0][1], cm[1][0], cm[1][1], air_train.nrow, m, t, v)\n    for m in metrics:\n        for t in train:\n            for v in valid:\n                if t and v:\n                    continue\n                cm = gbm_bin.confusion_matrix(metrics=m, train=t, valid=v)\n                if cm:\n                    cm = cm.to_list()\n                    dim_check(cm, m, t, v)\n                    type_check(cm, m, t, v)\n                    count_check(cm, m, t, v)\n    for x in range(10):\n        for t in train:\n            for v in valid:\n                if t and v:\n                    continue\n                thresholds = [gbm_bin.find_threshold_by_max_metric(m, t, v) for m in random.sample(metrics, random.randint(1, len(metrics)))]\n                cms = gbm_bin.confusion_matrix(thresholds=thresholds, train=t, valid=v)\n                if not isinstance(cms, list):\n                    cms = [cms]\n                for (idx, cm) in enumerate(cms):\n                    cm = cm.to_list()\n                    dim_check(cm, thresholds[idx], t, v)\n                    type_check(cm, thresholds[idx], t, v)\n                    count_check(cm, thresholds[idx], t, v)\n    cm = gbm_mult.confusion_matrix(data=air_test)\n    cm_count = 0\n    for r in range(7):\n        for c in range(7):\n            cm_count += cm.cell_values[r][c]\n    assert cm_count == air_test.nrow, 'incorrect confusion matrix elements. Should sum to {0}, but got {1}'.format(air_test.nrow, cm_count)\n    bin_perf = gbm_bin.model_performance(valid=True)\n    for metric in metrics:\n        cm = bin_perf.confusion_matrix(metrics=metric).to_list()\n        dim_check(cm, metric, False, True)\n        type_check(cm, metric, False, True)\n        count_check(cm, metric, False, True)\n    bin_perf = gbm_bin.model_performance(train=True)\n    for x in range(10):\n        thresholds = [gbm_bin.find_threshold_by_max_metric(m, t, v) for m in random.sample(metrics, random.randint(1, len(metrics)))]\n        cms = bin_perf.confusion_matrix(thresholds=thresholds)\n        if not isinstance(cms, list):\n            cms = [cms]\n        for (idx, cm) in enumerate(cms):\n            cm = cm.to_list()\n            dim_check(cm, thresholds[idx], True, False)\n            type_check(cm, thresholds[idx], True, False)\n            count_check(cm, thresholds[idx], True, False)\n    mult_perf = gbm_mult.model_performance(valid=True)\n    cm = mult_perf.confusion_matrix()\n    cm_count = 0\n    for r in range(7):\n        for c in range(7):\n            cm_count += cm.cell_values[r][c]\n    assert cm_count == air_test.nrow, 'incorrect confusion matrix elements. Should sum to {0}, but got {1}'.format(air_test.nrow, cm_count)",
            "def all_confusion_matrix_funcs():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    metrics = ['recall', 'specificity', 'min_per_class_accuracy', 'absolute_mcc', 'precision', 'accuracy', 'f0point5', 'f2', 'f1', 'mean_per_class_accuracy']\n    train = [True, False]\n    valid = [True, False]\n    print('PARSING TRAINING DATA')\n    air_train = h2o.import_file(path=pyunit_utils.locate('smalldata/airlines/AirlinesTrain.csv.zip'))\n    air_train['IsDepDelayed'] = air_train['IsDepDelayed'].asfactor()\n    print('PARSING TESTING DATA')\n    air_test = h2o.import_file(path=pyunit_utils.locate('smalldata/airlines/AirlinesTest.csv.zip'))\n    air_test['IsDepDelayed'] = air_test['IsDepDelayed'].asfactor()\n    print()\n    print('RUNNING FIRST GBM: ')\n    print()\n    gbm_bin = H2OGradientBoostingEstimator(distribution='bernoulli')\n    gbm_bin.train(x=['Origin', 'Dest', 'Distance', 'UniqueCarrier', 'fMonth', 'fDayofMonth', 'fDayOfWeek'], y='IsDepDelayed', training_frame=air_train, validation_frame=air_test)\n    print()\n    print('RUNNING SECOND GBM: ')\n    print()\n    air_train['fDayOfWeek'] = air_train['fDayOfWeek'].asfactor()\n    air_test['fDayOfWeek'] = air_test['fDayOfWeek'].asfactor()\n    gbm_mult = H2OGradientBoostingEstimator(distribution='multinomial')\n    gbm_mult.train(x=['Origin', 'Dest', 'Distance', 'UniqueCarrier', 'IsDepDelayed', 'fDayofMonth', 'fMonth'], y='fDayOfWeek', training_frame=air_train, validation_frame=air_test)\n\n    def dim_check(cm, m, t, v):\n        assert len(cm) == 2 and len(cm[0]) == 2 and (len(cm[1]) == 2), 'incorrect confusion matrix dimensions for metric/thresh: {0}, train: {1}, valid: {2}'.format(m, t, v)\n\n    def type_check(cm, m, t, v):\n        assert isinstance(cm[0][0], (int, float)) and isinstance(cm[0][1], (int, float)) and isinstance(cm[1][0], (int, float)) and isinstance(cm[0][0], (int, float)), 'confusion matrix entries should be integers or floats but got {0}, {1}, {2}, {3}. metric/thresh: {4}, train: {5}, valid: {6}'.format(type(cm[0][0]), type(cm[0][1]), type(cm[1][0]), type(cm[1][1]), m, t, v)\n\n    def count_check(cm, m, t, v):\n        if v:\n            assert cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1] == air_test.nrow, 'incorrect confusion matrix elements: {0}, {1}, {2}, {3}. Should sum to {4}. metric/thresh: {5}, train: {6}, valid: {7}'.format(cm[0][0], cm[0][1], cm[1][0], cm[1][1], air_test.nrow, m, t, v)\n        else:\n            assert cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1] == air_train.nrow, 'incorrect confusion matrix elements: {0}, {1}, {2}, {3}. Should sum to {4}. metric/thresh: {5}, train: {6}, valid: {7}'.format(cm[0][0], cm[0][1], cm[1][0], cm[1][1], air_train.nrow, m, t, v)\n    for m in metrics:\n        for t in train:\n            for v in valid:\n                if t and v:\n                    continue\n                cm = gbm_bin.confusion_matrix(metrics=m, train=t, valid=v)\n                if cm:\n                    cm = cm.to_list()\n                    dim_check(cm, m, t, v)\n                    type_check(cm, m, t, v)\n                    count_check(cm, m, t, v)\n    for x in range(10):\n        for t in train:\n            for v in valid:\n                if t and v:\n                    continue\n                thresholds = [gbm_bin.find_threshold_by_max_metric(m, t, v) for m in random.sample(metrics, random.randint(1, len(metrics)))]\n                cms = gbm_bin.confusion_matrix(thresholds=thresholds, train=t, valid=v)\n                if not isinstance(cms, list):\n                    cms = [cms]\n                for (idx, cm) in enumerate(cms):\n                    cm = cm.to_list()\n                    dim_check(cm, thresholds[idx], t, v)\n                    type_check(cm, thresholds[idx], t, v)\n                    count_check(cm, thresholds[idx], t, v)\n    cm = gbm_mult.confusion_matrix(data=air_test)\n    cm_count = 0\n    for r in range(7):\n        for c in range(7):\n            cm_count += cm.cell_values[r][c]\n    assert cm_count == air_test.nrow, 'incorrect confusion matrix elements. Should sum to {0}, but got {1}'.format(air_test.nrow, cm_count)\n    bin_perf = gbm_bin.model_performance(valid=True)\n    for metric in metrics:\n        cm = bin_perf.confusion_matrix(metrics=metric).to_list()\n        dim_check(cm, metric, False, True)\n        type_check(cm, metric, False, True)\n        count_check(cm, metric, False, True)\n    bin_perf = gbm_bin.model_performance(train=True)\n    for x in range(10):\n        thresholds = [gbm_bin.find_threshold_by_max_metric(m, t, v) for m in random.sample(metrics, random.randint(1, len(metrics)))]\n        cms = bin_perf.confusion_matrix(thresholds=thresholds)\n        if not isinstance(cms, list):\n            cms = [cms]\n        for (idx, cm) in enumerate(cms):\n            cm = cm.to_list()\n            dim_check(cm, thresholds[idx], True, False)\n            type_check(cm, thresholds[idx], True, False)\n            count_check(cm, thresholds[idx], True, False)\n    mult_perf = gbm_mult.model_performance(valid=True)\n    cm = mult_perf.confusion_matrix()\n    cm_count = 0\n    for r in range(7):\n        for c in range(7):\n            cm_count += cm.cell_values[r][c]\n    assert cm_count == air_test.nrow, 'incorrect confusion matrix elements. Should sum to {0}, but got {1}'.format(air_test.nrow, cm_count)",
            "def all_confusion_matrix_funcs():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    metrics = ['recall', 'specificity', 'min_per_class_accuracy', 'absolute_mcc', 'precision', 'accuracy', 'f0point5', 'f2', 'f1', 'mean_per_class_accuracy']\n    train = [True, False]\n    valid = [True, False]\n    print('PARSING TRAINING DATA')\n    air_train = h2o.import_file(path=pyunit_utils.locate('smalldata/airlines/AirlinesTrain.csv.zip'))\n    air_train['IsDepDelayed'] = air_train['IsDepDelayed'].asfactor()\n    print('PARSING TESTING DATA')\n    air_test = h2o.import_file(path=pyunit_utils.locate('smalldata/airlines/AirlinesTest.csv.zip'))\n    air_test['IsDepDelayed'] = air_test['IsDepDelayed'].asfactor()\n    print()\n    print('RUNNING FIRST GBM: ')\n    print()\n    gbm_bin = H2OGradientBoostingEstimator(distribution='bernoulli')\n    gbm_bin.train(x=['Origin', 'Dest', 'Distance', 'UniqueCarrier', 'fMonth', 'fDayofMonth', 'fDayOfWeek'], y='IsDepDelayed', training_frame=air_train, validation_frame=air_test)\n    print()\n    print('RUNNING SECOND GBM: ')\n    print()\n    air_train['fDayOfWeek'] = air_train['fDayOfWeek'].asfactor()\n    air_test['fDayOfWeek'] = air_test['fDayOfWeek'].asfactor()\n    gbm_mult = H2OGradientBoostingEstimator(distribution='multinomial')\n    gbm_mult.train(x=['Origin', 'Dest', 'Distance', 'UniqueCarrier', 'IsDepDelayed', 'fDayofMonth', 'fMonth'], y='fDayOfWeek', training_frame=air_train, validation_frame=air_test)\n\n    def dim_check(cm, m, t, v):\n        assert len(cm) == 2 and len(cm[0]) == 2 and (len(cm[1]) == 2), 'incorrect confusion matrix dimensions for metric/thresh: {0}, train: {1}, valid: {2}'.format(m, t, v)\n\n    def type_check(cm, m, t, v):\n        assert isinstance(cm[0][0], (int, float)) and isinstance(cm[0][1], (int, float)) and isinstance(cm[1][0], (int, float)) and isinstance(cm[0][0], (int, float)), 'confusion matrix entries should be integers or floats but got {0}, {1}, {2}, {3}. metric/thresh: {4}, train: {5}, valid: {6}'.format(type(cm[0][0]), type(cm[0][1]), type(cm[1][0]), type(cm[1][1]), m, t, v)\n\n    def count_check(cm, m, t, v):\n        if v:\n            assert cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1] == air_test.nrow, 'incorrect confusion matrix elements: {0}, {1}, {2}, {3}. Should sum to {4}. metric/thresh: {5}, train: {6}, valid: {7}'.format(cm[0][0], cm[0][1], cm[1][0], cm[1][1], air_test.nrow, m, t, v)\n        else:\n            assert cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1] == air_train.nrow, 'incorrect confusion matrix elements: {0}, {1}, {2}, {3}. Should sum to {4}. metric/thresh: {5}, train: {6}, valid: {7}'.format(cm[0][0], cm[0][1], cm[1][0], cm[1][1], air_train.nrow, m, t, v)\n    for m in metrics:\n        for t in train:\n            for v in valid:\n                if t and v:\n                    continue\n                cm = gbm_bin.confusion_matrix(metrics=m, train=t, valid=v)\n                if cm:\n                    cm = cm.to_list()\n                    dim_check(cm, m, t, v)\n                    type_check(cm, m, t, v)\n                    count_check(cm, m, t, v)\n    for x in range(10):\n        for t in train:\n            for v in valid:\n                if t and v:\n                    continue\n                thresholds = [gbm_bin.find_threshold_by_max_metric(m, t, v) for m in random.sample(metrics, random.randint(1, len(metrics)))]\n                cms = gbm_bin.confusion_matrix(thresholds=thresholds, train=t, valid=v)\n                if not isinstance(cms, list):\n                    cms = [cms]\n                for (idx, cm) in enumerate(cms):\n                    cm = cm.to_list()\n                    dim_check(cm, thresholds[idx], t, v)\n                    type_check(cm, thresholds[idx], t, v)\n                    count_check(cm, thresholds[idx], t, v)\n    cm = gbm_mult.confusion_matrix(data=air_test)\n    cm_count = 0\n    for r in range(7):\n        for c in range(7):\n            cm_count += cm.cell_values[r][c]\n    assert cm_count == air_test.nrow, 'incorrect confusion matrix elements. Should sum to {0}, but got {1}'.format(air_test.nrow, cm_count)\n    bin_perf = gbm_bin.model_performance(valid=True)\n    for metric in metrics:\n        cm = bin_perf.confusion_matrix(metrics=metric).to_list()\n        dim_check(cm, metric, False, True)\n        type_check(cm, metric, False, True)\n        count_check(cm, metric, False, True)\n    bin_perf = gbm_bin.model_performance(train=True)\n    for x in range(10):\n        thresholds = [gbm_bin.find_threshold_by_max_metric(m, t, v) for m in random.sample(metrics, random.randint(1, len(metrics)))]\n        cms = bin_perf.confusion_matrix(thresholds=thresholds)\n        if not isinstance(cms, list):\n            cms = [cms]\n        for (idx, cm) in enumerate(cms):\n            cm = cm.to_list()\n            dim_check(cm, thresholds[idx], True, False)\n            type_check(cm, thresholds[idx], True, False)\n            count_check(cm, thresholds[idx], True, False)\n    mult_perf = gbm_mult.model_performance(valid=True)\n    cm = mult_perf.confusion_matrix()\n    cm_count = 0\n    for r in range(7):\n        for c in range(7):\n            cm_count += cm.cell_values[r][c]\n    assert cm_count == air_test.nrow, 'incorrect confusion matrix elements. Should sum to {0}, but got {1}'.format(air_test.nrow, cm_count)"
        ]
    }
]