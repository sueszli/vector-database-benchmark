[
    {
        "func_name": "efficiency",
        "original": "@not_implemented_for('directed')\n@nx._dispatch\ndef efficiency(G, u, v):\n    \"\"\"Returns the efficiency of a pair of nodes in a graph.\n\n    The *efficiency* of a pair of nodes is the multiplicative inverse of the\n    shortest path distance between the nodes [1]_. Returns 0 if no path\n    between nodes.\n\n    Parameters\n    ----------\n    G : :class:`networkx.Graph`\n        An undirected graph for which to compute the average local efficiency.\n    u, v : node\n        Nodes in the graph ``G``.\n\n    Returns\n    -------\n    float\n        Multiplicative inverse of the shortest path distance between the nodes.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\n    >>> nx.efficiency(G, 2, 3)  # this gives efficiency for node 2 and 3\n    0.5\n\n    Notes\n    -----\n    Edge weights are ignored when computing the shortest path distances.\n\n    See also\n    --------\n    local_efficiency\n    global_efficiency\n\n    References\n    ----------\n    .. [1] Latora, Vito, and Massimo Marchiori.\n           \"Efficient behavior of small-world networks.\"\n           *Physical Review Letters* 87.19 (2001): 198701.\n           <https://doi.org/10.1103/PhysRevLett.87.198701>\n\n    \"\"\"\n    try:\n        eff = 1 / nx.shortest_path_length(G, u, v)\n    except NetworkXNoPath:\n        eff = 0\n    return eff",
        "mutated": [
            "@not_implemented_for('directed')\n@nx._dispatch\ndef efficiency(G, u, v):\n    if False:\n        i = 10\n    'Returns the efficiency of a pair of nodes in a graph.\\n\\n    The *efficiency* of a pair of nodes is the multiplicative inverse of the\\n    shortest path distance between the nodes [1]_. Returns 0 if no path\\n    between nodes.\\n\\n    Parameters\\n    ----------\\n    G : :class:`networkx.Graph`\\n        An undirected graph for which to compute the average local efficiency.\\n    u, v : node\\n        Nodes in the graph ``G``.\\n\\n    Returns\\n    -------\\n    float\\n        Multiplicative inverse of the shortest path distance between the nodes.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\\n    >>> nx.efficiency(G, 2, 3)  # this gives efficiency for node 2 and 3\\n    0.5\\n\\n    Notes\\n    -----\\n    Edge weights are ignored when computing the shortest path distances.\\n\\n    See also\\n    --------\\n    local_efficiency\\n    global_efficiency\\n\\n    References\\n    ----------\\n    .. [1] Latora, Vito, and Massimo Marchiori.\\n           \"Efficient behavior of small-world networks.\"\\n           *Physical Review Letters* 87.19 (2001): 198701.\\n           <https://doi.org/10.1103/PhysRevLett.87.198701>\\n\\n    '\n    try:\n        eff = 1 / nx.shortest_path_length(G, u, v)\n    except NetworkXNoPath:\n        eff = 0\n    return eff",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef efficiency(G, u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the efficiency of a pair of nodes in a graph.\\n\\n    The *efficiency* of a pair of nodes is the multiplicative inverse of the\\n    shortest path distance between the nodes [1]_. Returns 0 if no path\\n    between nodes.\\n\\n    Parameters\\n    ----------\\n    G : :class:`networkx.Graph`\\n        An undirected graph for which to compute the average local efficiency.\\n    u, v : node\\n        Nodes in the graph ``G``.\\n\\n    Returns\\n    -------\\n    float\\n        Multiplicative inverse of the shortest path distance between the nodes.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\\n    >>> nx.efficiency(G, 2, 3)  # this gives efficiency for node 2 and 3\\n    0.5\\n\\n    Notes\\n    -----\\n    Edge weights are ignored when computing the shortest path distances.\\n\\n    See also\\n    --------\\n    local_efficiency\\n    global_efficiency\\n\\n    References\\n    ----------\\n    .. [1] Latora, Vito, and Massimo Marchiori.\\n           \"Efficient behavior of small-world networks.\"\\n           *Physical Review Letters* 87.19 (2001): 198701.\\n           <https://doi.org/10.1103/PhysRevLett.87.198701>\\n\\n    '\n    try:\n        eff = 1 / nx.shortest_path_length(G, u, v)\n    except NetworkXNoPath:\n        eff = 0\n    return eff",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef efficiency(G, u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the efficiency of a pair of nodes in a graph.\\n\\n    The *efficiency* of a pair of nodes is the multiplicative inverse of the\\n    shortest path distance between the nodes [1]_. Returns 0 if no path\\n    between nodes.\\n\\n    Parameters\\n    ----------\\n    G : :class:`networkx.Graph`\\n        An undirected graph for which to compute the average local efficiency.\\n    u, v : node\\n        Nodes in the graph ``G``.\\n\\n    Returns\\n    -------\\n    float\\n        Multiplicative inverse of the shortest path distance between the nodes.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\\n    >>> nx.efficiency(G, 2, 3)  # this gives efficiency for node 2 and 3\\n    0.5\\n\\n    Notes\\n    -----\\n    Edge weights are ignored when computing the shortest path distances.\\n\\n    See also\\n    --------\\n    local_efficiency\\n    global_efficiency\\n\\n    References\\n    ----------\\n    .. [1] Latora, Vito, and Massimo Marchiori.\\n           \"Efficient behavior of small-world networks.\"\\n           *Physical Review Letters* 87.19 (2001): 198701.\\n           <https://doi.org/10.1103/PhysRevLett.87.198701>\\n\\n    '\n    try:\n        eff = 1 / nx.shortest_path_length(G, u, v)\n    except NetworkXNoPath:\n        eff = 0\n    return eff",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef efficiency(G, u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the efficiency of a pair of nodes in a graph.\\n\\n    The *efficiency* of a pair of nodes is the multiplicative inverse of the\\n    shortest path distance between the nodes [1]_. Returns 0 if no path\\n    between nodes.\\n\\n    Parameters\\n    ----------\\n    G : :class:`networkx.Graph`\\n        An undirected graph for which to compute the average local efficiency.\\n    u, v : node\\n        Nodes in the graph ``G``.\\n\\n    Returns\\n    -------\\n    float\\n        Multiplicative inverse of the shortest path distance between the nodes.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\\n    >>> nx.efficiency(G, 2, 3)  # this gives efficiency for node 2 and 3\\n    0.5\\n\\n    Notes\\n    -----\\n    Edge weights are ignored when computing the shortest path distances.\\n\\n    See also\\n    --------\\n    local_efficiency\\n    global_efficiency\\n\\n    References\\n    ----------\\n    .. [1] Latora, Vito, and Massimo Marchiori.\\n           \"Efficient behavior of small-world networks.\"\\n           *Physical Review Letters* 87.19 (2001): 198701.\\n           <https://doi.org/10.1103/PhysRevLett.87.198701>\\n\\n    '\n    try:\n        eff = 1 / nx.shortest_path_length(G, u, v)\n    except NetworkXNoPath:\n        eff = 0\n    return eff",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef efficiency(G, u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the efficiency of a pair of nodes in a graph.\\n\\n    The *efficiency* of a pair of nodes is the multiplicative inverse of the\\n    shortest path distance between the nodes [1]_. Returns 0 if no path\\n    between nodes.\\n\\n    Parameters\\n    ----------\\n    G : :class:`networkx.Graph`\\n        An undirected graph for which to compute the average local efficiency.\\n    u, v : node\\n        Nodes in the graph ``G``.\\n\\n    Returns\\n    -------\\n    float\\n        Multiplicative inverse of the shortest path distance between the nodes.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\\n    >>> nx.efficiency(G, 2, 3)  # this gives efficiency for node 2 and 3\\n    0.5\\n\\n    Notes\\n    -----\\n    Edge weights are ignored when computing the shortest path distances.\\n\\n    See also\\n    --------\\n    local_efficiency\\n    global_efficiency\\n\\n    References\\n    ----------\\n    .. [1] Latora, Vito, and Massimo Marchiori.\\n           \"Efficient behavior of small-world networks.\"\\n           *Physical Review Letters* 87.19 (2001): 198701.\\n           <https://doi.org/10.1103/PhysRevLett.87.198701>\\n\\n    '\n    try:\n        eff = 1 / nx.shortest_path_length(G, u, v)\n    except NetworkXNoPath:\n        eff = 0\n    return eff"
        ]
    },
    {
        "func_name": "global_efficiency",
        "original": "@not_implemented_for('directed')\n@nx._dispatch\ndef global_efficiency(G):\n    \"\"\"Returns the average global efficiency of the graph.\n\n    The *efficiency* of a pair of nodes in a graph is the multiplicative\n    inverse of the shortest path distance between the nodes. The *average\n    global efficiency* of a graph is the average efficiency of all pairs of\n    nodes [1]_.\n\n    Parameters\n    ----------\n    G : :class:`networkx.Graph`\n        An undirected graph for which to compute the average global efficiency.\n\n    Returns\n    -------\n    float\n        The average global efficiency of the graph.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\n    >>> round(nx.global_efficiency(G), 12)\n    0.916666666667\n\n    Notes\n    -----\n    Edge weights are ignored when computing the shortest path distances.\n\n    See also\n    --------\n    local_efficiency\n\n    References\n    ----------\n    .. [1] Latora, Vito, and Massimo Marchiori.\n           \"Efficient behavior of small-world networks.\"\n           *Physical Review Letters* 87.19 (2001): 198701.\n           <https://doi.org/10.1103/PhysRevLett.87.198701>\n\n    \"\"\"\n    n = len(G)\n    denom = n * (n - 1)\n    if denom != 0:\n        lengths = nx.all_pairs_shortest_path_length(G)\n        g_eff = 0\n        for (source, targets) in lengths:\n            for (target, distance) in targets.items():\n                if distance > 0:\n                    g_eff += 1 / distance\n        g_eff /= denom\n    else:\n        g_eff = 0\n    return g_eff",
        "mutated": [
            "@not_implemented_for('directed')\n@nx._dispatch\ndef global_efficiency(G):\n    if False:\n        i = 10\n    'Returns the average global efficiency of the graph.\\n\\n    The *efficiency* of a pair of nodes in a graph is the multiplicative\\n    inverse of the shortest path distance between the nodes. The *average\\n    global efficiency* of a graph is the average efficiency of all pairs of\\n    nodes [1]_.\\n\\n    Parameters\\n    ----------\\n    G : :class:`networkx.Graph`\\n        An undirected graph for which to compute the average global efficiency.\\n\\n    Returns\\n    -------\\n    float\\n        The average global efficiency of the graph.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\\n    >>> round(nx.global_efficiency(G), 12)\\n    0.916666666667\\n\\n    Notes\\n    -----\\n    Edge weights are ignored when computing the shortest path distances.\\n\\n    See also\\n    --------\\n    local_efficiency\\n\\n    References\\n    ----------\\n    .. [1] Latora, Vito, and Massimo Marchiori.\\n           \"Efficient behavior of small-world networks.\"\\n           *Physical Review Letters* 87.19 (2001): 198701.\\n           <https://doi.org/10.1103/PhysRevLett.87.198701>\\n\\n    '\n    n = len(G)\n    denom = n * (n - 1)\n    if denom != 0:\n        lengths = nx.all_pairs_shortest_path_length(G)\n        g_eff = 0\n        for (source, targets) in lengths:\n            for (target, distance) in targets.items():\n                if distance > 0:\n                    g_eff += 1 / distance\n        g_eff /= denom\n    else:\n        g_eff = 0\n    return g_eff",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef global_efficiency(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the average global efficiency of the graph.\\n\\n    The *efficiency* of a pair of nodes in a graph is the multiplicative\\n    inverse of the shortest path distance between the nodes. The *average\\n    global efficiency* of a graph is the average efficiency of all pairs of\\n    nodes [1]_.\\n\\n    Parameters\\n    ----------\\n    G : :class:`networkx.Graph`\\n        An undirected graph for which to compute the average global efficiency.\\n\\n    Returns\\n    -------\\n    float\\n        The average global efficiency of the graph.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\\n    >>> round(nx.global_efficiency(G), 12)\\n    0.916666666667\\n\\n    Notes\\n    -----\\n    Edge weights are ignored when computing the shortest path distances.\\n\\n    See also\\n    --------\\n    local_efficiency\\n\\n    References\\n    ----------\\n    .. [1] Latora, Vito, and Massimo Marchiori.\\n           \"Efficient behavior of small-world networks.\"\\n           *Physical Review Letters* 87.19 (2001): 198701.\\n           <https://doi.org/10.1103/PhysRevLett.87.198701>\\n\\n    '\n    n = len(G)\n    denom = n * (n - 1)\n    if denom != 0:\n        lengths = nx.all_pairs_shortest_path_length(G)\n        g_eff = 0\n        for (source, targets) in lengths:\n            for (target, distance) in targets.items():\n                if distance > 0:\n                    g_eff += 1 / distance\n        g_eff /= denom\n    else:\n        g_eff = 0\n    return g_eff",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef global_efficiency(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the average global efficiency of the graph.\\n\\n    The *efficiency* of a pair of nodes in a graph is the multiplicative\\n    inverse of the shortest path distance between the nodes. The *average\\n    global efficiency* of a graph is the average efficiency of all pairs of\\n    nodes [1]_.\\n\\n    Parameters\\n    ----------\\n    G : :class:`networkx.Graph`\\n        An undirected graph for which to compute the average global efficiency.\\n\\n    Returns\\n    -------\\n    float\\n        The average global efficiency of the graph.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\\n    >>> round(nx.global_efficiency(G), 12)\\n    0.916666666667\\n\\n    Notes\\n    -----\\n    Edge weights are ignored when computing the shortest path distances.\\n\\n    See also\\n    --------\\n    local_efficiency\\n\\n    References\\n    ----------\\n    .. [1] Latora, Vito, and Massimo Marchiori.\\n           \"Efficient behavior of small-world networks.\"\\n           *Physical Review Letters* 87.19 (2001): 198701.\\n           <https://doi.org/10.1103/PhysRevLett.87.198701>\\n\\n    '\n    n = len(G)\n    denom = n * (n - 1)\n    if denom != 0:\n        lengths = nx.all_pairs_shortest_path_length(G)\n        g_eff = 0\n        for (source, targets) in lengths:\n            for (target, distance) in targets.items():\n                if distance > 0:\n                    g_eff += 1 / distance\n        g_eff /= denom\n    else:\n        g_eff = 0\n    return g_eff",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef global_efficiency(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the average global efficiency of the graph.\\n\\n    The *efficiency* of a pair of nodes in a graph is the multiplicative\\n    inverse of the shortest path distance between the nodes. The *average\\n    global efficiency* of a graph is the average efficiency of all pairs of\\n    nodes [1]_.\\n\\n    Parameters\\n    ----------\\n    G : :class:`networkx.Graph`\\n        An undirected graph for which to compute the average global efficiency.\\n\\n    Returns\\n    -------\\n    float\\n        The average global efficiency of the graph.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\\n    >>> round(nx.global_efficiency(G), 12)\\n    0.916666666667\\n\\n    Notes\\n    -----\\n    Edge weights are ignored when computing the shortest path distances.\\n\\n    See also\\n    --------\\n    local_efficiency\\n\\n    References\\n    ----------\\n    .. [1] Latora, Vito, and Massimo Marchiori.\\n           \"Efficient behavior of small-world networks.\"\\n           *Physical Review Letters* 87.19 (2001): 198701.\\n           <https://doi.org/10.1103/PhysRevLett.87.198701>\\n\\n    '\n    n = len(G)\n    denom = n * (n - 1)\n    if denom != 0:\n        lengths = nx.all_pairs_shortest_path_length(G)\n        g_eff = 0\n        for (source, targets) in lengths:\n            for (target, distance) in targets.items():\n                if distance > 0:\n                    g_eff += 1 / distance\n        g_eff /= denom\n    else:\n        g_eff = 0\n    return g_eff",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef global_efficiency(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the average global efficiency of the graph.\\n\\n    The *efficiency* of a pair of nodes in a graph is the multiplicative\\n    inverse of the shortest path distance between the nodes. The *average\\n    global efficiency* of a graph is the average efficiency of all pairs of\\n    nodes [1]_.\\n\\n    Parameters\\n    ----------\\n    G : :class:`networkx.Graph`\\n        An undirected graph for which to compute the average global efficiency.\\n\\n    Returns\\n    -------\\n    float\\n        The average global efficiency of the graph.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\\n    >>> round(nx.global_efficiency(G), 12)\\n    0.916666666667\\n\\n    Notes\\n    -----\\n    Edge weights are ignored when computing the shortest path distances.\\n\\n    See also\\n    --------\\n    local_efficiency\\n\\n    References\\n    ----------\\n    .. [1] Latora, Vito, and Massimo Marchiori.\\n           \"Efficient behavior of small-world networks.\"\\n           *Physical Review Letters* 87.19 (2001): 198701.\\n           <https://doi.org/10.1103/PhysRevLett.87.198701>\\n\\n    '\n    n = len(G)\n    denom = n * (n - 1)\n    if denom != 0:\n        lengths = nx.all_pairs_shortest_path_length(G)\n        g_eff = 0\n        for (source, targets) in lengths:\n            for (target, distance) in targets.items():\n                if distance > 0:\n                    g_eff += 1 / distance\n        g_eff /= denom\n    else:\n        g_eff = 0\n    return g_eff"
        ]
    },
    {
        "func_name": "local_efficiency",
        "original": "@not_implemented_for('directed')\n@nx._dispatch\ndef local_efficiency(G):\n    \"\"\"Returns the average local efficiency of the graph.\n\n    The *efficiency* of a pair of nodes in a graph is the multiplicative\n    inverse of the shortest path distance between the nodes. The *local\n    efficiency* of a node in the graph is the average global efficiency of the\n    subgraph induced by the neighbors of the node. The *average local\n    efficiency* is the average of the local efficiencies of each node [1]_.\n\n    Parameters\n    ----------\n    G : :class:`networkx.Graph`\n        An undirected graph for which to compute the average local efficiency.\n\n    Returns\n    -------\n    float\n        The average local efficiency of the graph.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\n    >>> nx.local_efficiency(G)\n    0.9166666666666667\n\n    Notes\n    -----\n    Edge weights are ignored when computing the shortest path distances.\n\n    See also\n    --------\n    global_efficiency\n\n    References\n    ----------\n    .. [1] Latora, Vito, and Massimo Marchiori.\n           \"Efficient behavior of small-world networks.\"\n           *Physical Review Letters* 87.19 (2001): 198701.\n           <https://doi.org/10.1103/PhysRevLett.87.198701>\n\n    \"\"\"\n    efficiency_list = (global_efficiency(G.subgraph(G[v])) for v in G)\n    return sum(efficiency_list) / len(G)",
        "mutated": [
            "@not_implemented_for('directed')\n@nx._dispatch\ndef local_efficiency(G):\n    if False:\n        i = 10\n    'Returns the average local efficiency of the graph.\\n\\n    The *efficiency* of a pair of nodes in a graph is the multiplicative\\n    inverse of the shortest path distance between the nodes. The *local\\n    efficiency* of a node in the graph is the average global efficiency of the\\n    subgraph induced by the neighbors of the node. The *average local\\n    efficiency* is the average of the local efficiencies of each node [1]_.\\n\\n    Parameters\\n    ----------\\n    G : :class:`networkx.Graph`\\n        An undirected graph for which to compute the average local efficiency.\\n\\n    Returns\\n    -------\\n    float\\n        The average local efficiency of the graph.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\\n    >>> nx.local_efficiency(G)\\n    0.9166666666666667\\n\\n    Notes\\n    -----\\n    Edge weights are ignored when computing the shortest path distances.\\n\\n    See also\\n    --------\\n    global_efficiency\\n\\n    References\\n    ----------\\n    .. [1] Latora, Vito, and Massimo Marchiori.\\n           \"Efficient behavior of small-world networks.\"\\n           *Physical Review Letters* 87.19 (2001): 198701.\\n           <https://doi.org/10.1103/PhysRevLett.87.198701>\\n\\n    '\n    efficiency_list = (global_efficiency(G.subgraph(G[v])) for v in G)\n    return sum(efficiency_list) / len(G)",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef local_efficiency(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the average local efficiency of the graph.\\n\\n    The *efficiency* of a pair of nodes in a graph is the multiplicative\\n    inverse of the shortest path distance between the nodes. The *local\\n    efficiency* of a node in the graph is the average global efficiency of the\\n    subgraph induced by the neighbors of the node. The *average local\\n    efficiency* is the average of the local efficiencies of each node [1]_.\\n\\n    Parameters\\n    ----------\\n    G : :class:`networkx.Graph`\\n        An undirected graph for which to compute the average local efficiency.\\n\\n    Returns\\n    -------\\n    float\\n        The average local efficiency of the graph.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\\n    >>> nx.local_efficiency(G)\\n    0.9166666666666667\\n\\n    Notes\\n    -----\\n    Edge weights are ignored when computing the shortest path distances.\\n\\n    See also\\n    --------\\n    global_efficiency\\n\\n    References\\n    ----------\\n    .. [1] Latora, Vito, and Massimo Marchiori.\\n           \"Efficient behavior of small-world networks.\"\\n           *Physical Review Letters* 87.19 (2001): 198701.\\n           <https://doi.org/10.1103/PhysRevLett.87.198701>\\n\\n    '\n    efficiency_list = (global_efficiency(G.subgraph(G[v])) for v in G)\n    return sum(efficiency_list) / len(G)",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef local_efficiency(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the average local efficiency of the graph.\\n\\n    The *efficiency* of a pair of nodes in a graph is the multiplicative\\n    inverse of the shortest path distance between the nodes. The *local\\n    efficiency* of a node in the graph is the average global efficiency of the\\n    subgraph induced by the neighbors of the node. The *average local\\n    efficiency* is the average of the local efficiencies of each node [1]_.\\n\\n    Parameters\\n    ----------\\n    G : :class:`networkx.Graph`\\n        An undirected graph for which to compute the average local efficiency.\\n\\n    Returns\\n    -------\\n    float\\n        The average local efficiency of the graph.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\\n    >>> nx.local_efficiency(G)\\n    0.9166666666666667\\n\\n    Notes\\n    -----\\n    Edge weights are ignored when computing the shortest path distances.\\n\\n    See also\\n    --------\\n    global_efficiency\\n\\n    References\\n    ----------\\n    .. [1] Latora, Vito, and Massimo Marchiori.\\n           \"Efficient behavior of small-world networks.\"\\n           *Physical Review Letters* 87.19 (2001): 198701.\\n           <https://doi.org/10.1103/PhysRevLett.87.198701>\\n\\n    '\n    efficiency_list = (global_efficiency(G.subgraph(G[v])) for v in G)\n    return sum(efficiency_list) / len(G)",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef local_efficiency(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the average local efficiency of the graph.\\n\\n    The *efficiency* of a pair of nodes in a graph is the multiplicative\\n    inverse of the shortest path distance between the nodes. The *local\\n    efficiency* of a node in the graph is the average global efficiency of the\\n    subgraph induced by the neighbors of the node. The *average local\\n    efficiency* is the average of the local efficiencies of each node [1]_.\\n\\n    Parameters\\n    ----------\\n    G : :class:`networkx.Graph`\\n        An undirected graph for which to compute the average local efficiency.\\n\\n    Returns\\n    -------\\n    float\\n        The average local efficiency of the graph.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\\n    >>> nx.local_efficiency(G)\\n    0.9166666666666667\\n\\n    Notes\\n    -----\\n    Edge weights are ignored when computing the shortest path distances.\\n\\n    See also\\n    --------\\n    global_efficiency\\n\\n    References\\n    ----------\\n    .. [1] Latora, Vito, and Massimo Marchiori.\\n           \"Efficient behavior of small-world networks.\"\\n           *Physical Review Letters* 87.19 (2001): 198701.\\n           <https://doi.org/10.1103/PhysRevLett.87.198701>\\n\\n    '\n    efficiency_list = (global_efficiency(G.subgraph(G[v])) for v in G)\n    return sum(efficiency_list) / len(G)",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef local_efficiency(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the average local efficiency of the graph.\\n\\n    The *efficiency* of a pair of nodes in a graph is the multiplicative\\n    inverse of the shortest path distance between the nodes. The *local\\n    efficiency* of a node in the graph is the average global efficiency of the\\n    subgraph induced by the neighbors of the node. The *average local\\n    efficiency* is the average of the local efficiencies of each node [1]_.\\n\\n    Parameters\\n    ----------\\n    G : :class:`networkx.Graph`\\n        An undirected graph for which to compute the average local efficiency.\\n\\n    Returns\\n    -------\\n    float\\n        The average local efficiency of the graph.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\\n    >>> nx.local_efficiency(G)\\n    0.9166666666666667\\n\\n    Notes\\n    -----\\n    Edge weights are ignored when computing the shortest path distances.\\n\\n    See also\\n    --------\\n    global_efficiency\\n\\n    References\\n    ----------\\n    .. [1] Latora, Vito, and Massimo Marchiori.\\n           \"Efficient behavior of small-world networks.\"\\n           *Physical Review Letters* 87.19 (2001): 198701.\\n           <https://doi.org/10.1103/PhysRevLett.87.198701>\\n\\n    '\n    efficiency_list = (global_efficiency(G.subgraph(G[v])) for v in G)\n    return sum(efficiency_list) / len(G)"
        ]
    }
]