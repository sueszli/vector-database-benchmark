[
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    _localDir = os.path.dirname(__file__)\n    _curpath = os.path.normpath(os.path.join(os.getcwd(), _localDir))\n    curpath = _curpath\n    self.d = {}\n    print('loading dict...', file=sys.stderr)\n    with open(os.path.join(curpath, 'main.dic')) as in_file:\n        self.set([x.rstrip() for x in in_file])\n    with open(os.path.join(curpath, 'suffix.dic')) as in_file:\n        self.specialwords = set([x.rstrip().decode('utf-8') for x in in_file])\n    print('dict ok.', file=sys.stderr)",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    _localDir = os.path.dirname(__file__)\n    _curpath = os.path.normpath(os.path.join(os.getcwd(), _localDir))\n    curpath = _curpath\n    self.d = {}\n    print('loading dict...', file=sys.stderr)\n    with open(os.path.join(curpath, 'main.dic')) as in_file:\n        self.set([x.rstrip() for x in in_file])\n    with open(os.path.join(curpath, 'suffix.dic')) as in_file:\n        self.specialwords = set([x.rstrip().decode('utf-8') for x in in_file])\n    print('dict ok.', file=sys.stderr)",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    _localDir = os.path.dirname(__file__)\n    _curpath = os.path.normpath(os.path.join(os.getcwd(), _localDir))\n    curpath = _curpath\n    self.d = {}\n    print('loading dict...', file=sys.stderr)\n    with open(os.path.join(curpath, 'main.dic')) as in_file:\n        self.set([x.rstrip() for x in in_file])\n    with open(os.path.join(curpath, 'suffix.dic')) as in_file:\n        self.specialwords = set([x.rstrip().decode('utf-8') for x in in_file])\n    print('dict ok.', file=sys.stderr)",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    _localDir = os.path.dirname(__file__)\n    _curpath = os.path.normpath(os.path.join(os.getcwd(), _localDir))\n    curpath = _curpath\n    self.d = {}\n    print('loading dict...', file=sys.stderr)\n    with open(os.path.join(curpath, 'main.dic')) as in_file:\n        self.set([x.rstrip() for x in in_file])\n    with open(os.path.join(curpath, 'suffix.dic')) as in_file:\n        self.specialwords = set([x.rstrip().decode('utf-8') for x in in_file])\n    print('dict ok.', file=sys.stderr)",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    _localDir = os.path.dirname(__file__)\n    _curpath = os.path.normpath(os.path.join(os.getcwd(), _localDir))\n    curpath = _curpath\n    self.d = {}\n    print('loading dict...', file=sys.stderr)\n    with open(os.path.join(curpath, 'main.dic')) as in_file:\n        self.set([x.rstrip() for x in in_file])\n    with open(os.path.join(curpath, 'suffix.dic')) as in_file:\n        self.specialwords = set([x.rstrip().decode('utf-8') for x in in_file])\n    print('dict ok.', file=sys.stderr)",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    _localDir = os.path.dirname(__file__)\n    _curpath = os.path.normpath(os.path.join(os.getcwd(), _localDir))\n    curpath = _curpath\n    self.d = {}\n    print('loading dict...', file=sys.stderr)\n    with open(os.path.join(curpath, 'main.dic')) as in_file:\n        self.set([x.rstrip() for x in in_file])\n    with open(os.path.join(curpath, 'suffix.dic')) as in_file:\n        self.specialwords = set([x.rstrip().decode('utf-8') for x in in_file])\n    print('dict ok.', file=sys.stderr)"
        ]
    },
    {
        "func_name": "set",
        "original": "def set(self, keywords):\n    p = self.d\n    q = {}\n    k = ''\n    for word in keywords:\n        word = (chr(11) + word).decode('utf-8')\n        if len(word) > 5:\n            continue\n        p = self.d\n        ln = len(word)\n        for i in xrange(ln - 1, -1, -1):\n            char = word[i].lower()\n            if p == '':\n                q[k] = {}\n                p = q[k]\n            if not char in p:\n                p[char] = ''\n                q = p\n                k = char\n            p = p[char]",
        "mutated": [
            "def set(self, keywords):\n    if False:\n        i = 10\n    p = self.d\n    q = {}\n    k = ''\n    for word in keywords:\n        word = (chr(11) + word).decode('utf-8')\n        if len(word) > 5:\n            continue\n        p = self.d\n        ln = len(word)\n        for i in xrange(ln - 1, -1, -1):\n            char = word[i].lower()\n            if p == '':\n                q[k] = {}\n                p = q[k]\n            if not char in p:\n                p[char] = ''\n                q = p\n                k = char\n            p = p[char]",
            "def set(self, keywords):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    p = self.d\n    q = {}\n    k = ''\n    for word in keywords:\n        word = (chr(11) + word).decode('utf-8')\n        if len(word) > 5:\n            continue\n        p = self.d\n        ln = len(word)\n        for i in xrange(ln - 1, -1, -1):\n            char = word[i].lower()\n            if p == '':\n                q[k] = {}\n                p = q[k]\n            if not char in p:\n                p[char] = ''\n                q = p\n                k = char\n            p = p[char]",
            "def set(self, keywords):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    p = self.d\n    q = {}\n    k = ''\n    for word in keywords:\n        word = (chr(11) + word).decode('utf-8')\n        if len(word) > 5:\n            continue\n        p = self.d\n        ln = len(word)\n        for i in xrange(ln - 1, -1, -1):\n            char = word[i].lower()\n            if p == '':\n                q[k] = {}\n                p = q[k]\n            if not char in p:\n                p[char] = ''\n                q = p\n                k = char\n            p = p[char]",
            "def set(self, keywords):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    p = self.d\n    q = {}\n    k = ''\n    for word in keywords:\n        word = (chr(11) + word).decode('utf-8')\n        if len(word) > 5:\n            continue\n        p = self.d\n        ln = len(word)\n        for i in xrange(ln - 1, -1, -1):\n            char = word[i].lower()\n            if p == '':\n                q[k] = {}\n                p = q[k]\n            if not char in p:\n                p[char] = ''\n                q = p\n                k = char\n            p = p[char]",
            "def set(self, keywords):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    p = self.d\n    q = {}\n    k = ''\n    for word in keywords:\n        word = (chr(11) + word).decode('utf-8')\n        if len(word) > 5:\n            continue\n        p = self.d\n        ln = len(word)\n        for i in xrange(ln - 1, -1, -1):\n            char = word[i].lower()\n            if p == '':\n                q[k] = {}\n                p = q[k]\n            if not char in p:\n                p[char] = ''\n                q = p\n                k = char\n            p = p[char]"
        ]
    },
    {
        "func_name": "_binary_seg",
        "original": "def _binary_seg(self, s):\n    ln = len(s)\n    if ln == 1:\n        return [s]\n    R = []\n    for i in xrange(ln, 1, -1):\n        tmp = s[i - 2:i]\n        R.append(tmp)\n    return R",
        "mutated": [
            "def _binary_seg(self, s):\n    if False:\n        i = 10\n    ln = len(s)\n    if ln == 1:\n        return [s]\n    R = []\n    for i in xrange(ln, 1, -1):\n        tmp = s[i - 2:i]\n        R.append(tmp)\n    return R",
            "def _binary_seg(self, s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ln = len(s)\n    if ln == 1:\n        return [s]\n    R = []\n    for i in xrange(ln, 1, -1):\n        tmp = s[i - 2:i]\n        R.append(tmp)\n    return R",
            "def _binary_seg(self, s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ln = len(s)\n    if ln == 1:\n        return [s]\n    R = []\n    for i in xrange(ln, 1, -1):\n        tmp = s[i - 2:i]\n        R.append(tmp)\n    return R",
            "def _binary_seg(self, s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ln = len(s)\n    if ln == 1:\n        return [s]\n    R = []\n    for i in xrange(ln, 1, -1):\n        tmp = s[i - 2:i]\n        R.append(tmp)\n    return R",
            "def _binary_seg(self, s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ln = len(s)\n    if ln == 1:\n        return [s]\n    R = []\n    for i in xrange(ln, 1, -1):\n        tmp = s[i - 2:i]\n        R.append(tmp)\n    return R"
        ]
    },
    {
        "func_name": "_pro_unreg",
        "original": "def _pro_unreg(self, piece):\n    R = []\n    tmp = re.sub(u'\u3002|\uff0c|,|\uff01|\u2026|!|\u300a|\u300b|<|>|\"|\\'|:|\uff1a|\uff1f|\\\\?|\u3001|\\\\||\u201c|\u201d|\u2018|\u2019|\uff1b|\u2014|\uff08|\uff09|\u00b7|\\\\(|\\\\)|\\u3000', ' ', piece).split()\n    ln1 = len(tmp)\n    for i in xrange(len(tmp) - 1, -1, -1):\n        mc = re.split('([0-9A-Za-z\\\\-\\\\+#@_\\\\.]+)', tmp[i])\n        for j in xrange(len(mc) - 1, -1, -1):\n            r = mc[j]\n            if re.search('([0-9A-Za-z\\\\-\\\\+#@_\\\\.]+)', r) != None:\n                R.append(r)\n            else:\n                R.extend(self._binary_seg(r))\n    return R",
        "mutated": [
            "def _pro_unreg(self, piece):\n    if False:\n        i = 10\n    R = []\n    tmp = re.sub(u'\u3002|\uff0c|,|\uff01|\u2026|!|\u300a|\u300b|<|>|\"|\\'|:|\uff1a|\uff1f|\\\\?|\u3001|\\\\||\u201c|\u201d|\u2018|\u2019|\uff1b|\u2014|\uff08|\uff09|\u00b7|\\\\(|\\\\)|\\u3000', ' ', piece).split()\n    ln1 = len(tmp)\n    for i in xrange(len(tmp) - 1, -1, -1):\n        mc = re.split('([0-9A-Za-z\\\\-\\\\+#@_\\\\.]+)', tmp[i])\n        for j in xrange(len(mc) - 1, -1, -1):\n            r = mc[j]\n            if re.search('([0-9A-Za-z\\\\-\\\\+#@_\\\\.]+)', r) != None:\n                R.append(r)\n            else:\n                R.extend(self._binary_seg(r))\n    return R",
            "def _pro_unreg(self, piece):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    R = []\n    tmp = re.sub(u'\u3002|\uff0c|,|\uff01|\u2026|!|\u300a|\u300b|<|>|\"|\\'|:|\uff1a|\uff1f|\\\\?|\u3001|\\\\||\u201c|\u201d|\u2018|\u2019|\uff1b|\u2014|\uff08|\uff09|\u00b7|\\\\(|\\\\)|\\u3000', ' ', piece).split()\n    ln1 = len(tmp)\n    for i in xrange(len(tmp) - 1, -1, -1):\n        mc = re.split('([0-9A-Za-z\\\\-\\\\+#@_\\\\.]+)', tmp[i])\n        for j in xrange(len(mc) - 1, -1, -1):\n            r = mc[j]\n            if re.search('([0-9A-Za-z\\\\-\\\\+#@_\\\\.]+)', r) != None:\n                R.append(r)\n            else:\n                R.extend(self._binary_seg(r))\n    return R",
            "def _pro_unreg(self, piece):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    R = []\n    tmp = re.sub(u'\u3002|\uff0c|,|\uff01|\u2026|!|\u300a|\u300b|<|>|\"|\\'|:|\uff1a|\uff1f|\\\\?|\u3001|\\\\||\u201c|\u201d|\u2018|\u2019|\uff1b|\u2014|\uff08|\uff09|\u00b7|\\\\(|\\\\)|\\u3000', ' ', piece).split()\n    ln1 = len(tmp)\n    for i in xrange(len(tmp) - 1, -1, -1):\n        mc = re.split('([0-9A-Za-z\\\\-\\\\+#@_\\\\.]+)', tmp[i])\n        for j in xrange(len(mc) - 1, -1, -1):\n            r = mc[j]\n            if re.search('([0-9A-Za-z\\\\-\\\\+#@_\\\\.]+)', r) != None:\n                R.append(r)\n            else:\n                R.extend(self._binary_seg(r))\n    return R",
            "def _pro_unreg(self, piece):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    R = []\n    tmp = re.sub(u'\u3002|\uff0c|,|\uff01|\u2026|!|\u300a|\u300b|<|>|\"|\\'|:|\uff1a|\uff1f|\\\\?|\u3001|\\\\||\u201c|\u201d|\u2018|\u2019|\uff1b|\u2014|\uff08|\uff09|\u00b7|\\\\(|\\\\)|\\u3000', ' ', piece).split()\n    ln1 = len(tmp)\n    for i in xrange(len(tmp) - 1, -1, -1):\n        mc = re.split('([0-9A-Za-z\\\\-\\\\+#@_\\\\.]+)', tmp[i])\n        for j in xrange(len(mc) - 1, -1, -1):\n            r = mc[j]\n            if re.search('([0-9A-Za-z\\\\-\\\\+#@_\\\\.]+)', r) != None:\n                R.append(r)\n            else:\n                R.extend(self._binary_seg(r))\n    return R",
            "def _pro_unreg(self, piece):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    R = []\n    tmp = re.sub(u'\u3002|\uff0c|,|\uff01|\u2026|!|\u300a|\u300b|<|>|\"|\\'|:|\uff1a|\uff1f|\\\\?|\u3001|\\\\||\u201c|\u201d|\u2018|\u2019|\uff1b|\u2014|\uff08|\uff09|\u00b7|\\\\(|\\\\)|\\u3000', ' ', piece).split()\n    ln1 = len(tmp)\n    for i in xrange(len(tmp) - 1, -1, -1):\n        mc = re.split('([0-9A-Za-z\\\\-\\\\+#@_\\\\.]+)', tmp[i])\n        for j in xrange(len(mc) - 1, -1, -1):\n            r = mc[j]\n            if re.search('([0-9A-Za-z\\\\-\\\\+#@_\\\\.]+)', r) != None:\n                R.append(r)\n            else:\n                R.extend(self._binary_seg(r))\n    return R"
        ]
    },
    {
        "func_name": "cut",
        "original": "def cut(self, text):\n    \"\"\"\n        \"\"\"\n    text = text.decode('utf-8', 'ignore')\n    p = self.d\n    ln = len(text)\n    i = ln\n    j = 0\n    z = ln\n    q = 0\n    recognised = []\n    mem = None\n    mem2 = None\n    while i - j > 0:\n        t = text[i - j - 1].lower()\n        if not t in p:\n            if mem != None or mem2 != None:\n                if mem != None:\n                    (i, j, z) = mem\n                    mem = None\n                elif mem2 != None:\n                    delta = mem2[0] - i\n                    if delta >= 1:\n                        if delta < 5 and re.search(u'[\\\\w\u2e80-\\u9fff]', t) != None:\n                            pre = text[i - j]\n                            if not pre in self.specialwords:\n                                (i, j, z, q) = mem2\n                                del recognised[q:]\n                        mem2 = None\n                p = self.d\n                if i < ln and i < z:\n                    unreg_tmp = self._pro_unreg(text[i:z])\n                    recognised.extend(unreg_tmp)\n                recognised.append(text[i - j:i])\n                i = i - j\n                z = i\n                j = 0\n                continue\n            j = 0\n            i -= 1\n            p = self.d\n            continue\n        p = p[t]\n        j += 1\n        if chr(11) in p:\n            if j <= 2:\n                mem = (i, j, z)\n                if z - i < 2 and text[i - 1] in self.specialwords and (mem2 == None or (mem2 != None and mem2[0] - i > 1)):\n                    mem = None\n                    mem2 = (i, j, z, len(recognised))\n                    p = self.d\n                    i -= 1\n                    j = 0\n                continue\n            p = self.d\n            if i < ln and i < z:\n                unreg_tmp = self._pro_unreg(text[i:z])\n                recognised.extend(unreg_tmp)\n            recognised.append(text[i - j:i])\n            i = i - j\n            z = i\n            j = 0\n            mem = None\n            mem2 = None\n    if mem != None:\n        (i, j, z) = mem\n        recognised.extend(self._pro_unreg(text[i:z]))\n        recognised.append(text[i - j:i])\n    else:\n        recognised.extend(self._pro_unreg(text[i - j:z]))\n    return recognised",
        "mutated": [
            "def cut(self, text):\n    if False:\n        i = 10\n    '\\n        '\n    text = text.decode('utf-8', 'ignore')\n    p = self.d\n    ln = len(text)\n    i = ln\n    j = 0\n    z = ln\n    q = 0\n    recognised = []\n    mem = None\n    mem2 = None\n    while i - j > 0:\n        t = text[i - j - 1].lower()\n        if not t in p:\n            if mem != None or mem2 != None:\n                if mem != None:\n                    (i, j, z) = mem\n                    mem = None\n                elif mem2 != None:\n                    delta = mem2[0] - i\n                    if delta >= 1:\n                        if delta < 5 and re.search(u'[\\\\w\u2e80-\\u9fff]', t) != None:\n                            pre = text[i - j]\n                            if not pre in self.specialwords:\n                                (i, j, z, q) = mem2\n                                del recognised[q:]\n                        mem2 = None\n                p = self.d\n                if i < ln and i < z:\n                    unreg_tmp = self._pro_unreg(text[i:z])\n                    recognised.extend(unreg_tmp)\n                recognised.append(text[i - j:i])\n                i = i - j\n                z = i\n                j = 0\n                continue\n            j = 0\n            i -= 1\n            p = self.d\n            continue\n        p = p[t]\n        j += 1\n        if chr(11) in p:\n            if j <= 2:\n                mem = (i, j, z)\n                if z - i < 2 and text[i - 1] in self.specialwords and (mem2 == None or (mem2 != None and mem2[0] - i > 1)):\n                    mem = None\n                    mem2 = (i, j, z, len(recognised))\n                    p = self.d\n                    i -= 1\n                    j = 0\n                continue\n            p = self.d\n            if i < ln and i < z:\n                unreg_tmp = self._pro_unreg(text[i:z])\n                recognised.extend(unreg_tmp)\n            recognised.append(text[i - j:i])\n            i = i - j\n            z = i\n            j = 0\n            mem = None\n            mem2 = None\n    if mem != None:\n        (i, j, z) = mem\n        recognised.extend(self._pro_unreg(text[i:z]))\n        recognised.append(text[i - j:i])\n    else:\n        recognised.extend(self._pro_unreg(text[i - j:z]))\n    return recognised",
            "def cut(self, text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        '\n    text = text.decode('utf-8', 'ignore')\n    p = self.d\n    ln = len(text)\n    i = ln\n    j = 0\n    z = ln\n    q = 0\n    recognised = []\n    mem = None\n    mem2 = None\n    while i - j > 0:\n        t = text[i - j - 1].lower()\n        if not t in p:\n            if mem != None or mem2 != None:\n                if mem != None:\n                    (i, j, z) = mem\n                    mem = None\n                elif mem2 != None:\n                    delta = mem2[0] - i\n                    if delta >= 1:\n                        if delta < 5 and re.search(u'[\\\\w\u2e80-\\u9fff]', t) != None:\n                            pre = text[i - j]\n                            if not pre in self.specialwords:\n                                (i, j, z, q) = mem2\n                                del recognised[q:]\n                        mem2 = None\n                p = self.d\n                if i < ln and i < z:\n                    unreg_tmp = self._pro_unreg(text[i:z])\n                    recognised.extend(unreg_tmp)\n                recognised.append(text[i - j:i])\n                i = i - j\n                z = i\n                j = 0\n                continue\n            j = 0\n            i -= 1\n            p = self.d\n            continue\n        p = p[t]\n        j += 1\n        if chr(11) in p:\n            if j <= 2:\n                mem = (i, j, z)\n                if z - i < 2 and text[i - 1] in self.specialwords and (mem2 == None or (mem2 != None and mem2[0] - i > 1)):\n                    mem = None\n                    mem2 = (i, j, z, len(recognised))\n                    p = self.d\n                    i -= 1\n                    j = 0\n                continue\n            p = self.d\n            if i < ln and i < z:\n                unreg_tmp = self._pro_unreg(text[i:z])\n                recognised.extend(unreg_tmp)\n            recognised.append(text[i - j:i])\n            i = i - j\n            z = i\n            j = 0\n            mem = None\n            mem2 = None\n    if mem != None:\n        (i, j, z) = mem\n        recognised.extend(self._pro_unreg(text[i:z]))\n        recognised.append(text[i - j:i])\n    else:\n        recognised.extend(self._pro_unreg(text[i - j:z]))\n    return recognised",
            "def cut(self, text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        '\n    text = text.decode('utf-8', 'ignore')\n    p = self.d\n    ln = len(text)\n    i = ln\n    j = 0\n    z = ln\n    q = 0\n    recognised = []\n    mem = None\n    mem2 = None\n    while i - j > 0:\n        t = text[i - j - 1].lower()\n        if not t in p:\n            if mem != None or mem2 != None:\n                if mem != None:\n                    (i, j, z) = mem\n                    mem = None\n                elif mem2 != None:\n                    delta = mem2[0] - i\n                    if delta >= 1:\n                        if delta < 5 and re.search(u'[\\\\w\u2e80-\\u9fff]', t) != None:\n                            pre = text[i - j]\n                            if not pre in self.specialwords:\n                                (i, j, z, q) = mem2\n                                del recognised[q:]\n                        mem2 = None\n                p = self.d\n                if i < ln and i < z:\n                    unreg_tmp = self._pro_unreg(text[i:z])\n                    recognised.extend(unreg_tmp)\n                recognised.append(text[i - j:i])\n                i = i - j\n                z = i\n                j = 0\n                continue\n            j = 0\n            i -= 1\n            p = self.d\n            continue\n        p = p[t]\n        j += 1\n        if chr(11) in p:\n            if j <= 2:\n                mem = (i, j, z)\n                if z - i < 2 and text[i - 1] in self.specialwords and (mem2 == None or (mem2 != None and mem2[0] - i > 1)):\n                    mem = None\n                    mem2 = (i, j, z, len(recognised))\n                    p = self.d\n                    i -= 1\n                    j = 0\n                continue\n            p = self.d\n            if i < ln and i < z:\n                unreg_tmp = self._pro_unreg(text[i:z])\n                recognised.extend(unreg_tmp)\n            recognised.append(text[i - j:i])\n            i = i - j\n            z = i\n            j = 0\n            mem = None\n            mem2 = None\n    if mem != None:\n        (i, j, z) = mem\n        recognised.extend(self._pro_unreg(text[i:z]))\n        recognised.append(text[i - j:i])\n    else:\n        recognised.extend(self._pro_unreg(text[i - j:z]))\n    return recognised",
            "def cut(self, text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        '\n    text = text.decode('utf-8', 'ignore')\n    p = self.d\n    ln = len(text)\n    i = ln\n    j = 0\n    z = ln\n    q = 0\n    recognised = []\n    mem = None\n    mem2 = None\n    while i - j > 0:\n        t = text[i - j - 1].lower()\n        if not t in p:\n            if mem != None or mem2 != None:\n                if mem != None:\n                    (i, j, z) = mem\n                    mem = None\n                elif mem2 != None:\n                    delta = mem2[0] - i\n                    if delta >= 1:\n                        if delta < 5 and re.search(u'[\\\\w\u2e80-\\u9fff]', t) != None:\n                            pre = text[i - j]\n                            if not pre in self.specialwords:\n                                (i, j, z, q) = mem2\n                                del recognised[q:]\n                        mem2 = None\n                p = self.d\n                if i < ln and i < z:\n                    unreg_tmp = self._pro_unreg(text[i:z])\n                    recognised.extend(unreg_tmp)\n                recognised.append(text[i - j:i])\n                i = i - j\n                z = i\n                j = 0\n                continue\n            j = 0\n            i -= 1\n            p = self.d\n            continue\n        p = p[t]\n        j += 1\n        if chr(11) in p:\n            if j <= 2:\n                mem = (i, j, z)\n                if z - i < 2 and text[i - 1] in self.specialwords and (mem2 == None or (mem2 != None and mem2[0] - i > 1)):\n                    mem = None\n                    mem2 = (i, j, z, len(recognised))\n                    p = self.d\n                    i -= 1\n                    j = 0\n                continue\n            p = self.d\n            if i < ln and i < z:\n                unreg_tmp = self._pro_unreg(text[i:z])\n                recognised.extend(unreg_tmp)\n            recognised.append(text[i - j:i])\n            i = i - j\n            z = i\n            j = 0\n            mem = None\n            mem2 = None\n    if mem != None:\n        (i, j, z) = mem\n        recognised.extend(self._pro_unreg(text[i:z]))\n        recognised.append(text[i - j:i])\n    else:\n        recognised.extend(self._pro_unreg(text[i - j:z]))\n    return recognised",
            "def cut(self, text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        '\n    text = text.decode('utf-8', 'ignore')\n    p = self.d\n    ln = len(text)\n    i = ln\n    j = 0\n    z = ln\n    q = 0\n    recognised = []\n    mem = None\n    mem2 = None\n    while i - j > 0:\n        t = text[i - j - 1].lower()\n        if not t in p:\n            if mem != None or mem2 != None:\n                if mem != None:\n                    (i, j, z) = mem\n                    mem = None\n                elif mem2 != None:\n                    delta = mem2[0] - i\n                    if delta >= 1:\n                        if delta < 5 and re.search(u'[\\\\w\u2e80-\\u9fff]', t) != None:\n                            pre = text[i - j]\n                            if not pre in self.specialwords:\n                                (i, j, z, q) = mem2\n                                del recognised[q:]\n                        mem2 = None\n                p = self.d\n                if i < ln and i < z:\n                    unreg_tmp = self._pro_unreg(text[i:z])\n                    recognised.extend(unreg_tmp)\n                recognised.append(text[i - j:i])\n                i = i - j\n                z = i\n                j = 0\n                continue\n            j = 0\n            i -= 1\n            p = self.d\n            continue\n        p = p[t]\n        j += 1\n        if chr(11) in p:\n            if j <= 2:\n                mem = (i, j, z)\n                if z - i < 2 and text[i - 1] in self.specialwords and (mem2 == None or (mem2 != None and mem2[0] - i > 1)):\n                    mem = None\n                    mem2 = (i, j, z, len(recognised))\n                    p = self.d\n                    i -= 1\n                    j = 0\n                continue\n            p = self.d\n            if i < ln and i < z:\n                unreg_tmp = self._pro_unreg(text[i:z])\n                recognised.extend(unreg_tmp)\n            recognised.append(text[i - j:i])\n            i = i - j\n            z = i\n            j = 0\n            mem = None\n            mem2 = None\n    if mem != None:\n        (i, j, z) = mem\n        recognised.extend(self._pro_unreg(text[i:z]))\n        recognised.append(text[i - j:i])\n    else:\n        recognised.extend(self._pro_unreg(text[i - j:z]))\n    return recognised"
        ]
    }
]