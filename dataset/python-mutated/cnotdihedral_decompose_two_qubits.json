[
    {
        "func_name": "synth_cnotdihedral_two_qubits",
        "original": "def synth_cnotdihedral_two_qubits(elem):\n    \"\"\"Decompose a CNOTDihedral element on a single qubit and two qubits into a QuantumCircuit.\n    This decomposition has an optimal number of CX gates.\n\n    Args:\n        elem (CNOTDihedral): a CNOTDihedral element.\n\n    Return:\n        QuantumCircuit: a circuit implementation of the CNOTDihedral element.\n\n    Raises:\n        QiskitError: if the element in not 1-qubit or 2-qubit CNOTDihedral.\n\n    Reference:\n        1. Shelly Garion and Andrew W. Cross, *On the structure of the CNOT-Dihedral group*,\n           `arXiv:2006.12042 [quant-ph] <https://arxiv.org/abs/2006.12042>`_\n    \"\"\"\n    circuit = QuantumCircuit(elem.num_qubits)\n    if elem.num_qubits > 2:\n        raise QiskitError('Cannot decompose a CNOT-Dihedral element with more than 2 qubits. use synth_cnotdihedral_full function instead.')\n    if elem.num_qubits == 1:\n        if elem.poly.weight_0 != 0 or elem.linear != [[1]]:\n            raise QiskitError('1-qubit element in not CNOT-Dihedral .')\n        tpow0 = elem.poly.weight_1[0]\n        xpow0 = elem.shift[0]\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow0 == 0 and xpow0 == 0:\n            circuit.id(0)\n        return circuit\n    if elem.poly.weight_0 != 0:\n        raise QiskitError('2-qubit element in not CNOT-Dihedral .')\n    weight_1 = elem.poly.weight_1\n    weight_2 = elem.poly.weight_2\n    linear = elem.linear\n    shift = elem.shift\n    if (linear == [[1, 0], [0, 1]]).all():\n        [xpow0, xpow1] = shift\n        if weight_2 == [0]:\n            [tpow0, tpow1] = weight_1\n            if tpow0 > 0:\n                circuit.p(tpow0 * np.pi / 4, [0])\n            if xpow0 == 1:\n                circuit.x(0)\n            if tpow1 > 0:\n                circuit.p(tpow1 * np.pi / 4, [1])\n            if xpow1 == 1:\n                circuit.x(1)\n            if tpow0 == 0 and tpow1 == 0 and (xpow0 == 0) and (xpow1 == 0):\n                circuit.id(0)\n                circuit.id(1)\n        if weight_2 == [2] and xpow0 == xpow1 or (weight_2 == [6] and xpow0 != xpow1):\n            tpow0 = (weight_1[0] - 2 * xpow1 - 4 * xpow0 * xpow1) % 8\n            tpow1 = (weight_1[1] - 2 * xpow0 - 4 * xpow0 * xpow1) % 8\n            if tpow0 > 0:\n                circuit.p(tpow0 * np.pi / 4, [0])\n            if xpow0 == 1:\n                circuit.x(0)\n            if tpow1 > 0:\n                circuit.p(tpow1 * np.pi / 4, [1])\n            if xpow1 == 1:\n                circuit.x(1)\n            circuit.p(np.pi / 4, [0])\n            circuit.p(np.pi / 4, [1])\n            circuit.cx(0, 1)\n            circuit.p(7 * np.pi / 4, [1])\n            circuit.cx(0, 1)\n        if weight_2 == [6] and xpow0 == xpow1 or (weight_2 == [2] and xpow0 != xpow1):\n            tpow0 = (weight_1[0] - 6 * xpow1 - 4 * xpow0 * xpow1) % 8\n            tpow1 = (weight_1[1] - 6 * xpow0 - 4 * xpow0 * xpow1) % 8\n            if tpow0 > 0:\n                circuit.p(tpow0 * np.pi / 4, [0])\n            if xpow0 == 1:\n                circuit.x(0)\n            if tpow1 > 0:\n                circuit.p(tpow1 * np.pi / 4, [1])\n            if xpow1 == 1:\n                circuit.x(1)\n            circuit.p(7 * np.pi / 4, [0])\n            circuit.p(7 * np.pi / 4, [1])\n            circuit.cx(0, 1)\n            circuit.p(np.pi / 4, [1])\n            circuit.cx(0, 1)\n        if weight_2 == [4]:\n            tpow0 = (weight_1[0] - 4 * xpow1) % 8\n            tpow1 = (weight_1[1] - 4 * xpow0) % 8\n            if tpow0 > 0:\n                circuit.p(tpow0 * np.pi / 4, [0])\n            if xpow0 == 1:\n                circuit.x(0)\n            if tpow1 > 0:\n                circuit.p(tpow1 * np.pi / 4, [1])\n            if xpow1 == 1:\n                circuit.x(1)\n            circuit.cz(1, 0)\n    if (linear == [[1, 0], [1, 1]]).all():\n        xpow0 = shift[0]\n        xpow1 = (shift[1] + xpow0) % 2\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(0, 1)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [1])\n    if (linear == [[1, 1], [0, 1]]).all():\n        xpow1 = shift[1]\n        xpow0 = (shift[0] + xpow1) % 2\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(1, 0)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [0])\n    if (linear == [[0, 1], [1, 1]]).all():\n        xpow1 = shift[0]\n        xpow0 = (shift[1] + xpow1) % 2\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(0, 1)\n        circuit.cx(1, 0)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [1])\n    if (linear == [[1, 1], [1, 0]]).all():\n        xpow0 = shift[1]\n        xpow1 = (shift[0] + xpow0) % 2\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(1, 0)\n        circuit.cx(0, 1)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [0])\n    if (linear == [[0, 1], [1, 0]]).all():\n        xpow0 = shift[1]\n        xpow1 = shift[0]\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(0, 1)\n        circuit.cx(1, 0)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [1])\n        circuit.cx(0, 1)\n    return circuit",
        "mutated": [
            "def synth_cnotdihedral_two_qubits(elem):\n    if False:\n        i = 10\n    'Decompose a CNOTDihedral element on a single qubit and two qubits into a QuantumCircuit.\\n    This decomposition has an optimal number of CX gates.\\n\\n    Args:\\n        elem (CNOTDihedral): a CNOTDihedral element.\\n\\n    Return:\\n        QuantumCircuit: a circuit implementation of the CNOTDihedral element.\\n\\n    Raises:\\n        QiskitError: if the element in not 1-qubit or 2-qubit CNOTDihedral.\\n\\n    Reference:\\n        1. Shelly Garion and Andrew W. Cross, *On the structure of the CNOT-Dihedral group*,\\n           `arXiv:2006.12042 [quant-ph] <https://arxiv.org/abs/2006.12042>`_\\n    '\n    circuit = QuantumCircuit(elem.num_qubits)\n    if elem.num_qubits > 2:\n        raise QiskitError('Cannot decompose a CNOT-Dihedral element with more than 2 qubits. use synth_cnotdihedral_full function instead.')\n    if elem.num_qubits == 1:\n        if elem.poly.weight_0 != 0 or elem.linear != [[1]]:\n            raise QiskitError('1-qubit element in not CNOT-Dihedral .')\n        tpow0 = elem.poly.weight_1[0]\n        xpow0 = elem.shift[0]\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow0 == 0 and xpow0 == 0:\n            circuit.id(0)\n        return circuit\n    if elem.poly.weight_0 != 0:\n        raise QiskitError('2-qubit element in not CNOT-Dihedral .')\n    weight_1 = elem.poly.weight_1\n    weight_2 = elem.poly.weight_2\n    linear = elem.linear\n    shift = elem.shift\n    if (linear == [[1, 0], [0, 1]]).all():\n        [xpow0, xpow1] = shift\n        if weight_2 == [0]:\n            [tpow0, tpow1] = weight_1\n            if tpow0 > 0:\n                circuit.p(tpow0 * np.pi / 4, [0])\n            if xpow0 == 1:\n                circuit.x(0)\n            if tpow1 > 0:\n                circuit.p(tpow1 * np.pi / 4, [1])\n            if xpow1 == 1:\n                circuit.x(1)\n            if tpow0 == 0 and tpow1 == 0 and (xpow0 == 0) and (xpow1 == 0):\n                circuit.id(0)\n                circuit.id(1)\n        if weight_2 == [2] and xpow0 == xpow1 or (weight_2 == [6] and xpow0 != xpow1):\n            tpow0 = (weight_1[0] - 2 * xpow1 - 4 * xpow0 * xpow1) % 8\n            tpow1 = (weight_1[1] - 2 * xpow0 - 4 * xpow0 * xpow1) % 8\n            if tpow0 > 0:\n                circuit.p(tpow0 * np.pi / 4, [0])\n            if xpow0 == 1:\n                circuit.x(0)\n            if tpow1 > 0:\n                circuit.p(tpow1 * np.pi / 4, [1])\n            if xpow1 == 1:\n                circuit.x(1)\n            circuit.p(np.pi / 4, [0])\n            circuit.p(np.pi / 4, [1])\n            circuit.cx(0, 1)\n            circuit.p(7 * np.pi / 4, [1])\n            circuit.cx(0, 1)\n        if weight_2 == [6] and xpow0 == xpow1 or (weight_2 == [2] and xpow0 != xpow1):\n            tpow0 = (weight_1[0] - 6 * xpow1 - 4 * xpow0 * xpow1) % 8\n            tpow1 = (weight_1[1] - 6 * xpow0 - 4 * xpow0 * xpow1) % 8\n            if tpow0 > 0:\n                circuit.p(tpow0 * np.pi / 4, [0])\n            if xpow0 == 1:\n                circuit.x(0)\n            if tpow1 > 0:\n                circuit.p(tpow1 * np.pi / 4, [1])\n            if xpow1 == 1:\n                circuit.x(1)\n            circuit.p(7 * np.pi / 4, [0])\n            circuit.p(7 * np.pi / 4, [1])\n            circuit.cx(0, 1)\n            circuit.p(np.pi / 4, [1])\n            circuit.cx(0, 1)\n        if weight_2 == [4]:\n            tpow0 = (weight_1[0] - 4 * xpow1) % 8\n            tpow1 = (weight_1[1] - 4 * xpow0) % 8\n            if tpow0 > 0:\n                circuit.p(tpow0 * np.pi / 4, [0])\n            if xpow0 == 1:\n                circuit.x(0)\n            if tpow1 > 0:\n                circuit.p(tpow1 * np.pi / 4, [1])\n            if xpow1 == 1:\n                circuit.x(1)\n            circuit.cz(1, 0)\n    if (linear == [[1, 0], [1, 1]]).all():\n        xpow0 = shift[0]\n        xpow1 = (shift[1] + xpow0) % 2\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(0, 1)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [1])\n    if (linear == [[1, 1], [0, 1]]).all():\n        xpow1 = shift[1]\n        xpow0 = (shift[0] + xpow1) % 2\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(1, 0)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [0])\n    if (linear == [[0, 1], [1, 1]]).all():\n        xpow1 = shift[0]\n        xpow0 = (shift[1] + xpow1) % 2\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(0, 1)\n        circuit.cx(1, 0)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [1])\n    if (linear == [[1, 1], [1, 0]]).all():\n        xpow0 = shift[1]\n        xpow1 = (shift[0] + xpow0) % 2\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(1, 0)\n        circuit.cx(0, 1)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [0])\n    if (linear == [[0, 1], [1, 0]]).all():\n        xpow0 = shift[1]\n        xpow1 = shift[0]\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(0, 1)\n        circuit.cx(1, 0)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [1])\n        circuit.cx(0, 1)\n    return circuit",
            "def synth_cnotdihedral_two_qubits(elem):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Decompose a CNOTDihedral element on a single qubit and two qubits into a QuantumCircuit.\\n    This decomposition has an optimal number of CX gates.\\n\\n    Args:\\n        elem (CNOTDihedral): a CNOTDihedral element.\\n\\n    Return:\\n        QuantumCircuit: a circuit implementation of the CNOTDihedral element.\\n\\n    Raises:\\n        QiskitError: if the element in not 1-qubit or 2-qubit CNOTDihedral.\\n\\n    Reference:\\n        1. Shelly Garion and Andrew W. Cross, *On the structure of the CNOT-Dihedral group*,\\n           `arXiv:2006.12042 [quant-ph] <https://arxiv.org/abs/2006.12042>`_\\n    '\n    circuit = QuantumCircuit(elem.num_qubits)\n    if elem.num_qubits > 2:\n        raise QiskitError('Cannot decompose a CNOT-Dihedral element with more than 2 qubits. use synth_cnotdihedral_full function instead.')\n    if elem.num_qubits == 1:\n        if elem.poly.weight_0 != 0 or elem.linear != [[1]]:\n            raise QiskitError('1-qubit element in not CNOT-Dihedral .')\n        tpow0 = elem.poly.weight_1[0]\n        xpow0 = elem.shift[0]\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow0 == 0 and xpow0 == 0:\n            circuit.id(0)\n        return circuit\n    if elem.poly.weight_0 != 0:\n        raise QiskitError('2-qubit element in not CNOT-Dihedral .')\n    weight_1 = elem.poly.weight_1\n    weight_2 = elem.poly.weight_2\n    linear = elem.linear\n    shift = elem.shift\n    if (linear == [[1, 0], [0, 1]]).all():\n        [xpow0, xpow1] = shift\n        if weight_2 == [0]:\n            [tpow0, tpow1] = weight_1\n            if tpow0 > 0:\n                circuit.p(tpow0 * np.pi / 4, [0])\n            if xpow0 == 1:\n                circuit.x(0)\n            if tpow1 > 0:\n                circuit.p(tpow1 * np.pi / 4, [1])\n            if xpow1 == 1:\n                circuit.x(1)\n            if tpow0 == 0 and tpow1 == 0 and (xpow0 == 0) and (xpow1 == 0):\n                circuit.id(0)\n                circuit.id(1)\n        if weight_2 == [2] and xpow0 == xpow1 or (weight_2 == [6] and xpow0 != xpow1):\n            tpow0 = (weight_1[0] - 2 * xpow1 - 4 * xpow0 * xpow1) % 8\n            tpow1 = (weight_1[1] - 2 * xpow0 - 4 * xpow0 * xpow1) % 8\n            if tpow0 > 0:\n                circuit.p(tpow0 * np.pi / 4, [0])\n            if xpow0 == 1:\n                circuit.x(0)\n            if tpow1 > 0:\n                circuit.p(tpow1 * np.pi / 4, [1])\n            if xpow1 == 1:\n                circuit.x(1)\n            circuit.p(np.pi / 4, [0])\n            circuit.p(np.pi / 4, [1])\n            circuit.cx(0, 1)\n            circuit.p(7 * np.pi / 4, [1])\n            circuit.cx(0, 1)\n        if weight_2 == [6] and xpow0 == xpow1 or (weight_2 == [2] and xpow0 != xpow1):\n            tpow0 = (weight_1[0] - 6 * xpow1 - 4 * xpow0 * xpow1) % 8\n            tpow1 = (weight_1[1] - 6 * xpow0 - 4 * xpow0 * xpow1) % 8\n            if tpow0 > 0:\n                circuit.p(tpow0 * np.pi / 4, [0])\n            if xpow0 == 1:\n                circuit.x(0)\n            if tpow1 > 0:\n                circuit.p(tpow1 * np.pi / 4, [1])\n            if xpow1 == 1:\n                circuit.x(1)\n            circuit.p(7 * np.pi / 4, [0])\n            circuit.p(7 * np.pi / 4, [1])\n            circuit.cx(0, 1)\n            circuit.p(np.pi / 4, [1])\n            circuit.cx(0, 1)\n        if weight_2 == [4]:\n            tpow0 = (weight_1[0] - 4 * xpow1) % 8\n            tpow1 = (weight_1[1] - 4 * xpow0) % 8\n            if tpow0 > 0:\n                circuit.p(tpow0 * np.pi / 4, [0])\n            if xpow0 == 1:\n                circuit.x(0)\n            if tpow1 > 0:\n                circuit.p(tpow1 * np.pi / 4, [1])\n            if xpow1 == 1:\n                circuit.x(1)\n            circuit.cz(1, 0)\n    if (linear == [[1, 0], [1, 1]]).all():\n        xpow0 = shift[0]\n        xpow1 = (shift[1] + xpow0) % 2\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(0, 1)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [1])\n    if (linear == [[1, 1], [0, 1]]).all():\n        xpow1 = shift[1]\n        xpow0 = (shift[0] + xpow1) % 2\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(1, 0)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [0])\n    if (linear == [[0, 1], [1, 1]]).all():\n        xpow1 = shift[0]\n        xpow0 = (shift[1] + xpow1) % 2\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(0, 1)\n        circuit.cx(1, 0)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [1])\n    if (linear == [[1, 1], [1, 0]]).all():\n        xpow0 = shift[1]\n        xpow1 = (shift[0] + xpow0) % 2\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(1, 0)\n        circuit.cx(0, 1)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [0])\n    if (linear == [[0, 1], [1, 0]]).all():\n        xpow0 = shift[1]\n        xpow1 = shift[0]\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(0, 1)\n        circuit.cx(1, 0)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [1])\n        circuit.cx(0, 1)\n    return circuit",
            "def synth_cnotdihedral_two_qubits(elem):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Decompose a CNOTDihedral element on a single qubit and two qubits into a QuantumCircuit.\\n    This decomposition has an optimal number of CX gates.\\n\\n    Args:\\n        elem (CNOTDihedral): a CNOTDihedral element.\\n\\n    Return:\\n        QuantumCircuit: a circuit implementation of the CNOTDihedral element.\\n\\n    Raises:\\n        QiskitError: if the element in not 1-qubit or 2-qubit CNOTDihedral.\\n\\n    Reference:\\n        1. Shelly Garion and Andrew W. Cross, *On the structure of the CNOT-Dihedral group*,\\n           `arXiv:2006.12042 [quant-ph] <https://arxiv.org/abs/2006.12042>`_\\n    '\n    circuit = QuantumCircuit(elem.num_qubits)\n    if elem.num_qubits > 2:\n        raise QiskitError('Cannot decompose a CNOT-Dihedral element with more than 2 qubits. use synth_cnotdihedral_full function instead.')\n    if elem.num_qubits == 1:\n        if elem.poly.weight_0 != 0 or elem.linear != [[1]]:\n            raise QiskitError('1-qubit element in not CNOT-Dihedral .')\n        tpow0 = elem.poly.weight_1[0]\n        xpow0 = elem.shift[0]\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow0 == 0 and xpow0 == 0:\n            circuit.id(0)\n        return circuit\n    if elem.poly.weight_0 != 0:\n        raise QiskitError('2-qubit element in not CNOT-Dihedral .')\n    weight_1 = elem.poly.weight_1\n    weight_2 = elem.poly.weight_2\n    linear = elem.linear\n    shift = elem.shift\n    if (linear == [[1, 0], [0, 1]]).all():\n        [xpow0, xpow1] = shift\n        if weight_2 == [0]:\n            [tpow0, tpow1] = weight_1\n            if tpow0 > 0:\n                circuit.p(tpow0 * np.pi / 4, [0])\n            if xpow0 == 1:\n                circuit.x(0)\n            if tpow1 > 0:\n                circuit.p(tpow1 * np.pi / 4, [1])\n            if xpow1 == 1:\n                circuit.x(1)\n            if tpow0 == 0 and tpow1 == 0 and (xpow0 == 0) and (xpow1 == 0):\n                circuit.id(0)\n                circuit.id(1)\n        if weight_2 == [2] and xpow0 == xpow1 or (weight_2 == [6] and xpow0 != xpow1):\n            tpow0 = (weight_1[0] - 2 * xpow1 - 4 * xpow0 * xpow1) % 8\n            tpow1 = (weight_1[1] - 2 * xpow0 - 4 * xpow0 * xpow1) % 8\n            if tpow0 > 0:\n                circuit.p(tpow0 * np.pi / 4, [0])\n            if xpow0 == 1:\n                circuit.x(0)\n            if tpow1 > 0:\n                circuit.p(tpow1 * np.pi / 4, [1])\n            if xpow1 == 1:\n                circuit.x(1)\n            circuit.p(np.pi / 4, [0])\n            circuit.p(np.pi / 4, [1])\n            circuit.cx(0, 1)\n            circuit.p(7 * np.pi / 4, [1])\n            circuit.cx(0, 1)\n        if weight_2 == [6] and xpow0 == xpow1 or (weight_2 == [2] and xpow0 != xpow1):\n            tpow0 = (weight_1[0] - 6 * xpow1 - 4 * xpow0 * xpow1) % 8\n            tpow1 = (weight_1[1] - 6 * xpow0 - 4 * xpow0 * xpow1) % 8\n            if tpow0 > 0:\n                circuit.p(tpow0 * np.pi / 4, [0])\n            if xpow0 == 1:\n                circuit.x(0)\n            if tpow1 > 0:\n                circuit.p(tpow1 * np.pi / 4, [1])\n            if xpow1 == 1:\n                circuit.x(1)\n            circuit.p(7 * np.pi / 4, [0])\n            circuit.p(7 * np.pi / 4, [1])\n            circuit.cx(0, 1)\n            circuit.p(np.pi / 4, [1])\n            circuit.cx(0, 1)\n        if weight_2 == [4]:\n            tpow0 = (weight_1[0] - 4 * xpow1) % 8\n            tpow1 = (weight_1[1] - 4 * xpow0) % 8\n            if tpow0 > 0:\n                circuit.p(tpow0 * np.pi / 4, [0])\n            if xpow0 == 1:\n                circuit.x(0)\n            if tpow1 > 0:\n                circuit.p(tpow1 * np.pi / 4, [1])\n            if xpow1 == 1:\n                circuit.x(1)\n            circuit.cz(1, 0)\n    if (linear == [[1, 0], [1, 1]]).all():\n        xpow0 = shift[0]\n        xpow1 = (shift[1] + xpow0) % 2\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(0, 1)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [1])\n    if (linear == [[1, 1], [0, 1]]).all():\n        xpow1 = shift[1]\n        xpow0 = (shift[0] + xpow1) % 2\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(1, 0)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [0])\n    if (linear == [[0, 1], [1, 1]]).all():\n        xpow1 = shift[0]\n        xpow0 = (shift[1] + xpow1) % 2\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(0, 1)\n        circuit.cx(1, 0)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [1])\n    if (linear == [[1, 1], [1, 0]]).all():\n        xpow0 = shift[1]\n        xpow1 = (shift[0] + xpow0) % 2\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(1, 0)\n        circuit.cx(0, 1)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [0])\n    if (linear == [[0, 1], [1, 0]]).all():\n        xpow0 = shift[1]\n        xpow1 = shift[0]\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(0, 1)\n        circuit.cx(1, 0)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [1])\n        circuit.cx(0, 1)\n    return circuit",
            "def synth_cnotdihedral_two_qubits(elem):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Decompose a CNOTDihedral element on a single qubit and two qubits into a QuantumCircuit.\\n    This decomposition has an optimal number of CX gates.\\n\\n    Args:\\n        elem (CNOTDihedral): a CNOTDihedral element.\\n\\n    Return:\\n        QuantumCircuit: a circuit implementation of the CNOTDihedral element.\\n\\n    Raises:\\n        QiskitError: if the element in not 1-qubit or 2-qubit CNOTDihedral.\\n\\n    Reference:\\n        1. Shelly Garion and Andrew W. Cross, *On the structure of the CNOT-Dihedral group*,\\n           `arXiv:2006.12042 [quant-ph] <https://arxiv.org/abs/2006.12042>`_\\n    '\n    circuit = QuantumCircuit(elem.num_qubits)\n    if elem.num_qubits > 2:\n        raise QiskitError('Cannot decompose a CNOT-Dihedral element with more than 2 qubits. use synth_cnotdihedral_full function instead.')\n    if elem.num_qubits == 1:\n        if elem.poly.weight_0 != 0 or elem.linear != [[1]]:\n            raise QiskitError('1-qubit element in not CNOT-Dihedral .')\n        tpow0 = elem.poly.weight_1[0]\n        xpow0 = elem.shift[0]\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow0 == 0 and xpow0 == 0:\n            circuit.id(0)\n        return circuit\n    if elem.poly.weight_0 != 0:\n        raise QiskitError('2-qubit element in not CNOT-Dihedral .')\n    weight_1 = elem.poly.weight_1\n    weight_2 = elem.poly.weight_2\n    linear = elem.linear\n    shift = elem.shift\n    if (linear == [[1, 0], [0, 1]]).all():\n        [xpow0, xpow1] = shift\n        if weight_2 == [0]:\n            [tpow0, tpow1] = weight_1\n            if tpow0 > 0:\n                circuit.p(tpow0 * np.pi / 4, [0])\n            if xpow0 == 1:\n                circuit.x(0)\n            if tpow1 > 0:\n                circuit.p(tpow1 * np.pi / 4, [1])\n            if xpow1 == 1:\n                circuit.x(1)\n            if tpow0 == 0 and tpow1 == 0 and (xpow0 == 0) and (xpow1 == 0):\n                circuit.id(0)\n                circuit.id(1)\n        if weight_2 == [2] and xpow0 == xpow1 or (weight_2 == [6] and xpow0 != xpow1):\n            tpow0 = (weight_1[0] - 2 * xpow1 - 4 * xpow0 * xpow1) % 8\n            tpow1 = (weight_1[1] - 2 * xpow0 - 4 * xpow0 * xpow1) % 8\n            if tpow0 > 0:\n                circuit.p(tpow0 * np.pi / 4, [0])\n            if xpow0 == 1:\n                circuit.x(0)\n            if tpow1 > 0:\n                circuit.p(tpow1 * np.pi / 4, [1])\n            if xpow1 == 1:\n                circuit.x(1)\n            circuit.p(np.pi / 4, [0])\n            circuit.p(np.pi / 4, [1])\n            circuit.cx(0, 1)\n            circuit.p(7 * np.pi / 4, [1])\n            circuit.cx(0, 1)\n        if weight_2 == [6] and xpow0 == xpow1 or (weight_2 == [2] and xpow0 != xpow1):\n            tpow0 = (weight_1[0] - 6 * xpow1 - 4 * xpow0 * xpow1) % 8\n            tpow1 = (weight_1[1] - 6 * xpow0 - 4 * xpow0 * xpow1) % 8\n            if tpow0 > 0:\n                circuit.p(tpow0 * np.pi / 4, [0])\n            if xpow0 == 1:\n                circuit.x(0)\n            if tpow1 > 0:\n                circuit.p(tpow1 * np.pi / 4, [1])\n            if xpow1 == 1:\n                circuit.x(1)\n            circuit.p(7 * np.pi / 4, [0])\n            circuit.p(7 * np.pi / 4, [1])\n            circuit.cx(0, 1)\n            circuit.p(np.pi / 4, [1])\n            circuit.cx(0, 1)\n        if weight_2 == [4]:\n            tpow0 = (weight_1[0] - 4 * xpow1) % 8\n            tpow1 = (weight_1[1] - 4 * xpow0) % 8\n            if tpow0 > 0:\n                circuit.p(tpow0 * np.pi / 4, [0])\n            if xpow0 == 1:\n                circuit.x(0)\n            if tpow1 > 0:\n                circuit.p(tpow1 * np.pi / 4, [1])\n            if xpow1 == 1:\n                circuit.x(1)\n            circuit.cz(1, 0)\n    if (linear == [[1, 0], [1, 1]]).all():\n        xpow0 = shift[0]\n        xpow1 = (shift[1] + xpow0) % 2\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(0, 1)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [1])\n    if (linear == [[1, 1], [0, 1]]).all():\n        xpow1 = shift[1]\n        xpow0 = (shift[0] + xpow1) % 2\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(1, 0)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [0])\n    if (linear == [[0, 1], [1, 1]]).all():\n        xpow1 = shift[0]\n        xpow0 = (shift[1] + xpow1) % 2\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(0, 1)\n        circuit.cx(1, 0)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [1])\n    if (linear == [[1, 1], [1, 0]]).all():\n        xpow0 = shift[1]\n        xpow1 = (shift[0] + xpow0) % 2\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(1, 0)\n        circuit.cx(0, 1)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [0])\n    if (linear == [[0, 1], [1, 0]]).all():\n        xpow0 = shift[1]\n        xpow1 = shift[0]\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(0, 1)\n        circuit.cx(1, 0)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [1])\n        circuit.cx(0, 1)\n    return circuit",
            "def synth_cnotdihedral_two_qubits(elem):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Decompose a CNOTDihedral element on a single qubit and two qubits into a QuantumCircuit.\\n    This decomposition has an optimal number of CX gates.\\n\\n    Args:\\n        elem (CNOTDihedral): a CNOTDihedral element.\\n\\n    Return:\\n        QuantumCircuit: a circuit implementation of the CNOTDihedral element.\\n\\n    Raises:\\n        QiskitError: if the element in not 1-qubit or 2-qubit CNOTDihedral.\\n\\n    Reference:\\n        1. Shelly Garion and Andrew W. Cross, *On the structure of the CNOT-Dihedral group*,\\n           `arXiv:2006.12042 [quant-ph] <https://arxiv.org/abs/2006.12042>`_\\n    '\n    circuit = QuantumCircuit(elem.num_qubits)\n    if elem.num_qubits > 2:\n        raise QiskitError('Cannot decompose a CNOT-Dihedral element with more than 2 qubits. use synth_cnotdihedral_full function instead.')\n    if elem.num_qubits == 1:\n        if elem.poly.weight_0 != 0 or elem.linear != [[1]]:\n            raise QiskitError('1-qubit element in not CNOT-Dihedral .')\n        tpow0 = elem.poly.weight_1[0]\n        xpow0 = elem.shift[0]\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow0 == 0 and xpow0 == 0:\n            circuit.id(0)\n        return circuit\n    if elem.poly.weight_0 != 0:\n        raise QiskitError('2-qubit element in not CNOT-Dihedral .')\n    weight_1 = elem.poly.weight_1\n    weight_2 = elem.poly.weight_2\n    linear = elem.linear\n    shift = elem.shift\n    if (linear == [[1, 0], [0, 1]]).all():\n        [xpow0, xpow1] = shift\n        if weight_2 == [0]:\n            [tpow0, tpow1] = weight_1\n            if tpow0 > 0:\n                circuit.p(tpow0 * np.pi / 4, [0])\n            if xpow0 == 1:\n                circuit.x(0)\n            if tpow1 > 0:\n                circuit.p(tpow1 * np.pi / 4, [1])\n            if xpow1 == 1:\n                circuit.x(1)\n            if tpow0 == 0 and tpow1 == 0 and (xpow0 == 0) and (xpow1 == 0):\n                circuit.id(0)\n                circuit.id(1)\n        if weight_2 == [2] and xpow0 == xpow1 or (weight_2 == [6] and xpow0 != xpow1):\n            tpow0 = (weight_1[0] - 2 * xpow1 - 4 * xpow0 * xpow1) % 8\n            tpow1 = (weight_1[1] - 2 * xpow0 - 4 * xpow0 * xpow1) % 8\n            if tpow0 > 0:\n                circuit.p(tpow0 * np.pi / 4, [0])\n            if xpow0 == 1:\n                circuit.x(0)\n            if tpow1 > 0:\n                circuit.p(tpow1 * np.pi / 4, [1])\n            if xpow1 == 1:\n                circuit.x(1)\n            circuit.p(np.pi / 4, [0])\n            circuit.p(np.pi / 4, [1])\n            circuit.cx(0, 1)\n            circuit.p(7 * np.pi / 4, [1])\n            circuit.cx(0, 1)\n        if weight_2 == [6] and xpow0 == xpow1 or (weight_2 == [2] and xpow0 != xpow1):\n            tpow0 = (weight_1[0] - 6 * xpow1 - 4 * xpow0 * xpow1) % 8\n            tpow1 = (weight_1[1] - 6 * xpow0 - 4 * xpow0 * xpow1) % 8\n            if tpow0 > 0:\n                circuit.p(tpow0 * np.pi / 4, [0])\n            if xpow0 == 1:\n                circuit.x(0)\n            if tpow1 > 0:\n                circuit.p(tpow1 * np.pi / 4, [1])\n            if xpow1 == 1:\n                circuit.x(1)\n            circuit.p(7 * np.pi / 4, [0])\n            circuit.p(7 * np.pi / 4, [1])\n            circuit.cx(0, 1)\n            circuit.p(np.pi / 4, [1])\n            circuit.cx(0, 1)\n        if weight_2 == [4]:\n            tpow0 = (weight_1[0] - 4 * xpow1) % 8\n            tpow1 = (weight_1[1] - 4 * xpow0) % 8\n            if tpow0 > 0:\n                circuit.p(tpow0 * np.pi / 4, [0])\n            if xpow0 == 1:\n                circuit.x(0)\n            if tpow1 > 0:\n                circuit.p(tpow1 * np.pi / 4, [1])\n            if xpow1 == 1:\n                circuit.x(1)\n            circuit.cz(1, 0)\n    if (linear == [[1, 0], [1, 1]]).all():\n        xpow0 = shift[0]\n        xpow1 = (shift[1] + xpow0) % 2\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(0, 1)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [1])\n    if (linear == [[1, 1], [0, 1]]).all():\n        xpow1 = shift[1]\n        xpow0 = (shift[0] + xpow1) % 2\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(1, 0)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [0])\n    if (linear == [[0, 1], [1, 1]]).all():\n        xpow1 = shift[0]\n        xpow0 = (shift[1] + xpow1) % 2\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(0, 1)\n        circuit.cx(1, 0)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [1])\n    if (linear == [[1, 1], [1, 0]]).all():\n        xpow0 = shift[1]\n        xpow1 = (shift[0] + xpow0) % 2\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(1, 0)\n        circuit.cx(0, 1)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [0])\n    if (linear == [[0, 1], [1, 0]]).all():\n        xpow0 = shift[1]\n        xpow1 = shift[0]\n        if xpow0 == xpow1:\n            m = (8 - weight_2[0]) / 2 % 4\n            tpow0 = (weight_1[0] - m) % 8\n            tpow1 = (weight_1[1] - m) % 8\n        else:\n            m = weight_2[0] / 2 % 4\n            tpow0 = (weight_1[0] + m) % 8\n            tpow1 = (weight_1[1] + m) % 8\n        if tpow0 > 0:\n            circuit.p(tpow0 * np.pi / 4, [0])\n        if xpow0 == 1:\n            circuit.x(0)\n        if tpow1 > 0:\n            circuit.p(tpow1 * np.pi / 4, [1])\n        if xpow1 == 1:\n            circuit.x(1)\n        circuit.cx(0, 1)\n        circuit.cx(1, 0)\n        if m > 0:\n            circuit.p(m * np.pi / 4, [1])\n        circuit.cx(0, 1)\n    return circuit"
        ]
    }
]