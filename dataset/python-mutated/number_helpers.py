from hypothesis import strategies as st
from hypothesis.internal.floats import float_of
from . import general_helpers as gh, dtype_helpers
import ivy_tests.test_ivy.helpers.globals as test_globals
floats_info = {'float16': {'cast_type': 'float16', 'width': 16}, 'bfloat16': {'cast_type': 'float32', 'width': 32}, 'float32': {'cast_type': 'float32', 'width': 32}, 'float64': {'cast_type': 'float64', 'width': 64}}

@st.composite
def floats(draw, *, min_value=None, max_value=None, abs_smallest_val=None, allow_nan=False, allow_inf=False, allow_subnormal=False, exclude_min=True, exclude_max=True, large_abs_safety_factor=1.1, small_abs_safety_factor=1.1, safety_factor_scale='linear', mixed_fn_compos=True):
    if False:
        for i in range(10):
            print('nop')
    '\n    Draws an arbitrarily sized list of floats with a safety factor applied to avoid\n    values being generated at the edge of a dtype limit.\n\n    Parameters\n    ----------\n    draw\n        special function that draws data randomly (but is reproducible) from a given\n        data-set (ex. list).\n    min_value\n        minimum value of floats generated.\n    max_value\n        maximum value of floats generated.\n    abs_smallest_val\n        the absolute smallest representable value of the data type.\n    allow_nan\n        if True, allow Nans in the list.\n    allow_inf\n        if True, allow inf in the list.\n    allow_subnormal\n        if True, allow subnormals in the list.\n    exclude_min\n        if True, exclude the minimum limit.\n    exclude_max\n        if True, exclude the maximum limit.\n    large_abs_safety_factor\n        A safety factor of 1 means that all values are included without limitation,\n\n        when a "linear" safety factor scaler is used,  a safety factor of 2 means\n        that only 50% of the range is included, a safety factor of 3 means that\n        only 33% of the range is included etc.\n\n        when a "log" safety factor scaler is used, a data type with maximum\n        value of 2^32 and a safety factor of 2 transforms the maximum to 2^16.\n    small_abs_safety_factor\n        A safety factor of 1 means that all values are included without limitation,\n\n        when a "linear" safety factor scaler is used, a data type with minimum\n        representable number of 0.0001 and a safety factor of 2 transforms the\n        minimum to 0.0002, a safety factor of 3 transforms the minimum to 0.0003 etc.\n\n        when a "log" safety factor scaler is used, a data type with minimum\n        representable number of 0.5 * 2^-16 and a safety factor of 2 transforms the\n        minimum to 0.5 * 2^-8, a safety factor of 3 transforms the minimum to 0.5 * 2^-4\n    safety_factor_scale\n        The operation to use for the safety factor scaling. Can be "linear" or "log".\n        Default value = "linear".\n    mixed_fn_compos\n        boolean if True, the function will generate using the float dtypes\n        of the compositional implementation for mixed partial functions and\n        if False, it will generate using the float dtypes of the\n        primary implementation.\n\n    Returns\n    -------\n    ret\n        A strategy that draws floats.\n    '
    dtype = draw(dtype_helpers.get_dtypes('float', mixed_fn_compos=mixed_fn_compos, full=False, prune_function=False))
    dtype = dtype[0]
    (min_value, max_value, abs_smallest_val) = gh.apply_safety_factor(dtype, backend=test_globals.CURRENT_BACKEND, min_value=min_value, max_value=max_value, abs_smallest_val=abs_smallest_val, small_abs_safety_factor=small_abs_safety_factor, large_abs_safety_factor=large_abs_safety_factor, safety_factor_scale=safety_factor_scale)
    if min_value > -abs_smallest_val or max_value < abs_smallest_val:
        float_strategy = st.floats(min_value=float_of(min_value, floats_info[dtype]['width']), max_value=float_of(max_value, floats_info[dtype]['width']), allow_nan=allow_nan, allow_subnormal=allow_subnormal, allow_infinity=allow_inf, width=floats_info[dtype]['width'], exclude_min=exclude_min, exclude_max=exclude_max)
    else:
        float_strategy = st.one_of(st.floats(min_value=float_of(min_value, floats_info[dtype]['width']), max_value=float_of(-abs_smallest_val, floats_info[dtype]['width']), allow_nan=allow_nan, allow_subnormal=allow_subnormal, allow_infinity=allow_inf, width=floats_info[dtype]['width'], exclude_min=exclude_min, exclude_max=exclude_max), st.floats(min_value=float_of(abs_smallest_val, floats_info[dtype]['width']), max_value=float_of(max_value, floats_info[dtype]['width']), allow_nan=allow_nan, allow_subnormal=allow_subnormal, allow_infinity=allow_inf, width=floats_info[dtype]['width'], exclude_min=exclude_min, exclude_max=exclude_max))
    values = draw(float_strategy)
    return values

@st.composite
def ints(draw, *, min_value=None, max_value=None, safety_factor=1.1, safety_factor_scale=None, mixed_fn_compos=True):
    if False:
        while True:
            i = 10
    '\n    Draws an integer with a safety factor if specified.\n\n    Parameters\n    ----------\n    draw\n        special function that draws data randomly (but is reproducible) from a given\n        data-set (ex. list).\n    min_value\n        minimum value of integers generated.\n    max_value\n        maximum value of integers generated.\n    safety_factor\n        A safety factor of 1 means that all values are included without limitation,\n\n        when a "linear" safety factor scaler is used,  a safety factor of 2 means\n        that only 50% of the range is included, a safety factor of 3 means that\n        only 33% of the range is included etc.\n\n        when a "log" safety factor scaler is used, a data type with maximum\n        value of 2^32 and a safety factor of 2 transforms the maximum to 2^16.\n    safety_factor_scale\n        The operation to use for the safety factor scaling. Can be "linear" or "log".\n        Default value = "linear".\n    mixed_fn_compos\n        boolean if True, the function will generate using the integer dtypes\n        of the compositional implementation for mixed partial functions and\n        if False, it will generate using the integer dtypes of the\n        primary implementation.\n\n    Returns\n    -------\n    ret\n        A strategy that draws integers.\n    '
    dtype = draw(dtype_helpers.get_dtypes('integer', mixed_fn_compos=mixed_fn_compos, full=False, prune_function=False))
    if min_value is None and max_value is None:
        safety_factor_scale = 'linear'
    if safety_factor_scale is not None:
        (min_value, max_value, _) = gh.apply_safety_factor(dtype[0], backend=test_globals.CURRENT_BACKEND, min_value=min_value, max_value=max_value, large_abs_safety_factor=safety_factor, safety_factor_scale=safety_factor_scale)
    return draw(st.integers(min_value, max_value))

@st.composite
def number(draw, *, min_value=None, max_value=None, large_abs_safety_factor=1.1, small_abs_safety_factor=1.1, safety_factor_scale='linear', mixed_fn_compos=True):
    if False:
        for i in range(10):
            print('nop')
    '\n    Draws integers or floats with a safety factor applied to values.\n\n    Parameters\n    ----------\n    draw\n        special function that draws data randomly (but is reproducible) from a given\n        data-set (ex. list).\n    min_value\n        minimum value of integers generated.\n    max_value\n        maximum value of integers generated.\n    large_abs_safety_factor\n        A safety factor of 1 means that all values are included without limitation,\n\n        when a "linear" safety factor scaler is used,  a safety factor of 2 means\n        that only 50% of the range is included, a safety factor of 3 means that\n        only 33% of the range is included etc.\n\n        when a "log" safety factor scaler is used, a data type with maximum\n        value of 2^32 and a safety factor of 2 transforms the maximum to 2^16.\n    small_abs_safety_factor\n        A safety factor of 1 means that all values are included without limitation,\n        this has no effect on integer data types.\n\n        when a "linear" safety factor scaler is used, a data type with minimum\n        representable number of 0.0001 and a safety factor of 2 transforms the\n        minimum to 0.0002, a safety factor of 3 transforms the minimum to 0.0003 etc.\n\n        when a "log" safety factor scaler is used, a data type with minimum\n        representable number of 0.5 * 2^-16 and a safety factor of 2 transforms the\n        minimum to 0.5 * 2^-8, a safety factor of 3 transforms the minimum to 0.5 * 2^-4\n    safety_factor_scale\n        The operation to use for the safety factor scaling. Can be "linear" or "log".\n        Default value = "linear".\n    mixed_fn_compos\n        boolean if True, the function will generate using the numeric dtypes\n        of the compositional implementation for mixed partial functions and\n        if False, it will generate using the numeric dtypes of the\n        primary implementation.\n\n\n    Returns\n    -------\n    ret\n        A strategy that draws integers or floats.\n    '
    return draw(ints(min_value=min_value, max_value=max_value, safety_factor=large_abs_safety_factor, safety_factor_scale=safety_factor_scale, mixed_fn_compos=mixed_fn_compos) | floats(min_value=min_value, max_value=max_value, small_abs_safety_factor=small_abs_safety_factor, large_abs_safety_factor=large_abs_safety_factor, safety_factor_scale=safety_factor_scale, mixed_fn_compos=mixed_fn_compos))