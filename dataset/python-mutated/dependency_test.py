import BoostBuild

def test_basic():
    if False:
        i = 10
        return i + 15
    t = BoostBuild.Tester(['-d3', '-d+12'], use_test_config=False)
    t.write('a.cpp', '\n#include <a.h>\n# include "a.h"\n#include <x.h>\nint main() {}\n')
    t.write('a.h', '\n')
    t.write('a_c.c', '#include <a.h>\n# include "a.h"\n#include <x.h>\n')
    t.write('b.cpp', '#include "a.h"\nint main() {}\n')
    t.write('b.h', '\n')
    t.write('c.cpp', '#include "x.h"\nint main() {}\n')
    t.write('e.cpp', '#include "x.h"\nint main() {}\n')
    t.write('x.foo', '')
    t.write('y.foo', '')
    t.write('src1/a.h', '#include "b.h"\n')
    t.write('src1/b.h', '#include "c.h"\n')
    t.write('src1/c.h', '\n')
    t.write('src1/z.h', 'extern int dummy_variable_suppressing_empty_file_warning_on_hp_cxx_compiler;\n')
    t.write('src2/b.h', '\n')
    t.write('jamroot.jam', 'import foo ;\nimport types/cpp ;\nimport types/exe ;\n\nproject test : requirements <include>src1 ;\n\nexe a : x.foo a.cpp a_c.c ;\nexe b : b.cpp ;\n\n# Because of <define>FOO, c.cpp will be compiled to a different directory than\n# everything for main target "a". Therefore, without <implicit-dependency>, C\n# preprocessor processing that module will not find "x.h", which is part of\n# "a"\'s dependency graph.\n#\n# --------------------------\n# More detailed explanation:\n# --------------------------\n#   c.cpp includes x.h which does not exist on the current include path so Boost\n# Jam will try to match it to existing Jam targets to cover cases as this one\n# where the file is generated by the same build.\n#\n#   However, as x.h is not part of "c" metatarget\'s dependency graph, Boost\n# Build will not actualize its target by default, i.e. create its Jam target.\n#\n#   To get the Jam target created in time, we use the <implicit-dependency>\n# feature. This tells Boost Build that it needs to actualize the dependency\n# graph for metatarget "a", even though that metatarget has not been directly\n# mentioned and is not a dependency for any of the metatargets mentioned in the\n# current build request.\n#\n#   Note that Boost Build does not automatically add a dependency between the\n# Jam targets in question so, if Boost Jam does not add a dependency on a target\n# from that other dependency graph (x.h in our case), i.e. if c.cpp does not\n# actually include x.h, us actualizing it will have no effect in the end as\n# Boost Jam will not have a reason to actually build those targets in spite of\n# knowing about them.\nexe c : c.cpp : <define>FOO <implicit-dependency>a ;\n')
    t.write('foo.jam', 'import generators ;\nimport modules ;\nimport os ;\nimport print ;\nimport type ;\nimport types/cpp ;\n\ntype.register FOO : foo ;\n\ngenerators.register-standard foo.foo : FOO : CPP H ;\n\nnl = "\n" ;\n\nrule foo ( targets * : sources * : properties * )\n{\n    # On NT, you need an exported symbol in order to have an import library\n    # generated. We will not really use the symbol defined here, just force the\n    # import library creation.\n    if ( [ os.name ] = NT || [ modules.peek : OS ] in CYGWIN ) &&\n        <main-target-type>LIB in $(properties)\n    {\n        .decl = "void __declspec(dllexport) foo() {}" ;\n    }\n    print.output $(<[1]) ;\n    print.text $(.decl:E="//")$(nl) ;\n    print.output $(<[2]) ;\n    print.text "#include <z.h>"$(nl) ;\n}\n')
    t.write('foo.py', 'import bjam\nimport b2.build.type as type\nimport b2.build.generators as generators\n\nfrom b2.manager import get_manager\n\ntype.register("FOO", ["foo"])\ngenerators.register_standard("foo.foo", ["FOO"], ["CPP", "H"])\n\ndef prepare_foo(targets, sources, properties):\n    if properties.get(\'os\') in [\'windows\', \'cygwin\']:\n        bjam.call(\'set-target-variable\', targets, "DECL",\n            "void __declspec(dllexport) foo() {}")\n\nget_manager().engine().register_action("foo.foo",\n    "echo -e $(DECL:E=//)\\\\n > $(<[1])\\n"\n    "echo -e "#include <z.h>\\\\n" > $(<[2])\\n", function=prepare_foo)\n')
    t.run_build_system()
    t.expect_addition('bin/$toolset/debug*/c.exe')
    t.touch('a.h')
    t.run_build_system()
    t.expect_touch('bin/$toolset/debug*/a.exe')
    t.expect_touch('bin/$toolset/debug*/a.obj')
    t.expect_touch('bin/$toolset/debug*/a_c.obj')
    t.expect_touch('bin/$toolset/debug*/b.exe')
    t.expect_touch('bin/$toolset/debug*/b.obj')
    t.expect_nothing_more()
    t.touch('src1/a.h')
    t.run_build_system()
    t.expect_touch('bin/$toolset/debug*/a.exe')
    t.expect_touch('bin/$toolset/debug*/a.obj')
    t.expect_touch('bin/$toolset/debug*/a_c.obj')
    t.expect_nothing_more()
    t.touch('src1/b.h')
    t.run_build_system()
    t.expect_touch('bin/$toolset/debug*/a.exe')
    t.expect_touch('bin/$toolset/debug*/a.obj')
    t.expect_touch('bin/$toolset/debug*/a_c.obj')
    t.expect_nothing_more()
    t.touch('src1/c.h')
    t.run_build_system()
    t.expect_touch('bin/$toolset/debug*/a.exe')
    t.touch('b.h')
    t.run_build_system()
    t.expect_nothing_more()
    t.touch('x.foo')
    t.run_build_system()
    t.expect_touch('bin/$toolset/debug*/a.obj')
    t.expect_touch('bin/$toolset/debug*/a_c.obj')
    t.touch('src1/z.h')
    t.run_build_system()
    t.expect_touch('bin/$toolset/debug*/a.obj')
    t.expect_touch('bin/$toolset/debug*/a_c.obj')
    t.cleanup()

def test_scanned_includes_with_absolute_paths():
    if False:
        for i in range(10):
            print('nop')
    '\n      Regression test: on Windows, <includes> with absolute paths were not\n    considered when scanning dependencies.\n\n    '
    t = BoostBuild.Tester(['-d3', '-d+12'])
    t.write('jamroot.jam', 'path-constant TOP : . ;\nexe app : main.cpp : <include>$(TOP)/include ;\n')
    t.write('main.cpp', '#include <dir/header.h>\nint main() {}\n')
    t.write('include/dir/header.h', '\n')
    t.run_build_system()
    t.expect_addition('bin/$toolset/debug*/main.obj')
    t.touch('include/dir/header.h')
    t.run_build_system()
    t.expect_touch('bin/$toolset/debug*/main.obj')
    t.cleanup()
test_basic()
test_scanned_includes_with_absolute_paths()