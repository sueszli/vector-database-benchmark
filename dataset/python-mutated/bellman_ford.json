[
    {
        "func_name": "bellman_ford",
        "original": "def bellman_ford(graph, source):\n    \"\"\"\n    This Bellman-Ford Code is for determination whether we can get\n    shortest path from given graph or not for single-source shortest-paths problem.\n    In other words, if given graph has any negative-weight cycle that is reachable\n    from the source, then it will give answer False for \"no solution exits\".\n    For argument graph, it should be a dictionary type\n    such as\n    graph = {\n        'a': {'b': 6, 'e': 7},\n        'b': {'c': 5, 'd': -4, 'e': 8},\n        'c': {'b': -2},\n        'd': {'a': 2, 'c': 7},\n        'e': {'b': -3}\n    }\n    \"\"\"\n    weight = {}\n    pre_node = {}\n    initialize_single_source(graph, source, weight, pre_node)\n    for _ in range(1, len(graph)):\n        for node in graph:\n            for adjacent in graph[node]:\n                if weight[adjacent] > weight[node] + graph[node][adjacent]:\n                    weight[adjacent] = weight[node] + graph[node][adjacent]\n                    pre_node[adjacent] = node\n    for node in graph:\n        for adjacent in graph[node]:\n            if weight[adjacent] > weight[node] + graph[node][adjacent]:\n                return False\n    return True",
        "mutated": [
            "def bellman_ford(graph, source):\n    if False:\n        i = 10\n    '\\n    This Bellman-Ford Code is for determination whether we can get\\n    shortest path from given graph or not for single-source shortest-paths problem.\\n    In other words, if given graph has any negative-weight cycle that is reachable\\n    from the source, then it will give answer False for \"no solution exits\".\\n    For argument graph, it should be a dictionary type\\n    such as\\n    graph = {\\n        \\'a\\': {\\'b\\': 6, \\'e\\': 7},\\n        \\'b\\': {\\'c\\': 5, \\'d\\': -4, \\'e\\': 8},\\n        \\'c\\': {\\'b\\': -2},\\n        \\'d\\': {\\'a\\': 2, \\'c\\': 7},\\n        \\'e\\': {\\'b\\': -3}\\n    }\\n    '\n    weight = {}\n    pre_node = {}\n    initialize_single_source(graph, source, weight, pre_node)\n    for _ in range(1, len(graph)):\n        for node in graph:\n            for adjacent in graph[node]:\n                if weight[adjacent] > weight[node] + graph[node][adjacent]:\n                    weight[adjacent] = weight[node] + graph[node][adjacent]\n                    pre_node[adjacent] = node\n    for node in graph:\n        for adjacent in graph[node]:\n            if weight[adjacent] > weight[node] + graph[node][adjacent]:\n                return False\n    return True",
            "def bellman_ford(graph, source):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    This Bellman-Ford Code is for determination whether we can get\\n    shortest path from given graph or not for single-source shortest-paths problem.\\n    In other words, if given graph has any negative-weight cycle that is reachable\\n    from the source, then it will give answer False for \"no solution exits\".\\n    For argument graph, it should be a dictionary type\\n    such as\\n    graph = {\\n        \\'a\\': {\\'b\\': 6, \\'e\\': 7},\\n        \\'b\\': {\\'c\\': 5, \\'d\\': -4, \\'e\\': 8},\\n        \\'c\\': {\\'b\\': -2},\\n        \\'d\\': {\\'a\\': 2, \\'c\\': 7},\\n        \\'e\\': {\\'b\\': -3}\\n    }\\n    '\n    weight = {}\n    pre_node = {}\n    initialize_single_source(graph, source, weight, pre_node)\n    for _ in range(1, len(graph)):\n        for node in graph:\n            for adjacent in graph[node]:\n                if weight[adjacent] > weight[node] + graph[node][adjacent]:\n                    weight[adjacent] = weight[node] + graph[node][adjacent]\n                    pre_node[adjacent] = node\n    for node in graph:\n        for adjacent in graph[node]:\n            if weight[adjacent] > weight[node] + graph[node][adjacent]:\n                return False\n    return True",
            "def bellman_ford(graph, source):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    This Bellman-Ford Code is for determination whether we can get\\n    shortest path from given graph or not for single-source shortest-paths problem.\\n    In other words, if given graph has any negative-weight cycle that is reachable\\n    from the source, then it will give answer False for \"no solution exits\".\\n    For argument graph, it should be a dictionary type\\n    such as\\n    graph = {\\n        \\'a\\': {\\'b\\': 6, \\'e\\': 7},\\n        \\'b\\': {\\'c\\': 5, \\'d\\': -4, \\'e\\': 8},\\n        \\'c\\': {\\'b\\': -2},\\n        \\'d\\': {\\'a\\': 2, \\'c\\': 7},\\n        \\'e\\': {\\'b\\': -3}\\n    }\\n    '\n    weight = {}\n    pre_node = {}\n    initialize_single_source(graph, source, weight, pre_node)\n    for _ in range(1, len(graph)):\n        for node in graph:\n            for adjacent in graph[node]:\n                if weight[adjacent] > weight[node] + graph[node][adjacent]:\n                    weight[adjacent] = weight[node] + graph[node][adjacent]\n                    pre_node[adjacent] = node\n    for node in graph:\n        for adjacent in graph[node]:\n            if weight[adjacent] > weight[node] + graph[node][adjacent]:\n                return False\n    return True",
            "def bellman_ford(graph, source):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    This Bellman-Ford Code is for determination whether we can get\\n    shortest path from given graph or not for single-source shortest-paths problem.\\n    In other words, if given graph has any negative-weight cycle that is reachable\\n    from the source, then it will give answer False for \"no solution exits\".\\n    For argument graph, it should be a dictionary type\\n    such as\\n    graph = {\\n        \\'a\\': {\\'b\\': 6, \\'e\\': 7},\\n        \\'b\\': {\\'c\\': 5, \\'d\\': -4, \\'e\\': 8},\\n        \\'c\\': {\\'b\\': -2},\\n        \\'d\\': {\\'a\\': 2, \\'c\\': 7},\\n        \\'e\\': {\\'b\\': -3}\\n    }\\n    '\n    weight = {}\n    pre_node = {}\n    initialize_single_source(graph, source, weight, pre_node)\n    for _ in range(1, len(graph)):\n        for node in graph:\n            for adjacent in graph[node]:\n                if weight[adjacent] > weight[node] + graph[node][adjacent]:\n                    weight[adjacent] = weight[node] + graph[node][adjacent]\n                    pre_node[adjacent] = node\n    for node in graph:\n        for adjacent in graph[node]:\n            if weight[adjacent] > weight[node] + graph[node][adjacent]:\n                return False\n    return True",
            "def bellman_ford(graph, source):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    This Bellman-Ford Code is for determination whether we can get\\n    shortest path from given graph or not for single-source shortest-paths problem.\\n    In other words, if given graph has any negative-weight cycle that is reachable\\n    from the source, then it will give answer False for \"no solution exits\".\\n    For argument graph, it should be a dictionary type\\n    such as\\n    graph = {\\n        \\'a\\': {\\'b\\': 6, \\'e\\': 7},\\n        \\'b\\': {\\'c\\': 5, \\'d\\': -4, \\'e\\': 8},\\n        \\'c\\': {\\'b\\': -2},\\n        \\'d\\': {\\'a\\': 2, \\'c\\': 7},\\n        \\'e\\': {\\'b\\': -3}\\n    }\\n    '\n    weight = {}\n    pre_node = {}\n    initialize_single_source(graph, source, weight, pre_node)\n    for _ in range(1, len(graph)):\n        for node in graph:\n            for adjacent in graph[node]:\n                if weight[adjacent] > weight[node] + graph[node][adjacent]:\n                    weight[adjacent] = weight[node] + graph[node][adjacent]\n                    pre_node[adjacent] = node\n    for node in graph:\n        for adjacent in graph[node]:\n            if weight[adjacent] > weight[node] + graph[node][adjacent]:\n                return False\n    return True"
        ]
    },
    {
        "func_name": "initialize_single_source",
        "original": "def initialize_single_source(graph, source, weight, pre_node):\n    \"\"\"\n    Initialize data structures for Bellman-Ford algorithm.\n    \"\"\"\n    for node in graph:\n        weight[node] = float('inf')\n        pre_node[node] = None\n    weight[source] = 0",
        "mutated": [
            "def initialize_single_source(graph, source, weight, pre_node):\n    if False:\n        i = 10\n    '\\n    Initialize data structures for Bellman-Ford algorithm.\\n    '\n    for node in graph:\n        weight[node] = float('inf')\n        pre_node[node] = None\n    weight[source] = 0",
            "def initialize_single_source(graph, source, weight, pre_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Initialize data structures for Bellman-Ford algorithm.\\n    '\n    for node in graph:\n        weight[node] = float('inf')\n        pre_node[node] = None\n    weight[source] = 0",
            "def initialize_single_source(graph, source, weight, pre_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Initialize data structures for Bellman-Ford algorithm.\\n    '\n    for node in graph:\n        weight[node] = float('inf')\n        pre_node[node] = None\n    weight[source] = 0",
            "def initialize_single_source(graph, source, weight, pre_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Initialize data structures for Bellman-Ford algorithm.\\n    '\n    for node in graph:\n        weight[node] = float('inf')\n        pre_node[node] = None\n    weight[source] = 0",
            "def initialize_single_source(graph, source, weight, pre_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Initialize data structures for Bellman-Ford algorithm.\\n    '\n    for node in graph:\n        weight[node] = float('inf')\n        pre_node[node] = None\n    weight[source] = 0"
        ]
    }
]