[
    {
        "func_name": "test_mcmt_as_normal_control",
        "original": "@data(MCMT, MCMTVChain)\ndef test_mcmt_as_normal_control(self, mcmt_class):\n    \"\"\"Test that the MCMT can act as normal control gate.\"\"\"\n    qc = QuantumCircuit(2)\n    mcmt = mcmt_class(gate=CHGate(), num_ctrl_qubits=1, num_target_qubits=1)\n    qc = qc.compose(mcmt, [0, 1])\n    ref = QuantumCircuit(2)\n    ref.ch(0, 1)\n    self.assertEqual(qc, ref)",
        "mutated": [
            "@data(MCMT, MCMTVChain)\ndef test_mcmt_as_normal_control(self, mcmt_class):\n    if False:\n        i = 10\n    'Test that the MCMT can act as normal control gate.'\n    qc = QuantumCircuit(2)\n    mcmt = mcmt_class(gate=CHGate(), num_ctrl_qubits=1, num_target_qubits=1)\n    qc = qc.compose(mcmt, [0, 1])\n    ref = QuantumCircuit(2)\n    ref.ch(0, 1)\n    self.assertEqual(qc, ref)",
            "@data(MCMT, MCMTVChain)\ndef test_mcmt_as_normal_control(self, mcmt_class):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test that the MCMT can act as normal control gate.'\n    qc = QuantumCircuit(2)\n    mcmt = mcmt_class(gate=CHGate(), num_ctrl_qubits=1, num_target_qubits=1)\n    qc = qc.compose(mcmt, [0, 1])\n    ref = QuantumCircuit(2)\n    ref.ch(0, 1)\n    self.assertEqual(qc, ref)",
            "@data(MCMT, MCMTVChain)\ndef test_mcmt_as_normal_control(self, mcmt_class):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test that the MCMT can act as normal control gate.'\n    qc = QuantumCircuit(2)\n    mcmt = mcmt_class(gate=CHGate(), num_ctrl_qubits=1, num_target_qubits=1)\n    qc = qc.compose(mcmt, [0, 1])\n    ref = QuantumCircuit(2)\n    ref.ch(0, 1)\n    self.assertEqual(qc, ref)",
            "@data(MCMT, MCMTVChain)\ndef test_mcmt_as_normal_control(self, mcmt_class):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test that the MCMT can act as normal control gate.'\n    qc = QuantumCircuit(2)\n    mcmt = mcmt_class(gate=CHGate(), num_ctrl_qubits=1, num_target_qubits=1)\n    qc = qc.compose(mcmt, [0, 1])\n    ref = QuantumCircuit(2)\n    ref.ch(0, 1)\n    self.assertEqual(qc, ref)",
            "@data(MCMT, MCMTVChain)\ndef test_mcmt_as_normal_control(self, mcmt_class):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test that the MCMT can act as normal control gate.'\n    qc = QuantumCircuit(2)\n    mcmt = mcmt_class(gate=CHGate(), num_ctrl_qubits=1, num_target_qubits=1)\n    qc = qc.compose(mcmt, [0, 1])\n    ref = QuantumCircuit(2)\n    ref.ch(0, 1)\n    self.assertEqual(qc, ref)"
        ]
    },
    {
        "func_name": "test_missing_qubits",
        "original": "def test_missing_qubits(self):\n    \"\"\"Test that an error is raised if qubits are missing.\"\"\"\n    with self.subTest(msg='no control qubits'):\n        with self.assertRaises(AttributeError):\n            _ = MCMT(XGate(), num_ctrl_qubits=0, num_target_qubits=1)\n    with self.subTest(msg='no target qubits'):\n        with self.assertRaises(AttributeError):\n            _ = MCMT(ZGate(), num_ctrl_qubits=4, num_target_qubits=0)",
        "mutated": [
            "def test_missing_qubits(self):\n    if False:\n        i = 10\n    'Test that an error is raised if qubits are missing.'\n    with self.subTest(msg='no control qubits'):\n        with self.assertRaises(AttributeError):\n            _ = MCMT(XGate(), num_ctrl_qubits=0, num_target_qubits=1)\n    with self.subTest(msg='no target qubits'):\n        with self.assertRaises(AttributeError):\n            _ = MCMT(ZGate(), num_ctrl_qubits=4, num_target_qubits=0)",
            "def test_missing_qubits(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test that an error is raised if qubits are missing.'\n    with self.subTest(msg='no control qubits'):\n        with self.assertRaises(AttributeError):\n            _ = MCMT(XGate(), num_ctrl_qubits=0, num_target_qubits=1)\n    with self.subTest(msg='no target qubits'):\n        with self.assertRaises(AttributeError):\n            _ = MCMT(ZGate(), num_ctrl_qubits=4, num_target_qubits=0)",
            "def test_missing_qubits(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test that an error is raised if qubits are missing.'\n    with self.subTest(msg='no control qubits'):\n        with self.assertRaises(AttributeError):\n            _ = MCMT(XGate(), num_ctrl_qubits=0, num_target_qubits=1)\n    with self.subTest(msg='no target qubits'):\n        with self.assertRaises(AttributeError):\n            _ = MCMT(ZGate(), num_ctrl_qubits=4, num_target_qubits=0)",
            "def test_missing_qubits(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test that an error is raised if qubits are missing.'\n    with self.subTest(msg='no control qubits'):\n        with self.assertRaises(AttributeError):\n            _ = MCMT(XGate(), num_ctrl_qubits=0, num_target_qubits=1)\n    with self.subTest(msg='no target qubits'):\n        with self.assertRaises(AttributeError):\n            _ = MCMT(ZGate(), num_ctrl_qubits=4, num_target_qubits=0)",
            "def test_missing_qubits(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test that an error is raised if qubits are missing.'\n    with self.subTest(msg='no control qubits'):\n        with self.assertRaises(AttributeError):\n            _ = MCMT(XGate(), num_ctrl_qubits=0, num_target_qubits=1)\n    with self.subTest(msg='no target qubits'):\n        with self.assertRaises(AttributeError):\n            _ = MCMT(ZGate(), num_ctrl_qubits=4, num_target_qubits=0)"
        ]
    },
    {
        "func_name": "test_different_gate_types",
        "original": "def test_different_gate_types(self):\n    \"\"\"Test the different supported input types for the target gate.\"\"\"\n    x_circ = QuantumCircuit(1)\n    x_circ.x(0)\n    for input_gate in [x_circ, QuantumCircuit.cx, QuantumCircuit.x, 'cx', 'x', CXGate()]:\n        with self.subTest(input_gate=input_gate):\n            mcmt = MCMT(input_gate, 2, 2)\n            if isinstance(input_gate, QuantumCircuit):\n                self.assertEqual(mcmt.gate.definition[0].operation, XGate())\n                self.assertEqual(len(mcmt.gate.definition), 1)\n            else:\n                self.assertEqual(mcmt.gate, XGate())",
        "mutated": [
            "def test_different_gate_types(self):\n    if False:\n        i = 10\n    'Test the different supported input types for the target gate.'\n    x_circ = QuantumCircuit(1)\n    x_circ.x(0)\n    for input_gate in [x_circ, QuantumCircuit.cx, QuantumCircuit.x, 'cx', 'x', CXGate()]:\n        with self.subTest(input_gate=input_gate):\n            mcmt = MCMT(input_gate, 2, 2)\n            if isinstance(input_gate, QuantumCircuit):\n                self.assertEqual(mcmt.gate.definition[0].operation, XGate())\n                self.assertEqual(len(mcmt.gate.definition), 1)\n            else:\n                self.assertEqual(mcmt.gate, XGate())",
            "def test_different_gate_types(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test the different supported input types for the target gate.'\n    x_circ = QuantumCircuit(1)\n    x_circ.x(0)\n    for input_gate in [x_circ, QuantumCircuit.cx, QuantumCircuit.x, 'cx', 'x', CXGate()]:\n        with self.subTest(input_gate=input_gate):\n            mcmt = MCMT(input_gate, 2, 2)\n            if isinstance(input_gate, QuantumCircuit):\n                self.assertEqual(mcmt.gate.definition[0].operation, XGate())\n                self.assertEqual(len(mcmt.gate.definition), 1)\n            else:\n                self.assertEqual(mcmt.gate, XGate())",
            "def test_different_gate_types(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test the different supported input types for the target gate.'\n    x_circ = QuantumCircuit(1)\n    x_circ.x(0)\n    for input_gate in [x_circ, QuantumCircuit.cx, QuantumCircuit.x, 'cx', 'x', CXGate()]:\n        with self.subTest(input_gate=input_gate):\n            mcmt = MCMT(input_gate, 2, 2)\n            if isinstance(input_gate, QuantumCircuit):\n                self.assertEqual(mcmt.gate.definition[0].operation, XGate())\n                self.assertEqual(len(mcmt.gate.definition), 1)\n            else:\n                self.assertEqual(mcmt.gate, XGate())",
            "def test_different_gate_types(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test the different supported input types for the target gate.'\n    x_circ = QuantumCircuit(1)\n    x_circ.x(0)\n    for input_gate in [x_circ, QuantumCircuit.cx, QuantumCircuit.x, 'cx', 'x', CXGate()]:\n        with self.subTest(input_gate=input_gate):\n            mcmt = MCMT(input_gate, 2, 2)\n            if isinstance(input_gate, QuantumCircuit):\n                self.assertEqual(mcmt.gate.definition[0].operation, XGate())\n                self.assertEqual(len(mcmt.gate.definition), 1)\n            else:\n                self.assertEqual(mcmt.gate, XGate())",
            "def test_different_gate_types(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test the different supported input types for the target gate.'\n    x_circ = QuantumCircuit(1)\n    x_circ.x(0)\n    for input_gate in [x_circ, QuantumCircuit.cx, QuantumCircuit.x, 'cx', 'x', CXGate()]:\n        with self.subTest(input_gate=input_gate):\n            mcmt = MCMT(input_gate, 2, 2)\n            if isinstance(input_gate, QuantumCircuit):\n                self.assertEqual(mcmt.gate.definition[0].operation, XGate())\n                self.assertEqual(len(mcmt.gate.definition), 1)\n            else:\n                self.assertEqual(mcmt.gate, XGate())"
        ]
    },
    {
        "func_name": "test_mcmt_v_chain_ancilla_test",
        "original": "def test_mcmt_v_chain_ancilla_test(self):\n    \"\"\"Test too few and too many ancillas for the MCMT V-chain mode.\"\"\"\n    with self.subTest(msg='insufficient number of auxiliary qubits on gate'):\n        qc = QuantumCircuit(5)\n        mcmt = MCMTVChain(ZGate(), 3, 1)\n        with self.assertRaises(QiskitError):\n            qc.append(mcmt, range(5))\n    with self.subTest(msg='too many auxiliary qubits on gate'):\n        qc = QuantumCircuit(9)\n        mcmt = MCMTVChain(ZGate(), 3, 1)\n        with self.assertRaises(QiskitError):\n            qc.append(mcmt, range(9))",
        "mutated": [
            "def test_mcmt_v_chain_ancilla_test(self):\n    if False:\n        i = 10\n    'Test too few and too many ancillas for the MCMT V-chain mode.'\n    with self.subTest(msg='insufficient number of auxiliary qubits on gate'):\n        qc = QuantumCircuit(5)\n        mcmt = MCMTVChain(ZGate(), 3, 1)\n        with self.assertRaises(QiskitError):\n            qc.append(mcmt, range(5))\n    with self.subTest(msg='too many auxiliary qubits on gate'):\n        qc = QuantumCircuit(9)\n        mcmt = MCMTVChain(ZGate(), 3, 1)\n        with self.assertRaises(QiskitError):\n            qc.append(mcmt, range(9))",
            "def test_mcmt_v_chain_ancilla_test(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test too few and too many ancillas for the MCMT V-chain mode.'\n    with self.subTest(msg='insufficient number of auxiliary qubits on gate'):\n        qc = QuantumCircuit(5)\n        mcmt = MCMTVChain(ZGate(), 3, 1)\n        with self.assertRaises(QiskitError):\n            qc.append(mcmt, range(5))\n    with self.subTest(msg='too many auxiliary qubits on gate'):\n        qc = QuantumCircuit(9)\n        mcmt = MCMTVChain(ZGate(), 3, 1)\n        with self.assertRaises(QiskitError):\n            qc.append(mcmt, range(9))",
            "def test_mcmt_v_chain_ancilla_test(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test too few and too many ancillas for the MCMT V-chain mode.'\n    with self.subTest(msg='insufficient number of auxiliary qubits on gate'):\n        qc = QuantumCircuit(5)\n        mcmt = MCMTVChain(ZGate(), 3, 1)\n        with self.assertRaises(QiskitError):\n            qc.append(mcmt, range(5))\n    with self.subTest(msg='too many auxiliary qubits on gate'):\n        qc = QuantumCircuit(9)\n        mcmt = MCMTVChain(ZGate(), 3, 1)\n        with self.assertRaises(QiskitError):\n            qc.append(mcmt, range(9))",
            "def test_mcmt_v_chain_ancilla_test(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test too few and too many ancillas for the MCMT V-chain mode.'\n    with self.subTest(msg='insufficient number of auxiliary qubits on gate'):\n        qc = QuantumCircuit(5)\n        mcmt = MCMTVChain(ZGate(), 3, 1)\n        with self.assertRaises(QiskitError):\n            qc.append(mcmt, range(5))\n    with self.subTest(msg='too many auxiliary qubits on gate'):\n        qc = QuantumCircuit(9)\n        mcmt = MCMTVChain(ZGate(), 3, 1)\n        with self.assertRaises(QiskitError):\n            qc.append(mcmt, range(9))",
            "def test_mcmt_v_chain_ancilla_test(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test too few and too many ancillas for the MCMT V-chain mode.'\n    with self.subTest(msg='insufficient number of auxiliary qubits on gate'):\n        qc = QuantumCircuit(5)\n        mcmt = MCMTVChain(ZGate(), 3, 1)\n        with self.assertRaises(QiskitError):\n            qc.append(mcmt, range(5))\n    with self.subTest(msg='too many auxiliary qubits on gate'):\n        qc = QuantumCircuit(9)\n        mcmt = MCMTVChain(ZGate(), 3, 1)\n        with self.assertRaises(QiskitError):\n            qc.append(mcmt, range(9))"
        ]
    },
    {
        "func_name": "test_mcmt_v_chain_simulation",
        "original": "@data([CZGate(), 1, 1], [CHGate(), 1, 1], [CZGate(), 3, 3], [CHGate(), 3, 3], [CZGate(), 1, 5], [CHGate(), 1, 5], [CZGate(), 5, 1], [CHGate(), 5, 1])\n@unpack\ndef test_mcmt_v_chain_simulation(self, cgate, num_controls, num_targets):\n    \"\"\"Test the MCMT V-chain implementation test on a simulation.\"\"\"\n    controls = QuantumRegister(num_controls)\n    targets = QuantumRegister(num_targets)\n    subsets = [tuple(range(i)) for i in range(num_controls + 1)]\n    for subset in subsets:\n        qc = QuantumCircuit(targets, controls)\n        qc.x(targets)\n        num_ancillas = max(0, num_controls - 1)\n        if num_ancillas > 0:\n            ancillas = QuantumRegister(num_ancillas)\n            qc.add_register(ancillas)\n            qubits = controls[:] + targets[:] + ancillas[:]\n        else:\n            qubits = controls[:] + targets[:]\n        for i in subset:\n            qc.x(controls[i])\n        mcmt = MCMTVChain(cgate, num_controls, num_targets)\n        qc.compose(mcmt, qubits, inplace=True)\n        for i in subset:\n            qc.x(controls[i])\n        vec = Statevector.from_label('0' * qc.num_qubits).evolve(qc)\n        vec_exp = np.array([0] * (2 ** num_targets - 1) + [1])\n        if isinstance(cgate, CZGate):\n            if len(subset) == num_controls and num_controls % 2 == 1:\n                vec_exp[-1] = -1\n        elif isinstance(cgate, CHGate):\n            if len(subset) == num_controls:\n                h_i = 1 / np.sqrt(2) * np.array([[1, 1], [1, -1]])\n                h_tot = np.array([1])\n                for _ in range(num_targets):\n                    h_tot = np.kron(h_tot, h_i)\n                vec_exp = np.dot(h_tot, vec_exp)\n        else:\n            raise ValueError(f'Test not implement for gate: {cgate}')\n        vec_exp = np.concatenate((vec_exp, [0] * (2 ** (num_controls + num_ancillas + num_targets) - vec_exp.size)))\n        f_i = state_fidelity(vec, vec_exp)\n        self.assertAlmostEqual(f_i, 1)",
        "mutated": [
            "@data([CZGate(), 1, 1], [CHGate(), 1, 1], [CZGate(), 3, 3], [CHGate(), 3, 3], [CZGate(), 1, 5], [CHGate(), 1, 5], [CZGate(), 5, 1], [CHGate(), 5, 1])\n@unpack\ndef test_mcmt_v_chain_simulation(self, cgate, num_controls, num_targets):\n    if False:\n        i = 10\n    'Test the MCMT V-chain implementation test on a simulation.'\n    controls = QuantumRegister(num_controls)\n    targets = QuantumRegister(num_targets)\n    subsets = [tuple(range(i)) for i in range(num_controls + 1)]\n    for subset in subsets:\n        qc = QuantumCircuit(targets, controls)\n        qc.x(targets)\n        num_ancillas = max(0, num_controls - 1)\n        if num_ancillas > 0:\n            ancillas = QuantumRegister(num_ancillas)\n            qc.add_register(ancillas)\n            qubits = controls[:] + targets[:] + ancillas[:]\n        else:\n            qubits = controls[:] + targets[:]\n        for i in subset:\n            qc.x(controls[i])\n        mcmt = MCMTVChain(cgate, num_controls, num_targets)\n        qc.compose(mcmt, qubits, inplace=True)\n        for i in subset:\n            qc.x(controls[i])\n        vec = Statevector.from_label('0' * qc.num_qubits).evolve(qc)\n        vec_exp = np.array([0] * (2 ** num_targets - 1) + [1])\n        if isinstance(cgate, CZGate):\n            if len(subset) == num_controls and num_controls % 2 == 1:\n                vec_exp[-1] = -1\n        elif isinstance(cgate, CHGate):\n            if len(subset) == num_controls:\n                h_i = 1 / np.sqrt(2) * np.array([[1, 1], [1, -1]])\n                h_tot = np.array([1])\n                for _ in range(num_targets):\n                    h_tot = np.kron(h_tot, h_i)\n                vec_exp = np.dot(h_tot, vec_exp)\n        else:\n            raise ValueError(f'Test not implement for gate: {cgate}')\n        vec_exp = np.concatenate((vec_exp, [0] * (2 ** (num_controls + num_ancillas + num_targets) - vec_exp.size)))\n        f_i = state_fidelity(vec, vec_exp)\n        self.assertAlmostEqual(f_i, 1)",
            "@data([CZGate(), 1, 1], [CHGate(), 1, 1], [CZGate(), 3, 3], [CHGate(), 3, 3], [CZGate(), 1, 5], [CHGate(), 1, 5], [CZGate(), 5, 1], [CHGate(), 5, 1])\n@unpack\ndef test_mcmt_v_chain_simulation(self, cgate, num_controls, num_targets):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test the MCMT V-chain implementation test on a simulation.'\n    controls = QuantumRegister(num_controls)\n    targets = QuantumRegister(num_targets)\n    subsets = [tuple(range(i)) for i in range(num_controls + 1)]\n    for subset in subsets:\n        qc = QuantumCircuit(targets, controls)\n        qc.x(targets)\n        num_ancillas = max(0, num_controls - 1)\n        if num_ancillas > 0:\n            ancillas = QuantumRegister(num_ancillas)\n            qc.add_register(ancillas)\n            qubits = controls[:] + targets[:] + ancillas[:]\n        else:\n            qubits = controls[:] + targets[:]\n        for i in subset:\n            qc.x(controls[i])\n        mcmt = MCMTVChain(cgate, num_controls, num_targets)\n        qc.compose(mcmt, qubits, inplace=True)\n        for i in subset:\n            qc.x(controls[i])\n        vec = Statevector.from_label('0' * qc.num_qubits).evolve(qc)\n        vec_exp = np.array([0] * (2 ** num_targets - 1) + [1])\n        if isinstance(cgate, CZGate):\n            if len(subset) == num_controls and num_controls % 2 == 1:\n                vec_exp[-1] = -1\n        elif isinstance(cgate, CHGate):\n            if len(subset) == num_controls:\n                h_i = 1 / np.sqrt(2) * np.array([[1, 1], [1, -1]])\n                h_tot = np.array([1])\n                for _ in range(num_targets):\n                    h_tot = np.kron(h_tot, h_i)\n                vec_exp = np.dot(h_tot, vec_exp)\n        else:\n            raise ValueError(f'Test not implement for gate: {cgate}')\n        vec_exp = np.concatenate((vec_exp, [0] * (2 ** (num_controls + num_ancillas + num_targets) - vec_exp.size)))\n        f_i = state_fidelity(vec, vec_exp)\n        self.assertAlmostEqual(f_i, 1)",
            "@data([CZGate(), 1, 1], [CHGate(), 1, 1], [CZGate(), 3, 3], [CHGate(), 3, 3], [CZGate(), 1, 5], [CHGate(), 1, 5], [CZGate(), 5, 1], [CHGate(), 5, 1])\n@unpack\ndef test_mcmt_v_chain_simulation(self, cgate, num_controls, num_targets):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test the MCMT V-chain implementation test on a simulation.'\n    controls = QuantumRegister(num_controls)\n    targets = QuantumRegister(num_targets)\n    subsets = [tuple(range(i)) for i in range(num_controls + 1)]\n    for subset in subsets:\n        qc = QuantumCircuit(targets, controls)\n        qc.x(targets)\n        num_ancillas = max(0, num_controls - 1)\n        if num_ancillas > 0:\n            ancillas = QuantumRegister(num_ancillas)\n            qc.add_register(ancillas)\n            qubits = controls[:] + targets[:] + ancillas[:]\n        else:\n            qubits = controls[:] + targets[:]\n        for i in subset:\n            qc.x(controls[i])\n        mcmt = MCMTVChain(cgate, num_controls, num_targets)\n        qc.compose(mcmt, qubits, inplace=True)\n        for i in subset:\n            qc.x(controls[i])\n        vec = Statevector.from_label('0' * qc.num_qubits).evolve(qc)\n        vec_exp = np.array([0] * (2 ** num_targets - 1) + [1])\n        if isinstance(cgate, CZGate):\n            if len(subset) == num_controls and num_controls % 2 == 1:\n                vec_exp[-1] = -1\n        elif isinstance(cgate, CHGate):\n            if len(subset) == num_controls:\n                h_i = 1 / np.sqrt(2) * np.array([[1, 1], [1, -1]])\n                h_tot = np.array([1])\n                for _ in range(num_targets):\n                    h_tot = np.kron(h_tot, h_i)\n                vec_exp = np.dot(h_tot, vec_exp)\n        else:\n            raise ValueError(f'Test not implement for gate: {cgate}')\n        vec_exp = np.concatenate((vec_exp, [0] * (2 ** (num_controls + num_ancillas + num_targets) - vec_exp.size)))\n        f_i = state_fidelity(vec, vec_exp)\n        self.assertAlmostEqual(f_i, 1)",
            "@data([CZGate(), 1, 1], [CHGate(), 1, 1], [CZGate(), 3, 3], [CHGate(), 3, 3], [CZGate(), 1, 5], [CHGate(), 1, 5], [CZGate(), 5, 1], [CHGate(), 5, 1])\n@unpack\ndef test_mcmt_v_chain_simulation(self, cgate, num_controls, num_targets):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test the MCMT V-chain implementation test on a simulation.'\n    controls = QuantumRegister(num_controls)\n    targets = QuantumRegister(num_targets)\n    subsets = [tuple(range(i)) for i in range(num_controls + 1)]\n    for subset in subsets:\n        qc = QuantumCircuit(targets, controls)\n        qc.x(targets)\n        num_ancillas = max(0, num_controls - 1)\n        if num_ancillas > 0:\n            ancillas = QuantumRegister(num_ancillas)\n            qc.add_register(ancillas)\n            qubits = controls[:] + targets[:] + ancillas[:]\n        else:\n            qubits = controls[:] + targets[:]\n        for i in subset:\n            qc.x(controls[i])\n        mcmt = MCMTVChain(cgate, num_controls, num_targets)\n        qc.compose(mcmt, qubits, inplace=True)\n        for i in subset:\n            qc.x(controls[i])\n        vec = Statevector.from_label('0' * qc.num_qubits).evolve(qc)\n        vec_exp = np.array([0] * (2 ** num_targets - 1) + [1])\n        if isinstance(cgate, CZGate):\n            if len(subset) == num_controls and num_controls % 2 == 1:\n                vec_exp[-1] = -1\n        elif isinstance(cgate, CHGate):\n            if len(subset) == num_controls:\n                h_i = 1 / np.sqrt(2) * np.array([[1, 1], [1, -1]])\n                h_tot = np.array([1])\n                for _ in range(num_targets):\n                    h_tot = np.kron(h_tot, h_i)\n                vec_exp = np.dot(h_tot, vec_exp)\n        else:\n            raise ValueError(f'Test not implement for gate: {cgate}')\n        vec_exp = np.concatenate((vec_exp, [0] * (2 ** (num_controls + num_ancillas + num_targets) - vec_exp.size)))\n        f_i = state_fidelity(vec, vec_exp)\n        self.assertAlmostEqual(f_i, 1)",
            "@data([CZGate(), 1, 1], [CHGate(), 1, 1], [CZGate(), 3, 3], [CHGate(), 3, 3], [CZGate(), 1, 5], [CHGate(), 1, 5], [CZGate(), 5, 1], [CHGate(), 5, 1])\n@unpack\ndef test_mcmt_v_chain_simulation(self, cgate, num_controls, num_targets):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test the MCMT V-chain implementation test on a simulation.'\n    controls = QuantumRegister(num_controls)\n    targets = QuantumRegister(num_targets)\n    subsets = [tuple(range(i)) for i in range(num_controls + 1)]\n    for subset in subsets:\n        qc = QuantumCircuit(targets, controls)\n        qc.x(targets)\n        num_ancillas = max(0, num_controls - 1)\n        if num_ancillas > 0:\n            ancillas = QuantumRegister(num_ancillas)\n            qc.add_register(ancillas)\n            qubits = controls[:] + targets[:] + ancillas[:]\n        else:\n            qubits = controls[:] + targets[:]\n        for i in subset:\n            qc.x(controls[i])\n        mcmt = MCMTVChain(cgate, num_controls, num_targets)\n        qc.compose(mcmt, qubits, inplace=True)\n        for i in subset:\n            qc.x(controls[i])\n        vec = Statevector.from_label('0' * qc.num_qubits).evolve(qc)\n        vec_exp = np.array([0] * (2 ** num_targets - 1) + [1])\n        if isinstance(cgate, CZGate):\n            if len(subset) == num_controls and num_controls % 2 == 1:\n                vec_exp[-1] = -1\n        elif isinstance(cgate, CHGate):\n            if len(subset) == num_controls:\n                h_i = 1 / np.sqrt(2) * np.array([[1, 1], [1, -1]])\n                h_tot = np.array([1])\n                for _ in range(num_targets):\n                    h_tot = np.kron(h_tot, h_i)\n                vec_exp = np.dot(h_tot, vec_exp)\n        else:\n            raise ValueError(f'Test not implement for gate: {cgate}')\n        vec_exp = np.concatenate((vec_exp, [0] * (2 ** (num_controls + num_ancillas + num_targets) - vec_exp.size)))\n        f_i = state_fidelity(vec, vec_exp)\n        self.assertAlmostEqual(f_i, 1)"
        ]
    }
]