[
    {
        "func_name": "weakly_connected_components",
        "original": "@not_implemented_for('undirected')\n@nx._dispatch\ndef weakly_connected_components(G):\n    \"\"\"Generate weakly connected components of G.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        A directed graph\n\n    Returns\n    -------\n    comp : generator of sets\n        A generator of sets of nodes, one for each weakly connected\n        component of G.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If G is undirected.\n\n    Examples\n    --------\n    Generate a sorted list of weakly connected components, largest first.\n\n    >>> G = nx.path_graph(4, create_using=nx.DiGraph())\n    >>> nx.add_path(G, [10, 11, 12])\n    >>> [\n    ...     len(c)\n    ...     for c in sorted(nx.weakly_connected_components(G), key=len, reverse=True)\n    ... ]\n    [4, 3]\n\n    If you only want the largest component, it's more efficient to\n    use max instead of sort:\n\n    >>> largest_cc = max(nx.weakly_connected_components(G), key=len)\n\n    See Also\n    --------\n    connected_components\n    strongly_connected_components\n\n    Notes\n    -----\n    For directed graphs only.\n\n    \"\"\"\n    seen = set()\n    for v in G:\n        if v not in seen:\n            c = set(_plain_bfs(G, v))\n            seen.update(c)\n            yield c",
        "mutated": [
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef weakly_connected_components(G):\n    if False:\n        i = 10\n    \"Generate weakly connected components of G.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        A directed graph\\n\\n    Returns\\n    -------\\n    comp : generator of sets\\n        A generator of sets of nodes, one for each weakly connected\\n        component of G.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If G is undirected.\\n\\n    Examples\\n    --------\\n    Generate a sorted list of weakly connected components, largest first.\\n\\n    >>> G = nx.path_graph(4, create_using=nx.DiGraph())\\n    >>> nx.add_path(G, [10, 11, 12])\\n    >>> [\\n    ...     len(c)\\n    ...     for c in sorted(nx.weakly_connected_components(G), key=len, reverse=True)\\n    ... ]\\n    [4, 3]\\n\\n    If you only want the largest component, it's more efficient to\\n    use max instead of sort:\\n\\n    >>> largest_cc = max(nx.weakly_connected_components(G), key=len)\\n\\n    See Also\\n    --------\\n    connected_components\\n    strongly_connected_components\\n\\n    Notes\\n    -----\\n    For directed graphs only.\\n\\n    \"\n    seen = set()\n    for v in G:\n        if v not in seen:\n            c = set(_plain_bfs(G, v))\n            seen.update(c)\n            yield c",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef weakly_connected_components(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Generate weakly connected components of G.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        A directed graph\\n\\n    Returns\\n    -------\\n    comp : generator of sets\\n        A generator of sets of nodes, one for each weakly connected\\n        component of G.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If G is undirected.\\n\\n    Examples\\n    --------\\n    Generate a sorted list of weakly connected components, largest first.\\n\\n    >>> G = nx.path_graph(4, create_using=nx.DiGraph())\\n    >>> nx.add_path(G, [10, 11, 12])\\n    >>> [\\n    ...     len(c)\\n    ...     for c in sorted(nx.weakly_connected_components(G), key=len, reverse=True)\\n    ... ]\\n    [4, 3]\\n\\n    If you only want the largest component, it's more efficient to\\n    use max instead of sort:\\n\\n    >>> largest_cc = max(nx.weakly_connected_components(G), key=len)\\n\\n    See Also\\n    --------\\n    connected_components\\n    strongly_connected_components\\n\\n    Notes\\n    -----\\n    For directed graphs only.\\n\\n    \"\n    seen = set()\n    for v in G:\n        if v not in seen:\n            c = set(_plain_bfs(G, v))\n            seen.update(c)\n            yield c",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef weakly_connected_components(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Generate weakly connected components of G.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        A directed graph\\n\\n    Returns\\n    -------\\n    comp : generator of sets\\n        A generator of sets of nodes, one for each weakly connected\\n        component of G.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If G is undirected.\\n\\n    Examples\\n    --------\\n    Generate a sorted list of weakly connected components, largest first.\\n\\n    >>> G = nx.path_graph(4, create_using=nx.DiGraph())\\n    >>> nx.add_path(G, [10, 11, 12])\\n    >>> [\\n    ...     len(c)\\n    ...     for c in sorted(nx.weakly_connected_components(G), key=len, reverse=True)\\n    ... ]\\n    [4, 3]\\n\\n    If you only want the largest component, it's more efficient to\\n    use max instead of sort:\\n\\n    >>> largest_cc = max(nx.weakly_connected_components(G), key=len)\\n\\n    See Also\\n    --------\\n    connected_components\\n    strongly_connected_components\\n\\n    Notes\\n    -----\\n    For directed graphs only.\\n\\n    \"\n    seen = set()\n    for v in G:\n        if v not in seen:\n            c = set(_plain_bfs(G, v))\n            seen.update(c)\n            yield c",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef weakly_connected_components(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Generate weakly connected components of G.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        A directed graph\\n\\n    Returns\\n    -------\\n    comp : generator of sets\\n        A generator of sets of nodes, one for each weakly connected\\n        component of G.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If G is undirected.\\n\\n    Examples\\n    --------\\n    Generate a sorted list of weakly connected components, largest first.\\n\\n    >>> G = nx.path_graph(4, create_using=nx.DiGraph())\\n    >>> nx.add_path(G, [10, 11, 12])\\n    >>> [\\n    ...     len(c)\\n    ...     for c in sorted(nx.weakly_connected_components(G), key=len, reverse=True)\\n    ... ]\\n    [4, 3]\\n\\n    If you only want the largest component, it's more efficient to\\n    use max instead of sort:\\n\\n    >>> largest_cc = max(nx.weakly_connected_components(G), key=len)\\n\\n    See Also\\n    --------\\n    connected_components\\n    strongly_connected_components\\n\\n    Notes\\n    -----\\n    For directed graphs only.\\n\\n    \"\n    seen = set()\n    for v in G:\n        if v not in seen:\n            c = set(_plain_bfs(G, v))\n            seen.update(c)\n            yield c",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef weakly_connected_components(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Generate weakly connected components of G.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        A directed graph\\n\\n    Returns\\n    -------\\n    comp : generator of sets\\n        A generator of sets of nodes, one for each weakly connected\\n        component of G.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If G is undirected.\\n\\n    Examples\\n    --------\\n    Generate a sorted list of weakly connected components, largest first.\\n\\n    >>> G = nx.path_graph(4, create_using=nx.DiGraph())\\n    >>> nx.add_path(G, [10, 11, 12])\\n    >>> [\\n    ...     len(c)\\n    ...     for c in sorted(nx.weakly_connected_components(G), key=len, reverse=True)\\n    ... ]\\n    [4, 3]\\n\\n    If you only want the largest component, it's more efficient to\\n    use max instead of sort:\\n\\n    >>> largest_cc = max(nx.weakly_connected_components(G), key=len)\\n\\n    See Also\\n    --------\\n    connected_components\\n    strongly_connected_components\\n\\n    Notes\\n    -----\\n    For directed graphs only.\\n\\n    \"\n    seen = set()\n    for v in G:\n        if v not in seen:\n            c = set(_plain_bfs(G, v))\n            seen.update(c)\n            yield c"
        ]
    },
    {
        "func_name": "number_weakly_connected_components",
        "original": "@not_implemented_for('undirected')\n@nx._dispatch\ndef number_weakly_connected_components(G):\n    \"\"\"Returns the number of weakly connected components in G.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        A directed graph.\n\n    Returns\n    -------\n    n : integer\n        Number of weakly connected components\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If G is undirected.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(0, 1), (2, 1), (3, 4)])\n    >>> nx.number_weakly_connected_components(G)\n    2\n\n    See Also\n    --------\n    weakly_connected_components\n    number_connected_components\n    number_strongly_connected_components\n\n    Notes\n    -----\n    For directed graphs only.\n\n    \"\"\"\n    return sum((1 for wcc in weakly_connected_components(G)))",
        "mutated": [
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef number_weakly_connected_components(G):\n    if False:\n        i = 10\n    'Returns the number of weakly connected components in G.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        A directed graph.\\n\\n    Returns\\n    -------\\n    n : integer\\n        Number of weakly connected components\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If G is undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(0, 1), (2, 1), (3, 4)])\\n    >>> nx.number_weakly_connected_components(G)\\n    2\\n\\n    See Also\\n    --------\\n    weakly_connected_components\\n    number_connected_components\\n    number_strongly_connected_components\\n\\n    Notes\\n    -----\\n    For directed graphs only.\\n\\n    '\n    return sum((1 for wcc in weakly_connected_components(G)))",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef number_weakly_connected_components(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the number of weakly connected components in G.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        A directed graph.\\n\\n    Returns\\n    -------\\n    n : integer\\n        Number of weakly connected components\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If G is undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(0, 1), (2, 1), (3, 4)])\\n    >>> nx.number_weakly_connected_components(G)\\n    2\\n\\n    See Also\\n    --------\\n    weakly_connected_components\\n    number_connected_components\\n    number_strongly_connected_components\\n\\n    Notes\\n    -----\\n    For directed graphs only.\\n\\n    '\n    return sum((1 for wcc in weakly_connected_components(G)))",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef number_weakly_connected_components(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the number of weakly connected components in G.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        A directed graph.\\n\\n    Returns\\n    -------\\n    n : integer\\n        Number of weakly connected components\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If G is undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(0, 1), (2, 1), (3, 4)])\\n    >>> nx.number_weakly_connected_components(G)\\n    2\\n\\n    See Also\\n    --------\\n    weakly_connected_components\\n    number_connected_components\\n    number_strongly_connected_components\\n\\n    Notes\\n    -----\\n    For directed graphs only.\\n\\n    '\n    return sum((1 for wcc in weakly_connected_components(G)))",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef number_weakly_connected_components(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the number of weakly connected components in G.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        A directed graph.\\n\\n    Returns\\n    -------\\n    n : integer\\n        Number of weakly connected components\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If G is undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(0, 1), (2, 1), (3, 4)])\\n    >>> nx.number_weakly_connected_components(G)\\n    2\\n\\n    See Also\\n    --------\\n    weakly_connected_components\\n    number_connected_components\\n    number_strongly_connected_components\\n\\n    Notes\\n    -----\\n    For directed graphs only.\\n\\n    '\n    return sum((1 for wcc in weakly_connected_components(G)))",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef number_weakly_connected_components(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the number of weakly connected components in G.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        A directed graph.\\n\\n    Returns\\n    -------\\n    n : integer\\n        Number of weakly connected components\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If G is undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(0, 1), (2, 1), (3, 4)])\\n    >>> nx.number_weakly_connected_components(G)\\n    2\\n\\n    See Also\\n    --------\\n    weakly_connected_components\\n    number_connected_components\\n    number_strongly_connected_components\\n\\n    Notes\\n    -----\\n    For directed graphs only.\\n\\n    '\n    return sum((1 for wcc in weakly_connected_components(G)))"
        ]
    },
    {
        "func_name": "is_weakly_connected",
        "original": "@not_implemented_for('undirected')\n@nx._dispatch\ndef is_weakly_connected(G):\n    \"\"\"Test directed graph for weak connectivity.\n\n    A directed graph is weakly connected if and only if the graph\n    is connected when the direction of the edge between nodes is ignored.\n\n    Note that if a graph is strongly connected (i.e. the graph is connected\n    even when we account for directionality), it is by definition weakly\n    connected as well.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n        A directed graph.\n\n    Returns\n    -------\n    connected : bool\n        True if the graph is weakly connected, False otherwise.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If G is undirected.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(0, 1), (2, 1)])\n    >>> G.add_node(3)\n    >>> nx.is_weakly_connected(G)  # node 3 is not connected to the graph\n    False\n    >>> G.add_edge(2, 3)\n    >>> nx.is_weakly_connected(G)\n    True\n\n    See Also\n    --------\n    is_strongly_connected\n    is_semiconnected\n    is_connected\n    is_biconnected\n    weakly_connected_components\n\n    Notes\n    -----\n    For directed graphs only.\n\n    \"\"\"\n    if len(G) == 0:\n        raise nx.NetworkXPointlessConcept('Connectivity is undefined for the null graph.')\n    return len(next(weakly_connected_components(G))) == len(G)",
        "mutated": [
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef is_weakly_connected(G):\n    if False:\n        i = 10\n    'Test directed graph for weak connectivity.\\n\\n    A directed graph is weakly connected if and only if the graph\\n    is connected when the direction of the edge between nodes is ignored.\\n\\n    Note that if a graph is strongly connected (i.e. the graph is connected\\n    even when we account for directionality), it is by definition weakly\\n    connected as well.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        A directed graph.\\n\\n    Returns\\n    -------\\n    connected : bool\\n        True if the graph is weakly connected, False otherwise.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If G is undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(0, 1), (2, 1)])\\n    >>> G.add_node(3)\\n    >>> nx.is_weakly_connected(G)  # node 3 is not connected to the graph\\n    False\\n    >>> G.add_edge(2, 3)\\n    >>> nx.is_weakly_connected(G)\\n    True\\n\\n    See Also\\n    --------\\n    is_strongly_connected\\n    is_semiconnected\\n    is_connected\\n    is_biconnected\\n    weakly_connected_components\\n\\n    Notes\\n    -----\\n    For directed graphs only.\\n\\n    '\n    if len(G) == 0:\n        raise nx.NetworkXPointlessConcept('Connectivity is undefined for the null graph.')\n    return len(next(weakly_connected_components(G))) == len(G)",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef is_weakly_connected(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test directed graph for weak connectivity.\\n\\n    A directed graph is weakly connected if and only if the graph\\n    is connected when the direction of the edge between nodes is ignored.\\n\\n    Note that if a graph is strongly connected (i.e. the graph is connected\\n    even when we account for directionality), it is by definition weakly\\n    connected as well.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        A directed graph.\\n\\n    Returns\\n    -------\\n    connected : bool\\n        True if the graph is weakly connected, False otherwise.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If G is undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(0, 1), (2, 1)])\\n    >>> G.add_node(3)\\n    >>> nx.is_weakly_connected(G)  # node 3 is not connected to the graph\\n    False\\n    >>> G.add_edge(2, 3)\\n    >>> nx.is_weakly_connected(G)\\n    True\\n\\n    See Also\\n    --------\\n    is_strongly_connected\\n    is_semiconnected\\n    is_connected\\n    is_biconnected\\n    weakly_connected_components\\n\\n    Notes\\n    -----\\n    For directed graphs only.\\n\\n    '\n    if len(G) == 0:\n        raise nx.NetworkXPointlessConcept('Connectivity is undefined for the null graph.')\n    return len(next(weakly_connected_components(G))) == len(G)",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef is_weakly_connected(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test directed graph for weak connectivity.\\n\\n    A directed graph is weakly connected if and only if the graph\\n    is connected when the direction of the edge between nodes is ignored.\\n\\n    Note that if a graph is strongly connected (i.e. the graph is connected\\n    even when we account for directionality), it is by definition weakly\\n    connected as well.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        A directed graph.\\n\\n    Returns\\n    -------\\n    connected : bool\\n        True if the graph is weakly connected, False otherwise.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If G is undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(0, 1), (2, 1)])\\n    >>> G.add_node(3)\\n    >>> nx.is_weakly_connected(G)  # node 3 is not connected to the graph\\n    False\\n    >>> G.add_edge(2, 3)\\n    >>> nx.is_weakly_connected(G)\\n    True\\n\\n    See Also\\n    --------\\n    is_strongly_connected\\n    is_semiconnected\\n    is_connected\\n    is_biconnected\\n    weakly_connected_components\\n\\n    Notes\\n    -----\\n    For directed graphs only.\\n\\n    '\n    if len(G) == 0:\n        raise nx.NetworkXPointlessConcept('Connectivity is undefined for the null graph.')\n    return len(next(weakly_connected_components(G))) == len(G)",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef is_weakly_connected(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test directed graph for weak connectivity.\\n\\n    A directed graph is weakly connected if and only if the graph\\n    is connected when the direction of the edge between nodes is ignored.\\n\\n    Note that if a graph is strongly connected (i.e. the graph is connected\\n    even when we account for directionality), it is by definition weakly\\n    connected as well.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        A directed graph.\\n\\n    Returns\\n    -------\\n    connected : bool\\n        True if the graph is weakly connected, False otherwise.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If G is undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(0, 1), (2, 1)])\\n    >>> G.add_node(3)\\n    >>> nx.is_weakly_connected(G)  # node 3 is not connected to the graph\\n    False\\n    >>> G.add_edge(2, 3)\\n    >>> nx.is_weakly_connected(G)\\n    True\\n\\n    See Also\\n    --------\\n    is_strongly_connected\\n    is_semiconnected\\n    is_connected\\n    is_biconnected\\n    weakly_connected_components\\n\\n    Notes\\n    -----\\n    For directed graphs only.\\n\\n    '\n    if len(G) == 0:\n        raise nx.NetworkXPointlessConcept('Connectivity is undefined for the null graph.')\n    return len(next(weakly_connected_components(G))) == len(G)",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef is_weakly_connected(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test directed graph for weak connectivity.\\n\\n    A directed graph is weakly connected if and only if the graph\\n    is connected when the direction of the edge between nodes is ignored.\\n\\n    Note that if a graph is strongly connected (i.e. the graph is connected\\n    even when we account for directionality), it is by definition weakly\\n    connected as well.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        A directed graph.\\n\\n    Returns\\n    -------\\n    connected : bool\\n        True if the graph is weakly connected, False otherwise.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If G is undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(0, 1), (2, 1)])\\n    >>> G.add_node(3)\\n    >>> nx.is_weakly_connected(G)  # node 3 is not connected to the graph\\n    False\\n    >>> G.add_edge(2, 3)\\n    >>> nx.is_weakly_connected(G)\\n    True\\n\\n    See Also\\n    --------\\n    is_strongly_connected\\n    is_semiconnected\\n    is_connected\\n    is_biconnected\\n    weakly_connected_components\\n\\n    Notes\\n    -----\\n    For directed graphs only.\\n\\n    '\n    if len(G) == 0:\n        raise nx.NetworkXPointlessConcept('Connectivity is undefined for the null graph.')\n    return len(next(weakly_connected_components(G))) == len(G)"
        ]
    },
    {
        "func_name": "_plain_bfs",
        "original": "def _plain_bfs(G, source):\n    \"\"\"A fast BFS node generator\n\n    The direction of the edge between nodes is ignored.\n\n    For directed graphs only.\n\n    \"\"\"\n    n = len(G)\n    Gsucc = G._succ\n    Gpred = G._pred\n    seen = {source}\n    nextlevel = [source]\n    yield source\n    while nextlevel:\n        thislevel = nextlevel\n        nextlevel = []\n        for v in thislevel:\n            for w in Gsucc[v]:\n                if w not in seen:\n                    seen.add(w)\n                    nextlevel.append(w)\n                    yield w\n            for w in Gpred[v]:\n                if w not in seen:\n                    seen.add(w)\n                    nextlevel.append(w)\n                    yield w\n            if len(seen) == n:\n                return",
        "mutated": [
            "def _plain_bfs(G, source):\n    if False:\n        i = 10\n    'A fast BFS node generator\\n\\n    The direction of the edge between nodes is ignored.\\n\\n    For directed graphs only.\\n\\n    '\n    n = len(G)\n    Gsucc = G._succ\n    Gpred = G._pred\n    seen = {source}\n    nextlevel = [source]\n    yield source\n    while nextlevel:\n        thislevel = nextlevel\n        nextlevel = []\n        for v in thislevel:\n            for w in Gsucc[v]:\n                if w not in seen:\n                    seen.add(w)\n                    nextlevel.append(w)\n                    yield w\n            for w in Gpred[v]:\n                if w not in seen:\n                    seen.add(w)\n                    nextlevel.append(w)\n                    yield w\n            if len(seen) == n:\n                return",
            "def _plain_bfs(G, source):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'A fast BFS node generator\\n\\n    The direction of the edge between nodes is ignored.\\n\\n    For directed graphs only.\\n\\n    '\n    n = len(G)\n    Gsucc = G._succ\n    Gpred = G._pred\n    seen = {source}\n    nextlevel = [source]\n    yield source\n    while nextlevel:\n        thislevel = nextlevel\n        nextlevel = []\n        for v in thislevel:\n            for w in Gsucc[v]:\n                if w not in seen:\n                    seen.add(w)\n                    nextlevel.append(w)\n                    yield w\n            for w in Gpred[v]:\n                if w not in seen:\n                    seen.add(w)\n                    nextlevel.append(w)\n                    yield w\n            if len(seen) == n:\n                return",
            "def _plain_bfs(G, source):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'A fast BFS node generator\\n\\n    The direction of the edge between nodes is ignored.\\n\\n    For directed graphs only.\\n\\n    '\n    n = len(G)\n    Gsucc = G._succ\n    Gpred = G._pred\n    seen = {source}\n    nextlevel = [source]\n    yield source\n    while nextlevel:\n        thislevel = nextlevel\n        nextlevel = []\n        for v in thislevel:\n            for w in Gsucc[v]:\n                if w not in seen:\n                    seen.add(w)\n                    nextlevel.append(w)\n                    yield w\n            for w in Gpred[v]:\n                if w not in seen:\n                    seen.add(w)\n                    nextlevel.append(w)\n                    yield w\n            if len(seen) == n:\n                return",
            "def _plain_bfs(G, source):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'A fast BFS node generator\\n\\n    The direction of the edge between nodes is ignored.\\n\\n    For directed graphs only.\\n\\n    '\n    n = len(G)\n    Gsucc = G._succ\n    Gpred = G._pred\n    seen = {source}\n    nextlevel = [source]\n    yield source\n    while nextlevel:\n        thislevel = nextlevel\n        nextlevel = []\n        for v in thislevel:\n            for w in Gsucc[v]:\n                if w not in seen:\n                    seen.add(w)\n                    nextlevel.append(w)\n                    yield w\n            for w in Gpred[v]:\n                if w not in seen:\n                    seen.add(w)\n                    nextlevel.append(w)\n                    yield w\n            if len(seen) == n:\n                return",
            "def _plain_bfs(G, source):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'A fast BFS node generator\\n\\n    The direction of the edge between nodes is ignored.\\n\\n    For directed graphs only.\\n\\n    '\n    n = len(G)\n    Gsucc = G._succ\n    Gpred = G._pred\n    seen = {source}\n    nextlevel = [source]\n    yield source\n    while nextlevel:\n        thislevel = nextlevel\n        nextlevel = []\n        for v in thislevel:\n            for w in Gsucc[v]:\n                if w not in seen:\n                    seen.add(w)\n                    nextlevel.append(w)\n                    yield w\n            for w in Gpred[v]:\n                if w not in seen:\n                    seen.add(w)\n                    nextlevel.append(w)\n                    yield w\n            if len(seen) == n:\n                return"
        ]
    }
]