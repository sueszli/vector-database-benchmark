[
    {
        "func_name": "montage",
        "original": "@utils.channel_as_last_axis(multichannel_output=False)\ndef montage(arr_in, fill='mean', rescale_intensity=False, grid_shape=None, padding_width=0, *, channel_axis=None):\n    \"\"\"Create a montage of several single- or multichannel images.\n\n    Create a rectangular montage from an input array representing an ensemble\n    of equally shaped single- (gray) or multichannel (color) images.\n\n    For example, ``montage(arr_in)`` called with the following `arr_in`\n\n    +---+---+---+\n    | 1 | 2 | 3 |\n    +---+---+---+\n\n    will return\n\n    +---+---+\n    | 1 | 2 |\n    +---+---+\n    | 3 | * |\n    +---+---+\n\n    where the '*' patch will be determined by the `fill` parameter.\n\n    Parameters\n    ----------\n    arr_in : ndarray, shape (K, M, N[, C])\n        An array representing an ensemble of `K` images of equal shape.\n    fill : float or array-like of floats or 'mean', optional\n        Value to fill the padding areas and/or the extra tiles in\n        the output array. Has to be `float` for single channel collections.\n        For multichannel collections has to be an array-like of shape of\n        number of channels. If `mean`, uses the mean value over all images.\n    rescale_intensity : bool, optional\n        Whether to rescale the intensity of each image to [0, 1].\n    grid_shape : tuple, optional\n        The desired grid shape for the montage `(ntiles_row, ntiles_column)`.\n        The default aspect ratio is square.\n    padding_width : int, optional\n        The size of the spacing between the tiles and between the tiles and\n        the borders. If non-zero, makes the boundaries of individual images\n        easier to perceive.\n    channel_axis : int or None, optional\n        If None, the image is assumed to be a grayscale (single channel) image.\n        Otherwise, this parameter indicates which axis of the array corresponds\n        to channels.\n\n    Returns\n    -------\n    arr_out : (K*(M+p)+p, K*(N+p)+p[, C]) ndarray\n        Output array with input images glued together (including padding `p`).\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from skimage.util import montage\n    >>> arr_in = np.arange(3 * 2 * 2).reshape(3, 2, 2)\n    >>> arr_in  # doctest: +NORMALIZE_WHITESPACE\n    array([[[ 0,  1],\n            [ 2,  3]],\n           [[ 4,  5],\n            [ 6,  7]],\n           [[ 8,  9],\n            [10, 11]]])\n    >>> arr_out = montage(arr_in)\n    >>> arr_out.shape\n    (4, 4)\n    >>> arr_out\n    array([[ 0,  1,  4,  5],\n           [ 2,  3,  6,  7],\n           [ 8,  9,  5,  5],\n           [10, 11,  5,  5]])\n    >>> arr_in.mean()\n    5.5\n    >>> arr_out_nonsquare = montage(arr_in, grid_shape=(1, 3))\n    >>> arr_out_nonsquare\n    array([[ 0,  1,  4,  5,  8,  9],\n           [ 2,  3,  6,  7, 10, 11]])\n    >>> arr_out_nonsquare.shape\n    (2, 6)\n    \"\"\"\n    if channel_axis is not None:\n        arr_in = np.asarray(arr_in)\n    else:\n        arr_in = np.asarray(arr_in)[..., np.newaxis]\n    if arr_in.ndim != 4:\n        raise ValueError('Input array has to be 3-dimensional for grayscale images, or 4-dimensional with a `channel_axis` specified.')\n    (n_images, n_rows, n_cols, n_chan) = arr_in.shape\n    if grid_shape:\n        (ntiles_row, ntiles_col) = (int(s) for s in grid_shape)\n    else:\n        ntiles_row = ntiles_col = int(np.ceil(np.sqrt(n_images)))\n    if rescale_intensity:\n        for i in range(n_images):\n            arr_in[i] = exposure.rescale_intensity(arr_in[i])\n    if fill == 'mean':\n        fill = arr_in.mean(axis=(0, 1, 2))\n    fill = np.atleast_1d(fill).astype(arr_in.dtype)\n    n_pad = padding_width\n    arr_out = np.empty(((n_rows + n_pad) * ntiles_row + n_pad, (n_cols + n_pad) * ntiles_col + n_pad, n_chan), dtype=arr_in.dtype)\n    for idx_chan in range(n_chan):\n        arr_out[..., idx_chan] = fill[idx_chan]\n    slices_row = [slice(n_pad + (n_rows + n_pad) * n, n_pad + (n_rows + n_pad) * n + n_rows) for n in range(ntiles_row)]\n    slices_col = [slice(n_pad + (n_cols + n_pad) * n, n_pad + (n_cols + n_pad) * n + n_cols) for n in range(ntiles_col)]\n    for (idx_image, image) in enumerate(arr_in):\n        idx_sr = idx_image // ntiles_col\n        idx_sc = idx_image % ntiles_col\n        arr_out[slices_row[idx_sr], slices_col[idx_sc], :] = image\n    if channel_axis is not None:\n        return arr_out\n    else:\n        return arr_out[..., 0]",
        "mutated": [
            "@utils.channel_as_last_axis(multichannel_output=False)\ndef montage(arr_in, fill='mean', rescale_intensity=False, grid_shape=None, padding_width=0, *, channel_axis=None):\n    if False:\n        i = 10\n    \"Create a montage of several single- or multichannel images.\\n\\n    Create a rectangular montage from an input array representing an ensemble\\n    of equally shaped single- (gray) or multichannel (color) images.\\n\\n    For example, ``montage(arr_in)`` called with the following `arr_in`\\n\\n    +---+---+---+\\n    | 1 | 2 | 3 |\\n    +---+---+---+\\n\\n    will return\\n\\n    +---+---+\\n    | 1 | 2 |\\n    +---+---+\\n    | 3 | * |\\n    +---+---+\\n\\n    where the '*' patch will be determined by the `fill` parameter.\\n\\n    Parameters\\n    ----------\\n    arr_in : ndarray, shape (K, M, N[, C])\\n        An array representing an ensemble of `K` images of equal shape.\\n    fill : float or array-like of floats or 'mean', optional\\n        Value to fill the padding areas and/or the extra tiles in\\n        the output array. Has to be `float` for single channel collections.\\n        For multichannel collections has to be an array-like of shape of\\n        number of channels. If `mean`, uses the mean value over all images.\\n    rescale_intensity : bool, optional\\n        Whether to rescale the intensity of each image to [0, 1].\\n    grid_shape : tuple, optional\\n        The desired grid shape for the montage `(ntiles_row, ntiles_column)`.\\n        The default aspect ratio is square.\\n    padding_width : int, optional\\n        The size of the spacing between the tiles and between the tiles and\\n        the borders. If non-zero, makes the boundaries of individual images\\n        easier to perceive.\\n    channel_axis : int or None, optional\\n        If None, the image is assumed to be a grayscale (single channel) image.\\n        Otherwise, this parameter indicates which axis of the array corresponds\\n        to channels.\\n\\n    Returns\\n    -------\\n    arr_out : (K*(M+p)+p, K*(N+p)+p[, C]) ndarray\\n        Output array with input images glued together (including padding `p`).\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from skimage.util import montage\\n    >>> arr_in = np.arange(3 * 2 * 2).reshape(3, 2, 2)\\n    >>> arr_in  # doctest: +NORMALIZE_WHITESPACE\\n    array([[[ 0,  1],\\n            [ 2,  3]],\\n           [[ 4,  5],\\n            [ 6,  7]],\\n           [[ 8,  9],\\n            [10, 11]]])\\n    >>> arr_out = montage(arr_in)\\n    >>> arr_out.shape\\n    (4, 4)\\n    >>> arr_out\\n    array([[ 0,  1,  4,  5],\\n           [ 2,  3,  6,  7],\\n           [ 8,  9,  5,  5],\\n           [10, 11,  5,  5]])\\n    >>> arr_in.mean()\\n    5.5\\n    >>> arr_out_nonsquare = montage(arr_in, grid_shape=(1, 3))\\n    >>> arr_out_nonsquare\\n    array([[ 0,  1,  4,  5,  8,  9],\\n           [ 2,  3,  6,  7, 10, 11]])\\n    >>> arr_out_nonsquare.shape\\n    (2, 6)\\n    \"\n    if channel_axis is not None:\n        arr_in = np.asarray(arr_in)\n    else:\n        arr_in = np.asarray(arr_in)[..., np.newaxis]\n    if arr_in.ndim != 4:\n        raise ValueError('Input array has to be 3-dimensional for grayscale images, or 4-dimensional with a `channel_axis` specified.')\n    (n_images, n_rows, n_cols, n_chan) = arr_in.shape\n    if grid_shape:\n        (ntiles_row, ntiles_col) = (int(s) for s in grid_shape)\n    else:\n        ntiles_row = ntiles_col = int(np.ceil(np.sqrt(n_images)))\n    if rescale_intensity:\n        for i in range(n_images):\n            arr_in[i] = exposure.rescale_intensity(arr_in[i])\n    if fill == 'mean':\n        fill = arr_in.mean(axis=(0, 1, 2))\n    fill = np.atleast_1d(fill).astype(arr_in.dtype)\n    n_pad = padding_width\n    arr_out = np.empty(((n_rows + n_pad) * ntiles_row + n_pad, (n_cols + n_pad) * ntiles_col + n_pad, n_chan), dtype=arr_in.dtype)\n    for idx_chan in range(n_chan):\n        arr_out[..., idx_chan] = fill[idx_chan]\n    slices_row = [slice(n_pad + (n_rows + n_pad) * n, n_pad + (n_rows + n_pad) * n + n_rows) for n in range(ntiles_row)]\n    slices_col = [slice(n_pad + (n_cols + n_pad) * n, n_pad + (n_cols + n_pad) * n + n_cols) for n in range(ntiles_col)]\n    for (idx_image, image) in enumerate(arr_in):\n        idx_sr = idx_image // ntiles_col\n        idx_sc = idx_image % ntiles_col\n        arr_out[slices_row[idx_sr], slices_col[idx_sc], :] = image\n    if channel_axis is not None:\n        return arr_out\n    else:\n        return arr_out[..., 0]",
            "@utils.channel_as_last_axis(multichannel_output=False)\ndef montage(arr_in, fill='mean', rescale_intensity=False, grid_shape=None, padding_width=0, *, channel_axis=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Create a montage of several single- or multichannel images.\\n\\n    Create a rectangular montage from an input array representing an ensemble\\n    of equally shaped single- (gray) or multichannel (color) images.\\n\\n    For example, ``montage(arr_in)`` called with the following `arr_in`\\n\\n    +---+---+---+\\n    | 1 | 2 | 3 |\\n    +---+---+---+\\n\\n    will return\\n\\n    +---+---+\\n    | 1 | 2 |\\n    +---+---+\\n    | 3 | * |\\n    +---+---+\\n\\n    where the '*' patch will be determined by the `fill` parameter.\\n\\n    Parameters\\n    ----------\\n    arr_in : ndarray, shape (K, M, N[, C])\\n        An array representing an ensemble of `K` images of equal shape.\\n    fill : float or array-like of floats or 'mean', optional\\n        Value to fill the padding areas and/or the extra tiles in\\n        the output array. Has to be `float` for single channel collections.\\n        For multichannel collections has to be an array-like of shape of\\n        number of channels. If `mean`, uses the mean value over all images.\\n    rescale_intensity : bool, optional\\n        Whether to rescale the intensity of each image to [0, 1].\\n    grid_shape : tuple, optional\\n        The desired grid shape for the montage `(ntiles_row, ntiles_column)`.\\n        The default aspect ratio is square.\\n    padding_width : int, optional\\n        The size of the spacing between the tiles and between the tiles and\\n        the borders. If non-zero, makes the boundaries of individual images\\n        easier to perceive.\\n    channel_axis : int or None, optional\\n        If None, the image is assumed to be a grayscale (single channel) image.\\n        Otherwise, this parameter indicates which axis of the array corresponds\\n        to channels.\\n\\n    Returns\\n    -------\\n    arr_out : (K*(M+p)+p, K*(N+p)+p[, C]) ndarray\\n        Output array with input images glued together (including padding `p`).\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from skimage.util import montage\\n    >>> arr_in = np.arange(3 * 2 * 2).reshape(3, 2, 2)\\n    >>> arr_in  # doctest: +NORMALIZE_WHITESPACE\\n    array([[[ 0,  1],\\n            [ 2,  3]],\\n           [[ 4,  5],\\n            [ 6,  7]],\\n           [[ 8,  9],\\n            [10, 11]]])\\n    >>> arr_out = montage(arr_in)\\n    >>> arr_out.shape\\n    (4, 4)\\n    >>> arr_out\\n    array([[ 0,  1,  4,  5],\\n           [ 2,  3,  6,  7],\\n           [ 8,  9,  5,  5],\\n           [10, 11,  5,  5]])\\n    >>> arr_in.mean()\\n    5.5\\n    >>> arr_out_nonsquare = montage(arr_in, grid_shape=(1, 3))\\n    >>> arr_out_nonsquare\\n    array([[ 0,  1,  4,  5,  8,  9],\\n           [ 2,  3,  6,  7, 10, 11]])\\n    >>> arr_out_nonsquare.shape\\n    (2, 6)\\n    \"\n    if channel_axis is not None:\n        arr_in = np.asarray(arr_in)\n    else:\n        arr_in = np.asarray(arr_in)[..., np.newaxis]\n    if arr_in.ndim != 4:\n        raise ValueError('Input array has to be 3-dimensional for grayscale images, or 4-dimensional with a `channel_axis` specified.')\n    (n_images, n_rows, n_cols, n_chan) = arr_in.shape\n    if grid_shape:\n        (ntiles_row, ntiles_col) = (int(s) for s in grid_shape)\n    else:\n        ntiles_row = ntiles_col = int(np.ceil(np.sqrt(n_images)))\n    if rescale_intensity:\n        for i in range(n_images):\n            arr_in[i] = exposure.rescale_intensity(arr_in[i])\n    if fill == 'mean':\n        fill = arr_in.mean(axis=(0, 1, 2))\n    fill = np.atleast_1d(fill).astype(arr_in.dtype)\n    n_pad = padding_width\n    arr_out = np.empty(((n_rows + n_pad) * ntiles_row + n_pad, (n_cols + n_pad) * ntiles_col + n_pad, n_chan), dtype=arr_in.dtype)\n    for idx_chan in range(n_chan):\n        arr_out[..., idx_chan] = fill[idx_chan]\n    slices_row = [slice(n_pad + (n_rows + n_pad) * n, n_pad + (n_rows + n_pad) * n + n_rows) for n in range(ntiles_row)]\n    slices_col = [slice(n_pad + (n_cols + n_pad) * n, n_pad + (n_cols + n_pad) * n + n_cols) for n in range(ntiles_col)]\n    for (idx_image, image) in enumerate(arr_in):\n        idx_sr = idx_image // ntiles_col\n        idx_sc = idx_image % ntiles_col\n        arr_out[slices_row[idx_sr], slices_col[idx_sc], :] = image\n    if channel_axis is not None:\n        return arr_out\n    else:\n        return arr_out[..., 0]",
            "@utils.channel_as_last_axis(multichannel_output=False)\ndef montage(arr_in, fill='mean', rescale_intensity=False, grid_shape=None, padding_width=0, *, channel_axis=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Create a montage of several single- or multichannel images.\\n\\n    Create a rectangular montage from an input array representing an ensemble\\n    of equally shaped single- (gray) or multichannel (color) images.\\n\\n    For example, ``montage(arr_in)`` called with the following `arr_in`\\n\\n    +---+---+---+\\n    | 1 | 2 | 3 |\\n    +---+---+---+\\n\\n    will return\\n\\n    +---+---+\\n    | 1 | 2 |\\n    +---+---+\\n    | 3 | * |\\n    +---+---+\\n\\n    where the '*' patch will be determined by the `fill` parameter.\\n\\n    Parameters\\n    ----------\\n    arr_in : ndarray, shape (K, M, N[, C])\\n        An array representing an ensemble of `K` images of equal shape.\\n    fill : float or array-like of floats or 'mean', optional\\n        Value to fill the padding areas and/or the extra tiles in\\n        the output array. Has to be `float` for single channel collections.\\n        For multichannel collections has to be an array-like of shape of\\n        number of channels. If `mean`, uses the mean value over all images.\\n    rescale_intensity : bool, optional\\n        Whether to rescale the intensity of each image to [0, 1].\\n    grid_shape : tuple, optional\\n        The desired grid shape for the montage `(ntiles_row, ntiles_column)`.\\n        The default aspect ratio is square.\\n    padding_width : int, optional\\n        The size of the spacing between the tiles and between the tiles and\\n        the borders. If non-zero, makes the boundaries of individual images\\n        easier to perceive.\\n    channel_axis : int or None, optional\\n        If None, the image is assumed to be a grayscale (single channel) image.\\n        Otherwise, this parameter indicates which axis of the array corresponds\\n        to channels.\\n\\n    Returns\\n    -------\\n    arr_out : (K*(M+p)+p, K*(N+p)+p[, C]) ndarray\\n        Output array with input images glued together (including padding `p`).\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from skimage.util import montage\\n    >>> arr_in = np.arange(3 * 2 * 2).reshape(3, 2, 2)\\n    >>> arr_in  # doctest: +NORMALIZE_WHITESPACE\\n    array([[[ 0,  1],\\n            [ 2,  3]],\\n           [[ 4,  5],\\n            [ 6,  7]],\\n           [[ 8,  9],\\n            [10, 11]]])\\n    >>> arr_out = montage(arr_in)\\n    >>> arr_out.shape\\n    (4, 4)\\n    >>> arr_out\\n    array([[ 0,  1,  4,  5],\\n           [ 2,  3,  6,  7],\\n           [ 8,  9,  5,  5],\\n           [10, 11,  5,  5]])\\n    >>> arr_in.mean()\\n    5.5\\n    >>> arr_out_nonsquare = montage(arr_in, grid_shape=(1, 3))\\n    >>> arr_out_nonsquare\\n    array([[ 0,  1,  4,  5,  8,  9],\\n           [ 2,  3,  6,  7, 10, 11]])\\n    >>> arr_out_nonsquare.shape\\n    (2, 6)\\n    \"\n    if channel_axis is not None:\n        arr_in = np.asarray(arr_in)\n    else:\n        arr_in = np.asarray(arr_in)[..., np.newaxis]\n    if arr_in.ndim != 4:\n        raise ValueError('Input array has to be 3-dimensional for grayscale images, or 4-dimensional with a `channel_axis` specified.')\n    (n_images, n_rows, n_cols, n_chan) = arr_in.shape\n    if grid_shape:\n        (ntiles_row, ntiles_col) = (int(s) for s in grid_shape)\n    else:\n        ntiles_row = ntiles_col = int(np.ceil(np.sqrt(n_images)))\n    if rescale_intensity:\n        for i in range(n_images):\n            arr_in[i] = exposure.rescale_intensity(arr_in[i])\n    if fill == 'mean':\n        fill = arr_in.mean(axis=(0, 1, 2))\n    fill = np.atleast_1d(fill).astype(arr_in.dtype)\n    n_pad = padding_width\n    arr_out = np.empty(((n_rows + n_pad) * ntiles_row + n_pad, (n_cols + n_pad) * ntiles_col + n_pad, n_chan), dtype=arr_in.dtype)\n    for idx_chan in range(n_chan):\n        arr_out[..., idx_chan] = fill[idx_chan]\n    slices_row = [slice(n_pad + (n_rows + n_pad) * n, n_pad + (n_rows + n_pad) * n + n_rows) for n in range(ntiles_row)]\n    slices_col = [slice(n_pad + (n_cols + n_pad) * n, n_pad + (n_cols + n_pad) * n + n_cols) for n in range(ntiles_col)]\n    for (idx_image, image) in enumerate(arr_in):\n        idx_sr = idx_image // ntiles_col\n        idx_sc = idx_image % ntiles_col\n        arr_out[slices_row[idx_sr], slices_col[idx_sc], :] = image\n    if channel_axis is not None:\n        return arr_out\n    else:\n        return arr_out[..., 0]",
            "@utils.channel_as_last_axis(multichannel_output=False)\ndef montage(arr_in, fill='mean', rescale_intensity=False, grid_shape=None, padding_width=0, *, channel_axis=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Create a montage of several single- or multichannel images.\\n\\n    Create a rectangular montage from an input array representing an ensemble\\n    of equally shaped single- (gray) or multichannel (color) images.\\n\\n    For example, ``montage(arr_in)`` called with the following `arr_in`\\n\\n    +---+---+---+\\n    | 1 | 2 | 3 |\\n    +---+---+---+\\n\\n    will return\\n\\n    +---+---+\\n    | 1 | 2 |\\n    +---+---+\\n    | 3 | * |\\n    +---+---+\\n\\n    where the '*' patch will be determined by the `fill` parameter.\\n\\n    Parameters\\n    ----------\\n    arr_in : ndarray, shape (K, M, N[, C])\\n        An array representing an ensemble of `K` images of equal shape.\\n    fill : float or array-like of floats or 'mean', optional\\n        Value to fill the padding areas and/or the extra tiles in\\n        the output array. Has to be `float` for single channel collections.\\n        For multichannel collections has to be an array-like of shape of\\n        number of channels. If `mean`, uses the mean value over all images.\\n    rescale_intensity : bool, optional\\n        Whether to rescale the intensity of each image to [0, 1].\\n    grid_shape : tuple, optional\\n        The desired grid shape for the montage `(ntiles_row, ntiles_column)`.\\n        The default aspect ratio is square.\\n    padding_width : int, optional\\n        The size of the spacing between the tiles and between the tiles and\\n        the borders. If non-zero, makes the boundaries of individual images\\n        easier to perceive.\\n    channel_axis : int or None, optional\\n        If None, the image is assumed to be a grayscale (single channel) image.\\n        Otherwise, this parameter indicates which axis of the array corresponds\\n        to channels.\\n\\n    Returns\\n    -------\\n    arr_out : (K*(M+p)+p, K*(N+p)+p[, C]) ndarray\\n        Output array with input images glued together (including padding `p`).\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from skimage.util import montage\\n    >>> arr_in = np.arange(3 * 2 * 2).reshape(3, 2, 2)\\n    >>> arr_in  # doctest: +NORMALIZE_WHITESPACE\\n    array([[[ 0,  1],\\n            [ 2,  3]],\\n           [[ 4,  5],\\n            [ 6,  7]],\\n           [[ 8,  9],\\n            [10, 11]]])\\n    >>> arr_out = montage(arr_in)\\n    >>> arr_out.shape\\n    (4, 4)\\n    >>> arr_out\\n    array([[ 0,  1,  4,  5],\\n           [ 2,  3,  6,  7],\\n           [ 8,  9,  5,  5],\\n           [10, 11,  5,  5]])\\n    >>> arr_in.mean()\\n    5.5\\n    >>> arr_out_nonsquare = montage(arr_in, grid_shape=(1, 3))\\n    >>> arr_out_nonsquare\\n    array([[ 0,  1,  4,  5,  8,  9],\\n           [ 2,  3,  6,  7, 10, 11]])\\n    >>> arr_out_nonsquare.shape\\n    (2, 6)\\n    \"\n    if channel_axis is not None:\n        arr_in = np.asarray(arr_in)\n    else:\n        arr_in = np.asarray(arr_in)[..., np.newaxis]\n    if arr_in.ndim != 4:\n        raise ValueError('Input array has to be 3-dimensional for grayscale images, or 4-dimensional with a `channel_axis` specified.')\n    (n_images, n_rows, n_cols, n_chan) = arr_in.shape\n    if grid_shape:\n        (ntiles_row, ntiles_col) = (int(s) for s in grid_shape)\n    else:\n        ntiles_row = ntiles_col = int(np.ceil(np.sqrt(n_images)))\n    if rescale_intensity:\n        for i in range(n_images):\n            arr_in[i] = exposure.rescale_intensity(arr_in[i])\n    if fill == 'mean':\n        fill = arr_in.mean(axis=(0, 1, 2))\n    fill = np.atleast_1d(fill).astype(arr_in.dtype)\n    n_pad = padding_width\n    arr_out = np.empty(((n_rows + n_pad) * ntiles_row + n_pad, (n_cols + n_pad) * ntiles_col + n_pad, n_chan), dtype=arr_in.dtype)\n    for idx_chan in range(n_chan):\n        arr_out[..., idx_chan] = fill[idx_chan]\n    slices_row = [slice(n_pad + (n_rows + n_pad) * n, n_pad + (n_rows + n_pad) * n + n_rows) for n in range(ntiles_row)]\n    slices_col = [slice(n_pad + (n_cols + n_pad) * n, n_pad + (n_cols + n_pad) * n + n_cols) for n in range(ntiles_col)]\n    for (idx_image, image) in enumerate(arr_in):\n        idx_sr = idx_image // ntiles_col\n        idx_sc = idx_image % ntiles_col\n        arr_out[slices_row[idx_sr], slices_col[idx_sc], :] = image\n    if channel_axis is not None:\n        return arr_out\n    else:\n        return arr_out[..., 0]",
            "@utils.channel_as_last_axis(multichannel_output=False)\ndef montage(arr_in, fill='mean', rescale_intensity=False, grid_shape=None, padding_width=0, *, channel_axis=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Create a montage of several single- or multichannel images.\\n\\n    Create a rectangular montage from an input array representing an ensemble\\n    of equally shaped single- (gray) or multichannel (color) images.\\n\\n    For example, ``montage(arr_in)`` called with the following `arr_in`\\n\\n    +---+---+---+\\n    | 1 | 2 | 3 |\\n    +---+---+---+\\n\\n    will return\\n\\n    +---+---+\\n    | 1 | 2 |\\n    +---+---+\\n    | 3 | * |\\n    +---+---+\\n\\n    where the '*' patch will be determined by the `fill` parameter.\\n\\n    Parameters\\n    ----------\\n    arr_in : ndarray, shape (K, M, N[, C])\\n        An array representing an ensemble of `K` images of equal shape.\\n    fill : float or array-like of floats or 'mean', optional\\n        Value to fill the padding areas and/or the extra tiles in\\n        the output array. Has to be `float` for single channel collections.\\n        For multichannel collections has to be an array-like of shape of\\n        number of channels. If `mean`, uses the mean value over all images.\\n    rescale_intensity : bool, optional\\n        Whether to rescale the intensity of each image to [0, 1].\\n    grid_shape : tuple, optional\\n        The desired grid shape for the montage `(ntiles_row, ntiles_column)`.\\n        The default aspect ratio is square.\\n    padding_width : int, optional\\n        The size of the spacing between the tiles and between the tiles and\\n        the borders. If non-zero, makes the boundaries of individual images\\n        easier to perceive.\\n    channel_axis : int or None, optional\\n        If None, the image is assumed to be a grayscale (single channel) image.\\n        Otherwise, this parameter indicates which axis of the array corresponds\\n        to channels.\\n\\n    Returns\\n    -------\\n    arr_out : (K*(M+p)+p, K*(N+p)+p[, C]) ndarray\\n        Output array with input images glued together (including padding `p`).\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from skimage.util import montage\\n    >>> arr_in = np.arange(3 * 2 * 2).reshape(3, 2, 2)\\n    >>> arr_in  # doctest: +NORMALIZE_WHITESPACE\\n    array([[[ 0,  1],\\n            [ 2,  3]],\\n           [[ 4,  5],\\n            [ 6,  7]],\\n           [[ 8,  9],\\n            [10, 11]]])\\n    >>> arr_out = montage(arr_in)\\n    >>> arr_out.shape\\n    (4, 4)\\n    >>> arr_out\\n    array([[ 0,  1,  4,  5],\\n           [ 2,  3,  6,  7],\\n           [ 8,  9,  5,  5],\\n           [10, 11,  5,  5]])\\n    >>> arr_in.mean()\\n    5.5\\n    >>> arr_out_nonsquare = montage(arr_in, grid_shape=(1, 3))\\n    >>> arr_out_nonsquare\\n    array([[ 0,  1,  4,  5,  8,  9],\\n           [ 2,  3,  6,  7, 10, 11]])\\n    >>> arr_out_nonsquare.shape\\n    (2, 6)\\n    \"\n    if channel_axis is not None:\n        arr_in = np.asarray(arr_in)\n    else:\n        arr_in = np.asarray(arr_in)[..., np.newaxis]\n    if arr_in.ndim != 4:\n        raise ValueError('Input array has to be 3-dimensional for grayscale images, or 4-dimensional with a `channel_axis` specified.')\n    (n_images, n_rows, n_cols, n_chan) = arr_in.shape\n    if grid_shape:\n        (ntiles_row, ntiles_col) = (int(s) for s in grid_shape)\n    else:\n        ntiles_row = ntiles_col = int(np.ceil(np.sqrt(n_images)))\n    if rescale_intensity:\n        for i in range(n_images):\n            arr_in[i] = exposure.rescale_intensity(arr_in[i])\n    if fill == 'mean':\n        fill = arr_in.mean(axis=(0, 1, 2))\n    fill = np.atleast_1d(fill).astype(arr_in.dtype)\n    n_pad = padding_width\n    arr_out = np.empty(((n_rows + n_pad) * ntiles_row + n_pad, (n_cols + n_pad) * ntiles_col + n_pad, n_chan), dtype=arr_in.dtype)\n    for idx_chan in range(n_chan):\n        arr_out[..., idx_chan] = fill[idx_chan]\n    slices_row = [slice(n_pad + (n_rows + n_pad) * n, n_pad + (n_rows + n_pad) * n + n_rows) for n in range(ntiles_row)]\n    slices_col = [slice(n_pad + (n_cols + n_pad) * n, n_pad + (n_cols + n_pad) * n + n_cols) for n in range(ntiles_col)]\n    for (idx_image, image) in enumerate(arr_in):\n        idx_sr = idx_image // ntiles_col\n        idx_sc = idx_image % ntiles_col\n        arr_out[slices_row[idx_sr], slices_col[idx_sc], :] = image\n    if channel_axis is not None:\n        return arr_out\n    else:\n        return arr_out[..., 0]"
        ]
    }
]