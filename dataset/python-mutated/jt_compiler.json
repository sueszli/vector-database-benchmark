[
    {
        "func_name": "parse_attrs",
        "original": "def parse_attrs(s):\n    \"\"\"parse @attrs(..., x=y) syntax\"\"\"\n    attrs = {}\n    if s is None:\n        return attrs\n    for a in s.split(','):\n        a = a.strip()\n        if len(a) == 0:\n            continue\n        if '=' in a:\n            (k, v) = a.split('=')\n            attrs[k] = v\n        else:\n            attrs[a] = 1\n    return attrs",
        "mutated": [
            "def parse_attrs(s):\n    if False:\n        i = 10\n    'parse @attrs(..., x=y) syntax'\n    attrs = {}\n    if s is None:\n        return attrs\n    for a in s.split(','):\n        a = a.strip()\n        if len(a) == 0:\n            continue\n        if '=' in a:\n            (k, v) = a.split('=')\n            attrs[k] = v\n        else:\n            attrs[a] = 1\n    return attrs",
            "def parse_attrs(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'parse @attrs(..., x=y) syntax'\n    attrs = {}\n    if s is None:\n        return attrs\n    for a in s.split(','):\n        a = a.strip()\n        if len(a) == 0:\n            continue\n        if '=' in a:\n            (k, v) = a.split('=')\n            attrs[k] = v\n        else:\n            attrs[a] = 1\n    return attrs",
            "def parse_attrs(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'parse @attrs(..., x=y) syntax'\n    attrs = {}\n    if s is None:\n        return attrs\n    for a in s.split(','):\n        a = a.strip()\n        if len(a) == 0:\n            continue\n        if '=' in a:\n            (k, v) = a.split('=')\n            attrs[k] = v\n        else:\n            attrs[a] = 1\n    return attrs",
            "def parse_attrs(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'parse @attrs(..., x=y) syntax'\n    attrs = {}\n    if s is None:\n        return attrs\n    for a in s.split(','):\n        a = a.strip()\n        if len(a) == 0:\n            continue\n        if '=' in a:\n            (k, v) = a.split('=')\n            attrs[k] = v\n        else:\n            attrs[a] = 1\n    return attrs",
            "def parse_attrs(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'parse @attrs(..., x=y) syntax'\n    attrs = {}\n    if s is None:\n        return attrs\n    for a in s.split(','):\n        a = a.strip()\n        if len(a) == 0:\n            continue\n        if '=' in a:\n            (k, v) = a.split('=')\n            attrs[k] = v\n        else:\n            attrs[a] = 1\n    return attrs"
        ]
    },
    {
        "func_name": "get_pytype_map",
        "original": "def get_pytype_map(T, i):\n    assert T != ''\n    if T in pytype_map:\n        return pytype_map[T][i]\n    return ['from_py_object', 'to_py_object', 'is_type'][i] + '<' + T + '>'",
        "mutated": [
            "def get_pytype_map(T, i):\n    if False:\n        i = 10\n    assert T != ''\n    if T in pytype_map:\n        return pytype_map[T][i]\n    return ['from_py_object', 'to_py_object', 'is_type'][i] + '<' + T + '>'",
            "def get_pytype_map(T, i):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert T != ''\n    if T in pytype_map:\n        return pytype_map[T][i]\n    return ['from_py_object', 'to_py_object', 'is_type'][i] + '<' + T + '>'",
            "def get_pytype_map(T, i):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert T != ''\n    if T in pytype_map:\n        return pytype_map[T][i]\n    return ['from_py_object', 'to_py_object', 'is_type'][i] + '<' + T + '>'",
            "def get_pytype_map(T, i):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert T != ''\n    if T in pytype_map:\n        return pytype_map[T][i]\n    return ['from_py_object', 'to_py_object', 'is_type'][i] + '<' + T + '>'",
            "def get_pytype_map(T, i):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert T != ''\n    if T in pytype_map:\n        return pytype_map[T][i]\n    return ['from_py_object', 'to_py_object', 'is_type'][i] + '<' + T + '>'"
        ]
    },
    {
        "func_name": "split_args",
        "original": "def split_args(s):\n    s = s.strip()\n    if s == '':\n        return []\n    prev = -1\n    presum = 0\n    args = []\n    for i in range(len(s)):\n        if s[i] == '<':\n            presum += 1\n        elif s[i] == '>':\n            presum -= 1\n        if presum == 0 and s[i] == ',':\n            args.append(s[prev + 1:i])\n            prev = i\n    args.append(s[prev + 1:])\n    return args",
        "mutated": [
            "def split_args(s):\n    if False:\n        i = 10\n    s = s.strip()\n    if s == '':\n        return []\n    prev = -1\n    presum = 0\n    args = []\n    for i in range(len(s)):\n        if s[i] == '<':\n            presum += 1\n        elif s[i] == '>':\n            presum -= 1\n        if presum == 0 and s[i] == ',':\n            args.append(s[prev + 1:i])\n            prev = i\n    args.append(s[prev + 1:])\n    return args",
            "def split_args(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    s = s.strip()\n    if s == '':\n        return []\n    prev = -1\n    presum = 0\n    args = []\n    for i in range(len(s)):\n        if s[i] == '<':\n            presum += 1\n        elif s[i] == '>':\n            presum -= 1\n        if presum == 0 and s[i] == ',':\n            args.append(s[prev + 1:i])\n            prev = i\n    args.append(s[prev + 1:])\n    return args",
            "def split_args(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    s = s.strip()\n    if s == '':\n        return []\n    prev = -1\n    presum = 0\n    args = []\n    for i in range(len(s)):\n        if s[i] == '<':\n            presum += 1\n        elif s[i] == '>':\n            presum -= 1\n        if presum == 0 and s[i] == ',':\n            args.append(s[prev + 1:i])\n            prev = i\n    args.append(s[prev + 1:])\n    return args",
            "def split_args(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    s = s.strip()\n    if s == '':\n        return []\n    prev = -1\n    presum = 0\n    args = []\n    for i in range(len(s)):\n        if s[i] == '<':\n            presum += 1\n        elif s[i] == '>':\n            presum -= 1\n        if presum == 0 and s[i] == ',':\n            args.append(s[prev + 1:i])\n            prev = i\n    args.append(s[prev + 1:])\n    return args",
            "def split_args(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    s = s.strip()\n    if s == '':\n        return []\n    prev = -1\n    presum = 0\n    args = []\n    for i in range(len(s)):\n        if s[i] == '<':\n            presum += 1\n        elif s[i] == '>':\n            presum -= 1\n        if presum == 0 and s[i] == ',':\n            args.append(s[prev + 1:i])\n            prev = i\n    args.append(s[prev + 1:])\n    return args"
        ]
    },
    {
        "func_name": "get_def_code",
        "original": "def get_def_code(df, scope_name, pyname, self_as_arg0=False):\n    is_fast_call = not pyname.startswith('__')\n    no_need_convert = pyname == '__getitem__'\n    args = df['args']\n    max_args = len(args)\n    min_args = max_args\n    for (tid, a) in enumerate(args):\n        if a[2] != '':\n            min_args = tid\n            break\n    arg_names = [f'args[{i}]' for i in range(len(args))]\n    if self_as_arg0:\n        max_args -= 1\n        min_args -= 1\n        arg_names = ['self'] + arg_names[:-1]\n    kw_args_id = []\n    for (aid, arg) in enumerate(args):\n        if 'VarHolder*' != arg[0] and is_fast_call:\n            kw_args_id.append(aid)\n    func_quick_check_runable = ''\n    func_quick_check_size = f'n<={max_args} && n>={min_args}'\n    if len(kw_args_id):\n        func_quick_check_size = f'n+(kw?Py_SIZE(kw):0)<={max_args} && n+(kw?Py_SIZE(kw):0)>={min_args}'\n    fill_with_default = ''\n    func_args_convert = ''\n    func_call = df['func_name'] + '('\n    pytypes = [get_pytype_map(a[0], 0) for a in args]\n    holder_dec_array = []\n    holder_set_array = []\n    for (tid, tpc) in enumerate(pytypes):\n        check = get_pytype_map(args[tid][0], 2)\n        default_arg = args[tid][2]\n        jtp = args[tid][0]\n        holder_dec = ''\n        holder_set = ''\n        if jtp == 'VarHolder*':\n            holder_dec = f'unique_ptr<VarHolder> arg{tid}_holder'\n            holder_set = f', arg{tid}_holder'\n        if jtp == 'VarSlices':\n            holder_dec = f'vector<unique_ptr<VarHolder>> arg{tid}_holder'\n            holder_set = f', arg{tid}_holder'\n        holder_dec_array.append(holder_dec)\n        holder_set_array.append(holder_set)\n        if len(default_arg):\n            func_args_convert += f'\\n                        {holder_dec};\\n                        {jtp} arg{tid};\\n                        if (n>{tid - self_as_arg0}) {{\\n                            CHECK(({check}({arg_names[tid]})));\\n                            arg{tid} = {tpc}({arg_names[tid]}{holder_set});\\n                            arg_filled |= 1ull << {tid};\\n                        }}\\n            '\n            fill_with_default += f'\\n                        if (!(arg_filled & (1ull<<{tid}))) {{\\n                            arg{tid} = {default_arg};\\n                        }}\\n            '\n        else:\n            func_quick_check_runable += f' && {check}({arg_names[tid]})'\n            func_args_convert += f'\\n                        {holder_dec};\\n                        {jtp} arg{tid} = {tpc}({arg_names[tid]}{holder_set});\\n            '\n        if tid:\n            func_call += ','\n        if args[tid][3].endswith('&&'):\n            func_call += f'move(arg{tid})'\n        else:\n            func_call += f'arg{tid}'\n    if pyname == '__richcmp__':\n        for rname in ['__lt__', '__le__', '__gt__', '__ge__', '__eq__', '__ne__']:\n            if rname in df['attrs']:\n                func_quick_check_runable += ' && op==Py_' + rname[2:-2].upper()\n    fill_with_kw = ''\n    if is_fast_call and len(kw_args_id):\n        fill_with_kw = f'''\\n                        if (kw) {{\\n                            auto kw_n = Py_SIZE(kw);\\n                            for (int i=0; i<kw_n; i++) {{\\n                                auto ko = PyTuple_GET_ITEM(kw, i);\\n                                auto vo = args[i+n];\\n                                auto ks = PyUnicode_AsUTF8(ko);\\n                                uint khash = hash(ks);\\n                                {''.join([f\"\"\"\n                                if ({get_hash_condition(args[aid][1])}) {{\n                                    // hash match {args[aid][1]}\n                                    CHECK(({get_pytype_map(args[aid][0], 2)}(vo)));\n                                    arg{aid} = {pytypes[aid]}(vo{holder_set_array[aid]});\n                                    arg_filled |= 1ull << {aid};\n                                    continue;\n                                }}\n                                \"\"\" for aid in kw_args_id])}\\n                                LOGf << \"Not a valid keyword:\" << ks;\\n                            }}\\n                        }}\\n        '''\n    if len(args):\n        func_args_convert += '\\n                        CHECK(!PyErr_Occurred());\\n        '\n    func_call += ')'\n    if df['is_property']:\n        if pyname.startswith('__get__'):\n            func_call = df['func_name']\n        else:\n            assert pyname.startswith('__set__'), pyname\n            func_call = df['func_name'] + '= arg0'\n    has_return = df['return_t'] != 'void' and df['return_t'] != ''\n    if df['is_scope_def']:\n        if df['is_static']:\n            func_call = f'{scope_name}::' + func_call\n        else:\n            func_call = f'(GET_RAW_PTR({scope_name},self))->' + func_call\n    if pyname == '__init__':\n        assert '->' in func_call, func_call\n        func_call = 'new ' + func_call.replace('->', ' ')\n    if no_need_convert:\n        func_quick_check_runable = ''\n        func_args_convert = ''\n        fill_with_kw = fill_with_default = ''\n    return (func_quick_check_size + func_quick_check_runable, func_args_convert, fill_with_kw + fill_with_default, func_call, has_return)",
        "mutated": [
            "def get_def_code(df, scope_name, pyname, self_as_arg0=False):\n    if False:\n        i = 10\n    is_fast_call = not pyname.startswith('__')\n    no_need_convert = pyname == '__getitem__'\n    args = df['args']\n    max_args = len(args)\n    min_args = max_args\n    for (tid, a) in enumerate(args):\n        if a[2] != '':\n            min_args = tid\n            break\n    arg_names = [f'args[{i}]' for i in range(len(args))]\n    if self_as_arg0:\n        max_args -= 1\n        min_args -= 1\n        arg_names = ['self'] + arg_names[:-1]\n    kw_args_id = []\n    for (aid, arg) in enumerate(args):\n        if 'VarHolder*' != arg[0] and is_fast_call:\n            kw_args_id.append(aid)\n    func_quick_check_runable = ''\n    func_quick_check_size = f'n<={max_args} && n>={min_args}'\n    if len(kw_args_id):\n        func_quick_check_size = f'n+(kw?Py_SIZE(kw):0)<={max_args} && n+(kw?Py_SIZE(kw):0)>={min_args}'\n    fill_with_default = ''\n    func_args_convert = ''\n    func_call = df['func_name'] + '('\n    pytypes = [get_pytype_map(a[0], 0) for a in args]\n    holder_dec_array = []\n    holder_set_array = []\n    for (tid, tpc) in enumerate(pytypes):\n        check = get_pytype_map(args[tid][0], 2)\n        default_arg = args[tid][2]\n        jtp = args[tid][0]\n        holder_dec = ''\n        holder_set = ''\n        if jtp == 'VarHolder*':\n            holder_dec = f'unique_ptr<VarHolder> arg{tid}_holder'\n            holder_set = f', arg{tid}_holder'\n        if jtp == 'VarSlices':\n            holder_dec = f'vector<unique_ptr<VarHolder>> arg{tid}_holder'\n            holder_set = f', arg{tid}_holder'\n        holder_dec_array.append(holder_dec)\n        holder_set_array.append(holder_set)\n        if len(default_arg):\n            func_args_convert += f'\\n                        {holder_dec};\\n                        {jtp} arg{tid};\\n                        if (n>{tid - self_as_arg0}) {{\\n                            CHECK(({check}({arg_names[tid]})));\\n                            arg{tid} = {tpc}({arg_names[tid]}{holder_set});\\n                            arg_filled |= 1ull << {tid};\\n                        }}\\n            '\n            fill_with_default += f'\\n                        if (!(arg_filled & (1ull<<{tid}))) {{\\n                            arg{tid} = {default_arg};\\n                        }}\\n            '\n        else:\n            func_quick_check_runable += f' && {check}({arg_names[tid]})'\n            func_args_convert += f'\\n                        {holder_dec};\\n                        {jtp} arg{tid} = {tpc}({arg_names[tid]}{holder_set});\\n            '\n        if tid:\n            func_call += ','\n        if args[tid][3].endswith('&&'):\n            func_call += f'move(arg{tid})'\n        else:\n            func_call += f'arg{tid}'\n    if pyname == '__richcmp__':\n        for rname in ['__lt__', '__le__', '__gt__', '__ge__', '__eq__', '__ne__']:\n            if rname in df['attrs']:\n                func_quick_check_runable += ' && op==Py_' + rname[2:-2].upper()\n    fill_with_kw = ''\n    if is_fast_call and len(kw_args_id):\n        fill_with_kw = f'''\\n                        if (kw) {{\\n                            auto kw_n = Py_SIZE(kw);\\n                            for (int i=0; i<kw_n; i++) {{\\n                                auto ko = PyTuple_GET_ITEM(kw, i);\\n                                auto vo = args[i+n];\\n                                auto ks = PyUnicode_AsUTF8(ko);\\n                                uint khash = hash(ks);\\n                                {''.join([f\"\"\"\n                                if ({get_hash_condition(args[aid][1])}) {{\n                                    // hash match {args[aid][1]}\n                                    CHECK(({get_pytype_map(args[aid][0], 2)}(vo)));\n                                    arg{aid} = {pytypes[aid]}(vo{holder_set_array[aid]});\n                                    arg_filled |= 1ull << {aid};\n                                    continue;\n                                }}\n                                \"\"\" for aid in kw_args_id])}\\n                                LOGf << \"Not a valid keyword:\" << ks;\\n                            }}\\n                        }}\\n        '''\n    if len(args):\n        func_args_convert += '\\n                        CHECK(!PyErr_Occurred());\\n        '\n    func_call += ')'\n    if df['is_property']:\n        if pyname.startswith('__get__'):\n            func_call = df['func_name']\n        else:\n            assert pyname.startswith('__set__'), pyname\n            func_call = df['func_name'] + '= arg0'\n    has_return = df['return_t'] != 'void' and df['return_t'] != ''\n    if df['is_scope_def']:\n        if df['is_static']:\n            func_call = f'{scope_name}::' + func_call\n        else:\n            func_call = f'(GET_RAW_PTR({scope_name},self))->' + func_call\n    if pyname == '__init__':\n        assert '->' in func_call, func_call\n        func_call = 'new ' + func_call.replace('->', ' ')\n    if no_need_convert:\n        func_quick_check_runable = ''\n        func_args_convert = ''\n        fill_with_kw = fill_with_default = ''\n    return (func_quick_check_size + func_quick_check_runable, func_args_convert, fill_with_kw + fill_with_default, func_call, has_return)",
            "def get_def_code(df, scope_name, pyname, self_as_arg0=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    is_fast_call = not pyname.startswith('__')\n    no_need_convert = pyname == '__getitem__'\n    args = df['args']\n    max_args = len(args)\n    min_args = max_args\n    for (tid, a) in enumerate(args):\n        if a[2] != '':\n            min_args = tid\n            break\n    arg_names = [f'args[{i}]' for i in range(len(args))]\n    if self_as_arg0:\n        max_args -= 1\n        min_args -= 1\n        arg_names = ['self'] + arg_names[:-1]\n    kw_args_id = []\n    for (aid, arg) in enumerate(args):\n        if 'VarHolder*' != arg[0] and is_fast_call:\n            kw_args_id.append(aid)\n    func_quick_check_runable = ''\n    func_quick_check_size = f'n<={max_args} && n>={min_args}'\n    if len(kw_args_id):\n        func_quick_check_size = f'n+(kw?Py_SIZE(kw):0)<={max_args} && n+(kw?Py_SIZE(kw):0)>={min_args}'\n    fill_with_default = ''\n    func_args_convert = ''\n    func_call = df['func_name'] + '('\n    pytypes = [get_pytype_map(a[0], 0) for a in args]\n    holder_dec_array = []\n    holder_set_array = []\n    for (tid, tpc) in enumerate(pytypes):\n        check = get_pytype_map(args[tid][0], 2)\n        default_arg = args[tid][2]\n        jtp = args[tid][0]\n        holder_dec = ''\n        holder_set = ''\n        if jtp == 'VarHolder*':\n            holder_dec = f'unique_ptr<VarHolder> arg{tid}_holder'\n            holder_set = f', arg{tid}_holder'\n        if jtp == 'VarSlices':\n            holder_dec = f'vector<unique_ptr<VarHolder>> arg{tid}_holder'\n            holder_set = f', arg{tid}_holder'\n        holder_dec_array.append(holder_dec)\n        holder_set_array.append(holder_set)\n        if len(default_arg):\n            func_args_convert += f'\\n                        {holder_dec};\\n                        {jtp} arg{tid};\\n                        if (n>{tid - self_as_arg0}) {{\\n                            CHECK(({check}({arg_names[tid]})));\\n                            arg{tid} = {tpc}({arg_names[tid]}{holder_set});\\n                            arg_filled |= 1ull << {tid};\\n                        }}\\n            '\n            fill_with_default += f'\\n                        if (!(arg_filled & (1ull<<{tid}))) {{\\n                            arg{tid} = {default_arg};\\n                        }}\\n            '\n        else:\n            func_quick_check_runable += f' && {check}({arg_names[tid]})'\n            func_args_convert += f'\\n                        {holder_dec};\\n                        {jtp} arg{tid} = {tpc}({arg_names[tid]}{holder_set});\\n            '\n        if tid:\n            func_call += ','\n        if args[tid][3].endswith('&&'):\n            func_call += f'move(arg{tid})'\n        else:\n            func_call += f'arg{tid}'\n    if pyname == '__richcmp__':\n        for rname in ['__lt__', '__le__', '__gt__', '__ge__', '__eq__', '__ne__']:\n            if rname in df['attrs']:\n                func_quick_check_runable += ' && op==Py_' + rname[2:-2].upper()\n    fill_with_kw = ''\n    if is_fast_call and len(kw_args_id):\n        fill_with_kw = f'''\\n                        if (kw) {{\\n                            auto kw_n = Py_SIZE(kw);\\n                            for (int i=0; i<kw_n; i++) {{\\n                                auto ko = PyTuple_GET_ITEM(kw, i);\\n                                auto vo = args[i+n];\\n                                auto ks = PyUnicode_AsUTF8(ko);\\n                                uint khash = hash(ks);\\n                                {''.join([f\"\"\"\n                                if ({get_hash_condition(args[aid][1])}) {{\n                                    // hash match {args[aid][1]}\n                                    CHECK(({get_pytype_map(args[aid][0], 2)}(vo)));\n                                    arg{aid} = {pytypes[aid]}(vo{holder_set_array[aid]});\n                                    arg_filled |= 1ull << {aid};\n                                    continue;\n                                }}\n                                \"\"\" for aid in kw_args_id])}\\n                                LOGf << \"Not a valid keyword:\" << ks;\\n                            }}\\n                        }}\\n        '''\n    if len(args):\n        func_args_convert += '\\n                        CHECK(!PyErr_Occurred());\\n        '\n    func_call += ')'\n    if df['is_property']:\n        if pyname.startswith('__get__'):\n            func_call = df['func_name']\n        else:\n            assert pyname.startswith('__set__'), pyname\n            func_call = df['func_name'] + '= arg0'\n    has_return = df['return_t'] != 'void' and df['return_t'] != ''\n    if df['is_scope_def']:\n        if df['is_static']:\n            func_call = f'{scope_name}::' + func_call\n        else:\n            func_call = f'(GET_RAW_PTR({scope_name},self))->' + func_call\n    if pyname == '__init__':\n        assert '->' in func_call, func_call\n        func_call = 'new ' + func_call.replace('->', ' ')\n    if no_need_convert:\n        func_quick_check_runable = ''\n        func_args_convert = ''\n        fill_with_kw = fill_with_default = ''\n    return (func_quick_check_size + func_quick_check_runable, func_args_convert, fill_with_kw + fill_with_default, func_call, has_return)",
            "def get_def_code(df, scope_name, pyname, self_as_arg0=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    is_fast_call = not pyname.startswith('__')\n    no_need_convert = pyname == '__getitem__'\n    args = df['args']\n    max_args = len(args)\n    min_args = max_args\n    for (tid, a) in enumerate(args):\n        if a[2] != '':\n            min_args = tid\n            break\n    arg_names = [f'args[{i}]' for i in range(len(args))]\n    if self_as_arg0:\n        max_args -= 1\n        min_args -= 1\n        arg_names = ['self'] + arg_names[:-1]\n    kw_args_id = []\n    for (aid, arg) in enumerate(args):\n        if 'VarHolder*' != arg[0] and is_fast_call:\n            kw_args_id.append(aid)\n    func_quick_check_runable = ''\n    func_quick_check_size = f'n<={max_args} && n>={min_args}'\n    if len(kw_args_id):\n        func_quick_check_size = f'n+(kw?Py_SIZE(kw):0)<={max_args} && n+(kw?Py_SIZE(kw):0)>={min_args}'\n    fill_with_default = ''\n    func_args_convert = ''\n    func_call = df['func_name'] + '('\n    pytypes = [get_pytype_map(a[0], 0) for a in args]\n    holder_dec_array = []\n    holder_set_array = []\n    for (tid, tpc) in enumerate(pytypes):\n        check = get_pytype_map(args[tid][0], 2)\n        default_arg = args[tid][2]\n        jtp = args[tid][0]\n        holder_dec = ''\n        holder_set = ''\n        if jtp == 'VarHolder*':\n            holder_dec = f'unique_ptr<VarHolder> arg{tid}_holder'\n            holder_set = f', arg{tid}_holder'\n        if jtp == 'VarSlices':\n            holder_dec = f'vector<unique_ptr<VarHolder>> arg{tid}_holder'\n            holder_set = f', arg{tid}_holder'\n        holder_dec_array.append(holder_dec)\n        holder_set_array.append(holder_set)\n        if len(default_arg):\n            func_args_convert += f'\\n                        {holder_dec};\\n                        {jtp} arg{tid};\\n                        if (n>{tid - self_as_arg0}) {{\\n                            CHECK(({check}({arg_names[tid]})));\\n                            arg{tid} = {tpc}({arg_names[tid]}{holder_set});\\n                            arg_filled |= 1ull << {tid};\\n                        }}\\n            '\n            fill_with_default += f'\\n                        if (!(arg_filled & (1ull<<{tid}))) {{\\n                            arg{tid} = {default_arg};\\n                        }}\\n            '\n        else:\n            func_quick_check_runable += f' && {check}({arg_names[tid]})'\n            func_args_convert += f'\\n                        {holder_dec};\\n                        {jtp} arg{tid} = {tpc}({arg_names[tid]}{holder_set});\\n            '\n        if tid:\n            func_call += ','\n        if args[tid][3].endswith('&&'):\n            func_call += f'move(arg{tid})'\n        else:\n            func_call += f'arg{tid}'\n    if pyname == '__richcmp__':\n        for rname in ['__lt__', '__le__', '__gt__', '__ge__', '__eq__', '__ne__']:\n            if rname in df['attrs']:\n                func_quick_check_runable += ' && op==Py_' + rname[2:-2].upper()\n    fill_with_kw = ''\n    if is_fast_call and len(kw_args_id):\n        fill_with_kw = f'''\\n                        if (kw) {{\\n                            auto kw_n = Py_SIZE(kw);\\n                            for (int i=0; i<kw_n; i++) {{\\n                                auto ko = PyTuple_GET_ITEM(kw, i);\\n                                auto vo = args[i+n];\\n                                auto ks = PyUnicode_AsUTF8(ko);\\n                                uint khash = hash(ks);\\n                                {''.join([f\"\"\"\n                                if ({get_hash_condition(args[aid][1])}) {{\n                                    // hash match {args[aid][1]}\n                                    CHECK(({get_pytype_map(args[aid][0], 2)}(vo)));\n                                    arg{aid} = {pytypes[aid]}(vo{holder_set_array[aid]});\n                                    arg_filled |= 1ull << {aid};\n                                    continue;\n                                }}\n                                \"\"\" for aid in kw_args_id])}\\n                                LOGf << \"Not a valid keyword:\" << ks;\\n                            }}\\n                        }}\\n        '''\n    if len(args):\n        func_args_convert += '\\n                        CHECK(!PyErr_Occurred());\\n        '\n    func_call += ')'\n    if df['is_property']:\n        if pyname.startswith('__get__'):\n            func_call = df['func_name']\n        else:\n            assert pyname.startswith('__set__'), pyname\n            func_call = df['func_name'] + '= arg0'\n    has_return = df['return_t'] != 'void' and df['return_t'] != ''\n    if df['is_scope_def']:\n        if df['is_static']:\n            func_call = f'{scope_name}::' + func_call\n        else:\n            func_call = f'(GET_RAW_PTR({scope_name},self))->' + func_call\n    if pyname == '__init__':\n        assert '->' in func_call, func_call\n        func_call = 'new ' + func_call.replace('->', ' ')\n    if no_need_convert:\n        func_quick_check_runable = ''\n        func_args_convert = ''\n        fill_with_kw = fill_with_default = ''\n    return (func_quick_check_size + func_quick_check_runable, func_args_convert, fill_with_kw + fill_with_default, func_call, has_return)",
            "def get_def_code(df, scope_name, pyname, self_as_arg0=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    is_fast_call = not pyname.startswith('__')\n    no_need_convert = pyname == '__getitem__'\n    args = df['args']\n    max_args = len(args)\n    min_args = max_args\n    for (tid, a) in enumerate(args):\n        if a[2] != '':\n            min_args = tid\n            break\n    arg_names = [f'args[{i}]' for i in range(len(args))]\n    if self_as_arg0:\n        max_args -= 1\n        min_args -= 1\n        arg_names = ['self'] + arg_names[:-1]\n    kw_args_id = []\n    for (aid, arg) in enumerate(args):\n        if 'VarHolder*' != arg[0] and is_fast_call:\n            kw_args_id.append(aid)\n    func_quick_check_runable = ''\n    func_quick_check_size = f'n<={max_args} && n>={min_args}'\n    if len(kw_args_id):\n        func_quick_check_size = f'n+(kw?Py_SIZE(kw):0)<={max_args} && n+(kw?Py_SIZE(kw):0)>={min_args}'\n    fill_with_default = ''\n    func_args_convert = ''\n    func_call = df['func_name'] + '('\n    pytypes = [get_pytype_map(a[0], 0) for a in args]\n    holder_dec_array = []\n    holder_set_array = []\n    for (tid, tpc) in enumerate(pytypes):\n        check = get_pytype_map(args[tid][0], 2)\n        default_arg = args[tid][2]\n        jtp = args[tid][0]\n        holder_dec = ''\n        holder_set = ''\n        if jtp == 'VarHolder*':\n            holder_dec = f'unique_ptr<VarHolder> arg{tid}_holder'\n            holder_set = f', arg{tid}_holder'\n        if jtp == 'VarSlices':\n            holder_dec = f'vector<unique_ptr<VarHolder>> arg{tid}_holder'\n            holder_set = f', arg{tid}_holder'\n        holder_dec_array.append(holder_dec)\n        holder_set_array.append(holder_set)\n        if len(default_arg):\n            func_args_convert += f'\\n                        {holder_dec};\\n                        {jtp} arg{tid};\\n                        if (n>{tid - self_as_arg0}) {{\\n                            CHECK(({check}({arg_names[tid]})));\\n                            arg{tid} = {tpc}({arg_names[tid]}{holder_set});\\n                            arg_filled |= 1ull << {tid};\\n                        }}\\n            '\n            fill_with_default += f'\\n                        if (!(arg_filled & (1ull<<{tid}))) {{\\n                            arg{tid} = {default_arg};\\n                        }}\\n            '\n        else:\n            func_quick_check_runable += f' && {check}({arg_names[tid]})'\n            func_args_convert += f'\\n                        {holder_dec};\\n                        {jtp} arg{tid} = {tpc}({arg_names[tid]}{holder_set});\\n            '\n        if tid:\n            func_call += ','\n        if args[tid][3].endswith('&&'):\n            func_call += f'move(arg{tid})'\n        else:\n            func_call += f'arg{tid}'\n    if pyname == '__richcmp__':\n        for rname in ['__lt__', '__le__', '__gt__', '__ge__', '__eq__', '__ne__']:\n            if rname in df['attrs']:\n                func_quick_check_runable += ' && op==Py_' + rname[2:-2].upper()\n    fill_with_kw = ''\n    if is_fast_call and len(kw_args_id):\n        fill_with_kw = f'''\\n                        if (kw) {{\\n                            auto kw_n = Py_SIZE(kw);\\n                            for (int i=0; i<kw_n; i++) {{\\n                                auto ko = PyTuple_GET_ITEM(kw, i);\\n                                auto vo = args[i+n];\\n                                auto ks = PyUnicode_AsUTF8(ko);\\n                                uint khash = hash(ks);\\n                                {''.join([f\"\"\"\n                                if ({get_hash_condition(args[aid][1])}) {{\n                                    // hash match {args[aid][1]}\n                                    CHECK(({get_pytype_map(args[aid][0], 2)}(vo)));\n                                    arg{aid} = {pytypes[aid]}(vo{holder_set_array[aid]});\n                                    arg_filled |= 1ull << {aid};\n                                    continue;\n                                }}\n                                \"\"\" for aid in kw_args_id])}\\n                                LOGf << \"Not a valid keyword:\" << ks;\\n                            }}\\n                        }}\\n        '''\n    if len(args):\n        func_args_convert += '\\n                        CHECK(!PyErr_Occurred());\\n        '\n    func_call += ')'\n    if df['is_property']:\n        if pyname.startswith('__get__'):\n            func_call = df['func_name']\n        else:\n            assert pyname.startswith('__set__'), pyname\n            func_call = df['func_name'] + '= arg0'\n    has_return = df['return_t'] != 'void' and df['return_t'] != ''\n    if df['is_scope_def']:\n        if df['is_static']:\n            func_call = f'{scope_name}::' + func_call\n        else:\n            func_call = f'(GET_RAW_PTR({scope_name},self))->' + func_call\n    if pyname == '__init__':\n        assert '->' in func_call, func_call\n        func_call = 'new ' + func_call.replace('->', ' ')\n    if no_need_convert:\n        func_quick_check_runable = ''\n        func_args_convert = ''\n        fill_with_kw = fill_with_default = ''\n    return (func_quick_check_size + func_quick_check_runable, func_args_convert, fill_with_kw + fill_with_default, func_call, has_return)",
            "def get_def_code(df, scope_name, pyname, self_as_arg0=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    is_fast_call = not pyname.startswith('__')\n    no_need_convert = pyname == '__getitem__'\n    args = df['args']\n    max_args = len(args)\n    min_args = max_args\n    for (tid, a) in enumerate(args):\n        if a[2] != '':\n            min_args = tid\n            break\n    arg_names = [f'args[{i}]' for i in range(len(args))]\n    if self_as_arg0:\n        max_args -= 1\n        min_args -= 1\n        arg_names = ['self'] + arg_names[:-1]\n    kw_args_id = []\n    for (aid, arg) in enumerate(args):\n        if 'VarHolder*' != arg[0] and is_fast_call:\n            kw_args_id.append(aid)\n    func_quick_check_runable = ''\n    func_quick_check_size = f'n<={max_args} && n>={min_args}'\n    if len(kw_args_id):\n        func_quick_check_size = f'n+(kw?Py_SIZE(kw):0)<={max_args} && n+(kw?Py_SIZE(kw):0)>={min_args}'\n    fill_with_default = ''\n    func_args_convert = ''\n    func_call = df['func_name'] + '('\n    pytypes = [get_pytype_map(a[0], 0) for a in args]\n    holder_dec_array = []\n    holder_set_array = []\n    for (tid, tpc) in enumerate(pytypes):\n        check = get_pytype_map(args[tid][0], 2)\n        default_arg = args[tid][2]\n        jtp = args[tid][0]\n        holder_dec = ''\n        holder_set = ''\n        if jtp == 'VarHolder*':\n            holder_dec = f'unique_ptr<VarHolder> arg{tid}_holder'\n            holder_set = f', arg{tid}_holder'\n        if jtp == 'VarSlices':\n            holder_dec = f'vector<unique_ptr<VarHolder>> arg{tid}_holder'\n            holder_set = f', arg{tid}_holder'\n        holder_dec_array.append(holder_dec)\n        holder_set_array.append(holder_set)\n        if len(default_arg):\n            func_args_convert += f'\\n                        {holder_dec};\\n                        {jtp} arg{tid};\\n                        if (n>{tid - self_as_arg0}) {{\\n                            CHECK(({check}({arg_names[tid]})));\\n                            arg{tid} = {tpc}({arg_names[tid]}{holder_set});\\n                            arg_filled |= 1ull << {tid};\\n                        }}\\n            '\n            fill_with_default += f'\\n                        if (!(arg_filled & (1ull<<{tid}))) {{\\n                            arg{tid} = {default_arg};\\n                        }}\\n            '\n        else:\n            func_quick_check_runable += f' && {check}({arg_names[tid]})'\n            func_args_convert += f'\\n                        {holder_dec};\\n                        {jtp} arg{tid} = {tpc}({arg_names[tid]}{holder_set});\\n            '\n        if tid:\n            func_call += ','\n        if args[tid][3].endswith('&&'):\n            func_call += f'move(arg{tid})'\n        else:\n            func_call += f'arg{tid}'\n    if pyname == '__richcmp__':\n        for rname in ['__lt__', '__le__', '__gt__', '__ge__', '__eq__', '__ne__']:\n            if rname in df['attrs']:\n                func_quick_check_runable += ' && op==Py_' + rname[2:-2].upper()\n    fill_with_kw = ''\n    if is_fast_call and len(kw_args_id):\n        fill_with_kw = f'''\\n                        if (kw) {{\\n                            auto kw_n = Py_SIZE(kw);\\n                            for (int i=0; i<kw_n; i++) {{\\n                                auto ko = PyTuple_GET_ITEM(kw, i);\\n                                auto vo = args[i+n];\\n                                auto ks = PyUnicode_AsUTF8(ko);\\n                                uint khash = hash(ks);\\n                                {''.join([f\"\"\"\n                                if ({get_hash_condition(args[aid][1])}) {{\n                                    // hash match {args[aid][1]}\n                                    CHECK(({get_pytype_map(args[aid][0], 2)}(vo)));\n                                    arg{aid} = {pytypes[aid]}(vo{holder_set_array[aid]});\n                                    arg_filled |= 1ull << {aid};\n                                    continue;\n                                }}\n                                \"\"\" for aid in kw_args_id])}\\n                                LOGf << \"Not a valid keyword:\" << ks;\\n                            }}\\n                        }}\\n        '''\n    if len(args):\n        func_args_convert += '\\n                        CHECK(!PyErr_Occurred());\\n        '\n    func_call += ')'\n    if df['is_property']:\n        if pyname.startswith('__get__'):\n            func_call = df['func_name']\n        else:\n            assert pyname.startswith('__set__'), pyname\n            func_call = df['func_name'] + '= arg0'\n    has_return = df['return_t'] != 'void' and df['return_t'] != ''\n    if df['is_scope_def']:\n        if df['is_static']:\n            func_call = f'{scope_name}::' + func_call\n        else:\n            func_call = f'(GET_RAW_PTR({scope_name},self))->' + func_call\n    if pyname == '__init__':\n        assert '->' in func_call, func_call\n        func_call = 'new ' + func_call.replace('->', ' ')\n    if no_need_convert:\n        func_quick_check_runable = ''\n        func_args_convert = ''\n        fill_with_kw = fill_with_default = ''\n    return (func_quick_check_size + func_quick_check_runable, func_args_convert, fill_with_kw + fill_with_default, func_call, has_return)"
        ]
    },
    {
        "func_name": "get_hash",
        "original": "def get_hash(s):\n    mask = (1 << 32) - 1\n    v = 0\n    mul = 1\n    for c in s:\n        v += mul * ord(c)\n        mul *= 55\n        v &= mask\n        mul &= mask\n    if v in hash_to_key_map:\n        assert hash_to_key_map[v] == s, f'hash conflict {hash_to_key_map[v]} {s} {hash_to_key_map}'\n    hash_to_key_map[v] = s\n    return v",
        "mutated": [
            "def get_hash(s):\n    if False:\n        i = 10\n    mask = (1 << 32) - 1\n    v = 0\n    mul = 1\n    for c in s:\n        v += mul * ord(c)\n        mul *= 55\n        v &= mask\n        mul &= mask\n    if v in hash_to_key_map:\n        assert hash_to_key_map[v] == s, f'hash conflict {hash_to_key_map[v]} {s} {hash_to_key_map}'\n    hash_to_key_map[v] = s\n    return v",
            "def get_hash(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mask = (1 << 32) - 1\n    v = 0\n    mul = 1\n    for c in s:\n        v += mul * ord(c)\n        mul *= 55\n        v &= mask\n        mul &= mask\n    if v in hash_to_key_map:\n        assert hash_to_key_map[v] == s, f'hash conflict {hash_to_key_map[v]} {s} {hash_to_key_map}'\n    hash_to_key_map[v] = s\n    return v",
            "def get_hash(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mask = (1 << 32) - 1\n    v = 0\n    mul = 1\n    for c in s:\n        v += mul * ord(c)\n        mul *= 55\n        v &= mask\n        mul &= mask\n    if v in hash_to_key_map:\n        assert hash_to_key_map[v] == s, f'hash conflict {hash_to_key_map[v]} {s} {hash_to_key_map}'\n    hash_to_key_map[v] = s\n    return v",
            "def get_hash(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mask = (1 << 32) - 1\n    v = 0\n    mul = 1\n    for c in s:\n        v += mul * ord(c)\n        mul *= 55\n        v &= mask\n        mul &= mask\n    if v in hash_to_key_map:\n        assert hash_to_key_map[v] == s, f'hash conflict {hash_to_key_map[v]} {s} {hash_to_key_map}'\n    hash_to_key_map[v] = s\n    return v",
            "def get_hash(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mask = (1 << 32) - 1\n    v = 0\n    mul = 1\n    for c in s:\n        v += mul * ord(c)\n        mul *= 55\n        v &= mask\n        mul &= mask\n    if v in hash_to_key_map:\n        assert hash_to_key_map[v] == s, f'hash conflict {hash_to_key_map[v]} {s} {hash_to_key_map}'\n    hash_to_key_map[v] = s\n    return v"
        ]
    },
    {
        "func_name": "get_hash_condition",
        "original": "def get_hash_condition(s):\n    if s == 'keepdims':\n        return f\"khash == {get_hash(s)}u || khash == {get_hash('keepdim')}u\"\n    return f'khash == {get_hash(s)}u'",
        "mutated": [
            "def get_hash_condition(s):\n    if False:\n        i = 10\n    if s == 'keepdims':\n        return f\"khash == {get_hash(s)}u || khash == {get_hash('keepdim')}u\"\n    return f'khash == {get_hash(s)}u'",
            "def get_hash_condition(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if s == 'keepdims':\n        return f\"khash == {get_hash(s)}u || khash == {get_hash('keepdim')}u\"\n    return f'khash == {get_hash(s)}u'",
            "def get_hash_condition(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if s == 'keepdims':\n        return f\"khash == {get_hash(s)}u || khash == {get_hash('keepdim')}u\"\n    return f'khash == {get_hash(s)}u'",
            "def get_hash_condition(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if s == 'keepdims':\n        return f\"khash == {get_hash(s)}u || khash == {get_hash('keepdim')}u\"\n    return f'khash == {get_hash(s)}u'",
            "def get_hash_condition(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if s == 'keepdims':\n        return f\"khash == {get_hash(s)}u || khash == {get_hash('keepdim')}u\"\n    return f'khash == {get_hash(s)}u'"
        ]
    },
    {
        "func_name": "generate_error_code_from_func_header",
        "original": "def generate_error_code_from_func_header(func_head, target_scope_name, name, dfs, basename, h, class_info):\n    lib_name = os.path.basename(h).split('_')[0]\n    if target_scope_name == 'Var':\n        target_scope_name = None\n    if target_scope_name:\n        if target_scope_name == 'flags':\n            help_name = 'flags'\n        else:\n            help_name = '' + target_scope_name + '.' + name\n    else:\n        help_name = name\n    if lib_name in ['mpi', 'nccl', 'cudnn', 'curandcufft', 'cublas', 'mkl']:\n        help_name = lib_name + '.' + help_name\n    help_cmd = f'help(jt.{help_name})'\n    LOG.vvv('gen err from func_head', func_head)\n    args = func_head[1:].split(')')[0].split(',')\n    error_code = f' << \"Wrong inputs arguments, Please refer to examples({help_cmd}).\"'\n    error_code += ' << \"\\\\n\\\\nTypes of your inputs are:\\\\n\"'\n    for arg in args:\n        arg = arg.strip()\n        if arg.startswith('PyObject* '):\n            (t, n) = arg.split(' ')\n            if n == 'args' or n == '_args':\n                error_code += f' << PyTupleArgPrinter{{{n}, \"args\"}} '\n            elif n == 'kw':\n                error_code += f' << PyKwArgPrinter{{{n}}} '\n            else:\n                error_code += f' << PyArgPrinter{{{n}, \"{n}\"}} '\n        elif arg.startswith('PyObject** '):\n            (t, n) = arg.split(' ')\n            error_code += f' << PyFastCallArgPrinter{{{n}, n, kw}} '\n            break\n        else:\n            LOG.vvv('Unhandled arg', arg)\n    LOG.vvv('gen err from func_head', func_head, ' -> ', error_code)\n    return error_code",
        "mutated": [
            "def generate_error_code_from_func_header(func_head, target_scope_name, name, dfs, basename, h, class_info):\n    if False:\n        i = 10\n    lib_name = os.path.basename(h).split('_')[0]\n    if target_scope_name == 'Var':\n        target_scope_name = None\n    if target_scope_name:\n        if target_scope_name == 'flags':\n            help_name = 'flags'\n        else:\n            help_name = '' + target_scope_name + '.' + name\n    else:\n        help_name = name\n    if lib_name in ['mpi', 'nccl', 'cudnn', 'curandcufft', 'cublas', 'mkl']:\n        help_name = lib_name + '.' + help_name\n    help_cmd = f'help(jt.{help_name})'\n    LOG.vvv('gen err from func_head', func_head)\n    args = func_head[1:].split(')')[0].split(',')\n    error_code = f' << \"Wrong inputs arguments, Please refer to examples({help_cmd}).\"'\n    error_code += ' << \"\\\\n\\\\nTypes of your inputs are:\\\\n\"'\n    for arg in args:\n        arg = arg.strip()\n        if arg.startswith('PyObject* '):\n            (t, n) = arg.split(' ')\n            if n == 'args' or n == '_args':\n                error_code += f' << PyTupleArgPrinter{{{n}, \"args\"}} '\n            elif n == 'kw':\n                error_code += f' << PyKwArgPrinter{{{n}}} '\n            else:\n                error_code += f' << PyArgPrinter{{{n}, \"{n}\"}} '\n        elif arg.startswith('PyObject** '):\n            (t, n) = arg.split(' ')\n            error_code += f' << PyFastCallArgPrinter{{{n}, n, kw}} '\n            break\n        else:\n            LOG.vvv('Unhandled arg', arg)\n    LOG.vvv('gen err from func_head', func_head, ' -> ', error_code)\n    return error_code",
            "def generate_error_code_from_func_header(func_head, target_scope_name, name, dfs, basename, h, class_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    lib_name = os.path.basename(h).split('_')[0]\n    if target_scope_name == 'Var':\n        target_scope_name = None\n    if target_scope_name:\n        if target_scope_name == 'flags':\n            help_name = 'flags'\n        else:\n            help_name = '' + target_scope_name + '.' + name\n    else:\n        help_name = name\n    if lib_name in ['mpi', 'nccl', 'cudnn', 'curandcufft', 'cublas', 'mkl']:\n        help_name = lib_name + '.' + help_name\n    help_cmd = f'help(jt.{help_name})'\n    LOG.vvv('gen err from func_head', func_head)\n    args = func_head[1:].split(')')[0].split(',')\n    error_code = f' << \"Wrong inputs arguments, Please refer to examples({help_cmd}).\"'\n    error_code += ' << \"\\\\n\\\\nTypes of your inputs are:\\\\n\"'\n    for arg in args:\n        arg = arg.strip()\n        if arg.startswith('PyObject* '):\n            (t, n) = arg.split(' ')\n            if n == 'args' or n == '_args':\n                error_code += f' << PyTupleArgPrinter{{{n}, \"args\"}} '\n            elif n == 'kw':\n                error_code += f' << PyKwArgPrinter{{{n}}} '\n            else:\n                error_code += f' << PyArgPrinter{{{n}, \"{n}\"}} '\n        elif arg.startswith('PyObject** '):\n            (t, n) = arg.split(' ')\n            error_code += f' << PyFastCallArgPrinter{{{n}, n, kw}} '\n            break\n        else:\n            LOG.vvv('Unhandled arg', arg)\n    LOG.vvv('gen err from func_head', func_head, ' -> ', error_code)\n    return error_code",
            "def generate_error_code_from_func_header(func_head, target_scope_name, name, dfs, basename, h, class_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    lib_name = os.path.basename(h).split('_')[0]\n    if target_scope_name == 'Var':\n        target_scope_name = None\n    if target_scope_name:\n        if target_scope_name == 'flags':\n            help_name = 'flags'\n        else:\n            help_name = '' + target_scope_name + '.' + name\n    else:\n        help_name = name\n    if lib_name in ['mpi', 'nccl', 'cudnn', 'curandcufft', 'cublas', 'mkl']:\n        help_name = lib_name + '.' + help_name\n    help_cmd = f'help(jt.{help_name})'\n    LOG.vvv('gen err from func_head', func_head)\n    args = func_head[1:].split(')')[0].split(',')\n    error_code = f' << \"Wrong inputs arguments, Please refer to examples({help_cmd}).\"'\n    error_code += ' << \"\\\\n\\\\nTypes of your inputs are:\\\\n\"'\n    for arg in args:\n        arg = arg.strip()\n        if arg.startswith('PyObject* '):\n            (t, n) = arg.split(' ')\n            if n == 'args' or n == '_args':\n                error_code += f' << PyTupleArgPrinter{{{n}, \"args\"}} '\n            elif n == 'kw':\n                error_code += f' << PyKwArgPrinter{{{n}}} '\n            else:\n                error_code += f' << PyArgPrinter{{{n}, \"{n}\"}} '\n        elif arg.startswith('PyObject** '):\n            (t, n) = arg.split(' ')\n            error_code += f' << PyFastCallArgPrinter{{{n}, n, kw}} '\n            break\n        else:\n            LOG.vvv('Unhandled arg', arg)\n    LOG.vvv('gen err from func_head', func_head, ' -> ', error_code)\n    return error_code",
            "def generate_error_code_from_func_header(func_head, target_scope_name, name, dfs, basename, h, class_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    lib_name = os.path.basename(h).split('_')[0]\n    if target_scope_name == 'Var':\n        target_scope_name = None\n    if target_scope_name:\n        if target_scope_name == 'flags':\n            help_name = 'flags'\n        else:\n            help_name = '' + target_scope_name + '.' + name\n    else:\n        help_name = name\n    if lib_name in ['mpi', 'nccl', 'cudnn', 'curandcufft', 'cublas', 'mkl']:\n        help_name = lib_name + '.' + help_name\n    help_cmd = f'help(jt.{help_name})'\n    LOG.vvv('gen err from func_head', func_head)\n    args = func_head[1:].split(')')[0].split(',')\n    error_code = f' << \"Wrong inputs arguments, Please refer to examples({help_cmd}).\"'\n    error_code += ' << \"\\\\n\\\\nTypes of your inputs are:\\\\n\"'\n    for arg in args:\n        arg = arg.strip()\n        if arg.startswith('PyObject* '):\n            (t, n) = arg.split(' ')\n            if n == 'args' or n == '_args':\n                error_code += f' << PyTupleArgPrinter{{{n}, \"args\"}} '\n            elif n == 'kw':\n                error_code += f' << PyKwArgPrinter{{{n}}} '\n            else:\n                error_code += f' << PyArgPrinter{{{n}, \"{n}\"}} '\n        elif arg.startswith('PyObject** '):\n            (t, n) = arg.split(' ')\n            error_code += f' << PyFastCallArgPrinter{{{n}, n, kw}} '\n            break\n        else:\n            LOG.vvv('Unhandled arg', arg)\n    LOG.vvv('gen err from func_head', func_head, ' -> ', error_code)\n    return error_code",
            "def generate_error_code_from_func_header(func_head, target_scope_name, name, dfs, basename, h, class_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    lib_name = os.path.basename(h).split('_')[0]\n    if target_scope_name == 'Var':\n        target_scope_name = None\n    if target_scope_name:\n        if target_scope_name == 'flags':\n            help_name = 'flags'\n        else:\n            help_name = '' + target_scope_name + '.' + name\n    else:\n        help_name = name\n    if lib_name in ['mpi', 'nccl', 'cudnn', 'curandcufft', 'cublas', 'mkl']:\n        help_name = lib_name + '.' + help_name\n    help_cmd = f'help(jt.{help_name})'\n    LOG.vvv('gen err from func_head', func_head)\n    args = func_head[1:].split(')')[0].split(',')\n    error_code = f' << \"Wrong inputs arguments, Please refer to examples({help_cmd}).\"'\n    error_code += ' << \"\\\\n\\\\nTypes of your inputs are:\\\\n\"'\n    for arg in args:\n        arg = arg.strip()\n        if arg.startswith('PyObject* '):\n            (t, n) = arg.split(' ')\n            if n == 'args' or n == '_args':\n                error_code += f' << PyTupleArgPrinter{{{n}, \"args\"}} '\n            elif n == 'kw':\n                error_code += f' << PyKwArgPrinter{{{n}}} '\n            else:\n                error_code += f' << PyArgPrinter{{{n}, \"{n}\"}} '\n        elif arg.startswith('PyObject** '):\n            (t, n) = arg.split(' ')\n            error_code += f' << PyFastCallArgPrinter{{{n}, n, kw}} '\n            break\n        else:\n            LOG.vvv('Unhandled arg', arg)\n    LOG.vvv('gen err from func_head', func_head, ' -> ', error_code)\n    return error_code"
        ]
    },
    {
        "func_name": "find_bc",
        "original": "def find_bc(i):\n    while src[i] not in '({;':\n        i += 1\n    j = i + 1\n    if src[i] == ';':\n        return (i, j)\n    presum = 1\n    while True:\n        if src[j] in '({[':\n            presum += 1\n        elif src[j] in ')}]':\n            presum -= 1\n            if presum == 0:\n                s = src[i] + src[j]\n                assert s in ('()', '{}', '()'), 'braces not match ' + s\n                return (i, j)\n        j += 1",
        "mutated": [
            "def find_bc(i):\n    if False:\n        i = 10\n    while src[i] not in '({;':\n        i += 1\n    j = i + 1\n    if src[i] == ';':\n        return (i, j)\n    presum = 1\n    while True:\n        if src[j] in '({[':\n            presum += 1\n        elif src[j] in ')}]':\n            presum -= 1\n            if presum == 0:\n                s = src[i] + src[j]\n                assert s in ('()', '{}', '()'), 'braces not match ' + s\n                return (i, j)\n        j += 1",
            "def find_bc(i):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    while src[i] not in '({;':\n        i += 1\n    j = i + 1\n    if src[i] == ';':\n        return (i, j)\n    presum = 1\n    while True:\n        if src[j] in '({[':\n            presum += 1\n        elif src[j] in ')}]':\n            presum -= 1\n            if presum == 0:\n                s = src[i] + src[j]\n                assert s in ('()', '{}', '()'), 'braces not match ' + s\n                return (i, j)\n        j += 1",
            "def find_bc(i):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    while src[i] not in '({;':\n        i += 1\n    j = i + 1\n    if src[i] == ';':\n        return (i, j)\n    presum = 1\n    while True:\n        if src[j] in '({[':\n            presum += 1\n        elif src[j] in ')}]':\n            presum -= 1\n            if presum == 0:\n                s = src[i] + src[j]\n                assert s in ('()', '{}', '()'), 'braces not match ' + s\n                return (i, j)\n        j += 1",
            "def find_bc(i):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    while src[i] not in '({;':\n        i += 1\n    j = i + 1\n    if src[i] == ';':\n        return (i, j)\n    presum = 1\n    while True:\n        if src[j] in '({[':\n            presum += 1\n        elif src[j] in ')}]':\n            presum -= 1\n            if presum == 0:\n                s = src[i] + src[j]\n                assert s in ('()', '{}', '()'), 'braces not match ' + s\n                return (i, j)\n        j += 1",
            "def find_bc(i):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    while src[i] not in '({;':\n        i += 1\n    j = i + 1\n    if src[i] == ';':\n        return (i, j)\n    presum = 1\n    while True:\n        if src[j] in '({[':\n            presum += 1\n        elif src[j] in ')}]':\n            presum -= 1\n            if presum == 0:\n                s = src[i] + src[j]\n                assert s in ('()', '{}', '()'), 'braces not match ' + s\n                return (i, j)\n        j += 1"
        ]
    },
    {
        "func_name": "compile_src",
        "original": "def compile_src(src, h, basename):\n    res = list(reg.finditer(src, re.S))\n    if len(res) == 0:\n        return\n    class_ranges = None\n    class_name = None\n    class_info = None\n    submodule_name = None\n    submodule_ranges = None\n    submodule_info = None\n    defs = []\n    LOG.vv(('find in', h))\n    for x in res:\n        LOG.vvv((x, x.groups()))\n        g = x.groups()\n        doc = g[1]\n        pyjt = g[3]\n        attrs = g[5]\n        esplit = lambda x: [] if x == None else [a.strip() for a in x.split(',') if len(a.strip())]\n        attrs = parse_attrs(attrs)\n        pynames = esplit(pyjt)\n        end = x.end()\n\n        def find_bc(i):\n            while src[i] not in '({;':\n                i += 1\n            j = i + 1\n            if src[i] == ';':\n                return (i, j)\n            presum = 1\n            while True:\n                if src[j] in '({[':\n                    presum += 1\n                elif src[j] in ')}]':\n                    presum -= 1\n                    if presum == 0:\n                        s = src[i] + src[j]\n                        assert s in ('()', '{}', '()'), 'braces not match ' + s\n                        return (i, j)\n                j += 1\n        (a, b) = find_bc(end)\n        is_property = 0\n        if src[a] == ';':\n            is_property = 1\n        if src[a] == '{':\n            assert len(pynames) == 1\n            if 'submodule' in attrs:\n                assert submodule_ranges == None\n                submodule_ranges = (a, b)\n                submodule_name = src[end:a - 1].strip().split()[-1]\n                submodule_info = {'pynames': pynames, 'attrs': attrs}\n                continue\n            assert class_ranges == None\n            class_ranges = (a, b)\n            class_name = src[end:a - 1].strip().split()[-1]\n            class_info = {'pynames': pynames, 'attrs': attrs}\n            continue\n        is_scope_def = False\n        is_static = False\n        scope_name = ''\n        if class_ranges != None:\n            if class_ranges[0] < a and a < class_ranges[1]:\n                is_scope_def = True\n                scope_name = class_name\n        if submodule_ranges != None:\n            if submodule_ranges[0] < a and a < submodule_ranges[1]:\n                is_scope_def = True\n                scope_name = submodule_name\n                is_static = True\n        dec = src[end:b + 1].strip()\n        arr = src[end:a].strip().split()\n        func_name = arr[-1]\n        is_constructor = False\n        if is_scope_def and func_name == class_name:\n            is_constructor = True\n        args = []\n        for arg in split_args(src[a + 1:b]):\n            if arg == '':\n                continue\n            default = ''\n            if '=' in arg:\n                (arg, default) = arg.split('=')\n                default = default\n            arg = arg.strip()\n            name = arg.split(' ')[-1]\n            tp = arg[:-len(name)]\n            tp = tp.strip()\n            prev_tp = tp\n            if tp.startswith('const') and tp.endswith('&'):\n                tp = tp[5:-1].strip()\n            if tp.endswith('&&'):\n                tp = tp[:-2].strip()\n            if tp.endswith('&'):\n                tp = tp[:-1].strip()\n            args.append((tp, name.strip(), default.strip(), prev_tp))\n        return_t = ''\n        for a in arr[:-1]:\n            if a in ['', 'inline', 'constexpr']:\n                continue\n            if a == 'static':\n                is_static = True\n                continue\n            if return_t != '':\n                return_t += ' '\n            return_t += a\n        if is_scope_def and class_info and ('submodule' in class_info['attrs']):\n            is_static = True\n        for (pid, pyname) in enumerate(pynames):\n            for rname in ['__lt__', '__le__', '__gt__', '__ge__', '__eq__', '__ne__']:\n                if pyname.endswith(rname):\n                    attrs[rname] = 1\n                    pynames[pid] = pyname.replace(rname, '__richcmp__')\n        def_info = {'is_scope_def': is_scope_def, 'is_constructor': is_constructor, 'is_static': is_static, 'is_property': is_property, 'func_name': func_name, 'args': args, 'return_t': return_t, 'dec': dec, 'pynames': pynames, 'attrs': attrs, 'doc': doc, 'scope_name': scope_name}\n        if is_property:\n            assert is_scope_def and (not is_static)\n            def_info['is_property'] = 1\n            def_info['pynames'] = ['__get__' + n for n in pynames]\n            assert return_t != 'void'\n            defs.append(dict(def_info))\n            def_info['pynames'] = ['__set__' + n for n in pynames]\n            assert len(args) == 0\n            def_info['args'] = [(def_info['return_t'], func_name, '', '')]\n            def_info['return_t'] = 'void'\n            defs.append(dict(def_info))\n            continue\n        else:\n            defs.append(def_info)\n        LOG.vvv(lambda : json.dumps(def_info, indent=4))\n    if len(defs) == 0:\n        return\n    include_name = h\n    code = []\n    class_defs_code = []\n    class_getsets_code = []\n    class_gets = OrderedDict()\n    class_sets = OrderedDict()\n    class_slots_code = []\n    submodule_defs_code = []\n    def_targets = OrderedDict()\n    has_attr_dict = class_name in ['VarHolder']\n    for df in defs:\n        for name in df['pynames']:\n            if df['is_scope_def'] and '.' not in name:\n                if df['scope_name'] == class_name:\n                    name = class_info['pynames'][0] + '.' + name\n                else:\n                    name = submodule_info['pynames'][0] + '.' + name\n            if name not in def_targets:\n                def_targets[name] = []\n            def_targets[name].append(df)\n    for name in def_targets:\n        dfs = def_targets[name]\n        target_scope_name = None\n        LOG.vv(name)\n        if '.' in name:\n            (target_scope_name, name) = name.split('.')\n        arr_func_quick_check_runable = []\n        arr_func_args_convert = []\n        arr_fill_with_default = []\n        arr_func_call = []\n        arr_has_return = []\n        self_as_arg0 = False\n        for df in dfs:\n            self_as_arg0 = class_info and target_scope_name == class_info['pynames'][0] and (df['scope_name'] == submodule_name) and (not name.startswith('__'))\n            res = get_def_code(df, df['scope_name'], name, bool(self_as_arg0))\n            arr_func_quick_check_runable.append(res[0])\n            arr_func_args_convert.append(res[1])\n            arr_fill_with_default.append(res[2])\n            arr_func_call.append(res[3])\n            arr_has_return.append(res[4])\n        slot_name = None\n        func_cast = ''\n        func_fill = ''\n        before_return = ''\n        if name == '__init__':\n            slot_name = 'tp_init'\n            func_head = '(PyObject* self, PyObject* _args, PyObject* kw) -> int'\n            func_fill = '\\n                int64 n = Py_SIZE(_args);\\n                auto args = (PyObject**)&PyTuple_GET_ITEM(_args, 0);\\n                (void)n, (void)args;\\n                // TODO: support kw\\n                CHECK(kw==0);\\n            '\n            if has_attr_dict:\n                func_fill += f'((PyObject**)(((char*)self) + sizeof(PyObject) + sizeof({class_name})))[0] = PyDict_New(); '\n        elif name == '__repr__':\n            slot_name = 'tp_repr'\n            func_head = '(PyObject* self) -> PyObject*'\n            func_fill = 'int64 n = 0; (void)n;'\n        elif name.startswith('__get__'):\n            slot_name = 'tp_gets'\n            name = name[len('__get__'):]\n            func_head = '(PyObject* self, void*) -> PyObject*'\n            func_fill = 'int64 n = 0; (void)n;'\n        elif name.startswith('__set__'):\n            slot_name = 'tp_sets'\n            name = name[len('__set__'):]\n            func_head = '(PyObject* self, PyObject* arg, void*) -> int'\n            func_fill = '\\n                int64 n=1;\\n                PyObject** args = &arg;\\n                (void)n, (void)args;\\n            '\n        elif name == '__call__':\n            slot_name = 'tp_call'\n            func_head = '(PyObject* self, PyObject* _args, PyObject* kw) -> PyObject*'\n            func_fill = '\\n                int64 n = Py_SIZE(_args);\\n                auto args = (PyObject**)&PyTuple_GET_ITEM(_args, 0);\\n                (void)n, (void)args;\\n                // TODO: support kw\\n                CHECK(kw==0);\\n            '\n        elif name == '__dealloc__':\n            slot_name = 'tp_dealloc'\n            func_head = '(PyObject* self) -> void'\n            func_fill = 'int64 n = 0'\n            before_return = 'Py_TYPE(self)->tp_free((PyObject *) self);'\n            if has_attr_dict:\n                before_return = f'Py_XDECREF(((PyObject**)(((char*)self) + sizeof(PyObject) + sizeof({class_name}))));' + before_return\n        elif name in binary_number_slots:\n            slot_name = 'tp_as_number->' + binary_number_slots[name]\n            func_head = '(PyObject* self, PyObject* b) -> PyObject*'\n            if name.endswith('pow__'):\n                func_head = '(PyObject* self, PyObject* b, PyObject*) -> PyObject*'\n            func_fill = '\\n                int64 n = 2;\\n                PyObject* args[] = {self, b};\\n                (void)n, (void)args;\\n            '\n        elif name in unary_number_slots:\n            slot_name = 'tp_as_number->' + unary_number_slots[name]\n            func_head = '(PyObject* self) -> PyObject*'\n            func_fill = '\\n                int64 n = 1;\\n                PyObject* args[] = {self};\\n                (void)n, (void)args;\\n            '\n        elif name == '__str__':\n            slot_name = 'tp_str'\n            func_head = '(PyObject* self) -> PyObject*'\n            func_fill = '\\n                int64 n = 0;\\n                PyObject* args[] = {self};\\n                (void)n, (void)args;\\n            '\n        elif name == '__richcmp__':\n            slot_name = 'tp_richcompare'\n            func_head = '(PyObject* self, PyObject* b, int op) -> PyObject*'\n            func_fill = '\\n                int64 n = 2;\\n                PyObject* args[] = {self, b};\\n                (void)n, (void)args;\\n            '\n        elif name == '__len__':\n            slot_name = 'tp_as_sequence->sq_length'\n            func_head = '(PyObject* self) -> Py_ssize_t'\n            func_fill = '\\n                int64 n = 0;  \\n                (void)n;\\n            '\n        elif name == '__map_len__':\n            slot_name = 'tp_as_mapping->mp_length'\n            func_head = '(PyObject* self) -> Py_ssize_t'\n            func_fill = '\\n                int64 n = 0;  \\n                (void)n;\\n            '\n        elif name == '__getitem__':\n            slot_name = 'tp_as_sequence->sq_item'\n            func_head = '(PyObject* self, Py_ssize_t arg0) -> PyObject*'\n            func_fill = f\"\"\"\\n                int64 n = 1;\\n                (void)n;\\n                if (arg0 >= GET_RAW_PTR({dfs[0]['scope_name']},self)->size()) {{\\n                    PyErr_SetString(PyExc_IndexError, \"\");\\n                    return (PyObject*)nullptr;\\n                }}\\n            \"\"\"\n        elif name == '__map_getitem__':\n            slot_name = 'tp_as_mapping->mp_subscript'\n            func_head = '(PyObject* self, PyObject* arg0) -> PyObject*'\n            func_fill = f'\\n                int64 n = 1;\\n                PyObject* args[] = {{arg0}};\\n                (void)n;\\n            '\n        elif name.startswith('__'):\n            LOG.f(f'Not support slot {name}')\n            continue\n        else:\n            func_head = '(PyObject* self, PyObject** args, int64 n, PyObject* kw) -> PyObject*'\n            func_cast = f'(PyCFunction)(PyObject* (*)(PyObject*,PyObject**,int64,PyObject*))'\n            arr_has_return = [True for _ in arr_has_return]\n        arr_func_return = []\n        doc_all = ''\n        decs = 'The function declarations are:\\n'\n        for (did, has_return) in enumerate(arr_has_return):\n            df = dfs[did]\n            func_call = arr_func_call[did]\n            if df['doc'] and (not (did > 0 and df['doc'] == dfs[did - 1]['doc'])):\n                doc_all += 'Document:\\n'\n                doc_all += df['doc'] + '\\n'\n            doc_all += 'Declaration:\\n'\n            doc_all += df['dec'] + '\\n\\n'\n            decs += ' ' + df['dec'] + '\\n'\n            if has_return:\n                assert '-> int' not in func_head\n                if '-> PyObject*' in func_head:\n                    if 'return_self' in df['attrs']:\n                        arr_func_return.append(f'return (({func_call}), Py_INCREF(self), self)')\n                    else:\n                        arr_func_return.append(f\"return {get_pytype_map(df['return_t'], 1)}(({func_call}))\")\n                    func_return_failed = 'return nullptr'\n                else:\n                    arr_func_return.append(f'return ({func_call});')\n                    func_return_failed = 'return -1'\n            elif '-> int' in func_head:\n                arr_func_return.append(f'return ({func_call},0)')\n                func_return_failed = 'return -1'\n            else:\n                assert '-> void' in func_head, func_head\n                arr_func_return.append(f'{func_call};{before_return}return')\n                func_return_failed = 'return'\n        error_log_code = generate_error_code_from_func_header(func_head, target_scope_name, name, dfs, basename, h, class_info)\n        func = f'''\\n        {func_cast}[]{func_head} {{\\n            try {{\\n                {func_fill};\\n                uint64 arg_filled=0;\\n                (void)arg_filled;\\n                {''.join([f\"\"\"\n                if ({arr_func_quick_check_runable[did]}) {{\n                    {arr_func_args_convert[did]};\n                    {arr_fill_with_default[did]};\n                    {arr_func_return[did]};\n                }}\n                \"\"\" for did in range(len(arr_func_return))])}\\n                LOGf << \"Not a valid call.\";\\n            }} catch (const std::exception& e) {{\\n                if (!PyErr_Occurred()) {{\\n                    std::stringstream ss;\\n                    if (check_async_executor_error(e, ss)) {{\\n                        PyErr_Format(PyExc_RuntimeError, \\n                            \"%s\",\\n                            ss.str().c_str()\\n                        );\\n                    }} else {{\\n                        ss {error_log_code};\\n                        PyErr_Format(PyExc_RuntimeError, \\n                            \"%s\\\\n%s\\\\nFailed reason:%s\",\\n                            ss.str().c_str(),\\n                            R\"\"({decs})\"\",\\n                            e.what()\\n                        );\\n                    }}\\n                }}\\n            }}\\n            {func_return_failed};\\n        }}\\n        '''\n        if slot_name:\n            if slot_name == 'tp_gets':\n                class_gets[name] = {'func': func, 'doc': doc_all}\n                continue\n            if slot_name == 'tp_sets':\n                class_sets[name] = {'func': func, 'doc': ''}\n                continue\n            class_slots_code.append(f'\\n            tp.{slot_name} = {func};\\n            ')\n            continue\n        need_static = ''\n        if df['is_scope_def'] and df['is_static'] and (df['scope_name'] == class_name) and ('submodule' not in class_info['attrs']):\n            need_static = ' | METH_STATIC'\n        func = f'\\n        {{ R\"\"({name})\"\",\\n        {func},\\n        METH_FASTCALL | METH_KEYWORDS{need_static},\\n        R\"\"({doc_all})\"\"\\n        }}'\n        if df['is_scope_def']:\n            if df['scope_name'] == class_name or (class_info and target_scope_name == class_info['pynames'][0]):\n                class_defs_code.append(func)\n            else:\n                submodule_defs_code.append(func)\n        else:\n            code.append(func)\n    prop_names = list(set(class_gets.keys()).union(class_sets.keys()))\n    prop_names = sorted(prop_names)\n    for prop_name in prop_names:\n        get_func = 'NULL'\n        set_func = 'NULL'\n        doc = ''\n        if prop_name in class_gets:\n            get_func = class_gets[prop_name]['func']\n            if class_gets[prop_name]['doc']:\n                doc += class_gets[prop_name]['doc']\n        if prop_name in class_sets:\n            set_func = class_sets[prop_name]['func']\n            if class_sets[prop_name]['doc']:\n                doc += class_sets[prop_name]['doc']\n        class_getsets_code.append(f'\\n            {{\"{prop_name}\", {get_func}, {set_func}, R\"\"({doc})\"\"}}\\n        ')\n    code.append('{0,0,0,0}')\n    class_defs_code.append('{0,0,0,0}')\n    class_getsets_code.append('{0,0,0,0}')\n    submodule_defs_code.append('{0,0,0,0}')\n    core_name = 'jittor_core'\n    if class_info and 'attrs' in class_info and ('core_name' in class_info['attrs']):\n        core_name = class_info['attrs']['core_name']\n    if submodule_info and 'attrs' in submodule_info and ('core_name' in submodule_info['attrs']):\n        core_name = submodule_info['attrs']['core_name']\n    has_map = class_name in ['VarHolder', 'NanoVector']\n    has_seq = class_name in ['VarHolder', 'NanoVector']\n    src_code = ''\n    if include_name.endswith('var_slices.h'):\n        src_code += '#include \"var_holder.h\"\\n'\n    src_code += f'''\\n    #include \"utils/seh.h\"\\n    #include \"pyjt/py_converter.h\"\\n    #include \"pyjt/py_arg_printer.h\"\\n    #include \"common.h\"\\n    #include \"{include_name}\"\\n\\n    namespace jittor {{\\n\\n    {('' if class_name is None else f'PyHeapTypeObject Pyjt{class_name};' if 'heaptype' in class_info['attrs'] else f'PyTypeObject Pyjt{class_name};')}\\n    \\n    void pyjt_def_{basename}(PyObject* m) {{\\n        static PyMethodDef defs[] = {{\\n            {','.join(code)}\\n        }};\\n        ASSERT(PyModule_AddFunctions(m, defs)==0);\\n        {(f\"\"\"\n        static PyMethodDef class_defs[] = {{\n            {','.join(class_defs_code)}\n        }};\n        static PyGetSetDef class_getsets[] = {{\n            {','.join(class_getsets_code)}\n        }};\n\n        static PyNumberMethods number_methods = {{0}};\n        {(f'auto& htp =Pyjt{class_name}; auto& tp = htp.ht_type;' if 'heaptype' in class_info['attrs'] else f'auto& tp = Pyjt{class_name};')}\n        tp.tp_as_number = &number_methods;\n\n        {(f'static PyMappingMethods class_map_defs = {{0}};' if has_map else '')}\n        {(f'tp.tp_as_mapping = &class_map_defs;' if has_map else '')}\n\n        {(f'static PySequenceMethods class_seq_defs = {{0}};' if has_seq else '')}\n        {(f'tp.tp_as_sequence = &class_seq_defs;' if has_seq else '')}\n        \n        tp.tp_name = \"{core_name}.{class_info['pynames'][0]}\";\n        tp.tp_basicsize = GET_OBJ_SIZE({class_name});\n        {(f'tp.tp_dictoffset = tp.tp_basicsize; tp.tp_basicsize += sizeof(PyObject*); ' if has_attr_dict else '')}\n        tp.tp_new = PyType_GenericNew;\n        tp.tp_flags = Py_TPFLAGS_DEFAULT;\n        {('tp.tp_flags |= Py_TPFLAGS_HEAPTYPE; htp.ht_name = htp.ht_qualname = to_py_object<string>(tp.tp_name);' if 'heaptype' in class_info['attrs'] else '')}\n        tp.tp_methods = &class_defs[0];\n        tp.tp_getset = &class_getsets[0];\n        {''.join(class_slots_code)};\n        ASSERT(0==PyType_Ready(&tp)) << (PyErr_Print(), 0);\n        Py_INCREF(&tp);\n        ASSERT(0==PyModule_AddObject(m, \"{class_info['pynames'][0]}\", (PyObject*)&tp));\n        \"\"\" if class_name is not None else '')}\\n        {(f\"\"\"\n\n        // sub module def\n        static PyMethodDef submodule_defs[] = {{\n            {','.join(submodule_defs_code)}\n        }};\n        auto sub = PyImport_AddModule(\"{core_name}.{submodule_info['pynames'][0]}\");\n        ASSERT(PyModule_AddFunctions(sub, submodule_defs)==0);\n        ASSERT(sub);\n        ASSERT(0==PyModule_AddObject(m, \"{submodule_info['pynames'][0]}\", sub));\n        \"\"\" if submodule_name is not None else '')}\\n\\n    }}\\n\\n    }}\\n    '''\n    return src_code",
        "mutated": [
            "def compile_src(src, h, basename):\n    if False:\n        i = 10\n    res = list(reg.finditer(src, re.S))\n    if len(res) == 0:\n        return\n    class_ranges = None\n    class_name = None\n    class_info = None\n    submodule_name = None\n    submodule_ranges = None\n    submodule_info = None\n    defs = []\n    LOG.vv(('find in', h))\n    for x in res:\n        LOG.vvv((x, x.groups()))\n        g = x.groups()\n        doc = g[1]\n        pyjt = g[3]\n        attrs = g[5]\n        esplit = lambda x: [] if x == None else [a.strip() for a in x.split(',') if len(a.strip())]\n        attrs = parse_attrs(attrs)\n        pynames = esplit(pyjt)\n        end = x.end()\n\n        def find_bc(i):\n            while src[i] not in '({;':\n                i += 1\n            j = i + 1\n            if src[i] == ';':\n                return (i, j)\n            presum = 1\n            while True:\n                if src[j] in '({[':\n                    presum += 1\n                elif src[j] in ')}]':\n                    presum -= 1\n                    if presum == 0:\n                        s = src[i] + src[j]\n                        assert s in ('()', '{}', '()'), 'braces not match ' + s\n                        return (i, j)\n                j += 1\n        (a, b) = find_bc(end)\n        is_property = 0\n        if src[a] == ';':\n            is_property = 1\n        if src[a] == '{':\n            assert len(pynames) == 1\n            if 'submodule' in attrs:\n                assert submodule_ranges == None\n                submodule_ranges = (a, b)\n                submodule_name = src[end:a - 1].strip().split()[-1]\n                submodule_info = {'pynames': pynames, 'attrs': attrs}\n                continue\n            assert class_ranges == None\n            class_ranges = (a, b)\n            class_name = src[end:a - 1].strip().split()[-1]\n            class_info = {'pynames': pynames, 'attrs': attrs}\n            continue\n        is_scope_def = False\n        is_static = False\n        scope_name = ''\n        if class_ranges != None:\n            if class_ranges[0] < a and a < class_ranges[1]:\n                is_scope_def = True\n                scope_name = class_name\n        if submodule_ranges != None:\n            if submodule_ranges[0] < a and a < submodule_ranges[1]:\n                is_scope_def = True\n                scope_name = submodule_name\n                is_static = True\n        dec = src[end:b + 1].strip()\n        arr = src[end:a].strip().split()\n        func_name = arr[-1]\n        is_constructor = False\n        if is_scope_def and func_name == class_name:\n            is_constructor = True\n        args = []\n        for arg in split_args(src[a + 1:b]):\n            if arg == '':\n                continue\n            default = ''\n            if '=' in arg:\n                (arg, default) = arg.split('=')\n                default = default\n            arg = arg.strip()\n            name = arg.split(' ')[-1]\n            tp = arg[:-len(name)]\n            tp = tp.strip()\n            prev_tp = tp\n            if tp.startswith('const') and tp.endswith('&'):\n                tp = tp[5:-1].strip()\n            if tp.endswith('&&'):\n                tp = tp[:-2].strip()\n            if tp.endswith('&'):\n                tp = tp[:-1].strip()\n            args.append((tp, name.strip(), default.strip(), prev_tp))\n        return_t = ''\n        for a in arr[:-1]:\n            if a in ['', 'inline', 'constexpr']:\n                continue\n            if a == 'static':\n                is_static = True\n                continue\n            if return_t != '':\n                return_t += ' '\n            return_t += a\n        if is_scope_def and class_info and ('submodule' in class_info['attrs']):\n            is_static = True\n        for (pid, pyname) in enumerate(pynames):\n            for rname in ['__lt__', '__le__', '__gt__', '__ge__', '__eq__', '__ne__']:\n                if pyname.endswith(rname):\n                    attrs[rname] = 1\n                    pynames[pid] = pyname.replace(rname, '__richcmp__')\n        def_info = {'is_scope_def': is_scope_def, 'is_constructor': is_constructor, 'is_static': is_static, 'is_property': is_property, 'func_name': func_name, 'args': args, 'return_t': return_t, 'dec': dec, 'pynames': pynames, 'attrs': attrs, 'doc': doc, 'scope_name': scope_name}\n        if is_property:\n            assert is_scope_def and (not is_static)\n            def_info['is_property'] = 1\n            def_info['pynames'] = ['__get__' + n for n in pynames]\n            assert return_t != 'void'\n            defs.append(dict(def_info))\n            def_info['pynames'] = ['__set__' + n for n in pynames]\n            assert len(args) == 0\n            def_info['args'] = [(def_info['return_t'], func_name, '', '')]\n            def_info['return_t'] = 'void'\n            defs.append(dict(def_info))\n            continue\n        else:\n            defs.append(def_info)\n        LOG.vvv(lambda : json.dumps(def_info, indent=4))\n    if len(defs) == 0:\n        return\n    include_name = h\n    code = []\n    class_defs_code = []\n    class_getsets_code = []\n    class_gets = OrderedDict()\n    class_sets = OrderedDict()\n    class_slots_code = []\n    submodule_defs_code = []\n    def_targets = OrderedDict()\n    has_attr_dict = class_name in ['VarHolder']\n    for df in defs:\n        for name in df['pynames']:\n            if df['is_scope_def'] and '.' not in name:\n                if df['scope_name'] == class_name:\n                    name = class_info['pynames'][0] + '.' + name\n                else:\n                    name = submodule_info['pynames'][0] + '.' + name\n            if name not in def_targets:\n                def_targets[name] = []\n            def_targets[name].append(df)\n    for name in def_targets:\n        dfs = def_targets[name]\n        target_scope_name = None\n        LOG.vv(name)\n        if '.' in name:\n            (target_scope_name, name) = name.split('.')\n        arr_func_quick_check_runable = []\n        arr_func_args_convert = []\n        arr_fill_with_default = []\n        arr_func_call = []\n        arr_has_return = []\n        self_as_arg0 = False\n        for df in dfs:\n            self_as_arg0 = class_info and target_scope_name == class_info['pynames'][0] and (df['scope_name'] == submodule_name) and (not name.startswith('__'))\n            res = get_def_code(df, df['scope_name'], name, bool(self_as_arg0))\n            arr_func_quick_check_runable.append(res[0])\n            arr_func_args_convert.append(res[1])\n            arr_fill_with_default.append(res[2])\n            arr_func_call.append(res[3])\n            arr_has_return.append(res[4])\n        slot_name = None\n        func_cast = ''\n        func_fill = ''\n        before_return = ''\n        if name == '__init__':\n            slot_name = 'tp_init'\n            func_head = '(PyObject* self, PyObject* _args, PyObject* kw) -> int'\n            func_fill = '\\n                int64 n = Py_SIZE(_args);\\n                auto args = (PyObject**)&PyTuple_GET_ITEM(_args, 0);\\n                (void)n, (void)args;\\n                // TODO: support kw\\n                CHECK(kw==0);\\n            '\n            if has_attr_dict:\n                func_fill += f'((PyObject**)(((char*)self) + sizeof(PyObject) + sizeof({class_name})))[0] = PyDict_New(); '\n        elif name == '__repr__':\n            slot_name = 'tp_repr'\n            func_head = '(PyObject* self) -> PyObject*'\n            func_fill = 'int64 n = 0; (void)n;'\n        elif name.startswith('__get__'):\n            slot_name = 'tp_gets'\n            name = name[len('__get__'):]\n            func_head = '(PyObject* self, void*) -> PyObject*'\n            func_fill = 'int64 n = 0; (void)n;'\n        elif name.startswith('__set__'):\n            slot_name = 'tp_sets'\n            name = name[len('__set__'):]\n            func_head = '(PyObject* self, PyObject* arg, void*) -> int'\n            func_fill = '\\n                int64 n=1;\\n                PyObject** args = &arg;\\n                (void)n, (void)args;\\n            '\n        elif name == '__call__':\n            slot_name = 'tp_call'\n            func_head = '(PyObject* self, PyObject* _args, PyObject* kw) -> PyObject*'\n            func_fill = '\\n                int64 n = Py_SIZE(_args);\\n                auto args = (PyObject**)&PyTuple_GET_ITEM(_args, 0);\\n                (void)n, (void)args;\\n                // TODO: support kw\\n                CHECK(kw==0);\\n            '\n        elif name == '__dealloc__':\n            slot_name = 'tp_dealloc'\n            func_head = '(PyObject* self) -> void'\n            func_fill = 'int64 n = 0'\n            before_return = 'Py_TYPE(self)->tp_free((PyObject *) self);'\n            if has_attr_dict:\n                before_return = f'Py_XDECREF(((PyObject**)(((char*)self) + sizeof(PyObject) + sizeof({class_name}))));' + before_return\n        elif name in binary_number_slots:\n            slot_name = 'tp_as_number->' + binary_number_slots[name]\n            func_head = '(PyObject* self, PyObject* b) -> PyObject*'\n            if name.endswith('pow__'):\n                func_head = '(PyObject* self, PyObject* b, PyObject*) -> PyObject*'\n            func_fill = '\\n                int64 n = 2;\\n                PyObject* args[] = {self, b};\\n                (void)n, (void)args;\\n            '\n        elif name in unary_number_slots:\n            slot_name = 'tp_as_number->' + unary_number_slots[name]\n            func_head = '(PyObject* self) -> PyObject*'\n            func_fill = '\\n                int64 n = 1;\\n                PyObject* args[] = {self};\\n                (void)n, (void)args;\\n            '\n        elif name == '__str__':\n            slot_name = 'tp_str'\n            func_head = '(PyObject* self) -> PyObject*'\n            func_fill = '\\n                int64 n = 0;\\n                PyObject* args[] = {self};\\n                (void)n, (void)args;\\n            '\n        elif name == '__richcmp__':\n            slot_name = 'tp_richcompare'\n            func_head = '(PyObject* self, PyObject* b, int op) -> PyObject*'\n            func_fill = '\\n                int64 n = 2;\\n                PyObject* args[] = {self, b};\\n                (void)n, (void)args;\\n            '\n        elif name == '__len__':\n            slot_name = 'tp_as_sequence->sq_length'\n            func_head = '(PyObject* self) -> Py_ssize_t'\n            func_fill = '\\n                int64 n = 0;  \\n                (void)n;\\n            '\n        elif name == '__map_len__':\n            slot_name = 'tp_as_mapping->mp_length'\n            func_head = '(PyObject* self) -> Py_ssize_t'\n            func_fill = '\\n                int64 n = 0;  \\n                (void)n;\\n            '\n        elif name == '__getitem__':\n            slot_name = 'tp_as_sequence->sq_item'\n            func_head = '(PyObject* self, Py_ssize_t arg0) -> PyObject*'\n            func_fill = f\"\"\"\\n                int64 n = 1;\\n                (void)n;\\n                if (arg0 >= GET_RAW_PTR({dfs[0]['scope_name']},self)->size()) {{\\n                    PyErr_SetString(PyExc_IndexError, \"\");\\n                    return (PyObject*)nullptr;\\n                }}\\n            \"\"\"\n        elif name == '__map_getitem__':\n            slot_name = 'tp_as_mapping->mp_subscript'\n            func_head = '(PyObject* self, PyObject* arg0) -> PyObject*'\n            func_fill = f'\\n                int64 n = 1;\\n                PyObject* args[] = {{arg0}};\\n                (void)n;\\n            '\n        elif name.startswith('__'):\n            LOG.f(f'Not support slot {name}')\n            continue\n        else:\n            func_head = '(PyObject* self, PyObject** args, int64 n, PyObject* kw) -> PyObject*'\n            func_cast = f'(PyCFunction)(PyObject* (*)(PyObject*,PyObject**,int64,PyObject*))'\n            arr_has_return = [True for _ in arr_has_return]\n        arr_func_return = []\n        doc_all = ''\n        decs = 'The function declarations are:\\n'\n        for (did, has_return) in enumerate(arr_has_return):\n            df = dfs[did]\n            func_call = arr_func_call[did]\n            if df['doc'] and (not (did > 0 and df['doc'] == dfs[did - 1]['doc'])):\n                doc_all += 'Document:\\n'\n                doc_all += df['doc'] + '\\n'\n            doc_all += 'Declaration:\\n'\n            doc_all += df['dec'] + '\\n\\n'\n            decs += ' ' + df['dec'] + '\\n'\n            if has_return:\n                assert '-> int' not in func_head\n                if '-> PyObject*' in func_head:\n                    if 'return_self' in df['attrs']:\n                        arr_func_return.append(f'return (({func_call}), Py_INCREF(self), self)')\n                    else:\n                        arr_func_return.append(f\"return {get_pytype_map(df['return_t'], 1)}(({func_call}))\")\n                    func_return_failed = 'return nullptr'\n                else:\n                    arr_func_return.append(f'return ({func_call});')\n                    func_return_failed = 'return -1'\n            elif '-> int' in func_head:\n                arr_func_return.append(f'return ({func_call},0)')\n                func_return_failed = 'return -1'\n            else:\n                assert '-> void' in func_head, func_head\n                arr_func_return.append(f'{func_call};{before_return}return')\n                func_return_failed = 'return'\n        error_log_code = generate_error_code_from_func_header(func_head, target_scope_name, name, dfs, basename, h, class_info)\n        func = f'''\\n        {func_cast}[]{func_head} {{\\n            try {{\\n                {func_fill};\\n                uint64 arg_filled=0;\\n                (void)arg_filled;\\n                {''.join([f\"\"\"\n                if ({arr_func_quick_check_runable[did]}) {{\n                    {arr_func_args_convert[did]};\n                    {arr_fill_with_default[did]};\n                    {arr_func_return[did]};\n                }}\n                \"\"\" for did in range(len(arr_func_return))])}\\n                LOGf << \"Not a valid call.\";\\n            }} catch (const std::exception& e) {{\\n                if (!PyErr_Occurred()) {{\\n                    std::stringstream ss;\\n                    if (check_async_executor_error(e, ss)) {{\\n                        PyErr_Format(PyExc_RuntimeError, \\n                            \"%s\",\\n                            ss.str().c_str()\\n                        );\\n                    }} else {{\\n                        ss {error_log_code};\\n                        PyErr_Format(PyExc_RuntimeError, \\n                            \"%s\\\\n%s\\\\nFailed reason:%s\",\\n                            ss.str().c_str(),\\n                            R\"\"({decs})\"\",\\n                            e.what()\\n                        );\\n                    }}\\n                }}\\n            }}\\n            {func_return_failed};\\n        }}\\n        '''\n        if slot_name:\n            if slot_name == 'tp_gets':\n                class_gets[name] = {'func': func, 'doc': doc_all}\n                continue\n            if slot_name == 'tp_sets':\n                class_sets[name] = {'func': func, 'doc': ''}\n                continue\n            class_slots_code.append(f'\\n            tp.{slot_name} = {func};\\n            ')\n            continue\n        need_static = ''\n        if df['is_scope_def'] and df['is_static'] and (df['scope_name'] == class_name) and ('submodule' not in class_info['attrs']):\n            need_static = ' | METH_STATIC'\n        func = f'\\n        {{ R\"\"({name})\"\",\\n        {func},\\n        METH_FASTCALL | METH_KEYWORDS{need_static},\\n        R\"\"({doc_all})\"\"\\n        }}'\n        if df['is_scope_def']:\n            if df['scope_name'] == class_name or (class_info and target_scope_name == class_info['pynames'][0]):\n                class_defs_code.append(func)\n            else:\n                submodule_defs_code.append(func)\n        else:\n            code.append(func)\n    prop_names = list(set(class_gets.keys()).union(class_sets.keys()))\n    prop_names = sorted(prop_names)\n    for prop_name in prop_names:\n        get_func = 'NULL'\n        set_func = 'NULL'\n        doc = ''\n        if prop_name in class_gets:\n            get_func = class_gets[prop_name]['func']\n            if class_gets[prop_name]['doc']:\n                doc += class_gets[prop_name]['doc']\n        if prop_name in class_sets:\n            set_func = class_sets[prop_name]['func']\n            if class_sets[prop_name]['doc']:\n                doc += class_sets[prop_name]['doc']\n        class_getsets_code.append(f'\\n            {{\"{prop_name}\", {get_func}, {set_func}, R\"\"({doc})\"\"}}\\n        ')\n    code.append('{0,0,0,0}')\n    class_defs_code.append('{0,0,0,0}')\n    class_getsets_code.append('{0,0,0,0}')\n    submodule_defs_code.append('{0,0,0,0}')\n    core_name = 'jittor_core'\n    if class_info and 'attrs' in class_info and ('core_name' in class_info['attrs']):\n        core_name = class_info['attrs']['core_name']\n    if submodule_info and 'attrs' in submodule_info and ('core_name' in submodule_info['attrs']):\n        core_name = submodule_info['attrs']['core_name']\n    has_map = class_name in ['VarHolder', 'NanoVector']\n    has_seq = class_name in ['VarHolder', 'NanoVector']\n    src_code = ''\n    if include_name.endswith('var_slices.h'):\n        src_code += '#include \"var_holder.h\"\\n'\n    src_code += f'''\\n    #include \"utils/seh.h\"\\n    #include \"pyjt/py_converter.h\"\\n    #include \"pyjt/py_arg_printer.h\"\\n    #include \"common.h\"\\n    #include \"{include_name}\"\\n\\n    namespace jittor {{\\n\\n    {('' if class_name is None else f'PyHeapTypeObject Pyjt{class_name};' if 'heaptype' in class_info['attrs'] else f'PyTypeObject Pyjt{class_name};')}\\n    \\n    void pyjt_def_{basename}(PyObject* m) {{\\n        static PyMethodDef defs[] = {{\\n            {','.join(code)}\\n        }};\\n        ASSERT(PyModule_AddFunctions(m, defs)==0);\\n        {(f\"\"\"\n        static PyMethodDef class_defs[] = {{\n            {','.join(class_defs_code)}\n        }};\n        static PyGetSetDef class_getsets[] = {{\n            {','.join(class_getsets_code)}\n        }};\n\n        static PyNumberMethods number_methods = {{0}};\n        {(f'auto& htp =Pyjt{class_name}; auto& tp = htp.ht_type;' if 'heaptype' in class_info['attrs'] else f'auto& tp = Pyjt{class_name};')}\n        tp.tp_as_number = &number_methods;\n\n        {(f'static PyMappingMethods class_map_defs = {{0}};' if has_map else '')}\n        {(f'tp.tp_as_mapping = &class_map_defs;' if has_map else '')}\n\n        {(f'static PySequenceMethods class_seq_defs = {{0}};' if has_seq else '')}\n        {(f'tp.tp_as_sequence = &class_seq_defs;' if has_seq else '')}\n        \n        tp.tp_name = \"{core_name}.{class_info['pynames'][0]}\";\n        tp.tp_basicsize = GET_OBJ_SIZE({class_name});\n        {(f'tp.tp_dictoffset = tp.tp_basicsize; tp.tp_basicsize += sizeof(PyObject*); ' if has_attr_dict else '')}\n        tp.tp_new = PyType_GenericNew;\n        tp.tp_flags = Py_TPFLAGS_DEFAULT;\n        {('tp.tp_flags |= Py_TPFLAGS_HEAPTYPE; htp.ht_name = htp.ht_qualname = to_py_object<string>(tp.tp_name);' if 'heaptype' in class_info['attrs'] else '')}\n        tp.tp_methods = &class_defs[0];\n        tp.tp_getset = &class_getsets[0];\n        {''.join(class_slots_code)};\n        ASSERT(0==PyType_Ready(&tp)) << (PyErr_Print(), 0);\n        Py_INCREF(&tp);\n        ASSERT(0==PyModule_AddObject(m, \"{class_info['pynames'][0]}\", (PyObject*)&tp));\n        \"\"\" if class_name is not None else '')}\\n        {(f\"\"\"\n\n        // sub module def\n        static PyMethodDef submodule_defs[] = {{\n            {','.join(submodule_defs_code)}\n        }};\n        auto sub = PyImport_AddModule(\"{core_name}.{submodule_info['pynames'][0]}\");\n        ASSERT(PyModule_AddFunctions(sub, submodule_defs)==0);\n        ASSERT(sub);\n        ASSERT(0==PyModule_AddObject(m, \"{submodule_info['pynames'][0]}\", sub));\n        \"\"\" if submodule_name is not None else '')}\\n\\n    }}\\n\\n    }}\\n    '''\n    return src_code",
            "def compile_src(src, h, basename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    res = list(reg.finditer(src, re.S))\n    if len(res) == 0:\n        return\n    class_ranges = None\n    class_name = None\n    class_info = None\n    submodule_name = None\n    submodule_ranges = None\n    submodule_info = None\n    defs = []\n    LOG.vv(('find in', h))\n    for x in res:\n        LOG.vvv((x, x.groups()))\n        g = x.groups()\n        doc = g[1]\n        pyjt = g[3]\n        attrs = g[5]\n        esplit = lambda x: [] if x == None else [a.strip() for a in x.split(',') if len(a.strip())]\n        attrs = parse_attrs(attrs)\n        pynames = esplit(pyjt)\n        end = x.end()\n\n        def find_bc(i):\n            while src[i] not in '({;':\n                i += 1\n            j = i + 1\n            if src[i] == ';':\n                return (i, j)\n            presum = 1\n            while True:\n                if src[j] in '({[':\n                    presum += 1\n                elif src[j] in ')}]':\n                    presum -= 1\n                    if presum == 0:\n                        s = src[i] + src[j]\n                        assert s in ('()', '{}', '()'), 'braces not match ' + s\n                        return (i, j)\n                j += 1\n        (a, b) = find_bc(end)\n        is_property = 0\n        if src[a] == ';':\n            is_property = 1\n        if src[a] == '{':\n            assert len(pynames) == 1\n            if 'submodule' in attrs:\n                assert submodule_ranges == None\n                submodule_ranges = (a, b)\n                submodule_name = src[end:a - 1].strip().split()[-1]\n                submodule_info = {'pynames': pynames, 'attrs': attrs}\n                continue\n            assert class_ranges == None\n            class_ranges = (a, b)\n            class_name = src[end:a - 1].strip().split()[-1]\n            class_info = {'pynames': pynames, 'attrs': attrs}\n            continue\n        is_scope_def = False\n        is_static = False\n        scope_name = ''\n        if class_ranges != None:\n            if class_ranges[0] < a and a < class_ranges[1]:\n                is_scope_def = True\n                scope_name = class_name\n        if submodule_ranges != None:\n            if submodule_ranges[0] < a and a < submodule_ranges[1]:\n                is_scope_def = True\n                scope_name = submodule_name\n                is_static = True\n        dec = src[end:b + 1].strip()\n        arr = src[end:a].strip().split()\n        func_name = arr[-1]\n        is_constructor = False\n        if is_scope_def and func_name == class_name:\n            is_constructor = True\n        args = []\n        for arg in split_args(src[a + 1:b]):\n            if arg == '':\n                continue\n            default = ''\n            if '=' in arg:\n                (arg, default) = arg.split('=')\n                default = default\n            arg = arg.strip()\n            name = arg.split(' ')[-1]\n            tp = arg[:-len(name)]\n            tp = tp.strip()\n            prev_tp = tp\n            if tp.startswith('const') and tp.endswith('&'):\n                tp = tp[5:-1].strip()\n            if tp.endswith('&&'):\n                tp = tp[:-2].strip()\n            if tp.endswith('&'):\n                tp = tp[:-1].strip()\n            args.append((tp, name.strip(), default.strip(), prev_tp))\n        return_t = ''\n        for a in arr[:-1]:\n            if a in ['', 'inline', 'constexpr']:\n                continue\n            if a == 'static':\n                is_static = True\n                continue\n            if return_t != '':\n                return_t += ' '\n            return_t += a\n        if is_scope_def and class_info and ('submodule' in class_info['attrs']):\n            is_static = True\n        for (pid, pyname) in enumerate(pynames):\n            for rname in ['__lt__', '__le__', '__gt__', '__ge__', '__eq__', '__ne__']:\n                if pyname.endswith(rname):\n                    attrs[rname] = 1\n                    pynames[pid] = pyname.replace(rname, '__richcmp__')\n        def_info = {'is_scope_def': is_scope_def, 'is_constructor': is_constructor, 'is_static': is_static, 'is_property': is_property, 'func_name': func_name, 'args': args, 'return_t': return_t, 'dec': dec, 'pynames': pynames, 'attrs': attrs, 'doc': doc, 'scope_name': scope_name}\n        if is_property:\n            assert is_scope_def and (not is_static)\n            def_info['is_property'] = 1\n            def_info['pynames'] = ['__get__' + n for n in pynames]\n            assert return_t != 'void'\n            defs.append(dict(def_info))\n            def_info['pynames'] = ['__set__' + n for n in pynames]\n            assert len(args) == 0\n            def_info['args'] = [(def_info['return_t'], func_name, '', '')]\n            def_info['return_t'] = 'void'\n            defs.append(dict(def_info))\n            continue\n        else:\n            defs.append(def_info)\n        LOG.vvv(lambda : json.dumps(def_info, indent=4))\n    if len(defs) == 0:\n        return\n    include_name = h\n    code = []\n    class_defs_code = []\n    class_getsets_code = []\n    class_gets = OrderedDict()\n    class_sets = OrderedDict()\n    class_slots_code = []\n    submodule_defs_code = []\n    def_targets = OrderedDict()\n    has_attr_dict = class_name in ['VarHolder']\n    for df in defs:\n        for name in df['pynames']:\n            if df['is_scope_def'] and '.' not in name:\n                if df['scope_name'] == class_name:\n                    name = class_info['pynames'][0] + '.' + name\n                else:\n                    name = submodule_info['pynames'][0] + '.' + name\n            if name not in def_targets:\n                def_targets[name] = []\n            def_targets[name].append(df)\n    for name in def_targets:\n        dfs = def_targets[name]\n        target_scope_name = None\n        LOG.vv(name)\n        if '.' in name:\n            (target_scope_name, name) = name.split('.')\n        arr_func_quick_check_runable = []\n        arr_func_args_convert = []\n        arr_fill_with_default = []\n        arr_func_call = []\n        arr_has_return = []\n        self_as_arg0 = False\n        for df in dfs:\n            self_as_arg0 = class_info and target_scope_name == class_info['pynames'][0] and (df['scope_name'] == submodule_name) and (not name.startswith('__'))\n            res = get_def_code(df, df['scope_name'], name, bool(self_as_arg0))\n            arr_func_quick_check_runable.append(res[0])\n            arr_func_args_convert.append(res[1])\n            arr_fill_with_default.append(res[2])\n            arr_func_call.append(res[3])\n            arr_has_return.append(res[4])\n        slot_name = None\n        func_cast = ''\n        func_fill = ''\n        before_return = ''\n        if name == '__init__':\n            slot_name = 'tp_init'\n            func_head = '(PyObject* self, PyObject* _args, PyObject* kw) -> int'\n            func_fill = '\\n                int64 n = Py_SIZE(_args);\\n                auto args = (PyObject**)&PyTuple_GET_ITEM(_args, 0);\\n                (void)n, (void)args;\\n                // TODO: support kw\\n                CHECK(kw==0);\\n            '\n            if has_attr_dict:\n                func_fill += f'((PyObject**)(((char*)self) + sizeof(PyObject) + sizeof({class_name})))[0] = PyDict_New(); '\n        elif name == '__repr__':\n            slot_name = 'tp_repr'\n            func_head = '(PyObject* self) -> PyObject*'\n            func_fill = 'int64 n = 0; (void)n;'\n        elif name.startswith('__get__'):\n            slot_name = 'tp_gets'\n            name = name[len('__get__'):]\n            func_head = '(PyObject* self, void*) -> PyObject*'\n            func_fill = 'int64 n = 0; (void)n;'\n        elif name.startswith('__set__'):\n            slot_name = 'tp_sets'\n            name = name[len('__set__'):]\n            func_head = '(PyObject* self, PyObject* arg, void*) -> int'\n            func_fill = '\\n                int64 n=1;\\n                PyObject** args = &arg;\\n                (void)n, (void)args;\\n            '\n        elif name == '__call__':\n            slot_name = 'tp_call'\n            func_head = '(PyObject* self, PyObject* _args, PyObject* kw) -> PyObject*'\n            func_fill = '\\n                int64 n = Py_SIZE(_args);\\n                auto args = (PyObject**)&PyTuple_GET_ITEM(_args, 0);\\n                (void)n, (void)args;\\n                // TODO: support kw\\n                CHECK(kw==0);\\n            '\n        elif name == '__dealloc__':\n            slot_name = 'tp_dealloc'\n            func_head = '(PyObject* self) -> void'\n            func_fill = 'int64 n = 0'\n            before_return = 'Py_TYPE(self)->tp_free((PyObject *) self);'\n            if has_attr_dict:\n                before_return = f'Py_XDECREF(((PyObject**)(((char*)self) + sizeof(PyObject) + sizeof({class_name}))));' + before_return\n        elif name in binary_number_slots:\n            slot_name = 'tp_as_number->' + binary_number_slots[name]\n            func_head = '(PyObject* self, PyObject* b) -> PyObject*'\n            if name.endswith('pow__'):\n                func_head = '(PyObject* self, PyObject* b, PyObject*) -> PyObject*'\n            func_fill = '\\n                int64 n = 2;\\n                PyObject* args[] = {self, b};\\n                (void)n, (void)args;\\n            '\n        elif name in unary_number_slots:\n            slot_name = 'tp_as_number->' + unary_number_slots[name]\n            func_head = '(PyObject* self) -> PyObject*'\n            func_fill = '\\n                int64 n = 1;\\n                PyObject* args[] = {self};\\n                (void)n, (void)args;\\n            '\n        elif name == '__str__':\n            slot_name = 'tp_str'\n            func_head = '(PyObject* self) -> PyObject*'\n            func_fill = '\\n                int64 n = 0;\\n                PyObject* args[] = {self};\\n                (void)n, (void)args;\\n            '\n        elif name == '__richcmp__':\n            slot_name = 'tp_richcompare'\n            func_head = '(PyObject* self, PyObject* b, int op) -> PyObject*'\n            func_fill = '\\n                int64 n = 2;\\n                PyObject* args[] = {self, b};\\n                (void)n, (void)args;\\n            '\n        elif name == '__len__':\n            slot_name = 'tp_as_sequence->sq_length'\n            func_head = '(PyObject* self) -> Py_ssize_t'\n            func_fill = '\\n                int64 n = 0;  \\n                (void)n;\\n            '\n        elif name == '__map_len__':\n            slot_name = 'tp_as_mapping->mp_length'\n            func_head = '(PyObject* self) -> Py_ssize_t'\n            func_fill = '\\n                int64 n = 0;  \\n                (void)n;\\n            '\n        elif name == '__getitem__':\n            slot_name = 'tp_as_sequence->sq_item'\n            func_head = '(PyObject* self, Py_ssize_t arg0) -> PyObject*'\n            func_fill = f\"\"\"\\n                int64 n = 1;\\n                (void)n;\\n                if (arg0 >= GET_RAW_PTR({dfs[0]['scope_name']},self)->size()) {{\\n                    PyErr_SetString(PyExc_IndexError, \"\");\\n                    return (PyObject*)nullptr;\\n                }}\\n            \"\"\"\n        elif name == '__map_getitem__':\n            slot_name = 'tp_as_mapping->mp_subscript'\n            func_head = '(PyObject* self, PyObject* arg0) -> PyObject*'\n            func_fill = f'\\n                int64 n = 1;\\n                PyObject* args[] = {{arg0}};\\n                (void)n;\\n            '\n        elif name.startswith('__'):\n            LOG.f(f'Not support slot {name}')\n            continue\n        else:\n            func_head = '(PyObject* self, PyObject** args, int64 n, PyObject* kw) -> PyObject*'\n            func_cast = f'(PyCFunction)(PyObject* (*)(PyObject*,PyObject**,int64,PyObject*))'\n            arr_has_return = [True for _ in arr_has_return]\n        arr_func_return = []\n        doc_all = ''\n        decs = 'The function declarations are:\\n'\n        for (did, has_return) in enumerate(arr_has_return):\n            df = dfs[did]\n            func_call = arr_func_call[did]\n            if df['doc'] and (not (did > 0 and df['doc'] == dfs[did - 1]['doc'])):\n                doc_all += 'Document:\\n'\n                doc_all += df['doc'] + '\\n'\n            doc_all += 'Declaration:\\n'\n            doc_all += df['dec'] + '\\n\\n'\n            decs += ' ' + df['dec'] + '\\n'\n            if has_return:\n                assert '-> int' not in func_head\n                if '-> PyObject*' in func_head:\n                    if 'return_self' in df['attrs']:\n                        arr_func_return.append(f'return (({func_call}), Py_INCREF(self), self)')\n                    else:\n                        arr_func_return.append(f\"return {get_pytype_map(df['return_t'], 1)}(({func_call}))\")\n                    func_return_failed = 'return nullptr'\n                else:\n                    arr_func_return.append(f'return ({func_call});')\n                    func_return_failed = 'return -1'\n            elif '-> int' in func_head:\n                arr_func_return.append(f'return ({func_call},0)')\n                func_return_failed = 'return -1'\n            else:\n                assert '-> void' in func_head, func_head\n                arr_func_return.append(f'{func_call};{before_return}return')\n                func_return_failed = 'return'\n        error_log_code = generate_error_code_from_func_header(func_head, target_scope_name, name, dfs, basename, h, class_info)\n        func = f'''\\n        {func_cast}[]{func_head} {{\\n            try {{\\n                {func_fill};\\n                uint64 arg_filled=0;\\n                (void)arg_filled;\\n                {''.join([f\"\"\"\n                if ({arr_func_quick_check_runable[did]}) {{\n                    {arr_func_args_convert[did]};\n                    {arr_fill_with_default[did]};\n                    {arr_func_return[did]};\n                }}\n                \"\"\" for did in range(len(arr_func_return))])}\\n                LOGf << \"Not a valid call.\";\\n            }} catch (const std::exception& e) {{\\n                if (!PyErr_Occurred()) {{\\n                    std::stringstream ss;\\n                    if (check_async_executor_error(e, ss)) {{\\n                        PyErr_Format(PyExc_RuntimeError, \\n                            \"%s\",\\n                            ss.str().c_str()\\n                        );\\n                    }} else {{\\n                        ss {error_log_code};\\n                        PyErr_Format(PyExc_RuntimeError, \\n                            \"%s\\\\n%s\\\\nFailed reason:%s\",\\n                            ss.str().c_str(),\\n                            R\"\"({decs})\"\",\\n                            e.what()\\n                        );\\n                    }}\\n                }}\\n            }}\\n            {func_return_failed};\\n        }}\\n        '''\n        if slot_name:\n            if slot_name == 'tp_gets':\n                class_gets[name] = {'func': func, 'doc': doc_all}\n                continue\n            if slot_name == 'tp_sets':\n                class_sets[name] = {'func': func, 'doc': ''}\n                continue\n            class_slots_code.append(f'\\n            tp.{slot_name} = {func};\\n            ')\n            continue\n        need_static = ''\n        if df['is_scope_def'] and df['is_static'] and (df['scope_name'] == class_name) and ('submodule' not in class_info['attrs']):\n            need_static = ' | METH_STATIC'\n        func = f'\\n        {{ R\"\"({name})\"\",\\n        {func},\\n        METH_FASTCALL | METH_KEYWORDS{need_static},\\n        R\"\"({doc_all})\"\"\\n        }}'\n        if df['is_scope_def']:\n            if df['scope_name'] == class_name or (class_info and target_scope_name == class_info['pynames'][0]):\n                class_defs_code.append(func)\n            else:\n                submodule_defs_code.append(func)\n        else:\n            code.append(func)\n    prop_names = list(set(class_gets.keys()).union(class_sets.keys()))\n    prop_names = sorted(prop_names)\n    for prop_name in prop_names:\n        get_func = 'NULL'\n        set_func = 'NULL'\n        doc = ''\n        if prop_name in class_gets:\n            get_func = class_gets[prop_name]['func']\n            if class_gets[prop_name]['doc']:\n                doc += class_gets[prop_name]['doc']\n        if prop_name in class_sets:\n            set_func = class_sets[prop_name]['func']\n            if class_sets[prop_name]['doc']:\n                doc += class_sets[prop_name]['doc']\n        class_getsets_code.append(f'\\n            {{\"{prop_name}\", {get_func}, {set_func}, R\"\"({doc})\"\"}}\\n        ')\n    code.append('{0,0,0,0}')\n    class_defs_code.append('{0,0,0,0}')\n    class_getsets_code.append('{0,0,0,0}')\n    submodule_defs_code.append('{0,0,0,0}')\n    core_name = 'jittor_core'\n    if class_info and 'attrs' in class_info and ('core_name' in class_info['attrs']):\n        core_name = class_info['attrs']['core_name']\n    if submodule_info and 'attrs' in submodule_info and ('core_name' in submodule_info['attrs']):\n        core_name = submodule_info['attrs']['core_name']\n    has_map = class_name in ['VarHolder', 'NanoVector']\n    has_seq = class_name in ['VarHolder', 'NanoVector']\n    src_code = ''\n    if include_name.endswith('var_slices.h'):\n        src_code += '#include \"var_holder.h\"\\n'\n    src_code += f'''\\n    #include \"utils/seh.h\"\\n    #include \"pyjt/py_converter.h\"\\n    #include \"pyjt/py_arg_printer.h\"\\n    #include \"common.h\"\\n    #include \"{include_name}\"\\n\\n    namespace jittor {{\\n\\n    {('' if class_name is None else f'PyHeapTypeObject Pyjt{class_name};' if 'heaptype' in class_info['attrs'] else f'PyTypeObject Pyjt{class_name};')}\\n    \\n    void pyjt_def_{basename}(PyObject* m) {{\\n        static PyMethodDef defs[] = {{\\n            {','.join(code)}\\n        }};\\n        ASSERT(PyModule_AddFunctions(m, defs)==0);\\n        {(f\"\"\"\n        static PyMethodDef class_defs[] = {{\n            {','.join(class_defs_code)}\n        }};\n        static PyGetSetDef class_getsets[] = {{\n            {','.join(class_getsets_code)}\n        }};\n\n        static PyNumberMethods number_methods = {{0}};\n        {(f'auto& htp =Pyjt{class_name}; auto& tp = htp.ht_type;' if 'heaptype' in class_info['attrs'] else f'auto& tp = Pyjt{class_name};')}\n        tp.tp_as_number = &number_methods;\n\n        {(f'static PyMappingMethods class_map_defs = {{0}};' if has_map else '')}\n        {(f'tp.tp_as_mapping = &class_map_defs;' if has_map else '')}\n\n        {(f'static PySequenceMethods class_seq_defs = {{0}};' if has_seq else '')}\n        {(f'tp.tp_as_sequence = &class_seq_defs;' if has_seq else '')}\n        \n        tp.tp_name = \"{core_name}.{class_info['pynames'][0]}\";\n        tp.tp_basicsize = GET_OBJ_SIZE({class_name});\n        {(f'tp.tp_dictoffset = tp.tp_basicsize; tp.tp_basicsize += sizeof(PyObject*); ' if has_attr_dict else '')}\n        tp.tp_new = PyType_GenericNew;\n        tp.tp_flags = Py_TPFLAGS_DEFAULT;\n        {('tp.tp_flags |= Py_TPFLAGS_HEAPTYPE; htp.ht_name = htp.ht_qualname = to_py_object<string>(tp.tp_name);' if 'heaptype' in class_info['attrs'] else '')}\n        tp.tp_methods = &class_defs[0];\n        tp.tp_getset = &class_getsets[0];\n        {''.join(class_slots_code)};\n        ASSERT(0==PyType_Ready(&tp)) << (PyErr_Print(), 0);\n        Py_INCREF(&tp);\n        ASSERT(0==PyModule_AddObject(m, \"{class_info['pynames'][0]}\", (PyObject*)&tp));\n        \"\"\" if class_name is not None else '')}\\n        {(f\"\"\"\n\n        // sub module def\n        static PyMethodDef submodule_defs[] = {{\n            {','.join(submodule_defs_code)}\n        }};\n        auto sub = PyImport_AddModule(\"{core_name}.{submodule_info['pynames'][0]}\");\n        ASSERT(PyModule_AddFunctions(sub, submodule_defs)==0);\n        ASSERT(sub);\n        ASSERT(0==PyModule_AddObject(m, \"{submodule_info['pynames'][0]}\", sub));\n        \"\"\" if submodule_name is not None else '')}\\n\\n    }}\\n\\n    }}\\n    '''\n    return src_code",
            "def compile_src(src, h, basename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    res = list(reg.finditer(src, re.S))\n    if len(res) == 0:\n        return\n    class_ranges = None\n    class_name = None\n    class_info = None\n    submodule_name = None\n    submodule_ranges = None\n    submodule_info = None\n    defs = []\n    LOG.vv(('find in', h))\n    for x in res:\n        LOG.vvv((x, x.groups()))\n        g = x.groups()\n        doc = g[1]\n        pyjt = g[3]\n        attrs = g[5]\n        esplit = lambda x: [] if x == None else [a.strip() for a in x.split(',') if len(a.strip())]\n        attrs = parse_attrs(attrs)\n        pynames = esplit(pyjt)\n        end = x.end()\n\n        def find_bc(i):\n            while src[i] not in '({;':\n                i += 1\n            j = i + 1\n            if src[i] == ';':\n                return (i, j)\n            presum = 1\n            while True:\n                if src[j] in '({[':\n                    presum += 1\n                elif src[j] in ')}]':\n                    presum -= 1\n                    if presum == 0:\n                        s = src[i] + src[j]\n                        assert s in ('()', '{}', '()'), 'braces not match ' + s\n                        return (i, j)\n                j += 1\n        (a, b) = find_bc(end)\n        is_property = 0\n        if src[a] == ';':\n            is_property = 1\n        if src[a] == '{':\n            assert len(pynames) == 1\n            if 'submodule' in attrs:\n                assert submodule_ranges == None\n                submodule_ranges = (a, b)\n                submodule_name = src[end:a - 1].strip().split()[-1]\n                submodule_info = {'pynames': pynames, 'attrs': attrs}\n                continue\n            assert class_ranges == None\n            class_ranges = (a, b)\n            class_name = src[end:a - 1].strip().split()[-1]\n            class_info = {'pynames': pynames, 'attrs': attrs}\n            continue\n        is_scope_def = False\n        is_static = False\n        scope_name = ''\n        if class_ranges != None:\n            if class_ranges[0] < a and a < class_ranges[1]:\n                is_scope_def = True\n                scope_name = class_name\n        if submodule_ranges != None:\n            if submodule_ranges[0] < a and a < submodule_ranges[1]:\n                is_scope_def = True\n                scope_name = submodule_name\n                is_static = True\n        dec = src[end:b + 1].strip()\n        arr = src[end:a].strip().split()\n        func_name = arr[-1]\n        is_constructor = False\n        if is_scope_def and func_name == class_name:\n            is_constructor = True\n        args = []\n        for arg in split_args(src[a + 1:b]):\n            if arg == '':\n                continue\n            default = ''\n            if '=' in arg:\n                (arg, default) = arg.split('=')\n                default = default\n            arg = arg.strip()\n            name = arg.split(' ')[-1]\n            tp = arg[:-len(name)]\n            tp = tp.strip()\n            prev_tp = tp\n            if tp.startswith('const') and tp.endswith('&'):\n                tp = tp[5:-1].strip()\n            if tp.endswith('&&'):\n                tp = tp[:-2].strip()\n            if tp.endswith('&'):\n                tp = tp[:-1].strip()\n            args.append((tp, name.strip(), default.strip(), prev_tp))\n        return_t = ''\n        for a in arr[:-1]:\n            if a in ['', 'inline', 'constexpr']:\n                continue\n            if a == 'static':\n                is_static = True\n                continue\n            if return_t != '':\n                return_t += ' '\n            return_t += a\n        if is_scope_def and class_info and ('submodule' in class_info['attrs']):\n            is_static = True\n        for (pid, pyname) in enumerate(pynames):\n            for rname in ['__lt__', '__le__', '__gt__', '__ge__', '__eq__', '__ne__']:\n                if pyname.endswith(rname):\n                    attrs[rname] = 1\n                    pynames[pid] = pyname.replace(rname, '__richcmp__')\n        def_info = {'is_scope_def': is_scope_def, 'is_constructor': is_constructor, 'is_static': is_static, 'is_property': is_property, 'func_name': func_name, 'args': args, 'return_t': return_t, 'dec': dec, 'pynames': pynames, 'attrs': attrs, 'doc': doc, 'scope_name': scope_name}\n        if is_property:\n            assert is_scope_def and (not is_static)\n            def_info['is_property'] = 1\n            def_info['pynames'] = ['__get__' + n for n in pynames]\n            assert return_t != 'void'\n            defs.append(dict(def_info))\n            def_info['pynames'] = ['__set__' + n for n in pynames]\n            assert len(args) == 0\n            def_info['args'] = [(def_info['return_t'], func_name, '', '')]\n            def_info['return_t'] = 'void'\n            defs.append(dict(def_info))\n            continue\n        else:\n            defs.append(def_info)\n        LOG.vvv(lambda : json.dumps(def_info, indent=4))\n    if len(defs) == 0:\n        return\n    include_name = h\n    code = []\n    class_defs_code = []\n    class_getsets_code = []\n    class_gets = OrderedDict()\n    class_sets = OrderedDict()\n    class_slots_code = []\n    submodule_defs_code = []\n    def_targets = OrderedDict()\n    has_attr_dict = class_name in ['VarHolder']\n    for df in defs:\n        for name in df['pynames']:\n            if df['is_scope_def'] and '.' not in name:\n                if df['scope_name'] == class_name:\n                    name = class_info['pynames'][0] + '.' + name\n                else:\n                    name = submodule_info['pynames'][0] + '.' + name\n            if name not in def_targets:\n                def_targets[name] = []\n            def_targets[name].append(df)\n    for name in def_targets:\n        dfs = def_targets[name]\n        target_scope_name = None\n        LOG.vv(name)\n        if '.' in name:\n            (target_scope_name, name) = name.split('.')\n        arr_func_quick_check_runable = []\n        arr_func_args_convert = []\n        arr_fill_with_default = []\n        arr_func_call = []\n        arr_has_return = []\n        self_as_arg0 = False\n        for df in dfs:\n            self_as_arg0 = class_info and target_scope_name == class_info['pynames'][0] and (df['scope_name'] == submodule_name) and (not name.startswith('__'))\n            res = get_def_code(df, df['scope_name'], name, bool(self_as_arg0))\n            arr_func_quick_check_runable.append(res[0])\n            arr_func_args_convert.append(res[1])\n            arr_fill_with_default.append(res[2])\n            arr_func_call.append(res[3])\n            arr_has_return.append(res[4])\n        slot_name = None\n        func_cast = ''\n        func_fill = ''\n        before_return = ''\n        if name == '__init__':\n            slot_name = 'tp_init'\n            func_head = '(PyObject* self, PyObject* _args, PyObject* kw) -> int'\n            func_fill = '\\n                int64 n = Py_SIZE(_args);\\n                auto args = (PyObject**)&PyTuple_GET_ITEM(_args, 0);\\n                (void)n, (void)args;\\n                // TODO: support kw\\n                CHECK(kw==0);\\n            '\n            if has_attr_dict:\n                func_fill += f'((PyObject**)(((char*)self) + sizeof(PyObject) + sizeof({class_name})))[0] = PyDict_New(); '\n        elif name == '__repr__':\n            slot_name = 'tp_repr'\n            func_head = '(PyObject* self) -> PyObject*'\n            func_fill = 'int64 n = 0; (void)n;'\n        elif name.startswith('__get__'):\n            slot_name = 'tp_gets'\n            name = name[len('__get__'):]\n            func_head = '(PyObject* self, void*) -> PyObject*'\n            func_fill = 'int64 n = 0; (void)n;'\n        elif name.startswith('__set__'):\n            slot_name = 'tp_sets'\n            name = name[len('__set__'):]\n            func_head = '(PyObject* self, PyObject* arg, void*) -> int'\n            func_fill = '\\n                int64 n=1;\\n                PyObject** args = &arg;\\n                (void)n, (void)args;\\n            '\n        elif name == '__call__':\n            slot_name = 'tp_call'\n            func_head = '(PyObject* self, PyObject* _args, PyObject* kw) -> PyObject*'\n            func_fill = '\\n                int64 n = Py_SIZE(_args);\\n                auto args = (PyObject**)&PyTuple_GET_ITEM(_args, 0);\\n                (void)n, (void)args;\\n                // TODO: support kw\\n                CHECK(kw==0);\\n            '\n        elif name == '__dealloc__':\n            slot_name = 'tp_dealloc'\n            func_head = '(PyObject* self) -> void'\n            func_fill = 'int64 n = 0'\n            before_return = 'Py_TYPE(self)->tp_free((PyObject *) self);'\n            if has_attr_dict:\n                before_return = f'Py_XDECREF(((PyObject**)(((char*)self) + sizeof(PyObject) + sizeof({class_name}))));' + before_return\n        elif name in binary_number_slots:\n            slot_name = 'tp_as_number->' + binary_number_slots[name]\n            func_head = '(PyObject* self, PyObject* b) -> PyObject*'\n            if name.endswith('pow__'):\n                func_head = '(PyObject* self, PyObject* b, PyObject*) -> PyObject*'\n            func_fill = '\\n                int64 n = 2;\\n                PyObject* args[] = {self, b};\\n                (void)n, (void)args;\\n            '\n        elif name in unary_number_slots:\n            slot_name = 'tp_as_number->' + unary_number_slots[name]\n            func_head = '(PyObject* self) -> PyObject*'\n            func_fill = '\\n                int64 n = 1;\\n                PyObject* args[] = {self};\\n                (void)n, (void)args;\\n            '\n        elif name == '__str__':\n            slot_name = 'tp_str'\n            func_head = '(PyObject* self) -> PyObject*'\n            func_fill = '\\n                int64 n = 0;\\n                PyObject* args[] = {self};\\n                (void)n, (void)args;\\n            '\n        elif name == '__richcmp__':\n            slot_name = 'tp_richcompare'\n            func_head = '(PyObject* self, PyObject* b, int op) -> PyObject*'\n            func_fill = '\\n                int64 n = 2;\\n                PyObject* args[] = {self, b};\\n                (void)n, (void)args;\\n            '\n        elif name == '__len__':\n            slot_name = 'tp_as_sequence->sq_length'\n            func_head = '(PyObject* self) -> Py_ssize_t'\n            func_fill = '\\n                int64 n = 0;  \\n                (void)n;\\n            '\n        elif name == '__map_len__':\n            slot_name = 'tp_as_mapping->mp_length'\n            func_head = '(PyObject* self) -> Py_ssize_t'\n            func_fill = '\\n                int64 n = 0;  \\n                (void)n;\\n            '\n        elif name == '__getitem__':\n            slot_name = 'tp_as_sequence->sq_item'\n            func_head = '(PyObject* self, Py_ssize_t arg0) -> PyObject*'\n            func_fill = f\"\"\"\\n                int64 n = 1;\\n                (void)n;\\n                if (arg0 >= GET_RAW_PTR({dfs[0]['scope_name']},self)->size()) {{\\n                    PyErr_SetString(PyExc_IndexError, \"\");\\n                    return (PyObject*)nullptr;\\n                }}\\n            \"\"\"\n        elif name == '__map_getitem__':\n            slot_name = 'tp_as_mapping->mp_subscript'\n            func_head = '(PyObject* self, PyObject* arg0) -> PyObject*'\n            func_fill = f'\\n                int64 n = 1;\\n                PyObject* args[] = {{arg0}};\\n                (void)n;\\n            '\n        elif name.startswith('__'):\n            LOG.f(f'Not support slot {name}')\n            continue\n        else:\n            func_head = '(PyObject* self, PyObject** args, int64 n, PyObject* kw) -> PyObject*'\n            func_cast = f'(PyCFunction)(PyObject* (*)(PyObject*,PyObject**,int64,PyObject*))'\n            arr_has_return = [True for _ in arr_has_return]\n        arr_func_return = []\n        doc_all = ''\n        decs = 'The function declarations are:\\n'\n        for (did, has_return) in enumerate(arr_has_return):\n            df = dfs[did]\n            func_call = arr_func_call[did]\n            if df['doc'] and (not (did > 0 and df['doc'] == dfs[did - 1]['doc'])):\n                doc_all += 'Document:\\n'\n                doc_all += df['doc'] + '\\n'\n            doc_all += 'Declaration:\\n'\n            doc_all += df['dec'] + '\\n\\n'\n            decs += ' ' + df['dec'] + '\\n'\n            if has_return:\n                assert '-> int' not in func_head\n                if '-> PyObject*' in func_head:\n                    if 'return_self' in df['attrs']:\n                        arr_func_return.append(f'return (({func_call}), Py_INCREF(self), self)')\n                    else:\n                        arr_func_return.append(f\"return {get_pytype_map(df['return_t'], 1)}(({func_call}))\")\n                    func_return_failed = 'return nullptr'\n                else:\n                    arr_func_return.append(f'return ({func_call});')\n                    func_return_failed = 'return -1'\n            elif '-> int' in func_head:\n                arr_func_return.append(f'return ({func_call},0)')\n                func_return_failed = 'return -1'\n            else:\n                assert '-> void' in func_head, func_head\n                arr_func_return.append(f'{func_call};{before_return}return')\n                func_return_failed = 'return'\n        error_log_code = generate_error_code_from_func_header(func_head, target_scope_name, name, dfs, basename, h, class_info)\n        func = f'''\\n        {func_cast}[]{func_head} {{\\n            try {{\\n                {func_fill};\\n                uint64 arg_filled=0;\\n                (void)arg_filled;\\n                {''.join([f\"\"\"\n                if ({arr_func_quick_check_runable[did]}) {{\n                    {arr_func_args_convert[did]};\n                    {arr_fill_with_default[did]};\n                    {arr_func_return[did]};\n                }}\n                \"\"\" for did in range(len(arr_func_return))])}\\n                LOGf << \"Not a valid call.\";\\n            }} catch (const std::exception& e) {{\\n                if (!PyErr_Occurred()) {{\\n                    std::stringstream ss;\\n                    if (check_async_executor_error(e, ss)) {{\\n                        PyErr_Format(PyExc_RuntimeError, \\n                            \"%s\",\\n                            ss.str().c_str()\\n                        );\\n                    }} else {{\\n                        ss {error_log_code};\\n                        PyErr_Format(PyExc_RuntimeError, \\n                            \"%s\\\\n%s\\\\nFailed reason:%s\",\\n                            ss.str().c_str(),\\n                            R\"\"({decs})\"\",\\n                            e.what()\\n                        );\\n                    }}\\n                }}\\n            }}\\n            {func_return_failed};\\n        }}\\n        '''\n        if slot_name:\n            if slot_name == 'tp_gets':\n                class_gets[name] = {'func': func, 'doc': doc_all}\n                continue\n            if slot_name == 'tp_sets':\n                class_sets[name] = {'func': func, 'doc': ''}\n                continue\n            class_slots_code.append(f'\\n            tp.{slot_name} = {func};\\n            ')\n            continue\n        need_static = ''\n        if df['is_scope_def'] and df['is_static'] and (df['scope_name'] == class_name) and ('submodule' not in class_info['attrs']):\n            need_static = ' | METH_STATIC'\n        func = f'\\n        {{ R\"\"({name})\"\",\\n        {func},\\n        METH_FASTCALL | METH_KEYWORDS{need_static},\\n        R\"\"({doc_all})\"\"\\n        }}'\n        if df['is_scope_def']:\n            if df['scope_name'] == class_name or (class_info and target_scope_name == class_info['pynames'][0]):\n                class_defs_code.append(func)\n            else:\n                submodule_defs_code.append(func)\n        else:\n            code.append(func)\n    prop_names = list(set(class_gets.keys()).union(class_sets.keys()))\n    prop_names = sorted(prop_names)\n    for prop_name in prop_names:\n        get_func = 'NULL'\n        set_func = 'NULL'\n        doc = ''\n        if prop_name in class_gets:\n            get_func = class_gets[prop_name]['func']\n            if class_gets[prop_name]['doc']:\n                doc += class_gets[prop_name]['doc']\n        if prop_name in class_sets:\n            set_func = class_sets[prop_name]['func']\n            if class_sets[prop_name]['doc']:\n                doc += class_sets[prop_name]['doc']\n        class_getsets_code.append(f'\\n            {{\"{prop_name}\", {get_func}, {set_func}, R\"\"({doc})\"\"}}\\n        ')\n    code.append('{0,0,0,0}')\n    class_defs_code.append('{0,0,0,0}')\n    class_getsets_code.append('{0,0,0,0}')\n    submodule_defs_code.append('{0,0,0,0}')\n    core_name = 'jittor_core'\n    if class_info and 'attrs' in class_info and ('core_name' in class_info['attrs']):\n        core_name = class_info['attrs']['core_name']\n    if submodule_info and 'attrs' in submodule_info and ('core_name' in submodule_info['attrs']):\n        core_name = submodule_info['attrs']['core_name']\n    has_map = class_name in ['VarHolder', 'NanoVector']\n    has_seq = class_name in ['VarHolder', 'NanoVector']\n    src_code = ''\n    if include_name.endswith('var_slices.h'):\n        src_code += '#include \"var_holder.h\"\\n'\n    src_code += f'''\\n    #include \"utils/seh.h\"\\n    #include \"pyjt/py_converter.h\"\\n    #include \"pyjt/py_arg_printer.h\"\\n    #include \"common.h\"\\n    #include \"{include_name}\"\\n\\n    namespace jittor {{\\n\\n    {('' if class_name is None else f'PyHeapTypeObject Pyjt{class_name};' if 'heaptype' in class_info['attrs'] else f'PyTypeObject Pyjt{class_name};')}\\n    \\n    void pyjt_def_{basename}(PyObject* m) {{\\n        static PyMethodDef defs[] = {{\\n            {','.join(code)}\\n        }};\\n        ASSERT(PyModule_AddFunctions(m, defs)==0);\\n        {(f\"\"\"\n        static PyMethodDef class_defs[] = {{\n            {','.join(class_defs_code)}\n        }};\n        static PyGetSetDef class_getsets[] = {{\n            {','.join(class_getsets_code)}\n        }};\n\n        static PyNumberMethods number_methods = {{0}};\n        {(f'auto& htp =Pyjt{class_name}; auto& tp = htp.ht_type;' if 'heaptype' in class_info['attrs'] else f'auto& tp = Pyjt{class_name};')}\n        tp.tp_as_number = &number_methods;\n\n        {(f'static PyMappingMethods class_map_defs = {{0}};' if has_map else '')}\n        {(f'tp.tp_as_mapping = &class_map_defs;' if has_map else '')}\n\n        {(f'static PySequenceMethods class_seq_defs = {{0}};' if has_seq else '')}\n        {(f'tp.tp_as_sequence = &class_seq_defs;' if has_seq else '')}\n        \n        tp.tp_name = \"{core_name}.{class_info['pynames'][0]}\";\n        tp.tp_basicsize = GET_OBJ_SIZE({class_name});\n        {(f'tp.tp_dictoffset = tp.tp_basicsize; tp.tp_basicsize += sizeof(PyObject*); ' if has_attr_dict else '')}\n        tp.tp_new = PyType_GenericNew;\n        tp.tp_flags = Py_TPFLAGS_DEFAULT;\n        {('tp.tp_flags |= Py_TPFLAGS_HEAPTYPE; htp.ht_name = htp.ht_qualname = to_py_object<string>(tp.tp_name);' if 'heaptype' in class_info['attrs'] else '')}\n        tp.tp_methods = &class_defs[0];\n        tp.tp_getset = &class_getsets[0];\n        {''.join(class_slots_code)};\n        ASSERT(0==PyType_Ready(&tp)) << (PyErr_Print(), 0);\n        Py_INCREF(&tp);\n        ASSERT(0==PyModule_AddObject(m, \"{class_info['pynames'][0]}\", (PyObject*)&tp));\n        \"\"\" if class_name is not None else '')}\\n        {(f\"\"\"\n\n        // sub module def\n        static PyMethodDef submodule_defs[] = {{\n            {','.join(submodule_defs_code)}\n        }};\n        auto sub = PyImport_AddModule(\"{core_name}.{submodule_info['pynames'][0]}\");\n        ASSERT(PyModule_AddFunctions(sub, submodule_defs)==0);\n        ASSERT(sub);\n        ASSERT(0==PyModule_AddObject(m, \"{submodule_info['pynames'][0]}\", sub));\n        \"\"\" if submodule_name is not None else '')}\\n\\n    }}\\n\\n    }}\\n    '''\n    return src_code",
            "def compile_src(src, h, basename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    res = list(reg.finditer(src, re.S))\n    if len(res) == 0:\n        return\n    class_ranges = None\n    class_name = None\n    class_info = None\n    submodule_name = None\n    submodule_ranges = None\n    submodule_info = None\n    defs = []\n    LOG.vv(('find in', h))\n    for x in res:\n        LOG.vvv((x, x.groups()))\n        g = x.groups()\n        doc = g[1]\n        pyjt = g[3]\n        attrs = g[5]\n        esplit = lambda x: [] if x == None else [a.strip() for a in x.split(',') if len(a.strip())]\n        attrs = parse_attrs(attrs)\n        pynames = esplit(pyjt)\n        end = x.end()\n\n        def find_bc(i):\n            while src[i] not in '({;':\n                i += 1\n            j = i + 1\n            if src[i] == ';':\n                return (i, j)\n            presum = 1\n            while True:\n                if src[j] in '({[':\n                    presum += 1\n                elif src[j] in ')}]':\n                    presum -= 1\n                    if presum == 0:\n                        s = src[i] + src[j]\n                        assert s in ('()', '{}', '()'), 'braces not match ' + s\n                        return (i, j)\n                j += 1\n        (a, b) = find_bc(end)\n        is_property = 0\n        if src[a] == ';':\n            is_property = 1\n        if src[a] == '{':\n            assert len(pynames) == 1\n            if 'submodule' in attrs:\n                assert submodule_ranges == None\n                submodule_ranges = (a, b)\n                submodule_name = src[end:a - 1].strip().split()[-1]\n                submodule_info = {'pynames': pynames, 'attrs': attrs}\n                continue\n            assert class_ranges == None\n            class_ranges = (a, b)\n            class_name = src[end:a - 1].strip().split()[-1]\n            class_info = {'pynames': pynames, 'attrs': attrs}\n            continue\n        is_scope_def = False\n        is_static = False\n        scope_name = ''\n        if class_ranges != None:\n            if class_ranges[0] < a and a < class_ranges[1]:\n                is_scope_def = True\n                scope_name = class_name\n        if submodule_ranges != None:\n            if submodule_ranges[0] < a and a < submodule_ranges[1]:\n                is_scope_def = True\n                scope_name = submodule_name\n                is_static = True\n        dec = src[end:b + 1].strip()\n        arr = src[end:a].strip().split()\n        func_name = arr[-1]\n        is_constructor = False\n        if is_scope_def and func_name == class_name:\n            is_constructor = True\n        args = []\n        for arg in split_args(src[a + 1:b]):\n            if arg == '':\n                continue\n            default = ''\n            if '=' in arg:\n                (arg, default) = arg.split('=')\n                default = default\n            arg = arg.strip()\n            name = arg.split(' ')[-1]\n            tp = arg[:-len(name)]\n            tp = tp.strip()\n            prev_tp = tp\n            if tp.startswith('const') and tp.endswith('&'):\n                tp = tp[5:-1].strip()\n            if tp.endswith('&&'):\n                tp = tp[:-2].strip()\n            if tp.endswith('&'):\n                tp = tp[:-1].strip()\n            args.append((tp, name.strip(), default.strip(), prev_tp))\n        return_t = ''\n        for a in arr[:-1]:\n            if a in ['', 'inline', 'constexpr']:\n                continue\n            if a == 'static':\n                is_static = True\n                continue\n            if return_t != '':\n                return_t += ' '\n            return_t += a\n        if is_scope_def and class_info and ('submodule' in class_info['attrs']):\n            is_static = True\n        for (pid, pyname) in enumerate(pynames):\n            for rname in ['__lt__', '__le__', '__gt__', '__ge__', '__eq__', '__ne__']:\n                if pyname.endswith(rname):\n                    attrs[rname] = 1\n                    pynames[pid] = pyname.replace(rname, '__richcmp__')\n        def_info = {'is_scope_def': is_scope_def, 'is_constructor': is_constructor, 'is_static': is_static, 'is_property': is_property, 'func_name': func_name, 'args': args, 'return_t': return_t, 'dec': dec, 'pynames': pynames, 'attrs': attrs, 'doc': doc, 'scope_name': scope_name}\n        if is_property:\n            assert is_scope_def and (not is_static)\n            def_info['is_property'] = 1\n            def_info['pynames'] = ['__get__' + n for n in pynames]\n            assert return_t != 'void'\n            defs.append(dict(def_info))\n            def_info['pynames'] = ['__set__' + n for n in pynames]\n            assert len(args) == 0\n            def_info['args'] = [(def_info['return_t'], func_name, '', '')]\n            def_info['return_t'] = 'void'\n            defs.append(dict(def_info))\n            continue\n        else:\n            defs.append(def_info)\n        LOG.vvv(lambda : json.dumps(def_info, indent=4))\n    if len(defs) == 0:\n        return\n    include_name = h\n    code = []\n    class_defs_code = []\n    class_getsets_code = []\n    class_gets = OrderedDict()\n    class_sets = OrderedDict()\n    class_slots_code = []\n    submodule_defs_code = []\n    def_targets = OrderedDict()\n    has_attr_dict = class_name in ['VarHolder']\n    for df in defs:\n        for name in df['pynames']:\n            if df['is_scope_def'] and '.' not in name:\n                if df['scope_name'] == class_name:\n                    name = class_info['pynames'][0] + '.' + name\n                else:\n                    name = submodule_info['pynames'][0] + '.' + name\n            if name not in def_targets:\n                def_targets[name] = []\n            def_targets[name].append(df)\n    for name in def_targets:\n        dfs = def_targets[name]\n        target_scope_name = None\n        LOG.vv(name)\n        if '.' in name:\n            (target_scope_name, name) = name.split('.')\n        arr_func_quick_check_runable = []\n        arr_func_args_convert = []\n        arr_fill_with_default = []\n        arr_func_call = []\n        arr_has_return = []\n        self_as_arg0 = False\n        for df in dfs:\n            self_as_arg0 = class_info and target_scope_name == class_info['pynames'][0] and (df['scope_name'] == submodule_name) and (not name.startswith('__'))\n            res = get_def_code(df, df['scope_name'], name, bool(self_as_arg0))\n            arr_func_quick_check_runable.append(res[0])\n            arr_func_args_convert.append(res[1])\n            arr_fill_with_default.append(res[2])\n            arr_func_call.append(res[3])\n            arr_has_return.append(res[4])\n        slot_name = None\n        func_cast = ''\n        func_fill = ''\n        before_return = ''\n        if name == '__init__':\n            slot_name = 'tp_init'\n            func_head = '(PyObject* self, PyObject* _args, PyObject* kw) -> int'\n            func_fill = '\\n                int64 n = Py_SIZE(_args);\\n                auto args = (PyObject**)&PyTuple_GET_ITEM(_args, 0);\\n                (void)n, (void)args;\\n                // TODO: support kw\\n                CHECK(kw==0);\\n            '\n            if has_attr_dict:\n                func_fill += f'((PyObject**)(((char*)self) + sizeof(PyObject) + sizeof({class_name})))[0] = PyDict_New(); '\n        elif name == '__repr__':\n            slot_name = 'tp_repr'\n            func_head = '(PyObject* self) -> PyObject*'\n            func_fill = 'int64 n = 0; (void)n;'\n        elif name.startswith('__get__'):\n            slot_name = 'tp_gets'\n            name = name[len('__get__'):]\n            func_head = '(PyObject* self, void*) -> PyObject*'\n            func_fill = 'int64 n = 0; (void)n;'\n        elif name.startswith('__set__'):\n            slot_name = 'tp_sets'\n            name = name[len('__set__'):]\n            func_head = '(PyObject* self, PyObject* arg, void*) -> int'\n            func_fill = '\\n                int64 n=1;\\n                PyObject** args = &arg;\\n                (void)n, (void)args;\\n            '\n        elif name == '__call__':\n            slot_name = 'tp_call'\n            func_head = '(PyObject* self, PyObject* _args, PyObject* kw) -> PyObject*'\n            func_fill = '\\n                int64 n = Py_SIZE(_args);\\n                auto args = (PyObject**)&PyTuple_GET_ITEM(_args, 0);\\n                (void)n, (void)args;\\n                // TODO: support kw\\n                CHECK(kw==0);\\n            '\n        elif name == '__dealloc__':\n            slot_name = 'tp_dealloc'\n            func_head = '(PyObject* self) -> void'\n            func_fill = 'int64 n = 0'\n            before_return = 'Py_TYPE(self)->tp_free((PyObject *) self);'\n            if has_attr_dict:\n                before_return = f'Py_XDECREF(((PyObject**)(((char*)self) + sizeof(PyObject) + sizeof({class_name}))));' + before_return\n        elif name in binary_number_slots:\n            slot_name = 'tp_as_number->' + binary_number_slots[name]\n            func_head = '(PyObject* self, PyObject* b) -> PyObject*'\n            if name.endswith('pow__'):\n                func_head = '(PyObject* self, PyObject* b, PyObject*) -> PyObject*'\n            func_fill = '\\n                int64 n = 2;\\n                PyObject* args[] = {self, b};\\n                (void)n, (void)args;\\n            '\n        elif name in unary_number_slots:\n            slot_name = 'tp_as_number->' + unary_number_slots[name]\n            func_head = '(PyObject* self) -> PyObject*'\n            func_fill = '\\n                int64 n = 1;\\n                PyObject* args[] = {self};\\n                (void)n, (void)args;\\n            '\n        elif name == '__str__':\n            slot_name = 'tp_str'\n            func_head = '(PyObject* self) -> PyObject*'\n            func_fill = '\\n                int64 n = 0;\\n                PyObject* args[] = {self};\\n                (void)n, (void)args;\\n            '\n        elif name == '__richcmp__':\n            slot_name = 'tp_richcompare'\n            func_head = '(PyObject* self, PyObject* b, int op) -> PyObject*'\n            func_fill = '\\n                int64 n = 2;\\n                PyObject* args[] = {self, b};\\n                (void)n, (void)args;\\n            '\n        elif name == '__len__':\n            slot_name = 'tp_as_sequence->sq_length'\n            func_head = '(PyObject* self) -> Py_ssize_t'\n            func_fill = '\\n                int64 n = 0;  \\n                (void)n;\\n            '\n        elif name == '__map_len__':\n            slot_name = 'tp_as_mapping->mp_length'\n            func_head = '(PyObject* self) -> Py_ssize_t'\n            func_fill = '\\n                int64 n = 0;  \\n                (void)n;\\n            '\n        elif name == '__getitem__':\n            slot_name = 'tp_as_sequence->sq_item'\n            func_head = '(PyObject* self, Py_ssize_t arg0) -> PyObject*'\n            func_fill = f\"\"\"\\n                int64 n = 1;\\n                (void)n;\\n                if (arg0 >= GET_RAW_PTR({dfs[0]['scope_name']},self)->size()) {{\\n                    PyErr_SetString(PyExc_IndexError, \"\");\\n                    return (PyObject*)nullptr;\\n                }}\\n            \"\"\"\n        elif name == '__map_getitem__':\n            slot_name = 'tp_as_mapping->mp_subscript'\n            func_head = '(PyObject* self, PyObject* arg0) -> PyObject*'\n            func_fill = f'\\n                int64 n = 1;\\n                PyObject* args[] = {{arg0}};\\n                (void)n;\\n            '\n        elif name.startswith('__'):\n            LOG.f(f'Not support slot {name}')\n            continue\n        else:\n            func_head = '(PyObject* self, PyObject** args, int64 n, PyObject* kw) -> PyObject*'\n            func_cast = f'(PyCFunction)(PyObject* (*)(PyObject*,PyObject**,int64,PyObject*))'\n            arr_has_return = [True for _ in arr_has_return]\n        arr_func_return = []\n        doc_all = ''\n        decs = 'The function declarations are:\\n'\n        for (did, has_return) in enumerate(arr_has_return):\n            df = dfs[did]\n            func_call = arr_func_call[did]\n            if df['doc'] and (not (did > 0 and df['doc'] == dfs[did - 1]['doc'])):\n                doc_all += 'Document:\\n'\n                doc_all += df['doc'] + '\\n'\n            doc_all += 'Declaration:\\n'\n            doc_all += df['dec'] + '\\n\\n'\n            decs += ' ' + df['dec'] + '\\n'\n            if has_return:\n                assert '-> int' not in func_head\n                if '-> PyObject*' in func_head:\n                    if 'return_self' in df['attrs']:\n                        arr_func_return.append(f'return (({func_call}), Py_INCREF(self), self)')\n                    else:\n                        arr_func_return.append(f\"return {get_pytype_map(df['return_t'], 1)}(({func_call}))\")\n                    func_return_failed = 'return nullptr'\n                else:\n                    arr_func_return.append(f'return ({func_call});')\n                    func_return_failed = 'return -1'\n            elif '-> int' in func_head:\n                arr_func_return.append(f'return ({func_call},0)')\n                func_return_failed = 'return -1'\n            else:\n                assert '-> void' in func_head, func_head\n                arr_func_return.append(f'{func_call};{before_return}return')\n                func_return_failed = 'return'\n        error_log_code = generate_error_code_from_func_header(func_head, target_scope_name, name, dfs, basename, h, class_info)\n        func = f'''\\n        {func_cast}[]{func_head} {{\\n            try {{\\n                {func_fill};\\n                uint64 arg_filled=0;\\n                (void)arg_filled;\\n                {''.join([f\"\"\"\n                if ({arr_func_quick_check_runable[did]}) {{\n                    {arr_func_args_convert[did]};\n                    {arr_fill_with_default[did]};\n                    {arr_func_return[did]};\n                }}\n                \"\"\" for did in range(len(arr_func_return))])}\\n                LOGf << \"Not a valid call.\";\\n            }} catch (const std::exception& e) {{\\n                if (!PyErr_Occurred()) {{\\n                    std::stringstream ss;\\n                    if (check_async_executor_error(e, ss)) {{\\n                        PyErr_Format(PyExc_RuntimeError, \\n                            \"%s\",\\n                            ss.str().c_str()\\n                        );\\n                    }} else {{\\n                        ss {error_log_code};\\n                        PyErr_Format(PyExc_RuntimeError, \\n                            \"%s\\\\n%s\\\\nFailed reason:%s\",\\n                            ss.str().c_str(),\\n                            R\"\"({decs})\"\",\\n                            e.what()\\n                        );\\n                    }}\\n                }}\\n            }}\\n            {func_return_failed};\\n        }}\\n        '''\n        if slot_name:\n            if slot_name == 'tp_gets':\n                class_gets[name] = {'func': func, 'doc': doc_all}\n                continue\n            if slot_name == 'tp_sets':\n                class_sets[name] = {'func': func, 'doc': ''}\n                continue\n            class_slots_code.append(f'\\n            tp.{slot_name} = {func};\\n            ')\n            continue\n        need_static = ''\n        if df['is_scope_def'] and df['is_static'] and (df['scope_name'] == class_name) and ('submodule' not in class_info['attrs']):\n            need_static = ' | METH_STATIC'\n        func = f'\\n        {{ R\"\"({name})\"\",\\n        {func},\\n        METH_FASTCALL | METH_KEYWORDS{need_static},\\n        R\"\"({doc_all})\"\"\\n        }}'\n        if df['is_scope_def']:\n            if df['scope_name'] == class_name or (class_info and target_scope_name == class_info['pynames'][0]):\n                class_defs_code.append(func)\n            else:\n                submodule_defs_code.append(func)\n        else:\n            code.append(func)\n    prop_names = list(set(class_gets.keys()).union(class_sets.keys()))\n    prop_names = sorted(prop_names)\n    for prop_name in prop_names:\n        get_func = 'NULL'\n        set_func = 'NULL'\n        doc = ''\n        if prop_name in class_gets:\n            get_func = class_gets[prop_name]['func']\n            if class_gets[prop_name]['doc']:\n                doc += class_gets[prop_name]['doc']\n        if prop_name in class_sets:\n            set_func = class_sets[prop_name]['func']\n            if class_sets[prop_name]['doc']:\n                doc += class_sets[prop_name]['doc']\n        class_getsets_code.append(f'\\n            {{\"{prop_name}\", {get_func}, {set_func}, R\"\"({doc})\"\"}}\\n        ')\n    code.append('{0,0,0,0}')\n    class_defs_code.append('{0,0,0,0}')\n    class_getsets_code.append('{0,0,0,0}')\n    submodule_defs_code.append('{0,0,0,0}')\n    core_name = 'jittor_core'\n    if class_info and 'attrs' in class_info and ('core_name' in class_info['attrs']):\n        core_name = class_info['attrs']['core_name']\n    if submodule_info and 'attrs' in submodule_info and ('core_name' in submodule_info['attrs']):\n        core_name = submodule_info['attrs']['core_name']\n    has_map = class_name in ['VarHolder', 'NanoVector']\n    has_seq = class_name in ['VarHolder', 'NanoVector']\n    src_code = ''\n    if include_name.endswith('var_slices.h'):\n        src_code += '#include \"var_holder.h\"\\n'\n    src_code += f'''\\n    #include \"utils/seh.h\"\\n    #include \"pyjt/py_converter.h\"\\n    #include \"pyjt/py_arg_printer.h\"\\n    #include \"common.h\"\\n    #include \"{include_name}\"\\n\\n    namespace jittor {{\\n\\n    {('' if class_name is None else f'PyHeapTypeObject Pyjt{class_name};' if 'heaptype' in class_info['attrs'] else f'PyTypeObject Pyjt{class_name};')}\\n    \\n    void pyjt_def_{basename}(PyObject* m) {{\\n        static PyMethodDef defs[] = {{\\n            {','.join(code)}\\n        }};\\n        ASSERT(PyModule_AddFunctions(m, defs)==0);\\n        {(f\"\"\"\n        static PyMethodDef class_defs[] = {{\n            {','.join(class_defs_code)}\n        }};\n        static PyGetSetDef class_getsets[] = {{\n            {','.join(class_getsets_code)}\n        }};\n\n        static PyNumberMethods number_methods = {{0}};\n        {(f'auto& htp =Pyjt{class_name}; auto& tp = htp.ht_type;' if 'heaptype' in class_info['attrs'] else f'auto& tp = Pyjt{class_name};')}\n        tp.tp_as_number = &number_methods;\n\n        {(f'static PyMappingMethods class_map_defs = {{0}};' if has_map else '')}\n        {(f'tp.tp_as_mapping = &class_map_defs;' if has_map else '')}\n\n        {(f'static PySequenceMethods class_seq_defs = {{0}};' if has_seq else '')}\n        {(f'tp.tp_as_sequence = &class_seq_defs;' if has_seq else '')}\n        \n        tp.tp_name = \"{core_name}.{class_info['pynames'][0]}\";\n        tp.tp_basicsize = GET_OBJ_SIZE({class_name});\n        {(f'tp.tp_dictoffset = tp.tp_basicsize; tp.tp_basicsize += sizeof(PyObject*); ' if has_attr_dict else '')}\n        tp.tp_new = PyType_GenericNew;\n        tp.tp_flags = Py_TPFLAGS_DEFAULT;\n        {('tp.tp_flags |= Py_TPFLAGS_HEAPTYPE; htp.ht_name = htp.ht_qualname = to_py_object<string>(tp.tp_name);' if 'heaptype' in class_info['attrs'] else '')}\n        tp.tp_methods = &class_defs[0];\n        tp.tp_getset = &class_getsets[0];\n        {''.join(class_slots_code)};\n        ASSERT(0==PyType_Ready(&tp)) << (PyErr_Print(), 0);\n        Py_INCREF(&tp);\n        ASSERT(0==PyModule_AddObject(m, \"{class_info['pynames'][0]}\", (PyObject*)&tp));\n        \"\"\" if class_name is not None else '')}\\n        {(f\"\"\"\n\n        // sub module def\n        static PyMethodDef submodule_defs[] = {{\n            {','.join(submodule_defs_code)}\n        }};\n        auto sub = PyImport_AddModule(\"{core_name}.{submodule_info['pynames'][0]}\");\n        ASSERT(PyModule_AddFunctions(sub, submodule_defs)==0);\n        ASSERT(sub);\n        ASSERT(0==PyModule_AddObject(m, \"{submodule_info['pynames'][0]}\", sub));\n        \"\"\" if submodule_name is not None else '')}\\n\\n    }}\\n\\n    }}\\n    '''\n    return src_code",
            "def compile_src(src, h, basename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    res = list(reg.finditer(src, re.S))\n    if len(res) == 0:\n        return\n    class_ranges = None\n    class_name = None\n    class_info = None\n    submodule_name = None\n    submodule_ranges = None\n    submodule_info = None\n    defs = []\n    LOG.vv(('find in', h))\n    for x in res:\n        LOG.vvv((x, x.groups()))\n        g = x.groups()\n        doc = g[1]\n        pyjt = g[3]\n        attrs = g[5]\n        esplit = lambda x: [] if x == None else [a.strip() for a in x.split(',') if len(a.strip())]\n        attrs = parse_attrs(attrs)\n        pynames = esplit(pyjt)\n        end = x.end()\n\n        def find_bc(i):\n            while src[i] not in '({;':\n                i += 1\n            j = i + 1\n            if src[i] == ';':\n                return (i, j)\n            presum = 1\n            while True:\n                if src[j] in '({[':\n                    presum += 1\n                elif src[j] in ')}]':\n                    presum -= 1\n                    if presum == 0:\n                        s = src[i] + src[j]\n                        assert s in ('()', '{}', '()'), 'braces not match ' + s\n                        return (i, j)\n                j += 1\n        (a, b) = find_bc(end)\n        is_property = 0\n        if src[a] == ';':\n            is_property = 1\n        if src[a] == '{':\n            assert len(pynames) == 1\n            if 'submodule' in attrs:\n                assert submodule_ranges == None\n                submodule_ranges = (a, b)\n                submodule_name = src[end:a - 1].strip().split()[-1]\n                submodule_info = {'pynames': pynames, 'attrs': attrs}\n                continue\n            assert class_ranges == None\n            class_ranges = (a, b)\n            class_name = src[end:a - 1].strip().split()[-1]\n            class_info = {'pynames': pynames, 'attrs': attrs}\n            continue\n        is_scope_def = False\n        is_static = False\n        scope_name = ''\n        if class_ranges != None:\n            if class_ranges[0] < a and a < class_ranges[1]:\n                is_scope_def = True\n                scope_name = class_name\n        if submodule_ranges != None:\n            if submodule_ranges[0] < a and a < submodule_ranges[1]:\n                is_scope_def = True\n                scope_name = submodule_name\n                is_static = True\n        dec = src[end:b + 1].strip()\n        arr = src[end:a].strip().split()\n        func_name = arr[-1]\n        is_constructor = False\n        if is_scope_def and func_name == class_name:\n            is_constructor = True\n        args = []\n        for arg in split_args(src[a + 1:b]):\n            if arg == '':\n                continue\n            default = ''\n            if '=' in arg:\n                (arg, default) = arg.split('=')\n                default = default\n            arg = arg.strip()\n            name = arg.split(' ')[-1]\n            tp = arg[:-len(name)]\n            tp = tp.strip()\n            prev_tp = tp\n            if tp.startswith('const') and tp.endswith('&'):\n                tp = tp[5:-1].strip()\n            if tp.endswith('&&'):\n                tp = tp[:-2].strip()\n            if tp.endswith('&'):\n                tp = tp[:-1].strip()\n            args.append((tp, name.strip(), default.strip(), prev_tp))\n        return_t = ''\n        for a in arr[:-1]:\n            if a in ['', 'inline', 'constexpr']:\n                continue\n            if a == 'static':\n                is_static = True\n                continue\n            if return_t != '':\n                return_t += ' '\n            return_t += a\n        if is_scope_def and class_info and ('submodule' in class_info['attrs']):\n            is_static = True\n        for (pid, pyname) in enumerate(pynames):\n            for rname in ['__lt__', '__le__', '__gt__', '__ge__', '__eq__', '__ne__']:\n                if pyname.endswith(rname):\n                    attrs[rname] = 1\n                    pynames[pid] = pyname.replace(rname, '__richcmp__')\n        def_info = {'is_scope_def': is_scope_def, 'is_constructor': is_constructor, 'is_static': is_static, 'is_property': is_property, 'func_name': func_name, 'args': args, 'return_t': return_t, 'dec': dec, 'pynames': pynames, 'attrs': attrs, 'doc': doc, 'scope_name': scope_name}\n        if is_property:\n            assert is_scope_def and (not is_static)\n            def_info['is_property'] = 1\n            def_info['pynames'] = ['__get__' + n for n in pynames]\n            assert return_t != 'void'\n            defs.append(dict(def_info))\n            def_info['pynames'] = ['__set__' + n for n in pynames]\n            assert len(args) == 0\n            def_info['args'] = [(def_info['return_t'], func_name, '', '')]\n            def_info['return_t'] = 'void'\n            defs.append(dict(def_info))\n            continue\n        else:\n            defs.append(def_info)\n        LOG.vvv(lambda : json.dumps(def_info, indent=4))\n    if len(defs) == 0:\n        return\n    include_name = h\n    code = []\n    class_defs_code = []\n    class_getsets_code = []\n    class_gets = OrderedDict()\n    class_sets = OrderedDict()\n    class_slots_code = []\n    submodule_defs_code = []\n    def_targets = OrderedDict()\n    has_attr_dict = class_name in ['VarHolder']\n    for df in defs:\n        for name in df['pynames']:\n            if df['is_scope_def'] and '.' not in name:\n                if df['scope_name'] == class_name:\n                    name = class_info['pynames'][0] + '.' + name\n                else:\n                    name = submodule_info['pynames'][0] + '.' + name\n            if name not in def_targets:\n                def_targets[name] = []\n            def_targets[name].append(df)\n    for name in def_targets:\n        dfs = def_targets[name]\n        target_scope_name = None\n        LOG.vv(name)\n        if '.' in name:\n            (target_scope_name, name) = name.split('.')\n        arr_func_quick_check_runable = []\n        arr_func_args_convert = []\n        arr_fill_with_default = []\n        arr_func_call = []\n        arr_has_return = []\n        self_as_arg0 = False\n        for df in dfs:\n            self_as_arg0 = class_info and target_scope_name == class_info['pynames'][0] and (df['scope_name'] == submodule_name) and (not name.startswith('__'))\n            res = get_def_code(df, df['scope_name'], name, bool(self_as_arg0))\n            arr_func_quick_check_runable.append(res[0])\n            arr_func_args_convert.append(res[1])\n            arr_fill_with_default.append(res[2])\n            arr_func_call.append(res[3])\n            arr_has_return.append(res[4])\n        slot_name = None\n        func_cast = ''\n        func_fill = ''\n        before_return = ''\n        if name == '__init__':\n            slot_name = 'tp_init'\n            func_head = '(PyObject* self, PyObject* _args, PyObject* kw) -> int'\n            func_fill = '\\n                int64 n = Py_SIZE(_args);\\n                auto args = (PyObject**)&PyTuple_GET_ITEM(_args, 0);\\n                (void)n, (void)args;\\n                // TODO: support kw\\n                CHECK(kw==0);\\n            '\n            if has_attr_dict:\n                func_fill += f'((PyObject**)(((char*)self) + sizeof(PyObject) + sizeof({class_name})))[0] = PyDict_New(); '\n        elif name == '__repr__':\n            slot_name = 'tp_repr'\n            func_head = '(PyObject* self) -> PyObject*'\n            func_fill = 'int64 n = 0; (void)n;'\n        elif name.startswith('__get__'):\n            slot_name = 'tp_gets'\n            name = name[len('__get__'):]\n            func_head = '(PyObject* self, void*) -> PyObject*'\n            func_fill = 'int64 n = 0; (void)n;'\n        elif name.startswith('__set__'):\n            slot_name = 'tp_sets'\n            name = name[len('__set__'):]\n            func_head = '(PyObject* self, PyObject* arg, void*) -> int'\n            func_fill = '\\n                int64 n=1;\\n                PyObject** args = &arg;\\n                (void)n, (void)args;\\n            '\n        elif name == '__call__':\n            slot_name = 'tp_call'\n            func_head = '(PyObject* self, PyObject* _args, PyObject* kw) -> PyObject*'\n            func_fill = '\\n                int64 n = Py_SIZE(_args);\\n                auto args = (PyObject**)&PyTuple_GET_ITEM(_args, 0);\\n                (void)n, (void)args;\\n                // TODO: support kw\\n                CHECK(kw==0);\\n            '\n        elif name == '__dealloc__':\n            slot_name = 'tp_dealloc'\n            func_head = '(PyObject* self) -> void'\n            func_fill = 'int64 n = 0'\n            before_return = 'Py_TYPE(self)->tp_free((PyObject *) self);'\n            if has_attr_dict:\n                before_return = f'Py_XDECREF(((PyObject**)(((char*)self) + sizeof(PyObject) + sizeof({class_name}))));' + before_return\n        elif name in binary_number_slots:\n            slot_name = 'tp_as_number->' + binary_number_slots[name]\n            func_head = '(PyObject* self, PyObject* b) -> PyObject*'\n            if name.endswith('pow__'):\n                func_head = '(PyObject* self, PyObject* b, PyObject*) -> PyObject*'\n            func_fill = '\\n                int64 n = 2;\\n                PyObject* args[] = {self, b};\\n                (void)n, (void)args;\\n            '\n        elif name in unary_number_slots:\n            slot_name = 'tp_as_number->' + unary_number_slots[name]\n            func_head = '(PyObject* self) -> PyObject*'\n            func_fill = '\\n                int64 n = 1;\\n                PyObject* args[] = {self};\\n                (void)n, (void)args;\\n            '\n        elif name == '__str__':\n            slot_name = 'tp_str'\n            func_head = '(PyObject* self) -> PyObject*'\n            func_fill = '\\n                int64 n = 0;\\n                PyObject* args[] = {self};\\n                (void)n, (void)args;\\n            '\n        elif name == '__richcmp__':\n            slot_name = 'tp_richcompare'\n            func_head = '(PyObject* self, PyObject* b, int op) -> PyObject*'\n            func_fill = '\\n                int64 n = 2;\\n                PyObject* args[] = {self, b};\\n                (void)n, (void)args;\\n            '\n        elif name == '__len__':\n            slot_name = 'tp_as_sequence->sq_length'\n            func_head = '(PyObject* self) -> Py_ssize_t'\n            func_fill = '\\n                int64 n = 0;  \\n                (void)n;\\n            '\n        elif name == '__map_len__':\n            slot_name = 'tp_as_mapping->mp_length'\n            func_head = '(PyObject* self) -> Py_ssize_t'\n            func_fill = '\\n                int64 n = 0;  \\n                (void)n;\\n            '\n        elif name == '__getitem__':\n            slot_name = 'tp_as_sequence->sq_item'\n            func_head = '(PyObject* self, Py_ssize_t arg0) -> PyObject*'\n            func_fill = f\"\"\"\\n                int64 n = 1;\\n                (void)n;\\n                if (arg0 >= GET_RAW_PTR({dfs[0]['scope_name']},self)->size()) {{\\n                    PyErr_SetString(PyExc_IndexError, \"\");\\n                    return (PyObject*)nullptr;\\n                }}\\n            \"\"\"\n        elif name == '__map_getitem__':\n            slot_name = 'tp_as_mapping->mp_subscript'\n            func_head = '(PyObject* self, PyObject* arg0) -> PyObject*'\n            func_fill = f'\\n                int64 n = 1;\\n                PyObject* args[] = {{arg0}};\\n                (void)n;\\n            '\n        elif name.startswith('__'):\n            LOG.f(f'Not support slot {name}')\n            continue\n        else:\n            func_head = '(PyObject* self, PyObject** args, int64 n, PyObject* kw) -> PyObject*'\n            func_cast = f'(PyCFunction)(PyObject* (*)(PyObject*,PyObject**,int64,PyObject*))'\n            arr_has_return = [True for _ in arr_has_return]\n        arr_func_return = []\n        doc_all = ''\n        decs = 'The function declarations are:\\n'\n        for (did, has_return) in enumerate(arr_has_return):\n            df = dfs[did]\n            func_call = arr_func_call[did]\n            if df['doc'] and (not (did > 0 and df['doc'] == dfs[did - 1]['doc'])):\n                doc_all += 'Document:\\n'\n                doc_all += df['doc'] + '\\n'\n            doc_all += 'Declaration:\\n'\n            doc_all += df['dec'] + '\\n\\n'\n            decs += ' ' + df['dec'] + '\\n'\n            if has_return:\n                assert '-> int' not in func_head\n                if '-> PyObject*' in func_head:\n                    if 'return_self' in df['attrs']:\n                        arr_func_return.append(f'return (({func_call}), Py_INCREF(self), self)')\n                    else:\n                        arr_func_return.append(f\"return {get_pytype_map(df['return_t'], 1)}(({func_call}))\")\n                    func_return_failed = 'return nullptr'\n                else:\n                    arr_func_return.append(f'return ({func_call});')\n                    func_return_failed = 'return -1'\n            elif '-> int' in func_head:\n                arr_func_return.append(f'return ({func_call},0)')\n                func_return_failed = 'return -1'\n            else:\n                assert '-> void' in func_head, func_head\n                arr_func_return.append(f'{func_call};{before_return}return')\n                func_return_failed = 'return'\n        error_log_code = generate_error_code_from_func_header(func_head, target_scope_name, name, dfs, basename, h, class_info)\n        func = f'''\\n        {func_cast}[]{func_head} {{\\n            try {{\\n                {func_fill};\\n                uint64 arg_filled=0;\\n                (void)arg_filled;\\n                {''.join([f\"\"\"\n                if ({arr_func_quick_check_runable[did]}) {{\n                    {arr_func_args_convert[did]};\n                    {arr_fill_with_default[did]};\n                    {arr_func_return[did]};\n                }}\n                \"\"\" for did in range(len(arr_func_return))])}\\n                LOGf << \"Not a valid call.\";\\n            }} catch (const std::exception& e) {{\\n                if (!PyErr_Occurred()) {{\\n                    std::stringstream ss;\\n                    if (check_async_executor_error(e, ss)) {{\\n                        PyErr_Format(PyExc_RuntimeError, \\n                            \"%s\",\\n                            ss.str().c_str()\\n                        );\\n                    }} else {{\\n                        ss {error_log_code};\\n                        PyErr_Format(PyExc_RuntimeError, \\n                            \"%s\\\\n%s\\\\nFailed reason:%s\",\\n                            ss.str().c_str(),\\n                            R\"\"({decs})\"\",\\n                            e.what()\\n                        );\\n                    }}\\n                }}\\n            }}\\n            {func_return_failed};\\n        }}\\n        '''\n        if slot_name:\n            if slot_name == 'tp_gets':\n                class_gets[name] = {'func': func, 'doc': doc_all}\n                continue\n            if slot_name == 'tp_sets':\n                class_sets[name] = {'func': func, 'doc': ''}\n                continue\n            class_slots_code.append(f'\\n            tp.{slot_name} = {func};\\n            ')\n            continue\n        need_static = ''\n        if df['is_scope_def'] and df['is_static'] and (df['scope_name'] == class_name) and ('submodule' not in class_info['attrs']):\n            need_static = ' | METH_STATIC'\n        func = f'\\n        {{ R\"\"({name})\"\",\\n        {func},\\n        METH_FASTCALL | METH_KEYWORDS{need_static},\\n        R\"\"({doc_all})\"\"\\n        }}'\n        if df['is_scope_def']:\n            if df['scope_name'] == class_name or (class_info and target_scope_name == class_info['pynames'][0]):\n                class_defs_code.append(func)\n            else:\n                submodule_defs_code.append(func)\n        else:\n            code.append(func)\n    prop_names = list(set(class_gets.keys()).union(class_sets.keys()))\n    prop_names = sorted(prop_names)\n    for prop_name in prop_names:\n        get_func = 'NULL'\n        set_func = 'NULL'\n        doc = ''\n        if prop_name in class_gets:\n            get_func = class_gets[prop_name]['func']\n            if class_gets[prop_name]['doc']:\n                doc += class_gets[prop_name]['doc']\n        if prop_name in class_sets:\n            set_func = class_sets[prop_name]['func']\n            if class_sets[prop_name]['doc']:\n                doc += class_sets[prop_name]['doc']\n        class_getsets_code.append(f'\\n            {{\"{prop_name}\", {get_func}, {set_func}, R\"\"({doc})\"\"}}\\n        ')\n    code.append('{0,0,0,0}')\n    class_defs_code.append('{0,0,0,0}')\n    class_getsets_code.append('{0,0,0,0}')\n    submodule_defs_code.append('{0,0,0,0}')\n    core_name = 'jittor_core'\n    if class_info and 'attrs' in class_info and ('core_name' in class_info['attrs']):\n        core_name = class_info['attrs']['core_name']\n    if submodule_info and 'attrs' in submodule_info and ('core_name' in submodule_info['attrs']):\n        core_name = submodule_info['attrs']['core_name']\n    has_map = class_name in ['VarHolder', 'NanoVector']\n    has_seq = class_name in ['VarHolder', 'NanoVector']\n    src_code = ''\n    if include_name.endswith('var_slices.h'):\n        src_code += '#include \"var_holder.h\"\\n'\n    src_code += f'''\\n    #include \"utils/seh.h\"\\n    #include \"pyjt/py_converter.h\"\\n    #include \"pyjt/py_arg_printer.h\"\\n    #include \"common.h\"\\n    #include \"{include_name}\"\\n\\n    namespace jittor {{\\n\\n    {('' if class_name is None else f'PyHeapTypeObject Pyjt{class_name};' if 'heaptype' in class_info['attrs'] else f'PyTypeObject Pyjt{class_name};')}\\n    \\n    void pyjt_def_{basename}(PyObject* m) {{\\n        static PyMethodDef defs[] = {{\\n            {','.join(code)}\\n        }};\\n        ASSERT(PyModule_AddFunctions(m, defs)==0);\\n        {(f\"\"\"\n        static PyMethodDef class_defs[] = {{\n            {','.join(class_defs_code)}\n        }};\n        static PyGetSetDef class_getsets[] = {{\n            {','.join(class_getsets_code)}\n        }};\n\n        static PyNumberMethods number_methods = {{0}};\n        {(f'auto& htp =Pyjt{class_name}; auto& tp = htp.ht_type;' if 'heaptype' in class_info['attrs'] else f'auto& tp = Pyjt{class_name};')}\n        tp.tp_as_number = &number_methods;\n\n        {(f'static PyMappingMethods class_map_defs = {{0}};' if has_map else '')}\n        {(f'tp.tp_as_mapping = &class_map_defs;' if has_map else '')}\n\n        {(f'static PySequenceMethods class_seq_defs = {{0}};' if has_seq else '')}\n        {(f'tp.tp_as_sequence = &class_seq_defs;' if has_seq else '')}\n        \n        tp.tp_name = \"{core_name}.{class_info['pynames'][0]}\";\n        tp.tp_basicsize = GET_OBJ_SIZE({class_name});\n        {(f'tp.tp_dictoffset = tp.tp_basicsize; tp.tp_basicsize += sizeof(PyObject*); ' if has_attr_dict else '')}\n        tp.tp_new = PyType_GenericNew;\n        tp.tp_flags = Py_TPFLAGS_DEFAULT;\n        {('tp.tp_flags |= Py_TPFLAGS_HEAPTYPE; htp.ht_name = htp.ht_qualname = to_py_object<string>(tp.tp_name);' if 'heaptype' in class_info['attrs'] else '')}\n        tp.tp_methods = &class_defs[0];\n        tp.tp_getset = &class_getsets[0];\n        {''.join(class_slots_code)};\n        ASSERT(0==PyType_Ready(&tp)) << (PyErr_Print(), 0);\n        Py_INCREF(&tp);\n        ASSERT(0==PyModule_AddObject(m, \"{class_info['pynames'][0]}\", (PyObject*)&tp));\n        \"\"\" if class_name is not None else '')}\\n        {(f\"\"\"\n\n        // sub module def\n        static PyMethodDef submodule_defs[] = {{\n            {','.join(submodule_defs_code)}\n        }};\n        auto sub = PyImport_AddModule(\"{core_name}.{submodule_info['pynames'][0]}\");\n        ASSERT(PyModule_AddFunctions(sub, submodule_defs)==0);\n        ASSERT(sub);\n        ASSERT(0==PyModule_AddObject(m, \"{submodule_info['pynames'][0]}\", sub));\n        \"\"\" if submodule_name is not None else '')}\\n\\n    }}\\n\\n    }}\\n    '''\n    return src_code"
        ]
    },
    {
        "func_name": "compile_single",
        "original": "def compile_single(head_file_name, src_file_name, src=None):\n    basename = os.path.basename(head_file_name).split('.')[0]\n    if src == None:\n        with open(head_file_name, 'r', encoding='utf8') as f:\n            src = f.read()\n    code = compile_src(src, head_file_name, basename)\n    if not code:\n        return False\n    LOG.vvv('write to', src_file_name)\n    LOG.vvvv(code)\n    with open(src_file_name, 'w', encoding='utf8') as f:\n        f.write(code)\n    return True",
        "mutated": [
            "def compile_single(head_file_name, src_file_name, src=None):\n    if False:\n        i = 10\n    basename = os.path.basename(head_file_name).split('.')[0]\n    if src == None:\n        with open(head_file_name, 'r', encoding='utf8') as f:\n            src = f.read()\n    code = compile_src(src, head_file_name, basename)\n    if not code:\n        return False\n    LOG.vvv('write to', src_file_name)\n    LOG.vvvv(code)\n    with open(src_file_name, 'w', encoding='utf8') as f:\n        f.write(code)\n    return True",
            "def compile_single(head_file_name, src_file_name, src=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    basename = os.path.basename(head_file_name).split('.')[0]\n    if src == None:\n        with open(head_file_name, 'r', encoding='utf8') as f:\n            src = f.read()\n    code = compile_src(src, head_file_name, basename)\n    if not code:\n        return False\n    LOG.vvv('write to', src_file_name)\n    LOG.vvvv(code)\n    with open(src_file_name, 'w', encoding='utf8') as f:\n        f.write(code)\n    return True",
            "def compile_single(head_file_name, src_file_name, src=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    basename = os.path.basename(head_file_name).split('.')[0]\n    if src == None:\n        with open(head_file_name, 'r', encoding='utf8') as f:\n            src = f.read()\n    code = compile_src(src, head_file_name, basename)\n    if not code:\n        return False\n    LOG.vvv('write to', src_file_name)\n    LOG.vvvv(code)\n    with open(src_file_name, 'w', encoding='utf8') as f:\n        f.write(code)\n    return True",
            "def compile_single(head_file_name, src_file_name, src=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    basename = os.path.basename(head_file_name).split('.')[0]\n    if src == None:\n        with open(head_file_name, 'r', encoding='utf8') as f:\n            src = f.read()\n    code = compile_src(src, head_file_name, basename)\n    if not code:\n        return False\n    LOG.vvv('write to', src_file_name)\n    LOG.vvvv(code)\n    with open(src_file_name, 'w', encoding='utf8') as f:\n        f.write(code)\n    return True",
            "def compile_single(head_file_name, src_file_name, src=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    basename = os.path.basename(head_file_name).split('.')[0]\n    if src == None:\n        with open(head_file_name, 'r', encoding='utf8') as f:\n            src = f.read()\n    code = compile_src(src, head_file_name, basename)\n    if not code:\n        return False\n    LOG.vvv('write to', src_file_name)\n    LOG.vvvv(code)\n    with open(src_file_name, 'w', encoding='utf8') as f:\n        f.write(code)\n    return True"
        ]
    },
    {
        "func_name": "compile",
        "original": "def compile(cache_path, jittor_path):\n    headers1 = glob.glob(jittor_path + '/src/**/*.h', recursive=True)\n    headers2 = glob.glob(cache_path + '/gen/**/*.h', recursive=True)\n    headers = headers1 + headers2\n    basenames = []\n    pyjt_names = []\n    for h in headers:\n        with open(h, 'r', encoding='utf8') as f:\n            src = f.read()\n        bh = os.path.basename(h)\n        if bh == 'var_holder.h':\n            continue\n        if bh == 'jit_op_maker.h':\n            with open(os.path.join(jittor_path, 'src', 'var_holder.h'), 'r', encoding='utf8') as f:\n                src = f.read() + src\n        basename = bh.split('.')[0]\n        fname = 'pyjt_' + basename + '.cc'\n        fname = os.path.join(cache_path, 'gen', fname)\n        check = compile_single(h, fname, src)\n        if not check:\n            continue\n        basenames.append(basename)\n        pyjt_names.append(fname)\n    code = f\"\"\"\\n    #include \"pyjt/py_converter.h\"\\n    #include \"common.h\"\\n\\n    namespace jittor {{\\n\\n    {' '.join([f'extern void pyjt_def_{n}(PyObject* m);' for n in basenames])}\\n\\n    void pyjt_def_all(PyObject* m) {{\\n        {' '.join([f'pyjt_def_{n}(m);' for n in basenames])}\\n    }}\\n\\n    }}\\n    \"\"\"\n    fname = os.path.join(cache_path, 'gen', 'pyjt_all.cc')\n    LOG.vvv(('write to', fname))\n    LOG.vvvv(code)\n    with open(fname, 'w', encoding='utf8') as f:\n        f.write(code)\n    pyjt_names.append(fname)\n    return pyjt_names",
        "mutated": [
            "def compile(cache_path, jittor_path):\n    if False:\n        i = 10\n    headers1 = glob.glob(jittor_path + '/src/**/*.h', recursive=True)\n    headers2 = glob.glob(cache_path + '/gen/**/*.h', recursive=True)\n    headers = headers1 + headers2\n    basenames = []\n    pyjt_names = []\n    for h in headers:\n        with open(h, 'r', encoding='utf8') as f:\n            src = f.read()\n        bh = os.path.basename(h)\n        if bh == 'var_holder.h':\n            continue\n        if bh == 'jit_op_maker.h':\n            with open(os.path.join(jittor_path, 'src', 'var_holder.h'), 'r', encoding='utf8') as f:\n                src = f.read() + src\n        basename = bh.split('.')[0]\n        fname = 'pyjt_' + basename + '.cc'\n        fname = os.path.join(cache_path, 'gen', fname)\n        check = compile_single(h, fname, src)\n        if not check:\n            continue\n        basenames.append(basename)\n        pyjt_names.append(fname)\n    code = f\"\"\"\\n    #include \"pyjt/py_converter.h\"\\n    #include \"common.h\"\\n\\n    namespace jittor {{\\n\\n    {' '.join([f'extern void pyjt_def_{n}(PyObject* m);' for n in basenames])}\\n\\n    void pyjt_def_all(PyObject* m) {{\\n        {' '.join([f'pyjt_def_{n}(m);' for n in basenames])}\\n    }}\\n\\n    }}\\n    \"\"\"\n    fname = os.path.join(cache_path, 'gen', 'pyjt_all.cc')\n    LOG.vvv(('write to', fname))\n    LOG.vvvv(code)\n    with open(fname, 'w', encoding='utf8') as f:\n        f.write(code)\n    pyjt_names.append(fname)\n    return pyjt_names",
            "def compile(cache_path, jittor_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    headers1 = glob.glob(jittor_path + '/src/**/*.h', recursive=True)\n    headers2 = glob.glob(cache_path + '/gen/**/*.h', recursive=True)\n    headers = headers1 + headers2\n    basenames = []\n    pyjt_names = []\n    for h in headers:\n        with open(h, 'r', encoding='utf8') as f:\n            src = f.read()\n        bh = os.path.basename(h)\n        if bh == 'var_holder.h':\n            continue\n        if bh == 'jit_op_maker.h':\n            with open(os.path.join(jittor_path, 'src', 'var_holder.h'), 'r', encoding='utf8') as f:\n                src = f.read() + src\n        basename = bh.split('.')[0]\n        fname = 'pyjt_' + basename + '.cc'\n        fname = os.path.join(cache_path, 'gen', fname)\n        check = compile_single(h, fname, src)\n        if not check:\n            continue\n        basenames.append(basename)\n        pyjt_names.append(fname)\n    code = f\"\"\"\\n    #include \"pyjt/py_converter.h\"\\n    #include \"common.h\"\\n\\n    namespace jittor {{\\n\\n    {' '.join([f'extern void pyjt_def_{n}(PyObject* m);' for n in basenames])}\\n\\n    void pyjt_def_all(PyObject* m) {{\\n        {' '.join([f'pyjt_def_{n}(m);' for n in basenames])}\\n    }}\\n\\n    }}\\n    \"\"\"\n    fname = os.path.join(cache_path, 'gen', 'pyjt_all.cc')\n    LOG.vvv(('write to', fname))\n    LOG.vvvv(code)\n    with open(fname, 'w', encoding='utf8') as f:\n        f.write(code)\n    pyjt_names.append(fname)\n    return pyjt_names",
            "def compile(cache_path, jittor_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    headers1 = glob.glob(jittor_path + '/src/**/*.h', recursive=True)\n    headers2 = glob.glob(cache_path + '/gen/**/*.h', recursive=True)\n    headers = headers1 + headers2\n    basenames = []\n    pyjt_names = []\n    for h in headers:\n        with open(h, 'r', encoding='utf8') as f:\n            src = f.read()\n        bh = os.path.basename(h)\n        if bh == 'var_holder.h':\n            continue\n        if bh == 'jit_op_maker.h':\n            with open(os.path.join(jittor_path, 'src', 'var_holder.h'), 'r', encoding='utf8') as f:\n                src = f.read() + src\n        basename = bh.split('.')[0]\n        fname = 'pyjt_' + basename + '.cc'\n        fname = os.path.join(cache_path, 'gen', fname)\n        check = compile_single(h, fname, src)\n        if not check:\n            continue\n        basenames.append(basename)\n        pyjt_names.append(fname)\n    code = f\"\"\"\\n    #include \"pyjt/py_converter.h\"\\n    #include \"common.h\"\\n\\n    namespace jittor {{\\n\\n    {' '.join([f'extern void pyjt_def_{n}(PyObject* m);' for n in basenames])}\\n\\n    void pyjt_def_all(PyObject* m) {{\\n        {' '.join([f'pyjt_def_{n}(m);' for n in basenames])}\\n    }}\\n\\n    }}\\n    \"\"\"\n    fname = os.path.join(cache_path, 'gen', 'pyjt_all.cc')\n    LOG.vvv(('write to', fname))\n    LOG.vvvv(code)\n    with open(fname, 'w', encoding='utf8') as f:\n        f.write(code)\n    pyjt_names.append(fname)\n    return pyjt_names",
            "def compile(cache_path, jittor_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    headers1 = glob.glob(jittor_path + '/src/**/*.h', recursive=True)\n    headers2 = glob.glob(cache_path + '/gen/**/*.h', recursive=True)\n    headers = headers1 + headers2\n    basenames = []\n    pyjt_names = []\n    for h in headers:\n        with open(h, 'r', encoding='utf8') as f:\n            src = f.read()\n        bh = os.path.basename(h)\n        if bh == 'var_holder.h':\n            continue\n        if bh == 'jit_op_maker.h':\n            with open(os.path.join(jittor_path, 'src', 'var_holder.h'), 'r', encoding='utf8') as f:\n                src = f.read() + src\n        basename = bh.split('.')[0]\n        fname = 'pyjt_' + basename + '.cc'\n        fname = os.path.join(cache_path, 'gen', fname)\n        check = compile_single(h, fname, src)\n        if not check:\n            continue\n        basenames.append(basename)\n        pyjt_names.append(fname)\n    code = f\"\"\"\\n    #include \"pyjt/py_converter.h\"\\n    #include \"common.h\"\\n\\n    namespace jittor {{\\n\\n    {' '.join([f'extern void pyjt_def_{n}(PyObject* m);' for n in basenames])}\\n\\n    void pyjt_def_all(PyObject* m) {{\\n        {' '.join([f'pyjt_def_{n}(m);' for n in basenames])}\\n    }}\\n\\n    }}\\n    \"\"\"\n    fname = os.path.join(cache_path, 'gen', 'pyjt_all.cc')\n    LOG.vvv(('write to', fname))\n    LOG.vvvv(code)\n    with open(fname, 'w', encoding='utf8') as f:\n        f.write(code)\n    pyjt_names.append(fname)\n    return pyjt_names",
            "def compile(cache_path, jittor_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    headers1 = glob.glob(jittor_path + '/src/**/*.h', recursive=True)\n    headers2 = glob.glob(cache_path + '/gen/**/*.h', recursive=True)\n    headers = headers1 + headers2\n    basenames = []\n    pyjt_names = []\n    for h in headers:\n        with open(h, 'r', encoding='utf8') as f:\n            src = f.read()\n        bh = os.path.basename(h)\n        if bh == 'var_holder.h':\n            continue\n        if bh == 'jit_op_maker.h':\n            with open(os.path.join(jittor_path, 'src', 'var_holder.h'), 'r', encoding='utf8') as f:\n                src = f.read() + src\n        basename = bh.split('.')[0]\n        fname = 'pyjt_' + basename + '.cc'\n        fname = os.path.join(cache_path, 'gen', fname)\n        check = compile_single(h, fname, src)\n        if not check:\n            continue\n        basenames.append(basename)\n        pyjt_names.append(fname)\n    code = f\"\"\"\\n    #include \"pyjt/py_converter.h\"\\n    #include \"common.h\"\\n\\n    namespace jittor {{\\n\\n    {' '.join([f'extern void pyjt_def_{n}(PyObject* m);' for n in basenames])}\\n\\n    void pyjt_def_all(PyObject* m) {{\\n        {' '.join([f'pyjt_def_{n}(m);' for n in basenames])}\\n    }}\\n\\n    }}\\n    \"\"\"\n    fname = os.path.join(cache_path, 'gen', 'pyjt_all.cc')\n    LOG.vvv(('write to', fname))\n    LOG.vvvv(code)\n    with open(fname, 'w', encoding='utf8') as f:\n        f.write(code)\n    pyjt_names.append(fname)\n    return pyjt_names"
        ]
    }
]