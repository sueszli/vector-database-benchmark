[
    {
        "func_name": "__init__",
        "original": "def __init__(self, hparams, graph, col_spliter='\\t'):\n    \"\"\"Initialize an iterator. Create necessary placeholders for the model.\n        Different from sequential iterator\n\n        Args:\n            hparams (object): Global hyper-parameters. Some key settings such as #_feature and #_field are there.\n            graph (object): The running graph. All created placeholder will be added to this graph.\n            col_spliter (str): Column splitter in one line.\n        \"\"\"\n    self.col_spliter = col_spliter\n    (self.userdict, self.itemdict, self.catedict) = (load_dict(hparams.user_vocab), load_dict(hparams.item_vocab), load_dict(hparams.cate_vocab))\n    self.max_seq_length = hparams.max_seq_length\n    self.batch_size = hparams.batch_size\n    self.iter_data = dict()\n    self.graph = graph\n    with self.graph.as_default():\n        self.labels = tf.compat.v1.placeholder(tf.float32, [None, None], name='label')\n        self.users = tf.compat.v1.placeholder(tf.int32, [None], name='users')\n        self.items = tf.compat.v1.placeholder(tf.int32, [None, None], name='items')\n        self.cates = tf.compat.v1.placeholder(tf.int32, [None, None], name='cates')\n        self.item_history = tf.compat.v1.placeholder(tf.int32, [None, self.max_seq_length], name='item_history')\n        self.item_cate_history = tf.compat.v1.placeholder(tf.int32, [None, self.max_seq_length], name='item_cate_history')\n        self.mask = tf.compat.v1.placeholder(tf.int32, [None, self.max_seq_length], name='mask')\n        self.time = tf.compat.v1.placeholder(tf.float32, [None], name='time')\n        self.time_diff = tf.compat.v1.placeholder(tf.float32, [None, self.max_seq_length], name='time_diff')\n        self.time_from_first_action = tf.compat.v1.placeholder(tf.float32, [None, self.max_seq_length], name='time_from_first_action')\n        self.time_to_now = tf.compat.v1.placeholder(tf.float32, [None, self.max_seq_length], name='time_to_now')",
        "mutated": [
            "def __init__(self, hparams, graph, col_spliter='\\t'):\n    if False:\n        i = 10\n    'Initialize an iterator. Create necessary placeholders for the model.\\n        Different from sequential iterator\\n\\n        Args:\\n            hparams (object): Global hyper-parameters. Some key settings such as #_feature and #_field are there.\\n            graph (object): The running graph. All created placeholder will be added to this graph.\\n            col_spliter (str): Column splitter in one line.\\n        '\n    self.col_spliter = col_spliter\n    (self.userdict, self.itemdict, self.catedict) = (load_dict(hparams.user_vocab), load_dict(hparams.item_vocab), load_dict(hparams.cate_vocab))\n    self.max_seq_length = hparams.max_seq_length\n    self.batch_size = hparams.batch_size\n    self.iter_data = dict()\n    self.graph = graph\n    with self.graph.as_default():\n        self.labels = tf.compat.v1.placeholder(tf.float32, [None, None], name='label')\n        self.users = tf.compat.v1.placeholder(tf.int32, [None], name='users')\n        self.items = tf.compat.v1.placeholder(tf.int32, [None, None], name='items')\n        self.cates = tf.compat.v1.placeholder(tf.int32, [None, None], name='cates')\n        self.item_history = tf.compat.v1.placeholder(tf.int32, [None, self.max_seq_length], name='item_history')\n        self.item_cate_history = tf.compat.v1.placeholder(tf.int32, [None, self.max_seq_length], name='item_cate_history')\n        self.mask = tf.compat.v1.placeholder(tf.int32, [None, self.max_seq_length], name='mask')\n        self.time = tf.compat.v1.placeholder(tf.float32, [None], name='time')\n        self.time_diff = tf.compat.v1.placeholder(tf.float32, [None, self.max_seq_length], name='time_diff')\n        self.time_from_first_action = tf.compat.v1.placeholder(tf.float32, [None, self.max_seq_length], name='time_from_first_action')\n        self.time_to_now = tf.compat.v1.placeholder(tf.float32, [None, self.max_seq_length], name='time_to_now')",
            "def __init__(self, hparams, graph, col_spliter='\\t'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Initialize an iterator. Create necessary placeholders for the model.\\n        Different from sequential iterator\\n\\n        Args:\\n            hparams (object): Global hyper-parameters. Some key settings such as #_feature and #_field are there.\\n            graph (object): The running graph. All created placeholder will be added to this graph.\\n            col_spliter (str): Column splitter in one line.\\n        '\n    self.col_spliter = col_spliter\n    (self.userdict, self.itemdict, self.catedict) = (load_dict(hparams.user_vocab), load_dict(hparams.item_vocab), load_dict(hparams.cate_vocab))\n    self.max_seq_length = hparams.max_seq_length\n    self.batch_size = hparams.batch_size\n    self.iter_data = dict()\n    self.graph = graph\n    with self.graph.as_default():\n        self.labels = tf.compat.v1.placeholder(tf.float32, [None, None], name='label')\n        self.users = tf.compat.v1.placeholder(tf.int32, [None], name='users')\n        self.items = tf.compat.v1.placeholder(tf.int32, [None, None], name='items')\n        self.cates = tf.compat.v1.placeholder(tf.int32, [None, None], name='cates')\n        self.item_history = tf.compat.v1.placeholder(tf.int32, [None, self.max_seq_length], name='item_history')\n        self.item_cate_history = tf.compat.v1.placeholder(tf.int32, [None, self.max_seq_length], name='item_cate_history')\n        self.mask = tf.compat.v1.placeholder(tf.int32, [None, self.max_seq_length], name='mask')\n        self.time = tf.compat.v1.placeholder(tf.float32, [None], name='time')\n        self.time_diff = tf.compat.v1.placeholder(tf.float32, [None, self.max_seq_length], name='time_diff')\n        self.time_from_first_action = tf.compat.v1.placeholder(tf.float32, [None, self.max_seq_length], name='time_from_first_action')\n        self.time_to_now = tf.compat.v1.placeholder(tf.float32, [None, self.max_seq_length], name='time_to_now')",
            "def __init__(self, hparams, graph, col_spliter='\\t'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Initialize an iterator. Create necessary placeholders for the model.\\n        Different from sequential iterator\\n\\n        Args:\\n            hparams (object): Global hyper-parameters. Some key settings such as #_feature and #_field are there.\\n            graph (object): The running graph. All created placeholder will be added to this graph.\\n            col_spliter (str): Column splitter in one line.\\n        '\n    self.col_spliter = col_spliter\n    (self.userdict, self.itemdict, self.catedict) = (load_dict(hparams.user_vocab), load_dict(hparams.item_vocab), load_dict(hparams.cate_vocab))\n    self.max_seq_length = hparams.max_seq_length\n    self.batch_size = hparams.batch_size\n    self.iter_data = dict()\n    self.graph = graph\n    with self.graph.as_default():\n        self.labels = tf.compat.v1.placeholder(tf.float32, [None, None], name='label')\n        self.users = tf.compat.v1.placeholder(tf.int32, [None], name='users')\n        self.items = tf.compat.v1.placeholder(tf.int32, [None, None], name='items')\n        self.cates = tf.compat.v1.placeholder(tf.int32, [None, None], name='cates')\n        self.item_history = tf.compat.v1.placeholder(tf.int32, [None, self.max_seq_length], name='item_history')\n        self.item_cate_history = tf.compat.v1.placeholder(tf.int32, [None, self.max_seq_length], name='item_cate_history')\n        self.mask = tf.compat.v1.placeholder(tf.int32, [None, self.max_seq_length], name='mask')\n        self.time = tf.compat.v1.placeholder(tf.float32, [None], name='time')\n        self.time_diff = tf.compat.v1.placeholder(tf.float32, [None, self.max_seq_length], name='time_diff')\n        self.time_from_first_action = tf.compat.v1.placeholder(tf.float32, [None, self.max_seq_length], name='time_from_first_action')\n        self.time_to_now = tf.compat.v1.placeholder(tf.float32, [None, self.max_seq_length], name='time_to_now')",
            "def __init__(self, hparams, graph, col_spliter='\\t'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Initialize an iterator. Create necessary placeholders for the model.\\n        Different from sequential iterator\\n\\n        Args:\\n            hparams (object): Global hyper-parameters. Some key settings such as #_feature and #_field are there.\\n            graph (object): The running graph. All created placeholder will be added to this graph.\\n            col_spliter (str): Column splitter in one line.\\n        '\n    self.col_spliter = col_spliter\n    (self.userdict, self.itemdict, self.catedict) = (load_dict(hparams.user_vocab), load_dict(hparams.item_vocab), load_dict(hparams.cate_vocab))\n    self.max_seq_length = hparams.max_seq_length\n    self.batch_size = hparams.batch_size\n    self.iter_data = dict()\n    self.graph = graph\n    with self.graph.as_default():\n        self.labels = tf.compat.v1.placeholder(tf.float32, [None, None], name='label')\n        self.users = tf.compat.v1.placeholder(tf.int32, [None], name='users')\n        self.items = tf.compat.v1.placeholder(tf.int32, [None, None], name='items')\n        self.cates = tf.compat.v1.placeholder(tf.int32, [None, None], name='cates')\n        self.item_history = tf.compat.v1.placeholder(tf.int32, [None, self.max_seq_length], name='item_history')\n        self.item_cate_history = tf.compat.v1.placeholder(tf.int32, [None, self.max_seq_length], name='item_cate_history')\n        self.mask = tf.compat.v1.placeholder(tf.int32, [None, self.max_seq_length], name='mask')\n        self.time = tf.compat.v1.placeholder(tf.float32, [None], name='time')\n        self.time_diff = tf.compat.v1.placeholder(tf.float32, [None, self.max_seq_length], name='time_diff')\n        self.time_from_first_action = tf.compat.v1.placeholder(tf.float32, [None, self.max_seq_length], name='time_from_first_action')\n        self.time_to_now = tf.compat.v1.placeholder(tf.float32, [None, self.max_seq_length], name='time_to_now')",
            "def __init__(self, hparams, graph, col_spliter='\\t'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Initialize an iterator. Create necessary placeholders for the model.\\n        Different from sequential iterator\\n\\n        Args:\\n            hparams (object): Global hyper-parameters. Some key settings such as #_feature and #_field are there.\\n            graph (object): The running graph. All created placeholder will be added to this graph.\\n            col_spliter (str): Column splitter in one line.\\n        '\n    self.col_spliter = col_spliter\n    (self.userdict, self.itemdict, self.catedict) = (load_dict(hparams.user_vocab), load_dict(hparams.item_vocab), load_dict(hparams.cate_vocab))\n    self.max_seq_length = hparams.max_seq_length\n    self.batch_size = hparams.batch_size\n    self.iter_data = dict()\n    self.graph = graph\n    with self.graph.as_default():\n        self.labels = tf.compat.v1.placeholder(tf.float32, [None, None], name='label')\n        self.users = tf.compat.v1.placeholder(tf.int32, [None], name='users')\n        self.items = tf.compat.v1.placeholder(tf.int32, [None, None], name='items')\n        self.cates = tf.compat.v1.placeholder(tf.int32, [None, None], name='cates')\n        self.item_history = tf.compat.v1.placeholder(tf.int32, [None, self.max_seq_length], name='item_history')\n        self.item_cate_history = tf.compat.v1.placeholder(tf.int32, [None, self.max_seq_length], name='item_cate_history')\n        self.mask = tf.compat.v1.placeholder(tf.int32, [None, self.max_seq_length], name='mask')\n        self.time = tf.compat.v1.placeholder(tf.float32, [None], name='time')\n        self.time_diff = tf.compat.v1.placeholder(tf.float32, [None, self.max_seq_length], name='time_diff')\n        self.time_from_first_action = tf.compat.v1.placeholder(tf.float32, [None, self.max_seq_length], name='time_from_first_action')\n        self.time_to_now = tf.compat.v1.placeholder(tf.float32, [None, self.max_seq_length], name='time_to_now')"
        ]
    },
    {
        "func_name": "_convert_data",
        "original": "def _convert_data(self, label_list, user_list, item_list, item_cate_list, item_history_batch, item_cate_history_batch, time_list, time_diff_list, time_from_first_action_list, time_to_now_list, batch_num_ngs):\n    \"\"\"Convert data into numpy arrays that are good for further model operation.\n        Note: This is different from `sequential_iterator`.\n\n        Args:\n            label_list (list): A list of ground-truth labels.\n            user_list (list): A list of user indexes.\n            item_list (list): A list of item indexes.\n            item_cate_list (list): A list of category indexes.\n            item_history_batch (list): A list of item history indexes.\n            item_cate_history_batch (list): A list of category history indexes.\n            time_list (list): A list of current timestamp.\n            time_diff_list (list): A list of timestamp between each sequential opertions.\n            time_from_first_action_list (list): A list of timestamp from the first opertion.\n            time_to_now_list (list): A list of timestamp to the current time.\n            batch_num_ngs (int): The number of negative sampling while training in mini-batch.\n\n        Returns:\n            dict: A dictionary, contains multiple numpy arrays that are convenient for further operation.\n        \"\"\"\n    if batch_num_ngs:\n        instance_cnt = len(label_list)\n        if instance_cnt < 5:\n            return\n        label_list_all = []\n        item_list_all = []\n        item_cate_list_all = []\n        user_list_all = np.asarray([[user] * (batch_num_ngs + 1) for user in user_list], dtype=np.int32).flatten()\n        time_list_all = np.asarray([[t] * (batch_num_ngs + 1) for t in time_list], dtype=np.float32).flatten()\n        history_lengths = [len(item_history_batch[i]) for i in range(instance_cnt)]\n        max_seq_length_batch = self.max_seq_length\n        item_history_batch_all = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.int32)\n        item_cate_history_batch_all = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.int32)\n        time_diff_batch = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.float32)\n        time_from_first_action_batch = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.float32)\n        time_to_now_batch = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.float32)\n        mask = np.zeros((instance_cnt * (1 + batch_num_ngs), max_seq_length_batch), dtype=np.float32)\n        for i in range(instance_cnt):\n            this_length = min(history_lengths[i], max_seq_length_batch)\n            for index in range(batch_num_ngs + 1):\n                item_history_batch_all[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(item_history_batch[i][-this_length:], dtype=np.int32)\n                item_cate_history_batch_all[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(item_cate_history_batch[i][-this_length:], dtype=np.int32)\n                mask[i * (batch_num_ngs + 1) + index, -this_length:] = 1.0\n                time_diff_batch[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(time_diff_list[i][-this_length:], dtype=np.float32)\n                time_from_first_action_batch[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(time_from_first_action_list[i][-this_length:], dtype=np.float32)\n                time_to_now_batch[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(time_to_now_list[i][-this_length:], dtype=np.float32)\n        for i in range(instance_cnt):\n            positive_item = [*item_history_batch_all[i * (batch_num_ngs + 1)][1:], item_list[i]]\n            positive_item_cate = [*item_cate_history_batch_all[i * (batch_num_ngs + 1)][1:], item_cate_list[i]]\n            label_list_all.append([1] * max_seq_length_batch)\n            item_list_all.append(positive_item)\n            item_cate_list_all.append(positive_item_cate)\n            count = 0\n            while count < batch_num_ngs:\n                negative_item_list = []\n                negative_item_cate_list = []\n                count_inner = 1\n                while count_inner <= max_seq_length_batch:\n                    random_value = random.randint(0, instance_cnt - 1)\n                    negative_item = item_list[random_value]\n                    if negative_item == positive_item[count_inner - 1]:\n                        continue\n                    negative_item_list.append(negative_item)\n                    negative_item_cate_list.append(item_cate_list[random_value])\n                    count_inner += 1\n                label_list_all.append([0] * max_seq_length_batch)\n                item_list_all.append(negative_item_list)\n                item_cate_list_all.append(negative_item_cate_list)\n                count += 1\n        res = {}\n        res['labels'] = np.asarray(label_list_all, dtype=np.float32)\n        res['users'] = user_list_all\n        res['items'] = np.asarray(item_list_all, dtype=np.int32)\n        res['cates'] = np.asarray(item_cate_list_all, dtype=np.int32)\n        res['item_history'] = item_history_batch_all\n        res['item_cate_history'] = item_cate_history_batch_all\n        res['mask'] = mask\n        res['time'] = time_list_all\n        res['time_diff'] = time_diff_batch\n        res['time_from_first_action'] = time_from_first_action_batch\n        res['time_to_now'] = time_to_now_batch\n        return res\n    else:\n        instance_cnt = len(label_list)\n        history_lengths = [len(item_history_batch[i]) for i in range(instance_cnt)]\n        max_seq_length_batch = self.max_seq_length\n        item_history_batch_all = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.int32)\n        item_cate_history_batch_all = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.int32)\n        time_diff_batch = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.float32)\n        time_from_first_action_batch = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.float32)\n        time_to_now_batch = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.float32)\n        mask = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.float32)\n        for i in range(instance_cnt):\n            this_length = min(history_lengths[i], max_seq_length_batch)\n            item_history_batch_all[i, -this_length:] = item_history_batch[i][-this_length:]\n            item_cate_history_batch_all[i, -this_length:] = item_cate_history_batch[i][-this_length:]\n            mask[i, -this_length:] = 1.0\n            time_diff_batch[i, -this_length:] = time_diff_list[i][-this_length:]\n            time_from_first_action_batch[i, -this_length:] = time_from_first_action_list[i][-this_length:]\n            time_to_now_batch[i, -this_length:] = time_to_now_list[i][-this_length:]\n        res = {}\n        res['labels'] = np.asarray(label_list, dtype=np.float32).reshape([-1, 1])\n        res['users'] = np.asarray(user_list, dtype=np.float32)\n        res['items'] = np.asarray(item_list, dtype=np.int32).reshape([-1, 1])\n        res['cates'] = np.asarray(item_cate_list, dtype=np.int32).reshape([-1, 1])\n        res['item_history'] = item_history_batch_all\n        res['item_cate_history'] = item_cate_history_batch_all\n        res['mask'] = mask\n        res['time'] = np.asarray(time_list, dtype=np.float32)\n        res['time_diff'] = time_diff_batch\n        res['time_from_first_action'] = time_from_first_action_batch\n        res['time_to_now'] = time_to_now_batch\n        return res",
        "mutated": [
            "def _convert_data(self, label_list, user_list, item_list, item_cate_list, item_history_batch, item_cate_history_batch, time_list, time_diff_list, time_from_first_action_list, time_to_now_list, batch_num_ngs):\n    if False:\n        i = 10\n    'Convert data into numpy arrays that are good for further model operation.\\n        Note: This is different from `sequential_iterator`.\\n\\n        Args:\\n            label_list (list): A list of ground-truth labels.\\n            user_list (list): A list of user indexes.\\n            item_list (list): A list of item indexes.\\n            item_cate_list (list): A list of category indexes.\\n            item_history_batch (list): A list of item history indexes.\\n            item_cate_history_batch (list): A list of category history indexes.\\n            time_list (list): A list of current timestamp.\\n            time_diff_list (list): A list of timestamp between each sequential opertions.\\n            time_from_first_action_list (list): A list of timestamp from the first opertion.\\n            time_to_now_list (list): A list of timestamp to the current time.\\n            batch_num_ngs (int): The number of negative sampling while training in mini-batch.\\n\\n        Returns:\\n            dict: A dictionary, contains multiple numpy arrays that are convenient for further operation.\\n        '\n    if batch_num_ngs:\n        instance_cnt = len(label_list)\n        if instance_cnt < 5:\n            return\n        label_list_all = []\n        item_list_all = []\n        item_cate_list_all = []\n        user_list_all = np.asarray([[user] * (batch_num_ngs + 1) for user in user_list], dtype=np.int32).flatten()\n        time_list_all = np.asarray([[t] * (batch_num_ngs + 1) for t in time_list], dtype=np.float32).flatten()\n        history_lengths = [len(item_history_batch[i]) for i in range(instance_cnt)]\n        max_seq_length_batch = self.max_seq_length\n        item_history_batch_all = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.int32)\n        item_cate_history_batch_all = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.int32)\n        time_diff_batch = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.float32)\n        time_from_first_action_batch = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.float32)\n        time_to_now_batch = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.float32)\n        mask = np.zeros((instance_cnt * (1 + batch_num_ngs), max_seq_length_batch), dtype=np.float32)\n        for i in range(instance_cnt):\n            this_length = min(history_lengths[i], max_seq_length_batch)\n            for index in range(batch_num_ngs + 1):\n                item_history_batch_all[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(item_history_batch[i][-this_length:], dtype=np.int32)\n                item_cate_history_batch_all[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(item_cate_history_batch[i][-this_length:], dtype=np.int32)\n                mask[i * (batch_num_ngs + 1) + index, -this_length:] = 1.0\n                time_diff_batch[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(time_diff_list[i][-this_length:], dtype=np.float32)\n                time_from_first_action_batch[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(time_from_first_action_list[i][-this_length:], dtype=np.float32)\n                time_to_now_batch[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(time_to_now_list[i][-this_length:], dtype=np.float32)\n        for i in range(instance_cnt):\n            positive_item = [*item_history_batch_all[i * (batch_num_ngs + 1)][1:], item_list[i]]\n            positive_item_cate = [*item_cate_history_batch_all[i * (batch_num_ngs + 1)][1:], item_cate_list[i]]\n            label_list_all.append([1] * max_seq_length_batch)\n            item_list_all.append(positive_item)\n            item_cate_list_all.append(positive_item_cate)\n            count = 0\n            while count < batch_num_ngs:\n                negative_item_list = []\n                negative_item_cate_list = []\n                count_inner = 1\n                while count_inner <= max_seq_length_batch:\n                    random_value = random.randint(0, instance_cnt - 1)\n                    negative_item = item_list[random_value]\n                    if negative_item == positive_item[count_inner - 1]:\n                        continue\n                    negative_item_list.append(negative_item)\n                    negative_item_cate_list.append(item_cate_list[random_value])\n                    count_inner += 1\n                label_list_all.append([0] * max_seq_length_batch)\n                item_list_all.append(negative_item_list)\n                item_cate_list_all.append(negative_item_cate_list)\n                count += 1\n        res = {}\n        res['labels'] = np.asarray(label_list_all, dtype=np.float32)\n        res['users'] = user_list_all\n        res['items'] = np.asarray(item_list_all, dtype=np.int32)\n        res['cates'] = np.asarray(item_cate_list_all, dtype=np.int32)\n        res['item_history'] = item_history_batch_all\n        res['item_cate_history'] = item_cate_history_batch_all\n        res['mask'] = mask\n        res['time'] = time_list_all\n        res['time_diff'] = time_diff_batch\n        res['time_from_first_action'] = time_from_first_action_batch\n        res['time_to_now'] = time_to_now_batch\n        return res\n    else:\n        instance_cnt = len(label_list)\n        history_lengths = [len(item_history_batch[i]) for i in range(instance_cnt)]\n        max_seq_length_batch = self.max_seq_length\n        item_history_batch_all = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.int32)\n        item_cate_history_batch_all = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.int32)\n        time_diff_batch = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.float32)\n        time_from_first_action_batch = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.float32)\n        time_to_now_batch = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.float32)\n        mask = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.float32)\n        for i in range(instance_cnt):\n            this_length = min(history_lengths[i], max_seq_length_batch)\n            item_history_batch_all[i, -this_length:] = item_history_batch[i][-this_length:]\n            item_cate_history_batch_all[i, -this_length:] = item_cate_history_batch[i][-this_length:]\n            mask[i, -this_length:] = 1.0\n            time_diff_batch[i, -this_length:] = time_diff_list[i][-this_length:]\n            time_from_first_action_batch[i, -this_length:] = time_from_first_action_list[i][-this_length:]\n            time_to_now_batch[i, -this_length:] = time_to_now_list[i][-this_length:]\n        res = {}\n        res['labels'] = np.asarray(label_list, dtype=np.float32).reshape([-1, 1])\n        res['users'] = np.asarray(user_list, dtype=np.float32)\n        res['items'] = np.asarray(item_list, dtype=np.int32).reshape([-1, 1])\n        res['cates'] = np.asarray(item_cate_list, dtype=np.int32).reshape([-1, 1])\n        res['item_history'] = item_history_batch_all\n        res['item_cate_history'] = item_cate_history_batch_all\n        res['mask'] = mask\n        res['time'] = np.asarray(time_list, dtype=np.float32)\n        res['time_diff'] = time_diff_batch\n        res['time_from_first_action'] = time_from_first_action_batch\n        res['time_to_now'] = time_to_now_batch\n        return res",
            "def _convert_data(self, label_list, user_list, item_list, item_cate_list, item_history_batch, item_cate_history_batch, time_list, time_diff_list, time_from_first_action_list, time_to_now_list, batch_num_ngs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Convert data into numpy arrays that are good for further model operation.\\n        Note: This is different from `sequential_iterator`.\\n\\n        Args:\\n            label_list (list): A list of ground-truth labels.\\n            user_list (list): A list of user indexes.\\n            item_list (list): A list of item indexes.\\n            item_cate_list (list): A list of category indexes.\\n            item_history_batch (list): A list of item history indexes.\\n            item_cate_history_batch (list): A list of category history indexes.\\n            time_list (list): A list of current timestamp.\\n            time_diff_list (list): A list of timestamp between each sequential opertions.\\n            time_from_first_action_list (list): A list of timestamp from the first opertion.\\n            time_to_now_list (list): A list of timestamp to the current time.\\n            batch_num_ngs (int): The number of negative sampling while training in mini-batch.\\n\\n        Returns:\\n            dict: A dictionary, contains multiple numpy arrays that are convenient for further operation.\\n        '\n    if batch_num_ngs:\n        instance_cnt = len(label_list)\n        if instance_cnt < 5:\n            return\n        label_list_all = []\n        item_list_all = []\n        item_cate_list_all = []\n        user_list_all = np.asarray([[user] * (batch_num_ngs + 1) for user in user_list], dtype=np.int32).flatten()\n        time_list_all = np.asarray([[t] * (batch_num_ngs + 1) for t in time_list], dtype=np.float32).flatten()\n        history_lengths = [len(item_history_batch[i]) for i in range(instance_cnt)]\n        max_seq_length_batch = self.max_seq_length\n        item_history_batch_all = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.int32)\n        item_cate_history_batch_all = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.int32)\n        time_diff_batch = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.float32)\n        time_from_first_action_batch = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.float32)\n        time_to_now_batch = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.float32)\n        mask = np.zeros((instance_cnt * (1 + batch_num_ngs), max_seq_length_batch), dtype=np.float32)\n        for i in range(instance_cnt):\n            this_length = min(history_lengths[i], max_seq_length_batch)\n            for index in range(batch_num_ngs + 1):\n                item_history_batch_all[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(item_history_batch[i][-this_length:], dtype=np.int32)\n                item_cate_history_batch_all[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(item_cate_history_batch[i][-this_length:], dtype=np.int32)\n                mask[i * (batch_num_ngs + 1) + index, -this_length:] = 1.0\n                time_diff_batch[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(time_diff_list[i][-this_length:], dtype=np.float32)\n                time_from_first_action_batch[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(time_from_first_action_list[i][-this_length:], dtype=np.float32)\n                time_to_now_batch[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(time_to_now_list[i][-this_length:], dtype=np.float32)\n        for i in range(instance_cnt):\n            positive_item = [*item_history_batch_all[i * (batch_num_ngs + 1)][1:], item_list[i]]\n            positive_item_cate = [*item_cate_history_batch_all[i * (batch_num_ngs + 1)][1:], item_cate_list[i]]\n            label_list_all.append([1] * max_seq_length_batch)\n            item_list_all.append(positive_item)\n            item_cate_list_all.append(positive_item_cate)\n            count = 0\n            while count < batch_num_ngs:\n                negative_item_list = []\n                negative_item_cate_list = []\n                count_inner = 1\n                while count_inner <= max_seq_length_batch:\n                    random_value = random.randint(0, instance_cnt - 1)\n                    negative_item = item_list[random_value]\n                    if negative_item == positive_item[count_inner - 1]:\n                        continue\n                    negative_item_list.append(negative_item)\n                    negative_item_cate_list.append(item_cate_list[random_value])\n                    count_inner += 1\n                label_list_all.append([0] * max_seq_length_batch)\n                item_list_all.append(negative_item_list)\n                item_cate_list_all.append(negative_item_cate_list)\n                count += 1\n        res = {}\n        res['labels'] = np.asarray(label_list_all, dtype=np.float32)\n        res['users'] = user_list_all\n        res['items'] = np.asarray(item_list_all, dtype=np.int32)\n        res['cates'] = np.asarray(item_cate_list_all, dtype=np.int32)\n        res['item_history'] = item_history_batch_all\n        res['item_cate_history'] = item_cate_history_batch_all\n        res['mask'] = mask\n        res['time'] = time_list_all\n        res['time_diff'] = time_diff_batch\n        res['time_from_first_action'] = time_from_first_action_batch\n        res['time_to_now'] = time_to_now_batch\n        return res\n    else:\n        instance_cnt = len(label_list)\n        history_lengths = [len(item_history_batch[i]) for i in range(instance_cnt)]\n        max_seq_length_batch = self.max_seq_length\n        item_history_batch_all = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.int32)\n        item_cate_history_batch_all = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.int32)\n        time_diff_batch = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.float32)\n        time_from_first_action_batch = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.float32)\n        time_to_now_batch = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.float32)\n        mask = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.float32)\n        for i in range(instance_cnt):\n            this_length = min(history_lengths[i], max_seq_length_batch)\n            item_history_batch_all[i, -this_length:] = item_history_batch[i][-this_length:]\n            item_cate_history_batch_all[i, -this_length:] = item_cate_history_batch[i][-this_length:]\n            mask[i, -this_length:] = 1.0\n            time_diff_batch[i, -this_length:] = time_diff_list[i][-this_length:]\n            time_from_first_action_batch[i, -this_length:] = time_from_first_action_list[i][-this_length:]\n            time_to_now_batch[i, -this_length:] = time_to_now_list[i][-this_length:]\n        res = {}\n        res['labels'] = np.asarray(label_list, dtype=np.float32).reshape([-1, 1])\n        res['users'] = np.asarray(user_list, dtype=np.float32)\n        res['items'] = np.asarray(item_list, dtype=np.int32).reshape([-1, 1])\n        res['cates'] = np.asarray(item_cate_list, dtype=np.int32).reshape([-1, 1])\n        res['item_history'] = item_history_batch_all\n        res['item_cate_history'] = item_cate_history_batch_all\n        res['mask'] = mask\n        res['time'] = np.asarray(time_list, dtype=np.float32)\n        res['time_diff'] = time_diff_batch\n        res['time_from_first_action'] = time_from_first_action_batch\n        res['time_to_now'] = time_to_now_batch\n        return res",
            "def _convert_data(self, label_list, user_list, item_list, item_cate_list, item_history_batch, item_cate_history_batch, time_list, time_diff_list, time_from_first_action_list, time_to_now_list, batch_num_ngs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Convert data into numpy arrays that are good for further model operation.\\n        Note: This is different from `sequential_iterator`.\\n\\n        Args:\\n            label_list (list): A list of ground-truth labels.\\n            user_list (list): A list of user indexes.\\n            item_list (list): A list of item indexes.\\n            item_cate_list (list): A list of category indexes.\\n            item_history_batch (list): A list of item history indexes.\\n            item_cate_history_batch (list): A list of category history indexes.\\n            time_list (list): A list of current timestamp.\\n            time_diff_list (list): A list of timestamp between each sequential opertions.\\n            time_from_first_action_list (list): A list of timestamp from the first opertion.\\n            time_to_now_list (list): A list of timestamp to the current time.\\n            batch_num_ngs (int): The number of negative sampling while training in mini-batch.\\n\\n        Returns:\\n            dict: A dictionary, contains multiple numpy arrays that are convenient for further operation.\\n        '\n    if batch_num_ngs:\n        instance_cnt = len(label_list)\n        if instance_cnt < 5:\n            return\n        label_list_all = []\n        item_list_all = []\n        item_cate_list_all = []\n        user_list_all = np.asarray([[user] * (batch_num_ngs + 1) for user in user_list], dtype=np.int32).flatten()\n        time_list_all = np.asarray([[t] * (batch_num_ngs + 1) for t in time_list], dtype=np.float32).flatten()\n        history_lengths = [len(item_history_batch[i]) for i in range(instance_cnt)]\n        max_seq_length_batch = self.max_seq_length\n        item_history_batch_all = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.int32)\n        item_cate_history_batch_all = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.int32)\n        time_diff_batch = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.float32)\n        time_from_first_action_batch = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.float32)\n        time_to_now_batch = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.float32)\n        mask = np.zeros((instance_cnt * (1 + batch_num_ngs), max_seq_length_batch), dtype=np.float32)\n        for i in range(instance_cnt):\n            this_length = min(history_lengths[i], max_seq_length_batch)\n            for index in range(batch_num_ngs + 1):\n                item_history_batch_all[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(item_history_batch[i][-this_length:], dtype=np.int32)\n                item_cate_history_batch_all[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(item_cate_history_batch[i][-this_length:], dtype=np.int32)\n                mask[i * (batch_num_ngs + 1) + index, -this_length:] = 1.0\n                time_diff_batch[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(time_diff_list[i][-this_length:], dtype=np.float32)\n                time_from_first_action_batch[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(time_from_first_action_list[i][-this_length:], dtype=np.float32)\n                time_to_now_batch[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(time_to_now_list[i][-this_length:], dtype=np.float32)\n        for i in range(instance_cnt):\n            positive_item = [*item_history_batch_all[i * (batch_num_ngs + 1)][1:], item_list[i]]\n            positive_item_cate = [*item_cate_history_batch_all[i * (batch_num_ngs + 1)][1:], item_cate_list[i]]\n            label_list_all.append([1] * max_seq_length_batch)\n            item_list_all.append(positive_item)\n            item_cate_list_all.append(positive_item_cate)\n            count = 0\n            while count < batch_num_ngs:\n                negative_item_list = []\n                negative_item_cate_list = []\n                count_inner = 1\n                while count_inner <= max_seq_length_batch:\n                    random_value = random.randint(0, instance_cnt - 1)\n                    negative_item = item_list[random_value]\n                    if negative_item == positive_item[count_inner - 1]:\n                        continue\n                    negative_item_list.append(negative_item)\n                    negative_item_cate_list.append(item_cate_list[random_value])\n                    count_inner += 1\n                label_list_all.append([0] * max_seq_length_batch)\n                item_list_all.append(negative_item_list)\n                item_cate_list_all.append(negative_item_cate_list)\n                count += 1\n        res = {}\n        res['labels'] = np.asarray(label_list_all, dtype=np.float32)\n        res['users'] = user_list_all\n        res['items'] = np.asarray(item_list_all, dtype=np.int32)\n        res['cates'] = np.asarray(item_cate_list_all, dtype=np.int32)\n        res['item_history'] = item_history_batch_all\n        res['item_cate_history'] = item_cate_history_batch_all\n        res['mask'] = mask\n        res['time'] = time_list_all\n        res['time_diff'] = time_diff_batch\n        res['time_from_first_action'] = time_from_first_action_batch\n        res['time_to_now'] = time_to_now_batch\n        return res\n    else:\n        instance_cnt = len(label_list)\n        history_lengths = [len(item_history_batch[i]) for i in range(instance_cnt)]\n        max_seq_length_batch = self.max_seq_length\n        item_history_batch_all = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.int32)\n        item_cate_history_batch_all = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.int32)\n        time_diff_batch = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.float32)\n        time_from_first_action_batch = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.float32)\n        time_to_now_batch = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.float32)\n        mask = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.float32)\n        for i in range(instance_cnt):\n            this_length = min(history_lengths[i], max_seq_length_batch)\n            item_history_batch_all[i, -this_length:] = item_history_batch[i][-this_length:]\n            item_cate_history_batch_all[i, -this_length:] = item_cate_history_batch[i][-this_length:]\n            mask[i, -this_length:] = 1.0\n            time_diff_batch[i, -this_length:] = time_diff_list[i][-this_length:]\n            time_from_first_action_batch[i, -this_length:] = time_from_first_action_list[i][-this_length:]\n            time_to_now_batch[i, -this_length:] = time_to_now_list[i][-this_length:]\n        res = {}\n        res['labels'] = np.asarray(label_list, dtype=np.float32).reshape([-1, 1])\n        res['users'] = np.asarray(user_list, dtype=np.float32)\n        res['items'] = np.asarray(item_list, dtype=np.int32).reshape([-1, 1])\n        res['cates'] = np.asarray(item_cate_list, dtype=np.int32).reshape([-1, 1])\n        res['item_history'] = item_history_batch_all\n        res['item_cate_history'] = item_cate_history_batch_all\n        res['mask'] = mask\n        res['time'] = np.asarray(time_list, dtype=np.float32)\n        res['time_diff'] = time_diff_batch\n        res['time_from_first_action'] = time_from_first_action_batch\n        res['time_to_now'] = time_to_now_batch\n        return res",
            "def _convert_data(self, label_list, user_list, item_list, item_cate_list, item_history_batch, item_cate_history_batch, time_list, time_diff_list, time_from_first_action_list, time_to_now_list, batch_num_ngs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Convert data into numpy arrays that are good for further model operation.\\n        Note: This is different from `sequential_iterator`.\\n\\n        Args:\\n            label_list (list): A list of ground-truth labels.\\n            user_list (list): A list of user indexes.\\n            item_list (list): A list of item indexes.\\n            item_cate_list (list): A list of category indexes.\\n            item_history_batch (list): A list of item history indexes.\\n            item_cate_history_batch (list): A list of category history indexes.\\n            time_list (list): A list of current timestamp.\\n            time_diff_list (list): A list of timestamp between each sequential opertions.\\n            time_from_first_action_list (list): A list of timestamp from the first opertion.\\n            time_to_now_list (list): A list of timestamp to the current time.\\n            batch_num_ngs (int): The number of negative sampling while training in mini-batch.\\n\\n        Returns:\\n            dict: A dictionary, contains multiple numpy arrays that are convenient for further operation.\\n        '\n    if batch_num_ngs:\n        instance_cnt = len(label_list)\n        if instance_cnt < 5:\n            return\n        label_list_all = []\n        item_list_all = []\n        item_cate_list_all = []\n        user_list_all = np.asarray([[user] * (batch_num_ngs + 1) for user in user_list], dtype=np.int32).flatten()\n        time_list_all = np.asarray([[t] * (batch_num_ngs + 1) for t in time_list], dtype=np.float32).flatten()\n        history_lengths = [len(item_history_batch[i]) for i in range(instance_cnt)]\n        max_seq_length_batch = self.max_seq_length\n        item_history_batch_all = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.int32)\n        item_cate_history_batch_all = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.int32)\n        time_diff_batch = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.float32)\n        time_from_first_action_batch = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.float32)\n        time_to_now_batch = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.float32)\n        mask = np.zeros((instance_cnt * (1 + batch_num_ngs), max_seq_length_batch), dtype=np.float32)\n        for i in range(instance_cnt):\n            this_length = min(history_lengths[i], max_seq_length_batch)\n            for index in range(batch_num_ngs + 1):\n                item_history_batch_all[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(item_history_batch[i][-this_length:], dtype=np.int32)\n                item_cate_history_batch_all[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(item_cate_history_batch[i][-this_length:], dtype=np.int32)\n                mask[i * (batch_num_ngs + 1) + index, -this_length:] = 1.0\n                time_diff_batch[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(time_diff_list[i][-this_length:], dtype=np.float32)\n                time_from_first_action_batch[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(time_from_first_action_list[i][-this_length:], dtype=np.float32)\n                time_to_now_batch[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(time_to_now_list[i][-this_length:], dtype=np.float32)\n        for i in range(instance_cnt):\n            positive_item = [*item_history_batch_all[i * (batch_num_ngs + 1)][1:], item_list[i]]\n            positive_item_cate = [*item_cate_history_batch_all[i * (batch_num_ngs + 1)][1:], item_cate_list[i]]\n            label_list_all.append([1] * max_seq_length_batch)\n            item_list_all.append(positive_item)\n            item_cate_list_all.append(positive_item_cate)\n            count = 0\n            while count < batch_num_ngs:\n                negative_item_list = []\n                negative_item_cate_list = []\n                count_inner = 1\n                while count_inner <= max_seq_length_batch:\n                    random_value = random.randint(0, instance_cnt - 1)\n                    negative_item = item_list[random_value]\n                    if negative_item == positive_item[count_inner - 1]:\n                        continue\n                    negative_item_list.append(negative_item)\n                    negative_item_cate_list.append(item_cate_list[random_value])\n                    count_inner += 1\n                label_list_all.append([0] * max_seq_length_batch)\n                item_list_all.append(negative_item_list)\n                item_cate_list_all.append(negative_item_cate_list)\n                count += 1\n        res = {}\n        res['labels'] = np.asarray(label_list_all, dtype=np.float32)\n        res['users'] = user_list_all\n        res['items'] = np.asarray(item_list_all, dtype=np.int32)\n        res['cates'] = np.asarray(item_cate_list_all, dtype=np.int32)\n        res['item_history'] = item_history_batch_all\n        res['item_cate_history'] = item_cate_history_batch_all\n        res['mask'] = mask\n        res['time'] = time_list_all\n        res['time_diff'] = time_diff_batch\n        res['time_from_first_action'] = time_from_first_action_batch\n        res['time_to_now'] = time_to_now_batch\n        return res\n    else:\n        instance_cnt = len(label_list)\n        history_lengths = [len(item_history_batch[i]) for i in range(instance_cnt)]\n        max_seq_length_batch = self.max_seq_length\n        item_history_batch_all = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.int32)\n        item_cate_history_batch_all = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.int32)\n        time_diff_batch = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.float32)\n        time_from_first_action_batch = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.float32)\n        time_to_now_batch = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.float32)\n        mask = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.float32)\n        for i in range(instance_cnt):\n            this_length = min(history_lengths[i], max_seq_length_batch)\n            item_history_batch_all[i, -this_length:] = item_history_batch[i][-this_length:]\n            item_cate_history_batch_all[i, -this_length:] = item_cate_history_batch[i][-this_length:]\n            mask[i, -this_length:] = 1.0\n            time_diff_batch[i, -this_length:] = time_diff_list[i][-this_length:]\n            time_from_first_action_batch[i, -this_length:] = time_from_first_action_list[i][-this_length:]\n            time_to_now_batch[i, -this_length:] = time_to_now_list[i][-this_length:]\n        res = {}\n        res['labels'] = np.asarray(label_list, dtype=np.float32).reshape([-1, 1])\n        res['users'] = np.asarray(user_list, dtype=np.float32)\n        res['items'] = np.asarray(item_list, dtype=np.int32).reshape([-1, 1])\n        res['cates'] = np.asarray(item_cate_list, dtype=np.int32).reshape([-1, 1])\n        res['item_history'] = item_history_batch_all\n        res['item_cate_history'] = item_cate_history_batch_all\n        res['mask'] = mask\n        res['time'] = np.asarray(time_list, dtype=np.float32)\n        res['time_diff'] = time_diff_batch\n        res['time_from_first_action'] = time_from_first_action_batch\n        res['time_to_now'] = time_to_now_batch\n        return res",
            "def _convert_data(self, label_list, user_list, item_list, item_cate_list, item_history_batch, item_cate_history_batch, time_list, time_diff_list, time_from_first_action_list, time_to_now_list, batch_num_ngs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Convert data into numpy arrays that are good for further model operation.\\n        Note: This is different from `sequential_iterator`.\\n\\n        Args:\\n            label_list (list): A list of ground-truth labels.\\n            user_list (list): A list of user indexes.\\n            item_list (list): A list of item indexes.\\n            item_cate_list (list): A list of category indexes.\\n            item_history_batch (list): A list of item history indexes.\\n            item_cate_history_batch (list): A list of category history indexes.\\n            time_list (list): A list of current timestamp.\\n            time_diff_list (list): A list of timestamp between each sequential opertions.\\n            time_from_first_action_list (list): A list of timestamp from the first opertion.\\n            time_to_now_list (list): A list of timestamp to the current time.\\n            batch_num_ngs (int): The number of negative sampling while training in mini-batch.\\n\\n        Returns:\\n            dict: A dictionary, contains multiple numpy arrays that are convenient for further operation.\\n        '\n    if batch_num_ngs:\n        instance_cnt = len(label_list)\n        if instance_cnt < 5:\n            return\n        label_list_all = []\n        item_list_all = []\n        item_cate_list_all = []\n        user_list_all = np.asarray([[user] * (batch_num_ngs + 1) for user in user_list], dtype=np.int32).flatten()\n        time_list_all = np.asarray([[t] * (batch_num_ngs + 1) for t in time_list], dtype=np.float32).flatten()\n        history_lengths = [len(item_history_batch[i]) for i in range(instance_cnt)]\n        max_seq_length_batch = self.max_seq_length\n        item_history_batch_all = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.int32)\n        item_cate_history_batch_all = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.int32)\n        time_diff_batch = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.float32)\n        time_from_first_action_batch = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.float32)\n        time_to_now_batch = np.zeros((instance_cnt * (batch_num_ngs + 1), max_seq_length_batch), dtype=np.float32)\n        mask = np.zeros((instance_cnt * (1 + batch_num_ngs), max_seq_length_batch), dtype=np.float32)\n        for i in range(instance_cnt):\n            this_length = min(history_lengths[i], max_seq_length_batch)\n            for index in range(batch_num_ngs + 1):\n                item_history_batch_all[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(item_history_batch[i][-this_length:], dtype=np.int32)\n                item_cate_history_batch_all[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(item_cate_history_batch[i][-this_length:], dtype=np.int32)\n                mask[i * (batch_num_ngs + 1) + index, -this_length:] = 1.0\n                time_diff_batch[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(time_diff_list[i][-this_length:], dtype=np.float32)\n                time_from_first_action_batch[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(time_from_first_action_list[i][-this_length:], dtype=np.float32)\n                time_to_now_batch[i * (batch_num_ngs + 1) + index, -this_length:] = np.asarray(time_to_now_list[i][-this_length:], dtype=np.float32)\n        for i in range(instance_cnt):\n            positive_item = [*item_history_batch_all[i * (batch_num_ngs + 1)][1:], item_list[i]]\n            positive_item_cate = [*item_cate_history_batch_all[i * (batch_num_ngs + 1)][1:], item_cate_list[i]]\n            label_list_all.append([1] * max_seq_length_batch)\n            item_list_all.append(positive_item)\n            item_cate_list_all.append(positive_item_cate)\n            count = 0\n            while count < batch_num_ngs:\n                negative_item_list = []\n                negative_item_cate_list = []\n                count_inner = 1\n                while count_inner <= max_seq_length_batch:\n                    random_value = random.randint(0, instance_cnt - 1)\n                    negative_item = item_list[random_value]\n                    if negative_item == positive_item[count_inner - 1]:\n                        continue\n                    negative_item_list.append(negative_item)\n                    negative_item_cate_list.append(item_cate_list[random_value])\n                    count_inner += 1\n                label_list_all.append([0] * max_seq_length_batch)\n                item_list_all.append(negative_item_list)\n                item_cate_list_all.append(negative_item_cate_list)\n                count += 1\n        res = {}\n        res['labels'] = np.asarray(label_list_all, dtype=np.float32)\n        res['users'] = user_list_all\n        res['items'] = np.asarray(item_list_all, dtype=np.int32)\n        res['cates'] = np.asarray(item_cate_list_all, dtype=np.int32)\n        res['item_history'] = item_history_batch_all\n        res['item_cate_history'] = item_cate_history_batch_all\n        res['mask'] = mask\n        res['time'] = time_list_all\n        res['time_diff'] = time_diff_batch\n        res['time_from_first_action'] = time_from_first_action_batch\n        res['time_to_now'] = time_to_now_batch\n        return res\n    else:\n        instance_cnt = len(label_list)\n        history_lengths = [len(item_history_batch[i]) for i in range(instance_cnt)]\n        max_seq_length_batch = self.max_seq_length\n        item_history_batch_all = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.int32)\n        item_cate_history_batch_all = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.int32)\n        time_diff_batch = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.float32)\n        time_from_first_action_batch = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.float32)\n        time_to_now_batch = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.float32)\n        mask = np.zeros((instance_cnt, max_seq_length_batch), dtype=np.float32)\n        for i in range(instance_cnt):\n            this_length = min(history_lengths[i], max_seq_length_batch)\n            item_history_batch_all[i, -this_length:] = item_history_batch[i][-this_length:]\n            item_cate_history_batch_all[i, -this_length:] = item_cate_history_batch[i][-this_length:]\n            mask[i, -this_length:] = 1.0\n            time_diff_batch[i, -this_length:] = time_diff_list[i][-this_length:]\n            time_from_first_action_batch[i, -this_length:] = time_from_first_action_list[i][-this_length:]\n            time_to_now_batch[i, -this_length:] = time_to_now_list[i][-this_length:]\n        res = {}\n        res['labels'] = np.asarray(label_list, dtype=np.float32).reshape([-1, 1])\n        res['users'] = np.asarray(user_list, dtype=np.float32)\n        res['items'] = np.asarray(item_list, dtype=np.int32).reshape([-1, 1])\n        res['cates'] = np.asarray(item_cate_list, dtype=np.int32).reshape([-1, 1])\n        res['item_history'] = item_history_batch_all\n        res['item_cate_history'] = item_cate_history_batch_all\n        res['mask'] = mask\n        res['time'] = np.asarray(time_list, dtype=np.float32)\n        res['time_diff'] = time_diff_batch\n        res['time_from_first_action'] = time_from_first_action_batch\n        res['time_to_now'] = time_to_now_batch\n        return res"
        ]
    }
]