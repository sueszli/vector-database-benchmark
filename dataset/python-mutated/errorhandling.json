[
    {
        "func_name": "convert_api_errors",
        "original": "@contextlib.contextmanager\ndef convert_api_errors(dbx_path: str | None=None, local_path: str | None=None) -> Iterator[None]:\n    \"\"\"\n    A context manager that catches and re-raises instances of :exc:`OSError` and\n    :exc:`dropbox.exceptions.DropboxException` as\n    :exc:`maestral.exceptions.MaestralApiError` or :exc:`ConnectionError`.\n\n    :param dbx_path: Dropbox path associated with the error.\n    :param local_path: Local path associated with the error.\n    \"\"\"\n    try:\n        yield\n    except (exceptions.DropboxException, ValidationError) as exc:\n        raise dropbox_to_maestral_error(exc, dbx_path, local_path)\n    except CONNECTION_ERRORS:\n        raise DropboxConnectionError('Cannot connect to Dropbox', 'Please check you internet connection and try again later.')\n    except OSError as exc:\n        if exc.errno == errno.EPROTOTYPE:\n            raise DropboxConnectionError('Cannot connect to Dropbox', 'Please check your internet connection and try again later.')\n        else:\n            raise os_to_maestral_error(exc, dbx_path, local_path)",
        "mutated": [
            "@contextlib.contextmanager\ndef convert_api_errors(dbx_path: str | None=None, local_path: str | None=None) -> Iterator[None]:\n    if False:\n        i = 10\n    '\\n    A context manager that catches and re-raises instances of :exc:`OSError` and\\n    :exc:`dropbox.exceptions.DropboxException` as\\n    :exc:`maestral.exceptions.MaestralApiError` or :exc:`ConnectionError`.\\n\\n    :param dbx_path: Dropbox path associated with the error.\\n    :param local_path: Local path associated with the error.\\n    '\n    try:\n        yield\n    except (exceptions.DropboxException, ValidationError) as exc:\n        raise dropbox_to_maestral_error(exc, dbx_path, local_path)\n    except CONNECTION_ERRORS:\n        raise DropboxConnectionError('Cannot connect to Dropbox', 'Please check you internet connection and try again later.')\n    except OSError as exc:\n        if exc.errno == errno.EPROTOTYPE:\n            raise DropboxConnectionError('Cannot connect to Dropbox', 'Please check your internet connection and try again later.')\n        else:\n            raise os_to_maestral_error(exc, dbx_path, local_path)",
            "@contextlib.contextmanager\ndef convert_api_errors(dbx_path: str | None=None, local_path: str | None=None) -> Iterator[None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    A context manager that catches and re-raises instances of :exc:`OSError` and\\n    :exc:`dropbox.exceptions.DropboxException` as\\n    :exc:`maestral.exceptions.MaestralApiError` or :exc:`ConnectionError`.\\n\\n    :param dbx_path: Dropbox path associated with the error.\\n    :param local_path: Local path associated with the error.\\n    '\n    try:\n        yield\n    except (exceptions.DropboxException, ValidationError) as exc:\n        raise dropbox_to_maestral_error(exc, dbx_path, local_path)\n    except CONNECTION_ERRORS:\n        raise DropboxConnectionError('Cannot connect to Dropbox', 'Please check you internet connection and try again later.')\n    except OSError as exc:\n        if exc.errno == errno.EPROTOTYPE:\n            raise DropboxConnectionError('Cannot connect to Dropbox', 'Please check your internet connection and try again later.')\n        else:\n            raise os_to_maestral_error(exc, dbx_path, local_path)",
            "@contextlib.contextmanager\ndef convert_api_errors(dbx_path: str | None=None, local_path: str | None=None) -> Iterator[None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    A context manager that catches and re-raises instances of :exc:`OSError` and\\n    :exc:`dropbox.exceptions.DropboxException` as\\n    :exc:`maestral.exceptions.MaestralApiError` or :exc:`ConnectionError`.\\n\\n    :param dbx_path: Dropbox path associated with the error.\\n    :param local_path: Local path associated with the error.\\n    '\n    try:\n        yield\n    except (exceptions.DropboxException, ValidationError) as exc:\n        raise dropbox_to_maestral_error(exc, dbx_path, local_path)\n    except CONNECTION_ERRORS:\n        raise DropboxConnectionError('Cannot connect to Dropbox', 'Please check you internet connection and try again later.')\n    except OSError as exc:\n        if exc.errno == errno.EPROTOTYPE:\n            raise DropboxConnectionError('Cannot connect to Dropbox', 'Please check your internet connection and try again later.')\n        else:\n            raise os_to_maestral_error(exc, dbx_path, local_path)",
            "@contextlib.contextmanager\ndef convert_api_errors(dbx_path: str | None=None, local_path: str | None=None) -> Iterator[None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    A context manager that catches and re-raises instances of :exc:`OSError` and\\n    :exc:`dropbox.exceptions.DropboxException` as\\n    :exc:`maestral.exceptions.MaestralApiError` or :exc:`ConnectionError`.\\n\\n    :param dbx_path: Dropbox path associated with the error.\\n    :param local_path: Local path associated with the error.\\n    '\n    try:\n        yield\n    except (exceptions.DropboxException, ValidationError) as exc:\n        raise dropbox_to_maestral_error(exc, dbx_path, local_path)\n    except CONNECTION_ERRORS:\n        raise DropboxConnectionError('Cannot connect to Dropbox', 'Please check you internet connection and try again later.')\n    except OSError as exc:\n        if exc.errno == errno.EPROTOTYPE:\n            raise DropboxConnectionError('Cannot connect to Dropbox', 'Please check your internet connection and try again later.')\n        else:\n            raise os_to_maestral_error(exc, dbx_path, local_path)",
            "@contextlib.contextmanager\ndef convert_api_errors(dbx_path: str | None=None, local_path: str | None=None) -> Iterator[None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    A context manager that catches and re-raises instances of :exc:`OSError` and\\n    :exc:`dropbox.exceptions.DropboxException` as\\n    :exc:`maestral.exceptions.MaestralApiError` or :exc:`ConnectionError`.\\n\\n    :param dbx_path: Dropbox path associated with the error.\\n    :param local_path: Local path associated with the error.\\n    '\n    try:\n        yield\n    except (exceptions.DropboxException, ValidationError) as exc:\n        raise dropbox_to_maestral_error(exc, dbx_path, local_path)\n    except CONNECTION_ERRORS:\n        raise DropboxConnectionError('Cannot connect to Dropbox', 'Please check you internet connection and try again later.')\n    except OSError as exc:\n        if exc.errno == errno.EPROTOTYPE:\n            raise DropboxConnectionError('Cannot connect to Dropbox', 'Please check your internet connection and try again later.')\n        else:\n            raise os_to_maestral_error(exc, dbx_path, local_path)"
        ]
    },
    {
        "func_name": "os_to_maestral_error",
        "original": "def os_to_maestral_error(exc: OSError, dbx_path: str | None=None, local_path: str | None=None) -> LocalError:\n    \"\"\"\n    Converts a :exc:`OSError` to a :exc:`maestral.exceptions.MaestralApiError` and\n    tries to add a reasonably informative error title and message.\n\n    :param exc: Original OSError.\n    :param dbx_path: Dropbox path associated with the error.\n    :param local_path: Local path associated with the error.\n    :returns: Converted exception.\n    \"\"\"\n    title = 'Could not sync file or folder'\n    err_cls: type[MaestralApiError]\n    if isinstance(exc, PermissionError):\n        err_cls = InsufficientPermissionsError\n        text = 'Insufficient read or write permissions for this location.'\n    elif isinstance(exc, FileNotFoundError):\n        err_cls = NotFoundError\n        text = 'The given path does not exist.'\n    elif isinstance(exc, FileExistsError):\n        err_cls = ConflictError\n        title = 'Could not download file'\n        text = 'There already is an item at the given path.'\n    elif isinstance(exc, IsADirectoryError):\n        err_cls = IsAFolderError\n        title = 'Could not create local file'\n        text = 'The given path refers to a folder.'\n    elif isinstance(exc, NotADirectoryError):\n        err_cls = NotAFolderError\n        title = 'Could not create local folder'\n        text = 'The given path refers to a file.'\n    elif exc.errno == errno.ENAMETOOLONG:\n        err_cls = PathError\n        title = 'Could not create local file'\n        try:\n            (max_name, max_path) = fs_max_lengths_for_path(local_path or '/')\n        except RuntimeError:\n            text = 'The file name or path is too long.'\n        else:\n            text = f'The file name is too long. File names and paths must be shorter than {max_name} and {max_path} characters on your file system, respectively.'\n    elif exc.errno == errno.EINVAL:\n        err_cls = PathError\n        title = 'Could not create local file'\n        text = 'The file name contains characters which are not allowed on your file system. This could be for instance a colon or a trailing period.'\n    elif exc.errno == errno.EFBIG:\n        err_cls = FileSizeError\n        title = 'Could not download file'\n        text = 'The file size too large.'\n    elif exc.errno == errno.ELOOP:\n        err_cls = SymlinkError\n        title = 'Cannot upload symlink'\n        text = 'Symlinks are not currently supported by the public Dropbox API.'\n    elif exc.errno == errno.ENOSPC:\n        err_cls = InsufficientSpaceError\n        title = 'Could not download file'\n        text = 'There is not enough space left on the selected drive.'\n    elif exc.errno == errno.ENOMEM:\n        err_cls = OutOfMemoryError\n        text = 'Out of memory. Please reduce the number of memory consuming processes.'\n    elif exc.errno is not None:\n        err_cls = FileReadError\n        text = f'Could not access file. Errno {exc.errno}: {os.strerror(exc.errno)}.'\n    else:\n        err_cls = MaestralApiError\n        text = str(exc)\n    local_path = local_path or exc.filename\n    maestral_exc = err_cls(title, text, dbx_path=dbx_path, local_path=local_path)\n    maestral_exc.__cause__ = exc\n    return maestral_exc",
        "mutated": [
            "def os_to_maestral_error(exc: OSError, dbx_path: str | None=None, local_path: str | None=None) -> LocalError:\n    if False:\n        i = 10\n    '\\n    Converts a :exc:`OSError` to a :exc:`maestral.exceptions.MaestralApiError` and\\n    tries to add a reasonably informative error title and message.\\n\\n    :param exc: Original OSError.\\n    :param dbx_path: Dropbox path associated with the error.\\n    :param local_path: Local path associated with the error.\\n    :returns: Converted exception.\\n    '\n    title = 'Could not sync file or folder'\n    err_cls: type[MaestralApiError]\n    if isinstance(exc, PermissionError):\n        err_cls = InsufficientPermissionsError\n        text = 'Insufficient read or write permissions for this location.'\n    elif isinstance(exc, FileNotFoundError):\n        err_cls = NotFoundError\n        text = 'The given path does not exist.'\n    elif isinstance(exc, FileExistsError):\n        err_cls = ConflictError\n        title = 'Could not download file'\n        text = 'There already is an item at the given path.'\n    elif isinstance(exc, IsADirectoryError):\n        err_cls = IsAFolderError\n        title = 'Could not create local file'\n        text = 'The given path refers to a folder.'\n    elif isinstance(exc, NotADirectoryError):\n        err_cls = NotAFolderError\n        title = 'Could not create local folder'\n        text = 'The given path refers to a file.'\n    elif exc.errno == errno.ENAMETOOLONG:\n        err_cls = PathError\n        title = 'Could not create local file'\n        try:\n            (max_name, max_path) = fs_max_lengths_for_path(local_path or '/')\n        except RuntimeError:\n            text = 'The file name or path is too long.'\n        else:\n            text = f'The file name is too long. File names and paths must be shorter than {max_name} and {max_path} characters on your file system, respectively.'\n    elif exc.errno == errno.EINVAL:\n        err_cls = PathError\n        title = 'Could not create local file'\n        text = 'The file name contains characters which are not allowed on your file system. This could be for instance a colon or a trailing period.'\n    elif exc.errno == errno.EFBIG:\n        err_cls = FileSizeError\n        title = 'Could not download file'\n        text = 'The file size too large.'\n    elif exc.errno == errno.ELOOP:\n        err_cls = SymlinkError\n        title = 'Cannot upload symlink'\n        text = 'Symlinks are not currently supported by the public Dropbox API.'\n    elif exc.errno == errno.ENOSPC:\n        err_cls = InsufficientSpaceError\n        title = 'Could not download file'\n        text = 'There is not enough space left on the selected drive.'\n    elif exc.errno == errno.ENOMEM:\n        err_cls = OutOfMemoryError\n        text = 'Out of memory. Please reduce the number of memory consuming processes.'\n    elif exc.errno is not None:\n        err_cls = FileReadError\n        text = f'Could not access file. Errno {exc.errno}: {os.strerror(exc.errno)}.'\n    else:\n        err_cls = MaestralApiError\n        text = str(exc)\n    local_path = local_path or exc.filename\n    maestral_exc = err_cls(title, text, dbx_path=dbx_path, local_path=local_path)\n    maestral_exc.__cause__ = exc\n    return maestral_exc",
            "def os_to_maestral_error(exc: OSError, dbx_path: str | None=None, local_path: str | None=None) -> LocalError:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Converts a :exc:`OSError` to a :exc:`maestral.exceptions.MaestralApiError` and\\n    tries to add a reasonably informative error title and message.\\n\\n    :param exc: Original OSError.\\n    :param dbx_path: Dropbox path associated with the error.\\n    :param local_path: Local path associated with the error.\\n    :returns: Converted exception.\\n    '\n    title = 'Could not sync file or folder'\n    err_cls: type[MaestralApiError]\n    if isinstance(exc, PermissionError):\n        err_cls = InsufficientPermissionsError\n        text = 'Insufficient read or write permissions for this location.'\n    elif isinstance(exc, FileNotFoundError):\n        err_cls = NotFoundError\n        text = 'The given path does not exist.'\n    elif isinstance(exc, FileExistsError):\n        err_cls = ConflictError\n        title = 'Could not download file'\n        text = 'There already is an item at the given path.'\n    elif isinstance(exc, IsADirectoryError):\n        err_cls = IsAFolderError\n        title = 'Could not create local file'\n        text = 'The given path refers to a folder.'\n    elif isinstance(exc, NotADirectoryError):\n        err_cls = NotAFolderError\n        title = 'Could not create local folder'\n        text = 'The given path refers to a file.'\n    elif exc.errno == errno.ENAMETOOLONG:\n        err_cls = PathError\n        title = 'Could not create local file'\n        try:\n            (max_name, max_path) = fs_max_lengths_for_path(local_path or '/')\n        except RuntimeError:\n            text = 'The file name or path is too long.'\n        else:\n            text = f'The file name is too long. File names and paths must be shorter than {max_name} and {max_path} characters on your file system, respectively.'\n    elif exc.errno == errno.EINVAL:\n        err_cls = PathError\n        title = 'Could not create local file'\n        text = 'The file name contains characters which are not allowed on your file system. This could be for instance a colon or a trailing period.'\n    elif exc.errno == errno.EFBIG:\n        err_cls = FileSizeError\n        title = 'Could not download file'\n        text = 'The file size too large.'\n    elif exc.errno == errno.ELOOP:\n        err_cls = SymlinkError\n        title = 'Cannot upload symlink'\n        text = 'Symlinks are not currently supported by the public Dropbox API.'\n    elif exc.errno == errno.ENOSPC:\n        err_cls = InsufficientSpaceError\n        title = 'Could not download file'\n        text = 'There is not enough space left on the selected drive.'\n    elif exc.errno == errno.ENOMEM:\n        err_cls = OutOfMemoryError\n        text = 'Out of memory. Please reduce the number of memory consuming processes.'\n    elif exc.errno is not None:\n        err_cls = FileReadError\n        text = f'Could not access file. Errno {exc.errno}: {os.strerror(exc.errno)}.'\n    else:\n        err_cls = MaestralApiError\n        text = str(exc)\n    local_path = local_path or exc.filename\n    maestral_exc = err_cls(title, text, dbx_path=dbx_path, local_path=local_path)\n    maestral_exc.__cause__ = exc\n    return maestral_exc",
            "def os_to_maestral_error(exc: OSError, dbx_path: str | None=None, local_path: str | None=None) -> LocalError:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Converts a :exc:`OSError` to a :exc:`maestral.exceptions.MaestralApiError` and\\n    tries to add a reasonably informative error title and message.\\n\\n    :param exc: Original OSError.\\n    :param dbx_path: Dropbox path associated with the error.\\n    :param local_path: Local path associated with the error.\\n    :returns: Converted exception.\\n    '\n    title = 'Could not sync file or folder'\n    err_cls: type[MaestralApiError]\n    if isinstance(exc, PermissionError):\n        err_cls = InsufficientPermissionsError\n        text = 'Insufficient read or write permissions for this location.'\n    elif isinstance(exc, FileNotFoundError):\n        err_cls = NotFoundError\n        text = 'The given path does not exist.'\n    elif isinstance(exc, FileExistsError):\n        err_cls = ConflictError\n        title = 'Could not download file'\n        text = 'There already is an item at the given path.'\n    elif isinstance(exc, IsADirectoryError):\n        err_cls = IsAFolderError\n        title = 'Could not create local file'\n        text = 'The given path refers to a folder.'\n    elif isinstance(exc, NotADirectoryError):\n        err_cls = NotAFolderError\n        title = 'Could not create local folder'\n        text = 'The given path refers to a file.'\n    elif exc.errno == errno.ENAMETOOLONG:\n        err_cls = PathError\n        title = 'Could not create local file'\n        try:\n            (max_name, max_path) = fs_max_lengths_for_path(local_path or '/')\n        except RuntimeError:\n            text = 'The file name or path is too long.'\n        else:\n            text = f'The file name is too long. File names and paths must be shorter than {max_name} and {max_path} characters on your file system, respectively.'\n    elif exc.errno == errno.EINVAL:\n        err_cls = PathError\n        title = 'Could not create local file'\n        text = 'The file name contains characters which are not allowed on your file system. This could be for instance a colon or a trailing period.'\n    elif exc.errno == errno.EFBIG:\n        err_cls = FileSizeError\n        title = 'Could not download file'\n        text = 'The file size too large.'\n    elif exc.errno == errno.ELOOP:\n        err_cls = SymlinkError\n        title = 'Cannot upload symlink'\n        text = 'Symlinks are not currently supported by the public Dropbox API.'\n    elif exc.errno == errno.ENOSPC:\n        err_cls = InsufficientSpaceError\n        title = 'Could not download file'\n        text = 'There is not enough space left on the selected drive.'\n    elif exc.errno == errno.ENOMEM:\n        err_cls = OutOfMemoryError\n        text = 'Out of memory. Please reduce the number of memory consuming processes.'\n    elif exc.errno is not None:\n        err_cls = FileReadError\n        text = f'Could not access file. Errno {exc.errno}: {os.strerror(exc.errno)}.'\n    else:\n        err_cls = MaestralApiError\n        text = str(exc)\n    local_path = local_path or exc.filename\n    maestral_exc = err_cls(title, text, dbx_path=dbx_path, local_path=local_path)\n    maestral_exc.__cause__ = exc\n    return maestral_exc",
            "def os_to_maestral_error(exc: OSError, dbx_path: str | None=None, local_path: str | None=None) -> LocalError:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Converts a :exc:`OSError` to a :exc:`maestral.exceptions.MaestralApiError` and\\n    tries to add a reasonably informative error title and message.\\n\\n    :param exc: Original OSError.\\n    :param dbx_path: Dropbox path associated with the error.\\n    :param local_path: Local path associated with the error.\\n    :returns: Converted exception.\\n    '\n    title = 'Could not sync file or folder'\n    err_cls: type[MaestralApiError]\n    if isinstance(exc, PermissionError):\n        err_cls = InsufficientPermissionsError\n        text = 'Insufficient read or write permissions for this location.'\n    elif isinstance(exc, FileNotFoundError):\n        err_cls = NotFoundError\n        text = 'The given path does not exist.'\n    elif isinstance(exc, FileExistsError):\n        err_cls = ConflictError\n        title = 'Could not download file'\n        text = 'There already is an item at the given path.'\n    elif isinstance(exc, IsADirectoryError):\n        err_cls = IsAFolderError\n        title = 'Could not create local file'\n        text = 'The given path refers to a folder.'\n    elif isinstance(exc, NotADirectoryError):\n        err_cls = NotAFolderError\n        title = 'Could not create local folder'\n        text = 'The given path refers to a file.'\n    elif exc.errno == errno.ENAMETOOLONG:\n        err_cls = PathError\n        title = 'Could not create local file'\n        try:\n            (max_name, max_path) = fs_max_lengths_for_path(local_path or '/')\n        except RuntimeError:\n            text = 'The file name or path is too long.'\n        else:\n            text = f'The file name is too long. File names and paths must be shorter than {max_name} and {max_path} characters on your file system, respectively.'\n    elif exc.errno == errno.EINVAL:\n        err_cls = PathError\n        title = 'Could not create local file'\n        text = 'The file name contains characters which are not allowed on your file system. This could be for instance a colon or a trailing period.'\n    elif exc.errno == errno.EFBIG:\n        err_cls = FileSizeError\n        title = 'Could not download file'\n        text = 'The file size too large.'\n    elif exc.errno == errno.ELOOP:\n        err_cls = SymlinkError\n        title = 'Cannot upload symlink'\n        text = 'Symlinks are not currently supported by the public Dropbox API.'\n    elif exc.errno == errno.ENOSPC:\n        err_cls = InsufficientSpaceError\n        title = 'Could not download file'\n        text = 'There is not enough space left on the selected drive.'\n    elif exc.errno == errno.ENOMEM:\n        err_cls = OutOfMemoryError\n        text = 'Out of memory. Please reduce the number of memory consuming processes.'\n    elif exc.errno is not None:\n        err_cls = FileReadError\n        text = f'Could not access file. Errno {exc.errno}: {os.strerror(exc.errno)}.'\n    else:\n        err_cls = MaestralApiError\n        text = str(exc)\n    local_path = local_path or exc.filename\n    maestral_exc = err_cls(title, text, dbx_path=dbx_path, local_path=local_path)\n    maestral_exc.__cause__ = exc\n    return maestral_exc",
            "def os_to_maestral_error(exc: OSError, dbx_path: str | None=None, local_path: str | None=None) -> LocalError:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Converts a :exc:`OSError` to a :exc:`maestral.exceptions.MaestralApiError` and\\n    tries to add a reasonably informative error title and message.\\n\\n    :param exc: Original OSError.\\n    :param dbx_path: Dropbox path associated with the error.\\n    :param local_path: Local path associated with the error.\\n    :returns: Converted exception.\\n    '\n    title = 'Could not sync file or folder'\n    err_cls: type[MaestralApiError]\n    if isinstance(exc, PermissionError):\n        err_cls = InsufficientPermissionsError\n        text = 'Insufficient read or write permissions for this location.'\n    elif isinstance(exc, FileNotFoundError):\n        err_cls = NotFoundError\n        text = 'The given path does not exist.'\n    elif isinstance(exc, FileExistsError):\n        err_cls = ConflictError\n        title = 'Could not download file'\n        text = 'There already is an item at the given path.'\n    elif isinstance(exc, IsADirectoryError):\n        err_cls = IsAFolderError\n        title = 'Could not create local file'\n        text = 'The given path refers to a folder.'\n    elif isinstance(exc, NotADirectoryError):\n        err_cls = NotAFolderError\n        title = 'Could not create local folder'\n        text = 'The given path refers to a file.'\n    elif exc.errno == errno.ENAMETOOLONG:\n        err_cls = PathError\n        title = 'Could not create local file'\n        try:\n            (max_name, max_path) = fs_max_lengths_for_path(local_path or '/')\n        except RuntimeError:\n            text = 'The file name or path is too long.'\n        else:\n            text = f'The file name is too long. File names and paths must be shorter than {max_name} and {max_path} characters on your file system, respectively.'\n    elif exc.errno == errno.EINVAL:\n        err_cls = PathError\n        title = 'Could not create local file'\n        text = 'The file name contains characters which are not allowed on your file system. This could be for instance a colon or a trailing period.'\n    elif exc.errno == errno.EFBIG:\n        err_cls = FileSizeError\n        title = 'Could not download file'\n        text = 'The file size too large.'\n    elif exc.errno == errno.ELOOP:\n        err_cls = SymlinkError\n        title = 'Cannot upload symlink'\n        text = 'Symlinks are not currently supported by the public Dropbox API.'\n    elif exc.errno == errno.ENOSPC:\n        err_cls = InsufficientSpaceError\n        title = 'Could not download file'\n        text = 'There is not enough space left on the selected drive.'\n    elif exc.errno == errno.ENOMEM:\n        err_cls = OutOfMemoryError\n        text = 'Out of memory. Please reduce the number of memory consuming processes.'\n    elif exc.errno is not None:\n        err_cls = FileReadError\n        text = f'Could not access file. Errno {exc.errno}: {os.strerror(exc.errno)}.'\n    else:\n        err_cls = MaestralApiError\n        text = str(exc)\n    local_path = local_path or exc.filename\n    maestral_exc = err_cls(title, text, dbx_path=dbx_path, local_path=local_path)\n    maestral_exc.__cause__ = exc\n    return maestral_exc"
        ]
    },
    {
        "func_name": "dropbox_to_maestral_error",
        "original": "def dropbox_to_maestral_error(exc: exceptions.DropboxException | ValidationError | requests.HTTPError, dbx_path: str | None=None, local_path: str | None=None) -> MaestralApiError:\n    \"\"\"\n    Converts a Dropbox SDK exception to a :exc:`maestral.exceptions.MaestralApiError`\n    and tries to add a reasonably informative error title and message.\n\n    :param exc: Dropbox SDK exception..\n    :param dbx_path: Dropbox path associated with the error.\n    :param local_path: Local path associated with the error.\n    :returns: Converted exception.\n    \"\"\"\n    title = 'An unexpected error occurred'\n    text = 'Please contact the developer with the traceback information from the logs.'\n    err_cls = MaestralApiError\n    if isinstance(exc, exceptions.ApiError):\n        error = exc.error\n        if isinstance(error, files.RelocationError):\n            title = 'Could not move file or folder'\n            if error.is_cant_copy_shared_folder():\n                text = 'Shared folders can\u2019t be copied.'\n                err_cls = SyncError\n            elif error.is_cant_move_folder_into_itself():\n                text = 'You cannot move a folder into itself.'\n                err_cls = ConflictError\n            elif error.is_cant_move_shared_folder():\n                text = 'You cannot move the shared folder to the given destination.'\n                err_cls = SyncError\n            elif error.is_cant_nest_shared_folder():\n                text = 'Your move operation would result in nested shared folders. This is not allowed.'\n                err_cls = SyncError\n            elif error.is_cant_transfer_ownership():\n                text = 'Your move operation would result in an ownership transfer. Maestral does not currently support this. Please carry out the move on the Dropbox website instead.'\n                err_cls = SyncError\n            elif error.is_duplicated_or_nested_paths():\n                text = 'There are duplicated/nested paths among the target and destination folders.'\n                err_cls = SyncError\n            elif error.is_from_lookup():\n                lookup_error = error.get_from_lookup()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_from_write():\n                write_error = error.get_from_write()\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_insufficient_quota():\n                text = 'You do not have enough space on Dropbox to move or copy the files.'\n                err_cls = InsufficientSpaceError\n            elif error.is_internal_error():\n                text = 'Something went on Dropbox\u2019s end. Please try again later.'\n                err_cls = DropboxServerError\n            elif error.is_to():\n                to_error = error.get_to()\n                (text, err_cls) = get_write_error_msg(to_error)\n            elif error.is_too_many_files():\n                text = 'There are more than 10,000 files and folders in one request. Please try to move fewer items at once.'\n                err_cls = SyncError\n            elif error.is_cant_move_into_vault():\n                vault_error = error.get_cant_move_into_vault()\n                if vault_error.is_is_shared_folder():\n                    text = 'You cannot move a shared folder into the Dropbox Vault.'\n                else:\n                    text = 'You cannot move this folder into the Dropbox Vault.'\n                err_cls = SyncError\n        elif isinstance(error, (files.CreateFolderError, files.CreateFolderEntryError)):\n            title = 'Could not create folder'\n            if error.is_path():\n                write_error = error.get_path()\n                (text, err_cls) = get_write_error_msg(write_error)\n        elif isinstance(error, files.DeleteError):\n            title = 'Could not delete item'\n            if error.is_path_lookup():\n                lookup_error = error.get_path_lookup()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_path_write():\n                write_error = error.get_path_write()\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_too_many_files():\n                text = 'There are more than 10,000 files and folders in one request. Please try to delete fewer items at once.'\n                err_cls = SyncError\n            elif error.is_too_many_write_operations():\n                text = 'There are too many write operations happening in your Dropbox. Please try again later.'\n                err_cls = SyncError\n        elif isinstance(error, files.UploadError):\n            title = 'Could not upload file'\n            if error.is_path():\n                write_error = error.get_path().reason\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_properties_error():\n                text = 'Invalid property group provided.'\n            elif error.is_payload_too_large():\n                text = 'Can only upload in chunks of at most 150 MB.'\n                err_cls = FileSizeError\n            elif error.is_content_hash_mismatch():\n                text = 'Data corruption during upload. Please try again.'\n                err_cls = DataCorruptionError\n        elif isinstance(error, files.UploadSessionStartError):\n            title = 'Could not upload file'\n            if error.is_concurrent_session_close_not_allowed():\n                text = 'Can not start a closed concurrent upload session.'\n            elif error.is_concurrent_session_data_not_allowed():\n                text = 'Uploading data not allowed when starting concurrent upload session.'\n            elif error.is_payload_too_large():\n                text = 'Can only upload in chunks of at most 150 MB.'\n                err_cls = SyncError\n            elif error.is_content_hash_mismatch():\n                text = 'Data corruption during upload. Please try again.'\n                err_cls = DataCorruptionError\n        elif isinstance(error, files.UploadSessionFinishError):\n            title = 'Could not upload file'\n            if error.is_lookup_failed():\n                session_lookup_error = error.get_lookup_failed()\n                (text, err_cls) = get_session_lookup_error_msg(session_lookup_error)\n            elif error.is_path():\n                write_error = error.get_path()\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_properties_error():\n                text = 'Invalid property group provided.'\n            elif error.is_too_many_write_operations():\n                text = 'There are too many write operations happening in your Dropbox. Please retry again later.'\n                err_cls = SyncError\n            elif error.is_too_many_shared_folder_targets():\n                text = 'The batch request commits files into too many different shared folders. Please limit your batch request to files contained in a single shared folder.'\n                err_cls = SyncError\n            elif error.is_payload_too_large():\n                text = 'Can only upload in chunks of at most 150 MB.'\n                err_cls = SyncError\n            elif error.is_content_hash_mismatch():\n                text = 'Data corruption during upload. Please try again.'\n                err_cls = DataCorruptionError\n        elif isinstance(error, files.UploadSessionLookupError):\n            title = 'Could not upload file'\n            (text, err_cls) = get_session_lookup_error_msg(error)\n        elif isinstance(error, files.DownloadError):\n            title = 'Could not download file'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_unsupported_file():\n                text = 'This file type cannot be downloaded but must be exported.'\n                err_cls = UnsupportedFileError\n        elif isinstance(error, files.ListFolderError):\n            title = 'Could not list folder contents'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n        elif isinstance(error, files.ListFolderContinueError):\n            title = 'Could not list folder contents'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_reset():\n                text = \"Dropbox has reset its sync state. Please rebuild Maestral's index to re-sync your Dropbox.\"\n                err_cls = CursorResetError\n        elif isinstance(error, files.ListFolderLongpollError):\n            title = 'Could not get Dropbox changes'\n            if error.is_reset():\n                text = \"Dropbox has reset its sync state. Please rebuild Maestral's index to re-sync your Dropbox.\"\n                err_cls = CursorResetError\n        elif isinstance(error, async_.PollError):\n            title = 'Could not get status of batch job'\n            if error.is_internal_error():\n                text = 'Something went wrong with the job on Dropbox\u2019s end. Please verify on the Dropbox website if the job succeeded and try again if it failed.'\n                err_cls = DropboxServerError\n            else:\n                pass\n        elif isinstance(error, files.ListRevisionsError):\n            title = 'Could not list file revisions'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n        elif isinstance(error, files.RestoreError):\n            title = 'Could not restore file'\n            if error.is_invalid_revision():\n                text = 'Invalid revision.'\n                err_cls = NotFoundError\n            elif error.is_path_lookup():\n                lookup_error = error.get_path_lookup()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_path_write():\n                write_error = error.get_path_write()\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_in_progress():\n                title = 'Restore in progress'\n                text = 'Please check again later if the restore completed'\n                err_cls = SyncError\n        elif isinstance(error, files.GetMetadataError):\n            title = 'Could not get metadata'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n        elif isinstance(error, users.GetAccountError):\n            title = 'Could not get account info'\n            if error.is_no_account():\n                text = 'An account with the given Dropbox ID does not exist or has been deleted'\n                err_cls = InvalidDbidError\n        elif isinstance(error, sharing.CreateSharedLinkWithSettingsError):\n            title = 'Could not create shared link'\n            if error.is_access_denied():\n                text = 'You do not have access to create shared links for this path.'\n                err_cls = InsufficientPermissionsError\n            elif error.is_email_not_verified():\n                text = 'Please verify you email address before creating shared links'\n                err_cls = SharedLinkError\n            elif error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_settings_error():\n                settings_error = error.get_settings_error()\n                err_cls = SharedLinkError\n                if settings_error.is_invalid_settings():\n                    text = 'Please check if the settings are valid.'\n                elif settings_error.is_not_authorized():\n                    text = 'Basic accounts do not support passwords or expiry dates.'\n            elif error.is_shared_link_already_exists():\n                text = 'The shared link already exists.'\n                err_cls = SharedLinkError\n        elif isinstance(error, sharing.RevokeSharedLinkError):\n            title = 'Could not revoke shared link'\n            if error.is_shared_link_malformed():\n                text = 'The shared link is malformed.'\n                err_cls = SharedLinkError\n            elif error.is_shared_link_not_found():\n                text = 'The given link does not exist.'\n                err_cls = NotFoundError\n            elif error.is_shared_link_access_denied():\n                text = 'You do not have access to revoke the shared link.'\n                err_cls = InsufficientPermissionsError\n            elif error.is_unsupported_link_type():\n                text = 'The link type is not supported.'\n                err_cls = SharedLinkError\n        elif isinstance(error, sharing.ListSharedLinksError):\n            title = 'Could not list shared links'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_reset():\n                text = 'Please try again later.'\n                err_cls = SharedLinkError\n        elif isinstance(error, common.PathRootError):\n            if error.is_no_permission():\n                text = \"You don't have permission to access this namespace.\"\n                err_cls = InsufficientPermissionsError\n            elif error.is_invalid_root():\n                text = 'Invalid root namespace.'\n                err_cls = SyncError\n        elif isinstance(error, sharing.ShareFolderErrorBase):\n            title = 'Could not share folder'\n            if error.is_email_unverified():\n                text = 'You need to verify your email address before creating shared folders.'\n                err_cls = SyncError\n            elif error.is_bad_path():\n                path_error = error.get_bad_path()\n                (text, err_cls) = get_bad_path_error_msg(path_error)\n            elif error.is_team_policy_disallows_member_policy():\n                text = 'Team policy does not allow sharing with the specified members.'\n                err_cls = InsufficientPermissionsError\n            elif error.is_disallowed_shared_link_policy():\n                text = 'Team policy does not allow creating the specified shared link.'\n                err_cls = InsufficientPermissionsError\n            elif isinstance(error, sharing.ShareFolderError) and error.is_no_permission():\n                text = \"You don't have permissions to share this folder.\"\n                err_cls = InsufficientPermissionsError\n    elif isinstance(exc, exceptions.AuthError):\n        error = exc.error\n        if isinstance(error, auth.AuthError):\n            if error.is_expired_access_token():\n                err_cls = TokenExpiredError\n                title = 'Authentication error'\n                text = \"Maestral's access to your Dropbox has expired. Please relink to continue syncing.\"\n            elif error.is_invalid_access_token():\n                err_cls = TokenRevokedError\n                title = 'Authentication error'\n                text = \"Maestral's access to your Dropbox has been revoked. Please relink to continue syncing.\"\n            elif error.is_user_suspended():\n                err_cls = DropboxAuthError\n                title = 'Authentication error'\n                text = 'Your user account has been suspended.'\n            elif error.is_missing_scope():\n                scope_error = error.get_missing_scope()\n                required_scope = scope_error.required_scope\n                err_cls = InsufficientPermissionsError\n                title = 'Insufficient permissions'\n                text = f'Performing this action requires the {required_scope} scope.'\n            else:\n                pass\n        else:\n            err_cls = DropboxAuthError\n            title = 'Authentication error'\n            text = 'Please check if you can log in on the Dropbox website.'\n    elif isinstance(exc, exceptions.PathRootError):\n        error = exc.error\n        err_cls = PathRootError\n        title = 'Invalid root namespace'\n        if isinstance(error, common.PathRootError):\n            if error.is_no_permission():\n                text = \"You don't have permission to access this namespace.\"\n            elif error.is_invalid_root():\n                text = 'The given namespace does not exist.'\n            elif error.is_other():\n                text = 'An unexpected error occurred with the given namespace.'\n    elif isinstance(exc, (exceptions.BadInputError, ValidationError)):\n        err_cls = BadInputError\n        title = 'Bad input to API call'\n        text = exc.message\n    elif isinstance(exc, exceptions.InternalServerError):\n        err_cls = DropboxServerError\n        title = 'Dropbox server error'\n        text = 'Something went wrong on Dropbox\u2019s end. Please check on status.dropbox.com if their services are up and running and try again later.'\n    elif isinstance(exc, exceptions.HttpError):\n        text = exc.body\n    maestral_exc = err_cls(title, text, dbx_path=dbx_path, local_path=local_path)\n    maestral_exc.__cause__ = exc\n    return maestral_exc",
        "mutated": [
            "def dropbox_to_maestral_error(exc: exceptions.DropboxException | ValidationError | requests.HTTPError, dbx_path: str | None=None, local_path: str | None=None) -> MaestralApiError:\n    if False:\n        i = 10\n    '\\n    Converts a Dropbox SDK exception to a :exc:`maestral.exceptions.MaestralApiError`\\n    and tries to add a reasonably informative error title and message.\\n\\n    :param exc: Dropbox SDK exception..\\n    :param dbx_path: Dropbox path associated with the error.\\n    :param local_path: Local path associated with the error.\\n    :returns: Converted exception.\\n    '\n    title = 'An unexpected error occurred'\n    text = 'Please contact the developer with the traceback information from the logs.'\n    err_cls = MaestralApiError\n    if isinstance(exc, exceptions.ApiError):\n        error = exc.error\n        if isinstance(error, files.RelocationError):\n            title = 'Could not move file or folder'\n            if error.is_cant_copy_shared_folder():\n                text = 'Shared folders can\u2019t be copied.'\n                err_cls = SyncError\n            elif error.is_cant_move_folder_into_itself():\n                text = 'You cannot move a folder into itself.'\n                err_cls = ConflictError\n            elif error.is_cant_move_shared_folder():\n                text = 'You cannot move the shared folder to the given destination.'\n                err_cls = SyncError\n            elif error.is_cant_nest_shared_folder():\n                text = 'Your move operation would result in nested shared folders. This is not allowed.'\n                err_cls = SyncError\n            elif error.is_cant_transfer_ownership():\n                text = 'Your move operation would result in an ownership transfer. Maestral does not currently support this. Please carry out the move on the Dropbox website instead.'\n                err_cls = SyncError\n            elif error.is_duplicated_or_nested_paths():\n                text = 'There are duplicated/nested paths among the target and destination folders.'\n                err_cls = SyncError\n            elif error.is_from_lookup():\n                lookup_error = error.get_from_lookup()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_from_write():\n                write_error = error.get_from_write()\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_insufficient_quota():\n                text = 'You do not have enough space on Dropbox to move or copy the files.'\n                err_cls = InsufficientSpaceError\n            elif error.is_internal_error():\n                text = 'Something went on Dropbox\u2019s end. Please try again later.'\n                err_cls = DropboxServerError\n            elif error.is_to():\n                to_error = error.get_to()\n                (text, err_cls) = get_write_error_msg(to_error)\n            elif error.is_too_many_files():\n                text = 'There are more than 10,000 files and folders in one request. Please try to move fewer items at once.'\n                err_cls = SyncError\n            elif error.is_cant_move_into_vault():\n                vault_error = error.get_cant_move_into_vault()\n                if vault_error.is_is_shared_folder():\n                    text = 'You cannot move a shared folder into the Dropbox Vault.'\n                else:\n                    text = 'You cannot move this folder into the Dropbox Vault.'\n                err_cls = SyncError\n        elif isinstance(error, (files.CreateFolderError, files.CreateFolderEntryError)):\n            title = 'Could not create folder'\n            if error.is_path():\n                write_error = error.get_path()\n                (text, err_cls) = get_write_error_msg(write_error)\n        elif isinstance(error, files.DeleteError):\n            title = 'Could not delete item'\n            if error.is_path_lookup():\n                lookup_error = error.get_path_lookup()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_path_write():\n                write_error = error.get_path_write()\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_too_many_files():\n                text = 'There are more than 10,000 files and folders in one request. Please try to delete fewer items at once.'\n                err_cls = SyncError\n            elif error.is_too_many_write_operations():\n                text = 'There are too many write operations happening in your Dropbox. Please try again later.'\n                err_cls = SyncError\n        elif isinstance(error, files.UploadError):\n            title = 'Could not upload file'\n            if error.is_path():\n                write_error = error.get_path().reason\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_properties_error():\n                text = 'Invalid property group provided.'\n            elif error.is_payload_too_large():\n                text = 'Can only upload in chunks of at most 150 MB.'\n                err_cls = FileSizeError\n            elif error.is_content_hash_mismatch():\n                text = 'Data corruption during upload. Please try again.'\n                err_cls = DataCorruptionError\n        elif isinstance(error, files.UploadSessionStartError):\n            title = 'Could not upload file'\n            if error.is_concurrent_session_close_not_allowed():\n                text = 'Can not start a closed concurrent upload session.'\n            elif error.is_concurrent_session_data_not_allowed():\n                text = 'Uploading data not allowed when starting concurrent upload session.'\n            elif error.is_payload_too_large():\n                text = 'Can only upload in chunks of at most 150 MB.'\n                err_cls = SyncError\n            elif error.is_content_hash_mismatch():\n                text = 'Data corruption during upload. Please try again.'\n                err_cls = DataCorruptionError\n        elif isinstance(error, files.UploadSessionFinishError):\n            title = 'Could not upload file'\n            if error.is_lookup_failed():\n                session_lookup_error = error.get_lookup_failed()\n                (text, err_cls) = get_session_lookup_error_msg(session_lookup_error)\n            elif error.is_path():\n                write_error = error.get_path()\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_properties_error():\n                text = 'Invalid property group provided.'\n            elif error.is_too_many_write_operations():\n                text = 'There are too many write operations happening in your Dropbox. Please retry again later.'\n                err_cls = SyncError\n            elif error.is_too_many_shared_folder_targets():\n                text = 'The batch request commits files into too many different shared folders. Please limit your batch request to files contained in a single shared folder.'\n                err_cls = SyncError\n            elif error.is_payload_too_large():\n                text = 'Can only upload in chunks of at most 150 MB.'\n                err_cls = SyncError\n            elif error.is_content_hash_mismatch():\n                text = 'Data corruption during upload. Please try again.'\n                err_cls = DataCorruptionError\n        elif isinstance(error, files.UploadSessionLookupError):\n            title = 'Could not upload file'\n            (text, err_cls) = get_session_lookup_error_msg(error)\n        elif isinstance(error, files.DownloadError):\n            title = 'Could not download file'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_unsupported_file():\n                text = 'This file type cannot be downloaded but must be exported.'\n                err_cls = UnsupportedFileError\n        elif isinstance(error, files.ListFolderError):\n            title = 'Could not list folder contents'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n        elif isinstance(error, files.ListFolderContinueError):\n            title = 'Could not list folder contents'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_reset():\n                text = \"Dropbox has reset its sync state. Please rebuild Maestral's index to re-sync your Dropbox.\"\n                err_cls = CursorResetError\n        elif isinstance(error, files.ListFolderLongpollError):\n            title = 'Could not get Dropbox changes'\n            if error.is_reset():\n                text = \"Dropbox has reset its sync state. Please rebuild Maestral's index to re-sync your Dropbox.\"\n                err_cls = CursorResetError\n        elif isinstance(error, async_.PollError):\n            title = 'Could not get status of batch job'\n            if error.is_internal_error():\n                text = 'Something went wrong with the job on Dropbox\u2019s end. Please verify on the Dropbox website if the job succeeded and try again if it failed.'\n                err_cls = DropboxServerError\n            else:\n                pass\n        elif isinstance(error, files.ListRevisionsError):\n            title = 'Could not list file revisions'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n        elif isinstance(error, files.RestoreError):\n            title = 'Could not restore file'\n            if error.is_invalid_revision():\n                text = 'Invalid revision.'\n                err_cls = NotFoundError\n            elif error.is_path_lookup():\n                lookup_error = error.get_path_lookup()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_path_write():\n                write_error = error.get_path_write()\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_in_progress():\n                title = 'Restore in progress'\n                text = 'Please check again later if the restore completed'\n                err_cls = SyncError\n        elif isinstance(error, files.GetMetadataError):\n            title = 'Could not get metadata'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n        elif isinstance(error, users.GetAccountError):\n            title = 'Could not get account info'\n            if error.is_no_account():\n                text = 'An account with the given Dropbox ID does not exist or has been deleted'\n                err_cls = InvalidDbidError\n        elif isinstance(error, sharing.CreateSharedLinkWithSettingsError):\n            title = 'Could not create shared link'\n            if error.is_access_denied():\n                text = 'You do not have access to create shared links for this path.'\n                err_cls = InsufficientPermissionsError\n            elif error.is_email_not_verified():\n                text = 'Please verify you email address before creating shared links'\n                err_cls = SharedLinkError\n            elif error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_settings_error():\n                settings_error = error.get_settings_error()\n                err_cls = SharedLinkError\n                if settings_error.is_invalid_settings():\n                    text = 'Please check if the settings are valid.'\n                elif settings_error.is_not_authorized():\n                    text = 'Basic accounts do not support passwords or expiry dates.'\n            elif error.is_shared_link_already_exists():\n                text = 'The shared link already exists.'\n                err_cls = SharedLinkError\n        elif isinstance(error, sharing.RevokeSharedLinkError):\n            title = 'Could not revoke shared link'\n            if error.is_shared_link_malformed():\n                text = 'The shared link is malformed.'\n                err_cls = SharedLinkError\n            elif error.is_shared_link_not_found():\n                text = 'The given link does not exist.'\n                err_cls = NotFoundError\n            elif error.is_shared_link_access_denied():\n                text = 'You do not have access to revoke the shared link.'\n                err_cls = InsufficientPermissionsError\n            elif error.is_unsupported_link_type():\n                text = 'The link type is not supported.'\n                err_cls = SharedLinkError\n        elif isinstance(error, sharing.ListSharedLinksError):\n            title = 'Could not list shared links'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_reset():\n                text = 'Please try again later.'\n                err_cls = SharedLinkError\n        elif isinstance(error, common.PathRootError):\n            if error.is_no_permission():\n                text = \"You don't have permission to access this namespace.\"\n                err_cls = InsufficientPermissionsError\n            elif error.is_invalid_root():\n                text = 'Invalid root namespace.'\n                err_cls = SyncError\n        elif isinstance(error, sharing.ShareFolderErrorBase):\n            title = 'Could not share folder'\n            if error.is_email_unverified():\n                text = 'You need to verify your email address before creating shared folders.'\n                err_cls = SyncError\n            elif error.is_bad_path():\n                path_error = error.get_bad_path()\n                (text, err_cls) = get_bad_path_error_msg(path_error)\n            elif error.is_team_policy_disallows_member_policy():\n                text = 'Team policy does not allow sharing with the specified members.'\n                err_cls = InsufficientPermissionsError\n            elif error.is_disallowed_shared_link_policy():\n                text = 'Team policy does not allow creating the specified shared link.'\n                err_cls = InsufficientPermissionsError\n            elif isinstance(error, sharing.ShareFolderError) and error.is_no_permission():\n                text = \"You don't have permissions to share this folder.\"\n                err_cls = InsufficientPermissionsError\n    elif isinstance(exc, exceptions.AuthError):\n        error = exc.error\n        if isinstance(error, auth.AuthError):\n            if error.is_expired_access_token():\n                err_cls = TokenExpiredError\n                title = 'Authentication error'\n                text = \"Maestral's access to your Dropbox has expired. Please relink to continue syncing.\"\n            elif error.is_invalid_access_token():\n                err_cls = TokenRevokedError\n                title = 'Authentication error'\n                text = \"Maestral's access to your Dropbox has been revoked. Please relink to continue syncing.\"\n            elif error.is_user_suspended():\n                err_cls = DropboxAuthError\n                title = 'Authentication error'\n                text = 'Your user account has been suspended.'\n            elif error.is_missing_scope():\n                scope_error = error.get_missing_scope()\n                required_scope = scope_error.required_scope\n                err_cls = InsufficientPermissionsError\n                title = 'Insufficient permissions'\n                text = f'Performing this action requires the {required_scope} scope.'\n            else:\n                pass\n        else:\n            err_cls = DropboxAuthError\n            title = 'Authentication error'\n            text = 'Please check if you can log in on the Dropbox website.'\n    elif isinstance(exc, exceptions.PathRootError):\n        error = exc.error\n        err_cls = PathRootError\n        title = 'Invalid root namespace'\n        if isinstance(error, common.PathRootError):\n            if error.is_no_permission():\n                text = \"You don't have permission to access this namespace.\"\n            elif error.is_invalid_root():\n                text = 'The given namespace does not exist.'\n            elif error.is_other():\n                text = 'An unexpected error occurred with the given namespace.'\n    elif isinstance(exc, (exceptions.BadInputError, ValidationError)):\n        err_cls = BadInputError\n        title = 'Bad input to API call'\n        text = exc.message\n    elif isinstance(exc, exceptions.InternalServerError):\n        err_cls = DropboxServerError\n        title = 'Dropbox server error'\n        text = 'Something went wrong on Dropbox\u2019s end. Please check on status.dropbox.com if their services are up and running and try again later.'\n    elif isinstance(exc, exceptions.HttpError):\n        text = exc.body\n    maestral_exc = err_cls(title, text, dbx_path=dbx_path, local_path=local_path)\n    maestral_exc.__cause__ = exc\n    return maestral_exc",
            "def dropbox_to_maestral_error(exc: exceptions.DropboxException | ValidationError | requests.HTTPError, dbx_path: str | None=None, local_path: str | None=None) -> MaestralApiError:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Converts a Dropbox SDK exception to a :exc:`maestral.exceptions.MaestralApiError`\\n    and tries to add a reasonably informative error title and message.\\n\\n    :param exc: Dropbox SDK exception..\\n    :param dbx_path: Dropbox path associated with the error.\\n    :param local_path: Local path associated with the error.\\n    :returns: Converted exception.\\n    '\n    title = 'An unexpected error occurred'\n    text = 'Please contact the developer with the traceback information from the logs.'\n    err_cls = MaestralApiError\n    if isinstance(exc, exceptions.ApiError):\n        error = exc.error\n        if isinstance(error, files.RelocationError):\n            title = 'Could not move file or folder'\n            if error.is_cant_copy_shared_folder():\n                text = 'Shared folders can\u2019t be copied.'\n                err_cls = SyncError\n            elif error.is_cant_move_folder_into_itself():\n                text = 'You cannot move a folder into itself.'\n                err_cls = ConflictError\n            elif error.is_cant_move_shared_folder():\n                text = 'You cannot move the shared folder to the given destination.'\n                err_cls = SyncError\n            elif error.is_cant_nest_shared_folder():\n                text = 'Your move operation would result in nested shared folders. This is not allowed.'\n                err_cls = SyncError\n            elif error.is_cant_transfer_ownership():\n                text = 'Your move operation would result in an ownership transfer. Maestral does not currently support this. Please carry out the move on the Dropbox website instead.'\n                err_cls = SyncError\n            elif error.is_duplicated_or_nested_paths():\n                text = 'There are duplicated/nested paths among the target and destination folders.'\n                err_cls = SyncError\n            elif error.is_from_lookup():\n                lookup_error = error.get_from_lookup()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_from_write():\n                write_error = error.get_from_write()\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_insufficient_quota():\n                text = 'You do not have enough space on Dropbox to move or copy the files.'\n                err_cls = InsufficientSpaceError\n            elif error.is_internal_error():\n                text = 'Something went on Dropbox\u2019s end. Please try again later.'\n                err_cls = DropboxServerError\n            elif error.is_to():\n                to_error = error.get_to()\n                (text, err_cls) = get_write_error_msg(to_error)\n            elif error.is_too_many_files():\n                text = 'There are more than 10,000 files and folders in one request. Please try to move fewer items at once.'\n                err_cls = SyncError\n            elif error.is_cant_move_into_vault():\n                vault_error = error.get_cant_move_into_vault()\n                if vault_error.is_is_shared_folder():\n                    text = 'You cannot move a shared folder into the Dropbox Vault.'\n                else:\n                    text = 'You cannot move this folder into the Dropbox Vault.'\n                err_cls = SyncError\n        elif isinstance(error, (files.CreateFolderError, files.CreateFolderEntryError)):\n            title = 'Could not create folder'\n            if error.is_path():\n                write_error = error.get_path()\n                (text, err_cls) = get_write_error_msg(write_error)\n        elif isinstance(error, files.DeleteError):\n            title = 'Could not delete item'\n            if error.is_path_lookup():\n                lookup_error = error.get_path_lookup()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_path_write():\n                write_error = error.get_path_write()\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_too_many_files():\n                text = 'There are more than 10,000 files and folders in one request. Please try to delete fewer items at once.'\n                err_cls = SyncError\n            elif error.is_too_many_write_operations():\n                text = 'There are too many write operations happening in your Dropbox. Please try again later.'\n                err_cls = SyncError\n        elif isinstance(error, files.UploadError):\n            title = 'Could not upload file'\n            if error.is_path():\n                write_error = error.get_path().reason\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_properties_error():\n                text = 'Invalid property group provided.'\n            elif error.is_payload_too_large():\n                text = 'Can only upload in chunks of at most 150 MB.'\n                err_cls = FileSizeError\n            elif error.is_content_hash_mismatch():\n                text = 'Data corruption during upload. Please try again.'\n                err_cls = DataCorruptionError\n        elif isinstance(error, files.UploadSessionStartError):\n            title = 'Could not upload file'\n            if error.is_concurrent_session_close_not_allowed():\n                text = 'Can not start a closed concurrent upload session.'\n            elif error.is_concurrent_session_data_not_allowed():\n                text = 'Uploading data not allowed when starting concurrent upload session.'\n            elif error.is_payload_too_large():\n                text = 'Can only upload in chunks of at most 150 MB.'\n                err_cls = SyncError\n            elif error.is_content_hash_mismatch():\n                text = 'Data corruption during upload. Please try again.'\n                err_cls = DataCorruptionError\n        elif isinstance(error, files.UploadSessionFinishError):\n            title = 'Could not upload file'\n            if error.is_lookup_failed():\n                session_lookup_error = error.get_lookup_failed()\n                (text, err_cls) = get_session_lookup_error_msg(session_lookup_error)\n            elif error.is_path():\n                write_error = error.get_path()\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_properties_error():\n                text = 'Invalid property group provided.'\n            elif error.is_too_many_write_operations():\n                text = 'There are too many write operations happening in your Dropbox. Please retry again later.'\n                err_cls = SyncError\n            elif error.is_too_many_shared_folder_targets():\n                text = 'The batch request commits files into too many different shared folders. Please limit your batch request to files contained in a single shared folder.'\n                err_cls = SyncError\n            elif error.is_payload_too_large():\n                text = 'Can only upload in chunks of at most 150 MB.'\n                err_cls = SyncError\n            elif error.is_content_hash_mismatch():\n                text = 'Data corruption during upload. Please try again.'\n                err_cls = DataCorruptionError\n        elif isinstance(error, files.UploadSessionLookupError):\n            title = 'Could not upload file'\n            (text, err_cls) = get_session_lookup_error_msg(error)\n        elif isinstance(error, files.DownloadError):\n            title = 'Could not download file'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_unsupported_file():\n                text = 'This file type cannot be downloaded but must be exported.'\n                err_cls = UnsupportedFileError\n        elif isinstance(error, files.ListFolderError):\n            title = 'Could not list folder contents'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n        elif isinstance(error, files.ListFolderContinueError):\n            title = 'Could not list folder contents'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_reset():\n                text = \"Dropbox has reset its sync state. Please rebuild Maestral's index to re-sync your Dropbox.\"\n                err_cls = CursorResetError\n        elif isinstance(error, files.ListFolderLongpollError):\n            title = 'Could not get Dropbox changes'\n            if error.is_reset():\n                text = \"Dropbox has reset its sync state. Please rebuild Maestral's index to re-sync your Dropbox.\"\n                err_cls = CursorResetError\n        elif isinstance(error, async_.PollError):\n            title = 'Could not get status of batch job'\n            if error.is_internal_error():\n                text = 'Something went wrong with the job on Dropbox\u2019s end. Please verify on the Dropbox website if the job succeeded and try again if it failed.'\n                err_cls = DropboxServerError\n            else:\n                pass\n        elif isinstance(error, files.ListRevisionsError):\n            title = 'Could not list file revisions'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n        elif isinstance(error, files.RestoreError):\n            title = 'Could not restore file'\n            if error.is_invalid_revision():\n                text = 'Invalid revision.'\n                err_cls = NotFoundError\n            elif error.is_path_lookup():\n                lookup_error = error.get_path_lookup()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_path_write():\n                write_error = error.get_path_write()\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_in_progress():\n                title = 'Restore in progress'\n                text = 'Please check again later if the restore completed'\n                err_cls = SyncError\n        elif isinstance(error, files.GetMetadataError):\n            title = 'Could not get metadata'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n        elif isinstance(error, users.GetAccountError):\n            title = 'Could not get account info'\n            if error.is_no_account():\n                text = 'An account with the given Dropbox ID does not exist or has been deleted'\n                err_cls = InvalidDbidError\n        elif isinstance(error, sharing.CreateSharedLinkWithSettingsError):\n            title = 'Could not create shared link'\n            if error.is_access_denied():\n                text = 'You do not have access to create shared links for this path.'\n                err_cls = InsufficientPermissionsError\n            elif error.is_email_not_verified():\n                text = 'Please verify you email address before creating shared links'\n                err_cls = SharedLinkError\n            elif error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_settings_error():\n                settings_error = error.get_settings_error()\n                err_cls = SharedLinkError\n                if settings_error.is_invalid_settings():\n                    text = 'Please check if the settings are valid.'\n                elif settings_error.is_not_authorized():\n                    text = 'Basic accounts do not support passwords or expiry dates.'\n            elif error.is_shared_link_already_exists():\n                text = 'The shared link already exists.'\n                err_cls = SharedLinkError\n        elif isinstance(error, sharing.RevokeSharedLinkError):\n            title = 'Could not revoke shared link'\n            if error.is_shared_link_malformed():\n                text = 'The shared link is malformed.'\n                err_cls = SharedLinkError\n            elif error.is_shared_link_not_found():\n                text = 'The given link does not exist.'\n                err_cls = NotFoundError\n            elif error.is_shared_link_access_denied():\n                text = 'You do not have access to revoke the shared link.'\n                err_cls = InsufficientPermissionsError\n            elif error.is_unsupported_link_type():\n                text = 'The link type is not supported.'\n                err_cls = SharedLinkError\n        elif isinstance(error, sharing.ListSharedLinksError):\n            title = 'Could not list shared links'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_reset():\n                text = 'Please try again later.'\n                err_cls = SharedLinkError\n        elif isinstance(error, common.PathRootError):\n            if error.is_no_permission():\n                text = \"You don't have permission to access this namespace.\"\n                err_cls = InsufficientPermissionsError\n            elif error.is_invalid_root():\n                text = 'Invalid root namespace.'\n                err_cls = SyncError\n        elif isinstance(error, sharing.ShareFolderErrorBase):\n            title = 'Could not share folder'\n            if error.is_email_unverified():\n                text = 'You need to verify your email address before creating shared folders.'\n                err_cls = SyncError\n            elif error.is_bad_path():\n                path_error = error.get_bad_path()\n                (text, err_cls) = get_bad_path_error_msg(path_error)\n            elif error.is_team_policy_disallows_member_policy():\n                text = 'Team policy does not allow sharing with the specified members.'\n                err_cls = InsufficientPermissionsError\n            elif error.is_disallowed_shared_link_policy():\n                text = 'Team policy does not allow creating the specified shared link.'\n                err_cls = InsufficientPermissionsError\n            elif isinstance(error, sharing.ShareFolderError) and error.is_no_permission():\n                text = \"You don't have permissions to share this folder.\"\n                err_cls = InsufficientPermissionsError\n    elif isinstance(exc, exceptions.AuthError):\n        error = exc.error\n        if isinstance(error, auth.AuthError):\n            if error.is_expired_access_token():\n                err_cls = TokenExpiredError\n                title = 'Authentication error'\n                text = \"Maestral's access to your Dropbox has expired. Please relink to continue syncing.\"\n            elif error.is_invalid_access_token():\n                err_cls = TokenRevokedError\n                title = 'Authentication error'\n                text = \"Maestral's access to your Dropbox has been revoked. Please relink to continue syncing.\"\n            elif error.is_user_suspended():\n                err_cls = DropboxAuthError\n                title = 'Authentication error'\n                text = 'Your user account has been suspended.'\n            elif error.is_missing_scope():\n                scope_error = error.get_missing_scope()\n                required_scope = scope_error.required_scope\n                err_cls = InsufficientPermissionsError\n                title = 'Insufficient permissions'\n                text = f'Performing this action requires the {required_scope} scope.'\n            else:\n                pass\n        else:\n            err_cls = DropboxAuthError\n            title = 'Authentication error'\n            text = 'Please check if you can log in on the Dropbox website.'\n    elif isinstance(exc, exceptions.PathRootError):\n        error = exc.error\n        err_cls = PathRootError\n        title = 'Invalid root namespace'\n        if isinstance(error, common.PathRootError):\n            if error.is_no_permission():\n                text = \"You don't have permission to access this namespace.\"\n            elif error.is_invalid_root():\n                text = 'The given namespace does not exist.'\n            elif error.is_other():\n                text = 'An unexpected error occurred with the given namespace.'\n    elif isinstance(exc, (exceptions.BadInputError, ValidationError)):\n        err_cls = BadInputError\n        title = 'Bad input to API call'\n        text = exc.message\n    elif isinstance(exc, exceptions.InternalServerError):\n        err_cls = DropboxServerError\n        title = 'Dropbox server error'\n        text = 'Something went wrong on Dropbox\u2019s end. Please check on status.dropbox.com if their services are up and running and try again later.'\n    elif isinstance(exc, exceptions.HttpError):\n        text = exc.body\n    maestral_exc = err_cls(title, text, dbx_path=dbx_path, local_path=local_path)\n    maestral_exc.__cause__ = exc\n    return maestral_exc",
            "def dropbox_to_maestral_error(exc: exceptions.DropboxException | ValidationError | requests.HTTPError, dbx_path: str | None=None, local_path: str | None=None) -> MaestralApiError:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Converts a Dropbox SDK exception to a :exc:`maestral.exceptions.MaestralApiError`\\n    and tries to add a reasonably informative error title and message.\\n\\n    :param exc: Dropbox SDK exception..\\n    :param dbx_path: Dropbox path associated with the error.\\n    :param local_path: Local path associated with the error.\\n    :returns: Converted exception.\\n    '\n    title = 'An unexpected error occurred'\n    text = 'Please contact the developer with the traceback information from the logs.'\n    err_cls = MaestralApiError\n    if isinstance(exc, exceptions.ApiError):\n        error = exc.error\n        if isinstance(error, files.RelocationError):\n            title = 'Could not move file or folder'\n            if error.is_cant_copy_shared_folder():\n                text = 'Shared folders can\u2019t be copied.'\n                err_cls = SyncError\n            elif error.is_cant_move_folder_into_itself():\n                text = 'You cannot move a folder into itself.'\n                err_cls = ConflictError\n            elif error.is_cant_move_shared_folder():\n                text = 'You cannot move the shared folder to the given destination.'\n                err_cls = SyncError\n            elif error.is_cant_nest_shared_folder():\n                text = 'Your move operation would result in nested shared folders. This is not allowed.'\n                err_cls = SyncError\n            elif error.is_cant_transfer_ownership():\n                text = 'Your move operation would result in an ownership transfer. Maestral does not currently support this. Please carry out the move on the Dropbox website instead.'\n                err_cls = SyncError\n            elif error.is_duplicated_or_nested_paths():\n                text = 'There are duplicated/nested paths among the target and destination folders.'\n                err_cls = SyncError\n            elif error.is_from_lookup():\n                lookup_error = error.get_from_lookup()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_from_write():\n                write_error = error.get_from_write()\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_insufficient_quota():\n                text = 'You do not have enough space on Dropbox to move or copy the files.'\n                err_cls = InsufficientSpaceError\n            elif error.is_internal_error():\n                text = 'Something went on Dropbox\u2019s end. Please try again later.'\n                err_cls = DropboxServerError\n            elif error.is_to():\n                to_error = error.get_to()\n                (text, err_cls) = get_write_error_msg(to_error)\n            elif error.is_too_many_files():\n                text = 'There are more than 10,000 files and folders in one request. Please try to move fewer items at once.'\n                err_cls = SyncError\n            elif error.is_cant_move_into_vault():\n                vault_error = error.get_cant_move_into_vault()\n                if vault_error.is_is_shared_folder():\n                    text = 'You cannot move a shared folder into the Dropbox Vault.'\n                else:\n                    text = 'You cannot move this folder into the Dropbox Vault.'\n                err_cls = SyncError\n        elif isinstance(error, (files.CreateFolderError, files.CreateFolderEntryError)):\n            title = 'Could not create folder'\n            if error.is_path():\n                write_error = error.get_path()\n                (text, err_cls) = get_write_error_msg(write_error)\n        elif isinstance(error, files.DeleteError):\n            title = 'Could not delete item'\n            if error.is_path_lookup():\n                lookup_error = error.get_path_lookup()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_path_write():\n                write_error = error.get_path_write()\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_too_many_files():\n                text = 'There are more than 10,000 files and folders in one request. Please try to delete fewer items at once.'\n                err_cls = SyncError\n            elif error.is_too_many_write_operations():\n                text = 'There are too many write operations happening in your Dropbox. Please try again later.'\n                err_cls = SyncError\n        elif isinstance(error, files.UploadError):\n            title = 'Could not upload file'\n            if error.is_path():\n                write_error = error.get_path().reason\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_properties_error():\n                text = 'Invalid property group provided.'\n            elif error.is_payload_too_large():\n                text = 'Can only upload in chunks of at most 150 MB.'\n                err_cls = FileSizeError\n            elif error.is_content_hash_mismatch():\n                text = 'Data corruption during upload. Please try again.'\n                err_cls = DataCorruptionError\n        elif isinstance(error, files.UploadSessionStartError):\n            title = 'Could not upload file'\n            if error.is_concurrent_session_close_not_allowed():\n                text = 'Can not start a closed concurrent upload session.'\n            elif error.is_concurrent_session_data_not_allowed():\n                text = 'Uploading data not allowed when starting concurrent upload session.'\n            elif error.is_payload_too_large():\n                text = 'Can only upload in chunks of at most 150 MB.'\n                err_cls = SyncError\n            elif error.is_content_hash_mismatch():\n                text = 'Data corruption during upload. Please try again.'\n                err_cls = DataCorruptionError\n        elif isinstance(error, files.UploadSessionFinishError):\n            title = 'Could not upload file'\n            if error.is_lookup_failed():\n                session_lookup_error = error.get_lookup_failed()\n                (text, err_cls) = get_session_lookup_error_msg(session_lookup_error)\n            elif error.is_path():\n                write_error = error.get_path()\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_properties_error():\n                text = 'Invalid property group provided.'\n            elif error.is_too_many_write_operations():\n                text = 'There are too many write operations happening in your Dropbox. Please retry again later.'\n                err_cls = SyncError\n            elif error.is_too_many_shared_folder_targets():\n                text = 'The batch request commits files into too many different shared folders. Please limit your batch request to files contained in a single shared folder.'\n                err_cls = SyncError\n            elif error.is_payload_too_large():\n                text = 'Can only upload in chunks of at most 150 MB.'\n                err_cls = SyncError\n            elif error.is_content_hash_mismatch():\n                text = 'Data corruption during upload. Please try again.'\n                err_cls = DataCorruptionError\n        elif isinstance(error, files.UploadSessionLookupError):\n            title = 'Could not upload file'\n            (text, err_cls) = get_session_lookup_error_msg(error)\n        elif isinstance(error, files.DownloadError):\n            title = 'Could not download file'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_unsupported_file():\n                text = 'This file type cannot be downloaded but must be exported.'\n                err_cls = UnsupportedFileError\n        elif isinstance(error, files.ListFolderError):\n            title = 'Could not list folder contents'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n        elif isinstance(error, files.ListFolderContinueError):\n            title = 'Could not list folder contents'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_reset():\n                text = \"Dropbox has reset its sync state. Please rebuild Maestral's index to re-sync your Dropbox.\"\n                err_cls = CursorResetError\n        elif isinstance(error, files.ListFolderLongpollError):\n            title = 'Could not get Dropbox changes'\n            if error.is_reset():\n                text = \"Dropbox has reset its sync state. Please rebuild Maestral's index to re-sync your Dropbox.\"\n                err_cls = CursorResetError\n        elif isinstance(error, async_.PollError):\n            title = 'Could not get status of batch job'\n            if error.is_internal_error():\n                text = 'Something went wrong with the job on Dropbox\u2019s end. Please verify on the Dropbox website if the job succeeded and try again if it failed.'\n                err_cls = DropboxServerError\n            else:\n                pass\n        elif isinstance(error, files.ListRevisionsError):\n            title = 'Could not list file revisions'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n        elif isinstance(error, files.RestoreError):\n            title = 'Could not restore file'\n            if error.is_invalid_revision():\n                text = 'Invalid revision.'\n                err_cls = NotFoundError\n            elif error.is_path_lookup():\n                lookup_error = error.get_path_lookup()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_path_write():\n                write_error = error.get_path_write()\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_in_progress():\n                title = 'Restore in progress'\n                text = 'Please check again later if the restore completed'\n                err_cls = SyncError\n        elif isinstance(error, files.GetMetadataError):\n            title = 'Could not get metadata'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n        elif isinstance(error, users.GetAccountError):\n            title = 'Could not get account info'\n            if error.is_no_account():\n                text = 'An account with the given Dropbox ID does not exist or has been deleted'\n                err_cls = InvalidDbidError\n        elif isinstance(error, sharing.CreateSharedLinkWithSettingsError):\n            title = 'Could not create shared link'\n            if error.is_access_denied():\n                text = 'You do not have access to create shared links for this path.'\n                err_cls = InsufficientPermissionsError\n            elif error.is_email_not_verified():\n                text = 'Please verify you email address before creating shared links'\n                err_cls = SharedLinkError\n            elif error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_settings_error():\n                settings_error = error.get_settings_error()\n                err_cls = SharedLinkError\n                if settings_error.is_invalid_settings():\n                    text = 'Please check if the settings are valid.'\n                elif settings_error.is_not_authorized():\n                    text = 'Basic accounts do not support passwords or expiry dates.'\n            elif error.is_shared_link_already_exists():\n                text = 'The shared link already exists.'\n                err_cls = SharedLinkError\n        elif isinstance(error, sharing.RevokeSharedLinkError):\n            title = 'Could not revoke shared link'\n            if error.is_shared_link_malformed():\n                text = 'The shared link is malformed.'\n                err_cls = SharedLinkError\n            elif error.is_shared_link_not_found():\n                text = 'The given link does not exist.'\n                err_cls = NotFoundError\n            elif error.is_shared_link_access_denied():\n                text = 'You do not have access to revoke the shared link.'\n                err_cls = InsufficientPermissionsError\n            elif error.is_unsupported_link_type():\n                text = 'The link type is not supported.'\n                err_cls = SharedLinkError\n        elif isinstance(error, sharing.ListSharedLinksError):\n            title = 'Could not list shared links'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_reset():\n                text = 'Please try again later.'\n                err_cls = SharedLinkError\n        elif isinstance(error, common.PathRootError):\n            if error.is_no_permission():\n                text = \"You don't have permission to access this namespace.\"\n                err_cls = InsufficientPermissionsError\n            elif error.is_invalid_root():\n                text = 'Invalid root namespace.'\n                err_cls = SyncError\n        elif isinstance(error, sharing.ShareFolderErrorBase):\n            title = 'Could not share folder'\n            if error.is_email_unverified():\n                text = 'You need to verify your email address before creating shared folders.'\n                err_cls = SyncError\n            elif error.is_bad_path():\n                path_error = error.get_bad_path()\n                (text, err_cls) = get_bad_path_error_msg(path_error)\n            elif error.is_team_policy_disallows_member_policy():\n                text = 'Team policy does not allow sharing with the specified members.'\n                err_cls = InsufficientPermissionsError\n            elif error.is_disallowed_shared_link_policy():\n                text = 'Team policy does not allow creating the specified shared link.'\n                err_cls = InsufficientPermissionsError\n            elif isinstance(error, sharing.ShareFolderError) and error.is_no_permission():\n                text = \"You don't have permissions to share this folder.\"\n                err_cls = InsufficientPermissionsError\n    elif isinstance(exc, exceptions.AuthError):\n        error = exc.error\n        if isinstance(error, auth.AuthError):\n            if error.is_expired_access_token():\n                err_cls = TokenExpiredError\n                title = 'Authentication error'\n                text = \"Maestral's access to your Dropbox has expired. Please relink to continue syncing.\"\n            elif error.is_invalid_access_token():\n                err_cls = TokenRevokedError\n                title = 'Authentication error'\n                text = \"Maestral's access to your Dropbox has been revoked. Please relink to continue syncing.\"\n            elif error.is_user_suspended():\n                err_cls = DropboxAuthError\n                title = 'Authentication error'\n                text = 'Your user account has been suspended.'\n            elif error.is_missing_scope():\n                scope_error = error.get_missing_scope()\n                required_scope = scope_error.required_scope\n                err_cls = InsufficientPermissionsError\n                title = 'Insufficient permissions'\n                text = f'Performing this action requires the {required_scope} scope.'\n            else:\n                pass\n        else:\n            err_cls = DropboxAuthError\n            title = 'Authentication error'\n            text = 'Please check if you can log in on the Dropbox website.'\n    elif isinstance(exc, exceptions.PathRootError):\n        error = exc.error\n        err_cls = PathRootError\n        title = 'Invalid root namespace'\n        if isinstance(error, common.PathRootError):\n            if error.is_no_permission():\n                text = \"You don't have permission to access this namespace.\"\n            elif error.is_invalid_root():\n                text = 'The given namespace does not exist.'\n            elif error.is_other():\n                text = 'An unexpected error occurred with the given namespace.'\n    elif isinstance(exc, (exceptions.BadInputError, ValidationError)):\n        err_cls = BadInputError\n        title = 'Bad input to API call'\n        text = exc.message\n    elif isinstance(exc, exceptions.InternalServerError):\n        err_cls = DropboxServerError\n        title = 'Dropbox server error'\n        text = 'Something went wrong on Dropbox\u2019s end. Please check on status.dropbox.com if their services are up and running and try again later.'\n    elif isinstance(exc, exceptions.HttpError):\n        text = exc.body\n    maestral_exc = err_cls(title, text, dbx_path=dbx_path, local_path=local_path)\n    maestral_exc.__cause__ = exc\n    return maestral_exc",
            "def dropbox_to_maestral_error(exc: exceptions.DropboxException | ValidationError | requests.HTTPError, dbx_path: str | None=None, local_path: str | None=None) -> MaestralApiError:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Converts a Dropbox SDK exception to a :exc:`maestral.exceptions.MaestralApiError`\\n    and tries to add a reasonably informative error title and message.\\n\\n    :param exc: Dropbox SDK exception..\\n    :param dbx_path: Dropbox path associated with the error.\\n    :param local_path: Local path associated with the error.\\n    :returns: Converted exception.\\n    '\n    title = 'An unexpected error occurred'\n    text = 'Please contact the developer with the traceback information from the logs.'\n    err_cls = MaestralApiError\n    if isinstance(exc, exceptions.ApiError):\n        error = exc.error\n        if isinstance(error, files.RelocationError):\n            title = 'Could not move file or folder'\n            if error.is_cant_copy_shared_folder():\n                text = 'Shared folders can\u2019t be copied.'\n                err_cls = SyncError\n            elif error.is_cant_move_folder_into_itself():\n                text = 'You cannot move a folder into itself.'\n                err_cls = ConflictError\n            elif error.is_cant_move_shared_folder():\n                text = 'You cannot move the shared folder to the given destination.'\n                err_cls = SyncError\n            elif error.is_cant_nest_shared_folder():\n                text = 'Your move operation would result in nested shared folders. This is not allowed.'\n                err_cls = SyncError\n            elif error.is_cant_transfer_ownership():\n                text = 'Your move operation would result in an ownership transfer. Maestral does not currently support this. Please carry out the move on the Dropbox website instead.'\n                err_cls = SyncError\n            elif error.is_duplicated_or_nested_paths():\n                text = 'There are duplicated/nested paths among the target and destination folders.'\n                err_cls = SyncError\n            elif error.is_from_lookup():\n                lookup_error = error.get_from_lookup()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_from_write():\n                write_error = error.get_from_write()\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_insufficient_quota():\n                text = 'You do not have enough space on Dropbox to move or copy the files.'\n                err_cls = InsufficientSpaceError\n            elif error.is_internal_error():\n                text = 'Something went on Dropbox\u2019s end. Please try again later.'\n                err_cls = DropboxServerError\n            elif error.is_to():\n                to_error = error.get_to()\n                (text, err_cls) = get_write_error_msg(to_error)\n            elif error.is_too_many_files():\n                text = 'There are more than 10,000 files and folders in one request. Please try to move fewer items at once.'\n                err_cls = SyncError\n            elif error.is_cant_move_into_vault():\n                vault_error = error.get_cant_move_into_vault()\n                if vault_error.is_is_shared_folder():\n                    text = 'You cannot move a shared folder into the Dropbox Vault.'\n                else:\n                    text = 'You cannot move this folder into the Dropbox Vault.'\n                err_cls = SyncError\n        elif isinstance(error, (files.CreateFolderError, files.CreateFolderEntryError)):\n            title = 'Could not create folder'\n            if error.is_path():\n                write_error = error.get_path()\n                (text, err_cls) = get_write_error_msg(write_error)\n        elif isinstance(error, files.DeleteError):\n            title = 'Could not delete item'\n            if error.is_path_lookup():\n                lookup_error = error.get_path_lookup()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_path_write():\n                write_error = error.get_path_write()\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_too_many_files():\n                text = 'There are more than 10,000 files and folders in one request. Please try to delete fewer items at once.'\n                err_cls = SyncError\n            elif error.is_too_many_write_operations():\n                text = 'There are too many write operations happening in your Dropbox. Please try again later.'\n                err_cls = SyncError\n        elif isinstance(error, files.UploadError):\n            title = 'Could not upload file'\n            if error.is_path():\n                write_error = error.get_path().reason\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_properties_error():\n                text = 'Invalid property group provided.'\n            elif error.is_payload_too_large():\n                text = 'Can only upload in chunks of at most 150 MB.'\n                err_cls = FileSizeError\n            elif error.is_content_hash_mismatch():\n                text = 'Data corruption during upload. Please try again.'\n                err_cls = DataCorruptionError\n        elif isinstance(error, files.UploadSessionStartError):\n            title = 'Could not upload file'\n            if error.is_concurrent_session_close_not_allowed():\n                text = 'Can not start a closed concurrent upload session.'\n            elif error.is_concurrent_session_data_not_allowed():\n                text = 'Uploading data not allowed when starting concurrent upload session.'\n            elif error.is_payload_too_large():\n                text = 'Can only upload in chunks of at most 150 MB.'\n                err_cls = SyncError\n            elif error.is_content_hash_mismatch():\n                text = 'Data corruption during upload. Please try again.'\n                err_cls = DataCorruptionError\n        elif isinstance(error, files.UploadSessionFinishError):\n            title = 'Could not upload file'\n            if error.is_lookup_failed():\n                session_lookup_error = error.get_lookup_failed()\n                (text, err_cls) = get_session_lookup_error_msg(session_lookup_error)\n            elif error.is_path():\n                write_error = error.get_path()\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_properties_error():\n                text = 'Invalid property group provided.'\n            elif error.is_too_many_write_operations():\n                text = 'There are too many write operations happening in your Dropbox. Please retry again later.'\n                err_cls = SyncError\n            elif error.is_too_many_shared_folder_targets():\n                text = 'The batch request commits files into too many different shared folders. Please limit your batch request to files contained in a single shared folder.'\n                err_cls = SyncError\n            elif error.is_payload_too_large():\n                text = 'Can only upload in chunks of at most 150 MB.'\n                err_cls = SyncError\n            elif error.is_content_hash_mismatch():\n                text = 'Data corruption during upload. Please try again.'\n                err_cls = DataCorruptionError\n        elif isinstance(error, files.UploadSessionLookupError):\n            title = 'Could not upload file'\n            (text, err_cls) = get_session_lookup_error_msg(error)\n        elif isinstance(error, files.DownloadError):\n            title = 'Could not download file'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_unsupported_file():\n                text = 'This file type cannot be downloaded but must be exported.'\n                err_cls = UnsupportedFileError\n        elif isinstance(error, files.ListFolderError):\n            title = 'Could not list folder contents'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n        elif isinstance(error, files.ListFolderContinueError):\n            title = 'Could not list folder contents'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_reset():\n                text = \"Dropbox has reset its sync state. Please rebuild Maestral's index to re-sync your Dropbox.\"\n                err_cls = CursorResetError\n        elif isinstance(error, files.ListFolderLongpollError):\n            title = 'Could not get Dropbox changes'\n            if error.is_reset():\n                text = \"Dropbox has reset its sync state. Please rebuild Maestral's index to re-sync your Dropbox.\"\n                err_cls = CursorResetError\n        elif isinstance(error, async_.PollError):\n            title = 'Could not get status of batch job'\n            if error.is_internal_error():\n                text = 'Something went wrong with the job on Dropbox\u2019s end. Please verify on the Dropbox website if the job succeeded and try again if it failed.'\n                err_cls = DropboxServerError\n            else:\n                pass\n        elif isinstance(error, files.ListRevisionsError):\n            title = 'Could not list file revisions'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n        elif isinstance(error, files.RestoreError):\n            title = 'Could not restore file'\n            if error.is_invalid_revision():\n                text = 'Invalid revision.'\n                err_cls = NotFoundError\n            elif error.is_path_lookup():\n                lookup_error = error.get_path_lookup()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_path_write():\n                write_error = error.get_path_write()\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_in_progress():\n                title = 'Restore in progress'\n                text = 'Please check again later if the restore completed'\n                err_cls = SyncError\n        elif isinstance(error, files.GetMetadataError):\n            title = 'Could not get metadata'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n        elif isinstance(error, users.GetAccountError):\n            title = 'Could not get account info'\n            if error.is_no_account():\n                text = 'An account with the given Dropbox ID does not exist or has been deleted'\n                err_cls = InvalidDbidError\n        elif isinstance(error, sharing.CreateSharedLinkWithSettingsError):\n            title = 'Could not create shared link'\n            if error.is_access_denied():\n                text = 'You do not have access to create shared links for this path.'\n                err_cls = InsufficientPermissionsError\n            elif error.is_email_not_verified():\n                text = 'Please verify you email address before creating shared links'\n                err_cls = SharedLinkError\n            elif error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_settings_error():\n                settings_error = error.get_settings_error()\n                err_cls = SharedLinkError\n                if settings_error.is_invalid_settings():\n                    text = 'Please check if the settings are valid.'\n                elif settings_error.is_not_authorized():\n                    text = 'Basic accounts do not support passwords or expiry dates.'\n            elif error.is_shared_link_already_exists():\n                text = 'The shared link already exists.'\n                err_cls = SharedLinkError\n        elif isinstance(error, sharing.RevokeSharedLinkError):\n            title = 'Could not revoke shared link'\n            if error.is_shared_link_malformed():\n                text = 'The shared link is malformed.'\n                err_cls = SharedLinkError\n            elif error.is_shared_link_not_found():\n                text = 'The given link does not exist.'\n                err_cls = NotFoundError\n            elif error.is_shared_link_access_denied():\n                text = 'You do not have access to revoke the shared link.'\n                err_cls = InsufficientPermissionsError\n            elif error.is_unsupported_link_type():\n                text = 'The link type is not supported.'\n                err_cls = SharedLinkError\n        elif isinstance(error, sharing.ListSharedLinksError):\n            title = 'Could not list shared links'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_reset():\n                text = 'Please try again later.'\n                err_cls = SharedLinkError\n        elif isinstance(error, common.PathRootError):\n            if error.is_no_permission():\n                text = \"You don't have permission to access this namespace.\"\n                err_cls = InsufficientPermissionsError\n            elif error.is_invalid_root():\n                text = 'Invalid root namespace.'\n                err_cls = SyncError\n        elif isinstance(error, sharing.ShareFolderErrorBase):\n            title = 'Could not share folder'\n            if error.is_email_unverified():\n                text = 'You need to verify your email address before creating shared folders.'\n                err_cls = SyncError\n            elif error.is_bad_path():\n                path_error = error.get_bad_path()\n                (text, err_cls) = get_bad_path_error_msg(path_error)\n            elif error.is_team_policy_disallows_member_policy():\n                text = 'Team policy does not allow sharing with the specified members.'\n                err_cls = InsufficientPermissionsError\n            elif error.is_disallowed_shared_link_policy():\n                text = 'Team policy does not allow creating the specified shared link.'\n                err_cls = InsufficientPermissionsError\n            elif isinstance(error, sharing.ShareFolderError) and error.is_no_permission():\n                text = \"You don't have permissions to share this folder.\"\n                err_cls = InsufficientPermissionsError\n    elif isinstance(exc, exceptions.AuthError):\n        error = exc.error\n        if isinstance(error, auth.AuthError):\n            if error.is_expired_access_token():\n                err_cls = TokenExpiredError\n                title = 'Authentication error'\n                text = \"Maestral's access to your Dropbox has expired. Please relink to continue syncing.\"\n            elif error.is_invalid_access_token():\n                err_cls = TokenRevokedError\n                title = 'Authentication error'\n                text = \"Maestral's access to your Dropbox has been revoked. Please relink to continue syncing.\"\n            elif error.is_user_suspended():\n                err_cls = DropboxAuthError\n                title = 'Authentication error'\n                text = 'Your user account has been suspended.'\n            elif error.is_missing_scope():\n                scope_error = error.get_missing_scope()\n                required_scope = scope_error.required_scope\n                err_cls = InsufficientPermissionsError\n                title = 'Insufficient permissions'\n                text = f'Performing this action requires the {required_scope} scope.'\n            else:\n                pass\n        else:\n            err_cls = DropboxAuthError\n            title = 'Authentication error'\n            text = 'Please check if you can log in on the Dropbox website.'\n    elif isinstance(exc, exceptions.PathRootError):\n        error = exc.error\n        err_cls = PathRootError\n        title = 'Invalid root namespace'\n        if isinstance(error, common.PathRootError):\n            if error.is_no_permission():\n                text = \"You don't have permission to access this namespace.\"\n            elif error.is_invalid_root():\n                text = 'The given namespace does not exist.'\n            elif error.is_other():\n                text = 'An unexpected error occurred with the given namespace.'\n    elif isinstance(exc, (exceptions.BadInputError, ValidationError)):\n        err_cls = BadInputError\n        title = 'Bad input to API call'\n        text = exc.message\n    elif isinstance(exc, exceptions.InternalServerError):\n        err_cls = DropboxServerError\n        title = 'Dropbox server error'\n        text = 'Something went wrong on Dropbox\u2019s end. Please check on status.dropbox.com if their services are up and running and try again later.'\n    elif isinstance(exc, exceptions.HttpError):\n        text = exc.body\n    maestral_exc = err_cls(title, text, dbx_path=dbx_path, local_path=local_path)\n    maestral_exc.__cause__ = exc\n    return maestral_exc",
            "def dropbox_to_maestral_error(exc: exceptions.DropboxException | ValidationError | requests.HTTPError, dbx_path: str | None=None, local_path: str | None=None) -> MaestralApiError:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Converts a Dropbox SDK exception to a :exc:`maestral.exceptions.MaestralApiError`\\n    and tries to add a reasonably informative error title and message.\\n\\n    :param exc: Dropbox SDK exception..\\n    :param dbx_path: Dropbox path associated with the error.\\n    :param local_path: Local path associated with the error.\\n    :returns: Converted exception.\\n    '\n    title = 'An unexpected error occurred'\n    text = 'Please contact the developer with the traceback information from the logs.'\n    err_cls = MaestralApiError\n    if isinstance(exc, exceptions.ApiError):\n        error = exc.error\n        if isinstance(error, files.RelocationError):\n            title = 'Could not move file or folder'\n            if error.is_cant_copy_shared_folder():\n                text = 'Shared folders can\u2019t be copied.'\n                err_cls = SyncError\n            elif error.is_cant_move_folder_into_itself():\n                text = 'You cannot move a folder into itself.'\n                err_cls = ConflictError\n            elif error.is_cant_move_shared_folder():\n                text = 'You cannot move the shared folder to the given destination.'\n                err_cls = SyncError\n            elif error.is_cant_nest_shared_folder():\n                text = 'Your move operation would result in nested shared folders. This is not allowed.'\n                err_cls = SyncError\n            elif error.is_cant_transfer_ownership():\n                text = 'Your move operation would result in an ownership transfer. Maestral does not currently support this. Please carry out the move on the Dropbox website instead.'\n                err_cls = SyncError\n            elif error.is_duplicated_or_nested_paths():\n                text = 'There are duplicated/nested paths among the target and destination folders.'\n                err_cls = SyncError\n            elif error.is_from_lookup():\n                lookup_error = error.get_from_lookup()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_from_write():\n                write_error = error.get_from_write()\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_insufficient_quota():\n                text = 'You do not have enough space on Dropbox to move or copy the files.'\n                err_cls = InsufficientSpaceError\n            elif error.is_internal_error():\n                text = 'Something went on Dropbox\u2019s end. Please try again later.'\n                err_cls = DropboxServerError\n            elif error.is_to():\n                to_error = error.get_to()\n                (text, err_cls) = get_write_error_msg(to_error)\n            elif error.is_too_many_files():\n                text = 'There are more than 10,000 files and folders in one request. Please try to move fewer items at once.'\n                err_cls = SyncError\n            elif error.is_cant_move_into_vault():\n                vault_error = error.get_cant_move_into_vault()\n                if vault_error.is_is_shared_folder():\n                    text = 'You cannot move a shared folder into the Dropbox Vault.'\n                else:\n                    text = 'You cannot move this folder into the Dropbox Vault.'\n                err_cls = SyncError\n        elif isinstance(error, (files.CreateFolderError, files.CreateFolderEntryError)):\n            title = 'Could not create folder'\n            if error.is_path():\n                write_error = error.get_path()\n                (text, err_cls) = get_write_error_msg(write_error)\n        elif isinstance(error, files.DeleteError):\n            title = 'Could not delete item'\n            if error.is_path_lookup():\n                lookup_error = error.get_path_lookup()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_path_write():\n                write_error = error.get_path_write()\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_too_many_files():\n                text = 'There are more than 10,000 files and folders in one request. Please try to delete fewer items at once.'\n                err_cls = SyncError\n            elif error.is_too_many_write_operations():\n                text = 'There are too many write operations happening in your Dropbox. Please try again later.'\n                err_cls = SyncError\n        elif isinstance(error, files.UploadError):\n            title = 'Could not upload file'\n            if error.is_path():\n                write_error = error.get_path().reason\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_properties_error():\n                text = 'Invalid property group provided.'\n            elif error.is_payload_too_large():\n                text = 'Can only upload in chunks of at most 150 MB.'\n                err_cls = FileSizeError\n            elif error.is_content_hash_mismatch():\n                text = 'Data corruption during upload. Please try again.'\n                err_cls = DataCorruptionError\n        elif isinstance(error, files.UploadSessionStartError):\n            title = 'Could not upload file'\n            if error.is_concurrent_session_close_not_allowed():\n                text = 'Can not start a closed concurrent upload session.'\n            elif error.is_concurrent_session_data_not_allowed():\n                text = 'Uploading data not allowed when starting concurrent upload session.'\n            elif error.is_payload_too_large():\n                text = 'Can only upload in chunks of at most 150 MB.'\n                err_cls = SyncError\n            elif error.is_content_hash_mismatch():\n                text = 'Data corruption during upload. Please try again.'\n                err_cls = DataCorruptionError\n        elif isinstance(error, files.UploadSessionFinishError):\n            title = 'Could not upload file'\n            if error.is_lookup_failed():\n                session_lookup_error = error.get_lookup_failed()\n                (text, err_cls) = get_session_lookup_error_msg(session_lookup_error)\n            elif error.is_path():\n                write_error = error.get_path()\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_properties_error():\n                text = 'Invalid property group provided.'\n            elif error.is_too_many_write_operations():\n                text = 'There are too many write operations happening in your Dropbox. Please retry again later.'\n                err_cls = SyncError\n            elif error.is_too_many_shared_folder_targets():\n                text = 'The batch request commits files into too many different shared folders. Please limit your batch request to files contained in a single shared folder.'\n                err_cls = SyncError\n            elif error.is_payload_too_large():\n                text = 'Can only upload in chunks of at most 150 MB.'\n                err_cls = SyncError\n            elif error.is_content_hash_mismatch():\n                text = 'Data corruption during upload. Please try again.'\n                err_cls = DataCorruptionError\n        elif isinstance(error, files.UploadSessionLookupError):\n            title = 'Could not upload file'\n            (text, err_cls) = get_session_lookup_error_msg(error)\n        elif isinstance(error, files.DownloadError):\n            title = 'Could not download file'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_unsupported_file():\n                text = 'This file type cannot be downloaded but must be exported.'\n                err_cls = UnsupportedFileError\n        elif isinstance(error, files.ListFolderError):\n            title = 'Could not list folder contents'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n        elif isinstance(error, files.ListFolderContinueError):\n            title = 'Could not list folder contents'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_reset():\n                text = \"Dropbox has reset its sync state. Please rebuild Maestral's index to re-sync your Dropbox.\"\n                err_cls = CursorResetError\n        elif isinstance(error, files.ListFolderLongpollError):\n            title = 'Could not get Dropbox changes'\n            if error.is_reset():\n                text = \"Dropbox has reset its sync state. Please rebuild Maestral's index to re-sync your Dropbox.\"\n                err_cls = CursorResetError\n        elif isinstance(error, async_.PollError):\n            title = 'Could not get status of batch job'\n            if error.is_internal_error():\n                text = 'Something went wrong with the job on Dropbox\u2019s end. Please verify on the Dropbox website if the job succeeded and try again if it failed.'\n                err_cls = DropboxServerError\n            else:\n                pass\n        elif isinstance(error, files.ListRevisionsError):\n            title = 'Could not list file revisions'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n        elif isinstance(error, files.RestoreError):\n            title = 'Could not restore file'\n            if error.is_invalid_revision():\n                text = 'Invalid revision.'\n                err_cls = NotFoundError\n            elif error.is_path_lookup():\n                lookup_error = error.get_path_lookup()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_path_write():\n                write_error = error.get_path_write()\n                (text, err_cls) = get_write_error_msg(write_error)\n            elif error.is_in_progress():\n                title = 'Restore in progress'\n                text = 'Please check again later if the restore completed'\n                err_cls = SyncError\n        elif isinstance(error, files.GetMetadataError):\n            title = 'Could not get metadata'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n        elif isinstance(error, users.GetAccountError):\n            title = 'Could not get account info'\n            if error.is_no_account():\n                text = 'An account with the given Dropbox ID does not exist or has been deleted'\n                err_cls = InvalidDbidError\n        elif isinstance(error, sharing.CreateSharedLinkWithSettingsError):\n            title = 'Could not create shared link'\n            if error.is_access_denied():\n                text = 'You do not have access to create shared links for this path.'\n                err_cls = InsufficientPermissionsError\n            elif error.is_email_not_verified():\n                text = 'Please verify you email address before creating shared links'\n                err_cls = SharedLinkError\n            elif error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_settings_error():\n                settings_error = error.get_settings_error()\n                err_cls = SharedLinkError\n                if settings_error.is_invalid_settings():\n                    text = 'Please check if the settings are valid.'\n                elif settings_error.is_not_authorized():\n                    text = 'Basic accounts do not support passwords or expiry dates.'\n            elif error.is_shared_link_already_exists():\n                text = 'The shared link already exists.'\n                err_cls = SharedLinkError\n        elif isinstance(error, sharing.RevokeSharedLinkError):\n            title = 'Could not revoke shared link'\n            if error.is_shared_link_malformed():\n                text = 'The shared link is malformed.'\n                err_cls = SharedLinkError\n            elif error.is_shared_link_not_found():\n                text = 'The given link does not exist.'\n                err_cls = NotFoundError\n            elif error.is_shared_link_access_denied():\n                text = 'You do not have access to revoke the shared link.'\n                err_cls = InsufficientPermissionsError\n            elif error.is_unsupported_link_type():\n                text = 'The link type is not supported.'\n                err_cls = SharedLinkError\n        elif isinstance(error, sharing.ListSharedLinksError):\n            title = 'Could not list shared links'\n            if error.is_path():\n                lookup_error = error.get_path()\n                (text, err_cls) = get_lookup_error_msg(lookup_error)\n            elif error.is_reset():\n                text = 'Please try again later.'\n                err_cls = SharedLinkError\n        elif isinstance(error, common.PathRootError):\n            if error.is_no_permission():\n                text = \"You don't have permission to access this namespace.\"\n                err_cls = InsufficientPermissionsError\n            elif error.is_invalid_root():\n                text = 'Invalid root namespace.'\n                err_cls = SyncError\n        elif isinstance(error, sharing.ShareFolderErrorBase):\n            title = 'Could not share folder'\n            if error.is_email_unverified():\n                text = 'You need to verify your email address before creating shared folders.'\n                err_cls = SyncError\n            elif error.is_bad_path():\n                path_error = error.get_bad_path()\n                (text, err_cls) = get_bad_path_error_msg(path_error)\n            elif error.is_team_policy_disallows_member_policy():\n                text = 'Team policy does not allow sharing with the specified members.'\n                err_cls = InsufficientPermissionsError\n            elif error.is_disallowed_shared_link_policy():\n                text = 'Team policy does not allow creating the specified shared link.'\n                err_cls = InsufficientPermissionsError\n            elif isinstance(error, sharing.ShareFolderError) and error.is_no_permission():\n                text = \"You don't have permissions to share this folder.\"\n                err_cls = InsufficientPermissionsError\n    elif isinstance(exc, exceptions.AuthError):\n        error = exc.error\n        if isinstance(error, auth.AuthError):\n            if error.is_expired_access_token():\n                err_cls = TokenExpiredError\n                title = 'Authentication error'\n                text = \"Maestral's access to your Dropbox has expired. Please relink to continue syncing.\"\n            elif error.is_invalid_access_token():\n                err_cls = TokenRevokedError\n                title = 'Authentication error'\n                text = \"Maestral's access to your Dropbox has been revoked. Please relink to continue syncing.\"\n            elif error.is_user_suspended():\n                err_cls = DropboxAuthError\n                title = 'Authentication error'\n                text = 'Your user account has been suspended.'\n            elif error.is_missing_scope():\n                scope_error = error.get_missing_scope()\n                required_scope = scope_error.required_scope\n                err_cls = InsufficientPermissionsError\n                title = 'Insufficient permissions'\n                text = f'Performing this action requires the {required_scope} scope.'\n            else:\n                pass\n        else:\n            err_cls = DropboxAuthError\n            title = 'Authentication error'\n            text = 'Please check if you can log in on the Dropbox website.'\n    elif isinstance(exc, exceptions.PathRootError):\n        error = exc.error\n        err_cls = PathRootError\n        title = 'Invalid root namespace'\n        if isinstance(error, common.PathRootError):\n            if error.is_no_permission():\n                text = \"You don't have permission to access this namespace.\"\n            elif error.is_invalid_root():\n                text = 'The given namespace does not exist.'\n            elif error.is_other():\n                text = 'An unexpected error occurred with the given namespace.'\n    elif isinstance(exc, (exceptions.BadInputError, ValidationError)):\n        err_cls = BadInputError\n        title = 'Bad input to API call'\n        text = exc.message\n    elif isinstance(exc, exceptions.InternalServerError):\n        err_cls = DropboxServerError\n        title = 'Dropbox server error'\n        text = 'Something went wrong on Dropbox\u2019s end. Please check on status.dropbox.com if their services are up and running and try again later.'\n    elif isinstance(exc, exceptions.HttpError):\n        text = exc.body\n    maestral_exc = err_cls(title, text, dbx_path=dbx_path, local_path=local_path)\n    maestral_exc.__cause__ = exc\n    return maestral_exc"
        ]
    },
    {
        "func_name": "get_write_error_msg",
        "original": "def get_write_error_msg(write_error: files.WriteError) -> tuple[str, type[SyncError]]:\n    text = ''\n    err_cls = SyncError\n    if write_error.is_conflict():\n        conflict = write_error.get_conflict()\n        if conflict.is_file():\n            text = 'Could not write to the target path because another file was in the way.'\n            err_cls = FileConflictError\n        elif conflict.is_folder():\n            text = 'Could not write to the target path because another folder was in the way.'\n            err_cls = FolderConflictError\n        elif conflict.is_file_ancestor():\n            text = 'Could not create parent folders because another file was in the way.'\n            err_cls = FileConflictError\n        else:\n            text = 'Could not write to the target path because another file or folder was in the way.'\n            err_cls = ConflictError\n    elif write_error.is_disallowed_name():\n        text = 'Dropbox will not save the file or folder because of its name.'\n        err_cls = PathError\n    elif write_error.is_insufficient_space():\n        text = 'You do not have enough space on Dropbox to move or copy the files.'\n        err_cls = InsufficientSpaceError\n    elif write_error.is_malformed_path():\n        text = 'The destination path contains incompatible characters. Paths may not end with a slash or whitespace or contain some characters such as emojis.'\n        err_cls = PathError\n    elif write_error.is_no_write_permission():\n        text = 'You do not have permissions to write to the target location.'\n        err_cls = InsufficientPermissionsError\n    elif write_error.is_team_folder():\n        text = 'You cannot move or delete team folders through Maestral.'\n    elif write_error.is_too_many_write_operations():\n        text = 'There are too many write operations in your Dropbox. Please try again later.'\n    elif write_error.is_operation_suppressed():\n        text = 'This file operation is not allowed at this path.'\n    return (text, err_cls)",
        "mutated": [
            "def get_write_error_msg(write_error: files.WriteError) -> tuple[str, type[SyncError]]:\n    if False:\n        i = 10\n    text = ''\n    err_cls = SyncError\n    if write_error.is_conflict():\n        conflict = write_error.get_conflict()\n        if conflict.is_file():\n            text = 'Could not write to the target path because another file was in the way.'\n            err_cls = FileConflictError\n        elif conflict.is_folder():\n            text = 'Could not write to the target path because another folder was in the way.'\n            err_cls = FolderConflictError\n        elif conflict.is_file_ancestor():\n            text = 'Could not create parent folders because another file was in the way.'\n            err_cls = FileConflictError\n        else:\n            text = 'Could not write to the target path because another file or folder was in the way.'\n            err_cls = ConflictError\n    elif write_error.is_disallowed_name():\n        text = 'Dropbox will not save the file or folder because of its name.'\n        err_cls = PathError\n    elif write_error.is_insufficient_space():\n        text = 'You do not have enough space on Dropbox to move or copy the files.'\n        err_cls = InsufficientSpaceError\n    elif write_error.is_malformed_path():\n        text = 'The destination path contains incompatible characters. Paths may not end with a slash or whitespace or contain some characters such as emojis.'\n        err_cls = PathError\n    elif write_error.is_no_write_permission():\n        text = 'You do not have permissions to write to the target location.'\n        err_cls = InsufficientPermissionsError\n    elif write_error.is_team_folder():\n        text = 'You cannot move or delete team folders through Maestral.'\n    elif write_error.is_too_many_write_operations():\n        text = 'There are too many write operations in your Dropbox. Please try again later.'\n    elif write_error.is_operation_suppressed():\n        text = 'This file operation is not allowed at this path.'\n    return (text, err_cls)",
            "def get_write_error_msg(write_error: files.WriteError) -> tuple[str, type[SyncError]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    text = ''\n    err_cls = SyncError\n    if write_error.is_conflict():\n        conflict = write_error.get_conflict()\n        if conflict.is_file():\n            text = 'Could not write to the target path because another file was in the way.'\n            err_cls = FileConflictError\n        elif conflict.is_folder():\n            text = 'Could not write to the target path because another folder was in the way.'\n            err_cls = FolderConflictError\n        elif conflict.is_file_ancestor():\n            text = 'Could not create parent folders because another file was in the way.'\n            err_cls = FileConflictError\n        else:\n            text = 'Could not write to the target path because another file or folder was in the way.'\n            err_cls = ConflictError\n    elif write_error.is_disallowed_name():\n        text = 'Dropbox will not save the file or folder because of its name.'\n        err_cls = PathError\n    elif write_error.is_insufficient_space():\n        text = 'You do not have enough space on Dropbox to move or copy the files.'\n        err_cls = InsufficientSpaceError\n    elif write_error.is_malformed_path():\n        text = 'The destination path contains incompatible characters. Paths may not end with a slash or whitespace or contain some characters such as emojis.'\n        err_cls = PathError\n    elif write_error.is_no_write_permission():\n        text = 'You do not have permissions to write to the target location.'\n        err_cls = InsufficientPermissionsError\n    elif write_error.is_team_folder():\n        text = 'You cannot move or delete team folders through Maestral.'\n    elif write_error.is_too_many_write_operations():\n        text = 'There are too many write operations in your Dropbox. Please try again later.'\n    elif write_error.is_operation_suppressed():\n        text = 'This file operation is not allowed at this path.'\n    return (text, err_cls)",
            "def get_write_error_msg(write_error: files.WriteError) -> tuple[str, type[SyncError]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    text = ''\n    err_cls = SyncError\n    if write_error.is_conflict():\n        conflict = write_error.get_conflict()\n        if conflict.is_file():\n            text = 'Could not write to the target path because another file was in the way.'\n            err_cls = FileConflictError\n        elif conflict.is_folder():\n            text = 'Could not write to the target path because another folder was in the way.'\n            err_cls = FolderConflictError\n        elif conflict.is_file_ancestor():\n            text = 'Could not create parent folders because another file was in the way.'\n            err_cls = FileConflictError\n        else:\n            text = 'Could not write to the target path because another file or folder was in the way.'\n            err_cls = ConflictError\n    elif write_error.is_disallowed_name():\n        text = 'Dropbox will not save the file or folder because of its name.'\n        err_cls = PathError\n    elif write_error.is_insufficient_space():\n        text = 'You do not have enough space on Dropbox to move or copy the files.'\n        err_cls = InsufficientSpaceError\n    elif write_error.is_malformed_path():\n        text = 'The destination path contains incompatible characters. Paths may not end with a slash or whitespace or contain some characters such as emojis.'\n        err_cls = PathError\n    elif write_error.is_no_write_permission():\n        text = 'You do not have permissions to write to the target location.'\n        err_cls = InsufficientPermissionsError\n    elif write_error.is_team_folder():\n        text = 'You cannot move or delete team folders through Maestral.'\n    elif write_error.is_too_many_write_operations():\n        text = 'There are too many write operations in your Dropbox. Please try again later.'\n    elif write_error.is_operation_suppressed():\n        text = 'This file operation is not allowed at this path.'\n    return (text, err_cls)",
            "def get_write_error_msg(write_error: files.WriteError) -> tuple[str, type[SyncError]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    text = ''\n    err_cls = SyncError\n    if write_error.is_conflict():\n        conflict = write_error.get_conflict()\n        if conflict.is_file():\n            text = 'Could not write to the target path because another file was in the way.'\n            err_cls = FileConflictError\n        elif conflict.is_folder():\n            text = 'Could not write to the target path because another folder was in the way.'\n            err_cls = FolderConflictError\n        elif conflict.is_file_ancestor():\n            text = 'Could not create parent folders because another file was in the way.'\n            err_cls = FileConflictError\n        else:\n            text = 'Could not write to the target path because another file or folder was in the way.'\n            err_cls = ConflictError\n    elif write_error.is_disallowed_name():\n        text = 'Dropbox will not save the file or folder because of its name.'\n        err_cls = PathError\n    elif write_error.is_insufficient_space():\n        text = 'You do not have enough space on Dropbox to move or copy the files.'\n        err_cls = InsufficientSpaceError\n    elif write_error.is_malformed_path():\n        text = 'The destination path contains incompatible characters. Paths may not end with a slash or whitespace or contain some characters such as emojis.'\n        err_cls = PathError\n    elif write_error.is_no_write_permission():\n        text = 'You do not have permissions to write to the target location.'\n        err_cls = InsufficientPermissionsError\n    elif write_error.is_team_folder():\n        text = 'You cannot move or delete team folders through Maestral.'\n    elif write_error.is_too_many_write_operations():\n        text = 'There are too many write operations in your Dropbox. Please try again later.'\n    elif write_error.is_operation_suppressed():\n        text = 'This file operation is not allowed at this path.'\n    return (text, err_cls)",
            "def get_write_error_msg(write_error: files.WriteError) -> tuple[str, type[SyncError]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    text = ''\n    err_cls = SyncError\n    if write_error.is_conflict():\n        conflict = write_error.get_conflict()\n        if conflict.is_file():\n            text = 'Could not write to the target path because another file was in the way.'\n            err_cls = FileConflictError\n        elif conflict.is_folder():\n            text = 'Could not write to the target path because another folder was in the way.'\n            err_cls = FolderConflictError\n        elif conflict.is_file_ancestor():\n            text = 'Could not create parent folders because another file was in the way.'\n            err_cls = FileConflictError\n        else:\n            text = 'Could not write to the target path because another file or folder was in the way.'\n            err_cls = ConflictError\n    elif write_error.is_disallowed_name():\n        text = 'Dropbox will not save the file or folder because of its name.'\n        err_cls = PathError\n    elif write_error.is_insufficient_space():\n        text = 'You do not have enough space on Dropbox to move or copy the files.'\n        err_cls = InsufficientSpaceError\n    elif write_error.is_malformed_path():\n        text = 'The destination path contains incompatible characters. Paths may not end with a slash or whitespace or contain some characters such as emojis.'\n        err_cls = PathError\n    elif write_error.is_no_write_permission():\n        text = 'You do not have permissions to write to the target location.'\n        err_cls = InsufficientPermissionsError\n    elif write_error.is_team_folder():\n        text = 'You cannot move or delete team folders through Maestral.'\n    elif write_error.is_too_many_write_operations():\n        text = 'There are too many write operations in your Dropbox. Please try again later.'\n    elif write_error.is_operation_suppressed():\n        text = 'This file operation is not allowed at this path.'\n    return (text, err_cls)"
        ]
    },
    {
        "func_name": "get_lookup_error_msg",
        "original": "def get_lookup_error_msg(lookup_error: files.LookupError) -> tuple[str, type[SyncError]]:\n    err_cls = SyncError\n    if lookup_error.is_malformed_path():\n        text = 'The path is invalid. Paths may not end with a slash or whitespace.'\n        err_cls = PathError\n    elif lookup_error.is_not_file():\n        text = 'The given path refers to a folder.'\n        err_cls = IsAFolderError\n    elif lookup_error.is_not_folder():\n        text = 'The given path refers to a file.'\n        err_cls = NotAFolderError\n    elif lookup_error.is_not_found():\n        text = 'There is nothing at the given path.'\n        err_cls = NotFoundError\n    elif lookup_error.is_restricted_content():\n        text = 'The file cannot be transferred because the content is restricted. For example, sometimes there are legal restrictions due to copyright claims.'\n        err_cls = RestrictedContentError\n    elif lookup_error.is_unsupported_content_type():\n        text = 'This file type is currently not supported for syncing.'\n        err_cls = UnsupportedFileError\n    elif lookup_error.is_locked():\n        text = 'The given path is locked.'\n        err_cls = InsufficientPermissionsError\n    else:\n        text = 'An unexpected error occurred. Please try again later.'\n    return (text, err_cls)",
        "mutated": [
            "def get_lookup_error_msg(lookup_error: files.LookupError) -> tuple[str, type[SyncError]]:\n    if False:\n        i = 10\n    err_cls = SyncError\n    if lookup_error.is_malformed_path():\n        text = 'The path is invalid. Paths may not end with a slash or whitespace.'\n        err_cls = PathError\n    elif lookup_error.is_not_file():\n        text = 'The given path refers to a folder.'\n        err_cls = IsAFolderError\n    elif lookup_error.is_not_folder():\n        text = 'The given path refers to a file.'\n        err_cls = NotAFolderError\n    elif lookup_error.is_not_found():\n        text = 'There is nothing at the given path.'\n        err_cls = NotFoundError\n    elif lookup_error.is_restricted_content():\n        text = 'The file cannot be transferred because the content is restricted. For example, sometimes there are legal restrictions due to copyright claims.'\n        err_cls = RestrictedContentError\n    elif lookup_error.is_unsupported_content_type():\n        text = 'This file type is currently not supported for syncing.'\n        err_cls = UnsupportedFileError\n    elif lookup_error.is_locked():\n        text = 'The given path is locked.'\n        err_cls = InsufficientPermissionsError\n    else:\n        text = 'An unexpected error occurred. Please try again later.'\n    return (text, err_cls)",
            "def get_lookup_error_msg(lookup_error: files.LookupError) -> tuple[str, type[SyncError]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    err_cls = SyncError\n    if lookup_error.is_malformed_path():\n        text = 'The path is invalid. Paths may not end with a slash or whitespace.'\n        err_cls = PathError\n    elif lookup_error.is_not_file():\n        text = 'The given path refers to a folder.'\n        err_cls = IsAFolderError\n    elif lookup_error.is_not_folder():\n        text = 'The given path refers to a file.'\n        err_cls = NotAFolderError\n    elif lookup_error.is_not_found():\n        text = 'There is nothing at the given path.'\n        err_cls = NotFoundError\n    elif lookup_error.is_restricted_content():\n        text = 'The file cannot be transferred because the content is restricted. For example, sometimes there are legal restrictions due to copyright claims.'\n        err_cls = RestrictedContentError\n    elif lookup_error.is_unsupported_content_type():\n        text = 'This file type is currently not supported for syncing.'\n        err_cls = UnsupportedFileError\n    elif lookup_error.is_locked():\n        text = 'The given path is locked.'\n        err_cls = InsufficientPermissionsError\n    else:\n        text = 'An unexpected error occurred. Please try again later.'\n    return (text, err_cls)",
            "def get_lookup_error_msg(lookup_error: files.LookupError) -> tuple[str, type[SyncError]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    err_cls = SyncError\n    if lookup_error.is_malformed_path():\n        text = 'The path is invalid. Paths may not end with a slash or whitespace.'\n        err_cls = PathError\n    elif lookup_error.is_not_file():\n        text = 'The given path refers to a folder.'\n        err_cls = IsAFolderError\n    elif lookup_error.is_not_folder():\n        text = 'The given path refers to a file.'\n        err_cls = NotAFolderError\n    elif lookup_error.is_not_found():\n        text = 'There is nothing at the given path.'\n        err_cls = NotFoundError\n    elif lookup_error.is_restricted_content():\n        text = 'The file cannot be transferred because the content is restricted. For example, sometimes there are legal restrictions due to copyright claims.'\n        err_cls = RestrictedContentError\n    elif lookup_error.is_unsupported_content_type():\n        text = 'This file type is currently not supported for syncing.'\n        err_cls = UnsupportedFileError\n    elif lookup_error.is_locked():\n        text = 'The given path is locked.'\n        err_cls = InsufficientPermissionsError\n    else:\n        text = 'An unexpected error occurred. Please try again later.'\n    return (text, err_cls)",
            "def get_lookup_error_msg(lookup_error: files.LookupError) -> tuple[str, type[SyncError]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    err_cls = SyncError\n    if lookup_error.is_malformed_path():\n        text = 'The path is invalid. Paths may not end with a slash or whitespace.'\n        err_cls = PathError\n    elif lookup_error.is_not_file():\n        text = 'The given path refers to a folder.'\n        err_cls = IsAFolderError\n    elif lookup_error.is_not_folder():\n        text = 'The given path refers to a file.'\n        err_cls = NotAFolderError\n    elif lookup_error.is_not_found():\n        text = 'There is nothing at the given path.'\n        err_cls = NotFoundError\n    elif lookup_error.is_restricted_content():\n        text = 'The file cannot be transferred because the content is restricted. For example, sometimes there are legal restrictions due to copyright claims.'\n        err_cls = RestrictedContentError\n    elif lookup_error.is_unsupported_content_type():\n        text = 'This file type is currently not supported for syncing.'\n        err_cls = UnsupportedFileError\n    elif lookup_error.is_locked():\n        text = 'The given path is locked.'\n        err_cls = InsufficientPermissionsError\n    else:\n        text = 'An unexpected error occurred. Please try again later.'\n    return (text, err_cls)",
            "def get_lookup_error_msg(lookup_error: files.LookupError) -> tuple[str, type[SyncError]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    err_cls = SyncError\n    if lookup_error.is_malformed_path():\n        text = 'The path is invalid. Paths may not end with a slash or whitespace.'\n        err_cls = PathError\n    elif lookup_error.is_not_file():\n        text = 'The given path refers to a folder.'\n        err_cls = IsAFolderError\n    elif lookup_error.is_not_folder():\n        text = 'The given path refers to a file.'\n        err_cls = NotAFolderError\n    elif lookup_error.is_not_found():\n        text = 'There is nothing at the given path.'\n        err_cls = NotFoundError\n    elif lookup_error.is_restricted_content():\n        text = 'The file cannot be transferred because the content is restricted. For example, sometimes there are legal restrictions due to copyright claims.'\n        err_cls = RestrictedContentError\n    elif lookup_error.is_unsupported_content_type():\n        text = 'This file type is currently not supported for syncing.'\n        err_cls = UnsupportedFileError\n    elif lookup_error.is_locked():\n        text = 'The given path is locked.'\n        err_cls = InsufficientPermissionsError\n    else:\n        text = 'An unexpected error occurred. Please try again later.'\n    return (text, err_cls)"
        ]
    },
    {
        "func_name": "get_session_lookup_error_msg",
        "original": "def get_session_lookup_error_msg(session_lookup_error: files.UploadSessionLookupError) -> tuple[str, type[SyncError]]:\n    err_cls = SyncError\n    if session_lookup_error.is_closed():\n        text = 'Cannot append data to a closed upload session.'\n    elif session_lookup_error.is_incorrect_offset():\n        text = 'A network error occurred during the upload session.'\n        err_cls = DataCorruptionError\n    elif session_lookup_error.is_not_closed():\n        text = 'Upload session is still open, cannot finish.'\n    elif session_lookup_error.is_not_found():\n        text = 'The upload session ID was not found or has expired. Upload sessions are valid for 48 hours.'\n    elif session_lookup_error.is_too_large():\n        text = 'You can only upload files up to 350 GB.'\n        err_cls = FileSizeError\n    elif session_lookup_error.is_payload_too_large():\n        text = 'Can only upload in chunks of at most 150 MB.'\n    elif isinstance(session_lookup_error, files.UploadSessionAppendError) and session_lookup_error.is_content_hash_mismatch():\n        text = 'A network error occurred during the upload session.'\n        err_cls = DataCorruptionError\n    else:\n        text = 'An unexpected error occurred. Please try again later.'\n    return (text, err_cls)",
        "mutated": [
            "def get_session_lookup_error_msg(session_lookup_error: files.UploadSessionLookupError) -> tuple[str, type[SyncError]]:\n    if False:\n        i = 10\n    err_cls = SyncError\n    if session_lookup_error.is_closed():\n        text = 'Cannot append data to a closed upload session.'\n    elif session_lookup_error.is_incorrect_offset():\n        text = 'A network error occurred during the upload session.'\n        err_cls = DataCorruptionError\n    elif session_lookup_error.is_not_closed():\n        text = 'Upload session is still open, cannot finish.'\n    elif session_lookup_error.is_not_found():\n        text = 'The upload session ID was not found or has expired. Upload sessions are valid for 48 hours.'\n    elif session_lookup_error.is_too_large():\n        text = 'You can only upload files up to 350 GB.'\n        err_cls = FileSizeError\n    elif session_lookup_error.is_payload_too_large():\n        text = 'Can only upload in chunks of at most 150 MB.'\n    elif isinstance(session_lookup_error, files.UploadSessionAppendError) and session_lookup_error.is_content_hash_mismatch():\n        text = 'A network error occurred during the upload session.'\n        err_cls = DataCorruptionError\n    else:\n        text = 'An unexpected error occurred. Please try again later.'\n    return (text, err_cls)",
            "def get_session_lookup_error_msg(session_lookup_error: files.UploadSessionLookupError) -> tuple[str, type[SyncError]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    err_cls = SyncError\n    if session_lookup_error.is_closed():\n        text = 'Cannot append data to a closed upload session.'\n    elif session_lookup_error.is_incorrect_offset():\n        text = 'A network error occurred during the upload session.'\n        err_cls = DataCorruptionError\n    elif session_lookup_error.is_not_closed():\n        text = 'Upload session is still open, cannot finish.'\n    elif session_lookup_error.is_not_found():\n        text = 'The upload session ID was not found or has expired. Upload sessions are valid for 48 hours.'\n    elif session_lookup_error.is_too_large():\n        text = 'You can only upload files up to 350 GB.'\n        err_cls = FileSizeError\n    elif session_lookup_error.is_payload_too_large():\n        text = 'Can only upload in chunks of at most 150 MB.'\n    elif isinstance(session_lookup_error, files.UploadSessionAppendError) and session_lookup_error.is_content_hash_mismatch():\n        text = 'A network error occurred during the upload session.'\n        err_cls = DataCorruptionError\n    else:\n        text = 'An unexpected error occurred. Please try again later.'\n    return (text, err_cls)",
            "def get_session_lookup_error_msg(session_lookup_error: files.UploadSessionLookupError) -> tuple[str, type[SyncError]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    err_cls = SyncError\n    if session_lookup_error.is_closed():\n        text = 'Cannot append data to a closed upload session.'\n    elif session_lookup_error.is_incorrect_offset():\n        text = 'A network error occurred during the upload session.'\n        err_cls = DataCorruptionError\n    elif session_lookup_error.is_not_closed():\n        text = 'Upload session is still open, cannot finish.'\n    elif session_lookup_error.is_not_found():\n        text = 'The upload session ID was not found or has expired. Upload sessions are valid for 48 hours.'\n    elif session_lookup_error.is_too_large():\n        text = 'You can only upload files up to 350 GB.'\n        err_cls = FileSizeError\n    elif session_lookup_error.is_payload_too_large():\n        text = 'Can only upload in chunks of at most 150 MB.'\n    elif isinstance(session_lookup_error, files.UploadSessionAppendError) and session_lookup_error.is_content_hash_mismatch():\n        text = 'A network error occurred during the upload session.'\n        err_cls = DataCorruptionError\n    else:\n        text = 'An unexpected error occurred. Please try again later.'\n    return (text, err_cls)",
            "def get_session_lookup_error_msg(session_lookup_error: files.UploadSessionLookupError) -> tuple[str, type[SyncError]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    err_cls = SyncError\n    if session_lookup_error.is_closed():\n        text = 'Cannot append data to a closed upload session.'\n    elif session_lookup_error.is_incorrect_offset():\n        text = 'A network error occurred during the upload session.'\n        err_cls = DataCorruptionError\n    elif session_lookup_error.is_not_closed():\n        text = 'Upload session is still open, cannot finish.'\n    elif session_lookup_error.is_not_found():\n        text = 'The upload session ID was not found or has expired. Upload sessions are valid for 48 hours.'\n    elif session_lookup_error.is_too_large():\n        text = 'You can only upload files up to 350 GB.'\n        err_cls = FileSizeError\n    elif session_lookup_error.is_payload_too_large():\n        text = 'Can only upload in chunks of at most 150 MB.'\n    elif isinstance(session_lookup_error, files.UploadSessionAppendError) and session_lookup_error.is_content_hash_mismatch():\n        text = 'A network error occurred during the upload session.'\n        err_cls = DataCorruptionError\n    else:\n        text = 'An unexpected error occurred. Please try again later.'\n    return (text, err_cls)",
            "def get_session_lookup_error_msg(session_lookup_error: files.UploadSessionLookupError) -> tuple[str, type[SyncError]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    err_cls = SyncError\n    if session_lookup_error.is_closed():\n        text = 'Cannot append data to a closed upload session.'\n    elif session_lookup_error.is_incorrect_offset():\n        text = 'A network error occurred during the upload session.'\n        err_cls = DataCorruptionError\n    elif session_lookup_error.is_not_closed():\n        text = 'Upload session is still open, cannot finish.'\n    elif session_lookup_error.is_not_found():\n        text = 'The upload session ID was not found or has expired. Upload sessions are valid for 48 hours.'\n    elif session_lookup_error.is_too_large():\n        text = 'You can only upload files up to 350 GB.'\n        err_cls = FileSizeError\n    elif session_lookup_error.is_payload_too_large():\n        text = 'Can only upload in chunks of at most 150 MB.'\n    elif isinstance(session_lookup_error, files.UploadSessionAppendError) and session_lookup_error.is_content_hash_mismatch():\n        text = 'A network error occurred during the upload session.'\n        err_cls = DataCorruptionError\n    else:\n        text = 'An unexpected error occurred. Please try again later.'\n    return (text, err_cls)"
        ]
    },
    {
        "func_name": "get_bad_path_error_msg",
        "original": "def get_bad_path_error_msg(path_error: sharing.SharePathError) -> tuple[str, type[SyncError]]:\n    err_cls = SyncError\n    if path_error.is_is_file():\n        text = 'A file is at the specified path.'\n        err_cls = FileConflictError\n    elif path_error.is_inside_shared_folder():\n        text = 'Cannot share a folder inside a shared folder.'\n    elif path_error.is_contains_shared_folder():\n        text = 'Cannot share a folder that contains a shared folder.'\n    elif path_error.is_contains_app_folder():\n        text = 'Cannot share a folder that contains an app folder.'\n    elif path_error.is_contains_team_folder():\n        text = 'Cannot share a folder that contains a team folder.'\n    elif path_error.is_is_app_folder():\n        text = 'Cannot share app folders.'\n    elif path_error.is_inside_app_folder():\n        text = 'Cannot share a folder inside an app folder.'\n    elif path_error.is_is_public_folder():\n        text = \"A public folder can't be shared this way. Use a public link instead.\"\n    elif path_error.is_inside_public_folder():\n        text = \"A folder inside a public folder can't be shared this way. Use a public link instead.\"\n    elif path_error.is_already_shared():\n        err_cls = FolderConflictError\n        text = 'The folder is already shared.'\n    elif path_error.is_invalid_path():\n        text = 'The path is not valid.'\n    elif path_error.is_is_osx_package():\n        text = 'Cannot share macOS packages.'\n    elif path_error.is_inside_osx_package():\n        text = 'Cannot share folders inside macOS packages.'\n    elif path_error.is_is_vault():\n        text = 'Cannot share the Vault folder.'\n    elif path_error.is_is_vault_locked():\n        text = 'Cannot share a folder inside a locked Vault.'\n    elif path_error.is_is_family():\n        text = 'Cannot share the Family folder.'\n    else:\n        text = 'An unexpected error occurred. Please try again later.'\n    return (text, err_cls)",
        "mutated": [
            "def get_bad_path_error_msg(path_error: sharing.SharePathError) -> tuple[str, type[SyncError]]:\n    if False:\n        i = 10\n    err_cls = SyncError\n    if path_error.is_is_file():\n        text = 'A file is at the specified path.'\n        err_cls = FileConflictError\n    elif path_error.is_inside_shared_folder():\n        text = 'Cannot share a folder inside a shared folder.'\n    elif path_error.is_contains_shared_folder():\n        text = 'Cannot share a folder that contains a shared folder.'\n    elif path_error.is_contains_app_folder():\n        text = 'Cannot share a folder that contains an app folder.'\n    elif path_error.is_contains_team_folder():\n        text = 'Cannot share a folder that contains a team folder.'\n    elif path_error.is_is_app_folder():\n        text = 'Cannot share app folders.'\n    elif path_error.is_inside_app_folder():\n        text = 'Cannot share a folder inside an app folder.'\n    elif path_error.is_is_public_folder():\n        text = \"A public folder can't be shared this way. Use a public link instead.\"\n    elif path_error.is_inside_public_folder():\n        text = \"A folder inside a public folder can't be shared this way. Use a public link instead.\"\n    elif path_error.is_already_shared():\n        err_cls = FolderConflictError\n        text = 'The folder is already shared.'\n    elif path_error.is_invalid_path():\n        text = 'The path is not valid.'\n    elif path_error.is_is_osx_package():\n        text = 'Cannot share macOS packages.'\n    elif path_error.is_inside_osx_package():\n        text = 'Cannot share folders inside macOS packages.'\n    elif path_error.is_is_vault():\n        text = 'Cannot share the Vault folder.'\n    elif path_error.is_is_vault_locked():\n        text = 'Cannot share a folder inside a locked Vault.'\n    elif path_error.is_is_family():\n        text = 'Cannot share the Family folder.'\n    else:\n        text = 'An unexpected error occurred. Please try again later.'\n    return (text, err_cls)",
            "def get_bad_path_error_msg(path_error: sharing.SharePathError) -> tuple[str, type[SyncError]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    err_cls = SyncError\n    if path_error.is_is_file():\n        text = 'A file is at the specified path.'\n        err_cls = FileConflictError\n    elif path_error.is_inside_shared_folder():\n        text = 'Cannot share a folder inside a shared folder.'\n    elif path_error.is_contains_shared_folder():\n        text = 'Cannot share a folder that contains a shared folder.'\n    elif path_error.is_contains_app_folder():\n        text = 'Cannot share a folder that contains an app folder.'\n    elif path_error.is_contains_team_folder():\n        text = 'Cannot share a folder that contains a team folder.'\n    elif path_error.is_is_app_folder():\n        text = 'Cannot share app folders.'\n    elif path_error.is_inside_app_folder():\n        text = 'Cannot share a folder inside an app folder.'\n    elif path_error.is_is_public_folder():\n        text = \"A public folder can't be shared this way. Use a public link instead.\"\n    elif path_error.is_inside_public_folder():\n        text = \"A folder inside a public folder can't be shared this way. Use a public link instead.\"\n    elif path_error.is_already_shared():\n        err_cls = FolderConflictError\n        text = 'The folder is already shared.'\n    elif path_error.is_invalid_path():\n        text = 'The path is not valid.'\n    elif path_error.is_is_osx_package():\n        text = 'Cannot share macOS packages.'\n    elif path_error.is_inside_osx_package():\n        text = 'Cannot share folders inside macOS packages.'\n    elif path_error.is_is_vault():\n        text = 'Cannot share the Vault folder.'\n    elif path_error.is_is_vault_locked():\n        text = 'Cannot share a folder inside a locked Vault.'\n    elif path_error.is_is_family():\n        text = 'Cannot share the Family folder.'\n    else:\n        text = 'An unexpected error occurred. Please try again later.'\n    return (text, err_cls)",
            "def get_bad_path_error_msg(path_error: sharing.SharePathError) -> tuple[str, type[SyncError]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    err_cls = SyncError\n    if path_error.is_is_file():\n        text = 'A file is at the specified path.'\n        err_cls = FileConflictError\n    elif path_error.is_inside_shared_folder():\n        text = 'Cannot share a folder inside a shared folder.'\n    elif path_error.is_contains_shared_folder():\n        text = 'Cannot share a folder that contains a shared folder.'\n    elif path_error.is_contains_app_folder():\n        text = 'Cannot share a folder that contains an app folder.'\n    elif path_error.is_contains_team_folder():\n        text = 'Cannot share a folder that contains a team folder.'\n    elif path_error.is_is_app_folder():\n        text = 'Cannot share app folders.'\n    elif path_error.is_inside_app_folder():\n        text = 'Cannot share a folder inside an app folder.'\n    elif path_error.is_is_public_folder():\n        text = \"A public folder can't be shared this way. Use a public link instead.\"\n    elif path_error.is_inside_public_folder():\n        text = \"A folder inside a public folder can't be shared this way. Use a public link instead.\"\n    elif path_error.is_already_shared():\n        err_cls = FolderConflictError\n        text = 'The folder is already shared.'\n    elif path_error.is_invalid_path():\n        text = 'The path is not valid.'\n    elif path_error.is_is_osx_package():\n        text = 'Cannot share macOS packages.'\n    elif path_error.is_inside_osx_package():\n        text = 'Cannot share folders inside macOS packages.'\n    elif path_error.is_is_vault():\n        text = 'Cannot share the Vault folder.'\n    elif path_error.is_is_vault_locked():\n        text = 'Cannot share a folder inside a locked Vault.'\n    elif path_error.is_is_family():\n        text = 'Cannot share the Family folder.'\n    else:\n        text = 'An unexpected error occurred. Please try again later.'\n    return (text, err_cls)",
            "def get_bad_path_error_msg(path_error: sharing.SharePathError) -> tuple[str, type[SyncError]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    err_cls = SyncError\n    if path_error.is_is_file():\n        text = 'A file is at the specified path.'\n        err_cls = FileConflictError\n    elif path_error.is_inside_shared_folder():\n        text = 'Cannot share a folder inside a shared folder.'\n    elif path_error.is_contains_shared_folder():\n        text = 'Cannot share a folder that contains a shared folder.'\n    elif path_error.is_contains_app_folder():\n        text = 'Cannot share a folder that contains an app folder.'\n    elif path_error.is_contains_team_folder():\n        text = 'Cannot share a folder that contains a team folder.'\n    elif path_error.is_is_app_folder():\n        text = 'Cannot share app folders.'\n    elif path_error.is_inside_app_folder():\n        text = 'Cannot share a folder inside an app folder.'\n    elif path_error.is_is_public_folder():\n        text = \"A public folder can't be shared this way. Use a public link instead.\"\n    elif path_error.is_inside_public_folder():\n        text = \"A folder inside a public folder can't be shared this way. Use a public link instead.\"\n    elif path_error.is_already_shared():\n        err_cls = FolderConflictError\n        text = 'The folder is already shared.'\n    elif path_error.is_invalid_path():\n        text = 'The path is not valid.'\n    elif path_error.is_is_osx_package():\n        text = 'Cannot share macOS packages.'\n    elif path_error.is_inside_osx_package():\n        text = 'Cannot share folders inside macOS packages.'\n    elif path_error.is_is_vault():\n        text = 'Cannot share the Vault folder.'\n    elif path_error.is_is_vault_locked():\n        text = 'Cannot share a folder inside a locked Vault.'\n    elif path_error.is_is_family():\n        text = 'Cannot share the Family folder.'\n    else:\n        text = 'An unexpected error occurred. Please try again later.'\n    return (text, err_cls)",
            "def get_bad_path_error_msg(path_error: sharing.SharePathError) -> tuple[str, type[SyncError]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    err_cls = SyncError\n    if path_error.is_is_file():\n        text = 'A file is at the specified path.'\n        err_cls = FileConflictError\n    elif path_error.is_inside_shared_folder():\n        text = 'Cannot share a folder inside a shared folder.'\n    elif path_error.is_contains_shared_folder():\n        text = 'Cannot share a folder that contains a shared folder.'\n    elif path_error.is_contains_app_folder():\n        text = 'Cannot share a folder that contains an app folder.'\n    elif path_error.is_contains_team_folder():\n        text = 'Cannot share a folder that contains a team folder.'\n    elif path_error.is_is_app_folder():\n        text = 'Cannot share app folders.'\n    elif path_error.is_inside_app_folder():\n        text = 'Cannot share a folder inside an app folder.'\n    elif path_error.is_is_public_folder():\n        text = \"A public folder can't be shared this way. Use a public link instead.\"\n    elif path_error.is_inside_public_folder():\n        text = \"A folder inside a public folder can't be shared this way. Use a public link instead.\"\n    elif path_error.is_already_shared():\n        err_cls = FolderConflictError\n        text = 'The folder is already shared.'\n    elif path_error.is_invalid_path():\n        text = 'The path is not valid.'\n    elif path_error.is_is_osx_package():\n        text = 'Cannot share macOS packages.'\n    elif path_error.is_inside_osx_package():\n        text = 'Cannot share folders inside macOS packages.'\n    elif path_error.is_is_vault():\n        text = 'Cannot share the Vault folder.'\n    elif path_error.is_is_vault_locked():\n        text = 'Cannot share a folder inside a locked Vault.'\n    elif path_error.is_is_family():\n        text = 'Cannot share the Family folder.'\n    else:\n        text = 'An unexpected error occurred. Please try again later.'\n    return (text, err_cls)"
        ]
    }
]