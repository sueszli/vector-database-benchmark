[
    {
        "func_name": "_Aij",
        "original": "def _Aij(A, i, j):\n    \"\"\"Sum of upper-left and lower right blocks of contingency table.\"\"\"\n    return A[:i, :j].sum() + A[i + 1:, j + 1:].sum()",
        "mutated": [
            "def _Aij(A, i, j):\n    if False:\n        i = 10\n    'Sum of upper-left and lower right blocks of contingency table.'\n    return A[:i, :j].sum() + A[i + 1:, j + 1:].sum()",
            "def _Aij(A, i, j):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Sum of upper-left and lower right blocks of contingency table.'\n    return A[:i, :j].sum() + A[i + 1:, j + 1:].sum()",
            "def _Aij(A, i, j):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Sum of upper-left and lower right blocks of contingency table.'\n    return A[:i, :j].sum() + A[i + 1:, j + 1:].sum()",
            "def _Aij(A, i, j):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Sum of upper-left and lower right blocks of contingency table.'\n    return A[:i, :j].sum() + A[i + 1:, j + 1:].sum()",
            "def _Aij(A, i, j):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Sum of upper-left and lower right blocks of contingency table.'\n    return A[:i, :j].sum() + A[i + 1:, j + 1:].sum()"
        ]
    },
    {
        "func_name": "_Dij",
        "original": "def _Dij(A, i, j):\n    \"\"\"Sum of lower-left and upper-right blocks of contingency table.\"\"\"\n    return A[i + 1:, :j].sum() + A[:i, j + 1:].sum()",
        "mutated": [
            "def _Dij(A, i, j):\n    if False:\n        i = 10\n    'Sum of lower-left and upper-right blocks of contingency table.'\n    return A[i + 1:, :j].sum() + A[:i, j + 1:].sum()",
            "def _Dij(A, i, j):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Sum of lower-left and upper-right blocks of contingency table.'\n    return A[i + 1:, :j].sum() + A[:i, j + 1:].sum()",
            "def _Dij(A, i, j):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Sum of lower-left and upper-right blocks of contingency table.'\n    return A[i + 1:, :j].sum() + A[:i, j + 1:].sum()",
            "def _Dij(A, i, j):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Sum of lower-left and upper-right blocks of contingency table.'\n    return A[i + 1:, :j].sum() + A[:i, j + 1:].sum()",
            "def _Dij(A, i, j):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Sum of lower-left and upper-right blocks of contingency table.'\n    return A[i + 1:, :j].sum() + A[:i, j + 1:].sum()"
        ]
    },
    {
        "func_name": "_concordant_pairs",
        "original": "def _concordant_pairs(A):\n    \"\"\"Twice the number of concordant pairs, excluding ties.\"\"\"\n    (m, n) = A.shape\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            count += A[i, j] * _Aij(A, i, j)\n    return count",
        "mutated": [
            "def _concordant_pairs(A):\n    if False:\n        i = 10\n    'Twice the number of concordant pairs, excluding ties.'\n    (m, n) = A.shape\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            count += A[i, j] * _Aij(A, i, j)\n    return count",
            "def _concordant_pairs(A):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Twice the number of concordant pairs, excluding ties.'\n    (m, n) = A.shape\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            count += A[i, j] * _Aij(A, i, j)\n    return count",
            "def _concordant_pairs(A):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Twice the number of concordant pairs, excluding ties.'\n    (m, n) = A.shape\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            count += A[i, j] * _Aij(A, i, j)\n    return count",
            "def _concordant_pairs(A):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Twice the number of concordant pairs, excluding ties.'\n    (m, n) = A.shape\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            count += A[i, j] * _Aij(A, i, j)\n    return count",
            "def _concordant_pairs(A):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Twice the number of concordant pairs, excluding ties.'\n    (m, n) = A.shape\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            count += A[i, j] * _Aij(A, i, j)\n    return count"
        ]
    },
    {
        "func_name": "_discordant_pairs",
        "original": "def _discordant_pairs(A):\n    \"\"\"Twice the number of discordant pairs, excluding ties.\"\"\"\n    (m, n) = A.shape\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            count += A[i, j] * _Dij(A, i, j)\n    return count",
        "mutated": [
            "def _discordant_pairs(A):\n    if False:\n        i = 10\n    'Twice the number of discordant pairs, excluding ties.'\n    (m, n) = A.shape\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            count += A[i, j] * _Dij(A, i, j)\n    return count",
            "def _discordant_pairs(A):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Twice the number of discordant pairs, excluding ties.'\n    (m, n) = A.shape\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            count += A[i, j] * _Dij(A, i, j)\n    return count",
            "def _discordant_pairs(A):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Twice the number of discordant pairs, excluding ties.'\n    (m, n) = A.shape\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            count += A[i, j] * _Dij(A, i, j)\n    return count",
            "def _discordant_pairs(A):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Twice the number of discordant pairs, excluding ties.'\n    (m, n) = A.shape\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            count += A[i, j] * _Dij(A, i, j)\n    return count",
            "def _discordant_pairs(A):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Twice the number of discordant pairs, excluding ties.'\n    (m, n) = A.shape\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            count += A[i, j] * _Dij(A, i, j)\n    return count"
        ]
    },
    {
        "func_name": "_a_ij_Aij_Dij2",
        "original": "def _a_ij_Aij_Dij2(A):\n    \"\"\"A term that appears in the ASE of Kendall's tau and Somers' D.\"\"\"\n    (m, n) = A.shape\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            count += A[i, j] * (_Aij(A, i, j) - _Dij(A, i, j)) ** 2\n    return count",
        "mutated": [
            "def _a_ij_Aij_Dij2(A):\n    if False:\n        i = 10\n    \"A term that appears in the ASE of Kendall's tau and Somers' D.\"\n    (m, n) = A.shape\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            count += A[i, j] * (_Aij(A, i, j) - _Dij(A, i, j)) ** 2\n    return count",
            "def _a_ij_Aij_Dij2(A):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"A term that appears in the ASE of Kendall's tau and Somers' D.\"\n    (m, n) = A.shape\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            count += A[i, j] * (_Aij(A, i, j) - _Dij(A, i, j)) ** 2\n    return count",
            "def _a_ij_Aij_Dij2(A):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"A term that appears in the ASE of Kendall's tau and Somers' D.\"\n    (m, n) = A.shape\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            count += A[i, j] * (_Aij(A, i, j) - _Dij(A, i, j)) ** 2\n    return count",
            "def _a_ij_Aij_Dij2(A):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"A term that appears in the ASE of Kendall's tau and Somers' D.\"\n    (m, n) = A.shape\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            count += A[i, j] * (_Aij(A, i, j) - _Dij(A, i, j)) ** 2\n    return count",
            "def _a_ij_Aij_Dij2(A):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"A term that appears in the ASE of Kendall's tau and Somers' D.\"\n    (m, n) = A.shape\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            count += A[i, j] * (_Aij(A, i, j) - _Dij(A, i, j)) ** 2\n    return count"
        ]
    },
    {
        "func_name": "_compute_outer_prob_inside_method",
        "original": "def _compute_outer_prob_inside_method(m, n, g, h):\n    \"\"\"\n    Count the proportion of paths that do not stay strictly inside two\n    diagonal lines.\n\n    Parameters\n    ----------\n    m : integer\n        m > 0\n    n : integer\n        n > 0\n    g : integer\n        g is greatest common divisor of m and n\n    h : integer\n        0 <= h <= lcm(m,n)\n\n    Returns\n    -------\n    p : float\n        The proportion of paths that do not stay inside the two lines.\n\n    The classical algorithm counts the integer lattice paths from (0, 0)\n    to (m, n) which satisfy |x/m - y/n| < h / lcm(m, n).\n    The paths make steps of size +1 in either positive x or positive y\n    directions.\n    We are, however, interested in 1 - proportion to computes p-values,\n    so we change the recursion to compute 1 - p directly while staying\n    within the \"inside method\" a described by Hodges.\n\n    We generally follow Hodges' treatment of Drion/Gnedenko/Korolyuk.\n    Hodges, J.L. Jr.,\n    \"The Significance Probability of the Smirnov Two-Sample Test,\"\n    Arkiv fiur Matematik, 3, No. 43 (1958), 469-86.\n\n    For the recursion for 1-p see\n    Viehmann, T.: \"Numerically more stable computation of the p-values\n    for the two-sample Kolmogorov-Smirnov test,\" arXiv: 2102.08037\n\n    \"\"\"\n    if m < n:\n        (m, n) = (n, m)\n    mg = m // g\n    ng = n // g\n    (minj, maxj) = (0, min(int(np.ceil(h / mg)), n + 1))\n    curlen = maxj - minj\n    lenA = min(2 * maxj + 2, n + 1)\n    dtype = np.float64\n    A = np.ones(lenA, dtype=dtype)\n    A[minj:maxj] = 0.0\n    for i in range(1, m + 1):\n        (lastminj, lastlen) = (minj, curlen)\n        minj = max(int(np.floor((ng * i - h) / mg)) + 1, 0)\n        minj = min(minj, n)\n        maxj = min(int(np.ceil((ng * i + h) / mg)), n + 1)\n        if maxj <= minj:\n            return 1.0\n        val = 0.0 if minj == 0 else 1.0\n        for jj in range(maxj - minj):\n            j = jj + minj\n            val = (A[jj + minj - lastminj] * i + val * j) / (i + j)\n            A[jj] = val\n        curlen = maxj - minj\n        if lastlen > curlen:\n            A[maxj - minj:maxj - minj + (lastlen - curlen)] = 1\n    return A[maxj - minj - 1]",
        "mutated": [
            "def _compute_outer_prob_inside_method(m, n, g, h):\n    if False:\n        i = 10\n    '\\n    Count the proportion of paths that do not stay strictly inside two\\n    diagonal lines.\\n\\n    Parameters\\n    ----------\\n    m : integer\\n        m > 0\\n    n : integer\\n        n > 0\\n    g : integer\\n        g is greatest common divisor of m and n\\n    h : integer\\n        0 <= h <= lcm(m,n)\\n\\n    Returns\\n    -------\\n    p : float\\n        The proportion of paths that do not stay inside the two lines.\\n\\n    The classical algorithm counts the integer lattice paths from (0, 0)\\n    to (m, n) which satisfy |x/m - y/n| < h / lcm(m, n).\\n    The paths make steps of size +1 in either positive x or positive y\\n    directions.\\n    We are, however, interested in 1 - proportion to computes p-values,\\n    so we change the recursion to compute 1 - p directly while staying\\n    within the \"inside method\" a described by Hodges.\\n\\n    We generally follow Hodges\\' treatment of Drion/Gnedenko/Korolyuk.\\n    Hodges, J.L. Jr.,\\n    \"The Significance Probability of the Smirnov Two-Sample Test,\"\\n    Arkiv fiur Matematik, 3, No. 43 (1958), 469-86.\\n\\n    For the recursion for 1-p see\\n    Viehmann, T.: \"Numerically more stable computation of the p-values\\n    for the two-sample Kolmogorov-Smirnov test,\" arXiv: 2102.08037\\n\\n    '\n    if m < n:\n        (m, n) = (n, m)\n    mg = m // g\n    ng = n // g\n    (minj, maxj) = (0, min(int(np.ceil(h / mg)), n + 1))\n    curlen = maxj - minj\n    lenA = min(2 * maxj + 2, n + 1)\n    dtype = np.float64\n    A = np.ones(lenA, dtype=dtype)\n    A[minj:maxj] = 0.0\n    for i in range(1, m + 1):\n        (lastminj, lastlen) = (minj, curlen)\n        minj = max(int(np.floor((ng * i - h) / mg)) + 1, 0)\n        minj = min(minj, n)\n        maxj = min(int(np.ceil((ng * i + h) / mg)), n + 1)\n        if maxj <= minj:\n            return 1.0\n        val = 0.0 if minj == 0 else 1.0\n        for jj in range(maxj - minj):\n            j = jj + minj\n            val = (A[jj + minj - lastminj] * i + val * j) / (i + j)\n            A[jj] = val\n        curlen = maxj - minj\n        if lastlen > curlen:\n            A[maxj - minj:maxj - minj + (lastlen - curlen)] = 1\n    return A[maxj - minj - 1]",
            "def _compute_outer_prob_inside_method(m, n, g, h):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Count the proportion of paths that do not stay strictly inside two\\n    diagonal lines.\\n\\n    Parameters\\n    ----------\\n    m : integer\\n        m > 0\\n    n : integer\\n        n > 0\\n    g : integer\\n        g is greatest common divisor of m and n\\n    h : integer\\n        0 <= h <= lcm(m,n)\\n\\n    Returns\\n    -------\\n    p : float\\n        The proportion of paths that do not stay inside the two lines.\\n\\n    The classical algorithm counts the integer lattice paths from (0, 0)\\n    to (m, n) which satisfy |x/m - y/n| < h / lcm(m, n).\\n    The paths make steps of size +1 in either positive x or positive y\\n    directions.\\n    We are, however, interested in 1 - proportion to computes p-values,\\n    so we change the recursion to compute 1 - p directly while staying\\n    within the \"inside method\" a described by Hodges.\\n\\n    We generally follow Hodges\\' treatment of Drion/Gnedenko/Korolyuk.\\n    Hodges, J.L. Jr.,\\n    \"The Significance Probability of the Smirnov Two-Sample Test,\"\\n    Arkiv fiur Matematik, 3, No. 43 (1958), 469-86.\\n\\n    For the recursion for 1-p see\\n    Viehmann, T.: \"Numerically more stable computation of the p-values\\n    for the two-sample Kolmogorov-Smirnov test,\" arXiv: 2102.08037\\n\\n    '\n    if m < n:\n        (m, n) = (n, m)\n    mg = m // g\n    ng = n // g\n    (minj, maxj) = (0, min(int(np.ceil(h / mg)), n + 1))\n    curlen = maxj - minj\n    lenA = min(2 * maxj + 2, n + 1)\n    dtype = np.float64\n    A = np.ones(lenA, dtype=dtype)\n    A[minj:maxj] = 0.0\n    for i in range(1, m + 1):\n        (lastminj, lastlen) = (minj, curlen)\n        minj = max(int(np.floor((ng * i - h) / mg)) + 1, 0)\n        minj = min(minj, n)\n        maxj = min(int(np.ceil((ng * i + h) / mg)), n + 1)\n        if maxj <= minj:\n            return 1.0\n        val = 0.0 if minj == 0 else 1.0\n        for jj in range(maxj - minj):\n            j = jj + minj\n            val = (A[jj + minj - lastminj] * i + val * j) / (i + j)\n            A[jj] = val\n        curlen = maxj - minj\n        if lastlen > curlen:\n            A[maxj - minj:maxj - minj + (lastlen - curlen)] = 1\n    return A[maxj - minj - 1]",
            "def _compute_outer_prob_inside_method(m, n, g, h):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Count the proportion of paths that do not stay strictly inside two\\n    diagonal lines.\\n\\n    Parameters\\n    ----------\\n    m : integer\\n        m > 0\\n    n : integer\\n        n > 0\\n    g : integer\\n        g is greatest common divisor of m and n\\n    h : integer\\n        0 <= h <= lcm(m,n)\\n\\n    Returns\\n    -------\\n    p : float\\n        The proportion of paths that do not stay inside the two lines.\\n\\n    The classical algorithm counts the integer lattice paths from (0, 0)\\n    to (m, n) which satisfy |x/m - y/n| < h / lcm(m, n).\\n    The paths make steps of size +1 in either positive x or positive y\\n    directions.\\n    We are, however, interested in 1 - proportion to computes p-values,\\n    so we change the recursion to compute 1 - p directly while staying\\n    within the \"inside method\" a described by Hodges.\\n\\n    We generally follow Hodges\\' treatment of Drion/Gnedenko/Korolyuk.\\n    Hodges, J.L. Jr.,\\n    \"The Significance Probability of the Smirnov Two-Sample Test,\"\\n    Arkiv fiur Matematik, 3, No. 43 (1958), 469-86.\\n\\n    For the recursion for 1-p see\\n    Viehmann, T.: \"Numerically more stable computation of the p-values\\n    for the two-sample Kolmogorov-Smirnov test,\" arXiv: 2102.08037\\n\\n    '\n    if m < n:\n        (m, n) = (n, m)\n    mg = m // g\n    ng = n // g\n    (minj, maxj) = (0, min(int(np.ceil(h / mg)), n + 1))\n    curlen = maxj - minj\n    lenA = min(2 * maxj + 2, n + 1)\n    dtype = np.float64\n    A = np.ones(lenA, dtype=dtype)\n    A[minj:maxj] = 0.0\n    for i in range(1, m + 1):\n        (lastminj, lastlen) = (minj, curlen)\n        minj = max(int(np.floor((ng * i - h) / mg)) + 1, 0)\n        minj = min(minj, n)\n        maxj = min(int(np.ceil((ng * i + h) / mg)), n + 1)\n        if maxj <= minj:\n            return 1.0\n        val = 0.0 if minj == 0 else 1.0\n        for jj in range(maxj - minj):\n            j = jj + minj\n            val = (A[jj + minj - lastminj] * i + val * j) / (i + j)\n            A[jj] = val\n        curlen = maxj - minj\n        if lastlen > curlen:\n            A[maxj - minj:maxj - minj + (lastlen - curlen)] = 1\n    return A[maxj - minj - 1]",
            "def _compute_outer_prob_inside_method(m, n, g, h):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Count the proportion of paths that do not stay strictly inside two\\n    diagonal lines.\\n\\n    Parameters\\n    ----------\\n    m : integer\\n        m > 0\\n    n : integer\\n        n > 0\\n    g : integer\\n        g is greatest common divisor of m and n\\n    h : integer\\n        0 <= h <= lcm(m,n)\\n\\n    Returns\\n    -------\\n    p : float\\n        The proportion of paths that do not stay inside the two lines.\\n\\n    The classical algorithm counts the integer lattice paths from (0, 0)\\n    to (m, n) which satisfy |x/m - y/n| < h / lcm(m, n).\\n    The paths make steps of size +1 in either positive x or positive y\\n    directions.\\n    We are, however, interested in 1 - proportion to computes p-values,\\n    so we change the recursion to compute 1 - p directly while staying\\n    within the \"inside method\" a described by Hodges.\\n\\n    We generally follow Hodges\\' treatment of Drion/Gnedenko/Korolyuk.\\n    Hodges, J.L. Jr.,\\n    \"The Significance Probability of the Smirnov Two-Sample Test,\"\\n    Arkiv fiur Matematik, 3, No. 43 (1958), 469-86.\\n\\n    For the recursion for 1-p see\\n    Viehmann, T.: \"Numerically more stable computation of the p-values\\n    for the two-sample Kolmogorov-Smirnov test,\" arXiv: 2102.08037\\n\\n    '\n    if m < n:\n        (m, n) = (n, m)\n    mg = m // g\n    ng = n // g\n    (minj, maxj) = (0, min(int(np.ceil(h / mg)), n + 1))\n    curlen = maxj - minj\n    lenA = min(2 * maxj + 2, n + 1)\n    dtype = np.float64\n    A = np.ones(lenA, dtype=dtype)\n    A[minj:maxj] = 0.0\n    for i in range(1, m + 1):\n        (lastminj, lastlen) = (minj, curlen)\n        minj = max(int(np.floor((ng * i - h) / mg)) + 1, 0)\n        minj = min(minj, n)\n        maxj = min(int(np.ceil((ng * i + h) / mg)), n + 1)\n        if maxj <= minj:\n            return 1.0\n        val = 0.0 if minj == 0 else 1.0\n        for jj in range(maxj - minj):\n            j = jj + minj\n            val = (A[jj + minj - lastminj] * i + val * j) / (i + j)\n            A[jj] = val\n        curlen = maxj - minj\n        if lastlen > curlen:\n            A[maxj - minj:maxj - minj + (lastlen - curlen)] = 1\n    return A[maxj - minj - 1]",
            "def _compute_outer_prob_inside_method(m, n, g, h):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Count the proportion of paths that do not stay strictly inside two\\n    diagonal lines.\\n\\n    Parameters\\n    ----------\\n    m : integer\\n        m > 0\\n    n : integer\\n        n > 0\\n    g : integer\\n        g is greatest common divisor of m and n\\n    h : integer\\n        0 <= h <= lcm(m,n)\\n\\n    Returns\\n    -------\\n    p : float\\n        The proportion of paths that do not stay inside the two lines.\\n\\n    The classical algorithm counts the integer lattice paths from (0, 0)\\n    to (m, n) which satisfy |x/m - y/n| < h / lcm(m, n).\\n    The paths make steps of size +1 in either positive x or positive y\\n    directions.\\n    We are, however, interested in 1 - proportion to computes p-values,\\n    so we change the recursion to compute 1 - p directly while staying\\n    within the \"inside method\" a described by Hodges.\\n\\n    We generally follow Hodges\\' treatment of Drion/Gnedenko/Korolyuk.\\n    Hodges, J.L. Jr.,\\n    \"The Significance Probability of the Smirnov Two-Sample Test,\"\\n    Arkiv fiur Matematik, 3, No. 43 (1958), 469-86.\\n\\n    For the recursion for 1-p see\\n    Viehmann, T.: \"Numerically more stable computation of the p-values\\n    for the two-sample Kolmogorov-Smirnov test,\" arXiv: 2102.08037\\n\\n    '\n    if m < n:\n        (m, n) = (n, m)\n    mg = m // g\n    ng = n // g\n    (minj, maxj) = (0, min(int(np.ceil(h / mg)), n + 1))\n    curlen = maxj - minj\n    lenA = min(2 * maxj + 2, n + 1)\n    dtype = np.float64\n    A = np.ones(lenA, dtype=dtype)\n    A[minj:maxj] = 0.0\n    for i in range(1, m + 1):\n        (lastminj, lastlen) = (minj, curlen)\n        minj = max(int(np.floor((ng * i - h) / mg)) + 1, 0)\n        minj = min(minj, n)\n        maxj = min(int(np.ceil((ng * i + h) / mg)), n + 1)\n        if maxj <= minj:\n            return 1.0\n        val = 0.0 if minj == 0 else 1.0\n        for jj in range(maxj - minj):\n            j = jj + minj\n            val = (A[jj + minj - lastminj] * i + val * j) / (i + j)\n            A[jj] = val\n        curlen = maxj - minj\n        if lastlen > curlen:\n            A[maxj - minj:maxj - minj + (lastlen - curlen)] = 1\n    return A[maxj - minj - 1]"
        ]
    },
    {
        "func_name": "siegelslopes",
        "original": "def siegelslopes(y, x, method):\n    deltax = np.expand_dims(x, 1) - x\n    deltay = np.expand_dims(y, 1) - y\n    (slopes, intercepts) = ([], [])\n    for j in range(len(x)):\n        (id_nonzero,) = np.nonzero(deltax[j, :])\n        slopes_j = deltay[j, id_nonzero] / deltax[j, id_nonzero]\n        medslope_j = np.median(slopes_j)\n        slopes.append(medslope_j)\n        if method == 'separate':\n            z = y * x[j] - y[j] * x\n            medintercept_j = np.median(z[id_nonzero] / deltax[j, id_nonzero])\n            intercepts.append(medintercept_j)\n    medslope = np.median(np.asarray(slopes))\n    if method == 'separate':\n        medinter = np.median(np.asarray(intercepts))\n    else:\n        medinter = np.median(y - medslope * x)\n    return (medslope, medinter)",
        "mutated": [
            "def siegelslopes(y, x, method):\n    if False:\n        i = 10\n    deltax = np.expand_dims(x, 1) - x\n    deltay = np.expand_dims(y, 1) - y\n    (slopes, intercepts) = ([], [])\n    for j in range(len(x)):\n        (id_nonzero,) = np.nonzero(deltax[j, :])\n        slopes_j = deltay[j, id_nonzero] / deltax[j, id_nonzero]\n        medslope_j = np.median(slopes_j)\n        slopes.append(medslope_j)\n        if method == 'separate':\n            z = y * x[j] - y[j] * x\n            medintercept_j = np.median(z[id_nonzero] / deltax[j, id_nonzero])\n            intercepts.append(medintercept_j)\n    medslope = np.median(np.asarray(slopes))\n    if method == 'separate':\n        medinter = np.median(np.asarray(intercepts))\n    else:\n        medinter = np.median(y - medslope * x)\n    return (medslope, medinter)",
            "def siegelslopes(y, x, method):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    deltax = np.expand_dims(x, 1) - x\n    deltay = np.expand_dims(y, 1) - y\n    (slopes, intercepts) = ([], [])\n    for j in range(len(x)):\n        (id_nonzero,) = np.nonzero(deltax[j, :])\n        slopes_j = deltay[j, id_nonzero] / deltax[j, id_nonzero]\n        medslope_j = np.median(slopes_j)\n        slopes.append(medslope_j)\n        if method == 'separate':\n            z = y * x[j] - y[j] * x\n            medintercept_j = np.median(z[id_nonzero] / deltax[j, id_nonzero])\n            intercepts.append(medintercept_j)\n    medslope = np.median(np.asarray(slopes))\n    if method == 'separate':\n        medinter = np.median(np.asarray(intercepts))\n    else:\n        medinter = np.median(y - medslope * x)\n    return (medslope, medinter)",
            "def siegelslopes(y, x, method):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    deltax = np.expand_dims(x, 1) - x\n    deltay = np.expand_dims(y, 1) - y\n    (slopes, intercepts) = ([], [])\n    for j in range(len(x)):\n        (id_nonzero,) = np.nonzero(deltax[j, :])\n        slopes_j = deltay[j, id_nonzero] / deltax[j, id_nonzero]\n        medslope_j = np.median(slopes_j)\n        slopes.append(medslope_j)\n        if method == 'separate':\n            z = y * x[j] - y[j] * x\n            medintercept_j = np.median(z[id_nonzero] / deltax[j, id_nonzero])\n            intercepts.append(medintercept_j)\n    medslope = np.median(np.asarray(slopes))\n    if method == 'separate':\n        medinter = np.median(np.asarray(intercepts))\n    else:\n        medinter = np.median(y - medslope * x)\n    return (medslope, medinter)",
            "def siegelslopes(y, x, method):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    deltax = np.expand_dims(x, 1) - x\n    deltay = np.expand_dims(y, 1) - y\n    (slopes, intercepts) = ([], [])\n    for j in range(len(x)):\n        (id_nonzero,) = np.nonzero(deltax[j, :])\n        slopes_j = deltay[j, id_nonzero] / deltax[j, id_nonzero]\n        medslope_j = np.median(slopes_j)\n        slopes.append(medslope_j)\n        if method == 'separate':\n            z = y * x[j] - y[j] * x\n            medintercept_j = np.median(z[id_nonzero] / deltax[j, id_nonzero])\n            intercepts.append(medintercept_j)\n    medslope = np.median(np.asarray(slopes))\n    if method == 'separate':\n        medinter = np.median(np.asarray(intercepts))\n    else:\n        medinter = np.median(y - medslope * x)\n    return (medslope, medinter)",
            "def siegelslopes(y, x, method):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    deltax = np.expand_dims(x, 1) - x\n    deltay = np.expand_dims(y, 1) - y\n    (slopes, intercepts) = ([], [])\n    for j in range(len(x)):\n        (id_nonzero,) = np.nonzero(deltax[j, :])\n        slopes_j = deltay[j, id_nonzero] / deltax[j, id_nonzero]\n        medslope_j = np.median(slopes_j)\n        slopes.append(medslope_j)\n        if method == 'separate':\n            z = y * x[j] - y[j] * x\n            medintercept_j = np.median(z[id_nonzero] / deltax[j, id_nonzero])\n            intercepts.append(medintercept_j)\n    medslope = np.median(np.asarray(slopes))\n    if method == 'separate':\n        medinter = np.median(np.asarray(intercepts))\n    else:\n        medinter = np.median(y - medslope * x)\n    return (medslope, medinter)"
        ]
    }
]