[
    {
        "func_name": "test_convert_calendar",
        "original": "@pytest.mark.parametrize('source, target, use_cftime, freq', [('standard', 'noleap', None, 'D'), ('noleap', 'proleptic_gregorian', True, 'D'), ('noleap', 'all_leap', None, 'D'), ('all_leap', 'proleptic_gregorian', False, '4H')])\ndef test_convert_calendar(source, target, use_cftime, freq):\n    src = DataArray(date_range('2004-01-01', '2004-12-31', freq=freq, calendar=source), dims=('time',), name='time')\n    da_src = DataArray(np.linspace(0, 1, src.size), dims=('time',), coords={'time': src})\n    conv = convert_calendar(da_src, target, use_cftime=use_cftime)\n    assert conv.time.dt.calendar == target\n    if source != 'noleap':\n        expected_times = date_range('2004-01-01', '2004-12-31', freq=freq, use_cftime=use_cftime, calendar=target)\n    else:\n        expected_times_pre_leap = date_range('2004-01-01', '2004-02-28', freq=freq, use_cftime=use_cftime, calendar=target)\n        expected_times_post_leap = date_range('2004-03-01', '2004-12-31', freq=freq, use_cftime=use_cftime, calendar=target)\n        expected_times = expected_times_pre_leap.append(expected_times_post_leap)\n    np.testing.assert_array_equal(conv.time, expected_times)",
        "mutated": [
            "@pytest.mark.parametrize('source, target, use_cftime, freq', [('standard', 'noleap', None, 'D'), ('noleap', 'proleptic_gregorian', True, 'D'), ('noleap', 'all_leap', None, 'D'), ('all_leap', 'proleptic_gregorian', False, '4H')])\ndef test_convert_calendar(source, target, use_cftime, freq):\n    if False:\n        i = 10\n    src = DataArray(date_range('2004-01-01', '2004-12-31', freq=freq, calendar=source), dims=('time',), name='time')\n    da_src = DataArray(np.linspace(0, 1, src.size), dims=('time',), coords={'time': src})\n    conv = convert_calendar(da_src, target, use_cftime=use_cftime)\n    assert conv.time.dt.calendar == target\n    if source != 'noleap':\n        expected_times = date_range('2004-01-01', '2004-12-31', freq=freq, use_cftime=use_cftime, calendar=target)\n    else:\n        expected_times_pre_leap = date_range('2004-01-01', '2004-02-28', freq=freq, use_cftime=use_cftime, calendar=target)\n        expected_times_post_leap = date_range('2004-03-01', '2004-12-31', freq=freq, use_cftime=use_cftime, calendar=target)\n        expected_times = expected_times_pre_leap.append(expected_times_post_leap)\n    np.testing.assert_array_equal(conv.time, expected_times)",
            "@pytest.mark.parametrize('source, target, use_cftime, freq', [('standard', 'noleap', None, 'D'), ('noleap', 'proleptic_gregorian', True, 'D'), ('noleap', 'all_leap', None, 'D'), ('all_leap', 'proleptic_gregorian', False, '4H')])\ndef test_convert_calendar(source, target, use_cftime, freq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    src = DataArray(date_range('2004-01-01', '2004-12-31', freq=freq, calendar=source), dims=('time',), name='time')\n    da_src = DataArray(np.linspace(0, 1, src.size), dims=('time',), coords={'time': src})\n    conv = convert_calendar(da_src, target, use_cftime=use_cftime)\n    assert conv.time.dt.calendar == target\n    if source != 'noleap':\n        expected_times = date_range('2004-01-01', '2004-12-31', freq=freq, use_cftime=use_cftime, calendar=target)\n    else:\n        expected_times_pre_leap = date_range('2004-01-01', '2004-02-28', freq=freq, use_cftime=use_cftime, calendar=target)\n        expected_times_post_leap = date_range('2004-03-01', '2004-12-31', freq=freq, use_cftime=use_cftime, calendar=target)\n        expected_times = expected_times_pre_leap.append(expected_times_post_leap)\n    np.testing.assert_array_equal(conv.time, expected_times)",
            "@pytest.mark.parametrize('source, target, use_cftime, freq', [('standard', 'noleap', None, 'D'), ('noleap', 'proleptic_gregorian', True, 'D'), ('noleap', 'all_leap', None, 'D'), ('all_leap', 'proleptic_gregorian', False, '4H')])\ndef test_convert_calendar(source, target, use_cftime, freq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    src = DataArray(date_range('2004-01-01', '2004-12-31', freq=freq, calendar=source), dims=('time',), name='time')\n    da_src = DataArray(np.linspace(0, 1, src.size), dims=('time',), coords={'time': src})\n    conv = convert_calendar(da_src, target, use_cftime=use_cftime)\n    assert conv.time.dt.calendar == target\n    if source != 'noleap':\n        expected_times = date_range('2004-01-01', '2004-12-31', freq=freq, use_cftime=use_cftime, calendar=target)\n    else:\n        expected_times_pre_leap = date_range('2004-01-01', '2004-02-28', freq=freq, use_cftime=use_cftime, calendar=target)\n        expected_times_post_leap = date_range('2004-03-01', '2004-12-31', freq=freq, use_cftime=use_cftime, calendar=target)\n        expected_times = expected_times_pre_leap.append(expected_times_post_leap)\n    np.testing.assert_array_equal(conv.time, expected_times)",
            "@pytest.mark.parametrize('source, target, use_cftime, freq', [('standard', 'noleap', None, 'D'), ('noleap', 'proleptic_gregorian', True, 'D'), ('noleap', 'all_leap', None, 'D'), ('all_leap', 'proleptic_gregorian', False, '4H')])\ndef test_convert_calendar(source, target, use_cftime, freq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    src = DataArray(date_range('2004-01-01', '2004-12-31', freq=freq, calendar=source), dims=('time',), name='time')\n    da_src = DataArray(np.linspace(0, 1, src.size), dims=('time',), coords={'time': src})\n    conv = convert_calendar(da_src, target, use_cftime=use_cftime)\n    assert conv.time.dt.calendar == target\n    if source != 'noleap':\n        expected_times = date_range('2004-01-01', '2004-12-31', freq=freq, use_cftime=use_cftime, calendar=target)\n    else:\n        expected_times_pre_leap = date_range('2004-01-01', '2004-02-28', freq=freq, use_cftime=use_cftime, calendar=target)\n        expected_times_post_leap = date_range('2004-03-01', '2004-12-31', freq=freq, use_cftime=use_cftime, calendar=target)\n        expected_times = expected_times_pre_leap.append(expected_times_post_leap)\n    np.testing.assert_array_equal(conv.time, expected_times)",
            "@pytest.mark.parametrize('source, target, use_cftime, freq', [('standard', 'noleap', None, 'D'), ('noleap', 'proleptic_gregorian', True, 'D'), ('noleap', 'all_leap', None, 'D'), ('all_leap', 'proleptic_gregorian', False, '4H')])\ndef test_convert_calendar(source, target, use_cftime, freq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    src = DataArray(date_range('2004-01-01', '2004-12-31', freq=freq, calendar=source), dims=('time',), name='time')\n    da_src = DataArray(np.linspace(0, 1, src.size), dims=('time',), coords={'time': src})\n    conv = convert_calendar(da_src, target, use_cftime=use_cftime)\n    assert conv.time.dt.calendar == target\n    if source != 'noleap':\n        expected_times = date_range('2004-01-01', '2004-12-31', freq=freq, use_cftime=use_cftime, calendar=target)\n    else:\n        expected_times_pre_leap = date_range('2004-01-01', '2004-02-28', freq=freq, use_cftime=use_cftime, calendar=target)\n        expected_times_post_leap = date_range('2004-03-01', '2004-12-31', freq=freq, use_cftime=use_cftime, calendar=target)\n        expected_times = expected_times_pre_leap.append(expected_times_post_leap)\n    np.testing.assert_array_equal(conv.time, expected_times)"
        ]
    },
    {
        "func_name": "test_convert_calendar_360_days",
        "original": "@pytest.mark.parametrize('source,target,freq', [('standard', '360_day', 'D'), ('360_day', 'proleptic_gregorian', 'D'), ('proleptic_gregorian', '360_day', '4H')])\n@pytest.mark.parametrize('align_on', ['date', 'year'])\ndef test_convert_calendar_360_days(source, target, freq, align_on):\n    src = DataArray(date_range('2004-01-01', '2004-12-30', freq=freq, calendar=source), dims=('time',), name='time')\n    da_src = DataArray(np.linspace(0, 1, src.size), dims=('time',), coords={'time': src})\n    conv = convert_calendar(da_src, target, align_on=align_on)\n    assert conv.time.dt.calendar == target\n    if align_on == 'date':\n        np.testing.assert_array_equal(conv.time.resample(time='M').last().dt.day, [30, 29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30])\n    elif target == '360_day':\n        np.testing.assert_array_equal(conv.time.resample(time='M').last().dt.day, [30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 29])\n    else:\n        np.testing.assert_array_equal(conv.time.resample(time='M').last().dt.day, [30, 29, 30, 30, 31, 30, 30, 31, 30, 31, 29, 31])\n    if source == '360_day' and align_on == 'year':\n        assert conv.size == 360 if freq == 'D' else 360 * 4\n    else:\n        assert conv.size == 359 if freq == 'D' else 359 * 4",
        "mutated": [
            "@pytest.mark.parametrize('source,target,freq', [('standard', '360_day', 'D'), ('360_day', 'proleptic_gregorian', 'D'), ('proleptic_gregorian', '360_day', '4H')])\n@pytest.mark.parametrize('align_on', ['date', 'year'])\ndef test_convert_calendar_360_days(source, target, freq, align_on):\n    if False:\n        i = 10\n    src = DataArray(date_range('2004-01-01', '2004-12-30', freq=freq, calendar=source), dims=('time',), name='time')\n    da_src = DataArray(np.linspace(0, 1, src.size), dims=('time',), coords={'time': src})\n    conv = convert_calendar(da_src, target, align_on=align_on)\n    assert conv.time.dt.calendar == target\n    if align_on == 'date':\n        np.testing.assert_array_equal(conv.time.resample(time='M').last().dt.day, [30, 29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30])\n    elif target == '360_day':\n        np.testing.assert_array_equal(conv.time.resample(time='M').last().dt.day, [30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 29])\n    else:\n        np.testing.assert_array_equal(conv.time.resample(time='M').last().dt.day, [30, 29, 30, 30, 31, 30, 30, 31, 30, 31, 29, 31])\n    if source == '360_day' and align_on == 'year':\n        assert conv.size == 360 if freq == 'D' else 360 * 4\n    else:\n        assert conv.size == 359 if freq == 'D' else 359 * 4",
            "@pytest.mark.parametrize('source,target,freq', [('standard', '360_day', 'D'), ('360_day', 'proleptic_gregorian', 'D'), ('proleptic_gregorian', '360_day', '4H')])\n@pytest.mark.parametrize('align_on', ['date', 'year'])\ndef test_convert_calendar_360_days(source, target, freq, align_on):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    src = DataArray(date_range('2004-01-01', '2004-12-30', freq=freq, calendar=source), dims=('time',), name='time')\n    da_src = DataArray(np.linspace(0, 1, src.size), dims=('time',), coords={'time': src})\n    conv = convert_calendar(da_src, target, align_on=align_on)\n    assert conv.time.dt.calendar == target\n    if align_on == 'date':\n        np.testing.assert_array_equal(conv.time.resample(time='M').last().dt.day, [30, 29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30])\n    elif target == '360_day':\n        np.testing.assert_array_equal(conv.time.resample(time='M').last().dt.day, [30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 29])\n    else:\n        np.testing.assert_array_equal(conv.time.resample(time='M').last().dt.day, [30, 29, 30, 30, 31, 30, 30, 31, 30, 31, 29, 31])\n    if source == '360_day' and align_on == 'year':\n        assert conv.size == 360 if freq == 'D' else 360 * 4\n    else:\n        assert conv.size == 359 if freq == 'D' else 359 * 4",
            "@pytest.mark.parametrize('source,target,freq', [('standard', '360_day', 'D'), ('360_day', 'proleptic_gregorian', 'D'), ('proleptic_gregorian', '360_day', '4H')])\n@pytest.mark.parametrize('align_on', ['date', 'year'])\ndef test_convert_calendar_360_days(source, target, freq, align_on):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    src = DataArray(date_range('2004-01-01', '2004-12-30', freq=freq, calendar=source), dims=('time',), name='time')\n    da_src = DataArray(np.linspace(0, 1, src.size), dims=('time',), coords={'time': src})\n    conv = convert_calendar(da_src, target, align_on=align_on)\n    assert conv.time.dt.calendar == target\n    if align_on == 'date':\n        np.testing.assert_array_equal(conv.time.resample(time='M').last().dt.day, [30, 29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30])\n    elif target == '360_day':\n        np.testing.assert_array_equal(conv.time.resample(time='M').last().dt.day, [30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 29])\n    else:\n        np.testing.assert_array_equal(conv.time.resample(time='M').last().dt.day, [30, 29, 30, 30, 31, 30, 30, 31, 30, 31, 29, 31])\n    if source == '360_day' and align_on == 'year':\n        assert conv.size == 360 if freq == 'D' else 360 * 4\n    else:\n        assert conv.size == 359 if freq == 'D' else 359 * 4",
            "@pytest.mark.parametrize('source,target,freq', [('standard', '360_day', 'D'), ('360_day', 'proleptic_gregorian', 'D'), ('proleptic_gregorian', '360_day', '4H')])\n@pytest.mark.parametrize('align_on', ['date', 'year'])\ndef test_convert_calendar_360_days(source, target, freq, align_on):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    src = DataArray(date_range('2004-01-01', '2004-12-30', freq=freq, calendar=source), dims=('time',), name='time')\n    da_src = DataArray(np.linspace(0, 1, src.size), dims=('time',), coords={'time': src})\n    conv = convert_calendar(da_src, target, align_on=align_on)\n    assert conv.time.dt.calendar == target\n    if align_on == 'date':\n        np.testing.assert_array_equal(conv.time.resample(time='M').last().dt.day, [30, 29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30])\n    elif target == '360_day':\n        np.testing.assert_array_equal(conv.time.resample(time='M').last().dt.day, [30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 29])\n    else:\n        np.testing.assert_array_equal(conv.time.resample(time='M').last().dt.day, [30, 29, 30, 30, 31, 30, 30, 31, 30, 31, 29, 31])\n    if source == '360_day' and align_on == 'year':\n        assert conv.size == 360 if freq == 'D' else 360 * 4\n    else:\n        assert conv.size == 359 if freq == 'D' else 359 * 4",
            "@pytest.mark.parametrize('source,target,freq', [('standard', '360_day', 'D'), ('360_day', 'proleptic_gregorian', 'D'), ('proleptic_gregorian', '360_day', '4H')])\n@pytest.mark.parametrize('align_on', ['date', 'year'])\ndef test_convert_calendar_360_days(source, target, freq, align_on):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    src = DataArray(date_range('2004-01-01', '2004-12-30', freq=freq, calendar=source), dims=('time',), name='time')\n    da_src = DataArray(np.linspace(0, 1, src.size), dims=('time',), coords={'time': src})\n    conv = convert_calendar(da_src, target, align_on=align_on)\n    assert conv.time.dt.calendar == target\n    if align_on == 'date':\n        np.testing.assert_array_equal(conv.time.resample(time='M').last().dt.day, [30, 29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30])\n    elif target == '360_day':\n        np.testing.assert_array_equal(conv.time.resample(time='M').last().dt.day, [30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 29])\n    else:\n        np.testing.assert_array_equal(conv.time.resample(time='M').last().dt.day, [30, 29, 30, 30, 31, 30, 30, 31, 30, 31, 29, 31])\n    if source == '360_day' and align_on == 'year':\n        assert conv.size == 360 if freq == 'D' else 360 * 4\n    else:\n        assert conv.size == 359 if freq == 'D' else 359 * 4"
        ]
    },
    {
        "func_name": "test_convert_calendar_missing",
        "original": "@requires_cftime\n@pytest.mark.parametrize('source,target,freq', [('standard', 'noleap', 'D'), ('noleap', 'proleptic_gregorian', '4H'), ('noleap', 'all_leap', 'M'), ('360_day', 'noleap', 'D'), ('noleap', '360_day', 'D')])\ndef test_convert_calendar_missing(source, target, freq):\n    src = DataArray(date_range('2004-01-01', '2004-12-31' if source != '360_day' else '2004-12-30', freq=freq, calendar=source), dims=('time',), name='time')\n    da_src = DataArray(np.linspace(0, 1, src.size), dims=('time',), coords={'time': src})\n    out = convert_calendar(da_src, target, missing=np.nan, align_on='date')\n    assert infer_freq(out.time) == freq\n    expected = date_range('2004-01-01', '2004-12-31' if target != '360_day' else '2004-12-30', freq=freq, calendar=target)\n    np.testing.assert_array_equal(out.time, expected)\n    if freq != 'M':\n        out_without_missing = convert_calendar(da_src, target, align_on='date')\n        expected_nan = out.isel(time=~out.time.isin(out_without_missing.time))\n        assert expected_nan.isnull().all()\n        expected_not_nan = out.sel(time=out_without_missing.time)\n        assert_identical(expected_not_nan, out_without_missing)",
        "mutated": [
            "@requires_cftime\n@pytest.mark.parametrize('source,target,freq', [('standard', 'noleap', 'D'), ('noleap', 'proleptic_gregorian', '4H'), ('noleap', 'all_leap', 'M'), ('360_day', 'noleap', 'D'), ('noleap', '360_day', 'D')])\ndef test_convert_calendar_missing(source, target, freq):\n    if False:\n        i = 10\n    src = DataArray(date_range('2004-01-01', '2004-12-31' if source != '360_day' else '2004-12-30', freq=freq, calendar=source), dims=('time',), name='time')\n    da_src = DataArray(np.linspace(0, 1, src.size), dims=('time',), coords={'time': src})\n    out = convert_calendar(da_src, target, missing=np.nan, align_on='date')\n    assert infer_freq(out.time) == freq\n    expected = date_range('2004-01-01', '2004-12-31' if target != '360_day' else '2004-12-30', freq=freq, calendar=target)\n    np.testing.assert_array_equal(out.time, expected)\n    if freq != 'M':\n        out_without_missing = convert_calendar(da_src, target, align_on='date')\n        expected_nan = out.isel(time=~out.time.isin(out_without_missing.time))\n        assert expected_nan.isnull().all()\n        expected_not_nan = out.sel(time=out_without_missing.time)\n        assert_identical(expected_not_nan, out_without_missing)",
            "@requires_cftime\n@pytest.mark.parametrize('source,target,freq', [('standard', 'noleap', 'D'), ('noleap', 'proleptic_gregorian', '4H'), ('noleap', 'all_leap', 'M'), ('360_day', 'noleap', 'D'), ('noleap', '360_day', 'D')])\ndef test_convert_calendar_missing(source, target, freq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    src = DataArray(date_range('2004-01-01', '2004-12-31' if source != '360_day' else '2004-12-30', freq=freq, calendar=source), dims=('time',), name='time')\n    da_src = DataArray(np.linspace(0, 1, src.size), dims=('time',), coords={'time': src})\n    out = convert_calendar(da_src, target, missing=np.nan, align_on='date')\n    assert infer_freq(out.time) == freq\n    expected = date_range('2004-01-01', '2004-12-31' if target != '360_day' else '2004-12-30', freq=freq, calendar=target)\n    np.testing.assert_array_equal(out.time, expected)\n    if freq != 'M':\n        out_without_missing = convert_calendar(da_src, target, align_on='date')\n        expected_nan = out.isel(time=~out.time.isin(out_without_missing.time))\n        assert expected_nan.isnull().all()\n        expected_not_nan = out.sel(time=out_without_missing.time)\n        assert_identical(expected_not_nan, out_without_missing)",
            "@requires_cftime\n@pytest.mark.parametrize('source,target,freq', [('standard', 'noleap', 'D'), ('noleap', 'proleptic_gregorian', '4H'), ('noleap', 'all_leap', 'M'), ('360_day', 'noleap', 'D'), ('noleap', '360_day', 'D')])\ndef test_convert_calendar_missing(source, target, freq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    src = DataArray(date_range('2004-01-01', '2004-12-31' if source != '360_day' else '2004-12-30', freq=freq, calendar=source), dims=('time',), name='time')\n    da_src = DataArray(np.linspace(0, 1, src.size), dims=('time',), coords={'time': src})\n    out = convert_calendar(da_src, target, missing=np.nan, align_on='date')\n    assert infer_freq(out.time) == freq\n    expected = date_range('2004-01-01', '2004-12-31' if target != '360_day' else '2004-12-30', freq=freq, calendar=target)\n    np.testing.assert_array_equal(out.time, expected)\n    if freq != 'M':\n        out_without_missing = convert_calendar(da_src, target, align_on='date')\n        expected_nan = out.isel(time=~out.time.isin(out_without_missing.time))\n        assert expected_nan.isnull().all()\n        expected_not_nan = out.sel(time=out_without_missing.time)\n        assert_identical(expected_not_nan, out_without_missing)",
            "@requires_cftime\n@pytest.mark.parametrize('source,target,freq', [('standard', 'noleap', 'D'), ('noleap', 'proleptic_gregorian', '4H'), ('noleap', 'all_leap', 'M'), ('360_day', 'noleap', 'D'), ('noleap', '360_day', 'D')])\ndef test_convert_calendar_missing(source, target, freq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    src = DataArray(date_range('2004-01-01', '2004-12-31' if source != '360_day' else '2004-12-30', freq=freq, calendar=source), dims=('time',), name='time')\n    da_src = DataArray(np.linspace(0, 1, src.size), dims=('time',), coords={'time': src})\n    out = convert_calendar(da_src, target, missing=np.nan, align_on='date')\n    assert infer_freq(out.time) == freq\n    expected = date_range('2004-01-01', '2004-12-31' if target != '360_day' else '2004-12-30', freq=freq, calendar=target)\n    np.testing.assert_array_equal(out.time, expected)\n    if freq != 'M':\n        out_without_missing = convert_calendar(da_src, target, align_on='date')\n        expected_nan = out.isel(time=~out.time.isin(out_without_missing.time))\n        assert expected_nan.isnull().all()\n        expected_not_nan = out.sel(time=out_without_missing.time)\n        assert_identical(expected_not_nan, out_without_missing)",
            "@requires_cftime\n@pytest.mark.parametrize('source,target,freq', [('standard', 'noleap', 'D'), ('noleap', 'proleptic_gregorian', '4H'), ('noleap', 'all_leap', 'M'), ('360_day', 'noleap', 'D'), ('noleap', '360_day', 'D')])\ndef test_convert_calendar_missing(source, target, freq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    src = DataArray(date_range('2004-01-01', '2004-12-31' if source != '360_day' else '2004-12-30', freq=freq, calendar=source), dims=('time',), name='time')\n    da_src = DataArray(np.linspace(0, 1, src.size), dims=('time',), coords={'time': src})\n    out = convert_calendar(da_src, target, missing=np.nan, align_on='date')\n    assert infer_freq(out.time) == freq\n    expected = date_range('2004-01-01', '2004-12-31' if target != '360_day' else '2004-12-30', freq=freq, calendar=target)\n    np.testing.assert_array_equal(out.time, expected)\n    if freq != 'M':\n        out_without_missing = convert_calendar(da_src, target, align_on='date')\n        expected_nan = out.isel(time=~out.time.isin(out_without_missing.time))\n        assert expected_nan.isnull().all()\n        expected_not_nan = out.sel(time=out_without_missing.time)\n        assert_identical(expected_not_nan, out_without_missing)"
        ]
    },
    {
        "func_name": "test_convert_calendar_errors",
        "original": "@requires_cftime\ndef test_convert_calendar_errors():\n    src_nl = DataArray(date_range('0000-01-01', '0000-12-31', freq='D', calendar='noleap'), dims=('time',), name='time')\n    with pytest.raises(ValueError, match='Argument `align_on` must be specified'):\n        convert_calendar(src_nl, '360_day')\n    with pytest.raises(ValueError, match='Source time coordinate contains dates with year 0'):\n        convert_calendar(src_nl, 'standard')\n    src_360 = convert_calendar(src_nl, '360_day', align_on='year')\n    with pytest.raises(ValueError, match='Argument `align_on` must be specified'):\n        convert_calendar(src_360, 'noleap')\n    da = DataArray([0, 1, 2], dims=('x',), name='x')\n    with pytest.raises(ValueError, match='Coordinate x must contain datetime objects.'):\n        convert_calendar(da, 'standard', dim='x')",
        "mutated": [
            "@requires_cftime\ndef test_convert_calendar_errors():\n    if False:\n        i = 10\n    src_nl = DataArray(date_range('0000-01-01', '0000-12-31', freq='D', calendar='noleap'), dims=('time',), name='time')\n    with pytest.raises(ValueError, match='Argument `align_on` must be specified'):\n        convert_calendar(src_nl, '360_day')\n    with pytest.raises(ValueError, match='Source time coordinate contains dates with year 0'):\n        convert_calendar(src_nl, 'standard')\n    src_360 = convert_calendar(src_nl, '360_day', align_on='year')\n    with pytest.raises(ValueError, match='Argument `align_on` must be specified'):\n        convert_calendar(src_360, 'noleap')\n    da = DataArray([0, 1, 2], dims=('x',), name='x')\n    with pytest.raises(ValueError, match='Coordinate x must contain datetime objects.'):\n        convert_calendar(da, 'standard', dim='x')",
            "@requires_cftime\ndef test_convert_calendar_errors():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    src_nl = DataArray(date_range('0000-01-01', '0000-12-31', freq='D', calendar='noleap'), dims=('time',), name='time')\n    with pytest.raises(ValueError, match='Argument `align_on` must be specified'):\n        convert_calendar(src_nl, '360_day')\n    with pytest.raises(ValueError, match='Source time coordinate contains dates with year 0'):\n        convert_calendar(src_nl, 'standard')\n    src_360 = convert_calendar(src_nl, '360_day', align_on='year')\n    with pytest.raises(ValueError, match='Argument `align_on` must be specified'):\n        convert_calendar(src_360, 'noleap')\n    da = DataArray([0, 1, 2], dims=('x',), name='x')\n    with pytest.raises(ValueError, match='Coordinate x must contain datetime objects.'):\n        convert_calendar(da, 'standard', dim='x')",
            "@requires_cftime\ndef test_convert_calendar_errors():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    src_nl = DataArray(date_range('0000-01-01', '0000-12-31', freq='D', calendar='noleap'), dims=('time',), name='time')\n    with pytest.raises(ValueError, match='Argument `align_on` must be specified'):\n        convert_calendar(src_nl, '360_day')\n    with pytest.raises(ValueError, match='Source time coordinate contains dates with year 0'):\n        convert_calendar(src_nl, 'standard')\n    src_360 = convert_calendar(src_nl, '360_day', align_on='year')\n    with pytest.raises(ValueError, match='Argument `align_on` must be specified'):\n        convert_calendar(src_360, 'noleap')\n    da = DataArray([0, 1, 2], dims=('x',), name='x')\n    with pytest.raises(ValueError, match='Coordinate x must contain datetime objects.'):\n        convert_calendar(da, 'standard', dim='x')",
            "@requires_cftime\ndef test_convert_calendar_errors():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    src_nl = DataArray(date_range('0000-01-01', '0000-12-31', freq='D', calendar='noleap'), dims=('time',), name='time')\n    with pytest.raises(ValueError, match='Argument `align_on` must be specified'):\n        convert_calendar(src_nl, '360_day')\n    with pytest.raises(ValueError, match='Source time coordinate contains dates with year 0'):\n        convert_calendar(src_nl, 'standard')\n    src_360 = convert_calendar(src_nl, '360_day', align_on='year')\n    with pytest.raises(ValueError, match='Argument `align_on` must be specified'):\n        convert_calendar(src_360, 'noleap')\n    da = DataArray([0, 1, 2], dims=('x',), name='x')\n    with pytest.raises(ValueError, match='Coordinate x must contain datetime objects.'):\n        convert_calendar(da, 'standard', dim='x')",
            "@requires_cftime\ndef test_convert_calendar_errors():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    src_nl = DataArray(date_range('0000-01-01', '0000-12-31', freq='D', calendar='noleap'), dims=('time',), name='time')\n    with pytest.raises(ValueError, match='Argument `align_on` must be specified'):\n        convert_calendar(src_nl, '360_day')\n    with pytest.raises(ValueError, match='Source time coordinate contains dates with year 0'):\n        convert_calendar(src_nl, 'standard')\n    src_360 = convert_calendar(src_nl, '360_day', align_on='year')\n    with pytest.raises(ValueError, match='Argument `align_on` must be specified'):\n        convert_calendar(src_360, 'noleap')\n    da = DataArray([0, 1, 2], dims=('x',), name='x')\n    with pytest.raises(ValueError, match='Coordinate x must contain datetime objects.'):\n        convert_calendar(da, 'standard', dim='x')"
        ]
    },
    {
        "func_name": "test_convert_calendar_same_calendar",
        "original": "def test_convert_calendar_same_calendar():\n    src = DataArray(date_range('2000-01-01', periods=12, freq='6H', use_cftime=False), dims=('time',), name='time')\n    out = convert_calendar(src, 'proleptic_gregorian')\n    assert src is out",
        "mutated": [
            "def test_convert_calendar_same_calendar():\n    if False:\n        i = 10\n    src = DataArray(date_range('2000-01-01', periods=12, freq='6H', use_cftime=False), dims=('time',), name='time')\n    out = convert_calendar(src, 'proleptic_gregorian')\n    assert src is out",
            "def test_convert_calendar_same_calendar():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    src = DataArray(date_range('2000-01-01', periods=12, freq='6H', use_cftime=False), dims=('time',), name='time')\n    out = convert_calendar(src, 'proleptic_gregorian')\n    assert src is out",
            "def test_convert_calendar_same_calendar():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    src = DataArray(date_range('2000-01-01', periods=12, freq='6H', use_cftime=False), dims=('time',), name='time')\n    out = convert_calendar(src, 'proleptic_gregorian')\n    assert src is out",
            "def test_convert_calendar_same_calendar():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    src = DataArray(date_range('2000-01-01', periods=12, freq='6H', use_cftime=False), dims=('time',), name='time')\n    out = convert_calendar(src, 'proleptic_gregorian')\n    assert src is out",
            "def test_convert_calendar_same_calendar():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    src = DataArray(date_range('2000-01-01', periods=12, freq='6H', use_cftime=False), dims=('time',), name='time')\n    out = convert_calendar(src, 'proleptic_gregorian')\n    assert src is out"
        ]
    },
    {
        "func_name": "test_interp_calendar",
        "original": "@pytest.mark.parametrize('source,target', [('standard', 'noleap'), ('noleap', 'proleptic_gregorian'), ('standard', '360_day'), ('360_day', 'proleptic_gregorian'), ('noleap', 'all_leap'), ('360_day', 'noleap')])\ndef test_interp_calendar(source, target):\n    src = DataArray(date_range('2004-01-01', '2004-07-30', freq='D', calendar=source), dims=('time',), name='time')\n    tgt = DataArray(date_range('2004-01-01', '2004-07-30', freq='D', calendar=target), dims=('time',), name='time')\n    da_src = DataArray(np.linspace(0, 1, src.size), dims=('time',), coords={'time': src})\n    conv = interp_calendar(da_src, tgt)\n    assert_identical(tgt.time, conv.time)\n    np.testing.assert_almost_equal(conv.max(), 1, 2)\n    assert conv.min() == 0",
        "mutated": [
            "@pytest.mark.parametrize('source,target', [('standard', 'noleap'), ('noleap', 'proleptic_gregorian'), ('standard', '360_day'), ('360_day', 'proleptic_gregorian'), ('noleap', 'all_leap'), ('360_day', 'noleap')])\ndef test_interp_calendar(source, target):\n    if False:\n        i = 10\n    src = DataArray(date_range('2004-01-01', '2004-07-30', freq='D', calendar=source), dims=('time',), name='time')\n    tgt = DataArray(date_range('2004-01-01', '2004-07-30', freq='D', calendar=target), dims=('time',), name='time')\n    da_src = DataArray(np.linspace(0, 1, src.size), dims=('time',), coords={'time': src})\n    conv = interp_calendar(da_src, tgt)\n    assert_identical(tgt.time, conv.time)\n    np.testing.assert_almost_equal(conv.max(), 1, 2)\n    assert conv.min() == 0",
            "@pytest.mark.parametrize('source,target', [('standard', 'noleap'), ('noleap', 'proleptic_gregorian'), ('standard', '360_day'), ('360_day', 'proleptic_gregorian'), ('noleap', 'all_leap'), ('360_day', 'noleap')])\ndef test_interp_calendar(source, target):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    src = DataArray(date_range('2004-01-01', '2004-07-30', freq='D', calendar=source), dims=('time',), name='time')\n    tgt = DataArray(date_range('2004-01-01', '2004-07-30', freq='D', calendar=target), dims=('time',), name='time')\n    da_src = DataArray(np.linspace(0, 1, src.size), dims=('time',), coords={'time': src})\n    conv = interp_calendar(da_src, tgt)\n    assert_identical(tgt.time, conv.time)\n    np.testing.assert_almost_equal(conv.max(), 1, 2)\n    assert conv.min() == 0",
            "@pytest.mark.parametrize('source,target', [('standard', 'noleap'), ('noleap', 'proleptic_gregorian'), ('standard', '360_day'), ('360_day', 'proleptic_gregorian'), ('noleap', 'all_leap'), ('360_day', 'noleap')])\ndef test_interp_calendar(source, target):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    src = DataArray(date_range('2004-01-01', '2004-07-30', freq='D', calendar=source), dims=('time',), name='time')\n    tgt = DataArray(date_range('2004-01-01', '2004-07-30', freq='D', calendar=target), dims=('time',), name='time')\n    da_src = DataArray(np.linspace(0, 1, src.size), dims=('time',), coords={'time': src})\n    conv = interp_calendar(da_src, tgt)\n    assert_identical(tgt.time, conv.time)\n    np.testing.assert_almost_equal(conv.max(), 1, 2)\n    assert conv.min() == 0",
            "@pytest.mark.parametrize('source,target', [('standard', 'noleap'), ('noleap', 'proleptic_gregorian'), ('standard', '360_day'), ('360_day', 'proleptic_gregorian'), ('noleap', 'all_leap'), ('360_day', 'noleap')])\ndef test_interp_calendar(source, target):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    src = DataArray(date_range('2004-01-01', '2004-07-30', freq='D', calendar=source), dims=('time',), name='time')\n    tgt = DataArray(date_range('2004-01-01', '2004-07-30', freq='D', calendar=target), dims=('time',), name='time')\n    da_src = DataArray(np.linspace(0, 1, src.size), dims=('time',), coords={'time': src})\n    conv = interp_calendar(da_src, tgt)\n    assert_identical(tgt.time, conv.time)\n    np.testing.assert_almost_equal(conv.max(), 1, 2)\n    assert conv.min() == 0",
            "@pytest.mark.parametrize('source,target', [('standard', 'noleap'), ('noleap', 'proleptic_gregorian'), ('standard', '360_day'), ('360_day', 'proleptic_gregorian'), ('noleap', 'all_leap'), ('360_day', 'noleap')])\ndef test_interp_calendar(source, target):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    src = DataArray(date_range('2004-01-01', '2004-07-30', freq='D', calendar=source), dims=('time',), name='time')\n    tgt = DataArray(date_range('2004-01-01', '2004-07-30', freq='D', calendar=target), dims=('time',), name='time')\n    da_src = DataArray(np.linspace(0, 1, src.size), dims=('time',), coords={'time': src})\n    conv = interp_calendar(da_src, tgt)\n    assert_identical(tgt.time, conv.time)\n    np.testing.assert_almost_equal(conv.max(), 1, 2)\n    assert conv.min() == 0"
        ]
    },
    {
        "func_name": "test_interp_calendar_errors",
        "original": "@requires_cftime\ndef test_interp_calendar_errors():\n    src_nl = DataArray([1] * 100, dims=('time',), coords={'time': date_range('0000-01-01', periods=100, freq='MS', calendar='noleap')})\n    tgt_360 = date_range('0001-01-01', '0001-12-30', freq='MS', calendar='standard')\n    with pytest.raises(ValueError, match='Source time coordinate contains dates with year 0'):\n        interp_calendar(src_nl, tgt_360)\n    da1 = DataArray([0, 1, 2], dims=('x',), name='x')\n    da2 = da1 + 1\n    with pytest.raises(ValueError, match=\"Both 'source.x' and 'target' must contain datetime objects.\"):\n        interp_calendar(da1, da2, dim='x')",
        "mutated": [
            "@requires_cftime\ndef test_interp_calendar_errors():\n    if False:\n        i = 10\n    src_nl = DataArray([1] * 100, dims=('time',), coords={'time': date_range('0000-01-01', periods=100, freq='MS', calendar='noleap')})\n    tgt_360 = date_range('0001-01-01', '0001-12-30', freq='MS', calendar='standard')\n    with pytest.raises(ValueError, match='Source time coordinate contains dates with year 0'):\n        interp_calendar(src_nl, tgt_360)\n    da1 = DataArray([0, 1, 2], dims=('x',), name='x')\n    da2 = da1 + 1\n    with pytest.raises(ValueError, match=\"Both 'source.x' and 'target' must contain datetime objects.\"):\n        interp_calendar(da1, da2, dim='x')",
            "@requires_cftime\ndef test_interp_calendar_errors():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    src_nl = DataArray([1] * 100, dims=('time',), coords={'time': date_range('0000-01-01', periods=100, freq='MS', calendar='noleap')})\n    tgt_360 = date_range('0001-01-01', '0001-12-30', freq='MS', calendar='standard')\n    with pytest.raises(ValueError, match='Source time coordinate contains dates with year 0'):\n        interp_calendar(src_nl, tgt_360)\n    da1 = DataArray([0, 1, 2], dims=('x',), name='x')\n    da2 = da1 + 1\n    with pytest.raises(ValueError, match=\"Both 'source.x' and 'target' must contain datetime objects.\"):\n        interp_calendar(da1, da2, dim='x')",
            "@requires_cftime\ndef test_interp_calendar_errors():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    src_nl = DataArray([1] * 100, dims=('time',), coords={'time': date_range('0000-01-01', periods=100, freq='MS', calendar='noleap')})\n    tgt_360 = date_range('0001-01-01', '0001-12-30', freq='MS', calendar='standard')\n    with pytest.raises(ValueError, match='Source time coordinate contains dates with year 0'):\n        interp_calendar(src_nl, tgt_360)\n    da1 = DataArray([0, 1, 2], dims=('x',), name='x')\n    da2 = da1 + 1\n    with pytest.raises(ValueError, match=\"Both 'source.x' and 'target' must contain datetime objects.\"):\n        interp_calendar(da1, da2, dim='x')",
            "@requires_cftime\ndef test_interp_calendar_errors():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    src_nl = DataArray([1] * 100, dims=('time',), coords={'time': date_range('0000-01-01', periods=100, freq='MS', calendar='noleap')})\n    tgt_360 = date_range('0001-01-01', '0001-12-30', freq='MS', calendar='standard')\n    with pytest.raises(ValueError, match='Source time coordinate contains dates with year 0'):\n        interp_calendar(src_nl, tgt_360)\n    da1 = DataArray([0, 1, 2], dims=('x',), name='x')\n    da2 = da1 + 1\n    with pytest.raises(ValueError, match=\"Both 'source.x' and 'target' must contain datetime objects.\"):\n        interp_calendar(da1, da2, dim='x')",
            "@requires_cftime\ndef test_interp_calendar_errors():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    src_nl = DataArray([1] * 100, dims=('time',), coords={'time': date_range('0000-01-01', periods=100, freq='MS', calendar='noleap')})\n    tgt_360 = date_range('0001-01-01', '0001-12-30', freq='MS', calendar='standard')\n    with pytest.raises(ValueError, match='Source time coordinate contains dates with year 0'):\n        interp_calendar(src_nl, tgt_360)\n    da1 = DataArray([0, 1, 2], dims=('x',), name='x')\n    da2 = da1 + 1\n    with pytest.raises(ValueError, match=\"Both 'source.x' and 'target' must contain datetime objects.\"):\n        interp_calendar(da1, da2, dim='x')"
        ]
    }
]