[
    {
        "func_name": "__getattr__",
        "original": "def __getattr__(self, attrname: str):\n    \"\"\"\n            This function is required for ``get_attribute_hook`` in mypy plugin.\n\n            It is never called in real-life, because ``KindN`` is abstract.\n            It only exists during the type-checking phase.\n            \"\"\"",
        "mutated": [
            "def __getattr__(self, attrname: str):\n    if False:\n        i = 10\n    '\\n            This function is required for ``get_attribute_hook`` in mypy plugin.\\n\\n            It is never called in real-life, because ``KindN`` is abstract.\\n            It only exists during the type-checking phase.\\n            '",
            "def __getattr__(self, attrname: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n            This function is required for ``get_attribute_hook`` in mypy plugin.\\n\\n            It is never called in real-life, because ``KindN`` is abstract.\\n            It only exists during the type-checking phase.\\n            '",
            "def __getattr__(self, attrname: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n            This function is required for ``get_attribute_hook`` in mypy plugin.\\n\\n            It is never called in real-life, because ``KindN`` is abstract.\\n            It only exists during the type-checking phase.\\n            '",
            "def __getattr__(self, attrname: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n            This function is required for ``get_attribute_hook`` in mypy plugin.\\n\\n            It is never called in real-life, because ``KindN`` is abstract.\\n            It only exists during the type-checking phase.\\n            '",
            "def __getattr__(self, attrname: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n            This function is required for ``get_attribute_hook`` in mypy plugin.\\n\\n            It is never called in real-life, because ``KindN`` is abstract.\\n            It only exists during the type-checking phase.\\n            '"
        ]
    },
    {
        "func_name": "dekind",
        "original": "def dekind(kind: KindN[_InstanceType, _TypeArgType1, _TypeArgType2, _TypeArgType3]) -> _InstanceType:\n    \"\"\"\n    Turns ``Kind1[IO, int]`` type into real ``IO[int]`` type.\n\n    Should be used when you are left with accidental ``KindN`` instance\n    when you really want to have the real type.\n\n    Works with type arguments of any length.\n\n    We use a custom ``mypy`` plugin to make sure types are correct.\n    Otherwise, it is currently impossible to properly type this.\n\n    In runtime it just returns the passed argument, nothing really happens:\n\n    .. code:: python\n\n      >>> from returns.io import IO\n      >>> from returns.primitives.hkt import Kind1\n\n      >>> container: Kind1[IO, int] = IO(1)\n      >>> assert dekind(container) is container\n\n    However, please, do not use this function\n    unless you know exactly what you are doing and why do you need it.\n    \"\"\"\n    return kind",
        "mutated": [
            "def dekind(kind: KindN[_InstanceType, _TypeArgType1, _TypeArgType2, _TypeArgType3]) -> _InstanceType:\n    if False:\n        i = 10\n    '\\n    Turns ``Kind1[IO, int]`` type into real ``IO[int]`` type.\\n\\n    Should be used when you are left with accidental ``KindN`` instance\\n    when you really want to have the real type.\\n\\n    Works with type arguments of any length.\\n\\n    We use a custom ``mypy`` plugin to make sure types are correct.\\n    Otherwise, it is currently impossible to properly type this.\\n\\n    In runtime it just returns the passed argument, nothing really happens:\\n\\n    .. code:: python\\n\\n      >>> from returns.io import IO\\n      >>> from returns.primitives.hkt import Kind1\\n\\n      >>> container: Kind1[IO, int] = IO(1)\\n      >>> assert dekind(container) is container\\n\\n    However, please, do not use this function\\n    unless you know exactly what you are doing and why do you need it.\\n    '\n    return kind",
            "def dekind(kind: KindN[_InstanceType, _TypeArgType1, _TypeArgType2, _TypeArgType3]) -> _InstanceType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Turns ``Kind1[IO, int]`` type into real ``IO[int]`` type.\\n\\n    Should be used when you are left with accidental ``KindN`` instance\\n    when you really want to have the real type.\\n\\n    Works with type arguments of any length.\\n\\n    We use a custom ``mypy`` plugin to make sure types are correct.\\n    Otherwise, it is currently impossible to properly type this.\\n\\n    In runtime it just returns the passed argument, nothing really happens:\\n\\n    .. code:: python\\n\\n      >>> from returns.io import IO\\n      >>> from returns.primitives.hkt import Kind1\\n\\n      >>> container: Kind1[IO, int] = IO(1)\\n      >>> assert dekind(container) is container\\n\\n    However, please, do not use this function\\n    unless you know exactly what you are doing and why do you need it.\\n    '\n    return kind",
            "def dekind(kind: KindN[_InstanceType, _TypeArgType1, _TypeArgType2, _TypeArgType3]) -> _InstanceType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Turns ``Kind1[IO, int]`` type into real ``IO[int]`` type.\\n\\n    Should be used when you are left with accidental ``KindN`` instance\\n    when you really want to have the real type.\\n\\n    Works with type arguments of any length.\\n\\n    We use a custom ``mypy`` plugin to make sure types are correct.\\n    Otherwise, it is currently impossible to properly type this.\\n\\n    In runtime it just returns the passed argument, nothing really happens:\\n\\n    .. code:: python\\n\\n      >>> from returns.io import IO\\n      >>> from returns.primitives.hkt import Kind1\\n\\n      >>> container: Kind1[IO, int] = IO(1)\\n      >>> assert dekind(container) is container\\n\\n    However, please, do not use this function\\n    unless you know exactly what you are doing and why do you need it.\\n    '\n    return kind",
            "def dekind(kind: KindN[_InstanceType, _TypeArgType1, _TypeArgType2, _TypeArgType3]) -> _InstanceType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Turns ``Kind1[IO, int]`` type into real ``IO[int]`` type.\\n\\n    Should be used when you are left with accidental ``KindN`` instance\\n    when you really want to have the real type.\\n\\n    Works with type arguments of any length.\\n\\n    We use a custom ``mypy`` plugin to make sure types are correct.\\n    Otherwise, it is currently impossible to properly type this.\\n\\n    In runtime it just returns the passed argument, nothing really happens:\\n\\n    .. code:: python\\n\\n      >>> from returns.io import IO\\n      >>> from returns.primitives.hkt import Kind1\\n\\n      >>> container: Kind1[IO, int] = IO(1)\\n      >>> assert dekind(container) is container\\n\\n    However, please, do not use this function\\n    unless you know exactly what you are doing and why do you need it.\\n    '\n    return kind",
            "def dekind(kind: KindN[_InstanceType, _TypeArgType1, _TypeArgType2, _TypeArgType3]) -> _InstanceType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Turns ``Kind1[IO, int]`` type into real ``IO[int]`` type.\\n\\n    Should be used when you are left with accidental ``KindN`` instance\\n    when you really want to have the real type.\\n\\n    Works with type arguments of any length.\\n\\n    We use a custom ``mypy`` plugin to make sure types are correct.\\n    Otherwise, it is currently impossible to properly type this.\\n\\n    In runtime it just returns the passed argument, nothing really happens:\\n\\n    .. code:: python\\n\\n      >>> from returns.io import IO\\n      >>> from returns.primitives.hkt import Kind1\\n\\n      >>> container: Kind1[IO, int] = IO(1)\\n      >>> assert dekind(container) is container\\n\\n    However, please, do not use this function\\n    unless you know exactly what you are doing and why do you need it.\\n    '\n    return kind"
        ]
    },
    {
        "func_name": "__get__",
        "original": "def __get__(self, instance: _UpdatedType, type_) -> Callable[..., _UpdatedType]:\n    \"\"\"Used to decorate and properly analyze method calls.\"\"\"",
        "mutated": [
            "def __get__(self, instance: _UpdatedType, type_) -> Callable[..., _UpdatedType]:\n    if False:\n        i = 10\n    'Used to decorate and properly analyze method calls.'",
            "def __get__(self, instance: _UpdatedType, type_) -> Callable[..., _UpdatedType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Used to decorate and properly analyze method calls.'",
            "def __get__(self, instance: _UpdatedType, type_) -> Callable[..., _UpdatedType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Used to decorate and properly analyze method calls.'",
            "def __get__(self, instance: _UpdatedType, type_) -> Callable[..., _UpdatedType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Used to decorate and properly analyze method calls.'",
            "def __get__(self, instance: _UpdatedType, type_) -> Callable[..., _UpdatedType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Used to decorate and properly analyze method calls.'"
        ]
    },
    {
        "func_name": "kinded",
        "original": "def kinded(function: _FunctionType) -> Kinded[_FunctionType]:\n    \"\"\"\n    Decorator to be used when you want to dekind the function's return type.\n\n    Does nothing in runtime, just returns its argument.\n\n    We use a custom ``mypy`` plugin to make sure types are correct.\n    Otherwise, it is currently impossible to properly type this.\n\n    Here's an example of how it should be used:\n\n    .. code:: python\n\n      >>> from typing import TypeVar\n      >>> from returns.primitives.hkt import KindN, kinded\n      >>> from returns.interfaces.bindable import BindableN\n\n      >>> _Binds = TypeVar('_Binds', bound=BindableN)  # just an example\n      >>> _Type1 = TypeVar('_Type1')\n      >>> _Type2 = TypeVar('_Type2')\n      >>> _Type3 = TypeVar('_Type3')\n\n      >>> @kinded\n      ... def bindable_identity(\n      ...    container: KindN[_Binds, _Type1, _Type2, _Type3],\n      ... ) -> KindN[_Binds, _Type1, _Type2, _Type3]:\n      ...     return container  # just do nothing\n\n    As you can see, here we annotate our return type as\n    ``-> KindN[_Binds, _Type1, _Type2, _Type3]``,\n    it would be true without ``@kinded`` decorator.\n\n    But, ``@kinded`` decorator dekinds the return type and infers\n    the real type behind it:\n\n    .. code:: python\n\n      >>> from returns.io import IO, IOResult\n\n      >>> assert bindable_identity(IO(1)) == IO(1)\n      >>> # => Revealed type: 'IO[int]'\n\n      >>> iores: IOResult[int, str] = IOResult.from_value(1)\n      >>> assert bindable_identity(iores) == iores\n      >>> # => Revealed type: 'IOResult[int, str]'\n\n    The difference is very clear in ``methods`` modules, like:\n\n    - Raw :func:`returns.methods.bind.internal_bind`\n      that returns ``KindN`` instance\n    - User-facing :func:`returns.methods.bind.bind`\n      that returns the container type\n\n    You must use this decorator for your own kinded functions as well.\n    \"\"\"\n    return function",
        "mutated": [
            "def kinded(function: _FunctionType) -> Kinded[_FunctionType]:\n    if False:\n        i = 10\n    \"\\n    Decorator to be used when you want to dekind the function's return type.\\n\\n    Does nothing in runtime, just returns its argument.\\n\\n    We use a custom ``mypy`` plugin to make sure types are correct.\\n    Otherwise, it is currently impossible to properly type this.\\n\\n    Here's an example of how it should be used:\\n\\n    .. code:: python\\n\\n      >>> from typing import TypeVar\\n      >>> from returns.primitives.hkt import KindN, kinded\\n      >>> from returns.interfaces.bindable import BindableN\\n\\n      >>> _Binds = TypeVar('_Binds', bound=BindableN)  # just an example\\n      >>> _Type1 = TypeVar('_Type1')\\n      >>> _Type2 = TypeVar('_Type2')\\n      >>> _Type3 = TypeVar('_Type3')\\n\\n      >>> @kinded\\n      ... def bindable_identity(\\n      ...    container: KindN[_Binds, _Type1, _Type2, _Type3],\\n      ... ) -> KindN[_Binds, _Type1, _Type2, _Type3]:\\n      ...     return container  # just do nothing\\n\\n    As you can see, here we annotate our return type as\\n    ``-> KindN[_Binds, _Type1, _Type2, _Type3]``,\\n    it would be true without ``@kinded`` decorator.\\n\\n    But, ``@kinded`` decorator dekinds the return type and infers\\n    the real type behind it:\\n\\n    .. code:: python\\n\\n      >>> from returns.io import IO, IOResult\\n\\n      >>> assert bindable_identity(IO(1)) == IO(1)\\n      >>> # => Revealed type: 'IO[int]'\\n\\n      >>> iores: IOResult[int, str] = IOResult.from_value(1)\\n      >>> assert bindable_identity(iores) == iores\\n      >>> # => Revealed type: 'IOResult[int, str]'\\n\\n    The difference is very clear in ``methods`` modules, like:\\n\\n    - Raw :func:`returns.methods.bind.internal_bind`\\n      that returns ``KindN`` instance\\n    - User-facing :func:`returns.methods.bind.bind`\\n      that returns the container type\\n\\n    You must use this decorator for your own kinded functions as well.\\n    \"\n    return function",
            "def kinded(function: _FunctionType) -> Kinded[_FunctionType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Decorator to be used when you want to dekind the function's return type.\\n\\n    Does nothing in runtime, just returns its argument.\\n\\n    We use a custom ``mypy`` plugin to make sure types are correct.\\n    Otherwise, it is currently impossible to properly type this.\\n\\n    Here's an example of how it should be used:\\n\\n    .. code:: python\\n\\n      >>> from typing import TypeVar\\n      >>> from returns.primitives.hkt import KindN, kinded\\n      >>> from returns.interfaces.bindable import BindableN\\n\\n      >>> _Binds = TypeVar('_Binds', bound=BindableN)  # just an example\\n      >>> _Type1 = TypeVar('_Type1')\\n      >>> _Type2 = TypeVar('_Type2')\\n      >>> _Type3 = TypeVar('_Type3')\\n\\n      >>> @kinded\\n      ... def bindable_identity(\\n      ...    container: KindN[_Binds, _Type1, _Type2, _Type3],\\n      ... ) -> KindN[_Binds, _Type1, _Type2, _Type3]:\\n      ...     return container  # just do nothing\\n\\n    As you can see, here we annotate our return type as\\n    ``-> KindN[_Binds, _Type1, _Type2, _Type3]``,\\n    it would be true without ``@kinded`` decorator.\\n\\n    But, ``@kinded`` decorator dekinds the return type and infers\\n    the real type behind it:\\n\\n    .. code:: python\\n\\n      >>> from returns.io import IO, IOResult\\n\\n      >>> assert bindable_identity(IO(1)) == IO(1)\\n      >>> # => Revealed type: 'IO[int]'\\n\\n      >>> iores: IOResult[int, str] = IOResult.from_value(1)\\n      >>> assert bindable_identity(iores) == iores\\n      >>> # => Revealed type: 'IOResult[int, str]'\\n\\n    The difference is very clear in ``methods`` modules, like:\\n\\n    - Raw :func:`returns.methods.bind.internal_bind`\\n      that returns ``KindN`` instance\\n    - User-facing :func:`returns.methods.bind.bind`\\n      that returns the container type\\n\\n    You must use this decorator for your own kinded functions as well.\\n    \"\n    return function",
            "def kinded(function: _FunctionType) -> Kinded[_FunctionType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Decorator to be used when you want to dekind the function's return type.\\n\\n    Does nothing in runtime, just returns its argument.\\n\\n    We use a custom ``mypy`` plugin to make sure types are correct.\\n    Otherwise, it is currently impossible to properly type this.\\n\\n    Here's an example of how it should be used:\\n\\n    .. code:: python\\n\\n      >>> from typing import TypeVar\\n      >>> from returns.primitives.hkt import KindN, kinded\\n      >>> from returns.interfaces.bindable import BindableN\\n\\n      >>> _Binds = TypeVar('_Binds', bound=BindableN)  # just an example\\n      >>> _Type1 = TypeVar('_Type1')\\n      >>> _Type2 = TypeVar('_Type2')\\n      >>> _Type3 = TypeVar('_Type3')\\n\\n      >>> @kinded\\n      ... def bindable_identity(\\n      ...    container: KindN[_Binds, _Type1, _Type2, _Type3],\\n      ... ) -> KindN[_Binds, _Type1, _Type2, _Type3]:\\n      ...     return container  # just do nothing\\n\\n    As you can see, here we annotate our return type as\\n    ``-> KindN[_Binds, _Type1, _Type2, _Type3]``,\\n    it would be true without ``@kinded`` decorator.\\n\\n    But, ``@kinded`` decorator dekinds the return type and infers\\n    the real type behind it:\\n\\n    .. code:: python\\n\\n      >>> from returns.io import IO, IOResult\\n\\n      >>> assert bindable_identity(IO(1)) == IO(1)\\n      >>> # => Revealed type: 'IO[int]'\\n\\n      >>> iores: IOResult[int, str] = IOResult.from_value(1)\\n      >>> assert bindable_identity(iores) == iores\\n      >>> # => Revealed type: 'IOResult[int, str]'\\n\\n    The difference is very clear in ``methods`` modules, like:\\n\\n    - Raw :func:`returns.methods.bind.internal_bind`\\n      that returns ``KindN`` instance\\n    - User-facing :func:`returns.methods.bind.bind`\\n      that returns the container type\\n\\n    You must use this decorator for your own kinded functions as well.\\n    \"\n    return function",
            "def kinded(function: _FunctionType) -> Kinded[_FunctionType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Decorator to be used when you want to dekind the function's return type.\\n\\n    Does nothing in runtime, just returns its argument.\\n\\n    We use a custom ``mypy`` plugin to make sure types are correct.\\n    Otherwise, it is currently impossible to properly type this.\\n\\n    Here's an example of how it should be used:\\n\\n    .. code:: python\\n\\n      >>> from typing import TypeVar\\n      >>> from returns.primitives.hkt import KindN, kinded\\n      >>> from returns.interfaces.bindable import BindableN\\n\\n      >>> _Binds = TypeVar('_Binds', bound=BindableN)  # just an example\\n      >>> _Type1 = TypeVar('_Type1')\\n      >>> _Type2 = TypeVar('_Type2')\\n      >>> _Type3 = TypeVar('_Type3')\\n\\n      >>> @kinded\\n      ... def bindable_identity(\\n      ...    container: KindN[_Binds, _Type1, _Type2, _Type3],\\n      ... ) -> KindN[_Binds, _Type1, _Type2, _Type3]:\\n      ...     return container  # just do nothing\\n\\n    As you can see, here we annotate our return type as\\n    ``-> KindN[_Binds, _Type1, _Type2, _Type3]``,\\n    it would be true without ``@kinded`` decorator.\\n\\n    But, ``@kinded`` decorator dekinds the return type and infers\\n    the real type behind it:\\n\\n    .. code:: python\\n\\n      >>> from returns.io import IO, IOResult\\n\\n      >>> assert bindable_identity(IO(1)) == IO(1)\\n      >>> # => Revealed type: 'IO[int]'\\n\\n      >>> iores: IOResult[int, str] = IOResult.from_value(1)\\n      >>> assert bindable_identity(iores) == iores\\n      >>> # => Revealed type: 'IOResult[int, str]'\\n\\n    The difference is very clear in ``methods`` modules, like:\\n\\n    - Raw :func:`returns.methods.bind.internal_bind`\\n      that returns ``KindN`` instance\\n    - User-facing :func:`returns.methods.bind.bind`\\n      that returns the container type\\n\\n    You must use this decorator for your own kinded functions as well.\\n    \"\n    return function",
            "def kinded(function: _FunctionType) -> Kinded[_FunctionType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Decorator to be used when you want to dekind the function's return type.\\n\\n    Does nothing in runtime, just returns its argument.\\n\\n    We use a custom ``mypy`` plugin to make sure types are correct.\\n    Otherwise, it is currently impossible to properly type this.\\n\\n    Here's an example of how it should be used:\\n\\n    .. code:: python\\n\\n      >>> from typing import TypeVar\\n      >>> from returns.primitives.hkt import KindN, kinded\\n      >>> from returns.interfaces.bindable import BindableN\\n\\n      >>> _Binds = TypeVar('_Binds', bound=BindableN)  # just an example\\n      >>> _Type1 = TypeVar('_Type1')\\n      >>> _Type2 = TypeVar('_Type2')\\n      >>> _Type3 = TypeVar('_Type3')\\n\\n      >>> @kinded\\n      ... def bindable_identity(\\n      ...    container: KindN[_Binds, _Type1, _Type2, _Type3],\\n      ... ) -> KindN[_Binds, _Type1, _Type2, _Type3]:\\n      ...     return container  # just do nothing\\n\\n    As you can see, here we annotate our return type as\\n    ``-> KindN[_Binds, _Type1, _Type2, _Type3]``,\\n    it would be true without ``@kinded`` decorator.\\n\\n    But, ``@kinded`` decorator dekinds the return type and infers\\n    the real type behind it:\\n\\n    .. code:: python\\n\\n      >>> from returns.io import IO, IOResult\\n\\n      >>> assert bindable_identity(IO(1)) == IO(1)\\n      >>> # => Revealed type: 'IO[int]'\\n\\n      >>> iores: IOResult[int, str] = IOResult.from_value(1)\\n      >>> assert bindable_identity(iores) == iores\\n      >>> # => Revealed type: 'IOResult[int, str]'\\n\\n    The difference is very clear in ``methods`` modules, like:\\n\\n    - Raw :func:`returns.methods.bind.internal_bind`\\n      that returns ``KindN`` instance\\n    - User-facing :func:`returns.methods.bind.bind`\\n      that returns the container type\\n\\n    You must use this decorator for your own kinded functions as well.\\n    \"\n    return function"
        ]
    }
]