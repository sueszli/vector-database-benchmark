[
    {
        "func_name": "_cost",
        "original": "def _cost(node_and_neighborhood):\n    \"\"\"Returns the cost-effectiveness of greedily choosing the given\n        node.\n\n        `node_and_neighborhood` is a two-tuple comprising a node and its\n        closed neighborhood.\n\n        \"\"\"\n    (v, neighborhood) = node_and_neighborhood\n    return G.nodes[v].get(weight, 1) / len(neighborhood - dom_set)",
        "mutated": [
            "def _cost(node_and_neighborhood):\n    if False:\n        i = 10\n    'Returns the cost-effectiveness of greedily choosing the given\\n        node.\\n\\n        `node_and_neighborhood` is a two-tuple comprising a node and its\\n        closed neighborhood.\\n\\n        '\n    (v, neighborhood) = node_and_neighborhood\n    return G.nodes[v].get(weight, 1) / len(neighborhood - dom_set)",
            "def _cost(node_and_neighborhood):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the cost-effectiveness of greedily choosing the given\\n        node.\\n\\n        `node_and_neighborhood` is a two-tuple comprising a node and its\\n        closed neighborhood.\\n\\n        '\n    (v, neighborhood) = node_and_neighborhood\n    return G.nodes[v].get(weight, 1) / len(neighborhood - dom_set)",
            "def _cost(node_and_neighborhood):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the cost-effectiveness of greedily choosing the given\\n        node.\\n\\n        `node_and_neighborhood` is a two-tuple comprising a node and its\\n        closed neighborhood.\\n\\n        '\n    (v, neighborhood) = node_and_neighborhood\n    return G.nodes[v].get(weight, 1) / len(neighborhood - dom_set)",
            "def _cost(node_and_neighborhood):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the cost-effectiveness of greedily choosing the given\\n        node.\\n\\n        `node_and_neighborhood` is a two-tuple comprising a node and its\\n        closed neighborhood.\\n\\n        '\n    (v, neighborhood) = node_and_neighborhood\n    return G.nodes[v].get(weight, 1) / len(neighborhood - dom_set)",
            "def _cost(node_and_neighborhood):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the cost-effectiveness of greedily choosing the given\\n        node.\\n\\n        `node_and_neighborhood` is a two-tuple comprising a node and its\\n        closed neighborhood.\\n\\n        '\n    (v, neighborhood) = node_and_neighborhood\n    return G.nodes[v].get(weight, 1) / len(neighborhood - dom_set)"
        ]
    },
    {
        "func_name": "min_weighted_dominating_set",
        "original": "@not_implemented_for('directed')\n@nx._dispatch(node_attrs='weight')\ndef min_weighted_dominating_set(G, weight=None):\n    \"\"\"Returns a dominating set that approximates the minimum weight node\n    dominating set.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        Undirected graph.\n\n    weight : string\n        The node attribute storing the weight of an node. If provided,\n        the node attribute with this key must be a number for each\n        node. If not provided, each node is assumed to have weight one.\n\n    Returns\n    -------\n    min_weight_dominating_set : set\n        A set of nodes, the sum of whose weights is no more than `(\\\\log\n        w(V)) w(V^*)`, where `w(V)` denotes the sum of the weights of\n        each node in the graph and `w(V^*)` denotes the sum of the\n        weights of each node in the minimum weight dominating set.\n\n    Notes\n    -----\n    This algorithm computes an approximate minimum weighted dominating\n    set for the graph `G`. The returned solution has weight `(\\\\log\n    w(V)) w(V^*)`, where `w(V)` denotes the sum of the weights of each\n    node in the graph and `w(V^*)` denotes the sum of the weights of\n    each node in the minimum weight dominating set for the graph.\n\n    This implementation of the algorithm runs in $O(m)$ time, where $m$\n    is the number of edges in the graph.\n\n    References\n    ----------\n    .. [1] Vazirani, Vijay V.\n           *Approximation Algorithms*.\n           Springer Science & Business Media, 2001.\n\n    \"\"\"\n    if len(G) == 0:\n        return set()\n    dom_set = set()\n\n    def _cost(node_and_neighborhood):\n        \"\"\"Returns the cost-effectiveness of greedily choosing the given\n        node.\n\n        `node_and_neighborhood` is a two-tuple comprising a node and its\n        closed neighborhood.\n\n        \"\"\"\n        (v, neighborhood) = node_and_neighborhood\n        return G.nodes[v].get(weight, 1) / len(neighborhood - dom_set)\n    vertices = set(G)\n    neighborhoods = {v: {v} | set(G[v]) for v in G}\n    while vertices:\n        (dom_node, min_set) = min(neighborhoods.items(), key=_cost)\n        dom_set.add(dom_node)\n        del neighborhoods[dom_node]\n        vertices -= min_set\n    return dom_set",
        "mutated": [
            "@not_implemented_for('directed')\n@nx._dispatch(node_attrs='weight')\ndef min_weighted_dominating_set(G, weight=None):\n    if False:\n        i = 10\n    'Returns a dominating set that approximates the minimum weight node\\n    dominating set.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Undirected graph.\\n\\n    weight : string\\n        The node attribute storing the weight of an node. If provided,\\n        the node attribute with this key must be a number for each\\n        node. If not provided, each node is assumed to have weight one.\\n\\n    Returns\\n    -------\\n    min_weight_dominating_set : set\\n        A set of nodes, the sum of whose weights is no more than `(\\\\log\\n        w(V)) w(V^*)`, where `w(V)` denotes the sum of the weights of\\n        each node in the graph and `w(V^*)` denotes the sum of the\\n        weights of each node in the minimum weight dominating set.\\n\\n    Notes\\n    -----\\n    This algorithm computes an approximate minimum weighted dominating\\n    set for the graph `G`. The returned solution has weight `(\\\\log\\n    w(V)) w(V^*)`, where `w(V)` denotes the sum of the weights of each\\n    node in the graph and `w(V^*)` denotes the sum of the weights of\\n    each node in the minimum weight dominating set for the graph.\\n\\n    This implementation of the algorithm runs in $O(m)$ time, where $m$\\n    is the number of edges in the graph.\\n\\n    References\\n    ----------\\n    .. [1] Vazirani, Vijay V.\\n           *Approximation Algorithms*.\\n           Springer Science & Business Media, 2001.\\n\\n    '\n    if len(G) == 0:\n        return set()\n    dom_set = set()\n\n    def _cost(node_and_neighborhood):\n        \"\"\"Returns the cost-effectiveness of greedily choosing the given\n        node.\n\n        `node_and_neighborhood` is a two-tuple comprising a node and its\n        closed neighborhood.\n\n        \"\"\"\n        (v, neighborhood) = node_and_neighborhood\n        return G.nodes[v].get(weight, 1) / len(neighborhood - dom_set)\n    vertices = set(G)\n    neighborhoods = {v: {v} | set(G[v]) for v in G}\n    while vertices:\n        (dom_node, min_set) = min(neighborhoods.items(), key=_cost)\n        dom_set.add(dom_node)\n        del neighborhoods[dom_node]\n        vertices -= min_set\n    return dom_set",
            "@not_implemented_for('directed')\n@nx._dispatch(node_attrs='weight')\ndef min_weighted_dominating_set(G, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a dominating set that approximates the minimum weight node\\n    dominating set.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Undirected graph.\\n\\n    weight : string\\n        The node attribute storing the weight of an node. If provided,\\n        the node attribute with this key must be a number for each\\n        node. If not provided, each node is assumed to have weight one.\\n\\n    Returns\\n    -------\\n    min_weight_dominating_set : set\\n        A set of nodes, the sum of whose weights is no more than `(\\\\log\\n        w(V)) w(V^*)`, where `w(V)` denotes the sum of the weights of\\n        each node in the graph and `w(V^*)` denotes the sum of the\\n        weights of each node in the minimum weight dominating set.\\n\\n    Notes\\n    -----\\n    This algorithm computes an approximate minimum weighted dominating\\n    set for the graph `G`. The returned solution has weight `(\\\\log\\n    w(V)) w(V^*)`, where `w(V)` denotes the sum of the weights of each\\n    node in the graph and `w(V^*)` denotes the sum of the weights of\\n    each node in the minimum weight dominating set for the graph.\\n\\n    This implementation of the algorithm runs in $O(m)$ time, where $m$\\n    is the number of edges in the graph.\\n\\n    References\\n    ----------\\n    .. [1] Vazirani, Vijay V.\\n           *Approximation Algorithms*.\\n           Springer Science & Business Media, 2001.\\n\\n    '\n    if len(G) == 0:\n        return set()\n    dom_set = set()\n\n    def _cost(node_and_neighborhood):\n        \"\"\"Returns the cost-effectiveness of greedily choosing the given\n        node.\n\n        `node_and_neighborhood` is a two-tuple comprising a node and its\n        closed neighborhood.\n\n        \"\"\"\n        (v, neighborhood) = node_and_neighborhood\n        return G.nodes[v].get(weight, 1) / len(neighborhood - dom_set)\n    vertices = set(G)\n    neighborhoods = {v: {v} | set(G[v]) for v in G}\n    while vertices:\n        (dom_node, min_set) = min(neighborhoods.items(), key=_cost)\n        dom_set.add(dom_node)\n        del neighborhoods[dom_node]\n        vertices -= min_set\n    return dom_set",
            "@not_implemented_for('directed')\n@nx._dispatch(node_attrs='weight')\ndef min_weighted_dominating_set(G, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a dominating set that approximates the minimum weight node\\n    dominating set.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Undirected graph.\\n\\n    weight : string\\n        The node attribute storing the weight of an node. If provided,\\n        the node attribute with this key must be a number for each\\n        node. If not provided, each node is assumed to have weight one.\\n\\n    Returns\\n    -------\\n    min_weight_dominating_set : set\\n        A set of nodes, the sum of whose weights is no more than `(\\\\log\\n        w(V)) w(V^*)`, where `w(V)` denotes the sum of the weights of\\n        each node in the graph and `w(V^*)` denotes the sum of the\\n        weights of each node in the minimum weight dominating set.\\n\\n    Notes\\n    -----\\n    This algorithm computes an approximate minimum weighted dominating\\n    set for the graph `G`. The returned solution has weight `(\\\\log\\n    w(V)) w(V^*)`, where `w(V)` denotes the sum of the weights of each\\n    node in the graph and `w(V^*)` denotes the sum of the weights of\\n    each node in the minimum weight dominating set for the graph.\\n\\n    This implementation of the algorithm runs in $O(m)$ time, where $m$\\n    is the number of edges in the graph.\\n\\n    References\\n    ----------\\n    .. [1] Vazirani, Vijay V.\\n           *Approximation Algorithms*.\\n           Springer Science & Business Media, 2001.\\n\\n    '\n    if len(G) == 0:\n        return set()\n    dom_set = set()\n\n    def _cost(node_and_neighborhood):\n        \"\"\"Returns the cost-effectiveness of greedily choosing the given\n        node.\n\n        `node_and_neighborhood` is a two-tuple comprising a node and its\n        closed neighborhood.\n\n        \"\"\"\n        (v, neighborhood) = node_and_neighborhood\n        return G.nodes[v].get(weight, 1) / len(neighborhood - dom_set)\n    vertices = set(G)\n    neighborhoods = {v: {v} | set(G[v]) for v in G}\n    while vertices:\n        (dom_node, min_set) = min(neighborhoods.items(), key=_cost)\n        dom_set.add(dom_node)\n        del neighborhoods[dom_node]\n        vertices -= min_set\n    return dom_set",
            "@not_implemented_for('directed')\n@nx._dispatch(node_attrs='weight')\ndef min_weighted_dominating_set(G, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a dominating set that approximates the minimum weight node\\n    dominating set.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Undirected graph.\\n\\n    weight : string\\n        The node attribute storing the weight of an node. If provided,\\n        the node attribute with this key must be a number for each\\n        node. If not provided, each node is assumed to have weight one.\\n\\n    Returns\\n    -------\\n    min_weight_dominating_set : set\\n        A set of nodes, the sum of whose weights is no more than `(\\\\log\\n        w(V)) w(V^*)`, where `w(V)` denotes the sum of the weights of\\n        each node in the graph and `w(V^*)` denotes the sum of the\\n        weights of each node in the minimum weight dominating set.\\n\\n    Notes\\n    -----\\n    This algorithm computes an approximate minimum weighted dominating\\n    set for the graph `G`. The returned solution has weight `(\\\\log\\n    w(V)) w(V^*)`, where `w(V)` denotes the sum of the weights of each\\n    node in the graph and `w(V^*)` denotes the sum of the weights of\\n    each node in the minimum weight dominating set for the graph.\\n\\n    This implementation of the algorithm runs in $O(m)$ time, where $m$\\n    is the number of edges in the graph.\\n\\n    References\\n    ----------\\n    .. [1] Vazirani, Vijay V.\\n           *Approximation Algorithms*.\\n           Springer Science & Business Media, 2001.\\n\\n    '\n    if len(G) == 0:\n        return set()\n    dom_set = set()\n\n    def _cost(node_and_neighborhood):\n        \"\"\"Returns the cost-effectiveness of greedily choosing the given\n        node.\n\n        `node_and_neighborhood` is a two-tuple comprising a node and its\n        closed neighborhood.\n\n        \"\"\"\n        (v, neighborhood) = node_and_neighborhood\n        return G.nodes[v].get(weight, 1) / len(neighborhood - dom_set)\n    vertices = set(G)\n    neighborhoods = {v: {v} | set(G[v]) for v in G}\n    while vertices:\n        (dom_node, min_set) = min(neighborhoods.items(), key=_cost)\n        dom_set.add(dom_node)\n        del neighborhoods[dom_node]\n        vertices -= min_set\n    return dom_set",
            "@not_implemented_for('directed')\n@nx._dispatch(node_attrs='weight')\ndef min_weighted_dominating_set(G, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a dominating set that approximates the minimum weight node\\n    dominating set.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Undirected graph.\\n\\n    weight : string\\n        The node attribute storing the weight of an node. If provided,\\n        the node attribute with this key must be a number for each\\n        node. If not provided, each node is assumed to have weight one.\\n\\n    Returns\\n    -------\\n    min_weight_dominating_set : set\\n        A set of nodes, the sum of whose weights is no more than `(\\\\log\\n        w(V)) w(V^*)`, where `w(V)` denotes the sum of the weights of\\n        each node in the graph and `w(V^*)` denotes the sum of the\\n        weights of each node in the minimum weight dominating set.\\n\\n    Notes\\n    -----\\n    This algorithm computes an approximate minimum weighted dominating\\n    set for the graph `G`. The returned solution has weight `(\\\\log\\n    w(V)) w(V^*)`, where `w(V)` denotes the sum of the weights of each\\n    node in the graph and `w(V^*)` denotes the sum of the weights of\\n    each node in the minimum weight dominating set for the graph.\\n\\n    This implementation of the algorithm runs in $O(m)$ time, where $m$\\n    is the number of edges in the graph.\\n\\n    References\\n    ----------\\n    .. [1] Vazirani, Vijay V.\\n           *Approximation Algorithms*.\\n           Springer Science & Business Media, 2001.\\n\\n    '\n    if len(G) == 0:\n        return set()\n    dom_set = set()\n\n    def _cost(node_and_neighborhood):\n        \"\"\"Returns the cost-effectiveness of greedily choosing the given\n        node.\n\n        `node_and_neighborhood` is a two-tuple comprising a node and its\n        closed neighborhood.\n\n        \"\"\"\n        (v, neighborhood) = node_and_neighborhood\n        return G.nodes[v].get(weight, 1) / len(neighborhood - dom_set)\n    vertices = set(G)\n    neighborhoods = {v: {v} | set(G[v]) for v in G}\n    while vertices:\n        (dom_node, min_set) = min(neighborhoods.items(), key=_cost)\n        dom_set.add(dom_node)\n        del neighborhoods[dom_node]\n        vertices -= min_set\n    return dom_set"
        ]
    },
    {
        "func_name": "min_edge_dominating_set",
        "original": "@nx._dispatch\ndef min_edge_dominating_set(G):\n    \"\"\"Returns minimum cardinality edge dominating set.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n      Undirected graph\n\n    Returns\n    -------\n    min_edge_dominating_set : set\n      Returns a set of dominating edges whose size is no more than 2 * OPT.\n\n    Notes\n    -----\n    The algorithm computes an approximate solution to the edge dominating set\n    problem. The result is no more than 2 * OPT in terms of size of the set.\n    Runtime of the algorithm is $O(|E|)$.\n    \"\"\"\n    if not G:\n        raise ValueError('Expected non-empty NetworkX graph!')\n    return maximal_matching(G)",
        "mutated": [
            "@nx._dispatch\ndef min_edge_dominating_set(G):\n    if False:\n        i = 10\n    'Returns minimum cardinality edge dominating set.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n      Undirected graph\\n\\n    Returns\\n    -------\\n    min_edge_dominating_set : set\\n      Returns a set of dominating edges whose size is no more than 2 * OPT.\\n\\n    Notes\\n    -----\\n    The algorithm computes an approximate solution to the edge dominating set\\n    problem. The result is no more than 2 * OPT in terms of size of the set.\\n    Runtime of the algorithm is $O(|E|)$.\\n    '\n    if not G:\n        raise ValueError('Expected non-empty NetworkX graph!')\n    return maximal_matching(G)",
            "@nx._dispatch\ndef min_edge_dominating_set(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns minimum cardinality edge dominating set.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n      Undirected graph\\n\\n    Returns\\n    -------\\n    min_edge_dominating_set : set\\n      Returns a set of dominating edges whose size is no more than 2 * OPT.\\n\\n    Notes\\n    -----\\n    The algorithm computes an approximate solution to the edge dominating set\\n    problem. The result is no more than 2 * OPT in terms of size of the set.\\n    Runtime of the algorithm is $O(|E|)$.\\n    '\n    if not G:\n        raise ValueError('Expected non-empty NetworkX graph!')\n    return maximal_matching(G)",
            "@nx._dispatch\ndef min_edge_dominating_set(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns minimum cardinality edge dominating set.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n      Undirected graph\\n\\n    Returns\\n    -------\\n    min_edge_dominating_set : set\\n      Returns a set of dominating edges whose size is no more than 2 * OPT.\\n\\n    Notes\\n    -----\\n    The algorithm computes an approximate solution to the edge dominating set\\n    problem. The result is no more than 2 * OPT in terms of size of the set.\\n    Runtime of the algorithm is $O(|E|)$.\\n    '\n    if not G:\n        raise ValueError('Expected non-empty NetworkX graph!')\n    return maximal_matching(G)",
            "@nx._dispatch\ndef min_edge_dominating_set(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns minimum cardinality edge dominating set.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n      Undirected graph\\n\\n    Returns\\n    -------\\n    min_edge_dominating_set : set\\n      Returns a set of dominating edges whose size is no more than 2 * OPT.\\n\\n    Notes\\n    -----\\n    The algorithm computes an approximate solution to the edge dominating set\\n    problem. The result is no more than 2 * OPT in terms of size of the set.\\n    Runtime of the algorithm is $O(|E|)$.\\n    '\n    if not G:\n        raise ValueError('Expected non-empty NetworkX graph!')\n    return maximal_matching(G)",
            "@nx._dispatch\ndef min_edge_dominating_set(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns minimum cardinality edge dominating set.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n      Undirected graph\\n\\n    Returns\\n    -------\\n    min_edge_dominating_set : set\\n      Returns a set of dominating edges whose size is no more than 2 * OPT.\\n\\n    Notes\\n    -----\\n    The algorithm computes an approximate solution to the edge dominating set\\n    problem. The result is no more than 2 * OPT in terms of size of the set.\\n    Runtime of the algorithm is $O(|E|)$.\\n    '\n    if not G:\n        raise ValueError('Expected non-empty NetworkX graph!')\n    return maximal_matching(G)"
        ]
    }
]