[
    {
        "func_name": "sample_discount_curve_paths_fn",
        "original": "def sample_discount_curve_paths_fn(times, curve_times, num_samples):\n    (p_t_tau, r_t, _) = model.sample_discount_curve_paths(times=times, curve_times=curve_times, num_samples=num_samples, random_type=random_type, time_step=time_step, seed=seed, skip=skip)\n    p_t_tau = tf.expand_dims(p_t_tau, axis=-1)\n    r_t = tf.expand_dims(r_t, axis=-1)\n    return (p_t_tau, r_t)",
        "mutated": [
            "def sample_discount_curve_paths_fn(times, curve_times, num_samples):\n    if False:\n        i = 10\n    (p_t_tau, r_t, _) = model.sample_discount_curve_paths(times=times, curve_times=curve_times, num_samples=num_samples, random_type=random_type, time_step=time_step, seed=seed, skip=skip)\n    p_t_tau = tf.expand_dims(p_t_tau, axis=-1)\n    r_t = tf.expand_dims(r_t, axis=-1)\n    return (p_t_tau, r_t)",
            "def sample_discount_curve_paths_fn(times, curve_times, num_samples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (p_t_tau, r_t, _) = model.sample_discount_curve_paths(times=times, curve_times=curve_times, num_samples=num_samples, random_type=random_type, time_step=time_step, seed=seed, skip=skip)\n    p_t_tau = tf.expand_dims(p_t_tau, axis=-1)\n    r_t = tf.expand_dims(r_t, axis=-1)\n    return (p_t_tau, r_t)",
            "def sample_discount_curve_paths_fn(times, curve_times, num_samples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (p_t_tau, r_t, _) = model.sample_discount_curve_paths(times=times, curve_times=curve_times, num_samples=num_samples, random_type=random_type, time_step=time_step, seed=seed, skip=skip)\n    p_t_tau = tf.expand_dims(p_t_tau, axis=-1)\n    r_t = tf.expand_dims(r_t, axis=-1)\n    return (p_t_tau, r_t)",
            "def sample_discount_curve_paths_fn(times, curve_times, num_samples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (p_t_tau, r_t, _) = model.sample_discount_curve_paths(times=times, curve_times=curve_times, num_samples=num_samples, random_type=random_type, time_step=time_step, seed=seed, skip=skip)\n    p_t_tau = tf.expand_dims(p_t_tau, axis=-1)\n    r_t = tf.expand_dims(r_t, axis=-1)\n    return (p_t_tau, r_t)",
            "def sample_discount_curve_paths_fn(times, curve_times, num_samples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (p_t_tau, r_t, _) = model.sample_discount_curve_paths(times=times, curve_times=curve_times, num_samples=num_samples, random_type=random_type, time_step=time_step, seed=seed, skip=skip)\n    p_t_tau = tf.expand_dims(p_t_tau, axis=-1)\n    r_t = tf.expand_dims(r_t, axis=-1)\n    return (p_t_tau, r_t)"
        ]
    },
    {
        "func_name": "bond_option_price",
        "original": "def bond_option_price(*, strikes: types.RealTensor, expiries: types.RealTensor, maturities: types.RealTensor, discount_rate_fn: Callable[..., types.RealTensor], dim: int, mean_reversion: types.RealTensor, volatility: Union[types.RealTensor, Callable[..., types.RealTensor]], corr_matrix: types.RealTensor=None, is_call_options: types.BoolTensor=True, num_samples: types.IntTensor=1, random_type: random.RandomType=None, seed: types.IntTensor=None, skip: types.IntTensor=0, time_step: types.RealTensor=None, dtype: tf.DType=None, name: str=None) -> types.RealTensor:\n    \"\"\"Calculates European bond option prices using the HJM model.\n\n  Bond options are fixed income securities which give the holder a right to\n  exchange at a future date (the option expiry) a zero coupon bond for a fixed\n  price (the strike of the option). The maturity date of the bond is after the\n  the expiry of the option. If `P(t,T)` denotes the price at time `t` of a zero\n  coupon bond with maturity `T`, then the payoff from the option at option\n  expiry, `T0`, is given by:\n\n  ```None\n  payoff = max(P(T0, T) - X, 0)\n  ```\n  where `X` is the strike price of the option.\n\n  #### Example\n\n  ````python\n  import numpy as np\n  import tensorflow.compat.v2 as tf\n  import tf_quant_finance as tff\n\n  dtype = tf.float64\n\n  discount_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n  expiries = np.array([1.0])\n  maturities = np.array([5.0])\n  strikes = np.exp(-0.01 * maturities) / np.exp(-0.01 * expiries)\n  price = tff.models.hjm.bond_option_price(\n      strikes=strikes,\n      expiries=expiries,\n      maturities=maturities,\n      dim=1,\n      mean_reversion=[0.03],\n      volatility=[0.02],\n      discount_rate_fn=discount_rate_fn,\n      dtype=dtype)\n  # Expected value: [[0.02817777]]\n  ````\n\n  Args:\n    strikes: A real `Tensor` of any shape and dtype. The strike price of the\n      options. The shape of this input determines the number (and shape) of the\n      options to be priced and the output.\n    expiries: A real `Tensor` of the same dtype and compatible shape as\n      `strikes`.  The time to expiry of each bond option.\n    maturities: A real `Tensor` of the same dtype and compatible shape as\n      `strikes`.  The time to maturity of the underlying zero coupon bonds.\n    discount_rate_fn: A Python callable that accepts expiry time as a real\n      `Tensor` and returns a `Tensor` of shape `input_shape`. Computes the\n      zero coupon bond yield at the present time for the input expiry time.\n    dim: A Python scalar which corresponds to the number of factors within a\n      single HJM model.\n    mean_reversion: A real positive `Tensor` of shape `[dim]`. Corresponds to\n      the mean reversion rate of each factor.\n    volatility: A real positive `Tensor` of the same `dtype` and shape as\n      `mean_reversion` or a callable with the following properties: (a)  The\n        callable should accept a scalar `Tensor` `t` and a 1-D `Tensor` `r(t)`\n        of shape `[num_samples]` and returns a 2-D `Tensor` of shape\n        `[num_samples, dim]`. The variable `t`  stands for time and `r(t)` is\n        the short rate at time `t`.  The function returns instantaneous\n        volatility `sigma(t) = sigma(t, r(t))`. When `volatility` is specified\n        is a real `Tensor`, each factor is assumed to have a constant\n        instantaneous volatility  and the  model is effectively a Gaussian HJM\n        model. Corresponds to the instantaneous volatility of each factor.\n    corr_matrix: A `Tensor` of shape `[dim, dim]` and the same `dtype` as\n      `mean_reversion`. Corresponds to the correlation matrix `Rho`.\n      Default value: None, meaning the factors are uncorrelated.\n    is_call_options: A boolean `Tensor` of a shape compatible with `strikes`.\n      Indicates whether the option is a call (if True) or a put (if False). If\n      not supplied, call options are assumed.\n    num_samples: Positive scalar `int32` `Tensor`. The number of simulation\n      paths during Monte-Carlo valuation.\n      Default value: The default value is 1.\n    random_type: Enum value of `RandomType`. The type of (quasi)-random number\n      generator to use to generate the simulation paths.\n      Default value: `None` which maps to the standard pseudo-random numbers.\n    seed: Seed for the random number generator. The seed is only relevant if\n      `random_type` is one of `[STATELESS, PSEUDO, HALTON_RANDOMIZED,\n      PSEUDO_ANTITHETIC, STATELESS_ANTITHETIC]`. For `PSEUDO`,\n      `PSEUDO_ANTITHETIC` and `HALTON_RANDOMIZED` the seed should be an Python\n      integer. For `STATELESS` and  `STATELESS_ANTITHETIC `must be supplied as\n      an integer `Tensor` of shape `[2]`.\n      Default value: `None` which means no seed is set.\n    skip: `int32` 0-d `Tensor`. The number of initial points of the Sobol or\n      Halton sequence to skip. Used only when `random_type` is 'SOBOL',\n      'HALTON', or 'HALTON_RANDOMIZED', otherwise ignored.\n      Default value: `0`.\n    time_step: Scalar real `Tensor`. Maximal distance between time grid points\n      in Euler scheme. Relevant when Euler scheme is used for simulation.\n      Default value: `None`.\n    dtype: The default dtype to use when converting values to `Tensor`s.\n      Default value: `None` which means that default dtypes inferred by\n        TensorFlow are used.\n    name: Python string. The name to give to the ops created by this class.\n      Default value: `None` which maps to the default name\n        `hw_bond_option_price`.\n\n  Returns:\n    A `Tensor` of real dtype and shape  `strikes.shape` containing the\n    computed option prices.\n  \"\"\"\n    if time_step is None:\n        raise ValueError('`time_step` must be provided for simulation based bond option valuation.')\n    name = name or 'hjm_bond_option_price'\n    if dtype is None:\n        dtype = tf.convert_to_tensor([0.0]).dtype\n    with tf.name_scope(name):\n        strikes = tf.convert_to_tensor(strikes, dtype=dtype, name='strikes')\n        expiries = tf.convert_to_tensor(expiries, dtype=dtype, name='expiries')\n        maturities = tf.convert_to_tensor(maturities, dtype=dtype, name='maturities')\n        is_call_options = tf.convert_to_tensor(is_call_options, dtype=tf.bool, name='is_call_options')\n        model = quasi_gaussian_hjm.QuasiGaussianHJM(dim, mean_reversion=mean_reversion, volatility=volatility, initial_discount_rate_fn=discount_rate_fn, corr_matrix=corr_matrix, dtype=dtype)\n\n        def sample_discount_curve_paths_fn(times, curve_times, num_samples):\n            (p_t_tau, r_t, _) = model.sample_discount_curve_paths(times=times, curve_times=curve_times, num_samples=num_samples, random_type=random_type, time_step=time_step, seed=seed, skip=skip)\n            p_t_tau = tf.expand_dims(p_t_tau, axis=-1)\n            r_t = tf.expand_dims(r_t, axis=-1)\n            return (p_t_tau, r_t)\n        prices = zero_coupon_bond_option_util.options_price_from_samples(strikes, expiries, maturities, is_call_options, sample_discount_curve_paths_fn, num_samples, time_step, dtype=dtype)\n        return tf.squeeze(prices, axis=-1)",
        "mutated": [
            "def bond_option_price(*, strikes: types.RealTensor, expiries: types.RealTensor, maturities: types.RealTensor, discount_rate_fn: Callable[..., types.RealTensor], dim: int, mean_reversion: types.RealTensor, volatility: Union[types.RealTensor, Callable[..., types.RealTensor]], corr_matrix: types.RealTensor=None, is_call_options: types.BoolTensor=True, num_samples: types.IntTensor=1, random_type: random.RandomType=None, seed: types.IntTensor=None, skip: types.IntTensor=0, time_step: types.RealTensor=None, dtype: tf.DType=None, name: str=None) -> types.RealTensor:\n    if False:\n        i = 10\n    \"Calculates European bond option prices using the HJM model.\\n\\n  Bond options are fixed income securities which give the holder a right to\\n  exchange at a future date (the option expiry) a zero coupon bond for a fixed\\n  price (the strike of the option). The maturity date of the bond is after the\\n  the expiry of the option. If `P(t,T)` denotes the price at time `t` of a zero\\n  coupon bond with maturity `T`, then the payoff from the option at option\\n  expiry, `T0`, is given by:\\n\\n  ```None\\n  payoff = max(P(T0, T) - X, 0)\\n  ```\\n  where `X` is the strike price of the option.\\n\\n  #### Example\\n\\n  ````python\\n  import numpy as np\\n  import tensorflow.compat.v2 as tf\\n  import tf_quant_finance as tff\\n\\n  dtype = tf.float64\\n\\n  discount_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\\n  expiries = np.array([1.0])\\n  maturities = np.array([5.0])\\n  strikes = np.exp(-0.01 * maturities) / np.exp(-0.01 * expiries)\\n  price = tff.models.hjm.bond_option_price(\\n      strikes=strikes,\\n      expiries=expiries,\\n      maturities=maturities,\\n      dim=1,\\n      mean_reversion=[0.03],\\n      volatility=[0.02],\\n      discount_rate_fn=discount_rate_fn,\\n      dtype=dtype)\\n  # Expected value: [[0.02817777]]\\n  ````\\n\\n  Args:\\n    strikes: A real `Tensor` of any shape and dtype. The strike price of the\\n      options. The shape of this input determines the number (and shape) of the\\n      options to be priced and the output.\\n    expiries: A real `Tensor` of the same dtype and compatible shape as\\n      `strikes`.  The time to expiry of each bond option.\\n    maturities: A real `Tensor` of the same dtype and compatible shape as\\n      `strikes`.  The time to maturity of the underlying zero coupon bonds.\\n    discount_rate_fn: A Python callable that accepts expiry time as a real\\n      `Tensor` and returns a `Tensor` of shape `input_shape`. Computes the\\n      zero coupon bond yield at the present time for the input expiry time.\\n    dim: A Python scalar which corresponds to the number of factors within a\\n      single HJM model.\\n    mean_reversion: A real positive `Tensor` of shape `[dim]`. Corresponds to\\n      the mean reversion rate of each factor.\\n    volatility: A real positive `Tensor` of the same `dtype` and shape as\\n      `mean_reversion` or a callable with the following properties: (a)  The\\n        callable should accept a scalar `Tensor` `t` and a 1-D `Tensor` `r(t)`\\n        of shape `[num_samples]` and returns a 2-D `Tensor` of shape\\n        `[num_samples, dim]`. The variable `t`  stands for time and `r(t)` is\\n        the short rate at time `t`.  The function returns instantaneous\\n        volatility `sigma(t) = sigma(t, r(t))`. When `volatility` is specified\\n        is a real `Tensor`, each factor is assumed to have a constant\\n        instantaneous volatility  and the  model is effectively a Gaussian HJM\\n        model. Corresponds to the instantaneous volatility of each factor.\\n    corr_matrix: A `Tensor` of shape `[dim, dim]` and the same `dtype` as\\n      `mean_reversion`. Corresponds to the correlation matrix `Rho`.\\n      Default value: None, meaning the factors are uncorrelated.\\n    is_call_options: A boolean `Tensor` of a shape compatible with `strikes`.\\n      Indicates whether the option is a call (if True) or a put (if False). If\\n      not supplied, call options are assumed.\\n    num_samples: Positive scalar `int32` `Tensor`. The number of simulation\\n      paths during Monte-Carlo valuation.\\n      Default value: The default value is 1.\\n    random_type: Enum value of `RandomType`. The type of (quasi)-random number\\n      generator to use to generate the simulation paths.\\n      Default value: `None` which maps to the standard pseudo-random numbers.\\n    seed: Seed for the random number generator. The seed is only relevant if\\n      `random_type` is one of `[STATELESS, PSEUDO, HALTON_RANDOMIZED,\\n      PSEUDO_ANTITHETIC, STATELESS_ANTITHETIC]`. For `PSEUDO`,\\n      `PSEUDO_ANTITHETIC` and `HALTON_RANDOMIZED` the seed should be an Python\\n      integer. For `STATELESS` and  `STATELESS_ANTITHETIC `must be supplied as\\n      an integer `Tensor` of shape `[2]`.\\n      Default value: `None` which means no seed is set.\\n    skip: `int32` 0-d `Tensor`. The number of initial points of the Sobol or\\n      Halton sequence to skip. Used only when `random_type` is 'SOBOL',\\n      'HALTON', or 'HALTON_RANDOMIZED', otherwise ignored.\\n      Default value: `0`.\\n    time_step: Scalar real `Tensor`. Maximal distance between time grid points\\n      in Euler scheme. Relevant when Euler scheme is used for simulation.\\n      Default value: `None`.\\n    dtype: The default dtype to use when converting values to `Tensor`s.\\n      Default value: `None` which means that default dtypes inferred by\\n        TensorFlow are used.\\n    name: Python string. The name to give to the ops created by this class.\\n      Default value: `None` which maps to the default name\\n        `hw_bond_option_price`.\\n\\n  Returns:\\n    A `Tensor` of real dtype and shape  `strikes.shape` containing the\\n    computed option prices.\\n  \"\n    if time_step is None:\n        raise ValueError('`time_step` must be provided for simulation based bond option valuation.')\n    name = name or 'hjm_bond_option_price'\n    if dtype is None:\n        dtype = tf.convert_to_tensor([0.0]).dtype\n    with tf.name_scope(name):\n        strikes = tf.convert_to_tensor(strikes, dtype=dtype, name='strikes')\n        expiries = tf.convert_to_tensor(expiries, dtype=dtype, name='expiries')\n        maturities = tf.convert_to_tensor(maturities, dtype=dtype, name='maturities')\n        is_call_options = tf.convert_to_tensor(is_call_options, dtype=tf.bool, name='is_call_options')\n        model = quasi_gaussian_hjm.QuasiGaussianHJM(dim, mean_reversion=mean_reversion, volatility=volatility, initial_discount_rate_fn=discount_rate_fn, corr_matrix=corr_matrix, dtype=dtype)\n\n        def sample_discount_curve_paths_fn(times, curve_times, num_samples):\n            (p_t_tau, r_t, _) = model.sample_discount_curve_paths(times=times, curve_times=curve_times, num_samples=num_samples, random_type=random_type, time_step=time_step, seed=seed, skip=skip)\n            p_t_tau = tf.expand_dims(p_t_tau, axis=-1)\n            r_t = tf.expand_dims(r_t, axis=-1)\n            return (p_t_tau, r_t)\n        prices = zero_coupon_bond_option_util.options_price_from_samples(strikes, expiries, maturities, is_call_options, sample_discount_curve_paths_fn, num_samples, time_step, dtype=dtype)\n        return tf.squeeze(prices, axis=-1)",
            "def bond_option_price(*, strikes: types.RealTensor, expiries: types.RealTensor, maturities: types.RealTensor, discount_rate_fn: Callable[..., types.RealTensor], dim: int, mean_reversion: types.RealTensor, volatility: Union[types.RealTensor, Callable[..., types.RealTensor]], corr_matrix: types.RealTensor=None, is_call_options: types.BoolTensor=True, num_samples: types.IntTensor=1, random_type: random.RandomType=None, seed: types.IntTensor=None, skip: types.IntTensor=0, time_step: types.RealTensor=None, dtype: tf.DType=None, name: str=None) -> types.RealTensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Calculates European bond option prices using the HJM model.\\n\\n  Bond options are fixed income securities which give the holder a right to\\n  exchange at a future date (the option expiry) a zero coupon bond for a fixed\\n  price (the strike of the option). The maturity date of the bond is after the\\n  the expiry of the option. If `P(t,T)` denotes the price at time `t` of a zero\\n  coupon bond with maturity `T`, then the payoff from the option at option\\n  expiry, `T0`, is given by:\\n\\n  ```None\\n  payoff = max(P(T0, T) - X, 0)\\n  ```\\n  where `X` is the strike price of the option.\\n\\n  #### Example\\n\\n  ````python\\n  import numpy as np\\n  import tensorflow.compat.v2 as tf\\n  import tf_quant_finance as tff\\n\\n  dtype = tf.float64\\n\\n  discount_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\\n  expiries = np.array([1.0])\\n  maturities = np.array([5.0])\\n  strikes = np.exp(-0.01 * maturities) / np.exp(-0.01 * expiries)\\n  price = tff.models.hjm.bond_option_price(\\n      strikes=strikes,\\n      expiries=expiries,\\n      maturities=maturities,\\n      dim=1,\\n      mean_reversion=[0.03],\\n      volatility=[0.02],\\n      discount_rate_fn=discount_rate_fn,\\n      dtype=dtype)\\n  # Expected value: [[0.02817777]]\\n  ````\\n\\n  Args:\\n    strikes: A real `Tensor` of any shape and dtype. The strike price of the\\n      options. The shape of this input determines the number (and shape) of the\\n      options to be priced and the output.\\n    expiries: A real `Tensor` of the same dtype and compatible shape as\\n      `strikes`.  The time to expiry of each bond option.\\n    maturities: A real `Tensor` of the same dtype and compatible shape as\\n      `strikes`.  The time to maturity of the underlying zero coupon bonds.\\n    discount_rate_fn: A Python callable that accepts expiry time as a real\\n      `Tensor` and returns a `Tensor` of shape `input_shape`. Computes the\\n      zero coupon bond yield at the present time for the input expiry time.\\n    dim: A Python scalar which corresponds to the number of factors within a\\n      single HJM model.\\n    mean_reversion: A real positive `Tensor` of shape `[dim]`. Corresponds to\\n      the mean reversion rate of each factor.\\n    volatility: A real positive `Tensor` of the same `dtype` and shape as\\n      `mean_reversion` or a callable with the following properties: (a)  The\\n        callable should accept a scalar `Tensor` `t` and a 1-D `Tensor` `r(t)`\\n        of shape `[num_samples]` and returns a 2-D `Tensor` of shape\\n        `[num_samples, dim]`. The variable `t`  stands for time and `r(t)` is\\n        the short rate at time `t`.  The function returns instantaneous\\n        volatility `sigma(t) = sigma(t, r(t))`. When `volatility` is specified\\n        is a real `Tensor`, each factor is assumed to have a constant\\n        instantaneous volatility  and the  model is effectively a Gaussian HJM\\n        model. Corresponds to the instantaneous volatility of each factor.\\n    corr_matrix: A `Tensor` of shape `[dim, dim]` and the same `dtype` as\\n      `mean_reversion`. Corresponds to the correlation matrix `Rho`.\\n      Default value: None, meaning the factors are uncorrelated.\\n    is_call_options: A boolean `Tensor` of a shape compatible with `strikes`.\\n      Indicates whether the option is a call (if True) or a put (if False). If\\n      not supplied, call options are assumed.\\n    num_samples: Positive scalar `int32` `Tensor`. The number of simulation\\n      paths during Monte-Carlo valuation.\\n      Default value: The default value is 1.\\n    random_type: Enum value of `RandomType`. The type of (quasi)-random number\\n      generator to use to generate the simulation paths.\\n      Default value: `None` which maps to the standard pseudo-random numbers.\\n    seed: Seed for the random number generator. The seed is only relevant if\\n      `random_type` is one of `[STATELESS, PSEUDO, HALTON_RANDOMIZED,\\n      PSEUDO_ANTITHETIC, STATELESS_ANTITHETIC]`. For `PSEUDO`,\\n      `PSEUDO_ANTITHETIC` and `HALTON_RANDOMIZED` the seed should be an Python\\n      integer. For `STATELESS` and  `STATELESS_ANTITHETIC `must be supplied as\\n      an integer `Tensor` of shape `[2]`.\\n      Default value: `None` which means no seed is set.\\n    skip: `int32` 0-d `Tensor`. The number of initial points of the Sobol or\\n      Halton sequence to skip. Used only when `random_type` is 'SOBOL',\\n      'HALTON', or 'HALTON_RANDOMIZED', otherwise ignored.\\n      Default value: `0`.\\n    time_step: Scalar real `Tensor`. Maximal distance between time grid points\\n      in Euler scheme. Relevant when Euler scheme is used for simulation.\\n      Default value: `None`.\\n    dtype: The default dtype to use when converting values to `Tensor`s.\\n      Default value: `None` which means that default dtypes inferred by\\n        TensorFlow are used.\\n    name: Python string. The name to give to the ops created by this class.\\n      Default value: `None` which maps to the default name\\n        `hw_bond_option_price`.\\n\\n  Returns:\\n    A `Tensor` of real dtype and shape  `strikes.shape` containing the\\n    computed option prices.\\n  \"\n    if time_step is None:\n        raise ValueError('`time_step` must be provided for simulation based bond option valuation.')\n    name = name or 'hjm_bond_option_price'\n    if dtype is None:\n        dtype = tf.convert_to_tensor([0.0]).dtype\n    with tf.name_scope(name):\n        strikes = tf.convert_to_tensor(strikes, dtype=dtype, name='strikes')\n        expiries = tf.convert_to_tensor(expiries, dtype=dtype, name='expiries')\n        maturities = tf.convert_to_tensor(maturities, dtype=dtype, name='maturities')\n        is_call_options = tf.convert_to_tensor(is_call_options, dtype=tf.bool, name='is_call_options')\n        model = quasi_gaussian_hjm.QuasiGaussianHJM(dim, mean_reversion=mean_reversion, volatility=volatility, initial_discount_rate_fn=discount_rate_fn, corr_matrix=corr_matrix, dtype=dtype)\n\n        def sample_discount_curve_paths_fn(times, curve_times, num_samples):\n            (p_t_tau, r_t, _) = model.sample_discount_curve_paths(times=times, curve_times=curve_times, num_samples=num_samples, random_type=random_type, time_step=time_step, seed=seed, skip=skip)\n            p_t_tau = tf.expand_dims(p_t_tau, axis=-1)\n            r_t = tf.expand_dims(r_t, axis=-1)\n            return (p_t_tau, r_t)\n        prices = zero_coupon_bond_option_util.options_price_from_samples(strikes, expiries, maturities, is_call_options, sample_discount_curve_paths_fn, num_samples, time_step, dtype=dtype)\n        return tf.squeeze(prices, axis=-1)",
            "def bond_option_price(*, strikes: types.RealTensor, expiries: types.RealTensor, maturities: types.RealTensor, discount_rate_fn: Callable[..., types.RealTensor], dim: int, mean_reversion: types.RealTensor, volatility: Union[types.RealTensor, Callable[..., types.RealTensor]], corr_matrix: types.RealTensor=None, is_call_options: types.BoolTensor=True, num_samples: types.IntTensor=1, random_type: random.RandomType=None, seed: types.IntTensor=None, skip: types.IntTensor=0, time_step: types.RealTensor=None, dtype: tf.DType=None, name: str=None) -> types.RealTensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Calculates European bond option prices using the HJM model.\\n\\n  Bond options are fixed income securities which give the holder a right to\\n  exchange at a future date (the option expiry) a zero coupon bond for a fixed\\n  price (the strike of the option). The maturity date of the bond is after the\\n  the expiry of the option. If `P(t,T)` denotes the price at time `t` of a zero\\n  coupon bond with maturity `T`, then the payoff from the option at option\\n  expiry, `T0`, is given by:\\n\\n  ```None\\n  payoff = max(P(T0, T) - X, 0)\\n  ```\\n  where `X` is the strike price of the option.\\n\\n  #### Example\\n\\n  ````python\\n  import numpy as np\\n  import tensorflow.compat.v2 as tf\\n  import tf_quant_finance as tff\\n\\n  dtype = tf.float64\\n\\n  discount_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\\n  expiries = np.array([1.0])\\n  maturities = np.array([5.0])\\n  strikes = np.exp(-0.01 * maturities) / np.exp(-0.01 * expiries)\\n  price = tff.models.hjm.bond_option_price(\\n      strikes=strikes,\\n      expiries=expiries,\\n      maturities=maturities,\\n      dim=1,\\n      mean_reversion=[0.03],\\n      volatility=[0.02],\\n      discount_rate_fn=discount_rate_fn,\\n      dtype=dtype)\\n  # Expected value: [[0.02817777]]\\n  ````\\n\\n  Args:\\n    strikes: A real `Tensor` of any shape and dtype. The strike price of the\\n      options. The shape of this input determines the number (and shape) of the\\n      options to be priced and the output.\\n    expiries: A real `Tensor` of the same dtype and compatible shape as\\n      `strikes`.  The time to expiry of each bond option.\\n    maturities: A real `Tensor` of the same dtype and compatible shape as\\n      `strikes`.  The time to maturity of the underlying zero coupon bonds.\\n    discount_rate_fn: A Python callable that accepts expiry time as a real\\n      `Tensor` and returns a `Tensor` of shape `input_shape`. Computes the\\n      zero coupon bond yield at the present time for the input expiry time.\\n    dim: A Python scalar which corresponds to the number of factors within a\\n      single HJM model.\\n    mean_reversion: A real positive `Tensor` of shape `[dim]`. Corresponds to\\n      the mean reversion rate of each factor.\\n    volatility: A real positive `Tensor` of the same `dtype` and shape as\\n      `mean_reversion` or a callable with the following properties: (a)  The\\n        callable should accept a scalar `Tensor` `t` and a 1-D `Tensor` `r(t)`\\n        of shape `[num_samples]` and returns a 2-D `Tensor` of shape\\n        `[num_samples, dim]`. The variable `t`  stands for time and `r(t)` is\\n        the short rate at time `t`.  The function returns instantaneous\\n        volatility `sigma(t) = sigma(t, r(t))`. When `volatility` is specified\\n        is a real `Tensor`, each factor is assumed to have a constant\\n        instantaneous volatility  and the  model is effectively a Gaussian HJM\\n        model. Corresponds to the instantaneous volatility of each factor.\\n    corr_matrix: A `Tensor` of shape `[dim, dim]` and the same `dtype` as\\n      `mean_reversion`. Corresponds to the correlation matrix `Rho`.\\n      Default value: None, meaning the factors are uncorrelated.\\n    is_call_options: A boolean `Tensor` of a shape compatible with `strikes`.\\n      Indicates whether the option is a call (if True) or a put (if False). If\\n      not supplied, call options are assumed.\\n    num_samples: Positive scalar `int32` `Tensor`. The number of simulation\\n      paths during Monte-Carlo valuation.\\n      Default value: The default value is 1.\\n    random_type: Enum value of `RandomType`. The type of (quasi)-random number\\n      generator to use to generate the simulation paths.\\n      Default value: `None` which maps to the standard pseudo-random numbers.\\n    seed: Seed for the random number generator. The seed is only relevant if\\n      `random_type` is one of `[STATELESS, PSEUDO, HALTON_RANDOMIZED,\\n      PSEUDO_ANTITHETIC, STATELESS_ANTITHETIC]`. For `PSEUDO`,\\n      `PSEUDO_ANTITHETIC` and `HALTON_RANDOMIZED` the seed should be an Python\\n      integer. For `STATELESS` and  `STATELESS_ANTITHETIC `must be supplied as\\n      an integer `Tensor` of shape `[2]`.\\n      Default value: `None` which means no seed is set.\\n    skip: `int32` 0-d `Tensor`. The number of initial points of the Sobol or\\n      Halton sequence to skip. Used only when `random_type` is 'SOBOL',\\n      'HALTON', or 'HALTON_RANDOMIZED', otherwise ignored.\\n      Default value: `0`.\\n    time_step: Scalar real `Tensor`. Maximal distance between time grid points\\n      in Euler scheme. Relevant when Euler scheme is used for simulation.\\n      Default value: `None`.\\n    dtype: The default dtype to use when converting values to `Tensor`s.\\n      Default value: `None` which means that default dtypes inferred by\\n        TensorFlow are used.\\n    name: Python string. The name to give to the ops created by this class.\\n      Default value: `None` which maps to the default name\\n        `hw_bond_option_price`.\\n\\n  Returns:\\n    A `Tensor` of real dtype and shape  `strikes.shape` containing the\\n    computed option prices.\\n  \"\n    if time_step is None:\n        raise ValueError('`time_step` must be provided for simulation based bond option valuation.')\n    name = name or 'hjm_bond_option_price'\n    if dtype is None:\n        dtype = tf.convert_to_tensor([0.0]).dtype\n    with tf.name_scope(name):\n        strikes = tf.convert_to_tensor(strikes, dtype=dtype, name='strikes')\n        expiries = tf.convert_to_tensor(expiries, dtype=dtype, name='expiries')\n        maturities = tf.convert_to_tensor(maturities, dtype=dtype, name='maturities')\n        is_call_options = tf.convert_to_tensor(is_call_options, dtype=tf.bool, name='is_call_options')\n        model = quasi_gaussian_hjm.QuasiGaussianHJM(dim, mean_reversion=mean_reversion, volatility=volatility, initial_discount_rate_fn=discount_rate_fn, corr_matrix=corr_matrix, dtype=dtype)\n\n        def sample_discount_curve_paths_fn(times, curve_times, num_samples):\n            (p_t_tau, r_t, _) = model.sample_discount_curve_paths(times=times, curve_times=curve_times, num_samples=num_samples, random_type=random_type, time_step=time_step, seed=seed, skip=skip)\n            p_t_tau = tf.expand_dims(p_t_tau, axis=-1)\n            r_t = tf.expand_dims(r_t, axis=-1)\n            return (p_t_tau, r_t)\n        prices = zero_coupon_bond_option_util.options_price_from_samples(strikes, expiries, maturities, is_call_options, sample_discount_curve_paths_fn, num_samples, time_step, dtype=dtype)\n        return tf.squeeze(prices, axis=-1)",
            "def bond_option_price(*, strikes: types.RealTensor, expiries: types.RealTensor, maturities: types.RealTensor, discount_rate_fn: Callable[..., types.RealTensor], dim: int, mean_reversion: types.RealTensor, volatility: Union[types.RealTensor, Callable[..., types.RealTensor]], corr_matrix: types.RealTensor=None, is_call_options: types.BoolTensor=True, num_samples: types.IntTensor=1, random_type: random.RandomType=None, seed: types.IntTensor=None, skip: types.IntTensor=0, time_step: types.RealTensor=None, dtype: tf.DType=None, name: str=None) -> types.RealTensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Calculates European bond option prices using the HJM model.\\n\\n  Bond options are fixed income securities which give the holder a right to\\n  exchange at a future date (the option expiry) a zero coupon bond for a fixed\\n  price (the strike of the option). The maturity date of the bond is after the\\n  the expiry of the option. If `P(t,T)` denotes the price at time `t` of a zero\\n  coupon bond with maturity `T`, then the payoff from the option at option\\n  expiry, `T0`, is given by:\\n\\n  ```None\\n  payoff = max(P(T0, T) - X, 0)\\n  ```\\n  where `X` is the strike price of the option.\\n\\n  #### Example\\n\\n  ````python\\n  import numpy as np\\n  import tensorflow.compat.v2 as tf\\n  import tf_quant_finance as tff\\n\\n  dtype = tf.float64\\n\\n  discount_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\\n  expiries = np.array([1.0])\\n  maturities = np.array([5.0])\\n  strikes = np.exp(-0.01 * maturities) / np.exp(-0.01 * expiries)\\n  price = tff.models.hjm.bond_option_price(\\n      strikes=strikes,\\n      expiries=expiries,\\n      maturities=maturities,\\n      dim=1,\\n      mean_reversion=[0.03],\\n      volatility=[0.02],\\n      discount_rate_fn=discount_rate_fn,\\n      dtype=dtype)\\n  # Expected value: [[0.02817777]]\\n  ````\\n\\n  Args:\\n    strikes: A real `Tensor` of any shape and dtype. The strike price of the\\n      options. The shape of this input determines the number (and shape) of the\\n      options to be priced and the output.\\n    expiries: A real `Tensor` of the same dtype and compatible shape as\\n      `strikes`.  The time to expiry of each bond option.\\n    maturities: A real `Tensor` of the same dtype and compatible shape as\\n      `strikes`.  The time to maturity of the underlying zero coupon bonds.\\n    discount_rate_fn: A Python callable that accepts expiry time as a real\\n      `Tensor` and returns a `Tensor` of shape `input_shape`. Computes the\\n      zero coupon bond yield at the present time for the input expiry time.\\n    dim: A Python scalar which corresponds to the number of factors within a\\n      single HJM model.\\n    mean_reversion: A real positive `Tensor` of shape `[dim]`. Corresponds to\\n      the mean reversion rate of each factor.\\n    volatility: A real positive `Tensor` of the same `dtype` and shape as\\n      `mean_reversion` or a callable with the following properties: (a)  The\\n        callable should accept a scalar `Tensor` `t` and a 1-D `Tensor` `r(t)`\\n        of shape `[num_samples]` and returns a 2-D `Tensor` of shape\\n        `[num_samples, dim]`. The variable `t`  stands for time and `r(t)` is\\n        the short rate at time `t`.  The function returns instantaneous\\n        volatility `sigma(t) = sigma(t, r(t))`. When `volatility` is specified\\n        is a real `Tensor`, each factor is assumed to have a constant\\n        instantaneous volatility  and the  model is effectively a Gaussian HJM\\n        model. Corresponds to the instantaneous volatility of each factor.\\n    corr_matrix: A `Tensor` of shape `[dim, dim]` and the same `dtype` as\\n      `mean_reversion`. Corresponds to the correlation matrix `Rho`.\\n      Default value: None, meaning the factors are uncorrelated.\\n    is_call_options: A boolean `Tensor` of a shape compatible with `strikes`.\\n      Indicates whether the option is a call (if True) or a put (if False). If\\n      not supplied, call options are assumed.\\n    num_samples: Positive scalar `int32` `Tensor`. The number of simulation\\n      paths during Monte-Carlo valuation.\\n      Default value: The default value is 1.\\n    random_type: Enum value of `RandomType`. The type of (quasi)-random number\\n      generator to use to generate the simulation paths.\\n      Default value: `None` which maps to the standard pseudo-random numbers.\\n    seed: Seed for the random number generator. The seed is only relevant if\\n      `random_type` is one of `[STATELESS, PSEUDO, HALTON_RANDOMIZED,\\n      PSEUDO_ANTITHETIC, STATELESS_ANTITHETIC]`. For `PSEUDO`,\\n      `PSEUDO_ANTITHETIC` and `HALTON_RANDOMIZED` the seed should be an Python\\n      integer. For `STATELESS` and  `STATELESS_ANTITHETIC `must be supplied as\\n      an integer `Tensor` of shape `[2]`.\\n      Default value: `None` which means no seed is set.\\n    skip: `int32` 0-d `Tensor`. The number of initial points of the Sobol or\\n      Halton sequence to skip. Used only when `random_type` is 'SOBOL',\\n      'HALTON', or 'HALTON_RANDOMIZED', otherwise ignored.\\n      Default value: `0`.\\n    time_step: Scalar real `Tensor`. Maximal distance between time grid points\\n      in Euler scheme. Relevant when Euler scheme is used for simulation.\\n      Default value: `None`.\\n    dtype: The default dtype to use when converting values to `Tensor`s.\\n      Default value: `None` which means that default dtypes inferred by\\n        TensorFlow are used.\\n    name: Python string. The name to give to the ops created by this class.\\n      Default value: `None` which maps to the default name\\n        `hw_bond_option_price`.\\n\\n  Returns:\\n    A `Tensor` of real dtype and shape  `strikes.shape` containing the\\n    computed option prices.\\n  \"\n    if time_step is None:\n        raise ValueError('`time_step` must be provided for simulation based bond option valuation.')\n    name = name or 'hjm_bond_option_price'\n    if dtype is None:\n        dtype = tf.convert_to_tensor([0.0]).dtype\n    with tf.name_scope(name):\n        strikes = tf.convert_to_tensor(strikes, dtype=dtype, name='strikes')\n        expiries = tf.convert_to_tensor(expiries, dtype=dtype, name='expiries')\n        maturities = tf.convert_to_tensor(maturities, dtype=dtype, name='maturities')\n        is_call_options = tf.convert_to_tensor(is_call_options, dtype=tf.bool, name='is_call_options')\n        model = quasi_gaussian_hjm.QuasiGaussianHJM(dim, mean_reversion=mean_reversion, volatility=volatility, initial_discount_rate_fn=discount_rate_fn, corr_matrix=corr_matrix, dtype=dtype)\n\n        def sample_discount_curve_paths_fn(times, curve_times, num_samples):\n            (p_t_tau, r_t, _) = model.sample_discount_curve_paths(times=times, curve_times=curve_times, num_samples=num_samples, random_type=random_type, time_step=time_step, seed=seed, skip=skip)\n            p_t_tau = tf.expand_dims(p_t_tau, axis=-1)\n            r_t = tf.expand_dims(r_t, axis=-1)\n            return (p_t_tau, r_t)\n        prices = zero_coupon_bond_option_util.options_price_from_samples(strikes, expiries, maturities, is_call_options, sample_discount_curve_paths_fn, num_samples, time_step, dtype=dtype)\n        return tf.squeeze(prices, axis=-1)",
            "def bond_option_price(*, strikes: types.RealTensor, expiries: types.RealTensor, maturities: types.RealTensor, discount_rate_fn: Callable[..., types.RealTensor], dim: int, mean_reversion: types.RealTensor, volatility: Union[types.RealTensor, Callable[..., types.RealTensor]], corr_matrix: types.RealTensor=None, is_call_options: types.BoolTensor=True, num_samples: types.IntTensor=1, random_type: random.RandomType=None, seed: types.IntTensor=None, skip: types.IntTensor=0, time_step: types.RealTensor=None, dtype: tf.DType=None, name: str=None) -> types.RealTensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Calculates European bond option prices using the HJM model.\\n\\n  Bond options are fixed income securities which give the holder a right to\\n  exchange at a future date (the option expiry) a zero coupon bond for a fixed\\n  price (the strike of the option). The maturity date of the bond is after the\\n  the expiry of the option. If `P(t,T)` denotes the price at time `t` of a zero\\n  coupon bond with maturity `T`, then the payoff from the option at option\\n  expiry, `T0`, is given by:\\n\\n  ```None\\n  payoff = max(P(T0, T) - X, 0)\\n  ```\\n  where `X` is the strike price of the option.\\n\\n  #### Example\\n\\n  ````python\\n  import numpy as np\\n  import tensorflow.compat.v2 as tf\\n  import tf_quant_finance as tff\\n\\n  dtype = tf.float64\\n\\n  discount_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\\n  expiries = np.array([1.0])\\n  maturities = np.array([5.0])\\n  strikes = np.exp(-0.01 * maturities) / np.exp(-0.01 * expiries)\\n  price = tff.models.hjm.bond_option_price(\\n      strikes=strikes,\\n      expiries=expiries,\\n      maturities=maturities,\\n      dim=1,\\n      mean_reversion=[0.03],\\n      volatility=[0.02],\\n      discount_rate_fn=discount_rate_fn,\\n      dtype=dtype)\\n  # Expected value: [[0.02817777]]\\n  ````\\n\\n  Args:\\n    strikes: A real `Tensor` of any shape and dtype. The strike price of the\\n      options. The shape of this input determines the number (and shape) of the\\n      options to be priced and the output.\\n    expiries: A real `Tensor` of the same dtype and compatible shape as\\n      `strikes`.  The time to expiry of each bond option.\\n    maturities: A real `Tensor` of the same dtype and compatible shape as\\n      `strikes`.  The time to maturity of the underlying zero coupon bonds.\\n    discount_rate_fn: A Python callable that accepts expiry time as a real\\n      `Tensor` and returns a `Tensor` of shape `input_shape`. Computes the\\n      zero coupon bond yield at the present time for the input expiry time.\\n    dim: A Python scalar which corresponds to the number of factors within a\\n      single HJM model.\\n    mean_reversion: A real positive `Tensor` of shape `[dim]`. Corresponds to\\n      the mean reversion rate of each factor.\\n    volatility: A real positive `Tensor` of the same `dtype` and shape as\\n      `mean_reversion` or a callable with the following properties: (a)  The\\n        callable should accept a scalar `Tensor` `t` and a 1-D `Tensor` `r(t)`\\n        of shape `[num_samples]` and returns a 2-D `Tensor` of shape\\n        `[num_samples, dim]`. The variable `t`  stands for time and `r(t)` is\\n        the short rate at time `t`.  The function returns instantaneous\\n        volatility `sigma(t) = sigma(t, r(t))`. When `volatility` is specified\\n        is a real `Tensor`, each factor is assumed to have a constant\\n        instantaneous volatility  and the  model is effectively a Gaussian HJM\\n        model. Corresponds to the instantaneous volatility of each factor.\\n    corr_matrix: A `Tensor` of shape `[dim, dim]` and the same `dtype` as\\n      `mean_reversion`. Corresponds to the correlation matrix `Rho`.\\n      Default value: None, meaning the factors are uncorrelated.\\n    is_call_options: A boolean `Tensor` of a shape compatible with `strikes`.\\n      Indicates whether the option is a call (if True) or a put (if False). If\\n      not supplied, call options are assumed.\\n    num_samples: Positive scalar `int32` `Tensor`. The number of simulation\\n      paths during Monte-Carlo valuation.\\n      Default value: The default value is 1.\\n    random_type: Enum value of `RandomType`. The type of (quasi)-random number\\n      generator to use to generate the simulation paths.\\n      Default value: `None` which maps to the standard pseudo-random numbers.\\n    seed: Seed for the random number generator. The seed is only relevant if\\n      `random_type` is one of `[STATELESS, PSEUDO, HALTON_RANDOMIZED,\\n      PSEUDO_ANTITHETIC, STATELESS_ANTITHETIC]`. For `PSEUDO`,\\n      `PSEUDO_ANTITHETIC` and `HALTON_RANDOMIZED` the seed should be an Python\\n      integer. For `STATELESS` and  `STATELESS_ANTITHETIC `must be supplied as\\n      an integer `Tensor` of shape `[2]`.\\n      Default value: `None` which means no seed is set.\\n    skip: `int32` 0-d `Tensor`. The number of initial points of the Sobol or\\n      Halton sequence to skip. Used only when `random_type` is 'SOBOL',\\n      'HALTON', or 'HALTON_RANDOMIZED', otherwise ignored.\\n      Default value: `0`.\\n    time_step: Scalar real `Tensor`. Maximal distance between time grid points\\n      in Euler scheme. Relevant when Euler scheme is used for simulation.\\n      Default value: `None`.\\n    dtype: The default dtype to use when converting values to `Tensor`s.\\n      Default value: `None` which means that default dtypes inferred by\\n        TensorFlow are used.\\n    name: Python string. The name to give to the ops created by this class.\\n      Default value: `None` which maps to the default name\\n        `hw_bond_option_price`.\\n\\n  Returns:\\n    A `Tensor` of real dtype and shape  `strikes.shape` containing the\\n    computed option prices.\\n  \"\n    if time_step is None:\n        raise ValueError('`time_step` must be provided for simulation based bond option valuation.')\n    name = name or 'hjm_bond_option_price'\n    if dtype is None:\n        dtype = tf.convert_to_tensor([0.0]).dtype\n    with tf.name_scope(name):\n        strikes = tf.convert_to_tensor(strikes, dtype=dtype, name='strikes')\n        expiries = tf.convert_to_tensor(expiries, dtype=dtype, name='expiries')\n        maturities = tf.convert_to_tensor(maturities, dtype=dtype, name='maturities')\n        is_call_options = tf.convert_to_tensor(is_call_options, dtype=tf.bool, name='is_call_options')\n        model = quasi_gaussian_hjm.QuasiGaussianHJM(dim, mean_reversion=mean_reversion, volatility=volatility, initial_discount_rate_fn=discount_rate_fn, corr_matrix=corr_matrix, dtype=dtype)\n\n        def sample_discount_curve_paths_fn(times, curve_times, num_samples):\n            (p_t_tau, r_t, _) = model.sample_discount_curve_paths(times=times, curve_times=curve_times, num_samples=num_samples, random_type=random_type, time_step=time_step, seed=seed, skip=skip)\n            p_t_tau = tf.expand_dims(p_t_tau, axis=-1)\n            r_t = tf.expand_dims(r_t, axis=-1)\n            return (p_t_tau, r_t)\n        prices = zero_coupon_bond_option_util.options_price_from_samples(strikes, expiries, maturities, is_call_options, sample_discount_curve_paths_fn, num_samples, time_step, dtype=dtype)\n        return tf.squeeze(prices, axis=-1)"
        ]
    }
]