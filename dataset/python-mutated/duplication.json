[
    {
        "func_name": "partial_duplication_graph",
        "original": "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef partial_duplication_graph(N, n, p, q, seed=None):\n    \"\"\"Returns a random graph using the partial duplication model.\n\n    Parameters\n    ----------\n    N : int\n        The total number of nodes in the final graph.\n\n    n : int\n        The number of nodes in the initial clique.\n\n    p : float\n        The probability of joining each neighbor of a node to the\n        duplicate node. Must be a number in the between zero and one,\n        inclusive.\n\n    q : float\n        The probability of joining the source node to the duplicate\n        node. Must be a number in the between zero and one, inclusive.\n\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Notes\n    -----\n    A graph of nodes is grown by creating a fully connected graph\n    of size `n`. The following procedure is then repeated until\n    a total of `N` nodes have been reached.\n\n    1. A random node, *u*, is picked and a new node, *v*, is created.\n    2. For each neighbor of *u* an edge from the neighbor to *v* is created\n       with probability `p`.\n    3. An edge from *u* to *v* is created with probability `q`.\n\n    This algorithm appears in [1].\n\n    This implementation allows the possibility of generating\n    disconnected graphs.\n\n    References\n    ----------\n    .. [1] Knudsen Michael, and Carsten Wiuf. \"A Markov chain approach to\n           randomly grown graphs.\" Journal of Applied Mathematics 2008.\n           <https://doi.org/10.1155/2008/190836>\n\n    \"\"\"\n    if p < 0 or p > 1 or q < 0 or (q > 1):\n        msg = 'partial duplication graph must have 0 <= p, q <= 1.'\n        raise NetworkXError(msg)\n    if n > N:\n        raise NetworkXError('partial duplication graph must have n <= N.')\n    G = nx.complete_graph(n)\n    for new_node in range(n, N):\n        src_node = seed.randint(0, new_node - 1)\n        G.add_node(new_node)\n        for neighbor_node in list(nx.all_neighbors(G, src_node)):\n            if seed.random() < p:\n                G.add_edge(new_node, neighbor_node)\n        if seed.random() < q:\n            G.add_edge(new_node, src_node)\n    return G",
        "mutated": [
            "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef partial_duplication_graph(N, n, p, q, seed=None):\n    if False:\n        i = 10\n    'Returns a random graph using the partial duplication model.\\n\\n    Parameters\\n    ----------\\n    N : int\\n        The total number of nodes in the final graph.\\n\\n    n : int\\n        The number of nodes in the initial clique.\\n\\n    p : float\\n        The probability of joining each neighbor of a node to the\\n        duplicate node. Must be a number in the between zero and one,\\n        inclusive.\\n\\n    q : float\\n        The probability of joining the source node to the duplicate\\n        node. Must be a number in the between zero and one, inclusive.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    A graph of nodes is grown by creating a fully connected graph\\n    of size `n`. The following procedure is then repeated until\\n    a total of `N` nodes have been reached.\\n\\n    1. A random node, *u*, is picked and a new node, *v*, is created.\\n    2. For each neighbor of *u* an edge from the neighbor to *v* is created\\n       with probability `p`.\\n    3. An edge from *u* to *v* is created with probability `q`.\\n\\n    This algorithm appears in [1].\\n\\n    This implementation allows the possibility of generating\\n    disconnected graphs.\\n\\n    References\\n    ----------\\n    .. [1] Knudsen Michael, and Carsten Wiuf. \"A Markov chain approach to\\n           randomly grown graphs.\" Journal of Applied Mathematics 2008.\\n           <https://doi.org/10.1155/2008/190836>\\n\\n    '\n    if p < 0 or p > 1 or q < 0 or (q > 1):\n        msg = 'partial duplication graph must have 0 <= p, q <= 1.'\n        raise NetworkXError(msg)\n    if n > N:\n        raise NetworkXError('partial duplication graph must have n <= N.')\n    G = nx.complete_graph(n)\n    for new_node in range(n, N):\n        src_node = seed.randint(0, new_node - 1)\n        G.add_node(new_node)\n        for neighbor_node in list(nx.all_neighbors(G, src_node)):\n            if seed.random() < p:\n                G.add_edge(new_node, neighbor_node)\n        if seed.random() < q:\n            G.add_edge(new_node, src_node)\n    return G",
            "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef partial_duplication_graph(N, n, p, q, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a random graph using the partial duplication model.\\n\\n    Parameters\\n    ----------\\n    N : int\\n        The total number of nodes in the final graph.\\n\\n    n : int\\n        The number of nodes in the initial clique.\\n\\n    p : float\\n        The probability of joining each neighbor of a node to the\\n        duplicate node. Must be a number in the between zero and one,\\n        inclusive.\\n\\n    q : float\\n        The probability of joining the source node to the duplicate\\n        node. Must be a number in the between zero and one, inclusive.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    A graph of nodes is grown by creating a fully connected graph\\n    of size `n`. The following procedure is then repeated until\\n    a total of `N` nodes have been reached.\\n\\n    1. A random node, *u*, is picked and a new node, *v*, is created.\\n    2. For each neighbor of *u* an edge from the neighbor to *v* is created\\n       with probability `p`.\\n    3. An edge from *u* to *v* is created with probability `q`.\\n\\n    This algorithm appears in [1].\\n\\n    This implementation allows the possibility of generating\\n    disconnected graphs.\\n\\n    References\\n    ----------\\n    .. [1] Knudsen Michael, and Carsten Wiuf. \"A Markov chain approach to\\n           randomly grown graphs.\" Journal of Applied Mathematics 2008.\\n           <https://doi.org/10.1155/2008/190836>\\n\\n    '\n    if p < 0 or p > 1 or q < 0 or (q > 1):\n        msg = 'partial duplication graph must have 0 <= p, q <= 1.'\n        raise NetworkXError(msg)\n    if n > N:\n        raise NetworkXError('partial duplication graph must have n <= N.')\n    G = nx.complete_graph(n)\n    for new_node in range(n, N):\n        src_node = seed.randint(0, new_node - 1)\n        G.add_node(new_node)\n        for neighbor_node in list(nx.all_neighbors(G, src_node)):\n            if seed.random() < p:\n                G.add_edge(new_node, neighbor_node)\n        if seed.random() < q:\n            G.add_edge(new_node, src_node)\n    return G",
            "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef partial_duplication_graph(N, n, p, q, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a random graph using the partial duplication model.\\n\\n    Parameters\\n    ----------\\n    N : int\\n        The total number of nodes in the final graph.\\n\\n    n : int\\n        The number of nodes in the initial clique.\\n\\n    p : float\\n        The probability of joining each neighbor of a node to the\\n        duplicate node. Must be a number in the between zero and one,\\n        inclusive.\\n\\n    q : float\\n        The probability of joining the source node to the duplicate\\n        node. Must be a number in the between zero and one, inclusive.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    A graph of nodes is grown by creating a fully connected graph\\n    of size `n`. The following procedure is then repeated until\\n    a total of `N` nodes have been reached.\\n\\n    1. A random node, *u*, is picked and a new node, *v*, is created.\\n    2. For each neighbor of *u* an edge from the neighbor to *v* is created\\n       with probability `p`.\\n    3. An edge from *u* to *v* is created with probability `q`.\\n\\n    This algorithm appears in [1].\\n\\n    This implementation allows the possibility of generating\\n    disconnected graphs.\\n\\n    References\\n    ----------\\n    .. [1] Knudsen Michael, and Carsten Wiuf. \"A Markov chain approach to\\n           randomly grown graphs.\" Journal of Applied Mathematics 2008.\\n           <https://doi.org/10.1155/2008/190836>\\n\\n    '\n    if p < 0 or p > 1 or q < 0 or (q > 1):\n        msg = 'partial duplication graph must have 0 <= p, q <= 1.'\n        raise NetworkXError(msg)\n    if n > N:\n        raise NetworkXError('partial duplication graph must have n <= N.')\n    G = nx.complete_graph(n)\n    for new_node in range(n, N):\n        src_node = seed.randint(0, new_node - 1)\n        G.add_node(new_node)\n        for neighbor_node in list(nx.all_neighbors(G, src_node)):\n            if seed.random() < p:\n                G.add_edge(new_node, neighbor_node)\n        if seed.random() < q:\n            G.add_edge(new_node, src_node)\n    return G",
            "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef partial_duplication_graph(N, n, p, q, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a random graph using the partial duplication model.\\n\\n    Parameters\\n    ----------\\n    N : int\\n        The total number of nodes in the final graph.\\n\\n    n : int\\n        The number of nodes in the initial clique.\\n\\n    p : float\\n        The probability of joining each neighbor of a node to the\\n        duplicate node. Must be a number in the between zero and one,\\n        inclusive.\\n\\n    q : float\\n        The probability of joining the source node to the duplicate\\n        node. Must be a number in the between zero and one, inclusive.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    A graph of nodes is grown by creating a fully connected graph\\n    of size `n`. The following procedure is then repeated until\\n    a total of `N` nodes have been reached.\\n\\n    1. A random node, *u*, is picked and a new node, *v*, is created.\\n    2. For each neighbor of *u* an edge from the neighbor to *v* is created\\n       with probability `p`.\\n    3. An edge from *u* to *v* is created with probability `q`.\\n\\n    This algorithm appears in [1].\\n\\n    This implementation allows the possibility of generating\\n    disconnected graphs.\\n\\n    References\\n    ----------\\n    .. [1] Knudsen Michael, and Carsten Wiuf. \"A Markov chain approach to\\n           randomly grown graphs.\" Journal of Applied Mathematics 2008.\\n           <https://doi.org/10.1155/2008/190836>\\n\\n    '\n    if p < 0 or p > 1 or q < 0 or (q > 1):\n        msg = 'partial duplication graph must have 0 <= p, q <= 1.'\n        raise NetworkXError(msg)\n    if n > N:\n        raise NetworkXError('partial duplication graph must have n <= N.')\n    G = nx.complete_graph(n)\n    for new_node in range(n, N):\n        src_node = seed.randint(0, new_node - 1)\n        G.add_node(new_node)\n        for neighbor_node in list(nx.all_neighbors(G, src_node)):\n            if seed.random() < p:\n                G.add_edge(new_node, neighbor_node)\n        if seed.random() < q:\n            G.add_edge(new_node, src_node)\n    return G",
            "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef partial_duplication_graph(N, n, p, q, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a random graph using the partial duplication model.\\n\\n    Parameters\\n    ----------\\n    N : int\\n        The total number of nodes in the final graph.\\n\\n    n : int\\n        The number of nodes in the initial clique.\\n\\n    p : float\\n        The probability of joining each neighbor of a node to the\\n        duplicate node. Must be a number in the between zero and one,\\n        inclusive.\\n\\n    q : float\\n        The probability of joining the source node to the duplicate\\n        node. Must be a number in the between zero and one, inclusive.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Notes\\n    -----\\n    A graph of nodes is grown by creating a fully connected graph\\n    of size `n`. The following procedure is then repeated until\\n    a total of `N` nodes have been reached.\\n\\n    1. A random node, *u*, is picked and a new node, *v*, is created.\\n    2. For each neighbor of *u* an edge from the neighbor to *v* is created\\n       with probability `p`.\\n    3. An edge from *u* to *v* is created with probability `q`.\\n\\n    This algorithm appears in [1].\\n\\n    This implementation allows the possibility of generating\\n    disconnected graphs.\\n\\n    References\\n    ----------\\n    .. [1] Knudsen Michael, and Carsten Wiuf. \"A Markov chain approach to\\n           randomly grown graphs.\" Journal of Applied Mathematics 2008.\\n           <https://doi.org/10.1155/2008/190836>\\n\\n    '\n    if p < 0 or p > 1 or q < 0 or (q > 1):\n        msg = 'partial duplication graph must have 0 <= p, q <= 1.'\n        raise NetworkXError(msg)\n    if n > N:\n        raise NetworkXError('partial duplication graph must have n <= N.')\n    G = nx.complete_graph(n)\n    for new_node in range(n, N):\n        src_node = seed.randint(0, new_node - 1)\n        G.add_node(new_node)\n        for neighbor_node in list(nx.all_neighbors(G, src_node)):\n            if seed.random() < p:\n                G.add_edge(new_node, neighbor_node)\n        if seed.random() < q:\n            G.add_edge(new_node, src_node)\n    return G"
        ]
    },
    {
        "func_name": "duplication_divergence_graph",
        "original": "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef duplication_divergence_graph(n, p, seed=None):\n    \"\"\"Returns an undirected graph using the duplication-divergence model.\n\n    A graph of `n` nodes is created by duplicating the initial nodes\n    and retaining edges incident to the original nodes with a retention\n    probability `p`.\n\n    Parameters\n    ----------\n    n : int\n        The desired number of nodes in the graph.\n    p : float\n        The probability for retaining the edge of the replicated node.\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Returns\n    -------\n    G : Graph\n\n    Raises\n    ------\n    NetworkXError\n        If `p` is not a valid probability.\n        If `n` is less than 2.\n\n    Notes\n    -----\n    This algorithm appears in [1].\n\n    This implementation disallows the possibility of generating\n    disconnected graphs.\n\n    References\n    ----------\n    .. [1] I. Ispolatov, P. L. Krapivsky, A. Yuryev,\n       \"Duplication-divergence model of protein interaction network\",\n       Phys. Rev. E, 71, 061911, 2005.\n\n    \"\"\"\n    if p > 1 or p < 0:\n        msg = f'NetworkXError p={p} is not in [0,1].'\n        raise nx.NetworkXError(msg)\n    if n < 2:\n        msg = 'n must be greater than or equal to 2'\n        raise nx.NetworkXError(msg)\n    G = nx.Graph()\n    G.add_edge(0, 1)\n    i = 2\n    while i < n:\n        random_node = seed.choice(list(G))\n        G.add_node(i)\n        flag = False\n        for nbr in G.neighbors(random_node):\n            if seed.random() < p:\n                G.add_edge(i, nbr)\n                flag = True\n        if not flag:\n            G.remove_node(i)\n        else:\n            i += 1\n    return G",
        "mutated": [
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef duplication_divergence_graph(n, p, seed=None):\n    if False:\n        i = 10\n    'Returns an undirected graph using the duplication-divergence model.\\n\\n    A graph of `n` nodes is created by duplicating the initial nodes\\n    and retaining edges incident to the original nodes with a retention\\n    probability `p`.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The desired number of nodes in the graph.\\n    p : float\\n        The probability for retaining the edge of the replicated node.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `p` is not a valid probability.\\n        If `n` is less than 2.\\n\\n    Notes\\n    -----\\n    This algorithm appears in [1].\\n\\n    This implementation disallows the possibility of generating\\n    disconnected graphs.\\n\\n    References\\n    ----------\\n    .. [1] I. Ispolatov, P. L. Krapivsky, A. Yuryev,\\n       \"Duplication-divergence model of protein interaction network\",\\n       Phys. Rev. E, 71, 061911, 2005.\\n\\n    '\n    if p > 1 or p < 0:\n        msg = f'NetworkXError p={p} is not in [0,1].'\n        raise nx.NetworkXError(msg)\n    if n < 2:\n        msg = 'n must be greater than or equal to 2'\n        raise nx.NetworkXError(msg)\n    G = nx.Graph()\n    G.add_edge(0, 1)\n    i = 2\n    while i < n:\n        random_node = seed.choice(list(G))\n        G.add_node(i)\n        flag = False\n        for nbr in G.neighbors(random_node):\n            if seed.random() < p:\n                G.add_edge(i, nbr)\n                flag = True\n        if not flag:\n            G.remove_node(i)\n        else:\n            i += 1\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef duplication_divergence_graph(n, p, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns an undirected graph using the duplication-divergence model.\\n\\n    A graph of `n` nodes is created by duplicating the initial nodes\\n    and retaining edges incident to the original nodes with a retention\\n    probability `p`.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The desired number of nodes in the graph.\\n    p : float\\n        The probability for retaining the edge of the replicated node.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `p` is not a valid probability.\\n        If `n` is less than 2.\\n\\n    Notes\\n    -----\\n    This algorithm appears in [1].\\n\\n    This implementation disallows the possibility of generating\\n    disconnected graphs.\\n\\n    References\\n    ----------\\n    .. [1] I. Ispolatov, P. L. Krapivsky, A. Yuryev,\\n       \"Duplication-divergence model of protein interaction network\",\\n       Phys. Rev. E, 71, 061911, 2005.\\n\\n    '\n    if p > 1 or p < 0:\n        msg = f'NetworkXError p={p} is not in [0,1].'\n        raise nx.NetworkXError(msg)\n    if n < 2:\n        msg = 'n must be greater than or equal to 2'\n        raise nx.NetworkXError(msg)\n    G = nx.Graph()\n    G.add_edge(0, 1)\n    i = 2\n    while i < n:\n        random_node = seed.choice(list(G))\n        G.add_node(i)\n        flag = False\n        for nbr in G.neighbors(random_node):\n            if seed.random() < p:\n                G.add_edge(i, nbr)\n                flag = True\n        if not flag:\n            G.remove_node(i)\n        else:\n            i += 1\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef duplication_divergence_graph(n, p, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns an undirected graph using the duplication-divergence model.\\n\\n    A graph of `n` nodes is created by duplicating the initial nodes\\n    and retaining edges incident to the original nodes with a retention\\n    probability `p`.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The desired number of nodes in the graph.\\n    p : float\\n        The probability for retaining the edge of the replicated node.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `p` is not a valid probability.\\n        If `n` is less than 2.\\n\\n    Notes\\n    -----\\n    This algorithm appears in [1].\\n\\n    This implementation disallows the possibility of generating\\n    disconnected graphs.\\n\\n    References\\n    ----------\\n    .. [1] I. Ispolatov, P. L. Krapivsky, A. Yuryev,\\n       \"Duplication-divergence model of protein interaction network\",\\n       Phys. Rev. E, 71, 061911, 2005.\\n\\n    '\n    if p > 1 or p < 0:\n        msg = f'NetworkXError p={p} is not in [0,1].'\n        raise nx.NetworkXError(msg)\n    if n < 2:\n        msg = 'n must be greater than or equal to 2'\n        raise nx.NetworkXError(msg)\n    G = nx.Graph()\n    G.add_edge(0, 1)\n    i = 2\n    while i < n:\n        random_node = seed.choice(list(G))\n        G.add_node(i)\n        flag = False\n        for nbr in G.neighbors(random_node):\n            if seed.random() < p:\n                G.add_edge(i, nbr)\n                flag = True\n        if not flag:\n            G.remove_node(i)\n        else:\n            i += 1\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef duplication_divergence_graph(n, p, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns an undirected graph using the duplication-divergence model.\\n\\n    A graph of `n` nodes is created by duplicating the initial nodes\\n    and retaining edges incident to the original nodes with a retention\\n    probability `p`.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The desired number of nodes in the graph.\\n    p : float\\n        The probability for retaining the edge of the replicated node.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `p` is not a valid probability.\\n        If `n` is less than 2.\\n\\n    Notes\\n    -----\\n    This algorithm appears in [1].\\n\\n    This implementation disallows the possibility of generating\\n    disconnected graphs.\\n\\n    References\\n    ----------\\n    .. [1] I. Ispolatov, P. L. Krapivsky, A. Yuryev,\\n       \"Duplication-divergence model of protein interaction network\",\\n       Phys. Rev. E, 71, 061911, 2005.\\n\\n    '\n    if p > 1 or p < 0:\n        msg = f'NetworkXError p={p} is not in [0,1].'\n        raise nx.NetworkXError(msg)\n    if n < 2:\n        msg = 'n must be greater than or equal to 2'\n        raise nx.NetworkXError(msg)\n    G = nx.Graph()\n    G.add_edge(0, 1)\n    i = 2\n    while i < n:\n        random_node = seed.choice(list(G))\n        G.add_node(i)\n        flag = False\n        for nbr in G.neighbors(random_node):\n            if seed.random() < p:\n                G.add_edge(i, nbr)\n                flag = True\n        if not flag:\n            G.remove_node(i)\n        else:\n            i += 1\n    return G",
            "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef duplication_divergence_graph(n, p, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns an undirected graph using the duplication-divergence model.\\n\\n    A graph of `n` nodes is created by duplicating the initial nodes\\n    and retaining edges incident to the original nodes with a retention\\n    probability `p`.\\n\\n    Parameters\\n    ----------\\n    n : int\\n        The desired number of nodes in the graph.\\n    p : float\\n        The probability for retaining the edge of the replicated node.\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If `p` is not a valid probability.\\n        If `n` is less than 2.\\n\\n    Notes\\n    -----\\n    This algorithm appears in [1].\\n\\n    This implementation disallows the possibility of generating\\n    disconnected graphs.\\n\\n    References\\n    ----------\\n    .. [1] I. Ispolatov, P. L. Krapivsky, A. Yuryev,\\n       \"Duplication-divergence model of protein interaction network\",\\n       Phys. Rev. E, 71, 061911, 2005.\\n\\n    '\n    if p > 1 or p < 0:\n        msg = f'NetworkXError p={p} is not in [0,1].'\n        raise nx.NetworkXError(msg)\n    if n < 2:\n        msg = 'n must be greater than or equal to 2'\n        raise nx.NetworkXError(msg)\n    G = nx.Graph()\n    G.add_edge(0, 1)\n    i = 2\n    while i < n:\n        random_node = seed.choice(list(G))\n        G.add_node(i)\n        flag = False\n        for nbr in G.neighbors(random_node):\n            if seed.random() < p:\n                G.add_edge(i, nbr)\n                flag = True\n        if not flag:\n            G.remove_node(i)\n        else:\n            i += 1\n    return G"
        ]
    }
]