[
    {
        "func_name": "__virtual__",
        "original": "def __virtual__():\n    \"\"\"\n    Confirm this module is on a RPM based system, and has required utilities\n    \"\"\"\n    missing_util = False\n    utils_reqd = ['gpg', 'rpm', 'rpmbuild', 'mock', 'createrepo']\n    for named_util in utils_reqd:\n        if not salt.utils.path.which(named_util):\n            missing_util = True\n            break\n    if HAS_LIBS and (not missing_util):\n        if __grains__.get('os_family', False) in ('RedHat', 'Suse'):\n            return __virtualname__\n        else:\n            return 'rpmbuild'\n    else:\n        return (False, 'The rpmbuild module could not be loaded: requires python-gnupg, gpg, rpm, rpmbuild, mock and createrepo utilities to be installed')",
        "mutated": [
            "def __virtual__():\n    if False:\n        i = 10\n    '\\n    Confirm this module is on a RPM based system, and has required utilities\\n    '\n    missing_util = False\n    utils_reqd = ['gpg', 'rpm', 'rpmbuild', 'mock', 'createrepo']\n    for named_util in utils_reqd:\n        if not salt.utils.path.which(named_util):\n            missing_util = True\n            break\n    if HAS_LIBS and (not missing_util):\n        if __grains__.get('os_family', False) in ('RedHat', 'Suse'):\n            return __virtualname__\n        else:\n            return 'rpmbuild'\n    else:\n        return (False, 'The rpmbuild module could not be loaded: requires python-gnupg, gpg, rpm, rpmbuild, mock and createrepo utilities to be installed')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Confirm this module is on a RPM based system, and has required utilities\\n    '\n    missing_util = False\n    utils_reqd = ['gpg', 'rpm', 'rpmbuild', 'mock', 'createrepo']\n    for named_util in utils_reqd:\n        if not salt.utils.path.which(named_util):\n            missing_util = True\n            break\n    if HAS_LIBS and (not missing_util):\n        if __grains__.get('os_family', False) in ('RedHat', 'Suse'):\n            return __virtualname__\n        else:\n            return 'rpmbuild'\n    else:\n        return (False, 'The rpmbuild module could not be loaded: requires python-gnupg, gpg, rpm, rpmbuild, mock and createrepo utilities to be installed')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Confirm this module is on a RPM based system, and has required utilities\\n    '\n    missing_util = False\n    utils_reqd = ['gpg', 'rpm', 'rpmbuild', 'mock', 'createrepo']\n    for named_util in utils_reqd:\n        if not salt.utils.path.which(named_util):\n            missing_util = True\n            break\n    if HAS_LIBS and (not missing_util):\n        if __grains__.get('os_family', False) in ('RedHat', 'Suse'):\n            return __virtualname__\n        else:\n            return 'rpmbuild'\n    else:\n        return (False, 'The rpmbuild module could not be loaded: requires python-gnupg, gpg, rpm, rpmbuild, mock and createrepo utilities to be installed')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Confirm this module is on a RPM based system, and has required utilities\\n    '\n    missing_util = False\n    utils_reqd = ['gpg', 'rpm', 'rpmbuild', 'mock', 'createrepo']\n    for named_util in utils_reqd:\n        if not salt.utils.path.which(named_util):\n            missing_util = True\n            break\n    if HAS_LIBS and (not missing_util):\n        if __grains__.get('os_family', False) in ('RedHat', 'Suse'):\n            return __virtualname__\n        else:\n            return 'rpmbuild'\n    else:\n        return (False, 'The rpmbuild module could not be loaded: requires python-gnupg, gpg, rpm, rpmbuild, mock and createrepo utilities to be installed')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Confirm this module is on a RPM based system, and has required utilities\\n    '\n    missing_util = False\n    utils_reqd = ['gpg', 'rpm', 'rpmbuild', 'mock', 'createrepo']\n    for named_util in utils_reqd:\n        if not salt.utils.path.which(named_util):\n            missing_util = True\n            break\n    if HAS_LIBS and (not missing_util):\n        if __grains__.get('os_family', False) in ('RedHat', 'Suse'):\n            return __virtualname__\n        else:\n            return 'rpmbuild'\n    else:\n        return (False, 'The rpmbuild module could not be loaded: requires python-gnupg, gpg, rpm, rpmbuild, mock and createrepo utilities to be installed')"
        ]
    },
    {
        "func_name": "_create_rpmmacros",
        "original": "def _create_rpmmacros(runas='root'):\n    \"\"\"\n    Create the .rpmmacros file in user's home directory\n    \"\"\"\n    home = os.path.expanduser('~' + runas)\n    rpmbuilddir = os.path.join(home, 'rpmbuild')\n    if not os.path.isdir(rpmbuilddir):\n        __salt__['file.makedirs_perms'](name=rpmbuilddir, user=runas, group='mock')\n    mockdir = os.path.join(home, 'mock')\n    if not os.path.isdir(mockdir):\n        __salt__['file.makedirs_perms'](name=mockdir, user=runas, group='mock')\n    rpmmacros = os.path.join(home, '.rpmmacros')\n    with salt.utils.files.fopen(rpmmacros, 'w') as afile:\n        afile.write(salt.utils.stringutils.to_str('%_topdir {}\\n'.format(rpmbuilddir)))\n        afile.write('%signature gpg\\n')\n        afile.write('%_source_filedigest_algorithm 8\\n')\n        afile.write('%_binary_filedigest_algorithm 8\\n')\n        afile.write('%_gpg_name packaging@saltstack.com\\n')",
        "mutated": [
            "def _create_rpmmacros(runas='root'):\n    if False:\n        i = 10\n    \"\\n    Create the .rpmmacros file in user's home directory\\n    \"\n    home = os.path.expanduser('~' + runas)\n    rpmbuilddir = os.path.join(home, 'rpmbuild')\n    if not os.path.isdir(rpmbuilddir):\n        __salt__['file.makedirs_perms'](name=rpmbuilddir, user=runas, group='mock')\n    mockdir = os.path.join(home, 'mock')\n    if not os.path.isdir(mockdir):\n        __salt__['file.makedirs_perms'](name=mockdir, user=runas, group='mock')\n    rpmmacros = os.path.join(home, '.rpmmacros')\n    with salt.utils.files.fopen(rpmmacros, 'w') as afile:\n        afile.write(salt.utils.stringutils.to_str('%_topdir {}\\n'.format(rpmbuilddir)))\n        afile.write('%signature gpg\\n')\n        afile.write('%_source_filedigest_algorithm 8\\n')\n        afile.write('%_binary_filedigest_algorithm 8\\n')\n        afile.write('%_gpg_name packaging@saltstack.com\\n')",
            "def _create_rpmmacros(runas='root'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Create the .rpmmacros file in user's home directory\\n    \"\n    home = os.path.expanduser('~' + runas)\n    rpmbuilddir = os.path.join(home, 'rpmbuild')\n    if not os.path.isdir(rpmbuilddir):\n        __salt__['file.makedirs_perms'](name=rpmbuilddir, user=runas, group='mock')\n    mockdir = os.path.join(home, 'mock')\n    if not os.path.isdir(mockdir):\n        __salt__['file.makedirs_perms'](name=mockdir, user=runas, group='mock')\n    rpmmacros = os.path.join(home, '.rpmmacros')\n    with salt.utils.files.fopen(rpmmacros, 'w') as afile:\n        afile.write(salt.utils.stringutils.to_str('%_topdir {}\\n'.format(rpmbuilddir)))\n        afile.write('%signature gpg\\n')\n        afile.write('%_source_filedigest_algorithm 8\\n')\n        afile.write('%_binary_filedigest_algorithm 8\\n')\n        afile.write('%_gpg_name packaging@saltstack.com\\n')",
            "def _create_rpmmacros(runas='root'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Create the .rpmmacros file in user's home directory\\n    \"\n    home = os.path.expanduser('~' + runas)\n    rpmbuilddir = os.path.join(home, 'rpmbuild')\n    if not os.path.isdir(rpmbuilddir):\n        __salt__['file.makedirs_perms'](name=rpmbuilddir, user=runas, group='mock')\n    mockdir = os.path.join(home, 'mock')\n    if not os.path.isdir(mockdir):\n        __salt__['file.makedirs_perms'](name=mockdir, user=runas, group='mock')\n    rpmmacros = os.path.join(home, '.rpmmacros')\n    with salt.utils.files.fopen(rpmmacros, 'w') as afile:\n        afile.write(salt.utils.stringutils.to_str('%_topdir {}\\n'.format(rpmbuilddir)))\n        afile.write('%signature gpg\\n')\n        afile.write('%_source_filedigest_algorithm 8\\n')\n        afile.write('%_binary_filedigest_algorithm 8\\n')\n        afile.write('%_gpg_name packaging@saltstack.com\\n')",
            "def _create_rpmmacros(runas='root'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Create the .rpmmacros file in user's home directory\\n    \"\n    home = os.path.expanduser('~' + runas)\n    rpmbuilddir = os.path.join(home, 'rpmbuild')\n    if not os.path.isdir(rpmbuilddir):\n        __salt__['file.makedirs_perms'](name=rpmbuilddir, user=runas, group='mock')\n    mockdir = os.path.join(home, 'mock')\n    if not os.path.isdir(mockdir):\n        __salt__['file.makedirs_perms'](name=mockdir, user=runas, group='mock')\n    rpmmacros = os.path.join(home, '.rpmmacros')\n    with salt.utils.files.fopen(rpmmacros, 'w') as afile:\n        afile.write(salt.utils.stringutils.to_str('%_topdir {}\\n'.format(rpmbuilddir)))\n        afile.write('%signature gpg\\n')\n        afile.write('%_source_filedigest_algorithm 8\\n')\n        afile.write('%_binary_filedigest_algorithm 8\\n')\n        afile.write('%_gpg_name packaging@saltstack.com\\n')",
            "def _create_rpmmacros(runas='root'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Create the .rpmmacros file in user's home directory\\n    \"\n    home = os.path.expanduser('~' + runas)\n    rpmbuilddir = os.path.join(home, 'rpmbuild')\n    if not os.path.isdir(rpmbuilddir):\n        __salt__['file.makedirs_perms'](name=rpmbuilddir, user=runas, group='mock')\n    mockdir = os.path.join(home, 'mock')\n    if not os.path.isdir(mockdir):\n        __salt__['file.makedirs_perms'](name=mockdir, user=runas, group='mock')\n    rpmmacros = os.path.join(home, '.rpmmacros')\n    with salt.utils.files.fopen(rpmmacros, 'w') as afile:\n        afile.write(salt.utils.stringutils.to_str('%_topdir {}\\n'.format(rpmbuilddir)))\n        afile.write('%signature gpg\\n')\n        afile.write('%_source_filedigest_algorithm 8\\n')\n        afile.write('%_binary_filedigest_algorithm 8\\n')\n        afile.write('%_gpg_name packaging@saltstack.com\\n')"
        ]
    },
    {
        "func_name": "_mk_tree",
        "original": "def _mk_tree(runas='root'):\n    \"\"\"\n    Create the rpm build tree\n    \"\"\"\n    basedir = tempfile.mkdtemp()\n    paths = ['BUILD', 'RPMS', 'SOURCES', 'SPECS', 'SRPMS']\n    for path in paths:\n        full = os.path.join(basedir, path)\n        __salt__['file.makedirs_perms'](name=full, user=runas, group='mock')\n    return basedir",
        "mutated": [
            "def _mk_tree(runas='root'):\n    if False:\n        i = 10\n    '\\n    Create the rpm build tree\\n    '\n    basedir = tempfile.mkdtemp()\n    paths = ['BUILD', 'RPMS', 'SOURCES', 'SPECS', 'SRPMS']\n    for path in paths:\n        full = os.path.join(basedir, path)\n        __salt__['file.makedirs_perms'](name=full, user=runas, group='mock')\n    return basedir",
            "def _mk_tree(runas='root'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Create the rpm build tree\\n    '\n    basedir = tempfile.mkdtemp()\n    paths = ['BUILD', 'RPMS', 'SOURCES', 'SPECS', 'SRPMS']\n    for path in paths:\n        full = os.path.join(basedir, path)\n        __salt__['file.makedirs_perms'](name=full, user=runas, group='mock')\n    return basedir",
            "def _mk_tree(runas='root'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Create the rpm build tree\\n    '\n    basedir = tempfile.mkdtemp()\n    paths = ['BUILD', 'RPMS', 'SOURCES', 'SPECS', 'SRPMS']\n    for path in paths:\n        full = os.path.join(basedir, path)\n        __salt__['file.makedirs_perms'](name=full, user=runas, group='mock')\n    return basedir",
            "def _mk_tree(runas='root'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Create the rpm build tree\\n    '\n    basedir = tempfile.mkdtemp()\n    paths = ['BUILD', 'RPMS', 'SOURCES', 'SPECS', 'SRPMS']\n    for path in paths:\n        full = os.path.join(basedir, path)\n        __salt__['file.makedirs_perms'](name=full, user=runas, group='mock')\n    return basedir",
            "def _mk_tree(runas='root'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Create the rpm build tree\\n    '\n    basedir = tempfile.mkdtemp()\n    paths = ['BUILD', 'RPMS', 'SOURCES', 'SPECS', 'SRPMS']\n    for path in paths:\n        full = os.path.join(basedir, path)\n        __salt__['file.makedirs_perms'](name=full, user=runas, group='mock')\n    return basedir"
        ]
    },
    {
        "func_name": "_get_spec",
        "original": "def _get_spec(tree_base, spec, template, saltenv='base'):\n    \"\"\"\n    Get the spec file and place it in the SPECS dir\n    \"\"\"\n    spec_tgt = os.path.basename(spec)\n    dest = os.path.join(tree_base, 'SPECS', spec_tgt)\n    return __salt__['cp.get_url'](spec, dest, saltenv=saltenv)",
        "mutated": [
            "def _get_spec(tree_base, spec, template, saltenv='base'):\n    if False:\n        i = 10\n    '\\n    Get the spec file and place it in the SPECS dir\\n    '\n    spec_tgt = os.path.basename(spec)\n    dest = os.path.join(tree_base, 'SPECS', spec_tgt)\n    return __salt__['cp.get_url'](spec, dest, saltenv=saltenv)",
            "def _get_spec(tree_base, spec, template, saltenv='base'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Get the spec file and place it in the SPECS dir\\n    '\n    spec_tgt = os.path.basename(spec)\n    dest = os.path.join(tree_base, 'SPECS', spec_tgt)\n    return __salt__['cp.get_url'](spec, dest, saltenv=saltenv)",
            "def _get_spec(tree_base, spec, template, saltenv='base'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Get the spec file and place it in the SPECS dir\\n    '\n    spec_tgt = os.path.basename(spec)\n    dest = os.path.join(tree_base, 'SPECS', spec_tgt)\n    return __salt__['cp.get_url'](spec, dest, saltenv=saltenv)",
            "def _get_spec(tree_base, spec, template, saltenv='base'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Get the spec file and place it in the SPECS dir\\n    '\n    spec_tgt = os.path.basename(spec)\n    dest = os.path.join(tree_base, 'SPECS', spec_tgt)\n    return __salt__['cp.get_url'](spec, dest, saltenv=saltenv)",
            "def _get_spec(tree_base, spec, template, saltenv='base'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Get the spec file and place it in the SPECS dir\\n    '\n    spec_tgt = os.path.basename(spec)\n    dest = os.path.join(tree_base, 'SPECS', spec_tgt)\n    return __salt__['cp.get_url'](spec, dest, saltenv=saltenv)"
        ]
    },
    {
        "func_name": "_get_src",
        "original": "def _get_src(tree_base, source, saltenv='base', runas='root'):\n    \"\"\"\n    Get the named sources and place them into the tree_base\n    \"\"\"\n    parsed = urllib.parse.urlparse(source)\n    sbase = os.path.basename(source)\n    dest = os.path.join(tree_base, 'SOURCES', sbase)\n    if parsed.scheme:\n        lsrc = __salt__['cp.get_url'](source, dest, saltenv=saltenv)\n    else:\n        shutil.copy(source, dest)\n    __salt__['file.chown'](path=dest, user=runas, group='mock')",
        "mutated": [
            "def _get_src(tree_base, source, saltenv='base', runas='root'):\n    if False:\n        i = 10\n    '\\n    Get the named sources and place them into the tree_base\\n    '\n    parsed = urllib.parse.urlparse(source)\n    sbase = os.path.basename(source)\n    dest = os.path.join(tree_base, 'SOURCES', sbase)\n    if parsed.scheme:\n        lsrc = __salt__['cp.get_url'](source, dest, saltenv=saltenv)\n    else:\n        shutil.copy(source, dest)\n    __salt__['file.chown'](path=dest, user=runas, group='mock')",
            "def _get_src(tree_base, source, saltenv='base', runas='root'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Get the named sources and place them into the tree_base\\n    '\n    parsed = urllib.parse.urlparse(source)\n    sbase = os.path.basename(source)\n    dest = os.path.join(tree_base, 'SOURCES', sbase)\n    if parsed.scheme:\n        lsrc = __salt__['cp.get_url'](source, dest, saltenv=saltenv)\n    else:\n        shutil.copy(source, dest)\n    __salt__['file.chown'](path=dest, user=runas, group='mock')",
            "def _get_src(tree_base, source, saltenv='base', runas='root'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Get the named sources and place them into the tree_base\\n    '\n    parsed = urllib.parse.urlparse(source)\n    sbase = os.path.basename(source)\n    dest = os.path.join(tree_base, 'SOURCES', sbase)\n    if parsed.scheme:\n        lsrc = __salt__['cp.get_url'](source, dest, saltenv=saltenv)\n    else:\n        shutil.copy(source, dest)\n    __salt__['file.chown'](path=dest, user=runas, group='mock')",
            "def _get_src(tree_base, source, saltenv='base', runas='root'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Get the named sources and place them into the tree_base\\n    '\n    parsed = urllib.parse.urlparse(source)\n    sbase = os.path.basename(source)\n    dest = os.path.join(tree_base, 'SOURCES', sbase)\n    if parsed.scheme:\n        lsrc = __salt__['cp.get_url'](source, dest, saltenv=saltenv)\n    else:\n        shutil.copy(source, dest)\n    __salt__['file.chown'](path=dest, user=runas, group='mock')",
            "def _get_src(tree_base, source, saltenv='base', runas='root'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Get the named sources and place them into the tree_base\\n    '\n    parsed = urllib.parse.urlparse(source)\n    sbase = os.path.basename(source)\n    dest = os.path.join(tree_base, 'SOURCES', sbase)\n    if parsed.scheme:\n        lsrc = __salt__['cp.get_url'](source, dest, saltenv=saltenv)\n    else:\n        shutil.copy(source, dest)\n    __salt__['file.chown'](path=dest, user=runas, group='mock')"
        ]
    },
    {
        "func_name": "_get_distset",
        "original": "def _get_distset(tgt):\n    \"\"\"\n    Get the distribution string for use with rpmbuild and mock\n    \"\"\"\n    tgtattrs = tgt.split('-')\n    if tgtattrs[0] == 'amzn2':\n        distset = '--define \"dist .{}\"'.format(tgtattrs[0])\n    elif tgtattrs[1] in ['6', '7', '8']:\n        distset = '--define \"dist .el{}\"'.format(tgtattrs[1])\n    else:\n        distset = ''\n    return distset",
        "mutated": [
            "def _get_distset(tgt):\n    if False:\n        i = 10\n    '\\n    Get the distribution string for use with rpmbuild and mock\\n    '\n    tgtattrs = tgt.split('-')\n    if tgtattrs[0] == 'amzn2':\n        distset = '--define \"dist .{}\"'.format(tgtattrs[0])\n    elif tgtattrs[1] in ['6', '7', '8']:\n        distset = '--define \"dist .el{}\"'.format(tgtattrs[1])\n    else:\n        distset = ''\n    return distset",
            "def _get_distset(tgt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Get the distribution string for use with rpmbuild and mock\\n    '\n    tgtattrs = tgt.split('-')\n    if tgtattrs[0] == 'amzn2':\n        distset = '--define \"dist .{}\"'.format(tgtattrs[0])\n    elif tgtattrs[1] in ['6', '7', '8']:\n        distset = '--define \"dist .el{}\"'.format(tgtattrs[1])\n    else:\n        distset = ''\n    return distset",
            "def _get_distset(tgt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Get the distribution string for use with rpmbuild and mock\\n    '\n    tgtattrs = tgt.split('-')\n    if tgtattrs[0] == 'amzn2':\n        distset = '--define \"dist .{}\"'.format(tgtattrs[0])\n    elif tgtattrs[1] in ['6', '7', '8']:\n        distset = '--define \"dist .el{}\"'.format(tgtattrs[1])\n    else:\n        distset = ''\n    return distset",
            "def _get_distset(tgt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Get the distribution string for use with rpmbuild and mock\\n    '\n    tgtattrs = tgt.split('-')\n    if tgtattrs[0] == 'amzn2':\n        distset = '--define \"dist .{}\"'.format(tgtattrs[0])\n    elif tgtattrs[1] in ['6', '7', '8']:\n        distset = '--define \"dist .el{}\"'.format(tgtattrs[1])\n    else:\n        distset = ''\n    return distset",
            "def _get_distset(tgt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Get the distribution string for use with rpmbuild and mock\\n    '\n    tgtattrs = tgt.split('-')\n    if tgtattrs[0] == 'amzn2':\n        distset = '--define \"dist .{}\"'.format(tgtattrs[0])\n    elif tgtattrs[1] in ['6', '7', '8']:\n        distset = '--define \"dist .el{}\"'.format(tgtattrs[1])\n    else:\n        distset = ''\n    return distset"
        ]
    },
    {
        "func_name": "_get_deps",
        "original": "def _get_deps(deps, tree_base, saltenv='base'):\n    \"\"\"\n    Get include string for list of dependent rpms to build package\n    \"\"\"\n    deps_list = ''\n    if deps is None:\n        return deps_list\n    if not isinstance(deps, list):\n        raise SaltInvocationError(\"'deps' must be a Python list or comma-separated string\")\n    for deprpm in deps:\n        parsed = urllib.parse.urlparse(deprpm)\n        depbase = os.path.basename(deprpm)\n        dest = os.path.join(tree_base, depbase)\n        if parsed.scheme:\n            __salt__['cp.get_url'](deprpm, dest, saltenv=saltenv)\n        else:\n            shutil.copy(deprpm, dest)\n        deps_list += ' {}'.format(dest)\n    return deps_list",
        "mutated": [
            "def _get_deps(deps, tree_base, saltenv='base'):\n    if False:\n        i = 10\n    '\\n    Get include string for list of dependent rpms to build package\\n    '\n    deps_list = ''\n    if deps is None:\n        return deps_list\n    if not isinstance(deps, list):\n        raise SaltInvocationError(\"'deps' must be a Python list or comma-separated string\")\n    for deprpm in deps:\n        parsed = urllib.parse.urlparse(deprpm)\n        depbase = os.path.basename(deprpm)\n        dest = os.path.join(tree_base, depbase)\n        if parsed.scheme:\n            __salt__['cp.get_url'](deprpm, dest, saltenv=saltenv)\n        else:\n            shutil.copy(deprpm, dest)\n        deps_list += ' {}'.format(dest)\n    return deps_list",
            "def _get_deps(deps, tree_base, saltenv='base'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Get include string for list of dependent rpms to build package\\n    '\n    deps_list = ''\n    if deps is None:\n        return deps_list\n    if not isinstance(deps, list):\n        raise SaltInvocationError(\"'deps' must be a Python list or comma-separated string\")\n    for deprpm in deps:\n        parsed = urllib.parse.urlparse(deprpm)\n        depbase = os.path.basename(deprpm)\n        dest = os.path.join(tree_base, depbase)\n        if parsed.scheme:\n            __salt__['cp.get_url'](deprpm, dest, saltenv=saltenv)\n        else:\n            shutil.copy(deprpm, dest)\n        deps_list += ' {}'.format(dest)\n    return deps_list",
            "def _get_deps(deps, tree_base, saltenv='base'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Get include string for list of dependent rpms to build package\\n    '\n    deps_list = ''\n    if deps is None:\n        return deps_list\n    if not isinstance(deps, list):\n        raise SaltInvocationError(\"'deps' must be a Python list or comma-separated string\")\n    for deprpm in deps:\n        parsed = urllib.parse.urlparse(deprpm)\n        depbase = os.path.basename(deprpm)\n        dest = os.path.join(tree_base, depbase)\n        if parsed.scheme:\n            __salt__['cp.get_url'](deprpm, dest, saltenv=saltenv)\n        else:\n            shutil.copy(deprpm, dest)\n        deps_list += ' {}'.format(dest)\n    return deps_list",
            "def _get_deps(deps, tree_base, saltenv='base'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Get include string for list of dependent rpms to build package\\n    '\n    deps_list = ''\n    if deps is None:\n        return deps_list\n    if not isinstance(deps, list):\n        raise SaltInvocationError(\"'deps' must be a Python list or comma-separated string\")\n    for deprpm in deps:\n        parsed = urllib.parse.urlparse(deprpm)\n        depbase = os.path.basename(deprpm)\n        dest = os.path.join(tree_base, depbase)\n        if parsed.scheme:\n            __salt__['cp.get_url'](deprpm, dest, saltenv=saltenv)\n        else:\n            shutil.copy(deprpm, dest)\n        deps_list += ' {}'.format(dest)\n    return deps_list",
            "def _get_deps(deps, tree_base, saltenv='base'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Get include string for list of dependent rpms to build package\\n    '\n    deps_list = ''\n    if deps is None:\n        return deps_list\n    if not isinstance(deps, list):\n        raise SaltInvocationError(\"'deps' must be a Python list or comma-separated string\")\n    for deprpm in deps:\n        parsed = urllib.parse.urlparse(deprpm)\n        depbase = os.path.basename(deprpm)\n        dest = os.path.join(tree_base, depbase)\n        if parsed.scheme:\n            __salt__['cp.get_url'](deprpm, dest, saltenv=saltenv)\n        else:\n            shutil.copy(deprpm, dest)\n        deps_list += ' {}'.format(dest)\n    return deps_list"
        ]
    },
    {
        "func_name": "_check_repo_gpg_phrase_utils",
        "original": "def _check_repo_gpg_phrase_utils():\n    \"\"\"\n    Check for /usr/libexec/gpg-preset-passphrase is installed\n    \"\"\"\n    util_name = '/usr/libexec/gpg-preset-passphrase'\n    if __salt__['file.file_exists'](util_name):\n        return True\n    else:\n        raise CommandExecutionError(\"utility '{}' needs to be installed\".format(util_name))",
        "mutated": [
            "def _check_repo_gpg_phrase_utils():\n    if False:\n        i = 10\n    '\\n    Check for /usr/libexec/gpg-preset-passphrase is installed\\n    '\n    util_name = '/usr/libexec/gpg-preset-passphrase'\n    if __salt__['file.file_exists'](util_name):\n        return True\n    else:\n        raise CommandExecutionError(\"utility '{}' needs to be installed\".format(util_name))",
            "def _check_repo_gpg_phrase_utils():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Check for /usr/libexec/gpg-preset-passphrase is installed\\n    '\n    util_name = '/usr/libexec/gpg-preset-passphrase'\n    if __salt__['file.file_exists'](util_name):\n        return True\n    else:\n        raise CommandExecutionError(\"utility '{}' needs to be installed\".format(util_name))",
            "def _check_repo_gpg_phrase_utils():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Check for /usr/libexec/gpg-preset-passphrase is installed\\n    '\n    util_name = '/usr/libexec/gpg-preset-passphrase'\n    if __salt__['file.file_exists'](util_name):\n        return True\n    else:\n        raise CommandExecutionError(\"utility '{}' needs to be installed\".format(util_name))",
            "def _check_repo_gpg_phrase_utils():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Check for /usr/libexec/gpg-preset-passphrase is installed\\n    '\n    util_name = '/usr/libexec/gpg-preset-passphrase'\n    if __salt__['file.file_exists'](util_name):\n        return True\n    else:\n        raise CommandExecutionError(\"utility '{}' needs to be installed\".format(util_name))",
            "def _check_repo_gpg_phrase_utils():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Check for /usr/libexec/gpg-preset-passphrase is installed\\n    '\n    util_name = '/usr/libexec/gpg-preset-passphrase'\n    if __salt__['file.file_exists'](util_name):\n        return True\n    else:\n        raise CommandExecutionError(\"utility '{}' needs to be installed\".format(util_name))"
        ]
    },
    {
        "func_name": "_get_gpg_key_resources",
        "original": "def _get_gpg_key_resources(keyid, env, use_passphrase, gnupghome, runas):\n    \"\"\"\n    Obtain gpg key resource infomation to sign repo files with\n\n    keyid\n\n        Optional Key ID to use in signing packages and repository.\n        Utilizes Public and Private keys associated with keyid which have\n        been loaded into the minion's Pillar data.\n\n    env\n\n        A dictionary of environment variables to be utilized in creating the\n        repository.\n\n    use_passphrase : False\n\n        Use a passphrase with the signing key presented in ``keyid``.\n        Passphrase is received from Pillar data which could be passed on the\n        command line with ``pillar`` parameter.\n\n    gnupghome : /etc/salt/gpgkeys\n\n        Location where GPG related files are stored, used with ``keyid``.\n\n    runas : root\n\n        User to create the repository as, and optionally sign packages.\n\n        .. note::\n\n            Ensure the user has correct permissions to any files and\n            directories which are to be utilized.\n\n\n    Returns:\n        tuple\n            use_gpg_agent       True | False, Redhat 8 now makes use of a gpg-agent similar ot Debian\n            local_keyid         key id to use in signing\n            define_gpg_name     string containing definition to use with addsign (use_gpg_agent False)\n            phrase              pass phrase (may not be used)\n\n    \"\"\"\n    local_keygrip_to_use = None\n    local_key_fingerprint = None\n    local_keyid = None\n    local_uids = None\n    define_gpg_name = ''\n    phrase = ''\n    retrc = 0\n    use_gpg_agent = False\n    if __grains__.get('os_family') == 'RedHat' and __grains__.get('osmajorrelease') >= 8:\n        use_gpg_agent = True\n    if keyid is not None:\n        pkg_pub_key_file = '{}/{}'.format(gnupghome, __salt__['pillar.get']('gpg_pkg_pub_keyname', None))\n        pkg_priv_key_file = '{}/{}'.format(gnupghome, __salt__['pillar.get']('gpg_pkg_priv_keyname', None))\n        if pkg_pub_key_file is None or pkg_priv_key_file is None:\n            raise SaltInvocationError(\"Pillar data should contain Public and Private keys associated with 'keyid'\")\n        try:\n            __salt__['gpg.import_key'](user=runas, filename=pkg_pub_key_file, gnupghome=gnupghome)\n            __salt__['gpg.import_key'](user=runas, filename=pkg_priv_key_file, gnupghome=gnupghome)\n        except SaltInvocationError:\n            raise SaltInvocationError(\"Public and Private key files associated with Pillar data and 'keyid' {} could not be found\".format(keyid))\n        local_keys = __salt__['gpg.list_keys'](user=runas, gnupghome=gnupghome)\n        for gpg_key in local_keys:\n            if keyid == gpg_key['keyid'][8:]:\n                local_uids = gpg_key['uids']\n                local_keyid = gpg_key['keyid']\n                if use_gpg_agent:\n                    local_keygrip_to_use = gpg_key['fingerprint']\n                    local_key_fingerprint = gpg_key['fingerprint']\n                break\n        if use_gpg_agent:\n            cmd = 'gpg --with-keygrip --list-secret-keys'\n            local_keys2_keygrip = __salt__['cmd.run'](cmd, runas=runas, env=env)\n            local_keys2 = iter(local_keys2_keygrip.splitlines())\n            try:\n                for line in local_keys2:\n                    if line.startswith('sec'):\n                        line_fingerprint = next(local_keys2).lstrip().rstrip()\n                        if local_key_fingerprint == line_fingerprint:\n                            lkeygrip = next(local_keys2).split('=')\n                            local_keygrip_to_use = lkeygrip[1].lstrip().rstrip()\n                            break\n            except StopIteration:\n                raise SaltInvocationError(\"unable to find keygrip associated with fingerprint '{}' for keyid '{}'\".format(local_key_fingerprint, local_keyid))\n        if local_keyid is None:\n            raise SaltInvocationError(\"The key ID '{}' was not found in GnuPG keyring at '{}'\".format(keyid, gnupghome))\n        if use_passphrase:\n            phrase = __salt__['pillar.get']('gpg_passphrase')\n            if use_gpg_agent:\n                _check_repo_gpg_phrase_utils()\n                cmd = '/usr/libexec/gpg-preset-passphrase --verbose --preset --passphrase \"{}\" {}'.format(phrase, local_keygrip_to_use)\n                retrc = __salt__['cmd.retcode'](cmd, runas=runas, env=env)\n                if retrc != 0:\n                    raise SaltInvocationError('Failed to preset passphrase, error {1}, check logs for further details'.format(retrc))\n        if local_uids:\n            define_gpg_name = \"--define='%_signature gpg' --define='%_gpg_name {}'\".format(local_uids[0])\n        cmd = 'rpm --import {}'.format(pkg_pub_key_file)\n        retrc = __salt__['cmd.retcode'](cmd, runas=runas, use_vt=True)\n        if retrc != 0:\n            raise SaltInvocationError('Failed to import public key from file {} with return error {}, check logs for further details'.format(pkg_pub_key_file, retrc))\n    return (use_gpg_agent, local_keyid, define_gpg_name, phrase)",
        "mutated": [
            "def _get_gpg_key_resources(keyid, env, use_passphrase, gnupghome, runas):\n    if False:\n        i = 10\n    \"\\n    Obtain gpg key resource infomation to sign repo files with\\n\\n    keyid\\n\\n        Optional Key ID to use in signing packages and repository.\\n        Utilizes Public and Private keys associated with keyid which have\\n        been loaded into the minion's Pillar data.\\n\\n    env\\n\\n        A dictionary of environment variables to be utilized in creating the\\n        repository.\\n\\n    use_passphrase : False\\n\\n        Use a passphrase with the signing key presented in ``keyid``.\\n        Passphrase is received from Pillar data which could be passed on the\\n        command line with ``pillar`` parameter.\\n\\n    gnupghome : /etc/salt/gpgkeys\\n\\n        Location where GPG related files are stored, used with ``keyid``.\\n\\n    runas : root\\n\\n        User to create the repository as, and optionally sign packages.\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n\\n\\n    Returns:\\n        tuple\\n            use_gpg_agent       True | False, Redhat 8 now makes use of a gpg-agent similar ot Debian\\n            local_keyid         key id to use in signing\\n            define_gpg_name     string containing definition to use with addsign (use_gpg_agent False)\\n            phrase              pass phrase (may not be used)\\n\\n    \"\n    local_keygrip_to_use = None\n    local_key_fingerprint = None\n    local_keyid = None\n    local_uids = None\n    define_gpg_name = ''\n    phrase = ''\n    retrc = 0\n    use_gpg_agent = False\n    if __grains__.get('os_family') == 'RedHat' and __grains__.get('osmajorrelease') >= 8:\n        use_gpg_agent = True\n    if keyid is not None:\n        pkg_pub_key_file = '{}/{}'.format(gnupghome, __salt__['pillar.get']('gpg_pkg_pub_keyname', None))\n        pkg_priv_key_file = '{}/{}'.format(gnupghome, __salt__['pillar.get']('gpg_pkg_priv_keyname', None))\n        if pkg_pub_key_file is None or pkg_priv_key_file is None:\n            raise SaltInvocationError(\"Pillar data should contain Public and Private keys associated with 'keyid'\")\n        try:\n            __salt__['gpg.import_key'](user=runas, filename=pkg_pub_key_file, gnupghome=gnupghome)\n            __salt__['gpg.import_key'](user=runas, filename=pkg_priv_key_file, gnupghome=gnupghome)\n        except SaltInvocationError:\n            raise SaltInvocationError(\"Public and Private key files associated with Pillar data and 'keyid' {} could not be found\".format(keyid))\n        local_keys = __salt__['gpg.list_keys'](user=runas, gnupghome=gnupghome)\n        for gpg_key in local_keys:\n            if keyid == gpg_key['keyid'][8:]:\n                local_uids = gpg_key['uids']\n                local_keyid = gpg_key['keyid']\n                if use_gpg_agent:\n                    local_keygrip_to_use = gpg_key['fingerprint']\n                    local_key_fingerprint = gpg_key['fingerprint']\n                break\n        if use_gpg_agent:\n            cmd = 'gpg --with-keygrip --list-secret-keys'\n            local_keys2_keygrip = __salt__['cmd.run'](cmd, runas=runas, env=env)\n            local_keys2 = iter(local_keys2_keygrip.splitlines())\n            try:\n                for line in local_keys2:\n                    if line.startswith('sec'):\n                        line_fingerprint = next(local_keys2).lstrip().rstrip()\n                        if local_key_fingerprint == line_fingerprint:\n                            lkeygrip = next(local_keys2).split('=')\n                            local_keygrip_to_use = lkeygrip[1].lstrip().rstrip()\n                            break\n            except StopIteration:\n                raise SaltInvocationError(\"unable to find keygrip associated with fingerprint '{}' for keyid '{}'\".format(local_key_fingerprint, local_keyid))\n        if local_keyid is None:\n            raise SaltInvocationError(\"The key ID '{}' was not found in GnuPG keyring at '{}'\".format(keyid, gnupghome))\n        if use_passphrase:\n            phrase = __salt__['pillar.get']('gpg_passphrase')\n            if use_gpg_agent:\n                _check_repo_gpg_phrase_utils()\n                cmd = '/usr/libexec/gpg-preset-passphrase --verbose --preset --passphrase \"{}\" {}'.format(phrase, local_keygrip_to_use)\n                retrc = __salt__['cmd.retcode'](cmd, runas=runas, env=env)\n                if retrc != 0:\n                    raise SaltInvocationError('Failed to preset passphrase, error {1}, check logs for further details'.format(retrc))\n        if local_uids:\n            define_gpg_name = \"--define='%_signature gpg' --define='%_gpg_name {}'\".format(local_uids[0])\n        cmd = 'rpm --import {}'.format(pkg_pub_key_file)\n        retrc = __salt__['cmd.retcode'](cmd, runas=runas, use_vt=True)\n        if retrc != 0:\n            raise SaltInvocationError('Failed to import public key from file {} with return error {}, check logs for further details'.format(pkg_pub_key_file, retrc))\n    return (use_gpg_agent, local_keyid, define_gpg_name, phrase)",
            "def _get_gpg_key_resources(keyid, env, use_passphrase, gnupghome, runas):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Obtain gpg key resource infomation to sign repo files with\\n\\n    keyid\\n\\n        Optional Key ID to use in signing packages and repository.\\n        Utilizes Public and Private keys associated with keyid which have\\n        been loaded into the minion's Pillar data.\\n\\n    env\\n\\n        A dictionary of environment variables to be utilized in creating the\\n        repository.\\n\\n    use_passphrase : False\\n\\n        Use a passphrase with the signing key presented in ``keyid``.\\n        Passphrase is received from Pillar data which could be passed on the\\n        command line with ``pillar`` parameter.\\n\\n    gnupghome : /etc/salt/gpgkeys\\n\\n        Location where GPG related files are stored, used with ``keyid``.\\n\\n    runas : root\\n\\n        User to create the repository as, and optionally sign packages.\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n\\n\\n    Returns:\\n        tuple\\n            use_gpg_agent       True | False, Redhat 8 now makes use of a gpg-agent similar ot Debian\\n            local_keyid         key id to use in signing\\n            define_gpg_name     string containing definition to use with addsign (use_gpg_agent False)\\n            phrase              pass phrase (may not be used)\\n\\n    \"\n    local_keygrip_to_use = None\n    local_key_fingerprint = None\n    local_keyid = None\n    local_uids = None\n    define_gpg_name = ''\n    phrase = ''\n    retrc = 0\n    use_gpg_agent = False\n    if __grains__.get('os_family') == 'RedHat' and __grains__.get('osmajorrelease') >= 8:\n        use_gpg_agent = True\n    if keyid is not None:\n        pkg_pub_key_file = '{}/{}'.format(gnupghome, __salt__['pillar.get']('gpg_pkg_pub_keyname', None))\n        pkg_priv_key_file = '{}/{}'.format(gnupghome, __salt__['pillar.get']('gpg_pkg_priv_keyname', None))\n        if pkg_pub_key_file is None or pkg_priv_key_file is None:\n            raise SaltInvocationError(\"Pillar data should contain Public and Private keys associated with 'keyid'\")\n        try:\n            __salt__['gpg.import_key'](user=runas, filename=pkg_pub_key_file, gnupghome=gnupghome)\n            __salt__['gpg.import_key'](user=runas, filename=pkg_priv_key_file, gnupghome=gnupghome)\n        except SaltInvocationError:\n            raise SaltInvocationError(\"Public and Private key files associated with Pillar data and 'keyid' {} could not be found\".format(keyid))\n        local_keys = __salt__['gpg.list_keys'](user=runas, gnupghome=gnupghome)\n        for gpg_key in local_keys:\n            if keyid == gpg_key['keyid'][8:]:\n                local_uids = gpg_key['uids']\n                local_keyid = gpg_key['keyid']\n                if use_gpg_agent:\n                    local_keygrip_to_use = gpg_key['fingerprint']\n                    local_key_fingerprint = gpg_key['fingerprint']\n                break\n        if use_gpg_agent:\n            cmd = 'gpg --with-keygrip --list-secret-keys'\n            local_keys2_keygrip = __salt__['cmd.run'](cmd, runas=runas, env=env)\n            local_keys2 = iter(local_keys2_keygrip.splitlines())\n            try:\n                for line in local_keys2:\n                    if line.startswith('sec'):\n                        line_fingerprint = next(local_keys2).lstrip().rstrip()\n                        if local_key_fingerprint == line_fingerprint:\n                            lkeygrip = next(local_keys2).split('=')\n                            local_keygrip_to_use = lkeygrip[1].lstrip().rstrip()\n                            break\n            except StopIteration:\n                raise SaltInvocationError(\"unable to find keygrip associated with fingerprint '{}' for keyid '{}'\".format(local_key_fingerprint, local_keyid))\n        if local_keyid is None:\n            raise SaltInvocationError(\"The key ID '{}' was not found in GnuPG keyring at '{}'\".format(keyid, gnupghome))\n        if use_passphrase:\n            phrase = __salt__['pillar.get']('gpg_passphrase')\n            if use_gpg_agent:\n                _check_repo_gpg_phrase_utils()\n                cmd = '/usr/libexec/gpg-preset-passphrase --verbose --preset --passphrase \"{}\" {}'.format(phrase, local_keygrip_to_use)\n                retrc = __salt__['cmd.retcode'](cmd, runas=runas, env=env)\n                if retrc != 0:\n                    raise SaltInvocationError('Failed to preset passphrase, error {1}, check logs for further details'.format(retrc))\n        if local_uids:\n            define_gpg_name = \"--define='%_signature gpg' --define='%_gpg_name {}'\".format(local_uids[0])\n        cmd = 'rpm --import {}'.format(pkg_pub_key_file)\n        retrc = __salt__['cmd.retcode'](cmd, runas=runas, use_vt=True)\n        if retrc != 0:\n            raise SaltInvocationError('Failed to import public key from file {} with return error {}, check logs for further details'.format(pkg_pub_key_file, retrc))\n    return (use_gpg_agent, local_keyid, define_gpg_name, phrase)",
            "def _get_gpg_key_resources(keyid, env, use_passphrase, gnupghome, runas):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Obtain gpg key resource infomation to sign repo files with\\n\\n    keyid\\n\\n        Optional Key ID to use in signing packages and repository.\\n        Utilizes Public and Private keys associated with keyid which have\\n        been loaded into the minion's Pillar data.\\n\\n    env\\n\\n        A dictionary of environment variables to be utilized in creating the\\n        repository.\\n\\n    use_passphrase : False\\n\\n        Use a passphrase with the signing key presented in ``keyid``.\\n        Passphrase is received from Pillar data which could be passed on the\\n        command line with ``pillar`` parameter.\\n\\n    gnupghome : /etc/salt/gpgkeys\\n\\n        Location where GPG related files are stored, used with ``keyid``.\\n\\n    runas : root\\n\\n        User to create the repository as, and optionally sign packages.\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n\\n\\n    Returns:\\n        tuple\\n            use_gpg_agent       True | False, Redhat 8 now makes use of a gpg-agent similar ot Debian\\n            local_keyid         key id to use in signing\\n            define_gpg_name     string containing definition to use with addsign (use_gpg_agent False)\\n            phrase              pass phrase (may not be used)\\n\\n    \"\n    local_keygrip_to_use = None\n    local_key_fingerprint = None\n    local_keyid = None\n    local_uids = None\n    define_gpg_name = ''\n    phrase = ''\n    retrc = 0\n    use_gpg_agent = False\n    if __grains__.get('os_family') == 'RedHat' and __grains__.get('osmajorrelease') >= 8:\n        use_gpg_agent = True\n    if keyid is not None:\n        pkg_pub_key_file = '{}/{}'.format(gnupghome, __salt__['pillar.get']('gpg_pkg_pub_keyname', None))\n        pkg_priv_key_file = '{}/{}'.format(gnupghome, __salt__['pillar.get']('gpg_pkg_priv_keyname', None))\n        if pkg_pub_key_file is None or pkg_priv_key_file is None:\n            raise SaltInvocationError(\"Pillar data should contain Public and Private keys associated with 'keyid'\")\n        try:\n            __salt__['gpg.import_key'](user=runas, filename=pkg_pub_key_file, gnupghome=gnupghome)\n            __salt__['gpg.import_key'](user=runas, filename=pkg_priv_key_file, gnupghome=gnupghome)\n        except SaltInvocationError:\n            raise SaltInvocationError(\"Public and Private key files associated with Pillar data and 'keyid' {} could not be found\".format(keyid))\n        local_keys = __salt__['gpg.list_keys'](user=runas, gnupghome=gnupghome)\n        for gpg_key in local_keys:\n            if keyid == gpg_key['keyid'][8:]:\n                local_uids = gpg_key['uids']\n                local_keyid = gpg_key['keyid']\n                if use_gpg_agent:\n                    local_keygrip_to_use = gpg_key['fingerprint']\n                    local_key_fingerprint = gpg_key['fingerprint']\n                break\n        if use_gpg_agent:\n            cmd = 'gpg --with-keygrip --list-secret-keys'\n            local_keys2_keygrip = __salt__['cmd.run'](cmd, runas=runas, env=env)\n            local_keys2 = iter(local_keys2_keygrip.splitlines())\n            try:\n                for line in local_keys2:\n                    if line.startswith('sec'):\n                        line_fingerprint = next(local_keys2).lstrip().rstrip()\n                        if local_key_fingerprint == line_fingerprint:\n                            lkeygrip = next(local_keys2).split('=')\n                            local_keygrip_to_use = lkeygrip[1].lstrip().rstrip()\n                            break\n            except StopIteration:\n                raise SaltInvocationError(\"unable to find keygrip associated with fingerprint '{}' for keyid '{}'\".format(local_key_fingerprint, local_keyid))\n        if local_keyid is None:\n            raise SaltInvocationError(\"The key ID '{}' was not found in GnuPG keyring at '{}'\".format(keyid, gnupghome))\n        if use_passphrase:\n            phrase = __salt__['pillar.get']('gpg_passphrase')\n            if use_gpg_agent:\n                _check_repo_gpg_phrase_utils()\n                cmd = '/usr/libexec/gpg-preset-passphrase --verbose --preset --passphrase \"{}\" {}'.format(phrase, local_keygrip_to_use)\n                retrc = __salt__['cmd.retcode'](cmd, runas=runas, env=env)\n                if retrc != 0:\n                    raise SaltInvocationError('Failed to preset passphrase, error {1}, check logs for further details'.format(retrc))\n        if local_uids:\n            define_gpg_name = \"--define='%_signature gpg' --define='%_gpg_name {}'\".format(local_uids[0])\n        cmd = 'rpm --import {}'.format(pkg_pub_key_file)\n        retrc = __salt__['cmd.retcode'](cmd, runas=runas, use_vt=True)\n        if retrc != 0:\n            raise SaltInvocationError('Failed to import public key from file {} with return error {}, check logs for further details'.format(pkg_pub_key_file, retrc))\n    return (use_gpg_agent, local_keyid, define_gpg_name, phrase)",
            "def _get_gpg_key_resources(keyid, env, use_passphrase, gnupghome, runas):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Obtain gpg key resource infomation to sign repo files with\\n\\n    keyid\\n\\n        Optional Key ID to use in signing packages and repository.\\n        Utilizes Public and Private keys associated with keyid which have\\n        been loaded into the minion's Pillar data.\\n\\n    env\\n\\n        A dictionary of environment variables to be utilized in creating the\\n        repository.\\n\\n    use_passphrase : False\\n\\n        Use a passphrase with the signing key presented in ``keyid``.\\n        Passphrase is received from Pillar data which could be passed on the\\n        command line with ``pillar`` parameter.\\n\\n    gnupghome : /etc/salt/gpgkeys\\n\\n        Location where GPG related files are stored, used with ``keyid``.\\n\\n    runas : root\\n\\n        User to create the repository as, and optionally sign packages.\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n\\n\\n    Returns:\\n        tuple\\n            use_gpg_agent       True | False, Redhat 8 now makes use of a gpg-agent similar ot Debian\\n            local_keyid         key id to use in signing\\n            define_gpg_name     string containing definition to use with addsign (use_gpg_agent False)\\n            phrase              pass phrase (may not be used)\\n\\n    \"\n    local_keygrip_to_use = None\n    local_key_fingerprint = None\n    local_keyid = None\n    local_uids = None\n    define_gpg_name = ''\n    phrase = ''\n    retrc = 0\n    use_gpg_agent = False\n    if __grains__.get('os_family') == 'RedHat' and __grains__.get('osmajorrelease') >= 8:\n        use_gpg_agent = True\n    if keyid is not None:\n        pkg_pub_key_file = '{}/{}'.format(gnupghome, __salt__['pillar.get']('gpg_pkg_pub_keyname', None))\n        pkg_priv_key_file = '{}/{}'.format(gnupghome, __salt__['pillar.get']('gpg_pkg_priv_keyname', None))\n        if pkg_pub_key_file is None or pkg_priv_key_file is None:\n            raise SaltInvocationError(\"Pillar data should contain Public and Private keys associated with 'keyid'\")\n        try:\n            __salt__['gpg.import_key'](user=runas, filename=pkg_pub_key_file, gnupghome=gnupghome)\n            __salt__['gpg.import_key'](user=runas, filename=pkg_priv_key_file, gnupghome=gnupghome)\n        except SaltInvocationError:\n            raise SaltInvocationError(\"Public and Private key files associated with Pillar data and 'keyid' {} could not be found\".format(keyid))\n        local_keys = __salt__['gpg.list_keys'](user=runas, gnupghome=gnupghome)\n        for gpg_key in local_keys:\n            if keyid == gpg_key['keyid'][8:]:\n                local_uids = gpg_key['uids']\n                local_keyid = gpg_key['keyid']\n                if use_gpg_agent:\n                    local_keygrip_to_use = gpg_key['fingerprint']\n                    local_key_fingerprint = gpg_key['fingerprint']\n                break\n        if use_gpg_agent:\n            cmd = 'gpg --with-keygrip --list-secret-keys'\n            local_keys2_keygrip = __salt__['cmd.run'](cmd, runas=runas, env=env)\n            local_keys2 = iter(local_keys2_keygrip.splitlines())\n            try:\n                for line in local_keys2:\n                    if line.startswith('sec'):\n                        line_fingerprint = next(local_keys2).lstrip().rstrip()\n                        if local_key_fingerprint == line_fingerprint:\n                            lkeygrip = next(local_keys2).split('=')\n                            local_keygrip_to_use = lkeygrip[1].lstrip().rstrip()\n                            break\n            except StopIteration:\n                raise SaltInvocationError(\"unable to find keygrip associated with fingerprint '{}' for keyid '{}'\".format(local_key_fingerprint, local_keyid))\n        if local_keyid is None:\n            raise SaltInvocationError(\"The key ID '{}' was not found in GnuPG keyring at '{}'\".format(keyid, gnupghome))\n        if use_passphrase:\n            phrase = __salt__['pillar.get']('gpg_passphrase')\n            if use_gpg_agent:\n                _check_repo_gpg_phrase_utils()\n                cmd = '/usr/libexec/gpg-preset-passphrase --verbose --preset --passphrase \"{}\" {}'.format(phrase, local_keygrip_to_use)\n                retrc = __salt__['cmd.retcode'](cmd, runas=runas, env=env)\n                if retrc != 0:\n                    raise SaltInvocationError('Failed to preset passphrase, error {1}, check logs for further details'.format(retrc))\n        if local_uids:\n            define_gpg_name = \"--define='%_signature gpg' --define='%_gpg_name {}'\".format(local_uids[0])\n        cmd = 'rpm --import {}'.format(pkg_pub_key_file)\n        retrc = __salt__['cmd.retcode'](cmd, runas=runas, use_vt=True)\n        if retrc != 0:\n            raise SaltInvocationError('Failed to import public key from file {} with return error {}, check logs for further details'.format(pkg_pub_key_file, retrc))\n    return (use_gpg_agent, local_keyid, define_gpg_name, phrase)",
            "def _get_gpg_key_resources(keyid, env, use_passphrase, gnupghome, runas):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Obtain gpg key resource infomation to sign repo files with\\n\\n    keyid\\n\\n        Optional Key ID to use in signing packages and repository.\\n        Utilizes Public and Private keys associated with keyid which have\\n        been loaded into the minion's Pillar data.\\n\\n    env\\n\\n        A dictionary of environment variables to be utilized in creating the\\n        repository.\\n\\n    use_passphrase : False\\n\\n        Use a passphrase with the signing key presented in ``keyid``.\\n        Passphrase is received from Pillar data which could be passed on the\\n        command line with ``pillar`` parameter.\\n\\n    gnupghome : /etc/salt/gpgkeys\\n\\n        Location where GPG related files are stored, used with ``keyid``.\\n\\n    runas : root\\n\\n        User to create the repository as, and optionally sign packages.\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n\\n\\n    Returns:\\n        tuple\\n            use_gpg_agent       True | False, Redhat 8 now makes use of a gpg-agent similar ot Debian\\n            local_keyid         key id to use in signing\\n            define_gpg_name     string containing definition to use with addsign (use_gpg_agent False)\\n            phrase              pass phrase (may not be used)\\n\\n    \"\n    local_keygrip_to_use = None\n    local_key_fingerprint = None\n    local_keyid = None\n    local_uids = None\n    define_gpg_name = ''\n    phrase = ''\n    retrc = 0\n    use_gpg_agent = False\n    if __grains__.get('os_family') == 'RedHat' and __grains__.get('osmajorrelease') >= 8:\n        use_gpg_agent = True\n    if keyid is not None:\n        pkg_pub_key_file = '{}/{}'.format(gnupghome, __salt__['pillar.get']('gpg_pkg_pub_keyname', None))\n        pkg_priv_key_file = '{}/{}'.format(gnupghome, __salt__['pillar.get']('gpg_pkg_priv_keyname', None))\n        if pkg_pub_key_file is None or pkg_priv_key_file is None:\n            raise SaltInvocationError(\"Pillar data should contain Public and Private keys associated with 'keyid'\")\n        try:\n            __salt__['gpg.import_key'](user=runas, filename=pkg_pub_key_file, gnupghome=gnupghome)\n            __salt__['gpg.import_key'](user=runas, filename=pkg_priv_key_file, gnupghome=gnupghome)\n        except SaltInvocationError:\n            raise SaltInvocationError(\"Public and Private key files associated with Pillar data and 'keyid' {} could not be found\".format(keyid))\n        local_keys = __salt__['gpg.list_keys'](user=runas, gnupghome=gnupghome)\n        for gpg_key in local_keys:\n            if keyid == gpg_key['keyid'][8:]:\n                local_uids = gpg_key['uids']\n                local_keyid = gpg_key['keyid']\n                if use_gpg_agent:\n                    local_keygrip_to_use = gpg_key['fingerprint']\n                    local_key_fingerprint = gpg_key['fingerprint']\n                break\n        if use_gpg_agent:\n            cmd = 'gpg --with-keygrip --list-secret-keys'\n            local_keys2_keygrip = __salt__['cmd.run'](cmd, runas=runas, env=env)\n            local_keys2 = iter(local_keys2_keygrip.splitlines())\n            try:\n                for line in local_keys2:\n                    if line.startswith('sec'):\n                        line_fingerprint = next(local_keys2).lstrip().rstrip()\n                        if local_key_fingerprint == line_fingerprint:\n                            lkeygrip = next(local_keys2).split('=')\n                            local_keygrip_to_use = lkeygrip[1].lstrip().rstrip()\n                            break\n            except StopIteration:\n                raise SaltInvocationError(\"unable to find keygrip associated with fingerprint '{}' for keyid '{}'\".format(local_key_fingerprint, local_keyid))\n        if local_keyid is None:\n            raise SaltInvocationError(\"The key ID '{}' was not found in GnuPG keyring at '{}'\".format(keyid, gnupghome))\n        if use_passphrase:\n            phrase = __salt__['pillar.get']('gpg_passphrase')\n            if use_gpg_agent:\n                _check_repo_gpg_phrase_utils()\n                cmd = '/usr/libexec/gpg-preset-passphrase --verbose --preset --passphrase \"{}\" {}'.format(phrase, local_keygrip_to_use)\n                retrc = __salt__['cmd.retcode'](cmd, runas=runas, env=env)\n                if retrc != 0:\n                    raise SaltInvocationError('Failed to preset passphrase, error {1}, check logs for further details'.format(retrc))\n        if local_uids:\n            define_gpg_name = \"--define='%_signature gpg' --define='%_gpg_name {}'\".format(local_uids[0])\n        cmd = 'rpm --import {}'.format(pkg_pub_key_file)\n        retrc = __salt__['cmd.retcode'](cmd, runas=runas, use_vt=True)\n        if retrc != 0:\n            raise SaltInvocationError('Failed to import public key from file {} with return error {}, check logs for further details'.format(pkg_pub_key_file, retrc))\n    return (use_gpg_agent, local_keyid, define_gpg_name, phrase)"
        ]
    },
    {
        "func_name": "_sign_file",
        "original": "def _sign_file(runas, define_gpg_name, phrase, abs_file, timeout):\n    \"\"\"\n    Sign file with provided key and definition\n    \"\"\"\n    SIGN_PROMPT_RE = re.compile('Enter pass phrase: ', re.M)\n    interval = 0.5\n    number_retries = timeout / interval\n    times_looped = 0\n    error_msg = 'Failed to sign file {}'.format(abs_file)\n    cmd = 'rpm {} --addsign {}'.format(define_gpg_name, abs_file)\n    preexec_fn = functools.partial(salt.utils.user.chugid_and_umask, runas, None)\n    try:\n        (stdout, stderr) = (None, None)\n        proc = salt.utils.vt.Terminal(cmd, shell=True, preexec_fn=preexec_fn, stream_stdout=True, stream_stderr=True)\n        while proc.has_unread_data:\n            (stdout, stderr) = proc.recv()\n            if stdout and SIGN_PROMPT_RE.search(stdout):\n                proc.sendline(phrase)\n            else:\n                times_looped += 1\n            if times_looped > number_retries:\n                raise SaltInvocationError('Attemping to sign file {} failed, timed out after {} seconds'.format(abs_file, int(times_looped * interval)))\n            time.sleep(interval)\n        proc_exitstatus = proc.exitstatus\n        if proc_exitstatus != 0:\n            raise SaltInvocationError('Signing file {} failed with proc.status {}'.format(abs_file, proc_exitstatus))\n    except salt.utils.vt.TerminalException as err:\n        trace = traceback.format_exc()\n        log.error(error_msg, err, trace)\n    finally:\n        proc.close(terminate=True, kill=True)",
        "mutated": [
            "def _sign_file(runas, define_gpg_name, phrase, abs_file, timeout):\n    if False:\n        i = 10\n    '\\n    Sign file with provided key and definition\\n    '\n    SIGN_PROMPT_RE = re.compile('Enter pass phrase: ', re.M)\n    interval = 0.5\n    number_retries = timeout / interval\n    times_looped = 0\n    error_msg = 'Failed to sign file {}'.format(abs_file)\n    cmd = 'rpm {} --addsign {}'.format(define_gpg_name, abs_file)\n    preexec_fn = functools.partial(salt.utils.user.chugid_and_umask, runas, None)\n    try:\n        (stdout, stderr) = (None, None)\n        proc = salt.utils.vt.Terminal(cmd, shell=True, preexec_fn=preexec_fn, stream_stdout=True, stream_stderr=True)\n        while proc.has_unread_data:\n            (stdout, stderr) = proc.recv()\n            if stdout and SIGN_PROMPT_RE.search(stdout):\n                proc.sendline(phrase)\n            else:\n                times_looped += 1\n            if times_looped > number_retries:\n                raise SaltInvocationError('Attemping to sign file {} failed, timed out after {} seconds'.format(abs_file, int(times_looped * interval)))\n            time.sleep(interval)\n        proc_exitstatus = proc.exitstatus\n        if proc_exitstatus != 0:\n            raise SaltInvocationError('Signing file {} failed with proc.status {}'.format(abs_file, proc_exitstatus))\n    except salt.utils.vt.TerminalException as err:\n        trace = traceback.format_exc()\n        log.error(error_msg, err, trace)\n    finally:\n        proc.close(terminate=True, kill=True)",
            "def _sign_file(runas, define_gpg_name, phrase, abs_file, timeout):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Sign file with provided key and definition\\n    '\n    SIGN_PROMPT_RE = re.compile('Enter pass phrase: ', re.M)\n    interval = 0.5\n    number_retries = timeout / interval\n    times_looped = 0\n    error_msg = 'Failed to sign file {}'.format(abs_file)\n    cmd = 'rpm {} --addsign {}'.format(define_gpg_name, abs_file)\n    preexec_fn = functools.partial(salt.utils.user.chugid_and_umask, runas, None)\n    try:\n        (stdout, stderr) = (None, None)\n        proc = salt.utils.vt.Terminal(cmd, shell=True, preexec_fn=preexec_fn, stream_stdout=True, stream_stderr=True)\n        while proc.has_unread_data:\n            (stdout, stderr) = proc.recv()\n            if stdout and SIGN_PROMPT_RE.search(stdout):\n                proc.sendline(phrase)\n            else:\n                times_looped += 1\n            if times_looped > number_retries:\n                raise SaltInvocationError('Attemping to sign file {} failed, timed out after {} seconds'.format(abs_file, int(times_looped * interval)))\n            time.sleep(interval)\n        proc_exitstatus = proc.exitstatus\n        if proc_exitstatus != 0:\n            raise SaltInvocationError('Signing file {} failed with proc.status {}'.format(abs_file, proc_exitstatus))\n    except salt.utils.vt.TerminalException as err:\n        trace = traceback.format_exc()\n        log.error(error_msg, err, trace)\n    finally:\n        proc.close(terminate=True, kill=True)",
            "def _sign_file(runas, define_gpg_name, phrase, abs_file, timeout):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Sign file with provided key and definition\\n    '\n    SIGN_PROMPT_RE = re.compile('Enter pass phrase: ', re.M)\n    interval = 0.5\n    number_retries = timeout / interval\n    times_looped = 0\n    error_msg = 'Failed to sign file {}'.format(abs_file)\n    cmd = 'rpm {} --addsign {}'.format(define_gpg_name, abs_file)\n    preexec_fn = functools.partial(salt.utils.user.chugid_and_umask, runas, None)\n    try:\n        (stdout, stderr) = (None, None)\n        proc = salt.utils.vt.Terminal(cmd, shell=True, preexec_fn=preexec_fn, stream_stdout=True, stream_stderr=True)\n        while proc.has_unread_data:\n            (stdout, stderr) = proc.recv()\n            if stdout and SIGN_PROMPT_RE.search(stdout):\n                proc.sendline(phrase)\n            else:\n                times_looped += 1\n            if times_looped > number_retries:\n                raise SaltInvocationError('Attemping to sign file {} failed, timed out after {} seconds'.format(abs_file, int(times_looped * interval)))\n            time.sleep(interval)\n        proc_exitstatus = proc.exitstatus\n        if proc_exitstatus != 0:\n            raise SaltInvocationError('Signing file {} failed with proc.status {}'.format(abs_file, proc_exitstatus))\n    except salt.utils.vt.TerminalException as err:\n        trace = traceback.format_exc()\n        log.error(error_msg, err, trace)\n    finally:\n        proc.close(terminate=True, kill=True)",
            "def _sign_file(runas, define_gpg_name, phrase, abs_file, timeout):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Sign file with provided key and definition\\n    '\n    SIGN_PROMPT_RE = re.compile('Enter pass phrase: ', re.M)\n    interval = 0.5\n    number_retries = timeout / interval\n    times_looped = 0\n    error_msg = 'Failed to sign file {}'.format(abs_file)\n    cmd = 'rpm {} --addsign {}'.format(define_gpg_name, abs_file)\n    preexec_fn = functools.partial(salt.utils.user.chugid_and_umask, runas, None)\n    try:\n        (stdout, stderr) = (None, None)\n        proc = salt.utils.vt.Terminal(cmd, shell=True, preexec_fn=preexec_fn, stream_stdout=True, stream_stderr=True)\n        while proc.has_unread_data:\n            (stdout, stderr) = proc.recv()\n            if stdout and SIGN_PROMPT_RE.search(stdout):\n                proc.sendline(phrase)\n            else:\n                times_looped += 1\n            if times_looped > number_retries:\n                raise SaltInvocationError('Attemping to sign file {} failed, timed out after {} seconds'.format(abs_file, int(times_looped * interval)))\n            time.sleep(interval)\n        proc_exitstatus = proc.exitstatus\n        if proc_exitstatus != 0:\n            raise SaltInvocationError('Signing file {} failed with proc.status {}'.format(abs_file, proc_exitstatus))\n    except salt.utils.vt.TerminalException as err:\n        trace = traceback.format_exc()\n        log.error(error_msg, err, trace)\n    finally:\n        proc.close(terminate=True, kill=True)",
            "def _sign_file(runas, define_gpg_name, phrase, abs_file, timeout):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Sign file with provided key and definition\\n    '\n    SIGN_PROMPT_RE = re.compile('Enter pass phrase: ', re.M)\n    interval = 0.5\n    number_retries = timeout / interval\n    times_looped = 0\n    error_msg = 'Failed to sign file {}'.format(abs_file)\n    cmd = 'rpm {} --addsign {}'.format(define_gpg_name, abs_file)\n    preexec_fn = functools.partial(salt.utils.user.chugid_and_umask, runas, None)\n    try:\n        (stdout, stderr) = (None, None)\n        proc = salt.utils.vt.Terminal(cmd, shell=True, preexec_fn=preexec_fn, stream_stdout=True, stream_stderr=True)\n        while proc.has_unread_data:\n            (stdout, stderr) = proc.recv()\n            if stdout and SIGN_PROMPT_RE.search(stdout):\n                proc.sendline(phrase)\n            else:\n                times_looped += 1\n            if times_looped > number_retries:\n                raise SaltInvocationError('Attemping to sign file {} failed, timed out after {} seconds'.format(abs_file, int(times_looped * interval)))\n            time.sleep(interval)\n        proc_exitstatus = proc.exitstatus\n        if proc_exitstatus != 0:\n            raise SaltInvocationError('Signing file {} failed with proc.status {}'.format(abs_file, proc_exitstatus))\n    except salt.utils.vt.TerminalException as err:\n        trace = traceback.format_exc()\n        log.error(error_msg, err, trace)\n    finally:\n        proc.close(terminate=True, kill=True)"
        ]
    },
    {
        "func_name": "_sign_files_with_gpg_agent",
        "original": "def _sign_files_with_gpg_agent(runas, local_keyid, abs_file, repodir, env, timeout):\n    \"\"\"\n    Sign file with provided key utilizing gpg-agent\n    \"\"\"\n    cmd = 'rpmsign --verbose  --key-id={} --addsign {}'.format(local_keyid, abs_file)\n    retrc = __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n    if retrc != 0:\n        raise SaltInvocationError(\"Signing encountered errors for command '{}', return error {}, check logs for further details\".format(cmd, retrc))",
        "mutated": [
            "def _sign_files_with_gpg_agent(runas, local_keyid, abs_file, repodir, env, timeout):\n    if False:\n        i = 10\n    '\\n    Sign file with provided key utilizing gpg-agent\\n    '\n    cmd = 'rpmsign --verbose  --key-id={} --addsign {}'.format(local_keyid, abs_file)\n    retrc = __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n    if retrc != 0:\n        raise SaltInvocationError(\"Signing encountered errors for command '{}', return error {}, check logs for further details\".format(cmd, retrc))",
            "def _sign_files_with_gpg_agent(runas, local_keyid, abs_file, repodir, env, timeout):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Sign file with provided key utilizing gpg-agent\\n    '\n    cmd = 'rpmsign --verbose  --key-id={} --addsign {}'.format(local_keyid, abs_file)\n    retrc = __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n    if retrc != 0:\n        raise SaltInvocationError(\"Signing encountered errors for command '{}', return error {}, check logs for further details\".format(cmd, retrc))",
            "def _sign_files_with_gpg_agent(runas, local_keyid, abs_file, repodir, env, timeout):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Sign file with provided key utilizing gpg-agent\\n    '\n    cmd = 'rpmsign --verbose  --key-id={} --addsign {}'.format(local_keyid, abs_file)\n    retrc = __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n    if retrc != 0:\n        raise SaltInvocationError(\"Signing encountered errors for command '{}', return error {}, check logs for further details\".format(cmd, retrc))",
            "def _sign_files_with_gpg_agent(runas, local_keyid, abs_file, repodir, env, timeout):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Sign file with provided key utilizing gpg-agent\\n    '\n    cmd = 'rpmsign --verbose  --key-id={} --addsign {}'.format(local_keyid, abs_file)\n    retrc = __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n    if retrc != 0:\n        raise SaltInvocationError(\"Signing encountered errors for command '{}', return error {}, check logs for further details\".format(cmd, retrc))",
            "def _sign_files_with_gpg_agent(runas, local_keyid, abs_file, repodir, env, timeout):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Sign file with provided key utilizing gpg-agent\\n    '\n    cmd = 'rpmsign --verbose  --key-id={} --addsign {}'.format(local_keyid, abs_file)\n    retrc = __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n    if retrc != 0:\n        raise SaltInvocationError(\"Signing encountered errors for command '{}', return error {}, check logs for further details\".format(cmd, retrc))"
        ]
    },
    {
        "func_name": "make_src_pkg",
        "original": "def make_src_pkg(dest_dir, spec, sources, env=None, template=None, saltenv='base', runas='root'):\n    \"\"\"\n    Create a source rpm from the given spec file and sources\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkgbuild.make_src_pkg /var/www/html/\n                https://raw.githubusercontent.com/saltstack/libnacl/master/pkg/rpm/python-libnacl.spec\n                https://pypi.python.org/packages/source/l/libnacl/libnacl-1.3.5.tar.gz\n\n    This example command should build the libnacl SOURCE package and place it in\n    /var/www/html/ on the minion\n\n    .. versionchanged:: 2017.7.0\n\n    dest_dir\n        The directory on the minion to place the built package(s)\n\n    spec\n        The location of the spec file (used for rpms)\n\n    sources\n        The list of package sources\n\n    env\n        A dictionary of environment variables to be set prior to execution.\n\n    template\n        Run the spec file through a templating engine\n        Optional argument, allows for no templating engine used to be\n        if none is desired.\n\n    saltenv\n        The saltenv to use for files downloaded from the salt filesever\n\n    runas\n        The user to run the build process as\n\n        .. versionadded:: 2018.3.3\n\n\n    .. note::\n\n        using SHA256 as digest and minimum level dist el6\n\n    \"\"\"\n    _create_rpmmacros(runas)\n    tree_base = _mk_tree(runas)\n    spec_path = _get_spec(tree_base, spec, template, saltenv)\n    __salt__['file.chown'](path=spec_path, user=runas, group='mock')\n    __salt__['file.chown'](path=tree_base, user=runas, group='mock')\n    if isinstance(sources, str):\n        sources = sources.split(',')\n    for src in sources:\n        _get_src(tree_base, src, saltenv, runas)\n    cmd = 'rpmbuild --verbose --define \"_topdir {}\" -bs --define \"dist .el6\" {}'.format(tree_base, spec_path)\n    retrc = __salt__['cmd.retcode'](cmd, runas=runas)\n    if retrc != 0:\n        raise SaltInvocationError('Make source package for destination directory {}, spec {}, sources {}, failed with return error {}, check logs for further details'.format(dest_dir, spec, sources, retrc))\n    srpms = os.path.join(tree_base, 'SRPMS')\n    ret = []\n    if not os.path.isdir(dest_dir):\n        __salt__['file.makedirs_perms'](name=dest_dir, user=runas, group='mock')\n    for fn_ in os.listdir(srpms):\n        full = os.path.join(srpms, fn_)\n        tgt = os.path.join(dest_dir, fn_)\n        shutil.copy(full, tgt)\n        ret.append(tgt)\n    return ret",
        "mutated": [
            "def make_src_pkg(dest_dir, spec, sources, env=None, template=None, saltenv='base', runas='root'):\n    if False:\n        i = 10\n    \"\\n    Create a source rpm from the given spec file and sources\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkgbuild.make_src_pkg /var/www/html/\\n                https://raw.githubusercontent.com/saltstack/libnacl/master/pkg/rpm/python-libnacl.spec\\n                https://pypi.python.org/packages/source/l/libnacl/libnacl-1.3.5.tar.gz\\n\\n    This example command should build the libnacl SOURCE package and place it in\\n    /var/www/html/ on the minion\\n\\n    .. versionchanged:: 2017.7.0\\n\\n    dest_dir\\n        The directory on the minion to place the built package(s)\\n\\n    spec\\n        The location of the spec file (used for rpms)\\n\\n    sources\\n        The list of package sources\\n\\n    env\\n        A dictionary of environment variables to be set prior to execution.\\n\\n    template\\n        Run the spec file through a templating engine\\n        Optional argument, allows for no templating engine used to be\\n        if none is desired.\\n\\n    saltenv\\n        The saltenv to use for files downloaded from the salt filesever\\n\\n    runas\\n        The user to run the build process as\\n\\n        .. versionadded:: 2018.3.3\\n\\n\\n    .. note::\\n\\n        using SHA256 as digest and minimum level dist el6\\n\\n    \"\n    _create_rpmmacros(runas)\n    tree_base = _mk_tree(runas)\n    spec_path = _get_spec(tree_base, spec, template, saltenv)\n    __salt__['file.chown'](path=spec_path, user=runas, group='mock')\n    __salt__['file.chown'](path=tree_base, user=runas, group='mock')\n    if isinstance(sources, str):\n        sources = sources.split(',')\n    for src in sources:\n        _get_src(tree_base, src, saltenv, runas)\n    cmd = 'rpmbuild --verbose --define \"_topdir {}\" -bs --define \"dist .el6\" {}'.format(tree_base, spec_path)\n    retrc = __salt__['cmd.retcode'](cmd, runas=runas)\n    if retrc != 0:\n        raise SaltInvocationError('Make source package for destination directory {}, spec {}, sources {}, failed with return error {}, check logs for further details'.format(dest_dir, spec, sources, retrc))\n    srpms = os.path.join(tree_base, 'SRPMS')\n    ret = []\n    if not os.path.isdir(dest_dir):\n        __salt__['file.makedirs_perms'](name=dest_dir, user=runas, group='mock')\n    for fn_ in os.listdir(srpms):\n        full = os.path.join(srpms, fn_)\n        tgt = os.path.join(dest_dir, fn_)\n        shutil.copy(full, tgt)\n        ret.append(tgt)\n    return ret",
            "def make_src_pkg(dest_dir, spec, sources, env=None, template=None, saltenv='base', runas='root'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Create a source rpm from the given spec file and sources\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkgbuild.make_src_pkg /var/www/html/\\n                https://raw.githubusercontent.com/saltstack/libnacl/master/pkg/rpm/python-libnacl.spec\\n                https://pypi.python.org/packages/source/l/libnacl/libnacl-1.3.5.tar.gz\\n\\n    This example command should build the libnacl SOURCE package and place it in\\n    /var/www/html/ on the minion\\n\\n    .. versionchanged:: 2017.7.0\\n\\n    dest_dir\\n        The directory on the minion to place the built package(s)\\n\\n    spec\\n        The location of the spec file (used for rpms)\\n\\n    sources\\n        The list of package sources\\n\\n    env\\n        A dictionary of environment variables to be set prior to execution.\\n\\n    template\\n        Run the spec file through a templating engine\\n        Optional argument, allows for no templating engine used to be\\n        if none is desired.\\n\\n    saltenv\\n        The saltenv to use for files downloaded from the salt filesever\\n\\n    runas\\n        The user to run the build process as\\n\\n        .. versionadded:: 2018.3.3\\n\\n\\n    .. note::\\n\\n        using SHA256 as digest and minimum level dist el6\\n\\n    \"\n    _create_rpmmacros(runas)\n    tree_base = _mk_tree(runas)\n    spec_path = _get_spec(tree_base, spec, template, saltenv)\n    __salt__['file.chown'](path=spec_path, user=runas, group='mock')\n    __salt__['file.chown'](path=tree_base, user=runas, group='mock')\n    if isinstance(sources, str):\n        sources = sources.split(',')\n    for src in sources:\n        _get_src(tree_base, src, saltenv, runas)\n    cmd = 'rpmbuild --verbose --define \"_topdir {}\" -bs --define \"dist .el6\" {}'.format(tree_base, spec_path)\n    retrc = __salt__['cmd.retcode'](cmd, runas=runas)\n    if retrc != 0:\n        raise SaltInvocationError('Make source package for destination directory {}, spec {}, sources {}, failed with return error {}, check logs for further details'.format(dest_dir, spec, sources, retrc))\n    srpms = os.path.join(tree_base, 'SRPMS')\n    ret = []\n    if not os.path.isdir(dest_dir):\n        __salt__['file.makedirs_perms'](name=dest_dir, user=runas, group='mock')\n    for fn_ in os.listdir(srpms):\n        full = os.path.join(srpms, fn_)\n        tgt = os.path.join(dest_dir, fn_)\n        shutil.copy(full, tgt)\n        ret.append(tgt)\n    return ret",
            "def make_src_pkg(dest_dir, spec, sources, env=None, template=None, saltenv='base', runas='root'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Create a source rpm from the given spec file and sources\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkgbuild.make_src_pkg /var/www/html/\\n                https://raw.githubusercontent.com/saltstack/libnacl/master/pkg/rpm/python-libnacl.spec\\n                https://pypi.python.org/packages/source/l/libnacl/libnacl-1.3.5.tar.gz\\n\\n    This example command should build the libnacl SOURCE package and place it in\\n    /var/www/html/ on the minion\\n\\n    .. versionchanged:: 2017.7.0\\n\\n    dest_dir\\n        The directory on the minion to place the built package(s)\\n\\n    spec\\n        The location of the spec file (used for rpms)\\n\\n    sources\\n        The list of package sources\\n\\n    env\\n        A dictionary of environment variables to be set prior to execution.\\n\\n    template\\n        Run the spec file through a templating engine\\n        Optional argument, allows for no templating engine used to be\\n        if none is desired.\\n\\n    saltenv\\n        The saltenv to use for files downloaded from the salt filesever\\n\\n    runas\\n        The user to run the build process as\\n\\n        .. versionadded:: 2018.3.3\\n\\n\\n    .. note::\\n\\n        using SHA256 as digest and minimum level dist el6\\n\\n    \"\n    _create_rpmmacros(runas)\n    tree_base = _mk_tree(runas)\n    spec_path = _get_spec(tree_base, spec, template, saltenv)\n    __salt__['file.chown'](path=spec_path, user=runas, group='mock')\n    __salt__['file.chown'](path=tree_base, user=runas, group='mock')\n    if isinstance(sources, str):\n        sources = sources.split(',')\n    for src in sources:\n        _get_src(tree_base, src, saltenv, runas)\n    cmd = 'rpmbuild --verbose --define \"_topdir {}\" -bs --define \"dist .el6\" {}'.format(tree_base, spec_path)\n    retrc = __salt__['cmd.retcode'](cmd, runas=runas)\n    if retrc != 0:\n        raise SaltInvocationError('Make source package for destination directory {}, spec {}, sources {}, failed with return error {}, check logs for further details'.format(dest_dir, spec, sources, retrc))\n    srpms = os.path.join(tree_base, 'SRPMS')\n    ret = []\n    if not os.path.isdir(dest_dir):\n        __salt__['file.makedirs_perms'](name=dest_dir, user=runas, group='mock')\n    for fn_ in os.listdir(srpms):\n        full = os.path.join(srpms, fn_)\n        tgt = os.path.join(dest_dir, fn_)\n        shutil.copy(full, tgt)\n        ret.append(tgt)\n    return ret",
            "def make_src_pkg(dest_dir, spec, sources, env=None, template=None, saltenv='base', runas='root'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Create a source rpm from the given spec file and sources\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkgbuild.make_src_pkg /var/www/html/\\n                https://raw.githubusercontent.com/saltstack/libnacl/master/pkg/rpm/python-libnacl.spec\\n                https://pypi.python.org/packages/source/l/libnacl/libnacl-1.3.5.tar.gz\\n\\n    This example command should build the libnacl SOURCE package and place it in\\n    /var/www/html/ on the minion\\n\\n    .. versionchanged:: 2017.7.0\\n\\n    dest_dir\\n        The directory on the minion to place the built package(s)\\n\\n    spec\\n        The location of the spec file (used for rpms)\\n\\n    sources\\n        The list of package sources\\n\\n    env\\n        A dictionary of environment variables to be set prior to execution.\\n\\n    template\\n        Run the spec file through a templating engine\\n        Optional argument, allows for no templating engine used to be\\n        if none is desired.\\n\\n    saltenv\\n        The saltenv to use for files downloaded from the salt filesever\\n\\n    runas\\n        The user to run the build process as\\n\\n        .. versionadded:: 2018.3.3\\n\\n\\n    .. note::\\n\\n        using SHA256 as digest and minimum level dist el6\\n\\n    \"\n    _create_rpmmacros(runas)\n    tree_base = _mk_tree(runas)\n    spec_path = _get_spec(tree_base, spec, template, saltenv)\n    __salt__['file.chown'](path=spec_path, user=runas, group='mock')\n    __salt__['file.chown'](path=tree_base, user=runas, group='mock')\n    if isinstance(sources, str):\n        sources = sources.split(',')\n    for src in sources:\n        _get_src(tree_base, src, saltenv, runas)\n    cmd = 'rpmbuild --verbose --define \"_topdir {}\" -bs --define \"dist .el6\" {}'.format(tree_base, spec_path)\n    retrc = __salt__['cmd.retcode'](cmd, runas=runas)\n    if retrc != 0:\n        raise SaltInvocationError('Make source package for destination directory {}, spec {}, sources {}, failed with return error {}, check logs for further details'.format(dest_dir, spec, sources, retrc))\n    srpms = os.path.join(tree_base, 'SRPMS')\n    ret = []\n    if not os.path.isdir(dest_dir):\n        __salt__['file.makedirs_perms'](name=dest_dir, user=runas, group='mock')\n    for fn_ in os.listdir(srpms):\n        full = os.path.join(srpms, fn_)\n        tgt = os.path.join(dest_dir, fn_)\n        shutil.copy(full, tgt)\n        ret.append(tgt)\n    return ret",
            "def make_src_pkg(dest_dir, spec, sources, env=None, template=None, saltenv='base', runas='root'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Create a source rpm from the given spec file and sources\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkgbuild.make_src_pkg /var/www/html/\\n                https://raw.githubusercontent.com/saltstack/libnacl/master/pkg/rpm/python-libnacl.spec\\n                https://pypi.python.org/packages/source/l/libnacl/libnacl-1.3.5.tar.gz\\n\\n    This example command should build the libnacl SOURCE package and place it in\\n    /var/www/html/ on the minion\\n\\n    .. versionchanged:: 2017.7.0\\n\\n    dest_dir\\n        The directory on the minion to place the built package(s)\\n\\n    spec\\n        The location of the spec file (used for rpms)\\n\\n    sources\\n        The list of package sources\\n\\n    env\\n        A dictionary of environment variables to be set prior to execution.\\n\\n    template\\n        Run the spec file through a templating engine\\n        Optional argument, allows for no templating engine used to be\\n        if none is desired.\\n\\n    saltenv\\n        The saltenv to use for files downloaded from the salt filesever\\n\\n    runas\\n        The user to run the build process as\\n\\n        .. versionadded:: 2018.3.3\\n\\n\\n    .. note::\\n\\n        using SHA256 as digest and minimum level dist el6\\n\\n    \"\n    _create_rpmmacros(runas)\n    tree_base = _mk_tree(runas)\n    spec_path = _get_spec(tree_base, spec, template, saltenv)\n    __salt__['file.chown'](path=spec_path, user=runas, group='mock')\n    __salt__['file.chown'](path=tree_base, user=runas, group='mock')\n    if isinstance(sources, str):\n        sources = sources.split(',')\n    for src in sources:\n        _get_src(tree_base, src, saltenv, runas)\n    cmd = 'rpmbuild --verbose --define \"_topdir {}\" -bs --define \"dist .el6\" {}'.format(tree_base, spec_path)\n    retrc = __salt__['cmd.retcode'](cmd, runas=runas)\n    if retrc != 0:\n        raise SaltInvocationError('Make source package for destination directory {}, spec {}, sources {}, failed with return error {}, check logs for further details'.format(dest_dir, spec, sources, retrc))\n    srpms = os.path.join(tree_base, 'SRPMS')\n    ret = []\n    if not os.path.isdir(dest_dir):\n        __salt__['file.makedirs_perms'](name=dest_dir, user=runas, group='mock')\n    for fn_ in os.listdir(srpms):\n        full = os.path.join(srpms, fn_)\n        tgt = os.path.join(dest_dir, fn_)\n        shutil.copy(full, tgt)\n        ret.append(tgt)\n    return ret"
        ]
    },
    {
        "func_name": "build",
        "original": "def build(runas, tgt, dest_dir, spec, sources, deps, env, template, saltenv='base', log_dir='/var/log/salt/pkgbuild'):\n    \"\"\"\n    Given the package destination directory, the spec file source and package\n    sources, use mock to safely build the rpm defined in the spec file\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkgbuild.build mock epel-7-x86_64 /var/www/html\n                    https://raw.githubusercontent.com/saltstack/libnacl/master/pkg/rpm/python-libnacl.spec\n                    https://pypi.python.org/packages/source/l/libnacl/libnacl-1.3.5.tar.gz\n\n    This example command should build the libnacl package for rhel 7 using user\n    mock and place it in /var/www/html/ on the minion\n    \"\"\"\n    ret = {}\n    try:\n        __salt__['file.chown'](path=dest_dir, user=runas, group='mock')\n    except OSError as exc:\n        if exc.errno != errno.EEXIST:\n            raise\n    srpm_dir = os.path.join(dest_dir, 'SRPMS')\n    srpm_build_dir = tempfile.mkdtemp()\n    try:\n        srpms = make_src_pkg(srpm_build_dir, spec, sources, env, template, saltenv, runas)\n    except Exception as exc:\n        shutil.rmtree(srpm_build_dir)\n        log.error('Failed to make src package')\n        return ret\n    distset = _get_distset(tgt)\n    noclean = ''\n    deps_dir = tempfile.mkdtemp()\n    deps_list = _get_deps(deps, deps_dir, saltenv)\n    retrc = 0\n    for srpm in srpms:\n        dbase = os.path.dirname(srpm)\n        results_dir = tempfile.mkdtemp()\n        try:\n            __salt__['file.chown'](path=dbase, user=runas, group='mock')\n            __salt__['file.chown'](path=results_dir, user=runas, group='mock')\n            cmd = 'mock --root={} --resultdir={} --init'.format(tgt, results_dir)\n            retrc |= __salt__['cmd.retcode'](cmd, runas=runas)\n            if deps_list and (not deps_list.isspace()):\n                cmd = 'mock --root={} --resultdir={} --install {} {}'.format(tgt, results_dir, deps_list, noclean)\n                retrc |= __salt__['cmd.retcode'](cmd, runas=runas)\n                noclean += ' --no-clean'\n            cmd = 'mock --root={} --resultdir={} {} {} {}'.format(tgt, results_dir, distset, noclean, srpm)\n            retrc |= __salt__['cmd.retcode'](cmd, runas=runas)\n            cmdlist = ['rpm', '-qp', '--queryformat', '{0}/%{{name}}/%{{version}}-%{{release}}'.format(log_dir), srpm]\n            log_dest = __salt__['cmd.run_stdout'](cmdlist, python_shell=False)\n            for filename in os.listdir(results_dir):\n                full = os.path.join(results_dir, filename)\n                if filename.endswith('src.rpm'):\n                    sdest = os.path.join(srpm_dir, filename)\n                    try:\n                        __salt__['file.makedirs_perms'](name=srpm_dir, user=runas, group='mock')\n                    except OSError as exc:\n                        if exc.errno != errno.EEXIST:\n                            raise\n                    shutil.copy(full, sdest)\n                    ret.setdefault('Source Packages', []).append(sdest)\n                elif filename.endswith('.rpm'):\n                    bdist = os.path.join(dest_dir, filename)\n                    shutil.copy(full, bdist)\n                    ret.setdefault('Packages', []).append(bdist)\n                else:\n                    log_file = os.path.join(log_dest, filename)\n                    try:\n                        __salt__['file.makedirs_perms'](name=log_dest, user=runas, group='mock')\n                    except OSError as exc:\n                        if exc.errno != errno.EEXIST:\n                            raise\n                    shutil.copy(full, log_file)\n                    ret.setdefault('Log Files', []).append(log_file)\n        except Exception as exc:\n            log.error('Error building from %s: %s', srpm, exc)\n        finally:\n            shutil.rmtree(results_dir)\n    if retrc != 0:\n        raise SaltInvocationError('Building packages for destination directory {}, spec {}, sources {}, failed with return error {}, check logs for further details'.format(dest_dir, spec, sources, retrc))\n    shutil.rmtree(deps_dir)\n    shutil.rmtree(srpm_build_dir)\n    return ret",
        "mutated": [
            "def build(runas, tgt, dest_dir, spec, sources, deps, env, template, saltenv='base', log_dir='/var/log/salt/pkgbuild'):\n    if False:\n        i = 10\n    \"\\n    Given the package destination directory, the spec file source and package\\n    sources, use mock to safely build the rpm defined in the spec file\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkgbuild.build mock epel-7-x86_64 /var/www/html\\n                    https://raw.githubusercontent.com/saltstack/libnacl/master/pkg/rpm/python-libnacl.spec\\n                    https://pypi.python.org/packages/source/l/libnacl/libnacl-1.3.5.tar.gz\\n\\n    This example command should build the libnacl package for rhel 7 using user\\n    mock and place it in /var/www/html/ on the minion\\n    \"\n    ret = {}\n    try:\n        __salt__['file.chown'](path=dest_dir, user=runas, group='mock')\n    except OSError as exc:\n        if exc.errno != errno.EEXIST:\n            raise\n    srpm_dir = os.path.join(dest_dir, 'SRPMS')\n    srpm_build_dir = tempfile.mkdtemp()\n    try:\n        srpms = make_src_pkg(srpm_build_dir, spec, sources, env, template, saltenv, runas)\n    except Exception as exc:\n        shutil.rmtree(srpm_build_dir)\n        log.error('Failed to make src package')\n        return ret\n    distset = _get_distset(tgt)\n    noclean = ''\n    deps_dir = tempfile.mkdtemp()\n    deps_list = _get_deps(deps, deps_dir, saltenv)\n    retrc = 0\n    for srpm in srpms:\n        dbase = os.path.dirname(srpm)\n        results_dir = tempfile.mkdtemp()\n        try:\n            __salt__['file.chown'](path=dbase, user=runas, group='mock')\n            __salt__['file.chown'](path=results_dir, user=runas, group='mock')\n            cmd = 'mock --root={} --resultdir={} --init'.format(tgt, results_dir)\n            retrc |= __salt__['cmd.retcode'](cmd, runas=runas)\n            if deps_list and (not deps_list.isspace()):\n                cmd = 'mock --root={} --resultdir={} --install {} {}'.format(tgt, results_dir, deps_list, noclean)\n                retrc |= __salt__['cmd.retcode'](cmd, runas=runas)\n                noclean += ' --no-clean'\n            cmd = 'mock --root={} --resultdir={} {} {} {}'.format(tgt, results_dir, distset, noclean, srpm)\n            retrc |= __salt__['cmd.retcode'](cmd, runas=runas)\n            cmdlist = ['rpm', '-qp', '--queryformat', '{0}/%{{name}}/%{{version}}-%{{release}}'.format(log_dir), srpm]\n            log_dest = __salt__['cmd.run_stdout'](cmdlist, python_shell=False)\n            for filename in os.listdir(results_dir):\n                full = os.path.join(results_dir, filename)\n                if filename.endswith('src.rpm'):\n                    sdest = os.path.join(srpm_dir, filename)\n                    try:\n                        __salt__['file.makedirs_perms'](name=srpm_dir, user=runas, group='mock')\n                    except OSError as exc:\n                        if exc.errno != errno.EEXIST:\n                            raise\n                    shutil.copy(full, sdest)\n                    ret.setdefault('Source Packages', []).append(sdest)\n                elif filename.endswith('.rpm'):\n                    bdist = os.path.join(dest_dir, filename)\n                    shutil.copy(full, bdist)\n                    ret.setdefault('Packages', []).append(bdist)\n                else:\n                    log_file = os.path.join(log_dest, filename)\n                    try:\n                        __salt__['file.makedirs_perms'](name=log_dest, user=runas, group='mock')\n                    except OSError as exc:\n                        if exc.errno != errno.EEXIST:\n                            raise\n                    shutil.copy(full, log_file)\n                    ret.setdefault('Log Files', []).append(log_file)\n        except Exception as exc:\n            log.error('Error building from %s: %s', srpm, exc)\n        finally:\n            shutil.rmtree(results_dir)\n    if retrc != 0:\n        raise SaltInvocationError('Building packages for destination directory {}, spec {}, sources {}, failed with return error {}, check logs for further details'.format(dest_dir, spec, sources, retrc))\n    shutil.rmtree(deps_dir)\n    shutil.rmtree(srpm_build_dir)\n    return ret",
            "def build(runas, tgt, dest_dir, spec, sources, deps, env, template, saltenv='base', log_dir='/var/log/salt/pkgbuild'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Given the package destination directory, the spec file source and package\\n    sources, use mock to safely build the rpm defined in the spec file\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkgbuild.build mock epel-7-x86_64 /var/www/html\\n                    https://raw.githubusercontent.com/saltstack/libnacl/master/pkg/rpm/python-libnacl.spec\\n                    https://pypi.python.org/packages/source/l/libnacl/libnacl-1.3.5.tar.gz\\n\\n    This example command should build the libnacl package for rhel 7 using user\\n    mock and place it in /var/www/html/ on the minion\\n    \"\n    ret = {}\n    try:\n        __salt__['file.chown'](path=dest_dir, user=runas, group='mock')\n    except OSError as exc:\n        if exc.errno != errno.EEXIST:\n            raise\n    srpm_dir = os.path.join(dest_dir, 'SRPMS')\n    srpm_build_dir = tempfile.mkdtemp()\n    try:\n        srpms = make_src_pkg(srpm_build_dir, spec, sources, env, template, saltenv, runas)\n    except Exception as exc:\n        shutil.rmtree(srpm_build_dir)\n        log.error('Failed to make src package')\n        return ret\n    distset = _get_distset(tgt)\n    noclean = ''\n    deps_dir = tempfile.mkdtemp()\n    deps_list = _get_deps(deps, deps_dir, saltenv)\n    retrc = 0\n    for srpm in srpms:\n        dbase = os.path.dirname(srpm)\n        results_dir = tempfile.mkdtemp()\n        try:\n            __salt__['file.chown'](path=dbase, user=runas, group='mock')\n            __salt__['file.chown'](path=results_dir, user=runas, group='mock')\n            cmd = 'mock --root={} --resultdir={} --init'.format(tgt, results_dir)\n            retrc |= __salt__['cmd.retcode'](cmd, runas=runas)\n            if deps_list and (not deps_list.isspace()):\n                cmd = 'mock --root={} --resultdir={} --install {} {}'.format(tgt, results_dir, deps_list, noclean)\n                retrc |= __salt__['cmd.retcode'](cmd, runas=runas)\n                noclean += ' --no-clean'\n            cmd = 'mock --root={} --resultdir={} {} {} {}'.format(tgt, results_dir, distset, noclean, srpm)\n            retrc |= __salt__['cmd.retcode'](cmd, runas=runas)\n            cmdlist = ['rpm', '-qp', '--queryformat', '{0}/%{{name}}/%{{version}}-%{{release}}'.format(log_dir), srpm]\n            log_dest = __salt__['cmd.run_stdout'](cmdlist, python_shell=False)\n            for filename in os.listdir(results_dir):\n                full = os.path.join(results_dir, filename)\n                if filename.endswith('src.rpm'):\n                    sdest = os.path.join(srpm_dir, filename)\n                    try:\n                        __salt__['file.makedirs_perms'](name=srpm_dir, user=runas, group='mock')\n                    except OSError as exc:\n                        if exc.errno != errno.EEXIST:\n                            raise\n                    shutil.copy(full, sdest)\n                    ret.setdefault('Source Packages', []).append(sdest)\n                elif filename.endswith('.rpm'):\n                    bdist = os.path.join(dest_dir, filename)\n                    shutil.copy(full, bdist)\n                    ret.setdefault('Packages', []).append(bdist)\n                else:\n                    log_file = os.path.join(log_dest, filename)\n                    try:\n                        __salt__['file.makedirs_perms'](name=log_dest, user=runas, group='mock')\n                    except OSError as exc:\n                        if exc.errno != errno.EEXIST:\n                            raise\n                    shutil.copy(full, log_file)\n                    ret.setdefault('Log Files', []).append(log_file)\n        except Exception as exc:\n            log.error('Error building from %s: %s', srpm, exc)\n        finally:\n            shutil.rmtree(results_dir)\n    if retrc != 0:\n        raise SaltInvocationError('Building packages for destination directory {}, spec {}, sources {}, failed with return error {}, check logs for further details'.format(dest_dir, spec, sources, retrc))\n    shutil.rmtree(deps_dir)\n    shutil.rmtree(srpm_build_dir)\n    return ret",
            "def build(runas, tgt, dest_dir, spec, sources, deps, env, template, saltenv='base', log_dir='/var/log/salt/pkgbuild'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Given the package destination directory, the spec file source and package\\n    sources, use mock to safely build the rpm defined in the spec file\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkgbuild.build mock epel-7-x86_64 /var/www/html\\n                    https://raw.githubusercontent.com/saltstack/libnacl/master/pkg/rpm/python-libnacl.spec\\n                    https://pypi.python.org/packages/source/l/libnacl/libnacl-1.3.5.tar.gz\\n\\n    This example command should build the libnacl package for rhel 7 using user\\n    mock and place it in /var/www/html/ on the minion\\n    \"\n    ret = {}\n    try:\n        __salt__['file.chown'](path=dest_dir, user=runas, group='mock')\n    except OSError as exc:\n        if exc.errno != errno.EEXIST:\n            raise\n    srpm_dir = os.path.join(dest_dir, 'SRPMS')\n    srpm_build_dir = tempfile.mkdtemp()\n    try:\n        srpms = make_src_pkg(srpm_build_dir, spec, sources, env, template, saltenv, runas)\n    except Exception as exc:\n        shutil.rmtree(srpm_build_dir)\n        log.error('Failed to make src package')\n        return ret\n    distset = _get_distset(tgt)\n    noclean = ''\n    deps_dir = tempfile.mkdtemp()\n    deps_list = _get_deps(deps, deps_dir, saltenv)\n    retrc = 0\n    for srpm in srpms:\n        dbase = os.path.dirname(srpm)\n        results_dir = tempfile.mkdtemp()\n        try:\n            __salt__['file.chown'](path=dbase, user=runas, group='mock')\n            __salt__['file.chown'](path=results_dir, user=runas, group='mock')\n            cmd = 'mock --root={} --resultdir={} --init'.format(tgt, results_dir)\n            retrc |= __salt__['cmd.retcode'](cmd, runas=runas)\n            if deps_list and (not deps_list.isspace()):\n                cmd = 'mock --root={} --resultdir={} --install {} {}'.format(tgt, results_dir, deps_list, noclean)\n                retrc |= __salt__['cmd.retcode'](cmd, runas=runas)\n                noclean += ' --no-clean'\n            cmd = 'mock --root={} --resultdir={} {} {} {}'.format(tgt, results_dir, distset, noclean, srpm)\n            retrc |= __salt__['cmd.retcode'](cmd, runas=runas)\n            cmdlist = ['rpm', '-qp', '--queryformat', '{0}/%{{name}}/%{{version}}-%{{release}}'.format(log_dir), srpm]\n            log_dest = __salt__['cmd.run_stdout'](cmdlist, python_shell=False)\n            for filename in os.listdir(results_dir):\n                full = os.path.join(results_dir, filename)\n                if filename.endswith('src.rpm'):\n                    sdest = os.path.join(srpm_dir, filename)\n                    try:\n                        __salt__['file.makedirs_perms'](name=srpm_dir, user=runas, group='mock')\n                    except OSError as exc:\n                        if exc.errno != errno.EEXIST:\n                            raise\n                    shutil.copy(full, sdest)\n                    ret.setdefault('Source Packages', []).append(sdest)\n                elif filename.endswith('.rpm'):\n                    bdist = os.path.join(dest_dir, filename)\n                    shutil.copy(full, bdist)\n                    ret.setdefault('Packages', []).append(bdist)\n                else:\n                    log_file = os.path.join(log_dest, filename)\n                    try:\n                        __salt__['file.makedirs_perms'](name=log_dest, user=runas, group='mock')\n                    except OSError as exc:\n                        if exc.errno != errno.EEXIST:\n                            raise\n                    shutil.copy(full, log_file)\n                    ret.setdefault('Log Files', []).append(log_file)\n        except Exception as exc:\n            log.error('Error building from %s: %s', srpm, exc)\n        finally:\n            shutil.rmtree(results_dir)\n    if retrc != 0:\n        raise SaltInvocationError('Building packages for destination directory {}, spec {}, sources {}, failed with return error {}, check logs for further details'.format(dest_dir, spec, sources, retrc))\n    shutil.rmtree(deps_dir)\n    shutil.rmtree(srpm_build_dir)\n    return ret",
            "def build(runas, tgt, dest_dir, spec, sources, deps, env, template, saltenv='base', log_dir='/var/log/salt/pkgbuild'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Given the package destination directory, the spec file source and package\\n    sources, use mock to safely build the rpm defined in the spec file\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkgbuild.build mock epel-7-x86_64 /var/www/html\\n                    https://raw.githubusercontent.com/saltstack/libnacl/master/pkg/rpm/python-libnacl.spec\\n                    https://pypi.python.org/packages/source/l/libnacl/libnacl-1.3.5.tar.gz\\n\\n    This example command should build the libnacl package for rhel 7 using user\\n    mock and place it in /var/www/html/ on the minion\\n    \"\n    ret = {}\n    try:\n        __salt__['file.chown'](path=dest_dir, user=runas, group='mock')\n    except OSError as exc:\n        if exc.errno != errno.EEXIST:\n            raise\n    srpm_dir = os.path.join(dest_dir, 'SRPMS')\n    srpm_build_dir = tempfile.mkdtemp()\n    try:\n        srpms = make_src_pkg(srpm_build_dir, spec, sources, env, template, saltenv, runas)\n    except Exception as exc:\n        shutil.rmtree(srpm_build_dir)\n        log.error('Failed to make src package')\n        return ret\n    distset = _get_distset(tgt)\n    noclean = ''\n    deps_dir = tempfile.mkdtemp()\n    deps_list = _get_deps(deps, deps_dir, saltenv)\n    retrc = 0\n    for srpm in srpms:\n        dbase = os.path.dirname(srpm)\n        results_dir = tempfile.mkdtemp()\n        try:\n            __salt__['file.chown'](path=dbase, user=runas, group='mock')\n            __salt__['file.chown'](path=results_dir, user=runas, group='mock')\n            cmd = 'mock --root={} --resultdir={} --init'.format(tgt, results_dir)\n            retrc |= __salt__['cmd.retcode'](cmd, runas=runas)\n            if deps_list and (not deps_list.isspace()):\n                cmd = 'mock --root={} --resultdir={} --install {} {}'.format(tgt, results_dir, deps_list, noclean)\n                retrc |= __salt__['cmd.retcode'](cmd, runas=runas)\n                noclean += ' --no-clean'\n            cmd = 'mock --root={} --resultdir={} {} {} {}'.format(tgt, results_dir, distset, noclean, srpm)\n            retrc |= __salt__['cmd.retcode'](cmd, runas=runas)\n            cmdlist = ['rpm', '-qp', '--queryformat', '{0}/%{{name}}/%{{version}}-%{{release}}'.format(log_dir), srpm]\n            log_dest = __salt__['cmd.run_stdout'](cmdlist, python_shell=False)\n            for filename in os.listdir(results_dir):\n                full = os.path.join(results_dir, filename)\n                if filename.endswith('src.rpm'):\n                    sdest = os.path.join(srpm_dir, filename)\n                    try:\n                        __salt__['file.makedirs_perms'](name=srpm_dir, user=runas, group='mock')\n                    except OSError as exc:\n                        if exc.errno != errno.EEXIST:\n                            raise\n                    shutil.copy(full, sdest)\n                    ret.setdefault('Source Packages', []).append(sdest)\n                elif filename.endswith('.rpm'):\n                    bdist = os.path.join(dest_dir, filename)\n                    shutil.copy(full, bdist)\n                    ret.setdefault('Packages', []).append(bdist)\n                else:\n                    log_file = os.path.join(log_dest, filename)\n                    try:\n                        __salt__['file.makedirs_perms'](name=log_dest, user=runas, group='mock')\n                    except OSError as exc:\n                        if exc.errno != errno.EEXIST:\n                            raise\n                    shutil.copy(full, log_file)\n                    ret.setdefault('Log Files', []).append(log_file)\n        except Exception as exc:\n            log.error('Error building from %s: %s', srpm, exc)\n        finally:\n            shutil.rmtree(results_dir)\n    if retrc != 0:\n        raise SaltInvocationError('Building packages for destination directory {}, spec {}, sources {}, failed with return error {}, check logs for further details'.format(dest_dir, spec, sources, retrc))\n    shutil.rmtree(deps_dir)\n    shutil.rmtree(srpm_build_dir)\n    return ret",
            "def build(runas, tgt, dest_dir, spec, sources, deps, env, template, saltenv='base', log_dir='/var/log/salt/pkgbuild'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Given the package destination directory, the spec file source and package\\n    sources, use mock to safely build the rpm defined in the spec file\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkgbuild.build mock epel-7-x86_64 /var/www/html\\n                    https://raw.githubusercontent.com/saltstack/libnacl/master/pkg/rpm/python-libnacl.spec\\n                    https://pypi.python.org/packages/source/l/libnacl/libnacl-1.3.5.tar.gz\\n\\n    This example command should build the libnacl package for rhel 7 using user\\n    mock and place it in /var/www/html/ on the minion\\n    \"\n    ret = {}\n    try:\n        __salt__['file.chown'](path=dest_dir, user=runas, group='mock')\n    except OSError as exc:\n        if exc.errno != errno.EEXIST:\n            raise\n    srpm_dir = os.path.join(dest_dir, 'SRPMS')\n    srpm_build_dir = tempfile.mkdtemp()\n    try:\n        srpms = make_src_pkg(srpm_build_dir, spec, sources, env, template, saltenv, runas)\n    except Exception as exc:\n        shutil.rmtree(srpm_build_dir)\n        log.error('Failed to make src package')\n        return ret\n    distset = _get_distset(tgt)\n    noclean = ''\n    deps_dir = tempfile.mkdtemp()\n    deps_list = _get_deps(deps, deps_dir, saltenv)\n    retrc = 0\n    for srpm in srpms:\n        dbase = os.path.dirname(srpm)\n        results_dir = tempfile.mkdtemp()\n        try:\n            __salt__['file.chown'](path=dbase, user=runas, group='mock')\n            __salt__['file.chown'](path=results_dir, user=runas, group='mock')\n            cmd = 'mock --root={} --resultdir={} --init'.format(tgt, results_dir)\n            retrc |= __salt__['cmd.retcode'](cmd, runas=runas)\n            if deps_list and (not deps_list.isspace()):\n                cmd = 'mock --root={} --resultdir={} --install {} {}'.format(tgt, results_dir, deps_list, noclean)\n                retrc |= __salt__['cmd.retcode'](cmd, runas=runas)\n                noclean += ' --no-clean'\n            cmd = 'mock --root={} --resultdir={} {} {} {}'.format(tgt, results_dir, distset, noclean, srpm)\n            retrc |= __salt__['cmd.retcode'](cmd, runas=runas)\n            cmdlist = ['rpm', '-qp', '--queryformat', '{0}/%{{name}}/%{{version}}-%{{release}}'.format(log_dir), srpm]\n            log_dest = __salt__['cmd.run_stdout'](cmdlist, python_shell=False)\n            for filename in os.listdir(results_dir):\n                full = os.path.join(results_dir, filename)\n                if filename.endswith('src.rpm'):\n                    sdest = os.path.join(srpm_dir, filename)\n                    try:\n                        __salt__['file.makedirs_perms'](name=srpm_dir, user=runas, group='mock')\n                    except OSError as exc:\n                        if exc.errno != errno.EEXIST:\n                            raise\n                    shutil.copy(full, sdest)\n                    ret.setdefault('Source Packages', []).append(sdest)\n                elif filename.endswith('.rpm'):\n                    bdist = os.path.join(dest_dir, filename)\n                    shutil.copy(full, bdist)\n                    ret.setdefault('Packages', []).append(bdist)\n                else:\n                    log_file = os.path.join(log_dest, filename)\n                    try:\n                        __salt__['file.makedirs_perms'](name=log_dest, user=runas, group='mock')\n                    except OSError as exc:\n                        if exc.errno != errno.EEXIST:\n                            raise\n                    shutil.copy(full, log_file)\n                    ret.setdefault('Log Files', []).append(log_file)\n        except Exception as exc:\n            log.error('Error building from %s: %s', srpm, exc)\n        finally:\n            shutil.rmtree(results_dir)\n    if retrc != 0:\n        raise SaltInvocationError('Building packages for destination directory {}, spec {}, sources {}, failed with return error {}, check logs for further details'.format(dest_dir, spec, sources, retrc))\n    shutil.rmtree(deps_dir)\n    shutil.rmtree(srpm_build_dir)\n    return ret"
        ]
    },
    {
        "func_name": "make_repo",
        "original": "def make_repo(repodir, keyid=None, env=None, use_passphrase=False, gnupghome='/etc/salt/gpgkeys', runas='root', timeout=15.0):\n    \"\"\"\n    Make a package repository and optionally sign packages present\n\n    Given the repodir, create a ``yum`` repository out of the rpms therein\n    and optionally sign it and packages present, the name is directory to\n    turn into a repo. This state is best used with onchanges linked to\n    your package building states.\n\n    repodir\n        The directory to find packages that will be in the repository.\n\n    keyid\n        .. versionchanged:: 2016.3.0\n\n        Optional Key ID to use in signing packages and repository.\n        Utilizes Public and Private keys associated with keyid which have\n        been loaded into the minion's Pillar data.\n\n        For example, contents from a Pillar data file with named Public\n        and Private keys as follows:\n\n        .. code-block:: yaml\n\n            gpg_pkg_priv_key: |\n              -----BEGIN PGP PRIVATE KEY BLOCK-----\n              Version: GnuPG v1\n\n              lQO+BFciIfQBCADAPCtzx7I5Rl32escCMZsPzaEKWe7bIX1em4KCKkBoX47IG54b\n              w82PCE8Y1jF/9Uk2m3RKVWp3YcLlc7Ap3gj6VO4ysvVz28UbnhPxsIkOlf2cq8qc\n              .\n              .\n              Ebe+8JCQTwqSXPRTzXmy/b5WXDeM79CkLWvuGpXFor76D+ECMRPv/rawukEcNptn\n              R5OmgHqvydEnO4pWbn8JzQO9YX/Us0SMHBVzLC8eIi5ZIopzalvX\n              =JvW8\n              -----END PGP PRIVATE KEY BLOCK-----\n\n            gpg_pkg_priv_keyname: gpg_pkg_key.pem\n\n            gpg_pkg_pub_key: |\n              -----BEGIN PGP PUBLIC KEY BLOCK-----\n              Version: GnuPG v1\n\n              mQENBFciIfQBCADAPCtzx7I5Rl32escCMZsPzaEKWe7bIX1em4KCKkBoX47IG54b\n              w82PCE8Y1jF/9Uk2m3RKVWp3YcLlc7Ap3gj6VO4ysvVz28UbnhPxsIkOlf2cq8qc\n              .\n              .\n              bYP7t5iwJmQzRMyFInYRt77wkJBPCpJc9FPNebL9vlZcN4zv0KQta+4alcWivvoP\n              4QIxE+/+trC6QRw2m2dHk6aAeq/J0Sc7ilZufwnNA71hf9SzRIwcFXMsLx4iLlki\n              inNqW9c=\n              =s1CX\n              -----END PGP PUBLIC KEY BLOCK-----\n\n            gpg_pkg_pub_keyname: gpg_pkg_key.pub\n\n    env\n        .. versionchanged:: 2016.3.0\n\n        A dictionary of environment variables to be utilized in creating the\n        repository.\n\n        .. note::\n\n            This parameter is not used for making ``yum`` repositories.\n\n    use_passphrase : False\n        .. versionadded:: 2016.3.0\n\n        Use a passphrase with the signing key presented in ``keyid``.\n        Passphrase is received from Pillar data which could be passed on the\n        command line with ``pillar`` parameter.\n\n        .. code-block:: bash\n\n            pillar='{ \"gpg_passphrase\" : \"my_passphrase\" }'\n\n        .. versionadded:: 3001.1\n\n        RHEL 8 and above leverages gpg-agent and gpg-preset-passphrase for\n        caching keys, etc.\n\n    gnupghome : /etc/salt/gpgkeys\n        .. versionadded:: 2016.3.0\n\n        Location where GPG related files are stored, used with ``keyid``.\n\n    runas : root\n        .. versionadded:: 2016.3.0\n\n        User to create the repository as, and optionally sign packages.\n\n        .. note::\n\n            Ensure the user has correct permissions to any files and\n            directories which are to be utilized.\n\n    timeout : 15.0\n        .. versionadded:: 2016.3.4\n\n        Timeout in seconds to wait for the prompt for inputting the passphrase.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkgbuild.make_repo /var/www/html/\n\n    \"\"\"\n    home = os.path.expanduser('~' + runas)\n    rpmmacros = os.path.join(home, '.rpmmacros')\n    if not os.path.exists(rpmmacros):\n        _create_rpmmacros(runas)\n    if gnupghome and env is None:\n        env = {}\n        env['GNUPGHOME'] = gnupghome\n    (use_gpg_agent, local_keyid, define_gpg_name, phrase) = _get_gpg_key_resources(keyid, env, use_passphrase, gnupghome, runas)\n    for fileused in os.listdir(repodir):\n        if fileused.endswith('.rpm'):\n            abs_file = os.path.join(repodir, fileused)\n            if use_gpg_agent:\n                _sign_files_with_gpg_agent(runas, local_keyid, abs_file, repodir, env, timeout)\n            else:\n                _sign_file(runas, define_gpg_name, phrase, abs_file, timeout)\n    cmd = 'createrepo --update {}'.format(repodir)\n    retrc = __salt__['cmd.run_all'](cmd, runas=runas)\n    return retrc",
        "mutated": [
            "def make_repo(repodir, keyid=None, env=None, use_passphrase=False, gnupghome='/etc/salt/gpgkeys', runas='root', timeout=15.0):\n    if False:\n        i = 10\n    '\\n    Make a package repository and optionally sign packages present\\n\\n    Given the repodir, create a ``yum`` repository out of the rpms therein\\n    and optionally sign it and packages present, the name is directory to\\n    turn into a repo. This state is best used with onchanges linked to\\n    your package building states.\\n\\n    repodir\\n        The directory to find packages that will be in the repository.\\n\\n    keyid\\n        .. versionchanged:: 2016.3.0\\n\\n        Optional Key ID to use in signing packages and repository.\\n        Utilizes Public and Private keys associated with keyid which have\\n        been loaded into the minion\\'s Pillar data.\\n\\n        For example, contents from a Pillar data file with named Public\\n        and Private keys as follows:\\n\\n        .. code-block:: yaml\\n\\n            gpg_pkg_priv_key: |\\n              -----BEGIN PGP PRIVATE KEY BLOCK-----\\n              Version: GnuPG v1\\n\\n              lQO+BFciIfQBCADAPCtzx7I5Rl32escCMZsPzaEKWe7bIX1em4KCKkBoX47IG54b\\n              w82PCE8Y1jF/9Uk2m3RKVWp3YcLlc7Ap3gj6VO4ysvVz28UbnhPxsIkOlf2cq8qc\\n              .\\n              .\\n              Ebe+8JCQTwqSXPRTzXmy/b5WXDeM79CkLWvuGpXFor76D+ECMRPv/rawukEcNptn\\n              R5OmgHqvydEnO4pWbn8JzQO9YX/Us0SMHBVzLC8eIi5ZIopzalvX\\n              =JvW8\\n              -----END PGP PRIVATE KEY BLOCK-----\\n\\n            gpg_pkg_priv_keyname: gpg_pkg_key.pem\\n\\n            gpg_pkg_pub_key: |\\n              -----BEGIN PGP PUBLIC KEY BLOCK-----\\n              Version: GnuPG v1\\n\\n              mQENBFciIfQBCADAPCtzx7I5Rl32escCMZsPzaEKWe7bIX1em4KCKkBoX47IG54b\\n              w82PCE8Y1jF/9Uk2m3RKVWp3YcLlc7Ap3gj6VO4ysvVz28UbnhPxsIkOlf2cq8qc\\n              .\\n              .\\n              bYP7t5iwJmQzRMyFInYRt77wkJBPCpJc9FPNebL9vlZcN4zv0KQta+4alcWivvoP\\n              4QIxE+/+trC6QRw2m2dHk6aAeq/J0Sc7ilZufwnNA71hf9SzRIwcFXMsLx4iLlki\\n              inNqW9c=\\n              =s1CX\\n              -----END PGP PUBLIC KEY BLOCK-----\\n\\n            gpg_pkg_pub_keyname: gpg_pkg_key.pub\\n\\n    env\\n        .. versionchanged:: 2016.3.0\\n\\n        A dictionary of environment variables to be utilized in creating the\\n        repository.\\n\\n        .. note::\\n\\n            This parameter is not used for making ``yum`` repositories.\\n\\n    use_passphrase : False\\n        .. versionadded:: 2016.3.0\\n\\n        Use a passphrase with the signing key presented in ``keyid``.\\n        Passphrase is received from Pillar data which could be passed on the\\n        command line with ``pillar`` parameter.\\n\\n        .. code-block:: bash\\n\\n            pillar=\\'{ \"gpg_passphrase\" : \"my_passphrase\" }\\'\\n\\n        .. versionadded:: 3001.1\\n\\n        RHEL 8 and above leverages gpg-agent and gpg-preset-passphrase for\\n        caching keys, etc.\\n\\n    gnupghome : /etc/salt/gpgkeys\\n        .. versionadded:: 2016.3.0\\n\\n        Location where GPG related files are stored, used with ``keyid``.\\n\\n    runas : root\\n        .. versionadded:: 2016.3.0\\n\\n        User to create the repository as, and optionally sign packages.\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n\\n    timeout : 15.0\\n        .. versionadded:: 2016.3.4\\n\\n        Timeout in seconds to wait for the prompt for inputting the passphrase.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkgbuild.make_repo /var/www/html/\\n\\n    '\n    home = os.path.expanduser('~' + runas)\n    rpmmacros = os.path.join(home, '.rpmmacros')\n    if not os.path.exists(rpmmacros):\n        _create_rpmmacros(runas)\n    if gnupghome and env is None:\n        env = {}\n        env['GNUPGHOME'] = gnupghome\n    (use_gpg_agent, local_keyid, define_gpg_name, phrase) = _get_gpg_key_resources(keyid, env, use_passphrase, gnupghome, runas)\n    for fileused in os.listdir(repodir):\n        if fileused.endswith('.rpm'):\n            abs_file = os.path.join(repodir, fileused)\n            if use_gpg_agent:\n                _sign_files_with_gpg_agent(runas, local_keyid, abs_file, repodir, env, timeout)\n            else:\n                _sign_file(runas, define_gpg_name, phrase, abs_file, timeout)\n    cmd = 'createrepo --update {}'.format(repodir)\n    retrc = __salt__['cmd.run_all'](cmd, runas=runas)\n    return retrc",
            "def make_repo(repodir, keyid=None, env=None, use_passphrase=False, gnupghome='/etc/salt/gpgkeys', runas='root', timeout=15.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Make a package repository and optionally sign packages present\\n\\n    Given the repodir, create a ``yum`` repository out of the rpms therein\\n    and optionally sign it and packages present, the name is directory to\\n    turn into a repo. This state is best used with onchanges linked to\\n    your package building states.\\n\\n    repodir\\n        The directory to find packages that will be in the repository.\\n\\n    keyid\\n        .. versionchanged:: 2016.3.0\\n\\n        Optional Key ID to use in signing packages and repository.\\n        Utilizes Public and Private keys associated with keyid which have\\n        been loaded into the minion\\'s Pillar data.\\n\\n        For example, contents from a Pillar data file with named Public\\n        and Private keys as follows:\\n\\n        .. code-block:: yaml\\n\\n            gpg_pkg_priv_key: |\\n              -----BEGIN PGP PRIVATE KEY BLOCK-----\\n              Version: GnuPG v1\\n\\n              lQO+BFciIfQBCADAPCtzx7I5Rl32escCMZsPzaEKWe7bIX1em4KCKkBoX47IG54b\\n              w82PCE8Y1jF/9Uk2m3RKVWp3YcLlc7Ap3gj6VO4ysvVz28UbnhPxsIkOlf2cq8qc\\n              .\\n              .\\n              Ebe+8JCQTwqSXPRTzXmy/b5WXDeM79CkLWvuGpXFor76D+ECMRPv/rawukEcNptn\\n              R5OmgHqvydEnO4pWbn8JzQO9YX/Us0SMHBVzLC8eIi5ZIopzalvX\\n              =JvW8\\n              -----END PGP PRIVATE KEY BLOCK-----\\n\\n            gpg_pkg_priv_keyname: gpg_pkg_key.pem\\n\\n            gpg_pkg_pub_key: |\\n              -----BEGIN PGP PUBLIC KEY BLOCK-----\\n              Version: GnuPG v1\\n\\n              mQENBFciIfQBCADAPCtzx7I5Rl32escCMZsPzaEKWe7bIX1em4KCKkBoX47IG54b\\n              w82PCE8Y1jF/9Uk2m3RKVWp3YcLlc7Ap3gj6VO4ysvVz28UbnhPxsIkOlf2cq8qc\\n              .\\n              .\\n              bYP7t5iwJmQzRMyFInYRt77wkJBPCpJc9FPNebL9vlZcN4zv0KQta+4alcWivvoP\\n              4QIxE+/+trC6QRw2m2dHk6aAeq/J0Sc7ilZufwnNA71hf9SzRIwcFXMsLx4iLlki\\n              inNqW9c=\\n              =s1CX\\n              -----END PGP PUBLIC KEY BLOCK-----\\n\\n            gpg_pkg_pub_keyname: gpg_pkg_key.pub\\n\\n    env\\n        .. versionchanged:: 2016.3.0\\n\\n        A dictionary of environment variables to be utilized in creating the\\n        repository.\\n\\n        .. note::\\n\\n            This parameter is not used for making ``yum`` repositories.\\n\\n    use_passphrase : False\\n        .. versionadded:: 2016.3.0\\n\\n        Use a passphrase with the signing key presented in ``keyid``.\\n        Passphrase is received from Pillar data which could be passed on the\\n        command line with ``pillar`` parameter.\\n\\n        .. code-block:: bash\\n\\n            pillar=\\'{ \"gpg_passphrase\" : \"my_passphrase\" }\\'\\n\\n        .. versionadded:: 3001.1\\n\\n        RHEL 8 and above leverages gpg-agent and gpg-preset-passphrase for\\n        caching keys, etc.\\n\\n    gnupghome : /etc/salt/gpgkeys\\n        .. versionadded:: 2016.3.0\\n\\n        Location where GPG related files are stored, used with ``keyid``.\\n\\n    runas : root\\n        .. versionadded:: 2016.3.0\\n\\n        User to create the repository as, and optionally sign packages.\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n\\n    timeout : 15.0\\n        .. versionadded:: 2016.3.4\\n\\n        Timeout in seconds to wait for the prompt for inputting the passphrase.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkgbuild.make_repo /var/www/html/\\n\\n    '\n    home = os.path.expanduser('~' + runas)\n    rpmmacros = os.path.join(home, '.rpmmacros')\n    if not os.path.exists(rpmmacros):\n        _create_rpmmacros(runas)\n    if gnupghome and env is None:\n        env = {}\n        env['GNUPGHOME'] = gnupghome\n    (use_gpg_agent, local_keyid, define_gpg_name, phrase) = _get_gpg_key_resources(keyid, env, use_passphrase, gnupghome, runas)\n    for fileused in os.listdir(repodir):\n        if fileused.endswith('.rpm'):\n            abs_file = os.path.join(repodir, fileused)\n            if use_gpg_agent:\n                _sign_files_with_gpg_agent(runas, local_keyid, abs_file, repodir, env, timeout)\n            else:\n                _sign_file(runas, define_gpg_name, phrase, abs_file, timeout)\n    cmd = 'createrepo --update {}'.format(repodir)\n    retrc = __salt__['cmd.run_all'](cmd, runas=runas)\n    return retrc",
            "def make_repo(repodir, keyid=None, env=None, use_passphrase=False, gnupghome='/etc/salt/gpgkeys', runas='root', timeout=15.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Make a package repository and optionally sign packages present\\n\\n    Given the repodir, create a ``yum`` repository out of the rpms therein\\n    and optionally sign it and packages present, the name is directory to\\n    turn into a repo. This state is best used with onchanges linked to\\n    your package building states.\\n\\n    repodir\\n        The directory to find packages that will be in the repository.\\n\\n    keyid\\n        .. versionchanged:: 2016.3.0\\n\\n        Optional Key ID to use in signing packages and repository.\\n        Utilizes Public and Private keys associated with keyid which have\\n        been loaded into the minion\\'s Pillar data.\\n\\n        For example, contents from a Pillar data file with named Public\\n        and Private keys as follows:\\n\\n        .. code-block:: yaml\\n\\n            gpg_pkg_priv_key: |\\n              -----BEGIN PGP PRIVATE KEY BLOCK-----\\n              Version: GnuPG v1\\n\\n              lQO+BFciIfQBCADAPCtzx7I5Rl32escCMZsPzaEKWe7bIX1em4KCKkBoX47IG54b\\n              w82PCE8Y1jF/9Uk2m3RKVWp3YcLlc7Ap3gj6VO4ysvVz28UbnhPxsIkOlf2cq8qc\\n              .\\n              .\\n              Ebe+8JCQTwqSXPRTzXmy/b5WXDeM79CkLWvuGpXFor76D+ECMRPv/rawukEcNptn\\n              R5OmgHqvydEnO4pWbn8JzQO9YX/Us0SMHBVzLC8eIi5ZIopzalvX\\n              =JvW8\\n              -----END PGP PRIVATE KEY BLOCK-----\\n\\n            gpg_pkg_priv_keyname: gpg_pkg_key.pem\\n\\n            gpg_pkg_pub_key: |\\n              -----BEGIN PGP PUBLIC KEY BLOCK-----\\n              Version: GnuPG v1\\n\\n              mQENBFciIfQBCADAPCtzx7I5Rl32escCMZsPzaEKWe7bIX1em4KCKkBoX47IG54b\\n              w82PCE8Y1jF/9Uk2m3RKVWp3YcLlc7Ap3gj6VO4ysvVz28UbnhPxsIkOlf2cq8qc\\n              .\\n              .\\n              bYP7t5iwJmQzRMyFInYRt77wkJBPCpJc9FPNebL9vlZcN4zv0KQta+4alcWivvoP\\n              4QIxE+/+trC6QRw2m2dHk6aAeq/J0Sc7ilZufwnNA71hf9SzRIwcFXMsLx4iLlki\\n              inNqW9c=\\n              =s1CX\\n              -----END PGP PUBLIC KEY BLOCK-----\\n\\n            gpg_pkg_pub_keyname: gpg_pkg_key.pub\\n\\n    env\\n        .. versionchanged:: 2016.3.0\\n\\n        A dictionary of environment variables to be utilized in creating the\\n        repository.\\n\\n        .. note::\\n\\n            This parameter is not used for making ``yum`` repositories.\\n\\n    use_passphrase : False\\n        .. versionadded:: 2016.3.0\\n\\n        Use a passphrase with the signing key presented in ``keyid``.\\n        Passphrase is received from Pillar data which could be passed on the\\n        command line with ``pillar`` parameter.\\n\\n        .. code-block:: bash\\n\\n            pillar=\\'{ \"gpg_passphrase\" : \"my_passphrase\" }\\'\\n\\n        .. versionadded:: 3001.1\\n\\n        RHEL 8 and above leverages gpg-agent and gpg-preset-passphrase for\\n        caching keys, etc.\\n\\n    gnupghome : /etc/salt/gpgkeys\\n        .. versionadded:: 2016.3.0\\n\\n        Location where GPG related files are stored, used with ``keyid``.\\n\\n    runas : root\\n        .. versionadded:: 2016.3.0\\n\\n        User to create the repository as, and optionally sign packages.\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n\\n    timeout : 15.0\\n        .. versionadded:: 2016.3.4\\n\\n        Timeout in seconds to wait for the prompt for inputting the passphrase.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkgbuild.make_repo /var/www/html/\\n\\n    '\n    home = os.path.expanduser('~' + runas)\n    rpmmacros = os.path.join(home, '.rpmmacros')\n    if not os.path.exists(rpmmacros):\n        _create_rpmmacros(runas)\n    if gnupghome and env is None:\n        env = {}\n        env['GNUPGHOME'] = gnupghome\n    (use_gpg_agent, local_keyid, define_gpg_name, phrase) = _get_gpg_key_resources(keyid, env, use_passphrase, gnupghome, runas)\n    for fileused in os.listdir(repodir):\n        if fileused.endswith('.rpm'):\n            abs_file = os.path.join(repodir, fileused)\n            if use_gpg_agent:\n                _sign_files_with_gpg_agent(runas, local_keyid, abs_file, repodir, env, timeout)\n            else:\n                _sign_file(runas, define_gpg_name, phrase, abs_file, timeout)\n    cmd = 'createrepo --update {}'.format(repodir)\n    retrc = __salt__['cmd.run_all'](cmd, runas=runas)\n    return retrc",
            "def make_repo(repodir, keyid=None, env=None, use_passphrase=False, gnupghome='/etc/salt/gpgkeys', runas='root', timeout=15.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Make a package repository and optionally sign packages present\\n\\n    Given the repodir, create a ``yum`` repository out of the rpms therein\\n    and optionally sign it and packages present, the name is directory to\\n    turn into a repo. This state is best used with onchanges linked to\\n    your package building states.\\n\\n    repodir\\n        The directory to find packages that will be in the repository.\\n\\n    keyid\\n        .. versionchanged:: 2016.3.0\\n\\n        Optional Key ID to use in signing packages and repository.\\n        Utilizes Public and Private keys associated with keyid which have\\n        been loaded into the minion\\'s Pillar data.\\n\\n        For example, contents from a Pillar data file with named Public\\n        and Private keys as follows:\\n\\n        .. code-block:: yaml\\n\\n            gpg_pkg_priv_key: |\\n              -----BEGIN PGP PRIVATE KEY BLOCK-----\\n              Version: GnuPG v1\\n\\n              lQO+BFciIfQBCADAPCtzx7I5Rl32escCMZsPzaEKWe7bIX1em4KCKkBoX47IG54b\\n              w82PCE8Y1jF/9Uk2m3RKVWp3YcLlc7Ap3gj6VO4ysvVz28UbnhPxsIkOlf2cq8qc\\n              .\\n              .\\n              Ebe+8JCQTwqSXPRTzXmy/b5WXDeM79CkLWvuGpXFor76D+ECMRPv/rawukEcNptn\\n              R5OmgHqvydEnO4pWbn8JzQO9YX/Us0SMHBVzLC8eIi5ZIopzalvX\\n              =JvW8\\n              -----END PGP PRIVATE KEY BLOCK-----\\n\\n            gpg_pkg_priv_keyname: gpg_pkg_key.pem\\n\\n            gpg_pkg_pub_key: |\\n              -----BEGIN PGP PUBLIC KEY BLOCK-----\\n              Version: GnuPG v1\\n\\n              mQENBFciIfQBCADAPCtzx7I5Rl32escCMZsPzaEKWe7bIX1em4KCKkBoX47IG54b\\n              w82PCE8Y1jF/9Uk2m3RKVWp3YcLlc7Ap3gj6VO4ysvVz28UbnhPxsIkOlf2cq8qc\\n              .\\n              .\\n              bYP7t5iwJmQzRMyFInYRt77wkJBPCpJc9FPNebL9vlZcN4zv0KQta+4alcWivvoP\\n              4QIxE+/+trC6QRw2m2dHk6aAeq/J0Sc7ilZufwnNA71hf9SzRIwcFXMsLx4iLlki\\n              inNqW9c=\\n              =s1CX\\n              -----END PGP PUBLIC KEY BLOCK-----\\n\\n            gpg_pkg_pub_keyname: gpg_pkg_key.pub\\n\\n    env\\n        .. versionchanged:: 2016.3.0\\n\\n        A dictionary of environment variables to be utilized in creating the\\n        repository.\\n\\n        .. note::\\n\\n            This parameter is not used for making ``yum`` repositories.\\n\\n    use_passphrase : False\\n        .. versionadded:: 2016.3.0\\n\\n        Use a passphrase with the signing key presented in ``keyid``.\\n        Passphrase is received from Pillar data which could be passed on the\\n        command line with ``pillar`` parameter.\\n\\n        .. code-block:: bash\\n\\n            pillar=\\'{ \"gpg_passphrase\" : \"my_passphrase\" }\\'\\n\\n        .. versionadded:: 3001.1\\n\\n        RHEL 8 and above leverages gpg-agent and gpg-preset-passphrase for\\n        caching keys, etc.\\n\\n    gnupghome : /etc/salt/gpgkeys\\n        .. versionadded:: 2016.3.0\\n\\n        Location where GPG related files are stored, used with ``keyid``.\\n\\n    runas : root\\n        .. versionadded:: 2016.3.0\\n\\n        User to create the repository as, and optionally sign packages.\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n\\n    timeout : 15.0\\n        .. versionadded:: 2016.3.4\\n\\n        Timeout in seconds to wait for the prompt for inputting the passphrase.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkgbuild.make_repo /var/www/html/\\n\\n    '\n    home = os.path.expanduser('~' + runas)\n    rpmmacros = os.path.join(home, '.rpmmacros')\n    if not os.path.exists(rpmmacros):\n        _create_rpmmacros(runas)\n    if gnupghome and env is None:\n        env = {}\n        env['GNUPGHOME'] = gnupghome\n    (use_gpg_agent, local_keyid, define_gpg_name, phrase) = _get_gpg_key_resources(keyid, env, use_passphrase, gnupghome, runas)\n    for fileused in os.listdir(repodir):\n        if fileused.endswith('.rpm'):\n            abs_file = os.path.join(repodir, fileused)\n            if use_gpg_agent:\n                _sign_files_with_gpg_agent(runas, local_keyid, abs_file, repodir, env, timeout)\n            else:\n                _sign_file(runas, define_gpg_name, phrase, abs_file, timeout)\n    cmd = 'createrepo --update {}'.format(repodir)\n    retrc = __salt__['cmd.run_all'](cmd, runas=runas)\n    return retrc",
            "def make_repo(repodir, keyid=None, env=None, use_passphrase=False, gnupghome='/etc/salt/gpgkeys', runas='root', timeout=15.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Make a package repository and optionally sign packages present\\n\\n    Given the repodir, create a ``yum`` repository out of the rpms therein\\n    and optionally sign it and packages present, the name is directory to\\n    turn into a repo. This state is best used with onchanges linked to\\n    your package building states.\\n\\n    repodir\\n        The directory to find packages that will be in the repository.\\n\\n    keyid\\n        .. versionchanged:: 2016.3.0\\n\\n        Optional Key ID to use in signing packages and repository.\\n        Utilizes Public and Private keys associated with keyid which have\\n        been loaded into the minion\\'s Pillar data.\\n\\n        For example, contents from a Pillar data file with named Public\\n        and Private keys as follows:\\n\\n        .. code-block:: yaml\\n\\n            gpg_pkg_priv_key: |\\n              -----BEGIN PGP PRIVATE KEY BLOCK-----\\n              Version: GnuPG v1\\n\\n              lQO+BFciIfQBCADAPCtzx7I5Rl32escCMZsPzaEKWe7bIX1em4KCKkBoX47IG54b\\n              w82PCE8Y1jF/9Uk2m3RKVWp3YcLlc7Ap3gj6VO4ysvVz28UbnhPxsIkOlf2cq8qc\\n              .\\n              .\\n              Ebe+8JCQTwqSXPRTzXmy/b5WXDeM79CkLWvuGpXFor76D+ECMRPv/rawukEcNptn\\n              R5OmgHqvydEnO4pWbn8JzQO9YX/Us0SMHBVzLC8eIi5ZIopzalvX\\n              =JvW8\\n              -----END PGP PRIVATE KEY BLOCK-----\\n\\n            gpg_pkg_priv_keyname: gpg_pkg_key.pem\\n\\n            gpg_pkg_pub_key: |\\n              -----BEGIN PGP PUBLIC KEY BLOCK-----\\n              Version: GnuPG v1\\n\\n              mQENBFciIfQBCADAPCtzx7I5Rl32escCMZsPzaEKWe7bIX1em4KCKkBoX47IG54b\\n              w82PCE8Y1jF/9Uk2m3RKVWp3YcLlc7Ap3gj6VO4ysvVz28UbnhPxsIkOlf2cq8qc\\n              .\\n              .\\n              bYP7t5iwJmQzRMyFInYRt77wkJBPCpJc9FPNebL9vlZcN4zv0KQta+4alcWivvoP\\n              4QIxE+/+trC6QRw2m2dHk6aAeq/J0Sc7ilZufwnNA71hf9SzRIwcFXMsLx4iLlki\\n              inNqW9c=\\n              =s1CX\\n              -----END PGP PUBLIC KEY BLOCK-----\\n\\n            gpg_pkg_pub_keyname: gpg_pkg_key.pub\\n\\n    env\\n        .. versionchanged:: 2016.3.0\\n\\n        A dictionary of environment variables to be utilized in creating the\\n        repository.\\n\\n        .. note::\\n\\n            This parameter is not used for making ``yum`` repositories.\\n\\n    use_passphrase : False\\n        .. versionadded:: 2016.3.0\\n\\n        Use a passphrase with the signing key presented in ``keyid``.\\n        Passphrase is received from Pillar data which could be passed on the\\n        command line with ``pillar`` parameter.\\n\\n        .. code-block:: bash\\n\\n            pillar=\\'{ \"gpg_passphrase\" : \"my_passphrase\" }\\'\\n\\n        .. versionadded:: 3001.1\\n\\n        RHEL 8 and above leverages gpg-agent and gpg-preset-passphrase for\\n        caching keys, etc.\\n\\n    gnupghome : /etc/salt/gpgkeys\\n        .. versionadded:: 2016.3.0\\n\\n        Location where GPG related files are stored, used with ``keyid``.\\n\\n    runas : root\\n        .. versionadded:: 2016.3.0\\n\\n        User to create the repository as, and optionally sign packages.\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n\\n    timeout : 15.0\\n        .. versionadded:: 2016.3.4\\n\\n        Timeout in seconds to wait for the prompt for inputting the passphrase.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkgbuild.make_repo /var/www/html/\\n\\n    '\n    home = os.path.expanduser('~' + runas)\n    rpmmacros = os.path.join(home, '.rpmmacros')\n    if not os.path.exists(rpmmacros):\n        _create_rpmmacros(runas)\n    if gnupghome and env is None:\n        env = {}\n        env['GNUPGHOME'] = gnupghome\n    (use_gpg_agent, local_keyid, define_gpg_name, phrase) = _get_gpg_key_resources(keyid, env, use_passphrase, gnupghome, runas)\n    for fileused in os.listdir(repodir):\n        if fileused.endswith('.rpm'):\n            abs_file = os.path.join(repodir, fileused)\n            if use_gpg_agent:\n                _sign_files_with_gpg_agent(runas, local_keyid, abs_file, repodir, env, timeout)\n            else:\n                _sign_file(runas, define_gpg_name, phrase, abs_file, timeout)\n    cmd = 'createrepo --update {}'.format(repodir)\n    retrc = __salt__['cmd.run_all'](cmd, runas=runas)\n    return retrc"
        ]
    }
]