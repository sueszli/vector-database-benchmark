[
    {
        "func_name": "_check_child_op_type",
        "original": "def _check_child_op_type(op, child_op_type):\n    \"\"\"\n    :param op: operation\n    :param child_op_type: str\n    :return: Return True if op has 1 child and type of that child matches child_op_type\n    \"\"\"\n    if len(op.outputs) != 1:\n        return False\n    child_ops = list(op.outputs[0].child_ops)\n    if len(child_ops) != 1:\n        return False\n    if child_ops[0].op_type == child_op_type:\n        return True\n    return False",
        "mutated": [
            "def _check_child_op_type(op, child_op_type):\n    if False:\n        i = 10\n    '\\n    :param op: operation\\n    :param child_op_type: str\\n    :return: Return True if op has 1 child and type of that child matches child_op_type\\n    '\n    if len(op.outputs) != 1:\n        return False\n    child_ops = list(op.outputs[0].child_ops)\n    if len(child_ops) != 1:\n        return False\n    if child_ops[0].op_type == child_op_type:\n        return True\n    return False",
            "def _check_child_op_type(op, child_op_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    :param op: operation\\n    :param child_op_type: str\\n    :return: Return True if op has 1 child and type of that child matches child_op_type\\n    '\n    if len(op.outputs) != 1:\n        return False\n    child_ops = list(op.outputs[0].child_ops)\n    if len(child_ops) != 1:\n        return False\n    if child_ops[0].op_type == child_op_type:\n        return True\n    return False",
            "def _check_child_op_type(op, child_op_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    :param op: operation\\n    :param child_op_type: str\\n    :return: Return True if op has 1 child and type of that child matches child_op_type\\n    '\n    if len(op.outputs) != 1:\n        return False\n    child_ops = list(op.outputs[0].child_ops)\n    if len(child_ops) != 1:\n        return False\n    if child_ops[0].op_type == child_op_type:\n        return True\n    return False",
            "def _check_child_op_type(op, child_op_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    :param op: operation\\n    :param child_op_type: str\\n    :return: Return True if op has 1 child and type of that child matches child_op_type\\n    '\n    if len(op.outputs) != 1:\n        return False\n    child_ops = list(op.outputs[0].child_ops)\n    if len(child_ops) != 1:\n        return False\n    if child_ops[0].op_type == child_op_type:\n        return True\n    return False",
            "def _check_child_op_type(op, child_op_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    :param op: operation\\n    :param child_op_type: str\\n    :return: Return True if op has 1 child and type of that child matches child_op_type\\n    '\n    if len(op.outputs) != 1:\n        return False\n    child_ops = list(op.outputs[0].child_ops)\n    if len(child_ops) != 1:\n        return False\n    if child_ops[0].op_type == child_op_type:\n        return True\n    return False"
        ]
    },
    {
        "func_name": "_check_var_scalar_value",
        "original": "def _check_var_scalar_value(x, val, tol=0.001):\n    \"\"\"\n    :param x: var\n    :param val: a scalar value\n    :return: True if the value of var is equal to val otherwise return False\n    \"\"\"\n    if x.val is None:\n        return False\n    if not isinstance(x.val, (np.ndarray, np.generic)):\n        return False\n    if isinstance(x.val, np.ndarray):\n        if x.val.size != 1:\n            return False\n        x_val = x.val[:][0]\n    else:\n        x_val = x.val\n    if abs(x_val - val) < tol:\n        return True\n    return False",
        "mutated": [
            "def _check_var_scalar_value(x, val, tol=0.001):\n    if False:\n        i = 10\n    '\\n    :param x: var\\n    :param val: a scalar value\\n    :return: True if the value of var is equal to val otherwise return False\\n    '\n    if x.val is None:\n        return False\n    if not isinstance(x.val, (np.ndarray, np.generic)):\n        return False\n    if isinstance(x.val, np.ndarray):\n        if x.val.size != 1:\n            return False\n        x_val = x.val[:][0]\n    else:\n        x_val = x.val\n    if abs(x_val - val) < tol:\n        return True\n    return False",
            "def _check_var_scalar_value(x, val, tol=0.001):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    :param x: var\\n    :param val: a scalar value\\n    :return: True if the value of var is equal to val otherwise return False\\n    '\n    if x.val is None:\n        return False\n    if not isinstance(x.val, (np.ndarray, np.generic)):\n        return False\n    if isinstance(x.val, np.ndarray):\n        if x.val.size != 1:\n            return False\n        x_val = x.val[:][0]\n    else:\n        x_val = x.val\n    if abs(x_val - val) < tol:\n        return True\n    return False",
            "def _check_var_scalar_value(x, val, tol=0.001):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    :param x: var\\n    :param val: a scalar value\\n    :return: True if the value of var is equal to val otherwise return False\\n    '\n    if x.val is None:\n        return False\n    if not isinstance(x.val, (np.ndarray, np.generic)):\n        return False\n    if isinstance(x.val, np.ndarray):\n        if x.val.size != 1:\n            return False\n        x_val = x.val[:][0]\n    else:\n        x_val = x.val\n    if abs(x_val - val) < tol:\n        return True\n    return False",
            "def _check_var_scalar_value(x, val, tol=0.001):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    :param x: var\\n    :param val: a scalar value\\n    :return: True if the value of var is equal to val otherwise return False\\n    '\n    if x.val is None:\n        return False\n    if not isinstance(x.val, (np.ndarray, np.generic)):\n        return False\n    if isinstance(x.val, np.ndarray):\n        if x.val.size != 1:\n            return False\n        x_val = x.val[:][0]\n    else:\n        x_val = x.val\n    if abs(x_val - val) < tol:\n        return True\n    return False",
            "def _check_var_scalar_value(x, val, tol=0.001):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    :param x: var\\n    :param val: a scalar value\\n    :return: True if the value of var is equal to val otherwise return False\\n    '\n    if x.val is None:\n        return False\n    if not isinstance(x.val, (np.ndarray, np.generic)):\n        return False\n    if isinstance(x.val, np.ndarray):\n        if x.val.size != 1:\n            return False\n        x_val = x.val[:][0]\n    else:\n        x_val = x.val\n    if abs(x_val - val) < tol:\n        return True\n    return False"
        ]
    },
    {
        "func_name": "try_to_transform",
        "original": "def try_to_transform(onehot_op, block):\n    root_var = onehot_op.indices\n    if onehot_op.outputs[0] in block.outputs:\n        return False\n    axis = onehot_op.axis.val\n    if axis is None:\n        return False\n    if onehot_op.indices.shape is None:\n        return False\n    rank = len(onehot_op.indices.shape)\n    if axis >= 0:\n        axis -= rank\n    if axis != -1:\n        return False\n    if not _check_var_scalar_value(onehot_op.on_value, 1):\n        return False\n    if not _check_var_scalar_value(onehot_op.off_value, 0):\n        return False\n    if onehot_op.one_hot_vector_size.val is None:\n        return False\n    if not _check_child_op_type(onehot_op, 'matmul'):\n        return False\n    matmul_op = list(onehot_op.outputs[0].child_ops)[0]\n    if matmul_op.x != onehot_op.outputs[0]:\n        return False\n    if matmul_op.transpose_x.val or matmul_op.transpose_y.val:\n        return False\n    W_var = matmul_op.y\n    if W_var.val is None:\n        return False\n    if len(W_var.val.shape) != 2:\n        return False\n    out_name = matmul_op.outputs[0].name\n    x = mb.gather(x=W_var, indices=root_var, axis=0, name=out_name, before_op=matmul_op)\n    matmul_op.enclosing_block.replace_uses_of_var_after_op(anchor_op=matmul_op, old_var=matmul_op.outputs[0], new_var=x)\n    block.remove_ops([onehot_op, matmul_op])\n    return True",
        "mutated": [
            "def try_to_transform(onehot_op, block):\n    if False:\n        i = 10\n    root_var = onehot_op.indices\n    if onehot_op.outputs[0] in block.outputs:\n        return False\n    axis = onehot_op.axis.val\n    if axis is None:\n        return False\n    if onehot_op.indices.shape is None:\n        return False\n    rank = len(onehot_op.indices.shape)\n    if axis >= 0:\n        axis -= rank\n    if axis != -1:\n        return False\n    if not _check_var_scalar_value(onehot_op.on_value, 1):\n        return False\n    if not _check_var_scalar_value(onehot_op.off_value, 0):\n        return False\n    if onehot_op.one_hot_vector_size.val is None:\n        return False\n    if not _check_child_op_type(onehot_op, 'matmul'):\n        return False\n    matmul_op = list(onehot_op.outputs[0].child_ops)[0]\n    if matmul_op.x != onehot_op.outputs[0]:\n        return False\n    if matmul_op.transpose_x.val or matmul_op.transpose_y.val:\n        return False\n    W_var = matmul_op.y\n    if W_var.val is None:\n        return False\n    if len(W_var.val.shape) != 2:\n        return False\n    out_name = matmul_op.outputs[0].name\n    x = mb.gather(x=W_var, indices=root_var, axis=0, name=out_name, before_op=matmul_op)\n    matmul_op.enclosing_block.replace_uses_of_var_after_op(anchor_op=matmul_op, old_var=matmul_op.outputs[0], new_var=x)\n    block.remove_ops([onehot_op, matmul_op])\n    return True",
            "def try_to_transform(onehot_op, block):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    root_var = onehot_op.indices\n    if onehot_op.outputs[0] in block.outputs:\n        return False\n    axis = onehot_op.axis.val\n    if axis is None:\n        return False\n    if onehot_op.indices.shape is None:\n        return False\n    rank = len(onehot_op.indices.shape)\n    if axis >= 0:\n        axis -= rank\n    if axis != -1:\n        return False\n    if not _check_var_scalar_value(onehot_op.on_value, 1):\n        return False\n    if not _check_var_scalar_value(onehot_op.off_value, 0):\n        return False\n    if onehot_op.one_hot_vector_size.val is None:\n        return False\n    if not _check_child_op_type(onehot_op, 'matmul'):\n        return False\n    matmul_op = list(onehot_op.outputs[0].child_ops)[0]\n    if matmul_op.x != onehot_op.outputs[0]:\n        return False\n    if matmul_op.transpose_x.val or matmul_op.transpose_y.val:\n        return False\n    W_var = matmul_op.y\n    if W_var.val is None:\n        return False\n    if len(W_var.val.shape) != 2:\n        return False\n    out_name = matmul_op.outputs[0].name\n    x = mb.gather(x=W_var, indices=root_var, axis=0, name=out_name, before_op=matmul_op)\n    matmul_op.enclosing_block.replace_uses_of_var_after_op(anchor_op=matmul_op, old_var=matmul_op.outputs[0], new_var=x)\n    block.remove_ops([onehot_op, matmul_op])\n    return True",
            "def try_to_transform(onehot_op, block):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    root_var = onehot_op.indices\n    if onehot_op.outputs[0] in block.outputs:\n        return False\n    axis = onehot_op.axis.val\n    if axis is None:\n        return False\n    if onehot_op.indices.shape is None:\n        return False\n    rank = len(onehot_op.indices.shape)\n    if axis >= 0:\n        axis -= rank\n    if axis != -1:\n        return False\n    if not _check_var_scalar_value(onehot_op.on_value, 1):\n        return False\n    if not _check_var_scalar_value(onehot_op.off_value, 0):\n        return False\n    if onehot_op.one_hot_vector_size.val is None:\n        return False\n    if not _check_child_op_type(onehot_op, 'matmul'):\n        return False\n    matmul_op = list(onehot_op.outputs[0].child_ops)[0]\n    if matmul_op.x != onehot_op.outputs[0]:\n        return False\n    if matmul_op.transpose_x.val or matmul_op.transpose_y.val:\n        return False\n    W_var = matmul_op.y\n    if W_var.val is None:\n        return False\n    if len(W_var.val.shape) != 2:\n        return False\n    out_name = matmul_op.outputs[0].name\n    x = mb.gather(x=W_var, indices=root_var, axis=0, name=out_name, before_op=matmul_op)\n    matmul_op.enclosing_block.replace_uses_of_var_after_op(anchor_op=matmul_op, old_var=matmul_op.outputs[0], new_var=x)\n    block.remove_ops([onehot_op, matmul_op])\n    return True",
            "def try_to_transform(onehot_op, block):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    root_var = onehot_op.indices\n    if onehot_op.outputs[0] in block.outputs:\n        return False\n    axis = onehot_op.axis.val\n    if axis is None:\n        return False\n    if onehot_op.indices.shape is None:\n        return False\n    rank = len(onehot_op.indices.shape)\n    if axis >= 0:\n        axis -= rank\n    if axis != -1:\n        return False\n    if not _check_var_scalar_value(onehot_op.on_value, 1):\n        return False\n    if not _check_var_scalar_value(onehot_op.off_value, 0):\n        return False\n    if onehot_op.one_hot_vector_size.val is None:\n        return False\n    if not _check_child_op_type(onehot_op, 'matmul'):\n        return False\n    matmul_op = list(onehot_op.outputs[0].child_ops)[0]\n    if matmul_op.x != onehot_op.outputs[0]:\n        return False\n    if matmul_op.transpose_x.val or matmul_op.transpose_y.val:\n        return False\n    W_var = matmul_op.y\n    if W_var.val is None:\n        return False\n    if len(W_var.val.shape) != 2:\n        return False\n    out_name = matmul_op.outputs[0].name\n    x = mb.gather(x=W_var, indices=root_var, axis=0, name=out_name, before_op=matmul_op)\n    matmul_op.enclosing_block.replace_uses_of_var_after_op(anchor_op=matmul_op, old_var=matmul_op.outputs[0], new_var=x)\n    block.remove_ops([onehot_op, matmul_op])\n    return True",
            "def try_to_transform(onehot_op, block):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    root_var = onehot_op.indices\n    if onehot_op.outputs[0] in block.outputs:\n        return False\n    axis = onehot_op.axis.val\n    if axis is None:\n        return False\n    if onehot_op.indices.shape is None:\n        return False\n    rank = len(onehot_op.indices.shape)\n    if axis >= 0:\n        axis -= rank\n    if axis != -1:\n        return False\n    if not _check_var_scalar_value(onehot_op.on_value, 1):\n        return False\n    if not _check_var_scalar_value(onehot_op.off_value, 0):\n        return False\n    if onehot_op.one_hot_vector_size.val is None:\n        return False\n    if not _check_child_op_type(onehot_op, 'matmul'):\n        return False\n    matmul_op = list(onehot_op.outputs[0].child_ops)[0]\n    if matmul_op.x != onehot_op.outputs[0]:\n        return False\n    if matmul_op.transpose_x.val or matmul_op.transpose_y.val:\n        return False\n    W_var = matmul_op.y\n    if W_var.val is None:\n        return False\n    if len(W_var.val.shape) != 2:\n        return False\n    out_name = matmul_op.outputs[0].name\n    x = mb.gather(x=W_var, indices=root_var, axis=0, name=out_name, before_op=matmul_op)\n    matmul_op.enclosing_block.replace_uses_of_var_after_op(anchor_op=matmul_op, old_var=matmul_op.outputs[0], new_var=x)\n    block.remove_ops([onehot_op, matmul_op])\n    return True"
        ]
    },
    {
        "func_name": "fuse_onehot_matmul_to_gather_block",
        "original": "def fuse_onehot_matmul_to_gather_block(block):\n    fusion_status = False\n    for (i, op) in enumerate(list(block.operations)):\n        for b in op.blocks:\n            block_changed = True\n            while block_changed:\n                block_changed = fuse_onehot_matmul_to_gather_block(b)\n        if len(op.blocks) > 0:\n            continue\n        if op.op_type == 'one_hot':\n            with block:\n                fusion_status = try_to_transform(op, block)\n            if fusion_status:\n                return fusion_status\n    return fusion_status",
        "mutated": [
            "def fuse_onehot_matmul_to_gather_block(block):\n    if False:\n        i = 10\n    fusion_status = False\n    for (i, op) in enumerate(list(block.operations)):\n        for b in op.blocks:\n            block_changed = True\n            while block_changed:\n                block_changed = fuse_onehot_matmul_to_gather_block(b)\n        if len(op.blocks) > 0:\n            continue\n        if op.op_type == 'one_hot':\n            with block:\n                fusion_status = try_to_transform(op, block)\n            if fusion_status:\n                return fusion_status\n    return fusion_status",
            "def fuse_onehot_matmul_to_gather_block(block):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    fusion_status = False\n    for (i, op) in enumerate(list(block.operations)):\n        for b in op.blocks:\n            block_changed = True\n            while block_changed:\n                block_changed = fuse_onehot_matmul_to_gather_block(b)\n        if len(op.blocks) > 0:\n            continue\n        if op.op_type == 'one_hot':\n            with block:\n                fusion_status = try_to_transform(op, block)\n            if fusion_status:\n                return fusion_status\n    return fusion_status",
            "def fuse_onehot_matmul_to_gather_block(block):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    fusion_status = False\n    for (i, op) in enumerate(list(block.operations)):\n        for b in op.blocks:\n            block_changed = True\n            while block_changed:\n                block_changed = fuse_onehot_matmul_to_gather_block(b)\n        if len(op.blocks) > 0:\n            continue\n        if op.op_type == 'one_hot':\n            with block:\n                fusion_status = try_to_transform(op, block)\n            if fusion_status:\n                return fusion_status\n    return fusion_status",
            "def fuse_onehot_matmul_to_gather_block(block):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    fusion_status = False\n    for (i, op) in enumerate(list(block.operations)):\n        for b in op.blocks:\n            block_changed = True\n            while block_changed:\n                block_changed = fuse_onehot_matmul_to_gather_block(b)\n        if len(op.blocks) > 0:\n            continue\n        if op.op_type == 'one_hot':\n            with block:\n                fusion_status = try_to_transform(op, block)\n            if fusion_status:\n                return fusion_status\n    return fusion_status",
            "def fuse_onehot_matmul_to_gather_block(block):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    fusion_status = False\n    for (i, op) in enumerate(list(block.operations)):\n        for b in op.blocks:\n            block_changed = True\n            while block_changed:\n                block_changed = fuse_onehot_matmul_to_gather_block(b)\n        if len(op.blocks) > 0:\n            continue\n        if op.op_type == 'one_hot':\n            with block:\n                fusion_status = try_to_transform(op, block)\n            if fusion_status:\n                return fusion_status\n    return fusion_status"
        ]
    },
    {
        "func_name": "fuse_onehot_matmul_to_gather",
        "original": "@register_pass(namespace='common')\ndef fuse_onehot_matmul_to_gather(prog):\n    \"\"\"\n    Detect if onehot (axis=-1, on_value=1, off_value=0) is followed by a matmul op (no bias),\n    then they can be replaced by a gather op.\n\n    Input:\n        %2 = one_hot(%1, on_value=1, off_value=0, axis=-1)\n        %3 = const() # rank 2\n        %4  = matmul(%2, %3)\n\n    Output:\n        %4 = gather(%3, %2, axis=0)\n\n    \"\"\"\n    for (f_name, f) in prog.functions.items():\n        block_changed = True\n        while block_changed:\n            block_changed = fuse_onehot_matmul_to_gather_block(f)",
        "mutated": [
            "@register_pass(namespace='common')\ndef fuse_onehot_matmul_to_gather(prog):\n    if False:\n        i = 10\n    '\\n    Detect if onehot (axis=-1, on_value=1, off_value=0) is followed by a matmul op (no bias),\\n    then they can be replaced by a gather op.\\n\\n    Input:\\n        %2 = one_hot(%1, on_value=1, off_value=0, axis=-1)\\n        %3 = const() # rank 2\\n        %4  = matmul(%2, %3)\\n\\n    Output:\\n        %4 = gather(%3, %2, axis=0)\\n\\n    '\n    for (f_name, f) in prog.functions.items():\n        block_changed = True\n        while block_changed:\n            block_changed = fuse_onehot_matmul_to_gather_block(f)",
            "@register_pass(namespace='common')\ndef fuse_onehot_matmul_to_gather(prog):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Detect if onehot (axis=-1, on_value=1, off_value=0) is followed by a matmul op (no bias),\\n    then they can be replaced by a gather op.\\n\\n    Input:\\n        %2 = one_hot(%1, on_value=1, off_value=0, axis=-1)\\n        %3 = const() # rank 2\\n        %4  = matmul(%2, %3)\\n\\n    Output:\\n        %4 = gather(%3, %2, axis=0)\\n\\n    '\n    for (f_name, f) in prog.functions.items():\n        block_changed = True\n        while block_changed:\n            block_changed = fuse_onehot_matmul_to_gather_block(f)",
            "@register_pass(namespace='common')\ndef fuse_onehot_matmul_to_gather(prog):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Detect if onehot (axis=-1, on_value=1, off_value=0) is followed by a matmul op (no bias),\\n    then they can be replaced by a gather op.\\n\\n    Input:\\n        %2 = one_hot(%1, on_value=1, off_value=0, axis=-1)\\n        %3 = const() # rank 2\\n        %4  = matmul(%2, %3)\\n\\n    Output:\\n        %4 = gather(%3, %2, axis=0)\\n\\n    '\n    for (f_name, f) in prog.functions.items():\n        block_changed = True\n        while block_changed:\n            block_changed = fuse_onehot_matmul_to_gather_block(f)",
            "@register_pass(namespace='common')\ndef fuse_onehot_matmul_to_gather(prog):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Detect if onehot (axis=-1, on_value=1, off_value=0) is followed by a matmul op (no bias),\\n    then they can be replaced by a gather op.\\n\\n    Input:\\n        %2 = one_hot(%1, on_value=1, off_value=0, axis=-1)\\n        %3 = const() # rank 2\\n        %4  = matmul(%2, %3)\\n\\n    Output:\\n        %4 = gather(%3, %2, axis=0)\\n\\n    '\n    for (f_name, f) in prog.functions.items():\n        block_changed = True\n        while block_changed:\n            block_changed = fuse_onehot_matmul_to_gather_block(f)",
            "@register_pass(namespace='common')\ndef fuse_onehot_matmul_to_gather(prog):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Detect if onehot (axis=-1, on_value=1, off_value=0) is followed by a matmul op (no bias),\\n    then they can be replaced by a gather op.\\n\\n    Input:\\n        %2 = one_hot(%1, on_value=1, off_value=0, axis=-1)\\n        %3 = const() # rank 2\\n        %4  = matmul(%2, %3)\\n\\n    Output:\\n        %4 = gather(%3, %2, axis=0)\\n\\n    '\n    for (f_name, f) in prog.functions.items():\n        block_changed = True\n        while block_changed:\n            block_changed = fuse_onehot_matmul_to_gather_block(f)"
        ]
    }
]