"""
This module is for inspecting OGR data sources and generating either
models for GeoDjango and/or mapping dictionaries for use with the
`LayerMapping` utility.
"""
from django.contrib.gis.gdal import DataSource
from django.contrib.gis.gdal.field import OFTDate, OFTDateTime, OFTInteger, OFTInteger64, OFTReal, OFTString, OFTTime

def mapping(data_source, geom_name='geom', layer_key=0, multi_geom=False):
    if False:
        print('Hello World!')
    '\n    Given a DataSource, generate a dictionary that may be used\n    for invoking the LayerMapping utility.\n\n    Keyword Arguments:\n     `geom_name` => The name of the geometry field to use for the model.\n\n     `layer_key` => The key for specifying which layer in the DataSource to use;\n       defaults to 0 (the first layer).  May be an integer index or a string\n       identifier for the layer.\n\n     `multi_geom` => Boolean (default: False) - specify as multigeometry.\n    '
    if isinstance(data_source, str):
        data_source = DataSource(data_source)
    elif isinstance(data_source, DataSource):
        pass
    else:
        raise TypeError('Data source parameter must be a string or a DataSource object.')
    _mapping = {}
    for field in data_source[layer_key].fields:
        mfield = field.lower()
        if mfield[-1:] == '_':
            mfield += 'field'
        _mapping[mfield] = field
    gtype = data_source[layer_key].geom_type
    if multi_geom:
        gtype.to_multi()
    _mapping[geom_name] = str(gtype).upper()
    return _mapping

def ogrinspect(*args, **kwargs):
    if False:
        print('Hello World!')
    "\n    Given a data source (either a string or a DataSource object) and a string\n    model name this function will generate a GeoDjango model.\n\n    Usage:\n\n    >>> from django.contrib.gis.utils import ogrinspect\n    >>> ogrinspect('/path/to/shapefile.shp','NewModel')\n\n    ...will print model definition to stout\n\n    or put this in a Python script and use to redirect the output to a new\n    model like:\n\n    $ python generate_model.py > myapp/models.py\n\n    # generate_model.py\n    from django.contrib.gis.utils import ogrinspect\n    shp_file = 'data/mapping_hacks/world_borders.shp'\n    model_name = 'WorldBorders'\n\n    print(ogrinspect(shp_file, model_name, multi_geom=True, srid=4326,\n                     geom_name='shapes', blank=True))\n\n    Required Arguments\n     `datasource` => string or DataSource object to file pointer\n\n     `model name` => string of name of new model class to create\n\n    Optional Keyword Arguments\n     `geom_name` => For specifying the model name for the Geometry Field.\n       Otherwise will default to `geom`\n\n     `layer_key` => The key for specifying which layer in the DataSource to use;\n       defaults to 0 (the first layer).  May be an integer index or a string\n       identifier for the layer.\n\n     `srid` => The SRID to use for the Geometry Field.  If it can be determined,\n       the SRID of the datasource is used.\n\n     `multi_geom` => Boolean (default: False) - specify as multigeometry.\n\n     `name_field` => String - specifies a field name to return for the\n       __str__() method (which will be generated if specified).\n\n     `imports` => Boolean (default: True) - set to False to omit the\n       `from django.contrib.gis.db import models` code from the\n       autogenerated models thus avoiding duplicated imports when building\n       more than one model by batching ogrinspect()\n\n     `decimal` => Boolean or sequence (default: False).  When set to True\n       all generated model fields corresponding to the `OFTReal` type will\n       be `DecimalField` instead of `FloatField`.  A sequence of specific\n       field names to generate as `DecimalField` may also be used.\n\n     `blank` => Boolean or sequence (default: False).  When set to True all\n       generated model fields will have `blank=True`.  If the user wants to\n       give specific fields to have blank, then a list/tuple of OGR field\n       names may be used.\n\n     `null` => Boolean (default: False) - When set to True all generated\n       model fields will have `null=True`.  If the user wants to specify\n       give specific fields to have null, then a list/tuple of OGR field\n       names may be used.\n\n    Note: Call the _ogrinspect() helper to do the heavy lifting.\n    "
    return '\n'.join(_ogrinspect(*args, **kwargs))

def _ogrinspect(data_source, model_name, geom_name='geom', layer_key=0, srid=None, multi_geom=False, name_field=None, imports=True, decimal=False, blank=False, null=False):
    if False:
        while True:
            i = 10
    '\n    Helper routine for `ogrinspect` that generates GeoDjango models corresponding\n    to the given data source.  See the `ogrinspect` docstring for more details.\n    '
    if isinstance(data_source, str):
        data_source = DataSource(data_source)
    elif isinstance(data_source, DataSource):
        pass
    else:
        raise TypeError('Data source parameter must be a string or a DataSource object.')
    layer = data_source[layer_key]
    ogr_fields = layer.fields

    def process_kwarg(kwarg):
        if False:
            i = 10
            return i + 15
        if isinstance(kwarg, (list, tuple)):
            return [s.lower() for s in kwarg]
        elif kwarg:
            return [s.lower() for s in ogr_fields]
        else:
            return []
    null_fields = process_kwarg(null)
    blank_fields = process_kwarg(blank)
    decimal_fields = process_kwarg(decimal)

    def get_kwargs_str(field_name):
        if False:
            return 10
        kwlist = []
        if field_name.lower() in null_fields:
            kwlist.append('null=True')
        if field_name.lower() in blank_fields:
            kwlist.append('blank=True')
        if kwlist:
            return ', ' + ', '.join(kwlist)
        else:
            return ''
    if imports:
        yield '# This is an auto-generated Django model module created by ogrinspect.'
        yield 'from django.contrib.gis.db import models'
        yield ''
        yield ''
    yield ('class %s(models.Model):' % model_name)
    for (field_name, width, precision, field_type) in zip(ogr_fields, layer.field_widths, layer.field_precisions, layer.field_types):
        mfield = field_name.lower()
        if mfield[-1:] == '_':
            mfield += 'field'
        kwargs_str = get_kwargs_str(field_name)
        if field_type is OFTReal:
            if field_name.lower() in decimal_fields:
                yield ('    %s = models.DecimalField(max_digits=%d, decimal_places=%d%s)' % (mfield, width, precision, kwargs_str))
            else:
                yield ('    %s = models.FloatField(%s)' % (mfield, kwargs_str[2:]))
        elif field_type is OFTInteger:
            yield ('    %s = models.IntegerField(%s)' % (mfield, kwargs_str[2:]))
        elif field_type is OFTInteger64:
            yield ('    %s = models.BigIntegerField(%s)' % (mfield, kwargs_str[2:]))
        elif field_type is OFTString:
            yield ('    %s = models.CharField(max_length=%s%s)' % (mfield, width, kwargs_str))
        elif field_type is OFTDate:
            yield ('    %s = models.DateField(%s)' % (mfield, kwargs_str[2:]))
        elif field_type is OFTDateTime:
            yield ('    %s = models.DateTimeField(%s)' % (mfield, kwargs_str[2:]))
        elif field_type is OFTTime:
            yield ('    %s = models.TimeField(%s)' % (mfield, kwargs_str[2:]))
        else:
            raise TypeError('Unknown field type %s in %s' % (field_type, mfield))
    gtype = layer.geom_type
    if multi_geom:
        gtype.to_multi()
    geom_field = gtype.django
    if srid is None:
        if layer.srs is None:
            srid_str = 'srid=-1'
        else:
            srid = layer.srs.srid
            if srid is None:
                srid_str = 'srid=-1'
            elif srid == 4326:
                srid_str = ''
            else:
                srid_str = 'srid=%s' % srid
    else:
        srid_str = 'srid=%s' % srid
    yield ('    %s = models.%s(%s)' % (geom_name, geom_field, srid_str))
    if name_field:
        yield ''
        yield ('    def __str__(self): return self.%s' % name_field)