[
    {
        "func_name": "write_simple_fault",
        "original": "def write_simple_fault(index_fault, fault_name, OQ_entry_faults, faults_names, faults_data, Model_name, Domain_in_the_model, ScL_oq, log_mdf_file, M_min, ID_number):\n    if fault_name in faults_names:\n        i_MFD = np.where(np.array(faults_names) == fault_name)[0][0]\n        MFD = OQ_entry_faults[i_MFD]\n        ID_number = ID_number + 1\n        if not faults_data[index_fault]['domain'] in str(Domain_in_the_model):\n            Domain_in_the_model.append(faults_data[index_fault]['domain'])\n        ColLon = faults_data[index_fault]['lon']\n        ColLat = faults_data[index_fault]['lat']\n        Depth = faults_data[index_fault]['depth']\n        test_ok = 0\n        if Depth and all((elem == 'sf' for elem in Depth)):\n            type_of_fault = 'sf'\n        else:\n            type_of_fault = 'cf'\n            Depth = [float(i) for i in Depth]\n        if type_of_fault == 'sf':\n            fault_name = Model_name + '_' + str(fault_name)\n            line = '\\t\\t<simpleFaultSource id=\"' + str(ID_number) + '\" name=\"' + str(fault_name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n            test_ok += 1\n            compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n            if str('N') in str(faults_data[index_fault]['oriented']):\n                if compass_bearing < 180.0:\n                    ColLon = reversed(ColLon)\n                    ColLat = reversed(ColLat)\n            elif str('S') in str(faults_data[index_fault]['oriented']):\n                if compass_bearing > 180.0:\n                    ColLon = reversed(ColLon)\n                    ColLat = reversed(ColLat)\n            elif str('E') in str(faults_data[index_fault]['oriented']):\n                if compass_bearing > 90.0 and compass_bearing < 270.0:\n                    ColLon = reversed(ColLon)\n                    ColLat = reversed(ColLat)\n            elif str('W') in str(faults_data[index_fault]['oriented']):\n                if compass_bearing < 90.0 or compass_bearing > 270.0:\n                    ColLon = reversed(ColLon)\n                    ColLat = reversed(ColLat)\n            use_kite = False\n            if use_kite == True:\n                usd = faults_data[index_fault]['upper_sismo_depth']\n                lsd = faults_data[index_fault]['lower_sismo_depth']\n                dip_tan = math.tan(math.radians(faults_data[index_fault]['dip']))\n                hdist_top = usd / dip_tan\n                hdist_bottom = lsd / dip_tan\n                ColLon = list(ColLon)\n                ColLat = list(ColLat)\n                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                strike = compass_bearing\n                azimuth = (strike + 90.0) % 360\n                line += '\\t\\t\\t<kiteSurface>\\n'\n                for (x, y) in zip(ColLon, ColLat):\n                    line += '\\t\\t\\t<profile>\\n'\n                    line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                    line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                    (xt, yt) = point_at(x, y, azimuth, hdist_top)\n                    line += '\\t\\t\\t\\t\\t\\t' + str(xt) + ' ' + str(yt) + ' ' + str(usd) + ' '\n                    (xb, yb) = point_at(x, y, azimuth, hdist_bottom)\n                    line += str(xb) + ' ' + str(yb) + ' ' + str(lsd) + '\\n'\n                    line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                    line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                    line += '\\t\\t\\t</profile>\\n'\n                line += '\\t\\t\\t</kiteSurface>\\n'\n            else:\n                line += '\\t\\t\\t<simpleFaultGeometry>\\n'\n                line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                for (x, y) in zip(ColLon, ColLat):\n                    line += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + '\\n'\n                line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                line += '\\t\\t\\t\\t<dip>' + str(faults_data[index_fault]['dip']) + '</dip>\\n'\n                line += '\\t\\t\\t\\t<upperSeismoDepth>' + str(faults_data[index_fault]['upper_sismo_depth']) + '</upperSeismoDepth>\\n'\n                line += '\\t\\t\\t\\t<lowerSeismoDepth>' + str(faults_data[index_fault]['lower_sismo_depth']) + '</lowerSeismoDepth>\\n'\n                line += '\\t\\t\\t</simpleFaultGeometry>\\n'\n        if type_of_fault == 'cf':\n            fault_name = Model_name + '_' + str(fault_name)\n            line = '\\t\\t<complexFaultSource id=\"' + str(ID_number) + '\" name=\"' + str(fault_name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n            test_ok += 1\n            line += '\\t\\t\\t<complexFaultGeometry>\\n'\n            index_edge = 0\n            for depth_i in sorted(set(Depth)):\n                indexes_for_edge_i = np.where(np.array(Depth) == depth_i)[0]\n                if index_edge == 0:\n                    line += '\\t\\t\\t\\t<faultTopEdge>\\n'\n                elif index_edge == len(set(Depth)) - 1:\n                    line += '\\t\\t\\t\\t<faultBottomEdge>\\n'\n                else:\n                    line += '\\t\\t\\t\\t<intermediateEdge>\\n'\n                line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                for index in indexes_for_edge_i:\n                    line += '\\t\\t\\t\\t\\t\\t' + str(ColLon[index]) + ' ' + str(ColLat[index]) + ' ' + str(Depth[index]) + '\\n'\n                line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                if index_edge == 0:\n                    line += '\\t\\t\\t\\t</faultTopEdge>\\n'\n                elif index_edge == len(set(Depth)) - 1:\n                    line += '\\t\\t\\t\\t</faultBottomEdge>\\n'\n                else:\n                    line += '\\t\\t\\t\\t</intermediateEdge>\\n'\n                index_edge += 1\n            line += '\\t\\t\\t</complexFaultGeometry>\\n'\n        if test_ok == 0:\n            print('!!!!!!!!!! Problem with the fault Geometry, please check input file')\n            sys.exit()\n        line += '\\t\\t\\t<magScaleRel>' + ScL_oq + '</magScaleRel>\\n'\n        line += '\\t\\t\\t<ruptAspectRatio>1.0</ruptAspectRatio>\\n'\n        line += '\\t\\t\\t<incrementalMFD minMag=\"' + str(M_min) + '\" binWidth=\"0.10\">\\n'\n        if sum(MFD) != 0:\n            log_mdf_file.write(str(fault_name) + '\\t' + str(M_min) + '\\t' + ' '.join(list(map(str, MFD))) + '\\n')\n            line += '\\t\\t\\t\\t<occurRates> ' + ' '.join(list(map(str, MFD))) + '</occurRates>\\n'\n        else:\n            MFD[0] += 1e-11\n            log_mdf_file.write(str(fault_name) + '\\t' + str(M_min) + '\\t' + ' '.join(list(map(str, MFD))) + '\\n')\n            line += '\\t\\t\\t\\t<occurRates> ' + ' '.join(list(map(str, MFD))) + '</occurRates>\\n'\n        line += '\\t\\t\\t</incrementalMFD>\\n'\n        line += '\\t\\t\\t<rake>' + str(faults_data[index_fault]['rake']) + '</rake>\\n'\n        if type_of_fault == 'sf':\n            line += '\\t\\t</simpleFaultSource>\\n'\n        if type_of_fault == 'cf':\n            line += '\\t\\t</complexFaultSource>\\n'\n    return (line, Domain_in_the_model, ID_number)",
        "mutated": [
            "def write_simple_fault(index_fault, fault_name, OQ_entry_faults, faults_names, faults_data, Model_name, Domain_in_the_model, ScL_oq, log_mdf_file, M_min, ID_number):\n    if False:\n        i = 10\n    if fault_name in faults_names:\n        i_MFD = np.where(np.array(faults_names) == fault_name)[0][0]\n        MFD = OQ_entry_faults[i_MFD]\n        ID_number = ID_number + 1\n        if not faults_data[index_fault]['domain'] in str(Domain_in_the_model):\n            Domain_in_the_model.append(faults_data[index_fault]['domain'])\n        ColLon = faults_data[index_fault]['lon']\n        ColLat = faults_data[index_fault]['lat']\n        Depth = faults_data[index_fault]['depth']\n        test_ok = 0\n        if Depth and all((elem == 'sf' for elem in Depth)):\n            type_of_fault = 'sf'\n        else:\n            type_of_fault = 'cf'\n            Depth = [float(i) for i in Depth]\n        if type_of_fault == 'sf':\n            fault_name = Model_name + '_' + str(fault_name)\n            line = '\\t\\t<simpleFaultSource id=\"' + str(ID_number) + '\" name=\"' + str(fault_name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n            test_ok += 1\n            compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n            if str('N') in str(faults_data[index_fault]['oriented']):\n                if compass_bearing < 180.0:\n                    ColLon = reversed(ColLon)\n                    ColLat = reversed(ColLat)\n            elif str('S') in str(faults_data[index_fault]['oriented']):\n                if compass_bearing > 180.0:\n                    ColLon = reversed(ColLon)\n                    ColLat = reversed(ColLat)\n            elif str('E') in str(faults_data[index_fault]['oriented']):\n                if compass_bearing > 90.0 and compass_bearing < 270.0:\n                    ColLon = reversed(ColLon)\n                    ColLat = reversed(ColLat)\n            elif str('W') in str(faults_data[index_fault]['oriented']):\n                if compass_bearing < 90.0 or compass_bearing > 270.0:\n                    ColLon = reversed(ColLon)\n                    ColLat = reversed(ColLat)\n            use_kite = False\n            if use_kite == True:\n                usd = faults_data[index_fault]['upper_sismo_depth']\n                lsd = faults_data[index_fault]['lower_sismo_depth']\n                dip_tan = math.tan(math.radians(faults_data[index_fault]['dip']))\n                hdist_top = usd / dip_tan\n                hdist_bottom = lsd / dip_tan\n                ColLon = list(ColLon)\n                ColLat = list(ColLat)\n                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                strike = compass_bearing\n                azimuth = (strike + 90.0) % 360\n                line += '\\t\\t\\t<kiteSurface>\\n'\n                for (x, y) in zip(ColLon, ColLat):\n                    line += '\\t\\t\\t<profile>\\n'\n                    line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                    line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                    (xt, yt) = point_at(x, y, azimuth, hdist_top)\n                    line += '\\t\\t\\t\\t\\t\\t' + str(xt) + ' ' + str(yt) + ' ' + str(usd) + ' '\n                    (xb, yb) = point_at(x, y, azimuth, hdist_bottom)\n                    line += str(xb) + ' ' + str(yb) + ' ' + str(lsd) + '\\n'\n                    line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                    line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                    line += '\\t\\t\\t</profile>\\n'\n                line += '\\t\\t\\t</kiteSurface>\\n'\n            else:\n                line += '\\t\\t\\t<simpleFaultGeometry>\\n'\n                line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                for (x, y) in zip(ColLon, ColLat):\n                    line += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + '\\n'\n                line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                line += '\\t\\t\\t\\t<dip>' + str(faults_data[index_fault]['dip']) + '</dip>\\n'\n                line += '\\t\\t\\t\\t<upperSeismoDepth>' + str(faults_data[index_fault]['upper_sismo_depth']) + '</upperSeismoDepth>\\n'\n                line += '\\t\\t\\t\\t<lowerSeismoDepth>' + str(faults_data[index_fault]['lower_sismo_depth']) + '</lowerSeismoDepth>\\n'\n                line += '\\t\\t\\t</simpleFaultGeometry>\\n'\n        if type_of_fault == 'cf':\n            fault_name = Model_name + '_' + str(fault_name)\n            line = '\\t\\t<complexFaultSource id=\"' + str(ID_number) + '\" name=\"' + str(fault_name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n            test_ok += 1\n            line += '\\t\\t\\t<complexFaultGeometry>\\n'\n            index_edge = 0\n            for depth_i in sorted(set(Depth)):\n                indexes_for_edge_i = np.where(np.array(Depth) == depth_i)[0]\n                if index_edge == 0:\n                    line += '\\t\\t\\t\\t<faultTopEdge>\\n'\n                elif index_edge == len(set(Depth)) - 1:\n                    line += '\\t\\t\\t\\t<faultBottomEdge>\\n'\n                else:\n                    line += '\\t\\t\\t\\t<intermediateEdge>\\n'\n                line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                for index in indexes_for_edge_i:\n                    line += '\\t\\t\\t\\t\\t\\t' + str(ColLon[index]) + ' ' + str(ColLat[index]) + ' ' + str(Depth[index]) + '\\n'\n                line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                if index_edge == 0:\n                    line += '\\t\\t\\t\\t</faultTopEdge>\\n'\n                elif index_edge == len(set(Depth)) - 1:\n                    line += '\\t\\t\\t\\t</faultBottomEdge>\\n'\n                else:\n                    line += '\\t\\t\\t\\t</intermediateEdge>\\n'\n                index_edge += 1\n            line += '\\t\\t\\t</complexFaultGeometry>\\n'\n        if test_ok == 0:\n            print('!!!!!!!!!! Problem with the fault Geometry, please check input file')\n            sys.exit()\n        line += '\\t\\t\\t<magScaleRel>' + ScL_oq + '</magScaleRel>\\n'\n        line += '\\t\\t\\t<ruptAspectRatio>1.0</ruptAspectRatio>\\n'\n        line += '\\t\\t\\t<incrementalMFD minMag=\"' + str(M_min) + '\" binWidth=\"0.10\">\\n'\n        if sum(MFD) != 0:\n            log_mdf_file.write(str(fault_name) + '\\t' + str(M_min) + '\\t' + ' '.join(list(map(str, MFD))) + '\\n')\n            line += '\\t\\t\\t\\t<occurRates> ' + ' '.join(list(map(str, MFD))) + '</occurRates>\\n'\n        else:\n            MFD[0] += 1e-11\n            log_mdf_file.write(str(fault_name) + '\\t' + str(M_min) + '\\t' + ' '.join(list(map(str, MFD))) + '\\n')\n            line += '\\t\\t\\t\\t<occurRates> ' + ' '.join(list(map(str, MFD))) + '</occurRates>\\n'\n        line += '\\t\\t\\t</incrementalMFD>\\n'\n        line += '\\t\\t\\t<rake>' + str(faults_data[index_fault]['rake']) + '</rake>\\n'\n        if type_of_fault == 'sf':\n            line += '\\t\\t</simpleFaultSource>\\n'\n        if type_of_fault == 'cf':\n            line += '\\t\\t</complexFaultSource>\\n'\n    return (line, Domain_in_the_model, ID_number)",
            "def write_simple_fault(index_fault, fault_name, OQ_entry_faults, faults_names, faults_data, Model_name, Domain_in_the_model, ScL_oq, log_mdf_file, M_min, ID_number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if fault_name in faults_names:\n        i_MFD = np.where(np.array(faults_names) == fault_name)[0][0]\n        MFD = OQ_entry_faults[i_MFD]\n        ID_number = ID_number + 1\n        if not faults_data[index_fault]['domain'] in str(Domain_in_the_model):\n            Domain_in_the_model.append(faults_data[index_fault]['domain'])\n        ColLon = faults_data[index_fault]['lon']\n        ColLat = faults_data[index_fault]['lat']\n        Depth = faults_data[index_fault]['depth']\n        test_ok = 0\n        if Depth and all((elem == 'sf' for elem in Depth)):\n            type_of_fault = 'sf'\n        else:\n            type_of_fault = 'cf'\n            Depth = [float(i) for i in Depth]\n        if type_of_fault == 'sf':\n            fault_name = Model_name + '_' + str(fault_name)\n            line = '\\t\\t<simpleFaultSource id=\"' + str(ID_number) + '\" name=\"' + str(fault_name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n            test_ok += 1\n            compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n            if str('N') in str(faults_data[index_fault]['oriented']):\n                if compass_bearing < 180.0:\n                    ColLon = reversed(ColLon)\n                    ColLat = reversed(ColLat)\n            elif str('S') in str(faults_data[index_fault]['oriented']):\n                if compass_bearing > 180.0:\n                    ColLon = reversed(ColLon)\n                    ColLat = reversed(ColLat)\n            elif str('E') in str(faults_data[index_fault]['oriented']):\n                if compass_bearing > 90.0 and compass_bearing < 270.0:\n                    ColLon = reversed(ColLon)\n                    ColLat = reversed(ColLat)\n            elif str('W') in str(faults_data[index_fault]['oriented']):\n                if compass_bearing < 90.0 or compass_bearing > 270.0:\n                    ColLon = reversed(ColLon)\n                    ColLat = reversed(ColLat)\n            use_kite = False\n            if use_kite == True:\n                usd = faults_data[index_fault]['upper_sismo_depth']\n                lsd = faults_data[index_fault]['lower_sismo_depth']\n                dip_tan = math.tan(math.radians(faults_data[index_fault]['dip']))\n                hdist_top = usd / dip_tan\n                hdist_bottom = lsd / dip_tan\n                ColLon = list(ColLon)\n                ColLat = list(ColLat)\n                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                strike = compass_bearing\n                azimuth = (strike + 90.0) % 360\n                line += '\\t\\t\\t<kiteSurface>\\n'\n                for (x, y) in zip(ColLon, ColLat):\n                    line += '\\t\\t\\t<profile>\\n'\n                    line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                    line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                    (xt, yt) = point_at(x, y, azimuth, hdist_top)\n                    line += '\\t\\t\\t\\t\\t\\t' + str(xt) + ' ' + str(yt) + ' ' + str(usd) + ' '\n                    (xb, yb) = point_at(x, y, azimuth, hdist_bottom)\n                    line += str(xb) + ' ' + str(yb) + ' ' + str(lsd) + '\\n'\n                    line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                    line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                    line += '\\t\\t\\t</profile>\\n'\n                line += '\\t\\t\\t</kiteSurface>\\n'\n            else:\n                line += '\\t\\t\\t<simpleFaultGeometry>\\n'\n                line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                for (x, y) in zip(ColLon, ColLat):\n                    line += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + '\\n'\n                line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                line += '\\t\\t\\t\\t<dip>' + str(faults_data[index_fault]['dip']) + '</dip>\\n'\n                line += '\\t\\t\\t\\t<upperSeismoDepth>' + str(faults_data[index_fault]['upper_sismo_depth']) + '</upperSeismoDepth>\\n'\n                line += '\\t\\t\\t\\t<lowerSeismoDepth>' + str(faults_data[index_fault]['lower_sismo_depth']) + '</lowerSeismoDepth>\\n'\n                line += '\\t\\t\\t</simpleFaultGeometry>\\n'\n        if type_of_fault == 'cf':\n            fault_name = Model_name + '_' + str(fault_name)\n            line = '\\t\\t<complexFaultSource id=\"' + str(ID_number) + '\" name=\"' + str(fault_name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n            test_ok += 1\n            line += '\\t\\t\\t<complexFaultGeometry>\\n'\n            index_edge = 0\n            for depth_i in sorted(set(Depth)):\n                indexes_for_edge_i = np.where(np.array(Depth) == depth_i)[0]\n                if index_edge == 0:\n                    line += '\\t\\t\\t\\t<faultTopEdge>\\n'\n                elif index_edge == len(set(Depth)) - 1:\n                    line += '\\t\\t\\t\\t<faultBottomEdge>\\n'\n                else:\n                    line += '\\t\\t\\t\\t<intermediateEdge>\\n'\n                line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                for index in indexes_for_edge_i:\n                    line += '\\t\\t\\t\\t\\t\\t' + str(ColLon[index]) + ' ' + str(ColLat[index]) + ' ' + str(Depth[index]) + '\\n'\n                line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                if index_edge == 0:\n                    line += '\\t\\t\\t\\t</faultTopEdge>\\n'\n                elif index_edge == len(set(Depth)) - 1:\n                    line += '\\t\\t\\t\\t</faultBottomEdge>\\n'\n                else:\n                    line += '\\t\\t\\t\\t</intermediateEdge>\\n'\n                index_edge += 1\n            line += '\\t\\t\\t</complexFaultGeometry>\\n'\n        if test_ok == 0:\n            print('!!!!!!!!!! Problem with the fault Geometry, please check input file')\n            sys.exit()\n        line += '\\t\\t\\t<magScaleRel>' + ScL_oq + '</magScaleRel>\\n'\n        line += '\\t\\t\\t<ruptAspectRatio>1.0</ruptAspectRatio>\\n'\n        line += '\\t\\t\\t<incrementalMFD minMag=\"' + str(M_min) + '\" binWidth=\"0.10\">\\n'\n        if sum(MFD) != 0:\n            log_mdf_file.write(str(fault_name) + '\\t' + str(M_min) + '\\t' + ' '.join(list(map(str, MFD))) + '\\n')\n            line += '\\t\\t\\t\\t<occurRates> ' + ' '.join(list(map(str, MFD))) + '</occurRates>\\n'\n        else:\n            MFD[0] += 1e-11\n            log_mdf_file.write(str(fault_name) + '\\t' + str(M_min) + '\\t' + ' '.join(list(map(str, MFD))) + '\\n')\n            line += '\\t\\t\\t\\t<occurRates> ' + ' '.join(list(map(str, MFD))) + '</occurRates>\\n'\n        line += '\\t\\t\\t</incrementalMFD>\\n'\n        line += '\\t\\t\\t<rake>' + str(faults_data[index_fault]['rake']) + '</rake>\\n'\n        if type_of_fault == 'sf':\n            line += '\\t\\t</simpleFaultSource>\\n'\n        if type_of_fault == 'cf':\n            line += '\\t\\t</complexFaultSource>\\n'\n    return (line, Domain_in_the_model, ID_number)",
            "def write_simple_fault(index_fault, fault_name, OQ_entry_faults, faults_names, faults_data, Model_name, Domain_in_the_model, ScL_oq, log_mdf_file, M_min, ID_number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if fault_name in faults_names:\n        i_MFD = np.where(np.array(faults_names) == fault_name)[0][0]\n        MFD = OQ_entry_faults[i_MFD]\n        ID_number = ID_number + 1\n        if not faults_data[index_fault]['domain'] in str(Domain_in_the_model):\n            Domain_in_the_model.append(faults_data[index_fault]['domain'])\n        ColLon = faults_data[index_fault]['lon']\n        ColLat = faults_data[index_fault]['lat']\n        Depth = faults_data[index_fault]['depth']\n        test_ok = 0\n        if Depth and all((elem == 'sf' for elem in Depth)):\n            type_of_fault = 'sf'\n        else:\n            type_of_fault = 'cf'\n            Depth = [float(i) for i in Depth]\n        if type_of_fault == 'sf':\n            fault_name = Model_name + '_' + str(fault_name)\n            line = '\\t\\t<simpleFaultSource id=\"' + str(ID_number) + '\" name=\"' + str(fault_name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n            test_ok += 1\n            compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n            if str('N') in str(faults_data[index_fault]['oriented']):\n                if compass_bearing < 180.0:\n                    ColLon = reversed(ColLon)\n                    ColLat = reversed(ColLat)\n            elif str('S') in str(faults_data[index_fault]['oriented']):\n                if compass_bearing > 180.0:\n                    ColLon = reversed(ColLon)\n                    ColLat = reversed(ColLat)\n            elif str('E') in str(faults_data[index_fault]['oriented']):\n                if compass_bearing > 90.0 and compass_bearing < 270.0:\n                    ColLon = reversed(ColLon)\n                    ColLat = reversed(ColLat)\n            elif str('W') in str(faults_data[index_fault]['oriented']):\n                if compass_bearing < 90.0 or compass_bearing > 270.0:\n                    ColLon = reversed(ColLon)\n                    ColLat = reversed(ColLat)\n            use_kite = False\n            if use_kite == True:\n                usd = faults_data[index_fault]['upper_sismo_depth']\n                lsd = faults_data[index_fault]['lower_sismo_depth']\n                dip_tan = math.tan(math.radians(faults_data[index_fault]['dip']))\n                hdist_top = usd / dip_tan\n                hdist_bottom = lsd / dip_tan\n                ColLon = list(ColLon)\n                ColLat = list(ColLat)\n                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                strike = compass_bearing\n                azimuth = (strike + 90.0) % 360\n                line += '\\t\\t\\t<kiteSurface>\\n'\n                for (x, y) in zip(ColLon, ColLat):\n                    line += '\\t\\t\\t<profile>\\n'\n                    line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                    line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                    (xt, yt) = point_at(x, y, azimuth, hdist_top)\n                    line += '\\t\\t\\t\\t\\t\\t' + str(xt) + ' ' + str(yt) + ' ' + str(usd) + ' '\n                    (xb, yb) = point_at(x, y, azimuth, hdist_bottom)\n                    line += str(xb) + ' ' + str(yb) + ' ' + str(lsd) + '\\n'\n                    line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                    line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                    line += '\\t\\t\\t</profile>\\n'\n                line += '\\t\\t\\t</kiteSurface>\\n'\n            else:\n                line += '\\t\\t\\t<simpleFaultGeometry>\\n'\n                line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                for (x, y) in zip(ColLon, ColLat):\n                    line += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + '\\n'\n                line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                line += '\\t\\t\\t\\t<dip>' + str(faults_data[index_fault]['dip']) + '</dip>\\n'\n                line += '\\t\\t\\t\\t<upperSeismoDepth>' + str(faults_data[index_fault]['upper_sismo_depth']) + '</upperSeismoDepth>\\n'\n                line += '\\t\\t\\t\\t<lowerSeismoDepth>' + str(faults_data[index_fault]['lower_sismo_depth']) + '</lowerSeismoDepth>\\n'\n                line += '\\t\\t\\t</simpleFaultGeometry>\\n'\n        if type_of_fault == 'cf':\n            fault_name = Model_name + '_' + str(fault_name)\n            line = '\\t\\t<complexFaultSource id=\"' + str(ID_number) + '\" name=\"' + str(fault_name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n            test_ok += 1\n            line += '\\t\\t\\t<complexFaultGeometry>\\n'\n            index_edge = 0\n            for depth_i in sorted(set(Depth)):\n                indexes_for_edge_i = np.where(np.array(Depth) == depth_i)[0]\n                if index_edge == 0:\n                    line += '\\t\\t\\t\\t<faultTopEdge>\\n'\n                elif index_edge == len(set(Depth)) - 1:\n                    line += '\\t\\t\\t\\t<faultBottomEdge>\\n'\n                else:\n                    line += '\\t\\t\\t\\t<intermediateEdge>\\n'\n                line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                for index in indexes_for_edge_i:\n                    line += '\\t\\t\\t\\t\\t\\t' + str(ColLon[index]) + ' ' + str(ColLat[index]) + ' ' + str(Depth[index]) + '\\n'\n                line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                if index_edge == 0:\n                    line += '\\t\\t\\t\\t</faultTopEdge>\\n'\n                elif index_edge == len(set(Depth)) - 1:\n                    line += '\\t\\t\\t\\t</faultBottomEdge>\\n'\n                else:\n                    line += '\\t\\t\\t\\t</intermediateEdge>\\n'\n                index_edge += 1\n            line += '\\t\\t\\t</complexFaultGeometry>\\n'\n        if test_ok == 0:\n            print('!!!!!!!!!! Problem with the fault Geometry, please check input file')\n            sys.exit()\n        line += '\\t\\t\\t<magScaleRel>' + ScL_oq + '</magScaleRel>\\n'\n        line += '\\t\\t\\t<ruptAspectRatio>1.0</ruptAspectRatio>\\n'\n        line += '\\t\\t\\t<incrementalMFD minMag=\"' + str(M_min) + '\" binWidth=\"0.10\">\\n'\n        if sum(MFD) != 0:\n            log_mdf_file.write(str(fault_name) + '\\t' + str(M_min) + '\\t' + ' '.join(list(map(str, MFD))) + '\\n')\n            line += '\\t\\t\\t\\t<occurRates> ' + ' '.join(list(map(str, MFD))) + '</occurRates>\\n'\n        else:\n            MFD[0] += 1e-11\n            log_mdf_file.write(str(fault_name) + '\\t' + str(M_min) + '\\t' + ' '.join(list(map(str, MFD))) + '\\n')\n            line += '\\t\\t\\t\\t<occurRates> ' + ' '.join(list(map(str, MFD))) + '</occurRates>\\n'\n        line += '\\t\\t\\t</incrementalMFD>\\n'\n        line += '\\t\\t\\t<rake>' + str(faults_data[index_fault]['rake']) + '</rake>\\n'\n        if type_of_fault == 'sf':\n            line += '\\t\\t</simpleFaultSource>\\n'\n        if type_of_fault == 'cf':\n            line += '\\t\\t</complexFaultSource>\\n'\n    return (line, Domain_in_the_model, ID_number)",
            "def write_simple_fault(index_fault, fault_name, OQ_entry_faults, faults_names, faults_data, Model_name, Domain_in_the_model, ScL_oq, log_mdf_file, M_min, ID_number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if fault_name in faults_names:\n        i_MFD = np.where(np.array(faults_names) == fault_name)[0][0]\n        MFD = OQ_entry_faults[i_MFD]\n        ID_number = ID_number + 1\n        if not faults_data[index_fault]['domain'] in str(Domain_in_the_model):\n            Domain_in_the_model.append(faults_data[index_fault]['domain'])\n        ColLon = faults_data[index_fault]['lon']\n        ColLat = faults_data[index_fault]['lat']\n        Depth = faults_data[index_fault]['depth']\n        test_ok = 0\n        if Depth and all((elem == 'sf' for elem in Depth)):\n            type_of_fault = 'sf'\n        else:\n            type_of_fault = 'cf'\n            Depth = [float(i) for i in Depth]\n        if type_of_fault == 'sf':\n            fault_name = Model_name + '_' + str(fault_name)\n            line = '\\t\\t<simpleFaultSource id=\"' + str(ID_number) + '\" name=\"' + str(fault_name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n            test_ok += 1\n            compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n            if str('N') in str(faults_data[index_fault]['oriented']):\n                if compass_bearing < 180.0:\n                    ColLon = reversed(ColLon)\n                    ColLat = reversed(ColLat)\n            elif str('S') in str(faults_data[index_fault]['oriented']):\n                if compass_bearing > 180.0:\n                    ColLon = reversed(ColLon)\n                    ColLat = reversed(ColLat)\n            elif str('E') in str(faults_data[index_fault]['oriented']):\n                if compass_bearing > 90.0 and compass_bearing < 270.0:\n                    ColLon = reversed(ColLon)\n                    ColLat = reversed(ColLat)\n            elif str('W') in str(faults_data[index_fault]['oriented']):\n                if compass_bearing < 90.0 or compass_bearing > 270.0:\n                    ColLon = reversed(ColLon)\n                    ColLat = reversed(ColLat)\n            use_kite = False\n            if use_kite == True:\n                usd = faults_data[index_fault]['upper_sismo_depth']\n                lsd = faults_data[index_fault]['lower_sismo_depth']\n                dip_tan = math.tan(math.radians(faults_data[index_fault]['dip']))\n                hdist_top = usd / dip_tan\n                hdist_bottom = lsd / dip_tan\n                ColLon = list(ColLon)\n                ColLat = list(ColLat)\n                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                strike = compass_bearing\n                azimuth = (strike + 90.0) % 360\n                line += '\\t\\t\\t<kiteSurface>\\n'\n                for (x, y) in zip(ColLon, ColLat):\n                    line += '\\t\\t\\t<profile>\\n'\n                    line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                    line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                    (xt, yt) = point_at(x, y, azimuth, hdist_top)\n                    line += '\\t\\t\\t\\t\\t\\t' + str(xt) + ' ' + str(yt) + ' ' + str(usd) + ' '\n                    (xb, yb) = point_at(x, y, azimuth, hdist_bottom)\n                    line += str(xb) + ' ' + str(yb) + ' ' + str(lsd) + '\\n'\n                    line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                    line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                    line += '\\t\\t\\t</profile>\\n'\n                line += '\\t\\t\\t</kiteSurface>\\n'\n            else:\n                line += '\\t\\t\\t<simpleFaultGeometry>\\n'\n                line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                for (x, y) in zip(ColLon, ColLat):\n                    line += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + '\\n'\n                line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                line += '\\t\\t\\t\\t<dip>' + str(faults_data[index_fault]['dip']) + '</dip>\\n'\n                line += '\\t\\t\\t\\t<upperSeismoDepth>' + str(faults_data[index_fault]['upper_sismo_depth']) + '</upperSeismoDepth>\\n'\n                line += '\\t\\t\\t\\t<lowerSeismoDepth>' + str(faults_data[index_fault]['lower_sismo_depth']) + '</lowerSeismoDepth>\\n'\n                line += '\\t\\t\\t</simpleFaultGeometry>\\n'\n        if type_of_fault == 'cf':\n            fault_name = Model_name + '_' + str(fault_name)\n            line = '\\t\\t<complexFaultSource id=\"' + str(ID_number) + '\" name=\"' + str(fault_name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n            test_ok += 1\n            line += '\\t\\t\\t<complexFaultGeometry>\\n'\n            index_edge = 0\n            for depth_i in sorted(set(Depth)):\n                indexes_for_edge_i = np.where(np.array(Depth) == depth_i)[0]\n                if index_edge == 0:\n                    line += '\\t\\t\\t\\t<faultTopEdge>\\n'\n                elif index_edge == len(set(Depth)) - 1:\n                    line += '\\t\\t\\t\\t<faultBottomEdge>\\n'\n                else:\n                    line += '\\t\\t\\t\\t<intermediateEdge>\\n'\n                line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                for index in indexes_for_edge_i:\n                    line += '\\t\\t\\t\\t\\t\\t' + str(ColLon[index]) + ' ' + str(ColLat[index]) + ' ' + str(Depth[index]) + '\\n'\n                line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                if index_edge == 0:\n                    line += '\\t\\t\\t\\t</faultTopEdge>\\n'\n                elif index_edge == len(set(Depth)) - 1:\n                    line += '\\t\\t\\t\\t</faultBottomEdge>\\n'\n                else:\n                    line += '\\t\\t\\t\\t</intermediateEdge>\\n'\n                index_edge += 1\n            line += '\\t\\t\\t</complexFaultGeometry>\\n'\n        if test_ok == 0:\n            print('!!!!!!!!!! Problem with the fault Geometry, please check input file')\n            sys.exit()\n        line += '\\t\\t\\t<magScaleRel>' + ScL_oq + '</magScaleRel>\\n'\n        line += '\\t\\t\\t<ruptAspectRatio>1.0</ruptAspectRatio>\\n'\n        line += '\\t\\t\\t<incrementalMFD minMag=\"' + str(M_min) + '\" binWidth=\"0.10\">\\n'\n        if sum(MFD) != 0:\n            log_mdf_file.write(str(fault_name) + '\\t' + str(M_min) + '\\t' + ' '.join(list(map(str, MFD))) + '\\n')\n            line += '\\t\\t\\t\\t<occurRates> ' + ' '.join(list(map(str, MFD))) + '</occurRates>\\n'\n        else:\n            MFD[0] += 1e-11\n            log_mdf_file.write(str(fault_name) + '\\t' + str(M_min) + '\\t' + ' '.join(list(map(str, MFD))) + '\\n')\n            line += '\\t\\t\\t\\t<occurRates> ' + ' '.join(list(map(str, MFD))) + '</occurRates>\\n'\n        line += '\\t\\t\\t</incrementalMFD>\\n'\n        line += '\\t\\t\\t<rake>' + str(faults_data[index_fault]['rake']) + '</rake>\\n'\n        if type_of_fault == 'sf':\n            line += '\\t\\t</simpleFaultSource>\\n'\n        if type_of_fault == 'cf':\n            line += '\\t\\t</complexFaultSource>\\n'\n    return (line, Domain_in_the_model, ID_number)",
            "def write_simple_fault(index_fault, fault_name, OQ_entry_faults, faults_names, faults_data, Model_name, Domain_in_the_model, ScL_oq, log_mdf_file, M_min, ID_number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if fault_name in faults_names:\n        i_MFD = np.where(np.array(faults_names) == fault_name)[0][0]\n        MFD = OQ_entry_faults[i_MFD]\n        ID_number = ID_number + 1\n        if not faults_data[index_fault]['domain'] in str(Domain_in_the_model):\n            Domain_in_the_model.append(faults_data[index_fault]['domain'])\n        ColLon = faults_data[index_fault]['lon']\n        ColLat = faults_data[index_fault]['lat']\n        Depth = faults_data[index_fault]['depth']\n        test_ok = 0\n        if Depth and all((elem == 'sf' for elem in Depth)):\n            type_of_fault = 'sf'\n        else:\n            type_of_fault = 'cf'\n            Depth = [float(i) for i in Depth]\n        if type_of_fault == 'sf':\n            fault_name = Model_name + '_' + str(fault_name)\n            line = '\\t\\t<simpleFaultSource id=\"' + str(ID_number) + '\" name=\"' + str(fault_name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n            test_ok += 1\n            compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n            if str('N') in str(faults_data[index_fault]['oriented']):\n                if compass_bearing < 180.0:\n                    ColLon = reversed(ColLon)\n                    ColLat = reversed(ColLat)\n            elif str('S') in str(faults_data[index_fault]['oriented']):\n                if compass_bearing > 180.0:\n                    ColLon = reversed(ColLon)\n                    ColLat = reversed(ColLat)\n            elif str('E') in str(faults_data[index_fault]['oriented']):\n                if compass_bearing > 90.0 and compass_bearing < 270.0:\n                    ColLon = reversed(ColLon)\n                    ColLat = reversed(ColLat)\n            elif str('W') in str(faults_data[index_fault]['oriented']):\n                if compass_bearing < 90.0 or compass_bearing > 270.0:\n                    ColLon = reversed(ColLon)\n                    ColLat = reversed(ColLat)\n            use_kite = False\n            if use_kite == True:\n                usd = faults_data[index_fault]['upper_sismo_depth']\n                lsd = faults_data[index_fault]['lower_sismo_depth']\n                dip_tan = math.tan(math.radians(faults_data[index_fault]['dip']))\n                hdist_top = usd / dip_tan\n                hdist_bottom = lsd / dip_tan\n                ColLon = list(ColLon)\n                ColLat = list(ColLat)\n                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                strike = compass_bearing\n                azimuth = (strike + 90.0) % 360\n                line += '\\t\\t\\t<kiteSurface>\\n'\n                for (x, y) in zip(ColLon, ColLat):\n                    line += '\\t\\t\\t<profile>\\n'\n                    line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                    line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                    (xt, yt) = point_at(x, y, azimuth, hdist_top)\n                    line += '\\t\\t\\t\\t\\t\\t' + str(xt) + ' ' + str(yt) + ' ' + str(usd) + ' '\n                    (xb, yb) = point_at(x, y, azimuth, hdist_bottom)\n                    line += str(xb) + ' ' + str(yb) + ' ' + str(lsd) + '\\n'\n                    line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                    line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                    line += '\\t\\t\\t</profile>\\n'\n                line += '\\t\\t\\t</kiteSurface>\\n'\n            else:\n                line += '\\t\\t\\t<simpleFaultGeometry>\\n'\n                line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                for (x, y) in zip(ColLon, ColLat):\n                    line += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + '\\n'\n                line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                line += '\\t\\t\\t\\t<dip>' + str(faults_data[index_fault]['dip']) + '</dip>\\n'\n                line += '\\t\\t\\t\\t<upperSeismoDepth>' + str(faults_data[index_fault]['upper_sismo_depth']) + '</upperSeismoDepth>\\n'\n                line += '\\t\\t\\t\\t<lowerSeismoDepth>' + str(faults_data[index_fault]['lower_sismo_depth']) + '</lowerSeismoDepth>\\n'\n                line += '\\t\\t\\t</simpleFaultGeometry>\\n'\n        if type_of_fault == 'cf':\n            fault_name = Model_name + '_' + str(fault_name)\n            line = '\\t\\t<complexFaultSource id=\"' + str(ID_number) + '\" name=\"' + str(fault_name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n            test_ok += 1\n            line += '\\t\\t\\t<complexFaultGeometry>\\n'\n            index_edge = 0\n            for depth_i in sorted(set(Depth)):\n                indexes_for_edge_i = np.where(np.array(Depth) == depth_i)[0]\n                if index_edge == 0:\n                    line += '\\t\\t\\t\\t<faultTopEdge>\\n'\n                elif index_edge == len(set(Depth)) - 1:\n                    line += '\\t\\t\\t\\t<faultBottomEdge>\\n'\n                else:\n                    line += '\\t\\t\\t\\t<intermediateEdge>\\n'\n                line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                for index in indexes_for_edge_i:\n                    line += '\\t\\t\\t\\t\\t\\t' + str(ColLon[index]) + ' ' + str(ColLat[index]) + ' ' + str(Depth[index]) + '\\n'\n                line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                if index_edge == 0:\n                    line += '\\t\\t\\t\\t</faultTopEdge>\\n'\n                elif index_edge == len(set(Depth)) - 1:\n                    line += '\\t\\t\\t\\t</faultBottomEdge>\\n'\n                else:\n                    line += '\\t\\t\\t\\t</intermediateEdge>\\n'\n                index_edge += 1\n            line += '\\t\\t\\t</complexFaultGeometry>\\n'\n        if test_ok == 0:\n            print('!!!!!!!!!! Problem with the fault Geometry, please check input file')\n            sys.exit()\n        line += '\\t\\t\\t<magScaleRel>' + ScL_oq + '</magScaleRel>\\n'\n        line += '\\t\\t\\t<ruptAspectRatio>1.0</ruptAspectRatio>\\n'\n        line += '\\t\\t\\t<incrementalMFD minMag=\"' + str(M_min) + '\" binWidth=\"0.10\">\\n'\n        if sum(MFD) != 0:\n            log_mdf_file.write(str(fault_name) + '\\t' + str(M_min) + '\\t' + ' '.join(list(map(str, MFD))) + '\\n')\n            line += '\\t\\t\\t\\t<occurRates> ' + ' '.join(list(map(str, MFD))) + '</occurRates>\\n'\n        else:\n            MFD[0] += 1e-11\n            log_mdf_file.write(str(fault_name) + '\\t' + str(M_min) + '\\t' + ' '.join(list(map(str, MFD))) + '\\n')\n            line += '\\t\\t\\t\\t<occurRates> ' + ' '.join(list(map(str, MFD))) + '</occurRates>\\n'\n        line += '\\t\\t\\t</incrementalMFD>\\n'\n        line += '\\t\\t\\t<rake>' + str(faults_data[index_fault]['rake']) + '</rake>\\n'\n        if type_of_fault == 'sf':\n            line += '\\t\\t</simpleFaultSource>\\n'\n        if type_of_fault == 'cf':\n            line += '\\t\\t</complexFaultSource>\\n'\n    return (line, Domain_in_the_model, ID_number)"
        ]
    },
    {
        "func_name": "write_characteristic_scenario",
        "original": "def write_characteristic_scenario(scenarios_names, OQ_entry_scenarios, index_faults_in_scenario, scenario, faults_names, Model_name, faults_data, log_mdf_file, M_min, ID_number):\n    index_scenario = np.where(np.array(scenarios_names) == scenario[1])[0][0]\n    MFD = OQ_entry_scenarios[index_scenario]\n    if sum(MFD) != 0:\n        ID_number = ID_number + 1\n        index_fault = faults_names.index(scenario[1]['f_1'][0])\n        scenar_name = '_'.join(('{!s}={!r}'.format(key, val) for (key, val) in scenario[1].items()))\n        Fault_Name = Model_name + '_scenario_' + str(scenar_name)\n        line = '\\t\\t<characteristicFaultSource id=\"' + str(ID_number) + '\" name=\"' + str(Fault_Name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n        index_faults_in_scenario = index_faults_in_scenario[index_scenario][0]\n        faults_in_scenario = np.take(faults_names, index_faults_in_scenario)\n        line = +'\\t\\t\\t<surface>\\n'\n        scenario_mechanism = []\n        for Fault_name in faults_in_scenario:\n            index_fault = faults_names.index(Fault_name)\n            ColLon = faults_data[index_fault]['lon']\n            ColLat = faults_data[index_fault]['lat']\n            Depth = faults_data[index_fault]['depth']\n            scenario_mechanism.append(faults_data[index_fault]['rake'])\n            if Depth and all((elem == 'sf' for elem in Depth)):\n                type_of_fault = 'sf'\n            else:\n                type_of_fault = 'cf'\n                Depth = [float(i) for i in Depth]\n            if type_of_fault == 'sf':\n                line += '\\t\\t\\t<simpleFaultGeometry>\\n'\n                line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                if str('N') in str(faults_data[index_fault]['oriented']):\n                    if compass_bearing < 180.0:\n                        ColLon = reversed(ColLon)\n                        ColLat = reversed(ColLat)\n                elif str('S') in str(faults_data[index_fault]['oriented']):\n                    if compass_bearing > 180.0:\n                        ColLon = reversed(ColLon)\n                        ColLat = reversed(ColLat)\n                elif str('E') in str(faults_data[index_fault]['oriented']):\n                    if compass_bearing > 90.0 and compass_bearing < 270.0:\n                        ColLon = reversed(ColLon)\n                        ColLat = reversed(ColLat)\n                elif str('W') in str(faults_data[index_fault]['oriented']):\n                    if compass_bearing < 90.0 or compass_bearing > 270.0:\n                        ColLon = reversed(ColLon)\n                        ColLat = reversed(ColLat)\n                for (x, y) in zip(ColLon, ColLat):\n                    line += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + '\\n'\n                line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                line += '\\t\\t\\t\\t<dip>' + str(faults_data[index_fault]['dip']) + '</dip>\\n'\n                line += '\\t\\t\\t\\t<upperSeismoDepth>' + str(faults_data[index_fault]['upper_sismo_depth']) + '</upperSeismoDepth>\\n'\n                line += '\\t\\t\\t\\t<lowerSeismoDepth>' + str(faults_data[index_fault]['lower_sismo_depth']) + '</lowerSeismoDepth>\\n'\n                line += '\\t\\t\\t</simpleFaultGeometry>\\n'\n            if type_of_fault == 'cf':\n                line += '\\t\\t\\t<complexFaultGeometry>\\n'\n                index_edge = 0\n                for depth_i in sorted(set(Depth)):\n                    indexes_for_edge_i = np.where(np.array(Depth) == depth_i)[0]\n                    if index_edge == 0:\n                        line += '\\t\\t\\t\\t<faultTopEdge>\\n'\n                    elif index_edge == len(set(Depth)) - 1:\n                        line += '\\t\\t\\t\\t<faultBottomEdge>\\n'\n                    else:\n                        line += '\\t\\t\\t\\t<intermediateEdge>\\n'\n                    line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                    line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                    for index in indexes_for_edge_i:\n                        line += '\\t\\t\\t\\t\\t\\t' + str(ColLon[index]) + ' ' + str(ColLat[index]) + ' ' + str(Depth[index]) + '\\n'\n                    line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                    line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                    if index_edge == 0:\n                        line += '\\t\\t\\t\\t</faultTopEdge>\\n'\n                    elif index_edge == len(set(Depth)) - 1:\n                        line += '\\t\\t\\t\\t</faultBottomEdge>\\n'\n                    else:\n                        line += '\\t\\t\\t\\t</intermediateEdge>\\n'\n                    index_edge += 1\n                line += '\\t\\t\\t</complexFaultGeometry>\\n'\n        line += '\\t\\t\\t</surface>\\n'\n        line += '\\t\\t\\t<magScaleRel>' + ScL_oq + '</magScaleRel>\\n'\n        line += '\\t\\t\\t<ruptAspectRatio>1.0</ruptAspectRatio>\\n'\n        log_mdf_file.write(str(Fault_Name) + '\\t' + str(M_min) + '\\t' + ' '.join(list(map(str, MFD))) + '\\n')\n        line += '\\t\\t\\t<incrementalMFD minMag=\"' + str(M_min) + '\" binWidth=\"0.10\">\\n'\n        line += '\\t\\t\\t\\t<occurRates> ' + ' '.join(list(map(str, MFD))) + '</occurRates>\\n'\n        line += '\\t\\t\\t</incrementalMFD>\\n'\n        rake = np.mean(scenario_mechanism)\n        line += '\\t\\t\\t<rake>' + str(rake) + '</rake>\\n'\n        line = '\\t\\t</characteristicFaultSource>\\n'\n    return (line, ID_number)",
        "mutated": [
            "def write_characteristic_scenario(scenarios_names, OQ_entry_scenarios, index_faults_in_scenario, scenario, faults_names, Model_name, faults_data, log_mdf_file, M_min, ID_number):\n    if False:\n        i = 10\n    index_scenario = np.where(np.array(scenarios_names) == scenario[1])[0][0]\n    MFD = OQ_entry_scenarios[index_scenario]\n    if sum(MFD) != 0:\n        ID_number = ID_number + 1\n        index_fault = faults_names.index(scenario[1]['f_1'][0])\n        scenar_name = '_'.join(('{!s}={!r}'.format(key, val) for (key, val) in scenario[1].items()))\n        Fault_Name = Model_name + '_scenario_' + str(scenar_name)\n        line = '\\t\\t<characteristicFaultSource id=\"' + str(ID_number) + '\" name=\"' + str(Fault_Name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n        index_faults_in_scenario = index_faults_in_scenario[index_scenario][0]\n        faults_in_scenario = np.take(faults_names, index_faults_in_scenario)\n        line = +'\\t\\t\\t<surface>\\n'\n        scenario_mechanism = []\n        for Fault_name in faults_in_scenario:\n            index_fault = faults_names.index(Fault_name)\n            ColLon = faults_data[index_fault]['lon']\n            ColLat = faults_data[index_fault]['lat']\n            Depth = faults_data[index_fault]['depth']\n            scenario_mechanism.append(faults_data[index_fault]['rake'])\n            if Depth and all((elem == 'sf' for elem in Depth)):\n                type_of_fault = 'sf'\n            else:\n                type_of_fault = 'cf'\n                Depth = [float(i) for i in Depth]\n            if type_of_fault == 'sf':\n                line += '\\t\\t\\t<simpleFaultGeometry>\\n'\n                line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                if str('N') in str(faults_data[index_fault]['oriented']):\n                    if compass_bearing < 180.0:\n                        ColLon = reversed(ColLon)\n                        ColLat = reversed(ColLat)\n                elif str('S') in str(faults_data[index_fault]['oriented']):\n                    if compass_bearing > 180.0:\n                        ColLon = reversed(ColLon)\n                        ColLat = reversed(ColLat)\n                elif str('E') in str(faults_data[index_fault]['oriented']):\n                    if compass_bearing > 90.0 and compass_bearing < 270.0:\n                        ColLon = reversed(ColLon)\n                        ColLat = reversed(ColLat)\n                elif str('W') in str(faults_data[index_fault]['oriented']):\n                    if compass_bearing < 90.0 or compass_bearing > 270.0:\n                        ColLon = reversed(ColLon)\n                        ColLat = reversed(ColLat)\n                for (x, y) in zip(ColLon, ColLat):\n                    line += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + '\\n'\n                line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                line += '\\t\\t\\t\\t<dip>' + str(faults_data[index_fault]['dip']) + '</dip>\\n'\n                line += '\\t\\t\\t\\t<upperSeismoDepth>' + str(faults_data[index_fault]['upper_sismo_depth']) + '</upperSeismoDepth>\\n'\n                line += '\\t\\t\\t\\t<lowerSeismoDepth>' + str(faults_data[index_fault]['lower_sismo_depth']) + '</lowerSeismoDepth>\\n'\n                line += '\\t\\t\\t</simpleFaultGeometry>\\n'\n            if type_of_fault == 'cf':\n                line += '\\t\\t\\t<complexFaultGeometry>\\n'\n                index_edge = 0\n                for depth_i in sorted(set(Depth)):\n                    indexes_for_edge_i = np.where(np.array(Depth) == depth_i)[0]\n                    if index_edge == 0:\n                        line += '\\t\\t\\t\\t<faultTopEdge>\\n'\n                    elif index_edge == len(set(Depth)) - 1:\n                        line += '\\t\\t\\t\\t<faultBottomEdge>\\n'\n                    else:\n                        line += '\\t\\t\\t\\t<intermediateEdge>\\n'\n                    line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                    line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                    for index in indexes_for_edge_i:\n                        line += '\\t\\t\\t\\t\\t\\t' + str(ColLon[index]) + ' ' + str(ColLat[index]) + ' ' + str(Depth[index]) + '\\n'\n                    line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                    line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                    if index_edge == 0:\n                        line += '\\t\\t\\t\\t</faultTopEdge>\\n'\n                    elif index_edge == len(set(Depth)) - 1:\n                        line += '\\t\\t\\t\\t</faultBottomEdge>\\n'\n                    else:\n                        line += '\\t\\t\\t\\t</intermediateEdge>\\n'\n                    index_edge += 1\n                line += '\\t\\t\\t</complexFaultGeometry>\\n'\n        line += '\\t\\t\\t</surface>\\n'\n        line += '\\t\\t\\t<magScaleRel>' + ScL_oq + '</magScaleRel>\\n'\n        line += '\\t\\t\\t<ruptAspectRatio>1.0</ruptAspectRatio>\\n'\n        log_mdf_file.write(str(Fault_Name) + '\\t' + str(M_min) + '\\t' + ' '.join(list(map(str, MFD))) + '\\n')\n        line += '\\t\\t\\t<incrementalMFD minMag=\"' + str(M_min) + '\" binWidth=\"0.10\">\\n'\n        line += '\\t\\t\\t\\t<occurRates> ' + ' '.join(list(map(str, MFD))) + '</occurRates>\\n'\n        line += '\\t\\t\\t</incrementalMFD>\\n'\n        rake = np.mean(scenario_mechanism)\n        line += '\\t\\t\\t<rake>' + str(rake) + '</rake>\\n'\n        line = '\\t\\t</characteristicFaultSource>\\n'\n    return (line, ID_number)",
            "def write_characteristic_scenario(scenarios_names, OQ_entry_scenarios, index_faults_in_scenario, scenario, faults_names, Model_name, faults_data, log_mdf_file, M_min, ID_number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    index_scenario = np.where(np.array(scenarios_names) == scenario[1])[0][0]\n    MFD = OQ_entry_scenarios[index_scenario]\n    if sum(MFD) != 0:\n        ID_number = ID_number + 1\n        index_fault = faults_names.index(scenario[1]['f_1'][0])\n        scenar_name = '_'.join(('{!s}={!r}'.format(key, val) for (key, val) in scenario[1].items()))\n        Fault_Name = Model_name + '_scenario_' + str(scenar_name)\n        line = '\\t\\t<characteristicFaultSource id=\"' + str(ID_number) + '\" name=\"' + str(Fault_Name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n        index_faults_in_scenario = index_faults_in_scenario[index_scenario][0]\n        faults_in_scenario = np.take(faults_names, index_faults_in_scenario)\n        line = +'\\t\\t\\t<surface>\\n'\n        scenario_mechanism = []\n        for Fault_name in faults_in_scenario:\n            index_fault = faults_names.index(Fault_name)\n            ColLon = faults_data[index_fault]['lon']\n            ColLat = faults_data[index_fault]['lat']\n            Depth = faults_data[index_fault]['depth']\n            scenario_mechanism.append(faults_data[index_fault]['rake'])\n            if Depth and all((elem == 'sf' for elem in Depth)):\n                type_of_fault = 'sf'\n            else:\n                type_of_fault = 'cf'\n                Depth = [float(i) for i in Depth]\n            if type_of_fault == 'sf':\n                line += '\\t\\t\\t<simpleFaultGeometry>\\n'\n                line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                if str('N') in str(faults_data[index_fault]['oriented']):\n                    if compass_bearing < 180.0:\n                        ColLon = reversed(ColLon)\n                        ColLat = reversed(ColLat)\n                elif str('S') in str(faults_data[index_fault]['oriented']):\n                    if compass_bearing > 180.0:\n                        ColLon = reversed(ColLon)\n                        ColLat = reversed(ColLat)\n                elif str('E') in str(faults_data[index_fault]['oriented']):\n                    if compass_bearing > 90.0 and compass_bearing < 270.0:\n                        ColLon = reversed(ColLon)\n                        ColLat = reversed(ColLat)\n                elif str('W') in str(faults_data[index_fault]['oriented']):\n                    if compass_bearing < 90.0 or compass_bearing > 270.0:\n                        ColLon = reversed(ColLon)\n                        ColLat = reversed(ColLat)\n                for (x, y) in zip(ColLon, ColLat):\n                    line += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + '\\n'\n                line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                line += '\\t\\t\\t\\t<dip>' + str(faults_data[index_fault]['dip']) + '</dip>\\n'\n                line += '\\t\\t\\t\\t<upperSeismoDepth>' + str(faults_data[index_fault]['upper_sismo_depth']) + '</upperSeismoDepth>\\n'\n                line += '\\t\\t\\t\\t<lowerSeismoDepth>' + str(faults_data[index_fault]['lower_sismo_depth']) + '</lowerSeismoDepth>\\n'\n                line += '\\t\\t\\t</simpleFaultGeometry>\\n'\n            if type_of_fault == 'cf':\n                line += '\\t\\t\\t<complexFaultGeometry>\\n'\n                index_edge = 0\n                for depth_i in sorted(set(Depth)):\n                    indexes_for_edge_i = np.where(np.array(Depth) == depth_i)[0]\n                    if index_edge == 0:\n                        line += '\\t\\t\\t\\t<faultTopEdge>\\n'\n                    elif index_edge == len(set(Depth)) - 1:\n                        line += '\\t\\t\\t\\t<faultBottomEdge>\\n'\n                    else:\n                        line += '\\t\\t\\t\\t<intermediateEdge>\\n'\n                    line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                    line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                    for index in indexes_for_edge_i:\n                        line += '\\t\\t\\t\\t\\t\\t' + str(ColLon[index]) + ' ' + str(ColLat[index]) + ' ' + str(Depth[index]) + '\\n'\n                    line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                    line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                    if index_edge == 0:\n                        line += '\\t\\t\\t\\t</faultTopEdge>\\n'\n                    elif index_edge == len(set(Depth)) - 1:\n                        line += '\\t\\t\\t\\t</faultBottomEdge>\\n'\n                    else:\n                        line += '\\t\\t\\t\\t</intermediateEdge>\\n'\n                    index_edge += 1\n                line += '\\t\\t\\t</complexFaultGeometry>\\n'\n        line += '\\t\\t\\t</surface>\\n'\n        line += '\\t\\t\\t<magScaleRel>' + ScL_oq + '</magScaleRel>\\n'\n        line += '\\t\\t\\t<ruptAspectRatio>1.0</ruptAspectRatio>\\n'\n        log_mdf_file.write(str(Fault_Name) + '\\t' + str(M_min) + '\\t' + ' '.join(list(map(str, MFD))) + '\\n')\n        line += '\\t\\t\\t<incrementalMFD minMag=\"' + str(M_min) + '\" binWidth=\"0.10\">\\n'\n        line += '\\t\\t\\t\\t<occurRates> ' + ' '.join(list(map(str, MFD))) + '</occurRates>\\n'\n        line += '\\t\\t\\t</incrementalMFD>\\n'\n        rake = np.mean(scenario_mechanism)\n        line += '\\t\\t\\t<rake>' + str(rake) + '</rake>\\n'\n        line = '\\t\\t</characteristicFaultSource>\\n'\n    return (line, ID_number)",
            "def write_characteristic_scenario(scenarios_names, OQ_entry_scenarios, index_faults_in_scenario, scenario, faults_names, Model_name, faults_data, log_mdf_file, M_min, ID_number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    index_scenario = np.where(np.array(scenarios_names) == scenario[1])[0][0]\n    MFD = OQ_entry_scenarios[index_scenario]\n    if sum(MFD) != 0:\n        ID_number = ID_number + 1\n        index_fault = faults_names.index(scenario[1]['f_1'][0])\n        scenar_name = '_'.join(('{!s}={!r}'.format(key, val) for (key, val) in scenario[1].items()))\n        Fault_Name = Model_name + '_scenario_' + str(scenar_name)\n        line = '\\t\\t<characteristicFaultSource id=\"' + str(ID_number) + '\" name=\"' + str(Fault_Name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n        index_faults_in_scenario = index_faults_in_scenario[index_scenario][0]\n        faults_in_scenario = np.take(faults_names, index_faults_in_scenario)\n        line = +'\\t\\t\\t<surface>\\n'\n        scenario_mechanism = []\n        for Fault_name in faults_in_scenario:\n            index_fault = faults_names.index(Fault_name)\n            ColLon = faults_data[index_fault]['lon']\n            ColLat = faults_data[index_fault]['lat']\n            Depth = faults_data[index_fault]['depth']\n            scenario_mechanism.append(faults_data[index_fault]['rake'])\n            if Depth and all((elem == 'sf' for elem in Depth)):\n                type_of_fault = 'sf'\n            else:\n                type_of_fault = 'cf'\n                Depth = [float(i) for i in Depth]\n            if type_of_fault == 'sf':\n                line += '\\t\\t\\t<simpleFaultGeometry>\\n'\n                line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                if str('N') in str(faults_data[index_fault]['oriented']):\n                    if compass_bearing < 180.0:\n                        ColLon = reversed(ColLon)\n                        ColLat = reversed(ColLat)\n                elif str('S') in str(faults_data[index_fault]['oriented']):\n                    if compass_bearing > 180.0:\n                        ColLon = reversed(ColLon)\n                        ColLat = reversed(ColLat)\n                elif str('E') in str(faults_data[index_fault]['oriented']):\n                    if compass_bearing > 90.0 and compass_bearing < 270.0:\n                        ColLon = reversed(ColLon)\n                        ColLat = reversed(ColLat)\n                elif str('W') in str(faults_data[index_fault]['oriented']):\n                    if compass_bearing < 90.0 or compass_bearing > 270.0:\n                        ColLon = reversed(ColLon)\n                        ColLat = reversed(ColLat)\n                for (x, y) in zip(ColLon, ColLat):\n                    line += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + '\\n'\n                line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                line += '\\t\\t\\t\\t<dip>' + str(faults_data[index_fault]['dip']) + '</dip>\\n'\n                line += '\\t\\t\\t\\t<upperSeismoDepth>' + str(faults_data[index_fault]['upper_sismo_depth']) + '</upperSeismoDepth>\\n'\n                line += '\\t\\t\\t\\t<lowerSeismoDepth>' + str(faults_data[index_fault]['lower_sismo_depth']) + '</lowerSeismoDepth>\\n'\n                line += '\\t\\t\\t</simpleFaultGeometry>\\n'\n            if type_of_fault == 'cf':\n                line += '\\t\\t\\t<complexFaultGeometry>\\n'\n                index_edge = 0\n                for depth_i in sorted(set(Depth)):\n                    indexes_for_edge_i = np.where(np.array(Depth) == depth_i)[0]\n                    if index_edge == 0:\n                        line += '\\t\\t\\t\\t<faultTopEdge>\\n'\n                    elif index_edge == len(set(Depth)) - 1:\n                        line += '\\t\\t\\t\\t<faultBottomEdge>\\n'\n                    else:\n                        line += '\\t\\t\\t\\t<intermediateEdge>\\n'\n                    line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                    line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                    for index in indexes_for_edge_i:\n                        line += '\\t\\t\\t\\t\\t\\t' + str(ColLon[index]) + ' ' + str(ColLat[index]) + ' ' + str(Depth[index]) + '\\n'\n                    line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                    line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                    if index_edge == 0:\n                        line += '\\t\\t\\t\\t</faultTopEdge>\\n'\n                    elif index_edge == len(set(Depth)) - 1:\n                        line += '\\t\\t\\t\\t</faultBottomEdge>\\n'\n                    else:\n                        line += '\\t\\t\\t\\t</intermediateEdge>\\n'\n                    index_edge += 1\n                line += '\\t\\t\\t</complexFaultGeometry>\\n'\n        line += '\\t\\t\\t</surface>\\n'\n        line += '\\t\\t\\t<magScaleRel>' + ScL_oq + '</magScaleRel>\\n'\n        line += '\\t\\t\\t<ruptAspectRatio>1.0</ruptAspectRatio>\\n'\n        log_mdf_file.write(str(Fault_Name) + '\\t' + str(M_min) + '\\t' + ' '.join(list(map(str, MFD))) + '\\n')\n        line += '\\t\\t\\t<incrementalMFD minMag=\"' + str(M_min) + '\" binWidth=\"0.10\">\\n'\n        line += '\\t\\t\\t\\t<occurRates> ' + ' '.join(list(map(str, MFD))) + '</occurRates>\\n'\n        line += '\\t\\t\\t</incrementalMFD>\\n'\n        rake = np.mean(scenario_mechanism)\n        line += '\\t\\t\\t<rake>' + str(rake) + '</rake>\\n'\n        line = '\\t\\t</characteristicFaultSource>\\n'\n    return (line, ID_number)",
            "def write_characteristic_scenario(scenarios_names, OQ_entry_scenarios, index_faults_in_scenario, scenario, faults_names, Model_name, faults_data, log_mdf_file, M_min, ID_number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    index_scenario = np.where(np.array(scenarios_names) == scenario[1])[0][0]\n    MFD = OQ_entry_scenarios[index_scenario]\n    if sum(MFD) != 0:\n        ID_number = ID_number + 1\n        index_fault = faults_names.index(scenario[1]['f_1'][0])\n        scenar_name = '_'.join(('{!s}={!r}'.format(key, val) for (key, val) in scenario[1].items()))\n        Fault_Name = Model_name + '_scenario_' + str(scenar_name)\n        line = '\\t\\t<characteristicFaultSource id=\"' + str(ID_number) + '\" name=\"' + str(Fault_Name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n        index_faults_in_scenario = index_faults_in_scenario[index_scenario][0]\n        faults_in_scenario = np.take(faults_names, index_faults_in_scenario)\n        line = +'\\t\\t\\t<surface>\\n'\n        scenario_mechanism = []\n        for Fault_name in faults_in_scenario:\n            index_fault = faults_names.index(Fault_name)\n            ColLon = faults_data[index_fault]['lon']\n            ColLat = faults_data[index_fault]['lat']\n            Depth = faults_data[index_fault]['depth']\n            scenario_mechanism.append(faults_data[index_fault]['rake'])\n            if Depth and all((elem == 'sf' for elem in Depth)):\n                type_of_fault = 'sf'\n            else:\n                type_of_fault = 'cf'\n                Depth = [float(i) for i in Depth]\n            if type_of_fault == 'sf':\n                line += '\\t\\t\\t<simpleFaultGeometry>\\n'\n                line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                if str('N') in str(faults_data[index_fault]['oriented']):\n                    if compass_bearing < 180.0:\n                        ColLon = reversed(ColLon)\n                        ColLat = reversed(ColLat)\n                elif str('S') in str(faults_data[index_fault]['oriented']):\n                    if compass_bearing > 180.0:\n                        ColLon = reversed(ColLon)\n                        ColLat = reversed(ColLat)\n                elif str('E') in str(faults_data[index_fault]['oriented']):\n                    if compass_bearing > 90.0 and compass_bearing < 270.0:\n                        ColLon = reversed(ColLon)\n                        ColLat = reversed(ColLat)\n                elif str('W') in str(faults_data[index_fault]['oriented']):\n                    if compass_bearing < 90.0 or compass_bearing > 270.0:\n                        ColLon = reversed(ColLon)\n                        ColLat = reversed(ColLat)\n                for (x, y) in zip(ColLon, ColLat):\n                    line += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + '\\n'\n                line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                line += '\\t\\t\\t\\t<dip>' + str(faults_data[index_fault]['dip']) + '</dip>\\n'\n                line += '\\t\\t\\t\\t<upperSeismoDepth>' + str(faults_data[index_fault]['upper_sismo_depth']) + '</upperSeismoDepth>\\n'\n                line += '\\t\\t\\t\\t<lowerSeismoDepth>' + str(faults_data[index_fault]['lower_sismo_depth']) + '</lowerSeismoDepth>\\n'\n                line += '\\t\\t\\t</simpleFaultGeometry>\\n'\n            if type_of_fault == 'cf':\n                line += '\\t\\t\\t<complexFaultGeometry>\\n'\n                index_edge = 0\n                for depth_i in sorted(set(Depth)):\n                    indexes_for_edge_i = np.where(np.array(Depth) == depth_i)[0]\n                    if index_edge == 0:\n                        line += '\\t\\t\\t\\t<faultTopEdge>\\n'\n                    elif index_edge == len(set(Depth)) - 1:\n                        line += '\\t\\t\\t\\t<faultBottomEdge>\\n'\n                    else:\n                        line += '\\t\\t\\t\\t<intermediateEdge>\\n'\n                    line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                    line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                    for index in indexes_for_edge_i:\n                        line += '\\t\\t\\t\\t\\t\\t' + str(ColLon[index]) + ' ' + str(ColLat[index]) + ' ' + str(Depth[index]) + '\\n'\n                    line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                    line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                    if index_edge == 0:\n                        line += '\\t\\t\\t\\t</faultTopEdge>\\n'\n                    elif index_edge == len(set(Depth)) - 1:\n                        line += '\\t\\t\\t\\t</faultBottomEdge>\\n'\n                    else:\n                        line += '\\t\\t\\t\\t</intermediateEdge>\\n'\n                    index_edge += 1\n                line += '\\t\\t\\t</complexFaultGeometry>\\n'\n        line += '\\t\\t\\t</surface>\\n'\n        line += '\\t\\t\\t<magScaleRel>' + ScL_oq + '</magScaleRel>\\n'\n        line += '\\t\\t\\t<ruptAspectRatio>1.0</ruptAspectRatio>\\n'\n        log_mdf_file.write(str(Fault_Name) + '\\t' + str(M_min) + '\\t' + ' '.join(list(map(str, MFD))) + '\\n')\n        line += '\\t\\t\\t<incrementalMFD minMag=\"' + str(M_min) + '\" binWidth=\"0.10\">\\n'\n        line += '\\t\\t\\t\\t<occurRates> ' + ' '.join(list(map(str, MFD))) + '</occurRates>\\n'\n        line += '\\t\\t\\t</incrementalMFD>\\n'\n        rake = np.mean(scenario_mechanism)\n        line += '\\t\\t\\t<rake>' + str(rake) + '</rake>\\n'\n        line = '\\t\\t</characteristicFaultSource>\\n'\n    return (line, ID_number)",
            "def write_characteristic_scenario(scenarios_names, OQ_entry_scenarios, index_faults_in_scenario, scenario, faults_names, Model_name, faults_data, log_mdf_file, M_min, ID_number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    index_scenario = np.where(np.array(scenarios_names) == scenario[1])[0][0]\n    MFD = OQ_entry_scenarios[index_scenario]\n    if sum(MFD) != 0:\n        ID_number = ID_number + 1\n        index_fault = faults_names.index(scenario[1]['f_1'][0])\n        scenar_name = '_'.join(('{!s}={!r}'.format(key, val) for (key, val) in scenario[1].items()))\n        Fault_Name = Model_name + '_scenario_' + str(scenar_name)\n        line = '\\t\\t<characteristicFaultSource id=\"' + str(ID_number) + '\" name=\"' + str(Fault_Name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n        index_faults_in_scenario = index_faults_in_scenario[index_scenario][0]\n        faults_in_scenario = np.take(faults_names, index_faults_in_scenario)\n        line = +'\\t\\t\\t<surface>\\n'\n        scenario_mechanism = []\n        for Fault_name in faults_in_scenario:\n            index_fault = faults_names.index(Fault_name)\n            ColLon = faults_data[index_fault]['lon']\n            ColLat = faults_data[index_fault]['lat']\n            Depth = faults_data[index_fault]['depth']\n            scenario_mechanism.append(faults_data[index_fault]['rake'])\n            if Depth and all((elem == 'sf' for elem in Depth)):\n                type_of_fault = 'sf'\n            else:\n                type_of_fault = 'cf'\n                Depth = [float(i) for i in Depth]\n            if type_of_fault == 'sf':\n                line += '\\t\\t\\t<simpleFaultGeometry>\\n'\n                line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                if str('N') in str(faults_data[index_fault]['oriented']):\n                    if compass_bearing < 180.0:\n                        ColLon = reversed(ColLon)\n                        ColLat = reversed(ColLat)\n                elif str('S') in str(faults_data[index_fault]['oriented']):\n                    if compass_bearing > 180.0:\n                        ColLon = reversed(ColLon)\n                        ColLat = reversed(ColLat)\n                elif str('E') in str(faults_data[index_fault]['oriented']):\n                    if compass_bearing > 90.0 and compass_bearing < 270.0:\n                        ColLon = reversed(ColLon)\n                        ColLat = reversed(ColLat)\n                elif str('W') in str(faults_data[index_fault]['oriented']):\n                    if compass_bearing < 90.0 or compass_bearing > 270.0:\n                        ColLon = reversed(ColLon)\n                        ColLat = reversed(ColLat)\n                for (x, y) in zip(ColLon, ColLat):\n                    line += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + '\\n'\n                line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                line += '\\t\\t\\t\\t<dip>' + str(faults_data[index_fault]['dip']) + '</dip>\\n'\n                line += '\\t\\t\\t\\t<upperSeismoDepth>' + str(faults_data[index_fault]['upper_sismo_depth']) + '</upperSeismoDepth>\\n'\n                line += '\\t\\t\\t\\t<lowerSeismoDepth>' + str(faults_data[index_fault]['lower_sismo_depth']) + '</lowerSeismoDepth>\\n'\n                line += '\\t\\t\\t</simpleFaultGeometry>\\n'\n            if type_of_fault == 'cf':\n                line += '\\t\\t\\t<complexFaultGeometry>\\n'\n                index_edge = 0\n                for depth_i in sorted(set(Depth)):\n                    indexes_for_edge_i = np.where(np.array(Depth) == depth_i)[0]\n                    if index_edge == 0:\n                        line += '\\t\\t\\t\\t<faultTopEdge>\\n'\n                    elif index_edge == len(set(Depth)) - 1:\n                        line += '\\t\\t\\t\\t<faultBottomEdge>\\n'\n                    else:\n                        line += '\\t\\t\\t\\t<intermediateEdge>\\n'\n                    line += '\\t\\t\\t\\t<gml:LineString>\\n'\n                    line += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                    for index in indexes_for_edge_i:\n                        line += '\\t\\t\\t\\t\\t\\t' + str(ColLon[index]) + ' ' + str(ColLat[index]) + ' ' + str(Depth[index]) + '\\n'\n                    line += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                    line += '\\t\\t\\t\\t</gml:LineString>\\n'\n                    if index_edge == 0:\n                        line += '\\t\\t\\t\\t</faultTopEdge>\\n'\n                    elif index_edge == len(set(Depth)) - 1:\n                        line += '\\t\\t\\t\\t</faultBottomEdge>\\n'\n                    else:\n                        line += '\\t\\t\\t\\t</intermediateEdge>\\n'\n                    index_edge += 1\n                line += '\\t\\t\\t</complexFaultGeometry>\\n'\n        line += '\\t\\t\\t</surface>\\n'\n        line += '\\t\\t\\t<magScaleRel>' + ScL_oq + '</magScaleRel>\\n'\n        line += '\\t\\t\\t<ruptAspectRatio>1.0</ruptAspectRatio>\\n'\n        log_mdf_file.write(str(Fault_Name) + '\\t' + str(M_min) + '\\t' + ' '.join(list(map(str, MFD))) + '\\n')\n        line += '\\t\\t\\t<incrementalMFD minMag=\"' + str(M_min) + '\" binWidth=\"0.10\">\\n'\n        line += '\\t\\t\\t\\t<occurRates> ' + ' '.join(list(map(str, MFD))) + '</occurRates>\\n'\n        line += '\\t\\t\\t</incrementalMFD>\\n'\n        rake = np.mean(scenario_mechanism)\n        line += '\\t\\t\\t<rake>' + str(rake) + '</rake>\\n'\n        line = '\\t\\t</characteristicFaultSource>\\n'\n    return (line, ID_number)"
        ]
    },
    {
        "func_name": "write_non_parametric_one_fault",
        "original": "def write_non_parametric_one_fault(index_fault, fault_name, OQ_entry_faults, faults_names, faults_data, Model_name, Domain_in_the_model, ScL_oq, log_mdf_file, M_min, ID_number, explo_time):\n    \"\"\"\n    Write a non parametric source with fault trace defined as set of kite fault surfaces\n    for now the rupture occurs once of not. several occurences are not supported yet.\n    For one fault only\n    \"\"\"\n    i_MFD = np.where(np.array(faults_names) == fault_name)[0][0]\n    MFD = OQ_entry_faults[i_MFD]\n    line = ''\n    if sum(MFD) != 0:\n        ID_number = ID_number + 1\n        Fault_Name = Model_name + '_' + str(fault_name)\n        if not faults_data[index_fault]['domain'] in str(Domain_in_the_model):\n            Domain_in_the_model.append(faults_data[index_fault]['domain'])\n        line = '\\t\\t<nonParametricSeismicSource id=\"' + str(ID_number) + '\" name=\"' + str(Fault_Name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n        str_geom = ''\n        bin_mag = np.linspace(M_min, M_min + 0.1 * len(MFD) + 0.1, num=2 + len(MFD))\n        for (mag, i_mag) in zip(bin_mag, range(len(bin_mag))):\n            if i_mag <= len(MFD) - 1:\n                l = MFD[i_mag]\n                if l != 0.0:\n                    t = explo_time\n                    p_occur_1 = np.float32((l * t) ** 1 * np.exp(-l * t) / np.math.factorial(1))\n                    xxx1 = Decimal('{:.8f}'.format(np.float32(p_occur_1)))\n                    p_not_occur = Decimal('1') - xxx1\n                    p_not_occur = '{:.8f}'.format(p_not_occur)\n                    line += '\\t\\t\\t<multiPlanesRupture probs_occur=\"' + str(p_not_occur) + ' ' + str(xxx1) + '\">\\n'\n                    line += '\\t\\t\\t<magnitude>' + str(mag) + '</magnitude>\\n'\n                    if str_geom == '':\n                        scenario_mechanism = []\n                        index_fault = faults_names.index(fault_name)\n                        ColLon = faults_data[index_fault]['lon']\n                        ColLat = faults_data[index_fault]['lat']\n                        Depth = faults_data[index_fault]['depth']\n                        scenario_mechanism.append(faults_data[index_fault]['rake'])\n                        if Depth and all((elem == 'sf' for elem in Depth)):\n                            type_of_fault = 'sf'\n                        else:\n                            type_of_fault = 'cf'\n                            Depth = [float(i) for i in Depth]\n                        if type_of_fault == 'sf':\n                            usd = faults_data[index_fault]['upper_sismo_depth']\n                            lsd = faults_data[index_fault]['lower_sismo_depth']\n                            dip_tan = math.tan(math.radians(faults_data[index_fault]['dip']))\n                            hdist_top = usd / dip_tan\n                            hdist_bottom = lsd / dip_tan\n                            compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                            if str('N') in str(faults_data[index_fault]['oriented']):\n                                if compass_bearing < 180.0:\n                                    ColLon = reversed(ColLon)\n                                    ColLat = reversed(ColLat)\n                            elif str('S') in str(faults_data[index_fault]['oriented']):\n                                if compass_bearing > 180.0:\n                                    ColLon = reversed(ColLon)\n                                    ColLat = reversed(ColLat)\n                            elif str('E') in str(faults_data[index_fault]['oriented']):\n                                if compass_bearing > 90.0 and compass_bearing < 270.0:\n                                    ColLon = reversed(ColLon)\n                                    ColLat = reversed(ColLat)\n                            elif str('W') in str(faults_data[index_fault]['oriented']):\n                                if compass_bearing < 90.0 or compass_bearing > 270.0:\n                                    ColLon = reversed(ColLon)\n                                    ColLat = reversed(ColLat)\n                            ColLon = list(ColLon)\n                            ColLat = list(ColLat)\n                            do_resample = True\n                            if do_resample == True:\n                                min_d = 5.0\n                                max_d = 15.0\n                                az_d = 15.0\n                                (resampled_ColLon, resampled_ColLat) = ([ColLon[0]], [ColLat[0]])\n                                for i_pt in range(len(ColLon) - 2):\n                                    add_point = False\n                                    i_pt += 1\n                                    dist_before = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt], ColLat[i_pt])\n                                    dist_after = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt + 1], ColLat[i_pt + 1])\n                                    az_before = calculate_initial_compass_bearing((resampled_ColLon[-1], resampled_ColLat[-1]), (ColLon[i_pt], ColLat[i_pt]))\n                                    az_after = calculate_initial_compass_bearing((ColLon[i_pt], ColLat[i_pt]), (ColLon[i_pt + 1], ColLat[i_pt + 1]))\n                                    if dist_before > min_d and (dist_after > max_d or abs(az_before - az_after) > az_d):\n                                        add_point = True\n                                        if i_pt == len(ColLon) - 2:\n                                            last_dist_after = distance(ColLon[i_pt], ColLat[i_pt], ColLon[-1], ColLat[-1])\n                                            if last_dist_after < min_d:\n                                                add_point = False\n                                    if add_point == True:\n                                        resampled_ColLon.append(ColLon[i_pt])\n                                        resampled_ColLat.append(ColLat[i_pt])\n                                resampled_ColLon.append(ColLon[-1])\n                                resampled_ColLat.append(ColLat[-1])\n                                (ColLon, ColLat) = (resampled_ColLon, resampled_ColLat)\n                                plot_stuf_detail = True\n                                if plot_stuf_detail == True:\n                                    min_dist_tmp = min_d\n                                    for i_pt in range(len(ColLon) - 2):\n                                        dist_tmp = distance(resampled_ColLon[i_pt + 1], resampled_ColLat[i_pt + 1], resampled_ColLon[i_pt], resampled_ColLat[i_pt])\n                                        if dist_tmp < min_dist_tmp:\n                                            min_dist_tmp = dist_tmp\n                                    if min_dist_tmp < min_d / 2.0:\n                                        print('min dist :', round(min_dist_tmp), 'id: ', faults_data[index_fault]['name'])\n                            str_geom += '\\t\\t\\t<kiteSurface>\\n'\n                            compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                            strike = compass_bearing\n                            mean_azimuth = (strike + 90.0) % 360\n                            i_pt = 0\n                            for (x, y) in zip(ColLon, ColLat):\n                                if [x, y] == [ColLon[0], ColLat[0]]:\n                                    compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[1], ColLon[1]))\n                                    strike = compass_bearing\n                                    azimuth = (strike + 90.0) % 360\n                                elif [x, y] == [ColLon[-1], ColLat[-1]]:\n                                    compass_bearing = calculate_initial_compass_bearing((ColLat[-2], ColLon[-2]), (ColLat[-1], ColLon[-1]))\n                                    strike = compass_bearing\n                                    azimuth = (strike + 90.0) % 360\n                                else:\n                                    compass_bearing = calculate_initial_compass_bearing((ColLat[i_pt - 1], ColLon[i_pt - 1]), (ColLat[i_pt + 1], ColLon[i_pt + 1]))\n                                    strike = compass_bearing\n                                    azimuth = (strike + 90.0) % 360\n                                azimuth = (mean_azimuth + azimuth) / 2.0 % 360\n                                str_geom += '\\t\\t\\t<profile>\\n'\n                                str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                (xt, yt) = point_at(x, y, azimuth, hdist_top)\n                                str_geom += '\\t\\t\\t\\t\\t\\t' + str(xt) + ' ' + str(yt) + ' ' + str(usd) + ' '\n                                (xb, yb) = point_at(x, y, azimuth, hdist_bottom)\n                                str_geom += str(xb) + ' ' + str(yb) + ' ' + str(lsd) + '\\n'\n                                str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t</profile>\\n'\n                                i_pt += 1\n                            str_geom += '\\t\\t\\t</kiteSurface>\\n'\n                        if type_of_fault == 'cf':\n                            str_geom += '\\t\\t\\t<kiteSurface>\\n'\n                            for depth_i in sorted(set(Depth)):\n                                str_geom += '\\t\\t\\t<profile>\\n'\n                                str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                for (x, y) in zip(ColLon, ColLat):\n                                    str_geom += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + ' ' + str(hdist_d) + '\\n'\n                                str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t<\\\\profile>\\n'\n                            str_geom += '\\t\\t\\t</kiteSurface>\\n'\n                    hypo_depth = (faults_data[index_fault]['upper_sismo_depth'] + faults_data[index_fault]['lower_sismo_depth']) / 2.0\n                    str_geom += '\\t\\t\\t<hypocenter depth=\"' + str(hypo_depth) + '\" lat=\"' + str(np.mean(faults_data[index_fault]['lat'])) + '\" lon=\"' + str(np.mean(faults_data[index_fault]['lon'])) + '\"/>\\n'\n                    rake = np.mean(scenario_mechanism)\n                    str_geom += '\\t\\t\\t<rake>' + str(rake) + '</rake>\\n'\n                    line += str_geom\n                    line += '\\t\\t\\t</multiPlanesRupture>\\n'\n        line += '\\t\\t</nonParametricSeismicSource>\\n'\n    return (line, Domain_in_the_model, ID_number)",
        "mutated": [
            "def write_non_parametric_one_fault(index_fault, fault_name, OQ_entry_faults, faults_names, faults_data, Model_name, Domain_in_the_model, ScL_oq, log_mdf_file, M_min, ID_number, explo_time):\n    if False:\n        i = 10\n    '\\n    Write a non parametric source with fault trace defined as set of kite fault surfaces\\n    for now the rupture occurs once of not. several occurences are not supported yet.\\n    For one fault only\\n    '\n    i_MFD = np.where(np.array(faults_names) == fault_name)[0][0]\n    MFD = OQ_entry_faults[i_MFD]\n    line = ''\n    if sum(MFD) != 0:\n        ID_number = ID_number + 1\n        Fault_Name = Model_name + '_' + str(fault_name)\n        if not faults_data[index_fault]['domain'] in str(Domain_in_the_model):\n            Domain_in_the_model.append(faults_data[index_fault]['domain'])\n        line = '\\t\\t<nonParametricSeismicSource id=\"' + str(ID_number) + '\" name=\"' + str(Fault_Name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n        str_geom = ''\n        bin_mag = np.linspace(M_min, M_min + 0.1 * len(MFD) + 0.1, num=2 + len(MFD))\n        for (mag, i_mag) in zip(bin_mag, range(len(bin_mag))):\n            if i_mag <= len(MFD) - 1:\n                l = MFD[i_mag]\n                if l != 0.0:\n                    t = explo_time\n                    p_occur_1 = np.float32((l * t) ** 1 * np.exp(-l * t) / np.math.factorial(1))\n                    xxx1 = Decimal('{:.8f}'.format(np.float32(p_occur_1)))\n                    p_not_occur = Decimal('1') - xxx1\n                    p_not_occur = '{:.8f}'.format(p_not_occur)\n                    line += '\\t\\t\\t<multiPlanesRupture probs_occur=\"' + str(p_not_occur) + ' ' + str(xxx1) + '\">\\n'\n                    line += '\\t\\t\\t<magnitude>' + str(mag) + '</magnitude>\\n'\n                    if str_geom == '':\n                        scenario_mechanism = []\n                        index_fault = faults_names.index(fault_name)\n                        ColLon = faults_data[index_fault]['lon']\n                        ColLat = faults_data[index_fault]['lat']\n                        Depth = faults_data[index_fault]['depth']\n                        scenario_mechanism.append(faults_data[index_fault]['rake'])\n                        if Depth and all((elem == 'sf' for elem in Depth)):\n                            type_of_fault = 'sf'\n                        else:\n                            type_of_fault = 'cf'\n                            Depth = [float(i) for i in Depth]\n                        if type_of_fault == 'sf':\n                            usd = faults_data[index_fault]['upper_sismo_depth']\n                            lsd = faults_data[index_fault]['lower_sismo_depth']\n                            dip_tan = math.tan(math.radians(faults_data[index_fault]['dip']))\n                            hdist_top = usd / dip_tan\n                            hdist_bottom = lsd / dip_tan\n                            compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                            if str('N') in str(faults_data[index_fault]['oriented']):\n                                if compass_bearing < 180.0:\n                                    ColLon = reversed(ColLon)\n                                    ColLat = reversed(ColLat)\n                            elif str('S') in str(faults_data[index_fault]['oriented']):\n                                if compass_bearing > 180.0:\n                                    ColLon = reversed(ColLon)\n                                    ColLat = reversed(ColLat)\n                            elif str('E') in str(faults_data[index_fault]['oriented']):\n                                if compass_bearing > 90.0 and compass_bearing < 270.0:\n                                    ColLon = reversed(ColLon)\n                                    ColLat = reversed(ColLat)\n                            elif str('W') in str(faults_data[index_fault]['oriented']):\n                                if compass_bearing < 90.0 or compass_bearing > 270.0:\n                                    ColLon = reversed(ColLon)\n                                    ColLat = reversed(ColLat)\n                            ColLon = list(ColLon)\n                            ColLat = list(ColLat)\n                            do_resample = True\n                            if do_resample == True:\n                                min_d = 5.0\n                                max_d = 15.0\n                                az_d = 15.0\n                                (resampled_ColLon, resampled_ColLat) = ([ColLon[0]], [ColLat[0]])\n                                for i_pt in range(len(ColLon) - 2):\n                                    add_point = False\n                                    i_pt += 1\n                                    dist_before = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt], ColLat[i_pt])\n                                    dist_after = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt + 1], ColLat[i_pt + 1])\n                                    az_before = calculate_initial_compass_bearing((resampled_ColLon[-1], resampled_ColLat[-1]), (ColLon[i_pt], ColLat[i_pt]))\n                                    az_after = calculate_initial_compass_bearing((ColLon[i_pt], ColLat[i_pt]), (ColLon[i_pt + 1], ColLat[i_pt + 1]))\n                                    if dist_before > min_d and (dist_after > max_d or abs(az_before - az_after) > az_d):\n                                        add_point = True\n                                        if i_pt == len(ColLon) - 2:\n                                            last_dist_after = distance(ColLon[i_pt], ColLat[i_pt], ColLon[-1], ColLat[-1])\n                                            if last_dist_after < min_d:\n                                                add_point = False\n                                    if add_point == True:\n                                        resampled_ColLon.append(ColLon[i_pt])\n                                        resampled_ColLat.append(ColLat[i_pt])\n                                resampled_ColLon.append(ColLon[-1])\n                                resampled_ColLat.append(ColLat[-1])\n                                (ColLon, ColLat) = (resampled_ColLon, resampled_ColLat)\n                                plot_stuf_detail = True\n                                if plot_stuf_detail == True:\n                                    min_dist_tmp = min_d\n                                    for i_pt in range(len(ColLon) - 2):\n                                        dist_tmp = distance(resampled_ColLon[i_pt + 1], resampled_ColLat[i_pt + 1], resampled_ColLon[i_pt], resampled_ColLat[i_pt])\n                                        if dist_tmp < min_dist_tmp:\n                                            min_dist_tmp = dist_tmp\n                                    if min_dist_tmp < min_d / 2.0:\n                                        print('min dist :', round(min_dist_tmp), 'id: ', faults_data[index_fault]['name'])\n                            str_geom += '\\t\\t\\t<kiteSurface>\\n'\n                            compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                            strike = compass_bearing\n                            mean_azimuth = (strike + 90.0) % 360\n                            i_pt = 0\n                            for (x, y) in zip(ColLon, ColLat):\n                                if [x, y] == [ColLon[0], ColLat[0]]:\n                                    compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[1], ColLon[1]))\n                                    strike = compass_bearing\n                                    azimuth = (strike + 90.0) % 360\n                                elif [x, y] == [ColLon[-1], ColLat[-1]]:\n                                    compass_bearing = calculate_initial_compass_bearing((ColLat[-2], ColLon[-2]), (ColLat[-1], ColLon[-1]))\n                                    strike = compass_bearing\n                                    azimuth = (strike + 90.0) % 360\n                                else:\n                                    compass_bearing = calculate_initial_compass_bearing((ColLat[i_pt - 1], ColLon[i_pt - 1]), (ColLat[i_pt + 1], ColLon[i_pt + 1]))\n                                    strike = compass_bearing\n                                    azimuth = (strike + 90.0) % 360\n                                azimuth = (mean_azimuth + azimuth) / 2.0 % 360\n                                str_geom += '\\t\\t\\t<profile>\\n'\n                                str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                (xt, yt) = point_at(x, y, azimuth, hdist_top)\n                                str_geom += '\\t\\t\\t\\t\\t\\t' + str(xt) + ' ' + str(yt) + ' ' + str(usd) + ' '\n                                (xb, yb) = point_at(x, y, azimuth, hdist_bottom)\n                                str_geom += str(xb) + ' ' + str(yb) + ' ' + str(lsd) + '\\n'\n                                str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t</profile>\\n'\n                                i_pt += 1\n                            str_geom += '\\t\\t\\t</kiteSurface>\\n'\n                        if type_of_fault == 'cf':\n                            str_geom += '\\t\\t\\t<kiteSurface>\\n'\n                            for depth_i in sorted(set(Depth)):\n                                str_geom += '\\t\\t\\t<profile>\\n'\n                                str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                for (x, y) in zip(ColLon, ColLat):\n                                    str_geom += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + ' ' + str(hdist_d) + '\\n'\n                                str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t<\\\\profile>\\n'\n                            str_geom += '\\t\\t\\t</kiteSurface>\\n'\n                    hypo_depth = (faults_data[index_fault]['upper_sismo_depth'] + faults_data[index_fault]['lower_sismo_depth']) / 2.0\n                    str_geom += '\\t\\t\\t<hypocenter depth=\"' + str(hypo_depth) + '\" lat=\"' + str(np.mean(faults_data[index_fault]['lat'])) + '\" lon=\"' + str(np.mean(faults_data[index_fault]['lon'])) + '\"/>\\n'\n                    rake = np.mean(scenario_mechanism)\n                    str_geom += '\\t\\t\\t<rake>' + str(rake) + '</rake>\\n'\n                    line += str_geom\n                    line += '\\t\\t\\t</multiPlanesRupture>\\n'\n        line += '\\t\\t</nonParametricSeismicSource>\\n'\n    return (line, Domain_in_the_model, ID_number)",
            "def write_non_parametric_one_fault(index_fault, fault_name, OQ_entry_faults, faults_names, faults_data, Model_name, Domain_in_the_model, ScL_oq, log_mdf_file, M_min, ID_number, explo_time):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Write a non parametric source with fault trace defined as set of kite fault surfaces\\n    for now the rupture occurs once of not. several occurences are not supported yet.\\n    For one fault only\\n    '\n    i_MFD = np.where(np.array(faults_names) == fault_name)[0][0]\n    MFD = OQ_entry_faults[i_MFD]\n    line = ''\n    if sum(MFD) != 0:\n        ID_number = ID_number + 1\n        Fault_Name = Model_name + '_' + str(fault_name)\n        if not faults_data[index_fault]['domain'] in str(Domain_in_the_model):\n            Domain_in_the_model.append(faults_data[index_fault]['domain'])\n        line = '\\t\\t<nonParametricSeismicSource id=\"' + str(ID_number) + '\" name=\"' + str(Fault_Name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n        str_geom = ''\n        bin_mag = np.linspace(M_min, M_min + 0.1 * len(MFD) + 0.1, num=2 + len(MFD))\n        for (mag, i_mag) in zip(bin_mag, range(len(bin_mag))):\n            if i_mag <= len(MFD) - 1:\n                l = MFD[i_mag]\n                if l != 0.0:\n                    t = explo_time\n                    p_occur_1 = np.float32((l * t) ** 1 * np.exp(-l * t) / np.math.factorial(1))\n                    xxx1 = Decimal('{:.8f}'.format(np.float32(p_occur_1)))\n                    p_not_occur = Decimal('1') - xxx1\n                    p_not_occur = '{:.8f}'.format(p_not_occur)\n                    line += '\\t\\t\\t<multiPlanesRupture probs_occur=\"' + str(p_not_occur) + ' ' + str(xxx1) + '\">\\n'\n                    line += '\\t\\t\\t<magnitude>' + str(mag) + '</magnitude>\\n'\n                    if str_geom == '':\n                        scenario_mechanism = []\n                        index_fault = faults_names.index(fault_name)\n                        ColLon = faults_data[index_fault]['lon']\n                        ColLat = faults_data[index_fault]['lat']\n                        Depth = faults_data[index_fault]['depth']\n                        scenario_mechanism.append(faults_data[index_fault]['rake'])\n                        if Depth and all((elem == 'sf' for elem in Depth)):\n                            type_of_fault = 'sf'\n                        else:\n                            type_of_fault = 'cf'\n                            Depth = [float(i) for i in Depth]\n                        if type_of_fault == 'sf':\n                            usd = faults_data[index_fault]['upper_sismo_depth']\n                            lsd = faults_data[index_fault]['lower_sismo_depth']\n                            dip_tan = math.tan(math.radians(faults_data[index_fault]['dip']))\n                            hdist_top = usd / dip_tan\n                            hdist_bottom = lsd / dip_tan\n                            compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                            if str('N') in str(faults_data[index_fault]['oriented']):\n                                if compass_bearing < 180.0:\n                                    ColLon = reversed(ColLon)\n                                    ColLat = reversed(ColLat)\n                            elif str('S') in str(faults_data[index_fault]['oriented']):\n                                if compass_bearing > 180.0:\n                                    ColLon = reversed(ColLon)\n                                    ColLat = reversed(ColLat)\n                            elif str('E') in str(faults_data[index_fault]['oriented']):\n                                if compass_bearing > 90.0 and compass_bearing < 270.0:\n                                    ColLon = reversed(ColLon)\n                                    ColLat = reversed(ColLat)\n                            elif str('W') in str(faults_data[index_fault]['oriented']):\n                                if compass_bearing < 90.0 or compass_bearing > 270.0:\n                                    ColLon = reversed(ColLon)\n                                    ColLat = reversed(ColLat)\n                            ColLon = list(ColLon)\n                            ColLat = list(ColLat)\n                            do_resample = True\n                            if do_resample == True:\n                                min_d = 5.0\n                                max_d = 15.0\n                                az_d = 15.0\n                                (resampled_ColLon, resampled_ColLat) = ([ColLon[0]], [ColLat[0]])\n                                for i_pt in range(len(ColLon) - 2):\n                                    add_point = False\n                                    i_pt += 1\n                                    dist_before = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt], ColLat[i_pt])\n                                    dist_after = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt + 1], ColLat[i_pt + 1])\n                                    az_before = calculate_initial_compass_bearing((resampled_ColLon[-1], resampled_ColLat[-1]), (ColLon[i_pt], ColLat[i_pt]))\n                                    az_after = calculate_initial_compass_bearing((ColLon[i_pt], ColLat[i_pt]), (ColLon[i_pt + 1], ColLat[i_pt + 1]))\n                                    if dist_before > min_d and (dist_after > max_d or abs(az_before - az_after) > az_d):\n                                        add_point = True\n                                        if i_pt == len(ColLon) - 2:\n                                            last_dist_after = distance(ColLon[i_pt], ColLat[i_pt], ColLon[-1], ColLat[-1])\n                                            if last_dist_after < min_d:\n                                                add_point = False\n                                    if add_point == True:\n                                        resampled_ColLon.append(ColLon[i_pt])\n                                        resampled_ColLat.append(ColLat[i_pt])\n                                resampled_ColLon.append(ColLon[-1])\n                                resampled_ColLat.append(ColLat[-1])\n                                (ColLon, ColLat) = (resampled_ColLon, resampled_ColLat)\n                                plot_stuf_detail = True\n                                if plot_stuf_detail == True:\n                                    min_dist_tmp = min_d\n                                    for i_pt in range(len(ColLon) - 2):\n                                        dist_tmp = distance(resampled_ColLon[i_pt + 1], resampled_ColLat[i_pt + 1], resampled_ColLon[i_pt], resampled_ColLat[i_pt])\n                                        if dist_tmp < min_dist_tmp:\n                                            min_dist_tmp = dist_tmp\n                                    if min_dist_tmp < min_d / 2.0:\n                                        print('min dist :', round(min_dist_tmp), 'id: ', faults_data[index_fault]['name'])\n                            str_geom += '\\t\\t\\t<kiteSurface>\\n'\n                            compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                            strike = compass_bearing\n                            mean_azimuth = (strike + 90.0) % 360\n                            i_pt = 0\n                            for (x, y) in zip(ColLon, ColLat):\n                                if [x, y] == [ColLon[0], ColLat[0]]:\n                                    compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[1], ColLon[1]))\n                                    strike = compass_bearing\n                                    azimuth = (strike + 90.0) % 360\n                                elif [x, y] == [ColLon[-1], ColLat[-1]]:\n                                    compass_bearing = calculate_initial_compass_bearing((ColLat[-2], ColLon[-2]), (ColLat[-1], ColLon[-1]))\n                                    strike = compass_bearing\n                                    azimuth = (strike + 90.0) % 360\n                                else:\n                                    compass_bearing = calculate_initial_compass_bearing((ColLat[i_pt - 1], ColLon[i_pt - 1]), (ColLat[i_pt + 1], ColLon[i_pt + 1]))\n                                    strike = compass_bearing\n                                    azimuth = (strike + 90.0) % 360\n                                azimuth = (mean_azimuth + azimuth) / 2.0 % 360\n                                str_geom += '\\t\\t\\t<profile>\\n'\n                                str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                (xt, yt) = point_at(x, y, azimuth, hdist_top)\n                                str_geom += '\\t\\t\\t\\t\\t\\t' + str(xt) + ' ' + str(yt) + ' ' + str(usd) + ' '\n                                (xb, yb) = point_at(x, y, azimuth, hdist_bottom)\n                                str_geom += str(xb) + ' ' + str(yb) + ' ' + str(lsd) + '\\n'\n                                str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t</profile>\\n'\n                                i_pt += 1\n                            str_geom += '\\t\\t\\t</kiteSurface>\\n'\n                        if type_of_fault == 'cf':\n                            str_geom += '\\t\\t\\t<kiteSurface>\\n'\n                            for depth_i in sorted(set(Depth)):\n                                str_geom += '\\t\\t\\t<profile>\\n'\n                                str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                for (x, y) in zip(ColLon, ColLat):\n                                    str_geom += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + ' ' + str(hdist_d) + '\\n'\n                                str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t<\\\\profile>\\n'\n                            str_geom += '\\t\\t\\t</kiteSurface>\\n'\n                    hypo_depth = (faults_data[index_fault]['upper_sismo_depth'] + faults_data[index_fault]['lower_sismo_depth']) / 2.0\n                    str_geom += '\\t\\t\\t<hypocenter depth=\"' + str(hypo_depth) + '\" lat=\"' + str(np.mean(faults_data[index_fault]['lat'])) + '\" lon=\"' + str(np.mean(faults_data[index_fault]['lon'])) + '\"/>\\n'\n                    rake = np.mean(scenario_mechanism)\n                    str_geom += '\\t\\t\\t<rake>' + str(rake) + '</rake>\\n'\n                    line += str_geom\n                    line += '\\t\\t\\t</multiPlanesRupture>\\n'\n        line += '\\t\\t</nonParametricSeismicSource>\\n'\n    return (line, Domain_in_the_model, ID_number)",
            "def write_non_parametric_one_fault(index_fault, fault_name, OQ_entry_faults, faults_names, faults_data, Model_name, Domain_in_the_model, ScL_oq, log_mdf_file, M_min, ID_number, explo_time):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Write a non parametric source with fault trace defined as set of kite fault surfaces\\n    for now the rupture occurs once of not. several occurences are not supported yet.\\n    For one fault only\\n    '\n    i_MFD = np.where(np.array(faults_names) == fault_name)[0][0]\n    MFD = OQ_entry_faults[i_MFD]\n    line = ''\n    if sum(MFD) != 0:\n        ID_number = ID_number + 1\n        Fault_Name = Model_name + '_' + str(fault_name)\n        if not faults_data[index_fault]['domain'] in str(Domain_in_the_model):\n            Domain_in_the_model.append(faults_data[index_fault]['domain'])\n        line = '\\t\\t<nonParametricSeismicSource id=\"' + str(ID_number) + '\" name=\"' + str(Fault_Name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n        str_geom = ''\n        bin_mag = np.linspace(M_min, M_min + 0.1 * len(MFD) + 0.1, num=2 + len(MFD))\n        for (mag, i_mag) in zip(bin_mag, range(len(bin_mag))):\n            if i_mag <= len(MFD) - 1:\n                l = MFD[i_mag]\n                if l != 0.0:\n                    t = explo_time\n                    p_occur_1 = np.float32((l * t) ** 1 * np.exp(-l * t) / np.math.factorial(1))\n                    xxx1 = Decimal('{:.8f}'.format(np.float32(p_occur_1)))\n                    p_not_occur = Decimal('1') - xxx1\n                    p_not_occur = '{:.8f}'.format(p_not_occur)\n                    line += '\\t\\t\\t<multiPlanesRupture probs_occur=\"' + str(p_not_occur) + ' ' + str(xxx1) + '\">\\n'\n                    line += '\\t\\t\\t<magnitude>' + str(mag) + '</magnitude>\\n'\n                    if str_geom == '':\n                        scenario_mechanism = []\n                        index_fault = faults_names.index(fault_name)\n                        ColLon = faults_data[index_fault]['lon']\n                        ColLat = faults_data[index_fault]['lat']\n                        Depth = faults_data[index_fault]['depth']\n                        scenario_mechanism.append(faults_data[index_fault]['rake'])\n                        if Depth and all((elem == 'sf' for elem in Depth)):\n                            type_of_fault = 'sf'\n                        else:\n                            type_of_fault = 'cf'\n                            Depth = [float(i) for i in Depth]\n                        if type_of_fault == 'sf':\n                            usd = faults_data[index_fault]['upper_sismo_depth']\n                            lsd = faults_data[index_fault]['lower_sismo_depth']\n                            dip_tan = math.tan(math.radians(faults_data[index_fault]['dip']))\n                            hdist_top = usd / dip_tan\n                            hdist_bottom = lsd / dip_tan\n                            compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                            if str('N') in str(faults_data[index_fault]['oriented']):\n                                if compass_bearing < 180.0:\n                                    ColLon = reversed(ColLon)\n                                    ColLat = reversed(ColLat)\n                            elif str('S') in str(faults_data[index_fault]['oriented']):\n                                if compass_bearing > 180.0:\n                                    ColLon = reversed(ColLon)\n                                    ColLat = reversed(ColLat)\n                            elif str('E') in str(faults_data[index_fault]['oriented']):\n                                if compass_bearing > 90.0 and compass_bearing < 270.0:\n                                    ColLon = reversed(ColLon)\n                                    ColLat = reversed(ColLat)\n                            elif str('W') in str(faults_data[index_fault]['oriented']):\n                                if compass_bearing < 90.0 or compass_bearing > 270.0:\n                                    ColLon = reversed(ColLon)\n                                    ColLat = reversed(ColLat)\n                            ColLon = list(ColLon)\n                            ColLat = list(ColLat)\n                            do_resample = True\n                            if do_resample == True:\n                                min_d = 5.0\n                                max_d = 15.0\n                                az_d = 15.0\n                                (resampled_ColLon, resampled_ColLat) = ([ColLon[0]], [ColLat[0]])\n                                for i_pt in range(len(ColLon) - 2):\n                                    add_point = False\n                                    i_pt += 1\n                                    dist_before = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt], ColLat[i_pt])\n                                    dist_after = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt + 1], ColLat[i_pt + 1])\n                                    az_before = calculate_initial_compass_bearing((resampled_ColLon[-1], resampled_ColLat[-1]), (ColLon[i_pt], ColLat[i_pt]))\n                                    az_after = calculate_initial_compass_bearing((ColLon[i_pt], ColLat[i_pt]), (ColLon[i_pt + 1], ColLat[i_pt + 1]))\n                                    if dist_before > min_d and (dist_after > max_d or abs(az_before - az_after) > az_d):\n                                        add_point = True\n                                        if i_pt == len(ColLon) - 2:\n                                            last_dist_after = distance(ColLon[i_pt], ColLat[i_pt], ColLon[-1], ColLat[-1])\n                                            if last_dist_after < min_d:\n                                                add_point = False\n                                    if add_point == True:\n                                        resampled_ColLon.append(ColLon[i_pt])\n                                        resampled_ColLat.append(ColLat[i_pt])\n                                resampled_ColLon.append(ColLon[-1])\n                                resampled_ColLat.append(ColLat[-1])\n                                (ColLon, ColLat) = (resampled_ColLon, resampled_ColLat)\n                                plot_stuf_detail = True\n                                if plot_stuf_detail == True:\n                                    min_dist_tmp = min_d\n                                    for i_pt in range(len(ColLon) - 2):\n                                        dist_tmp = distance(resampled_ColLon[i_pt + 1], resampled_ColLat[i_pt + 1], resampled_ColLon[i_pt], resampled_ColLat[i_pt])\n                                        if dist_tmp < min_dist_tmp:\n                                            min_dist_tmp = dist_tmp\n                                    if min_dist_tmp < min_d / 2.0:\n                                        print('min dist :', round(min_dist_tmp), 'id: ', faults_data[index_fault]['name'])\n                            str_geom += '\\t\\t\\t<kiteSurface>\\n'\n                            compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                            strike = compass_bearing\n                            mean_azimuth = (strike + 90.0) % 360\n                            i_pt = 0\n                            for (x, y) in zip(ColLon, ColLat):\n                                if [x, y] == [ColLon[0], ColLat[0]]:\n                                    compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[1], ColLon[1]))\n                                    strike = compass_bearing\n                                    azimuth = (strike + 90.0) % 360\n                                elif [x, y] == [ColLon[-1], ColLat[-1]]:\n                                    compass_bearing = calculate_initial_compass_bearing((ColLat[-2], ColLon[-2]), (ColLat[-1], ColLon[-1]))\n                                    strike = compass_bearing\n                                    azimuth = (strike + 90.0) % 360\n                                else:\n                                    compass_bearing = calculate_initial_compass_bearing((ColLat[i_pt - 1], ColLon[i_pt - 1]), (ColLat[i_pt + 1], ColLon[i_pt + 1]))\n                                    strike = compass_bearing\n                                    azimuth = (strike + 90.0) % 360\n                                azimuth = (mean_azimuth + azimuth) / 2.0 % 360\n                                str_geom += '\\t\\t\\t<profile>\\n'\n                                str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                (xt, yt) = point_at(x, y, azimuth, hdist_top)\n                                str_geom += '\\t\\t\\t\\t\\t\\t' + str(xt) + ' ' + str(yt) + ' ' + str(usd) + ' '\n                                (xb, yb) = point_at(x, y, azimuth, hdist_bottom)\n                                str_geom += str(xb) + ' ' + str(yb) + ' ' + str(lsd) + '\\n'\n                                str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t</profile>\\n'\n                                i_pt += 1\n                            str_geom += '\\t\\t\\t</kiteSurface>\\n'\n                        if type_of_fault == 'cf':\n                            str_geom += '\\t\\t\\t<kiteSurface>\\n'\n                            for depth_i in sorted(set(Depth)):\n                                str_geom += '\\t\\t\\t<profile>\\n'\n                                str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                for (x, y) in zip(ColLon, ColLat):\n                                    str_geom += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + ' ' + str(hdist_d) + '\\n'\n                                str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t<\\\\profile>\\n'\n                            str_geom += '\\t\\t\\t</kiteSurface>\\n'\n                    hypo_depth = (faults_data[index_fault]['upper_sismo_depth'] + faults_data[index_fault]['lower_sismo_depth']) / 2.0\n                    str_geom += '\\t\\t\\t<hypocenter depth=\"' + str(hypo_depth) + '\" lat=\"' + str(np.mean(faults_data[index_fault]['lat'])) + '\" lon=\"' + str(np.mean(faults_data[index_fault]['lon'])) + '\"/>\\n'\n                    rake = np.mean(scenario_mechanism)\n                    str_geom += '\\t\\t\\t<rake>' + str(rake) + '</rake>\\n'\n                    line += str_geom\n                    line += '\\t\\t\\t</multiPlanesRupture>\\n'\n        line += '\\t\\t</nonParametricSeismicSource>\\n'\n    return (line, Domain_in_the_model, ID_number)",
            "def write_non_parametric_one_fault(index_fault, fault_name, OQ_entry_faults, faults_names, faults_data, Model_name, Domain_in_the_model, ScL_oq, log_mdf_file, M_min, ID_number, explo_time):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Write a non parametric source with fault trace defined as set of kite fault surfaces\\n    for now the rupture occurs once of not. several occurences are not supported yet.\\n    For one fault only\\n    '\n    i_MFD = np.where(np.array(faults_names) == fault_name)[0][0]\n    MFD = OQ_entry_faults[i_MFD]\n    line = ''\n    if sum(MFD) != 0:\n        ID_number = ID_number + 1\n        Fault_Name = Model_name + '_' + str(fault_name)\n        if not faults_data[index_fault]['domain'] in str(Domain_in_the_model):\n            Domain_in_the_model.append(faults_data[index_fault]['domain'])\n        line = '\\t\\t<nonParametricSeismicSource id=\"' + str(ID_number) + '\" name=\"' + str(Fault_Name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n        str_geom = ''\n        bin_mag = np.linspace(M_min, M_min + 0.1 * len(MFD) + 0.1, num=2 + len(MFD))\n        for (mag, i_mag) in zip(bin_mag, range(len(bin_mag))):\n            if i_mag <= len(MFD) - 1:\n                l = MFD[i_mag]\n                if l != 0.0:\n                    t = explo_time\n                    p_occur_1 = np.float32((l * t) ** 1 * np.exp(-l * t) / np.math.factorial(1))\n                    xxx1 = Decimal('{:.8f}'.format(np.float32(p_occur_1)))\n                    p_not_occur = Decimal('1') - xxx1\n                    p_not_occur = '{:.8f}'.format(p_not_occur)\n                    line += '\\t\\t\\t<multiPlanesRupture probs_occur=\"' + str(p_not_occur) + ' ' + str(xxx1) + '\">\\n'\n                    line += '\\t\\t\\t<magnitude>' + str(mag) + '</magnitude>\\n'\n                    if str_geom == '':\n                        scenario_mechanism = []\n                        index_fault = faults_names.index(fault_name)\n                        ColLon = faults_data[index_fault]['lon']\n                        ColLat = faults_data[index_fault]['lat']\n                        Depth = faults_data[index_fault]['depth']\n                        scenario_mechanism.append(faults_data[index_fault]['rake'])\n                        if Depth and all((elem == 'sf' for elem in Depth)):\n                            type_of_fault = 'sf'\n                        else:\n                            type_of_fault = 'cf'\n                            Depth = [float(i) for i in Depth]\n                        if type_of_fault == 'sf':\n                            usd = faults_data[index_fault]['upper_sismo_depth']\n                            lsd = faults_data[index_fault]['lower_sismo_depth']\n                            dip_tan = math.tan(math.radians(faults_data[index_fault]['dip']))\n                            hdist_top = usd / dip_tan\n                            hdist_bottom = lsd / dip_tan\n                            compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                            if str('N') in str(faults_data[index_fault]['oriented']):\n                                if compass_bearing < 180.0:\n                                    ColLon = reversed(ColLon)\n                                    ColLat = reversed(ColLat)\n                            elif str('S') in str(faults_data[index_fault]['oriented']):\n                                if compass_bearing > 180.0:\n                                    ColLon = reversed(ColLon)\n                                    ColLat = reversed(ColLat)\n                            elif str('E') in str(faults_data[index_fault]['oriented']):\n                                if compass_bearing > 90.0 and compass_bearing < 270.0:\n                                    ColLon = reversed(ColLon)\n                                    ColLat = reversed(ColLat)\n                            elif str('W') in str(faults_data[index_fault]['oriented']):\n                                if compass_bearing < 90.0 or compass_bearing > 270.0:\n                                    ColLon = reversed(ColLon)\n                                    ColLat = reversed(ColLat)\n                            ColLon = list(ColLon)\n                            ColLat = list(ColLat)\n                            do_resample = True\n                            if do_resample == True:\n                                min_d = 5.0\n                                max_d = 15.0\n                                az_d = 15.0\n                                (resampled_ColLon, resampled_ColLat) = ([ColLon[0]], [ColLat[0]])\n                                for i_pt in range(len(ColLon) - 2):\n                                    add_point = False\n                                    i_pt += 1\n                                    dist_before = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt], ColLat[i_pt])\n                                    dist_after = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt + 1], ColLat[i_pt + 1])\n                                    az_before = calculate_initial_compass_bearing((resampled_ColLon[-1], resampled_ColLat[-1]), (ColLon[i_pt], ColLat[i_pt]))\n                                    az_after = calculate_initial_compass_bearing((ColLon[i_pt], ColLat[i_pt]), (ColLon[i_pt + 1], ColLat[i_pt + 1]))\n                                    if dist_before > min_d and (dist_after > max_d or abs(az_before - az_after) > az_d):\n                                        add_point = True\n                                        if i_pt == len(ColLon) - 2:\n                                            last_dist_after = distance(ColLon[i_pt], ColLat[i_pt], ColLon[-1], ColLat[-1])\n                                            if last_dist_after < min_d:\n                                                add_point = False\n                                    if add_point == True:\n                                        resampled_ColLon.append(ColLon[i_pt])\n                                        resampled_ColLat.append(ColLat[i_pt])\n                                resampled_ColLon.append(ColLon[-1])\n                                resampled_ColLat.append(ColLat[-1])\n                                (ColLon, ColLat) = (resampled_ColLon, resampled_ColLat)\n                                plot_stuf_detail = True\n                                if plot_stuf_detail == True:\n                                    min_dist_tmp = min_d\n                                    for i_pt in range(len(ColLon) - 2):\n                                        dist_tmp = distance(resampled_ColLon[i_pt + 1], resampled_ColLat[i_pt + 1], resampled_ColLon[i_pt], resampled_ColLat[i_pt])\n                                        if dist_tmp < min_dist_tmp:\n                                            min_dist_tmp = dist_tmp\n                                    if min_dist_tmp < min_d / 2.0:\n                                        print('min dist :', round(min_dist_tmp), 'id: ', faults_data[index_fault]['name'])\n                            str_geom += '\\t\\t\\t<kiteSurface>\\n'\n                            compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                            strike = compass_bearing\n                            mean_azimuth = (strike + 90.0) % 360\n                            i_pt = 0\n                            for (x, y) in zip(ColLon, ColLat):\n                                if [x, y] == [ColLon[0], ColLat[0]]:\n                                    compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[1], ColLon[1]))\n                                    strike = compass_bearing\n                                    azimuth = (strike + 90.0) % 360\n                                elif [x, y] == [ColLon[-1], ColLat[-1]]:\n                                    compass_bearing = calculate_initial_compass_bearing((ColLat[-2], ColLon[-2]), (ColLat[-1], ColLon[-1]))\n                                    strike = compass_bearing\n                                    azimuth = (strike + 90.0) % 360\n                                else:\n                                    compass_bearing = calculate_initial_compass_bearing((ColLat[i_pt - 1], ColLon[i_pt - 1]), (ColLat[i_pt + 1], ColLon[i_pt + 1]))\n                                    strike = compass_bearing\n                                    azimuth = (strike + 90.0) % 360\n                                azimuth = (mean_azimuth + azimuth) / 2.0 % 360\n                                str_geom += '\\t\\t\\t<profile>\\n'\n                                str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                (xt, yt) = point_at(x, y, azimuth, hdist_top)\n                                str_geom += '\\t\\t\\t\\t\\t\\t' + str(xt) + ' ' + str(yt) + ' ' + str(usd) + ' '\n                                (xb, yb) = point_at(x, y, azimuth, hdist_bottom)\n                                str_geom += str(xb) + ' ' + str(yb) + ' ' + str(lsd) + '\\n'\n                                str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t</profile>\\n'\n                                i_pt += 1\n                            str_geom += '\\t\\t\\t</kiteSurface>\\n'\n                        if type_of_fault == 'cf':\n                            str_geom += '\\t\\t\\t<kiteSurface>\\n'\n                            for depth_i in sorted(set(Depth)):\n                                str_geom += '\\t\\t\\t<profile>\\n'\n                                str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                for (x, y) in zip(ColLon, ColLat):\n                                    str_geom += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + ' ' + str(hdist_d) + '\\n'\n                                str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t<\\\\profile>\\n'\n                            str_geom += '\\t\\t\\t</kiteSurface>\\n'\n                    hypo_depth = (faults_data[index_fault]['upper_sismo_depth'] + faults_data[index_fault]['lower_sismo_depth']) / 2.0\n                    str_geom += '\\t\\t\\t<hypocenter depth=\"' + str(hypo_depth) + '\" lat=\"' + str(np.mean(faults_data[index_fault]['lat'])) + '\" lon=\"' + str(np.mean(faults_data[index_fault]['lon'])) + '\"/>\\n'\n                    rake = np.mean(scenario_mechanism)\n                    str_geom += '\\t\\t\\t<rake>' + str(rake) + '</rake>\\n'\n                    line += str_geom\n                    line += '\\t\\t\\t</multiPlanesRupture>\\n'\n        line += '\\t\\t</nonParametricSeismicSource>\\n'\n    return (line, Domain_in_the_model, ID_number)",
            "def write_non_parametric_one_fault(index_fault, fault_name, OQ_entry_faults, faults_names, faults_data, Model_name, Domain_in_the_model, ScL_oq, log_mdf_file, M_min, ID_number, explo_time):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Write a non parametric source with fault trace defined as set of kite fault surfaces\\n    for now the rupture occurs once of not. several occurences are not supported yet.\\n    For one fault only\\n    '\n    i_MFD = np.where(np.array(faults_names) == fault_name)[0][0]\n    MFD = OQ_entry_faults[i_MFD]\n    line = ''\n    if sum(MFD) != 0:\n        ID_number = ID_number + 1\n        Fault_Name = Model_name + '_' + str(fault_name)\n        if not faults_data[index_fault]['domain'] in str(Domain_in_the_model):\n            Domain_in_the_model.append(faults_data[index_fault]['domain'])\n        line = '\\t\\t<nonParametricSeismicSource id=\"' + str(ID_number) + '\" name=\"' + str(Fault_Name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n        str_geom = ''\n        bin_mag = np.linspace(M_min, M_min + 0.1 * len(MFD) + 0.1, num=2 + len(MFD))\n        for (mag, i_mag) in zip(bin_mag, range(len(bin_mag))):\n            if i_mag <= len(MFD) - 1:\n                l = MFD[i_mag]\n                if l != 0.0:\n                    t = explo_time\n                    p_occur_1 = np.float32((l * t) ** 1 * np.exp(-l * t) / np.math.factorial(1))\n                    xxx1 = Decimal('{:.8f}'.format(np.float32(p_occur_1)))\n                    p_not_occur = Decimal('1') - xxx1\n                    p_not_occur = '{:.8f}'.format(p_not_occur)\n                    line += '\\t\\t\\t<multiPlanesRupture probs_occur=\"' + str(p_not_occur) + ' ' + str(xxx1) + '\">\\n'\n                    line += '\\t\\t\\t<magnitude>' + str(mag) + '</magnitude>\\n'\n                    if str_geom == '':\n                        scenario_mechanism = []\n                        index_fault = faults_names.index(fault_name)\n                        ColLon = faults_data[index_fault]['lon']\n                        ColLat = faults_data[index_fault]['lat']\n                        Depth = faults_data[index_fault]['depth']\n                        scenario_mechanism.append(faults_data[index_fault]['rake'])\n                        if Depth and all((elem == 'sf' for elem in Depth)):\n                            type_of_fault = 'sf'\n                        else:\n                            type_of_fault = 'cf'\n                            Depth = [float(i) for i in Depth]\n                        if type_of_fault == 'sf':\n                            usd = faults_data[index_fault]['upper_sismo_depth']\n                            lsd = faults_data[index_fault]['lower_sismo_depth']\n                            dip_tan = math.tan(math.radians(faults_data[index_fault]['dip']))\n                            hdist_top = usd / dip_tan\n                            hdist_bottom = lsd / dip_tan\n                            compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                            if str('N') in str(faults_data[index_fault]['oriented']):\n                                if compass_bearing < 180.0:\n                                    ColLon = reversed(ColLon)\n                                    ColLat = reversed(ColLat)\n                            elif str('S') in str(faults_data[index_fault]['oriented']):\n                                if compass_bearing > 180.0:\n                                    ColLon = reversed(ColLon)\n                                    ColLat = reversed(ColLat)\n                            elif str('E') in str(faults_data[index_fault]['oriented']):\n                                if compass_bearing > 90.0 and compass_bearing < 270.0:\n                                    ColLon = reversed(ColLon)\n                                    ColLat = reversed(ColLat)\n                            elif str('W') in str(faults_data[index_fault]['oriented']):\n                                if compass_bearing < 90.0 or compass_bearing > 270.0:\n                                    ColLon = reversed(ColLon)\n                                    ColLat = reversed(ColLat)\n                            ColLon = list(ColLon)\n                            ColLat = list(ColLat)\n                            do_resample = True\n                            if do_resample == True:\n                                min_d = 5.0\n                                max_d = 15.0\n                                az_d = 15.0\n                                (resampled_ColLon, resampled_ColLat) = ([ColLon[0]], [ColLat[0]])\n                                for i_pt in range(len(ColLon) - 2):\n                                    add_point = False\n                                    i_pt += 1\n                                    dist_before = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt], ColLat[i_pt])\n                                    dist_after = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt + 1], ColLat[i_pt + 1])\n                                    az_before = calculate_initial_compass_bearing((resampled_ColLon[-1], resampled_ColLat[-1]), (ColLon[i_pt], ColLat[i_pt]))\n                                    az_after = calculate_initial_compass_bearing((ColLon[i_pt], ColLat[i_pt]), (ColLon[i_pt + 1], ColLat[i_pt + 1]))\n                                    if dist_before > min_d and (dist_after > max_d or abs(az_before - az_after) > az_d):\n                                        add_point = True\n                                        if i_pt == len(ColLon) - 2:\n                                            last_dist_after = distance(ColLon[i_pt], ColLat[i_pt], ColLon[-1], ColLat[-1])\n                                            if last_dist_after < min_d:\n                                                add_point = False\n                                    if add_point == True:\n                                        resampled_ColLon.append(ColLon[i_pt])\n                                        resampled_ColLat.append(ColLat[i_pt])\n                                resampled_ColLon.append(ColLon[-1])\n                                resampled_ColLat.append(ColLat[-1])\n                                (ColLon, ColLat) = (resampled_ColLon, resampled_ColLat)\n                                plot_stuf_detail = True\n                                if plot_stuf_detail == True:\n                                    min_dist_tmp = min_d\n                                    for i_pt in range(len(ColLon) - 2):\n                                        dist_tmp = distance(resampled_ColLon[i_pt + 1], resampled_ColLat[i_pt + 1], resampled_ColLon[i_pt], resampled_ColLat[i_pt])\n                                        if dist_tmp < min_dist_tmp:\n                                            min_dist_tmp = dist_tmp\n                                    if min_dist_tmp < min_d / 2.0:\n                                        print('min dist :', round(min_dist_tmp), 'id: ', faults_data[index_fault]['name'])\n                            str_geom += '\\t\\t\\t<kiteSurface>\\n'\n                            compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                            strike = compass_bearing\n                            mean_azimuth = (strike + 90.0) % 360\n                            i_pt = 0\n                            for (x, y) in zip(ColLon, ColLat):\n                                if [x, y] == [ColLon[0], ColLat[0]]:\n                                    compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[1], ColLon[1]))\n                                    strike = compass_bearing\n                                    azimuth = (strike + 90.0) % 360\n                                elif [x, y] == [ColLon[-1], ColLat[-1]]:\n                                    compass_bearing = calculate_initial_compass_bearing((ColLat[-2], ColLon[-2]), (ColLat[-1], ColLon[-1]))\n                                    strike = compass_bearing\n                                    azimuth = (strike + 90.0) % 360\n                                else:\n                                    compass_bearing = calculate_initial_compass_bearing((ColLat[i_pt - 1], ColLon[i_pt - 1]), (ColLat[i_pt + 1], ColLon[i_pt + 1]))\n                                    strike = compass_bearing\n                                    azimuth = (strike + 90.0) % 360\n                                azimuth = (mean_azimuth + azimuth) / 2.0 % 360\n                                str_geom += '\\t\\t\\t<profile>\\n'\n                                str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                (xt, yt) = point_at(x, y, azimuth, hdist_top)\n                                str_geom += '\\t\\t\\t\\t\\t\\t' + str(xt) + ' ' + str(yt) + ' ' + str(usd) + ' '\n                                (xb, yb) = point_at(x, y, azimuth, hdist_bottom)\n                                str_geom += str(xb) + ' ' + str(yb) + ' ' + str(lsd) + '\\n'\n                                str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t</profile>\\n'\n                                i_pt += 1\n                            str_geom += '\\t\\t\\t</kiteSurface>\\n'\n                        if type_of_fault == 'cf':\n                            str_geom += '\\t\\t\\t<kiteSurface>\\n'\n                            for depth_i in sorted(set(Depth)):\n                                str_geom += '\\t\\t\\t<profile>\\n'\n                                str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                for (x, y) in zip(ColLon, ColLat):\n                                    str_geom += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + ' ' + str(hdist_d) + '\\n'\n                                str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t<\\\\profile>\\n'\n                            str_geom += '\\t\\t\\t</kiteSurface>\\n'\n                    hypo_depth = (faults_data[index_fault]['upper_sismo_depth'] + faults_data[index_fault]['lower_sismo_depth']) / 2.0\n                    str_geom += '\\t\\t\\t<hypocenter depth=\"' + str(hypo_depth) + '\" lat=\"' + str(np.mean(faults_data[index_fault]['lat'])) + '\" lon=\"' + str(np.mean(faults_data[index_fault]['lon'])) + '\"/>\\n'\n                    rake = np.mean(scenario_mechanism)\n                    str_geom += '\\t\\t\\t<rake>' + str(rake) + '</rake>\\n'\n                    line += str_geom\n                    line += '\\t\\t\\t</multiPlanesRupture>\\n'\n        line += '\\t\\t</nonParametricSeismicSource>\\n'\n    return (line, Domain_in_the_model, ID_number)"
        ]
    },
    {
        "func_name": "write_non_parametric_source",
        "original": "def write_non_parametric_source(scenario, scenarios_names, OQ_entry_scenarios, index_faults_in_scenario, faults_names, faults_data, Model_name, Domain_in_the_model, ScL_oq, log_mdf_file, explo_time, M_min, ID_number):\n    \"\"\"\n    Write a non parametric source with fault trace defined as set of kite fault surfaces\n    for now the rupture occurs once of not. several occurences are not supported yet.\n    \"\"\"\n    index_scenario = np.where(np.array(scenarios_names) == scenario[1])[0][0]\n    MFD = OQ_entry_scenarios[index_scenario]\n    line = ''\n    if sum(MFD) != 0:\n        ID_number = ID_number + 1\n        index_fault = faults_names.index(scenario[1]['f_1'][0])\n        scenar_name = '_'.join(('{!s}={!r}'.format(key, val) for (key, val) in scenario[1].items()))\n        Fault_Name = Model_name + '_scenario_' + str(scenar_name)\n        line = '\\t\\t<nonParametricSeismicSource id=\"' + str(ID_number) + '\" name=\"' + str(Fault_Name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n        index_faults_in_scenario = index_faults_in_scenario[index_scenario][0]\n        faults_in_scenario = np.take(faults_names, index_faults_in_scenario)\n        str_geom = ''\n        bin_mag = np.linspace(M_min, M_min + 0.1 * len(MFD) + 0.1, num=2 + len(MFD))\n        for (mag, i_mag) in zip(bin_mag, range(len(bin_mag))):\n            if i_mag <= len(MFD) - 1:\n                l = MFD[i_mag]\n                if l != 0.0:\n                    t = explo_time\n                    p_occur_1 = np.float32((l * t) ** 1 * np.exp(-l * t) / np.math.factorial(1))\n                    xxx1 = Decimal('{:.8f}'.format(np.float32(p_occur_1)))\n                    p_not_occur = Decimal('1') - xxx1\n                    p_not_occur = '{:.8f}'.format(p_not_occur)\n                    line += '\\t\\t\\t<multiPlanesRupture probs_occur=\"' + str(p_not_occur) + ' ' + str(xxx1) + '\">\\n'\n                    line += '\\t\\t\\t<magnitude>' + str(mag) + '</magnitude>\\n'\n                    if str_geom == '':\n                        scenario_mechanism = []\n                        for Fault_name in faults_in_scenario:\n                            index_fault = faults_names.index(Fault_name)\n                            ColLon = faults_data[index_fault]['lon']\n                            ColLat = faults_data[index_fault]['lat']\n                            Depth = faults_data[index_fault]['depth']\n                            scenario_mechanism.append(faults_data[index_fault]['rake'])\n                            if Depth and all((elem == 'sf' for elem in Depth)):\n                                type_of_fault = 'sf'\n                            else:\n                                type_of_fault = 'cf'\n                                Depth = [float(i) for i in Depth]\n                            if type_of_fault == 'sf':\n                                usd = faults_data[index_fault]['upper_sismo_depth']\n                                lsd = faults_data[index_fault]['lower_sismo_depth']\n                                dip_tan = math.tan(math.radians(faults_data[index_fault]['dip']))\n                                hdist_top = usd / dip_tan\n                                hdist_bottom = lsd / dip_tan\n                                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                                if str('N') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing < 180.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('S') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing > 180.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('E') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing > 90.0 and compass_bearing < 270.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('W') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing < 90.0 or compass_bearing > 270.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                ColLon = list(ColLon)\n                                ColLat = list(ColLat)\n                                do_resample = True\n                                if do_resample == True:\n                                    min_d = 5.0\n                                    max_d = 15.0\n                                    az_d = 15.0\n                                    (resampled_ColLon, resampled_ColLat) = ([ColLon[0]], [ColLat[0]])\n                                    for i_pt in range(len(ColLon) - 2):\n                                        add_point = False\n                                        i_pt += 1\n                                        dist_before = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt], ColLat[i_pt])\n                                        dist_after = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt + 1], ColLat[i_pt + 1])\n                                        az_before = calculate_initial_compass_bearing((resampled_ColLon[-1], resampled_ColLat[-1]), (ColLon[i_pt], ColLat[i_pt]))\n                                        az_after = calculate_initial_compass_bearing((ColLon[i_pt], ColLat[i_pt]), (ColLon[i_pt + 1], ColLat[i_pt + 1]))\n                                        if dist_before > min_d and (dist_after > max_d or abs(az_before - az_after) > az_d):\n                                            add_point = True\n                                            if i_pt == len(ColLon) - 2:\n                                                last_dist_after = distance(ColLon[i_pt], ColLat[i_pt], ColLon[-1], ColLat[-1])\n                                                if last_dist_after < min_d:\n                                                    add_point = False\n                                        if add_point == True:\n                                            resampled_ColLon.append(ColLon[i_pt])\n                                            resampled_ColLat.append(ColLat[i_pt])\n                                    resampled_ColLon.append(ColLon[-1])\n                                    resampled_ColLat.append(ColLat[-1])\n                                    (ColLon, ColLat) = (resampled_ColLon, resampled_ColLat)\n                                    plot_stuf_detail = True\n                                    if plot_stuf_detail == True:\n                                        min_dist_tmp = min_d\n                                        for i_pt in range(len(ColLon) - 2):\n                                            dist_tmp = distance(resampled_ColLon[i_pt + 1], resampled_ColLat[i_pt + 1], resampled_ColLon[i_pt], resampled_ColLat[i_pt])\n                                            if dist_tmp < min_dist_tmp:\n                                                min_dist_tmp = dist_tmp\n                                        if min_dist_tmp < min_d / 2.0:\n                                            print('min dist :', round(min_dist_tmp), 'id: ', faults_data[index_fault]['name'])\n                                str_geom += '\\t\\t\\t<kiteSurface>\\n'\n                                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                                strike = compass_bearing\n                                mean_azimuth = (strike + 90.0) % 360\n                                i_pt = 0\n                                for (x, y) in zip(ColLon, ColLat):\n                                    if [x, y] == [ColLon[0], ColLat[0]]:\n                                        compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[1], ColLon[1]))\n                                        strike = compass_bearing\n                                        azimuth = (strike + 90.0) % 360\n                                    elif [x, y] == [ColLon[-1], ColLat[-1]]:\n                                        compass_bearing = calculate_initial_compass_bearing((ColLat[-2], ColLon[-2]), (ColLat[-1], ColLon[-1]))\n                                        strike = compass_bearing\n                                        azimuth = (strike + 90.0) % 360\n                                    else:\n                                        compass_bearing = calculate_initial_compass_bearing((ColLat[i_pt - 1], ColLon[i_pt - 1]), (ColLat[i_pt + 1], ColLon[i_pt + 1]))\n                                        strike = compass_bearing\n                                        azimuth = (strike + 90.0) % 360\n                                    azimuth = (mean_azimuth + azimuth) / 2.0 % 360\n                                    str_geom += '\\t\\t\\t<profile>\\n'\n                                    str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                    (xt, yt) = point_at(x, y, azimuth, hdist_top)\n                                    str_geom += '\\t\\t\\t\\t\\t\\t' + str(xt) + ' ' + str(yt) + ' ' + str(usd) + ' '\n                                    (xb, yb) = point_at(x, y, azimuth, hdist_bottom)\n                                    str_geom += str(xb) + ' ' + str(yb) + ' ' + str(lsd) + '\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                    str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t</profile>\\n'\n                                    i_pt += 1\n                                str_geom += '\\t\\t\\t</kiteSurface>\\n'\n                            if type_of_fault == 'cf':\n                                str_geom += '\\t\\t\\t<kiteSurface>\\n'\n                                for depth_i in sorted(set(Depth)):\n                                    str_geom += '\\t\\t\\t<profile>\\n'\n                                    str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                    for (x, y) in zip(ColLon, ColLat):\n                                        str_geom += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + ' ' + str(hdist_d) + '\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                    str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t<\\\\profile>\\n'\n                                str_geom += '\\t\\t\\t</kiteSurface>\\n'\n                        hypo_depth = (faults_data[index_fault]['upper_sismo_depth'] + faults_data[index_fault]['lower_sismo_depth']) / 2.0\n                        str_geom += '\\t\\t\\t<hypocenter depth=\"' + str(hypo_depth) + '\" lat=\"' + str(np.mean(faults_data[index_fault]['lat'])) + '\" lon=\"' + str(np.mean(faults_data[index_fault]['lon'])) + '\"/>\\n'\n                        rake = np.mean(scenario_mechanism)\n                        str_geom += '\\t\\t\\t<rake>' + str(rake) + '</rake>\\n'\n                    line += str_geom\n                    line += '\\t\\t\\t</multiPlanesRupture>\\n'\n        line += '\\t\\t</nonParametricSeismicSource>\\n'\n    return (line, ID_number)",
        "mutated": [
            "def write_non_parametric_source(scenario, scenarios_names, OQ_entry_scenarios, index_faults_in_scenario, faults_names, faults_data, Model_name, Domain_in_the_model, ScL_oq, log_mdf_file, explo_time, M_min, ID_number):\n    if False:\n        i = 10\n    '\\n    Write a non parametric source with fault trace defined as set of kite fault surfaces\\n    for now the rupture occurs once of not. several occurences are not supported yet.\\n    '\n    index_scenario = np.where(np.array(scenarios_names) == scenario[1])[0][0]\n    MFD = OQ_entry_scenarios[index_scenario]\n    line = ''\n    if sum(MFD) != 0:\n        ID_number = ID_number + 1\n        index_fault = faults_names.index(scenario[1]['f_1'][0])\n        scenar_name = '_'.join(('{!s}={!r}'.format(key, val) for (key, val) in scenario[1].items()))\n        Fault_Name = Model_name + '_scenario_' + str(scenar_name)\n        line = '\\t\\t<nonParametricSeismicSource id=\"' + str(ID_number) + '\" name=\"' + str(Fault_Name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n        index_faults_in_scenario = index_faults_in_scenario[index_scenario][0]\n        faults_in_scenario = np.take(faults_names, index_faults_in_scenario)\n        str_geom = ''\n        bin_mag = np.linspace(M_min, M_min + 0.1 * len(MFD) + 0.1, num=2 + len(MFD))\n        for (mag, i_mag) in zip(bin_mag, range(len(bin_mag))):\n            if i_mag <= len(MFD) - 1:\n                l = MFD[i_mag]\n                if l != 0.0:\n                    t = explo_time\n                    p_occur_1 = np.float32((l * t) ** 1 * np.exp(-l * t) / np.math.factorial(1))\n                    xxx1 = Decimal('{:.8f}'.format(np.float32(p_occur_1)))\n                    p_not_occur = Decimal('1') - xxx1\n                    p_not_occur = '{:.8f}'.format(p_not_occur)\n                    line += '\\t\\t\\t<multiPlanesRupture probs_occur=\"' + str(p_not_occur) + ' ' + str(xxx1) + '\">\\n'\n                    line += '\\t\\t\\t<magnitude>' + str(mag) + '</magnitude>\\n'\n                    if str_geom == '':\n                        scenario_mechanism = []\n                        for Fault_name in faults_in_scenario:\n                            index_fault = faults_names.index(Fault_name)\n                            ColLon = faults_data[index_fault]['lon']\n                            ColLat = faults_data[index_fault]['lat']\n                            Depth = faults_data[index_fault]['depth']\n                            scenario_mechanism.append(faults_data[index_fault]['rake'])\n                            if Depth and all((elem == 'sf' for elem in Depth)):\n                                type_of_fault = 'sf'\n                            else:\n                                type_of_fault = 'cf'\n                                Depth = [float(i) for i in Depth]\n                            if type_of_fault == 'sf':\n                                usd = faults_data[index_fault]['upper_sismo_depth']\n                                lsd = faults_data[index_fault]['lower_sismo_depth']\n                                dip_tan = math.tan(math.radians(faults_data[index_fault]['dip']))\n                                hdist_top = usd / dip_tan\n                                hdist_bottom = lsd / dip_tan\n                                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                                if str('N') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing < 180.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('S') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing > 180.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('E') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing > 90.0 and compass_bearing < 270.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('W') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing < 90.0 or compass_bearing > 270.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                ColLon = list(ColLon)\n                                ColLat = list(ColLat)\n                                do_resample = True\n                                if do_resample == True:\n                                    min_d = 5.0\n                                    max_d = 15.0\n                                    az_d = 15.0\n                                    (resampled_ColLon, resampled_ColLat) = ([ColLon[0]], [ColLat[0]])\n                                    for i_pt in range(len(ColLon) - 2):\n                                        add_point = False\n                                        i_pt += 1\n                                        dist_before = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt], ColLat[i_pt])\n                                        dist_after = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt + 1], ColLat[i_pt + 1])\n                                        az_before = calculate_initial_compass_bearing((resampled_ColLon[-1], resampled_ColLat[-1]), (ColLon[i_pt], ColLat[i_pt]))\n                                        az_after = calculate_initial_compass_bearing((ColLon[i_pt], ColLat[i_pt]), (ColLon[i_pt + 1], ColLat[i_pt + 1]))\n                                        if dist_before > min_d and (dist_after > max_d or abs(az_before - az_after) > az_d):\n                                            add_point = True\n                                            if i_pt == len(ColLon) - 2:\n                                                last_dist_after = distance(ColLon[i_pt], ColLat[i_pt], ColLon[-1], ColLat[-1])\n                                                if last_dist_after < min_d:\n                                                    add_point = False\n                                        if add_point == True:\n                                            resampled_ColLon.append(ColLon[i_pt])\n                                            resampled_ColLat.append(ColLat[i_pt])\n                                    resampled_ColLon.append(ColLon[-1])\n                                    resampled_ColLat.append(ColLat[-1])\n                                    (ColLon, ColLat) = (resampled_ColLon, resampled_ColLat)\n                                    plot_stuf_detail = True\n                                    if plot_stuf_detail == True:\n                                        min_dist_tmp = min_d\n                                        for i_pt in range(len(ColLon) - 2):\n                                            dist_tmp = distance(resampled_ColLon[i_pt + 1], resampled_ColLat[i_pt + 1], resampled_ColLon[i_pt], resampled_ColLat[i_pt])\n                                            if dist_tmp < min_dist_tmp:\n                                                min_dist_tmp = dist_tmp\n                                        if min_dist_tmp < min_d / 2.0:\n                                            print('min dist :', round(min_dist_tmp), 'id: ', faults_data[index_fault]['name'])\n                                str_geom += '\\t\\t\\t<kiteSurface>\\n'\n                                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                                strike = compass_bearing\n                                mean_azimuth = (strike + 90.0) % 360\n                                i_pt = 0\n                                for (x, y) in zip(ColLon, ColLat):\n                                    if [x, y] == [ColLon[0], ColLat[0]]:\n                                        compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[1], ColLon[1]))\n                                        strike = compass_bearing\n                                        azimuth = (strike + 90.0) % 360\n                                    elif [x, y] == [ColLon[-1], ColLat[-1]]:\n                                        compass_bearing = calculate_initial_compass_bearing((ColLat[-2], ColLon[-2]), (ColLat[-1], ColLon[-1]))\n                                        strike = compass_bearing\n                                        azimuth = (strike + 90.0) % 360\n                                    else:\n                                        compass_bearing = calculate_initial_compass_bearing((ColLat[i_pt - 1], ColLon[i_pt - 1]), (ColLat[i_pt + 1], ColLon[i_pt + 1]))\n                                        strike = compass_bearing\n                                        azimuth = (strike + 90.0) % 360\n                                    azimuth = (mean_azimuth + azimuth) / 2.0 % 360\n                                    str_geom += '\\t\\t\\t<profile>\\n'\n                                    str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                    (xt, yt) = point_at(x, y, azimuth, hdist_top)\n                                    str_geom += '\\t\\t\\t\\t\\t\\t' + str(xt) + ' ' + str(yt) + ' ' + str(usd) + ' '\n                                    (xb, yb) = point_at(x, y, azimuth, hdist_bottom)\n                                    str_geom += str(xb) + ' ' + str(yb) + ' ' + str(lsd) + '\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                    str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t</profile>\\n'\n                                    i_pt += 1\n                                str_geom += '\\t\\t\\t</kiteSurface>\\n'\n                            if type_of_fault == 'cf':\n                                str_geom += '\\t\\t\\t<kiteSurface>\\n'\n                                for depth_i in sorted(set(Depth)):\n                                    str_geom += '\\t\\t\\t<profile>\\n'\n                                    str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                    for (x, y) in zip(ColLon, ColLat):\n                                        str_geom += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + ' ' + str(hdist_d) + '\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                    str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t<\\\\profile>\\n'\n                                str_geom += '\\t\\t\\t</kiteSurface>\\n'\n                        hypo_depth = (faults_data[index_fault]['upper_sismo_depth'] + faults_data[index_fault]['lower_sismo_depth']) / 2.0\n                        str_geom += '\\t\\t\\t<hypocenter depth=\"' + str(hypo_depth) + '\" lat=\"' + str(np.mean(faults_data[index_fault]['lat'])) + '\" lon=\"' + str(np.mean(faults_data[index_fault]['lon'])) + '\"/>\\n'\n                        rake = np.mean(scenario_mechanism)\n                        str_geom += '\\t\\t\\t<rake>' + str(rake) + '</rake>\\n'\n                    line += str_geom\n                    line += '\\t\\t\\t</multiPlanesRupture>\\n'\n        line += '\\t\\t</nonParametricSeismicSource>\\n'\n    return (line, ID_number)",
            "def write_non_parametric_source(scenario, scenarios_names, OQ_entry_scenarios, index_faults_in_scenario, faults_names, faults_data, Model_name, Domain_in_the_model, ScL_oq, log_mdf_file, explo_time, M_min, ID_number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Write a non parametric source with fault trace defined as set of kite fault surfaces\\n    for now the rupture occurs once of not. several occurences are not supported yet.\\n    '\n    index_scenario = np.where(np.array(scenarios_names) == scenario[1])[0][0]\n    MFD = OQ_entry_scenarios[index_scenario]\n    line = ''\n    if sum(MFD) != 0:\n        ID_number = ID_number + 1\n        index_fault = faults_names.index(scenario[1]['f_1'][0])\n        scenar_name = '_'.join(('{!s}={!r}'.format(key, val) for (key, val) in scenario[1].items()))\n        Fault_Name = Model_name + '_scenario_' + str(scenar_name)\n        line = '\\t\\t<nonParametricSeismicSource id=\"' + str(ID_number) + '\" name=\"' + str(Fault_Name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n        index_faults_in_scenario = index_faults_in_scenario[index_scenario][0]\n        faults_in_scenario = np.take(faults_names, index_faults_in_scenario)\n        str_geom = ''\n        bin_mag = np.linspace(M_min, M_min + 0.1 * len(MFD) + 0.1, num=2 + len(MFD))\n        for (mag, i_mag) in zip(bin_mag, range(len(bin_mag))):\n            if i_mag <= len(MFD) - 1:\n                l = MFD[i_mag]\n                if l != 0.0:\n                    t = explo_time\n                    p_occur_1 = np.float32((l * t) ** 1 * np.exp(-l * t) / np.math.factorial(1))\n                    xxx1 = Decimal('{:.8f}'.format(np.float32(p_occur_1)))\n                    p_not_occur = Decimal('1') - xxx1\n                    p_not_occur = '{:.8f}'.format(p_not_occur)\n                    line += '\\t\\t\\t<multiPlanesRupture probs_occur=\"' + str(p_not_occur) + ' ' + str(xxx1) + '\">\\n'\n                    line += '\\t\\t\\t<magnitude>' + str(mag) + '</magnitude>\\n'\n                    if str_geom == '':\n                        scenario_mechanism = []\n                        for Fault_name in faults_in_scenario:\n                            index_fault = faults_names.index(Fault_name)\n                            ColLon = faults_data[index_fault]['lon']\n                            ColLat = faults_data[index_fault]['lat']\n                            Depth = faults_data[index_fault]['depth']\n                            scenario_mechanism.append(faults_data[index_fault]['rake'])\n                            if Depth and all((elem == 'sf' for elem in Depth)):\n                                type_of_fault = 'sf'\n                            else:\n                                type_of_fault = 'cf'\n                                Depth = [float(i) for i in Depth]\n                            if type_of_fault == 'sf':\n                                usd = faults_data[index_fault]['upper_sismo_depth']\n                                lsd = faults_data[index_fault]['lower_sismo_depth']\n                                dip_tan = math.tan(math.radians(faults_data[index_fault]['dip']))\n                                hdist_top = usd / dip_tan\n                                hdist_bottom = lsd / dip_tan\n                                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                                if str('N') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing < 180.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('S') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing > 180.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('E') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing > 90.0 and compass_bearing < 270.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('W') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing < 90.0 or compass_bearing > 270.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                ColLon = list(ColLon)\n                                ColLat = list(ColLat)\n                                do_resample = True\n                                if do_resample == True:\n                                    min_d = 5.0\n                                    max_d = 15.0\n                                    az_d = 15.0\n                                    (resampled_ColLon, resampled_ColLat) = ([ColLon[0]], [ColLat[0]])\n                                    for i_pt in range(len(ColLon) - 2):\n                                        add_point = False\n                                        i_pt += 1\n                                        dist_before = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt], ColLat[i_pt])\n                                        dist_after = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt + 1], ColLat[i_pt + 1])\n                                        az_before = calculate_initial_compass_bearing((resampled_ColLon[-1], resampled_ColLat[-1]), (ColLon[i_pt], ColLat[i_pt]))\n                                        az_after = calculate_initial_compass_bearing((ColLon[i_pt], ColLat[i_pt]), (ColLon[i_pt + 1], ColLat[i_pt + 1]))\n                                        if dist_before > min_d and (dist_after > max_d or abs(az_before - az_after) > az_d):\n                                            add_point = True\n                                            if i_pt == len(ColLon) - 2:\n                                                last_dist_after = distance(ColLon[i_pt], ColLat[i_pt], ColLon[-1], ColLat[-1])\n                                                if last_dist_after < min_d:\n                                                    add_point = False\n                                        if add_point == True:\n                                            resampled_ColLon.append(ColLon[i_pt])\n                                            resampled_ColLat.append(ColLat[i_pt])\n                                    resampled_ColLon.append(ColLon[-1])\n                                    resampled_ColLat.append(ColLat[-1])\n                                    (ColLon, ColLat) = (resampled_ColLon, resampled_ColLat)\n                                    plot_stuf_detail = True\n                                    if plot_stuf_detail == True:\n                                        min_dist_tmp = min_d\n                                        for i_pt in range(len(ColLon) - 2):\n                                            dist_tmp = distance(resampled_ColLon[i_pt + 1], resampled_ColLat[i_pt + 1], resampled_ColLon[i_pt], resampled_ColLat[i_pt])\n                                            if dist_tmp < min_dist_tmp:\n                                                min_dist_tmp = dist_tmp\n                                        if min_dist_tmp < min_d / 2.0:\n                                            print('min dist :', round(min_dist_tmp), 'id: ', faults_data[index_fault]['name'])\n                                str_geom += '\\t\\t\\t<kiteSurface>\\n'\n                                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                                strike = compass_bearing\n                                mean_azimuth = (strike + 90.0) % 360\n                                i_pt = 0\n                                for (x, y) in zip(ColLon, ColLat):\n                                    if [x, y] == [ColLon[0], ColLat[0]]:\n                                        compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[1], ColLon[1]))\n                                        strike = compass_bearing\n                                        azimuth = (strike + 90.0) % 360\n                                    elif [x, y] == [ColLon[-1], ColLat[-1]]:\n                                        compass_bearing = calculate_initial_compass_bearing((ColLat[-2], ColLon[-2]), (ColLat[-1], ColLon[-1]))\n                                        strike = compass_bearing\n                                        azimuth = (strike + 90.0) % 360\n                                    else:\n                                        compass_bearing = calculate_initial_compass_bearing((ColLat[i_pt - 1], ColLon[i_pt - 1]), (ColLat[i_pt + 1], ColLon[i_pt + 1]))\n                                        strike = compass_bearing\n                                        azimuth = (strike + 90.0) % 360\n                                    azimuth = (mean_azimuth + azimuth) / 2.0 % 360\n                                    str_geom += '\\t\\t\\t<profile>\\n'\n                                    str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                    (xt, yt) = point_at(x, y, azimuth, hdist_top)\n                                    str_geom += '\\t\\t\\t\\t\\t\\t' + str(xt) + ' ' + str(yt) + ' ' + str(usd) + ' '\n                                    (xb, yb) = point_at(x, y, azimuth, hdist_bottom)\n                                    str_geom += str(xb) + ' ' + str(yb) + ' ' + str(lsd) + '\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                    str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t</profile>\\n'\n                                    i_pt += 1\n                                str_geom += '\\t\\t\\t</kiteSurface>\\n'\n                            if type_of_fault == 'cf':\n                                str_geom += '\\t\\t\\t<kiteSurface>\\n'\n                                for depth_i in sorted(set(Depth)):\n                                    str_geom += '\\t\\t\\t<profile>\\n'\n                                    str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                    for (x, y) in zip(ColLon, ColLat):\n                                        str_geom += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + ' ' + str(hdist_d) + '\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                    str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t<\\\\profile>\\n'\n                                str_geom += '\\t\\t\\t</kiteSurface>\\n'\n                        hypo_depth = (faults_data[index_fault]['upper_sismo_depth'] + faults_data[index_fault]['lower_sismo_depth']) / 2.0\n                        str_geom += '\\t\\t\\t<hypocenter depth=\"' + str(hypo_depth) + '\" lat=\"' + str(np.mean(faults_data[index_fault]['lat'])) + '\" lon=\"' + str(np.mean(faults_data[index_fault]['lon'])) + '\"/>\\n'\n                        rake = np.mean(scenario_mechanism)\n                        str_geom += '\\t\\t\\t<rake>' + str(rake) + '</rake>\\n'\n                    line += str_geom\n                    line += '\\t\\t\\t</multiPlanesRupture>\\n'\n        line += '\\t\\t</nonParametricSeismicSource>\\n'\n    return (line, ID_number)",
            "def write_non_parametric_source(scenario, scenarios_names, OQ_entry_scenarios, index_faults_in_scenario, faults_names, faults_data, Model_name, Domain_in_the_model, ScL_oq, log_mdf_file, explo_time, M_min, ID_number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Write a non parametric source with fault trace defined as set of kite fault surfaces\\n    for now the rupture occurs once of not. several occurences are not supported yet.\\n    '\n    index_scenario = np.where(np.array(scenarios_names) == scenario[1])[0][0]\n    MFD = OQ_entry_scenarios[index_scenario]\n    line = ''\n    if sum(MFD) != 0:\n        ID_number = ID_number + 1\n        index_fault = faults_names.index(scenario[1]['f_1'][0])\n        scenar_name = '_'.join(('{!s}={!r}'.format(key, val) for (key, val) in scenario[1].items()))\n        Fault_Name = Model_name + '_scenario_' + str(scenar_name)\n        line = '\\t\\t<nonParametricSeismicSource id=\"' + str(ID_number) + '\" name=\"' + str(Fault_Name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n        index_faults_in_scenario = index_faults_in_scenario[index_scenario][0]\n        faults_in_scenario = np.take(faults_names, index_faults_in_scenario)\n        str_geom = ''\n        bin_mag = np.linspace(M_min, M_min + 0.1 * len(MFD) + 0.1, num=2 + len(MFD))\n        for (mag, i_mag) in zip(bin_mag, range(len(bin_mag))):\n            if i_mag <= len(MFD) - 1:\n                l = MFD[i_mag]\n                if l != 0.0:\n                    t = explo_time\n                    p_occur_1 = np.float32((l * t) ** 1 * np.exp(-l * t) / np.math.factorial(1))\n                    xxx1 = Decimal('{:.8f}'.format(np.float32(p_occur_1)))\n                    p_not_occur = Decimal('1') - xxx1\n                    p_not_occur = '{:.8f}'.format(p_not_occur)\n                    line += '\\t\\t\\t<multiPlanesRupture probs_occur=\"' + str(p_not_occur) + ' ' + str(xxx1) + '\">\\n'\n                    line += '\\t\\t\\t<magnitude>' + str(mag) + '</magnitude>\\n'\n                    if str_geom == '':\n                        scenario_mechanism = []\n                        for Fault_name in faults_in_scenario:\n                            index_fault = faults_names.index(Fault_name)\n                            ColLon = faults_data[index_fault]['lon']\n                            ColLat = faults_data[index_fault]['lat']\n                            Depth = faults_data[index_fault]['depth']\n                            scenario_mechanism.append(faults_data[index_fault]['rake'])\n                            if Depth and all((elem == 'sf' for elem in Depth)):\n                                type_of_fault = 'sf'\n                            else:\n                                type_of_fault = 'cf'\n                                Depth = [float(i) for i in Depth]\n                            if type_of_fault == 'sf':\n                                usd = faults_data[index_fault]['upper_sismo_depth']\n                                lsd = faults_data[index_fault]['lower_sismo_depth']\n                                dip_tan = math.tan(math.radians(faults_data[index_fault]['dip']))\n                                hdist_top = usd / dip_tan\n                                hdist_bottom = lsd / dip_tan\n                                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                                if str('N') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing < 180.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('S') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing > 180.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('E') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing > 90.0 and compass_bearing < 270.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('W') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing < 90.0 or compass_bearing > 270.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                ColLon = list(ColLon)\n                                ColLat = list(ColLat)\n                                do_resample = True\n                                if do_resample == True:\n                                    min_d = 5.0\n                                    max_d = 15.0\n                                    az_d = 15.0\n                                    (resampled_ColLon, resampled_ColLat) = ([ColLon[0]], [ColLat[0]])\n                                    for i_pt in range(len(ColLon) - 2):\n                                        add_point = False\n                                        i_pt += 1\n                                        dist_before = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt], ColLat[i_pt])\n                                        dist_after = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt + 1], ColLat[i_pt + 1])\n                                        az_before = calculate_initial_compass_bearing((resampled_ColLon[-1], resampled_ColLat[-1]), (ColLon[i_pt], ColLat[i_pt]))\n                                        az_after = calculate_initial_compass_bearing((ColLon[i_pt], ColLat[i_pt]), (ColLon[i_pt + 1], ColLat[i_pt + 1]))\n                                        if dist_before > min_d and (dist_after > max_d or abs(az_before - az_after) > az_d):\n                                            add_point = True\n                                            if i_pt == len(ColLon) - 2:\n                                                last_dist_after = distance(ColLon[i_pt], ColLat[i_pt], ColLon[-1], ColLat[-1])\n                                                if last_dist_after < min_d:\n                                                    add_point = False\n                                        if add_point == True:\n                                            resampled_ColLon.append(ColLon[i_pt])\n                                            resampled_ColLat.append(ColLat[i_pt])\n                                    resampled_ColLon.append(ColLon[-1])\n                                    resampled_ColLat.append(ColLat[-1])\n                                    (ColLon, ColLat) = (resampled_ColLon, resampled_ColLat)\n                                    plot_stuf_detail = True\n                                    if plot_stuf_detail == True:\n                                        min_dist_tmp = min_d\n                                        for i_pt in range(len(ColLon) - 2):\n                                            dist_tmp = distance(resampled_ColLon[i_pt + 1], resampled_ColLat[i_pt + 1], resampled_ColLon[i_pt], resampled_ColLat[i_pt])\n                                            if dist_tmp < min_dist_tmp:\n                                                min_dist_tmp = dist_tmp\n                                        if min_dist_tmp < min_d / 2.0:\n                                            print('min dist :', round(min_dist_tmp), 'id: ', faults_data[index_fault]['name'])\n                                str_geom += '\\t\\t\\t<kiteSurface>\\n'\n                                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                                strike = compass_bearing\n                                mean_azimuth = (strike + 90.0) % 360\n                                i_pt = 0\n                                for (x, y) in zip(ColLon, ColLat):\n                                    if [x, y] == [ColLon[0], ColLat[0]]:\n                                        compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[1], ColLon[1]))\n                                        strike = compass_bearing\n                                        azimuth = (strike + 90.0) % 360\n                                    elif [x, y] == [ColLon[-1], ColLat[-1]]:\n                                        compass_bearing = calculate_initial_compass_bearing((ColLat[-2], ColLon[-2]), (ColLat[-1], ColLon[-1]))\n                                        strike = compass_bearing\n                                        azimuth = (strike + 90.0) % 360\n                                    else:\n                                        compass_bearing = calculate_initial_compass_bearing((ColLat[i_pt - 1], ColLon[i_pt - 1]), (ColLat[i_pt + 1], ColLon[i_pt + 1]))\n                                        strike = compass_bearing\n                                        azimuth = (strike + 90.0) % 360\n                                    azimuth = (mean_azimuth + azimuth) / 2.0 % 360\n                                    str_geom += '\\t\\t\\t<profile>\\n'\n                                    str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                    (xt, yt) = point_at(x, y, azimuth, hdist_top)\n                                    str_geom += '\\t\\t\\t\\t\\t\\t' + str(xt) + ' ' + str(yt) + ' ' + str(usd) + ' '\n                                    (xb, yb) = point_at(x, y, azimuth, hdist_bottom)\n                                    str_geom += str(xb) + ' ' + str(yb) + ' ' + str(lsd) + '\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                    str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t</profile>\\n'\n                                    i_pt += 1\n                                str_geom += '\\t\\t\\t</kiteSurface>\\n'\n                            if type_of_fault == 'cf':\n                                str_geom += '\\t\\t\\t<kiteSurface>\\n'\n                                for depth_i in sorted(set(Depth)):\n                                    str_geom += '\\t\\t\\t<profile>\\n'\n                                    str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                    for (x, y) in zip(ColLon, ColLat):\n                                        str_geom += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + ' ' + str(hdist_d) + '\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                    str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t<\\\\profile>\\n'\n                                str_geom += '\\t\\t\\t</kiteSurface>\\n'\n                        hypo_depth = (faults_data[index_fault]['upper_sismo_depth'] + faults_data[index_fault]['lower_sismo_depth']) / 2.0\n                        str_geom += '\\t\\t\\t<hypocenter depth=\"' + str(hypo_depth) + '\" lat=\"' + str(np.mean(faults_data[index_fault]['lat'])) + '\" lon=\"' + str(np.mean(faults_data[index_fault]['lon'])) + '\"/>\\n'\n                        rake = np.mean(scenario_mechanism)\n                        str_geom += '\\t\\t\\t<rake>' + str(rake) + '</rake>\\n'\n                    line += str_geom\n                    line += '\\t\\t\\t</multiPlanesRupture>\\n'\n        line += '\\t\\t</nonParametricSeismicSource>\\n'\n    return (line, ID_number)",
            "def write_non_parametric_source(scenario, scenarios_names, OQ_entry_scenarios, index_faults_in_scenario, faults_names, faults_data, Model_name, Domain_in_the_model, ScL_oq, log_mdf_file, explo_time, M_min, ID_number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Write a non parametric source with fault trace defined as set of kite fault surfaces\\n    for now the rupture occurs once of not. several occurences are not supported yet.\\n    '\n    index_scenario = np.where(np.array(scenarios_names) == scenario[1])[0][0]\n    MFD = OQ_entry_scenarios[index_scenario]\n    line = ''\n    if sum(MFD) != 0:\n        ID_number = ID_number + 1\n        index_fault = faults_names.index(scenario[1]['f_1'][0])\n        scenar_name = '_'.join(('{!s}={!r}'.format(key, val) for (key, val) in scenario[1].items()))\n        Fault_Name = Model_name + '_scenario_' + str(scenar_name)\n        line = '\\t\\t<nonParametricSeismicSource id=\"' + str(ID_number) + '\" name=\"' + str(Fault_Name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n        index_faults_in_scenario = index_faults_in_scenario[index_scenario][0]\n        faults_in_scenario = np.take(faults_names, index_faults_in_scenario)\n        str_geom = ''\n        bin_mag = np.linspace(M_min, M_min + 0.1 * len(MFD) + 0.1, num=2 + len(MFD))\n        for (mag, i_mag) in zip(bin_mag, range(len(bin_mag))):\n            if i_mag <= len(MFD) - 1:\n                l = MFD[i_mag]\n                if l != 0.0:\n                    t = explo_time\n                    p_occur_1 = np.float32((l * t) ** 1 * np.exp(-l * t) / np.math.factorial(1))\n                    xxx1 = Decimal('{:.8f}'.format(np.float32(p_occur_1)))\n                    p_not_occur = Decimal('1') - xxx1\n                    p_not_occur = '{:.8f}'.format(p_not_occur)\n                    line += '\\t\\t\\t<multiPlanesRupture probs_occur=\"' + str(p_not_occur) + ' ' + str(xxx1) + '\">\\n'\n                    line += '\\t\\t\\t<magnitude>' + str(mag) + '</magnitude>\\n'\n                    if str_geom == '':\n                        scenario_mechanism = []\n                        for Fault_name in faults_in_scenario:\n                            index_fault = faults_names.index(Fault_name)\n                            ColLon = faults_data[index_fault]['lon']\n                            ColLat = faults_data[index_fault]['lat']\n                            Depth = faults_data[index_fault]['depth']\n                            scenario_mechanism.append(faults_data[index_fault]['rake'])\n                            if Depth and all((elem == 'sf' for elem in Depth)):\n                                type_of_fault = 'sf'\n                            else:\n                                type_of_fault = 'cf'\n                                Depth = [float(i) for i in Depth]\n                            if type_of_fault == 'sf':\n                                usd = faults_data[index_fault]['upper_sismo_depth']\n                                lsd = faults_data[index_fault]['lower_sismo_depth']\n                                dip_tan = math.tan(math.radians(faults_data[index_fault]['dip']))\n                                hdist_top = usd / dip_tan\n                                hdist_bottom = lsd / dip_tan\n                                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                                if str('N') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing < 180.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('S') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing > 180.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('E') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing > 90.0 and compass_bearing < 270.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('W') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing < 90.0 or compass_bearing > 270.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                ColLon = list(ColLon)\n                                ColLat = list(ColLat)\n                                do_resample = True\n                                if do_resample == True:\n                                    min_d = 5.0\n                                    max_d = 15.0\n                                    az_d = 15.0\n                                    (resampled_ColLon, resampled_ColLat) = ([ColLon[0]], [ColLat[0]])\n                                    for i_pt in range(len(ColLon) - 2):\n                                        add_point = False\n                                        i_pt += 1\n                                        dist_before = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt], ColLat[i_pt])\n                                        dist_after = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt + 1], ColLat[i_pt + 1])\n                                        az_before = calculate_initial_compass_bearing((resampled_ColLon[-1], resampled_ColLat[-1]), (ColLon[i_pt], ColLat[i_pt]))\n                                        az_after = calculate_initial_compass_bearing((ColLon[i_pt], ColLat[i_pt]), (ColLon[i_pt + 1], ColLat[i_pt + 1]))\n                                        if dist_before > min_d and (dist_after > max_d or abs(az_before - az_after) > az_d):\n                                            add_point = True\n                                            if i_pt == len(ColLon) - 2:\n                                                last_dist_after = distance(ColLon[i_pt], ColLat[i_pt], ColLon[-1], ColLat[-1])\n                                                if last_dist_after < min_d:\n                                                    add_point = False\n                                        if add_point == True:\n                                            resampled_ColLon.append(ColLon[i_pt])\n                                            resampled_ColLat.append(ColLat[i_pt])\n                                    resampled_ColLon.append(ColLon[-1])\n                                    resampled_ColLat.append(ColLat[-1])\n                                    (ColLon, ColLat) = (resampled_ColLon, resampled_ColLat)\n                                    plot_stuf_detail = True\n                                    if plot_stuf_detail == True:\n                                        min_dist_tmp = min_d\n                                        for i_pt in range(len(ColLon) - 2):\n                                            dist_tmp = distance(resampled_ColLon[i_pt + 1], resampled_ColLat[i_pt + 1], resampled_ColLon[i_pt], resampled_ColLat[i_pt])\n                                            if dist_tmp < min_dist_tmp:\n                                                min_dist_tmp = dist_tmp\n                                        if min_dist_tmp < min_d / 2.0:\n                                            print('min dist :', round(min_dist_tmp), 'id: ', faults_data[index_fault]['name'])\n                                str_geom += '\\t\\t\\t<kiteSurface>\\n'\n                                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                                strike = compass_bearing\n                                mean_azimuth = (strike + 90.0) % 360\n                                i_pt = 0\n                                for (x, y) in zip(ColLon, ColLat):\n                                    if [x, y] == [ColLon[0], ColLat[0]]:\n                                        compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[1], ColLon[1]))\n                                        strike = compass_bearing\n                                        azimuth = (strike + 90.0) % 360\n                                    elif [x, y] == [ColLon[-1], ColLat[-1]]:\n                                        compass_bearing = calculate_initial_compass_bearing((ColLat[-2], ColLon[-2]), (ColLat[-1], ColLon[-1]))\n                                        strike = compass_bearing\n                                        azimuth = (strike + 90.0) % 360\n                                    else:\n                                        compass_bearing = calculate_initial_compass_bearing((ColLat[i_pt - 1], ColLon[i_pt - 1]), (ColLat[i_pt + 1], ColLon[i_pt + 1]))\n                                        strike = compass_bearing\n                                        azimuth = (strike + 90.0) % 360\n                                    azimuth = (mean_azimuth + azimuth) / 2.0 % 360\n                                    str_geom += '\\t\\t\\t<profile>\\n'\n                                    str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                    (xt, yt) = point_at(x, y, azimuth, hdist_top)\n                                    str_geom += '\\t\\t\\t\\t\\t\\t' + str(xt) + ' ' + str(yt) + ' ' + str(usd) + ' '\n                                    (xb, yb) = point_at(x, y, azimuth, hdist_bottom)\n                                    str_geom += str(xb) + ' ' + str(yb) + ' ' + str(lsd) + '\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                    str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t</profile>\\n'\n                                    i_pt += 1\n                                str_geom += '\\t\\t\\t</kiteSurface>\\n'\n                            if type_of_fault == 'cf':\n                                str_geom += '\\t\\t\\t<kiteSurface>\\n'\n                                for depth_i in sorted(set(Depth)):\n                                    str_geom += '\\t\\t\\t<profile>\\n'\n                                    str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                    for (x, y) in zip(ColLon, ColLat):\n                                        str_geom += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + ' ' + str(hdist_d) + '\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                    str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t<\\\\profile>\\n'\n                                str_geom += '\\t\\t\\t</kiteSurface>\\n'\n                        hypo_depth = (faults_data[index_fault]['upper_sismo_depth'] + faults_data[index_fault]['lower_sismo_depth']) / 2.0\n                        str_geom += '\\t\\t\\t<hypocenter depth=\"' + str(hypo_depth) + '\" lat=\"' + str(np.mean(faults_data[index_fault]['lat'])) + '\" lon=\"' + str(np.mean(faults_data[index_fault]['lon'])) + '\"/>\\n'\n                        rake = np.mean(scenario_mechanism)\n                        str_geom += '\\t\\t\\t<rake>' + str(rake) + '</rake>\\n'\n                    line += str_geom\n                    line += '\\t\\t\\t</multiPlanesRupture>\\n'\n        line += '\\t\\t</nonParametricSeismicSource>\\n'\n    return (line, ID_number)",
            "def write_non_parametric_source(scenario, scenarios_names, OQ_entry_scenarios, index_faults_in_scenario, faults_names, faults_data, Model_name, Domain_in_the_model, ScL_oq, log_mdf_file, explo_time, M_min, ID_number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Write a non parametric source with fault trace defined as set of kite fault surfaces\\n    for now the rupture occurs once of not. several occurences are not supported yet.\\n    '\n    index_scenario = np.where(np.array(scenarios_names) == scenario[1])[0][0]\n    MFD = OQ_entry_scenarios[index_scenario]\n    line = ''\n    if sum(MFD) != 0:\n        ID_number = ID_number + 1\n        index_fault = faults_names.index(scenario[1]['f_1'][0])\n        scenar_name = '_'.join(('{!s}={!r}'.format(key, val) for (key, val) in scenario[1].items()))\n        Fault_Name = Model_name + '_scenario_' + str(scenar_name)\n        line = '\\t\\t<nonParametricSeismicSource id=\"' + str(ID_number) + '\" name=\"' + str(Fault_Name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n        index_faults_in_scenario = index_faults_in_scenario[index_scenario][0]\n        faults_in_scenario = np.take(faults_names, index_faults_in_scenario)\n        str_geom = ''\n        bin_mag = np.linspace(M_min, M_min + 0.1 * len(MFD) + 0.1, num=2 + len(MFD))\n        for (mag, i_mag) in zip(bin_mag, range(len(bin_mag))):\n            if i_mag <= len(MFD) - 1:\n                l = MFD[i_mag]\n                if l != 0.0:\n                    t = explo_time\n                    p_occur_1 = np.float32((l * t) ** 1 * np.exp(-l * t) / np.math.factorial(1))\n                    xxx1 = Decimal('{:.8f}'.format(np.float32(p_occur_1)))\n                    p_not_occur = Decimal('1') - xxx1\n                    p_not_occur = '{:.8f}'.format(p_not_occur)\n                    line += '\\t\\t\\t<multiPlanesRupture probs_occur=\"' + str(p_not_occur) + ' ' + str(xxx1) + '\">\\n'\n                    line += '\\t\\t\\t<magnitude>' + str(mag) + '</magnitude>\\n'\n                    if str_geom == '':\n                        scenario_mechanism = []\n                        for Fault_name in faults_in_scenario:\n                            index_fault = faults_names.index(Fault_name)\n                            ColLon = faults_data[index_fault]['lon']\n                            ColLat = faults_data[index_fault]['lat']\n                            Depth = faults_data[index_fault]['depth']\n                            scenario_mechanism.append(faults_data[index_fault]['rake'])\n                            if Depth and all((elem == 'sf' for elem in Depth)):\n                                type_of_fault = 'sf'\n                            else:\n                                type_of_fault = 'cf'\n                                Depth = [float(i) for i in Depth]\n                            if type_of_fault == 'sf':\n                                usd = faults_data[index_fault]['upper_sismo_depth']\n                                lsd = faults_data[index_fault]['lower_sismo_depth']\n                                dip_tan = math.tan(math.radians(faults_data[index_fault]['dip']))\n                                hdist_top = usd / dip_tan\n                                hdist_bottom = lsd / dip_tan\n                                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                                if str('N') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing < 180.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('S') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing > 180.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('E') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing > 90.0 and compass_bearing < 270.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('W') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing < 90.0 or compass_bearing > 270.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                ColLon = list(ColLon)\n                                ColLat = list(ColLat)\n                                do_resample = True\n                                if do_resample == True:\n                                    min_d = 5.0\n                                    max_d = 15.0\n                                    az_d = 15.0\n                                    (resampled_ColLon, resampled_ColLat) = ([ColLon[0]], [ColLat[0]])\n                                    for i_pt in range(len(ColLon) - 2):\n                                        add_point = False\n                                        i_pt += 1\n                                        dist_before = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt], ColLat[i_pt])\n                                        dist_after = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt + 1], ColLat[i_pt + 1])\n                                        az_before = calculate_initial_compass_bearing((resampled_ColLon[-1], resampled_ColLat[-1]), (ColLon[i_pt], ColLat[i_pt]))\n                                        az_after = calculate_initial_compass_bearing((ColLon[i_pt], ColLat[i_pt]), (ColLon[i_pt + 1], ColLat[i_pt + 1]))\n                                        if dist_before > min_d and (dist_after > max_d or abs(az_before - az_after) > az_d):\n                                            add_point = True\n                                            if i_pt == len(ColLon) - 2:\n                                                last_dist_after = distance(ColLon[i_pt], ColLat[i_pt], ColLon[-1], ColLat[-1])\n                                                if last_dist_after < min_d:\n                                                    add_point = False\n                                        if add_point == True:\n                                            resampled_ColLon.append(ColLon[i_pt])\n                                            resampled_ColLat.append(ColLat[i_pt])\n                                    resampled_ColLon.append(ColLon[-1])\n                                    resampled_ColLat.append(ColLat[-1])\n                                    (ColLon, ColLat) = (resampled_ColLon, resampled_ColLat)\n                                    plot_stuf_detail = True\n                                    if plot_stuf_detail == True:\n                                        min_dist_tmp = min_d\n                                        for i_pt in range(len(ColLon) - 2):\n                                            dist_tmp = distance(resampled_ColLon[i_pt + 1], resampled_ColLat[i_pt + 1], resampled_ColLon[i_pt], resampled_ColLat[i_pt])\n                                            if dist_tmp < min_dist_tmp:\n                                                min_dist_tmp = dist_tmp\n                                        if min_dist_tmp < min_d / 2.0:\n                                            print('min dist :', round(min_dist_tmp), 'id: ', faults_data[index_fault]['name'])\n                                str_geom += '\\t\\t\\t<kiteSurface>\\n'\n                                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                                strike = compass_bearing\n                                mean_azimuth = (strike + 90.0) % 360\n                                i_pt = 0\n                                for (x, y) in zip(ColLon, ColLat):\n                                    if [x, y] == [ColLon[0], ColLat[0]]:\n                                        compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[1], ColLon[1]))\n                                        strike = compass_bearing\n                                        azimuth = (strike + 90.0) % 360\n                                    elif [x, y] == [ColLon[-1], ColLat[-1]]:\n                                        compass_bearing = calculate_initial_compass_bearing((ColLat[-2], ColLon[-2]), (ColLat[-1], ColLon[-1]))\n                                        strike = compass_bearing\n                                        azimuth = (strike + 90.0) % 360\n                                    else:\n                                        compass_bearing = calculate_initial_compass_bearing((ColLat[i_pt - 1], ColLon[i_pt - 1]), (ColLat[i_pt + 1], ColLon[i_pt + 1]))\n                                        strike = compass_bearing\n                                        azimuth = (strike + 90.0) % 360\n                                    azimuth = (mean_azimuth + azimuth) / 2.0 % 360\n                                    str_geom += '\\t\\t\\t<profile>\\n'\n                                    str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                    (xt, yt) = point_at(x, y, azimuth, hdist_top)\n                                    str_geom += '\\t\\t\\t\\t\\t\\t' + str(xt) + ' ' + str(yt) + ' ' + str(usd) + ' '\n                                    (xb, yb) = point_at(x, y, azimuth, hdist_bottom)\n                                    str_geom += str(xb) + ' ' + str(yb) + ' ' + str(lsd) + '\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                    str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t</profile>\\n'\n                                    i_pt += 1\n                                str_geom += '\\t\\t\\t</kiteSurface>\\n'\n                            if type_of_fault == 'cf':\n                                str_geom += '\\t\\t\\t<kiteSurface>\\n'\n                                for depth_i in sorted(set(Depth)):\n                                    str_geom += '\\t\\t\\t<profile>\\n'\n                                    str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                    for (x, y) in zip(ColLon, ColLat):\n                                        str_geom += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + ' ' + str(hdist_d) + '\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                    str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t<\\\\profile>\\n'\n                                str_geom += '\\t\\t\\t</kiteSurface>\\n'\n                        hypo_depth = (faults_data[index_fault]['upper_sismo_depth'] + faults_data[index_fault]['lower_sismo_depth']) / 2.0\n                        str_geom += '\\t\\t\\t<hypocenter depth=\"' + str(hypo_depth) + '\" lat=\"' + str(np.mean(faults_data[index_fault]['lat'])) + '\" lon=\"' + str(np.mean(faults_data[index_fault]['lon'])) + '\"/>\\n'\n                        rake = np.mean(scenario_mechanism)\n                        str_geom += '\\t\\t\\t<rake>' + str(rake) + '</rake>\\n'\n                    line += str_geom\n                    line += '\\t\\t\\t</multiPlanesRupture>\\n'\n        line += '\\t\\t</nonParametricSeismicSource>\\n'\n    return (line, ID_number)"
        ]
    },
    {
        "func_name": "write_non_parametric_source_multi_types",
        "original": "def write_non_parametric_source_multi_types(scenario, scenarios_names, OQ_entry_scenarios, index_faults_in_scenario, faults_names, faults_data, Model_name, Domain_in_the_model, ScL_oq, log_mdf_file, explo_time, M_min, ID_number):\n    index_scenario = np.where(np.array(scenarios_names) == scenario[1])[0][0]\n    MFD = OQ_entry_scenarios[index_scenario]\n    line = ''\n    if sum(MFD) != 0:\n        ID_number = ID_number + 1\n        index_fault = faults_names.index(scenario[1]['f_1'][0])\n        scenar_name = '_'.join(('{!s}={!r}'.format(key, val) for (key, val) in scenario[1].items()))\n        Fault_Name = Model_name + '_scenario_' + str(scenar_name)\n        line = '\\t\\t<nonParametricSeismicSource id=\"' + str(ID_number) + '\" name=\"' + str(Fault_Name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n        index_faults_in_scenario = index_faults_in_scenario[index_scenario][0]\n        faults_in_scenario = np.take(faults_names, index_faults_in_scenario)\n        str_geom = ''\n        bin_mag = np.linspace(M_min, M_min + 0.1 * len(MFD) + 0.1, num=2 + len(MFD))\n        for (mag, i_mag) in zip(bin_mag, range(len(bin_mag))):\n            if i_mag <= len(MFD) - 1:\n                l = MFD[i_mag]\n                if l != 0.0:\n                    t = explo_time\n                    p_occur_1 = np.float32((l * t) ** 1 * np.exp(-l * t) / np.math.factorial(1))\n                    xxx1 = Decimal('{:.8f}'.format(np.float32(p_occur_1)))\n                    p_not_occur = Decimal('1') - xxx1\n                    p_not_occur = '{:.8f}'.format(p_not_occur)\n                    line += '\\t\\t\\t<multiPlanesRupture probs_occur=\"' + str(p_not_occur) + ' ' + str(xxx1) + '\">\\n'\n                    line += '\\t\\t\\t<magnitude>' + str(mag) + '</magnitude>\\n'\n                    if str_geom == '':\n                        scenario_mechanism = []\n                        for Fault_name in faults_in_scenario:\n                            index_fault = faults_names.index(Fault_name)\n                            ColLon = faults_data[index_fault]['lon']\n                            ColLat = faults_data[index_fault]['lat']\n                            Depth = faults_data[index_fault]['depth']\n                            scenario_mechanism.append(faults_data[index_fault]['rake'])\n                            if Depth and all((elem == 'sf' for elem in Depth)):\n                                type_of_fault = 'sf'\n                            else:\n                                type_of_fault = 'cf'\n                                Depth = [float(i) for i in Depth]\n                            if type_of_fault == 'sf':\n                                str_geom += '\\t\\t\\t<simpleFaultGeometry>\\n'\n                                str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                                if str('N') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing < 180.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('S') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing > 180.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('E') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing > 90.0 and compass_bearing < 270.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('W') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing < 90.0 or compass_bearing > 270.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                for (x, y) in zip(ColLon, ColLat):\n                                    str_geom += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + '\\n'\n                                str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t\\t<dip>' + str(faults_data[index_fault]['dip']) + '</dip>\\n'\n                                str_geom += '\\t\\t\\t\\t<upperSeismoDepth>' + str(faults_data[index_fault]['upper_sismo_depth']) + '</upperSeismoDepth>\\n'\n                                str_geom += '\\t\\t\\t\\t<lowerSeismoDepth>' + str(faults_data[index_fault]['lower_sismo_depth']) + '</lowerSeismoDepth>\\n'\n                                str_geom += '\\t\\t\\t</simpleFaultGeometry>\\n'\n                            if type_of_fault == 'cf':\n                                str_geom += '\\t\\t\\t<complexFaultGeometry>\\n'\n                                index_edge = 0\n                                for depth_i in sorted(set(Depth)):\n                                    indexes_for_edge_i = np.where(np.array(Depth) == depth_i)[0]\n                                    if index_edge == 0:\n                                        str_geom += '\\t\\t\\t\\t<faultTopEdge>\\n'\n                                    elif index_edge == len(set(Depth)) - 1:\n                                        str_geom += '\\t\\t\\t\\t<faultBottomEdge>\\n'\n                                    else:\n                                        str_geom += '\\t\\t\\t\\t<intermediateEdge>\\n'\n                                    str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                    for index in indexes_for_edge_i:\n                                        str_geom += '\\t\\t\\t\\t\\t\\t' + str(ColLon[index]) + ' ' + str(ColLat[index]) + ' ' + str(Depth[index]) + '\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                    str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                    if index_edge == 0:\n                                        str_geom += '\\t\\t\\t\\t</faultTopEdge>\\n'\n                                    elif index_edge == len(set(Depth)) - 1:\n                                        str_geom += '\\t\\t\\t\\t</faultBottomEdge>\\n'\n                                    else:\n                                        str_geom += '\\t\\t\\t\\t</intermediateEdge>\\n'\n                                    index_edge += 1\n                                str_geom += '\\t\\t\\t</complexFaultGeometry>\\n'\n                        hypo_depth = (faults_data[index_fault]['upper_sismo_depth'] + faults_data[index_fault]['lower_sismo_depth']) / 2.0\n                        str_geom += '\\t\\t\\t<hypocenter depth=\"' + str(hypo_depth) + '\" lat=\"' + str(np.mean(faults_data[index_fault]['lat'])) + '\" lon=\"' + str(np.mean(faults_data[index_fault]['lon'])) + '\"/>\\n'\n                        str_geom += '\\t\\t\\t<magScaleRel>' + ScL_oq + '</magScaleRel>\\n'\n                        str_geom += '\\t\\t\\t<ruptAspectRatio>1.0</ruptAspectRatio>\\n'\n                        rake = np.mean(scenario_mechanism)\n                        str_geom += '\\t\\t\\t<rake>' + str(rake) + '</rake>\\n'\n                    line += str_geom\n                    line += '\\t\\t\\t</multiPlanesRupture>\\n'\n        line += '\\t\\t</nonParametricSeismicSource>\\n'\n    return (line, ID_number)",
        "mutated": [
            "def write_non_parametric_source_multi_types(scenario, scenarios_names, OQ_entry_scenarios, index_faults_in_scenario, faults_names, faults_data, Model_name, Domain_in_the_model, ScL_oq, log_mdf_file, explo_time, M_min, ID_number):\n    if False:\n        i = 10\n    index_scenario = np.where(np.array(scenarios_names) == scenario[1])[0][0]\n    MFD = OQ_entry_scenarios[index_scenario]\n    line = ''\n    if sum(MFD) != 0:\n        ID_number = ID_number + 1\n        index_fault = faults_names.index(scenario[1]['f_1'][0])\n        scenar_name = '_'.join(('{!s}={!r}'.format(key, val) for (key, val) in scenario[1].items()))\n        Fault_Name = Model_name + '_scenario_' + str(scenar_name)\n        line = '\\t\\t<nonParametricSeismicSource id=\"' + str(ID_number) + '\" name=\"' + str(Fault_Name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n        index_faults_in_scenario = index_faults_in_scenario[index_scenario][0]\n        faults_in_scenario = np.take(faults_names, index_faults_in_scenario)\n        str_geom = ''\n        bin_mag = np.linspace(M_min, M_min + 0.1 * len(MFD) + 0.1, num=2 + len(MFD))\n        for (mag, i_mag) in zip(bin_mag, range(len(bin_mag))):\n            if i_mag <= len(MFD) - 1:\n                l = MFD[i_mag]\n                if l != 0.0:\n                    t = explo_time\n                    p_occur_1 = np.float32((l * t) ** 1 * np.exp(-l * t) / np.math.factorial(1))\n                    xxx1 = Decimal('{:.8f}'.format(np.float32(p_occur_1)))\n                    p_not_occur = Decimal('1') - xxx1\n                    p_not_occur = '{:.8f}'.format(p_not_occur)\n                    line += '\\t\\t\\t<multiPlanesRupture probs_occur=\"' + str(p_not_occur) + ' ' + str(xxx1) + '\">\\n'\n                    line += '\\t\\t\\t<magnitude>' + str(mag) + '</magnitude>\\n'\n                    if str_geom == '':\n                        scenario_mechanism = []\n                        for Fault_name in faults_in_scenario:\n                            index_fault = faults_names.index(Fault_name)\n                            ColLon = faults_data[index_fault]['lon']\n                            ColLat = faults_data[index_fault]['lat']\n                            Depth = faults_data[index_fault]['depth']\n                            scenario_mechanism.append(faults_data[index_fault]['rake'])\n                            if Depth and all((elem == 'sf' for elem in Depth)):\n                                type_of_fault = 'sf'\n                            else:\n                                type_of_fault = 'cf'\n                                Depth = [float(i) for i in Depth]\n                            if type_of_fault == 'sf':\n                                str_geom += '\\t\\t\\t<simpleFaultGeometry>\\n'\n                                str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                                if str('N') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing < 180.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('S') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing > 180.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('E') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing > 90.0 and compass_bearing < 270.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('W') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing < 90.0 or compass_bearing > 270.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                for (x, y) in zip(ColLon, ColLat):\n                                    str_geom += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + '\\n'\n                                str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t\\t<dip>' + str(faults_data[index_fault]['dip']) + '</dip>\\n'\n                                str_geom += '\\t\\t\\t\\t<upperSeismoDepth>' + str(faults_data[index_fault]['upper_sismo_depth']) + '</upperSeismoDepth>\\n'\n                                str_geom += '\\t\\t\\t\\t<lowerSeismoDepth>' + str(faults_data[index_fault]['lower_sismo_depth']) + '</lowerSeismoDepth>\\n'\n                                str_geom += '\\t\\t\\t</simpleFaultGeometry>\\n'\n                            if type_of_fault == 'cf':\n                                str_geom += '\\t\\t\\t<complexFaultGeometry>\\n'\n                                index_edge = 0\n                                for depth_i in sorted(set(Depth)):\n                                    indexes_for_edge_i = np.where(np.array(Depth) == depth_i)[0]\n                                    if index_edge == 0:\n                                        str_geom += '\\t\\t\\t\\t<faultTopEdge>\\n'\n                                    elif index_edge == len(set(Depth)) - 1:\n                                        str_geom += '\\t\\t\\t\\t<faultBottomEdge>\\n'\n                                    else:\n                                        str_geom += '\\t\\t\\t\\t<intermediateEdge>\\n'\n                                    str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                    for index in indexes_for_edge_i:\n                                        str_geom += '\\t\\t\\t\\t\\t\\t' + str(ColLon[index]) + ' ' + str(ColLat[index]) + ' ' + str(Depth[index]) + '\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                    str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                    if index_edge == 0:\n                                        str_geom += '\\t\\t\\t\\t</faultTopEdge>\\n'\n                                    elif index_edge == len(set(Depth)) - 1:\n                                        str_geom += '\\t\\t\\t\\t</faultBottomEdge>\\n'\n                                    else:\n                                        str_geom += '\\t\\t\\t\\t</intermediateEdge>\\n'\n                                    index_edge += 1\n                                str_geom += '\\t\\t\\t</complexFaultGeometry>\\n'\n                        hypo_depth = (faults_data[index_fault]['upper_sismo_depth'] + faults_data[index_fault]['lower_sismo_depth']) / 2.0\n                        str_geom += '\\t\\t\\t<hypocenter depth=\"' + str(hypo_depth) + '\" lat=\"' + str(np.mean(faults_data[index_fault]['lat'])) + '\" lon=\"' + str(np.mean(faults_data[index_fault]['lon'])) + '\"/>\\n'\n                        str_geom += '\\t\\t\\t<magScaleRel>' + ScL_oq + '</magScaleRel>\\n'\n                        str_geom += '\\t\\t\\t<ruptAspectRatio>1.0</ruptAspectRatio>\\n'\n                        rake = np.mean(scenario_mechanism)\n                        str_geom += '\\t\\t\\t<rake>' + str(rake) + '</rake>\\n'\n                    line += str_geom\n                    line += '\\t\\t\\t</multiPlanesRupture>\\n'\n        line += '\\t\\t</nonParametricSeismicSource>\\n'\n    return (line, ID_number)",
            "def write_non_parametric_source_multi_types(scenario, scenarios_names, OQ_entry_scenarios, index_faults_in_scenario, faults_names, faults_data, Model_name, Domain_in_the_model, ScL_oq, log_mdf_file, explo_time, M_min, ID_number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    index_scenario = np.where(np.array(scenarios_names) == scenario[1])[0][0]\n    MFD = OQ_entry_scenarios[index_scenario]\n    line = ''\n    if sum(MFD) != 0:\n        ID_number = ID_number + 1\n        index_fault = faults_names.index(scenario[1]['f_1'][0])\n        scenar_name = '_'.join(('{!s}={!r}'.format(key, val) for (key, val) in scenario[1].items()))\n        Fault_Name = Model_name + '_scenario_' + str(scenar_name)\n        line = '\\t\\t<nonParametricSeismicSource id=\"' + str(ID_number) + '\" name=\"' + str(Fault_Name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n        index_faults_in_scenario = index_faults_in_scenario[index_scenario][0]\n        faults_in_scenario = np.take(faults_names, index_faults_in_scenario)\n        str_geom = ''\n        bin_mag = np.linspace(M_min, M_min + 0.1 * len(MFD) + 0.1, num=2 + len(MFD))\n        for (mag, i_mag) in zip(bin_mag, range(len(bin_mag))):\n            if i_mag <= len(MFD) - 1:\n                l = MFD[i_mag]\n                if l != 0.0:\n                    t = explo_time\n                    p_occur_1 = np.float32((l * t) ** 1 * np.exp(-l * t) / np.math.factorial(1))\n                    xxx1 = Decimal('{:.8f}'.format(np.float32(p_occur_1)))\n                    p_not_occur = Decimal('1') - xxx1\n                    p_not_occur = '{:.8f}'.format(p_not_occur)\n                    line += '\\t\\t\\t<multiPlanesRupture probs_occur=\"' + str(p_not_occur) + ' ' + str(xxx1) + '\">\\n'\n                    line += '\\t\\t\\t<magnitude>' + str(mag) + '</magnitude>\\n'\n                    if str_geom == '':\n                        scenario_mechanism = []\n                        for Fault_name in faults_in_scenario:\n                            index_fault = faults_names.index(Fault_name)\n                            ColLon = faults_data[index_fault]['lon']\n                            ColLat = faults_data[index_fault]['lat']\n                            Depth = faults_data[index_fault]['depth']\n                            scenario_mechanism.append(faults_data[index_fault]['rake'])\n                            if Depth and all((elem == 'sf' for elem in Depth)):\n                                type_of_fault = 'sf'\n                            else:\n                                type_of_fault = 'cf'\n                                Depth = [float(i) for i in Depth]\n                            if type_of_fault == 'sf':\n                                str_geom += '\\t\\t\\t<simpleFaultGeometry>\\n'\n                                str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                                if str('N') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing < 180.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('S') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing > 180.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('E') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing > 90.0 and compass_bearing < 270.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('W') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing < 90.0 or compass_bearing > 270.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                for (x, y) in zip(ColLon, ColLat):\n                                    str_geom += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + '\\n'\n                                str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t\\t<dip>' + str(faults_data[index_fault]['dip']) + '</dip>\\n'\n                                str_geom += '\\t\\t\\t\\t<upperSeismoDepth>' + str(faults_data[index_fault]['upper_sismo_depth']) + '</upperSeismoDepth>\\n'\n                                str_geom += '\\t\\t\\t\\t<lowerSeismoDepth>' + str(faults_data[index_fault]['lower_sismo_depth']) + '</lowerSeismoDepth>\\n'\n                                str_geom += '\\t\\t\\t</simpleFaultGeometry>\\n'\n                            if type_of_fault == 'cf':\n                                str_geom += '\\t\\t\\t<complexFaultGeometry>\\n'\n                                index_edge = 0\n                                for depth_i in sorted(set(Depth)):\n                                    indexes_for_edge_i = np.where(np.array(Depth) == depth_i)[0]\n                                    if index_edge == 0:\n                                        str_geom += '\\t\\t\\t\\t<faultTopEdge>\\n'\n                                    elif index_edge == len(set(Depth)) - 1:\n                                        str_geom += '\\t\\t\\t\\t<faultBottomEdge>\\n'\n                                    else:\n                                        str_geom += '\\t\\t\\t\\t<intermediateEdge>\\n'\n                                    str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                    for index in indexes_for_edge_i:\n                                        str_geom += '\\t\\t\\t\\t\\t\\t' + str(ColLon[index]) + ' ' + str(ColLat[index]) + ' ' + str(Depth[index]) + '\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                    str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                    if index_edge == 0:\n                                        str_geom += '\\t\\t\\t\\t</faultTopEdge>\\n'\n                                    elif index_edge == len(set(Depth)) - 1:\n                                        str_geom += '\\t\\t\\t\\t</faultBottomEdge>\\n'\n                                    else:\n                                        str_geom += '\\t\\t\\t\\t</intermediateEdge>\\n'\n                                    index_edge += 1\n                                str_geom += '\\t\\t\\t</complexFaultGeometry>\\n'\n                        hypo_depth = (faults_data[index_fault]['upper_sismo_depth'] + faults_data[index_fault]['lower_sismo_depth']) / 2.0\n                        str_geom += '\\t\\t\\t<hypocenter depth=\"' + str(hypo_depth) + '\" lat=\"' + str(np.mean(faults_data[index_fault]['lat'])) + '\" lon=\"' + str(np.mean(faults_data[index_fault]['lon'])) + '\"/>\\n'\n                        str_geom += '\\t\\t\\t<magScaleRel>' + ScL_oq + '</magScaleRel>\\n'\n                        str_geom += '\\t\\t\\t<ruptAspectRatio>1.0</ruptAspectRatio>\\n'\n                        rake = np.mean(scenario_mechanism)\n                        str_geom += '\\t\\t\\t<rake>' + str(rake) + '</rake>\\n'\n                    line += str_geom\n                    line += '\\t\\t\\t</multiPlanesRupture>\\n'\n        line += '\\t\\t</nonParametricSeismicSource>\\n'\n    return (line, ID_number)",
            "def write_non_parametric_source_multi_types(scenario, scenarios_names, OQ_entry_scenarios, index_faults_in_scenario, faults_names, faults_data, Model_name, Domain_in_the_model, ScL_oq, log_mdf_file, explo_time, M_min, ID_number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    index_scenario = np.where(np.array(scenarios_names) == scenario[1])[0][0]\n    MFD = OQ_entry_scenarios[index_scenario]\n    line = ''\n    if sum(MFD) != 0:\n        ID_number = ID_number + 1\n        index_fault = faults_names.index(scenario[1]['f_1'][0])\n        scenar_name = '_'.join(('{!s}={!r}'.format(key, val) for (key, val) in scenario[1].items()))\n        Fault_Name = Model_name + '_scenario_' + str(scenar_name)\n        line = '\\t\\t<nonParametricSeismicSource id=\"' + str(ID_number) + '\" name=\"' + str(Fault_Name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n        index_faults_in_scenario = index_faults_in_scenario[index_scenario][0]\n        faults_in_scenario = np.take(faults_names, index_faults_in_scenario)\n        str_geom = ''\n        bin_mag = np.linspace(M_min, M_min + 0.1 * len(MFD) + 0.1, num=2 + len(MFD))\n        for (mag, i_mag) in zip(bin_mag, range(len(bin_mag))):\n            if i_mag <= len(MFD) - 1:\n                l = MFD[i_mag]\n                if l != 0.0:\n                    t = explo_time\n                    p_occur_1 = np.float32((l * t) ** 1 * np.exp(-l * t) / np.math.factorial(1))\n                    xxx1 = Decimal('{:.8f}'.format(np.float32(p_occur_1)))\n                    p_not_occur = Decimal('1') - xxx1\n                    p_not_occur = '{:.8f}'.format(p_not_occur)\n                    line += '\\t\\t\\t<multiPlanesRupture probs_occur=\"' + str(p_not_occur) + ' ' + str(xxx1) + '\">\\n'\n                    line += '\\t\\t\\t<magnitude>' + str(mag) + '</magnitude>\\n'\n                    if str_geom == '':\n                        scenario_mechanism = []\n                        for Fault_name in faults_in_scenario:\n                            index_fault = faults_names.index(Fault_name)\n                            ColLon = faults_data[index_fault]['lon']\n                            ColLat = faults_data[index_fault]['lat']\n                            Depth = faults_data[index_fault]['depth']\n                            scenario_mechanism.append(faults_data[index_fault]['rake'])\n                            if Depth and all((elem == 'sf' for elem in Depth)):\n                                type_of_fault = 'sf'\n                            else:\n                                type_of_fault = 'cf'\n                                Depth = [float(i) for i in Depth]\n                            if type_of_fault == 'sf':\n                                str_geom += '\\t\\t\\t<simpleFaultGeometry>\\n'\n                                str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                                if str('N') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing < 180.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('S') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing > 180.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('E') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing > 90.0 and compass_bearing < 270.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('W') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing < 90.0 or compass_bearing > 270.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                for (x, y) in zip(ColLon, ColLat):\n                                    str_geom += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + '\\n'\n                                str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t\\t<dip>' + str(faults_data[index_fault]['dip']) + '</dip>\\n'\n                                str_geom += '\\t\\t\\t\\t<upperSeismoDepth>' + str(faults_data[index_fault]['upper_sismo_depth']) + '</upperSeismoDepth>\\n'\n                                str_geom += '\\t\\t\\t\\t<lowerSeismoDepth>' + str(faults_data[index_fault]['lower_sismo_depth']) + '</lowerSeismoDepth>\\n'\n                                str_geom += '\\t\\t\\t</simpleFaultGeometry>\\n'\n                            if type_of_fault == 'cf':\n                                str_geom += '\\t\\t\\t<complexFaultGeometry>\\n'\n                                index_edge = 0\n                                for depth_i in sorted(set(Depth)):\n                                    indexes_for_edge_i = np.where(np.array(Depth) == depth_i)[0]\n                                    if index_edge == 0:\n                                        str_geom += '\\t\\t\\t\\t<faultTopEdge>\\n'\n                                    elif index_edge == len(set(Depth)) - 1:\n                                        str_geom += '\\t\\t\\t\\t<faultBottomEdge>\\n'\n                                    else:\n                                        str_geom += '\\t\\t\\t\\t<intermediateEdge>\\n'\n                                    str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                    for index in indexes_for_edge_i:\n                                        str_geom += '\\t\\t\\t\\t\\t\\t' + str(ColLon[index]) + ' ' + str(ColLat[index]) + ' ' + str(Depth[index]) + '\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                    str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                    if index_edge == 0:\n                                        str_geom += '\\t\\t\\t\\t</faultTopEdge>\\n'\n                                    elif index_edge == len(set(Depth)) - 1:\n                                        str_geom += '\\t\\t\\t\\t</faultBottomEdge>\\n'\n                                    else:\n                                        str_geom += '\\t\\t\\t\\t</intermediateEdge>\\n'\n                                    index_edge += 1\n                                str_geom += '\\t\\t\\t</complexFaultGeometry>\\n'\n                        hypo_depth = (faults_data[index_fault]['upper_sismo_depth'] + faults_data[index_fault]['lower_sismo_depth']) / 2.0\n                        str_geom += '\\t\\t\\t<hypocenter depth=\"' + str(hypo_depth) + '\" lat=\"' + str(np.mean(faults_data[index_fault]['lat'])) + '\" lon=\"' + str(np.mean(faults_data[index_fault]['lon'])) + '\"/>\\n'\n                        str_geom += '\\t\\t\\t<magScaleRel>' + ScL_oq + '</magScaleRel>\\n'\n                        str_geom += '\\t\\t\\t<ruptAspectRatio>1.0</ruptAspectRatio>\\n'\n                        rake = np.mean(scenario_mechanism)\n                        str_geom += '\\t\\t\\t<rake>' + str(rake) + '</rake>\\n'\n                    line += str_geom\n                    line += '\\t\\t\\t</multiPlanesRupture>\\n'\n        line += '\\t\\t</nonParametricSeismicSource>\\n'\n    return (line, ID_number)",
            "def write_non_parametric_source_multi_types(scenario, scenarios_names, OQ_entry_scenarios, index_faults_in_scenario, faults_names, faults_data, Model_name, Domain_in_the_model, ScL_oq, log_mdf_file, explo_time, M_min, ID_number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    index_scenario = np.where(np.array(scenarios_names) == scenario[1])[0][0]\n    MFD = OQ_entry_scenarios[index_scenario]\n    line = ''\n    if sum(MFD) != 0:\n        ID_number = ID_number + 1\n        index_fault = faults_names.index(scenario[1]['f_1'][0])\n        scenar_name = '_'.join(('{!s}={!r}'.format(key, val) for (key, val) in scenario[1].items()))\n        Fault_Name = Model_name + '_scenario_' + str(scenar_name)\n        line = '\\t\\t<nonParametricSeismicSource id=\"' + str(ID_number) + '\" name=\"' + str(Fault_Name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n        index_faults_in_scenario = index_faults_in_scenario[index_scenario][0]\n        faults_in_scenario = np.take(faults_names, index_faults_in_scenario)\n        str_geom = ''\n        bin_mag = np.linspace(M_min, M_min + 0.1 * len(MFD) + 0.1, num=2 + len(MFD))\n        for (mag, i_mag) in zip(bin_mag, range(len(bin_mag))):\n            if i_mag <= len(MFD) - 1:\n                l = MFD[i_mag]\n                if l != 0.0:\n                    t = explo_time\n                    p_occur_1 = np.float32((l * t) ** 1 * np.exp(-l * t) / np.math.factorial(1))\n                    xxx1 = Decimal('{:.8f}'.format(np.float32(p_occur_1)))\n                    p_not_occur = Decimal('1') - xxx1\n                    p_not_occur = '{:.8f}'.format(p_not_occur)\n                    line += '\\t\\t\\t<multiPlanesRupture probs_occur=\"' + str(p_not_occur) + ' ' + str(xxx1) + '\">\\n'\n                    line += '\\t\\t\\t<magnitude>' + str(mag) + '</magnitude>\\n'\n                    if str_geom == '':\n                        scenario_mechanism = []\n                        for Fault_name in faults_in_scenario:\n                            index_fault = faults_names.index(Fault_name)\n                            ColLon = faults_data[index_fault]['lon']\n                            ColLat = faults_data[index_fault]['lat']\n                            Depth = faults_data[index_fault]['depth']\n                            scenario_mechanism.append(faults_data[index_fault]['rake'])\n                            if Depth and all((elem == 'sf' for elem in Depth)):\n                                type_of_fault = 'sf'\n                            else:\n                                type_of_fault = 'cf'\n                                Depth = [float(i) for i in Depth]\n                            if type_of_fault == 'sf':\n                                str_geom += '\\t\\t\\t<simpleFaultGeometry>\\n'\n                                str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                                if str('N') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing < 180.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('S') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing > 180.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('E') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing > 90.0 and compass_bearing < 270.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('W') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing < 90.0 or compass_bearing > 270.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                for (x, y) in zip(ColLon, ColLat):\n                                    str_geom += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + '\\n'\n                                str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t\\t<dip>' + str(faults_data[index_fault]['dip']) + '</dip>\\n'\n                                str_geom += '\\t\\t\\t\\t<upperSeismoDepth>' + str(faults_data[index_fault]['upper_sismo_depth']) + '</upperSeismoDepth>\\n'\n                                str_geom += '\\t\\t\\t\\t<lowerSeismoDepth>' + str(faults_data[index_fault]['lower_sismo_depth']) + '</lowerSeismoDepth>\\n'\n                                str_geom += '\\t\\t\\t</simpleFaultGeometry>\\n'\n                            if type_of_fault == 'cf':\n                                str_geom += '\\t\\t\\t<complexFaultGeometry>\\n'\n                                index_edge = 0\n                                for depth_i in sorted(set(Depth)):\n                                    indexes_for_edge_i = np.where(np.array(Depth) == depth_i)[0]\n                                    if index_edge == 0:\n                                        str_geom += '\\t\\t\\t\\t<faultTopEdge>\\n'\n                                    elif index_edge == len(set(Depth)) - 1:\n                                        str_geom += '\\t\\t\\t\\t<faultBottomEdge>\\n'\n                                    else:\n                                        str_geom += '\\t\\t\\t\\t<intermediateEdge>\\n'\n                                    str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                    for index in indexes_for_edge_i:\n                                        str_geom += '\\t\\t\\t\\t\\t\\t' + str(ColLon[index]) + ' ' + str(ColLat[index]) + ' ' + str(Depth[index]) + '\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                    str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                    if index_edge == 0:\n                                        str_geom += '\\t\\t\\t\\t</faultTopEdge>\\n'\n                                    elif index_edge == len(set(Depth)) - 1:\n                                        str_geom += '\\t\\t\\t\\t</faultBottomEdge>\\n'\n                                    else:\n                                        str_geom += '\\t\\t\\t\\t</intermediateEdge>\\n'\n                                    index_edge += 1\n                                str_geom += '\\t\\t\\t</complexFaultGeometry>\\n'\n                        hypo_depth = (faults_data[index_fault]['upper_sismo_depth'] + faults_data[index_fault]['lower_sismo_depth']) / 2.0\n                        str_geom += '\\t\\t\\t<hypocenter depth=\"' + str(hypo_depth) + '\" lat=\"' + str(np.mean(faults_data[index_fault]['lat'])) + '\" lon=\"' + str(np.mean(faults_data[index_fault]['lon'])) + '\"/>\\n'\n                        str_geom += '\\t\\t\\t<magScaleRel>' + ScL_oq + '</magScaleRel>\\n'\n                        str_geom += '\\t\\t\\t<ruptAspectRatio>1.0</ruptAspectRatio>\\n'\n                        rake = np.mean(scenario_mechanism)\n                        str_geom += '\\t\\t\\t<rake>' + str(rake) + '</rake>\\n'\n                    line += str_geom\n                    line += '\\t\\t\\t</multiPlanesRupture>\\n'\n        line += '\\t\\t</nonParametricSeismicSource>\\n'\n    return (line, ID_number)",
            "def write_non_parametric_source_multi_types(scenario, scenarios_names, OQ_entry_scenarios, index_faults_in_scenario, faults_names, faults_data, Model_name, Domain_in_the_model, ScL_oq, log_mdf_file, explo_time, M_min, ID_number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    index_scenario = np.where(np.array(scenarios_names) == scenario[1])[0][0]\n    MFD = OQ_entry_scenarios[index_scenario]\n    line = ''\n    if sum(MFD) != 0:\n        ID_number = ID_number + 1\n        index_fault = faults_names.index(scenario[1]['f_1'][0])\n        scenar_name = '_'.join(('{!s}={!r}'.format(key, val) for (key, val) in scenario[1].items()))\n        Fault_Name = Model_name + '_scenario_' + str(scenar_name)\n        line = '\\t\\t<nonParametricSeismicSource id=\"' + str(ID_number) + '\" name=\"' + str(Fault_Name) + '\" tectonicRegion=\"' + str(faults_data[index_fault]['domain']) + '\">\\n'\n        index_faults_in_scenario = index_faults_in_scenario[index_scenario][0]\n        faults_in_scenario = np.take(faults_names, index_faults_in_scenario)\n        str_geom = ''\n        bin_mag = np.linspace(M_min, M_min + 0.1 * len(MFD) + 0.1, num=2 + len(MFD))\n        for (mag, i_mag) in zip(bin_mag, range(len(bin_mag))):\n            if i_mag <= len(MFD) - 1:\n                l = MFD[i_mag]\n                if l != 0.0:\n                    t = explo_time\n                    p_occur_1 = np.float32((l * t) ** 1 * np.exp(-l * t) / np.math.factorial(1))\n                    xxx1 = Decimal('{:.8f}'.format(np.float32(p_occur_1)))\n                    p_not_occur = Decimal('1') - xxx1\n                    p_not_occur = '{:.8f}'.format(p_not_occur)\n                    line += '\\t\\t\\t<multiPlanesRupture probs_occur=\"' + str(p_not_occur) + ' ' + str(xxx1) + '\">\\n'\n                    line += '\\t\\t\\t<magnitude>' + str(mag) + '</magnitude>\\n'\n                    if str_geom == '':\n                        scenario_mechanism = []\n                        for Fault_name in faults_in_scenario:\n                            index_fault = faults_names.index(Fault_name)\n                            ColLon = faults_data[index_fault]['lon']\n                            ColLat = faults_data[index_fault]['lat']\n                            Depth = faults_data[index_fault]['depth']\n                            scenario_mechanism.append(faults_data[index_fault]['rake'])\n                            if Depth and all((elem == 'sf' for elem in Depth)):\n                                type_of_fault = 'sf'\n                            else:\n                                type_of_fault = 'cf'\n                                Depth = [float(i) for i in Depth]\n                            if type_of_fault == 'sf':\n                                str_geom += '\\t\\t\\t<simpleFaultGeometry>\\n'\n                                str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n                                if str('N') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing < 180.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('S') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing > 180.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('E') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing > 90.0 and compass_bearing < 270.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                elif str('W') in str(faults_data[index_fault]['oriented']):\n                                    if compass_bearing < 90.0 or compass_bearing > 270.0:\n                                        ColLon = reversed(ColLon)\n                                        ColLat = reversed(ColLat)\n                                for (x, y) in zip(ColLon, ColLat):\n                                    str_geom += '\\t\\t\\t\\t\\t\\t' + str(x) + ' ' + str(y) + '\\n'\n                                str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                str_geom += '\\t\\t\\t\\t<dip>' + str(faults_data[index_fault]['dip']) + '</dip>\\n'\n                                str_geom += '\\t\\t\\t\\t<upperSeismoDepth>' + str(faults_data[index_fault]['upper_sismo_depth']) + '</upperSeismoDepth>\\n'\n                                str_geom += '\\t\\t\\t\\t<lowerSeismoDepth>' + str(faults_data[index_fault]['lower_sismo_depth']) + '</lowerSeismoDepth>\\n'\n                                str_geom += '\\t\\t\\t</simpleFaultGeometry>\\n'\n                            if type_of_fault == 'cf':\n                                str_geom += '\\t\\t\\t<complexFaultGeometry>\\n'\n                                index_edge = 0\n                                for depth_i in sorted(set(Depth)):\n                                    indexes_for_edge_i = np.where(np.array(Depth) == depth_i)[0]\n                                    if index_edge == 0:\n                                        str_geom += '\\t\\t\\t\\t<faultTopEdge>\\n'\n                                    elif index_edge == len(set(Depth)) - 1:\n                                        str_geom += '\\t\\t\\t\\t<faultBottomEdge>\\n'\n                                    else:\n                                        str_geom += '\\t\\t\\t\\t<intermediateEdge>\\n'\n                                    str_geom += '\\t\\t\\t\\t<gml:LineString>\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n                                    for index in indexes_for_edge_i:\n                                        str_geom += '\\t\\t\\t\\t\\t\\t' + str(ColLon[index]) + ' ' + str(ColLat[index]) + ' ' + str(Depth[index]) + '\\n'\n                                    str_geom += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n                                    str_geom += '\\t\\t\\t\\t</gml:LineString>\\n'\n                                    if index_edge == 0:\n                                        str_geom += '\\t\\t\\t\\t</faultTopEdge>\\n'\n                                    elif index_edge == len(set(Depth)) - 1:\n                                        str_geom += '\\t\\t\\t\\t</faultBottomEdge>\\n'\n                                    else:\n                                        str_geom += '\\t\\t\\t\\t</intermediateEdge>\\n'\n                                    index_edge += 1\n                                str_geom += '\\t\\t\\t</complexFaultGeometry>\\n'\n                        hypo_depth = (faults_data[index_fault]['upper_sismo_depth'] + faults_data[index_fault]['lower_sismo_depth']) / 2.0\n                        str_geom += '\\t\\t\\t<hypocenter depth=\"' + str(hypo_depth) + '\" lat=\"' + str(np.mean(faults_data[index_fault]['lat'])) + '\" lon=\"' + str(np.mean(faults_data[index_fault]['lon'])) + '\"/>\\n'\n                        str_geom += '\\t\\t\\t<magScaleRel>' + ScL_oq + '</magScaleRel>\\n'\n                        str_geom += '\\t\\t\\t<ruptAspectRatio>1.0</ruptAspectRatio>\\n'\n                        rake = np.mean(scenario_mechanism)\n                        str_geom += '\\t\\t\\t<rake>' + str(rake) + '</rake>\\n'\n                    line += str_geom\n                    line += '\\t\\t\\t</multiPlanesRupture>\\n'\n        line += '\\t\\t</nonParametricSeismicSource>\\n'\n    return (line, ID_number)"
        ]
    }
]