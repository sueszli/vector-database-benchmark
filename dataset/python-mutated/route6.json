[
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    self.resync()\n    self.invalidate_cache()",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    self.resync()\n    self.invalidate_cache()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.resync()\n    self.invalidate_cache()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.resync()\n    self.invalidate_cache()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.resync()\n    self.invalidate_cache()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.resync()\n    self.invalidate_cache()"
        ]
    },
    {
        "func_name": "invalidate_cache",
        "original": "def invalidate_cache(self):\n    self.cache = {}",
        "mutated": [
            "def invalidate_cache(self):\n    if False:\n        i = 10\n    self.cache = {}",
            "def invalidate_cache(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.cache = {}",
            "def invalidate_cache(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.cache = {}",
            "def invalidate_cache(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.cache = {}",
            "def invalidate_cache(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.cache = {}"
        ]
    },
    {
        "func_name": "flush",
        "original": "def flush(self):\n    self.invalidate_cache()\n    self.ipv6_ifaces = set()\n    self.routes = []",
        "mutated": [
            "def flush(self):\n    if False:\n        i = 10\n    self.invalidate_cache()\n    self.ipv6_ifaces = set()\n    self.routes = []",
            "def flush(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.invalidate_cache()\n    self.ipv6_ifaces = set()\n    self.routes = []",
            "def flush(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.invalidate_cache()\n    self.ipv6_ifaces = set()\n    self.routes = []",
            "def flush(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.invalidate_cache()\n    self.ipv6_ifaces = set()\n    self.routes = []",
            "def flush(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.invalidate_cache()\n    self.ipv6_ifaces = set()\n    self.routes = []"
        ]
    },
    {
        "func_name": "resync",
        "original": "def resync(self):\n    self.invalidate_cache()\n    self.routes = read_routes6()\n    self.ipv6_ifaces = set()\n    for route in self.routes:\n        self.ipv6_ifaces.add(route[3])\n    if self.routes == []:\n        log_loading.info('No IPv6 support in kernel')",
        "mutated": [
            "def resync(self):\n    if False:\n        i = 10\n    self.invalidate_cache()\n    self.routes = read_routes6()\n    self.ipv6_ifaces = set()\n    for route in self.routes:\n        self.ipv6_ifaces.add(route[3])\n    if self.routes == []:\n        log_loading.info('No IPv6 support in kernel')",
            "def resync(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.invalidate_cache()\n    self.routes = read_routes6()\n    self.ipv6_ifaces = set()\n    for route in self.routes:\n        self.ipv6_ifaces.add(route[3])\n    if self.routes == []:\n        log_loading.info('No IPv6 support in kernel')",
            "def resync(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.invalidate_cache()\n    self.routes = read_routes6()\n    self.ipv6_ifaces = set()\n    for route in self.routes:\n        self.ipv6_ifaces.add(route[3])\n    if self.routes == []:\n        log_loading.info('No IPv6 support in kernel')",
            "def resync(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.invalidate_cache()\n    self.routes = read_routes6()\n    self.ipv6_ifaces = set()\n    for route in self.routes:\n        self.ipv6_ifaces.add(route[3])\n    if self.routes == []:\n        log_loading.info('No IPv6 support in kernel')",
            "def resync(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.invalidate_cache()\n    self.routes = read_routes6()\n    self.ipv6_ifaces = set()\n    for route in self.routes:\n        self.ipv6_ifaces.add(route[3])\n    if self.routes == []:\n        log_loading.info('No IPv6 support in kernel')"
        ]
    },
    {
        "func_name": "__repr__",
        "original": "def __repr__(self):\n    rtlst = []\n    for (net, msk, gw, iface, cset, metric) in self.routes:\n        if_repr = resolve_iface(iface).description\n        rtlst.append(('%s/%i' % (net, msk), gw, if_repr, cset, str(metric)))\n    return pretty_list(rtlst, [('Destination', 'Next Hop', 'Iface', 'Src candidates', 'Metric')], sortBy=1)",
        "mutated": [
            "def __repr__(self):\n    if False:\n        i = 10\n    rtlst = []\n    for (net, msk, gw, iface, cset, metric) in self.routes:\n        if_repr = resolve_iface(iface).description\n        rtlst.append(('%s/%i' % (net, msk), gw, if_repr, cset, str(metric)))\n    return pretty_list(rtlst, [('Destination', 'Next Hop', 'Iface', 'Src candidates', 'Metric')], sortBy=1)",
            "def __repr__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rtlst = []\n    for (net, msk, gw, iface, cset, metric) in self.routes:\n        if_repr = resolve_iface(iface).description\n        rtlst.append(('%s/%i' % (net, msk), gw, if_repr, cset, str(metric)))\n    return pretty_list(rtlst, [('Destination', 'Next Hop', 'Iface', 'Src candidates', 'Metric')], sortBy=1)",
            "def __repr__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rtlst = []\n    for (net, msk, gw, iface, cset, metric) in self.routes:\n        if_repr = resolve_iface(iface).description\n        rtlst.append(('%s/%i' % (net, msk), gw, if_repr, cset, str(metric)))\n    return pretty_list(rtlst, [('Destination', 'Next Hop', 'Iface', 'Src candidates', 'Metric')], sortBy=1)",
            "def __repr__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rtlst = []\n    for (net, msk, gw, iface, cset, metric) in self.routes:\n        if_repr = resolve_iface(iface).description\n        rtlst.append(('%s/%i' % (net, msk), gw, if_repr, cset, str(metric)))\n    return pretty_list(rtlst, [('Destination', 'Next Hop', 'Iface', 'Src candidates', 'Metric')], sortBy=1)",
            "def __repr__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rtlst = []\n    for (net, msk, gw, iface, cset, metric) in self.routes:\n        if_repr = resolve_iface(iface).description\n        rtlst.append(('%s/%i' % (net, msk), gw, if_repr, cset, str(metric)))\n    return pretty_list(rtlst, [('Destination', 'Next Hop', 'Iface', 'Src candidates', 'Metric')], sortBy=1)"
        ]
    },
    {
        "func_name": "make_route",
        "original": "def make_route(self, dst, gw=None, dev=None):\n    \"\"\"Internal function : create a route for 'dst' via 'gw'.\n        \"\"\"\n    (prefix, plen_b) = (dst.split('/') + ['128'])[:2]\n    plen = int(plen_b)\n    if gw is None:\n        gw = '::'\n    if dev is None:\n        (dev, ifaddr_uniq, x) = self.route(gw)\n        ifaddr = [ifaddr_uniq]\n    else:\n        lifaddr = in6_getifaddr()\n        devaddrs = (x for x in lifaddr if x[2] == dev)\n        ifaddr = construct_source_candidate_set(prefix, plen, devaddrs)\n    self.ipv6_ifaces.add(dev)\n    return (prefix, plen, gw, dev, ifaddr, 1)",
        "mutated": [
            "def make_route(self, dst, gw=None, dev=None):\n    if False:\n        i = 10\n    \"Internal function : create a route for 'dst' via 'gw'.\\n        \"\n    (prefix, plen_b) = (dst.split('/') + ['128'])[:2]\n    plen = int(plen_b)\n    if gw is None:\n        gw = '::'\n    if dev is None:\n        (dev, ifaddr_uniq, x) = self.route(gw)\n        ifaddr = [ifaddr_uniq]\n    else:\n        lifaddr = in6_getifaddr()\n        devaddrs = (x for x in lifaddr if x[2] == dev)\n        ifaddr = construct_source_candidate_set(prefix, plen, devaddrs)\n    self.ipv6_ifaces.add(dev)\n    return (prefix, plen, gw, dev, ifaddr, 1)",
            "def make_route(self, dst, gw=None, dev=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Internal function : create a route for 'dst' via 'gw'.\\n        \"\n    (prefix, plen_b) = (dst.split('/') + ['128'])[:2]\n    plen = int(plen_b)\n    if gw is None:\n        gw = '::'\n    if dev is None:\n        (dev, ifaddr_uniq, x) = self.route(gw)\n        ifaddr = [ifaddr_uniq]\n    else:\n        lifaddr = in6_getifaddr()\n        devaddrs = (x for x in lifaddr if x[2] == dev)\n        ifaddr = construct_source_candidate_set(prefix, plen, devaddrs)\n    self.ipv6_ifaces.add(dev)\n    return (prefix, plen, gw, dev, ifaddr, 1)",
            "def make_route(self, dst, gw=None, dev=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Internal function : create a route for 'dst' via 'gw'.\\n        \"\n    (prefix, plen_b) = (dst.split('/') + ['128'])[:2]\n    plen = int(plen_b)\n    if gw is None:\n        gw = '::'\n    if dev is None:\n        (dev, ifaddr_uniq, x) = self.route(gw)\n        ifaddr = [ifaddr_uniq]\n    else:\n        lifaddr = in6_getifaddr()\n        devaddrs = (x for x in lifaddr if x[2] == dev)\n        ifaddr = construct_source_candidate_set(prefix, plen, devaddrs)\n    self.ipv6_ifaces.add(dev)\n    return (prefix, plen, gw, dev, ifaddr, 1)",
            "def make_route(self, dst, gw=None, dev=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Internal function : create a route for 'dst' via 'gw'.\\n        \"\n    (prefix, plen_b) = (dst.split('/') + ['128'])[:2]\n    plen = int(plen_b)\n    if gw is None:\n        gw = '::'\n    if dev is None:\n        (dev, ifaddr_uniq, x) = self.route(gw)\n        ifaddr = [ifaddr_uniq]\n    else:\n        lifaddr = in6_getifaddr()\n        devaddrs = (x for x in lifaddr if x[2] == dev)\n        ifaddr = construct_source_candidate_set(prefix, plen, devaddrs)\n    self.ipv6_ifaces.add(dev)\n    return (prefix, plen, gw, dev, ifaddr, 1)",
            "def make_route(self, dst, gw=None, dev=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Internal function : create a route for 'dst' via 'gw'.\\n        \"\n    (prefix, plen_b) = (dst.split('/') + ['128'])[:2]\n    plen = int(plen_b)\n    if gw is None:\n        gw = '::'\n    if dev is None:\n        (dev, ifaddr_uniq, x) = self.route(gw)\n        ifaddr = [ifaddr_uniq]\n    else:\n        lifaddr = in6_getifaddr()\n        devaddrs = (x for x in lifaddr if x[2] == dev)\n        ifaddr = construct_source_candidate_set(prefix, plen, devaddrs)\n    self.ipv6_ifaces.add(dev)\n    return (prefix, plen, gw, dev, ifaddr, 1)"
        ]
    },
    {
        "func_name": "add",
        "original": "def add(self, *args, **kargs):\n    \"\"\"Ex:\n        add(dst=\"2001:db8:cafe:f000::/56\")\n        add(dst=\"2001:db8:cafe:f000::/56\", gw=\"2001:db8:cafe::1\")\n        add(dst=\"2001:db8:cafe:f000::/64\", gw=\"2001:db8:cafe::1\", dev=\"eth0\")\n        \"\"\"\n    self.invalidate_cache()\n    self.routes.append(self.make_route(*args, **kargs))",
        "mutated": [
            "def add(self, *args, **kargs):\n    if False:\n        i = 10\n    'Ex:\\n        add(dst=\"2001:db8:cafe:f000::/56\")\\n        add(dst=\"2001:db8:cafe:f000::/56\", gw=\"2001:db8:cafe::1\")\\n        add(dst=\"2001:db8:cafe:f000::/64\", gw=\"2001:db8:cafe::1\", dev=\"eth0\")\\n        '\n    self.invalidate_cache()\n    self.routes.append(self.make_route(*args, **kargs))",
            "def add(self, *args, **kargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Ex:\\n        add(dst=\"2001:db8:cafe:f000::/56\")\\n        add(dst=\"2001:db8:cafe:f000::/56\", gw=\"2001:db8:cafe::1\")\\n        add(dst=\"2001:db8:cafe:f000::/64\", gw=\"2001:db8:cafe::1\", dev=\"eth0\")\\n        '\n    self.invalidate_cache()\n    self.routes.append(self.make_route(*args, **kargs))",
            "def add(self, *args, **kargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Ex:\\n        add(dst=\"2001:db8:cafe:f000::/56\")\\n        add(dst=\"2001:db8:cafe:f000::/56\", gw=\"2001:db8:cafe::1\")\\n        add(dst=\"2001:db8:cafe:f000::/64\", gw=\"2001:db8:cafe::1\", dev=\"eth0\")\\n        '\n    self.invalidate_cache()\n    self.routes.append(self.make_route(*args, **kargs))",
            "def add(self, *args, **kargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Ex:\\n        add(dst=\"2001:db8:cafe:f000::/56\")\\n        add(dst=\"2001:db8:cafe:f000::/56\", gw=\"2001:db8:cafe::1\")\\n        add(dst=\"2001:db8:cafe:f000::/64\", gw=\"2001:db8:cafe::1\", dev=\"eth0\")\\n        '\n    self.invalidate_cache()\n    self.routes.append(self.make_route(*args, **kargs))",
            "def add(self, *args, **kargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Ex:\\n        add(dst=\"2001:db8:cafe:f000::/56\")\\n        add(dst=\"2001:db8:cafe:f000::/56\", gw=\"2001:db8:cafe::1\")\\n        add(dst=\"2001:db8:cafe:f000::/64\", gw=\"2001:db8:cafe::1\", dev=\"eth0\")\\n        '\n    self.invalidate_cache()\n    self.routes.append(self.make_route(*args, **kargs))"
        ]
    },
    {
        "func_name": "remove_ipv6_iface",
        "original": "def remove_ipv6_iface(self, iface):\n    \"\"\"\n        Remove the network interface 'iface' from the list of interfaces\n        supporting IPv6.\n        \"\"\"\n    if not all((r[3] == iface for r in conf.route6.routes)):\n        try:\n            self.ipv6_ifaces.remove(iface)\n        except KeyError:\n            pass",
        "mutated": [
            "def remove_ipv6_iface(self, iface):\n    if False:\n        i = 10\n    \"\\n        Remove the network interface 'iface' from the list of interfaces\\n        supporting IPv6.\\n        \"\n    if not all((r[3] == iface for r in conf.route6.routes)):\n        try:\n            self.ipv6_ifaces.remove(iface)\n        except KeyError:\n            pass",
            "def remove_ipv6_iface(self, iface):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Remove the network interface 'iface' from the list of interfaces\\n        supporting IPv6.\\n        \"\n    if not all((r[3] == iface for r in conf.route6.routes)):\n        try:\n            self.ipv6_ifaces.remove(iface)\n        except KeyError:\n            pass",
            "def remove_ipv6_iface(self, iface):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Remove the network interface 'iface' from the list of interfaces\\n        supporting IPv6.\\n        \"\n    if not all((r[3] == iface for r in conf.route6.routes)):\n        try:\n            self.ipv6_ifaces.remove(iface)\n        except KeyError:\n            pass",
            "def remove_ipv6_iface(self, iface):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Remove the network interface 'iface' from the list of interfaces\\n        supporting IPv6.\\n        \"\n    if not all((r[3] == iface for r in conf.route6.routes)):\n        try:\n            self.ipv6_ifaces.remove(iface)\n        except KeyError:\n            pass",
            "def remove_ipv6_iface(self, iface):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Remove the network interface 'iface' from the list of interfaces\\n        supporting IPv6.\\n        \"\n    if not all((r[3] == iface for r in conf.route6.routes)):\n        try:\n            self.ipv6_ifaces.remove(iface)\n        except KeyError:\n            pass"
        ]
    },
    {
        "func_name": "delt",
        "original": "def delt(self, dst, gw=None):\n    \"\"\" Ex:\n        delt(dst=\"::/0\")\n        delt(dst=\"2001:db8:cafe:f000::/56\")\n        delt(dst=\"2001:db8:cafe:f000::/56\", gw=\"2001:db8:deca::1\")\n        \"\"\"\n    tmp = dst + '/128'\n    (dst, plen_b) = tmp.split('/')[:2]\n    dst = in6_ptop(dst)\n    plen = int(plen_b)\n    to_del = [x for x in self.routes if in6_ptop(x[0]) == dst and x[1] == plen]\n    if gw:\n        gw = in6_ptop(gw)\n        to_del = [x for x in self.routes if in6_ptop(x[2]) == gw]\n    if len(to_del) == 0:\n        warning('No matching route found')\n    elif len(to_del) > 1:\n        warning('Found more than one match. Aborting.')\n    else:\n        i = self.routes.index(to_del[0])\n        self.invalidate_cache()\n        self.remove_ipv6_iface(self.routes[i][3])\n        del self.routes[i]",
        "mutated": [
            "def delt(self, dst, gw=None):\n    if False:\n        i = 10\n    ' Ex:\\n        delt(dst=\"::/0\")\\n        delt(dst=\"2001:db8:cafe:f000::/56\")\\n        delt(dst=\"2001:db8:cafe:f000::/56\", gw=\"2001:db8:deca::1\")\\n        '\n    tmp = dst + '/128'\n    (dst, plen_b) = tmp.split('/')[:2]\n    dst = in6_ptop(dst)\n    plen = int(plen_b)\n    to_del = [x for x in self.routes if in6_ptop(x[0]) == dst and x[1] == plen]\n    if gw:\n        gw = in6_ptop(gw)\n        to_del = [x for x in self.routes if in6_ptop(x[2]) == gw]\n    if len(to_del) == 0:\n        warning('No matching route found')\n    elif len(to_del) > 1:\n        warning('Found more than one match. Aborting.')\n    else:\n        i = self.routes.index(to_del[0])\n        self.invalidate_cache()\n        self.remove_ipv6_iface(self.routes[i][3])\n        del self.routes[i]",
            "def delt(self, dst, gw=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Ex:\\n        delt(dst=\"::/0\")\\n        delt(dst=\"2001:db8:cafe:f000::/56\")\\n        delt(dst=\"2001:db8:cafe:f000::/56\", gw=\"2001:db8:deca::1\")\\n        '\n    tmp = dst + '/128'\n    (dst, plen_b) = tmp.split('/')[:2]\n    dst = in6_ptop(dst)\n    plen = int(plen_b)\n    to_del = [x for x in self.routes if in6_ptop(x[0]) == dst and x[1] == plen]\n    if gw:\n        gw = in6_ptop(gw)\n        to_del = [x for x in self.routes if in6_ptop(x[2]) == gw]\n    if len(to_del) == 0:\n        warning('No matching route found')\n    elif len(to_del) > 1:\n        warning('Found more than one match. Aborting.')\n    else:\n        i = self.routes.index(to_del[0])\n        self.invalidate_cache()\n        self.remove_ipv6_iface(self.routes[i][3])\n        del self.routes[i]",
            "def delt(self, dst, gw=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Ex:\\n        delt(dst=\"::/0\")\\n        delt(dst=\"2001:db8:cafe:f000::/56\")\\n        delt(dst=\"2001:db8:cafe:f000::/56\", gw=\"2001:db8:deca::1\")\\n        '\n    tmp = dst + '/128'\n    (dst, plen_b) = tmp.split('/')[:2]\n    dst = in6_ptop(dst)\n    plen = int(plen_b)\n    to_del = [x for x in self.routes if in6_ptop(x[0]) == dst and x[1] == plen]\n    if gw:\n        gw = in6_ptop(gw)\n        to_del = [x for x in self.routes if in6_ptop(x[2]) == gw]\n    if len(to_del) == 0:\n        warning('No matching route found')\n    elif len(to_del) > 1:\n        warning('Found more than one match. Aborting.')\n    else:\n        i = self.routes.index(to_del[0])\n        self.invalidate_cache()\n        self.remove_ipv6_iface(self.routes[i][3])\n        del self.routes[i]",
            "def delt(self, dst, gw=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Ex:\\n        delt(dst=\"::/0\")\\n        delt(dst=\"2001:db8:cafe:f000::/56\")\\n        delt(dst=\"2001:db8:cafe:f000::/56\", gw=\"2001:db8:deca::1\")\\n        '\n    tmp = dst + '/128'\n    (dst, plen_b) = tmp.split('/')[:2]\n    dst = in6_ptop(dst)\n    plen = int(plen_b)\n    to_del = [x for x in self.routes if in6_ptop(x[0]) == dst and x[1] == plen]\n    if gw:\n        gw = in6_ptop(gw)\n        to_del = [x for x in self.routes if in6_ptop(x[2]) == gw]\n    if len(to_del) == 0:\n        warning('No matching route found')\n    elif len(to_del) > 1:\n        warning('Found more than one match. Aborting.')\n    else:\n        i = self.routes.index(to_del[0])\n        self.invalidate_cache()\n        self.remove_ipv6_iface(self.routes[i][3])\n        del self.routes[i]",
            "def delt(self, dst, gw=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Ex:\\n        delt(dst=\"::/0\")\\n        delt(dst=\"2001:db8:cafe:f000::/56\")\\n        delt(dst=\"2001:db8:cafe:f000::/56\", gw=\"2001:db8:deca::1\")\\n        '\n    tmp = dst + '/128'\n    (dst, plen_b) = tmp.split('/')[:2]\n    dst = in6_ptop(dst)\n    plen = int(plen_b)\n    to_del = [x for x in self.routes if in6_ptop(x[0]) == dst and x[1] == plen]\n    if gw:\n        gw = in6_ptop(gw)\n        to_del = [x for x in self.routes if in6_ptop(x[2]) == gw]\n    if len(to_del) == 0:\n        warning('No matching route found')\n    elif len(to_del) > 1:\n        warning('Found more than one match. Aborting.')\n    else:\n        i = self.routes.index(to_del[0])\n        self.invalidate_cache()\n        self.remove_ipv6_iface(self.routes[i][3])\n        del self.routes[i]"
        ]
    },
    {
        "func_name": "ifchange",
        "original": "def ifchange(self, iff, addr):\n    (the_addr, the_plen_b) = (addr.split('/') + ['128'])[:2]\n    the_plen = int(the_plen_b)\n    naddr = inet_pton(socket.AF_INET6, the_addr)\n    nmask = in6_cidr2mask(the_plen)\n    the_net = inet_ntop(socket.AF_INET6, in6_and(nmask, naddr))\n    for (i, route) in enumerate(self.routes):\n        (net, plen, gw, iface, _, metric) = route\n        if iface != iff:\n            continue\n        self.ipv6_ifaces.add(iface)\n        if gw == '::':\n            self.routes[i] = (the_net, the_plen, gw, iface, [the_addr], metric)\n        else:\n            self.routes[i] = (net, plen, gw, iface, [the_addr], metric)\n    self.invalidate_cache()\n    conf.netcache.in6_neighbor.flush()",
        "mutated": [
            "def ifchange(self, iff, addr):\n    if False:\n        i = 10\n    (the_addr, the_plen_b) = (addr.split('/') + ['128'])[:2]\n    the_plen = int(the_plen_b)\n    naddr = inet_pton(socket.AF_INET6, the_addr)\n    nmask = in6_cidr2mask(the_plen)\n    the_net = inet_ntop(socket.AF_INET6, in6_and(nmask, naddr))\n    for (i, route) in enumerate(self.routes):\n        (net, plen, gw, iface, _, metric) = route\n        if iface != iff:\n            continue\n        self.ipv6_ifaces.add(iface)\n        if gw == '::':\n            self.routes[i] = (the_net, the_plen, gw, iface, [the_addr], metric)\n        else:\n            self.routes[i] = (net, plen, gw, iface, [the_addr], metric)\n    self.invalidate_cache()\n    conf.netcache.in6_neighbor.flush()",
            "def ifchange(self, iff, addr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (the_addr, the_plen_b) = (addr.split('/') + ['128'])[:2]\n    the_plen = int(the_plen_b)\n    naddr = inet_pton(socket.AF_INET6, the_addr)\n    nmask = in6_cidr2mask(the_plen)\n    the_net = inet_ntop(socket.AF_INET6, in6_and(nmask, naddr))\n    for (i, route) in enumerate(self.routes):\n        (net, plen, gw, iface, _, metric) = route\n        if iface != iff:\n            continue\n        self.ipv6_ifaces.add(iface)\n        if gw == '::':\n            self.routes[i] = (the_net, the_plen, gw, iface, [the_addr], metric)\n        else:\n            self.routes[i] = (net, plen, gw, iface, [the_addr], metric)\n    self.invalidate_cache()\n    conf.netcache.in6_neighbor.flush()",
            "def ifchange(self, iff, addr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (the_addr, the_plen_b) = (addr.split('/') + ['128'])[:2]\n    the_plen = int(the_plen_b)\n    naddr = inet_pton(socket.AF_INET6, the_addr)\n    nmask = in6_cidr2mask(the_plen)\n    the_net = inet_ntop(socket.AF_INET6, in6_and(nmask, naddr))\n    for (i, route) in enumerate(self.routes):\n        (net, plen, gw, iface, _, metric) = route\n        if iface != iff:\n            continue\n        self.ipv6_ifaces.add(iface)\n        if gw == '::':\n            self.routes[i] = (the_net, the_plen, gw, iface, [the_addr], metric)\n        else:\n            self.routes[i] = (net, plen, gw, iface, [the_addr], metric)\n    self.invalidate_cache()\n    conf.netcache.in6_neighbor.flush()",
            "def ifchange(self, iff, addr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (the_addr, the_plen_b) = (addr.split('/') + ['128'])[:2]\n    the_plen = int(the_plen_b)\n    naddr = inet_pton(socket.AF_INET6, the_addr)\n    nmask = in6_cidr2mask(the_plen)\n    the_net = inet_ntop(socket.AF_INET6, in6_and(nmask, naddr))\n    for (i, route) in enumerate(self.routes):\n        (net, plen, gw, iface, _, metric) = route\n        if iface != iff:\n            continue\n        self.ipv6_ifaces.add(iface)\n        if gw == '::':\n            self.routes[i] = (the_net, the_plen, gw, iface, [the_addr], metric)\n        else:\n            self.routes[i] = (net, plen, gw, iface, [the_addr], metric)\n    self.invalidate_cache()\n    conf.netcache.in6_neighbor.flush()",
            "def ifchange(self, iff, addr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (the_addr, the_plen_b) = (addr.split('/') + ['128'])[:2]\n    the_plen = int(the_plen_b)\n    naddr = inet_pton(socket.AF_INET6, the_addr)\n    nmask = in6_cidr2mask(the_plen)\n    the_net = inet_ntop(socket.AF_INET6, in6_and(nmask, naddr))\n    for (i, route) in enumerate(self.routes):\n        (net, plen, gw, iface, _, metric) = route\n        if iface != iff:\n            continue\n        self.ipv6_ifaces.add(iface)\n        if gw == '::':\n            self.routes[i] = (the_net, the_plen, gw, iface, [the_addr], metric)\n        else:\n            self.routes[i] = (net, plen, gw, iface, [the_addr], metric)\n    self.invalidate_cache()\n    conf.netcache.in6_neighbor.flush()"
        ]
    },
    {
        "func_name": "ifdel",
        "original": "def ifdel(self, iff):\n    \"\"\" removes all route entries that uses 'iff' interface. \"\"\"\n    new_routes = []\n    for rt in self.routes:\n        if rt[3] != iff:\n            new_routes.append(rt)\n    self.invalidate_cache()\n    self.routes = new_routes\n    self.remove_ipv6_iface(iff)",
        "mutated": [
            "def ifdel(self, iff):\n    if False:\n        i = 10\n    \" removes all route entries that uses 'iff' interface. \"\n    new_routes = []\n    for rt in self.routes:\n        if rt[3] != iff:\n            new_routes.append(rt)\n    self.invalidate_cache()\n    self.routes = new_routes\n    self.remove_ipv6_iface(iff)",
            "def ifdel(self, iff):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \" removes all route entries that uses 'iff' interface. \"\n    new_routes = []\n    for rt in self.routes:\n        if rt[3] != iff:\n            new_routes.append(rt)\n    self.invalidate_cache()\n    self.routes = new_routes\n    self.remove_ipv6_iface(iff)",
            "def ifdel(self, iff):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \" removes all route entries that uses 'iff' interface. \"\n    new_routes = []\n    for rt in self.routes:\n        if rt[3] != iff:\n            new_routes.append(rt)\n    self.invalidate_cache()\n    self.routes = new_routes\n    self.remove_ipv6_iface(iff)",
            "def ifdel(self, iff):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \" removes all route entries that uses 'iff' interface. \"\n    new_routes = []\n    for rt in self.routes:\n        if rt[3] != iff:\n            new_routes.append(rt)\n    self.invalidate_cache()\n    self.routes = new_routes\n    self.remove_ipv6_iface(iff)",
            "def ifdel(self, iff):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \" removes all route entries that uses 'iff' interface. \"\n    new_routes = []\n    for rt in self.routes:\n        if rt[3] != iff:\n            new_routes.append(rt)\n    self.invalidate_cache()\n    self.routes = new_routes\n    self.remove_ipv6_iface(iff)"
        ]
    },
    {
        "func_name": "ifadd",
        "original": "def ifadd(self, iff, addr):\n    \"\"\"\n        Add an interface 'iff' with provided address into routing table.\n\n        Ex: ifadd('eth0', '2001:bd8:cafe:1::1/64') will add following entry into  # noqa: E501\n            Scapy6 internal routing table:\n\n            Destination           Next Hop  iface  Def src @           Metric\n            2001:bd8:cafe:1::/64  ::        eth0   2001:bd8:cafe:1::1  1\n\n            prefix length value can be omitted. In that case, a value of 128\n            will be used.\n        \"\"\"\n    (addr, plen_b) = (addr.split('/') + ['128'])[:2]\n    addr = in6_ptop(addr)\n    plen = int(plen_b)\n    naddr = inet_pton(socket.AF_INET6, addr)\n    nmask = in6_cidr2mask(plen)\n    prefix = inet_ntop(socket.AF_INET6, in6_and(nmask, naddr))\n    self.invalidate_cache()\n    self.routes.append((prefix, plen, '::', iff, [addr], 1))\n    self.ipv6_ifaces.add(iff)",
        "mutated": [
            "def ifadd(self, iff, addr):\n    if False:\n        i = 10\n    \"\\n        Add an interface 'iff' with provided address into routing table.\\n\\n        Ex: ifadd('eth0', '2001:bd8:cafe:1::1/64') will add following entry into  # noqa: E501\\n            Scapy6 internal routing table:\\n\\n            Destination           Next Hop  iface  Def src @           Metric\\n            2001:bd8:cafe:1::/64  ::        eth0   2001:bd8:cafe:1::1  1\\n\\n            prefix length value can be omitted. In that case, a value of 128\\n            will be used.\\n        \"\n    (addr, plen_b) = (addr.split('/') + ['128'])[:2]\n    addr = in6_ptop(addr)\n    plen = int(plen_b)\n    naddr = inet_pton(socket.AF_INET6, addr)\n    nmask = in6_cidr2mask(plen)\n    prefix = inet_ntop(socket.AF_INET6, in6_and(nmask, naddr))\n    self.invalidate_cache()\n    self.routes.append((prefix, plen, '::', iff, [addr], 1))\n    self.ipv6_ifaces.add(iff)",
            "def ifadd(self, iff, addr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Add an interface 'iff' with provided address into routing table.\\n\\n        Ex: ifadd('eth0', '2001:bd8:cafe:1::1/64') will add following entry into  # noqa: E501\\n            Scapy6 internal routing table:\\n\\n            Destination           Next Hop  iface  Def src @           Metric\\n            2001:bd8:cafe:1::/64  ::        eth0   2001:bd8:cafe:1::1  1\\n\\n            prefix length value can be omitted. In that case, a value of 128\\n            will be used.\\n        \"\n    (addr, plen_b) = (addr.split('/') + ['128'])[:2]\n    addr = in6_ptop(addr)\n    plen = int(plen_b)\n    naddr = inet_pton(socket.AF_INET6, addr)\n    nmask = in6_cidr2mask(plen)\n    prefix = inet_ntop(socket.AF_INET6, in6_and(nmask, naddr))\n    self.invalidate_cache()\n    self.routes.append((prefix, plen, '::', iff, [addr], 1))\n    self.ipv6_ifaces.add(iff)",
            "def ifadd(self, iff, addr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Add an interface 'iff' with provided address into routing table.\\n\\n        Ex: ifadd('eth0', '2001:bd8:cafe:1::1/64') will add following entry into  # noqa: E501\\n            Scapy6 internal routing table:\\n\\n            Destination           Next Hop  iface  Def src @           Metric\\n            2001:bd8:cafe:1::/64  ::        eth0   2001:bd8:cafe:1::1  1\\n\\n            prefix length value can be omitted. In that case, a value of 128\\n            will be used.\\n        \"\n    (addr, plen_b) = (addr.split('/') + ['128'])[:2]\n    addr = in6_ptop(addr)\n    plen = int(plen_b)\n    naddr = inet_pton(socket.AF_INET6, addr)\n    nmask = in6_cidr2mask(plen)\n    prefix = inet_ntop(socket.AF_INET6, in6_and(nmask, naddr))\n    self.invalidate_cache()\n    self.routes.append((prefix, plen, '::', iff, [addr], 1))\n    self.ipv6_ifaces.add(iff)",
            "def ifadd(self, iff, addr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Add an interface 'iff' with provided address into routing table.\\n\\n        Ex: ifadd('eth0', '2001:bd8:cafe:1::1/64') will add following entry into  # noqa: E501\\n            Scapy6 internal routing table:\\n\\n            Destination           Next Hop  iface  Def src @           Metric\\n            2001:bd8:cafe:1::/64  ::        eth0   2001:bd8:cafe:1::1  1\\n\\n            prefix length value can be omitted. In that case, a value of 128\\n            will be used.\\n        \"\n    (addr, plen_b) = (addr.split('/') + ['128'])[:2]\n    addr = in6_ptop(addr)\n    plen = int(plen_b)\n    naddr = inet_pton(socket.AF_INET6, addr)\n    nmask = in6_cidr2mask(plen)\n    prefix = inet_ntop(socket.AF_INET6, in6_and(nmask, naddr))\n    self.invalidate_cache()\n    self.routes.append((prefix, plen, '::', iff, [addr], 1))\n    self.ipv6_ifaces.add(iff)",
            "def ifadd(self, iff, addr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Add an interface 'iff' with provided address into routing table.\\n\\n        Ex: ifadd('eth0', '2001:bd8:cafe:1::1/64') will add following entry into  # noqa: E501\\n            Scapy6 internal routing table:\\n\\n            Destination           Next Hop  iface  Def src @           Metric\\n            2001:bd8:cafe:1::/64  ::        eth0   2001:bd8:cafe:1::1  1\\n\\n            prefix length value can be omitted. In that case, a value of 128\\n            will be used.\\n        \"\n    (addr, plen_b) = (addr.split('/') + ['128'])[:2]\n    addr = in6_ptop(addr)\n    plen = int(plen_b)\n    naddr = inet_pton(socket.AF_INET6, addr)\n    nmask = in6_cidr2mask(plen)\n    prefix = inet_ntop(socket.AF_INET6, in6_and(nmask, naddr))\n    self.invalidate_cache()\n    self.routes.append((prefix, plen, '::', iff, [addr], 1))\n    self.ipv6_ifaces.add(iff)"
        ]
    },
    {
        "func_name": "route",
        "original": "def route(self, dst='', dev=None, verbose=conf.verb):\n    \"\"\"\n        Provide best route to IPv6 destination address, based on Scapy\n        internal routing table content.\n\n        When a set of address is passed (e.g. ``2001:db8:cafe:*::1-5``) an\n        address of the set is used. Be aware of that behavior when using\n        wildcards in upper parts of addresses !\n\n        If 'dst' parameter is a FQDN, name resolution is performed and result\n        is used.\n\n        if optional 'dev' parameter is provided a specific interface, filtering\n        is performed to limit search to route associated to that interface.\n        \"\"\"\n    dst = dst or '::/0'\n    dst = dst.split('/')[0]\n    savedst = dst\n    dst = dst.replace('*', '0')\n    idx = dst.find('-')\n    while idx >= 0:\n        m = (dst[idx:] + ':').find(':')\n        dst = dst[:idx] + dst[idx + m:]\n        idx = dst.find('-')\n    try:\n        inet_pton(socket.AF_INET6, dst)\n    except socket.error:\n        dst = socket.getaddrinfo(savedst, None, socket.AF_INET6)[0][-1][0]\n    if dev is None and (in6_islladdr(dst) or in6_ismlladdr(dst)):\n        dev = conf.iface\n        if dev not in self.ipv6_ifaces and self.ipv6_ifaces:\n            tmp_routes = [route for route in self.routes if route[3] != conf.iface]\n            default_routes = [route for route in tmp_routes if (route[0], route[1]) == ('::', 0)]\n            ll_routes = [route for route in tmp_routes if (route[0], route[1]) == ('fe80::', 64)]\n            if default_routes:\n                dev = default_routes[0][3]\n            elif ll_routes:\n                dev = ll_routes[0][3]\n            else:\n                dev = conf.loopback_name\n            warning('The conf.iface interface (%s) does not support IPv6! Using %s instead for routing!' % (conf.iface, dev))\n    k = dst\n    if dev is not None:\n        k = dst + '%%' + dev\n    if k in self.cache:\n        return self.cache[k]\n    paths = []\n    for (p, plen, gw, iface, cset, me) in self.routes:\n        if dev is not None and iface != dev:\n            continue\n        if in6_isincluded(dst, p, plen):\n            paths.append((plen, me, (iface, cset, gw)))\n        elif in6_ismlladdr(dst) and in6_islladdr(p) and in6_islladdr(cset[0]):\n            paths.append((plen, me, (iface, cset, gw)))\n    if not paths:\n        if dst == '::1':\n            return (conf.loopback_name, '::1', '::')\n        else:\n            if verbose:\n                warning('No route found for IPv6 destination %s (no default route?)', dst)\n            return (conf.loopback_name, '::', '::')\n    paths.sort(key=lambda x: (-x[0], x[1]))\n    best_plen = (paths[0][0], paths[0][1])\n    paths = [x for x in paths if (x[0], x[1]) == best_plen]\n    res = []\n    for path in paths:\n        tmp_c = path[2]\n        srcaddr = get_source_addr_from_candidate_set(dst, tmp_c[1])\n        if srcaddr is not None:\n            res.append((path[0], path[1], (tmp_c[0], srcaddr, tmp_c[2])))\n    if res == []:\n        warning(\"Found a route for IPv6 destination '%s', but no possible source address.\", dst)\n        return (conf.loopback_name, '::', '::')\n    if len(res) > 1:\n        tmp = []\n        if in6_isgladdr(dst) and in6_isaddr6to4(dst):\n            tmp = [x for x in res if in6_isaddr6to4(x[2][1])]\n        elif in6_ismaddr(dst) or in6_islladdr(dst):\n            tmp = [x for x in res if x[2][0] == conf.iface]\n        if tmp:\n            res = tmp\n    k = dst\n    if dev is not None:\n        k = dst + '%%' + dev\n    self.cache[k] = res[0][2]\n    return res[0][2]",
        "mutated": [
            "def route(self, dst='', dev=None, verbose=conf.verb):\n    if False:\n        i = 10\n    \"\\n        Provide best route to IPv6 destination address, based on Scapy\\n        internal routing table content.\\n\\n        When a set of address is passed (e.g. ``2001:db8:cafe:*::1-5``) an\\n        address of the set is used. Be aware of that behavior when using\\n        wildcards in upper parts of addresses !\\n\\n        If 'dst' parameter is a FQDN, name resolution is performed and result\\n        is used.\\n\\n        if optional 'dev' parameter is provided a specific interface, filtering\\n        is performed to limit search to route associated to that interface.\\n        \"\n    dst = dst or '::/0'\n    dst = dst.split('/')[0]\n    savedst = dst\n    dst = dst.replace('*', '0')\n    idx = dst.find('-')\n    while idx >= 0:\n        m = (dst[idx:] + ':').find(':')\n        dst = dst[:idx] + dst[idx + m:]\n        idx = dst.find('-')\n    try:\n        inet_pton(socket.AF_INET6, dst)\n    except socket.error:\n        dst = socket.getaddrinfo(savedst, None, socket.AF_INET6)[0][-1][0]\n    if dev is None and (in6_islladdr(dst) or in6_ismlladdr(dst)):\n        dev = conf.iface\n        if dev not in self.ipv6_ifaces and self.ipv6_ifaces:\n            tmp_routes = [route for route in self.routes if route[3] != conf.iface]\n            default_routes = [route for route in tmp_routes if (route[0], route[1]) == ('::', 0)]\n            ll_routes = [route for route in tmp_routes if (route[0], route[1]) == ('fe80::', 64)]\n            if default_routes:\n                dev = default_routes[0][3]\n            elif ll_routes:\n                dev = ll_routes[0][3]\n            else:\n                dev = conf.loopback_name\n            warning('The conf.iface interface (%s) does not support IPv6! Using %s instead for routing!' % (conf.iface, dev))\n    k = dst\n    if dev is not None:\n        k = dst + '%%' + dev\n    if k in self.cache:\n        return self.cache[k]\n    paths = []\n    for (p, plen, gw, iface, cset, me) in self.routes:\n        if dev is not None and iface != dev:\n            continue\n        if in6_isincluded(dst, p, plen):\n            paths.append((plen, me, (iface, cset, gw)))\n        elif in6_ismlladdr(dst) and in6_islladdr(p) and in6_islladdr(cset[0]):\n            paths.append((plen, me, (iface, cset, gw)))\n    if not paths:\n        if dst == '::1':\n            return (conf.loopback_name, '::1', '::')\n        else:\n            if verbose:\n                warning('No route found for IPv6 destination %s (no default route?)', dst)\n            return (conf.loopback_name, '::', '::')\n    paths.sort(key=lambda x: (-x[0], x[1]))\n    best_plen = (paths[0][0], paths[0][1])\n    paths = [x for x in paths if (x[0], x[1]) == best_plen]\n    res = []\n    for path in paths:\n        tmp_c = path[2]\n        srcaddr = get_source_addr_from_candidate_set(dst, tmp_c[1])\n        if srcaddr is not None:\n            res.append((path[0], path[1], (tmp_c[0], srcaddr, tmp_c[2])))\n    if res == []:\n        warning(\"Found a route for IPv6 destination '%s', but no possible source address.\", dst)\n        return (conf.loopback_name, '::', '::')\n    if len(res) > 1:\n        tmp = []\n        if in6_isgladdr(dst) and in6_isaddr6to4(dst):\n            tmp = [x for x in res if in6_isaddr6to4(x[2][1])]\n        elif in6_ismaddr(dst) or in6_islladdr(dst):\n            tmp = [x for x in res if x[2][0] == conf.iface]\n        if tmp:\n            res = tmp\n    k = dst\n    if dev is not None:\n        k = dst + '%%' + dev\n    self.cache[k] = res[0][2]\n    return res[0][2]",
            "def route(self, dst='', dev=None, verbose=conf.verb):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Provide best route to IPv6 destination address, based on Scapy\\n        internal routing table content.\\n\\n        When a set of address is passed (e.g. ``2001:db8:cafe:*::1-5``) an\\n        address of the set is used. Be aware of that behavior when using\\n        wildcards in upper parts of addresses !\\n\\n        If 'dst' parameter is a FQDN, name resolution is performed and result\\n        is used.\\n\\n        if optional 'dev' parameter is provided a specific interface, filtering\\n        is performed to limit search to route associated to that interface.\\n        \"\n    dst = dst or '::/0'\n    dst = dst.split('/')[0]\n    savedst = dst\n    dst = dst.replace('*', '0')\n    idx = dst.find('-')\n    while idx >= 0:\n        m = (dst[idx:] + ':').find(':')\n        dst = dst[:idx] + dst[idx + m:]\n        idx = dst.find('-')\n    try:\n        inet_pton(socket.AF_INET6, dst)\n    except socket.error:\n        dst = socket.getaddrinfo(savedst, None, socket.AF_INET6)[0][-1][0]\n    if dev is None and (in6_islladdr(dst) or in6_ismlladdr(dst)):\n        dev = conf.iface\n        if dev not in self.ipv6_ifaces and self.ipv6_ifaces:\n            tmp_routes = [route for route in self.routes if route[3] != conf.iface]\n            default_routes = [route for route in tmp_routes if (route[0], route[1]) == ('::', 0)]\n            ll_routes = [route for route in tmp_routes if (route[0], route[1]) == ('fe80::', 64)]\n            if default_routes:\n                dev = default_routes[0][3]\n            elif ll_routes:\n                dev = ll_routes[0][3]\n            else:\n                dev = conf.loopback_name\n            warning('The conf.iface interface (%s) does not support IPv6! Using %s instead for routing!' % (conf.iface, dev))\n    k = dst\n    if dev is not None:\n        k = dst + '%%' + dev\n    if k in self.cache:\n        return self.cache[k]\n    paths = []\n    for (p, plen, gw, iface, cset, me) in self.routes:\n        if dev is not None and iface != dev:\n            continue\n        if in6_isincluded(dst, p, plen):\n            paths.append((plen, me, (iface, cset, gw)))\n        elif in6_ismlladdr(dst) and in6_islladdr(p) and in6_islladdr(cset[0]):\n            paths.append((plen, me, (iface, cset, gw)))\n    if not paths:\n        if dst == '::1':\n            return (conf.loopback_name, '::1', '::')\n        else:\n            if verbose:\n                warning('No route found for IPv6 destination %s (no default route?)', dst)\n            return (conf.loopback_name, '::', '::')\n    paths.sort(key=lambda x: (-x[0], x[1]))\n    best_plen = (paths[0][0], paths[0][1])\n    paths = [x for x in paths if (x[0], x[1]) == best_plen]\n    res = []\n    for path in paths:\n        tmp_c = path[2]\n        srcaddr = get_source_addr_from_candidate_set(dst, tmp_c[1])\n        if srcaddr is not None:\n            res.append((path[0], path[1], (tmp_c[0], srcaddr, tmp_c[2])))\n    if res == []:\n        warning(\"Found a route for IPv6 destination '%s', but no possible source address.\", dst)\n        return (conf.loopback_name, '::', '::')\n    if len(res) > 1:\n        tmp = []\n        if in6_isgladdr(dst) and in6_isaddr6to4(dst):\n            tmp = [x for x in res if in6_isaddr6to4(x[2][1])]\n        elif in6_ismaddr(dst) or in6_islladdr(dst):\n            tmp = [x for x in res if x[2][0] == conf.iface]\n        if tmp:\n            res = tmp\n    k = dst\n    if dev is not None:\n        k = dst + '%%' + dev\n    self.cache[k] = res[0][2]\n    return res[0][2]",
            "def route(self, dst='', dev=None, verbose=conf.verb):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Provide best route to IPv6 destination address, based on Scapy\\n        internal routing table content.\\n\\n        When a set of address is passed (e.g. ``2001:db8:cafe:*::1-5``) an\\n        address of the set is used. Be aware of that behavior when using\\n        wildcards in upper parts of addresses !\\n\\n        If 'dst' parameter is a FQDN, name resolution is performed and result\\n        is used.\\n\\n        if optional 'dev' parameter is provided a specific interface, filtering\\n        is performed to limit search to route associated to that interface.\\n        \"\n    dst = dst or '::/0'\n    dst = dst.split('/')[0]\n    savedst = dst\n    dst = dst.replace('*', '0')\n    idx = dst.find('-')\n    while idx >= 0:\n        m = (dst[idx:] + ':').find(':')\n        dst = dst[:idx] + dst[idx + m:]\n        idx = dst.find('-')\n    try:\n        inet_pton(socket.AF_INET6, dst)\n    except socket.error:\n        dst = socket.getaddrinfo(savedst, None, socket.AF_INET6)[0][-1][0]\n    if dev is None and (in6_islladdr(dst) or in6_ismlladdr(dst)):\n        dev = conf.iface\n        if dev not in self.ipv6_ifaces and self.ipv6_ifaces:\n            tmp_routes = [route for route in self.routes if route[3] != conf.iface]\n            default_routes = [route for route in tmp_routes if (route[0], route[1]) == ('::', 0)]\n            ll_routes = [route for route in tmp_routes if (route[0], route[1]) == ('fe80::', 64)]\n            if default_routes:\n                dev = default_routes[0][3]\n            elif ll_routes:\n                dev = ll_routes[0][3]\n            else:\n                dev = conf.loopback_name\n            warning('The conf.iface interface (%s) does not support IPv6! Using %s instead for routing!' % (conf.iface, dev))\n    k = dst\n    if dev is not None:\n        k = dst + '%%' + dev\n    if k in self.cache:\n        return self.cache[k]\n    paths = []\n    for (p, plen, gw, iface, cset, me) in self.routes:\n        if dev is not None and iface != dev:\n            continue\n        if in6_isincluded(dst, p, plen):\n            paths.append((plen, me, (iface, cset, gw)))\n        elif in6_ismlladdr(dst) and in6_islladdr(p) and in6_islladdr(cset[0]):\n            paths.append((plen, me, (iface, cset, gw)))\n    if not paths:\n        if dst == '::1':\n            return (conf.loopback_name, '::1', '::')\n        else:\n            if verbose:\n                warning('No route found for IPv6 destination %s (no default route?)', dst)\n            return (conf.loopback_name, '::', '::')\n    paths.sort(key=lambda x: (-x[0], x[1]))\n    best_plen = (paths[0][0], paths[0][1])\n    paths = [x for x in paths if (x[0], x[1]) == best_plen]\n    res = []\n    for path in paths:\n        tmp_c = path[2]\n        srcaddr = get_source_addr_from_candidate_set(dst, tmp_c[1])\n        if srcaddr is not None:\n            res.append((path[0], path[1], (tmp_c[0], srcaddr, tmp_c[2])))\n    if res == []:\n        warning(\"Found a route for IPv6 destination '%s', but no possible source address.\", dst)\n        return (conf.loopback_name, '::', '::')\n    if len(res) > 1:\n        tmp = []\n        if in6_isgladdr(dst) and in6_isaddr6to4(dst):\n            tmp = [x for x in res if in6_isaddr6to4(x[2][1])]\n        elif in6_ismaddr(dst) or in6_islladdr(dst):\n            tmp = [x for x in res if x[2][0] == conf.iface]\n        if tmp:\n            res = tmp\n    k = dst\n    if dev is not None:\n        k = dst + '%%' + dev\n    self.cache[k] = res[0][2]\n    return res[0][2]",
            "def route(self, dst='', dev=None, verbose=conf.verb):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Provide best route to IPv6 destination address, based on Scapy\\n        internal routing table content.\\n\\n        When a set of address is passed (e.g. ``2001:db8:cafe:*::1-5``) an\\n        address of the set is used. Be aware of that behavior when using\\n        wildcards in upper parts of addresses !\\n\\n        If 'dst' parameter is a FQDN, name resolution is performed and result\\n        is used.\\n\\n        if optional 'dev' parameter is provided a specific interface, filtering\\n        is performed to limit search to route associated to that interface.\\n        \"\n    dst = dst or '::/0'\n    dst = dst.split('/')[0]\n    savedst = dst\n    dst = dst.replace('*', '0')\n    idx = dst.find('-')\n    while idx >= 0:\n        m = (dst[idx:] + ':').find(':')\n        dst = dst[:idx] + dst[idx + m:]\n        idx = dst.find('-')\n    try:\n        inet_pton(socket.AF_INET6, dst)\n    except socket.error:\n        dst = socket.getaddrinfo(savedst, None, socket.AF_INET6)[0][-1][0]\n    if dev is None and (in6_islladdr(dst) or in6_ismlladdr(dst)):\n        dev = conf.iface\n        if dev not in self.ipv6_ifaces and self.ipv6_ifaces:\n            tmp_routes = [route for route in self.routes if route[3] != conf.iface]\n            default_routes = [route for route in tmp_routes if (route[0], route[1]) == ('::', 0)]\n            ll_routes = [route for route in tmp_routes if (route[0], route[1]) == ('fe80::', 64)]\n            if default_routes:\n                dev = default_routes[0][3]\n            elif ll_routes:\n                dev = ll_routes[0][3]\n            else:\n                dev = conf.loopback_name\n            warning('The conf.iface interface (%s) does not support IPv6! Using %s instead for routing!' % (conf.iface, dev))\n    k = dst\n    if dev is not None:\n        k = dst + '%%' + dev\n    if k in self.cache:\n        return self.cache[k]\n    paths = []\n    for (p, plen, gw, iface, cset, me) in self.routes:\n        if dev is not None and iface != dev:\n            continue\n        if in6_isincluded(dst, p, plen):\n            paths.append((plen, me, (iface, cset, gw)))\n        elif in6_ismlladdr(dst) and in6_islladdr(p) and in6_islladdr(cset[0]):\n            paths.append((plen, me, (iface, cset, gw)))\n    if not paths:\n        if dst == '::1':\n            return (conf.loopback_name, '::1', '::')\n        else:\n            if verbose:\n                warning('No route found for IPv6 destination %s (no default route?)', dst)\n            return (conf.loopback_name, '::', '::')\n    paths.sort(key=lambda x: (-x[0], x[1]))\n    best_plen = (paths[0][0], paths[0][1])\n    paths = [x for x in paths if (x[0], x[1]) == best_plen]\n    res = []\n    for path in paths:\n        tmp_c = path[2]\n        srcaddr = get_source_addr_from_candidate_set(dst, tmp_c[1])\n        if srcaddr is not None:\n            res.append((path[0], path[1], (tmp_c[0], srcaddr, tmp_c[2])))\n    if res == []:\n        warning(\"Found a route for IPv6 destination '%s', but no possible source address.\", dst)\n        return (conf.loopback_name, '::', '::')\n    if len(res) > 1:\n        tmp = []\n        if in6_isgladdr(dst) and in6_isaddr6to4(dst):\n            tmp = [x for x in res if in6_isaddr6to4(x[2][1])]\n        elif in6_ismaddr(dst) or in6_islladdr(dst):\n            tmp = [x for x in res if x[2][0] == conf.iface]\n        if tmp:\n            res = tmp\n    k = dst\n    if dev is not None:\n        k = dst + '%%' + dev\n    self.cache[k] = res[0][2]\n    return res[0][2]",
            "def route(self, dst='', dev=None, verbose=conf.verb):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Provide best route to IPv6 destination address, based on Scapy\\n        internal routing table content.\\n\\n        When a set of address is passed (e.g. ``2001:db8:cafe:*::1-5``) an\\n        address of the set is used. Be aware of that behavior when using\\n        wildcards in upper parts of addresses !\\n\\n        If 'dst' parameter is a FQDN, name resolution is performed and result\\n        is used.\\n\\n        if optional 'dev' parameter is provided a specific interface, filtering\\n        is performed to limit search to route associated to that interface.\\n        \"\n    dst = dst or '::/0'\n    dst = dst.split('/')[0]\n    savedst = dst\n    dst = dst.replace('*', '0')\n    idx = dst.find('-')\n    while idx >= 0:\n        m = (dst[idx:] + ':').find(':')\n        dst = dst[:idx] + dst[idx + m:]\n        idx = dst.find('-')\n    try:\n        inet_pton(socket.AF_INET6, dst)\n    except socket.error:\n        dst = socket.getaddrinfo(savedst, None, socket.AF_INET6)[0][-1][0]\n    if dev is None and (in6_islladdr(dst) or in6_ismlladdr(dst)):\n        dev = conf.iface\n        if dev not in self.ipv6_ifaces and self.ipv6_ifaces:\n            tmp_routes = [route for route in self.routes if route[3] != conf.iface]\n            default_routes = [route for route in tmp_routes if (route[0], route[1]) == ('::', 0)]\n            ll_routes = [route for route in tmp_routes if (route[0], route[1]) == ('fe80::', 64)]\n            if default_routes:\n                dev = default_routes[0][3]\n            elif ll_routes:\n                dev = ll_routes[0][3]\n            else:\n                dev = conf.loopback_name\n            warning('The conf.iface interface (%s) does not support IPv6! Using %s instead for routing!' % (conf.iface, dev))\n    k = dst\n    if dev is not None:\n        k = dst + '%%' + dev\n    if k in self.cache:\n        return self.cache[k]\n    paths = []\n    for (p, plen, gw, iface, cset, me) in self.routes:\n        if dev is not None and iface != dev:\n            continue\n        if in6_isincluded(dst, p, plen):\n            paths.append((plen, me, (iface, cset, gw)))\n        elif in6_ismlladdr(dst) and in6_islladdr(p) and in6_islladdr(cset[0]):\n            paths.append((plen, me, (iface, cset, gw)))\n    if not paths:\n        if dst == '::1':\n            return (conf.loopback_name, '::1', '::')\n        else:\n            if verbose:\n                warning('No route found for IPv6 destination %s (no default route?)', dst)\n            return (conf.loopback_name, '::', '::')\n    paths.sort(key=lambda x: (-x[0], x[1]))\n    best_plen = (paths[0][0], paths[0][1])\n    paths = [x for x in paths if (x[0], x[1]) == best_plen]\n    res = []\n    for path in paths:\n        tmp_c = path[2]\n        srcaddr = get_source_addr_from_candidate_set(dst, tmp_c[1])\n        if srcaddr is not None:\n            res.append((path[0], path[1], (tmp_c[0], srcaddr, tmp_c[2])))\n    if res == []:\n        warning(\"Found a route for IPv6 destination '%s', but no possible source address.\", dst)\n        return (conf.loopback_name, '::', '::')\n    if len(res) > 1:\n        tmp = []\n        if in6_isgladdr(dst) and in6_isaddr6to4(dst):\n            tmp = [x for x in res if in6_isaddr6to4(x[2][1])]\n        elif in6_ismaddr(dst) or in6_islladdr(dst):\n            tmp = [x for x in res if x[2][0] == conf.iface]\n        if tmp:\n            res = tmp\n    k = dst\n    if dev is not None:\n        k = dst + '%%' + dev\n    self.cache[k] = res[0][2]\n    return res[0][2]"
        ]
    }
]