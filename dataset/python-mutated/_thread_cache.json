[
    {
        "func_name": "_to_os_thread_name",
        "original": "def _to_os_thread_name(name: str) -> bytes:\n    return name.encode('ascii', errors='replace')[:15]",
        "mutated": [
            "def _to_os_thread_name(name: str) -> bytes:\n    if False:\n        i = 10\n    return name.encode('ascii', errors='replace')[:15]",
            "def _to_os_thread_name(name: str) -> bytes:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return name.encode('ascii', errors='replace')[:15]",
            "def _to_os_thread_name(name: str) -> bytes:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return name.encode('ascii', errors='replace')[:15]",
            "def _to_os_thread_name(name: str) -> bytes:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return name.encode('ascii', errors='replace')[:15]",
            "def _to_os_thread_name(name: str) -> bytes:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return name.encode('ascii', errors='replace')[:15]"
        ]
    },
    {
        "func_name": "namefunc",
        "original": "def namefunc(setname: Callable[[int, bytes], int], ident: int | None, name: str) -> None:\n    if ident is not None:\n        setname(ident, _to_os_thread_name(name))",
        "mutated": [
            "def namefunc(setname: Callable[[int, bytes], int], ident: int | None, name: str) -> None:\n    if False:\n        i = 10\n    if ident is not None:\n        setname(ident, _to_os_thread_name(name))",
            "def namefunc(setname: Callable[[int, bytes], int], ident: int | None, name: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if ident is not None:\n        setname(ident, _to_os_thread_name(name))",
            "def namefunc(setname: Callable[[int, bytes], int], ident: int | None, name: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if ident is not None:\n        setname(ident, _to_os_thread_name(name))",
            "def namefunc(setname: Callable[[int, bytes], int], ident: int | None, name: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if ident is not None:\n        setname(ident, _to_os_thread_name(name))",
            "def namefunc(setname: Callable[[int, bytes], int], ident: int | None, name: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if ident is not None:\n        setname(ident, _to_os_thread_name(name))"
        ]
    },
    {
        "func_name": "darwin_namefunc",
        "original": "def darwin_namefunc(setname: Callable[[bytes], int], ident: int | None, name: str) -> None:\n    if ident is not None:\n        setname(_to_os_thread_name(name))",
        "mutated": [
            "def darwin_namefunc(setname: Callable[[bytes], int], ident: int | None, name: str) -> None:\n    if False:\n        i = 10\n    if ident is not None:\n        setname(_to_os_thread_name(name))",
            "def darwin_namefunc(setname: Callable[[bytes], int], ident: int | None, name: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if ident is not None:\n        setname(_to_os_thread_name(name))",
            "def darwin_namefunc(setname: Callable[[bytes], int], ident: int | None, name: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if ident is not None:\n        setname(_to_os_thread_name(name))",
            "def darwin_namefunc(setname: Callable[[bytes], int], ident: int | None, name: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if ident is not None:\n        setname(_to_os_thread_name(name))",
            "def darwin_namefunc(setname: Callable[[bytes], int], ident: int | None, name: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if ident is not None:\n        setname(_to_os_thread_name(name))"
        ]
    },
    {
        "func_name": "get_os_thread_name_func",
        "original": "def get_os_thread_name_func() -> Callable[[int | None, str], None] | None:\n\n    def namefunc(setname: Callable[[int, bytes], int], ident: int | None, name: str) -> None:\n        if ident is not None:\n            setname(ident, _to_os_thread_name(name))\n\n    def darwin_namefunc(setname: Callable[[bytes], int], ident: int | None, name: str) -> None:\n        if ident is not None:\n            setname(_to_os_thread_name(name))\n    libpthread_path = ctypes.util.find_library('pthread')\n    if not libpthread_path:\n        return None\n    try:\n        libpthread = ctypes.CDLL(libpthread_path)\n    except Exception:\n        return None\n    pthread_setname_np = getattr(libpthread, 'pthread_setname_np', None)\n    if pthread_setname_np is None:\n        return None\n    pthread_setname_np.restype = ctypes.c_int\n    if sys.platform == 'darwin':\n        pthread_setname_np.argtypes = [ctypes.c_char_p]\n        return partial(darwin_namefunc, pthread_setname_np)\n    pthread_setname_np.argtypes = [ctypes.c_void_p, ctypes.c_char_p]\n    return partial(namefunc, pthread_setname_np)",
        "mutated": [
            "def get_os_thread_name_func() -> Callable[[int | None, str], None] | None:\n    if False:\n        i = 10\n\n    def namefunc(setname: Callable[[int, bytes], int], ident: int | None, name: str) -> None:\n        if ident is not None:\n            setname(ident, _to_os_thread_name(name))\n\n    def darwin_namefunc(setname: Callable[[bytes], int], ident: int | None, name: str) -> None:\n        if ident is not None:\n            setname(_to_os_thread_name(name))\n    libpthread_path = ctypes.util.find_library('pthread')\n    if not libpthread_path:\n        return None\n    try:\n        libpthread = ctypes.CDLL(libpthread_path)\n    except Exception:\n        return None\n    pthread_setname_np = getattr(libpthread, 'pthread_setname_np', None)\n    if pthread_setname_np is None:\n        return None\n    pthread_setname_np.restype = ctypes.c_int\n    if sys.platform == 'darwin':\n        pthread_setname_np.argtypes = [ctypes.c_char_p]\n        return partial(darwin_namefunc, pthread_setname_np)\n    pthread_setname_np.argtypes = [ctypes.c_void_p, ctypes.c_char_p]\n    return partial(namefunc, pthread_setname_np)",
            "def get_os_thread_name_func() -> Callable[[int | None, str], None] | None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def namefunc(setname: Callable[[int, bytes], int], ident: int | None, name: str) -> None:\n        if ident is not None:\n            setname(ident, _to_os_thread_name(name))\n\n    def darwin_namefunc(setname: Callable[[bytes], int], ident: int | None, name: str) -> None:\n        if ident is not None:\n            setname(_to_os_thread_name(name))\n    libpthread_path = ctypes.util.find_library('pthread')\n    if not libpthread_path:\n        return None\n    try:\n        libpthread = ctypes.CDLL(libpthread_path)\n    except Exception:\n        return None\n    pthread_setname_np = getattr(libpthread, 'pthread_setname_np', None)\n    if pthread_setname_np is None:\n        return None\n    pthread_setname_np.restype = ctypes.c_int\n    if sys.platform == 'darwin':\n        pthread_setname_np.argtypes = [ctypes.c_char_p]\n        return partial(darwin_namefunc, pthread_setname_np)\n    pthread_setname_np.argtypes = [ctypes.c_void_p, ctypes.c_char_p]\n    return partial(namefunc, pthread_setname_np)",
            "def get_os_thread_name_func() -> Callable[[int | None, str], None] | None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def namefunc(setname: Callable[[int, bytes], int], ident: int | None, name: str) -> None:\n        if ident is not None:\n            setname(ident, _to_os_thread_name(name))\n\n    def darwin_namefunc(setname: Callable[[bytes], int], ident: int | None, name: str) -> None:\n        if ident is not None:\n            setname(_to_os_thread_name(name))\n    libpthread_path = ctypes.util.find_library('pthread')\n    if not libpthread_path:\n        return None\n    try:\n        libpthread = ctypes.CDLL(libpthread_path)\n    except Exception:\n        return None\n    pthread_setname_np = getattr(libpthread, 'pthread_setname_np', None)\n    if pthread_setname_np is None:\n        return None\n    pthread_setname_np.restype = ctypes.c_int\n    if sys.platform == 'darwin':\n        pthread_setname_np.argtypes = [ctypes.c_char_p]\n        return partial(darwin_namefunc, pthread_setname_np)\n    pthread_setname_np.argtypes = [ctypes.c_void_p, ctypes.c_char_p]\n    return partial(namefunc, pthread_setname_np)",
            "def get_os_thread_name_func() -> Callable[[int | None, str], None] | None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def namefunc(setname: Callable[[int, bytes], int], ident: int | None, name: str) -> None:\n        if ident is not None:\n            setname(ident, _to_os_thread_name(name))\n\n    def darwin_namefunc(setname: Callable[[bytes], int], ident: int | None, name: str) -> None:\n        if ident is not None:\n            setname(_to_os_thread_name(name))\n    libpthread_path = ctypes.util.find_library('pthread')\n    if not libpthread_path:\n        return None\n    try:\n        libpthread = ctypes.CDLL(libpthread_path)\n    except Exception:\n        return None\n    pthread_setname_np = getattr(libpthread, 'pthread_setname_np', None)\n    if pthread_setname_np is None:\n        return None\n    pthread_setname_np.restype = ctypes.c_int\n    if sys.platform == 'darwin':\n        pthread_setname_np.argtypes = [ctypes.c_char_p]\n        return partial(darwin_namefunc, pthread_setname_np)\n    pthread_setname_np.argtypes = [ctypes.c_void_p, ctypes.c_char_p]\n    return partial(namefunc, pthread_setname_np)",
            "def get_os_thread_name_func() -> Callable[[int | None, str], None] | None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def namefunc(setname: Callable[[int, bytes], int], ident: int | None, name: str) -> None:\n        if ident is not None:\n            setname(ident, _to_os_thread_name(name))\n\n    def darwin_namefunc(setname: Callable[[bytes], int], ident: int | None, name: str) -> None:\n        if ident is not None:\n            setname(_to_os_thread_name(name))\n    libpthread_path = ctypes.util.find_library('pthread')\n    if not libpthread_path:\n        return None\n    try:\n        libpthread = ctypes.CDLL(libpthread_path)\n    except Exception:\n        return None\n    pthread_setname_np = getattr(libpthread, 'pthread_setname_np', None)\n    if pthread_setname_np is None:\n        return None\n    pthread_setname_np.restype = ctypes.c_int\n    if sys.platform == 'darwin':\n        pthread_setname_np.argtypes = [ctypes.c_char_p]\n        return partial(darwin_namefunc, pthread_setname_np)\n    pthread_setname_np.argtypes = [ctypes.c_void_p, ctypes.c_char_p]\n    return partial(namefunc, pthread_setname_np)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, thread_cache: ThreadCache) -> None:\n    self._job: tuple[Callable[[], RetT], Callable[[outcome.Outcome[RetT]], object], str | None] | None = None\n    self._thread_cache = thread_cache\n    self._worker_lock = Lock()\n    self._worker_lock.acquire()\n    self._default_name = f'Trio thread {next(name_counter)}'\n    self._thread = Thread(target=self._work, name=self._default_name, daemon=True)\n    if set_os_thread_name:\n        set_os_thread_name(self._thread.ident, self._default_name)\n    self._thread.start()",
        "mutated": [
            "def __init__(self, thread_cache: ThreadCache) -> None:\n    if False:\n        i = 10\n    self._job: tuple[Callable[[], RetT], Callable[[outcome.Outcome[RetT]], object], str | None] | None = None\n    self._thread_cache = thread_cache\n    self._worker_lock = Lock()\n    self._worker_lock.acquire()\n    self._default_name = f'Trio thread {next(name_counter)}'\n    self._thread = Thread(target=self._work, name=self._default_name, daemon=True)\n    if set_os_thread_name:\n        set_os_thread_name(self._thread.ident, self._default_name)\n    self._thread.start()",
            "def __init__(self, thread_cache: ThreadCache) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._job: tuple[Callable[[], RetT], Callable[[outcome.Outcome[RetT]], object], str | None] | None = None\n    self._thread_cache = thread_cache\n    self._worker_lock = Lock()\n    self._worker_lock.acquire()\n    self._default_name = f'Trio thread {next(name_counter)}'\n    self._thread = Thread(target=self._work, name=self._default_name, daemon=True)\n    if set_os_thread_name:\n        set_os_thread_name(self._thread.ident, self._default_name)\n    self._thread.start()",
            "def __init__(self, thread_cache: ThreadCache) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._job: tuple[Callable[[], RetT], Callable[[outcome.Outcome[RetT]], object], str | None] | None = None\n    self._thread_cache = thread_cache\n    self._worker_lock = Lock()\n    self._worker_lock.acquire()\n    self._default_name = f'Trio thread {next(name_counter)}'\n    self._thread = Thread(target=self._work, name=self._default_name, daemon=True)\n    if set_os_thread_name:\n        set_os_thread_name(self._thread.ident, self._default_name)\n    self._thread.start()",
            "def __init__(self, thread_cache: ThreadCache) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._job: tuple[Callable[[], RetT], Callable[[outcome.Outcome[RetT]], object], str | None] | None = None\n    self._thread_cache = thread_cache\n    self._worker_lock = Lock()\n    self._worker_lock.acquire()\n    self._default_name = f'Trio thread {next(name_counter)}'\n    self._thread = Thread(target=self._work, name=self._default_name, daemon=True)\n    if set_os_thread_name:\n        set_os_thread_name(self._thread.ident, self._default_name)\n    self._thread.start()",
            "def __init__(self, thread_cache: ThreadCache) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._job: tuple[Callable[[], RetT], Callable[[outcome.Outcome[RetT]], object], str | None] | None = None\n    self._thread_cache = thread_cache\n    self._worker_lock = Lock()\n    self._worker_lock.acquire()\n    self._default_name = f'Trio thread {next(name_counter)}'\n    self._thread = Thread(target=self._work, name=self._default_name, daemon=True)\n    if set_os_thread_name:\n        set_os_thread_name(self._thread.ident, self._default_name)\n    self._thread.start()"
        ]
    },
    {
        "func_name": "_handle_job",
        "original": "def _handle_job(self) -> None:\n    assert self._job is not None\n    (fn, deliver, name) = self._job\n    self._job = None\n    if name is not None:\n        self._thread.name = name\n        if set_os_thread_name:\n            set_os_thread_name(self._thread.ident, name)\n    result = outcome.capture(fn)\n    if name is not None:\n        self._thread.name = self._default_name\n        if set_os_thread_name:\n            set_os_thread_name(self._thread.ident, self._default_name)\n    self._thread_cache._idle_workers[self] = None\n    try:\n        deliver(result)\n    except BaseException as e:\n        print('Exception while delivering result of thread', file=sys.stderr)\n        traceback.print_exception(type(e), e, e.__traceback__)",
        "mutated": [
            "def _handle_job(self) -> None:\n    if False:\n        i = 10\n    assert self._job is not None\n    (fn, deliver, name) = self._job\n    self._job = None\n    if name is not None:\n        self._thread.name = name\n        if set_os_thread_name:\n            set_os_thread_name(self._thread.ident, name)\n    result = outcome.capture(fn)\n    if name is not None:\n        self._thread.name = self._default_name\n        if set_os_thread_name:\n            set_os_thread_name(self._thread.ident, self._default_name)\n    self._thread_cache._idle_workers[self] = None\n    try:\n        deliver(result)\n    except BaseException as e:\n        print('Exception while delivering result of thread', file=sys.stderr)\n        traceback.print_exception(type(e), e, e.__traceback__)",
            "def _handle_job(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert self._job is not None\n    (fn, deliver, name) = self._job\n    self._job = None\n    if name is not None:\n        self._thread.name = name\n        if set_os_thread_name:\n            set_os_thread_name(self._thread.ident, name)\n    result = outcome.capture(fn)\n    if name is not None:\n        self._thread.name = self._default_name\n        if set_os_thread_name:\n            set_os_thread_name(self._thread.ident, self._default_name)\n    self._thread_cache._idle_workers[self] = None\n    try:\n        deliver(result)\n    except BaseException as e:\n        print('Exception while delivering result of thread', file=sys.stderr)\n        traceback.print_exception(type(e), e, e.__traceback__)",
            "def _handle_job(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert self._job is not None\n    (fn, deliver, name) = self._job\n    self._job = None\n    if name is not None:\n        self._thread.name = name\n        if set_os_thread_name:\n            set_os_thread_name(self._thread.ident, name)\n    result = outcome.capture(fn)\n    if name is not None:\n        self._thread.name = self._default_name\n        if set_os_thread_name:\n            set_os_thread_name(self._thread.ident, self._default_name)\n    self._thread_cache._idle_workers[self] = None\n    try:\n        deliver(result)\n    except BaseException as e:\n        print('Exception while delivering result of thread', file=sys.stderr)\n        traceback.print_exception(type(e), e, e.__traceback__)",
            "def _handle_job(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert self._job is not None\n    (fn, deliver, name) = self._job\n    self._job = None\n    if name is not None:\n        self._thread.name = name\n        if set_os_thread_name:\n            set_os_thread_name(self._thread.ident, name)\n    result = outcome.capture(fn)\n    if name is not None:\n        self._thread.name = self._default_name\n        if set_os_thread_name:\n            set_os_thread_name(self._thread.ident, self._default_name)\n    self._thread_cache._idle_workers[self] = None\n    try:\n        deliver(result)\n    except BaseException as e:\n        print('Exception while delivering result of thread', file=sys.stderr)\n        traceback.print_exception(type(e), e, e.__traceback__)",
            "def _handle_job(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert self._job is not None\n    (fn, deliver, name) = self._job\n    self._job = None\n    if name is not None:\n        self._thread.name = name\n        if set_os_thread_name:\n            set_os_thread_name(self._thread.ident, name)\n    result = outcome.capture(fn)\n    if name is not None:\n        self._thread.name = self._default_name\n        if set_os_thread_name:\n            set_os_thread_name(self._thread.ident, self._default_name)\n    self._thread_cache._idle_workers[self] = None\n    try:\n        deliver(result)\n    except BaseException as e:\n        print('Exception while delivering result of thread', file=sys.stderr)\n        traceback.print_exception(type(e), e, e.__traceback__)"
        ]
    },
    {
        "func_name": "_work",
        "original": "def _work(self) -> None:\n    while True:\n        if self._worker_lock.acquire(timeout=IDLE_TIMEOUT):\n            self._handle_job()\n        else:\n            try:\n                del self._thread_cache._idle_workers[self]\n            except KeyError:\n                continue\n            else:\n                return",
        "mutated": [
            "def _work(self) -> None:\n    if False:\n        i = 10\n    while True:\n        if self._worker_lock.acquire(timeout=IDLE_TIMEOUT):\n            self._handle_job()\n        else:\n            try:\n                del self._thread_cache._idle_workers[self]\n            except KeyError:\n                continue\n            else:\n                return",
            "def _work(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    while True:\n        if self._worker_lock.acquire(timeout=IDLE_TIMEOUT):\n            self._handle_job()\n        else:\n            try:\n                del self._thread_cache._idle_workers[self]\n            except KeyError:\n                continue\n            else:\n                return",
            "def _work(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    while True:\n        if self._worker_lock.acquire(timeout=IDLE_TIMEOUT):\n            self._handle_job()\n        else:\n            try:\n                del self._thread_cache._idle_workers[self]\n            except KeyError:\n                continue\n            else:\n                return",
            "def _work(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    while True:\n        if self._worker_lock.acquire(timeout=IDLE_TIMEOUT):\n            self._handle_job()\n        else:\n            try:\n                del self._thread_cache._idle_workers[self]\n            except KeyError:\n                continue\n            else:\n                return",
            "def _work(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    while True:\n        if self._worker_lock.acquire(timeout=IDLE_TIMEOUT):\n            self._handle_job()\n        else:\n            try:\n                del self._thread_cache._idle_workers[self]\n            except KeyError:\n                continue\n            else:\n                return"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self) -> None:\n    self._idle_workers: dict[WorkerThread[Any], None] = {}",
        "mutated": [
            "def __init__(self) -> None:\n    if False:\n        i = 10\n    self._idle_workers: dict[WorkerThread[Any], None] = {}",
            "def __init__(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._idle_workers: dict[WorkerThread[Any], None] = {}",
            "def __init__(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._idle_workers: dict[WorkerThread[Any], None] = {}",
            "def __init__(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._idle_workers: dict[WorkerThread[Any], None] = {}",
            "def __init__(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._idle_workers: dict[WorkerThread[Any], None] = {}"
        ]
    },
    {
        "func_name": "start_thread_soon",
        "original": "def start_thread_soon(self, fn: Callable[[], RetT], deliver: Callable[[outcome.Outcome[RetT]], object], name: str | None=None) -> None:\n    worker: WorkerThread[RetT]\n    try:\n        (worker, _) = self._idle_workers.popitem()\n    except KeyError:\n        worker = WorkerThread(self)\n    worker._job = (fn, deliver, name)\n    worker._worker_lock.release()",
        "mutated": [
            "def start_thread_soon(self, fn: Callable[[], RetT], deliver: Callable[[outcome.Outcome[RetT]], object], name: str | None=None) -> None:\n    if False:\n        i = 10\n    worker: WorkerThread[RetT]\n    try:\n        (worker, _) = self._idle_workers.popitem()\n    except KeyError:\n        worker = WorkerThread(self)\n    worker._job = (fn, deliver, name)\n    worker._worker_lock.release()",
            "def start_thread_soon(self, fn: Callable[[], RetT], deliver: Callable[[outcome.Outcome[RetT]], object], name: str | None=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    worker: WorkerThread[RetT]\n    try:\n        (worker, _) = self._idle_workers.popitem()\n    except KeyError:\n        worker = WorkerThread(self)\n    worker._job = (fn, deliver, name)\n    worker._worker_lock.release()",
            "def start_thread_soon(self, fn: Callable[[], RetT], deliver: Callable[[outcome.Outcome[RetT]], object], name: str | None=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    worker: WorkerThread[RetT]\n    try:\n        (worker, _) = self._idle_workers.popitem()\n    except KeyError:\n        worker = WorkerThread(self)\n    worker._job = (fn, deliver, name)\n    worker._worker_lock.release()",
            "def start_thread_soon(self, fn: Callable[[], RetT], deliver: Callable[[outcome.Outcome[RetT]], object], name: str | None=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    worker: WorkerThread[RetT]\n    try:\n        (worker, _) = self._idle_workers.popitem()\n    except KeyError:\n        worker = WorkerThread(self)\n    worker._job = (fn, deliver, name)\n    worker._worker_lock.release()",
            "def start_thread_soon(self, fn: Callable[[], RetT], deliver: Callable[[outcome.Outcome[RetT]], object], name: str | None=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    worker: WorkerThread[RetT]\n    try:\n        (worker, _) = self._idle_workers.popitem()\n    except KeyError:\n        worker = WorkerThread(self)\n    worker._job = (fn, deliver, name)\n    worker._worker_lock.release()"
        ]
    },
    {
        "func_name": "start_thread_soon",
        "original": "def start_thread_soon(fn: Callable[[], RetT], deliver: Callable[[outcome.Outcome[RetT]], object], name: str | None=None) -> None:\n    \"\"\"Runs ``deliver(outcome.capture(fn))`` in a worker thread.\n\n    Generally ``fn`` does some blocking work, and ``deliver`` delivers the\n    result back to whoever is interested.\n\n    This is a low-level, no-frills interface, very similar to using\n    `threading.Thread` to spawn a thread directly. The main difference is\n    that this function tries to reuse threads when possible, so it can be\n    a bit faster than `threading.Thread`.\n\n    Worker threads have the `~threading.Thread.daemon` flag set, which means\n    that if your main thread exits, worker threads will automatically be\n    killed. If you want to make sure that your ``fn`` runs to completion, then\n    you should make sure that the main thread remains alive until ``deliver``\n    is called.\n\n    It is safe to call this function simultaneously from multiple threads.\n\n    Args:\n\n        fn (sync function): Performs arbitrary blocking work.\n\n        deliver (sync function): Takes the `outcome.Outcome` of ``fn``, and\n          delivers it. *Must not block.*\n\n    Because worker threads are cached and reused for multiple calls, neither\n    function should mutate thread-level state, like `threading.local` objects\n    \u2013 or if they do, they should be careful to revert their changes before\n    returning.\n\n    Note:\n\n        The split between ``fn`` and ``deliver`` serves two purposes. First,\n        it's convenient, since most callers need something like this anyway.\n\n        Second, it avoids a small race condition that could cause too many\n        threads to be spawned. Consider a program that wants to run several\n        jobs sequentially on a thread, so the main thread submits a job, waits\n        for it to finish, submits another job, etc. In theory, this program\n        should only need one worker thread. But what could happen is:\n\n        1. Worker thread: First job finishes, and calls ``deliver``.\n\n        2. Main thread: receives notification that the job finished, and calls\n           ``start_thread_soon``.\n\n        3. Main thread: sees that no worker threads are marked idle, so spawns\n           a second worker thread.\n\n        4. Original worker thread: marks itself as idle.\n\n        To avoid this, threads mark themselves as idle *before* calling\n        ``deliver``.\n\n        Is this potential extra thread a major problem? Maybe not, but it's\n        easy enough to avoid, and we figure that if the user is trying to\n        limit how many threads they're using then it's polite to respect that.\n\n    \"\"\"\n    THREAD_CACHE.start_thread_soon(fn, deliver, name)",
        "mutated": [
            "def start_thread_soon(fn: Callable[[], RetT], deliver: Callable[[outcome.Outcome[RetT]], object], name: str | None=None) -> None:\n    if False:\n        i = 10\n    \"Runs ``deliver(outcome.capture(fn))`` in a worker thread.\\n\\n    Generally ``fn`` does some blocking work, and ``deliver`` delivers the\\n    result back to whoever is interested.\\n\\n    This is a low-level, no-frills interface, very similar to using\\n    `threading.Thread` to spawn a thread directly. The main difference is\\n    that this function tries to reuse threads when possible, so it can be\\n    a bit faster than `threading.Thread`.\\n\\n    Worker threads have the `~threading.Thread.daemon` flag set, which means\\n    that if your main thread exits, worker threads will automatically be\\n    killed. If you want to make sure that your ``fn`` runs to completion, then\\n    you should make sure that the main thread remains alive until ``deliver``\\n    is called.\\n\\n    It is safe to call this function simultaneously from multiple threads.\\n\\n    Args:\\n\\n        fn (sync function): Performs arbitrary blocking work.\\n\\n        deliver (sync function): Takes the `outcome.Outcome` of ``fn``, and\\n          delivers it. *Must not block.*\\n\\n    Because worker threads are cached and reused for multiple calls, neither\\n    function should mutate thread-level state, like `threading.local` objects\\n    \u2013 or if they do, they should be careful to revert their changes before\\n    returning.\\n\\n    Note:\\n\\n        The split between ``fn`` and ``deliver`` serves two purposes. First,\\n        it's convenient, since most callers need something like this anyway.\\n\\n        Second, it avoids a small race condition that could cause too many\\n        threads to be spawned. Consider a program that wants to run several\\n        jobs sequentially on a thread, so the main thread submits a job, waits\\n        for it to finish, submits another job, etc. In theory, this program\\n        should only need one worker thread. But what could happen is:\\n\\n        1. Worker thread: First job finishes, and calls ``deliver``.\\n\\n        2. Main thread: receives notification that the job finished, and calls\\n           ``start_thread_soon``.\\n\\n        3. Main thread: sees that no worker threads are marked idle, so spawns\\n           a second worker thread.\\n\\n        4. Original worker thread: marks itself as idle.\\n\\n        To avoid this, threads mark themselves as idle *before* calling\\n        ``deliver``.\\n\\n        Is this potential extra thread a major problem? Maybe not, but it's\\n        easy enough to avoid, and we figure that if the user is trying to\\n        limit how many threads they're using then it's polite to respect that.\\n\\n    \"\n    THREAD_CACHE.start_thread_soon(fn, deliver, name)",
            "def start_thread_soon(fn: Callable[[], RetT], deliver: Callable[[outcome.Outcome[RetT]], object], name: str | None=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Runs ``deliver(outcome.capture(fn))`` in a worker thread.\\n\\n    Generally ``fn`` does some blocking work, and ``deliver`` delivers the\\n    result back to whoever is interested.\\n\\n    This is a low-level, no-frills interface, very similar to using\\n    `threading.Thread` to spawn a thread directly. The main difference is\\n    that this function tries to reuse threads when possible, so it can be\\n    a bit faster than `threading.Thread`.\\n\\n    Worker threads have the `~threading.Thread.daemon` flag set, which means\\n    that if your main thread exits, worker threads will automatically be\\n    killed. If you want to make sure that your ``fn`` runs to completion, then\\n    you should make sure that the main thread remains alive until ``deliver``\\n    is called.\\n\\n    It is safe to call this function simultaneously from multiple threads.\\n\\n    Args:\\n\\n        fn (sync function): Performs arbitrary blocking work.\\n\\n        deliver (sync function): Takes the `outcome.Outcome` of ``fn``, and\\n          delivers it. *Must not block.*\\n\\n    Because worker threads are cached and reused for multiple calls, neither\\n    function should mutate thread-level state, like `threading.local` objects\\n    \u2013 or if they do, they should be careful to revert their changes before\\n    returning.\\n\\n    Note:\\n\\n        The split between ``fn`` and ``deliver`` serves two purposes. First,\\n        it's convenient, since most callers need something like this anyway.\\n\\n        Second, it avoids a small race condition that could cause too many\\n        threads to be spawned. Consider a program that wants to run several\\n        jobs sequentially on a thread, so the main thread submits a job, waits\\n        for it to finish, submits another job, etc. In theory, this program\\n        should only need one worker thread. But what could happen is:\\n\\n        1. Worker thread: First job finishes, and calls ``deliver``.\\n\\n        2. Main thread: receives notification that the job finished, and calls\\n           ``start_thread_soon``.\\n\\n        3. Main thread: sees that no worker threads are marked idle, so spawns\\n           a second worker thread.\\n\\n        4. Original worker thread: marks itself as idle.\\n\\n        To avoid this, threads mark themselves as idle *before* calling\\n        ``deliver``.\\n\\n        Is this potential extra thread a major problem? Maybe not, but it's\\n        easy enough to avoid, and we figure that if the user is trying to\\n        limit how many threads they're using then it's polite to respect that.\\n\\n    \"\n    THREAD_CACHE.start_thread_soon(fn, deliver, name)",
            "def start_thread_soon(fn: Callable[[], RetT], deliver: Callable[[outcome.Outcome[RetT]], object], name: str | None=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Runs ``deliver(outcome.capture(fn))`` in a worker thread.\\n\\n    Generally ``fn`` does some blocking work, and ``deliver`` delivers the\\n    result back to whoever is interested.\\n\\n    This is a low-level, no-frills interface, very similar to using\\n    `threading.Thread` to spawn a thread directly. The main difference is\\n    that this function tries to reuse threads when possible, so it can be\\n    a bit faster than `threading.Thread`.\\n\\n    Worker threads have the `~threading.Thread.daemon` flag set, which means\\n    that if your main thread exits, worker threads will automatically be\\n    killed. If you want to make sure that your ``fn`` runs to completion, then\\n    you should make sure that the main thread remains alive until ``deliver``\\n    is called.\\n\\n    It is safe to call this function simultaneously from multiple threads.\\n\\n    Args:\\n\\n        fn (sync function): Performs arbitrary blocking work.\\n\\n        deliver (sync function): Takes the `outcome.Outcome` of ``fn``, and\\n          delivers it. *Must not block.*\\n\\n    Because worker threads are cached and reused for multiple calls, neither\\n    function should mutate thread-level state, like `threading.local` objects\\n    \u2013 or if they do, they should be careful to revert their changes before\\n    returning.\\n\\n    Note:\\n\\n        The split between ``fn`` and ``deliver`` serves two purposes. First,\\n        it's convenient, since most callers need something like this anyway.\\n\\n        Second, it avoids a small race condition that could cause too many\\n        threads to be spawned. Consider a program that wants to run several\\n        jobs sequentially on a thread, so the main thread submits a job, waits\\n        for it to finish, submits another job, etc. In theory, this program\\n        should only need one worker thread. But what could happen is:\\n\\n        1. Worker thread: First job finishes, and calls ``deliver``.\\n\\n        2. Main thread: receives notification that the job finished, and calls\\n           ``start_thread_soon``.\\n\\n        3. Main thread: sees that no worker threads are marked idle, so spawns\\n           a second worker thread.\\n\\n        4. Original worker thread: marks itself as idle.\\n\\n        To avoid this, threads mark themselves as idle *before* calling\\n        ``deliver``.\\n\\n        Is this potential extra thread a major problem? Maybe not, but it's\\n        easy enough to avoid, and we figure that if the user is trying to\\n        limit how many threads they're using then it's polite to respect that.\\n\\n    \"\n    THREAD_CACHE.start_thread_soon(fn, deliver, name)",
            "def start_thread_soon(fn: Callable[[], RetT], deliver: Callable[[outcome.Outcome[RetT]], object], name: str | None=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Runs ``deliver(outcome.capture(fn))`` in a worker thread.\\n\\n    Generally ``fn`` does some blocking work, and ``deliver`` delivers the\\n    result back to whoever is interested.\\n\\n    This is a low-level, no-frills interface, very similar to using\\n    `threading.Thread` to spawn a thread directly. The main difference is\\n    that this function tries to reuse threads when possible, so it can be\\n    a bit faster than `threading.Thread`.\\n\\n    Worker threads have the `~threading.Thread.daemon` flag set, which means\\n    that if your main thread exits, worker threads will automatically be\\n    killed. If you want to make sure that your ``fn`` runs to completion, then\\n    you should make sure that the main thread remains alive until ``deliver``\\n    is called.\\n\\n    It is safe to call this function simultaneously from multiple threads.\\n\\n    Args:\\n\\n        fn (sync function): Performs arbitrary blocking work.\\n\\n        deliver (sync function): Takes the `outcome.Outcome` of ``fn``, and\\n          delivers it. *Must not block.*\\n\\n    Because worker threads are cached and reused for multiple calls, neither\\n    function should mutate thread-level state, like `threading.local` objects\\n    \u2013 or if they do, they should be careful to revert their changes before\\n    returning.\\n\\n    Note:\\n\\n        The split between ``fn`` and ``deliver`` serves two purposes. First,\\n        it's convenient, since most callers need something like this anyway.\\n\\n        Second, it avoids a small race condition that could cause too many\\n        threads to be spawned. Consider a program that wants to run several\\n        jobs sequentially on a thread, so the main thread submits a job, waits\\n        for it to finish, submits another job, etc. In theory, this program\\n        should only need one worker thread. But what could happen is:\\n\\n        1. Worker thread: First job finishes, and calls ``deliver``.\\n\\n        2. Main thread: receives notification that the job finished, and calls\\n           ``start_thread_soon``.\\n\\n        3. Main thread: sees that no worker threads are marked idle, so spawns\\n           a second worker thread.\\n\\n        4. Original worker thread: marks itself as idle.\\n\\n        To avoid this, threads mark themselves as idle *before* calling\\n        ``deliver``.\\n\\n        Is this potential extra thread a major problem? Maybe not, but it's\\n        easy enough to avoid, and we figure that if the user is trying to\\n        limit how many threads they're using then it's polite to respect that.\\n\\n    \"\n    THREAD_CACHE.start_thread_soon(fn, deliver, name)",
            "def start_thread_soon(fn: Callable[[], RetT], deliver: Callable[[outcome.Outcome[RetT]], object], name: str | None=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Runs ``deliver(outcome.capture(fn))`` in a worker thread.\\n\\n    Generally ``fn`` does some blocking work, and ``deliver`` delivers the\\n    result back to whoever is interested.\\n\\n    This is a low-level, no-frills interface, very similar to using\\n    `threading.Thread` to spawn a thread directly. The main difference is\\n    that this function tries to reuse threads when possible, so it can be\\n    a bit faster than `threading.Thread`.\\n\\n    Worker threads have the `~threading.Thread.daemon` flag set, which means\\n    that if your main thread exits, worker threads will automatically be\\n    killed. If you want to make sure that your ``fn`` runs to completion, then\\n    you should make sure that the main thread remains alive until ``deliver``\\n    is called.\\n\\n    It is safe to call this function simultaneously from multiple threads.\\n\\n    Args:\\n\\n        fn (sync function): Performs arbitrary blocking work.\\n\\n        deliver (sync function): Takes the `outcome.Outcome` of ``fn``, and\\n          delivers it. *Must not block.*\\n\\n    Because worker threads are cached and reused for multiple calls, neither\\n    function should mutate thread-level state, like `threading.local` objects\\n    \u2013 or if they do, they should be careful to revert their changes before\\n    returning.\\n\\n    Note:\\n\\n        The split between ``fn`` and ``deliver`` serves two purposes. First,\\n        it's convenient, since most callers need something like this anyway.\\n\\n        Second, it avoids a small race condition that could cause too many\\n        threads to be spawned. Consider a program that wants to run several\\n        jobs sequentially on a thread, so the main thread submits a job, waits\\n        for it to finish, submits another job, etc. In theory, this program\\n        should only need one worker thread. But what could happen is:\\n\\n        1. Worker thread: First job finishes, and calls ``deliver``.\\n\\n        2. Main thread: receives notification that the job finished, and calls\\n           ``start_thread_soon``.\\n\\n        3. Main thread: sees that no worker threads are marked idle, so spawns\\n           a second worker thread.\\n\\n        4. Original worker thread: marks itself as idle.\\n\\n        To avoid this, threads mark themselves as idle *before* calling\\n        ``deliver``.\\n\\n        Is this potential extra thread a major problem? Maybe not, but it's\\n        easy enough to avoid, and we figure that if the user is trying to\\n        limit how many threads they're using then it's polite to respect that.\\n\\n    \"\n    THREAD_CACHE.start_thread_soon(fn, deliver, name)"
        ]
    }
]