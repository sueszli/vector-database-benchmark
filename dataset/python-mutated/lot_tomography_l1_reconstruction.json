[
    {
        "func_name": "_weights",
        "original": "def _weights(x, dx=1, orig=0):\n    x = np.ravel(x)\n    floor_x = np.floor((x - orig) / dx).astype(np.int64)\n    alpha = (x - orig - floor_x * dx) / dx\n    return (np.hstack((floor_x, floor_x + 1)), np.hstack((1 - alpha, alpha)))",
        "mutated": [
            "def _weights(x, dx=1, orig=0):\n    if False:\n        i = 10\n    x = np.ravel(x)\n    floor_x = np.floor((x - orig) / dx).astype(np.int64)\n    alpha = (x - orig - floor_x * dx) / dx\n    return (np.hstack((floor_x, floor_x + 1)), np.hstack((1 - alpha, alpha)))",
            "def _weights(x, dx=1, orig=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    x = np.ravel(x)\n    floor_x = np.floor((x - orig) / dx).astype(np.int64)\n    alpha = (x - orig - floor_x * dx) / dx\n    return (np.hstack((floor_x, floor_x + 1)), np.hstack((1 - alpha, alpha)))",
            "def _weights(x, dx=1, orig=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    x = np.ravel(x)\n    floor_x = np.floor((x - orig) / dx).astype(np.int64)\n    alpha = (x - orig - floor_x * dx) / dx\n    return (np.hstack((floor_x, floor_x + 1)), np.hstack((1 - alpha, alpha)))",
            "def _weights(x, dx=1, orig=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    x = np.ravel(x)\n    floor_x = np.floor((x - orig) / dx).astype(np.int64)\n    alpha = (x - orig - floor_x * dx) / dx\n    return (np.hstack((floor_x, floor_x + 1)), np.hstack((1 - alpha, alpha)))",
            "def _weights(x, dx=1, orig=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    x = np.ravel(x)\n    floor_x = np.floor((x - orig) / dx).astype(np.int64)\n    alpha = (x - orig - floor_x * dx) / dx\n    return (np.hstack((floor_x, floor_x + 1)), np.hstack((1 - alpha, alpha)))"
        ]
    },
    {
        "func_name": "_generate_center_coordinates",
        "original": "def _generate_center_coordinates(l_x):\n    (X, Y) = np.mgrid[:l_x, :l_x].astype(np.float64)\n    center = l_x / 2.0\n    X += 0.5 - center\n    Y += 0.5 - center\n    return (X, Y)",
        "mutated": [
            "def _generate_center_coordinates(l_x):\n    if False:\n        i = 10\n    (X, Y) = np.mgrid[:l_x, :l_x].astype(np.float64)\n    center = l_x / 2.0\n    X += 0.5 - center\n    Y += 0.5 - center\n    return (X, Y)",
            "def _generate_center_coordinates(l_x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (X, Y) = np.mgrid[:l_x, :l_x].astype(np.float64)\n    center = l_x / 2.0\n    X += 0.5 - center\n    Y += 0.5 - center\n    return (X, Y)",
            "def _generate_center_coordinates(l_x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (X, Y) = np.mgrid[:l_x, :l_x].astype(np.float64)\n    center = l_x / 2.0\n    X += 0.5 - center\n    Y += 0.5 - center\n    return (X, Y)",
            "def _generate_center_coordinates(l_x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (X, Y) = np.mgrid[:l_x, :l_x].astype(np.float64)\n    center = l_x / 2.0\n    X += 0.5 - center\n    Y += 0.5 - center\n    return (X, Y)",
            "def _generate_center_coordinates(l_x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (X, Y) = np.mgrid[:l_x, :l_x].astype(np.float64)\n    center = l_x / 2.0\n    X += 0.5 - center\n    Y += 0.5 - center\n    return (X, Y)"
        ]
    },
    {
        "func_name": "build_projection_operator",
        "original": "def build_projection_operator(l_x, n_dir):\n    \"\"\"Compute the tomography design matrix.\n\n    Parameters\n    ----------\n\n    l_x : int\n        linear size of image array\n\n    n_dir : int\n        number of angles at which projections are acquired.\n\n    Returns\n    -------\n    p : sparse matrix of shape (n_dir l_x, l_x**2)\n    \"\"\"\n    (X, Y) = _generate_center_coordinates(l_x)\n    angles = np.linspace(0, np.pi, n_dir, endpoint=False)\n    (data_inds, weights, camera_inds) = ([], [], [])\n    data_unravel_indices = np.arange(l_x ** 2)\n    data_unravel_indices = np.hstack((data_unravel_indices, data_unravel_indices))\n    for (i, angle) in enumerate(angles):\n        Xrot = np.cos(angle) * X - np.sin(angle) * Y\n        (inds, w) = _weights(Xrot, dx=1, orig=X.min())\n        mask = np.logical_and(inds >= 0, inds < l_x)\n        weights += list(w[mask])\n        camera_inds += list(inds[mask] + i * l_x)\n        data_inds += list(data_unravel_indices[mask])\n    proj_operator = sparse.coo_matrix((weights, (camera_inds, data_inds)))\n    return proj_operator",
        "mutated": [
            "def build_projection_operator(l_x, n_dir):\n    if False:\n        i = 10\n    'Compute the tomography design matrix.\\n\\n    Parameters\\n    ----------\\n\\n    l_x : int\\n        linear size of image array\\n\\n    n_dir : int\\n        number of angles at which projections are acquired.\\n\\n    Returns\\n    -------\\n    p : sparse matrix of shape (n_dir l_x, l_x**2)\\n    '\n    (X, Y) = _generate_center_coordinates(l_x)\n    angles = np.linspace(0, np.pi, n_dir, endpoint=False)\n    (data_inds, weights, camera_inds) = ([], [], [])\n    data_unravel_indices = np.arange(l_x ** 2)\n    data_unravel_indices = np.hstack((data_unravel_indices, data_unravel_indices))\n    for (i, angle) in enumerate(angles):\n        Xrot = np.cos(angle) * X - np.sin(angle) * Y\n        (inds, w) = _weights(Xrot, dx=1, orig=X.min())\n        mask = np.logical_and(inds >= 0, inds < l_x)\n        weights += list(w[mask])\n        camera_inds += list(inds[mask] + i * l_x)\n        data_inds += list(data_unravel_indices[mask])\n    proj_operator = sparse.coo_matrix((weights, (camera_inds, data_inds)))\n    return proj_operator",
            "def build_projection_operator(l_x, n_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute the tomography design matrix.\\n\\n    Parameters\\n    ----------\\n\\n    l_x : int\\n        linear size of image array\\n\\n    n_dir : int\\n        number of angles at which projections are acquired.\\n\\n    Returns\\n    -------\\n    p : sparse matrix of shape (n_dir l_x, l_x**2)\\n    '\n    (X, Y) = _generate_center_coordinates(l_x)\n    angles = np.linspace(0, np.pi, n_dir, endpoint=False)\n    (data_inds, weights, camera_inds) = ([], [], [])\n    data_unravel_indices = np.arange(l_x ** 2)\n    data_unravel_indices = np.hstack((data_unravel_indices, data_unravel_indices))\n    for (i, angle) in enumerate(angles):\n        Xrot = np.cos(angle) * X - np.sin(angle) * Y\n        (inds, w) = _weights(Xrot, dx=1, orig=X.min())\n        mask = np.logical_and(inds >= 0, inds < l_x)\n        weights += list(w[mask])\n        camera_inds += list(inds[mask] + i * l_x)\n        data_inds += list(data_unravel_indices[mask])\n    proj_operator = sparse.coo_matrix((weights, (camera_inds, data_inds)))\n    return proj_operator",
            "def build_projection_operator(l_x, n_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute the tomography design matrix.\\n\\n    Parameters\\n    ----------\\n\\n    l_x : int\\n        linear size of image array\\n\\n    n_dir : int\\n        number of angles at which projections are acquired.\\n\\n    Returns\\n    -------\\n    p : sparse matrix of shape (n_dir l_x, l_x**2)\\n    '\n    (X, Y) = _generate_center_coordinates(l_x)\n    angles = np.linspace(0, np.pi, n_dir, endpoint=False)\n    (data_inds, weights, camera_inds) = ([], [], [])\n    data_unravel_indices = np.arange(l_x ** 2)\n    data_unravel_indices = np.hstack((data_unravel_indices, data_unravel_indices))\n    for (i, angle) in enumerate(angles):\n        Xrot = np.cos(angle) * X - np.sin(angle) * Y\n        (inds, w) = _weights(Xrot, dx=1, orig=X.min())\n        mask = np.logical_and(inds >= 0, inds < l_x)\n        weights += list(w[mask])\n        camera_inds += list(inds[mask] + i * l_x)\n        data_inds += list(data_unravel_indices[mask])\n    proj_operator = sparse.coo_matrix((weights, (camera_inds, data_inds)))\n    return proj_operator",
            "def build_projection_operator(l_x, n_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute the tomography design matrix.\\n\\n    Parameters\\n    ----------\\n\\n    l_x : int\\n        linear size of image array\\n\\n    n_dir : int\\n        number of angles at which projections are acquired.\\n\\n    Returns\\n    -------\\n    p : sparse matrix of shape (n_dir l_x, l_x**2)\\n    '\n    (X, Y) = _generate_center_coordinates(l_x)\n    angles = np.linspace(0, np.pi, n_dir, endpoint=False)\n    (data_inds, weights, camera_inds) = ([], [], [])\n    data_unravel_indices = np.arange(l_x ** 2)\n    data_unravel_indices = np.hstack((data_unravel_indices, data_unravel_indices))\n    for (i, angle) in enumerate(angles):\n        Xrot = np.cos(angle) * X - np.sin(angle) * Y\n        (inds, w) = _weights(Xrot, dx=1, orig=X.min())\n        mask = np.logical_and(inds >= 0, inds < l_x)\n        weights += list(w[mask])\n        camera_inds += list(inds[mask] + i * l_x)\n        data_inds += list(data_unravel_indices[mask])\n    proj_operator = sparse.coo_matrix((weights, (camera_inds, data_inds)))\n    return proj_operator",
            "def build_projection_operator(l_x, n_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute the tomography design matrix.\\n\\n    Parameters\\n    ----------\\n\\n    l_x : int\\n        linear size of image array\\n\\n    n_dir : int\\n        number of angles at which projections are acquired.\\n\\n    Returns\\n    -------\\n    p : sparse matrix of shape (n_dir l_x, l_x**2)\\n    '\n    (X, Y) = _generate_center_coordinates(l_x)\n    angles = np.linspace(0, np.pi, n_dir, endpoint=False)\n    (data_inds, weights, camera_inds) = ([], [], [])\n    data_unravel_indices = np.arange(l_x ** 2)\n    data_unravel_indices = np.hstack((data_unravel_indices, data_unravel_indices))\n    for (i, angle) in enumerate(angles):\n        Xrot = np.cos(angle) * X - np.sin(angle) * Y\n        (inds, w) = _weights(Xrot, dx=1, orig=X.min())\n        mask = np.logical_and(inds >= 0, inds < l_x)\n        weights += list(w[mask])\n        camera_inds += list(inds[mask] + i * l_x)\n        data_inds += list(data_unravel_indices[mask])\n    proj_operator = sparse.coo_matrix((weights, (camera_inds, data_inds)))\n    return proj_operator"
        ]
    },
    {
        "func_name": "generate_synthetic_data",
        "original": "def generate_synthetic_data():\n    \"\"\"Synthetic binary data\"\"\"\n    rs = np.random.RandomState(0)\n    n_pts = 36\n    (x, y) = np.ogrid[0:l, 0:l]\n    mask_outer = (x - l / 2.0) ** 2 + (y - l / 2.0) ** 2 < (l / 2.0) ** 2\n    mask = np.zeros((l, l))\n    points = l * rs.rand(2, n_pts)\n    mask[points[0].astype(int), points[1].astype(int)] = 1\n    mask = ndimage.gaussian_filter(mask, sigma=l / n_pts)\n    res = np.logical_and(mask > mask.mean(), mask_outer)\n    return np.logical_xor(res, ndimage.binary_erosion(res))",
        "mutated": [
            "def generate_synthetic_data():\n    if False:\n        i = 10\n    'Synthetic binary data'\n    rs = np.random.RandomState(0)\n    n_pts = 36\n    (x, y) = np.ogrid[0:l, 0:l]\n    mask_outer = (x - l / 2.0) ** 2 + (y - l / 2.0) ** 2 < (l / 2.0) ** 2\n    mask = np.zeros((l, l))\n    points = l * rs.rand(2, n_pts)\n    mask[points[0].astype(int), points[1].astype(int)] = 1\n    mask = ndimage.gaussian_filter(mask, sigma=l / n_pts)\n    res = np.logical_and(mask > mask.mean(), mask_outer)\n    return np.logical_xor(res, ndimage.binary_erosion(res))",
            "def generate_synthetic_data():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Synthetic binary data'\n    rs = np.random.RandomState(0)\n    n_pts = 36\n    (x, y) = np.ogrid[0:l, 0:l]\n    mask_outer = (x - l / 2.0) ** 2 + (y - l / 2.0) ** 2 < (l / 2.0) ** 2\n    mask = np.zeros((l, l))\n    points = l * rs.rand(2, n_pts)\n    mask[points[0].astype(int), points[1].astype(int)] = 1\n    mask = ndimage.gaussian_filter(mask, sigma=l / n_pts)\n    res = np.logical_and(mask > mask.mean(), mask_outer)\n    return np.logical_xor(res, ndimage.binary_erosion(res))",
            "def generate_synthetic_data():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Synthetic binary data'\n    rs = np.random.RandomState(0)\n    n_pts = 36\n    (x, y) = np.ogrid[0:l, 0:l]\n    mask_outer = (x - l / 2.0) ** 2 + (y - l / 2.0) ** 2 < (l / 2.0) ** 2\n    mask = np.zeros((l, l))\n    points = l * rs.rand(2, n_pts)\n    mask[points[0].astype(int), points[1].astype(int)] = 1\n    mask = ndimage.gaussian_filter(mask, sigma=l / n_pts)\n    res = np.logical_and(mask > mask.mean(), mask_outer)\n    return np.logical_xor(res, ndimage.binary_erosion(res))",
            "def generate_synthetic_data():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Synthetic binary data'\n    rs = np.random.RandomState(0)\n    n_pts = 36\n    (x, y) = np.ogrid[0:l, 0:l]\n    mask_outer = (x - l / 2.0) ** 2 + (y - l / 2.0) ** 2 < (l / 2.0) ** 2\n    mask = np.zeros((l, l))\n    points = l * rs.rand(2, n_pts)\n    mask[points[0].astype(int), points[1].astype(int)] = 1\n    mask = ndimage.gaussian_filter(mask, sigma=l / n_pts)\n    res = np.logical_and(mask > mask.mean(), mask_outer)\n    return np.logical_xor(res, ndimage.binary_erosion(res))",
            "def generate_synthetic_data():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Synthetic binary data'\n    rs = np.random.RandomState(0)\n    n_pts = 36\n    (x, y) = np.ogrid[0:l, 0:l]\n    mask_outer = (x - l / 2.0) ** 2 + (y - l / 2.0) ** 2 < (l / 2.0) ** 2\n    mask = np.zeros((l, l))\n    points = l * rs.rand(2, n_pts)\n    mask[points[0].astype(int), points[1].astype(int)] = 1\n    mask = ndimage.gaussian_filter(mask, sigma=l / n_pts)\n    res = np.logical_and(mask > mask.mean(), mask_outer)\n    return np.logical_xor(res, ndimage.binary_erosion(res))"
        ]
    }
]