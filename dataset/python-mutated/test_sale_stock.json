[
    {
        "func_name": "test_00_sale_stock_invoice",
        "original": "def test_00_sale_stock_invoice(self):\n    \"\"\"\n        Test SO's changes when playing around with stock moves, quants, pack operations, pickings\n        and whatever other model there is in stock with \"invoice on delivery\" products\n        \"\"\"\n    inv_obj = self.env['account.invoice']\n    self.so = self.env['sale.order'].create({'partner_id': self.partner.id, 'partner_invoice_id': self.partner.id, 'partner_shipping_id': self.partner.id, 'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for (_, p) in self.products.iteritems()], 'pricelist_id': self.env.ref('product.list0').id, 'picking_policy': 'direct'})\n    self.so.action_confirm()\n    self.assertTrue(self.so.picking_ids, 'Sale Stock: no picking created for \"invoice on delivery\" stockable products')\n    self.so.action_invoice_create()\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"nothing to invoice\" after invoicing')\n    pick = self.so.picking_ids\n    pick.force_assign()\n    pick.pack_operation_product_ids.write({'qty_done': 1})\n    wiz_act = pick.do_new_transfer()\n    wiz = self.env[wiz_act['res_model']].browse(wiz_act['res_id'])\n    wiz.process()\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" after partial delivery')\n    del_qties = [sol.qty_delivered for sol in self.so.order_line]\n    del_qties_truth = [1.0 if sol.product_id.type in ['product', 'consu'] else 0.0 for sol in self.so.order_line]\n    self.assertEqual(del_qties, del_qties_truth, 'Sale Stock: delivered quantities are wrong after partial delivery')\n    inv_id = self.so.action_invoice_create()\n    inv_1 = inv_obj.browse(inv_id)\n    self.assertTrue(all([il.product_id.invoice_policy == 'delivery' for il in inv_1.invoice_line_ids]), 'Sale Stock: invoice should only contain \"invoice on delivery\" products')\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"nothing to invoice\" after partial delivery and invoicing')\n    self.assertEqual(len(self.so.picking_ids), 2, 'Sale Stock: number of pickings should be 2')\n    pick_2 = self.so.picking_ids[0]\n    pick_2.force_assign()\n    pick_2.pack_operation_product_ids.write({'qty_done': 1})\n    self.assertIsNone(pick_2.do_new_transfer(), 'Sale Stock: second picking should be final without need for a backorder')\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" after complete delivery')\n    del_qties = [sol.qty_delivered for sol in self.so.order_line]\n    del_qties_truth = [2.0 if sol.product_id.type in ['product', 'consu'] else 0.0 for sol in self.so.order_line]\n    self.assertEqual(del_qties, del_qties_truth, 'Sale Stock: delivered quantities are wrong after complete delivery')\n    self.so.order_line[1]['qty_delivered'] = 2.0\n    inv_id = self.so.action_invoice_create()\n    self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so invoice_status should be \"fully invoiced\" after complete delivery and invoicing')",
        "mutated": [
            "def test_00_sale_stock_invoice(self):\n    if False:\n        i = 10\n    '\\n        Test SO\\'s changes when playing around with stock moves, quants, pack operations, pickings\\n        and whatever other model there is in stock with \"invoice on delivery\" products\\n        '\n    inv_obj = self.env['account.invoice']\n    self.so = self.env['sale.order'].create({'partner_id': self.partner.id, 'partner_invoice_id': self.partner.id, 'partner_shipping_id': self.partner.id, 'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for (_, p) in self.products.iteritems()], 'pricelist_id': self.env.ref('product.list0').id, 'picking_policy': 'direct'})\n    self.so.action_confirm()\n    self.assertTrue(self.so.picking_ids, 'Sale Stock: no picking created for \"invoice on delivery\" stockable products')\n    self.so.action_invoice_create()\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"nothing to invoice\" after invoicing')\n    pick = self.so.picking_ids\n    pick.force_assign()\n    pick.pack_operation_product_ids.write({'qty_done': 1})\n    wiz_act = pick.do_new_transfer()\n    wiz = self.env[wiz_act['res_model']].browse(wiz_act['res_id'])\n    wiz.process()\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" after partial delivery')\n    del_qties = [sol.qty_delivered for sol in self.so.order_line]\n    del_qties_truth = [1.0 if sol.product_id.type in ['product', 'consu'] else 0.0 for sol in self.so.order_line]\n    self.assertEqual(del_qties, del_qties_truth, 'Sale Stock: delivered quantities are wrong after partial delivery')\n    inv_id = self.so.action_invoice_create()\n    inv_1 = inv_obj.browse(inv_id)\n    self.assertTrue(all([il.product_id.invoice_policy == 'delivery' for il in inv_1.invoice_line_ids]), 'Sale Stock: invoice should only contain \"invoice on delivery\" products')\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"nothing to invoice\" after partial delivery and invoicing')\n    self.assertEqual(len(self.so.picking_ids), 2, 'Sale Stock: number of pickings should be 2')\n    pick_2 = self.so.picking_ids[0]\n    pick_2.force_assign()\n    pick_2.pack_operation_product_ids.write({'qty_done': 1})\n    self.assertIsNone(pick_2.do_new_transfer(), 'Sale Stock: second picking should be final without need for a backorder')\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" after complete delivery')\n    del_qties = [sol.qty_delivered for sol in self.so.order_line]\n    del_qties_truth = [2.0 if sol.product_id.type in ['product', 'consu'] else 0.0 for sol in self.so.order_line]\n    self.assertEqual(del_qties, del_qties_truth, 'Sale Stock: delivered quantities are wrong after complete delivery')\n    self.so.order_line[1]['qty_delivered'] = 2.0\n    inv_id = self.so.action_invoice_create()\n    self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so invoice_status should be \"fully invoiced\" after complete delivery and invoicing')",
            "def test_00_sale_stock_invoice(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Test SO\\'s changes when playing around with stock moves, quants, pack operations, pickings\\n        and whatever other model there is in stock with \"invoice on delivery\" products\\n        '\n    inv_obj = self.env['account.invoice']\n    self.so = self.env['sale.order'].create({'partner_id': self.partner.id, 'partner_invoice_id': self.partner.id, 'partner_shipping_id': self.partner.id, 'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for (_, p) in self.products.iteritems()], 'pricelist_id': self.env.ref('product.list0').id, 'picking_policy': 'direct'})\n    self.so.action_confirm()\n    self.assertTrue(self.so.picking_ids, 'Sale Stock: no picking created for \"invoice on delivery\" stockable products')\n    self.so.action_invoice_create()\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"nothing to invoice\" after invoicing')\n    pick = self.so.picking_ids\n    pick.force_assign()\n    pick.pack_operation_product_ids.write({'qty_done': 1})\n    wiz_act = pick.do_new_transfer()\n    wiz = self.env[wiz_act['res_model']].browse(wiz_act['res_id'])\n    wiz.process()\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" after partial delivery')\n    del_qties = [sol.qty_delivered for sol in self.so.order_line]\n    del_qties_truth = [1.0 if sol.product_id.type in ['product', 'consu'] else 0.0 for sol in self.so.order_line]\n    self.assertEqual(del_qties, del_qties_truth, 'Sale Stock: delivered quantities are wrong after partial delivery')\n    inv_id = self.so.action_invoice_create()\n    inv_1 = inv_obj.browse(inv_id)\n    self.assertTrue(all([il.product_id.invoice_policy == 'delivery' for il in inv_1.invoice_line_ids]), 'Sale Stock: invoice should only contain \"invoice on delivery\" products')\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"nothing to invoice\" after partial delivery and invoicing')\n    self.assertEqual(len(self.so.picking_ids), 2, 'Sale Stock: number of pickings should be 2')\n    pick_2 = self.so.picking_ids[0]\n    pick_2.force_assign()\n    pick_2.pack_operation_product_ids.write({'qty_done': 1})\n    self.assertIsNone(pick_2.do_new_transfer(), 'Sale Stock: second picking should be final without need for a backorder')\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" after complete delivery')\n    del_qties = [sol.qty_delivered for sol in self.so.order_line]\n    del_qties_truth = [2.0 if sol.product_id.type in ['product', 'consu'] else 0.0 for sol in self.so.order_line]\n    self.assertEqual(del_qties, del_qties_truth, 'Sale Stock: delivered quantities are wrong after complete delivery')\n    self.so.order_line[1]['qty_delivered'] = 2.0\n    inv_id = self.so.action_invoice_create()\n    self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so invoice_status should be \"fully invoiced\" after complete delivery and invoicing')",
            "def test_00_sale_stock_invoice(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Test SO\\'s changes when playing around with stock moves, quants, pack operations, pickings\\n        and whatever other model there is in stock with \"invoice on delivery\" products\\n        '\n    inv_obj = self.env['account.invoice']\n    self.so = self.env['sale.order'].create({'partner_id': self.partner.id, 'partner_invoice_id': self.partner.id, 'partner_shipping_id': self.partner.id, 'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for (_, p) in self.products.iteritems()], 'pricelist_id': self.env.ref('product.list0').id, 'picking_policy': 'direct'})\n    self.so.action_confirm()\n    self.assertTrue(self.so.picking_ids, 'Sale Stock: no picking created for \"invoice on delivery\" stockable products')\n    self.so.action_invoice_create()\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"nothing to invoice\" after invoicing')\n    pick = self.so.picking_ids\n    pick.force_assign()\n    pick.pack_operation_product_ids.write({'qty_done': 1})\n    wiz_act = pick.do_new_transfer()\n    wiz = self.env[wiz_act['res_model']].browse(wiz_act['res_id'])\n    wiz.process()\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" after partial delivery')\n    del_qties = [sol.qty_delivered for sol in self.so.order_line]\n    del_qties_truth = [1.0 if sol.product_id.type in ['product', 'consu'] else 0.0 for sol in self.so.order_line]\n    self.assertEqual(del_qties, del_qties_truth, 'Sale Stock: delivered quantities are wrong after partial delivery')\n    inv_id = self.so.action_invoice_create()\n    inv_1 = inv_obj.browse(inv_id)\n    self.assertTrue(all([il.product_id.invoice_policy == 'delivery' for il in inv_1.invoice_line_ids]), 'Sale Stock: invoice should only contain \"invoice on delivery\" products')\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"nothing to invoice\" after partial delivery and invoicing')\n    self.assertEqual(len(self.so.picking_ids), 2, 'Sale Stock: number of pickings should be 2')\n    pick_2 = self.so.picking_ids[0]\n    pick_2.force_assign()\n    pick_2.pack_operation_product_ids.write({'qty_done': 1})\n    self.assertIsNone(pick_2.do_new_transfer(), 'Sale Stock: second picking should be final without need for a backorder')\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" after complete delivery')\n    del_qties = [sol.qty_delivered for sol in self.so.order_line]\n    del_qties_truth = [2.0 if sol.product_id.type in ['product', 'consu'] else 0.0 for sol in self.so.order_line]\n    self.assertEqual(del_qties, del_qties_truth, 'Sale Stock: delivered quantities are wrong after complete delivery')\n    self.so.order_line[1]['qty_delivered'] = 2.0\n    inv_id = self.so.action_invoice_create()\n    self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so invoice_status should be \"fully invoiced\" after complete delivery and invoicing')",
            "def test_00_sale_stock_invoice(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Test SO\\'s changes when playing around with stock moves, quants, pack operations, pickings\\n        and whatever other model there is in stock with \"invoice on delivery\" products\\n        '\n    inv_obj = self.env['account.invoice']\n    self.so = self.env['sale.order'].create({'partner_id': self.partner.id, 'partner_invoice_id': self.partner.id, 'partner_shipping_id': self.partner.id, 'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for (_, p) in self.products.iteritems()], 'pricelist_id': self.env.ref('product.list0').id, 'picking_policy': 'direct'})\n    self.so.action_confirm()\n    self.assertTrue(self.so.picking_ids, 'Sale Stock: no picking created for \"invoice on delivery\" stockable products')\n    self.so.action_invoice_create()\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"nothing to invoice\" after invoicing')\n    pick = self.so.picking_ids\n    pick.force_assign()\n    pick.pack_operation_product_ids.write({'qty_done': 1})\n    wiz_act = pick.do_new_transfer()\n    wiz = self.env[wiz_act['res_model']].browse(wiz_act['res_id'])\n    wiz.process()\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" after partial delivery')\n    del_qties = [sol.qty_delivered for sol in self.so.order_line]\n    del_qties_truth = [1.0 if sol.product_id.type in ['product', 'consu'] else 0.0 for sol in self.so.order_line]\n    self.assertEqual(del_qties, del_qties_truth, 'Sale Stock: delivered quantities are wrong after partial delivery')\n    inv_id = self.so.action_invoice_create()\n    inv_1 = inv_obj.browse(inv_id)\n    self.assertTrue(all([il.product_id.invoice_policy == 'delivery' for il in inv_1.invoice_line_ids]), 'Sale Stock: invoice should only contain \"invoice on delivery\" products')\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"nothing to invoice\" after partial delivery and invoicing')\n    self.assertEqual(len(self.so.picking_ids), 2, 'Sale Stock: number of pickings should be 2')\n    pick_2 = self.so.picking_ids[0]\n    pick_2.force_assign()\n    pick_2.pack_operation_product_ids.write({'qty_done': 1})\n    self.assertIsNone(pick_2.do_new_transfer(), 'Sale Stock: second picking should be final without need for a backorder')\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" after complete delivery')\n    del_qties = [sol.qty_delivered for sol in self.so.order_line]\n    del_qties_truth = [2.0 if sol.product_id.type in ['product', 'consu'] else 0.0 for sol in self.so.order_line]\n    self.assertEqual(del_qties, del_qties_truth, 'Sale Stock: delivered quantities are wrong after complete delivery')\n    self.so.order_line[1]['qty_delivered'] = 2.0\n    inv_id = self.so.action_invoice_create()\n    self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so invoice_status should be \"fully invoiced\" after complete delivery and invoicing')",
            "def test_00_sale_stock_invoice(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Test SO\\'s changes when playing around with stock moves, quants, pack operations, pickings\\n        and whatever other model there is in stock with \"invoice on delivery\" products\\n        '\n    inv_obj = self.env['account.invoice']\n    self.so = self.env['sale.order'].create({'partner_id': self.partner.id, 'partner_invoice_id': self.partner.id, 'partner_shipping_id': self.partner.id, 'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for (_, p) in self.products.iteritems()], 'pricelist_id': self.env.ref('product.list0').id, 'picking_policy': 'direct'})\n    self.so.action_confirm()\n    self.assertTrue(self.so.picking_ids, 'Sale Stock: no picking created for \"invoice on delivery\" stockable products')\n    self.so.action_invoice_create()\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"nothing to invoice\" after invoicing')\n    pick = self.so.picking_ids\n    pick.force_assign()\n    pick.pack_operation_product_ids.write({'qty_done': 1})\n    wiz_act = pick.do_new_transfer()\n    wiz = self.env[wiz_act['res_model']].browse(wiz_act['res_id'])\n    wiz.process()\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" after partial delivery')\n    del_qties = [sol.qty_delivered for sol in self.so.order_line]\n    del_qties_truth = [1.0 if sol.product_id.type in ['product', 'consu'] else 0.0 for sol in self.so.order_line]\n    self.assertEqual(del_qties, del_qties_truth, 'Sale Stock: delivered quantities are wrong after partial delivery')\n    inv_id = self.so.action_invoice_create()\n    inv_1 = inv_obj.browse(inv_id)\n    self.assertTrue(all([il.product_id.invoice_policy == 'delivery' for il in inv_1.invoice_line_ids]), 'Sale Stock: invoice should only contain \"invoice on delivery\" products')\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"nothing to invoice\" after partial delivery and invoicing')\n    self.assertEqual(len(self.so.picking_ids), 2, 'Sale Stock: number of pickings should be 2')\n    pick_2 = self.so.picking_ids[0]\n    pick_2.force_assign()\n    pick_2.pack_operation_product_ids.write({'qty_done': 1})\n    self.assertIsNone(pick_2.do_new_transfer(), 'Sale Stock: second picking should be final without need for a backorder')\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" after complete delivery')\n    del_qties = [sol.qty_delivered for sol in self.so.order_line]\n    del_qties_truth = [2.0 if sol.product_id.type in ['product', 'consu'] else 0.0 for sol in self.so.order_line]\n    self.assertEqual(del_qties, del_qties_truth, 'Sale Stock: delivered quantities are wrong after complete delivery')\n    self.so.order_line[1]['qty_delivered'] = 2.0\n    inv_id = self.so.action_invoice_create()\n    self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so invoice_status should be \"fully invoiced\" after complete delivery and invoicing')"
        ]
    },
    {
        "func_name": "test_01_sale_stock_order",
        "original": "def test_01_sale_stock_order(self):\n    \"\"\"\n        Test SO's changes when playing around with stock moves, quants, pack operations, pickings\n        and whatever other model there is in stock with \"invoice on order\" products\n        \"\"\"\n    self.so = self.env['sale.order'].create({'partner_id': self.partner.id, 'partner_invoice_id': self.partner.id, 'partner_shipping_id': self.partner.id, 'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for (_, p) in self.products.iteritems()], 'pricelist_id': self.env.ref('product.list0').id, 'picking_policy': 'direct'})\n    for sol in self.so.order_line:\n        sol.product_id.invoice_policy = 'order'\n    self.so.action_confirm()\n    self.assertTrue(self.so.picking_ids, 'Sale Stock: no picking created for \"invoice on order\" stockable products')\n    adv_wiz = self.env['sale.advance.payment.inv'].with_context(active_ids=[self.so.id]).create({'advance_payment_method': 'percentage', 'amount': 5.0, 'product_id': self.env.ref('sale.advance_product_0').id})\n    act = adv_wiz.with_context(open_invoices=True).create_invoices()\n    inv = self.env['account.invoice'].browse(act['res_id'])\n    self.assertEqual(inv.amount_untaxed, self.so.amount_untaxed * 5.0 / 100.0, 'Sale Stock: deposit invoice is wrong')\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so should be to invoice after invoicing deposit')\n    self.so.action_invoice_create(final=True)\n    self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so should be fully invoiced after second invoice')\n    pick = self.so.picking_ids\n    pick.force_assign()\n    pick.pack_operation_product_ids.write({'qty_done': 2})\n    self.assertIsNone(pick.do_new_transfer(), 'Sale Stock: complete delivery should not need a backorder')\n    del_qties = [sol.qty_delivered for sol in self.so.order_line]\n    del_qties_truth = [2.0 if sol.product_id.type in ['product', 'consu'] else 0.0 for sol in self.so.order_line]\n    self.assertEqual(del_qties, del_qties_truth, 'Sale Stock: delivered quantities are wrong after partial delivery')\n    with self.assertRaises(UserError):\n        self.so.action_invoice_create()",
        "mutated": [
            "def test_01_sale_stock_order(self):\n    if False:\n        i = 10\n    '\\n        Test SO\\'s changes when playing around with stock moves, quants, pack operations, pickings\\n        and whatever other model there is in stock with \"invoice on order\" products\\n        '\n    self.so = self.env['sale.order'].create({'partner_id': self.partner.id, 'partner_invoice_id': self.partner.id, 'partner_shipping_id': self.partner.id, 'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for (_, p) in self.products.iteritems()], 'pricelist_id': self.env.ref('product.list0').id, 'picking_policy': 'direct'})\n    for sol in self.so.order_line:\n        sol.product_id.invoice_policy = 'order'\n    self.so.action_confirm()\n    self.assertTrue(self.so.picking_ids, 'Sale Stock: no picking created for \"invoice on order\" stockable products')\n    adv_wiz = self.env['sale.advance.payment.inv'].with_context(active_ids=[self.so.id]).create({'advance_payment_method': 'percentage', 'amount': 5.0, 'product_id': self.env.ref('sale.advance_product_0').id})\n    act = adv_wiz.with_context(open_invoices=True).create_invoices()\n    inv = self.env['account.invoice'].browse(act['res_id'])\n    self.assertEqual(inv.amount_untaxed, self.so.amount_untaxed * 5.0 / 100.0, 'Sale Stock: deposit invoice is wrong')\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so should be to invoice after invoicing deposit')\n    self.so.action_invoice_create(final=True)\n    self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so should be fully invoiced after second invoice')\n    pick = self.so.picking_ids\n    pick.force_assign()\n    pick.pack_operation_product_ids.write({'qty_done': 2})\n    self.assertIsNone(pick.do_new_transfer(), 'Sale Stock: complete delivery should not need a backorder')\n    del_qties = [sol.qty_delivered for sol in self.so.order_line]\n    del_qties_truth = [2.0 if sol.product_id.type in ['product', 'consu'] else 0.0 for sol in self.so.order_line]\n    self.assertEqual(del_qties, del_qties_truth, 'Sale Stock: delivered quantities are wrong after partial delivery')\n    with self.assertRaises(UserError):\n        self.so.action_invoice_create()",
            "def test_01_sale_stock_order(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Test SO\\'s changes when playing around with stock moves, quants, pack operations, pickings\\n        and whatever other model there is in stock with \"invoice on order\" products\\n        '\n    self.so = self.env['sale.order'].create({'partner_id': self.partner.id, 'partner_invoice_id': self.partner.id, 'partner_shipping_id': self.partner.id, 'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for (_, p) in self.products.iteritems()], 'pricelist_id': self.env.ref('product.list0').id, 'picking_policy': 'direct'})\n    for sol in self.so.order_line:\n        sol.product_id.invoice_policy = 'order'\n    self.so.action_confirm()\n    self.assertTrue(self.so.picking_ids, 'Sale Stock: no picking created for \"invoice on order\" stockable products')\n    adv_wiz = self.env['sale.advance.payment.inv'].with_context(active_ids=[self.so.id]).create({'advance_payment_method': 'percentage', 'amount': 5.0, 'product_id': self.env.ref('sale.advance_product_0').id})\n    act = adv_wiz.with_context(open_invoices=True).create_invoices()\n    inv = self.env['account.invoice'].browse(act['res_id'])\n    self.assertEqual(inv.amount_untaxed, self.so.amount_untaxed * 5.0 / 100.0, 'Sale Stock: deposit invoice is wrong')\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so should be to invoice after invoicing deposit')\n    self.so.action_invoice_create(final=True)\n    self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so should be fully invoiced after second invoice')\n    pick = self.so.picking_ids\n    pick.force_assign()\n    pick.pack_operation_product_ids.write({'qty_done': 2})\n    self.assertIsNone(pick.do_new_transfer(), 'Sale Stock: complete delivery should not need a backorder')\n    del_qties = [sol.qty_delivered for sol in self.so.order_line]\n    del_qties_truth = [2.0 if sol.product_id.type in ['product', 'consu'] else 0.0 for sol in self.so.order_line]\n    self.assertEqual(del_qties, del_qties_truth, 'Sale Stock: delivered quantities are wrong after partial delivery')\n    with self.assertRaises(UserError):\n        self.so.action_invoice_create()",
            "def test_01_sale_stock_order(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Test SO\\'s changes when playing around with stock moves, quants, pack operations, pickings\\n        and whatever other model there is in stock with \"invoice on order\" products\\n        '\n    self.so = self.env['sale.order'].create({'partner_id': self.partner.id, 'partner_invoice_id': self.partner.id, 'partner_shipping_id': self.partner.id, 'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for (_, p) in self.products.iteritems()], 'pricelist_id': self.env.ref('product.list0').id, 'picking_policy': 'direct'})\n    for sol in self.so.order_line:\n        sol.product_id.invoice_policy = 'order'\n    self.so.action_confirm()\n    self.assertTrue(self.so.picking_ids, 'Sale Stock: no picking created for \"invoice on order\" stockable products')\n    adv_wiz = self.env['sale.advance.payment.inv'].with_context(active_ids=[self.so.id]).create({'advance_payment_method': 'percentage', 'amount': 5.0, 'product_id': self.env.ref('sale.advance_product_0').id})\n    act = adv_wiz.with_context(open_invoices=True).create_invoices()\n    inv = self.env['account.invoice'].browse(act['res_id'])\n    self.assertEqual(inv.amount_untaxed, self.so.amount_untaxed * 5.0 / 100.0, 'Sale Stock: deposit invoice is wrong')\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so should be to invoice after invoicing deposit')\n    self.so.action_invoice_create(final=True)\n    self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so should be fully invoiced after second invoice')\n    pick = self.so.picking_ids\n    pick.force_assign()\n    pick.pack_operation_product_ids.write({'qty_done': 2})\n    self.assertIsNone(pick.do_new_transfer(), 'Sale Stock: complete delivery should not need a backorder')\n    del_qties = [sol.qty_delivered for sol in self.so.order_line]\n    del_qties_truth = [2.0 if sol.product_id.type in ['product', 'consu'] else 0.0 for sol in self.so.order_line]\n    self.assertEqual(del_qties, del_qties_truth, 'Sale Stock: delivered quantities are wrong after partial delivery')\n    with self.assertRaises(UserError):\n        self.so.action_invoice_create()",
            "def test_01_sale_stock_order(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Test SO\\'s changes when playing around with stock moves, quants, pack operations, pickings\\n        and whatever other model there is in stock with \"invoice on order\" products\\n        '\n    self.so = self.env['sale.order'].create({'partner_id': self.partner.id, 'partner_invoice_id': self.partner.id, 'partner_shipping_id': self.partner.id, 'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for (_, p) in self.products.iteritems()], 'pricelist_id': self.env.ref('product.list0').id, 'picking_policy': 'direct'})\n    for sol in self.so.order_line:\n        sol.product_id.invoice_policy = 'order'\n    self.so.action_confirm()\n    self.assertTrue(self.so.picking_ids, 'Sale Stock: no picking created for \"invoice on order\" stockable products')\n    adv_wiz = self.env['sale.advance.payment.inv'].with_context(active_ids=[self.so.id]).create({'advance_payment_method': 'percentage', 'amount': 5.0, 'product_id': self.env.ref('sale.advance_product_0').id})\n    act = adv_wiz.with_context(open_invoices=True).create_invoices()\n    inv = self.env['account.invoice'].browse(act['res_id'])\n    self.assertEqual(inv.amount_untaxed, self.so.amount_untaxed * 5.0 / 100.0, 'Sale Stock: deposit invoice is wrong')\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so should be to invoice after invoicing deposit')\n    self.so.action_invoice_create(final=True)\n    self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so should be fully invoiced after second invoice')\n    pick = self.so.picking_ids\n    pick.force_assign()\n    pick.pack_operation_product_ids.write({'qty_done': 2})\n    self.assertIsNone(pick.do_new_transfer(), 'Sale Stock: complete delivery should not need a backorder')\n    del_qties = [sol.qty_delivered for sol in self.so.order_line]\n    del_qties_truth = [2.0 if sol.product_id.type in ['product', 'consu'] else 0.0 for sol in self.so.order_line]\n    self.assertEqual(del_qties, del_qties_truth, 'Sale Stock: delivered quantities are wrong after partial delivery')\n    with self.assertRaises(UserError):\n        self.so.action_invoice_create()",
            "def test_01_sale_stock_order(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Test SO\\'s changes when playing around with stock moves, quants, pack operations, pickings\\n        and whatever other model there is in stock with \"invoice on order\" products\\n        '\n    self.so = self.env['sale.order'].create({'partner_id': self.partner.id, 'partner_invoice_id': self.partner.id, 'partner_shipping_id': self.partner.id, 'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for (_, p) in self.products.iteritems()], 'pricelist_id': self.env.ref('product.list0').id, 'picking_policy': 'direct'})\n    for sol in self.so.order_line:\n        sol.product_id.invoice_policy = 'order'\n    self.so.action_confirm()\n    self.assertTrue(self.so.picking_ids, 'Sale Stock: no picking created for \"invoice on order\" stockable products')\n    adv_wiz = self.env['sale.advance.payment.inv'].with_context(active_ids=[self.so.id]).create({'advance_payment_method': 'percentage', 'amount': 5.0, 'product_id': self.env.ref('sale.advance_product_0').id})\n    act = adv_wiz.with_context(open_invoices=True).create_invoices()\n    inv = self.env['account.invoice'].browse(act['res_id'])\n    self.assertEqual(inv.amount_untaxed, self.so.amount_untaxed * 5.0 / 100.0, 'Sale Stock: deposit invoice is wrong')\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so should be to invoice after invoicing deposit')\n    self.so.action_invoice_create(final=True)\n    self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so should be fully invoiced after second invoice')\n    pick = self.so.picking_ids\n    pick.force_assign()\n    pick.pack_operation_product_ids.write({'qty_done': 2})\n    self.assertIsNone(pick.do_new_transfer(), 'Sale Stock: complete delivery should not need a backorder')\n    del_qties = [sol.qty_delivered for sol in self.so.order_line]\n    del_qties_truth = [2.0 if sol.product_id.type in ['product', 'consu'] else 0.0 for sol in self.so.order_line]\n    self.assertEqual(del_qties, del_qties_truth, 'Sale Stock: delivered quantities are wrong after partial delivery')\n    with self.assertRaises(UserError):\n        self.so.action_invoice_create()"
        ]
    },
    {
        "func_name": "test_02_sale_stock_return",
        "original": "def test_02_sale_stock_return(self):\n    \"\"\"\n        Test a SO with a product invoiced on delivery. Deliver and invoice the SO, then do a return\n        of the picking. Check that a refund invoice is well generated.\n        \"\"\"\n    self.partner = self.env.ref('base.res_partner_1')\n    self.product = self.env.ref('product.product_delivery_01')\n    so_vals = {'partner_id': self.partner.id, 'partner_invoice_id': self.partner.id, 'partner_shipping_id': self.partner.id, 'order_line': [(0, 0, {'name': self.product.name, 'product_id': self.product.id, 'product_uom_qty': 5.0, 'product_uom': self.product.uom_id.id, 'price_unit': self.product.list_price})], 'pricelist_id': self.env.ref('product.list0').id}\n    self.so = self.env['sale.order'].create(so_vals)\n    self.so.action_confirm()\n    self.assertTrue(self.so.picking_ids, 'Sale Stock: no picking created for \"invoice on delivery\" stockable products')\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"no\" instead of \"%s\".' % self.so.invoice_status)\n    pick = self.so.picking_ids\n    pick.force_assign()\n    pick.pack_operation_product_ids.write({'qty_done': 5})\n    pick.do_new_transfer()\n    del_qty = sum((sol.qty_delivered for sol in self.so.order_line))\n    self.assertEqual(del_qty, 5.0, 'Sale Stock: delivered quantity should be 5.0 instead of %s after complete delivery' % del_qty)\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" instead of \"%s\" before invoicing' % self.so.invoice_status)\n    inv_1_id = self.so.action_invoice_create()\n    self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so invoice_status should be \"invoiced\" instead of \"%s\" after invoicing' % self.so.invoice_status)\n    self.assertEqual(len(inv_1_id), 1, 'Sale Stock: only one invoice instead of \"%s\" should be created' % len(inv_1_id))\n    self.inv_1 = self.env['account.invoice'].browse(inv_1_id)\n    self.assertEqual(self.inv_1.amount_untaxed, self.inv_1.amount_untaxed, 'Sale Stock: amount in SO and invoice should be the same')\n    self.inv_1.action_invoice_open()\n    StockReturnPicking = self.env['stock.return.picking']\n    default_data = StockReturnPicking.with_context(active_ids=pick.ids, active_id=pick.ids[0]).default_get(['move_dest_exists', 'original_location_id', 'product_return_moves', 'parent_location_id', 'location_id'])\n    return_wiz = StockReturnPicking.with_context(active_ids=pick.ids, active_id=pick.ids[0]).create(default_data)\n    return_wiz.product_return_moves.quantity = 2.0\n    return_wiz.product_return_moves.to_refund_so = True\n    res = return_wiz.create_returns()\n    return_pick = self.env['stock.picking'].browse(res['res_id'])\n    return_pick.force_assign()\n    return_pick.pack_operation_product_ids.write({'qty_done': 2})\n    return_pick.do_new_transfer()\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" instead of \"%s\" after picking return' % self.so.invoice_status)\n    self.assertEqual(self.so.order_line[0].qty_delivered, 3.0, 'Sale Stock: delivered quantity should be 3.0 instead of \"%s\" after picking return' % self.so.order_line[0].qty_delivered)\n    adv_wiz = self.env['sale.advance.payment.inv'].with_context(active_ids=[self.so.id]).create({'advance_payment_method': 'all'})\n    adv_wiz.with_context(open_invoices=True).create_invoices()\n    self.inv_2 = self.so.invoice_ids.filtered(lambda r: r.state == 'draft')\n    self.assertEqual(self.inv_2.invoice_line_ids[0].quantity, 2.0, 'Sale Stock: refund quantity on the invoice should be 2.0 instead of \"%s\".' % self.inv_2.invoice_line_ids[0].quantity)\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"no\" instead of \"%s\" after invoicing the return' % self.so.invoice_status)",
        "mutated": [
            "def test_02_sale_stock_return(self):\n    if False:\n        i = 10\n    '\\n        Test a SO with a product invoiced on delivery. Deliver and invoice the SO, then do a return\\n        of the picking. Check that a refund invoice is well generated.\\n        '\n    self.partner = self.env.ref('base.res_partner_1')\n    self.product = self.env.ref('product.product_delivery_01')\n    so_vals = {'partner_id': self.partner.id, 'partner_invoice_id': self.partner.id, 'partner_shipping_id': self.partner.id, 'order_line': [(0, 0, {'name': self.product.name, 'product_id': self.product.id, 'product_uom_qty': 5.0, 'product_uom': self.product.uom_id.id, 'price_unit': self.product.list_price})], 'pricelist_id': self.env.ref('product.list0').id}\n    self.so = self.env['sale.order'].create(so_vals)\n    self.so.action_confirm()\n    self.assertTrue(self.so.picking_ids, 'Sale Stock: no picking created for \"invoice on delivery\" stockable products')\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"no\" instead of \"%s\".' % self.so.invoice_status)\n    pick = self.so.picking_ids\n    pick.force_assign()\n    pick.pack_operation_product_ids.write({'qty_done': 5})\n    pick.do_new_transfer()\n    del_qty = sum((sol.qty_delivered for sol in self.so.order_line))\n    self.assertEqual(del_qty, 5.0, 'Sale Stock: delivered quantity should be 5.0 instead of %s after complete delivery' % del_qty)\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" instead of \"%s\" before invoicing' % self.so.invoice_status)\n    inv_1_id = self.so.action_invoice_create()\n    self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so invoice_status should be \"invoiced\" instead of \"%s\" after invoicing' % self.so.invoice_status)\n    self.assertEqual(len(inv_1_id), 1, 'Sale Stock: only one invoice instead of \"%s\" should be created' % len(inv_1_id))\n    self.inv_1 = self.env['account.invoice'].browse(inv_1_id)\n    self.assertEqual(self.inv_1.amount_untaxed, self.inv_1.amount_untaxed, 'Sale Stock: amount in SO and invoice should be the same')\n    self.inv_1.action_invoice_open()\n    StockReturnPicking = self.env['stock.return.picking']\n    default_data = StockReturnPicking.with_context(active_ids=pick.ids, active_id=pick.ids[0]).default_get(['move_dest_exists', 'original_location_id', 'product_return_moves', 'parent_location_id', 'location_id'])\n    return_wiz = StockReturnPicking.with_context(active_ids=pick.ids, active_id=pick.ids[0]).create(default_data)\n    return_wiz.product_return_moves.quantity = 2.0\n    return_wiz.product_return_moves.to_refund_so = True\n    res = return_wiz.create_returns()\n    return_pick = self.env['stock.picking'].browse(res['res_id'])\n    return_pick.force_assign()\n    return_pick.pack_operation_product_ids.write({'qty_done': 2})\n    return_pick.do_new_transfer()\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" instead of \"%s\" after picking return' % self.so.invoice_status)\n    self.assertEqual(self.so.order_line[0].qty_delivered, 3.0, 'Sale Stock: delivered quantity should be 3.0 instead of \"%s\" after picking return' % self.so.order_line[0].qty_delivered)\n    adv_wiz = self.env['sale.advance.payment.inv'].with_context(active_ids=[self.so.id]).create({'advance_payment_method': 'all'})\n    adv_wiz.with_context(open_invoices=True).create_invoices()\n    self.inv_2 = self.so.invoice_ids.filtered(lambda r: r.state == 'draft')\n    self.assertEqual(self.inv_2.invoice_line_ids[0].quantity, 2.0, 'Sale Stock: refund quantity on the invoice should be 2.0 instead of \"%s\".' % self.inv_2.invoice_line_ids[0].quantity)\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"no\" instead of \"%s\" after invoicing the return' % self.so.invoice_status)",
            "def test_02_sale_stock_return(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Test a SO with a product invoiced on delivery. Deliver and invoice the SO, then do a return\\n        of the picking. Check that a refund invoice is well generated.\\n        '\n    self.partner = self.env.ref('base.res_partner_1')\n    self.product = self.env.ref('product.product_delivery_01')\n    so_vals = {'partner_id': self.partner.id, 'partner_invoice_id': self.partner.id, 'partner_shipping_id': self.partner.id, 'order_line': [(0, 0, {'name': self.product.name, 'product_id': self.product.id, 'product_uom_qty': 5.0, 'product_uom': self.product.uom_id.id, 'price_unit': self.product.list_price})], 'pricelist_id': self.env.ref('product.list0').id}\n    self.so = self.env['sale.order'].create(so_vals)\n    self.so.action_confirm()\n    self.assertTrue(self.so.picking_ids, 'Sale Stock: no picking created for \"invoice on delivery\" stockable products')\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"no\" instead of \"%s\".' % self.so.invoice_status)\n    pick = self.so.picking_ids\n    pick.force_assign()\n    pick.pack_operation_product_ids.write({'qty_done': 5})\n    pick.do_new_transfer()\n    del_qty = sum((sol.qty_delivered for sol in self.so.order_line))\n    self.assertEqual(del_qty, 5.0, 'Sale Stock: delivered quantity should be 5.0 instead of %s after complete delivery' % del_qty)\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" instead of \"%s\" before invoicing' % self.so.invoice_status)\n    inv_1_id = self.so.action_invoice_create()\n    self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so invoice_status should be \"invoiced\" instead of \"%s\" after invoicing' % self.so.invoice_status)\n    self.assertEqual(len(inv_1_id), 1, 'Sale Stock: only one invoice instead of \"%s\" should be created' % len(inv_1_id))\n    self.inv_1 = self.env['account.invoice'].browse(inv_1_id)\n    self.assertEqual(self.inv_1.amount_untaxed, self.inv_1.amount_untaxed, 'Sale Stock: amount in SO and invoice should be the same')\n    self.inv_1.action_invoice_open()\n    StockReturnPicking = self.env['stock.return.picking']\n    default_data = StockReturnPicking.with_context(active_ids=pick.ids, active_id=pick.ids[0]).default_get(['move_dest_exists', 'original_location_id', 'product_return_moves', 'parent_location_id', 'location_id'])\n    return_wiz = StockReturnPicking.with_context(active_ids=pick.ids, active_id=pick.ids[0]).create(default_data)\n    return_wiz.product_return_moves.quantity = 2.0\n    return_wiz.product_return_moves.to_refund_so = True\n    res = return_wiz.create_returns()\n    return_pick = self.env['stock.picking'].browse(res['res_id'])\n    return_pick.force_assign()\n    return_pick.pack_operation_product_ids.write({'qty_done': 2})\n    return_pick.do_new_transfer()\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" instead of \"%s\" after picking return' % self.so.invoice_status)\n    self.assertEqual(self.so.order_line[0].qty_delivered, 3.0, 'Sale Stock: delivered quantity should be 3.0 instead of \"%s\" after picking return' % self.so.order_line[0].qty_delivered)\n    adv_wiz = self.env['sale.advance.payment.inv'].with_context(active_ids=[self.so.id]).create({'advance_payment_method': 'all'})\n    adv_wiz.with_context(open_invoices=True).create_invoices()\n    self.inv_2 = self.so.invoice_ids.filtered(lambda r: r.state == 'draft')\n    self.assertEqual(self.inv_2.invoice_line_ids[0].quantity, 2.0, 'Sale Stock: refund quantity on the invoice should be 2.0 instead of \"%s\".' % self.inv_2.invoice_line_ids[0].quantity)\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"no\" instead of \"%s\" after invoicing the return' % self.so.invoice_status)",
            "def test_02_sale_stock_return(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Test a SO with a product invoiced on delivery. Deliver and invoice the SO, then do a return\\n        of the picking. Check that a refund invoice is well generated.\\n        '\n    self.partner = self.env.ref('base.res_partner_1')\n    self.product = self.env.ref('product.product_delivery_01')\n    so_vals = {'partner_id': self.partner.id, 'partner_invoice_id': self.partner.id, 'partner_shipping_id': self.partner.id, 'order_line': [(0, 0, {'name': self.product.name, 'product_id': self.product.id, 'product_uom_qty': 5.0, 'product_uom': self.product.uom_id.id, 'price_unit': self.product.list_price})], 'pricelist_id': self.env.ref('product.list0').id}\n    self.so = self.env['sale.order'].create(so_vals)\n    self.so.action_confirm()\n    self.assertTrue(self.so.picking_ids, 'Sale Stock: no picking created for \"invoice on delivery\" stockable products')\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"no\" instead of \"%s\".' % self.so.invoice_status)\n    pick = self.so.picking_ids\n    pick.force_assign()\n    pick.pack_operation_product_ids.write({'qty_done': 5})\n    pick.do_new_transfer()\n    del_qty = sum((sol.qty_delivered for sol in self.so.order_line))\n    self.assertEqual(del_qty, 5.0, 'Sale Stock: delivered quantity should be 5.0 instead of %s after complete delivery' % del_qty)\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" instead of \"%s\" before invoicing' % self.so.invoice_status)\n    inv_1_id = self.so.action_invoice_create()\n    self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so invoice_status should be \"invoiced\" instead of \"%s\" after invoicing' % self.so.invoice_status)\n    self.assertEqual(len(inv_1_id), 1, 'Sale Stock: only one invoice instead of \"%s\" should be created' % len(inv_1_id))\n    self.inv_1 = self.env['account.invoice'].browse(inv_1_id)\n    self.assertEqual(self.inv_1.amount_untaxed, self.inv_1.amount_untaxed, 'Sale Stock: amount in SO and invoice should be the same')\n    self.inv_1.action_invoice_open()\n    StockReturnPicking = self.env['stock.return.picking']\n    default_data = StockReturnPicking.with_context(active_ids=pick.ids, active_id=pick.ids[0]).default_get(['move_dest_exists', 'original_location_id', 'product_return_moves', 'parent_location_id', 'location_id'])\n    return_wiz = StockReturnPicking.with_context(active_ids=pick.ids, active_id=pick.ids[0]).create(default_data)\n    return_wiz.product_return_moves.quantity = 2.0\n    return_wiz.product_return_moves.to_refund_so = True\n    res = return_wiz.create_returns()\n    return_pick = self.env['stock.picking'].browse(res['res_id'])\n    return_pick.force_assign()\n    return_pick.pack_operation_product_ids.write({'qty_done': 2})\n    return_pick.do_new_transfer()\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" instead of \"%s\" after picking return' % self.so.invoice_status)\n    self.assertEqual(self.so.order_line[0].qty_delivered, 3.0, 'Sale Stock: delivered quantity should be 3.0 instead of \"%s\" after picking return' % self.so.order_line[0].qty_delivered)\n    adv_wiz = self.env['sale.advance.payment.inv'].with_context(active_ids=[self.so.id]).create({'advance_payment_method': 'all'})\n    adv_wiz.with_context(open_invoices=True).create_invoices()\n    self.inv_2 = self.so.invoice_ids.filtered(lambda r: r.state == 'draft')\n    self.assertEqual(self.inv_2.invoice_line_ids[0].quantity, 2.0, 'Sale Stock: refund quantity on the invoice should be 2.0 instead of \"%s\".' % self.inv_2.invoice_line_ids[0].quantity)\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"no\" instead of \"%s\" after invoicing the return' % self.so.invoice_status)",
            "def test_02_sale_stock_return(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Test a SO with a product invoiced on delivery. Deliver and invoice the SO, then do a return\\n        of the picking. Check that a refund invoice is well generated.\\n        '\n    self.partner = self.env.ref('base.res_partner_1')\n    self.product = self.env.ref('product.product_delivery_01')\n    so_vals = {'partner_id': self.partner.id, 'partner_invoice_id': self.partner.id, 'partner_shipping_id': self.partner.id, 'order_line': [(0, 0, {'name': self.product.name, 'product_id': self.product.id, 'product_uom_qty': 5.0, 'product_uom': self.product.uom_id.id, 'price_unit': self.product.list_price})], 'pricelist_id': self.env.ref('product.list0').id}\n    self.so = self.env['sale.order'].create(so_vals)\n    self.so.action_confirm()\n    self.assertTrue(self.so.picking_ids, 'Sale Stock: no picking created for \"invoice on delivery\" stockable products')\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"no\" instead of \"%s\".' % self.so.invoice_status)\n    pick = self.so.picking_ids\n    pick.force_assign()\n    pick.pack_operation_product_ids.write({'qty_done': 5})\n    pick.do_new_transfer()\n    del_qty = sum((sol.qty_delivered for sol in self.so.order_line))\n    self.assertEqual(del_qty, 5.0, 'Sale Stock: delivered quantity should be 5.0 instead of %s after complete delivery' % del_qty)\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" instead of \"%s\" before invoicing' % self.so.invoice_status)\n    inv_1_id = self.so.action_invoice_create()\n    self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so invoice_status should be \"invoiced\" instead of \"%s\" after invoicing' % self.so.invoice_status)\n    self.assertEqual(len(inv_1_id), 1, 'Sale Stock: only one invoice instead of \"%s\" should be created' % len(inv_1_id))\n    self.inv_1 = self.env['account.invoice'].browse(inv_1_id)\n    self.assertEqual(self.inv_1.amount_untaxed, self.inv_1.amount_untaxed, 'Sale Stock: amount in SO and invoice should be the same')\n    self.inv_1.action_invoice_open()\n    StockReturnPicking = self.env['stock.return.picking']\n    default_data = StockReturnPicking.with_context(active_ids=pick.ids, active_id=pick.ids[0]).default_get(['move_dest_exists', 'original_location_id', 'product_return_moves', 'parent_location_id', 'location_id'])\n    return_wiz = StockReturnPicking.with_context(active_ids=pick.ids, active_id=pick.ids[0]).create(default_data)\n    return_wiz.product_return_moves.quantity = 2.0\n    return_wiz.product_return_moves.to_refund_so = True\n    res = return_wiz.create_returns()\n    return_pick = self.env['stock.picking'].browse(res['res_id'])\n    return_pick.force_assign()\n    return_pick.pack_operation_product_ids.write({'qty_done': 2})\n    return_pick.do_new_transfer()\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" instead of \"%s\" after picking return' % self.so.invoice_status)\n    self.assertEqual(self.so.order_line[0].qty_delivered, 3.0, 'Sale Stock: delivered quantity should be 3.0 instead of \"%s\" after picking return' % self.so.order_line[0].qty_delivered)\n    adv_wiz = self.env['sale.advance.payment.inv'].with_context(active_ids=[self.so.id]).create({'advance_payment_method': 'all'})\n    adv_wiz.with_context(open_invoices=True).create_invoices()\n    self.inv_2 = self.so.invoice_ids.filtered(lambda r: r.state == 'draft')\n    self.assertEqual(self.inv_2.invoice_line_ids[0].quantity, 2.0, 'Sale Stock: refund quantity on the invoice should be 2.0 instead of \"%s\".' % self.inv_2.invoice_line_ids[0].quantity)\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"no\" instead of \"%s\" after invoicing the return' % self.so.invoice_status)",
            "def test_02_sale_stock_return(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Test a SO with a product invoiced on delivery. Deliver and invoice the SO, then do a return\\n        of the picking. Check that a refund invoice is well generated.\\n        '\n    self.partner = self.env.ref('base.res_partner_1')\n    self.product = self.env.ref('product.product_delivery_01')\n    so_vals = {'partner_id': self.partner.id, 'partner_invoice_id': self.partner.id, 'partner_shipping_id': self.partner.id, 'order_line': [(0, 0, {'name': self.product.name, 'product_id': self.product.id, 'product_uom_qty': 5.0, 'product_uom': self.product.uom_id.id, 'price_unit': self.product.list_price})], 'pricelist_id': self.env.ref('product.list0').id}\n    self.so = self.env['sale.order'].create(so_vals)\n    self.so.action_confirm()\n    self.assertTrue(self.so.picking_ids, 'Sale Stock: no picking created for \"invoice on delivery\" stockable products')\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"no\" instead of \"%s\".' % self.so.invoice_status)\n    pick = self.so.picking_ids\n    pick.force_assign()\n    pick.pack_operation_product_ids.write({'qty_done': 5})\n    pick.do_new_transfer()\n    del_qty = sum((sol.qty_delivered for sol in self.so.order_line))\n    self.assertEqual(del_qty, 5.0, 'Sale Stock: delivered quantity should be 5.0 instead of %s after complete delivery' % del_qty)\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" instead of \"%s\" before invoicing' % self.so.invoice_status)\n    inv_1_id = self.so.action_invoice_create()\n    self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so invoice_status should be \"invoiced\" instead of \"%s\" after invoicing' % self.so.invoice_status)\n    self.assertEqual(len(inv_1_id), 1, 'Sale Stock: only one invoice instead of \"%s\" should be created' % len(inv_1_id))\n    self.inv_1 = self.env['account.invoice'].browse(inv_1_id)\n    self.assertEqual(self.inv_1.amount_untaxed, self.inv_1.amount_untaxed, 'Sale Stock: amount in SO and invoice should be the same')\n    self.inv_1.action_invoice_open()\n    StockReturnPicking = self.env['stock.return.picking']\n    default_data = StockReturnPicking.with_context(active_ids=pick.ids, active_id=pick.ids[0]).default_get(['move_dest_exists', 'original_location_id', 'product_return_moves', 'parent_location_id', 'location_id'])\n    return_wiz = StockReturnPicking.with_context(active_ids=pick.ids, active_id=pick.ids[0]).create(default_data)\n    return_wiz.product_return_moves.quantity = 2.0\n    return_wiz.product_return_moves.to_refund_so = True\n    res = return_wiz.create_returns()\n    return_pick = self.env['stock.picking'].browse(res['res_id'])\n    return_pick.force_assign()\n    return_pick.pack_operation_product_ids.write({'qty_done': 2})\n    return_pick.do_new_transfer()\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" instead of \"%s\" after picking return' % self.so.invoice_status)\n    self.assertEqual(self.so.order_line[0].qty_delivered, 3.0, 'Sale Stock: delivered quantity should be 3.0 instead of \"%s\" after picking return' % self.so.order_line[0].qty_delivered)\n    adv_wiz = self.env['sale.advance.payment.inv'].with_context(active_ids=[self.so.id]).create({'advance_payment_method': 'all'})\n    adv_wiz.with_context(open_invoices=True).create_invoices()\n    self.inv_2 = self.so.invoice_ids.filtered(lambda r: r.state == 'draft')\n    self.assertEqual(self.inv_2.invoice_line_ids[0].quantity, 2.0, 'Sale Stock: refund quantity on the invoice should be 2.0 instead of \"%s\".' % self.inv_2.invoice_line_ids[0].quantity)\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"no\" instead of \"%s\" after invoicing the return' % self.so.invoice_status)"
        ]
    },
    {
        "func_name": "test_03_sale_stock_delivery_partial",
        "original": "def test_03_sale_stock_delivery_partial(self):\n    \"\"\"\n        Test a SO with a product invoiced on delivery. Deliver partially and invoice the SO, when\n        the SO is set on 'done', the SO should be fully invoiced.\n        \"\"\"\n    self.partner = self.env.ref('base.res_partner_1')\n    self.product = self.env.ref('product.product_delivery_01')\n    so_vals = {'partner_id': self.partner.id, 'partner_invoice_id': self.partner.id, 'partner_shipping_id': self.partner.id, 'order_line': [(0, 0, {'name': self.product.name, 'product_id': self.product.id, 'product_uom_qty': 5.0, 'product_uom': self.product.uom_id.id, 'price_unit': self.product.list_price})], 'pricelist_id': self.env.ref('product.list0').id}\n    self.so = self.env['sale.order'].create(so_vals)\n    self.so.action_confirm()\n    self.assertTrue(self.so.picking_ids, 'Sale Stock: no picking created for \"invoice on delivery\" stockable products')\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"nothing to invoice\"')\n    pick = self.so.picking_ids\n    pick.force_assign()\n    pick.pack_operation_product_ids.write({'qty_done': 4})\n    backorder_wiz_id = pick.do_new_transfer()['res_id']\n    backorder_wiz = self.env['stock.backorder.confirmation'].browse([backorder_wiz_id])\n    backorder_wiz.process_cancel_backorder()\n    del_qty = sum((sol.qty_delivered for sol in self.so.order_line))\n    self.assertEqual(del_qty, 4.0, 'Sale Stock: delivered quantity should be 4.0 after partial delivery')\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" before invoicing')\n    inv_1_id = self.so.action_invoice_create()\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"no\" after invoicing')\n    self.assertEqual(len(inv_1_id), 1, 'Sale Stock: only one invoice should be created')\n    self.inv_1 = self.env['account.invoice'].browse(inv_1_id)\n    self.assertEqual(self.inv_1.amount_untaxed, self.inv_1.amount_untaxed, 'Sale Stock: amount in SO and invoice should be the same')\n    self.so.action_done()\n    self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so invoice_status should be \"invoiced\" when set to done')",
        "mutated": [
            "def test_03_sale_stock_delivery_partial(self):\n    if False:\n        i = 10\n    \"\\n        Test a SO with a product invoiced on delivery. Deliver partially and invoice the SO, when\\n        the SO is set on 'done', the SO should be fully invoiced.\\n        \"\n    self.partner = self.env.ref('base.res_partner_1')\n    self.product = self.env.ref('product.product_delivery_01')\n    so_vals = {'partner_id': self.partner.id, 'partner_invoice_id': self.partner.id, 'partner_shipping_id': self.partner.id, 'order_line': [(0, 0, {'name': self.product.name, 'product_id': self.product.id, 'product_uom_qty': 5.0, 'product_uom': self.product.uom_id.id, 'price_unit': self.product.list_price})], 'pricelist_id': self.env.ref('product.list0').id}\n    self.so = self.env['sale.order'].create(so_vals)\n    self.so.action_confirm()\n    self.assertTrue(self.so.picking_ids, 'Sale Stock: no picking created for \"invoice on delivery\" stockable products')\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"nothing to invoice\"')\n    pick = self.so.picking_ids\n    pick.force_assign()\n    pick.pack_operation_product_ids.write({'qty_done': 4})\n    backorder_wiz_id = pick.do_new_transfer()['res_id']\n    backorder_wiz = self.env['stock.backorder.confirmation'].browse([backorder_wiz_id])\n    backorder_wiz.process_cancel_backorder()\n    del_qty = sum((sol.qty_delivered for sol in self.so.order_line))\n    self.assertEqual(del_qty, 4.0, 'Sale Stock: delivered quantity should be 4.0 after partial delivery')\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" before invoicing')\n    inv_1_id = self.so.action_invoice_create()\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"no\" after invoicing')\n    self.assertEqual(len(inv_1_id), 1, 'Sale Stock: only one invoice should be created')\n    self.inv_1 = self.env['account.invoice'].browse(inv_1_id)\n    self.assertEqual(self.inv_1.amount_untaxed, self.inv_1.amount_untaxed, 'Sale Stock: amount in SO and invoice should be the same')\n    self.so.action_done()\n    self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so invoice_status should be \"invoiced\" when set to done')",
            "def test_03_sale_stock_delivery_partial(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Test a SO with a product invoiced on delivery. Deliver partially and invoice the SO, when\\n        the SO is set on 'done', the SO should be fully invoiced.\\n        \"\n    self.partner = self.env.ref('base.res_partner_1')\n    self.product = self.env.ref('product.product_delivery_01')\n    so_vals = {'partner_id': self.partner.id, 'partner_invoice_id': self.partner.id, 'partner_shipping_id': self.partner.id, 'order_line': [(0, 0, {'name': self.product.name, 'product_id': self.product.id, 'product_uom_qty': 5.0, 'product_uom': self.product.uom_id.id, 'price_unit': self.product.list_price})], 'pricelist_id': self.env.ref('product.list0').id}\n    self.so = self.env['sale.order'].create(so_vals)\n    self.so.action_confirm()\n    self.assertTrue(self.so.picking_ids, 'Sale Stock: no picking created for \"invoice on delivery\" stockable products')\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"nothing to invoice\"')\n    pick = self.so.picking_ids\n    pick.force_assign()\n    pick.pack_operation_product_ids.write({'qty_done': 4})\n    backorder_wiz_id = pick.do_new_transfer()['res_id']\n    backorder_wiz = self.env['stock.backorder.confirmation'].browse([backorder_wiz_id])\n    backorder_wiz.process_cancel_backorder()\n    del_qty = sum((sol.qty_delivered for sol in self.so.order_line))\n    self.assertEqual(del_qty, 4.0, 'Sale Stock: delivered quantity should be 4.0 after partial delivery')\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" before invoicing')\n    inv_1_id = self.so.action_invoice_create()\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"no\" after invoicing')\n    self.assertEqual(len(inv_1_id), 1, 'Sale Stock: only one invoice should be created')\n    self.inv_1 = self.env['account.invoice'].browse(inv_1_id)\n    self.assertEqual(self.inv_1.amount_untaxed, self.inv_1.amount_untaxed, 'Sale Stock: amount in SO and invoice should be the same')\n    self.so.action_done()\n    self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so invoice_status should be \"invoiced\" when set to done')",
            "def test_03_sale_stock_delivery_partial(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Test a SO with a product invoiced on delivery. Deliver partially and invoice the SO, when\\n        the SO is set on 'done', the SO should be fully invoiced.\\n        \"\n    self.partner = self.env.ref('base.res_partner_1')\n    self.product = self.env.ref('product.product_delivery_01')\n    so_vals = {'partner_id': self.partner.id, 'partner_invoice_id': self.partner.id, 'partner_shipping_id': self.partner.id, 'order_line': [(0, 0, {'name': self.product.name, 'product_id': self.product.id, 'product_uom_qty': 5.0, 'product_uom': self.product.uom_id.id, 'price_unit': self.product.list_price})], 'pricelist_id': self.env.ref('product.list0').id}\n    self.so = self.env['sale.order'].create(so_vals)\n    self.so.action_confirm()\n    self.assertTrue(self.so.picking_ids, 'Sale Stock: no picking created for \"invoice on delivery\" stockable products')\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"nothing to invoice\"')\n    pick = self.so.picking_ids\n    pick.force_assign()\n    pick.pack_operation_product_ids.write({'qty_done': 4})\n    backorder_wiz_id = pick.do_new_transfer()['res_id']\n    backorder_wiz = self.env['stock.backorder.confirmation'].browse([backorder_wiz_id])\n    backorder_wiz.process_cancel_backorder()\n    del_qty = sum((sol.qty_delivered for sol in self.so.order_line))\n    self.assertEqual(del_qty, 4.0, 'Sale Stock: delivered quantity should be 4.0 after partial delivery')\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" before invoicing')\n    inv_1_id = self.so.action_invoice_create()\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"no\" after invoicing')\n    self.assertEqual(len(inv_1_id), 1, 'Sale Stock: only one invoice should be created')\n    self.inv_1 = self.env['account.invoice'].browse(inv_1_id)\n    self.assertEqual(self.inv_1.amount_untaxed, self.inv_1.amount_untaxed, 'Sale Stock: amount in SO and invoice should be the same')\n    self.so.action_done()\n    self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so invoice_status should be \"invoiced\" when set to done')",
            "def test_03_sale_stock_delivery_partial(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Test a SO with a product invoiced on delivery. Deliver partially and invoice the SO, when\\n        the SO is set on 'done', the SO should be fully invoiced.\\n        \"\n    self.partner = self.env.ref('base.res_partner_1')\n    self.product = self.env.ref('product.product_delivery_01')\n    so_vals = {'partner_id': self.partner.id, 'partner_invoice_id': self.partner.id, 'partner_shipping_id': self.partner.id, 'order_line': [(0, 0, {'name': self.product.name, 'product_id': self.product.id, 'product_uom_qty': 5.0, 'product_uom': self.product.uom_id.id, 'price_unit': self.product.list_price})], 'pricelist_id': self.env.ref('product.list0').id}\n    self.so = self.env['sale.order'].create(so_vals)\n    self.so.action_confirm()\n    self.assertTrue(self.so.picking_ids, 'Sale Stock: no picking created for \"invoice on delivery\" stockable products')\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"nothing to invoice\"')\n    pick = self.so.picking_ids\n    pick.force_assign()\n    pick.pack_operation_product_ids.write({'qty_done': 4})\n    backorder_wiz_id = pick.do_new_transfer()['res_id']\n    backorder_wiz = self.env['stock.backorder.confirmation'].browse([backorder_wiz_id])\n    backorder_wiz.process_cancel_backorder()\n    del_qty = sum((sol.qty_delivered for sol in self.so.order_line))\n    self.assertEqual(del_qty, 4.0, 'Sale Stock: delivered quantity should be 4.0 after partial delivery')\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" before invoicing')\n    inv_1_id = self.so.action_invoice_create()\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"no\" after invoicing')\n    self.assertEqual(len(inv_1_id), 1, 'Sale Stock: only one invoice should be created')\n    self.inv_1 = self.env['account.invoice'].browse(inv_1_id)\n    self.assertEqual(self.inv_1.amount_untaxed, self.inv_1.amount_untaxed, 'Sale Stock: amount in SO and invoice should be the same')\n    self.so.action_done()\n    self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so invoice_status should be \"invoiced\" when set to done')",
            "def test_03_sale_stock_delivery_partial(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Test a SO with a product invoiced on delivery. Deliver partially and invoice the SO, when\\n        the SO is set on 'done', the SO should be fully invoiced.\\n        \"\n    self.partner = self.env.ref('base.res_partner_1')\n    self.product = self.env.ref('product.product_delivery_01')\n    so_vals = {'partner_id': self.partner.id, 'partner_invoice_id': self.partner.id, 'partner_shipping_id': self.partner.id, 'order_line': [(0, 0, {'name': self.product.name, 'product_id': self.product.id, 'product_uom_qty': 5.0, 'product_uom': self.product.uom_id.id, 'price_unit': self.product.list_price})], 'pricelist_id': self.env.ref('product.list0').id}\n    self.so = self.env['sale.order'].create(so_vals)\n    self.so.action_confirm()\n    self.assertTrue(self.so.picking_ids, 'Sale Stock: no picking created for \"invoice on delivery\" stockable products')\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"nothing to invoice\"')\n    pick = self.so.picking_ids\n    pick.force_assign()\n    pick.pack_operation_product_ids.write({'qty_done': 4})\n    backorder_wiz_id = pick.do_new_transfer()['res_id']\n    backorder_wiz = self.env['stock.backorder.confirmation'].browse([backorder_wiz_id])\n    backorder_wiz.process_cancel_backorder()\n    del_qty = sum((sol.qty_delivered for sol in self.so.order_line))\n    self.assertEqual(del_qty, 4.0, 'Sale Stock: delivered quantity should be 4.0 after partial delivery')\n    self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be \"to invoice\" before invoicing')\n    inv_1_id = self.so.action_invoice_create()\n    self.assertEqual(self.so.invoice_status, 'no', 'Sale Stock: so invoice_status should be \"no\" after invoicing')\n    self.assertEqual(len(inv_1_id), 1, 'Sale Stock: only one invoice should be created')\n    self.inv_1 = self.env['account.invoice'].browse(inv_1_id)\n    self.assertEqual(self.inv_1.amount_untaxed, self.inv_1.amount_untaxed, 'Sale Stock: amount in SO and invoice should be the same')\n    self.so.action_done()\n    self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so invoice_status should be \"invoiced\" when set to done')"
        ]
    },
    {
        "func_name": "test_04_create_picking_update_saleorderline",
        "original": "def test_04_create_picking_update_saleorderline(self):\n    \"\"\"\n        Test that updating multiple sale order lines after a succesful delivery creates a single picking containing\n        the new move lines.\n        \"\"\"\n    item1 = self.products['prod_order']\n    item2 = self.products['prod_del']\n    self.so = self.env['sale.order'].create({'partner_id': self.partner.id, 'order_line': [(0, 0, {'name': item1.name, 'product_id': item1.id, 'product_uom_qty': 1, 'product_uom': item1.uom_id.id, 'price_unit': item1.list_price}), (0, 0, {'name': item2.name, 'product_id': item2.id, 'product_uom_qty': 1, 'product_uom': item2.uom_id.id, 'price_unit': item2.list_price})]})\n    self.so.action_confirm()\n    self.assertEquals(len(self.so.picking_ids), 1)\n    self.so.picking_ids[0].action_done()\n    self.assertEquals(self.so.picking_ids[0].state, 'done')\n    self.so.write({'order_line': [(1, self.so.order_line[0].id, {'product_uom_qty': 2}), (1, self.so.order_line[1].id, {'product_uom_qty': 2})]})\n    self.assertEquals(len(self.so.picking_ids), 2)",
        "mutated": [
            "def test_04_create_picking_update_saleorderline(self):\n    if False:\n        i = 10\n    '\\n        Test that updating multiple sale order lines after a succesful delivery creates a single picking containing\\n        the new move lines.\\n        '\n    item1 = self.products['prod_order']\n    item2 = self.products['prod_del']\n    self.so = self.env['sale.order'].create({'partner_id': self.partner.id, 'order_line': [(0, 0, {'name': item1.name, 'product_id': item1.id, 'product_uom_qty': 1, 'product_uom': item1.uom_id.id, 'price_unit': item1.list_price}), (0, 0, {'name': item2.name, 'product_id': item2.id, 'product_uom_qty': 1, 'product_uom': item2.uom_id.id, 'price_unit': item2.list_price})]})\n    self.so.action_confirm()\n    self.assertEquals(len(self.so.picking_ids), 1)\n    self.so.picking_ids[0].action_done()\n    self.assertEquals(self.so.picking_ids[0].state, 'done')\n    self.so.write({'order_line': [(1, self.so.order_line[0].id, {'product_uom_qty': 2}), (1, self.so.order_line[1].id, {'product_uom_qty': 2})]})\n    self.assertEquals(len(self.so.picking_ids), 2)",
            "def test_04_create_picking_update_saleorderline(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Test that updating multiple sale order lines after a succesful delivery creates a single picking containing\\n        the new move lines.\\n        '\n    item1 = self.products['prod_order']\n    item2 = self.products['prod_del']\n    self.so = self.env['sale.order'].create({'partner_id': self.partner.id, 'order_line': [(0, 0, {'name': item1.name, 'product_id': item1.id, 'product_uom_qty': 1, 'product_uom': item1.uom_id.id, 'price_unit': item1.list_price}), (0, 0, {'name': item2.name, 'product_id': item2.id, 'product_uom_qty': 1, 'product_uom': item2.uom_id.id, 'price_unit': item2.list_price})]})\n    self.so.action_confirm()\n    self.assertEquals(len(self.so.picking_ids), 1)\n    self.so.picking_ids[0].action_done()\n    self.assertEquals(self.so.picking_ids[0].state, 'done')\n    self.so.write({'order_line': [(1, self.so.order_line[0].id, {'product_uom_qty': 2}), (1, self.so.order_line[1].id, {'product_uom_qty': 2})]})\n    self.assertEquals(len(self.so.picking_ids), 2)",
            "def test_04_create_picking_update_saleorderline(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Test that updating multiple sale order lines after a succesful delivery creates a single picking containing\\n        the new move lines.\\n        '\n    item1 = self.products['prod_order']\n    item2 = self.products['prod_del']\n    self.so = self.env['sale.order'].create({'partner_id': self.partner.id, 'order_line': [(0, 0, {'name': item1.name, 'product_id': item1.id, 'product_uom_qty': 1, 'product_uom': item1.uom_id.id, 'price_unit': item1.list_price}), (0, 0, {'name': item2.name, 'product_id': item2.id, 'product_uom_qty': 1, 'product_uom': item2.uom_id.id, 'price_unit': item2.list_price})]})\n    self.so.action_confirm()\n    self.assertEquals(len(self.so.picking_ids), 1)\n    self.so.picking_ids[0].action_done()\n    self.assertEquals(self.so.picking_ids[0].state, 'done')\n    self.so.write({'order_line': [(1, self.so.order_line[0].id, {'product_uom_qty': 2}), (1, self.so.order_line[1].id, {'product_uom_qty': 2})]})\n    self.assertEquals(len(self.so.picking_ids), 2)",
            "def test_04_create_picking_update_saleorderline(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Test that updating multiple sale order lines after a succesful delivery creates a single picking containing\\n        the new move lines.\\n        '\n    item1 = self.products['prod_order']\n    item2 = self.products['prod_del']\n    self.so = self.env['sale.order'].create({'partner_id': self.partner.id, 'order_line': [(0, 0, {'name': item1.name, 'product_id': item1.id, 'product_uom_qty': 1, 'product_uom': item1.uom_id.id, 'price_unit': item1.list_price}), (0, 0, {'name': item2.name, 'product_id': item2.id, 'product_uom_qty': 1, 'product_uom': item2.uom_id.id, 'price_unit': item2.list_price})]})\n    self.so.action_confirm()\n    self.assertEquals(len(self.so.picking_ids), 1)\n    self.so.picking_ids[0].action_done()\n    self.assertEquals(self.so.picking_ids[0].state, 'done')\n    self.so.write({'order_line': [(1, self.so.order_line[0].id, {'product_uom_qty': 2}), (1, self.so.order_line[1].id, {'product_uom_qty': 2})]})\n    self.assertEquals(len(self.so.picking_ids), 2)",
            "def test_04_create_picking_update_saleorderline(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Test that updating multiple sale order lines after a succesful delivery creates a single picking containing\\n        the new move lines.\\n        '\n    item1 = self.products['prod_order']\n    item2 = self.products['prod_del']\n    self.so = self.env['sale.order'].create({'partner_id': self.partner.id, 'order_line': [(0, 0, {'name': item1.name, 'product_id': item1.id, 'product_uom_qty': 1, 'product_uom': item1.uom_id.id, 'price_unit': item1.list_price}), (0, 0, {'name': item2.name, 'product_id': item2.id, 'product_uom_qty': 1, 'product_uom': item2.uom_id.id, 'price_unit': item2.list_price})]})\n    self.so.action_confirm()\n    self.assertEquals(len(self.so.picking_ids), 1)\n    self.so.picking_ids[0].action_done()\n    self.assertEquals(self.so.picking_ids[0].state, 'done')\n    self.so.write({'order_line': [(1, self.so.order_line[0].id, {'product_uom_qty': 2}), (1, self.so.order_line[1].id, {'product_uom_qty': 2})]})\n    self.assertEquals(len(self.so.picking_ids), 2)"
        ]
    }
]