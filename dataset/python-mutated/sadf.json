[
    {
        "func_name": "_get_sadf_at_t",
        "original": "def _get_sadf_at_t(X: pd.DataFrame, y: pd.DataFrame, min_length: int, model: str, phi: float) -> float:\n    \"\"\"\n    Advances in Financial Machine Learning, Snippet 17.2, page 258.\n\n    SADF's Inner Loop (get SADF value at t)\n\n    :param X: (pd.DataFrame) Lagged values, constants, trend coefficients\n    :param y: (pd.DataFrame) Y values (either y or y.diff())\n    :param min_length: (int) Minimum number of samples needed for estimation\n    :param model: (str) Either 'linear', 'quadratic', 'sm_poly_1', 'sm_poly_2', 'sm_exp', 'sm_power'\n    :param phi: (float) Coefficient to penalize large sample lengths when computing SMT, in [0, 1]\n    :return: (float) SADF statistics for y.index[-1]\n    \"\"\"\n    pass",
        "mutated": [
            "def _get_sadf_at_t(X: pd.DataFrame, y: pd.DataFrame, min_length: int, model: str, phi: float) -> float:\n    if False:\n        i = 10\n    \"\\n    Advances in Financial Machine Learning, Snippet 17.2, page 258.\\n\\n    SADF's Inner Loop (get SADF value at t)\\n\\n    :param X: (pd.DataFrame) Lagged values, constants, trend coefficients\\n    :param y: (pd.DataFrame) Y values (either y or y.diff())\\n    :param min_length: (int) Minimum number of samples needed for estimation\\n    :param model: (str) Either 'linear', 'quadratic', 'sm_poly_1', 'sm_poly_2', 'sm_exp', 'sm_power'\\n    :param phi: (float) Coefficient to penalize large sample lengths when computing SMT, in [0, 1]\\n    :return: (float) SADF statistics for y.index[-1]\\n    \"\n    pass",
            "def _get_sadf_at_t(X: pd.DataFrame, y: pd.DataFrame, min_length: int, model: str, phi: float) -> float:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Advances in Financial Machine Learning, Snippet 17.2, page 258.\\n\\n    SADF's Inner Loop (get SADF value at t)\\n\\n    :param X: (pd.DataFrame) Lagged values, constants, trend coefficients\\n    :param y: (pd.DataFrame) Y values (either y or y.diff())\\n    :param min_length: (int) Minimum number of samples needed for estimation\\n    :param model: (str) Either 'linear', 'quadratic', 'sm_poly_1', 'sm_poly_2', 'sm_exp', 'sm_power'\\n    :param phi: (float) Coefficient to penalize large sample lengths when computing SMT, in [0, 1]\\n    :return: (float) SADF statistics for y.index[-1]\\n    \"\n    pass",
            "def _get_sadf_at_t(X: pd.DataFrame, y: pd.DataFrame, min_length: int, model: str, phi: float) -> float:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Advances in Financial Machine Learning, Snippet 17.2, page 258.\\n\\n    SADF's Inner Loop (get SADF value at t)\\n\\n    :param X: (pd.DataFrame) Lagged values, constants, trend coefficients\\n    :param y: (pd.DataFrame) Y values (either y or y.diff())\\n    :param min_length: (int) Minimum number of samples needed for estimation\\n    :param model: (str) Either 'linear', 'quadratic', 'sm_poly_1', 'sm_poly_2', 'sm_exp', 'sm_power'\\n    :param phi: (float) Coefficient to penalize large sample lengths when computing SMT, in [0, 1]\\n    :return: (float) SADF statistics for y.index[-1]\\n    \"\n    pass",
            "def _get_sadf_at_t(X: pd.DataFrame, y: pd.DataFrame, min_length: int, model: str, phi: float) -> float:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Advances in Financial Machine Learning, Snippet 17.2, page 258.\\n\\n    SADF's Inner Loop (get SADF value at t)\\n\\n    :param X: (pd.DataFrame) Lagged values, constants, trend coefficients\\n    :param y: (pd.DataFrame) Y values (either y or y.diff())\\n    :param min_length: (int) Minimum number of samples needed for estimation\\n    :param model: (str) Either 'linear', 'quadratic', 'sm_poly_1', 'sm_poly_2', 'sm_exp', 'sm_power'\\n    :param phi: (float) Coefficient to penalize large sample lengths when computing SMT, in [0, 1]\\n    :return: (float) SADF statistics for y.index[-1]\\n    \"\n    pass",
            "def _get_sadf_at_t(X: pd.DataFrame, y: pd.DataFrame, min_length: int, model: str, phi: float) -> float:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Advances in Financial Machine Learning, Snippet 17.2, page 258.\\n\\n    SADF's Inner Loop (get SADF value at t)\\n\\n    :param X: (pd.DataFrame) Lagged values, constants, trend coefficients\\n    :param y: (pd.DataFrame) Y values (either y or y.diff())\\n    :param min_length: (int) Minimum number of samples needed for estimation\\n    :param model: (str) Either 'linear', 'quadratic', 'sm_poly_1', 'sm_poly_2', 'sm_exp', 'sm_power'\\n    :param phi: (float) Coefficient to penalize large sample lengths when computing SMT, in [0, 1]\\n    :return: (float) SADF statistics for y.index[-1]\\n    \"\n    pass"
        ]
    },
    {
        "func_name": "_get_y_x",
        "original": "def _get_y_x(series: pd.Series, model: str, lags: Union[int, list], add_const: bool) -> Tuple[pd.DataFrame, pd.DataFrame]:\n    \"\"\"\n    Advances in Financial Machine Learning, Snippet 17.2, page 258-259.\n\n    Preparing The Datasets\n\n    :param series: (pd.Series) Series to prepare for test statistics generation (for example log prices)\n    :param model: (str) Either 'linear', 'quadratic', 'sm_poly_1', 'sm_poly_2', 'sm_exp', 'sm_power'\n    :param lags: (int or list) Either number of lags to use or array of specified lags\n    :param add_const: (bool) Flag to add constant\n    :return: (pd.DataFrame, pd.DataFrame) Prepared y and X for SADF generation\n    \"\"\"\n    pass",
        "mutated": [
            "def _get_y_x(series: pd.Series, model: str, lags: Union[int, list], add_const: bool) -> Tuple[pd.DataFrame, pd.DataFrame]:\n    if False:\n        i = 10\n    \"\\n    Advances in Financial Machine Learning, Snippet 17.2, page 258-259.\\n\\n    Preparing The Datasets\\n\\n    :param series: (pd.Series) Series to prepare for test statistics generation (for example log prices)\\n    :param model: (str) Either 'linear', 'quadratic', 'sm_poly_1', 'sm_poly_2', 'sm_exp', 'sm_power'\\n    :param lags: (int or list) Either number of lags to use or array of specified lags\\n    :param add_const: (bool) Flag to add constant\\n    :return: (pd.DataFrame, pd.DataFrame) Prepared y and X for SADF generation\\n    \"\n    pass",
            "def _get_y_x(series: pd.Series, model: str, lags: Union[int, list], add_const: bool) -> Tuple[pd.DataFrame, pd.DataFrame]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Advances in Financial Machine Learning, Snippet 17.2, page 258-259.\\n\\n    Preparing The Datasets\\n\\n    :param series: (pd.Series) Series to prepare for test statistics generation (for example log prices)\\n    :param model: (str) Either 'linear', 'quadratic', 'sm_poly_1', 'sm_poly_2', 'sm_exp', 'sm_power'\\n    :param lags: (int or list) Either number of lags to use or array of specified lags\\n    :param add_const: (bool) Flag to add constant\\n    :return: (pd.DataFrame, pd.DataFrame) Prepared y and X for SADF generation\\n    \"\n    pass",
            "def _get_y_x(series: pd.Series, model: str, lags: Union[int, list], add_const: bool) -> Tuple[pd.DataFrame, pd.DataFrame]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Advances in Financial Machine Learning, Snippet 17.2, page 258-259.\\n\\n    Preparing The Datasets\\n\\n    :param series: (pd.Series) Series to prepare for test statistics generation (for example log prices)\\n    :param model: (str) Either 'linear', 'quadratic', 'sm_poly_1', 'sm_poly_2', 'sm_exp', 'sm_power'\\n    :param lags: (int or list) Either number of lags to use or array of specified lags\\n    :param add_const: (bool) Flag to add constant\\n    :return: (pd.DataFrame, pd.DataFrame) Prepared y and X for SADF generation\\n    \"\n    pass",
            "def _get_y_x(series: pd.Series, model: str, lags: Union[int, list], add_const: bool) -> Tuple[pd.DataFrame, pd.DataFrame]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Advances in Financial Machine Learning, Snippet 17.2, page 258-259.\\n\\n    Preparing The Datasets\\n\\n    :param series: (pd.Series) Series to prepare for test statistics generation (for example log prices)\\n    :param model: (str) Either 'linear', 'quadratic', 'sm_poly_1', 'sm_poly_2', 'sm_exp', 'sm_power'\\n    :param lags: (int or list) Either number of lags to use or array of specified lags\\n    :param add_const: (bool) Flag to add constant\\n    :return: (pd.DataFrame, pd.DataFrame) Prepared y and X for SADF generation\\n    \"\n    pass",
            "def _get_y_x(series: pd.Series, model: str, lags: Union[int, list], add_const: bool) -> Tuple[pd.DataFrame, pd.DataFrame]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Advances in Financial Machine Learning, Snippet 17.2, page 258-259.\\n\\n    Preparing The Datasets\\n\\n    :param series: (pd.Series) Series to prepare for test statistics generation (for example log prices)\\n    :param model: (str) Either 'linear', 'quadratic', 'sm_poly_1', 'sm_poly_2', 'sm_exp', 'sm_power'\\n    :param lags: (int or list) Either number of lags to use or array of specified lags\\n    :param add_const: (bool) Flag to add constant\\n    :return: (pd.DataFrame, pd.DataFrame) Prepared y and X for SADF generation\\n    \"\n    pass"
        ]
    },
    {
        "func_name": "_lag_df",
        "original": "def _lag_df(df: pd.DataFrame, lags: Union[int, list]) -> pd.DataFrame:\n    \"\"\"\n    Advances in Financial Machine Learning, Snipet 17.3, page 259.\n\n    Apply Lags to DataFrame\n\n    :param df: (int or list) Either number of lags to use or array of specified lags\n    :param lags: (int or list) Lag(s) to use\n    :return: (pd.DataFrame) Dataframe with lags\n    \"\"\"\n    pass",
        "mutated": [
            "def _lag_df(df: pd.DataFrame, lags: Union[int, list]) -> pd.DataFrame:\n    if False:\n        i = 10\n    '\\n    Advances in Financial Machine Learning, Snipet 17.3, page 259.\\n\\n    Apply Lags to DataFrame\\n\\n    :param df: (int or list) Either number of lags to use or array of specified lags\\n    :param lags: (int or list) Lag(s) to use\\n    :return: (pd.DataFrame) Dataframe with lags\\n    '\n    pass",
            "def _lag_df(df: pd.DataFrame, lags: Union[int, list]) -> pd.DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Advances in Financial Machine Learning, Snipet 17.3, page 259.\\n\\n    Apply Lags to DataFrame\\n\\n    :param df: (int or list) Either number of lags to use or array of specified lags\\n    :param lags: (int or list) Lag(s) to use\\n    :return: (pd.DataFrame) Dataframe with lags\\n    '\n    pass",
            "def _lag_df(df: pd.DataFrame, lags: Union[int, list]) -> pd.DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Advances in Financial Machine Learning, Snipet 17.3, page 259.\\n\\n    Apply Lags to DataFrame\\n\\n    :param df: (int or list) Either number of lags to use or array of specified lags\\n    :param lags: (int or list) Lag(s) to use\\n    :return: (pd.DataFrame) Dataframe with lags\\n    '\n    pass",
            "def _lag_df(df: pd.DataFrame, lags: Union[int, list]) -> pd.DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Advances in Financial Machine Learning, Snipet 17.3, page 259.\\n\\n    Apply Lags to DataFrame\\n\\n    :param df: (int or list) Either number of lags to use or array of specified lags\\n    :param lags: (int or list) Lag(s) to use\\n    :return: (pd.DataFrame) Dataframe with lags\\n    '\n    pass",
            "def _lag_df(df: pd.DataFrame, lags: Union[int, list]) -> pd.DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Advances in Financial Machine Learning, Snipet 17.3, page 259.\\n\\n    Apply Lags to DataFrame\\n\\n    :param df: (int or list) Either number of lags to use or array of specified lags\\n    :param lags: (int or list) Lag(s) to use\\n    :return: (pd.DataFrame) Dataframe with lags\\n    '\n    pass"
        ]
    },
    {
        "func_name": "get_betas",
        "original": "def get_betas(X: pd.DataFrame, y: pd.DataFrame) -> Tuple[np.array, np.array]:\n    \"\"\"\n    Advances in Financial Machine Learning, Snippet 17.4, page 259.\n\n    Fitting The ADF Specification (get beta estimate and estimate variance)\n\n    :param X: (pd.DataFrame) Features(factors)\n    :param y: (pd.DataFrame) Outcomes\n    :return: (np.array, np.array) Betas and variances of estimates\n    \"\"\"\n    pass",
        "mutated": [
            "def get_betas(X: pd.DataFrame, y: pd.DataFrame) -> Tuple[np.array, np.array]:\n    if False:\n        i = 10\n    '\\n    Advances in Financial Machine Learning, Snippet 17.4, page 259.\\n\\n    Fitting The ADF Specification (get beta estimate and estimate variance)\\n\\n    :param X: (pd.DataFrame) Features(factors)\\n    :param y: (pd.DataFrame) Outcomes\\n    :return: (np.array, np.array) Betas and variances of estimates\\n    '\n    pass",
            "def get_betas(X: pd.DataFrame, y: pd.DataFrame) -> Tuple[np.array, np.array]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Advances in Financial Machine Learning, Snippet 17.4, page 259.\\n\\n    Fitting The ADF Specification (get beta estimate and estimate variance)\\n\\n    :param X: (pd.DataFrame) Features(factors)\\n    :param y: (pd.DataFrame) Outcomes\\n    :return: (np.array, np.array) Betas and variances of estimates\\n    '\n    pass",
            "def get_betas(X: pd.DataFrame, y: pd.DataFrame) -> Tuple[np.array, np.array]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Advances in Financial Machine Learning, Snippet 17.4, page 259.\\n\\n    Fitting The ADF Specification (get beta estimate and estimate variance)\\n\\n    :param X: (pd.DataFrame) Features(factors)\\n    :param y: (pd.DataFrame) Outcomes\\n    :return: (np.array, np.array) Betas and variances of estimates\\n    '\n    pass",
            "def get_betas(X: pd.DataFrame, y: pd.DataFrame) -> Tuple[np.array, np.array]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Advances in Financial Machine Learning, Snippet 17.4, page 259.\\n\\n    Fitting The ADF Specification (get beta estimate and estimate variance)\\n\\n    :param X: (pd.DataFrame) Features(factors)\\n    :param y: (pd.DataFrame) Outcomes\\n    :return: (np.array, np.array) Betas and variances of estimates\\n    '\n    pass",
            "def get_betas(X: pd.DataFrame, y: pd.DataFrame) -> Tuple[np.array, np.array]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Advances in Financial Machine Learning, Snippet 17.4, page 259.\\n\\n    Fitting The ADF Specification (get beta estimate and estimate variance)\\n\\n    :param X: (pd.DataFrame) Features(factors)\\n    :param y: (pd.DataFrame) Outcomes\\n    :return: (np.array, np.array) Betas and variances of estimates\\n    '\n    pass"
        ]
    },
    {
        "func_name": "_sadf_outer_loop",
        "original": "def _sadf_outer_loop(X: pd.DataFrame, y: pd.DataFrame, min_length: int, model: str, phi: float, molecule: list) -> pd.Series:\n    \"\"\"\n    This function gets SADF for t times from molecule\n\n    :param X: (pd.DataFrame) Features(factors)\n    :param y: (pd.DataFrame) Outcomes\n    :param min_length: (int) Minimum number of observations\n    :param model: (str) Either 'linear', 'quadratic', 'sm_poly_1', 'sm_poly_2', 'sm_exp', 'sm_power'\n    :param phi: (float) Coefficient to penalize large sample lengths when computing SMT, in [0, 1]\n    :param molecule: (list) Indices to get SADF\n    :return: (pd.Series) SADF statistics\n    \"\"\"\n    pass",
        "mutated": [
            "def _sadf_outer_loop(X: pd.DataFrame, y: pd.DataFrame, min_length: int, model: str, phi: float, molecule: list) -> pd.Series:\n    if False:\n        i = 10\n    \"\\n    This function gets SADF for t times from molecule\\n\\n    :param X: (pd.DataFrame) Features(factors)\\n    :param y: (pd.DataFrame) Outcomes\\n    :param min_length: (int) Minimum number of observations\\n    :param model: (str) Either 'linear', 'quadratic', 'sm_poly_1', 'sm_poly_2', 'sm_exp', 'sm_power'\\n    :param phi: (float) Coefficient to penalize large sample lengths when computing SMT, in [0, 1]\\n    :param molecule: (list) Indices to get SADF\\n    :return: (pd.Series) SADF statistics\\n    \"\n    pass",
            "def _sadf_outer_loop(X: pd.DataFrame, y: pd.DataFrame, min_length: int, model: str, phi: float, molecule: list) -> pd.Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    This function gets SADF for t times from molecule\\n\\n    :param X: (pd.DataFrame) Features(factors)\\n    :param y: (pd.DataFrame) Outcomes\\n    :param min_length: (int) Minimum number of observations\\n    :param model: (str) Either 'linear', 'quadratic', 'sm_poly_1', 'sm_poly_2', 'sm_exp', 'sm_power'\\n    :param phi: (float) Coefficient to penalize large sample lengths when computing SMT, in [0, 1]\\n    :param molecule: (list) Indices to get SADF\\n    :return: (pd.Series) SADF statistics\\n    \"\n    pass",
            "def _sadf_outer_loop(X: pd.DataFrame, y: pd.DataFrame, min_length: int, model: str, phi: float, molecule: list) -> pd.Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    This function gets SADF for t times from molecule\\n\\n    :param X: (pd.DataFrame) Features(factors)\\n    :param y: (pd.DataFrame) Outcomes\\n    :param min_length: (int) Minimum number of observations\\n    :param model: (str) Either 'linear', 'quadratic', 'sm_poly_1', 'sm_poly_2', 'sm_exp', 'sm_power'\\n    :param phi: (float) Coefficient to penalize large sample lengths when computing SMT, in [0, 1]\\n    :param molecule: (list) Indices to get SADF\\n    :return: (pd.Series) SADF statistics\\n    \"\n    pass",
            "def _sadf_outer_loop(X: pd.DataFrame, y: pd.DataFrame, min_length: int, model: str, phi: float, molecule: list) -> pd.Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    This function gets SADF for t times from molecule\\n\\n    :param X: (pd.DataFrame) Features(factors)\\n    :param y: (pd.DataFrame) Outcomes\\n    :param min_length: (int) Minimum number of observations\\n    :param model: (str) Either 'linear', 'quadratic', 'sm_poly_1', 'sm_poly_2', 'sm_exp', 'sm_power'\\n    :param phi: (float) Coefficient to penalize large sample lengths when computing SMT, in [0, 1]\\n    :param molecule: (list) Indices to get SADF\\n    :return: (pd.Series) SADF statistics\\n    \"\n    pass",
            "def _sadf_outer_loop(X: pd.DataFrame, y: pd.DataFrame, min_length: int, model: str, phi: float, molecule: list) -> pd.Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    This function gets SADF for t times from molecule\\n\\n    :param X: (pd.DataFrame) Features(factors)\\n    :param y: (pd.DataFrame) Outcomes\\n    :param min_length: (int) Minimum number of observations\\n    :param model: (str) Either 'linear', 'quadratic', 'sm_poly_1', 'sm_poly_2', 'sm_exp', 'sm_power'\\n    :param phi: (float) Coefficient to penalize large sample lengths when computing SMT, in [0, 1]\\n    :param molecule: (list) Indices to get SADF\\n    :return: (pd.Series) SADF statistics\\n    \"\n    pass"
        ]
    },
    {
        "func_name": "get_sadf",
        "original": "def get_sadf(series: pd.Series, model: str, lags: Union[int, list], min_length: int, add_const: bool=False, phi: float=0, num_threads: int=8, verbose: bool=True) -> pd.Series:\n    \"\"\"\n    Advances in Financial Machine Learning, p. 258-259.\n\n    Multithread implementation of SADF\n\n    SADF fits the ADF regression at each end point t with backwards expanding start points. For the estimation\n    of SADF(t), the right side of the window is fixed at t. SADF recursively expands the beginning of the sample\n    up to t - min_length, and returns the sup of this set.\n\n    When doing with sub- or super-martingale test, the variance of beta of a weak long-run bubble may be smaller than\n    one of a strong short-run bubble, hence biasing the method towards long-run bubbles. To correct for this bias,\n    ADF statistic in samples with large lengths can be penalized with the coefficient phi in [0, 1] such that:\n\n    ADF_penalized = ADF / (sample_length ^ phi)\n\n    :param series: (pd.Series) Series for which SADF statistics are generated\n    :param model: (str) Either 'linear', 'quadratic', 'sm_poly_1', 'sm_poly_2', 'sm_exp', 'sm_power'\n    :param lags: (int or list) Either number of lags to use or array of specified lags\n    :param min_length: (int) Minimum number of observations needed for estimation\n    :param add_const: (bool) Flag to add constant\n    :param phi: (float) Coefficient to penalize large sample lengths when computing SMT, in [0, 1]\n    :param num_threads: (int) Number of cores to use\n    :param verbose: (bool) Flag to report progress on asynch jobs\n    :return: (pd.Series) SADF statistics\n    \"\"\"\n    pass",
        "mutated": [
            "def get_sadf(series: pd.Series, model: str, lags: Union[int, list], min_length: int, add_const: bool=False, phi: float=0, num_threads: int=8, verbose: bool=True) -> pd.Series:\n    if False:\n        i = 10\n    \"\\n    Advances in Financial Machine Learning, p. 258-259.\\n\\n    Multithread implementation of SADF\\n\\n    SADF fits the ADF regression at each end point t with backwards expanding start points. For the estimation\\n    of SADF(t), the right side of the window is fixed at t. SADF recursively expands the beginning of the sample\\n    up to t - min_length, and returns the sup of this set.\\n\\n    When doing with sub- or super-martingale test, the variance of beta of a weak long-run bubble may be smaller than\\n    one of a strong short-run bubble, hence biasing the method towards long-run bubbles. To correct for this bias,\\n    ADF statistic in samples with large lengths can be penalized with the coefficient phi in [0, 1] such that:\\n\\n    ADF_penalized = ADF / (sample_length ^ phi)\\n\\n    :param series: (pd.Series) Series for which SADF statistics are generated\\n    :param model: (str) Either 'linear', 'quadratic', 'sm_poly_1', 'sm_poly_2', 'sm_exp', 'sm_power'\\n    :param lags: (int or list) Either number of lags to use or array of specified lags\\n    :param min_length: (int) Minimum number of observations needed for estimation\\n    :param add_const: (bool) Flag to add constant\\n    :param phi: (float) Coefficient to penalize large sample lengths when computing SMT, in [0, 1]\\n    :param num_threads: (int) Number of cores to use\\n    :param verbose: (bool) Flag to report progress on asynch jobs\\n    :return: (pd.Series) SADF statistics\\n    \"\n    pass",
            "def get_sadf(series: pd.Series, model: str, lags: Union[int, list], min_length: int, add_const: bool=False, phi: float=0, num_threads: int=8, verbose: bool=True) -> pd.Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Advances in Financial Machine Learning, p. 258-259.\\n\\n    Multithread implementation of SADF\\n\\n    SADF fits the ADF regression at each end point t with backwards expanding start points. For the estimation\\n    of SADF(t), the right side of the window is fixed at t. SADF recursively expands the beginning of the sample\\n    up to t - min_length, and returns the sup of this set.\\n\\n    When doing with sub- or super-martingale test, the variance of beta of a weak long-run bubble may be smaller than\\n    one of a strong short-run bubble, hence biasing the method towards long-run bubbles. To correct for this bias,\\n    ADF statistic in samples with large lengths can be penalized with the coefficient phi in [0, 1] such that:\\n\\n    ADF_penalized = ADF / (sample_length ^ phi)\\n\\n    :param series: (pd.Series) Series for which SADF statistics are generated\\n    :param model: (str) Either 'linear', 'quadratic', 'sm_poly_1', 'sm_poly_2', 'sm_exp', 'sm_power'\\n    :param lags: (int or list) Either number of lags to use or array of specified lags\\n    :param min_length: (int) Minimum number of observations needed for estimation\\n    :param add_const: (bool) Flag to add constant\\n    :param phi: (float) Coefficient to penalize large sample lengths when computing SMT, in [0, 1]\\n    :param num_threads: (int) Number of cores to use\\n    :param verbose: (bool) Flag to report progress on asynch jobs\\n    :return: (pd.Series) SADF statistics\\n    \"\n    pass",
            "def get_sadf(series: pd.Series, model: str, lags: Union[int, list], min_length: int, add_const: bool=False, phi: float=0, num_threads: int=8, verbose: bool=True) -> pd.Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Advances in Financial Machine Learning, p. 258-259.\\n\\n    Multithread implementation of SADF\\n\\n    SADF fits the ADF regression at each end point t with backwards expanding start points. For the estimation\\n    of SADF(t), the right side of the window is fixed at t. SADF recursively expands the beginning of the sample\\n    up to t - min_length, and returns the sup of this set.\\n\\n    When doing with sub- or super-martingale test, the variance of beta of a weak long-run bubble may be smaller than\\n    one of a strong short-run bubble, hence biasing the method towards long-run bubbles. To correct for this bias,\\n    ADF statistic in samples with large lengths can be penalized with the coefficient phi in [0, 1] such that:\\n\\n    ADF_penalized = ADF / (sample_length ^ phi)\\n\\n    :param series: (pd.Series) Series for which SADF statistics are generated\\n    :param model: (str) Either 'linear', 'quadratic', 'sm_poly_1', 'sm_poly_2', 'sm_exp', 'sm_power'\\n    :param lags: (int or list) Either number of lags to use or array of specified lags\\n    :param min_length: (int) Minimum number of observations needed for estimation\\n    :param add_const: (bool) Flag to add constant\\n    :param phi: (float) Coefficient to penalize large sample lengths when computing SMT, in [0, 1]\\n    :param num_threads: (int) Number of cores to use\\n    :param verbose: (bool) Flag to report progress on asynch jobs\\n    :return: (pd.Series) SADF statistics\\n    \"\n    pass",
            "def get_sadf(series: pd.Series, model: str, lags: Union[int, list], min_length: int, add_const: bool=False, phi: float=0, num_threads: int=8, verbose: bool=True) -> pd.Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Advances in Financial Machine Learning, p. 258-259.\\n\\n    Multithread implementation of SADF\\n\\n    SADF fits the ADF regression at each end point t with backwards expanding start points. For the estimation\\n    of SADF(t), the right side of the window is fixed at t. SADF recursively expands the beginning of the sample\\n    up to t - min_length, and returns the sup of this set.\\n\\n    When doing with sub- or super-martingale test, the variance of beta of a weak long-run bubble may be smaller than\\n    one of a strong short-run bubble, hence biasing the method towards long-run bubbles. To correct for this bias,\\n    ADF statistic in samples with large lengths can be penalized with the coefficient phi in [0, 1] such that:\\n\\n    ADF_penalized = ADF / (sample_length ^ phi)\\n\\n    :param series: (pd.Series) Series for which SADF statistics are generated\\n    :param model: (str) Either 'linear', 'quadratic', 'sm_poly_1', 'sm_poly_2', 'sm_exp', 'sm_power'\\n    :param lags: (int or list) Either number of lags to use or array of specified lags\\n    :param min_length: (int) Minimum number of observations needed for estimation\\n    :param add_const: (bool) Flag to add constant\\n    :param phi: (float) Coefficient to penalize large sample lengths when computing SMT, in [0, 1]\\n    :param num_threads: (int) Number of cores to use\\n    :param verbose: (bool) Flag to report progress on asynch jobs\\n    :return: (pd.Series) SADF statistics\\n    \"\n    pass",
            "def get_sadf(series: pd.Series, model: str, lags: Union[int, list], min_length: int, add_const: bool=False, phi: float=0, num_threads: int=8, verbose: bool=True) -> pd.Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Advances in Financial Machine Learning, p. 258-259.\\n\\n    Multithread implementation of SADF\\n\\n    SADF fits the ADF regression at each end point t with backwards expanding start points. For the estimation\\n    of SADF(t), the right side of the window is fixed at t. SADF recursively expands the beginning of the sample\\n    up to t - min_length, and returns the sup of this set.\\n\\n    When doing with sub- or super-martingale test, the variance of beta of a weak long-run bubble may be smaller than\\n    one of a strong short-run bubble, hence biasing the method towards long-run bubbles. To correct for this bias,\\n    ADF statistic in samples with large lengths can be penalized with the coefficient phi in [0, 1] such that:\\n\\n    ADF_penalized = ADF / (sample_length ^ phi)\\n\\n    :param series: (pd.Series) Series for which SADF statistics are generated\\n    :param model: (str) Either 'linear', 'quadratic', 'sm_poly_1', 'sm_poly_2', 'sm_exp', 'sm_power'\\n    :param lags: (int or list) Either number of lags to use or array of specified lags\\n    :param min_length: (int) Minimum number of observations needed for estimation\\n    :param add_const: (bool) Flag to add constant\\n    :param phi: (float) Coefficient to penalize large sample lengths when computing SMT, in [0, 1]\\n    :param num_threads: (int) Number of cores to use\\n    :param verbose: (bool) Flag to report progress on asynch jobs\\n    :return: (pd.Series) SADF statistics\\n    \"\n    pass"
        ]
    }
]