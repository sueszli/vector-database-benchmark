"""Case functions for Control Flow Operations."""
import collections
import functools
from tensorflow.python.eager import context
from tensorflow.python.framework import constant_op
from tensorflow.python.framework import dtypes
from tensorflow.python.framework import ops
from tensorflow.python.framework import tensor
from tensorflow.python.ops import array_ops_stack
from tensorflow.python.ops import cond
from tensorflow.python.ops import control_flow_assert
from tensorflow.python.ops import math_ops
from tensorflow.python.platform import tf_logging as logging
from tensorflow.python.util import dispatch
from tensorflow.python.util.tf_export import tf_export

@tf_export('case', v1=[])
@dispatch.add_dispatch_support
def case_v2(pred_fn_pairs, default=None, exclusive=False, strict=False, name='case'):
    if False:
        for i in range(10):
            print('nop')
    'Create a case operation.\n\n  See also `tf.switch_case`.\n\n  The `pred_fn_pairs` parameter is a list of pairs of size N.\n  Each pair contains a boolean scalar tensor and a python callable that\n  creates the tensors to be returned if the boolean evaluates to True.\n  `default` is a callable generating a list of tensors. All the callables\n  in `pred_fn_pairs` as well as `default` (if provided) should return the same\n  number and types of tensors.\n\n  If `exclusive==True`, all predicates are evaluated, and an exception is\n  thrown if more than one of the predicates evaluates to `True`.\n  If `exclusive==False`, execution stops at the first predicate which\n  evaluates to True, and the tensors generated by the corresponding function\n  are returned immediately. If none of the predicates evaluate to True, this\n  operation returns the tensors generated by `default`.\n\n  `tf.case` supports nested structures as implemented in\n  `tf.nest`. All of the callables must return the same (possibly nested) value\n  structure of lists, tuples, and/or named tuples. Singleton lists and tuples\n  form the only exceptions to this: when returned by a callable, they are\n  implicitly unpacked to single values. This behavior is disabled by passing\n  `strict=True`.\n\n  @compatibility(v2)\n  `pred_fn_pairs` could be a dictionary in v1. However, tf.Tensor and\n  tf.Variable are no longer hashable in v2, so cannot be used as a key for a\n  dictionary.  Please use a list or a tuple instead.\n  @end_compatibility\n\n\n  **Example 1:**\n\n  Pseudocode:\n\n  ```\n  if (x < y) return 17;\n  else return 23;\n  ```\n\n  Expressions:\n\n  ```python\n  f1 = lambda: tf.constant(17)\n  f2 = lambda: tf.constant(23)\n  r = tf.case([(tf.less(x, y), f1)], default=f2)\n  ```\n\n  **Example 2:**\n\n  Pseudocode:\n\n  ```\n  if (x < y && x > z) raise OpError("Only one predicate may evaluate to True");\n  if (x < y) return 17;\n  else if (x > z) return 23;\n  else return -1;\n  ```\n\n  Expressions:\n\n  ```python\n  def f1(): return tf.constant(17)\n  def f2(): return tf.constant(23)\n  def f3(): return tf.constant(-1)\n  r = tf.case([(tf.less(x, y), f1), (tf.greater(x, z), f2)],\n           default=f3, exclusive=True)\n  ```\n\n  Args:\n    pred_fn_pairs: List of pairs of a boolean scalar tensor and a callable which\n      returns a list of tensors.\n    default: Optional callable that returns a list of tensors.\n    exclusive: True iff at most one predicate is allowed to evaluate to `True`.\n    strict: A boolean that enables/disables \'strict\' mode; see above.\n    name: A name for this operation (optional).\n\n  Returns:\n    The tensors returned by the first pair whose predicate evaluated to True, or\n    those returned by `default` if none does.\n\n  Raises:\n    TypeError: If `pred_fn_pairs` is not a list/tuple.\n    TypeError: If `pred_fn_pairs` is a list but does not contain 2-tuples.\n    TypeError: If `fns[i]` is not callable for any i, or `default` is not\n               callable.\n  '
    return _case_helper(cond.cond, pred_fn_pairs, default, exclusive, name, allow_python_preds=False, strict=strict)

@tf_export(v1=['case'])
@dispatch.add_dispatch_support
def case(pred_fn_pairs, default=None, exclusive=False, strict=False, name='case'):
    if False:
        return 10
    'Create a case operation.\n\n  See also `tf.switch_case`.\n\n  The `pred_fn_pairs` parameter is a dict or list of pairs of size N.\n  Each pair contains a boolean scalar tensor and a python callable that\n  creates the tensors to be returned if the boolean evaluates to True.\n  `default` is a callable generating a list of tensors. All the callables\n  in `pred_fn_pairs` as well as `default` (if provided) should return the same\n  number and types of tensors.\n\n  If `exclusive==True`, all predicates are evaluated, and an exception is\n  thrown if more than one of the predicates evaluates to `True`.\n  If `exclusive==False`, execution stops at the first predicate which\n  evaluates to True, and the tensors generated by the corresponding function\n  are returned immediately. If none of the predicates evaluate to True, this\n  operation returns the tensors generated by `default`.\n\n  `tf.case` supports nested structures as implemented in\n  `tf.nest`. All of the callables must return the same (possibly nested) value\n  structure of lists, tuples, and/or named tuples. Singleton lists and tuples\n  form the only exceptions to this: when returned by a callable, they are\n  implicitly unpacked to single values. This behavior is disabled by passing\n  `strict=True`.\n\n  If an unordered dictionary is used for `pred_fn_pairs`, the order of the\n  conditional tests is not guaranteed. However, the order is guaranteed to be\n  deterministic, so that variables created in conditional branches are created\n  in fixed order across runs.\n\n  @compatibility(eager)\n  Unordered dictionaries are not supported in eager mode when `exclusive=False`.\n  Use a list of tuples instead.\n  @end_compatibility\n\n\n  **Example 1:**\n\n  Pseudocode:\n\n  ```\n  if (x < y) return 17;\n  else return 23;\n  ```\n\n  Expressions:\n\n  ```python\n  f1 = lambda: tf.constant(17)\n  f2 = lambda: tf.constant(23)\n  r = tf.case([(tf.less(x, y), f1)], default=f2)\n  ```\n\n  **Example 2:**\n\n  Pseudocode:\n\n  ```\n  if (x < y && x > z) raise OpError("Only one predicate may evaluate to True");\n  if (x < y) return 17;\n  else if (x > z) return 23;\n  else return -1;\n  ```\n\n  Expressions:\n\n  ```python\n  def f1(): return tf.constant(17)\n  def f2(): return tf.constant(23)\n  def f3(): return tf.constant(-1)\n  r = tf.case({tf.less(x, y): f1, tf.greater(x, z): f2},\n           default=f3, exclusive=True)\n  ```\n\n  Args:\n    pred_fn_pairs: Dict or list of pairs of a boolean scalar tensor and a\n      callable which returns a list of tensors.\n    default: Optional callable that returns a list of tensors.\n    exclusive: True iff at most one predicate is allowed to evaluate to `True`.\n    strict: A boolean that enables/disables \'strict\' mode; see above.\n    name: A name for this operation (optional).\n\n  Returns:\n    The tensors returned by the first pair whose predicate evaluated to True, or\n    those returned by `default` if none does.\n\n  Raises:\n    TypeError: If `pred_fn_pairs` is not a list/dictionary.\n    TypeError: If `pred_fn_pairs` is a list but does not contain 2-tuples.\n    TypeError: If `fns[i]` is not callable for any i, or `default` is not\n               callable.\n  '
    return _case_helper(cond.cond, pred_fn_pairs, default, exclusive, name, allow_python_preds=False, strict=strict)

def _assert_at_most_n_true(predicates, n, msg):
    if False:
        i = 10
        return i + 15
    'Returns an Assert op that checks that at most n predicates are True.\n\n  Args:\n    predicates: list of bool scalar tensors.\n    n: maximum number of true predicates allowed.\n    msg: Error message.\n  '
    preds_c = array_ops_stack.stack(predicates, name='preds_c')
    num_true_conditions = math_ops.reduce_sum(math_ops.cast(preds_c, dtypes.int32), name='num_true_conds')
    condition = math_ops.less_equal(num_true_conditions, constant_op.constant(n, name='n_true_conds'))
    preds_names = ', '.join((getattr(p, 'name', '?') for p in predicates))
    error_msg = ['%s: more than %d conditions (%s) evaluated as True:' % (msg, n, preds_names), preds_c]
    return control_flow_assert.Assert(condition, data=error_msg, summarize=len(predicates))

def _case_create_default_action(predicates, actions):
    if False:
        for i in range(10):
            print('nop')
    'Creates default action for a list of actions and their predicates.\n\n  It uses the input actions to select an arbitrary as default and makes sure\n  that corresponding predicates have valid values.\n\n  Args:\n    predicates: a list of bool scalar tensors\n    actions: a list of callable objects which return tensors.\n\n  Returns:\n    a callable\n  '
    k = len(predicates) - 1
    (predicate, action) = (predicates[k], actions[k])
    (other_predicates, other_actions) = (predicates[:k], actions[:k])

    def default_action():
        if False:
            while True:
                i = 10
        others_msg = 'Implementation error: selected default action #%d was called, but some of other predicates are True: ' % k
        default_msg = ('Input error: None of conditions evaluated as True:', array_ops_stack.stack(predicates, name='preds_c'))
        with ops.control_dependencies([_assert_at_most_n_true(other_predicates, n=0, msg=others_msg), control_flow_assert.Assert(predicate, data=default_msg)]):
            return action()
    return (default_action, other_predicates, other_actions)

def _case_helper(cond_fn, pred_fn_pairs, default, exclusive, name, allow_python_preds=False, **cond_kwargs):
    if False:
        i = 10
        return i + 15
    'Implementation of case that allows for different cond functions.\n\n  Args:\n    cond_fn: method that has signature and semantics of `cond` above.\n    pred_fn_pairs: Dict or list of pairs of a boolean scalar tensor, and a\n      callable which returns a list of tensors.\n    default: Optional callable that returns a list of tensors.\n    exclusive: True iff at most one predicate is allowed to evaluate to `True`.\n    name: A name for this operation (optional).\n    allow_python_preds: if true, pred_fn_pairs may contain Python bools in\n      addition to boolean Tensors\n    **cond_kwargs: keyword arguments that will be passed to `cond_fn`.\n\n  Returns:\n    The tensors returned by the first pair whose predicate evaluated to True, or\n    those returned by `default` if none does.\n\n  Raises:\n    TypeError: If `pred_fn_pairs` is not a list/dictionary.\n    TypeError: If `pred_fn_pairs` is a list but does not contain 2-tuples.\n    TypeError: If `fns[i]` is not callable for any i, or `default` is not\n               callable.\n  '
    (predicates, actions) = _case_verify_and_canonicalize_args(pred_fn_pairs, exclusive, name, allow_python_preds)
    with ops.name_scope(name, 'case', [predicates]):
        if default is None:
            (default, predicates, actions) = _case_create_default_action(predicates, actions)
        fn = default
        for (predicate, action) in reversed(list(zip(predicates, actions))):
            fn = functools.partial(cond_fn, predicate, true_fn=action, false_fn=fn, **cond_kwargs)
        if exclusive:
            with ops.control_dependencies([_assert_at_most_n_true(predicates, n=1, msg='Input error: exclusive=True')]):
                return fn()
        else:
            return fn()

def _case_verify_and_canonicalize_args(pred_fn_pairs, exclusive, name, allow_python_preds):
    if False:
        print('Hello World!')
    'Verifies input arguments for the case function.\n\n  Args:\n    pred_fn_pairs: Dict or list of pairs of a boolean scalar tensor, and a\n      callable which returns a list of tensors.\n    exclusive: True iff at most one predicate is allowed to evaluate to `True`.\n    name: A name for the case operation.\n    allow_python_preds: if true, pred_fn_pairs may contain Python bools in\n      addition to boolean Tensors\n\n  Raises:\n    TypeError: If `pred_fn_pairs` is not a list/dictionary.\n    TypeError: If `pred_fn_pairs` is a list but does not contain 2-tuples.\n    TypeError: If `fns[i]` is not callable for any i, or `default` is not\n               callable.\n\n  Returns:\n    a tuple <list of scalar bool tensors, list of callables>.\n  '
    if not isinstance(pred_fn_pairs, (list, tuple, dict)):
        raise TypeError(f"'pred_fn_pairs' must be a list, tuple, or dict. Received: {type(pred_fn_pairs)}")
    if isinstance(pred_fn_pairs, collections.OrderedDict):
        pred_fn_pairs = pred_fn_pairs.items()
    elif isinstance(pred_fn_pairs, dict):
        if context.executing_eagerly():
            if not exclusive:
                raise ValueError("Unordered dictionaries are not supported for the 'pred_fn_pairs' argument when `exclusive=False` and eager mode is enabled.")
            pred_fn_pairs = list(pred_fn_pairs.items())
        else:
            pred_fn_pairs = sorted(pred_fn_pairs.items(), key=lambda item: item[0].name)
            if not exclusive:
                logging.warn('%s: An unordered dictionary of predicate/fn pairs was provided, but exclusive=False. The order of conditional tests is deterministic but not guaranteed.', name)
    for pred_fn_pair in pred_fn_pairs:
        if not isinstance(pred_fn_pair, tuple) or len(pred_fn_pair) != 2:
            raise TypeError(f"Each entry in 'pred_fn_pairs' must be a 2-tuple. Received {pred_fn_pair}.")
        (pred, fn) = pred_fn_pair
        if isinstance(pred, tensor.Tensor):
            if pred.dtype != dtypes.bool:
                raise TypeError('pred must be Tensor of type bool: %s' % pred.name)
        elif not allow_python_preds:
            raise TypeError('pred must be a Tensor, got: %s' % pred)
        elif not isinstance(pred, bool):
            raise TypeError('pred must be a Tensor or bool, got: %s' % pred)
        if not callable(fn):
            raise TypeError('fn for pred %s must be callable.' % pred.name)
    (predicates, actions) = zip(*pred_fn_pairs)
    return (predicates, actions)