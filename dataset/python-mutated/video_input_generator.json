[
    {
        "func_name": "decode_image_sequence",
        "original": "def decode_image_sequence(tensor, image_format='jpeg', shape=None, channels=3, raw_dtype=tf.uint8):\n    \"\"\"Decodes a sequence of images.\n\n  Args:\n    tensor: the tensor of strings to decode, shape: [num_images]\n    image_format: a string (possibly tensor) with the format of the image.\n      Options include 'jpeg', 'png', and 'raw'.\n    shape: a list or tensor of the decoded image shape for a single image.\n    channels: if 'shape' is None, the third dimension of the image is set to\n      this value.\n    raw_dtype: if the image is encoded as raw bytes, this is the method of\n      decoding the bytes into values.\n  Returns:\n    The decoded images with shape [time, height, width, channels].\n  \"\"\"\n    handler = slim.tfexample_decoder.Image(shape=shape, channels=channels, dtype=raw_dtype, repeated=True)\n    return handler.tensors_to_item({'image/encoded': tensor, 'image/format': image_format})",
        "mutated": [
            "def decode_image_sequence(tensor, image_format='jpeg', shape=None, channels=3, raw_dtype=tf.uint8):\n    if False:\n        i = 10\n    \"Decodes a sequence of images.\\n\\n  Args:\\n    tensor: the tensor of strings to decode, shape: [num_images]\\n    image_format: a string (possibly tensor) with the format of the image.\\n      Options include 'jpeg', 'png', and 'raw'.\\n    shape: a list or tensor of the decoded image shape for a single image.\\n    channels: if 'shape' is None, the third dimension of the image is set to\\n      this value.\\n    raw_dtype: if the image is encoded as raw bytes, this is the method of\\n      decoding the bytes into values.\\n  Returns:\\n    The decoded images with shape [time, height, width, channels].\\n  \"\n    handler = slim.tfexample_decoder.Image(shape=shape, channels=channels, dtype=raw_dtype, repeated=True)\n    return handler.tensors_to_item({'image/encoded': tensor, 'image/format': image_format})",
            "def decode_image_sequence(tensor, image_format='jpeg', shape=None, channels=3, raw_dtype=tf.uint8):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Decodes a sequence of images.\\n\\n  Args:\\n    tensor: the tensor of strings to decode, shape: [num_images]\\n    image_format: a string (possibly tensor) with the format of the image.\\n      Options include 'jpeg', 'png', and 'raw'.\\n    shape: a list or tensor of the decoded image shape for a single image.\\n    channels: if 'shape' is None, the third dimension of the image is set to\\n      this value.\\n    raw_dtype: if the image is encoded as raw bytes, this is the method of\\n      decoding the bytes into values.\\n  Returns:\\n    The decoded images with shape [time, height, width, channels].\\n  \"\n    handler = slim.tfexample_decoder.Image(shape=shape, channels=channels, dtype=raw_dtype, repeated=True)\n    return handler.tensors_to_item({'image/encoded': tensor, 'image/format': image_format})",
            "def decode_image_sequence(tensor, image_format='jpeg', shape=None, channels=3, raw_dtype=tf.uint8):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Decodes a sequence of images.\\n\\n  Args:\\n    tensor: the tensor of strings to decode, shape: [num_images]\\n    image_format: a string (possibly tensor) with the format of the image.\\n      Options include 'jpeg', 'png', and 'raw'.\\n    shape: a list or tensor of the decoded image shape for a single image.\\n    channels: if 'shape' is None, the third dimension of the image is set to\\n      this value.\\n    raw_dtype: if the image is encoded as raw bytes, this is the method of\\n      decoding the bytes into values.\\n  Returns:\\n    The decoded images with shape [time, height, width, channels].\\n  \"\n    handler = slim.tfexample_decoder.Image(shape=shape, channels=channels, dtype=raw_dtype, repeated=True)\n    return handler.tensors_to_item({'image/encoded': tensor, 'image/format': image_format})",
            "def decode_image_sequence(tensor, image_format='jpeg', shape=None, channels=3, raw_dtype=tf.uint8):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Decodes a sequence of images.\\n\\n  Args:\\n    tensor: the tensor of strings to decode, shape: [num_images]\\n    image_format: a string (possibly tensor) with the format of the image.\\n      Options include 'jpeg', 'png', and 'raw'.\\n    shape: a list or tensor of the decoded image shape for a single image.\\n    channels: if 'shape' is None, the third dimension of the image is set to\\n      this value.\\n    raw_dtype: if the image is encoded as raw bytes, this is the method of\\n      decoding the bytes into values.\\n  Returns:\\n    The decoded images with shape [time, height, width, channels].\\n  \"\n    handler = slim.tfexample_decoder.Image(shape=shape, channels=channels, dtype=raw_dtype, repeated=True)\n    return handler.tensors_to_item({'image/encoded': tensor, 'image/format': image_format})",
            "def decode_image_sequence(tensor, image_format='jpeg', shape=None, channels=3, raw_dtype=tf.uint8):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Decodes a sequence of images.\\n\\n  Args:\\n    tensor: the tensor of strings to decode, shape: [num_images]\\n    image_format: a string (possibly tensor) with the format of the image.\\n      Options include 'jpeg', 'png', and 'raw'.\\n    shape: a list or tensor of the decoded image shape for a single image.\\n    channels: if 'shape' is None, the third dimension of the image is set to\\n      this value.\\n    raw_dtype: if the image is encoded as raw bytes, this is the method of\\n      decoding the bytes into values.\\n  Returns:\\n    The decoded images with shape [time, height, width, channels].\\n  \"\n    handler = slim.tfexample_decoder.Image(shape=shape, channels=channels, dtype=raw_dtype, repeated=True)\n    return handler.tensors_to_item({'image/encoded': tensor, 'image/format': image_format})"
        ]
    },
    {
        "func_name": "_get_data",
        "original": "def _get_data(data_provider, dataset_split, video_frames_are_decoded):\n    \"\"\"Gets data from data provider.\n\n  Args:\n    data_provider: An object of slim.data_provider.\n    dataset_split: Dataset split.\n    video_frames_are_decoded: Boolean, whether the video frames are already\n        decoded\n\n  Returns:\n    image: Image Tensor.\n    label: Label Tensor storing segmentation annotations.\n    object_label: An integer refers to object_label according to labelmap. If\n      the example has more than one object_label, take the first one.\n    image_name: Image name.\n    height: Image height.\n    width: Image width.\n    video_id: String tensor representing the name of the video.\n\n  Raises:\n    ValueError: Failed to find label.\n  \"\"\"\n    if video_frames_are_decoded:\n        (image,) = data_provider.get(['image'])\n    else:\n        (image,) = data_provider.get(['image/encoded'])\n    if 'image_name' in data_provider.list_items():\n        (image_name,) = data_provider.get(['image_name'])\n    else:\n        image_name = tf.constant('')\n    (height, width) = data_provider.get(['height', 'width'])\n    label = None\n    if dataset_split != 'test':\n        if video_frames_are_decoded:\n            if 'labels_class' not in data_provider.list_items():\n                raise ValueError('Failed to find labels.')\n            (label,) = data_provider.get(['labels_class'])\n        else:\n            key = 'segmentation/object/encoded'\n            if key not in data_provider.list_items():\n                raise ValueError('Failed to find labels.')\n            (label,) = data_provider.get([key])\n    object_label = None\n    (video_id,) = data_provider.get(['video_id'])\n    return (image, label, object_label, image_name, height, width, video_id)",
        "mutated": [
            "def _get_data(data_provider, dataset_split, video_frames_are_decoded):\n    if False:\n        i = 10\n    'Gets data from data provider.\\n\\n  Args:\\n    data_provider: An object of slim.data_provider.\\n    dataset_split: Dataset split.\\n    video_frames_are_decoded: Boolean, whether the video frames are already\\n        decoded\\n\\n  Returns:\\n    image: Image Tensor.\\n    label: Label Tensor storing segmentation annotations.\\n    object_label: An integer refers to object_label according to labelmap. If\\n      the example has more than one object_label, take the first one.\\n    image_name: Image name.\\n    height: Image height.\\n    width: Image width.\\n    video_id: String tensor representing the name of the video.\\n\\n  Raises:\\n    ValueError: Failed to find label.\\n  '\n    if video_frames_are_decoded:\n        (image,) = data_provider.get(['image'])\n    else:\n        (image,) = data_provider.get(['image/encoded'])\n    if 'image_name' in data_provider.list_items():\n        (image_name,) = data_provider.get(['image_name'])\n    else:\n        image_name = tf.constant('')\n    (height, width) = data_provider.get(['height', 'width'])\n    label = None\n    if dataset_split != 'test':\n        if video_frames_are_decoded:\n            if 'labels_class' not in data_provider.list_items():\n                raise ValueError('Failed to find labels.')\n            (label,) = data_provider.get(['labels_class'])\n        else:\n            key = 'segmentation/object/encoded'\n            if key not in data_provider.list_items():\n                raise ValueError('Failed to find labels.')\n            (label,) = data_provider.get([key])\n    object_label = None\n    (video_id,) = data_provider.get(['video_id'])\n    return (image, label, object_label, image_name, height, width, video_id)",
            "def _get_data(data_provider, dataset_split, video_frames_are_decoded):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Gets data from data provider.\\n\\n  Args:\\n    data_provider: An object of slim.data_provider.\\n    dataset_split: Dataset split.\\n    video_frames_are_decoded: Boolean, whether the video frames are already\\n        decoded\\n\\n  Returns:\\n    image: Image Tensor.\\n    label: Label Tensor storing segmentation annotations.\\n    object_label: An integer refers to object_label according to labelmap. If\\n      the example has more than one object_label, take the first one.\\n    image_name: Image name.\\n    height: Image height.\\n    width: Image width.\\n    video_id: String tensor representing the name of the video.\\n\\n  Raises:\\n    ValueError: Failed to find label.\\n  '\n    if video_frames_are_decoded:\n        (image,) = data_provider.get(['image'])\n    else:\n        (image,) = data_provider.get(['image/encoded'])\n    if 'image_name' in data_provider.list_items():\n        (image_name,) = data_provider.get(['image_name'])\n    else:\n        image_name = tf.constant('')\n    (height, width) = data_provider.get(['height', 'width'])\n    label = None\n    if dataset_split != 'test':\n        if video_frames_are_decoded:\n            if 'labels_class' not in data_provider.list_items():\n                raise ValueError('Failed to find labels.')\n            (label,) = data_provider.get(['labels_class'])\n        else:\n            key = 'segmentation/object/encoded'\n            if key not in data_provider.list_items():\n                raise ValueError('Failed to find labels.')\n            (label,) = data_provider.get([key])\n    object_label = None\n    (video_id,) = data_provider.get(['video_id'])\n    return (image, label, object_label, image_name, height, width, video_id)",
            "def _get_data(data_provider, dataset_split, video_frames_are_decoded):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Gets data from data provider.\\n\\n  Args:\\n    data_provider: An object of slim.data_provider.\\n    dataset_split: Dataset split.\\n    video_frames_are_decoded: Boolean, whether the video frames are already\\n        decoded\\n\\n  Returns:\\n    image: Image Tensor.\\n    label: Label Tensor storing segmentation annotations.\\n    object_label: An integer refers to object_label according to labelmap. If\\n      the example has more than one object_label, take the first one.\\n    image_name: Image name.\\n    height: Image height.\\n    width: Image width.\\n    video_id: String tensor representing the name of the video.\\n\\n  Raises:\\n    ValueError: Failed to find label.\\n  '\n    if video_frames_are_decoded:\n        (image,) = data_provider.get(['image'])\n    else:\n        (image,) = data_provider.get(['image/encoded'])\n    if 'image_name' in data_provider.list_items():\n        (image_name,) = data_provider.get(['image_name'])\n    else:\n        image_name = tf.constant('')\n    (height, width) = data_provider.get(['height', 'width'])\n    label = None\n    if dataset_split != 'test':\n        if video_frames_are_decoded:\n            if 'labels_class' not in data_provider.list_items():\n                raise ValueError('Failed to find labels.')\n            (label,) = data_provider.get(['labels_class'])\n        else:\n            key = 'segmentation/object/encoded'\n            if key not in data_provider.list_items():\n                raise ValueError('Failed to find labels.')\n            (label,) = data_provider.get([key])\n    object_label = None\n    (video_id,) = data_provider.get(['video_id'])\n    return (image, label, object_label, image_name, height, width, video_id)",
            "def _get_data(data_provider, dataset_split, video_frames_are_decoded):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Gets data from data provider.\\n\\n  Args:\\n    data_provider: An object of slim.data_provider.\\n    dataset_split: Dataset split.\\n    video_frames_are_decoded: Boolean, whether the video frames are already\\n        decoded\\n\\n  Returns:\\n    image: Image Tensor.\\n    label: Label Tensor storing segmentation annotations.\\n    object_label: An integer refers to object_label according to labelmap. If\\n      the example has more than one object_label, take the first one.\\n    image_name: Image name.\\n    height: Image height.\\n    width: Image width.\\n    video_id: String tensor representing the name of the video.\\n\\n  Raises:\\n    ValueError: Failed to find label.\\n  '\n    if video_frames_are_decoded:\n        (image,) = data_provider.get(['image'])\n    else:\n        (image,) = data_provider.get(['image/encoded'])\n    if 'image_name' in data_provider.list_items():\n        (image_name,) = data_provider.get(['image_name'])\n    else:\n        image_name = tf.constant('')\n    (height, width) = data_provider.get(['height', 'width'])\n    label = None\n    if dataset_split != 'test':\n        if video_frames_are_decoded:\n            if 'labels_class' not in data_provider.list_items():\n                raise ValueError('Failed to find labels.')\n            (label,) = data_provider.get(['labels_class'])\n        else:\n            key = 'segmentation/object/encoded'\n            if key not in data_provider.list_items():\n                raise ValueError('Failed to find labels.')\n            (label,) = data_provider.get([key])\n    object_label = None\n    (video_id,) = data_provider.get(['video_id'])\n    return (image, label, object_label, image_name, height, width, video_id)",
            "def _get_data(data_provider, dataset_split, video_frames_are_decoded):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Gets data from data provider.\\n\\n  Args:\\n    data_provider: An object of slim.data_provider.\\n    dataset_split: Dataset split.\\n    video_frames_are_decoded: Boolean, whether the video frames are already\\n        decoded\\n\\n  Returns:\\n    image: Image Tensor.\\n    label: Label Tensor storing segmentation annotations.\\n    object_label: An integer refers to object_label according to labelmap. If\\n      the example has more than one object_label, take the first one.\\n    image_name: Image name.\\n    height: Image height.\\n    width: Image width.\\n    video_id: String tensor representing the name of the video.\\n\\n  Raises:\\n    ValueError: Failed to find label.\\n  '\n    if video_frames_are_decoded:\n        (image,) = data_provider.get(['image'])\n    else:\n        (image,) = data_provider.get(['image/encoded'])\n    if 'image_name' in data_provider.list_items():\n        (image_name,) = data_provider.get(['image_name'])\n    else:\n        image_name = tf.constant('')\n    (height, width) = data_provider.get(['height', 'width'])\n    label = None\n    if dataset_split != 'test':\n        if video_frames_are_decoded:\n            if 'labels_class' not in data_provider.list_items():\n                raise ValueError('Failed to find labels.')\n            (label,) = data_provider.get(['labels_class'])\n        else:\n            key = 'segmentation/object/encoded'\n            if key not in data_provider.list_items():\n                raise ValueError('Failed to find labels.')\n            (label,) = data_provider.get([key])\n    object_label = None\n    (video_id,) = data_provider.get(['video_id'])\n    return (image, label, object_label, image_name, height, width, video_id)"
        ]
    },
    {
        "func_name": "_has_foreground_and_background_in_first_frame",
        "original": "def _has_foreground_and_background_in_first_frame(label, subsampling_factor):\n    \"\"\"Checks if the labels have foreground and background in the first frame.\n\n  Args:\n    label: Label tensor of shape [num_frames, height, width, 1].\n    subsampling_factor: Integer, the subsampling factor.\n\n  Returns:\n    Boolean, whether the labels have foreground and background in the first\n      frame.\n  \"\"\"\n    (h, w) = train_utils.resolve_shape(label)[1:3]\n    label_downscaled = tf.squeeze(tf.image.resize_nearest_neighbor(label[0, tf.newaxis], [h // subsampling_factor, w // subsampling_factor], align_corners=True), axis=0)\n    is_bg = tf.equal(label_downscaled, 0)\n    is_fg = tf.logical_not(is_bg)\n    fg_count = tf.reduce_sum(tf.cast(is_fg, tf.int32))\n    bg_count = tf.reduce_sum(tf.cast(is_bg, tf.int32))\n    has_bg = tf.greater_equal(fg_count, MIN_LABEL_COUNT)\n    has_fg = tf.greater_equal(bg_count, MIN_LABEL_COUNT)\n    return tf.logical_and(has_bg, has_fg)",
        "mutated": [
            "def _has_foreground_and_background_in_first_frame(label, subsampling_factor):\n    if False:\n        i = 10\n    'Checks if the labels have foreground and background in the first frame.\\n\\n  Args:\\n    label: Label tensor of shape [num_frames, height, width, 1].\\n    subsampling_factor: Integer, the subsampling factor.\\n\\n  Returns:\\n    Boolean, whether the labels have foreground and background in the first\\n      frame.\\n  '\n    (h, w) = train_utils.resolve_shape(label)[1:3]\n    label_downscaled = tf.squeeze(tf.image.resize_nearest_neighbor(label[0, tf.newaxis], [h // subsampling_factor, w // subsampling_factor], align_corners=True), axis=0)\n    is_bg = tf.equal(label_downscaled, 0)\n    is_fg = tf.logical_not(is_bg)\n    fg_count = tf.reduce_sum(tf.cast(is_fg, tf.int32))\n    bg_count = tf.reduce_sum(tf.cast(is_bg, tf.int32))\n    has_bg = tf.greater_equal(fg_count, MIN_LABEL_COUNT)\n    has_fg = tf.greater_equal(bg_count, MIN_LABEL_COUNT)\n    return tf.logical_and(has_bg, has_fg)",
            "def _has_foreground_and_background_in_first_frame(label, subsampling_factor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Checks if the labels have foreground and background in the first frame.\\n\\n  Args:\\n    label: Label tensor of shape [num_frames, height, width, 1].\\n    subsampling_factor: Integer, the subsampling factor.\\n\\n  Returns:\\n    Boolean, whether the labels have foreground and background in the first\\n      frame.\\n  '\n    (h, w) = train_utils.resolve_shape(label)[1:3]\n    label_downscaled = tf.squeeze(tf.image.resize_nearest_neighbor(label[0, tf.newaxis], [h // subsampling_factor, w // subsampling_factor], align_corners=True), axis=0)\n    is_bg = tf.equal(label_downscaled, 0)\n    is_fg = tf.logical_not(is_bg)\n    fg_count = tf.reduce_sum(tf.cast(is_fg, tf.int32))\n    bg_count = tf.reduce_sum(tf.cast(is_bg, tf.int32))\n    has_bg = tf.greater_equal(fg_count, MIN_LABEL_COUNT)\n    has_fg = tf.greater_equal(bg_count, MIN_LABEL_COUNT)\n    return tf.logical_and(has_bg, has_fg)",
            "def _has_foreground_and_background_in_first_frame(label, subsampling_factor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Checks if the labels have foreground and background in the first frame.\\n\\n  Args:\\n    label: Label tensor of shape [num_frames, height, width, 1].\\n    subsampling_factor: Integer, the subsampling factor.\\n\\n  Returns:\\n    Boolean, whether the labels have foreground and background in the first\\n      frame.\\n  '\n    (h, w) = train_utils.resolve_shape(label)[1:3]\n    label_downscaled = tf.squeeze(tf.image.resize_nearest_neighbor(label[0, tf.newaxis], [h // subsampling_factor, w // subsampling_factor], align_corners=True), axis=0)\n    is_bg = tf.equal(label_downscaled, 0)\n    is_fg = tf.logical_not(is_bg)\n    fg_count = tf.reduce_sum(tf.cast(is_fg, tf.int32))\n    bg_count = tf.reduce_sum(tf.cast(is_bg, tf.int32))\n    has_bg = tf.greater_equal(fg_count, MIN_LABEL_COUNT)\n    has_fg = tf.greater_equal(bg_count, MIN_LABEL_COUNT)\n    return tf.logical_and(has_bg, has_fg)",
            "def _has_foreground_and_background_in_first_frame(label, subsampling_factor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Checks if the labels have foreground and background in the first frame.\\n\\n  Args:\\n    label: Label tensor of shape [num_frames, height, width, 1].\\n    subsampling_factor: Integer, the subsampling factor.\\n\\n  Returns:\\n    Boolean, whether the labels have foreground and background in the first\\n      frame.\\n  '\n    (h, w) = train_utils.resolve_shape(label)[1:3]\n    label_downscaled = tf.squeeze(tf.image.resize_nearest_neighbor(label[0, tf.newaxis], [h // subsampling_factor, w // subsampling_factor], align_corners=True), axis=0)\n    is_bg = tf.equal(label_downscaled, 0)\n    is_fg = tf.logical_not(is_bg)\n    fg_count = tf.reduce_sum(tf.cast(is_fg, tf.int32))\n    bg_count = tf.reduce_sum(tf.cast(is_bg, tf.int32))\n    has_bg = tf.greater_equal(fg_count, MIN_LABEL_COUNT)\n    has_fg = tf.greater_equal(bg_count, MIN_LABEL_COUNT)\n    return tf.logical_and(has_bg, has_fg)",
            "def _has_foreground_and_background_in_first_frame(label, subsampling_factor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Checks if the labels have foreground and background in the first frame.\\n\\n  Args:\\n    label: Label tensor of shape [num_frames, height, width, 1].\\n    subsampling_factor: Integer, the subsampling factor.\\n\\n  Returns:\\n    Boolean, whether the labels have foreground and background in the first\\n      frame.\\n  '\n    (h, w) = train_utils.resolve_shape(label)[1:3]\n    label_downscaled = tf.squeeze(tf.image.resize_nearest_neighbor(label[0, tf.newaxis], [h // subsampling_factor, w // subsampling_factor], align_corners=True), axis=0)\n    is_bg = tf.equal(label_downscaled, 0)\n    is_fg = tf.logical_not(is_bg)\n    fg_count = tf.reduce_sum(tf.cast(is_fg, tf.int32))\n    bg_count = tf.reduce_sum(tf.cast(is_bg, tf.int32))\n    has_bg = tf.greater_equal(fg_count, MIN_LABEL_COUNT)\n    has_fg = tf.greater_equal(bg_count, MIN_LABEL_COUNT)\n    return tf.logical_and(has_bg, has_fg)"
        ]
    },
    {
        "func_name": "_has_foreground_and_background_in_first_frame_2",
        "original": "def _has_foreground_and_background_in_first_frame_2(label, decoder_output_stride):\n    \"\"\"Checks if the labels have foreground and background in the first frame.\n\n  Second attempt, this time we use the actual output dimension for resizing.\n\n  Args:\n    label: Label tensor of shape [num_frames, height, width, 1].\n    decoder_output_stride: Integer, the stride of the decoder output.\n\n  Returns:\n    Boolean, whether the labels have foreground and background in the first\n      frame.\n  \"\"\"\n    (h, w) = train_utils.resolve_shape(label)[1:3]\n    h_sub = model.scale_dimension(h, 1.0 / decoder_output_stride)\n    w_sub = model.scale_dimension(w, 1.0 / decoder_output_stride)\n    label_downscaled = tf.squeeze(tf.image.resize_nearest_neighbor(label[0, tf.newaxis], [h_sub, w_sub], align_corners=True), axis=0)\n    is_bg = tf.equal(label_downscaled, 0)\n    is_fg = tf.logical_not(is_bg)\n    fg_count = tf.reduce_sum(tf.cast(is_fg, tf.int32))\n    bg_count = tf.reduce_sum(tf.cast(is_bg, tf.int32))\n    has_bg = tf.greater_equal(fg_count, MIN_LABEL_COUNT)\n    has_fg = tf.greater_equal(bg_count, MIN_LABEL_COUNT)\n    return tf.logical_and(has_bg, has_fg)",
        "mutated": [
            "def _has_foreground_and_background_in_first_frame_2(label, decoder_output_stride):\n    if False:\n        i = 10\n    'Checks if the labels have foreground and background in the first frame.\\n\\n  Second attempt, this time we use the actual output dimension for resizing.\\n\\n  Args:\\n    label: Label tensor of shape [num_frames, height, width, 1].\\n    decoder_output_stride: Integer, the stride of the decoder output.\\n\\n  Returns:\\n    Boolean, whether the labels have foreground and background in the first\\n      frame.\\n  '\n    (h, w) = train_utils.resolve_shape(label)[1:3]\n    h_sub = model.scale_dimension(h, 1.0 / decoder_output_stride)\n    w_sub = model.scale_dimension(w, 1.0 / decoder_output_stride)\n    label_downscaled = tf.squeeze(tf.image.resize_nearest_neighbor(label[0, tf.newaxis], [h_sub, w_sub], align_corners=True), axis=0)\n    is_bg = tf.equal(label_downscaled, 0)\n    is_fg = tf.logical_not(is_bg)\n    fg_count = tf.reduce_sum(tf.cast(is_fg, tf.int32))\n    bg_count = tf.reduce_sum(tf.cast(is_bg, tf.int32))\n    has_bg = tf.greater_equal(fg_count, MIN_LABEL_COUNT)\n    has_fg = tf.greater_equal(bg_count, MIN_LABEL_COUNT)\n    return tf.logical_and(has_bg, has_fg)",
            "def _has_foreground_and_background_in_first_frame_2(label, decoder_output_stride):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Checks if the labels have foreground and background in the first frame.\\n\\n  Second attempt, this time we use the actual output dimension for resizing.\\n\\n  Args:\\n    label: Label tensor of shape [num_frames, height, width, 1].\\n    decoder_output_stride: Integer, the stride of the decoder output.\\n\\n  Returns:\\n    Boolean, whether the labels have foreground and background in the first\\n      frame.\\n  '\n    (h, w) = train_utils.resolve_shape(label)[1:3]\n    h_sub = model.scale_dimension(h, 1.0 / decoder_output_stride)\n    w_sub = model.scale_dimension(w, 1.0 / decoder_output_stride)\n    label_downscaled = tf.squeeze(tf.image.resize_nearest_neighbor(label[0, tf.newaxis], [h_sub, w_sub], align_corners=True), axis=0)\n    is_bg = tf.equal(label_downscaled, 0)\n    is_fg = tf.logical_not(is_bg)\n    fg_count = tf.reduce_sum(tf.cast(is_fg, tf.int32))\n    bg_count = tf.reduce_sum(tf.cast(is_bg, tf.int32))\n    has_bg = tf.greater_equal(fg_count, MIN_LABEL_COUNT)\n    has_fg = tf.greater_equal(bg_count, MIN_LABEL_COUNT)\n    return tf.logical_and(has_bg, has_fg)",
            "def _has_foreground_and_background_in_first_frame_2(label, decoder_output_stride):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Checks if the labels have foreground and background in the first frame.\\n\\n  Second attempt, this time we use the actual output dimension for resizing.\\n\\n  Args:\\n    label: Label tensor of shape [num_frames, height, width, 1].\\n    decoder_output_stride: Integer, the stride of the decoder output.\\n\\n  Returns:\\n    Boolean, whether the labels have foreground and background in the first\\n      frame.\\n  '\n    (h, w) = train_utils.resolve_shape(label)[1:3]\n    h_sub = model.scale_dimension(h, 1.0 / decoder_output_stride)\n    w_sub = model.scale_dimension(w, 1.0 / decoder_output_stride)\n    label_downscaled = tf.squeeze(tf.image.resize_nearest_neighbor(label[0, tf.newaxis], [h_sub, w_sub], align_corners=True), axis=0)\n    is_bg = tf.equal(label_downscaled, 0)\n    is_fg = tf.logical_not(is_bg)\n    fg_count = tf.reduce_sum(tf.cast(is_fg, tf.int32))\n    bg_count = tf.reduce_sum(tf.cast(is_bg, tf.int32))\n    has_bg = tf.greater_equal(fg_count, MIN_LABEL_COUNT)\n    has_fg = tf.greater_equal(bg_count, MIN_LABEL_COUNT)\n    return tf.logical_and(has_bg, has_fg)",
            "def _has_foreground_and_background_in_first_frame_2(label, decoder_output_stride):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Checks if the labels have foreground and background in the first frame.\\n\\n  Second attempt, this time we use the actual output dimension for resizing.\\n\\n  Args:\\n    label: Label tensor of shape [num_frames, height, width, 1].\\n    decoder_output_stride: Integer, the stride of the decoder output.\\n\\n  Returns:\\n    Boolean, whether the labels have foreground and background in the first\\n      frame.\\n  '\n    (h, w) = train_utils.resolve_shape(label)[1:3]\n    h_sub = model.scale_dimension(h, 1.0 / decoder_output_stride)\n    w_sub = model.scale_dimension(w, 1.0 / decoder_output_stride)\n    label_downscaled = tf.squeeze(tf.image.resize_nearest_neighbor(label[0, tf.newaxis], [h_sub, w_sub], align_corners=True), axis=0)\n    is_bg = tf.equal(label_downscaled, 0)\n    is_fg = tf.logical_not(is_bg)\n    fg_count = tf.reduce_sum(tf.cast(is_fg, tf.int32))\n    bg_count = tf.reduce_sum(tf.cast(is_bg, tf.int32))\n    has_bg = tf.greater_equal(fg_count, MIN_LABEL_COUNT)\n    has_fg = tf.greater_equal(bg_count, MIN_LABEL_COUNT)\n    return tf.logical_and(has_bg, has_fg)",
            "def _has_foreground_and_background_in_first_frame_2(label, decoder_output_stride):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Checks if the labels have foreground and background in the first frame.\\n\\n  Second attempt, this time we use the actual output dimension for resizing.\\n\\n  Args:\\n    label: Label tensor of shape [num_frames, height, width, 1].\\n    decoder_output_stride: Integer, the stride of the decoder output.\\n\\n  Returns:\\n    Boolean, whether the labels have foreground and background in the first\\n      frame.\\n  '\n    (h, w) = train_utils.resolve_shape(label)[1:3]\n    h_sub = model.scale_dimension(h, 1.0 / decoder_output_stride)\n    w_sub = model.scale_dimension(w, 1.0 / decoder_output_stride)\n    label_downscaled = tf.squeeze(tf.image.resize_nearest_neighbor(label[0, tf.newaxis], [h_sub, w_sub], align_corners=True), axis=0)\n    is_bg = tf.equal(label_downscaled, 0)\n    is_fg = tf.logical_not(is_bg)\n    fg_count = tf.reduce_sum(tf.cast(is_fg, tf.int32))\n    bg_count = tf.reduce_sum(tf.cast(is_bg, tf.int32))\n    has_bg = tf.greater_equal(fg_count, MIN_LABEL_COUNT)\n    has_fg = tf.greater_equal(bg_count, MIN_LABEL_COUNT)\n    return tf.logical_and(has_bg, has_fg)"
        ]
    },
    {
        "func_name": "_has_enough_pixels_of_each_object_in_first_frame",
        "original": "def _has_enough_pixels_of_each_object_in_first_frame(label, decoder_output_stride):\n    \"\"\"Checks if for each object (incl. background) enough pixels are visible.\n\n  During test time, we will usually not see a reference frame in which only\n  very few pixels of one object are visible. These cases can be problematic\n  during training, especially if more than the 1-nearest neighbor is used.\n  That's why this function can be used to detect and filter these cases.\n\n  Args:\n    label: Label tensor of shape [num_frames, height, width, 1].\n    decoder_output_stride: Integer, the stride of the decoder output.\n\n  Returns:\n    Boolean, whether the labels have enough pixels of each object in the first\n      frame.\n  \"\"\"\n    (h, w) = train_utils.resolve_shape(label)[1:3]\n    h_sub = model.scale_dimension(h, 1.0 / decoder_output_stride)\n    w_sub = model.scale_dimension(w, 1.0 / decoder_output_stride)\n    label_downscaled = tf.squeeze(tf.image.resize_nearest_neighbor(label[0, tf.newaxis], [h_sub, w_sub], align_corners=True), axis=0)\n    (_, _, counts) = tf.unique_with_counts(tf.reshape(label_downscaled, [-1]))\n    has_enough_pixels_per_object = tf.reduce_all(tf.greater_equal(counts, MIN_LABEL_COUNT))\n    return has_enough_pixels_per_object",
        "mutated": [
            "def _has_enough_pixels_of_each_object_in_first_frame(label, decoder_output_stride):\n    if False:\n        i = 10\n    \"Checks if for each object (incl. background) enough pixels are visible.\\n\\n  During test time, we will usually not see a reference frame in which only\\n  very few pixels of one object are visible. These cases can be problematic\\n  during training, especially if more than the 1-nearest neighbor is used.\\n  That's why this function can be used to detect and filter these cases.\\n\\n  Args:\\n    label: Label tensor of shape [num_frames, height, width, 1].\\n    decoder_output_stride: Integer, the stride of the decoder output.\\n\\n  Returns:\\n    Boolean, whether the labels have enough pixels of each object in the first\\n      frame.\\n  \"\n    (h, w) = train_utils.resolve_shape(label)[1:3]\n    h_sub = model.scale_dimension(h, 1.0 / decoder_output_stride)\n    w_sub = model.scale_dimension(w, 1.0 / decoder_output_stride)\n    label_downscaled = tf.squeeze(tf.image.resize_nearest_neighbor(label[0, tf.newaxis], [h_sub, w_sub], align_corners=True), axis=0)\n    (_, _, counts) = tf.unique_with_counts(tf.reshape(label_downscaled, [-1]))\n    has_enough_pixels_per_object = tf.reduce_all(tf.greater_equal(counts, MIN_LABEL_COUNT))\n    return has_enough_pixels_per_object",
            "def _has_enough_pixels_of_each_object_in_first_frame(label, decoder_output_stride):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Checks if for each object (incl. background) enough pixels are visible.\\n\\n  During test time, we will usually not see a reference frame in which only\\n  very few pixels of one object are visible. These cases can be problematic\\n  during training, especially if more than the 1-nearest neighbor is used.\\n  That's why this function can be used to detect and filter these cases.\\n\\n  Args:\\n    label: Label tensor of shape [num_frames, height, width, 1].\\n    decoder_output_stride: Integer, the stride of the decoder output.\\n\\n  Returns:\\n    Boolean, whether the labels have enough pixels of each object in the first\\n      frame.\\n  \"\n    (h, w) = train_utils.resolve_shape(label)[1:3]\n    h_sub = model.scale_dimension(h, 1.0 / decoder_output_stride)\n    w_sub = model.scale_dimension(w, 1.0 / decoder_output_stride)\n    label_downscaled = tf.squeeze(tf.image.resize_nearest_neighbor(label[0, tf.newaxis], [h_sub, w_sub], align_corners=True), axis=0)\n    (_, _, counts) = tf.unique_with_counts(tf.reshape(label_downscaled, [-1]))\n    has_enough_pixels_per_object = tf.reduce_all(tf.greater_equal(counts, MIN_LABEL_COUNT))\n    return has_enough_pixels_per_object",
            "def _has_enough_pixels_of_each_object_in_first_frame(label, decoder_output_stride):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Checks if for each object (incl. background) enough pixels are visible.\\n\\n  During test time, we will usually not see a reference frame in which only\\n  very few pixels of one object are visible. These cases can be problematic\\n  during training, especially if more than the 1-nearest neighbor is used.\\n  That's why this function can be used to detect and filter these cases.\\n\\n  Args:\\n    label: Label tensor of shape [num_frames, height, width, 1].\\n    decoder_output_stride: Integer, the stride of the decoder output.\\n\\n  Returns:\\n    Boolean, whether the labels have enough pixels of each object in the first\\n      frame.\\n  \"\n    (h, w) = train_utils.resolve_shape(label)[1:3]\n    h_sub = model.scale_dimension(h, 1.0 / decoder_output_stride)\n    w_sub = model.scale_dimension(w, 1.0 / decoder_output_stride)\n    label_downscaled = tf.squeeze(tf.image.resize_nearest_neighbor(label[0, tf.newaxis], [h_sub, w_sub], align_corners=True), axis=0)\n    (_, _, counts) = tf.unique_with_counts(tf.reshape(label_downscaled, [-1]))\n    has_enough_pixels_per_object = tf.reduce_all(tf.greater_equal(counts, MIN_LABEL_COUNT))\n    return has_enough_pixels_per_object",
            "def _has_enough_pixels_of_each_object_in_first_frame(label, decoder_output_stride):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Checks if for each object (incl. background) enough pixels are visible.\\n\\n  During test time, we will usually not see a reference frame in which only\\n  very few pixels of one object are visible. These cases can be problematic\\n  during training, especially if more than the 1-nearest neighbor is used.\\n  That's why this function can be used to detect and filter these cases.\\n\\n  Args:\\n    label: Label tensor of shape [num_frames, height, width, 1].\\n    decoder_output_stride: Integer, the stride of the decoder output.\\n\\n  Returns:\\n    Boolean, whether the labels have enough pixels of each object in the first\\n      frame.\\n  \"\n    (h, w) = train_utils.resolve_shape(label)[1:3]\n    h_sub = model.scale_dimension(h, 1.0 / decoder_output_stride)\n    w_sub = model.scale_dimension(w, 1.0 / decoder_output_stride)\n    label_downscaled = tf.squeeze(tf.image.resize_nearest_neighbor(label[0, tf.newaxis], [h_sub, w_sub], align_corners=True), axis=0)\n    (_, _, counts) = tf.unique_with_counts(tf.reshape(label_downscaled, [-1]))\n    has_enough_pixels_per_object = tf.reduce_all(tf.greater_equal(counts, MIN_LABEL_COUNT))\n    return has_enough_pixels_per_object",
            "def _has_enough_pixels_of_each_object_in_first_frame(label, decoder_output_stride):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Checks if for each object (incl. background) enough pixels are visible.\\n\\n  During test time, we will usually not see a reference frame in which only\\n  very few pixels of one object are visible. These cases can be problematic\\n  during training, especially if more than the 1-nearest neighbor is used.\\n  That's why this function can be used to detect and filter these cases.\\n\\n  Args:\\n    label: Label tensor of shape [num_frames, height, width, 1].\\n    decoder_output_stride: Integer, the stride of the decoder output.\\n\\n  Returns:\\n    Boolean, whether the labels have enough pixels of each object in the first\\n      frame.\\n  \"\n    (h, w) = train_utils.resolve_shape(label)[1:3]\n    h_sub = model.scale_dimension(h, 1.0 / decoder_output_stride)\n    w_sub = model.scale_dimension(w, 1.0 / decoder_output_stride)\n    label_downscaled = tf.squeeze(tf.image.resize_nearest_neighbor(label[0, tf.newaxis], [h_sub, w_sub], align_corners=True), axis=0)\n    (_, _, counts) = tf.unique_with_counts(tf.reshape(label_downscaled, [-1]))\n    has_enough_pixels_per_object = tf.reduce_all(tf.greater_equal(counts, MIN_LABEL_COUNT))\n    return has_enough_pixels_per_object"
        ]
    },
    {
        "func_name": "sample_query_start_idx",
        "original": "def sample_query_start_idx():\n    return tf.random_shuffle(tf.range(total_num_frames - num_frames_per_video + 1))[0]",
        "mutated": [
            "def sample_query_start_idx():\n    if False:\n        i = 10\n    return tf.random_shuffle(tf.range(total_num_frames - num_frames_per_video + 1))[0]",
            "def sample_query_start_idx():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return tf.random_shuffle(tf.range(total_num_frames - num_frames_per_video + 1))[0]",
            "def sample_query_start_idx():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return tf.random_shuffle(tf.range(total_num_frames - num_frames_per_video + 1))[0]",
            "def sample_query_start_idx():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return tf.random_shuffle(tf.range(total_num_frames - num_frames_per_video + 1))[0]",
            "def sample_query_start_idx():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return tf.random_shuffle(tf.range(total_num_frames - num_frames_per_video + 1))[0]"
        ]
    },
    {
        "func_name": "sample_sel_indices",
        "original": "def sample_sel_indices():\n    return tf.concat([ref_idx[tf.newaxis], tf.range(query_start_idx, query_start_idx + (num_frames_per_video - 1))], axis=0)",
        "mutated": [
            "def sample_sel_indices():\n    if False:\n        i = 10\n    return tf.concat([ref_idx[tf.newaxis], tf.range(query_start_idx, query_start_idx + (num_frames_per_video - 1))], axis=0)",
            "def sample_sel_indices():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return tf.concat([ref_idx[tf.newaxis], tf.range(query_start_idx, query_start_idx + (num_frames_per_video - 1))], axis=0)",
            "def sample_sel_indices():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return tf.concat([ref_idx[tf.newaxis], tf.range(query_start_idx, query_start_idx + (num_frames_per_video - 1))], axis=0)",
            "def sample_sel_indices():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return tf.concat([ref_idx[tf.newaxis], tf.range(query_start_idx, query_start_idx + (num_frames_per_video - 1))], axis=0)",
            "def sample_sel_indices():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return tf.concat([ref_idx[tf.newaxis], tf.range(query_start_idx, query_start_idx + (num_frames_per_video - 1))], axis=0)"
        ]
    },
    {
        "func_name": "get",
        "original": "def get(dataset, num_frames_per_video, crop_size, batch_size, min_resize_value=None, max_resize_value=None, resize_factor=None, min_scale_factor=1.0, max_scale_factor=1.0, scale_factor_step_size=0, preprocess_image_and_label=True, num_readers=1, num_threads=1, dataset_split=None, is_training=True, model_variant=None, batch_capacity_factor=32, video_frames_are_decoded=False, decoder_output_stride=None, first_frame_finetuning=False, sample_only_first_frame_for_finetuning=False, sample_adjacent_and_consistent_query_frames=False, remap_labels_to_reference_frame=True, generate_prev_frame_mask_by_mask_damaging=False, three_frame_dataset=False, add_prev_frame_label=True):\n    \"\"\"Gets the dataset split for semantic segmentation.\n\n  This functions gets the dataset split for semantic segmentation. In\n  particular, it is a wrapper of (1) dataset_data_provider which returns the raw\n  dataset split, (2) input_preprcess which preprocess the raw data, and (3) the\n  Tensorflow operation of batching the preprocessed data. Then, the output could\n  be directly used by training, evaluation or visualization.\n\n  Args:\n    dataset: An instance of slim Dataset.\n    num_frames_per_video: The number of frames used per video\n    crop_size: Image crop size [height, width].\n    batch_size: Batch size.\n    min_resize_value: Desired size of the smaller image side.\n    max_resize_value: Maximum allowed size of the larger image side.\n    resize_factor: Resized dimensions are multiple of factor plus one.\n    min_scale_factor: Minimum scale factor value.\n    max_scale_factor: Maximum scale factor value.\n    scale_factor_step_size: The step size from min scale factor to max scale\n      factor. The input is randomly scaled based on the value of\n      (min_scale_factor, max_scale_factor, scale_factor_step_size).\n    preprocess_image_and_label: Boolean variable specifies if preprocessing of\n      image and label will be performed or not.\n    num_readers: Number of readers for data provider.\n    num_threads: Number of threads for batching data.\n    dataset_split: Dataset split.\n    is_training: Is training or not.\n    model_variant: Model variant (string) for choosing how to mean-subtract the\n      images. See feature_extractor.network_map for supported model variants.\n    batch_capacity_factor: Batch capacity factor affecting the training queue\n      batch capacity.\n    video_frames_are_decoded: Boolean, whether the video frames are already\n        decoded\n    decoder_output_stride: Integer, the stride of the decoder output.\n    first_frame_finetuning: Boolean, whether to only sample the first frame\n      for fine-tuning.\n    sample_only_first_frame_for_finetuning: Boolean, whether to only sample the\n      first frame during fine-tuning. This should be False when using lucid or\n      wonderland data, but true when fine-tuning on the first frame only.\n      Only has an effect if first_frame_finetuning is True.\n    sample_adjacent_and_consistent_query_frames: Boolean, if true, the query\n      frames (all but the first frame which is the reference frame) will be\n      sampled such that they are adjacent video frames and have the same\n      crop coordinates and flip augmentation.\n    remap_labels_to_reference_frame: Boolean, whether to remap the labels of\n      the query frames to match the labels of the (downscaled) reference frame.\n      If a query frame contains a label which is not present in the reference,\n      it will be mapped to background.\n    generate_prev_frame_mask_by_mask_damaging: Boolean, whether to generate\n      the masks used as guidance from the previous frame by damaging the\n      ground truth mask.\n    three_frame_dataset: Boolean, whether the dataset has exactly three frames\n      per video of which the first is to be used as reference and the two\n      others are consecutive frames to be used as query frames.\n    add_prev_frame_label: Boolean, whether to sample one more frame before the\n      first query frame to obtain a previous frame label. Only has an effect,\n      if sample_adjacent_and_consistent_query_frames is True and\n      generate_prev_frame_mask_by_mask_damaging is False.\n\n  Returns:\n    A dictionary of batched Tensors for semantic segmentation.\n\n  Raises:\n    ValueError: dataset_split is None, or Failed to find labels.\n  \"\"\"\n    if dataset_split is None:\n        raise ValueError('Unknown dataset split.')\n    if model_variant is None:\n        tf.logging.warning('Please specify a model_variant. See feature_extractor.network_map for supported model variants.')\n    data_provider = dataset_data_provider.DatasetDataProvider(dataset, num_readers=num_readers, num_epochs=None if is_training else 1, shuffle=is_training)\n    (image, label, object_label, image_name, height, width, video_id) = _get_data(data_provider, dataset_split, video_frames_are_decoded)\n    sampling_is_valid = tf.constant(True)\n    if num_frames_per_video is not None:\n        total_num_frames = tf.shape(image)[0]\n        if first_frame_finetuning or three_frame_dataset:\n            if sample_only_first_frame_for_finetuning:\n                assert not sample_adjacent_and_consistent_query_frames, 'this option does not make sense for sampling only first frame.'\n                sel_indices = tf.tile(tf.constant(0, dtype=tf.int32)[tf.newaxis], multiples=[num_frames_per_video])\n            else:\n                if sample_adjacent_and_consistent_query_frames:\n                    if add_prev_frame_label:\n                        num_frames_per_video += 1\n                    assert num_frames_per_video == 3\n                    with tf.control_dependencies([tf.assert_equal(total_num_frames, 3)]):\n                        sel_indices = tf.constant([1, 2], dtype=tf.int32)\n                else:\n                    sel_indices = tf.random_shuffle(tf.range(1, total_num_frames))[:num_frames_per_video - 1]\n                sel_indices = tf.concat([tf.constant(0, dtype=tf.int32)[tf.newaxis], sel_indices], axis=0)\n        elif sample_adjacent_and_consistent_query_frames:\n            if add_prev_frame_label:\n                num_frames_per_video += 1\n            ref_idx = tf.random_shuffle(tf.range(total_num_frames))[0]\n            sampling_is_valid = tf.greater_equal(total_num_frames, num_frames_per_video)\n\n            def sample_query_start_idx():\n                return tf.random_shuffle(tf.range(total_num_frames - num_frames_per_video + 1))[0]\n            query_start_idx = tf.cond(sampling_is_valid, sample_query_start_idx, lambda : tf.constant(0, dtype=tf.int32))\n\n            def sample_sel_indices():\n                return tf.concat([ref_idx[tf.newaxis], tf.range(query_start_idx, query_start_idx + (num_frames_per_video - 1))], axis=0)\n            sel_indices = tf.cond(sampling_is_valid, sample_sel_indices, lambda : tf.zeros((num_frames_per_video,), dtype=tf.int32))\n        else:\n            sel_indices = tf.random_shuffle(tf.range(total_num_frames))[:num_frames_per_video]\n        image = tf.gather(image, sel_indices, axis=0)\n    if not video_frames_are_decoded:\n        image = decode_image_sequence(image)\n    if label is not None:\n        if num_frames_per_video is not None:\n            label = tf.gather(label, sel_indices, axis=0)\n        if not video_frames_are_decoded:\n            label = decode_image_sequence(label, image_format='png', channels=1)\n        if label.shape.ndims == 3:\n            label = tf.expand_dims(label, 3)\n        elif label.shape.ndims == 4 and label.shape.dims[3] == 1:\n            pass\n        else:\n            raise ValueError('Input label shape must be [num_frames_per_video, height, width], or [num_frames, height, width, 1]. Got {}'.format(label.shape.ndims))\n        label.set_shape([None, None, None, 1])\n    image.set_shape((num_frames_per_video, None, None, None))\n    if label is not None:\n        label.set_shape((num_frames_per_video, None, None, None))\n    preceding_frame_label = None\n    if preprocess_image_and_label:\n        if num_frames_per_video is None:\n            raise ValueError('num_frame_per_video must be specified for preproc.')\n        original_images = []\n        images = []\n        labels = []\n        if sample_adjacent_and_consistent_query_frames:\n            num_frames_individual_preproc = 1\n        else:\n            num_frames_individual_preproc = num_frames_per_video\n        for frame_idx in range(num_frames_individual_preproc):\n            (original_image_t, image_t, label_t) = input_preprocess.preprocess_image_and_label(image[frame_idx], label[frame_idx], crop_height=crop_size[0] if crop_size is not None else None, crop_width=crop_size[1] if crop_size is not None else None, min_resize_value=min_resize_value, max_resize_value=max_resize_value, resize_factor=resize_factor, min_scale_factor=min_scale_factor, max_scale_factor=max_scale_factor, scale_factor_step_size=scale_factor_step_size, ignore_label=dataset.ignore_label, is_training=is_training, model_variant=model_variant)\n            original_images.append(original_image_t)\n            images.append(image_t)\n            labels.append(label_t)\n        if sample_adjacent_and_consistent_query_frames:\n            imgs_for_preproc = [image[frame_idx] for frame_idx in range(1, num_frames_per_video)]\n            labels_for_preproc = [label[frame_idx] for frame_idx in range(1, num_frames_per_video)]\n            (original_image_rest, image_rest, label_rest) = input_preprocess.preprocess_images_and_labels_consistently(imgs_for_preproc, labels_for_preproc, crop_height=crop_size[0] if crop_size is not None else None, crop_width=crop_size[1] if crop_size is not None else None, min_resize_value=min_resize_value, max_resize_value=max_resize_value, resize_factor=resize_factor, min_scale_factor=min_scale_factor, max_scale_factor=max_scale_factor, scale_factor_step_size=scale_factor_step_size, ignore_label=dataset.ignore_label, is_training=is_training, model_variant=model_variant)\n            original_images.extend(original_image_rest)\n            images.extend(image_rest)\n            labels.extend(label_rest)\n        assert len(original_images) == num_frames_per_video\n        assert len(images) == num_frames_per_video\n        assert len(labels) == num_frames_per_video\n        if remap_labels_to_reference_frame:\n            reference_labels = labels[0][tf.newaxis]\n            (h, w) = train_utils.resolve_shape(reference_labels)[1:3]\n            embedding_height = model.scale_dimension(h, 1.0 / decoder_output_stride)\n            embedding_width = model.scale_dimension(w, 1.0 / decoder_output_stride)\n            reference_labels_embedding_size = tf.squeeze(tf.image.resize_nearest_neighbor(reference_labels, tf.stack([embedding_height, embedding_width]), align_corners=True), axis=0)\n            (labels_in_ref_frame, _) = tf.unique(tf.reshape(reference_labels_embedding_size, [-1]))\n            labels_in_ref_frame = tf.contrib.framework.sort(labels_in_ref_frame)\n            for idx in range(1, len(labels)):\n                ref_label_mask = tf.equal(labels[idx], labels_in_ref_frame[tf.newaxis, tf.newaxis, :])\n                remapped = tf.argmax(tf.cast(ref_label_mask, tf.uint8), axis=-1, output_type=tf.int32)\n                is_in_ref = tf.reduce_any(ref_label_mask, axis=-1)\n                remapped *= tf.cast(is_in_ref, tf.int32)\n                labels[idx] = remapped[..., tf.newaxis]\n        if sample_adjacent_and_consistent_query_frames:\n            if first_frame_finetuning and generate_prev_frame_mask_by_mask_damaging:\n                preceding_frame_label = mask_damaging.damage_masks(labels[1])\n            elif add_prev_frame_label:\n                original_images = [original_images[0]] + original_images[2:]\n                preceding_frame_label = labels[1]\n                images = [images[0]] + images[2:]\n                labels = [labels[0]] + labels[2:]\n                num_frames_per_video -= 1\n        original_image = tf.stack(original_images, axis=0)\n        image = tf.stack(images, axis=0)\n        label = tf.stack(labels, axis=0)\n    else:\n        if label is not None:\n            label.set_shape([num_frames_per_video, None if crop_size is None else crop_size[0], None if crop_size is None else crop_size[1], 1])\n        original_image = tf.to_float(tf.zeros_like(label))\n        if crop_size is None:\n            height = tf.shape(image)[1]\n            width = tf.shape(image)[2]\n        else:\n            height = crop_size[0]\n            width = crop_size[1]\n    sample = {'image': image, 'image_name': image_name, 'height': height, 'width': width, 'video_id': video_id}\n    if label is not None:\n        sample['label'] = label\n    if object_label is not None:\n        sample['object_label'] = object_label\n    if preceding_frame_label is not None:\n        sample['preceding_frame_label'] = preceding_frame_label\n    if not is_training:\n        sample['original_image'] = original_image\n    if is_training:\n        if first_frame_finetuning:\n            keep_input = tf.constant(True)\n        else:\n            keep_input = tf.logical_and(sampling_is_valid, tf.logical_and(_has_enough_pixels_of_each_object_in_first_frame(label, decoder_output_stride), _has_foreground_and_background_in_first_frame_2(label, decoder_output_stride)))\n        batched = tf.train.maybe_batch(sample, keep_input=keep_input, batch_size=batch_size, num_threads=num_threads, capacity=batch_capacity_factor * batch_size, dynamic_pad=True)\n    else:\n        batched = tf.train.batch(sample, batch_size=batch_size, num_threads=num_threads, capacity=batch_capacity_factor * batch_size, dynamic_pad=True)\n    cropped_height = train_utils.resolve_shape(batched['image'])[2]\n    cropped_width = train_utils.resolve_shape(batched['image'])[3]\n    if num_frames_per_video is None:\n        first_dim = -1\n    else:\n        first_dim = batch_size * num_frames_per_video\n    batched['image'] = tf.reshape(batched['image'], [first_dim, cropped_height, cropped_width, 3])\n    if label is not None:\n        batched['label'] = tf.reshape(batched['label'], [first_dim, cropped_height, cropped_width, 1])\n    return batched",
        "mutated": [
            "def get(dataset, num_frames_per_video, crop_size, batch_size, min_resize_value=None, max_resize_value=None, resize_factor=None, min_scale_factor=1.0, max_scale_factor=1.0, scale_factor_step_size=0, preprocess_image_and_label=True, num_readers=1, num_threads=1, dataset_split=None, is_training=True, model_variant=None, batch_capacity_factor=32, video_frames_are_decoded=False, decoder_output_stride=None, first_frame_finetuning=False, sample_only_first_frame_for_finetuning=False, sample_adjacent_and_consistent_query_frames=False, remap_labels_to_reference_frame=True, generate_prev_frame_mask_by_mask_damaging=False, three_frame_dataset=False, add_prev_frame_label=True):\n    if False:\n        i = 10\n    'Gets the dataset split for semantic segmentation.\\n\\n  This functions gets the dataset split for semantic segmentation. In\\n  particular, it is a wrapper of (1) dataset_data_provider which returns the raw\\n  dataset split, (2) input_preprcess which preprocess the raw data, and (3) the\\n  Tensorflow operation of batching the preprocessed data. Then, the output could\\n  be directly used by training, evaluation or visualization.\\n\\n  Args:\\n    dataset: An instance of slim Dataset.\\n    num_frames_per_video: The number of frames used per video\\n    crop_size: Image crop size [height, width].\\n    batch_size: Batch size.\\n    min_resize_value: Desired size of the smaller image side.\\n    max_resize_value: Maximum allowed size of the larger image side.\\n    resize_factor: Resized dimensions are multiple of factor plus one.\\n    min_scale_factor: Minimum scale factor value.\\n    max_scale_factor: Maximum scale factor value.\\n    scale_factor_step_size: The step size from min scale factor to max scale\\n      factor. The input is randomly scaled based on the value of\\n      (min_scale_factor, max_scale_factor, scale_factor_step_size).\\n    preprocess_image_and_label: Boolean variable specifies if preprocessing of\\n      image and label will be performed or not.\\n    num_readers: Number of readers for data provider.\\n    num_threads: Number of threads for batching data.\\n    dataset_split: Dataset split.\\n    is_training: Is training or not.\\n    model_variant: Model variant (string) for choosing how to mean-subtract the\\n      images. See feature_extractor.network_map for supported model variants.\\n    batch_capacity_factor: Batch capacity factor affecting the training queue\\n      batch capacity.\\n    video_frames_are_decoded: Boolean, whether the video frames are already\\n        decoded\\n    decoder_output_stride: Integer, the stride of the decoder output.\\n    first_frame_finetuning: Boolean, whether to only sample the first frame\\n      for fine-tuning.\\n    sample_only_first_frame_for_finetuning: Boolean, whether to only sample the\\n      first frame during fine-tuning. This should be False when using lucid or\\n      wonderland data, but true when fine-tuning on the first frame only.\\n      Only has an effect if first_frame_finetuning is True.\\n    sample_adjacent_and_consistent_query_frames: Boolean, if true, the query\\n      frames (all but the first frame which is the reference frame) will be\\n      sampled such that they are adjacent video frames and have the same\\n      crop coordinates and flip augmentation.\\n    remap_labels_to_reference_frame: Boolean, whether to remap the labels of\\n      the query frames to match the labels of the (downscaled) reference frame.\\n      If a query frame contains a label which is not present in the reference,\\n      it will be mapped to background.\\n    generate_prev_frame_mask_by_mask_damaging: Boolean, whether to generate\\n      the masks used as guidance from the previous frame by damaging the\\n      ground truth mask.\\n    three_frame_dataset: Boolean, whether the dataset has exactly three frames\\n      per video of which the first is to be used as reference and the two\\n      others are consecutive frames to be used as query frames.\\n    add_prev_frame_label: Boolean, whether to sample one more frame before the\\n      first query frame to obtain a previous frame label. Only has an effect,\\n      if sample_adjacent_and_consistent_query_frames is True and\\n      generate_prev_frame_mask_by_mask_damaging is False.\\n\\n  Returns:\\n    A dictionary of batched Tensors for semantic segmentation.\\n\\n  Raises:\\n    ValueError: dataset_split is None, or Failed to find labels.\\n  '\n    if dataset_split is None:\n        raise ValueError('Unknown dataset split.')\n    if model_variant is None:\n        tf.logging.warning('Please specify a model_variant. See feature_extractor.network_map for supported model variants.')\n    data_provider = dataset_data_provider.DatasetDataProvider(dataset, num_readers=num_readers, num_epochs=None if is_training else 1, shuffle=is_training)\n    (image, label, object_label, image_name, height, width, video_id) = _get_data(data_provider, dataset_split, video_frames_are_decoded)\n    sampling_is_valid = tf.constant(True)\n    if num_frames_per_video is not None:\n        total_num_frames = tf.shape(image)[0]\n        if first_frame_finetuning or three_frame_dataset:\n            if sample_only_first_frame_for_finetuning:\n                assert not sample_adjacent_and_consistent_query_frames, 'this option does not make sense for sampling only first frame.'\n                sel_indices = tf.tile(tf.constant(0, dtype=tf.int32)[tf.newaxis], multiples=[num_frames_per_video])\n            else:\n                if sample_adjacent_and_consistent_query_frames:\n                    if add_prev_frame_label:\n                        num_frames_per_video += 1\n                    assert num_frames_per_video == 3\n                    with tf.control_dependencies([tf.assert_equal(total_num_frames, 3)]):\n                        sel_indices = tf.constant([1, 2], dtype=tf.int32)\n                else:\n                    sel_indices = tf.random_shuffle(tf.range(1, total_num_frames))[:num_frames_per_video - 1]\n                sel_indices = tf.concat([tf.constant(0, dtype=tf.int32)[tf.newaxis], sel_indices], axis=0)\n        elif sample_adjacent_and_consistent_query_frames:\n            if add_prev_frame_label:\n                num_frames_per_video += 1\n            ref_idx = tf.random_shuffle(tf.range(total_num_frames))[0]\n            sampling_is_valid = tf.greater_equal(total_num_frames, num_frames_per_video)\n\n            def sample_query_start_idx():\n                return tf.random_shuffle(tf.range(total_num_frames - num_frames_per_video + 1))[0]\n            query_start_idx = tf.cond(sampling_is_valid, sample_query_start_idx, lambda : tf.constant(0, dtype=tf.int32))\n\n            def sample_sel_indices():\n                return tf.concat([ref_idx[tf.newaxis], tf.range(query_start_idx, query_start_idx + (num_frames_per_video - 1))], axis=0)\n            sel_indices = tf.cond(sampling_is_valid, sample_sel_indices, lambda : tf.zeros((num_frames_per_video,), dtype=tf.int32))\n        else:\n            sel_indices = tf.random_shuffle(tf.range(total_num_frames))[:num_frames_per_video]\n        image = tf.gather(image, sel_indices, axis=0)\n    if not video_frames_are_decoded:\n        image = decode_image_sequence(image)\n    if label is not None:\n        if num_frames_per_video is not None:\n            label = tf.gather(label, sel_indices, axis=0)\n        if not video_frames_are_decoded:\n            label = decode_image_sequence(label, image_format='png', channels=1)\n        if label.shape.ndims == 3:\n            label = tf.expand_dims(label, 3)\n        elif label.shape.ndims == 4 and label.shape.dims[3] == 1:\n            pass\n        else:\n            raise ValueError('Input label shape must be [num_frames_per_video, height, width], or [num_frames, height, width, 1]. Got {}'.format(label.shape.ndims))\n        label.set_shape([None, None, None, 1])\n    image.set_shape((num_frames_per_video, None, None, None))\n    if label is not None:\n        label.set_shape((num_frames_per_video, None, None, None))\n    preceding_frame_label = None\n    if preprocess_image_and_label:\n        if num_frames_per_video is None:\n            raise ValueError('num_frame_per_video must be specified for preproc.')\n        original_images = []\n        images = []\n        labels = []\n        if sample_adjacent_and_consistent_query_frames:\n            num_frames_individual_preproc = 1\n        else:\n            num_frames_individual_preproc = num_frames_per_video\n        for frame_idx in range(num_frames_individual_preproc):\n            (original_image_t, image_t, label_t) = input_preprocess.preprocess_image_and_label(image[frame_idx], label[frame_idx], crop_height=crop_size[0] if crop_size is not None else None, crop_width=crop_size[1] if crop_size is not None else None, min_resize_value=min_resize_value, max_resize_value=max_resize_value, resize_factor=resize_factor, min_scale_factor=min_scale_factor, max_scale_factor=max_scale_factor, scale_factor_step_size=scale_factor_step_size, ignore_label=dataset.ignore_label, is_training=is_training, model_variant=model_variant)\n            original_images.append(original_image_t)\n            images.append(image_t)\n            labels.append(label_t)\n        if sample_adjacent_and_consistent_query_frames:\n            imgs_for_preproc = [image[frame_idx] for frame_idx in range(1, num_frames_per_video)]\n            labels_for_preproc = [label[frame_idx] for frame_idx in range(1, num_frames_per_video)]\n            (original_image_rest, image_rest, label_rest) = input_preprocess.preprocess_images_and_labels_consistently(imgs_for_preproc, labels_for_preproc, crop_height=crop_size[0] if crop_size is not None else None, crop_width=crop_size[1] if crop_size is not None else None, min_resize_value=min_resize_value, max_resize_value=max_resize_value, resize_factor=resize_factor, min_scale_factor=min_scale_factor, max_scale_factor=max_scale_factor, scale_factor_step_size=scale_factor_step_size, ignore_label=dataset.ignore_label, is_training=is_training, model_variant=model_variant)\n            original_images.extend(original_image_rest)\n            images.extend(image_rest)\n            labels.extend(label_rest)\n        assert len(original_images) == num_frames_per_video\n        assert len(images) == num_frames_per_video\n        assert len(labels) == num_frames_per_video\n        if remap_labels_to_reference_frame:\n            reference_labels = labels[0][tf.newaxis]\n            (h, w) = train_utils.resolve_shape(reference_labels)[1:3]\n            embedding_height = model.scale_dimension(h, 1.0 / decoder_output_stride)\n            embedding_width = model.scale_dimension(w, 1.0 / decoder_output_stride)\n            reference_labels_embedding_size = tf.squeeze(tf.image.resize_nearest_neighbor(reference_labels, tf.stack([embedding_height, embedding_width]), align_corners=True), axis=0)\n            (labels_in_ref_frame, _) = tf.unique(tf.reshape(reference_labels_embedding_size, [-1]))\n            labels_in_ref_frame = tf.contrib.framework.sort(labels_in_ref_frame)\n            for idx in range(1, len(labels)):\n                ref_label_mask = tf.equal(labels[idx], labels_in_ref_frame[tf.newaxis, tf.newaxis, :])\n                remapped = tf.argmax(tf.cast(ref_label_mask, tf.uint8), axis=-1, output_type=tf.int32)\n                is_in_ref = tf.reduce_any(ref_label_mask, axis=-1)\n                remapped *= tf.cast(is_in_ref, tf.int32)\n                labels[idx] = remapped[..., tf.newaxis]\n        if sample_adjacent_and_consistent_query_frames:\n            if first_frame_finetuning and generate_prev_frame_mask_by_mask_damaging:\n                preceding_frame_label = mask_damaging.damage_masks(labels[1])\n            elif add_prev_frame_label:\n                original_images = [original_images[0]] + original_images[2:]\n                preceding_frame_label = labels[1]\n                images = [images[0]] + images[2:]\n                labels = [labels[0]] + labels[2:]\n                num_frames_per_video -= 1\n        original_image = tf.stack(original_images, axis=0)\n        image = tf.stack(images, axis=0)\n        label = tf.stack(labels, axis=0)\n    else:\n        if label is not None:\n            label.set_shape([num_frames_per_video, None if crop_size is None else crop_size[0], None if crop_size is None else crop_size[1], 1])\n        original_image = tf.to_float(tf.zeros_like(label))\n        if crop_size is None:\n            height = tf.shape(image)[1]\n            width = tf.shape(image)[2]\n        else:\n            height = crop_size[0]\n            width = crop_size[1]\n    sample = {'image': image, 'image_name': image_name, 'height': height, 'width': width, 'video_id': video_id}\n    if label is not None:\n        sample['label'] = label\n    if object_label is not None:\n        sample['object_label'] = object_label\n    if preceding_frame_label is not None:\n        sample['preceding_frame_label'] = preceding_frame_label\n    if not is_training:\n        sample['original_image'] = original_image\n    if is_training:\n        if first_frame_finetuning:\n            keep_input = tf.constant(True)\n        else:\n            keep_input = tf.logical_and(sampling_is_valid, tf.logical_and(_has_enough_pixels_of_each_object_in_first_frame(label, decoder_output_stride), _has_foreground_and_background_in_first_frame_2(label, decoder_output_stride)))\n        batched = tf.train.maybe_batch(sample, keep_input=keep_input, batch_size=batch_size, num_threads=num_threads, capacity=batch_capacity_factor * batch_size, dynamic_pad=True)\n    else:\n        batched = tf.train.batch(sample, batch_size=batch_size, num_threads=num_threads, capacity=batch_capacity_factor * batch_size, dynamic_pad=True)\n    cropped_height = train_utils.resolve_shape(batched['image'])[2]\n    cropped_width = train_utils.resolve_shape(batched['image'])[3]\n    if num_frames_per_video is None:\n        first_dim = -1\n    else:\n        first_dim = batch_size * num_frames_per_video\n    batched['image'] = tf.reshape(batched['image'], [first_dim, cropped_height, cropped_width, 3])\n    if label is not None:\n        batched['label'] = tf.reshape(batched['label'], [first_dim, cropped_height, cropped_width, 1])\n    return batched",
            "def get(dataset, num_frames_per_video, crop_size, batch_size, min_resize_value=None, max_resize_value=None, resize_factor=None, min_scale_factor=1.0, max_scale_factor=1.0, scale_factor_step_size=0, preprocess_image_and_label=True, num_readers=1, num_threads=1, dataset_split=None, is_training=True, model_variant=None, batch_capacity_factor=32, video_frames_are_decoded=False, decoder_output_stride=None, first_frame_finetuning=False, sample_only_first_frame_for_finetuning=False, sample_adjacent_and_consistent_query_frames=False, remap_labels_to_reference_frame=True, generate_prev_frame_mask_by_mask_damaging=False, three_frame_dataset=False, add_prev_frame_label=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Gets the dataset split for semantic segmentation.\\n\\n  This functions gets the dataset split for semantic segmentation. In\\n  particular, it is a wrapper of (1) dataset_data_provider which returns the raw\\n  dataset split, (2) input_preprcess which preprocess the raw data, and (3) the\\n  Tensorflow operation of batching the preprocessed data. Then, the output could\\n  be directly used by training, evaluation or visualization.\\n\\n  Args:\\n    dataset: An instance of slim Dataset.\\n    num_frames_per_video: The number of frames used per video\\n    crop_size: Image crop size [height, width].\\n    batch_size: Batch size.\\n    min_resize_value: Desired size of the smaller image side.\\n    max_resize_value: Maximum allowed size of the larger image side.\\n    resize_factor: Resized dimensions are multiple of factor plus one.\\n    min_scale_factor: Minimum scale factor value.\\n    max_scale_factor: Maximum scale factor value.\\n    scale_factor_step_size: The step size from min scale factor to max scale\\n      factor. The input is randomly scaled based on the value of\\n      (min_scale_factor, max_scale_factor, scale_factor_step_size).\\n    preprocess_image_and_label: Boolean variable specifies if preprocessing of\\n      image and label will be performed or not.\\n    num_readers: Number of readers for data provider.\\n    num_threads: Number of threads for batching data.\\n    dataset_split: Dataset split.\\n    is_training: Is training or not.\\n    model_variant: Model variant (string) for choosing how to mean-subtract the\\n      images. See feature_extractor.network_map for supported model variants.\\n    batch_capacity_factor: Batch capacity factor affecting the training queue\\n      batch capacity.\\n    video_frames_are_decoded: Boolean, whether the video frames are already\\n        decoded\\n    decoder_output_stride: Integer, the stride of the decoder output.\\n    first_frame_finetuning: Boolean, whether to only sample the first frame\\n      for fine-tuning.\\n    sample_only_first_frame_for_finetuning: Boolean, whether to only sample the\\n      first frame during fine-tuning. This should be False when using lucid or\\n      wonderland data, but true when fine-tuning on the first frame only.\\n      Only has an effect if first_frame_finetuning is True.\\n    sample_adjacent_and_consistent_query_frames: Boolean, if true, the query\\n      frames (all but the first frame which is the reference frame) will be\\n      sampled such that they are adjacent video frames and have the same\\n      crop coordinates and flip augmentation.\\n    remap_labels_to_reference_frame: Boolean, whether to remap the labels of\\n      the query frames to match the labels of the (downscaled) reference frame.\\n      If a query frame contains a label which is not present in the reference,\\n      it will be mapped to background.\\n    generate_prev_frame_mask_by_mask_damaging: Boolean, whether to generate\\n      the masks used as guidance from the previous frame by damaging the\\n      ground truth mask.\\n    three_frame_dataset: Boolean, whether the dataset has exactly three frames\\n      per video of which the first is to be used as reference and the two\\n      others are consecutive frames to be used as query frames.\\n    add_prev_frame_label: Boolean, whether to sample one more frame before the\\n      first query frame to obtain a previous frame label. Only has an effect,\\n      if sample_adjacent_and_consistent_query_frames is True and\\n      generate_prev_frame_mask_by_mask_damaging is False.\\n\\n  Returns:\\n    A dictionary of batched Tensors for semantic segmentation.\\n\\n  Raises:\\n    ValueError: dataset_split is None, or Failed to find labels.\\n  '\n    if dataset_split is None:\n        raise ValueError('Unknown dataset split.')\n    if model_variant is None:\n        tf.logging.warning('Please specify a model_variant. See feature_extractor.network_map for supported model variants.')\n    data_provider = dataset_data_provider.DatasetDataProvider(dataset, num_readers=num_readers, num_epochs=None if is_training else 1, shuffle=is_training)\n    (image, label, object_label, image_name, height, width, video_id) = _get_data(data_provider, dataset_split, video_frames_are_decoded)\n    sampling_is_valid = tf.constant(True)\n    if num_frames_per_video is not None:\n        total_num_frames = tf.shape(image)[0]\n        if first_frame_finetuning or three_frame_dataset:\n            if sample_only_first_frame_for_finetuning:\n                assert not sample_adjacent_and_consistent_query_frames, 'this option does not make sense for sampling only first frame.'\n                sel_indices = tf.tile(tf.constant(0, dtype=tf.int32)[tf.newaxis], multiples=[num_frames_per_video])\n            else:\n                if sample_adjacent_and_consistent_query_frames:\n                    if add_prev_frame_label:\n                        num_frames_per_video += 1\n                    assert num_frames_per_video == 3\n                    with tf.control_dependencies([tf.assert_equal(total_num_frames, 3)]):\n                        sel_indices = tf.constant([1, 2], dtype=tf.int32)\n                else:\n                    sel_indices = tf.random_shuffle(tf.range(1, total_num_frames))[:num_frames_per_video - 1]\n                sel_indices = tf.concat([tf.constant(0, dtype=tf.int32)[tf.newaxis], sel_indices], axis=0)\n        elif sample_adjacent_and_consistent_query_frames:\n            if add_prev_frame_label:\n                num_frames_per_video += 1\n            ref_idx = tf.random_shuffle(tf.range(total_num_frames))[0]\n            sampling_is_valid = tf.greater_equal(total_num_frames, num_frames_per_video)\n\n            def sample_query_start_idx():\n                return tf.random_shuffle(tf.range(total_num_frames - num_frames_per_video + 1))[0]\n            query_start_idx = tf.cond(sampling_is_valid, sample_query_start_idx, lambda : tf.constant(0, dtype=tf.int32))\n\n            def sample_sel_indices():\n                return tf.concat([ref_idx[tf.newaxis], tf.range(query_start_idx, query_start_idx + (num_frames_per_video - 1))], axis=0)\n            sel_indices = tf.cond(sampling_is_valid, sample_sel_indices, lambda : tf.zeros((num_frames_per_video,), dtype=tf.int32))\n        else:\n            sel_indices = tf.random_shuffle(tf.range(total_num_frames))[:num_frames_per_video]\n        image = tf.gather(image, sel_indices, axis=0)\n    if not video_frames_are_decoded:\n        image = decode_image_sequence(image)\n    if label is not None:\n        if num_frames_per_video is not None:\n            label = tf.gather(label, sel_indices, axis=0)\n        if not video_frames_are_decoded:\n            label = decode_image_sequence(label, image_format='png', channels=1)\n        if label.shape.ndims == 3:\n            label = tf.expand_dims(label, 3)\n        elif label.shape.ndims == 4 and label.shape.dims[3] == 1:\n            pass\n        else:\n            raise ValueError('Input label shape must be [num_frames_per_video, height, width], or [num_frames, height, width, 1]. Got {}'.format(label.shape.ndims))\n        label.set_shape([None, None, None, 1])\n    image.set_shape((num_frames_per_video, None, None, None))\n    if label is not None:\n        label.set_shape((num_frames_per_video, None, None, None))\n    preceding_frame_label = None\n    if preprocess_image_and_label:\n        if num_frames_per_video is None:\n            raise ValueError('num_frame_per_video must be specified for preproc.')\n        original_images = []\n        images = []\n        labels = []\n        if sample_adjacent_and_consistent_query_frames:\n            num_frames_individual_preproc = 1\n        else:\n            num_frames_individual_preproc = num_frames_per_video\n        for frame_idx in range(num_frames_individual_preproc):\n            (original_image_t, image_t, label_t) = input_preprocess.preprocess_image_and_label(image[frame_idx], label[frame_idx], crop_height=crop_size[0] if crop_size is not None else None, crop_width=crop_size[1] if crop_size is not None else None, min_resize_value=min_resize_value, max_resize_value=max_resize_value, resize_factor=resize_factor, min_scale_factor=min_scale_factor, max_scale_factor=max_scale_factor, scale_factor_step_size=scale_factor_step_size, ignore_label=dataset.ignore_label, is_training=is_training, model_variant=model_variant)\n            original_images.append(original_image_t)\n            images.append(image_t)\n            labels.append(label_t)\n        if sample_adjacent_and_consistent_query_frames:\n            imgs_for_preproc = [image[frame_idx] for frame_idx in range(1, num_frames_per_video)]\n            labels_for_preproc = [label[frame_idx] for frame_idx in range(1, num_frames_per_video)]\n            (original_image_rest, image_rest, label_rest) = input_preprocess.preprocess_images_and_labels_consistently(imgs_for_preproc, labels_for_preproc, crop_height=crop_size[0] if crop_size is not None else None, crop_width=crop_size[1] if crop_size is not None else None, min_resize_value=min_resize_value, max_resize_value=max_resize_value, resize_factor=resize_factor, min_scale_factor=min_scale_factor, max_scale_factor=max_scale_factor, scale_factor_step_size=scale_factor_step_size, ignore_label=dataset.ignore_label, is_training=is_training, model_variant=model_variant)\n            original_images.extend(original_image_rest)\n            images.extend(image_rest)\n            labels.extend(label_rest)\n        assert len(original_images) == num_frames_per_video\n        assert len(images) == num_frames_per_video\n        assert len(labels) == num_frames_per_video\n        if remap_labels_to_reference_frame:\n            reference_labels = labels[0][tf.newaxis]\n            (h, w) = train_utils.resolve_shape(reference_labels)[1:3]\n            embedding_height = model.scale_dimension(h, 1.0 / decoder_output_stride)\n            embedding_width = model.scale_dimension(w, 1.0 / decoder_output_stride)\n            reference_labels_embedding_size = tf.squeeze(tf.image.resize_nearest_neighbor(reference_labels, tf.stack([embedding_height, embedding_width]), align_corners=True), axis=0)\n            (labels_in_ref_frame, _) = tf.unique(tf.reshape(reference_labels_embedding_size, [-1]))\n            labels_in_ref_frame = tf.contrib.framework.sort(labels_in_ref_frame)\n            for idx in range(1, len(labels)):\n                ref_label_mask = tf.equal(labels[idx], labels_in_ref_frame[tf.newaxis, tf.newaxis, :])\n                remapped = tf.argmax(tf.cast(ref_label_mask, tf.uint8), axis=-1, output_type=tf.int32)\n                is_in_ref = tf.reduce_any(ref_label_mask, axis=-1)\n                remapped *= tf.cast(is_in_ref, tf.int32)\n                labels[idx] = remapped[..., tf.newaxis]\n        if sample_adjacent_and_consistent_query_frames:\n            if first_frame_finetuning and generate_prev_frame_mask_by_mask_damaging:\n                preceding_frame_label = mask_damaging.damage_masks(labels[1])\n            elif add_prev_frame_label:\n                original_images = [original_images[0]] + original_images[2:]\n                preceding_frame_label = labels[1]\n                images = [images[0]] + images[2:]\n                labels = [labels[0]] + labels[2:]\n                num_frames_per_video -= 1\n        original_image = tf.stack(original_images, axis=0)\n        image = tf.stack(images, axis=0)\n        label = tf.stack(labels, axis=0)\n    else:\n        if label is not None:\n            label.set_shape([num_frames_per_video, None if crop_size is None else crop_size[0], None if crop_size is None else crop_size[1], 1])\n        original_image = tf.to_float(tf.zeros_like(label))\n        if crop_size is None:\n            height = tf.shape(image)[1]\n            width = tf.shape(image)[2]\n        else:\n            height = crop_size[0]\n            width = crop_size[1]\n    sample = {'image': image, 'image_name': image_name, 'height': height, 'width': width, 'video_id': video_id}\n    if label is not None:\n        sample['label'] = label\n    if object_label is not None:\n        sample['object_label'] = object_label\n    if preceding_frame_label is not None:\n        sample['preceding_frame_label'] = preceding_frame_label\n    if not is_training:\n        sample['original_image'] = original_image\n    if is_training:\n        if first_frame_finetuning:\n            keep_input = tf.constant(True)\n        else:\n            keep_input = tf.logical_and(sampling_is_valid, tf.logical_and(_has_enough_pixels_of_each_object_in_first_frame(label, decoder_output_stride), _has_foreground_and_background_in_first_frame_2(label, decoder_output_stride)))\n        batched = tf.train.maybe_batch(sample, keep_input=keep_input, batch_size=batch_size, num_threads=num_threads, capacity=batch_capacity_factor * batch_size, dynamic_pad=True)\n    else:\n        batched = tf.train.batch(sample, batch_size=batch_size, num_threads=num_threads, capacity=batch_capacity_factor * batch_size, dynamic_pad=True)\n    cropped_height = train_utils.resolve_shape(batched['image'])[2]\n    cropped_width = train_utils.resolve_shape(batched['image'])[3]\n    if num_frames_per_video is None:\n        first_dim = -1\n    else:\n        first_dim = batch_size * num_frames_per_video\n    batched['image'] = tf.reshape(batched['image'], [first_dim, cropped_height, cropped_width, 3])\n    if label is not None:\n        batched['label'] = tf.reshape(batched['label'], [first_dim, cropped_height, cropped_width, 1])\n    return batched",
            "def get(dataset, num_frames_per_video, crop_size, batch_size, min_resize_value=None, max_resize_value=None, resize_factor=None, min_scale_factor=1.0, max_scale_factor=1.0, scale_factor_step_size=0, preprocess_image_and_label=True, num_readers=1, num_threads=1, dataset_split=None, is_training=True, model_variant=None, batch_capacity_factor=32, video_frames_are_decoded=False, decoder_output_stride=None, first_frame_finetuning=False, sample_only_first_frame_for_finetuning=False, sample_adjacent_and_consistent_query_frames=False, remap_labels_to_reference_frame=True, generate_prev_frame_mask_by_mask_damaging=False, three_frame_dataset=False, add_prev_frame_label=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Gets the dataset split for semantic segmentation.\\n\\n  This functions gets the dataset split for semantic segmentation. In\\n  particular, it is a wrapper of (1) dataset_data_provider which returns the raw\\n  dataset split, (2) input_preprcess which preprocess the raw data, and (3) the\\n  Tensorflow operation of batching the preprocessed data. Then, the output could\\n  be directly used by training, evaluation or visualization.\\n\\n  Args:\\n    dataset: An instance of slim Dataset.\\n    num_frames_per_video: The number of frames used per video\\n    crop_size: Image crop size [height, width].\\n    batch_size: Batch size.\\n    min_resize_value: Desired size of the smaller image side.\\n    max_resize_value: Maximum allowed size of the larger image side.\\n    resize_factor: Resized dimensions are multiple of factor plus one.\\n    min_scale_factor: Minimum scale factor value.\\n    max_scale_factor: Maximum scale factor value.\\n    scale_factor_step_size: The step size from min scale factor to max scale\\n      factor. The input is randomly scaled based on the value of\\n      (min_scale_factor, max_scale_factor, scale_factor_step_size).\\n    preprocess_image_and_label: Boolean variable specifies if preprocessing of\\n      image and label will be performed or not.\\n    num_readers: Number of readers for data provider.\\n    num_threads: Number of threads for batching data.\\n    dataset_split: Dataset split.\\n    is_training: Is training or not.\\n    model_variant: Model variant (string) for choosing how to mean-subtract the\\n      images. See feature_extractor.network_map for supported model variants.\\n    batch_capacity_factor: Batch capacity factor affecting the training queue\\n      batch capacity.\\n    video_frames_are_decoded: Boolean, whether the video frames are already\\n        decoded\\n    decoder_output_stride: Integer, the stride of the decoder output.\\n    first_frame_finetuning: Boolean, whether to only sample the first frame\\n      for fine-tuning.\\n    sample_only_first_frame_for_finetuning: Boolean, whether to only sample the\\n      first frame during fine-tuning. This should be False when using lucid or\\n      wonderland data, but true when fine-tuning on the first frame only.\\n      Only has an effect if first_frame_finetuning is True.\\n    sample_adjacent_and_consistent_query_frames: Boolean, if true, the query\\n      frames (all but the first frame which is the reference frame) will be\\n      sampled such that they are adjacent video frames and have the same\\n      crop coordinates and flip augmentation.\\n    remap_labels_to_reference_frame: Boolean, whether to remap the labels of\\n      the query frames to match the labels of the (downscaled) reference frame.\\n      If a query frame contains a label which is not present in the reference,\\n      it will be mapped to background.\\n    generate_prev_frame_mask_by_mask_damaging: Boolean, whether to generate\\n      the masks used as guidance from the previous frame by damaging the\\n      ground truth mask.\\n    three_frame_dataset: Boolean, whether the dataset has exactly three frames\\n      per video of which the first is to be used as reference and the two\\n      others are consecutive frames to be used as query frames.\\n    add_prev_frame_label: Boolean, whether to sample one more frame before the\\n      first query frame to obtain a previous frame label. Only has an effect,\\n      if sample_adjacent_and_consistent_query_frames is True and\\n      generate_prev_frame_mask_by_mask_damaging is False.\\n\\n  Returns:\\n    A dictionary of batched Tensors for semantic segmentation.\\n\\n  Raises:\\n    ValueError: dataset_split is None, or Failed to find labels.\\n  '\n    if dataset_split is None:\n        raise ValueError('Unknown dataset split.')\n    if model_variant is None:\n        tf.logging.warning('Please specify a model_variant. See feature_extractor.network_map for supported model variants.')\n    data_provider = dataset_data_provider.DatasetDataProvider(dataset, num_readers=num_readers, num_epochs=None if is_training else 1, shuffle=is_training)\n    (image, label, object_label, image_name, height, width, video_id) = _get_data(data_provider, dataset_split, video_frames_are_decoded)\n    sampling_is_valid = tf.constant(True)\n    if num_frames_per_video is not None:\n        total_num_frames = tf.shape(image)[0]\n        if first_frame_finetuning or three_frame_dataset:\n            if sample_only_first_frame_for_finetuning:\n                assert not sample_adjacent_and_consistent_query_frames, 'this option does not make sense for sampling only first frame.'\n                sel_indices = tf.tile(tf.constant(0, dtype=tf.int32)[tf.newaxis], multiples=[num_frames_per_video])\n            else:\n                if sample_adjacent_and_consistent_query_frames:\n                    if add_prev_frame_label:\n                        num_frames_per_video += 1\n                    assert num_frames_per_video == 3\n                    with tf.control_dependencies([tf.assert_equal(total_num_frames, 3)]):\n                        sel_indices = tf.constant([1, 2], dtype=tf.int32)\n                else:\n                    sel_indices = tf.random_shuffle(tf.range(1, total_num_frames))[:num_frames_per_video - 1]\n                sel_indices = tf.concat([tf.constant(0, dtype=tf.int32)[tf.newaxis], sel_indices], axis=0)\n        elif sample_adjacent_and_consistent_query_frames:\n            if add_prev_frame_label:\n                num_frames_per_video += 1\n            ref_idx = tf.random_shuffle(tf.range(total_num_frames))[0]\n            sampling_is_valid = tf.greater_equal(total_num_frames, num_frames_per_video)\n\n            def sample_query_start_idx():\n                return tf.random_shuffle(tf.range(total_num_frames - num_frames_per_video + 1))[0]\n            query_start_idx = tf.cond(sampling_is_valid, sample_query_start_idx, lambda : tf.constant(0, dtype=tf.int32))\n\n            def sample_sel_indices():\n                return tf.concat([ref_idx[tf.newaxis], tf.range(query_start_idx, query_start_idx + (num_frames_per_video - 1))], axis=0)\n            sel_indices = tf.cond(sampling_is_valid, sample_sel_indices, lambda : tf.zeros((num_frames_per_video,), dtype=tf.int32))\n        else:\n            sel_indices = tf.random_shuffle(tf.range(total_num_frames))[:num_frames_per_video]\n        image = tf.gather(image, sel_indices, axis=0)\n    if not video_frames_are_decoded:\n        image = decode_image_sequence(image)\n    if label is not None:\n        if num_frames_per_video is not None:\n            label = tf.gather(label, sel_indices, axis=0)\n        if not video_frames_are_decoded:\n            label = decode_image_sequence(label, image_format='png', channels=1)\n        if label.shape.ndims == 3:\n            label = tf.expand_dims(label, 3)\n        elif label.shape.ndims == 4 and label.shape.dims[3] == 1:\n            pass\n        else:\n            raise ValueError('Input label shape must be [num_frames_per_video, height, width], or [num_frames, height, width, 1]. Got {}'.format(label.shape.ndims))\n        label.set_shape([None, None, None, 1])\n    image.set_shape((num_frames_per_video, None, None, None))\n    if label is not None:\n        label.set_shape((num_frames_per_video, None, None, None))\n    preceding_frame_label = None\n    if preprocess_image_and_label:\n        if num_frames_per_video is None:\n            raise ValueError('num_frame_per_video must be specified for preproc.')\n        original_images = []\n        images = []\n        labels = []\n        if sample_adjacent_and_consistent_query_frames:\n            num_frames_individual_preproc = 1\n        else:\n            num_frames_individual_preproc = num_frames_per_video\n        for frame_idx in range(num_frames_individual_preproc):\n            (original_image_t, image_t, label_t) = input_preprocess.preprocess_image_and_label(image[frame_idx], label[frame_idx], crop_height=crop_size[0] if crop_size is not None else None, crop_width=crop_size[1] if crop_size is not None else None, min_resize_value=min_resize_value, max_resize_value=max_resize_value, resize_factor=resize_factor, min_scale_factor=min_scale_factor, max_scale_factor=max_scale_factor, scale_factor_step_size=scale_factor_step_size, ignore_label=dataset.ignore_label, is_training=is_training, model_variant=model_variant)\n            original_images.append(original_image_t)\n            images.append(image_t)\n            labels.append(label_t)\n        if sample_adjacent_and_consistent_query_frames:\n            imgs_for_preproc = [image[frame_idx] for frame_idx in range(1, num_frames_per_video)]\n            labels_for_preproc = [label[frame_idx] for frame_idx in range(1, num_frames_per_video)]\n            (original_image_rest, image_rest, label_rest) = input_preprocess.preprocess_images_and_labels_consistently(imgs_for_preproc, labels_for_preproc, crop_height=crop_size[0] if crop_size is not None else None, crop_width=crop_size[1] if crop_size is not None else None, min_resize_value=min_resize_value, max_resize_value=max_resize_value, resize_factor=resize_factor, min_scale_factor=min_scale_factor, max_scale_factor=max_scale_factor, scale_factor_step_size=scale_factor_step_size, ignore_label=dataset.ignore_label, is_training=is_training, model_variant=model_variant)\n            original_images.extend(original_image_rest)\n            images.extend(image_rest)\n            labels.extend(label_rest)\n        assert len(original_images) == num_frames_per_video\n        assert len(images) == num_frames_per_video\n        assert len(labels) == num_frames_per_video\n        if remap_labels_to_reference_frame:\n            reference_labels = labels[0][tf.newaxis]\n            (h, w) = train_utils.resolve_shape(reference_labels)[1:3]\n            embedding_height = model.scale_dimension(h, 1.0 / decoder_output_stride)\n            embedding_width = model.scale_dimension(w, 1.0 / decoder_output_stride)\n            reference_labels_embedding_size = tf.squeeze(tf.image.resize_nearest_neighbor(reference_labels, tf.stack([embedding_height, embedding_width]), align_corners=True), axis=0)\n            (labels_in_ref_frame, _) = tf.unique(tf.reshape(reference_labels_embedding_size, [-1]))\n            labels_in_ref_frame = tf.contrib.framework.sort(labels_in_ref_frame)\n            for idx in range(1, len(labels)):\n                ref_label_mask = tf.equal(labels[idx], labels_in_ref_frame[tf.newaxis, tf.newaxis, :])\n                remapped = tf.argmax(tf.cast(ref_label_mask, tf.uint8), axis=-1, output_type=tf.int32)\n                is_in_ref = tf.reduce_any(ref_label_mask, axis=-1)\n                remapped *= tf.cast(is_in_ref, tf.int32)\n                labels[idx] = remapped[..., tf.newaxis]\n        if sample_adjacent_and_consistent_query_frames:\n            if first_frame_finetuning and generate_prev_frame_mask_by_mask_damaging:\n                preceding_frame_label = mask_damaging.damage_masks(labels[1])\n            elif add_prev_frame_label:\n                original_images = [original_images[0]] + original_images[2:]\n                preceding_frame_label = labels[1]\n                images = [images[0]] + images[2:]\n                labels = [labels[0]] + labels[2:]\n                num_frames_per_video -= 1\n        original_image = tf.stack(original_images, axis=0)\n        image = tf.stack(images, axis=0)\n        label = tf.stack(labels, axis=0)\n    else:\n        if label is not None:\n            label.set_shape([num_frames_per_video, None if crop_size is None else crop_size[0], None if crop_size is None else crop_size[1], 1])\n        original_image = tf.to_float(tf.zeros_like(label))\n        if crop_size is None:\n            height = tf.shape(image)[1]\n            width = tf.shape(image)[2]\n        else:\n            height = crop_size[0]\n            width = crop_size[1]\n    sample = {'image': image, 'image_name': image_name, 'height': height, 'width': width, 'video_id': video_id}\n    if label is not None:\n        sample['label'] = label\n    if object_label is not None:\n        sample['object_label'] = object_label\n    if preceding_frame_label is not None:\n        sample['preceding_frame_label'] = preceding_frame_label\n    if not is_training:\n        sample['original_image'] = original_image\n    if is_training:\n        if first_frame_finetuning:\n            keep_input = tf.constant(True)\n        else:\n            keep_input = tf.logical_and(sampling_is_valid, tf.logical_and(_has_enough_pixels_of_each_object_in_first_frame(label, decoder_output_stride), _has_foreground_and_background_in_first_frame_2(label, decoder_output_stride)))\n        batched = tf.train.maybe_batch(sample, keep_input=keep_input, batch_size=batch_size, num_threads=num_threads, capacity=batch_capacity_factor * batch_size, dynamic_pad=True)\n    else:\n        batched = tf.train.batch(sample, batch_size=batch_size, num_threads=num_threads, capacity=batch_capacity_factor * batch_size, dynamic_pad=True)\n    cropped_height = train_utils.resolve_shape(batched['image'])[2]\n    cropped_width = train_utils.resolve_shape(batched['image'])[3]\n    if num_frames_per_video is None:\n        first_dim = -1\n    else:\n        first_dim = batch_size * num_frames_per_video\n    batched['image'] = tf.reshape(batched['image'], [first_dim, cropped_height, cropped_width, 3])\n    if label is not None:\n        batched['label'] = tf.reshape(batched['label'], [first_dim, cropped_height, cropped_width, 1])\n    return batched",
            "def get(dataset, num_frames_per_video, crop_size, batch_size, min_resize_value=None, max_resize_value=None, resize_factor=None, min_scale_factor=1.0, max_scale_factor=1.0, scale_factor_step_size=0, preprocess_image_and_label=True, num_readers=1, num_threads=1, dataset_split=None, is_training=True, model_variant=None, batch_capacity_factor=32, video_frames_are_decoded=False, decoder_output_stride=None, first_frame_finetuning=False, sample_only_first_frame_for_finetuning=False, sample_adjacent_and_consistent_query_frames=False, remap_labels_to_reference_frame=True, generate_prev_frame_mask_by_mask_damaging=False, three_frame_dataset=False, add_prev_frame_label=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Gets the dataset split for semantic segmentation.\\n\\n  This functions gets the dataset split for semantic segmentation. In\\n  particular, it is a wrapper of (1) dataset_data_provider which returns the raw\\n  dataset split, (2) input_preprcess which preprocess the raw data, and (3) the\\n  Tensorflow operation of batching the preprocessed data. Then, the output could\\n  be directly used by training, evaluation or visualization.\\n\\n  Args:\\n    dataset: An instance of slim Dataset.\\n    num_frames_per_video: The number of frames used per video\\n    crop_size: Image crop size [height, width].\\n    batch_size: Batch size.\\n    min_resize_value: Desired size of the smaller image side.\\n    max_resize_value: Maximum allowed size of the larger image side.\\n    resize_factor: Resized dimensions are multiple of factor plus one.\\n    min_scale_factor: Minimum scale factor value.\\n    max_scale_factor: Maximum scale factor value.\\n    scale_factor_step_size: The step size from min scale factor to max scale\\n      factor. The input is randomly scaled based on the value of\\n      (min_scale_factor, max_scale_factor, scale_factor_step_size).\\n    preprocess_image_and_label: Boolean variable specifies if preprocessing of\\n      image and label will be performed or not.\\n    num_readers: Number of readers for data provider.\\n    num_threads: Number of threads for batching data.\\n    dataset_split: Dataset split.\\n    is_training: Is training or not.\\n    model_variant: Model variant (string) for choosing how to mean-subtract the\\n      images. See feature_extractor.network_map for supported model variants.\\n    batch_capacity_factor: Batch capacity factor affecting the training queue\\n      batch capacity.\\n    video_frames_are_decoded: Boolean, whether the video frames are already\\n        decoded\\n    decoder_output_stride: Integer, the stride of the decoder output.\\n    first_frame_finetuning: Boolean, whether to only sample the first frame\\n      for fine-tuning.\\n    sample_only_first_frame_for_finetuning: Boolean, whether to only sample the\\n      first frame during fine-tuning. This should be False when using lucid or\\n      wonderland data, but true when fine-tuning on the first frame only.\\n      Only has an effect if first_frame_finetuning is True.\\n    sample_adjacent_and_consistent_query_frames: Boolean, if true, the query\\n      frames (all but the first frame which is the reference frame) will be\\n      sampled such that they are adjacent video frames and have the same\\n      crop coordinates and flip augmentation.\\n    remap_labels_to_reference_frame: Boolean, whether to remap the labels of\\n      the query frames to match the labels of the (downscaled) reference frame.\\n      If a query frame contains a label which is not present in the reference,\\n      it will be mapped to background.\\n    generate_prev_frame_mask_by_mask_damaging: Boolean, whether to generate\\n      the masks used as guidance from the previous frame by damaging the\\n      ground truth mask.\\n    three_frame_dataset: Boolean, whether the dataset has exactly three frames\\n      per video of which the first is to be used as reference and the two\\n      others are consecutive frames to be used as query frames.\\n    add_prev_frame_label: Boolean, whether to sample one more frame before the\\n      first query frame to obtain a previous frame label. Only has an effect,\\n      if sample_adjacent_and_consistent_query_frames is True and\\n      generate_prev_frame_mask_by_mask_damaging is False.\\n\\n  Returns:\\n    A dictionary of batched Tensors for semantic segmentation.\\n\\n  Raises:\\n    ValueError: dataset_split is None, or Failed to find labels.\\n  '\n    if dataset_split is None:\n        raise ValueError('Unknown dataset split.')\n    if model_variant is None:\n        tf.logging.warning('Please specify a model_variant. See feature_extractor.network_map for supported model variants.')\n    data_provider = dataset_data_provider.DatasetDataProvider(dataset, num_readers=num_readers, num_epochs=None if is_training else 1, shuffle=is_training)\n    (image, label, object_label, image_name, height, width, video_id) = _get_data(data_provider, dataset_split, video_frames_are_decoded)\n    sampling_is_valid = tf.constant(True)\n    if num_frames_per_video is not None:\n        total_num_frames = tf.shape(image)[0]\n        if first_frame_finetuning or three_frame_dataset:\n            if sample_only_first_frame_for_finetuning:\n                assert not sample_adjacent_and_consistent_query_frames, 'this option does not make sense for sampling only first frame.'\n                sel_indices = tf.tile(tf.constant(0, dtype=tf.int32)[tf.newaxis], multiples=[num_frames_per_video])\n            else:\n                if sample_adjacent_and_consistent_query_frames:\n                    if add_prev_frame_label:\n                        num_frames_per_video += 1\n                    assert num_frames_per_video == 3\n                    with tf.control_dependencies([tf.assert_equal(total_num_frames, 3)]):\n                        sel_indices = tf.constant([1, 2], dtype=tf.int32)\n                else:\n                    sel_indices = tf.random_shuffle(tf.range(1, total_num_frames))[:num_frames_per_video - 1]\n                sel_indices = tf.concat([tf.constant(0, dtype=tf.int32)[tf.newaxis], sel_indices], axis=0)\n        elif sample_adjacent_and_consistent_query_frames:\n            if add_prev_frame_label:\n                num_frames_per_video += 1\n            ref_idx = tf.random_shuffle(tf.range(total_num_frames))[0]\n            sampling_is_valid = tf.greater_equal(total_num_frames, num_frames_per_video)\n\n            def sample_query_start_idx():\n                return tf.random_shuffle(tf.range(total_num_frames - num_frames_per_video + 1))[0]\n            query_start_idx = tf.cond(sampling_is_valid, sample_query_start_idx, lambda : tf.constant(0, dtype=tf.int32))\n\n            def sample_sel_indices():\n                return tf.concat([ref_idx[tf.newaxis], tf.range(query_start_idx, query_start_idx + (num_frames_per_video - 1))], axis=0)\n            sel_indices = tf.cond(sampling_is_valid, sample_sel_indices, lambda : tf.zeros((num_frames_per_video,), dtype=tf.int32))\n        else:\n            sel_indices = tf.random_shuffle(tf.range(total_num_frames))[:num_frames_per_video]\n        image = tf.gather(image, sel_indices, axis=0)\n    if not video_frames_are_decoded:\n        image = decode_image_sequence(image)\n    if label is not None:\n        if num_frames_per_video is not None:\n            label = tf.gather(label, sel_indices, axis=0)\n        if not video_frames_are_decoded:\n            label = decode_image_sequence(label, image_format='png', channels=1)\n        if label.shape.ndims == 3:\n            label = tf.expand_dims(label, 3)\n        elif label.shape.ndims == 4 and label.shape.dims[3] == 1:\n            pass\n        else:\n            raise ValueError('Input label shape must be [num_frames_per_video, height, width], or [num_frames, height, width, 1]. Got {}'.format(label.shape.ndims))\n        label.set_shape([None, None, None, 1])\n    image.set_shape((num_frames_per_video, None, None, None))\n    if label is not None:\n        label.set_shape((num_frames_per_video, None, None, None))\n    preceding_frame_label = None\n    if preprocess_image_and_label:\n        if num_frames_per_video is None:\n            raise ValueError('num_frame_per_video must be specified for preproc.')\n        original_images = []\n        images = []\n        labels = []\n        if sample_adjacent_and_consistent_query_frames:\n            num_frames_individual_preproc = 1\n        else:\n            num_frames_individual_preproc = num_frames_per_video\n        for frame_idx in range(num_frames_individual_preproc):\n            (original_image_t, image_t, label_t) = input_preprocess.preprocess_image_and_label(image[frame_idx], label[frame_idx], crop_height=crop_size[0] if crop_size is not None else None, crop_width=crop_size[1] if crop_size is not None else None, min_resize_value=min_resize_value, max_resize_value=max_resize_value, resize_factor=resize_factor, min_scale_factor=min_scale_factor, max_scale_factor=max_scale_factor, scale_factor_step_size=scale_factor_step_size, ignore_label=dataset.ignore_label, is_training=is_training, model_variant=model_variant)\n            original_images.append(original_image_t)\n            images.append(image_t)\n            labels.append(label_t)\n        if sample_adjacent_and_consistent_query_frames:\n            imgs_for_preproc = [image[frame_idx] for frame_idx in range(1, num_frames_per_video)]\n            labels_for_preproc = [label[frame_idx] for frame_idx in range(1, num_frames_per_video)]\n            (original_image_rest, image_rest, label_rest) = input_preprocess.preprocess_images_and_labels_consistently(imgs_for_preproc, labels_for_preproc, crop_height=crop_size[0] if crop_size is not None else None, crop_width=crop_size[1] if crop_size is not None else None, min_resize_value=min_resize_value, max_resize_value=max_resize_value, resize_factor=resize_factor, min_scale_factor=min_scale_factor, max_scale_factor=max_scale_factor, scale_factor_step_size=scale_factor_step_size, ignore_label=dataset.ignore_label, is_training=is_training, model_variant=model_variant)\n            original_images.extend(original_image_rest)\n            images.extend(image_rest)\n            labels.extend(label_rest)\n        assert len(original_images) == num_frames_per_video\n        assert len(images) == num_frames_per_video\n        assert len(labels) == num_frames_per_video\n        if remap_labels_to_reference_frame:\n            reference_labels = labels[0][tf.newaxis]\n            (h, w) = train_utils.resolve_shape(reference_labels)[1:3]\n            embedding_height = model.scale_dimension(h, 1.0 / decoder_output_stride)\n            embedding_width = model.scale_dimension(w, 1.0 / decoder_output_stride)\n            reference_labels_embedding_size = tf.squeeze(tf.image.resize_nearest_neighbor(reference_labels, tf.stack([embedding_height, embedding_width]), align_corners=True), axis=0)\n            (labels_in_ref_frame, _) = tf.unique(tf.reshape(reference_labels_embedding_size, [-1]))\n            labels_in_ref_frame = tf.contrib.framework.sort(labels_in_ref_frame)\n            for idx in range(1, len(labels)):\n                ref_label_mask = tf.equal(labels[idx], labels_in_ref_frame[tf.newaxis, tf.newaxis, :])\n                remapped = tf.argmax(tf.cast(ref_label_mask, tf.uint8), axis=-1, output_type=tf.int32)\n                is_in_ref = tf.reduce_any(ref_label_mask, axis=-1)\n                remapped *= tf.cast(is_in_ref, tf.int32)\n                labels[idx] = remapped[..., tf.newaxis]\n        if sample_adjacent_and_consistent_query_frames:\n            if first_frame_finetuning and generate_prev_frame_mask_by_mask_damaging:\n                preceding_frame_label = mask_damaging.damage_masks(labels[1])\n            elif add_prev_frame_label:\n                original_images = [original_images[0]] + original_images[2:]\n                preceding_frame_label = labels[1]\n                images = [images[0]] + images[2:]\n                labels = [labels[0]] + labels[2:]\n                num_frames_per_video -= 1\n        original_image = tf.stack(original_images, axis=0)\n        image = tf.stack(images, axis=0)\n        label = tf.stack(labels, axis=0)\n    else:\n        if label is not None:\n            label.set_shape([num_frames_per_video, None if crop_size is None else crop_size[0], None if crop_size is None else crop_size[1], 1])\n        original_image = tf.to_float(tf.zeros_like(label))\n        if crop_size is None:\n            height = tf.shape(image)[1]\n            width = tf.shape(image)[2]\n        else:\n            height = crop_size[0]\n            width = crop_size[1]\n    sample = {'image': image, 'image_name': image_name, 'height': height, 'width': width, 'video_id': video_id}\n    if label is not None:\n        sample['label'] = label\n    if object_label is not None:\n        sample['object_label'] = object_label\n    if preceding_frame_label is not None:\n        sample['preceding_frame_label'] = preceding_frame_label\n    if not is_training:\n        sample['original_image'] = original_image\n    if is_training:\n        if first_frame_finetuning:\n            keep_input = tf.constant(True)\n        else:\n            keep_input = tf.logical_and(sampling_is_valid, tf.logical_and(_has_enough_pixels_of_each_object_in_first_frame(label, decoder_output_stride), _has_foreground_and_background_in_first_frame_2(label, decoder_output_stride)))\n        batched = tf.train.maybe_batch(sample, keep_input=keep_input, batch_size=batch_size, num_threads=num_threads, capacity=batch_capacity_factor * batch_size, dynamic_pad=True)\n    else:\n        batched = tf.train.batch(sample, batch_size=batch_size, num_threads=num_threads, capacity=batch_capacity_factor * batch_size, dynamic_pad=True)\n    cropped_height = train_utils.resolve_shape(batched['image'])[2]\n    cropped_width = train_utils.resolve_shape(batched['image'])[3]\n    if num_frames_per_video is None:\n        first_dim = -1\n    else:\n        first_dim = batch_size * num_frames_per_video\n    batched['image'] = tf.reshape(batched['image'], [first_dim, cropped_height, cropped_width, 3])\n    if label is not None:\n        batched['label'] = tf.reshape(batched['label'], [first_dim, cropped_height, cropped_width, 1])\n    return batched",
            "def get(dataset, num_frames_per_video, crop_size, batch_size, min_resize_value=None, max_resize_value=None, resize_factor=None, min_scale_factor=1.0, max_scale_factor=1.0, scale_factor_step_size=0, preprocess_image_and_label=True, num_readers=1, num_threads=1, dataset_split=None, is_training=True, model_variant=None, batch_capacity_factor=32, video_frames_are_decoded=False, decoder_output_stride=None, first_frame_finetuning=False, sample_only_first_frame_for_finetuning=False, sample_adjacent_and_consistent_query_frames=False, remap_labels_to_reference_frame=True, generate_prev_frame_mask_by_mask_damaging=False, three_frame_dataset=False, add_prev_frame_label=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Gets the dataset split for semantic segmentation.\\n\\n  This functions gets the dataset split for semantic segmentation. In\\n  particular, it is a wrapper of (1) dataset_data_provider which returns the raw\\n  dataset split, (2) input_preprcess which preprocess the raw data, and (3) the\\n  Tensorflow operation of batching the preprocessed data. Then, the output could\\n  be directly used by training, evaluation or visualization.\\n\\n  Args:\\n    dataset: An instance of slim Dataset.\\n    num_frames_per_video: The number of frames used per video\\n    crop_size: Image crop size [height, width].\\n    batch_size: Batch size.\\n    min_resize_value: Desired size of the smaller image side.\\n    max_resize_value: Maximum allowed size of the larger image side.\\n    resize_factor: Resized dimensions are multiple of factor plus one.\\n    min_scale_factor: Minimum scale factor value.\\n    max_scale_factor: Maximum scale factor value.\\n    scale_factor_step_size: The step size from min scale factor to max scale\\n      factor. The input is randomly scaled based on the value of\\n      (min_scale_factor, max_scale_factor, scale_factor_step_size).\\n    preprocess_image_and_label: Boolean variable specifies if preprocessing of\\n      image and label will be performed or not.\\n    num_readers: Number of readers for data provider.\\n    num_threads: Number of threads for batching data.\\n    dataset_split: Dataset split.\\n    is_training: Is training or not.\\n    model_variant: Model variant (string) for choosing how to mean-subtract the\\n      images. See feature_extractor.network_map for supported model variants.\\n    batch_capacity_factor: Batch capacity factor affecting the training queue\\n      batch capacity.\\n    video_frames_are_decoded: Boolean, whether the video frames are already\\n        decoded\\n    decoder_output_stride: Integer, the stride of the decoder output.\\n    first_frame_finetuning: Boolean, whether to only sample the first frame\\n      for fine-tuning.\\n    sample_only_first_frame_for_finetuning: Boolean, whether to only sample the\\n      first frame during fine-tuning. This should be False when using lucid or\\n      wonderland data, but true when fine-tuning on the first frame only.\\n      Only has an effect if first_frame_finetuning is True.\\n    sample_adjacent_and_consistent_query_frames: Boolean, if true, the query\\n      frames (all but the first frame which is the reference frame) will be\\n      sampled such that they are adjacent video frames and have the same\\n      crop coordinates and flip augmentation.\\n    remap_labels_to_reference_frame: Boolean, whether to remap the labels of\\n      the query frames to match the labels of the (downscaled) reference frame.\\n      If a query frame contains a label which is not present in the reference,\\n      it will be mapped to background.\\n    generate_prev_frame_mask_by_mask_damaging: Boolean, whether to generate\\n      the masks used as guidance from the previous frame by damaging the\\n      ground truth mask.\\n    three_frame_dataset: Boolean, whether the dataset has exactly three frames\\n      per video of which the first is to be used as reference and the two\\n      others are consecutive frames to be used as query frames.\\n    add_prev_frame_label: Boolean, whether to sample one more frame before the\\n      first query frame to obtain a previous frame label. Only has an effect,\\n      if sample_adjacent_and_consistent_query_frames is True and\\n      generate_prev_frame_mask_by_mask_damaging is False.\\n\\n  Returns:\\n    A dictionary of batched Tensors for semantic segmentation.\\n\\n  Raises:\\n    ValueError: dataset_split is None, or Failed to find labels.\\n  '\n    if dataset_split is None:\n        raise ValueError('Unknown dataset split.')\n    if model_variant is None:\n        tf.logging.warning('Please specify a model_variant. See feature_extractor.network_map for supported model variants.')\n    data_provider = dataset_data_provider.DatasetDataProvider(dataset, num_readers=num_readers, num_epochs=None if is_training else 1, shuffle=is_training)\n    (image, label, object_label, image_name, height, width, video_id) = _get_data(data_provider, dataset_split, video_frames_are_decoded)\n    sampling_is_valid = tf.constant(True)\n    if num_frames_per_video is not None:\n        total_num_frames = tf.shape(image)[0]\n        if first_frame_finetuning or three_frame_dataset:\n            if sample_only_first_frame_for_finetuning:\n                assert not sample_adjacent_and_consistent_query_frames, 'this option does not make sense for sampling only first frame.'\n                sel_indices = tf.tile(tf.constant(0, dtype=tf.int32)[tf.newaxis], multiples=[num_frames_per_video])\n            else:\n                if sample_adjacent_and_consistent_query_frames:\n                    if add_prev_frame_label:\n                        num_frames_per_video += 1\n                    assert num_frames_per_video == 3\n                    with tf.control_dependencies([tf.assert_equal(total_num_frames, 3)]):\n                        sel_indices = tf.constant([1, 2], dtype=tf.int32)\n                else:\n                    sel_indices = tf.random_shuffle(tf.range(1, total_num_frames))[:num_frames_per_video - 1]\n                sel_indices = tf.concat([tf.constant(0, dtype=tf.int32)[tf.newaxis], sel_indices], axis=0)\n        elif sample_adjacent_and_consistent_query_frames:\n            if add_prev_frame_label:\n                num_frames_per_video += 1\n            ref_idx = tf.random_shuffle(tf.range(total_num_frames))[0]\n            sampling_is_valid = tf.greater_equal(total_num_frames, num_frames_per_video)\n\n            def sample_query_start_idx():\n                return tf.random_shuffle(tf.range(total_num_frames - num_frames_per_video + 1))[0]\n            query_start_idx = tf.cond(sampling_is_valid, sample_query_start_idx, lambda : tf.constant(0, dtype=tf.int32))\n\n            def sample_sel_indices():\n                return tf.concat([ref_idx[tf.newaxis], tf.range(query_start_idx, query_start_idx + (num_frames_per_video - 1))], axis=0)\n            sel_indices = tf.cond(sampling_is_valid, sample_sel_indices, lambda : tf.zeros((num_frames_per_video,), dtype=tf.int32))\n        else:\n            sel_indices = tf.random_shuffle(tf.range(total_num_frames))[:num_frames_per_video]\n        image = tf.gather(image, sel_indices, axis=0)\n    if not video_frames_are_decoded:\n        image = decode_image_sequence(image)\n    if label is not None:\n        if num_frames_per_video is not None:\n            label = tf.gather(label, sel_indices, axis=0)\n        if not video_frames_are_decoded:\n            label = decode_image_sequence(label, image_format='png', channels=1)\n        if label.shape.ndims == 3:\n            label = tf.expand_dims(label, 3)\n        elif label.shape.ndims == 4 and label.shape.dims[3] == 1:\n            pass\n        else:\n            raise ValueError('Input label shape must be [num_frames_per_video, height, width], or [num_frames, height, width, 1]. Got {}'.format(label.shape.ndims))\n        label.set_shape([None, None, None, 1])\n    image.set_shape((num_frames_per_video, None, None, None))\n    if label is not None:\n        label.set_shape((num_frames_per_video, None, None, None))\n    preceding_frame_label = None\n    if preprocess_image_and_label:\n        if num_frames_per_video is None:\n            raise ValueError('num_frame_per_video must be specified for preproc.')\n        original_images = []\n        images = []\n        labels = []\n        if sample_adjacent_and_consistent_query_frames:\n            num_frames_individual_preproc = 1\n        else:\n            num_frames_individual_preproc = num_frames_per_video\n        for frame_idx in range(num_frames_individual_preproc):\n            (original_image_t, image_t, label_t) = input_preprocess.preprocess_image_and_label(image[frame_idx], label[frame_idx], crop_height=crop_size[0] if crop_size is not None else None, crop_width=crop_size[1] if crop_size is not None else None, min_resize_value=min_resize_value, max_resize_value=max_resize_value, resize_factor=resize_factor, min_scale_factor=min_scale_factor, max_scale_factor=max_scale_factor, scale_factor_step_size=scale_factor_step_size, ignore_label=dataset.ignore_label, is_training=is_training, model_variant=model_variant)\n            original_images.append(original_image_t)\n            images.append(image_t)\n            labels.append(label_t)\n        if sample_adjacent_and_consistent_query_frames:\n            imgs_for_preproc = [image[frame_idx] for frame_idx in range(1, num_frames_per_video)]\n            labels_for_preproc = [label[frame_idx] for frame_idx in range(1, num_frames_per_video)]\n            (original_image_rest, image_rest, label_rest) = input_preprocess.preprocess_images_and_labels_consistently(imgs_for_preproc, labels_for_preproc, crop_height=crop_size[0] if crop_size is not None else None, crop_width=crop_size[1] if crop_size is not None else None, min_resize_value=min_resize_value, max_resize_value=max_resize_value, resize_factor=resize_factor, min_scale_factor=min_scale_factor, max_scale_factor=max_scale_factor, scale_factor_step_size=scale_factor_step_size, ignore_label=dataset.ignore_label, is_training=is_training, model_variant=model_variant)\n            original_images.extend(original_image_rest)\n            images.extend(image_rest)\n            labels.extend(label_rest)\n        assert len(original_images) == num_frames_per_video\n        assert len(images) == num_frames_per_video\n        assert len(labels) == num_frames_per_video\n        if remap_labels_to_reference_frame:\n            reference_labels = labels[0][tf.newaxis]\n            (h, w) = train_utils.resolve_shape(reference_labels)[1:3]\n            embedding_height = model.scale_dimension(h, 1.0 / decoder_output_stride)\n            embedding_width = model.scale_dimension(w, 1.0 / decoder_output_stride)\n            reference_labels_embedding_size = tf.squeeze(tf.image.resize_nearest_neighbor(reference_labels, tf.stack([embedding_height, embedding_width]), align_corners=True), axis=0)\n            (labels_in_ref_frame, _) = tf.unique(tf.reshape(reference_labels_embedding_size, [-1]))\n            labels_in_ref_frame = tf.contrib.framework.sort(labels_in_ref_frame)\n            for idx in range(1, len(labels)):\n                ref_label_mask = tf.equal(labels[idx], labels_in_ref_frame[tf.newaxis, tf.newaxis, :])\n                remapped = tf.argmax(tf.cast(ref_label_mask, tf.uint8), axis=-1, output_type=tf.int32)\n                is_in_ref = tf.reduce_any(ref_label_mask, axis=-1)\n                remapped *= tf.cast(is_in_ref, tf.int32)\n                labels[idx] = remapped[..., tf.newaxis]\n        if sample_adjacent_and_consistent_query_frames:\n            if first_frame_finetuning and generate_prev_frame_mask_by_mask_damaging:\n                preceding_frame_label = mask_damaging.damage_masks(labels[1])\n            elif add_prev_frame_label:\n                original_images = [original_images[0]] + original_images[2:]\n                preceding_frame_label = labels[1]\n                images = [images[0]] + images[2:]\n                labels = [labels[0]] + labels[2:]\n                num_frames_per_video -= 1\n        original_image = tf.stack(original_images, axis=0)\n        image = tf.stack(images, axis=0)\n        label = tf.stack(labels, axis=0)\n    else:\n        if label is not None:\n            label.set_shape([num_frames_per_video, None if crop_size is None else crop_size[0], None if crop_size is None else crop_size[1], 1])\n        original_image = tf.to_float(tf.zeros_like(label))\n        if crop_size is None:\n            height = tf.shape(image)[1]\n            width = tf.shape(image)[2]\n        else:\n            height = crop_size[0]\n            width = crop_size[1]\n    sample = {'image': image, 'image_name': image_name, 'height': height, 'width': width, 'video_id': video_id}\n    if label is not None:\n        sample['label'] = label\n    if object_label is not None:\n        sample['object_label'] = object_label\n    if preceding_frame_label is not None:\n        sample['preceding_frame_label'] = preceding_frame_label\n    if not is_training:\n        sample['original_image'] = original_image\n    if is_training:\n        if first_frame_finetuning:\n            keep_input = tf.constant(True)\n        else:\n            keep_input = tf.logical_and(sampling_is_valid, tf.logical_and(_has_enough_pixels_of_each_object_in_first_frame(label, decoder_output_stride), _has_foreground_and_background_in_first_frame_2(label, decoder_output_stride)))\n        batched = tf.train.maybe_batch(sample, keep_input=keep_input, batch_size=batch_size, num_threads=num_threads, capacity=batch_capacity_factor * batch_size, dynamic_pad=True)\n    else:\n        batched = tf.train.batch(sample, batch_size=batch_size, num_threads=num_threads, capacity=batch_capacity_factor * batch_size, dynamic_pad=True)\n    cropped_height = train_utils.resolve_shape(batched['image'])[2]\n    cropped_width = train_utils.resolve_shape(batched['image'])[3]\n    if num_frames_per_video is None:\n        first_dim = -1\n    else:\n        first_dim = batch_size * num_frames_per_video\n    batched['image'] = tf.reshape(batched['image'], [first_dim, cropped_height, cropped_width, 3])\n    if label is not None:\n        batched['label'] = tf.reshape(batched['label'], [first_dim, cropped_height, cropped_width, 1])\n    return batched"
        ]
    }
]