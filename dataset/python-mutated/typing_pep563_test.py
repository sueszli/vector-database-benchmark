from __future__ import annotations
import sys
import pytest
from pyupgrade._data import Settings
from pyupgrade._main import _fix_plugins

@pytest.mark.parametrize('s', (pytest.param('from typing import Literal\nx: "str"\n', id='missing __future__ import'), pytest.param('from __future__ import annotations\nx: Literal["foo", "bar"]\n', id='Literal'), pytest.param('from __future__ import annotations\nx = TypeVar("x", "str")\n', id='TypeVar'), pytest.param('from __future__ import annotations\nx = cast(x, "str")\n', id='cast'), pytest.param('from __future__ import annotations\nX = List["MyClass"]\n', id='Alias'), pytest.param('from __future__ import annotations\nX: MyCallable("X")\n', id='Custom callable'), pytest.param('from __future__ import annotations\ndef foo(x, *args, **kwargs): ...\n', id='Untyped'), pytest.param('from __future__ import annotations\ndef foo(*, inplace): ...\n', id='Kwonly, untyped'), pytest.param('from __future__ import annotations\nx: Annotated[1:2] = ...\n', id='Annotated with invalid slice'), pytest.param('from __future__ import annotations\ndef f[X](x: X) -> X: return x\n', id='TypeVar without bound')))
def test_fix_typing_pep563_noop(s):
    if False:
        print('Hello World!')
    assert _fix_plugins(s, settings=Settings()) == s

@pytest.mark.parametrize(('s', 'expected'), (pytest.param('from __future__ import annotations\ndef foo(var: "MyClass") -> "MyClass":\n   x: "MyClass"\n', 'from __future__ import annotations\ndef foo(var: MyClass) -> MyClass:\n   x: MyClass\n', id='Simple annotation'), pytest.param('from __future__ import annotations\nasync def foo(var: "MyClass") -> "MyClass":\n   ...\n', 'from __future__ import annotations\nasync def foo(var: MyClass) -> MyClass:\n   ...\n', id='simple async annotation'), pytest.param('from __future__ import annotations\ndef foo(*, inplace: "bool"): ...\n', 'from __future__ import annotations\ndef foo(*, inplace: bool): ...\n', id='Kwonly, typed'), pytest.param('from __future__ import annotations\ndef foo(*args: "str", **kwargs: "int"): ...\n', 'from __future__ import annotations\ndef foo(*args: str, **kwargs: int): ...\n', id='Vararg and kwarg typed'), pytest.param('from __future__ import annotations\nx: Tuple["MyClass"]\n', 'from __future__ import annotations\nx: Tuple[MyClass]\n', id='Tuple'), pytest.param('from __future__ import annotations\nx: Callable[["MyClass"], None]\n', 'from __future__ import annotations\nx: Callable[[MyClass], None]\n', id='List within Callable'), pytest.param('from __future__ import annotations\nclass Foo(NamedTuple):\n    x: "MyClass"\n', 'from __future__ import annotations\nclass Foo(NamedTuple):\n    x: MyClass\n', id='Inherit from NamedTuple'), pytest.param('from __future__ import annotations\nclass D(TypedDict):\n    E: TypedDict("E", foo="int", total=False)\n', 'from __future__ import annotations\nclass D(TypedDict):\n    E: TypedDict("E", foo=int, total=False)\n', id='TypedDict keyword syntax'), pytest.param('from __future__ import annotations\nclass D(TypedDict):\n    E: TypedDict("E", {"foo": "int"})\n', 'from __future__ import annotations\nclass D(TypedDict):\n    E: TypedDict("E", {"foo": int})\n', id='TypedDict dict syntax'), pytest.param('from __future__ import annotations\nclass D(typing.TypedDict):\n    E: typing.TypedDict("E", {"foo": "int"})\n', 'from __future__ import annotations\nclass D(typing.TypedDict):\n    E: typing.TypedDict("E", {"foo": int})\n', id='typing.TypedDict'), pytest.param('from __future__ import annotations\nclass D(TypedDict):\n    E: TypedDict("E")\n', 'from __future__ import annotations\nclass D(TypedDict):\n    E: TypedDict("E")\n', id='TypedDict no type (invalid syntax)'), pytest.param('from __future__ import annotations\nx: Annotated["str", "metadata"]\n', 'from __future__ import annotations\nx: Annotated[str, "metadata"]\n', id='Annotated'), pytest.param('from __future__ import annotations\nx: typing.Annotated["str", "metadata"]\n', 'from __future__ import annotations\nx: typing.Annotated[str, "metadata"]\n', id='typing.Annotated'), pytest.param('from __future__ import annotations\nx: Annotated[()]\n', 'from __future__ import annotations\nx: Annotated[()]\n', id='Empty Annotated (garbage)'), pytest.param('from __future__ import annotations\nx: Arg("str", "name")\n', 'from __future__ import annotations\nx: Arg(str, "name")\n', id='Arg'), pytest.param('from __future__ import annotations\nx: DefaultArg("str", "name")\n', 'from __future__ import annotations\nx: DefaultArg(str, "name")\n', id='DefaultArg'), pytest.param('from __future__ import annotations\nx: NamedArg("str", "name")\n', 'from __future__ import annotations\nx: NamedArg(str, "name")\n', id='NamedArg'), pytest.param('from __future__ import annotations\nx: DefaultNamedArg("str", "name")\n', 'from __future__ import annotations\nx: DefaultNamedArg(str, "name")\n', id='DefaultNamedArg'), pytest.param('from __future__ import annotations\nx: DefaultNamedArg("str", name="name")\n', 'from __future__ import annotations\nx: DefaultNamedArg(str, name="name")\n', id='DefaultNamedArg with one keyword argument'), pytest.param('from __future__ import annotations\nx: DefaultNamedArg(name="name", type="str")\n', 'from __future__ import annotations\nx: DefaultNamedArg(name="name", type=str)\n', id='DefaultNamedArg with keyword arguments'), pytest.param('from __future__ import annotations\nx: DefaultNamedArg(name="name", quox="str")\n', 'from __future__ import annotations\nx: DefaultNamedArg(name="name", quox="str")\n', id='DefaultNamedArg with invalid arguments'), pytest.param('from __future__ import annotations\nx: DefaultNamedArg(name="name")\n', 'from __future__ import annotations\nx: DefaultNamedArg(name="name")\n', id='DefaultNamedArg with no type (invalid syntax)'), pytest.param('from __future__ import annotations\nx: VarArg("str")\n', 'from __future__ import annotations\nx: VarArg(str)\n', id='VarArg'), pytest.param('from __future__ import annotations\nx: List[List[List["MyClass"]]]\n', 'from __future__ import annotations\nx: List[List[List[MyClass]]]\n', id='Nested'), pytest.param('from __future__ import annotations\nx: NamedTuple("X", [("foo", "int"), ("bar", "str")])\n', 'from __future__ import annotations\nx: NamedTuple("X", [("foo", int), ("bar", str)])\n', id='NamedTuple with types, no kwarg'), pytest.param('from __future__ import annotations\nx: NamedTuple("X", fields=[("foo", "int"), ("bar", "str")])\n', 'from __future__ import annotations\nx: NamedTuple("X", fields=[("foo", int), ("bar", str)])\n', id='NamedTuple with types, one kwarg'), pytest.param('from __future__ import annotations\nx: NamedTuple(typename="X", fields=[("foo", "int")])\n', 'from __future__ import annotations\nx: NamedTuple(typename="X", fields=[("foo", int)])\n', id='NamedTuple with types, two kwargs'), pytest.param('from __future__ import annotations\nx: NamedTuple("X", [("foo",), ("bar",)])\n', 'from __future__ import annotations\nx: NamedTuple("X", [("foo",), ("bar",)])\n', id='NamedTuple with length-1 tuples (invalid syntax)'), pytest.param('from __future__ import annotations\nx: NamedTuple("X", ["foo", "bar"])\n', 'from __future__ import annotations\nx: NamedTuple("X", ["foo", "bar"])\n', id='NamedTuple with missing types (invalid syntax)'), pytest.param('from __future__ import annotations\nx: NamedTuple()\n', 'from __future__ import annotations\nx: NamedTuple()\n', id='NamedTuple with no args (invalid syntax)'), pytest.param('from __future__ import annotations\ndef foo(var0, /, var1: "MyClass") -> "MyClass":\n   x: "MyClass"\n', 'from __future__ import annotations\ndef foo(var0, /, var1: MyClass) -> MyClass:\n   x: MyClass\n', id='posonly args')))
def test_fix_typing_pep563(s, expected):
    if False:
        i = 10
        return i + 15
    ret = _fix_plugins(s, settings=Settings(min_version=(3, 7)))
    assert ret == expected

@pytest.mark.xfail(sys.version_info < (3, 12), reason='3.12+ syntax')
def test_typevar_bound():
    if False:
        i = 10
        return i + 15
    src = 'from __future__ import annotations\ndef f[T: "int"](t: T) -> T:\n    return t\n'
    expected = 'from __future__ import annotations\ndef f[T: int](t: T) -> T:\n    return t\n'
    ret = _fix_plugins(src, settings=Settings())
    assert ret == expected