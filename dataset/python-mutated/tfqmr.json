[
    {
        "func_name": "tfqmr",
        "original": "@_deprecate_positional_args(version='1.14.0')\ndef tfqmr(A, b, x0=None, *, tol=1e-05, maxiter=None, M=None, callback=None, atol=None, show=False):\n    \"\"\"\n    Use Transpose-Free Quasi-Minimal Residual iteration to solve ``Ax = b``.\n\n    Parameters\n    ----------\n    A : {sparse matrix, ndarray, LinearOperator}\n        The real or complex N-by-N matrix of the linear system.\n        Alternatively, `A` can be a linear operator which can\n        produce ``Ax`` using, e.g.,\n        `scipy.sparse.linalg.LinearOperator`.\n    b : {ndarray}\n        Right hand side of the linear system. Has shape (N,) or (N,1).\n    x0 : {ndarray}\n        Starting guess for the solution.\n    tol, atol : float, optional\n        Tolerances for convergence, ``norm(residual) <= max(tol*norm(b-Ax0), atol)``.\n        The default for `tol` is 1.0e-5.\n        The default for `atol` is ``tol * norm(b-Ax0)``.\n\n        .. warning::\n\n           The default value for `atol` will be changed in a future release.\n           For future compatibility, specify `atol` explicitly.\n    maxiter : int, optional\n        Maximum number of iterations.  Iteration will stop after maxiter\n        steps even if the specified tolerance has not been achieved.\n        Default is ``min(10000, ndofs * 10)``, where ``ndofs = A.shape[0]``.\n    M : {sparse matrix, ndarray, LinearOperator}\n        Inverse of the preconditioner of A.  M should approximate the\n        inverse of A and be easy to solve for (see Notes).  Effective\n        preconditioning dramatically improves the rate of convergence,\n        which implies that fewer iterations are needed to reach a given\n        error tolerance.  By default, no preconditioner is used.\n    callback : function, optional\n        User-supplied function to call after each iteration.  It is called\n        as `callback(xk)`, where `xk` is the current solution vector.\n    show : bool, optional\n        Specify ``show = True`` to show the convergence, ``show = False`` is\n        to close the output of the convergence.\n        Default is `False`.\n\n    Returns\n    -------\n    x : ndarray\n        The converged solution.\n    info : int\n        Provides convergence information:\n\n            - 0  : successful exit\n            - >0 : convergence to tolerance not achieved, number of iterations\n            - <0 : illegal input or breakdown\n\n    Notes\n    -----\n    The Transpose-Free QMR algorithm is derived from the CGS algorithm.\n    However, unlike CGS, the convergence curves for the TFQMR method is\n    smoothed by computing a quasi minimization of the residual norm. The\n    implementation supports left preconditioner, and the \"residual norm\"\n    to compute in convergence criterion is actually an upper bound on the\n    actual residual norm ``||b - Axk||``.\n\n    References\n    ----------\n    .. [1] R. W. Freund, A Transpose-Free Quasi-Minimal Residual Algorithm for\n           Non-Hermitian Linear Systems, SIAM J. Sci. Comput., 14(2), 470-482,\n           1993.\n    .. [2] Y. Saad, Iterative Methods for Sparse Linear Systems, 2nd edition,\n           SIAM, Philadelphia, 2003.\n    .. [3] C. T. Kelley, Iterative Methods for Linear and Nonlinear Equations,\n           number 16 in Frontiers in Applied Mathematics, SIAM, Philadelphia,\n           1995.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from scipy.sparse import csc_matrix\n    >>> from scipy.sparse.linalg import tfqmr\n    >>> A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)\n    >>> b = np.array([2, 4, -1], dtype=float)\n    >>> x, exitCode = tfqmr(A, b)\n    >>> print(exitCode)            # 0 indicates successful convergence\n    0\n    >>> np.allclose(A.dot(x), b)\n    True\n    \"\"\"\n    dtype = A.dtype\n    if np.issubdtype(dtype, np.int64):\n        dtype = float\n        A = A.astype(dtype)\n    if np.issubdtype(b.dtype, np.int64):\n        b = b.astype(dtype)\n    (A, M, x, b, postprocess) = make_system(A, M, x0, b)\n    if np.linalg.norm(b) == 0.0:\n        x = b.copy()\n        return (postprocess(x), 0)\n    ndofs = A.shape[0]\n    if maxiter is None:\n        maxiter = min(10000, ndofs * 10)\n    if x0 is None:\n        r = b.copy()\n    else:\n        r = b - A.matvec(x)\n    u = r\n    w = r.copy()\n    rstar = r\n    v = M.matvec(A.matvec(r))\n    uhat = v\n    d = theta = eta = 0.0\n    rho = np.inner(rstar.conjugate(), r)\n    rhoLast = rho\n    r0norm = np.sqrt(rho)\n    tau = r0norm\n    if r0norm == 0:\n        return (postprocess(x), 0)\n    if atol is None:\n        atol = tol * r0norm\n    else:\n        atol = max(atol, tol * r0norm)\n    for iter in range(maxiter):\n        even = iter % 2 == 0\n        if even:\n            vtrstar = np.inner(rstar.conjugate(), v)\n            if vtrstar == 0.0:\n                return (postprocess(x), -1)\n            alpha = rho / vtrstar\n            uNext = u - alpha * v\n        w -= alpha * uhat\n        d = u + theta ** 2 / alpha * eta * d\n        theta = np.linalg.norm(w) / tau\n        c = np.sqrt(1.0 / (1 + theta ** 2))\n        tau *= theta * c\n        eta = c ** 2 * alpha\n        z = M.matvec(d)\n        x += eta * z\n        if callback is not None:\n            callback(x)\n        if tau * np.sqrt(iter + 1) < atol:\n            if show:\n                print('TFQMR: Linear solve converged due to reach TOL iterations {}'.format(iter + 1))\n            return (postprocess(x), 0)\n        if not even:\n            rho = np.inner(rstar.conjugate(), w)\n            beta = rho / rhoLast\n            u = w + beta * u\n            v = beta * uhat + beta ** 2 * v\n            uhat = M.matvec(A.matvec(u))\n            v += uhat\n        else:\n            uhat = M.matvec(A.matvec(uNext))\n            u = uNext\n            rhoLast = rho\n    if show:\n        print('TFQMR: Linear solve not converged due to reach MAXIT iterations {}'.format(iter + 1))\n    return (postprocess(x), maxiter)",
        "mutated": [
            "@_deprecate_positional_args(version='1.14.0')\ndef tfqmr(A, b, x0=None, *, tol=1e-05, maxiter=None, M=None, callback=None, atol=None, show=False):\n    if False:\n        i = 10\n    '\\n    Use Transpose-Free Quasi-Minimal Residual iteration to solve ``Ax = b``.\\n\\n    Parameters\\n    ----------\\n    A : {sparse matrix, ndarray, LinearOperator}\\n        The real or complex N-by-N matrix of the linear system.\\n        Alternatively, `A` can be a linear operator which can\\n        produce ``Ax`` using, e.g.,\\n        `scipy.sparse.linalg.LinearOperator`.\\n    b : {ndarray}\\n        Right hand side of the linear system. Has shape (N,) or (N,1).\\n    x0 : {ndarray}\\n        Starting guess for the solution.\\n    tol, atol : float, optional\\n        Tolerances for convergence, ``norm(residual) <= max(tol*norm(b-Ax0), atol)``.\\n        The default for `tol` is 1.0e-5.\\n        The default for `atol` is ``tol * norm(b-Ax0)``.\\n\\n        .. warning::\\n\\n           The default value for `atol` will be changed in a future release.\\n           For future compatibility, specify `atol` explicitly.\\n    maxiter : int, optional\\n        Maximum number of iterations.  Iteration will stop after maxiter\\n        steps even if the specified tolerance has not been achieved.\\n        Default is ``min(10000, ndofs * 10)``, where ``ndofs = A.shape[0]``.\\n    M : {sparse matrix, ndarray, LinearOperator}\\n        Inverse of the preconditioner of A.  M should approximate the\\n        inverse of A and be easy to solve for (see Notes).  Effective\\n        preconditioning dramatically improves the rate of convergence,\\n        which implies that fewer iterations are needed to reach a given\\n        error tolerance.  By default, no preconditioner is used.\\n    callback : function, optional\\n        User-supplied function to call after each iteration.  It is called\\n        as `callback(xk)`, where `xk` is the current solution vector.\\n    show : bool, optional\\n        Specify ``show = True`` to show the convergence, ``show = False`` is\\n        to close the output of the convergence.\\n        Default is `False`.\\n\\n    Returns\\n    -------\\n    x : ndarray\\n        The converged solution.\\n    info : int\\n        Provides convergence information:\\n\\n            - 0  : successful exit\\n            - >0 : convergence to tolerance not achieved, number of iterations\\n            - <0 : illegal input or breakdown\\n\\n    Notes\\n    -----\\n    The Transpose-Free QMR algorithm is derived from the CGS algorithm.\\n    However, unlike CGS, the convergence curves for the TFQMR method is\\n    smoothed by computing a quasi minimization of the residual norm. The\\n    implementation supports left preconditioner, and the \"residual norm\"\\n    to compute in convergence criterion is actually an upper bound on the\\n    actual residual norm ``||b - Axk||``.\\n\\n    References\\n    ----------\\n    .. [1] R. W. Freund, A Transpose-Free Quasi-Minimal Residual Algorithm for\\n           Non-Hermitian Linear Systems, SIAM J. Sci. Comput., 14(2), 470-482,\\n           1993.\\n    .. [2] Y. Saad, Iterative Methods for Sparse Linear Systems, 2nd edition,\\n           SIAM, Philadelphia, 2003.\\n    .. [3] C. T. Kelley, Iterative Methods for Linear and Nonlinear Equations,\\n           number 16 in Frontiers in Applied Mathematics, SIAM, Philadelphia,\\n           1995.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.sparse import csc_matrix\\n    >>> from scipy.sparse.linalg import tfqmr\\n    >>> A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)\\n    >>> b = np.array([2, 4, -1], dtype=float)\\n    >>> x, exitCode = tfqmr(A, b)\\n    >>> print(exitCode)            # 0 indicates successful convergence\\n    0\\n    >>> np.allclose(A.dot(x), b)\\n    True\\n    '\n    dtype = A.dtype\n    if np.issubdtype(dtype, np.int64):\n        dtype = float\n        A = A.astype(dtype)\n    if np.issubdtype(b.dtype, np.int64):\n        b = b.astype(dtype)\n    (A, M, x, b, postprocess) = make_system(A, M, x0, b)\n    if np.linalg.norm(b) == 0.0:\n        x = b.copy()\n        return (postprocess(x), 0)\n    ndofs = A.shape[0]\n    if maxiter is None:\n        maxiter = min(10000, ndofs * 10)\n    if x0 is None:\n        r = b.copy()\n    else:\n        r = b - A.matvec(x)\n    u = r\n    w = r.copy()\n    rstar = r\n    v = M.matvec(A.matvec(r))\n    uhat = v\n    d = theta = eta = 0.0\n    rho = np.inner(rstar.conjugate(), r)\n    rhoLast = rho\n    r0norm = np.sqrt(rho)\n    tau = r0norm\n    if r0norm == 0:\n        return (postprocess(x), 0)\n    if atol is None:\n        atol = tol * r0norm\n    else:\n        atol = max(atol, tol * r0norm)\n    for iter in range(maxiter):\n        even = iter % 2 == 0\n        if even:\n            vtrstar = np.inner(rstar.conjugate(), v)\n            if vtrstar == 0.0:\n                return (postprocess(x), -1)\n            alpha = rho / vtrstar\n            uNext = u - alpha * v\n        w -= alpha * uhat\n        d = u + theta ** 2 / alpha * eta * d\n        theta = np.linalg.norm(w) / tau\n        c = np.sqrt(1.0 / (1 + theta ** 2))\n        tau *= theta * c\n        eta = c ** 2 * alpha\n        z = M.matvec(d)\n        x += eta * z\n        if callback is not None:\n            callback(x)\n        if tau * np.sqrt(iter + 1) < atol:\n            if show:\n                print('TFQMR: Linear solve converged due to reach TOL iterations {}'.format(iter + 1))\n            return (postprocess(x), 0)\n        if not even:\n            rho = np.inner(rstar.conjugate(), w)\n            beta = rho / rhoLast\n            u = w + beta * u\n            v = beta * uhat + beta ** 2 * v\n            uhat = M.matvec(A.matvec(u))\n            v += uhat\n        else:\n            uhat = M.matvec(A.matvec(uNext))\n            u = uNext\n            rhoLast = rho\n    if show:\n        print('TFQMR: Linear solve not converged due to reach MAXIT iterations {}'.format(iter + 1))\n    return (postprocess(x), maxiter)",
            "@_deprecate_positional_args(version='1.14.0')\ndef tfqmr(A, b, x0=None, *, tol=1e-05, maxiter=None, M=None, callback=None, atol=None, show=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Use Transpose-Free Quasi-Minimal Residual iteration to solve ``Ax = b``.\\n\\n    Parameters\\n    ----------\\n    A : {sparse matrix, ndarray, LinearOperator}\\n        The real or complex N-by-N matrix of the linear system.\\n        Alternatively, `A` can be a linear operator which can\\n        produce ``Ax`` using, e.g.,\\n        `scipy.sparse.linalg.LinearOperator`.\\n    b : {ndarray}\\n        Right hand side of the linear system. Has shape (N,) or (N,1).\\n    x0 : {ndarray}\\n        Starting guess for the solution.\\n    tol, atol : float, optional\\n        Tolerances for convergence, ``norm(residual) <= max(tol*norm(b-Ax0), atol)``.\\n        The default for `tol` is 1.0e-5.\\n        The default for `atol` is ``tol * norm(b-Ax0)``.\\n\\n        .. warning::\\n\\n           The default value for `atol` will be changed in a future release.\\n           For future compatibility, specify `atol` explicitly.\\n    maxiter : int, optional\\n        Maximum number of iterations.  Iteration will stop after maxiter\\n        steps even if the specified tolerance has not been achieved.\\n        Default is ``min(10000, ndofs * 10)``, where ``ndofs = A.shape[0]``.\\n    M : {sparse matrix, ndarray, LinearOperator}\\n        Inverse of the preconditioner of A.  M should approximate the\\n        inverse of A and be easy to solve for (see Notes).  Effective\\n        preconditioning dramatically improves the rate of convergence,\\n        which implies that fewer iterations are needed to reach a given\\n        error tolerance.  By default, no preconditioner is used.\\n    callback : function, optional\\n        User-supplied function to call after each iteration.  It is called\\n        as `callback(xk)`, where `xk` is the current solution vector.\\n    show : bool, optional\\n        Specify ``show = True`` to show the convergence, ``show = False`` is\\n        to close the output of the convergence.\\n        Default is `False`.\\n\\n    Returns\\n    -------\\n    x : ndarray\\n        The converged solution.\\n    info : int\\n        Provides convergence information:\\n\\n            - 0  : successful exit\\n            - >0 : convergence to tolerance not achieved, number of iterations\\n            - <0 : illegal input or breakdown\\n\\n    Notes\\n    -----\\n    The Transpose-Free QMR algorithm is derived from the CGS algorithm.\\n    However, unlike CGS, the convergence curves for the TFQMR method is\\n    smoothed by computing a quasi minimization of the residual norm. The\\n    implementation supports left preconditioner, and the \"residual norm\"\\n    to compute in convergence criterion is actually an upper bound on the\\n    actual residual norm ``||b - Axk||``.\\n\\n    References\\n    ----------\\n    .. [1] R. W. Freund, A Transpose-Free Quasi-Minimal Residual Algorithm for\\n           Non-Hermitian Linear Systems, SIAM J. Sci. Comput., 14(2), 470-482,\\n           1993.\\n    .. [2] Y. Saad, Iterative Methods for Sparse Linear Systems, 2nd edition,\\n           SIAM, Philadelphia, 2003.\\n    .. [3] C. T. Kelley, Iterative Methods for Linear and Nonlinear Equations,\\n           number 16 in Frontiers in Applied Mathematics, SIAM, Philadelphia,\\n           1995.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.sparse import csc_matrix\\n    >>> from scipy.sparse.linalg import tfqmr\\n    >>> A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)\\n    >>> b = np.array([2, 4, -1], dtype=float)\\n    >>> x, exitCode = tfqmr(A, b)\\n    >>> print(exitCode)            # 0 indicates successful convergence\\n    0\\n    >>> np.allclose(A.dot(x), b)\\n    True\\n    '\n    dtype = A.dtype\n    if np.issubdtype(dtype, np.int64):\n        dtype = float\n        A = A.astype(dtype)\n    if np.issubdtype(b.dtype, np.int64):\n        b = b.astype(dtype)\n    (A, M, x, b, postprocess) = make_system(A, M, x0, b)\n    if np.linalg.norm(b) == 0.0:\n        x = b.copy()\n        return (postprocess(x), 0)\n    ndofs = A.shape[0]\n    if maxiter is None:\n        maxiter = min(10000, ndofs * 10)\n    if x0 is None:\n        r = b.copy()\n    else:\n        r = b - A.matvec(x)\n    u = r\n    w = r.copy()\n    rstar = r\n    v = M.matvec(A.matvec(r))\n    uhat = v\n    d = theta = eta = 0.0\n    rho = np.inner(rstar.conjugate(), r)\n    rhoLast = rho\n    r0norm = np.sqrt(rho)\n    tau = r0norm\n    if r0norm == 0:\n        return (postprocess(x), 0)\n    if atol is None:\n        atol = tol * r0norm\n    else:\n        atol = max(atol, tol * r0norm)\n    for iter in range(maxiter):\n        even = iter % 2 == 0\n        if even:\n            vtrstar = np.inner(rstar.conjugate(), v)\n            if vtrstar == 0.0:\n                return (postprocess(x), -1)\n            alpha = rho / vtrstar\n            uNext = u - alpha * v\n        w -= alpha * uhat\n        d = u + theta ** 2 / alpha * eta * d\n        theta = np.linalg.norm(w) / tau\n        c = np.sqrt(1.0 / (1 + theta ** 2))\n        tau *= theta * c\n        eta = c ** 2 * alpha\n        z = M.matvec(d)\n        x += eta * z\n        if callback is not None:\n            callback(x)\n        if tau * np.sqrt(iter + 1) < atol:\n            if show:\n                print('TFQMR: Linear solve converged due to reach TOL iterations {}'.format(iter + 1))\n            return (postprocess(x), 0)\n        if not even:\n            rho = np.inner(rstar.conjugate(), w)\n            beta = rho / rhoLast\n            u = w + beta * u\n            v = beta * uhat + beta ** 2 * v\n            uhat = M.matvec(A.matvec(u))\n            v += uhat\n        else:\n            uhat = M.matvec(A.matvec(uNext))\n            u = uNext\n            rhoLast = rho\n    if show:\n        print('TFQMR: Linear solve not converged due to reach MAXIT iterations {}'.format(iter + 1))\n    return (postprocess(x), maxiter)",
            "@_deprecate_positional_args(version='1.14.0')\ndef tfqmr(A, b, x0=None, *, tol=1e-05, maxiter=None, M=None, callback=None, atol=None, show=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Use Transpose-Free Quasi-Minimal Residual iteration to solve ``Ax = b``.\\n\\n    Parameters\\n    ----------\\n    A : {sparse matrix, ndarray, LinearOperator}\\n        The real or complex N-by-N matrix of the linear system.\\n        Alternatively, `A` can be a linear operator which can\\n        produce ``Ax`` using, e.g.,\\n        `scipy.sparse.linalg.LinearOperator`.\\n    b : {ndarray}\\n        Right hand side of the linear system. Has shape (N,) or (N,1).\\n    x0 : {ndarray}\\n        Starting guess for the solution.\\n    tol, atol : float, optional\\n        Tolerances for convergence, ``norm(residual) <= max(tol*norm(b-Ax0), atol)``.\\n        The default for `tol` is 1.0e-5.\\n        The default for `atol` is ``tol * norm(b-Ax0)``.\\n\\n        .. warning::\\n\\n           The default value for `atol` will be changed in a future release.\\n           For future compatibility, specify `atol` explicitly.\\n    maxiter : int, optional\\n        Maximum number of iterations.  Iteration will stop after maxiter\\n        steps even if the specified tolerance has not been achieved.\\n        Default is ``min(10000, ndofs * 10)``, where ``ndofs = A.shape[0]``.\\n    M : {sparse matrix, ndarray, LinearOperator}\\n        Inverse of the preconditioner of A.  M should approximate the\\n        inverse of A and be easy to solve for (see Notes).  Effective\\n        preconditioning dramatically improves the rate of convergence,\\n        which implies that fewer iterations are needed to reach a given\\n        error tolerance.  By default, no preconditioner is used.\\n    callback : function, optional\\n        User-supplied function to call after each iteration.  It is called\\n        as `callback(xk)`, where `xk` is the current solution vector.\\n    show : bool, optional\\n        Specify ``show = True`` to show the convergence, ``show = False`` is\\n        to close the output of the convergence.\\n        Default is `False`.\\n\\n    Returns\\n    -------\\n    x : ndarray\\n        The converged solution.\\n    info : int\\n        Provides convergence information:\\n\\n            - 0  : successful exit\\n            - >0 : convergence to tolerance not achieved, number of iterations\\n            - <0 : illegal input or breakdown\\n\\n    Notes\\n    -----\\n    The Transpose-Free QMR algorithm is derived from the CGS algorithm.\\n    However, unlike CGS, the convergence curves for the TFQMR method is\\n    smoothed by computing a quasi minimization of the residual norm. The\\n    implementation supports left preconditioner, and the \"residual norm\"\\n    to compute in convergence criterion is actually an upper bound on the\\n    actual residual norm ``||b - Axk||``.\\n\\n    References\\n    ----------\\n    .. [1] R. W. Freund, A Transpose-Free Quasi-Minimal Residual Algorithm for\\n           Non-Hermitian Linear Systems, SIAM J. Sci. Comput., 14(2), 470-482,\\n           1993.\\n    .. [2] Y. Saad, Iterative Methods for Sparse Linear Systems, 2nd edition,\\n           SIAM, Philadelphia, 2003.\\n    .. [3] C. T. Kelley, Iterative Methods for Linear and Nonlinear Equations,\\n           number 16 in Frontiers in Applied Mathematics, SIAM, Philadelphia,\\n           1995.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.sparse import csc_matrix\\n    >>> from scipy.sparse.linalg import tfqmr\\n    >>> A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)\\n    >>> b = np.array([2, 4, -1], dtype=float)\\n    >>> x, exitCode = tfqmr(A, b)\\n    >>> print(exitCode)            # 0 indicates successful convergence\\n    0\\n    >>> np.allclose(A.dot(x), b)\\n    True\\n    '\n    dtype = A.dtype\n    if np.issubdtype(dtype, np.int64):\n        dtype = float\n        A = A.astype(dtype)\n    if np.issubdtype(b.dtype, np.int64):\n        b = b.astype(dtype)\n    (A, M, x, b, postprocess) = make_system(A, M, x0, b)\n    if np.linalg.norm(b) == 0.0:\n        x = b.copy()\n        return (postprocess(x), 0)\n    ndofs = A.shape[0]\n    if maxiter is None:\n        maxiter = min(10000, ndofs * 10)\n    if x0 is None:\n        r = b.copy()\n    else:\n        r = b - A.matvec(x)\n    u = r\n    w = r.copy()\n    rstar = r\n    v = M.matvec(A.matvec(r))\n    uhat = v\n    d = theta = eta = 0.0\n    rho = np.inner(rstar.conjugate(), r)\n    rhoLast = rho\n    r0norm = np.sqrt(rho)\n    tau = r0norm\n    if r0norm == 0:\n        return (postprocess(x), 0)\n    if atol is None:\n        atol = tol * r0norm\n    else:\n        atol = max(atol, tol * r0norm)\n    for iter in range(maxiter):\n        even = iter % 2 == 0\n        if even:\n            vtrstar = np.inner(rstar.conjugate(), v)\n            if vtrstar == 0.0:\n                return (postprocess(x), -1)\n            alpha = rho / vtrstar\n            uNext = u - alpha * v\n        w -= alpha * uhat\n        d = u + theta ** 2 / alpha * eta * d\n        theta = np.linalg.norm(w) / tau\n        c = np.sqrt(1.0 / (1 + theta ** 2))\n        tau *= theta * c\n        eta = c ** 2 * alpha\n        z = M.matvec(d)\n        x += eta * z\n        if callback is not None:\n            callback(x)\n        if tau * np.sqrt(iter + 1) < atol:\n            if show:\n                print('TFQMR: Linear solve converged due to reach TOL iterations {}'.format(iter + 1))\n            return (postprocess(x), 0)\n        if not even:\n            rho = np.inner(rstar.conjugate(), w)\n            beta = rho / rhoLast\n            u = w + beta * u\n            v = beta * uhat + beta ** 2 * v\n            uhat = M.matvec(A.matvec(u))\n            v += uhat\n        else:\n            uhat = M.matvec(A.matvec(uNext))\n            u = uNext\n            rhoLast = rho\n    if show:\n        print('TFQMR: Linear solve not converged due to reach MAXIT iterations {}'.format(iter + 1))\n    return (postprocess(x), maxiter)",
            "@_deprecate_positional_args(version='1.14.0')\ndef tfqmr(A, b, x0=None, *, tol=1e-05, maxiter=None, M=None, callback=None, atol=None, show=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Use Transpose-Free Quasi-Minimal Residual iteration to solve ``Ax = b``.\\n\\n    Parameters\\n    ----------\\n    A : {sparse matrix, ndarray, LinearOperator}\\n        The real or complex N-by-N matrix of the linear system.\\n        Alternatively, `A` can be a linear operator which can\\n        produce ``Ax`` using, e.g.,\\n        `scipy.sparse.linalg.LinearOperator`.\\n    b : {ndarray}\\n        Right hand side of the linear system. Has shape (N,) or (N,1).\\n    x0 : {ndarray}\\n        Starting guess for the solution.\\n    tol, atol : float, optional\\n        Tolerances for convergence, ``norm(residual) <= max(tol*norm(b-Ax0), atol)``.\\n        The default for `tol` is 1.0e-5.\\n        The default for `atol` is ``tol * norm(b-Ax0)``.\\n\\n        .. warning::\\n\\n           The default value for `atol` will be changed in a future release.\\n           For future compatibility, specify `atol` explicitly.\\n    maxiter : int, optional\\n        Maximum number of iterations.  Iteration will stop after maxiter\\n        steps even if the specified tolerance has not been achieved.\\n        Default is ``min(10000, ndofs * 10)``, where ``ndofs = A.shape[0]``.\\n    M : {sparse matrix, ndarray, LinearOperator}\\n        Inverse of the preconditioner of A.  M should approximate the\\n        inverse of A and be easy to solve for (see Notes).  Effective\\n        preconditioning dramatically improves the rate of convergence,\\n        which implies that fewer iterations are needed to reach a given\\n        error tolerance.  By default, no preconditioner is used.\\n    callback : function, optional\\n        User-supplied function to call after each iteration.  It is called\\n        as `callback(xk)`, where `xk` is the current solution vector.\\n    show : bool, optional\\n        Specify ``show = True`` to show the convergence, ``show = False`` is\\n        to close the output of the convergence.\\n        Default is `False`.\\n\\n    Returns\\n    -------\\n    x : ndarray\\n        The converged solution.\\n    info : int\\n        Provides convergence information:\\n\\n            - 0  : successful exit\\n            - >0 : convergence to tolerance not achieved, number of iterations\\n            - <0 : illegal input or breakdown\\n\\n    Notes\\n    -----\\n    The Transpose-Free QMR algorithm is derived from the CGS algorithm.\\n    However, unlike CGS, the convergence curves for the TFQMR method is\\n    smoothed by computing a quasi minimization of the residual norm. The\\n    implementation supports left preconditioner, and the \"residual norm\"\\n    to compute in convergence criterion is actually an upper bound on the\\n    actual residual norm ``||b - Axk||``.\\n\\n    References\\n    ----------\\n    .. [1] R. W. Freund, A Transpose-Free Quasi-Minimal Residual Algorithm for\\n           Non-Hermitian Linear Systems, SIAM J. Sci. Comput., 14(2), 470-482,\\n           1993.\\n    .. [2] Y. Saad, Iterative Methods for Sparse Linear Systems, 2nd edition,\\n           SIAM, Philadelphia, 2003.\\n    .. [3] C. T. Kelley, Iterative Methods for Linear and Nonlinear Equations,\\n           number 16 in Frontiers in Applied Mathematics, SIAM, Philadelphia,\\n           1995.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.sparse import csc_matrix\\n    >>> from scipy.sparse.linalg import tfqmr\\n    >>> A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)\\n    >>> b = np.array([2, 4, -1], dtype=float)\\n    >>> x, exitCode = tfqmr(A, b)\\n    >>> print(exitCode)            # 0 indicates successful convergence\\n    0\\n    >>> np.allclose(A.dot(x), b)\\n    True\\n    '\n    dtype = A.dtype\n    if np.issubdtype(dtype, np.int64):\n        dtype = float\n        A = A.astype(dtype)\n    if np.issubdtype(b.dtype, np.int64):\n        b = b.astype(dtype)\n    (A, M, x, b, postprocess) = make_system(A, M, x0, b)\n    if np.linalg.norm(b) == 0.0:\n        x = b.copy()\n        return (postprocess(x), 0)\n    ndofs = A.shape[0]\n    if maxiter is None:\n        maxiter = min(10000, ndofs * 10)\n    if x0 is None:\n        r = b.copy()\n    else:\n        r = b - A.matvec(x)\n    u = r\n    w = r.copy()\n    rstar = r\n    v = M.matvec(A.matvec(r))\n    uhat = v\n    d = theta = eta = 0.0\n    rho = np.inner(rstar.conjugate(), r)\n    rhoLast = rho\n    r0norm = np.sqrt(rho)\n    tau = r0norm\n    if r0norm == 0:\n        return (postprocess(x), 0)\n    if atol is None:\n        atol = tol * r0norm\n    else:\n        atol = max(atol, tol * r0norm)\n    for iter in range(maxiter):\n        even = iter % 2 == 0\n        if even:\n            vtrstar = np.inner(rstar.conjugate(), v)\n            if vtrstar == 0.0:\n                return (postprocess(x), -1)\n            alpha = rho / vtrstar\n            uNext = u - alpha * v\n        w -= alpha * uhat\n        d = u + theta ** 2 / alpha * eta * d\n        theta = np.linalg.norm(w) / tau\n        c = np.sqrt(1.0 / (1 + theta ** 2))\n        tau *= theta * c\n        eta = c ** 2 * alpha\n        z = M.matvec(d)\n        x += eta * z\n        if callback is not None:\n            callback(x)\n        if tau * np.sqrt(iter + 1) < atol:\n            if show:\n                print('TFQMR: Linear solve converged due to reach TOL iterations {}'.format(iter + 1))\n            return (postprocess(x), 0)\n        if not even:\n            rho = np.inner(rstar.conjugate(), w)\n            beta = rho / rhoLast\n            u = w + beta * u\n            v = beta * uhat + beta ** 2 * v\n            uhat = M.matvec(A.matvec(u))\n            v += uhat\n        else:\n            uhat = M.matvec(A.matvec(uNext))\n            u = uNext\n            rhoLast = rho\n    if show:\n        print('TFQMR: Linear solve not converged due to reach MAXIT iterations {}'.format(iter + 1))\n    return (postprocess(x), maxiter)",
            "@_deprecate_positional_args(version='1.14.0')\ndef tfqmr(A, b, x0=None, *, tol=1e-05, maxiter=None, M=None, callback=None, atol=None, show=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Use Transpose-Free Quasi-Minimal Residual iteration to solve ``Ax = b``.\\n\\n    Parameters\\n    ----------\\n    A : {sparse matrix, ndarray, LinearOperator}\\n        The real or complex N-by-N matrix of the linear system.\\n        Alternatively, `A` can be a linear operator which can\\n        produce ``Ax`` using, e.g.,\\n        `scipy.sparse.linalg.LinearOperator`.\\n    b : {ndarray}\\n        Right hand side of the linear system. Has shape (N,) or (N,1).\\n    x0 : {ndarray}\\n        Starting guess for the solution.\\n    tol, atol : float, optional\\n        Tolerances for convergence, ``norm(residual) <= max(tol*norm(b-Ax0), atol)``.\\n        The default for `tol` is 1.0e-5.\\n        The default for `atol` is ``tol * norm(b-Ax0)``.\\n\\n        .. warning::\\n\\n           The default value for `atol` will be changed in a future release.\\n           For future compatibility, specify `atol` explicitly.\\n    maxiter : int, optional\\n        Maximum number of iterations.  Iteration will stop after maxiter\\n        steps even if the specified tolerance has not been achieved.\\n        Default is ``min(10000, ndofs * 10)``, where ``ndofs = A.shape[0]``.\\n    M : {sparse matrix, ndarray, LinearOperator}\\n        Inverse of the preconditioner of A.  M should approximate the\\n        inverse of A and be easy to solve for (see Notes).  Effective\\n        preconditioning dramatically improves the rate of convergence,\\n        which implies that fewer iterations are needed to reach a given\\n        error tolerance.  By default, no preconditioner is used.\\n    callback : function, optional\\n        User-supplied function to call after each iteration.  It is called\\n        as `callback(xk)`, where `xk` is the current solution vector.\\n    show : bool, optional\\n        Specify ``show = True`` to show the convergence, ``show = False`` is\\n        to close the output of the convergence.\\n        Default is `False`.\\n\\n    Returns\\n    -------\\n    x : ndarray\\n        The converged solution.\\n    info : int\\n        Provides convergence information:\\n\\n            - 0  : successful exit\\n            - >0 : convergence to tolerance not achieved, number of iterations\\n            - <0 : illegal input or breakdown\\n\\n    Notes\\n    -----\\n    The Transpose-Free QMR algorithm is derived from the CGS algorithm.\\n    However, unlike CGS, the convergence curves for the TFQMR method is\\n    smoothed by computing a quasi minimization of the residual norm. The\\n    implementation supports left preconditioner, and the \"residual norm\"\\n    to compute in convergence criterion is actually an upper bound on the\\n    actual residual norm ``||b - Axk||``.\\n\\n    References\\n    ----------\\n    .. [1] R. W. Freund, A Transpose-Free Quasi-Minimal Residual Algorithm for\\n           Non-Hermitian Linear Systems, SIAM J. Sci. Comput., 14(2), 470-482,\\n           1993.\\n    .. [2] Y. Saad, Iterative Methods for Sparse Linear Systems, 2nd edition,\\n           SIAM, Philadelphia, 2003.\\n    .. [3] C. T. Kelley, Iterative Methods for Linear and Nonlinear Equations,\\n           number 16 in Frontiers in Applied Mathematics, SIAM, Philadelphia,\\n           1995.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.sparse import csc_matrix\\n    >>> from scipy.sparse.linalg import tfqmr\\n    >>> A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)\\n    >>> b = np.array([2, 4, -1], dtype=float)\\n    >>> x, exitCode = tfqmr(A, b)\\n    >>> print(exitCode)            # 0 indicates successful convergence\\n    0\\n    >>> np.allclose(A.dot(x), b)\\n    True\\n    '\n    dtype = A.dtype\n    if np.issubdtype(dtype, np.int64):\n        dtype = float\n        A = A.astype(dtype)\n    if np.issubdtype(b.dtype, np.int64):\n        b = b.astype(dtype)\n    (A, M, x, b, postprocess) = make_system(A, M, x0, b)\n    if np.linalg.norm(b) == 0.0:\n        x = b.copy()\n        return (postprocess(x), 0)\n    ndofs = A.shape[0]\n    if maxiter is None:\n        maxiter = min(10000, ndofs * 10)\n    if x0 is None:\n        r = b.copy()\n    else:\n        r = b - A.matvec(x)\n    u = r\n    w = r.copy()\n    rstar = r\n    v = M.matvec(A.matvec(r))\n    uhat = v\n    d = theta = eta = 0.0\n    rho = np.inner(rstar.conjugate(), r)\n    rhoLast = rho\n    r0norm = np.sqrt(rho)\n    tau = r0norm\n    if r0norm == 0:\n        return (postprocess(x), 0)\n    if atol is None:\n        atol = tol * r0norm\n    else:\n        atol = max(atol, tol * r0norm)\n    for iter in range(maxiter):\n        even = iter % 2 == 0\n        if even:\n            vtrstar = np.inner(rstar.conjugate(), v)\n            if vtrstar == 0.0:\n                return (postprocess(x), -1)\n            alpha = rho / vtrstar\n            uNext = u - alpha * v\n        w -= alpha * uhat\n        d = u + theta ** 2 / alpha * eta * d\n        theta = np.linalg.norm(w) / tau\n        c = np.sqrt(1.0 / (1 + theta ** 2))\n        tau *= theta * c\n        eta = c ** 2 * alpha\n        z = M.matvec(d)\n        x += eta * z\n        if callback is not None:\n            callback(x)\n        if tau * np.sqrt(iter + 1) < atol:\n            if show:\n                print('TFQMR: Linear solve converged due to reach TOL iterations {}'.format(iter + 1))\n            return (postprocess(x), 0)\n        if not even:\n            rho = np.inner(rstar.conjugate(), w)\n            beta = rho / rhoLast\n            u = w + beta * u\n            v = beta * uhat + beta ** 2 * v\n            uhat = M.matvec(A.matvec(u))\n            v += uhat\n        else:\n            uhat = M.matvec(A.matvec(uNext))\n            u = uNext\n            rhoLast = rho\n    if show:\n        print('TFQMR: Linear solve not converged due to reach MAXIT iterations {}'.format(iter + 1))\n    return (postprocess(x), maxiter)"
        ]
    }
]