[
    {
        "func_name": "_evalf",
        "original": "def _evalf(func, points, derivatives=False, method='RK4'):\n    \"\"\"\n    Numerical methods for numerical integration along a given set of\n    points in the complex plane.\n    \"\"\"\n    ann = func.annihilator\n    a = ann.order\n    R = ann.parent.base\n    K = R.get_field()\n    if method == 'Euler':\n        meth = _euler\n    else:\n        meth = _rk4\n    dmf = []\n    for j in ann.listofpoly:\n        dmf.append(K.new(j.to_list()))\n    red = [-dmf[i] / dmf[a] for i in range(a)]\n    y0 = func.y0\n    if len(y0) < a:\n        raise TypeError('Not Enough Initial Conditions')\n    x0 = func.x0\n    sol = [meth(red, x0, points[0], y0, a)]\n    for (i, j) in enumerate(points[1:]):\n        sol.append(meth(red, points[i], j, sol[-1], a))\n    if not derivatives:\n        return [sympify(i[0]) for i in sol]\n    else:\n        return sympify(sol)",
        "mutated": [
            "def _evalf(func, points, derivatives=False, method='RK4'):\n    if False:\n        i = 10\n    '\\n    Numerical methods for numerical integration along a given set of\\n    points in the complex plane.\\n    '\n    ann = func.annihilator\n    a = ann.order\n    R = ann.parent.base\n    K = R.get_field()\n    if method == 'Euler':\n        meth = _euler\n    else:\n        meth = _rk4\n    dmf = []\n    for j in ann.listofpoly:\n        dmf.append(K.new(j.to_list()))\n    red = [-dmf[i] / dmf[a] for i in range(a)]\n    y0 = func.y0\n    if len(y0) < a:\n        raise TypeError('Not Enough Initial Conditions')\n    x0 = func.x0\n    sol = [meth(red, x0, points[0], y0, a)]\n    for (i, j) in enumerate(points[1:]):\n        sol.append(meth(red, points[i], j, sol[-1], a))\n    if not derivatives:\n        return [sympify(i[0]) for i in sol]\n    else:\n        return sympify(sol)",
            "def _evalf(func, points, derivatives=False, method='RK4'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Numerical methods for numerical integration along a given set of\\n    points in the complex plane.\\n    '\n    ann = func.annihilator\n    a = ann.order\n    R = ann.parent.base\n    K = R.get_field()\n    if method == 'Euler':\n        meth = _euler\n    else:\n        meth = _rk4\n    dmf = []\n    for j in ann.listofpoly:\n        dmf.append(K.new(j.to_list()))\n    red = [-dmf[i] / dmf[a] for i in range(a)]\n    y0 = func.y0\n    if len(y0) < a:\n        raise TypeError('Not Enough Initial Conditions')\n    x0 = func.x0\n    sol = [meth(red, x0, points[0], y0, a)]\n    for (i, j) in enumerate(points[1:]):\n        sol.append(meth(red, points[i], j, sol[-1], a))\n    if not derivatives:\n        return [sympify(i[0]) for i in sol]\n    else:\n        return sympify(sol)",
            "def _evalf(func, points, derivatives=False, method='RK4'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Numerical methods for numerical integration along a given set of\\n    points in the complex plane.\\n    '\n    ann = func.annihilator\n    a = ann.order\n    R = ann.parent.base\n    K = R.get_field()\n    if method == 'Euler':\n        meth = _euler\n    else:\n        meth = _rk4\n    dmf = []\n    for j in ann.listofpoly:\n        dmf.append(K.new(j.to_list()))\n    red = [-dmf[i] / dmf[a] for i in range(a)]\n    y0 = func.y0\n    if len(y0) < a:\n        raise TypeError('Not Enough Initial Conditions')\n    x0 = func.x0\n    sol = [meth(red, x0, points[0], y0, a)]\n    for (i, j) in enumerate(points[1:]):\n        sol.append(meth(red, points[i], j, sol[-1], a))\n    if not derivatives:\n        return [sympify(i[0]) for i in sol]\n    else:\n        return sympify(sol)",
            "def _evalf(func, points, derivatives=False, method='RK4'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Numerical methods for numerical integration along a given set of\\n    points in the complex plane.\\n    '\n    ann = func.annihilator\n    a = ann.order\n    R = ann.parent.base\n    K = R.get_field()\n    if method == 'Euler':\n        meth = _euler\n    else:\n        meth = _rk4\n    dmf = []\n    for j in ann.listofpoly:\n        dmf.append(K.new(j.to_list()))\n    red = [-dmf[i] / dmf[a] for i in range(a)]\n    y0 = func.y0\n    if len(y0) < a:\n        raise TypeError('Not Enough Initial Conditions')\n    x0 = func.x0\n    sol = [meth(red, x0, points[0], y0, a)]\n    for (i, j) in enumerate(points[1:]):\n        sol.append(meth(red, points[i], j, sol[-1], a))\n    if not derivatives:\n        return [sympify(i[0]) for i in sol]\n    else:\n        return sympify(sol)",
            "def _evalf(func, points, derivatives=False, method='RK4'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Numerical methods for numerical integration along a given set of\\n    points in the complex plane.\\n    '\n    ann = func.annihilator\n    a = ann.order\n    R = ann.parent.base\n    K = R.get_field()\n    if method == 'Euler':\n        meth = _euler\n    else:\n        meth = _rk4\n    dmf = []\n    for j in ann.listofpoly:\n        dmf.append(K.new(j.to_list()))\n    red = [-dmf[i] / dmf[a] for i in range(a)]\n    y0 = func.y0\n    if len(y0) < a:\n        raise TypeError('Not Enough Initial Conditions')\n    x0 = func.x0\n    sol = [meth(red, x0, points[0], y0, a)]\n    for (i, j) in enumerate(points[1:]):\n        sol.append(meth(red, points[i], j, sol[-1], a))\n    if not derivatives:\n        return [sympify(i[0]) for i in sol]\n    else:\n        return sympify(sol)"
        ]
    },
    {
        "func_name": "_euler",
        "original": "def _euler(red, x0, x1, y0, a):\n    \"\"\"\n    Euler's method for numerical integration.\n    From x0 to x1 with initial values given at x0 as vector y0.\n    \"\"\"\n    A = sympify(x0)._to_mpmath(mp.prec)\n    B = sympify(x1)._to_mpmath(mp.prec)\n    y_0 = [sympify(i)._to_mpmath(mp.prec) for i in y0]\n    h = B - A\n    f_0 = y_0[1:]\n    f_0_n = 0\n    for i in range(a):\n        f_0_n += sympify(DMFsubs(red[i], A, mpm=True))._to_mpmath(mp.prec) * y_0[i]\n    f_0.append(f_0_n)\n    sol = []\n    for i in range(a):\n        sol.append(y_0[i] + h * f_0[i])\n    return sol",
        "mutated": [
            "def _euler(red, x0, x1, y0, a):\n    if False:\n        i = 10\n    \"\\n    Euler's method for numerical integration.\\n    From x0 to x1 with initial values given at x0 as vector y0.\\n    \"\n    A = sympify(x0)._to_mpmath(mp.prec)\n    B = sympify(x1)._to_mpmath(mp.prec)\n    y_0 = [sympify(i)._to_mpmath(mp.prec) for i in y0]\n    h = B - A\n    f_0 = y_0[1:]\n    f_0_n = 0\n    for i in range(a):\n        f_0_n += sympify(DMFsubs(red[i], A, mpm=True))._to_mpmath(mp.prec) * y_0[i]\n    f_0.append(f_0_n)\n    sol = []\n    for i in range(a):\n        sol.append(y_0[i] + h * f_0[i])\n    return sol",
            "def _euler(red, x0, x1, y0, a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Euler's method for numerical integration.\\n    From x0 to x1 with initial values given at x0 as vector y0.\\n    \"\n    A = sympify(x0)._to_mpmath(mp.prec)\n    B = sympify(x1)._to_mpmath(mp.prec)\n    y_0 = [sympify(i)._to_mpmath(mp.prec) for i in y0]\n    h = B - A\n    f_0 = y_0[1:]\n    f_0_n = 0\n    for i in range(a):\n        f_0_n += sympify(DMFsubs(red[i], A, mpm=True))._to_mpmath(mp.prec) * y_0[i]\n    f_0.append(f_0_n)\n    sol = []\n    for i in range(a):\n        sol.append(y_0[i] + h * f_0[i])\n    return sol",
            "def _euler(red, x0, x1, y0, a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Euler's method for numerical integration.\\n    From x0 to x1 with initial values given at x0 as vector y0.\\n    \"\n    A = sympify(x0)._to_mpmath(mp.prec)\n    B = sympify(x1)._to_mpmath(mp.prec)\n    y_0 = [sympify(i)._to_mpmath(mp.prec) for i in y0]\n    h = B - A\n    f_0 = y_0[1:]\n    f_0_n = 0\n    for i in range(a):\n        f_0_n += sympify(DMFsubs(red[i], A, mpm=True))._to_mpmath(mp.prec) * y_0[i]\n    f_0.append(f_0_n)\n    sol = []\n    for i in range(a):\n        sol.append(y_0[i] + h * f_0[i])\n    return sol",
            "def _euler(red, x0, x1, y0, a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Euler's method for numerical integration.\\n    From x0 to x1 with initial values given at x0 as vector y0.\\n    \"\n    A = sympify(x0)._to_mpmath(mp.prec)\n    B = sympify(x1)._to_mpmath(mp.prec)\n    y_0 = [sympify(i)._to_mpmath(mp.prec) for i in y0]\n    h = B - A\n    f_0 = y_0[1:]\n    f_0_n = 0\n    for i in range(a):\n        f_0_n += sympify(DMFsubs(red[i], A, mpm=True))._to_mpmath(mp.prec) * y_0[i]\n    f_0.append(f_0_n)\n    sol = []\n    for i in range(a):\n        sol.append(y_0[i] + h * f_0[i])\n    return sol",
            "def _euler(red, x0, x1, y0, a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Euler's method for numerical integration.\\n    From x0 to x1 with initial values given at x0 as vector y0.\\n    \"\n    A = sympify(x0)._to_mpmath(mp.prec)\n    B = sympify(x1)._to_mpmath(mp.prec)\n    y_0 = [sympify(i)._to_mpmath(mp.prec) for i in y0]\n    h = B - A\n    f_0 = y_0[1:]\n    f_0_n = 0\n    for i in range(a):\n        f_0_n += sympify(DMFsubs(red[i], A, mpm=True))._to_mpmath(mp.prec) * y_0[i]\n    f_0.append(f_0_n)\n    sol = []\n    for i in range(a):\n        sol.append(y_0[i] + h * f_0[i])\n    return sol"
        ]
    },
    {
        "func_name": "_rk4",
        "original": "def _rk4(red, x0, x1, y0, a):\n    \"\"\"\n    Runge-Kutta 4th order numerical method.\n    \"\"\"\n    A = sympify(x0)._to_mpmath(mp.prec)\n    B = sympify(x1)._to_mpmath(mp.prec)\n    y_0 = [sympify(i)._to_mpmath(mp.prec) for i in y0]\n    h = B - A\n    f_0_n = 0\n    f_1_n = 0\n    f_2_n = 0\n    f_3_n = 0\n    f_0 = y_0[1:]\n    for i in range(a):\n        f_0_n += sympify(DMFsubs(red[i], A, mpm=True))._to_mpmath(mp.prec) * y_0[i]\n    f_0.append(f_0_n)\n    f_1 = [y_0[i] + f_0[i] * h / 2 for i in range(1, a)]\n    for i in range(a):\n        f_1_n += sympify(DMFsubs(red[i], A + h / 2, mpm=True))._to_mpmath(mp.prec) * (y_0[i] + f_0[i] * h / 2)\n    f_1.append(f_1_n)\n    f_2 = [y_0[i] + f_1[i] * h / 2 for i in range(1, a)]\n    for i in range(a):\n        f_2_n += sympify(DMFsubs(red[i], A + h / 2, mpm=True))._to_mpmath(mp.prec) * (y_0[i] + f_1[i] * h / 2)\n    f_2.append(f_2_n)\n    f_3 = [y_0[i] + f_2[i] * h for i in range(1, a)]\n    for i in range(a):\n        f_3_n += sympify(DMFsubs(red[i], A + h, mpm=True))._to_mpmath(mp.prec) * (y_0[i] + f_2[i] * h)\n    f_3.append(f_3_n)\n    sol = []\n    for i in range(a):\n        sol.append(y_0[i] + h * (f_0[i] + 2 * f_1[i] + 2 * f_2[i] + f_3[i]) / 6)\n    return sol",
        "mutated": [
            "def _rk4(red, x0, x1, y0, a):\n    if False:\n        i = 10\n    '\\n    Runge-Kutta 4th order numerical method.\\n    '\n    A = sympify(x0)._to_mpmath(mp.prec)\n    B = sympify(x1)._to_mpmath(mp.prec)\n    y_0 = [sympify(i)._to_mpmath(mp.prec) for i in y0]\n    h = B - A\n    f_0_n = 0\n    f_1_n = 0\n    f_2_n = 0\n    f_3_n = 0\n    f_0 = y_0[1:]\n    for i in range(a):\n        f_0_n += sympify(DMFsubs(red[i], A, mpm=True))._to_mpmath(mp.prec) * y_0[i]\n    f_0.append(f_0_n)\n    f_1 = [y_0[i] + f_0[i] * h / 2 for i in range(1, a)]\n    for i in range(a):\n        f_1_n += sympify(DMFsubs(red[i], A + h / 2, mpm=True))._to_mpmath(mp.prec) * (y_0[i] + f_0[i] * h / 2)\n    f_1.append(f_1_n)\n    f_2 = [y_0[i] + f_1[i] * h / 2 for i in range(1, a)]\n    for i in range(a):\n        f_2_n += sympify(DMFsubs(red[i], A + h / 2, mpm=True))._to_mpmath(mp.prec) * (y_0[i] + f_1[i] * h / 2)\n    f_2.append(f_2_n)\n    f_3 = [y_0[i] + f_2[i] * h for i in range(1, a)]\n    for i in range(a):\n        f_3_n += sympify(DMFsubs(red[i], A + h, mpm=True))._to_mpmath(mp.prec) * (y_0[i] + f_2[i] * h)\n    f_3.append(f_3_n)\n    sol = []\n    for i in range(a):\n        sol.append(y_0[i] + h * (f_0[i] + 2 * f_1[i] + 2 * f_2[i] + f_3[i]) / 6)\n    return sol",
            "def _rk4(red, x0, x1, y0, a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Runge-Kutta 4th order numerical method.\\n    '\n    A = sympify(x0)._to_mpmath(mp.prec)\n    B = sympify(x1)._to_mpmath(mp.prec)\n    y_0 = [sympify(i)._to_mpmath(mp.prec) for i in y0]\n    h = B - A\n    f_0_n = 0\n    f_1_n = 0\n    f_2_n = 0\n    f_3_n = 0\n    f_0 = y_0[1:]\n    for i in range(a):\n        f_0_n += sympify(DMFsubs(red[i], A, mpm=True))._to_mpmath(mp.prec) * y_0[i]\n    f_0.append(f_0_n)\n    f_1 = [y_0[i] + f_0[i] * h / 2 for i in range(1, a)]\n    for i in range(a):\n        f_1_n += sympify(DMFsubs(red[i], A + h / 2, mpm=True))._to_mpmath(mp.prec) * (y_0[i] + f_0[i] * h / 2)\n    f_1.append(f_1_n)\n    f_2 = [y_0[i] + f_1[i] * h / 2 for i in range(1, a)]\n    for i in range(a):\n        f_2_n += sympify(DMFsubs(red[i], A + h / 2, mpm=True))._to_mpmath(mp.prec) * (y_0[i] + f_1[i] * h / 2)\n    f_2.append(f_2_n)\n    f_3 = [y_0[i] + f_2[i] * h for i in range(1, a)]\n    for i in range(a):\n        f_3_n += sympify(DMFsubs(red[i], A + h, mpm=True))._to_mpmath(mp.prec) * (y_0[i] + f_2[i] * h)\n    f_3.append(f_3_n)\n    sol = []\n    for i in range(a):\n        sol.append(y_0[i] + h * (f_0[i] + 2 * f_1[i] + 2 * f_2[i] + f_3[i]) / 6)\n    return sol",
            "def _rk4(red, x0, x1, y0, a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Runge-Kutta 4th order numerical method.\\n    '\n    A = sympify(x0)._to_mpmath(mp.prec)\n    B = sympify(x1)._to_mpmath(mp.prec)\n    y_0 = [sympify(i)._to_mpmath(mp.prec) for i in y0]\n    h = B - A\n    f_0_n = 0\n    f_1_n = 0\n    f_2_n = 0\n    f_3_n = 0\n    f_0 = y_0[1:]\n    for i in range(a):\n        f_0_n += sympify(DMFsubs(red[i], A, mpm=True))._to_mpmath(mp.prec) * y_0[i]\n    f_0.append(f_0_n)\n    f_1 = [y_0[i] + f_0[i] * h / 2 for i in range(1, a)]\n    for i in range(a):\n        f_1_n += sympify(DMFsubs(red[i], A + h / 2, mpm=True))._to_mpmath(mp.prec) * (y_0[i] + f_0[i] * h / 2)\n    f_1.append(f_1_n)\n    f_2 = [y_0[i] + f_1[i] * h / 2 for i in range(1, a)]\n    for i in range(a):\n        f_2_n += sympify(DMFsubs(red[i], A + h / 2, mpm=True))._to_mpmath(mp.prec) * (y_0[i] + f_1[i] * h / 2)\n    f_2.append(f_2_n)\n    f_3 = [y_0[i] + f_2[i] * h for i in range(1, a)]\n    for i in range(a):\n        f_3_n += sympify(DMFsubs(red[i], A + h, mpm=True))._to_mpmath(mp.prec) * (y_0[i] + f_2[i] * h)\n    f_3.append(f_3_n)\n    sol = []\n    for i in range(a):\n        sol.append(y_0[i] + h * (f_0[i] + 2 * f_1[i] + 2 * f_2[i] + f_3[i]) / 6)\n    return sol",
            "def _rk4(red, x0, x1, y0, a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Runge-Kutta 4th order numerical method.\\n    '\n    A = sympify(x0)._to_mpmath(mp.prec)\n    B = sympify(x1)._to_mpmath(mp.prec)\n    y_0 = [sympify(i)._to_mpmath(mp.prec) for i in y0]\n    h = B - A\n    f_0_n = 0\n    f_1_n = 0\n    f_2_n = 0\n    f_3_n = 0\n    f_0 = y_0[1:]\n    for i in range(a):\n        f_0_n += sympify(DMFsubs(red[i], A, mpm=True))._to_mpmath(mp.prec) * y_0[i]\n    f_0.append(f_0_n)\n    f_1 = [y_0[i] + f_0[i] * h / 2 for i in range(1, a)]\n    for i in range(a):\n        f_1_n += sympify(DMFsubs(red[i], A + h / 2, mpm=True))._to_mpmath(mp.prec) * (y_0[i] + f_0[i] * h / 2)\n    f_1.append(f_1_n)\n    f_2 = [y_0[i] + f_1[i] * h / 2 for i in range(1, a)]\n    for i in range(a):\n        f_2_n += sympify(DMFsubs(red[i], A + h / 2, mpm=True))._to_mpmath(mp.prec) * (y_0[i] + f_1[i] * h / 2)\n    f_2.append(f_2_n)\n    f_3 = [y_0[i] + f_2[i] * h for i in range(1, a)]\n    for i in range(a):\n        f_3_n += sympify(DMFsubs(red[i], A + h, mpm=True))._to_mpmath(mp.prec) * (y_0[i] + f_2[i] * h)\n    f_3.append(f_3_n)\n    sol = []\n    for i in range(a):\n        sol.append(y_0[i] + h * (f_0[i] + 2 * f_1[i] + 2 * f_2[i] + f_3[i]) / 6)\n    return sol",
            "def _rk4(red, x0, x1, y0, a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Runge-Kutta 4th order numerical method.\\n    '\n    A = sympify(x0)._to_mpmath(mp.prec)\n    B = sympify(x1)._to_mpmath(mp.prec)\n    y_0 = [sympify(i)._to_mpmath(mp.prec) for i in y0]\n    h = B - A\n    f_0_n = 0\n    f_1_n = 0\n    f_2_n = 0\n    f_3_n = 0\n    f_0 = y_0[1:]\n    for i in range(a):\n        f_0_n += sympify(DMFsubs(red[i], A, mpm=True))._to_mpmath(mp.prec) * y_0[i]\n    f_0.append(f_0_n)\n    f_1 = [y_0[i] + f_0[i] * h / 2 for i in range(1, a)]\n    for i in range(a):\n        f_1_n += sympify(DMFsubs(red[i], A + h / 2, mpm=True))._to_mpmath(mp.prec) * (y_0[i] + f_0[i] * h / 2)\n    f_1.append(f_1_n)\n    f_2 = [y_0[i] + f_1[i] * h / 2 for i in range(1, a)]\n    for i in range(a):\n        f_2_n += sympify(DMFsubs(red[i], A + h / 2, mpm=True))._to_mpmath(mp.prec) * (y_0[i] + f_1[i] * h / 2)\n    f_2.append(f_2_n)\n    f_3 = [y_0[i] + f_2[i] * h for i in range(1, a)]\n    for i in range(a):\n        f_3_n += sympify(DMFsubs(red[i], A + h, mpm=True))._to_mpmath(mp.prec) * (y_0[i] + f_2[i] * h)\n    f_3.append(f_3_n)\n    sol = []\n    for i in range(a):\n        sol.append(y_0[i] + h * (f_0[i] + 2 * f_1[i] + 2 * f_2[i] + f_3[i]) / 6)\n    return sol"
        ]
    }
]