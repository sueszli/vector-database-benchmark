[
    {
        "func_name": "test_gdb_parameter_default_value_works",
        "original": "@pytest.mark.parametrize('params', (('int', 123, '123', {}), ('bool', True, 'on', {}), ('bool', False, 'off', {}), ('string', 'some-string-val', 'some-string-val', {}), ('auto-bool', None, 'auto', {'param_class': gdb.PARAM_AUTO_BOOLEAN}), ('unlimited-uint', 0, 'unlimited', {'param_class': gdb.PARAM_UINTEGER}), ('unlimited-int', 0, 'unlimited', {'param_class': gdb.PARAM_INTEGER}), ('enum', 'enum1', 'enum1', {'param_class': gdb.PARAM_ENUM, 'enum_sequence': ['enum1', 'enum2', 'enum3']}), ('zuint', 0, '0', {'param_class': gdb.PARAM_ZUINTEGER if hasattr(gdb, 'PARAM_ZUINTEGER') else 'PARAM_ZUINTEGER'}), ('unlimited-zuint', -1, 'unlimited', {'param_class': gdb.PARAM_ZUINTEGER_UNLIMITED if hasattr(gdb, 'PARAM_ZUINTEGER_UNLIMITED') else 'PARAM_ZUINTEGER_UNLIMITED'})))\ndef test_gdb_parameter_default_value_works(start_binary, params):\n    if not params:\n        pytest.skip('Current GDB version does not support this testcase')\n    (name_suffix, default_value, displayed_value, optional_kwargs) = params\n    param_name = f'test-param-{name_suffix}'\n    help_docstring = f'Help docstring for {param_name}'\n    set_show_doc = 'the value of the foo'\n    param = pwndbg.gdblib.config.add_param(param_name, default_value, set_show_doc, help_docstring=help_docstring, **optional_kwargs)\n    pwndbg.gdblib.config_mod.Parameter(param)\n    out = gdb.execute(f'show {param_name}', to_string=True)\n    assert out == f'{set_show_doc.capitalize()} is {displayed_value!r}. See `help set {param_name}` for more information.\\n'\n    if optional_kwargs.get('param_class') in (gdb.PARAM_UINTEGER, gdb.PARAM_INTEGER) and default_value == 0:\n        assert gdb.parameter(param_name) is None\n    else:\n        assert gdb.parameter(param_name) == default_value\n    assert param.value == default_value\n    out = gdb.execute(f'help show {param_name}', to_string=True)\n    assert out == f'Show {set_show_doc}.\\n{help_docstring}\\n'\n    assert gdb.execute(f'help set {param_name}', to_string=True) == f'Set {set_show_doc}.\\n{help_docstring}\\n'",
        "mutated": [
            "@pytest.mark.parametrize('params', (('int', 123, '123', {}), ('bool', True, 'on', {}), ('bool', False, 'off', {}), ('string', 'some-string-val', 'some-string-val', {}), ('auto-bool', None, 'auto', {'param_class': gdb.PARAM_AUTO_BOOLEAN}), ('unlimited-uint', 0, 'unlimited', {'param_class': gdb.PARAM_UINTEGER}), ('unlimited-int', 0, 'unlimited', {'param_class': gdb.PARAM_INTEGER}), ('enum', 'enum1', 'enum1', {'param_class': gdb.PARAM_ENUM, 'enum_sequence': ['enum1', 'enum2', 'enum3']}), ('zuint', 0, '0', {'param_class': gdb.PARAM_ZUINTEGER if hasattr(gdb, 'PARAM_ZUINTEGER') else 'PARAM_ZUINTEGER'}), ('unlimited-zuint', -1, 'unlimited', {'param_class': gdb.PARAM_ZUINTEGER_UNLIMITED if hasattr(gdb, 'PARAM_ZUINTEGER_UNLIMITED') else 'PARAM_ZUINTEGER_UNLIMITED'})))\ndef test_gdb_parameter_default_value_works(start_binary, params):\n    if False:\n        i = 10\n    if not params:\n        pytest.skip('Current GDB version does not support this testcase')\n    (name_suffix, default_value, displayed_value, optional_kwargs) = params\n    param_name = f'test-param-{name_suffix}'\n    help_docstring = f'Help docstring for {param_name}'\n    set_show_doc = 'the value of the foo'\n    param = pwndbg.gdblib.config.add_param(param_name, default_value, set_show_doc, help_docstring=help_docstring, **optional_kwargs)\n    pwndbg.gdblib.config_mod.Parameter(param)\n    out = gdb.execute(f'show {param_name}', to_string=True)\n    assert out == f'{set_show_doc.capitalize()} is {displayed_value!r}. See `help set {param_name}` for more information.\\n'\n    if optional_kwargs.get('param_class') in (gdb.PARAM_UINTEGER, gdb.PARAM_INTEGER) and default_value == 0:\n        assert gdb.parameter(param_name) is None\n    else:\n        assert gdb.parameter(param_name) == default_value\n    assert param.value == default_value\n    out = gdb.execute(f'help show {param_name}', to_string=True)\n    assert out == f'Show {set_show_doc}.\\n{help_docstring}\\n'\n    assert gdb.execute(f'help set {param_name}', to_string=True) == f'Set {set_show_doc}.\\n{help_docstring}\\n'",
            "@pytest.mark.parametrize('params', (('int', 123, '123', {}), ('bool', True, 'on', {}), ('bool', False, 'off', {}), ('string', 'some-string-val', 'some-string-val', {}), ('auto-bool', None, 'auto', {'param_class': gdb.PARAM_AUTO_BOOLEAN}), ('unlimited-uint', 0, 'unlimited', {'param_class': gdb.PARAM_UINTEGER}), ('unlimited-int', 0, 'unlimited', {'param_class': gdb.PARAM_INTEGER}), ('enum', 'enum1', 'enum1', {'param_class': gdb.PARAM_ENUM, 'enum_sequence': ['enum1', 'enum2', 'enum3']}), ('zuint', 0, '0', {'param_class': gdb.PARAM_ZUINTEGER if hasattr(gdb, 'PARAM_ZUINTEGER') else 'PARAM_ZUINTEGER'}), ('unlimited-zuint', -1, 'unlimited', {'param_class': gdb.PARAM_ZUINTEGER_UNLIMITED if hasattr(gdb, 'PARAM_ZUINTEGER_UNLIMITED') else 'PARAM_ZUINTEGER_UNLIMITED'})))\ndef test_gdb_parameter_default_value_works(start_binary, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not params:\n        pytest.skip('Current GDB version does not support this testcase')\n    (name_suffix, default_value, displayed_value, optional_kwargs) = params\n    param_name = f'test-param-{name_suffix}'\n    help_docstring = f'Help docstring for {param_name}'\n    set_show_doc = 'the value of the foo'\n    param = pwndbg.gdblib.config.add_param(param_name, default_value, set_show_doc, help_docstring=help_docstring, **optional_kwargs)\n    pwndbg.gdblib.config_mod.Parameter(param)\n    out = gdb.execute(f'show {param_name}', to_string=True)\n    assert out == f'{set_show_doc.capitalize()} is {displayed_value!r}. See `help set {param_name}` for more information.\\n'\n    if optional_kwargs.get('param_class') in (gdb.PARAM_UINTEGER, gdb.PARAM_INTEGER) and default_value == 0:\n        assert gdb.parameter(param_name) is None\n    else:\n        assert gdb.parameter(param_name) == default_value\n    assert param.value == default_value\n    out = gdb.execute(f'help show {param_name}', to_string=True)\n    assert out == f'Show {set_show_doc}.\\n{help_docstring}\\n'\n    assert gdb.execute(f'help set {param_name}', to_string=True) == f'Set {set_show_doc}.\\n{help_docstring}\\n'",
            "@pytest.mark.parametrize('params', (('int', 123, '123', {}), ('bool', True, 'on', {}), ('bool', False, 'off', {}), ('string', 'some-string-val', 'some-string-val', {}), ('auto-bool', None, 'auto', {'param_class': gdb.PARAM_AUTO_BOOLEAN}), ('unlimited-uint', 0, 'unlimited', {'param_class': gdb.PARAM_UINTEGER}), ('unlimited-int', 0, 'unlimited', {'param_class': gdb.PARAM_INTEGER}), ('enum', 'enum1', 'enum1', {'param_class': gdb.PARAM_ENUM, 'enum_sequence': ['enum1', 'enum2', 'enum3']}), ('zuint', 0, '0', {'param_class': gdb.PARAM_ZUINTEGER if hasattr(gdb, 'PARAM_ZUINTEGER') else 'PARAM_ZUINTEGER'}), ('unlimited-zuint', -1, 'unlimited', {'param_class': gdb.PARAM_ZUINTEGER_UNLIMITED if hasattr(gdb, 'PARAM_ZUINTEGER_UNLIMITED') else 'PARAM_ZUINTEGER_UNLIMITED'})))\ndef test_gdb_parameter_default_value_works(start_binary, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not params:\n        pytest.skip('Current GDB version does not support this testcase')\n    (name_suffix, default_value, displayed_value, optional_kwargs) = params\n    param_name = f'test-param-{name_suffix}'\n    help_docstring = f'Help docstring for {param_name}'\n    set_show_doc = 'the value of the foo'\n    param = pwndbg.gdblib.config.add_param(param_name, default_value, set_show_doc, help_docstring=help_docstring, **optional_kwargs)\n    pwndbg.gdblib.config_mod.Parameter(param)\n    out = gdb.execute(f'show {param_name}', to_string=True)\n    assert out == f'{set_show_doc.capitalize()} is {displayed_value!r}. See `help set {param_name}` for more information.\\n'\n    if optional_kwargs.get('param_class') in (gdb.PARAM_UINTEGER, gdb.PARAM_INTEGER) and default_value == 0:\n        assert gdb.parameter(param_name) is None\n    else:\n        assert gdb.parameter(param_name) == default_value\n    assert param.value == default_value\n    out = gdb.execute(f'help show {param_name}', to_string=True)\n    assert out == f'Show {set_show_doc}.\\n{help_docstring}\\n'\n    assert gdb.execute(f'help set {param_name}', to_string=True) == f'Set {set_show_doc}.\\n{help_docstring}\\n'",
            "@pytest.mark.parametrize('params', (('int', 123, '123', {}), ('bool', True, 'on', {}), ('bool', False, 'off', {}), ('string', 'some-string-val', 'some-string-val', {}), ('auto-bool', None, 'auto', {'param_class': gdb.PARAM_AUTO_BOOLEAN}), ('unlimited-uint', 0, 'unlimited', {'param_class': gdb.PARAM_UINTEGER}), ('unlimited-int', 0, 'unlimited', {'param_class': gdb.PARAM_INTEGER}), ('enum', 'enum1', 'enum1', {'param_class': gdb.PARAM_ENUM, 'enum_sequence': ['enum1', 'enum2', 'enum3']}), ('zuint', 0, '0', {'param_class': gdb.PARAM_ZUINTEGER if hasattr(gdb, 'PARAM_ZUINTEGER') else 'PARAM_ZUINTEGER'}), ('unlimited-zuint', -1, 'unlimited', {'param_class': gdb.PARAM_ZUINTEGER_UNLIMITED if hasattr(gdb, 'PARAM_ZUINTEGER_UNLIMITED') else 'PARAM_ZUINTEGER_UNLIMITED'})))\ndef test_gdb_parameter_default_value_works(start_binary, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not params:\n        pytest.skip('Current GDB version does not support this testcase')\n    (name_suffix, default_value, displayed_value, optional_kwargs) = params\n    param_name = f'test-param-{name_suffix}'\n    help_docstring = f'Help docstring for {param_name}'\n    set_show_doc = 'the value of the foo'\n    param = pwndbg.gdblib.config.add_param(param_name, default_value, set_show_doc, help_docstring=help_docstring, **optional_kwargs)\n    pwndbg.gdblib.config_mod.Parameter(param)\n    out = gdb.execute(f'show {param_name}', to_string=True)\n    assert out == f'{set_show_doc.capitalize()} is {displayed_value!r}. See `help set {param_name}` for more information.\\n'\n    if optional_kwargs.get('param_class') in (gdb.PARAM_UINTEGER, gdb.PARAM_INTEGER) and default_value == 0:\n        assert gdb.parameter(param_name) is None\n    else:\n        assert gdb.parameter(param_name) == default_value\n    assert param.value == default_value\n    out = gdb.execute(f'help show {param_name}', to_string=True)\n    assert out == f'Show {set_show_doc}.\\n{help_docstring}\\n'\n    assert gdb.execute(f'help set {param_name}', to_string=True) == f'Set {set_show_doc}.\\n{help_docstring}\\n'",
            "@pytest.mark.parametrize('params', (('int', 123, '123', {}), ('bool', True, 'on', {}), ('bool', False, 'off', {}), ('string', 'some-string-val', 'some-string-val', {}), ('auto-bool', None, 'auto', {'param_class': gdb.PARAM_AUTO_BOOLEAN}), ('unlimited-uint', 0, 'unlimited', {'param_class': gdb.PARAM_UINTEGER}), ('unlimited-int', 0, 'unlimited', {'param_class': gdb.PARAM_INTEGER}), ('enum', 'enum1', 'enum1', {'param_class': gdb.PARAM_ENUM, 'enum_sequence': ['enum1', 'enum2', 'enum3']}), ('zuint', 0, '0', {'param_class': gdb.PARAM_ZUINTEGER if hasattr(gdb, 'PARAM_ZUINTEGER') else 'PARAM_ZUINTEGER'}), ('unlimited-zuint', -1, 'unlimited', {'param_class': gdb.PARAM_ZUINTEGER_UNLIMITED if hasattr(gdb, 'PARAM_ZUINTEGER_UNLIMITED') else 'PARAM_ZUINTEGER_UNLIMITED'})))\ndef test_gdb_parameter_default_value_works(start_binary, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not params:\n        pytest.skip('Current GDB version does not support this testcase')\n    (name_suffix, default_value, displayed_value, optional_kwargs) = params\n    param_name = f'test-param-{name_suffix}'\n    help_docstring = f'Help docstring for {param_name}'\n    set_show_doc = 'the value of the foo'\n    param = pwndbg.gdblib.config.add_param(param_name, default_value, set_show_doc, help_docstring=help_docstring, **optional_kwargs)\n    pwndbg.gdblib.config_mod.Parameter(param)\n    out = gdb.execute(f'show {param_name}', to_string=True)\n    assert out == f'{set_show_doc.capitalize()} is {displayed_value!r}. See `help set {param_name}` for more information.\\n'\n    if optional_kwargs.get('param_class') in (gdb.PARAM_UINTEGER, gdb.PARAM_INTEGER) and default_value == 0:\n        assert gdb.parameter(param_name) is None\n    else:\n        assert gdb.parameter(param_name) == default_value\n    assert param.value == default_value\n    out = gdb.execute(f'help show {param_name}', to_string=True)\n    assert out == f'Show {set_show_doc}.\\n{help_docstring}\\n'\n    assert gdb.execute(f'help set {param_name}', to_string=True) == f'Set {set_show_doc}.\\n{help_docstring}\\n'"
        ]
    }
]