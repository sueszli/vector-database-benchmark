[
    {
        "func_name": "mag_bin_distr",
        "original": "def mag_bin_distr(f_for_sherifs):\n    binning_in_mag = np.array([round(i, 1) for i in list(np.linspace(5, 10, 51))])\n    nb_rup_per_bin = []\n    for si in range(len(f_for_sherifs)):\n        nb_for_i = []\n        for j in binning_in_mag:\n            nb_for_i.append(0)\n        nb_rup_per_bin.append(nb_for_i)\n    return (binning_in_mag, nb_rup_per_bin)",
        "mutated": [
            "def mag_bin_distr(f_for_sherifs):\n    if False:\n        i = 10\n    binning_in_mag = np.array([round(i, 1) for i in list(np.linspace(5, 10, 51))])\n    nb_rup_per_bin = []\n    for si in range(len(f_for_sherifs)):\n        nb_for_i = []\n        for j in binning_in_mag:\n            nb_for_i.append(0)\n        nb_rup_per_bin.append(nb_for_i)\n    return (binning_in_mag, nb_rup_per_bin)",
            "def mag_bin_distr(f_for_sherifs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    binning_in_mag = np.array([round(i, 1) for i in list(np.linspace(5, 10, 51))])\n    nb_rup_per_bin = []\n    for si in range(len(f_for_sherifs)):\n        nb_for_i = []\n        for j in binning_in_mag:\n            nb_for_i.append(0)\n        nb_rup_per_bin.append(nb_for_i)\n    return (binning_in_mag, nb_rup_per_bin)",
            "def mag_bin_distr(f_for_sherifs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    binning_in_mag = np.array([round(i, 1) for i in list(np.linspace(5, 10, 51))])\n    nb_rup_per_bin = []\n    for si in range(len(f_for_sherifs)):\n        nb_for_i = []\n        for j in binning_in_mag:\n            nb_for_i.append(0)\n        nb_rup_per_bin.append(nb_for_i)\n    return (binning_in_mag, nb_rup_per_bin)",
            "def mag_bin_distr(f_for_sherifs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    binning_in_mag = np.array([round(i, 1) for i in list(np.linspace(5, 10, 51))])\n    nb_rup_per_bin = []\n    for si in range(len(f_for_sherifs)):\n        nb_for_i = []\n        for j in binning_in_mag:\n            nb_for_i.append(0)\n        nb_rup_per_bin.append(nb_for_i)\n    return (binning_in_mag, nb_rup_per_bin)",
            "def mag_bin_distr(f_for_sherifs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    binning_in_mag = np.array([round(i, 1) for i in list(np.linspace(5, 10, 51))])\n    nb_rup_per_bin = []\n    for si in range(len(f_for_sherifs)):\n        nb_for_i = []\n        for j in binning_in_mag:\n            nb_for_i.append(0)\n        nb_rup_per_bin.append(nb_for_i)\n    return (binning_in_mag, nb_rup_per_bin)"
        ]
    },
    {
        "func_name": "build_scenarios",
        "original": "def build_scenarios(f_for_sherifs, id_sections_fault, sections_areas_tot, sections_lengths_tot, binning_in_mag, nb_rup_per_bin, section_jump):\n    t0 = time.time()\n    max_fault_jumps = 100\n    max_fault_invo = 100\n    max_zig_zag = 2\n    nb_sections = len(f_for_sherifs)\n    rup = []\n    rup_paired = []\n    full_fault_rup = []\n    rup_f_jump = []\n    for si in range(nb_sections):\n        f_for_sherifs[si]['rup_id'] = []\n    rups_length = []\n    rups_area = []\n    rups_rake = []\n    rups_mag = []\n    target_section = False\n    if target_section == True:\n        look_at = 917\n    too_long = 0\n    too_big = 0\n    rup_id = 0\n    for si in range(len(f_for_sherifs)):\n        new_rup = [si]\n        rup.append(new_rup)\n        rup_paired.append([])\n        rup_area = sections_areas_tot[si]\n        rake = f_for_sherifs[si]['rake']\n        mag = wc1994_median_mag(rup_area, rake)\n        index_mag = np.where(binning_in_mag == round(mag, 1))[0][0]\n        for sk in new_rup:\n            f_for_sherifs[sk]['rup_id'].append(rup_id)\n            nb_rup_per_bin[sk][index_mag] += 1\n            f_for_sherifs[sk]['max_length'] = sections_lengths_tot[si]\n        rups_length.append(sections_lengths_tot[si])\n        rups_area.append(rup_area)\n        rups_rake.append(f_for_sherifs[si]['rake'])\n        rups_mag.append(mag)\n        full_fault = False\n        len_2 = len(id_sections_fault[f_for_sherifs[new_rup[0]]['oiler_id']])\n        if len_2 == len(new_rup):\n            full_fault = True\n        full_fault_rup.append(full_fault)\n        rup_f_jump.append([])\n        rup_id += 1\n    for si in range(nb_sections):\n        fi = f_for_sherifs[si]['oiler_id']\n        sec_fi = id_sections_fault[fi]\n        if len(sec_fi) > 1:\n            id_si_in_fi = sec_fi.index(si)\n            for i in range(len(sec_fi) - id_si_in_fi):\n                new_rup = sec_fi[id_si_in_fi:id_si_in_fi + i + 1]\n                new_rup = sorted(list(set(new_rup)))\n                rup_length = sum([sections_lengths_tot[sk] for sk in new_rup])\n                max_length = min([f_for_sherifs[i]['max_possible_length'] for sk in new_rup])\n                rup_area = sum([sections_areas_tot[sk] for sk in new_rup])\n                max_mmax = min([f_for_sherifs[sk]['max_possible_Mmax'] for sk in new_rup])\n                rake = sum([sections_areas_tot[sk] * f_for_sherifs[sk]['rake'] for sk in new_rup]) / rup_area\n                mag = wc1994_median_mag(rup_area, rake)\n                index_mag = np.where(binning_in_mag == round(mag, 1))[0][0]\n                if len(new_rup) > 1 and rup_length < max_length:\n                    if mag <= max_mmax:\n                        if not new_rup in rup:\n                            nb_fault_invo = len(set([f_for_sherifs[i]['oiler_id'] for sk in new_rup]))\n                            if nb_fault_invo <= max_fault_invo:\n                                rup.append(new_rup)\n                                rup_paired.append([])\n                                for sk in new_rup:\n                                    nb_rup_per_bin[sk][index_mag] += 1\n                                    f_for_sherifs[sk]['rup_id'].append(rup_id)\n                                    if rup_length > f_for_sherifs[sk]['max_length']:\n                                        f_for_sherifs[sk]['max_length'] = rup_length\n                                rups_length.append(rup_length)\n                                rups_area.append(rup_area)\n                                rups_rake.append(rake)\n                                rups_mag.append(mag)\n                                full_fault = False\n                                if nb_fault_invo == 1:\n                                    len_2 = len(id_sections_fault[f_for_sherifs[new_rup[0]]['oiler_id']])\n                                    if len_2 == len(new_rup):\n                                        full_fault = True\n                                full_fault_rup.append(full_fault)\n                                rup_f_jump.append([])\n                                rup_id += 1\n                    else:\n                        too_big += 1\n                else:\n                    too_long += 1\n    if target_section == True:\n        print('look at section :', look_at, '\\nother sections in the same fault', id_sections_fault[f_for_sherifs[look_at]['oiler_id']], '\\njumps with', section_jump[look_at], '\\nruptures', f_for_sherifs[look_at]['rup_id'])\n        print('ruptures :')\n        for rup_i in [rup[i] for i in f_for_sherifs[look_at]['rup_id']]:\n            print(rup_i)\n    print('\\nNumber of rup without jumps: ', len(rup), '\\n')\n    last_l = -1\n    loop = 1\n    already_created = 0\n    already_paired = 0\n    too_many_faults = 0\n    too_many_jumps = 0\n    too_many_zig_zag = 0\n    not_diverse_enough = 0\n    max_length = min([f_for_sherifs[sk]['max_possible_length'] for sk in range(nb_sections)])\n    while last_l != len(rup):\n        print('\\n##\\n-> Loop', loop)\n        last_l = len(rup)\n        for si in range(nb_sections):\n            sec_fi = id_sections_fault[fi]\n            jumps = section_jump[si]\n            si_rup = f_for_sherifs[si]['rup_id']\n            for sj in jumps:\n                sj_rup = f_for_sherifs[sj]['rup_id']\n                sj_rup = [i for i in sj_rup if not si in rup[i]]\n                sii_rup = [i for i in si_rup if not sj in rup[i]]\n                for id_rup_i in sii_rup:\n                    if rups_length[id_rup_i] > max_length / 2.0:\n                        sjj_rup = [j for j in sj_rup if full_fault_rup[j] == True]\n                    else:\n                        sjj_rup = [j for j in sj_rup if rups_length[j] < max_length / 2.0]\n                    for id_rup_j in sjj_rup:\n                        build = True\n                        nb_jumps = len(rup_f_jump[id_rup_j] + rup_f_jump[id_rup_i]) + 1\n                        if nb_jumps <= max_fault_jumps:\n                            build = True\n                        else:\n                            build = False\n                            too_many_jumps += 1\n                        if build == True:\n                            jump_i = sorted([f_for_sherifs[si]['oiler_id'], f_for_sherifs[sj]['oiler_id']])\n                            nb_zig_zag = rup_f_jump[id_rup_j].count(jump_i) + rup_f_jump[id_rup_i].count(jump_i)\n                            if not nb_zig_zag > max_zig_zag:\n                                build = True\n                            else:\n                                build = False\n                                too_many_zig_zag += 1\n                        if build == True:\n                            if id_rup_j in rup_paired[id_rup_i]:\n                                build = False\n                                already_paired += 1\n                        if build == True:\n                            if id_rup_i in rup_paired[id_rup_j]:\n                                build = False\n                                already_paired += 1\n                        if build == True:\n                            new_rup = rup[id_rup_i] + rup[id_rup_j]\n                            new_rup = sorted(list(set(new_rup)))\n                            rup_length = rups_length[id_rup_i] + rups_length[id_rup_j]\n                            max_length = min([f_for_sherifs[sk]['max_possible_length'] for sk in new_rup])\n                            rup_area = rups_area[id_rup_i] + rups_area[id_rup_j]\n                            max_mmax = min([f_for_sherifs[sk]['max_possible_Mmax'] for sk in new_rup])\n                            rake = (rups_rake[id_rup_i] * rups_area[id_rup_i] + rups_rake[id_rup_j] * rups_area[id_rup_j]) / rup_area\n                            mag = wc1994_median_mag(rup_area, rake)\n                            index_mag = np.where(binning_in_mag == round(mag, 1))[0][0]\n                            if rup_length > max_length:\n                                build = False\n                                too_long += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                            if build == True and mag > max_mmax:\n                                build = False\n                                too_big += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                        if build == True:\n                            if not new_rup in rup:\n                                build = True\n                                nb_fault_invo = len(set([f_for_sherifs[i]['oiler_id'] for i in new_rup]))\n                            else:\n                                build = False\n                                already_created += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                        if build == True:\n                            if nb_fault_invo <= max_fault_invo:\n                                build = True\n                            else:\n                                build = False\n                                too_many_faults += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                        if build == True:\n                            test_using_length = False\n                            test_using_mag = True\n                            if test_using_length == True:\n                                nb_rup_sec = [len(f_for_sherifs[i]['rup_id']) for i in new_rup]\n                                max_nb_rup_i = max(nb_rup_sec)\n                                mean_nb_rup = len(rup) / nb_sections\n                                min_max_length_i = min([f_for_sherifs[i]['max_length'] for i in new_rup])\n                                mean_max_length_i = np.mean([f_for_sherifs[i]['max_length'] for i in new_rup])\n                                hogger = False\n                                if max_nb_rup_i > 40 and rup_length < mean_max_length_i * 1.5:\n                                    hogger = True\n                                if hogger == True:\n                                    nb_i_to_remove = 0\n                                    if rup_length < min_max_length_i / 2.0:\n                                        if len(rup[id_rup_j]) < 2 or len(rup[id_rup_i]) < 2:\n                                            build = False\n                                        else:\n                                            nb_i_to_remove = 2\n                                    elif rup_length < min_max_length_i * 3.0 / 4.0:\n                                        if len(rup[id_rup_j]) < 3 or len(rup[id_rup_i]) < 3:\n                                            build = False\n                                        else:\n                                            nb_i_to_remove = 3\n                                    elif len(rup[id_rup_j]) < 4 or len(rup[id_rup_i]) < 4:\n                                        build = False\n                                    else:\n                                        nb_i_to_remove = 4\n                                    if build == True and nb_i_to_remove != 0:\n                                        r = list(combinations(new_rup, nb_i_to_remove))\n                                        grp_i = 0\n                                        while build == True and grp_i < len(r):\n                                            if len(r[grp_i]) == nb_i_to_remove:\n                                                test_rup = [i for i in new_rup if not i in r[grp_i]]\n                                                if test_rup in rup:\n                                                    build = False\n                                                    if target_section == True:\n                                                        if si == look_at:\n                                                            print(id_rup_j + id_rup_i, test_rup, 'already there|nb_i_to_remove:', nb_i_to_remove)\n                                            grp_i += 1\n                            elif test_using_mag == True:\n                                nb_i = np.mean([nb_rup_per_bin[sk][index_mag] for sk in new_rup])\n                                if nb_i > 7:\n                                    nb_j = 0\n                                    for sk in new_rup:\n                                        tmp_list = np.trim_zeros(nb_rup_per_bin[sk])\n                                        p = np.percentile(tmp_list, 66)\n                                        if nb_rup_per_bin[sk][index_mag] >= p:\n                                            nb_j += 1\n                                    if nb_j >= len(new_rup) / 2.0:\n                                        build = False\n                            if build == False:\n                                not_diverse_enough += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                        if build == True:\n                            rup.append(new_rup)\n                            rup_paired.append([])\n                            rup_paired[id_rup_i].append(id_rup_j)\n                            rup_paired[id_rup_j].append(id_rup_i)\n                            l = len(rup)\n                            for sk in new_rup:\n                                f_for_sherifs[sk]['rup_id'].append(rup_id)\n                                nb_rup_per_bin[sk][index_mag] += 1\n                                if rup_length > f_for_sherifs[sk]['max_length']:\n                                    f_for_sherifs[sk]['max_length'] = rup_length\n                            rups_length.append(rup_length)\n                            rups_area.append(rup_area)\n                            rups_rake.append(rake)\n                            rups_mag.append(mag)\n                            full_fault_rup.append(False)\n                            rup_f_jump.append(rup_f_jump[id_rup_j] + rup_f_jump[id_rup_i] + [jump_i])\n                            if '000' == str(l)[-3:]:\n                                print(l, 'ruptures   |   active section :', si, ' |    not_diverse_enough :', not_diverse_enough)\n                            rup_id += 1\n            if target_section == True:\n                if si == look_at:\n                    print(si, len(f_for_sherifs[si]['rup_id']))\n        print('\\n -> Number of rup with ', loop, ' loops: ', len(rup))\n        loop += 1\n    print('\\n########\\n')\n    print('Total ruptures : ', len(rup))\n    print('The longest rupture is : ', round(max(rups_length)), ' km.')\n    print('The largest magnitude is : ', round(max(rups_mag), 1), '.')\n    print('Max number of ruptures for a section :', max([len(f_for_sherifs[i]['rup_id']) for i in range(len(f_for_sherifs))]))\n    print('Number of ruptures created for nothing because already there : ', already_created)\n    print('Number of ruptures tried for nothing because already paired : ', already_paired)\n    print('Number of ruptures not used because too many faults : ', too_many_faults)\n    print('Number of ruptures not used because too many jumps : ', too_many_jumps)\n    print('Number of ruptures not used because too many zigzag : ', too_many_zig_zag)\n    print('Number of ruptures not used because not diverse enough : ', not_diverse_enough)\n    print('Number of ruptures not used because too long : ', too_long)\n    print('Number of ruptures not used because magnitude was too large : ', too_big)\n    if target_section == True:\n        print('\\n########\\n')\n        print('ruptures for the look_at :', '    look_at id is ', look_at)\n        print('number of ruptures : ', len(f_for_sherifs[look_at]['rup_id']))\n        for i in f_for_sherifs[look_at]['rup_id']:\n            if rup.count(rup[i]) != 1:\n                print('error')\n            print(i, rup[i], round(rups_length[i]), 'km | M :', rups_mag[i])\n    duration = time.time() - t0\n    print('\\n\\nIt took ', round(duration, 3), 'seconds to find all the ruptures.')\n    return (rup, [rups_length, rups_mag])",
        "mutated": [
            "def build_scenarios(f_for_sherifs, id_sections_fault, sections_areas_tot, sections_lengths_tot, binning_in_mag, nb_rup_per_bin, section_jump):\n    if False:\n        i = 10\n    t0 = time.time()\n    max_fault_jumps = 100\n    max_fault_invo = 100\n    max_zig_zag = 2\n    nb_sections = len(f_for_sherifs)\n    rup = []\n    rup_paired = []\n    full_fault_rup = []\n    rup_f_jump = []\n    for si in range(nb_sections):\n        f_for_sherifs[si]['rup_id'] = []\n    rups_length = []\n    rups_area = []\n    rups_rake = []\n    rups_mag = []\n    target_section = False\n    if target_section == True:\n        look_at = 917\n    too_long = 0\n    too_big = 0\n    rup_id = 0\n    for si in range(len(f_for_sherifs)):\n        new_rup = [si]\n        rup.append(new_rup)\n        rup_paired.append([])\n        rup_area = sections_areas_tot[si]\n        rake = f_for_sherifs[si]['rake']\n        mag = wc1994_median_mag(rup_area, rake)\n        index_mag = np.where(binning_in_mag == round(mag, 1))[0][0]\n        for sk in new_rup:\n            f_for_sherifs[sk]['rup_id'].append(rup_id)\n            nb_rup_per_bin[sk][index_mag] += 1\n            f_for_sherifs[sk]['max_length'] = sections_lengths_tot[si]\n        rups_length.append(sections_lengths_tot[si])\n        rups_area.append(rup_area)\n        rups_rake.append(f_for_sherifs[si]['rake'])\n        rups_mag.append(mag)\n        full_fault = False\n        len_2 = len(id_sections_fault[f_for_sherifs[new_rup[0]]['oiler_id']])\n        if len_2 == len(new_rup):\n            full_fault = True\n        full_fault_rup.append(full_fault)\n        rup_f_jump.append([])\n        rup_id += 1\n    for si in range(nb_sections):\n        fi = f_for_sherifs[si]['oiler_id']\n        sec_fi = id_sections_fault[fi]\n        if len(sec_fi) > 1:\n            id_si_in_fi = sec_fi.index(si)\n            for i in range(len(sec_fi) - id_si_in_fi):\n                new_rup = sec_fi[id_si_in_fi:id_si_in_fi + i + 1]\n                new_rup = sorted(list(set(new_rup)))\n                rup_length = sum([sections_lengths_tot[sk] for sk in new_rup])\n                max_length = min([f_for_sherifs[i]['max_possible_length'] for sk in new_rup])\n                rup_area = sum([sections_areas_tot[sk] for sk in new_rup])\n                max_mmax = min([f_for_sherifs[sk]['max_possible_Mmax'] for sk in new_rup])\n                rake = sum([sections_areas_tot[sk] * f_for_sherifs[sk]['rake'] for sk in new_rup]) / rup_area\n                mag = wc1994_median_mag(rup_area, rake)\n                index_mag = np.where(binning_in_mag == round(mag, 1))[0][0]\n                if len(new_rup) > 1 and rup_length < max_length:\n                    if mag <= max_mmax:\n                        if not new_rup in rup:\n                            nb_fault_invo = len(set([f_for_sherifs[i]['oiler_id'] for sk in new_rup]))\n                            if nb_fault_invo <= max_fault_invo:\n                                rup.append(new_rup)\n                                rup_paired.append([])\n                                for sk in new_rup:\n                                    nb_rup_per_bin[sk][index_mag] += 1\n                                    f_for_sherifs[sk]['rup_id'].append(rup_id)\n                                    if rup_length > f_for_sherifs[sk]['max_length']:\n                                        f_for_sherifs[sk]['max_length'] = rup_length\n                                rups_length.append(rup_length)\n                                rups_area.append(rup_area)\n                                rups_rake.append(rake)\n                                rups_mag.append(mag)\n                                full_fault = False\n                                if nb_fault_invo == 1:\n                                    len_2 = len(id_sections_fault[f_for_sherifs[new_rup[0]]['oiler_id']])\n                                    if len_2 == len(new_rup):\n                                        full_fault = True\n                                full_fault_rup.append(full_fault)\n                                rup_f_jump.append([])\n                                rup_id += 1\n                    else:\n                        too_big += 1\n                else:\n                    too_long += 1\n    if target_section == True:\n        print('look at section :', look_at, '\\nother sections in the same fault', id_sections_fault[f_for_sherifs[look_at]['oiler_id']], '\\njumps with', section_jump[look_at], '\\nruptures', f_for_sherifs[look_at]['rup_id'])\n        print('ruptures :')\n        for rup_i in [rup[i] for i in f_for_sherifs[look_at]['rup_id']]:\n            print(rup_i)\n    print('\\nNumber of rup without jumps: ', len(rup), '\\n')\n    last_l = -1\n    loop = 1\n    already_created = 0\n    already_paired = 0\n    too_many_faults = 0\n    too_many_jumps = 0\n    too_many_zig_zag = 0\n    not_diverse_enough = 0\n    max_length = min([f_for_sherifs[sk]['max_possible_length'] for sk in range(nb_sections)])\n    while last_l != len(rup):\n        print('\\n##\\n-> Loop', loop)\n        last_l = len(rup)\n        for si in range(nb_sections):\n            sec_fi = id_sections_fault[fi]\n            jumps = section_jump[si]\n            si_rup = f_for_sherifs[si]['rup_id']\n            for sj in jumps:\n                sj_rup = f_for_sherifs[sj]['rup_id']\n                sj_rup = [i for i in sj_rup if not si in rup[i]]\n                sii_rup = [i for i in si_rup if not sj in rup[i]]\n                for id_rup_i in sii_rup:\n                    if rups_length[id_rup_i] > max_length / 2.0:\n                        sjj_rup = [j for j in sj_rup if full_fault_rup[j] == True]\n                    else:\n                        sjj_rup = [j for j in sj_rup if rups_length[j] < max_length / 2.0]\n                    for id_rup_j in sjj_rup:\n                        build = True\n                        nb_jumps = len(rup_f_jump[id_rup_j] + rup_f_jump[id_rup_i]) + 1\n                        if nb_jumps <= max_fault_jumps:\n                            build = True\n                        else:\n                            build = False\n                            too_many_jumps += 1\n                        if build == True:\n                            jump_i = sorted([f_for_sherifs[si]['oiler_id'], f_for_sherifs[sj]['oiler_id']])\n                            nb_zig_zag = rup_f_jump[id_rup_j].count(jump_i) + rup_f_jump[id_rup_i].count(jump_i)\n                            if not nb_zig_zag > max_zig_zag:\n                                build = True\n                            else:\n                                build = False\n                                too_many_zig_zag += 1\n                        if build == True:\n                            if id_rup_j in rup_paired[id_rup_i]:\n                                build = False\n                                already_paired += 1\n                        if build == True:\n                            if id_rup_i in rup_paired[id_rup_j]:\n                                build = False\n                                already_paired += 1\n                        if build == True:\n                            new_rup = rup[id_rup_i] + rup[id_rup_j]\n                            new_rup = sorted(list(set(new_rup)))\n                            rup_length = rups_length[id_rup_i] + rups_length[id_rup_j]\n                            max_length = min([f_for_sherifs[sk]['max_possible_length'] for sk in new_rup])\n                            rup_area = rups_area[id_rup_i] + rups_area[id_rup_j]\n                            max_mmax = min([f_for_sherifs[sk]['max_possible_Mmax'] for sk in new_rup])\n                            rake = (rups_rake[id_rup_i] * rups_area[id_rup_i] + rups_rake[id_rup_j] * rups_area[id_rup_j]) / rup_area\n                            mag = wc1994_median_mag(rup_area, rake)\n                            index_mag = np.where(binning_in_mag == round(mag, 1))[0][0]\n                            if rup_length > max_length:\n                                build = False\n                                too_long += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                            if build == True and mag > max_mmax:\n                                build = False\n                                too_big += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                        if build == True:\n                            if not new_rup in rup:\n                                build = True\n                                nb_fault_invo = len(set([f_for_sherifs[i]['oiler_id'] for i in new_rup]))\n                            else:\n                                build = False\n                                already_created += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                        if build == True:\n                            if nb_fault_invo <= max_fault_invo:\n                                build = True\n                            else:\n                                build = False\n                                too_many_faults += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                        if build == True:\n                            test_using_length = False\n                            test_using_mag = True\n                            if test_using_length == True:\n                                nb_rup_sec = [len(f_for_sherifs[i]['rup_id']) for i in new_rup]\n                                max_nb_rup_i = max(nb_rup_sec)\n                                mean_nb_rup = len(rup) / nb_sections\n                                min_max_length_i = min([f_for_sherifs[i]['max_length'] for i in new_rup])\n                                mean_max_length_i = np.mean([f_for_sherifs[i]['max_length'] for i in new_rup])\n                                hogger = False\n                                if max_nb_rup_i > 40 and rup_length < mean_max_length_i * 1.5:\n                                    hogger = True\n                                if hogger == True:\n                                    nb_i_to_remove = 0\n                                    if rup_length < min_max_length_i / 2.0:\n                                        if len(rup[id_rup_j]) < 2 or len(rup[id_rup_i]) < 2:\n                                            build = False\n                                        else:\n                                            nb_i_to_remove = 2\n                                    elif rup_length < min_max_length_i * 3.0 / 4.0:\n                                        if len(rup[id_rup_j]) < 3 or len(rup[id_rup_i]) < 3:\n                                            build = False\n                                        else:\n                                            nb_i_to_remove = 3\n                                    elif len(rup[id_rup_j]) < 4 or len(rup[id_rup_i]) < 4:\n                                        build = False\n                                    else:\n                                        nb_i_to_remove = 4\n                                    if build == True and nb_i_to_remove != 0:\n                                        r = list(combinations(new_rup, nb_i_to_remove))\n                                        grp_i = 0\n                                        while build == True and grp_i < len(r):\n                                            if len(r[grp_i]) == nb_i_to_remove:\n                                                test_rup = [i for i in new_rup if not i in r[grp_i]]\n                                                if test_rup in rup:\n                                                    build = False\n                                                    if target_section == True:\n                                                        if si == look_at:\n                                                            print(id_rup_j + id_rup_i, test_rup, 'already there|nb_i_to_remove:', nb_i_to_remove)\n                                            grp_i += 1\n                            elif test_using_mag == True:\n                                nb_i = np.mean([nb_rup_per_bin[sk][index_mag] for sk in new_rup])\n                                if nb_i > 7:\n                                    nb_j = 0\n                                    for sk in new_rup:\n                                        tmp_list = np.trim_zeros(nb_rup_per_bin[sk])\n                                        p = np.percentile(tmp_list, 66)\n                                        if nb_rup_per_bin[sk][index_mag] >= p:\n                                            nb_j += 1\n                                    if nb_j >= len(new_rup) / 2.0:\n                                        build = False\n                            if build == False:\n                                not_diverse_enough += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                        if build == True:\n                            rup.append(new_rup)\n                            rup_paired.append([])\n                            rup_paired[id_rup_i].append(id_rup_j)\n                            rup_paired[id_rup_j].append(id_rup_i)\n                            l = len(rup)\n                            for sk in new_rup:\n                                f_for_sherifs[sk]['rup_id'].append(rup_id)\n                                nb_rup_per_bin[sk][index_mag] += 1\n                                if rup_length > f_for_sherifs[sk]['max_length']:\n                                    f_for_sherifs[sk]['max_length'] = rup_length\n                            rups_length.append(rup_length)\n                            rups_area.append(rup_area)\n                            rups_rake.append(rake)\n                            rups_mag.append(mag)\n                            full_fault_rup.append(False)\n                            rup_f_jump.append(rup_f_jump[id_rup_j] + rup_f_jump[id_rup_i] + [jump_i])\n                            if '000' == str(l)[-3:]:\n                                print(l, 'ruptures   |   active section :', si, ' |    not_diverse_enough :', not_diverse_enough)\n                            rup_id += 1\n            if target_section == True:\n                if si == look_at:\n                    print(si, len(f_for_sherifs[si]['rup_id']))\n        print('\\n -> Number of rup with ', loop, ' loops: ', len(rup))\n        loop += 1\n    print('\\n########\\n')\n    print('Total ruptures : ', len(rup))\n    print('The longest rupture is : ', round(max(rups_length)), ' km.')\n    print('The largest magnitude is : ', round(max(rups_mag), 1), '.')\n    print('Max number of ruptures for a section :', max([len(f_for_sherifs[i]['rup_id']) for i in range(len(f_for_sherifs))]))\n    print('Number of ruptures created for nothing because already there : ', already_created)\n    print('Number of ruptures tried for nothing because already paired : ', already_paired)\n    print('Number of ruptures not used because too many faults : ', too_many_faults)\n    print('Number of ruptures not used because too many jumps : ', too_many_jumps)\n    print('Number of ruptures not used because too many zigzag : ', too_many_zig_zag)\n    print('Number of ruptures not used because not diverse enough : ', not_diverse_enough)\n    print('Number of ruptures not used because too long : ', too_long)\n    print('Number of ruptures not used because magnitude was too large : ', too_big)\n    if target_section == True:\n        print('\\n########\\n')\n        print('ruptures for the look_at :', '    look_at id is ', look_at)\n        print('number of ruptures : ', len(f_for_sherifs[look_at]['rup_id']))\n        for i in f_for_sherifs[look_at]['rup_id']:\n            if rup.count(rup[i]) != 1:\n                print('error')\n            print(i, rup[i], round(rups_length[i]), 'km | M :', rups_mag[i])\n    duration = time.time() - t0\n    print('\\n\\nIt took ', round(duration, 3), 'seconds to find all the ruptures.')\n    return (rup, [rups_length, rups_mag])",
            "def build_scenarios(f_for_sherifs, id_sections_fault, sections_areas_tot, sections_lengths_tot, binning_in_mag, nb_rup_per_bin, section_jump):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    t0 = time.time()\n    max_fault_jumps = 100\n    max_fault_invo = 100\n    max_zig_zag = 2\n    nb_sections = len(f_for_sherifs)\n    rup = []\n    rup_paired = []\n    full_fault_rup = []\n    rup_f_jump = []\n    for si in range(nb_sections):\n        f_for_sherifs[si]['rup_id'] = []\n    rups_length = []\n    rups_area = []\n    rups_rake = []\n    rups_mag = []\n    target_section = False\n    if target_section == True:\n        look_at = 917\n    too_long = 0\n    too_big = 0\n    rup_id = 0\n    for si in range(len(f_for_sherifs)):\n        new_rup = [si]\n        rup.append(new_rup)\n        rup_paired.append([])\n        rup_area = sections_areas_tot[si]\n        rake = f_for_sherifs[si]['rake']\n        mag = wc1994_median_mag(rup_area, rake)\n        index_mag = np.where(binning_in_mag == round(mag, 1))[0][0]\n        for sk in new_rup:\n            f_for_sherifs[sk]['rup_id'].append(rup_id)\n            nb_rup_per_bin[sk][index_mag] += 1\n            f_for_sherifs[sk]['max_length'] = sections_lengths_tot[si]\n        rups_length.append(sections_lengths_tot[si])\n        rups_area.append(rup_area)\n        rups_rake.append(f_for_sherifs[si]['rake'])\n        rups_mag.append(mag)\n        full_fault = False\n        len_2 = len(id_sections_fault[f_for_sherifs[new_rup[0]]['oiler_id']])\n        if len_2 == len(new_rup):\n            full_fault = True\n        full_fault_rup.append(full_fault)\n        rup_f_jump.append([])\n        rup_id += 1\n    for si in range(nb_sections):\n        fi = f_for_sherifs[si]['oiler_id']\n        sec_fi = id_sections_fault[fi]\n        if len(sec_fi) > 1:\n            id_si_in_fi = sec_fi.index(si)\n            for i in range(len(sec_fi) - id_si_in_fi):\n                new_rup = sec_fi[id_si_in_fi:id_si_in_fi + i + 1]\n                new_rup = sorted(list(set(new_rup)))\n                rup_length = sum([sections_lengths_tot[sk] for sk in new_rup])\n                max_length = min([f_for_sherifs[i]['max_possible_length'] for sk in new_rup])\n                rup_area = sum([sections_areas_tot[sk] for sk in new_rup])\n                max_mmax = min([f_for_sherifs[sk]['max_possible_Mmax'] for sk in new_rup])\n                rake = sum([sections_areas_tot[sk] * f_for_sherifs[sk]['rake'] for sk in new_rup]) / rup_area\n                mag = wc1994_median_mag(rup_area, rake)\n                index_mag = np.where(binning_in_mag == round(mag, 1))[0][0]\n                if len(new_rup) > 1 and rup_length < max_length:\n                    if mag <= max_mmax:\n                        if not new_rup in rup:\n                            nb_fault_invo = len(set([f_for_sherifs[i]['oiler_id'] for sk in new_rup]))\n                            if nb_fault_invo <= max_fault_invo:\n                                rup.append(new_rup)\n                                rup_paired.append([])\n                                for sk in new_rup:\n                                    nb_rup_per_bin[sk][index_mag] += 1\n                                    f_for_sherifs[sk]['rup_id'].append(rup_id)\n                                    if rup_length > f_for_sherifs[sk]['max_length']:\n                                        f_for_sherifs[sk]['max_length'] = rup_length\n                                rups_length.append(rup_length)\n                                rups_area.append(rup_area)\n                                rups_rake.append(rake)\n                                rups_mag.append(mag)\n                                full_fault = False\n                                if nb_fault_invo == 1:\n                                    len_2 = len(id_sections_fault[f_for_sherifs[new_rup[0]]['oiler_id']])\n                                    if len_2 == len(new_rup):\n                                        full_fault = True\n                                full_fault_rup.append(full_fault)\n                                rup_f_jump.append([])\n                                rup_id += 1\n                    else:\n                        too_big += 1\n                else:\n                    too_long += 1\n    if target_section == True:\n        print('look at section :', look_at, '\\nother sections in the same fault', id_sections_fault[f_for_sherifs[look_at]['oiler_id']], '\\njumps with', section_jump[look_at], '\\nruptures', f_for_sherifs[look_at]['rup_id'])\n        print('ruptures :')\n        for rup_i in [rup[i] for i in f_for_sherifs[look_at]['rup_id']]:\n            print(rup_i)\n    print('\\nNumber of rup without jumps: ', len(rup), '\\n')\n    last_l = -1\n    loop = 1\n    already_created = 0\n    already_paired = 0\n    too_many_faults = 0\n    too_many_jumps = 0\n    too_many_zig_zag = 0\n    not_diverse_enough = 0\n    max_length = min([f_for_sherifs[sk]['max_possible_length'] for sk in range(nb_sections)])\n    while last_l != len(rup):\n        print('\\n##\\n-> Loop', loop)\n        last_l = len(rup)\n        for si in range(nb_sections):\n            sec_fi = id_sections_fault[fi]\n            jumps = section_jump[si]\n            si_rup = f_for_sherifs[si]['rup_id']\n            for sj in jumps:\n                sj_rup = f_for_sherifs[sj]['rup_id']\n                sj_rup = [i for i in sj_rup if not si in rup[i]]\n                sii_rup = [i for i in si_rup if not sj in rup[i]]\n                for id_rup_i in sii_rup:\n                    if rups_length[id_rup_i] > max_length / 2.0:\n                        sjj_rup = [j for j in sj_rup if full_fault_rup[j] == True]\n                    else:\n                        sjj_rup = [j for j in sj_rup if rups_length[j] < max_length / 2.0]\n                    for id_rup_j in sjj_rup:\n                        build = True\n                        nb_jumps = len(rup_f_jump[id_rup_j] + rup_f_jump[id_rup_i]) + 1\n                        if nb_jumps <= max_fault_jumps:\n                            build = True\n                        else:\n                            build = False\n                            too_many_jumps += 1\n                        if build == True:\n                            jump_i = sorted([f_for_sherifs[si]['oiler_id'], f_for_sherifs[sj]['oiler_id']])\n                            nb_zig_zag = rup_f_jump[id_rup_j].count(jump_i) + rup_f_jump[id_rup_i].count(jump_i)\n                            if not nb_zig_zag > max_zig_zag:\n                                build = True\n                            else:\n                                build = False\n                                too_many_zig_zag += 1\n                        if build == True:\n                            if id_rup_j in rup_paired[id_rup_i]:\n                                build = False\n                                already_paired += 1\n                        if build == True:\n                            if id_rup_i in rup_paired[id_rup_j]:\n                                build = False\n                                already_paired += 1\n                        if build == True:\n                            new_rup = rup[id_rup_i] + rup[id_rup_j]\n                            new_rup = sorted(list(set(new_rup)))\n                            rup_length = rups_length[id_rup_i] + rups_length[id_rup_j]\n                            max_length = min([f_for_sherifs[sk]['max_possible_length'] for sk in new_rup])\n                            rup_area = rups_area[id_rup_i] + rups_area[id_rup_j]\n                            max_mmax = min([f_for_sherifs[sk]['max_possible_Mmax'] for sk in new_rup])\n                            rake = (rups_rake[id_rup_i] * rups_area[id_rup_i] + rups_rake[id_rup_j] * rups_area[id_rup_j]) / rup_area\n                            mag = wc1994_median_mag(rup_area, rake)\n                            index_mag = np.where(binning_in_mag == round(mag, 1))[0][0]\n                            if rup_length > max_length:\n                                build = False\n                                too_long += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                            if build == True and mag > max_mmax:\n                                build = False\n                                too_big += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                        if build == True:\n                            if not new_rup in rup:\n                                build = True\n                                nb_fault_invo = len(set([f_for_sherifs[i]['oiler_id'] for i in new_rup]))\n                            else:\n                                build = False\n                                already_created += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                        if build == True:\n                            if nb_fault_invo <= max_fault_invo:\n                                build = True\n                            else:\n                                build = False\n                                too_many_faults += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                        if build == True:\n                            test_using_length = False\n                            test_using_mag = True\n                            if test_using_length == True:\n                                nb_rup_sec = [len(f_for_sherifs[i]['rup_id']) for i in new_rup]\n                                max_nb_rup_i = max(nb_rup_sec)\n                                mean_nb_rup = len(rup) / nb_sections\n                                min_max_length_i = min([f_for_sherifs[i]['max_length'] for i in new_rup])\n                                mean_max_length_i = np.mean([f_for_sherifs[i]['max_length'] for i in new_rup])\n                                hogger = False\n                                if max_nb_rup_i > 40 and rup_length < mean_max_length_i * 1.5:\n                                    hogger = True\n                                if hogger == True:\n                                    nb_i_to_remove = 0\n                                    if rup_length < min_max_length_i / 2.0:\n                                        if len(rup[id_rup_j]) < 2 or len(rup[id_rup_i]) < 2:\n                                            build = False\n                                        else:\n                                            nb_i_to_remove = 2\n                                    elif rup_length < min_max_length_i * 3.0 / 4.0:\n                                        if len(rup[id_rup_j]) < 3 or len(rup[id_rup_i]) < 3:\n                                            build = False\n                                        else:\n                                            nb_i_to_remove = 3\n                                    elif len(rup[id_rup_j]) < 4 or len(rup[id_rup_i]) < 4:\n                                        build = False\n                                    else:\n                                        nb_i_to_remove = 4\n                                    if build == True and nb_i_to_remove != 0:\n                                        r = list(combinations(new_rup, nb_i_to_remove))\n                                        grp_i = 0\n                                        while build == True and grp_i < len(r):\n                                            if len(r[grp_i]) == nb_i_to_remove:\n                                                test_rup = [i for i in new_rup if not i in r[grp_i]]\n                                                if test_rup in rup:\n                                                    build = False\n                                                    if target_section == True:\n                                                        if si == look_at:\n                                                            print(id_rup_j + id_rup_i, test_rup, 'already there|nb_i_to_remove:', nb_i_to_remove)\n                                            grp_i += 1\n                            elif test_using_mag == True:\n                                nb_i = np.mean([nb_rup_per_bin[sk][index_mag] for sk in new_rup])\n                                if nb_i > 7:\n                                    nb_j = 0\n                                    for sk in new_rup:\n                                        tmp_list = np.trim_zeros(nb_rup_per_bin[sk])\n                                        p = np.percentile(tmp_list, 66)\n                                        if nb_rup_per_bin[sk][index_mag] >= p:\n                                            nb_j += 1\n                                    if nb_j >= len(new_rup) / 2.0:\n                                        build = False\n                            if build == False:\n                                not_diverse_enough += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                        if build == True:\n                            rup.append(new_rup)\n                            rup_paired.append([])\n                            rup_paired[id_rup_i].append(id_rup_j)\n                            rup_paired[id_rup_j].append(id_rup_i)\n                            l = len(rup)\n                            for sk in new_rup:\n                                f_for_sherifs[sk]['rup_id'].append(rup_id)\n                                nb_rup_per_bin[sk][index_mag] += 1\n                                if rup_length > f_for_sherifs[sk]['max_length']:\n                                    f_for_sherifs[sk]['max_length'] = rup_length\n                            rups_length.append(rup_length)\n                            rups_area.append(rup_area)\n                            rups_rake.append(rake)\n                            rups_mag.append(mag)\n                            full_fault_rup.append(False)\n                            rup_f_jump.append(rup_f_jump[id_rup_j] + rup_f_jump[id_rup_i] + [jump_i])\n                            if '000' == str(l)[-3:]:\n                                print(l, 'ruptures   |   active section :', si, ' |    not_diverse_enough :', not_diverse_enough)\n                            rup_id += 1\n            if target_section == True:\n                if si == look_at:\n                    print(si, len(f_for_sherifs[si]['rup_id']))\n        print('\\n -> Number of rup with ', loop, ' loops: ', len(rup))\n        loop += 1\n    print('\\n########\\n')\n    print('Total ruptures : ', len(rup))\n    print('The longest rupture is : ', round(max(rups_length)), ' km.')\n    print('The largest magnitude is : ', round(max(rups_mag), 1), '.')\n    print('Max number of ruptures for a section :', max([len(f_for_sherifs[i]['rup_id']) for i in range(len(f_for_sherifs))]))\n    print('Number of ruptures created for nothing because already there : ', already_created)\n    print('Number of ruptures tried for nothing because already paired : ', already_paired)\n    print('Number of ruptures not used because too many faults : ', too_many_faults)\n    print('Number of ruptures not used because too many jumps : ', too_many_jumps)\n    print('Number of ruptures not used because too many zigzag : ', too_many_zig_zag)\n    print('Number of ruptures not used because not diverse enough : ', not_diverse_enough)\n    print('Number of ruptures not used because too long : ', too_long)\n    print('Number of ruptures not used because magnitude was too large : ', too_big)\n    if target_section == True:\n        print('\\n########\\n')\n        print('ruptures for the look_at :', '    look_at id is ', look_at)\n        print('number of ruptures : ', len(f_for_sherifs[look_at]['rup_id']))\n        for i in f_for_sherifs[look_at]['rup_id']:\n            if rup.count(rup[i]) != 1:\n                print('error')\n            print(i, rup[i], round(rups_length[i]), 'km | M :', rups_mag[i])\n    duration = time.time() - t0\n    print('\\n\\nIt took ', round(duration, 3), 'seconds to find all the ruptures.')\n    return (rup, [rups_length, rups_mag])",
            "def build_scenarios(f_for_sherifs, id_sections_fault, sections_areas_tot, sections_lengths_tot, binning_in_mag, nb_rup_per_bin, section_jump):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    t0 = time.time()\n    max_fault_jumps = 100\n    max_fault_invo = 100\n    max_zig_zag = 2\n    nb_sections = len(f_for_sherifs)\n    rup = []\n    rup_paired = []\n    full_fault_rup = []\n    rup_f_jump = []\n    for si in range(nb_sections):\n        f_for_sherifs[si]['rup_id'] = []\n    rups_length = []\n    rups_area = []\n    rups_rake = []\n    rups_mag = []\n    target_section = False\n    if target_section == True:\n        look_at = 917\n    too_long = 0\n    too_big = 0\n    rup_id = 0\n    for si in range(len(f_for_sherifs)):\n        new_rup = [si]\n        rup.append(new_rup)\n        rup_paired.append([])\n        rup_area = sections_areas_tot[si]\n        rake = f_for_sherifs[si]['rake']\n        mag = wc1994_median_mag(rup_area, rake)\n        index_mag = np.where(binning_in_mag == round(mag, 1))[0][0]\n        for sk in new_rup:\n            f_for_sherifs[sk]['rup_id'].append(rup_id)\n            nb_rup_per_bin[sk][index_mag] += 1\n            f_for_sherifs[sk]['max_length'] = sections_lengths_tot[si]\n        rups_length.append(sections_lengths_tot[si])\n        rups_area.append(rup_area)\n        rups_rake.append(f_for_sherifs[si]['rake'])\n        rups_mag.append(mag)\n        full_fault = False\n        len_2 = len(id_sections_fault[f_for_sherifs[new_rup[0]]['oiler_id']])\n        if len_2 == len(new_rup):\n            full_fault = True\n        full_fault_rup.append(full_fault)\n        rup_f_jump.append([])\n        rup_id += 1\n    for si in range(nb_sections):\n        fi = f_for_sherifs[si]['oiler_id']\n        sec_fi = id_sections_fault[fi]\n        if len(sec_fi) > 1:\n            id_si_in_fi = sec_fi.index(si)\n            for i in range(len(sec_fi) - id_si_in_fi):\n                new_rup = sec_fi[id_si_in_fi:id_si_in_fi + i + 1]\n                new_rup = sorted(list(set(new_rup)))\n                rup_length = sum([sections_lengths_tot[sk] for sk in new_rup])\n                max_length = min([f_for_sherifs[i]['max_possible_length'] for sk in new_rup])\n                rup_area = sum([sections_areas_tot[sk] for sk in new_rup])\n                max_mmax = min([f_for_sherifs[sk]['max_possible_Mmax'] for sk in new_rup])\n                rake = sum([sections_areas_tot[sk] * f_for_sherifs[sk]['rake'] for sk in new_rup]) / rup_area\n                mag = wc1994_median_mag(rup_area, rake)\n                index_mag = np.where(binning_in_mag == round(mag, 1))[0][0]\n                if len(new_rup) > 1 and rup_length < max_length:\n                    if mag <= max_mmax:\n                        if not new_rup in rup:\n                            nb_fault_invo = len(set([f_for_sherifs[i]['oiler_id'] for sk in new_rup]))\n                            if nb_fault_invo <= max_fault_invo:\n                                rup.append(new_rup)\n                                rup_paired.append([])\n                                for sk in new_rup:\n                                    nb_rup_per_bin[sk][index_mag] += 1\n                                    f_for_sherifs[sk]['rup_id'].append(rup_id)\n                                    if rup_length > f_for_sherifs[sk]['max_length']:\n                                        f_for_sherifs[sk]['max_length'] = rup_length\n                                rups_length.append(rup_length)\n                                rups_area.append(rup_area)\n                                rups_rake.append(rake)\n                                rups_mag.append(mag)\n                                full_fault = False\n                                if nb_fault_invo == 1:\n                                    len_2 = len(id_sections_fault[f_for_sherifs[new_rup[0]]['oiler_id']])\n                                    if len_2 == len(new_rup):\n                                        full_fault = True\n                                full_fault_rup.append(full_fault)\n                                rup_f_jump.append([])\n                                rup_id += 1\n                    else:\n                        too_big += 1\n                else:\n                    too_long += 1\n    if target_section == True:\n        print('look at section :', look_at, '\\nother sections in the same fault', id_sections_fault[f_for_sherifs[look_at]['oiler_id']], '\\njumps with', section_jump[look_at], '\\nruptures', f_for_sherifs[look_at]['rup_id'])\n        print('ruptures :')\n        for rup_i in [rup[i] for i in f_for_sherifs[look_at]['rup_id']]:\n            print(rup_i)\n    print('\\nNumber of rup without jumps: ', len(rup), '\\n')\n    last_l = -1\n    loop = 1\n    already_created = 0\n    already_paired = 0\n    too_many_faults = 0\n    too_many_jumps = 0\n    too_many_zig_zag = 0\n    not_diverse_enough = 0\n    max_length = min([f_for_sherifs[sk]['max_possible_length'] for sk in range(nb_sections)])\n    while last_l != len(rup):\n        print('\\n##\\n-> Loop', loop)\n        last_l = len(rup)\n        for si in range(nb_sections):\n            sec_fi = id_sections_fault[fi]\n            jumps = section_jump[si]\n            si_rup = f_for_sherifs[si]['rup_id']\n            for sj in jumps:\n                sj_rup = f_for_sherifs[sj]['rup_id']\n                sj_rup = [i for i in sj_rup if not si in rup[i]]\n                sii_rup = [i for i in si_rup if not sj in rup[i]]\n                for id_rup_i in sii_rup:\n                    if rups_length[id_rup_i] > max_length / 2.0:\n                        sjj_rup = [j for j in sj_rup if full_fault_rup[j] == True]\n                    else:\n                        sjj_rup = [j for j in sj_rup if rups_length[j] < max_length / 2.0]\n                    for id_rup_j in sjj_rup:\n                        build = True\n                        nb_jumps = len(rup_f_jump[id_rup_j] + rup_f_jump[id_rup_i]) + 1\n                        if nb_jumps <= max_fault_jumps:\n                            build = True\n                        else:\n                            build = False\n                            too_many_jumps += 1\n                        if build == True:\n                            jump_i = sorted([f_for_sherifs[si]['oiler_id'], f_for_sherifs[sj]['oiler_id']])\n                            nb_zig_zag = rup_f_jump[id_rup_j].count(jump_i) + rup_f_jump[id_rup_i].count(jump_i)\n                            if not nb_zig_zag > max_zig_zag:\n                                build = True\n                            else:\n                                build = False\n                                too_many_zig_zag += 1\n                        if build == True:\n                            if id_rup_j in rup_paired[id_rup_i]:\n                                build = False\n                                already_paired += 1\n                        if build == True:\n                            if id_rup_i in rup_paired[id_rup_j]:\n                                build = False\n                                already_paired += 1\n                        if build == True:\n                            new_rup = rup[id_rup_i] + rup[id_rup_j]\n                            new_rup = sorted(list(set(new_rup)))\n                            rup_length = rups_length[id_rup_i] + rups_length[id_rup_j]\n                            max_length = min([f_for_sherifs[sk]['max_possible_length'] for sk in new_rup])\n                            rup_area = rups_area[id_rup_i] + rups_area[id_rup_j]\n                            max_mmax = min([f_for_sherifs[sk]['max_possible_Mmax'] for sk in new_rup])\n                            rake = (rups_rake[id_rup_i] * rups_area[id_rup_i] + rups_rake[id_rup_j] * rups_area[id_rup_j]) / rup_area\n                            mag = wc1994_median_mag(rup_area, rake)\n                            index_mag = np.where(binning_in_mag == round(mag, 1))[0][0]\n                            if rup_length > max_length:\n                                build = False\n                                too_long += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                            if build == True and mag > max_mmax:\n                                build = False\n                                too_big += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                        if build == True:\n                            if not new_rup in rup:\n                                build = True\n                                nb_fault_invo = len(set([f_for_sherifs[i]['oiler_id'] for i in new_rup]))\n                            else:\n                                build = False\n                                already_created += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                        if build == True:\n                            if nb_fault_invo <= max_fault_invo:\n                                build = True\n                            else:\n                                build = False\n                                too_many_faults += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                        if build == True:\n                            test_using_length = False\n                            test_using_mag = True\n                            if test_using_length == True:\n                                nb_rup_sec = [len(f_for_sherifs[i]['rup_id']) for i in new_rup]\n                                max_nb_rup_i = max(nb_rup_sec)\n                                mean_nb_rup = len(rup) / nb_sections\n                                min_max_length_i = min([f_for_sherifs[i]['max_length'] for i in new_rup])\n                                mean_max_length_i = np.mean([f_for_sherifs[i]['max_length'] for i in new_rup])\n                                hogger = False\n                                if max_nb_rup_i > 40 and rup_length < mean_max_length_i * 1.5:\n                                    hogger = True\n                                if hogger == True:\n                                    nb_i_to_remove = 0\n                                    if rup_length < min_max_length_i / 2.0:\n                                        if len(rup[id_rup_j]) < 2 or len(rup[id_rup_i]) < 2:\n                                            build = False\n                                        else:\n                                            nb_i_to_remove = 2\n                                    elif rup_length < min_max_length_i * 3.0 / 4.0:\n                                        if len(rup[id_rup_j]) < 3 or len(rup[id_rup_i]) < 3:\n                                            build = False\n                                        else:\n                                            nb_i_to_remove = 3\n                                    elif len(rup[id_rup_j]) < 4 or len(rup[id_rup_i]) < 4:\n                                        build = False\n                                    else:\n                                        nb_i_to_remove = 4\n                                    if build == True and nb_i_to_remove != 0:\n                                        r = list(combinations(new_rup, nb_i_to_remove))\n                                        grp_i = 0\n                                        while build == True and grp_i < len(r):\n                                            if len(r[grp_i]) == nb_i_to_remove:\n                                                test_rup = [i for i in new_rup if not i in r[grp_i]]\n                                                if test_rup in rup:\n                                                    build = False\n                                                    if target_section == True:\n                                                        if si == look_at:\n                                                            print(id_rup_j + id_rup_i, test_rup, 'already there|nb_i_to_remove:', nb_i_to_remove)\n                                            grp_i += 1\n                            elif test_using_mag == True:\n                                nb_i = np.mean([nb_rup_per_bin[sk][index_mag] for sk in new_rup])\n                                if nb_i > 7:\n                                    nb_j = 0\n                                    for sk in new_rup:\n                                        tmp_list = np.trim_zeros(nb_rup_per_bin[sk])\n                                        p = np.percentile(tmp_list, 66)\n                                        if nb_rup_per_bin[sk][index_mag] >= p:\n                                            nb_j += 1\n                                    if nb_j >= len(new_rup) / 2.0:\n                                        build = False\n                            if build == False:\n                                not_diverse_enough += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                        if build == True:\n                            rup.append(new_rup)\n                            rup_paired.append([])\n                            rup_paired[id_rup_i].append(id_rup_j)\n                            rup_paired[id_rup_j].append(id_rup_i)\n                            l = len(rup)\n                            for sk in new_rup:\n                                f_for_sherifs[sk]['rup_id'].append(rup_id)\n                                nb_rup_per_bin[sk][index_mag] += 1\n                                if rup_length > f_for_sherifs[sk]['max_length']:\n                                    f_for_sherifs[sk]['max_length'] = rup_length\n                            rups_length.append(rup_length)\n                            rups_area.append(rup_area)\n                            rups_rake.append(rake)\n                            rups_mag.append(mag)\n                            full_fault_rup.append(False)\n                            rup_f_jump.append(rup_f_jump[id_rup_j] + rup_f_jump[id_rup_i] + [jump_i])\n                            if '000' == str(l)[-3:]:\n                                print(l, 'ruptures   |   active section :', si, ' |    not_diverse_enough :', not_diverse_enough)\n                            rup_id += 1\n            if target_section == True:\n                if si == look_at:\n                    print(si, len(f_for_sherifs[si]['rup_id']))\n        print('\\n -> Number of rup with ', loop, ' loops: ', len(rup))\n        loop += 1\n    print('\\n########\\n')\n    print('Total ruptures : ', len(rup))\n    print('The longest rupture is : ', round(max(rups_length)), ' km.')\n    print('The largest magnitude is : ', round(max(rups_mag), 1), '.')\n    print('Max number of ruptures for a section :', max([len(f_for_sherifs[i]['rup_id']) for i in range(len(f_for_sherifs))]))\n    print('Number of ruptures created for nothing because already there : ', already_created)\n    print('Number of ruptures tried for nothing because already paired : ', already_paired)\n    print('Number of ruptures not used because too many faults : ', too_many_faults)\n    print('Number of ruptures not used because too many jumps : ', too_many_jumps)\n    print('Number of ruptures not used because too many zigzag : ', too_many_zig_zag)\n    print('Number of ruptures not used because not diverse enough : ', not_diverse_enough)\n    print('Number of ruptures not used because too long : ', too_long)\n    print('Number of ruptures not used because magnitude was too large : ', too_big)\n    if target_section == True:\n        print('\\n########\\n')\n        print('ruptures for the look_at :', '    look_at id is ', look_at)\n        print('number of ruptures : ', len(f_for_sherifs[look_at]['rup_id']))\n        for i in f_for_sherifs[look_at]['rup_id']:\n            if rup.count(rup[i]) != 1:\n                print('error')\n            print(i, rup[i], round(rups_length[i]), 'km | M :', rups_mag[i])\n    duration = time.time() - t0\n    print('\\n\\nIt took ', round(duration, 3), 'seconds to find all the ruptures.')\n    return (rup, [rups_length, rups_mag])",
            "def build_scenarios(f_for_sherifs, id_sections_fault, sections_areas_tot, sections_lengths_tot, binning_in_mag, nb_rup_per_bin, section_jump):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    t0 = time.time()\n    max_fault_jumps = 100\n    max_fault_invo = 100\n    max_zig_zag = 2\n    nb_sections = len(f_for_sherifs)\n    rup = []\n    rup_paired = []\n    full_fault_rup = []\n    rup_f_jump = []\n    for si in range(nb_sections):\n        f_for_sherifs[si]['rup_id'] = []\n    rups_length = []\n    rups_area = []\n    rups_rake = []\n    rups_mag = []\n    target_section = False\n    if target_section == True:\n        look_at = 917\n    too_long = 0\n    too_big = 0\n    rup_id = 0\n    for si in range(len(f_for_sherifs)):\n        new_rup = [si]\n        rup.append(new_rup)\n        rup_paired.append([])\n        rup_area = sections_areas_tot[si]\n        rake = f_for_sherifs[si]['rake']\n        mag = wc1994_median_mag(rup_area, rake)\n        index_mag = np.where(binning_in_mag == round(mag, 1))[0][0]\n        for sk in new_rup:\n            f_for_sherifs[sk]['rup_id'].append(rup_id)\n            nb_rup_per_bin[sk][index_mag] += 1\n            f_for_sherifs[sk]['max_length'] = sections_lengths_tot[si]\n        rups_length.append(sections_lengths_tot[si])\n        rups_area.append(rup_area)\n        rups_rake.append(f_for_sherifs[si]['rake'])\n        rups_mag.append(mag)\n        full_fault = False\n        len_2 = len(id_sections_fault[f_for_sherifs[new_rup[0]]['oiler_id']])\n        if len_2 == len(new_rup):\n            full_fault = True\n        full_fault_rup.append(full_fault)\n        rup_f_jump.append([])\n        rup_id += 1\n    for si in range(nb_sections):\n        fi = f_for_sherifs[si]['oiler_id']\n        sec_fi = id_sections_fault[fi]\n        if len(sec_fi) > 1:\n            id_si_in_fi = sec_fi.index(si)\n            for i in range(len(sec_fi) - id_si_in_fi):\n                new_rup = sec_fi[id_si_in_fi:id_si_in_fi + i + 1]\n                new_rup = sorted(list(set(new_rup)))\n                rup_length = sum([sections_lengths_tot[sk] for sk in new_rup])\n                max_length = min([f_for_sherifs[i]['max_possible_length'] for sk in new_rup])\n                rup_area = sum([sections_areas_tot[sk] for sk in new_rup])\n                max_mmax = min([f_for_sherifs[sk]['max_possible_Mmax'] for sk in new_rup])\n                rake = sum([sections_areas_tot[sk] * f_for_sherifs[sk]['rake'] for sk in new_rup]) / rup_area\n                mag = wc1994_median_mag(rup_area, rake)\n                index_mag = np.where(binning_in_mag == round(mag, 1))[0][0]\n                if len(new_rup) > 1 and rup_length < max_length:\n                    if mag <= max_mmax:\n                        if not new_rup in rup:\n                            nb_fault_invo = len(set([f_for_sherifs[i]['oiler_id'] for sk in new_rup]))\n                            if nb_fault_invo <= max_fault_invo:\n                                rup.append(new_rup)\n                                rup_paired.append([])\n                                for sk in new_rup:\n                                    nb_rup_per_bin[sk][index_mag] += 1\n                                    f_for_sherifs[sk]['rup_id'].append(rup_id)\n                                    if rup_length > f_for_sherifs[sk]['max_length']:\n                                        f_for_sherifs[sk]['max_length'] = rup_length\n                                rups_length.append(rup_length)\n                                rups_area.append(rup_area)\n                                rups_rake.append(rake)\n                                rups_mag.append(mag)\n                                full_fault = False\n                                if nb_fault_invo == 1:\n                                    len_2 = len(id_sections_fault[f_for_sherifs[new_rup[0]]['oiler_id']])\n                                    if len_2 == len(new_rup):\n                                        full_fault = True\n                                full_fault_rup.append(full_fault)\n                                rup_f_jump.append([])\n                                rup_id += 1\n                    else:\n                        too_big += 1\n                else:\n                    too_long += 1\n    if target_section == True:\n        print('look at section :', look_at, '\\nother sections in the same fault', id_sections_fault[f_for_sherifs[look_at]['oiler_id']], '\\njumps with', section_jump[look_at], '\\nruptures', f_for_sherifs[look_at]['rup_id'])\n        print('ruptures :')\n        for rup_i in [rup[i] for i in f_for_sherifs[look_at]['rup_id']]:\n            print(rup_i)\n    print('\\nNumber of rup without jumps: ', len(rup), '\\n')\n    last_l = -1\n    loop = 1\n    already_created = 0\n    already_paired = 0\n    too_many_faults = 0\n    too_many_jumps = 0\n    too_many_zig_zag = 0\n    not_diverse_enough = 0\n    max_length = min([f_for_sherifs[sk]['max_possible_length'] for sk in range(nb_sections)])\n    while last_l != len(rup):\n        print('\\n##\\n-> Loop', loop)\n        last_l = len(rup)\n        for si in range(nb_sections):\n            sec_fi = id_sections_fault[fi]\n            jumps = section_jump[si]\n            si_rup = f_for_sherifs[si]['rup_id']\n            for sj in jumps:\n                sj_rup = f_for_sherifs[sj]['rup_id']\n                sj_rup = [i for i in sj_rup if not si in rup[i]]\n                sii_rup = [i for i in si_rup if not sj in rup[i]]\n                for id_rup_i in sii_rup:\n                    if rups_length[id_rup_i] > max_length / 2.0:\n                        sjj_rup = [j for j in sj_rup if full_fault_rup[j] == True]\n                    else:\n                        sjj_rup = [j for j in sj_rup if rups_length[j] < max_length / 2.0]\n                    for id_rup_j in sjj_rup:\n                        build = True\n                        nb_jumps = len(rup_f_jump[id_rup_j] + rup_f_jump[id_rup_i]) + 1\n                        if nb_jumps <= max_fault_jumps:\n                            build = True\n                        else:\n                            build = False\n                            too_many_jumps += 1\n                        if build == True:\n                            jump_i = sorted([f_for_sherifs[si]['oiler_id'], f_for_sherifs[sj]['oiler_id']])\n                            nb_zig_zag = rup_f_jump[id_rup_j].count(jump_i) + rup_f_jump[id_rup_i].count(jump_i)\n                            if not nb_zig_zag > max_zig_zag:\n                                build = True\n                            else:\n                                build = False\n                                too_many_zig_zag += 1\n                        if build == True:\n                            if id_rup_j in rup_paired[id_rup_i]:\n                                build = False\n                                already_paired += 1\n                        if build == True:\n                            if id_rup_i in rup_paired[id_rup_j]:\n                                build = False\n                                already_paired += 1\n                        if build == True:\n                            new_rup = rup[id_rup_i] + rup[id_rup_j]\n                            new_rup = sorted(list(set(new_rup)))\n                            rup_length = rups_length[id_rup_i] + rups_length[id_rup_j]\n                            max_length = min([f_for_sherifs[sk]['max_possible_length'] for sk in new_rup])\n                            rup_area = rups_area[id_rup_i] + rups_area[id_rup_j]\n                            max_mmax = min([f_for_sherifs[sk]['max_possible_Mmax'] for sk in new_rup])\n                            rake = (rups_rake[id_rup_i] * rups_area[id_rup_i] + rups_rake[id_rup_j] * rups_area[id_rup_j]) / rup_area\n                            mag = wc1994_median_mag(rup_area, rake)\n                            index_mag = np.where(binning_in_mag == round(mag, 1))[0][0]\n                            if rup_length > max_length:\n                                build = False\n                                too_long += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                            if build == True and mag > max_mmax:\n                                build = False\n                                too_big += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                        if build == True:\n                            if not new_rup in rup:\n                                build = True\n                                nb_fault_invo = len(set([f_for_sherifs[i]['oiler_id'] for i in new_rup]))\n                            else:\n                                build = False\n                                already_created += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                        if build == True:\n                            if nb_fault_invo <= max_fault_invo:\n                                build = True\n                            else:\n                                build = False\n                                too_many_faults += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                        if build == True:\n                            test_using_length = False\n                            test_using_mag = True\n                            if test_using_length == True:\n                                nb_rup_sec = [len(f_for_sherifs[i]['rup_id']) for i in new_rup]\n                                max_nb_rup_i = max(nb_rup_sec)\n                                mean_nb_rup = len(rup) / nb_sections\n                                min_max_length_i = min([f_for_sherifs[i]['max_length'] for i in new_rup])\n                                mean_max_length_i = np.mean([f_for_sherifs[i]['max_length'] for i in new_rup])\n                                hogger = False\n                                if max_nb_rup_i > 40 and rup_length < mean_max_length_i * 1.5:\n                                    hogger = True\n                                if hogger == True:\n                                    nb_i_to_remove = 0\n                                    if rup_length < min_max_length_i / 2.0:\n                                        if len(rup[id_rup_j]) < 2 or len(rup[id_rup_i]) < 2:\n                                            build = False\n                                        else:\n                                            nb_i_to_remove = 2\n                                    elif rup_length < min_max_length_i * 3.0 / 4.0:\n                                        if len(rup[id_rup_j]) < 3 or len(rup[id_rup_i]) < 3:\n                                            build = False\n                                        else:\n                                            nb_i_to_remove = 3\n                                    elif len(rup[id_rup_j]) < 4 or len(rup[id_rup_i]) < 4:\n                                        build = False\n                                    else:\n                                        nb_i_to_remove = 4\n                                    if build == True and nb_i_to_remove != 0:\n                                        r = list(combinations(new_rup, nb_i_to_remove))\n                                        grp_i = 0\n                                        while build == True and grp_i < len(r):\n                                            if len(r[grp_i]) == nb_i_to_remove:\n                                                test_rup = [i for i in new_rup if not i in r[grp_i]]\n                                                if test_rup in rup:\n                                                    build = False\n                                                    if target_section == True:\n                                                        if si == look_at:\n                                                            print(id_rup_j + id_rup_i, test_rup, 'already there|nb_i_to_remove:', nb_i_to_remove)\n                                            grp_i += 1\n                            elif test_using_mag == True:\n                                nb_i = np.mean([nb_rup_per_bin[sk][index_mag] for sk in new_rup])\n                                if nb_i > 7:\n                                    nb_j = 0\n                                    for sk in new_rup:\n                                        tmp_list = np.trim_zeros(nb_rup_per_bin[sk])\n                                        p = np.percentile(tmp_list, 66)\n                                        if nb_rup_per_bin[sk][index_mag] >= p:\n                                            nb_j += 1\n                                    if nb_j >= len(new_rup) / 2.0:\n                                        build = False\n                            if build == False:\n                                not_diverse_enough += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                        if build == True:\n                            rup.append(new_rup)\n                            rup_paired.append([])\n                            rup_paired[id_rup_i].append(id_rup_j)\n                            rup_paired[id_rup_j].append(id_rup_i)\n                            l = len(rup)\n                            for sk in new_rup:\n                                f_for_sherifs[sk]['rup_id'].append(rup_id)\n                                nb_rup_per_bin[sk][index_mag] += 1\n                                if rup_length > f_for_sherifs[sk]['max_length']:\n                                    f_for_sherifs[sk]['max_length'] = rup_length\n                            rups_length.append(rup_length)\n                            rups_area.append(rup_area)\n                            rups_rake.append(rake)\n                            rups_mag.append(mag)\n                            full_fault_rup.append(False)\n                            rup_f_jump.append(rup_f_jump[id_rup_j] + rup_f_jump[id_rup_i] + [jump_i])\n                            if '000' == str(l)[-3:]:\n                                print(l, 'ruptures   |   active section :', si, ' |    not_diverse_enough :', not_diverse_enough)\n                            rup_id += 1\n            if target_section == True:\n                if si == look_at:\n                    print(si, len(f_for_sherifs[si]['rup_id']))\n        print('\\n -> Number of rup with ', loop, ' loops: ', len(rup))\n        loop += 1\n    print('\\n########\\n')\n    print('Total ruptures : ', len(rup))\n    print('The longest rupture is : ', round(max(rups_length)), ' km.')\n    print('The largest magnitude is : ', round(max(rups_mag), 1), '.')\n    print('Max number of ruptures for a section :', max([len(f_for_sherifs[i]['rup_id']) for i in range(len(f_for_sherifs))]))\n    print('Number of ruptures created for nothing because already there : ', already_created)\n    print('Number of ruptures tried for nothing because already paired : ', already_paired)\n    print('Number of ruptures not used because too many faults : ', too_many_faults)\n    print('Number of ruptures not used because too many jumps : ', too_many_jumps)\n    print('Number of ruptures not used because too many zigzag : ', too_many_zig_zag)\n    print('Number of ruptures not used because not diverse enough : ', not_diverse_enough)\n    print('Number of ruptures not used because too long : ', too_long)\n    print('Number of ruptures not used because magnitude was too large : ', too_big)\n    if target_section == True:\n        print('\\n########\\n')\n        print('ruptures for the look_at :', '    look_at id is ', look_at)\n        print('number of ruptures : ', len(f_for_sherifs[look_at]['rup_id']))\n        for i in f_for_sherifs[look_at]['rup_id']:\n            if rup.count(rup[i]) != 1:\n                print('error')\n            print(i, rup[i], round(rups_length[i]), 'km | M :', rups_mag[i])\n    duration = time.time() - t0\n    print('\\n\\nIt took ', round(duration, 3), 'seconds to find all the ruptures.')\n    return (rup, [rups_length, rups_mag])",
            "def build_scenarios(f_for_sherifs, id_sections_fault, sections_areas_tot, sections_lengths_tot, binning_in_mag, nb_rup_per_bin, section_jump):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    t0 = time.time()\n    max_fault_jumps = 100\n    max_fault_invo = 100\n    max_zig_zag = 2\n    nb_sections = len(f_for_sherifs)\n    rup = []\n    rup_paired = []\n    full_fault_rup = []\n    rup_f_jump = []\n    for si in range(nb_sections):\n        f_for_sherifs[si]['rup_id'] = []\n    rups_length = []\n    rups_area = []\n    rups_rake = []\n    rups_mag = []\n    target_section = False\n    if target_section == True:\n        look_at = 917\n    too_long = 0\n    too_big = 0\n    rup_id = 0\n    for si in range(len(f_for_sherifs)):\n        new_rup = [si]\n        rup.append(new_rup)\n        rup_paired.append([])\n        rup_area = sections_areas_tot[si]\n        rake = f_for_sherifs[si]['rake']\n        mag = wc1994_median_mag(rup_area, rake)\n        index_mag = np.where(binning_in_mag == round(mag, 1))[0][0]\n        for sk in new_rup:\n            f_for_sherifs[sk]['rup_id'].append(rup_id)\n            nb_rup_per_bin[sk][index_mag] += 1\n            f_for_sherifs[sk]['max_length'] = sections_lengths_tot[si]\n        rups_length.append(sections_lengths_tot[si])\n        rups_area.append(rup_area)\n        rups_rake.append(f_for_sherifs[si]['rake'])\n        rups_mag.append(mag)\n        full_fault = False\n        len_2 = len(id_sections_fault[f_for_sherifs[new_rup[0]]['oiler_id']])\n        if len_2 == len(new_rup):\n            full_fault = True\n        full_fault_rup.append(full_fault)\n        rup_f_jump.append([])\n        rup_id += 1\n    for si in range(nb_sections):\n        fi = f_for_sherifs[si]['oiler_id']\n        sec_fi = id_sections_fault[fi]\n        if len(sec_fi) > 1:\n            id_si_in_fi = sec_fi.index(si)\n            for i in range(len(sec_fi) - id_si_in_fi):\n                new_rup = sec_fi[id_si_in_fi:id_si_in_fi + i + 1]\n                new_rup = sorted(list(set(new_rup)))\n                rup_length = sum([sections_lengths_tot[sk] for sk in new_rup])\n                max_length = min([f_for_sherifs[i]['max_possible_length'] for sk in new_rup])\n                rup_area = sum([sections_areas_tot[sk] for sk in new_rup])\n                max_mmax = min([f_for_sherifs[sk]['max_possible_Mmax'] for sk in new_rup])\n                rake = sum([sections_areas_tot[sk] * f_for_sherifs[sk]['rake'] for sk in new_rup]) / rup_area\n                mag = wc1994_median_mag(rup_area, rake)\n                index_mag = np.where(binning_in_mag == round(mag, 1))[0][0]\n                if len(new_rup) > 1 and rup_length < max_length:\n                    if mag <= max_mmax:\n                        if not new_rup in rup:\n                            nb_fault_invo = len(set([f_for_sherifs[i]['oiler_id'] for sk in new_rup]))\n                            if nb_fault_invo <= max_fault_invo:\n                                rup.append(new_rup)\n                                rup_paired.append([])\n                                for sk in new_rup:\n                                    nb_rup_per_bin[sk][index_mag] += 1\n                                    f_for_sherifs[sk]['rup_id'].append(rup_id)\n                                    if rup_length > f_for_sherifs[sk]['max_length']:\n                                        f_for_sherifs[sk]['max_length'] = rup_length\n                                rups_length.append(rup_length)\n                                rups_area.append(rup_area)\n                                rups_rake.append(rake)\n                                rups_mag.append(mag)\n                                full_fault = False\n                                if nb_fault_invo == 1:\n                                    len_2 = len(id_sections_fault[f_for_sherifs[new_rup[0]]['oiler_id']])\n                                    if len_2 == len(new_rup):\n                                        full_fault = True\n                                full_fault_rup.append(full_fault)\n                                rup_f_jump.append([])\n                                rup_id += 1\n                    else:\n                        too_big += 1\n                else:\n                    too_long += 1\n    if target_section == True:\n        print('look at section :', look_at, '\\nother sections in the same fault', id_sections_fault[f_for_sherifs[look_at]['oiler_id']], '\\njumps with', section_jump[look_at], '\\nruptures', f_for_sherifs[look_at]['rup_id'])\n        print('ruptures :')\n        for rup_i in [rup[i] for i in f_for_sherifs[look_at]['rup_id']]:\n            print(rup_i)\n    print('\\nNumber of rup without jumps: ', len(rup), '\\n')\n    last_l = -1\n    loop = 1\n    already_created = 0\n    already_paired = 0\n    too_many_faults = 0\n    too_many_jumps = 0\n    too_many_zig_zag = 0\n    not_diverse_enough = 0\n    max_length = min([f_for_sherifs[sk]['max_possible_length'] for sk in range(nb_sections)])\n    while last_l != len(rup):\n        print('\\n##\\n-> Loop', loop)\n        last_l = len(rup)\n        for si in range(nb_sections):\n            sec_fi = id_sections_fault[fi]\n            jumps = section_jump[si]\n            si_rup = f_for_sherifs[si]['rup_id']\n            for sj in jumps:\n                sj_rup = f_for_sherifs[sj]['rup_id']\n                sj_rup = [i for i in sj_rup if not si in rup[i]]\n                sii_rup = [i for i in si_rup if not sj in rup[i]]\n                for id_rup_i in sii_rup:\n                    if rups_length[id_rup_i] > max_length / 2.0:\n                        sjj_rup = [j for j in sj_rup if full_fault_rup[j] == True]\n                    else:\n                        sjj_rup = [j for j in sj_rup if rups_length[j] < max_length / 2.0]\n                    for id_rup_j in sjj_rup:\n                        build = True\n                        nb_jumps = len(rup_f_jump[id_rup_j] + rup_f_jump[id_rup_i]) + 1\n                        if nb_jumps <= max_fault_jumps:\n                            build = True\n                        else:\n                            build = False\n                            too_many_jumps += 1\n                        if build == True:\n                            jump_i = sorted([f_for_sherifs[si]['oiler_id'], f_for_sherifs[sj]['oiler_id']])\n                            nb_zig_zag = rup_f_jump[id_rup_j].count(jump_i) + rup_f_jump[id_rup_i].count(jump_i)\n                            if not nb_zig_zag > max_zig_zag:\n                                build = True\n                            else:\n                                build = False\n                                too_many_zig_zag += 1\n                        if build == True:\n                            if id_rup_j in rup_paired[id_rup_i]:\n                                build = False\n                                already_paired += 1\n                        if build == True:\n                            if id_rup_i in rup_paired[id_rup_j]:\n                                build = False\n                                already_paired += 1\n                        if build == True:\n                            new_rup = rup[id_rup_i] + rup[id_rup_j]\n                            new_rup = sorted(list(set(new_rup)))\n                            rup_length = rups_length[id_rup_i] + rups_length[id_rup_j]\n                            max_length = min([f_for_sherifs[sk]['max_possible_length'] for sk in new_rup])\n                            rup_area = rups_area[id_rup_i] + rups_area[id_rup_j]\n                            max_mmax = min([f_for_sherifs[sk]['max_possible_Mmax'] for sk in new_rup])\n                            rake = (rups_rake[id_rup_i] * rups_area[id_rup_i] + rups_rake[id_rup_j] * rups_area[id_rup_j]) / rup_area\n                            mag = wc1994_median_mag(rup_area, rake)\n                            index_mag = np.where(binning_in_mag == round(mag, 1))[0][0]\n                            if rup_length > max_length:\n                                build = False\n                                too_long += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                            if build == True and mag > max_mmax:\n                                build = False\n                                too_big += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                        if build == True:\n                            if not new_rup in rup:\n                                build = True\n                                nb_fault_invo = len(set([f_for_sherifs[i]['oiler_id'] for i in new_rup]))\n                            else:\n                                build = False\n                                already_created += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                        if build == True:\n                            if nb_fault_invo <= max_fault_invo:\n                                build = True\n                            else:\n                                build = False\n                                too_many_faults += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                        if build == True:\n                            test_using_length = False\n                            test_using_mag = True\n                            if test_using_length == True:\n                                nb_rup_sec = [len(f_for_sherifs[i]['rup_id']) for i in new_rup]\n                                max_nb_rup_i = max(nb_rup_sec)\n                                mean_nb_rup = len(rup) / nb_sections\n                                min_max_length_i = min([f_for_sherifs[i]['max_length'] for i in new_rup])\n                                mean_max_length_i = np.mean([f_for_sherifs[i]['max_length'] for i in new_rup])\n                                hogger = False\n                                if max_nb_rup_i > 40 and rup_length < mean_max_length_i * 1.5:\n                                    hogger = True\n                                if hogger == True:\n                                    nb_i_to_remove = 0\n                                    if rup_length < min_max_length_i / 2.0:\n                                        if len(rup[id_rup_j]) < 2 or len(rup[id_rup_i]) < 2:\n                                            build = False\n                                        else:\n                                            nb_i_to_remove = 2\n                                    elif rup_length < min_max_length_i * 3.0 / 4.0:\n                                        if len(rup[id_rup_j]) < 3 or len(rup[id_rup_i]) < 3:\n                                            build = False\n                                        else:\n                                            nb_i_to_remove = 3\n                                    elif len(rup[id_rup_j]) < 4 or len(rup[id_rup_i]) < 4:\n                                        build = False\n                                    else:\n                                        nb_i_to_remove = 4\n                                    if build == True and nb_i_to_remove != 0:\n                                        r = list(combinations(new_rup, nb_i_to_remove))\n                                        grp_i = 0\n                                        while build == True and grp_i < len(r):\n                                            if len(r[grp_i]) == nb_i_to_remove:\n                                                test_rup = [i for i in new_rup if not i in r[grp_i]]\n                                                if test_rup in rup:\n                                                    build = False\n                                                    if target_section == True:\n                                                        if si == look_at:\n                                                            print(id_rup_j + id_rup_i, test_rup, 'already there|nb_i_to_remove:', nb_i_to_remove)\n                                            grp_i += 1\n                            elif test_using_mag == True:\n                                nb_i = np.mean([nb_rup_per_bin[sk][index_mag] for sk in new_rup])\n                                if nb_i > 7:\n                                    nb_j = 0\n                                    for sk in new_rup:\n                                        tmp_list = np.trim_zeros(nb_rup_per_bin[sk])\n                                        p = np.percentile(tmp_list, 66)\n                                        if nb_rup_per_bin[sk][index_mag] >= p:\n                                            nb_j += 1\n                                    if nb_j >= len(new_rup) / 2.0:\n                                        build = False\n                            if build == False:\n                                not_diverse_enough += 1\n                                rup_paired[id_rup_i].append(id_rup_j)\n                                rup_paired[id_rup_j].append(id_rup_i)\n                        if build == True:\n                            rup.append(new_rup)\n                            rup_paired.append([])\n                            rup_paired[id_rup_i].append(id_rup_j)\n                            rup_paired[id_rup_j].append(id_rup_i)\n                            l = len(rup)\n                            for sk in new_rup:\n                                f_for_sherifs[sk]['rup_id'].append(rup_id)\n                                nb_rup_per_bin[sk][index_mag] += 1\n                                if rup_length > f_for_sherifs[sk]['max_length']:\n                                    f_for_sherifs[sk]['max_length'] = rup_length\n                            rups_length.append(rup_length)\n                            rups_area.append(rup_area)\n                            rups_rake.append(rake)\n                            rups_mag.append(mag)\n                            full_fault_rup.append(False)\n                            rup_f_jump.append(rup_f_jump[id_rup_j] + rup_f_jump[id_rup_i] + [jump_i])\n                            if '000' == str(l)[-3:]:\n                                print(l, 'ruptures   |   active section :', si, ' |    not_diverse_enough :', not_diverse_enough)\n                            rup_id += 1\n            if target_section == True:\n                if si == look_at:\n                    print(si, len(f_for_sherifs[si]['rup_id']))\n        print('\\n -> Number of rup with ', loop, ' loops: ', len(rup))\n        loop += 1\n    print('\\n########\\n')\n    print('Total ruptures : ', len(rup))\n    print('The longest rupture is : ', round(max(rups_length)), ' km.')\n    print('The largest magnitude is : ', round(max(rups_mag), 1), '.')\n    print('Max number of ruptures for a section :', max([len(f_for_sherifs[i]['rup_id']) for i in range(len(f_for_sherifs))]))\n    print('Number of ruptures created for nothing because already there : ', already_created)\n    print('Number of ruptures tried for nothing because already paired : ', already_paired)\n    print('Number of ruptures not used because too many faults : ', too_many_faults)\n    print('Number of ruptures not used because too many jumps : ', too_many_jumps)\n    print('Number of ruptures not used because too many zigzag : ', too_many_zig_zag)\n    print('Number of ruptures not used because not diverse enough : ', not_diverse_enough)\n    print('Number of ruptures not used because too long : ', too_long)\n    print('Number of ruptures not used because magnitude was too large : ', too_big)\n    if target_section == True:\n        print('\\n########\\n')\n        print('ruptures for the look_at :', '    look_at id is ', look_at)\n        print('number of ruptures : ', len(f_for_sherifs[look_at]['rup_id']))\n        for i in f_for_sherifs[look_at]['rup_id']:\n            if rup.count(rup[i]) != 1:\n                print('error')\n            print(i, rup[i], round(rups_length[i]), 'km | M :', rups_mag[i])\n    duration = time.time() - t0\n    print('\\n\\nIt took ', round(duration, 3), 'seconds to find all the ruptures.')\n    return (rup, [rups_length, rups_mag])"
        ]
    },
    {
        "func_name": "write_rupt_file",
        "original": "def write_rupt_file(rup, Run_Name, Set_Name, dirpath):\n    f_name = dirpath + 'input/' + Run_Name + '/ruptures.txt'\n    f = open(f_name, 'w')\n    f.write('set ' + Set_Name + '\\n')\n    for rup_i in rup:\n        if len(rup_i) > 1:\n            line = ''\n            for si in rup_i:\n                line += str(si) + ' '\n            line = line[:-1]\n            f.write(line + '\\n')\n    f.close()\n    print('Rupture file built')",
        "mutated": [
            "def write_rupt_file(rup, Run_Name, Set_Name, dirpath):\n    if False:\n        i = 10\n    f_name = dirpath + 'input/' + Run_Name + '/ruptures.txt'\n    f = open(f_name, 'w')\n    f.write('set ' + Set_Name + '\\n')\n    for rup_i in rup:\n        if len(rup_i) > 1:\n            line = ''\n            for si in rup_i:\n                line += str(si) + ' '\n            line = line[:-1]\n            f.write(line + '\\n')\n    f.close()\n    print('Rupture file built')",
            "def write_rupt_file(rup, Run_Name, Set_Name, dirpath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    f_name = dirpath + 'input/' + Run_Name + '/ruptures.txt'\n    f = open(f_name, 'w')\n    f.write('set ' + Set_Name + '\\n')\n    for rup_i in rup:\n        if len(rup_i) > 1:\n            line = ''\n            for si in rup_i:\n                line += str(si) + ' '\n            line = line[:-1]\n            f.write(line + '\\n')\n    f.close()\n    print('Rupture file built')",
            "def write_rupt_file(rup, Run_Name, Set_Name, dirpath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    f_name = dirpath + 'input/' + Run_Name + '/ruptures.txt'\n    f = open(f_name, 'w')\n    f.write('set ' + Set_Name + '\\n')\n    for rup_i in rup:\n        if len(rup_i) > 1:\n            line = ''\n            for si in rup_i:\n                line += str(si) + ' '\n            line = line[:-1]\n            f.write(line + '\\n')\n    f.close()\n    print('Rupture file built')",
            "def write_rupt_file(rup, Run_Name, Set_Name, dirpath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    f_name = dirpath + 'input/' + Run_Name + '/ruptures.txt'\n    f = open(f_name, 'w')\n    f.write('set ' + Set_Name + '\\n')\n    for rup_i in rup:\n        if len(rup_i) > 1:\n            line = ''\n            for si in rup_i:\n                line += str(si) + ' '\n            line = line[:-1]\n            f.write(line + '\\n')\n    f.close()\n    print('Rupture file built')",
            "def write_rupt_file(rup, Run_Name, Set_Name, dirpath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    f_name = dirpath + 'input/' + Run_Name + '/ruptures.txt'\n    f = open(f_name, 'w')\n    f.write('set ' + Set_Name + '\\n')\n    for rup_i in rup:\n        if len(rup_i) > 1:\n            line = ''\n            for si in rup_i:\n                line += str(si) + ' '\n            line = line[:-1]\n            f.write(line + '\\n')\n    f.close()\n    print('Rupture file built')"
        ]
    },
    {
        "func_name": "visu_rup",
        "original": "def visu_rup(f_for_sherifs, rup, rups_length, rups_mag, path):\n    from shapely.geometry import MultiPoint\n    from geojson import Feature, FeatureCollection, dump\n    import os\n    north_shift = 0.08\n    for s in range(len(f_for_sherifs)):\n        if len(f_for_sherifs[s]['rup_id']) > 3.0:\n            features = []\n            sections = []\n            z = 0\n            id_rup = 0\n            for rup_i in rup:\n                add = False\n                for si in rup_i:\n                    if str(si) == str(s):\n                        add = True\n                if add == True:\n                    geom = []\n                    for si in rup_i:\n                        for (lon_i, lat_i) in zip(f_for_sherifs[si]['lons'], f_for_sherifs[si]['lats']):\n                            geom.append([lon_i, lat_i + z * north_shift])\n                    geom = MultiPoint(geom)\n                    features.append(Feature(geometry=geom, properties={'id_rup': id_rup, 'length': rups_length[id_rup], 'mag': rups_mag[id_rup]}))\n                    z += 1\n                id_rup += 1\n            feature_collection = FeatureCollection(features)\n            if not os.path.exists(path + '/qgis/rups'):\n                os.makedirs(path + '/qgis/rups')\n            with open(path + '/qgis/rups/rup_' + str(s) + '.geojson', 'w') as f:\n                dump(feature_collection, f)",
        "mutated": [
            "def visu_rup(f_for_sherifs, rup, rups_length, rups_mag, path):\n    if False:\n        i = 10\n    from shapely.geometry import MultiPoint\n    from geojson import Feature, FeatureCollection, dump\n    import os\n    north_shift = 0.08\n    for s in range(len(f_for_sherifs)):\n        if len(f_for_sherifs[s]['rup_id']) > 3.0:\n            features = []\n            sections = []\n            z = 0\n            id_rup = 0\n            for rup_i in rup:\n                add = False\n                for si in rup_i:\n                    if str(si) == str(s):\n                        add = True\n                if add == True:\n                    geom = []\n                    for si in rup_i:\n                        for (lon_i, lat_i) in zip(f_for_sherifs[si]['lons'], f_for_sherifs[si]['lats']):\n                            geom.append([lon_i, lat_i + z * north_shift])\n                    geom = MultiPoint(geom)\n                    features.append(Feature(geometry=geom, properties={'id_rup': id_rup, 'length': rups_length[id_rup], 'mag': rups_mag[id_rup]}))\n                    z += 1\n                id_rup += 1\n            feature_collection = FeatureCollection(features)\n            if not os.path.exists(path + '/qgis/rups'):\n                os.makedirs(path + '/qgis/rups')\n            with open(path + '/qgis/rups/rup_' + str(s) + '.geojson', 'w') as f:\n                dump(feature_collection, f)",
            "def visu_rup(f_for_sherifs, rup, rups_length, rups_mag, path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    from shapely.geometry import MultiPoint\n    from geojson import Feature, FeatureCollection, dump\n    import os\n    north_shift = 0.08\n    for s in range(len(f_for_sherifs)):\n        if len(f_for_sherifs[s]['rup_id']) > 3.0:\n            features = []\n            sections = []\n            z = 0\n            id_rup = 0\n            for rup_i in rup:\n                add = False\n                for si in rup_i:\n                    if str(si) == str(s):\n                        add = True\n                if add == True:\n                    geom = []\n                    for si in rup_i:\n                        for (lon_i, lat_i) in zip(f_for_sherifs[si]['lons'], f_for_sherifs[si]['lats']):\n                            geom.append([lon_i, lat_i + z * north_shift])\n                    geom = MultiPoint(geom)\n                    features.append(Feature(geometry=geom, properties={'id_rup': id_rup, 'length': rups_length[id_rup], 'mag': rups_mag[id_rup]}))\n                    z += 1\n                id_rup += 1\n            feature_collection = FeatureCollection(features)\n            if not os.path.exists(path + '/qgis/rups'):\n                os.makedirs(path + '/qgis/rups')\n            with open(path + '/qgis/rups/rup_' + str(s) + '.geojson', 'w') as f:\n                dump(feature_collection, f)",
            "def visu_rup(f_for_sherifs, rup, rups_length, rups_mag, path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    from shapely.geometry import MultiPoint\n    from geojson import Feature, FeatureCollection, dump\n    import os\n    north_shift = 0.08\n    for s in range(len(f_for_sherifs)):\n        if len(f_for_sherifs[s]['rup_id']) > 3.0:\n            features = []\n            sections = []\n            z = 0\n            id_rup = 0\n            for rup_i in rup:\n                add = False\n                for si in rup_i:\n                    if str(si) == str(s):\n                        add = True\n                if add == True:\n                    geom = []\n                    for si in rup_i:\n                        for (lon_i, lat_i) in zip(f_for_sherifs[si]['lons'], f_for_sherifs[si]['lats']):\n                            geom.append([lon_i, lat_i + z * north_shift])\n                    geom = MultiPoint(geom)\n                    features.append(Feature(geometry=geom, properties={'id_rup': id_rup, 'length': rups_length[id_rup], 'mag': rups_mag[id_rup]}))\n                    z += 1\n                id_rup += 1\n            feature_collection = FeatureCollection(features)\n            if not os.path.exists(path + '/qgis/rups'):\n                os.makedirs(path + '/qgis/rups')\n            with open(path + '/qgis/rups/rup_' + str(s) + '.geojson', 'w') as f:\n                dump(feature_collection, f)",
            "def visu_rup(f_for_sherifs, rup, rups_length, rups_mag, path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    from shapely.geometry import MultiPoint\n    from geojson import Feature, FeatureCollection, dump\n    import os\n    north_shift = 0.08\n    for s in range(len(f_for_sherifs)):\n        if len(f_for_sherifs[s]['rup_id']) > 3.0:\n            features = []\n            sections = []\n            z = 0\n            id_rup = 0\n            for rup_i in rup:\n                add = False\n                for si in rup_i:\n                    if str(si) == str(s):\n                        add = True\n                if add == True:\n                    geom = []\n                    for si in rup_i:\n                        for (lon_i, lat_i) in zip(f_for_sherifs[si]['lons'], f_for_sherifs[si]['lats']):\n                            geom.append([lon_i, lat_i + z * north_shift])\n                    geom = MultiPoint(geom)\n                    features.append(Feature(geometry=geom, properties={'id_rup': id_rup, 'length': rups_length[id_rup], 'mag': rups_mag[id_rup]}))\n                    z += 1\n                id_rup += 1\n            feature_collection = FeatureCollection(features)\n            if not os.path.exists(path + '/qgis/rups'):\n                os.makedirs(path + '/qgis/rups')\n            with open(path + '/qgis/rups/rup_' + str(s) + '.geojson', 'w') as f:\n                dump(feature_collection, f)",
            "def visu_rup(f_for_sherifs, rup, rups_length, rups_mag, path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    from shapely.geometry import MultiPoint\n    from geojson import Feature, FeatureCollection, dump\n    import os\n    north_shift = 0.08\n    for s in range(len(f_for_sherifs)):\n        if len(f_for_sherifs[s]['rup_id']) > 3.0:\n            features = []\n            sections = []\n            z = 0\n            id_rup = 0\n            for rup_i in rup:\n                add = False\n                for si in rup_i:\n                    if str(si) == str(s):\n                        add = True\n                if add == True:\n                    geom = []\n                    for si in rup_i:\n                        for (lon_i, lat_i) in zip(f_for_sherifs[si]['lons'], f_for_sherifs[si]['lats']):\n                            geom.append([lon_i, lat_i + z * north_shift])\n                    geom = MultiPoint(geom)\n                    features.append(Feature(geometry=geom, properties={'id_rup': id_rup, 'length': rups_length[id_rup], 'mag': rups_mag[id_rup]}))\n                    z += 1\n                id_rup += 1\n            feature_collection = FeatureCollection(features)\n            if not os.path.exists(path + '/qgis/rups'):\n                os.makedirs(path + '/qgis/rups')\n            with open(path + '/qgis/rups/rup_' + str(s) + '.geojson', 'w') as f:\n                dump(feature_collection, f)"
        ]
    }
]