[
    {
        "func_name": "strongPasswordChecker",
        "original": "def strongPasswordChecker(password):\n    groups = []\n    length = len(password)\n    last = 0\n    lower = upper = digit = 0\n    for curr in range(length):\n        if password[curr].islower():\n            lower = 1\n        elif password[curr].isupper():\n            upper = 1\n        elif password[curr].isdigit():\n            digit = 1\n        if password[last] != password[curr]:\n            groups.append(curr - last)\n            last = curr\n    groups.append(curr + 1 - last)\n    lud = lower + upper + digit\n    addSteps = 0\n    if length < 6:\n        if length == 5 and groups[0] == 5:\n            addSteps = 2\n        else:\n            addSteps = 6 - length\n        ludLeft = 3 - lud\n        if addSteps < ludLeft:\n            addSteps = ludLeft\n        return addSteps\n    deleteSteps = 0\n    groupsLength = len(groups)\n    while length > 20:\n        found = False\n        for priority in range(3):\n            for gidx in range(groupsLength):\n                if groups[gidx] > 2 and groups[gidx] % 3 == priority:\n                    groups[gidx] -= 1\n                    found = True\n                    break\n            if found:\n                break\n        if not found:\n            lastGroupIdx = groupsLength - 1\n            groups[lastGroupIdx] -= 1\n            if groups[lastGroupIdx] == 0:\n                groups.pop(lastGroupIdx)\n                groupsLength -= 1\n        length -= 1\n        deleteSteps += 1\n    changeSteps = 0\n    for gidx in range(groupsLength):\n        changeSteps += groups[gidx] // 3\n    ludLeft = 3 - lud\n    if changeSteps < ludLeft:\n        changeSteps = ludLeft\n    return deleteSteps + changeSteps",
        "mutated": [
            "def strongPasswordChecker(password):\n    if False:\n        i = 10\n    groups = []\n    length = len(password)\n    last = 0\n    lower = upper = digit = 0\n    for curr in range(length):\n        if password[curr].islower():\n            lower = 1\n        elif password[curr].isupper():\n            upper = 1\n        elif password[curr].isdigit():\n            digit = 1\n        if password[last] != password[curr]:\n            groups.append(curr - last)\n            last = curr\n    groups.append(curr + 1 - last)\n    lud = lower + upper + digit\n    addSteps = 0\n    if length < 6:\n        if length == 5 and groups[0] == 5:\n            addSteps = 2\n        else:\n            addSteps = 6 - length\n        ludLeft = 3 - lud\n        if addSteps < ludLeft:\n            addSteps = ludLeft\n        return addSteps\n    deleteSteps = 0\n    groupsLength = len(groups)\n    while length > 20:\n        found = False\n        for priority in range(3):\n            for gidx in range(groupsLength):\n                if groups[gidx] > 2 and groups[gidx] % 3 == priority:\n                    groups[gidx] -= 1\n                    found = True\n                    break\n            if found:\n                break\n        if not found:\n            lastGroupIdx = groupsLength - 1\n            groups[lastGroupIdx] -= 1\n            if groups[lastGroupIdx] == 0:\n                groups.pop(lastGroupIdx)\n                groupsLength -= 1\n        length -= 1\n        deleteSteps += 1\n    changeSteps = 0\n    for gidx in range(groupsLength):\n        changeSteps += groups[gidx] // 3\n    ludLeft = 3 - lud\n    if changeSteps < ludLeft:\n        changeSteps = ludLeft\n    return deleteSteps + changeSteps",
            "def strongPasswordChecker(password):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    groups = []\n    length = len(password)\n    last = 0\n    lower = upper = digit = 0\n    for curr in range(length):\n        if password[curr].islower():\n            lower = 1\n        elif password[curr].isupper():\n            upper = 1\n        elif password[curr].isdigit():\n            digit = 1\n        if password[last] != password[curr]:\n            groups.append(curr - last)\n            last = curr\n    groups.append(curr + 1 - last)\n    lud = lower + upper + digit\n    addSteps = 0\n    if length < 6:\n        if length == 5 and groups[0] == 5:\n            addSteps = 2\n        else:\n            addSteps = 6 - length\n        ludLeft = 3 - lud\n        if addSteps < ludLeft:\n            addSteps = ludLeft\n        return addSteps\n    deleteSteps = 0\n    groupsLength = len(groups)\n    while length > 20:\n        found = False\n        for priority in range(3):\n            for gidx in range(groupsLength):\n                if groups[gidx] > 2 and groups[gidx] % 3 == priority:\n                    groups[gidx] -= 1\n                    found = True\n                    break\n            if found:\n                break\n        if not found:\n            lastGroupIdx = groupsLength - 1\n            groups[lastGroupIdx] -= 1\n            if groups[lastGroupIdx] == 0:\n                groups.pop(lastGroupIdx)\n                groupsLength -= 1\n        length -= 1\n        deleteSteps += 1\n    changeSteps = 0\n    for gidx in range(groupsLength):\n        changeSteps += groups[gidx] // 3\n    ludLeft = 3 - lud\n    if changeSteps < ludLeft:\n        changeSteps = ludLeft\n    return deleteSteps + changeSteps",
            "def strongPasswordChecker(password):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    groups = []\n    length = len(password)\n    last = 0\n    lower = upper = digit = 0\n    for curr in range(length):\n        if password[curr].islower():\n            lower = 1\n        elif password[curr].isupper():\n            upper = 1\n        elif password[curr].isdigit():\n            digit = 1\n        if password[last] != password[curr]:\n            groups.append(curr - last)\n            last = curr\n    groups.append(curr + 1 - last)\n    lud = lower + upper + digit\n    addSteps = 0\n    if length < 6:\n        if length == 5 and groups[0] == 5:\n            addSteps = 2\n        else:\n            addSteps = 6 - length\n        ludLeft = 3 - lud\n        if addSteps < ludLeft:\n            addSteps = ludLeft\n        return addSteps\n    deleteSteps = 0\n    groupsLength = len(groups)\n    while length > 20:\n        found = False\n        for priority in range(3):\n            for gidx in range(groupsLength):\n                if groups[gidx] > 2 and groups[gidx] % 3 == priority:\n                    groups[gidx] -= 1\n                    found = True\n                    break\n            if found:\n                break\n        if not found:\n            lastGroupIdx = groupsLength - 1\n            groups[lastGroupIdx] -= 1\n            if groups[lastGroupIdx] == 0:\n                groups.pop(lastGroupIdx)\n                groupsLength -= 1\n        length -= 1\n        deleteSteps += 1\n    changeSteps = 0\n    for gidx in range(groupsLength):\n        changeSteps += groups[gidx] // 3\n    ludLeft = 3 - lud\n    if changeSteps < ludLeft:\n        changeSteps = ludLeft\n    return deleteSteps + changeSteps",
            "def strongPasswordChecker(password):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    groups = []\n    length = len(password)\n    last = 0\n    lower = upper = digit = 0\n    for curr in range(length):\n        if password[curr].islower():\n            lower = 1\n        elif password[curr].isupper():\n            upper = 1\n        elif password[curr].isdigit():\n            digit = 1\n        if password[last] != password[curr]:\n            groups.append(curr - last)\n            last = curr\n    groups.append(curr + 1 - last)\n    lud = lower + upper + digit\n    addSteps = 0\n    if length < 6:\n        if length == 5 and groups[0] == 5:\n            addSteps = 2\n        else:\n            addSteps = 6 - length\n        ludLeft = 3 - lud\n        if addSteps < ludLeft:\n            addSteps = ludLeft\n        return addSteps\n    deleteSteps = 0\n    groupsLength = len(groups)\n    while length > 20:\n        found = False\n        for priority in range(3):\n            for gidx in range(groupsLength):\n                if groups[gidx] > 2 and groups[gidx] % 3 == priority:\n                    groups[gidx] -= 1\n                    found = True\n                    break\n            if found:\n                break\n        if not found:\n            lastGroupIdx = groupsLength - 1\n            groups[lastGroupIdx] -= 1\n            if groups[lastGroupIdx] == 0:\n                groups.pop(lastGroupIdx)\n                groupsLength -= 1\n        length -= 1\n        deleteSteps += 1\n    changeSteps = 0\n    for gidx in range(groupsLength):\n        changeSteps += groups[gidx] // 3\n    ludLeft = 3 - lud\n    if changeSteps < ludLeft:\n        changeSteps = ludLeft\n    return deleteSteps + changeSteps",
            "def strongPasswordChecker(password):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    groups = []\n    length = len(password)\n    last = 0\n    lower = upper = digit = 0\n    for curr in range(length):\n        if password[curr].islower():\n            lower = 1\n        elif password[curr].isupper():\n            upper = 1\n        elif password[curr].isdigit():\n            digit = 1\n        if password[last] != password[curr]:\n            groups.append(curr - last)\n            last = curr\n    groups.append(curr + 1 - last)\n    lud = lower + upper + digit\n    addSteps = 0\n    if length < 6:\n        if length == 5 and groups[0] == 5:\n            addSteps = 2\n        else:\n            addSteps = 6 - length\n        ludLeft = 3 - lud\n        if addSteps < ludLeft:\n            addSteps = ludLeft\n        return addSteps\n    deleteSteps = 0\n    groupsLength = len(groups)\n    while length > 20:\n        found = False\n        for priority in range(3):\n            for gidx in range(groupsLength):\n                if groups[gidx] > 2 and groups[gidx] % 3 == priority:\n                    groups[gidx] -= 1\n                    found = True\n                    break\n            if found:\n                break\n        if not found:\n            lastGroupIdx = groupsLength - 1\n            groups[lastGroupIdx] -= 1\n            if groups[lastGroupIdx] == 0:\n                groups.pop(lastGroupIdx)\n                groupsLength -= 1\n        length -= 1\n        deleteSteps += 1\n    changeSteps = 0\n    for gidx in range(groupsLength):\n        changeSteps += groups[gidx] // 3\n    ludLeft = 3 - lud\n    if changeSteps < ludLeft:\n        changeSteps = ludLeft\n    return deleteSteps + changeSteps"
        ]
    }
]