[
    {
        "func_name": "get",
        "original": "@extend_schema(operation_id='Retrieve an Issue Alert Rule for a Project', parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG, IssueAlertParams.ISSUE_RULE_ID], responses={200: RuleSerializer, 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND}, examples=IssueAlertExamples.GET_PROJECT_RULE)\n@transaction_start('ProjectRuleDetailsEndpoint')\ndef get(self, request: Request, project, rule) -> Response:\n    \"\"\"\n        Return details on an individual issue alert rule.\n\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\n        - Triggers - specify what type of activity you'd like monitored or when an alert should be triggered.\n        - Filters - help control noise by triggering an alert only if the issue matches the specified criteria.\n        - Actions - specify what should happen when the trigger conditions are met and the filters match.\n        \"\"\"\n    serialized_rule = serialize(rule, request.user, RuleSerializer(request.GET.getlist('expand', [])))\n    errors = []\n    for action in serialized_rule.get('actions', []):\n        if action.get('_sentry_app_installation') and action.get('_sentry_app_component'):\n            installation = SentryAppInstallation(**action.get('_sentry_app_installation', {}))\n            component = prepare_ui_component(installation, SentryAppComponent(**action.get('_sentry_app_component')), project.slug, action.get('settings'))\n            if component is None:\n                errors.append({'detail': f'Could not fetch details from {installation.sentry_app.name}'})\n                action['disabled'] = True\n                continue\n            action['formFields'] = component.schema.get('settings', {})\n            del action['_sentry_app_installation']\n            del action['_sentry_app_component']\n        if action.get('id') in (JiraCreateTicketAction.id, JiraServerCreateTicketAction.id):\n            for field in action.get('dynamic_form_fields', []):\n                if field.get('choices'):\n                    field['choices'] = [p for p in field.get('choices', []) if isinstance(p[0], str) and isinstance(p[1], str)]\n    if len(errors):\n        serialized_rule['errors'] = errors\n    return Response(serialized_rule)",
        "mutated": [
            "@extend_schema(operation_id='Retrieve an Issue Alert Rule for a Project', parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG, IssueAlertParams.ISSUE_RULE_ID], responses={200: RuleSerializer, 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND}, examples=IssueAlertExamples.GET_PROJECT_RULE)\n@transaction_start('ProjectRuleDetailsEndpoint')\ndef get(self, request: Request, project, rule) -> Response:\n    if False:\n        i = 10\n    \"\\n        Return details on an individual issue alert rule.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers - specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters - help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions - specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    serialized_rule = serialize(rule, request.user, RuleSerializer(request.GET.getlist('expand', [])))\n    errors = []\n    for action in serialized_rule.get('actions', []):\n        if action.get('_sentry_app_installation') and action.get('_sentry_app_component'):\n            installation = SentryAppInstallation(**action.get('_sentry_app_installation', {}))\n            component = prepare_ui_component(installation, SentryAppComponent(**action.get('_sentry_app_component')), project.slug, action.get('settings'))\n            if component is None:\n                errors.append({'detail': f'Could not fetch details from {installation.sentry_app.name}'})\n                action['disabled'] = True\n                continue\n            action['formFields'] = component.schema.get('settings', {})\n            del action['_sentry_app_installation']\n            del action['_sentry_app_component']\n        if action.get('id') in (JiraCreateTicketAction.id, JiraServerCreateTicketAction.id):\n            for field in action.get('dynamic_form_fields', []):\n                if field.get('choices'):\n                    field['choices'] = [p for p in field.get('choices', []) if isinstance(p[0], str) and isinstance(p[1], str)]\n    if len(errors):\n        serialized_rule['errors'] = errors\n    return Response(serialized_rule)",
            "@extend_schema(operation_id='Retrieve an Issue Alert Rule for a Project', parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG, IssueAlertParams.ISSUE_RULE_ID], responses={200: RuleSerializer, 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND}, examples=IssueAlertExamples.GET_PROJECT_RULE)\n@transaction_start('ProjectRuleDetailsEndpoint')\ndef get(self, request: Request, project, rule) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Return details on an individual issue alert rule.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers - specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters - help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions - specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    serialized_rule = serialize(rule, request.user, RuleSerializer(request.GET.getlist('expand', [])))\n    errors = []\n    for action in serialized_rule.get('actions', []):\n        if action.get('_sentry_app_installation') and action.get('_sentry_app_component'):\n            installation = SentryAppInstallation(**action.get('_sentry_app_installation', {}))\n            component = prepare_ui_component(installation, SentryAppComponent(**action.get('_sentry_app_component')), project.slug, action.get('settings'))\n            if component is None:\n                errors.append({'detail': f'Could not fetch details from {installation.sentry_app.name}'})\n                action['disabled'] = True\n                continue\n            action['formFields'] = component.schema.get('settings', {})\n            del action['_sentry_app_installation']\n            del action['_sentry_app_component']\n        if action.get('id') in (JiraCreateTicketAction.id, JiraServerCreateTicketAction.id):\n            for field in action.get('dynamic_form_fields', []):\n                if field.get('choices'):\n                    field['choices'] = [p for p in field.get('choices', []) if isinstance(p[0], str) and isinstance(p[1], str)]\n    if len(errors):\n        serialized_rule['errors'] = errors\n    return Response(serialized_rule)",
            "@extend_schema(operation_id='Retrieve an Issue Alert Rule for a Project', parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG, IssueAlertParams.ISSUE_RULE_ID], responses={200: RuleSerializer, 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND}, examples=IssueAlertExamples.GET_PROJECT_RULE)\n@transaction_start('ProjectRuleDetailsEndpoint')\ndef get(self, request: Request, project, rule) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Return details on an individual issue alert rule.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers - specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters - help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions - specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    serialized_rule = serialize(rule, request.user, RuleSerializer(request.GET.getlist('expand', [])))\n    errors = []\n    for action in serialized_rule.get('actions', []):\n        if action.get('_sentry_app_installation') and action.get('_sentry_app_component'):\n            installation = SentryAppInstallation(**action.get('_sentry_app_installation', {}))\n            component = prepare_ui_component(installation, SentryAppComponent(**action.get('_sentry_app_component')), project.slug, action.get('settings'))\n            if component is None:\n                errors.append({'detail': f'Could not fetch details from {installation.sentry_app.name}'})\n                action['disabled'] = True\n                continue\n            action['formFields'] = component.schema.get('settings', {})\n            del action['_sentry_app_installation']\n            del action['_sentry_app_component']\n        if action.get('id') in (JiraCreateTicketAction.id, JiraServerCreateTicketAction.id):\n            for field in action.get('dynamic_form_fields', []):\n                if field.get('choices'):\n                    field['choices'] = [p for p in field.get('choices', []) if isinstance(p[0], str) and isinstance(p[1], str)]\n    if len(errors):\n        serialized_rule['errors'] = errors\n    return Response(serialized_rule)",
            "@extend_schema(operation_id='Retrieve an Issue Alert Rule for a Project', parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG, IssueAlertParams.ISSUE_RULE_ID], responses={200: RuleSerializer, 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND}, examples=IssueAlertExamples.GET_PROJECT_RULE)\n@transaction_start('ProjectRuleDetailsEndpoint')\ndef get(self, request: Request, project, rule) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Return details on an individual issue alert rule.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers - specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters - help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions - specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    serialized_rule = serialize(rule, request.user, RuleSerializer(request.GET.getlist('expand', [])))\n    errors = []\n    for action in serialized_rule.get('actions', []):\n        if action.get('_sentry_app_installation') and action.get('_sentry_app_component'):\n            installation = SentryAppInstallation(**action.get('_sentry_app_installation', {}))\n            component = prepare_ui_component(installation, SentryAppComponent(**action.get('_sentry_app_component')), project.slug, action.get('settings'))\n            if component is None:\n                errors.append({'detail': f'Could not fetch details from {installation.sentry_app.name}'})\n                action['disabled'] = True\n                continue\n            action['formFields'] = component.schema.get('settings', {})\n            del action['_sentry_app_installation']\n            del action['_sentry_app_component']\n        if action.get('id') in (JiraCreateTicketAction.id, JiraServerCreateTicketAction.id):\n            for field in action.get('dynamic_form_fields', []):\n                if field.get('choices'):\n                    field['choices'] = [p for p in field.get('choices', []) if isinstance(p[0], str) and isinstance(p[1], str)]\n    if len(errors):\n        serialized_rule['errors'] = errors\n    return Response(serialized_rule)",
            "@extend_schema(operation_id='Retrieve an Issue Alert Rule for a Project', parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG, IssueAlertParams.ISSUE_RULE_ID], responses={200: RuleSerializer, 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND}, examples=IssueAlertExamples.GET_PROJECT_RULE)\n@transaction_start('ProjectRuleDetailsEndpoint')\ndef get(self, request: Request, project, rule) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Return details on an individual issue alert rule.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers - specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters - help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions - specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    serialized_rule = serialize(rule, request.user, RuleSerializer(request.GET.getlist('expand', [])))\n    errors = []\n    for action in serialized_rule.get('actions', []):\n        if action.get('_sentry_app_installation') and action.get('_sentry_app_component'):\n            installation = SentryAppInstallation(**action.get('_sentry_app_installation', {}))\n            component = prepare_ui_component(installation, SentryAppComponent(**action.get('_sentry_app_component')), project.slug, action.get('settings'))\n            if component is None:\n                errors.append({'detail': f'Could not fetch details from {installation.sentry_app.name}'})\n                action['disabled'] = True\n                continue\n            action['formFields'] = component.schema.get('settings', {})\n            del action['_sentry_app_installation']\n            del action['_sentry_app_component']\n        if action.get('id') in (JiraCreateTicketAction.id, JiraServerCreateTicketAction.id):\n            for field in action.get('dynamic_form_fields', []):\n                if field.get('choices'):\n                    field['choices'] = [p for p in field.get('choices', []) if isinstance(p[0], str) and isinstance(p[1], str)]\n    if len(errors):\n        serialized_rule['errors'] = errors\n    return Response(serialized_rule)"
        ]
    },
    {
        "func_name": "put",
        "original": "@extend_schema(operation_id='Update an Issue Alert Rule', parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG, IssueAlertParams.ISSUE_RULE_ID], request=ProjectRuleDetailsPutSerializer, responses={200: RuleSerializer, 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND}, examples=IssueAlertExamples.UPDATE_PROJECT_RULE)\n@transaction_start('ProjectRuleDetailsEndpoint')\ndef put(self, request: Request, project, rule) -> Response:\n    \"\"\"\n        Updates an issue alert rule.\n        > Warning: Calling this endpoint fully overwrites the specified issue alert.\n\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\n        - Triggers - specify what type of activity you'd like monitored or when an alert should be triggered.\n        - Filters - help control noise by triggering an alert only if the issue matches the specified criteria.\n        - Actions - specify what should happen when the trigger conditions are met and the filters match.\n        \"\"\"\n    serializer = DrfRuleSerializer(context={'project': project, 'organization': project.organization}, data=request.data, partial=True)\n    if serializer.is_valid():\n        data = serializer.validated_data\n        explicit_opt_out = request.data.get('optOutExplicit')\n        edit_opt_out = request.data.get('optOutEdit')\n        if explicit_opt_out or edit_opt_out:\n            try:\n                neglected_rule = NeglectedRule.objects.get(rule=rule.id, organization=project.organization, opted_out=False)\n                neglected_rule.opted_out = True\n                neglected_rule.save()\n                analytics_data = {'rule_id': rule.id, 'user_id': request.user.id, 'organization_id': project.organization.id}\n                if explicit_opt_out:\n                    analytics.record('rule_disable_opt_out.explicit', **analytics_data)\n                if edit_opt_out:\n                    analytics.record('rule_disable_opt_out.edit', **analytics_data)\n            except NeglectedRule.DoesNotExist:\n                pass\n            except NeglectedRule.MultipleObjectsReturned:\n                logger.info('rule_disable_opt_out.multiple', extra={'rule_id': rule.id, 'org_id': project.organization.id})\n        if not data.get('actions', []):\n            return Response({'actions': ['You must add an action for this alert to fire.']}, status=status.HTTP_400_BAD_REQUEST)\n        conditions = data.get('conditions', [])\n        if 'filters' in data:\n            conditions.extend(data['filters'])\n        kwargs = {'name': data['name'], 'environment': data.get('environment'), 'project': project, 'action_match': data['actionMatch'], 'filter_match': data.get('filterMatch'), 'conditions': conditions, 'actions': data['actions'], 'frequency': data.get('frequency')}\n        duplicate_rule = find_duplicate_rule(project=project, rule_data=kwargs, rule_id=rule.id)\n        if duplicate_rule:\n            return Response({'name': [f\"This rule is an exact duplicate of '{duplicate_rule.label}' in this project and may not be created.\"], 'ruleId': [duplicate_rule.id]}, status=status.HTTP_400_BAD_REQUEST)\n        owner = data.get('owner')\n        if owner:\n            try:\n                kwargs['owner'] = owner.resolve_to_actor().id\n            except (User.DoesNotExist, Team.DoesNotExist):\n                return Response('Could not resolve owner', status=status.HTTP_400_BAD_REQUEST)\n        if rule.status == ObjectStatus.DISABLED:\n            rule.status = ObjectStatus.ACTIVE\n            rule.save()\n            analytics.record('rule_reenable.edit', rule_id=rule.id, user_id=request.user.id, organization_id=project.organization.id)\n        if data.get('pending_save'):\n            client = RedisRuleStatus()\n            kwargs.update({'uuid': client.uuid, 'rule_id': rule.id})\n            find_channel_id_for_rule.apply_async(kwargs=kwargs)\n            context = {'uuid': client.uuid}\n            return Response(context, status=202)\n        trigger_sentry_app_action_creators_for_issues(actions=kwargs.get('actions'))\n        updated_rule = Updater.run(rule=rule, request=request, **kwargs)\n        RuleActivity.objects.create(rule=updated_rule, user_id=request.user.id, type=RuleActivityType.UPDATED.value)\n        self.create_audit_entry(request=request, organization=project.organization, target_object=updated_rule.id, event=audit_log.get_event_id('RULE_EDIT'), data=updated_rule.get_audit_log_data())\n        alert_rule_edited.send_robust(user=request.user, project=project, rule=rule, rule_type='issue', sender=self, is_api_token=request.auth is not None)\n        return Response(serialize(updated_rule, request.user))\n    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)",
        "mutated": [
            "@extend_schema(operation_id='Update an Issue Alert Rule', parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG, IssueAlertParams.ISSUE_RULE_ID], request=ProjectRuleDetailsPutSerializer, responses={200: RuleSerializer, 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND}, examples=IssueAlertExamples.UPDATE_PROJECT_RULE)\n@transaction_start('ProjectRuleDetailsEndpoint')\ndef put(self, request: Request, project, rule) -> Response:\n    if False:\n        i = 10\n    \"\\n        Updates an issue alert rule.\\n        > Warning: Calling this endpoint fully overwrites the specified issue alert.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers - specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters - help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions - specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    serializer = DrfRuleSerializer(context={'project': project, 'organization': project.organization}, data=request.data, partial=True)\n    if serializer.is_valid():\n        data = serializer.validated_data\n        explicit_opt_out = request.data.get('optOutExplicit')\n        edit_opt_out = request.data.get('optOutEdit')\n        if explicit_opt_out or edit_opt_out:\n            try:\n                neglected_rule = NeglectedRule.objects.get(rule=rule.id, organization=project.organization, opted_out=False)\n                neglected_rule.opted_out = True\n                neglected_rule.save()\n                analytics_data = {'rule_id': rule.id, 'user_id': request.user.id, 'organization_id': project.organization.id}\n                if explicit_opt_out:\n                    analytics.record('rule_disable_opt_out.explicit', **analytics_data)\n                if edit_opt_out:\n                    analytics.record('rule_disable_opt_out.edit', **analytics_data)\n            except NeglectedRule.DoesNotExist:\n                pass\n            except NeglectedRule.MultipleObjectsReturned:\n                logger.info('rule_disable_opt_out.multiple', extra={'rule_id': rule.id, 'org_id': project.organization.id})\n        if not data.get('actions', []):\n            return Response({'actions': ['You must add an action for this alert to fire.']}, status=status.HTTP_400_BAD_REQUEST)\n        conditions = data.get('conditions', [])\n        if 'filters' in data:\n            conditions.extend(data['filters'])\n        kwargs = {'name': data['name'], 'environment': data.get('environment'), 'project': project, 'action_match': data['actionMatch'], 'filter_match': data.get('filterMatch'), 'conditions': conditions, 'actions': data['actions'], 'frequency': data.get('frequency')}\n        duplicate_rule = find_duplicate_rule(project=project, rule_data=kwargs, rule_id=rule.id)\n        if duplicate_rule:\n            return Response({'name': [f\"This rule is an exact duplicate of '{duplicate_rule.label}' in this project and may not be created.\"], 'ruleId': [duplicate_rule.id]}, status=status.HTTP_400_BAD_REQUEST)\n        owner = data.get('owner')\n        if owner:\n            try:\n                kwargs['owner'] = owner.resolve_to_actor().id\n            except (User.DoesNotExist, Team.DoesNotExist):\n                return Response('Could not resolve owner', status=status.HTTP_400_BAD_REQUEST)\n        if rule.status == ObjectStatus.DISABLED:\n            rule.status = ObjectStatus.ACTIVE\n            rule.save()\n            analytics.record('rule_reenable.edit', rule_id=rule.id, user_id=request.user.id, organization_id=project.organization.id)\n        if data.get('pending_save'):\n            client = RedisRuleStatus()\n            kwargs.update({'uuid': client.uuid, 'rule_id': rule.id})\n            find_channel_id_for_rule.apply_async(kwargs=kwargs)\n            context = {'uuid': client.uuid}\n            return Response(context, status=202)\n        trigger_sentry_app_action_creators_for_issues(actions=kwargs.get('actions'))\n        updated_rule = Updater.run(rule=rule, request=request, **kwargs)\n        RuleActivity.objects.create(rule=updated_rule, user_id=request.user.id, type=RuleActivityType.UPDATED.value)\n        self.create_audit_entry(request=request, organization=project.organization, target_object=updated_rule.id, event=audit_log.get_event_id('RULE_EDIT'), data=updated_rule.get_audit_log_data())\n        alert_rule_edited.send_robust(user=request.user, project=project, rule=rule, rule_type='issue', sender=self, is_api_token=request.auth is not None)\n        return Response(serialize(updated_rule, request.user))\n    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)",
            "@extend_schema(operation_id='Update an Issue Alert Rule', parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG, IssueAlertParams.ISSUE_RULE_ID], request=ProjectRuleDetailsPutSerializer, responses={200: RuleSerializer, 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND}, examples=IssueAlertExamples.UPDATE_PROJECT_RULE)\n@transaction_start('ProjectRuleDetailsEndpoint')\ndef put(self, request: Request, project, rule) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Updates an issue alert rule.\\n        > Warning: Calling this endpoint fully overwrites the specified issue alert.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers - specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters - help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions - specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    serializer = DrfRuleSerializer(context={'project': project, 'organization': project.organization}, data=request.data, partial=True)\n    if serializer.is_valid():\n        data = serializer.validated_data\n        explicit_opt_out = request.data.get('optOutExplicit')\n        edit_opt_out = request.data.get('optOutEdit')\n        if explicit_opt_out or edit_opt_out:\n            try:\n                neglected_rule = NeglectedRule.objects.get(rule=rule.id, organization=project.organization, opted_out=False)\n                neglected_rule.opted_out = True\n                neglected_rule.save()\n                analytics_data = {'rule_id': rule.id, 'user_id': request.user.id, 'organization_id': project.organization.id}\n                if explicit_opt_out:\n                    analytics.record('rule_disable_opt_out.explicit', **analytics_data)\n                if edit_opt_out:\n                    analytics.record('rule_disable_opt_out.edit', **analytics_data)\n            except NeglectedRule.DoesNotExist:\n                pass\n            except NeglectedRule.MultipleObjectsReturned:\n                logger.info('rule_disable_opt_out.multiple', extra={'rule_id': rule.id, 'org_id': project.organization.id})\n        if not data.get('actions', []):\n            return Response({'actions': ['You must add an action for this alert to fire.']}, status=status.HTTP_400_BAD_REQUEST)\n        conditions = data.get('conditions', [])\n        if 'filters' in data:\n            conditions.extend(data['filters'])\n        kwargs = {'name': data['name'], 'environment': data.get('environment'), 'project': project, 'action_match': data['actionMatch'], 'filter_match': data.get('filterMatch'), 'conditions': conditions, 'actions': data['actions'], 'frequency': data.get('frequency')}\n        duplicate_rule = find_duplicate_rule(project=project, rule_data=kwargs, rule_id=rule.id)\n        if duplicate_rule:\n            return Response({'name': [f\"This rule is an exact duplicate of '{duplicate_rule.label}' in this project and may not be created.\"], 'ruleId': [duplicate_rule.id]}, status=status.HTTP_400_BAD_REQUEST)\n        owner = data.get('owner')\n        if owner:\n            try:\n                kwargs['owner'] = owner.resolve_to_actor().id\n            except (User.DoesNotExist, Team.DoesNotExist):\n                return Response('Could not resolve owner', status=status.HTTP_400_BAD_REQUEST)\n        if rule.status == ObjectStatus.DISABLED:\n            rule.status = ObjectStatus.ACTIVE\n            rule.save()\n            analytics.record('rule_reenable.edit', rule_id=rule.id, user_id=request.user.id, organization_id=project.organization.id)\n        if data.get('pending_save'):\n            client = RedisRuleStatus()\n            kwargs.update({'uuid': client.uuid, 'rule_id': rule.id})\n            find_channel_id_for_rule.apply_async(kwargs=kwargs)\n            context = {'uuid': client.uuid}\n            return Response(context, status=202)\n        trigger_sentry_app_action_creators_for_issues(actions=kwargs.get('actions'))\n        updated_rule = Updater.run(rule=rule, request=request, **kwargs)\n        RuleActivity.objects.create(rule=updated_rule, user_id=request.user.id, type=RuleActivityType.UPDATED.value)\n        self.create_audit_entry(request=request, organization=project.organization, target_object=updated_rule.id, event=audit_log.get_event_id('RULE_EDIT'), data=updated_rule.get_audit_log_data())\n        alert_rule_edited.send_robust(user=request.user, project=project, rule=rule, rule_type='issue', sender=self, is_api_token=request.auth is not None)\n        return Response(serialize(updated_rule, request.user))\n    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)",
            "@extend_schema(operation_id='Update an Issue Alert Rule', parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG, IssueAlertParams.ISSUE_RULE_ID], request=ProjectRuleDetailsPutSerializer, responses={200: RuleSerializer, 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND}, examples=IssueAlertExamples.UPDATE_PROJECT_RULE)\n@transaction_start('ProjectRuleDetailsEndpoint')\ndef put(self, request: Request, project, rule) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Updates an issue alert rule.\\n        > Warning: Calling this endpoint fully overwrites the specified issue alert.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers - specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters - help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions - specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    serializer = DrfRuleSerializer(context={'project': project, 'organization': project.organization}, data=request.data, partial=True)\n    if serializer.is_valid():\n        data = serializer.validated_data\n        explicit_opt_out = request.data.get('optOutExplicit')\n        edit_opt_out = request.data.get('optOutEdit')\n        if explicit_opt_out or edit_opt_out:\n            try:\n                neglected_rule = NeglectedRule.objects.get(rule=rule.id, organization=project.organization, opted_out=False)\n                neglected_rule.opted_out = True\n                neglected_rule.save()\n                analytics_data = {'rule_id': rule.id, 'user_id': request.user.id, 'organization_id': project.organization.id}\n                if explicit_opt_out:\n                    analytics.record('rule_disable_opt_out.explicit', **analytics_data)\n                if edit_opt_out:\n                    analytics.record('rule_disable_opt_out.edit', **analytics_data)\n            except NeglectedRule.DoesNotExist:\n                pass\n            except NeglectedRule.MultipleObjectsReturned:\n                logger.info('rule_disable_opt_out.multiple', extra={'rule_id': rule.id, 'org_id': project.organization.id})\n        if not data.get('actions', []):\n            return Response({'actions': ['You must add an action for this alert to fire.']}, status=status.HTTP_400_BAD_REQUEST)\n        conditions = data.get('conditions', [])\n        if 'filters' in data:\n            conditions.extend(data['filters'])\n        kwargs = {'name': data['name'], 'environment': data.get('environment'), 'project': project, 'action_match': data['actionMatch'], 'filter_match': data.get('filterMatch'), 'conditions': conditions, 'actions': data['actions'], 'frequency': data.get('frequency')}\n        duplicate_rule = find_duplicate_rule(project=project, rule_data=kwargs, rule_id=rule.id)\n        if duplicate_rule:\n            return Response({'name': [f\"This rule is an exact duplicate of '{duplicate_rule.label}' in this project and may not be created.\"], 'ruleId': [duplicate_rule.id]}, status=status.HTTP_400_BAD_REQUEST)\n        owner = data.get('owner')\n        if owner:\n            try:\n                kwargs['owner'] = owner.resolve_to_actor().id\n            except (User.DoesNotExist, Team.DoesNotExist):\n                return Response('Could not resolve owner', status=status.HTTP_400_BAD_REQUEST)\n        if rule.status == ObjectStatus.DISABLED:\n            rule.status = ObjectStatus.ACTIVE\n            rule.save()\n            analytics.record('rule_reenable.edit', rule_id=rule.id, user_id=request.user.id, organization_id=project.organization.id)\n        if data.get('pending_save'):\n            client = RedisRuleStatus()\n            kwargs.update({'uuid': client.uuid, 'rule_id': rule.id})\n            find_channel_id_for_rule.apply_async(kwargs=kwargs)\n            context = {'uuid': client.uuid}\n            return Response(context, status=202)\n        trigger_sentry_app_action_creators_for_issues(actions=kwargs.get('actions'))\n        updated_rule = Updater.run(rule=rule, request=request, **kwargs)\n        RuleActivity.objects.create(rule=updated_rule, user_id=request.user.id, type=RuleActivityType.UPDATED.value)\n        self.create_audit_entry(request=request, organization=project.organization, target_object=updated_rule.id, event=audit_log.get_event_id('RULE_EDIT'), data=updated_rule.get_audit_log_data())\n        alert_rule_edited.send_robust(user=request.user, project=project, rule=rule, rule_type='issue', sender=self, is_api_token=request.auth is not None)\n        return Response(serialize(updated_rule, request.user))\n    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)",
            "@extend_schema(operation_id='Update an Issue Alert Rule', parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG, IssueAlertParams.ISSUE_RULE_ID], request=ProjectRuleDetailsPutSerializer, responses={200: RuleSerializer, 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND}, examples=IssueAlertExamples.UPDATE_PROJECT_RULE)\n@transaction_start('ProjectRuleDetailsEndpoint')\ndef put(self, request: Request, project, rule) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Updates an issue alert rule.\\n        > Warning: Calling this endpoint fully overwrites the specified issue alert.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers - specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters - help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions - specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    serializer = DrfRuleSerializer(context={'project': project, 'organization': project.organization}, data=request.data, partial=True)\n    if serializer.is_valid():\n        data = serializer.validated_data\n        explicit_opt_out = request.data.get('optOutExplicit')\n        edit_opt_out = request.data.get('optOutEdit')\n        if explicit_opt_out or edit_opt_out:\n            try:\n                neglected_rule = NeglectedRule.objects.get(rule=rule.id, organization=project.organization, opted_out=False)\n                neglected_rule.opted_out = True\n                neglected_rule.save()\n                analytics_data = {'rule_id': rule.id, 'user_id': request.user.id, 'organization_id': project.organization.id}\n                if explicit_opt_out:\n                    analytics.record('rule_disable_opt_out.explicit', **analytics_data)\n                if edit_opt_out:\n                    analytics.record('rule_disable_opt_out.edit', **analytics_data)\n            except NeglectedRule.DoesNotExist:\n                pass\n            except NeglectedRule.MultipleObjectsReturned:\n                logger.info('rule_disable_opt_out.multiple', extra={'rule_id': rule.id, 'org_id': project.organization.id})\n        if not data.get('actions', []):\n            return Response({'actions': ['You must add an action for this alert to fire.']}, status=status.HTTP_400_BAD_REQUEST)\n        conditions = data.get('conditions', [])\n        if 'filters' in data:\n            conditions.extend(data['filters'])\n        kwargs = {'name': data['name'], 'environment': data.get('environment'), 'project': project, 'action_match': data['actionMatch'], 'filter_match': data.get('filterMatch'), 'conditions': conditions, 'actions': data['actions'], 'frequency': data.get('frequency')}\n        duplicate_rule = find_duplicate_rule(project=project, rule_data=kwargs, rule_id=rule.id)\n        if duplicate_rule:\n            return Response({'name': [f\"This rule is an exact duplicate of '{duplicate_rule.label}' in this project and may not be created.\"], 'ruleId': [duplicate_rule.id]}, status=status.HTTP_400_BAD_REQUEST)\n        owner = data.get('owner')\n        if owner:\n            try:\n                kwargs['owner'] = owner.resolve_to_actor().id\n            except (User.DoesNotExist, Team.DoesNotExist):\n                return Response('Could not resolve owner', status=status.HTTP_400_BAD_REQUEST)\n        if rule.status == ObjectStatus.DISABLED:\n            rule.status = ObjectStatus.ACTIVE\n            rule.save()\n            analytics.record('rule_reenable.edit', rule_id=rule.id, user_id=request.user.id, organization_id=project.organization.id)\n        if data.get('pending_save'):\n            client = RedisRuleStatus()\n            kwargs.update({'uuid': client.uuid, 'rule_id': rule.id})\n            find_channel_id_for_rule.apply_async(kwargs=kwargs)\n            context = {'uuid': client.uuid}\n            return Response(context, status=202)\n        trigger_sentry_app_action_creators_for_issues(actions=kwargs.get('actions'))\n        updated_rule = Updater.run(rule=rule, request=request, **kwargs)\n        RuleActivity.objects.create(rule=updated_rule, user_id=request.user.id, type=RuleActivityType.UPDATED.value)\n        self.create_audit_entry(request=request, organization=project.organization, target_object=updated_rule.id, event=audit_log.get_event_id('RULE_EDIT'), data=updated_rule.get_audit_log_data())\n        alert_rule_edited.send_robust(user=request.user, project=project, rule=rule, rule_type='issue', sender=self, is_api_token=request.auth is not None)\n        return Response(serialize(updated_rule, request.user))\n    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)",
            "@extend_schema(operation_id='Update an Issue Alert Rule', parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG, IssueAlertParams.ISSUE_RULE_ID], request=ProjectRuleDetailsPutSerializer, responses={200: RuleSerializer, 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND}, examples=IssueAlertExamples.UPDATE_PROJECT_RULE)\n@transaction_start('ProjectRuleDetailsEndpoint')\ndef put(self, request: Request, project, rule) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Updates an issue alert rule.\\n        > Warning: Calling this endpoint fully overwrites the specified issue alert.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers - specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters - help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions - specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    serializer = DrfRuleSerializer(context={'project': project, 'organization': project.organization}, data=request.data, partial=True)\n    if serializer.is_valid():\n        data = serializer.validated_data\n        explicit_opt_out = request.data.get('optOutExplicit')\n        edit_opt_out = request.data.get('optOutEdit')\n        if explicit_opt_out or edit_opt_out:\n            try:\n                neglected_rule = NeglectedRule.objects.get(rule=rule.id, organization=project.organization, opted_out=False)\n                neglected_rule.opted_out = True\n                neglected_rule.save()\n                analytics_data = {'rule_id': rule.id, 'user_id': request.user.id, 'organization_id': project.organization.id}\n                if explicit_opt_out:\n                    analytics.record('rule_disable_opt_out.explicit', **analytics_data)\n                if edit_opt_out:\n                    analytics.record('rule_disable_opt_out.edit', **analytics_data)\n            except NeglectedRule.DoesNotExist:\n                pass\n            except NeglectedRule.MultipleObjectsReturned:\n                logger.info('rule_disable_opt_out.multiple', extra={'rule_id': rule.id, 'org_id': project.organization.id})\n        if not data.get('actions', []):\n            return Response({'actions': ['You must add an action for this alert to fire.']}, status=status.HTTP_400_BAD_REQUEST)\n        conditions = data.get('conditions', [])\n        if 'filters' in data:\n            conditions.extend(data['filters'])\n        kwargs = {'name': data['name'], 'environment': data.get('environment'), 'project': project, 'action_match': data['actionMatch'], 'filter_match': data.get('filterMatch'), 'conditions': conditions, 'actions': data['actions'], 'frequency': data.get('frequency')}\n        duplicate_rule = find_duplicate_rule(project=project, rule_data=kwargs, rule_id=rule.id)\n        if duplicate_rule:\n            return Response({'name': [f\"This rule is an exact duplicate of '{duplicate_rule.label}' in this project and may not be created.\"], 'ruleId': [duplicate_rule.id]}, status=status.HTTP_400_BAD_REQUEST)\n        owner = data.get('owner')\n        if owner:\n            try:\n                kwargs['owner'] = owner.resolve_to_actor().id\n            except (User.DoesNotExist, Team.DoesNotExist):\n                return Response('Could not resolve owner', status=status.HTTP_400_BAD_REQUEST)\n        if rule.status == ObjectStatus.DISABLED:\n            rule.status = ObjectStatus.ACTIVE\n            rule.save()\n            analytics.record('rule_reenable.edit', rule_id=rule.id, user_id=request.user.id, organization_id=project.organization.id)\n        if data.get('pending_save'):\n            client = RedisRuleStatus()\n            kwargs.update({'uuid': client.uuid, 'rule_id': rule.id})\n            find_channel_id_for_rule.apply_async(kwargs=kwargs)\n            context = {'uuid': client.uuid}\n            return Response(context, status=202)\n        trigger_sentry_app_action_creators_for_issues(actions=kwargs.get('actions'))\n        updated_rule = Updater.run(rule=rule, request=request, **kwargs)\n        RuleActivity.objects.create(rule=updated_rule, user_id=request.user.id, type=RuleActivityType.UPDATED.value)\n        self.create_audit_entry(request=request, organization=project.organization, target_object=updated_rule.id, event=audit_log.get_event_id('RULE_EDIT'), data=updated_rule.get_audit_log_data())\n        alert_rule_edited.send_robust(user=request.user, project=project, rule=rule, rule_type='issue', sender=self, is_api_token=request.auth is not None)\n        return Response(serialize(updated_rule, request.user))\n    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)"
        ]
    },
    {
        "func_name": "delete",
        "original": "@extend_schema(operation_id='Delete an Issue Alert Rule', parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG, IssueAlertParams.ISSUE_RULE_ID], responses={202: RESPONSE_ACCEPTED, 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND})\n@transaction_start('ProjectRuleDetailsEndpoint')\ndef delete(self, request: Request, project, rule) -> Response:\n    \"\"\"\n        Delete a specific issue alert rule.\n\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\n        - Triggers: specify what type of activity you'd like monitored or when an alert should be triggered.\n        - Filters: help control noise by triggering an alert only if the issue matches the specified criteria.\n        - Actions: specify what should happen when the trigger conditions are met and the filters match.\n        \"\"\"\n    rule.update(status=ObjectStatus.PENDING_DELETION)\n    RuleActivity.objects.create(rule=rule, user_id=request.user.id, type=RuleActivityType.DELETED.value)\n    scheduled = RegionScheduledDeletion.schedule(rule, days=0, actor=request.user)\n    self.create_audit_entry(request=request, organization=project.organization, target_object=rule.id, event=audit_log.get_event_id('RULE_REMOVE'), data=rule.get_audit_log_data(), transaction_id=scheduled.id)\n    return Response(status=202)",
        "mutated": [
            "@extend_schema(operation_id='Delete an Issue Alert Rule', parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG, IssueAlertParams.ISSUE_RULE_ID], responses={202: RESPONSE_ACCEPTED, 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND})\n@transaction_start('ProjectRuleDetailsEndpoint')\ndef delete(self, request: Request, project, rule) -> Response:\n    if False:\n        i = 10\n    \"\\n        Delete a specific issue alert rule.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers: specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters: help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions: specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    rule.update(status=ObjectStatus.PENDING_DELETION)\n    RuleActivity.objects.create(rule=rule, user_id=request.user.id, type=RuleActivityType.DELETED.value)\n    scheduled = RegionScheduledDeletion.schedule(rule, days=0, actor=request.user)\n    self.create_audit_entry(request=request, organization=project.organization, target_object=rule.id, event=audit_log.get_event_id('RULE_REMOVE'), data=rule.get_audit_log_data(), transaction_id=scheduled.id)\n    return Response(status=202)",
            "@extend_schema(operation_id='Delete an Issue Alert Rule', parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG, IssueAlertParams.ISSUE_RULE_ID], responses={202: RESPONSE_ACCEPTED, 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND})\n@transaction_start('ProjectRuleDetailsEndpoint')\ndef delete(self, request: Request, project, rule) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Delete a specific issue alert rule.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers: specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters: help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions: specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    rule.update(status=ObjectStatus.PENDING_DELETION)\n    RuleActivity.objects.create(rule=rule, user_id=request.user.id, type=RuleActivityType.DELETED.value)\n    scheduled = RegionScheduledDeletion.schedule(rule, days=0, actor=request.user)\n    self.create_audit_entry(request=request, organization=project.organization, target_object=rule.id, event=audit_log.get_event_id('RULE_REMOVE'), data=rule.get_audit_log_data(), transaction_id=scheduled.id)\n    return Response(status=202)",
            "@extend_schema(operation_id='Delete an Issue Alert Rule', parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG, IssueAlertParams.ISSUE_RULE_ID], responses={202: RESPONSE_ACCEPTED, 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND})\n@transaction_start('ProjectRuleDetailsEndpoint')\ndef delete(self, request: Request, project, rule) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Delete a specific issue alert rule.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers: specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters: help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions: specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    rule.update(status=ObjectStatus.PENDING_DELETION)\n    RuleActivity.objects.create(rule=rule, user_id=request.user.id, type=RuleActivityType.DELETED.value)\n    scheduled = RegionScheduledDeletion.schedule(rule, days=0, actor=request.user)\n    self.create_audit_entry(request=request, organization=project.organization, target_object=rule.id, event=audit_log.get_event_id('RULE_REMOVE'), data=rule.get_audit_log_data(), transaction_id=scheduled.id)\n    return Response(status=202)",
            "@extend_schema(operation_id='Delete an Issue Alert Rule', parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG, IssueAlertParams.ISSUE_RULE_ID], responses={202: RESPONSE_ACCEPTED, 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND})\n@transaction_start('ProjectRuleDetailsEndpoint')\ndef delete(self, request: Request, project, rule) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Delete a specific issue alert rule.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers: specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters: help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions: specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    rule.update(status=ObjectStatus.PENDING_DELETION)\n    RuleActivity.objects.create(rule=rule, user_id=request.user.id, type=RuleActivityType.DELETED.value)\n    scheduled = RegionScheduledDeletion.schedule(rule, days=0, actor=request.user)\n    self.create_audit_entry(request=request, organization=project.organization, target_object=rule.id, event=audit_log.get_event_id('RULE_REMOVE'), data=rule.get_audit_log_data(), transaction_id=scheduled.id)\n    return Response(status=202)",
            "@extend_schema(operation_id='Delete an Issue Alert Rule', parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG, IssueAlertParams.ISSUE_RULE_ID], responses={202: RESPONSE_ACCEPTED, 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND})\n@transaction_start('ProjectRuleDetailsEndpoint')\ndef delete(self, request: Request, project, rule) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Delete a specific issue alert rule.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers: specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters: help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions: specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    rule.update(status=ObjectStatus.PENDING_DELETION)\n    RuleActivity.objects.create(rule=rule, user_id=request.user.id, type=RuleActivityType.DELETED.value)\n    scheduled = RegionScheduledDeletion.schedule(rule, days=0, actor=request.user)\n    self.create_audit_entry(request=request, organization=project.organization, target_object=rule.id, event=audit_log.get_event_id('RULE_REMOVE'), data=rule.get_audit_log_data(), transaction_id=scheduled.id)\n    return Response(status=202)"
        ]
    }
]