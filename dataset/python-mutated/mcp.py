from ._mcp import MCP, MCP_Geometric, MCP_Connect, MCP_Flexible

def route_through_array(array, start, end, fully_connected=True, geometric=True):
    if False:
        i = 10
        return i + 15
    'Simple example of how to use the MCP and MCP_Geometric classes.\n\n    See the MCP and MCP_Geometric class documentation for explanation of the\n    path-finding algorithm.\n\n    Parameters\n    ----------\n    array : ndarray\n        Array of costs.\n    start : iterable\n        n-d index into `array` defining the starting point\n    end : iterable\n        n-d index into `array` defining the end point\n    fully_connected : bool (optional)\n        If True, diagonal moves are permitted, if False, only axial moves.\n    geometric : bool (optional)\n        If True, the MCP_Geometric class is used to calculate costs, if False,\n        the MCP base class is used. See the class documentation for\n        an explanation of the differences between MCP and MCP_Geometric.\n\n    Returns\n    -------\n    path : list\n        List of n-d index tuples defining the path from `start` to `end`.\n    cost : float\n        Cost of the path. If `geometric` is False, the cost of the path is\n        the sum of the values of `array` along the path. If `geometric` is\n        True, a finer computation is made (see the documentation of the\n        MCP_Geometric class).\n\n    See Also\n    --------\n    MCP, MCP_Geometric\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from skimage.graph import route_through_array\n    >>>\n    >>> image = np.array([[1, 3], [10, 12]])\n    >>> image\n    array([[ 1,  3],\n           [10, 12]])\n    >>> # Forbid diagonal steps\n    >>> route_through_array(image, [0, 0], [1, 1], fully_connected=False)\n    ([(0, 0), (0, 1), (1, 1)], 9.5)\n    >>> # Now allow diagonal steps: the path goes directly from start to end\n    >>> route_through_array(image, [0, 0], [1, 1])\n    ([(0, 0), (1, 1)], 9.19238815542512)\n    >>> # Cost is the sum of array values along the path (16 = 1 + 3 + 12)\n    >>> route_through_array(image, [0, 0], [1, 1], fully_connected=False,\n    ... geometric=False)\n    ([(0, 0), (0, 1), (1, 1)], 16.0)\n    >>> # Larger array where we display the path that is selected\n    >>> image = np.arange((36)).reshape((6, 6))\n    >>> image\n    array([[ 0,  1,  2,  3,  4,  5],\n           [ 6,  7,  8,  9, 10, 11],\n           [12, 13, 14, 15, 16, 17],\n           [18, 19, 20, 21, 22, 23],\n           [24, 25, 26, 27, 28, 29],\n           [30, 31, 32, 33, 34, 35]])\n    >>> # Find the path with lowest cost\n    >>> indices, weight = route_through_array(image, (0, 0), (5, 5))\n    >>> indices = np.stack(indices, axis=-1)\n    >>> path = np.zeros_like(image)\n    >>> path[indices[0], indices[1]] = 1\n    >>> path\n    array([[1, 1, 1, 1, 1, 0],\n           [0, 0, 0, 0, 0, 1],\n           [0, 0, 0, 0, 0, 1],\n           [0, 0, 0, 0, 0, 1],\n           [0, 0, 0, 0, 0, 1],\n           [0, 0, 0, 0, 0, 1]])\n\n    '
    (start, end) = (tuple(start), tuple(end))
    if geometric:
        mcp_class = MCP_Geometric
    else:
        mcp_class = MCP
    m = mcp_class(array, fully_connected=fully_connected)
    (costs, traceback_array) = m.find_costs([start], [end])
    return (m.traceback(end), costs[end])