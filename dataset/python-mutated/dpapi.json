[
    {
        "func_name": "__init__",
        "original": "def __init__(self, options):\n    self.options = options\n    self.dpapiSystem = {}\n    pass",
        "mutated": [
            "def __init__(self, options):\n    if False:\n        i = 10\n    self.options = options\n    self.dpapiSystem = {}\n    pass",
            "def __init__(self, options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.options = options\n    self.dpapiSystem = {}\n    pass",
            "def __init__(self, options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.options = options\n    self.dpapiSystem = {}\n    pass",
            "def __init__(self, options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.options = options\n    self.dpapiSystem = {}\n    pass",
            "def __init__(self, options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.options = options\n    self.dpapiSystem = {}\n    pass"
        ]
    },
    {
        "func_name": "getDPAPI_SYSTEM",
        "original": "def getDPAPI_SYSTEM(self, secretType, secret):\n    if secret.startswith('dpapi_machinekey:'):\n        (machineKey, userKey) = secret.split('\\n')\n        machineKey = machineKey.split(':')[1]\n        userKey = userKey.split(':')[1]\n        self.dpapiSystem['MachineKey'] = unhexlify(machineKey[2:])\n        self.dpapiSystem['UserKey'] = unhexlify(userKey[2:])",
        "mutated": [
            "def getDPAPI_SYSTEM(self, secretType, secret):\n    if False:\n        i = 10\n    if secret.startswith('dpapi_machinekey:'):\n        (machineKey, userKey) = secret.split('\\n')\n        machineKey = machineKey.split(':')[1]\n        userKey = userKey.split(':')[1]\n        self.dpapiSystem['MachineKey'] = unhexlify(machineKey[2:])\n        self.dpapiSystem['UserKey'] = unhexlify(userKey[2:])",
            "def getDPAPI_SYSTEM(self, secretType, secret):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if secret.startswith('dpapi_machinekey:'):\n        (machineKey, userKey) = secret.split('\\n')\n        machineKey = machineKey.split(':')[1]\n        userKey = userKey.split(':')[1]\n        self.dpapiSystem['MachineKey'] = unhexlify(machineKey[2:])\n        self.dpapiSystem['UserKey'] = unhexlify(userKey[2:])",
            "def getDPAPI_SYSTEM(self, secretType, secret):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if secret.startswith('dpapi_machinekey:'):\n        (machineKey, userKey) = secret.split('\\n')\n        machineKey = machineKey.split(':')[1]\n        userKey = userKey.split(':')[1]\n        self.dpapiSystem['MachineKey'] = unhexlify(machineKey[2:])\n        self.dpapiSystem['UserKey'] = unhexlify(userKey[2:])",
            "def getDPAPI_SYSTEM(self, secretType, secret):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if secret.startswith('dpapi_machinekey:'):\n        (machineKey, userKey) = secret.split('\\n')\n        machineKey = machineKey.split(':')[1]\n        userKey = userKey.split(':')[1]\n        self.dpapiSystem['MachineKey'] = unhexlify(machineKey[2:])\n        self.dpapiSystem['UserKey'] = unhexlify(userKey[2:])",
            "def getDPAPI_SYSTEM(self, secretType, secret):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if secret.startswith('dpapi_machinekey:'):\n        (machineKey, userKey) = secret.split('\\n')\n        machineKey = machineKey.split(':')[1]\n        userKey = userKey.split(':')[1]\n        self.dpapiSystem['MachineKey'] = unhexlify(machineKey[2:])\n        self.dpapiSystem['UserKey'] = unhexlify(userKey[2:])"
        ]
    },
    {
        "func_name": "getLSA",
        "original": "def getLSA(self):\n    localOperations = LocalOperations(self.options.system)\n    bootKey = localOperations.getBootKey()\n    lsaSecrets = LSASecrets(self.options.security, bootKey, None, isRemote=False, history=False, perSecretCallback=self.getDPAPI_SYSTEM)\n    lsaSecrets.dumpSecrets()\n    if 'MachineKey' not in self.dpapiSystem or 'UserKey' not in self.dpapiSystem:\n        logging.error('Cannot grab MachineKey/UserKey from LSA, aborting...')\n        sys.exit(1)",
        "mutated": [
            "def getLSA(self):\n    if False:\n        i = 10\n    localOperations = LocalOperations(self.options.system)\n    bootKey = localOperations.getBootKey()\n    lsaSecrets = LSASecrets(self.options.security, bootKey, None, isRemote=False, history=False, perSecretCallback=self.getDPAPI_SYSTEM)\n    lsaSecrets.dumpSecrets()\n    if 'MachineKey' not in self.dpapiSystem or 'UserKey' not in self.dpapiSystem:\n        logging.error('Cannot grab MachineKey/UserKey from LSA, aborting...')\n        sys.exit(1)",
            "def getLSA(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    localOperations = LocalOperations(self.options.system)\n    bootKey = localOperations.getBootKey()\n    lsaSecrets = LSASecrets(self.options.security, bootKey, None, isRemote=False, history=False, perSecretCallback=self.getDPAPI_SYSTEM)\n    lsaSecrets.dumpSecrets()\n    if 'MachineKey' not in self.dpapiSystem or 'UserKey' not in self.dpapiSystem:\n        logging.error('Cannot grab MachineKey/UserKey from LSA, aborting...')\n        sys.exit(1)",
            "def getLSA(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    localOperations = LocalOperations(self.options.system)\n    bootKey = localOperations.getBootKey()\n    lsaSecrets = LSASecrets(self.options.security, bootKey, None, isRemote=False, history=False, perSecretCallback=self.getDPAPI_SYSTEM)\n    lsaSecrets.dumpSecrets()\n    if 'MachineKey' not in self.dpapiSystem or 'UserKey' not in self.dpapiSystem:\n        logging.error('Cannot grab MachineKey/UserKey from LSA, aborting...')\n        sys.exit(1)",
            "def getLSA(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    localOperations = LocalOperations(self.options.system)\n    bootKey = localOperations.getBootKey()\n    lsaSecrets = LSASecrets(self.options.security, bootKey, None, isRemote=False, history=False, perSecretCallback=self.getDPAPI_SYSTEM)\n    lsaSecrets.dumpSecrets()\n    if 'MachineKey' not in self.dpapiSystem or 'UserKey' not in self.dpapiSystem:\n        logging.error('Cannot grab MachineKey/UserKey from LSA, aborting...')\n        sys.exit(1)",
            "def getLSA(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    localOperations = LocalOperations(self.options.system)\n    bootKey = localOperations.getBootKey()\n    lsaSecrets = LSASecrets(self.options.security, bootKey, None, isRemote=False, history=False, perSecretCallback=self.getDPAPI_SYSTEM)\n    lsaSecrets.dumpSecrets()\n    if 'MachineKey' not in self.dpapiSystem or 'UserKey' not in self.dpapiSystem:\n        logging.error('Cannot grab MachineKey/UserKey from LSA, aborting...')\n        sys.exit(1)"
        ]
    },
    {
        "func_name": "run",
        "original": "def run(self):\n    if self.options.action.upper() == 'MASTERKEY':\n        fp = open(options.file, 'rb')\n        data = fp.read()\n        mkf = MasterKeyFile(data)\n        mkf.dump()\n        data = data[len(mkf):]\n        if mkf['MasterKeyLen'] > 0:\n            mk = MasterKey(data[:mkf['MasterKeyLen']])\n            data = data[len(mk):]\n        if mkf['BackupKeyLen'] > 0:\n            bkmk = MasterKey(data[:mkf['BackupKeyLen']])\n            data = data[len(bkmk):]\n        if mkf['CredHistLen'] > 0:\n            ch = CredHist(data[:mkf['CredHistLen']])\n            data = data[len(ch):]\n        if mkf['DomainKeyLen'] > 0:\n            dk = DomainKey(data[:mkf['DomainKeyLen']])\n            data = data[len(dk):]\n        if self.options.system and self.options.security and (self.options.sid is None):\n            self.getLSA()\n            decryptedKey = mk.decrypt(self.dpapiSystem['UserKey'])\n            if decryptedKey:\n                print('Decrypted key with UserKey')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(self.dpapiSystem['MachineKey'])\n            if decryptedKey:\n                print('Decrypted key with MachineKey')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(self.dpapiSystem['UserKey'])\n            if decryptedKey:\n                print('Decrypted Backup key with UserKey')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(self.dpapiSystem['MachineKey'])\n            if decryptedKey:\n                print('Decrypted Backup key with MachineKey')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.system and self.options.security:\n            self.getLSA()\n            (key1, key2) = deriveKeysFromUserkey(self.options.sid, self.dpapiSystem['UserKey'])\n            decryptedKey = mk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted key with UserKey + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted Backup key with UserKey + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted key with UserKey + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted Backup key with UserKey + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.key and self.options.sid:\n            key = unhexlify(self.options.key[2:])\n            (key1, key2) = deriveKeysFromUserkey(self.options.sid, key)\n            decryptedKey = mk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted key with key provided + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted key with key provided + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.key:\n            key = unhexlify(self.options.key[2:])\n            decryptedKey = mk.decrypt(key)\n            if decryptedKey:\n                print('Decrypted key with key provided')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.pvk and dk:\n            pvkfile = open(self.options.pvk, 'rb').read()\n            key = PRIVATE_KEY_BLOB(pvkfile[len(PVK_FILE_HDR()):])\n            private = privatekeyblob_to_pkcs1(key)\n            cipher = PKCS1_v1_5.new(private)\n            decryptedKey = cipher.decrypt(dk['SecretData'][::-1], None)\n            if decryptedKey:\n                domain_master_key = DPAPI_DOMAIN_RSA_MASTER_KEY(decryptedKey)\n                key = domain_master_key['buffer'][:domain_master_key['cbMasterKey']]\n                print('Decrypted key with domain backup key provided')\n                print('Decrypted key: 0x%s' % hexlify(key).decode('latin-1'))\n            return\n        elif self.options.sid and self.options.key is None:\n            if self.options.password is None:\n                from getpass import getpass\n                password = getpass('Password:')\n            else:\n                password = options.password\n            (key1, key2, key3) = deriveKeysFromUser(self.options.sid, password)\n            decryptedKey = mk.decrypt(key3)\n            if decryptedKey:\n                print('Decrypted key with User Key (MD4 protected)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted key with User Key (MD4)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted key with User Key (SHA1)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key3)\n            if decryptedKey:\n                print('Decrypted Backup key with User Key (MD4 protected)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted Backup key with User Key (MD4)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted Backup key with User Key (SHA1)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.target is not None:\n            (domain, username, password, remoteName) = parse_target(self.options.target)\n            if domain is None:\n                domain = ''\n            if password == '' and username != '' and (self.options.hashes is None) and (self.options.no_pass is False) and (self.options.aesKey is None):\n                from getpass import getpass\n                password = getpass('Password:')\n            if self.options.hashes is not None:\n                (lmhash, nthash) = self.options.hashes.split(':')\n            else:\n                (lmhash, nthash) = ('', '')\n            rpctransport = transport.DCERPCTransportFactory('ncacn_np:%s[\\\\PIPE\\\\protected_storage]' % remoteName)\n            if hasattr(rpctransport, 'set_credentials'):\n                rpctransport.set_credentials(username, password, domain, lmhash, nthash, self.options.aesKey)\n            rpctransport.set_kerberos(self.options.k, self.options.dc_ip)\n            dce = rpctransport.get_dce_rpc()\n            dce.set_auth_level(RPC_C_AUTHN_LEVEL_PKT_PRIVACY)\n            if self.options.k is True:\n                dce.set_auth_type(RPC_C_AUTHN_GSS_NEGOTIATE)\n            dce.connect()\n            dce.bind(bkrp.MSRPC_UUID_BKRP, transfer_syntax=('8a885d04-1ceb-11c9-9fe8-08002b104860', '2.0'))\n            request = bkrp.BackuprKey()\n            request['pguidActionAgent'] = bkrp.BACKUPKEY_RESTORE_GUID\n            request['pDataIn'] = dk.getData()\n            request['cbDataIn'] = len(dk.getData())\n            request['dwParam'] = 0\n            resp = dce.request(request)\n            beginning = 0\n            for i in range(len(resp['ppDataOut'])):\n                if resp['ppDataOut'][i] == b'\\x00':\n                    beginning += 1\n                else:\n                    break\n            masterkey = b''.join(resp['ppDataOut'][beginning:])\n            print('Decrypted key using rpc call')\n            print('Decrypted key: 0x%s' % hexlify(masterkey).decode())\n            return\n        else:\n            if mkf['MasterKeyLen'] > 0:\n                mk.dump()\n            if mkf['BackupKeyLen'] > 0:\n                bkmk.dump()\n            if mkf['CredHistLen'] > 0:\n                ch.dump()\n            if mkf['DomainKeyLen'] > 0:\n                dk.dump()\n    elif self.options.action.upper() == 'BACKUPKEYS':\n        (domain, username, password, address) = parse_target(self.options.target)\n        if password == '' and username != '' and (self.options.hashes is None) and (self.options.no_pass is False) and (self.options.aesKey is None):\n            from getpass import getpass\n            password = getpass('Password:')\n        if self.options.hashes is not None:\n            (lmhash, nthash) = self.options.hashes.split(':')\n        else:\n            (lmhash, nthash) = ('', '')\n        connection = SMBConnection(address, address)\n        if self.options.k:\n            connection.kerberosLogin(username, password, domain, lmhash, nthash, self.options.aesKey)\n        else:\n            connection.login(username, password, domain, lmhash=lmhash, nthash=nthash)\n        rpctransport = transport.DCERPCTransportFactory('ncacn_np:445[\\\\pipe\\\\lsarpc]')\n        rpctransport.set_smb_connection(connection)\n        dce = rpctransport.get_dce_rpc()\n        if self.options.k:\n            dce.set_auth_type(RPC_C_AUTHN_GSS_NEGOTIATE)\n        try:\n            dce.connect()\n            dce.bind(lsad.MSRPC_UUID_LSAD)\n        except transport.DCERPCException as e:\n            raise e\n        resp = lsad.hLsarOpenPolicy2(dce, lsad.POLICY_GET_PRIVATE_INFORMATION)\n        for keyname in ('G$BCKUPKEY_PREFERRED', 'G$BCKUPKEY_P'):\n            buffer = crypto.decryptSecret(connection.getSessionKey(), lsad.hLsarRetrievePrivateData(dce, resp['PolicyHandle'], keyname))\n            guid = bin_to_string(buffer)\n            name = 'G$BCKUPKEY_{}'.format(guid)\n            secret = crypto.decryptSecret(connection.getSessionKey(), lsad.hLsarRetrievePrivateData(dce, resp['PolicyHandle'], name))\n            keyVersion = struct.unpack('<L', secret[:4])[0]\n            if keyVersion == 1:\n                backup_key = P_BACKUP_KEY(secret)\n                backupkey = backup_key['Data']\n                if self.options.export:\n                    logging.debug('Exporting key to file {}'.format(name + '.key'))\n                    open(name + '.key', 'wb').write(backupkey)\n                else:\n                    print('Legacy key:')\n                    print('0x%s' % hexlify(backupkey).decode('latin-1'))\n                    print('\\n')\n            elif keyVersion == 2:\n                backup_key = PREFERRED_BACKUP_KEY(secret)\n                pvk = backup_key['Data'][:backup_key['KeyLength']]\n                cert = backup_key['Data'][backup_key['KeyLength']:backup_key['KeyLength'] + backup_key['CertificateLength']]\n                header = PVK_FILE_HDR()\n                header['dwMagic'] = 2964713758\n                header['dwVersion'] = 0\n                header['dwKeySpec'] = 1\n                header['dwEncryptType'] = 0\n                header['cbEncryptData'] = 0\n                header['cbPvk'] = backup_key['KeyLength']\n                backupkey_pvk = header.getData() + pvk\n                backupkey = backupkey_pvk\n                if self.options.export:\n                    logging.debug('Exporting certificate to file {}'.format(name + '.der'))\n                    open(name + '.der', 'wb').write(cert)\n                    logging.debug('Exporting private key to file {}'.format(name + '.pvk'))\n                    open(name + '.pvk', 'wb').write(backupkey)\n                else:\n                    print('Preferred key:')\n                    header.dump()\n                    print('PRIVATEKEYBLOB:{%s}' % hexlify(backupkey).decode('latin-1'))\n                    print('\\n')\n        return\n    elif self.options.action.upper() == 'CREDENTIAL':\n        fp = open(options.file, 'rb')\n        data = fp.read()\n        cred = CredentialFile(data)\n        blob = DPAPI_BLOB(cred['Data'])\n        if self.options.key is not None:\n            key = unhexlify(self.options.key[2:])\n            decrypted = blob.decrypt(key)\n            if decrypted is not None:\n                creds = CREDENTIAL_BLOB(decrypted)\n                creds.dump()\n                return\n        else:\n            blob.dump()\n    elif self.options.action.upper() == 'VAULT':\n        if options.vcrd is None and options.vpol is None:\n            print('You must specify either -vcrd or -vpol parameter. Type --help for more info')\n            return\n        if options.vcrd is not None:\n            fp = open(options.vcrd, 'rb')\n            data = fp.read()\n            blob = VAULT_VCRD(data)\n            if self.options.key is not None:\n                key = unhexlify(self.options.key[2:])\n                cleartext = None\n                for (i, entry) in enumerate(blob.attributesLen):\n                    if entry > 28:\n                        attribute = blob.attributes[i]\n                        if 'IV' in attribute.fields and len(attribute['IV']) == 16:\n                            cipher = AES.new(key, AES.MODE_CBC, iv=attribute['IV'])\n                        else:\n                            cipher = AES.new(key, AES.MODE_CBC)\n                        cleartext = cipher.decrypt(attribute['Data'])\n                if cleartext is not None:\n                    if blob['FriendlyName'].decode('utf-16le')[:-1] in VAULT_KNOWN_SCHEMAS:\n                        vault = VAULT_KNOWN_SCHEMAS[blob['FriendlyName'].decode('utf-16le')[:-1]](cleartext)\n                        vault.dump()\n                    else:\n                        hexdump(cleartext)\n                    return\n            else:\n                blob.dump()\n        elif options.vpol is not None:\n            fp = open(options.vpol, 'rb')\n            data = fp.read()\n            vpol = VAULT_VPOL(data)\n            vpol.dump()\n            if self.options.key is not None:\n                key = unhexlify(self.options.key[2:])\n                blob = vpol['Blob']\n                data = blob.decrypt(key)\n                if data is not None:\n                    keys = VAULT_VPOL_KEYS(data)\n                    keys.dump()\n                    return\n    elif self.options.action.upper() == 'UNPROTECT':\n        fp = open(options.file, 'rb')\n        data = fp.read()\n        blob = DPAPI_BLOB(data)\n        if self.options.key is not None:\n            key = unhexlify(self.options.key[2:])\n            if self.options.entropy_file is not None:\n                fp2 = open(self.options.entropy_file, 'rb')\n                entropy = fp2.read()\n                fp2.close()\n            elif self.options.entropy is not None:\n                entropy = b(self.options.entropy)\n            else:\n                entropy = None\n            decrypted = blob.decrypt(key, entropy)\n            if decrypted is not None:\n                print('Successfully decrypted data')\n                hexdump(decrypted)\n                return\n        else:\n            blob.dump()\n    elif self.options.action.upper() == 'CREDHIST':\n        fp = open(self.options.file, 'rb')\n        data = fp.read()\n        chf = CREDHIST_FILE(data)\n        if len(chf.credhist_entries_list) == 0:\n            print('The CREDHIST file is empty')\n            return\n        if self.options.key:\n            key = unhexlify(self.options.key[2:])\n            keys = deriveKeysFromUserkey(chf.credhist_entries_list[0].sid, key)\n        else:\n            if self.options.password is None:\n                from getpass import getpass\n                password = getpass('Password:')\n            else:\n                password = options.password\n            keys = deriveKeysFromUser(chf.credhist_entries_list[0].sid, password)\n        if self.options.entry is None:\n            real_key = None\n            for k in keys:\n                chf.decrypt_entry_by_index(0, k)\n                if chf.credhist_entries_list[0].pwdhash is not None:\n                    real_key = k\n                    break\n            if real_key is None:\n                chf.dump()\n                print()\n                print('Cannot decrypt (wrong key or password)')\n                return\n            else:\n                chf.decrypt(real_key)\n                chf.dump()\n                if chf.credhist_entries_list[-1].pwdhash is not None:\n                    return\n        else:\n            for k in keys:\n                chf.decrypt_entry_by_index(self.options.entry, k)\n                if chf.credhist_entries_list[self.options.entry].pwdhash is not None:\n                    chf.credhist_entries_list[self.options.entry].dump()\n                    return\n            chf.credhist_entries_list[self.options.entry].dump()\n            print()\n            print('Cannot decrypt (wrong key or password)')\n            return\n    print('Cannot decrypt (specify -key or -sid whenever applicable) ')",
        "mutated": [
            "def run(self):\n    if False:\n        i = 10\n    if self.options.action.upper() == 'MASTERKEY':\n        fp = open(options.file, 'rb')\n        data = fp.read()\n        mkf = MasterKeyFile(data)\n        mkf.dump()\n        data = data[len(mkf):]\n        if mkf['MasterKeyLen'] > 0:\n            mk = MasterKey(data[:mkf['MasterKeyLen']])\n            data = data[len(mk):]\n        if mkf['BackupKeyLen'] > 0:\n            bkmk = MasterKey(data[:mkf['BackupKeyLen']])\n            data = data[len(bkmk):]\n        if mkf['CredHistLen'] > 0:\n            ch = CredHist(data[:mkf['CredHistLen']])\n            data = data[len(ch):]\n        if mkf['DomainKeyLen'] > 0:\n            dk = DomainKey(data[:mkf['DomainKeyLen']])\n            data = data[len(dk):]\n        if self.options.system and self.options.security and (self.options.sid is None):\n            self.getLSA()\n            decryptedKey = mk.decrypt(self.dpapiSystem['UserKey'])\n            if decryptedKey:\n                print('Decrypted key with UserKey')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(self.dpapiSystem['MachineKey'])\n            if decryptedKey:\n                print('Decrypted key with MachineKey')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(self.dpapiSystem['UserKey'])\n            if decryptedKey:\n                print('Decrypted Backup key with UserKey')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(self.dpapiSystem['MachineKey'])\n            if decryptedKey:\n                print('Decrypted Backup key with MachineKey')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.system and self.options.security:\n            self.getLSA()\n            (key1, key2) = deriveKeysFromUserkey(self.options.sid, self.dpapiSystem['UserKey'])\n            decryptedKey = mk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted key with UserKey + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted Backup key with UserKey + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted key with UserKey + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted Backup key with UserKey + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.key and self.options.sid:\n            key = unhexlify(self.options.key[2:])\n            (key1, key2) = deriveKeysFromUserkey(self.options.sid, key)\n            decryptedKey = mk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted key with key provided + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted key with key provided + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.key:\n            key = unhexlify(self.options.key[2:])\n            decryptedKey = mk.decrypt(key)\n            if decryptedKey:\n                print('Decrypted key with key provided')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.pvk and dk:\n            pvkfile = open(self.options.pvk, 'rb').read()\n            key = PRIVATE_KEY_BLOB(pvkfile[len(PVK_FILE_HDR()):])\n            private = privatekeyblob_to_pkcs1(key)\n            cipher = PKCS1_v1_5.new(private)\n            decryptedKey = cipher.decrypt(dk['SecretData'][::-1], None)\n            if decryptedKey:\n                domain_master_key = DPAPI_DOMAIN_RSA_MASTER_KEY(decryptedKey)\n                key = domain_master_key['buffer'][:domain_master_key['cbMasterKey']]\n                print('Decrypted key with domain backup key provided')\n                print('Decrypted key: 0x%s' % hexlify(key).decode('latin-1'))\n            return\n        elif self.options.sid and self.options.key is None:\n            if self.options.password is None:\n                from getpass import getpass\n                password = getpass('Password:')\n            else:\n                password = options.password\n            (key1, key2, key3) = deriveKeysFromUser(self.options.sid, password)\n            decryptedKey = mk.decrypt(key3)\n            if decryptedKey:\n                print('Decrypted key with User Key (MD4 protected)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted key with User Key (MD4)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted key with User Key (SHA1)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key3)\n            if decryptedKey:\n                print('Decrypted Backup key with User Key (MD4 protected)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted Backup key with User Key (MD4)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted Backup key with User Key (SHA1)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.target is not None:\n            (domain, username, password, remoteName) = parse_target(self.options.target)\n            if domain is None:\n                domain = ''\n            if password == '' and username != '' and (self.options.hashes is None) and (self.options.no_pass is False) and (self.options.aesKey is None):\n                from getpass import getpass\n                password = getpass('Password:')\n            if self.options.hashes is not None:\n                (lmhash, nthash) = self.options.hashes.split(':')\n            else:\n                (lmhash, nthash) = ('', '')\n            rpctransport = transport.DCERPCTransportFactory('ncacn_np:%s[\\\\PIPE\\\\protected_storage]' % remoteName)\n            if hasattr(rpctransport, 'set_credentials'):\n                rpctransport.set_credentials(username, password, domain, lmhash, nthash, self.options.aesKey)\n            rpctransport.set_kerberos(self.options.k, self.options.dc_ip)\n            dce = rpctransport.get_dce_rpc()\n            dce.set_auth_level(RPC_C_AUTHN_LEVEL_PKT_PRIVACY)\n            if self.options.k is True:\n                dce.set_auth_type(RPC_C_AUTHN_GSS_NEGOTIATE)\n            dce.connect()\n            dce.bind(bkrp.MSRPC_UUID_BKRP, transfer_syntax=('8a885d04-1ceb-11c9-9fe8-08002b104860', '2.0'))\n            request = bkrp.BackuprKey()\n            request['pguidActionAgent'] = bkrp.BACKUPKEY_RESTORE_GUID\n            request['pDataIn'] = dk.getData()\n            request['cbDataIn'] = len(dk.getData())\n            request['dwParam'] = 0\n            resp = dce.request(request)\n            beginning = 0\n            for i in range(len(resp['ppDataOut'])):\n                if resp['ppDataOut'][i] == b'\\x00':\n                    beginning += 1\n                else:\n                    break\n            masterkey = b''.join(resp['ppDataOut'][beginning:])\n            print('Decrypted key using rpc call')\n            print('Decrypted key: 0x%s' % hexlify(masterkey).decode())\n            return\n        else:\n            if mkf['MasterKeyLen'] > 0:\n                mk.dump()\n            if mkf['BackupKeyLen'] > 0:\n                bkmk.dump()\n            if mkf['CredHistLen'] > 0:\n                ch.dump()\n            if mkf['DomainKeyLen'] > 0:\n                dk.dump()\n    elif self.options.action.upper() == 'BACKUPKEYS':\n        (domain, username, password, address) = parse_target(self.options.target)\n        if password == '' and username != '' and (self.options.hashes is None) and (self.options.no_pass is False) and (self.options.aesKey is None):\n            from getpass import getpass\n            password = getpass('Password:')\n        if self.options.hashes is not None:\n            (lmhash, nthash) = self.options.hashes.split(':')\n        else:\n            (lmhash, nthash) = ('', '')\n        connection = SMBConnection(address, address)\n        if self.options.k:\n            connection.kerberosLogin(username, password, domain, lmhash, nthash, self.options.aesKey)\n        else:\n            connection.login(username, password, domain, lmhash=lmhash, nthash=nthash)\n        rpctransport = transport.DCERPCTransportFactory('ncacn_np:445[\\\\pipe\\\\lsarpc]')\n        rpctransport.set_smb_connection(connection)\n        dce = rpctransport.get_dce_rpc()\n        if self.options.k:\n            dce.set_auth_type(RPC_C_AUTHN_GSS_NEGOTIATE)\n        try:\n            dce.connect()\n            dce.bind(lsad.MSRPC_UUID_LSAD)\n        except transport.DCERPCException as e:\n            raise e\n        resp = lsad.hLsarOpenPolicy2(dce, lsad.POLICY_GET_PRIVATE_INFORMATION)\n        for keyname in ('G$BCKUPKEY_PREFERRED', 'G$BCKUPKEY_P'):\n            buffer = crypto.decryptSecret(connection.getSessionKey(), lsad.hLsarRetrievePrivateData(dce, resp['PolicyHandle'], keyname))\n            guid = bin_to_string(buffer)\n            name = 'G$BCKUPKEY_{}'.format(guid)\n            secret = crypto.decryptSecret(connection.getSessionKey(), lsad.hLsarRetrievePrivateData(dce, resp['PolicyHandle'], name))\n            keyVersion = struct.unpack('<L', secret[:4])[0]\n            if keyVersion == 1:\n                backup_key = P_BACKUP_KEY(secret)\n                backupkey = backup_key['Data']\n                if self.options.export:\n                    logging.debug('Exporting key to file {}'.format(name + '.key'))\n                    open(name + '.key', 'wb').write(backupkey)\n                else:\n                    print('Legacy key:')\n                    print('0x%s' % hexlify(backupkey).decode('latin-1'))\n                    print('\\n')\n            elif keyVersion == 2:\n                backup_key = PREFERRED_BACKUP_KEY(secret)\n                pvk = backup_key['Data'][:backup_key['KeyLength']]\n                cert = backup_key['Data'][backup_key['KeyLength']:backup_key['KeyLength'] + backup_key['CertificateLength']]\n                header = PVK_FILE_HDR()\n                header['dwMagic'] = 2964713758\n                header['dwVersion'] = 0\n                header['dwKeySpec'] = 1\n                header['dwEncryptType'] = 0\n                header['cbEncryptData'] = 0\n                header['cbPvk'] = backup_key['KeyLength']\n                backupkey_pvk = header.getData() + pvk\n                backupkey = backupkey_pvk\n                if self.options.export:\n                    logging.debug('Exporting certificate to file {}'.format(name + '.der'))\n                    open(name + '.der', 'wb').write(cert)\n                    logging.debug('Exporting private key to file {}'.format(name + '.pvk'))\n                    open(name + '.pvk', 'wb').write(backupkey)\n                else:\n                    print('Preferred key:')\n                    header.dump()\n                    print('PRIVATEKEYBLOB:{%s}' % hexlify(backupkey).decode('latin-1'))\n                    print('\\n')\n        return\n    elif self.options.action.upper() == 'CREDENTIAL':\n        fp = open(options.file, 'rb')\n        data = fp.read()\n        cred = CredentialFile(data)\n        blob = DPAPI_BLOB(cred['Data'])\n        if self.options.key is not None:\n            key = unhexlify(self.options.key[2:])\n            decrypted = blob.decrypt(key)\n            if decrypted is not None:\n                creds = CREDENTIAL_BLOB(decrypted)\n                creds.dump()\n                return\n        else:\n            blob.dump()\n    elif self.options.action.upper() == 'VAULT':\n        if options.vcrd is None and options.vpol is None:\n            print('You must specify either -vcrd or -vpol parameter. Type --help for more info')\n            return\n        if options.vcrd is not None:\n            fp = open(options.vcrd, 'rb')\n            data = fp.read()\n            blob = VAULT_VCRD(data)\n            if self.options.key is not None:\n                key = unhexlify(self.options.key[2:])\n                cleartext = None\n                for (i, entry) in enumerate(blob.attributesLen):\n                    if entry > 28:\n                        attribute = blob.attributes[i]\n                        if 'IV' in attribute.fields and len(attribute['IV']) == 16:\n                            cipher = AES.new(key, AES.MODE_CBC, iv=attribute['IV'])\n                        else:\n                            cipher = AES.new(key, AES.MODE_CBC)\n                        cleartext = cipher.decrypt(attribute['Data'])\n                if cleartext is not None:\n                    if blob['FriendlyName'].decode('utf-16le')[:-1] in VAULT_KNOWN_SCHEMAS:\n                        vault = VAULT_KNOWN_SCHEMAS[blob['FriendlyName'].decode('utf-16le')[:-1]](cleartext)\n                        vault.dump()\n                    else:\n                        hexdump(cleartext)\n                    return\n            else:\n                blob.dump()\n        elif options.vpol is not None:\n            fp = open(options.vpol, 'rb')\n            data = fp.read()\n            vpol = VAULT_VPOL(data)\n            vpol.dump()\n            if self.options.key is not None:\n                key = unhexlify(self.options.key[2:])\n                blob = vpol['Blob']\n                data = blob.decrypt(key)\n                if data is not None:\n                    keys = VAULT_VPOL_KEYS(data)\n                    keys.dump()\n                    return\n    elif self.options.action.upper() == 'UNPROTECT':\n        fp = open(options.file, 'rb')\n        data = fp.read()\n        blob = DPAPI_BLOB(data)\n        if self.options.key is not None:\n            key = unhexlify(self.options.key[2:])\n            if self.options.entropy_file is not None:\n                fp2 = open(self.options.entropy_file, 'rb')\n                entropy = fp2.read()\n                fp2.close()\n            elif self.options.entropy is not None:\n                entropy = b(self.options.entropy)\n            else:\n                entropy = None\n            decrypted = blob.decrypt(key, entropy)\n            if decrypted is not None:\n                print('Successfully decrypted data')\n                hexdump(decrypted)\n                return\n        else:\n            blob.dump()\n    elif self.options.action.upper() == 'CREDHIST':\n        fp = open(self.options.file, 'rb')\n        data = fp.read()\n        chf = CREDHIST_FILE(data)\n        if len(chf.credhist_entries_list) == 0:\n            print('The CREDHIST file is empty')\n            return\n        if self.options.key:\n            key = unhexlify(self.options.key[2:])\n            keys = deriveKeysFromUserkey(chf.credhist_entries_list[0].sid, key)\n        else:\n            if self.options.password is None:\n                from getpass import getpass\n                password = getpass('Password:')\n            else:\n                password = options.password\n            keys = deriveKeysFromUser(chf.credhist_entries_list[0].sid, password)\n        if self.options.entry is None:\n            real_key = None\n            for k in keys:\n                chf.decrypt_entry_by_index(0, k)\n                if chf.credhist_entries_list[0].pwdhash is not None:\n                    real_key = k\n                    break\n            if real_key is None:\n                chf.dump()\n                print()\n                print('Cannot decrypt (wrong key or password)')\n                return\n            else:\n                chf.decrypt(real_key)\n                chf.dump()\n                if chf.credhist_entries_list[-1].pwdhash is not None:\n                    return\n        else:\n            for k in keys:\n                chf.decrypt_entry_by_index(self.options.entry, k)\n                if chf.credhist_entries_list[self.options.entry].pwdhash is not None:\n                    chf.credhist_entries_list[self.options.entry].dump()\n                    return\n            chf.credhist_entries_list[self.options.entry].dump()\n            print()\n            print('Cannot decrypt (wrong key or password)')\n            return\n    print('Cannot decrypt (specify -key or -sid whenever applicable) ')",
            "def run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.options.action.upper() == 'MASTERKEY':\n        fp = open(options.file, 'rb')\n        data = fp.read()\n        mkf = MasterKeyFile(data)\n        mkf.dump()\n        data = data[len(mkf):]\n        if mkf['MasterKeyLen'] > 0:\n            mk = MasterKey(data[:mkf['MasterKeyLen']])\n            data = data[len(mk):]\n        if mkf['BackupKeyLen'] > 0:\n            bkmk = MasterKey(data[:mkf['BackupKeyLen']])\n            data = data[len(bkmk):]\n        if mkf['CredHistLen'] > 0:\n            ch = CredHist(data[:mkf['CredHistLen']])\n            data = data[len(ch):]\n        if mkf['DomainKeyLen'] > 0:\n            dk = DomainKey(data[:mkf['DomainKeyLen']])\n            data = data[len(dk):]\n        if self.options.system and self.options.security and (self.options.sid is None):\n            self.getLSA()\n            decryptedKey = mk.decrypt(self.dpapiSystem['UserKey'])\n            if decryptedKey:\n                print('Decrypted key with UserKey')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(self.dpapiSystem['MachineKey'])\n            if decryptedKey:\n                print('Decrypted key with MachineKey')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(self.dpapiSystem['UserKey'])\n            if decryptedKey:\n                print('Decrypted Backup key with UserKey')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(self.dpapiSystem['MachineKey'])\n            if decryptedKey:\n                print('Decrypted Backup key with MachineKey')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.system and self.options.security:\n            self.getLSA()\n            (key1, key2) = deriveKeysFromUserkey(self.options.sid, self.dpapiSystem['UserKey'])\n            decryptedKey = mk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted key with UserKey + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted Backup key with UserKey + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted key with UserKey + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted Backup key with UserKey + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.key and self.options.sid:\n            key = unhexlify(self.options.key[2:])\n            (key1, key2) = deriveKeysFromUserkey(self.options.sid, key)\n            decryptedKey = mk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted key with key provided + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted key with key provided + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.key:\n            key = unhexlify(self.options.key[2:])\n            decryptedKey = mk.decrypt(key)\n            if decryptedKey:\n                print('Decrypted key with key provided')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.pvk and dk:\n            pvkfile = open(self.options.pvk, 'rb').read()\n            key = PRIVATE_KEY_BLOB(pvkfile[len(PVK_FILE_HDR()):])\n            private = privatekeyblob_to_pkcs1(key)\n            cipher = PKCS1_v1_5.new(private)\n            decryptedKey = cipher.decrypt(dk['SecretData'][::-1], None)\n            if decryptedKey:\n                domain_master_key = DPAPI_DOMAIN_RSA_MASTER_KEY(decryptedKey)\n                key = domain_master_key['buffer'][:domain_master_key['cbMasterKey']]\n                print('Decrypted key with domain backup key provided')\n                print('Decrypted key: 0x%s' % hexlify(key).decode('latin-1'))\n            return\n        elif self.options.sid and self.options.key is None:\n            if self.options.password is None:\n                from getpass import getpass\n                password = getpass('Password:')\n            else:\n                password = options.password\n            (key1, key2, key3) = deriveKeysFromUser(self.options.sid, password)\n            decryptedKey = mk.decrypt(key3)\n            if decryptedKey:\n                print('Decrypted key with User Key (MD4 protected)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted key with User Key (MD4)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted key with User Key (SHA1)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key3)\n            if decryptedKey:\n                print('Decrypted Backup key with User Key (MD4 protected)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted Backup key with User Key (MD4)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted Backup key with User Key (SHA1)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.target is not None:\n            (domain, username, password, remoteName) = parse_target(self.options.target)\n            if domain is None:\n                domain = ''\n            if password == '' and username != '' and (self.options.hashes is None) and (self.options.no_pass is False) and (self.options.aesKey is None):\n                from getpass import getpass\n                password = getpass('Password:')\n            if self.options.hashes is not None:\n                (lmhash, nthash) = self.options.hashes.split(':')\n            else:\n                (lmhash, nthash) = ('', '')\n            rpctransport = transport.DCERPCTransportFactory('ncacn_np:%s[\\\\PIPE\\\\protected_storage]' % remoteName)\n            if hasattr(rpctransport, 'set_credentials'):\n                rpctransport.set_credentials(username, password, domain, lmhash, nthash, self.options.aesKey)\n            rpctransport.set_kerberos(self.options.k, self.options.dc_ip)\n            dce = rpctransport.get_dce_rpc()\n            dce.set_auth_level(RPC_C_AUTHN_LEVEL_PKT_PRIVACY)\n            if self.options.k is True:\n                dce.set_auth_type(RPC_C_AUTHN_GSS_NEGOTIATE)\n            dce.connect()\n            dce.bind(bkrp.MSRPC_UUID_BKRP, transfer_syntax=('8a885d04-1ceb-11c9-9fe8-08002b104860', '2.0'))\n            request = bkrp.BackuprKey()\n            request['pguidActionAgent'] = bkrp.BACKUPKEY_RESTORE_GUID\n            request['pDataIn'] = dk.getData()\n            request['cbDataIn'] = len(dk.getData())\n            request['dwParam'] = 0\n            resp = dce.request(request)\n            beginning = 0\n            for i in range(len(resp['ppDataOut'])):\n                if resp['ppDataOut'][i] == b'\\x00':\n                    beginning += 1\n                else:\n                    break\n            masterkey = b''.join(resp['ppDataOut'][beginning:])\n            print('Decrypted key using rpc call')\n            print('Decrypted key: 0x%s' % hexlify(masterkey).decode())\n            return\n        else:\n            if mkf['MasterKeyLen'] > 0:\n                mk.dump()\n            if mkf['BackupKeyLen'] > 0:\n                bkmk.dump()\n            if mkf['CredHistLen'] > 0:\n                ch.dump()\n            if mkf['DomainKeyLen'] > 0:\n                dk.dump()\n    elif self.options.action.upper() == 'BACKUPKEYS':\n        (domain, username, password, address) = parse_target(self.options.target)\n        if password == '' and username != '' and (self.options.hashes is None) and (self.options.no_pass is False) and (self.options.aesKey is None):\n            from getpass import getpass\n            password = getpass('Password:')\n        if self.options.hashes is not None:\n            (lmhash, nthash) = self.options.hashes.split(':')\n        else:\n            (lmhash, nthash) = ('', '')\n        connection = SMBConnection(address, address)\n        if self.options.k:\n            connection.kerberosLogin(username, password, domain, lmhash, nthash, self.options.aesKey)\n        else:\n            connection.login(username, password, domain, lmhash=lmhash, nthash=nthash)\n        rpctransport = transport.DCERPCTransportFactory('ncacn_np:445[\\\\pipe\\\\lsarpc]')\n        rpctransport.set_smb_connection(connection)\n        dce = rpctransport.get_dce_rpc()\n        if self.options.k:\n            dce.set_auth_type(RPC_C_AUTHN_GSS_NEGOTIATE)\n        try:\n            dce.connect()\n            dce.bind(lsad.MSRPC_UUID_LSAD)\n        except transport.DCERPCException as e:\n            raise e\n        resp = lsad.hLsarOpenPolicy2(dce, lsad.POLICY_GET_PRIVATE_INFORMATION)\n        for keyname in ('G$BCKUPKEY_PREFERRED', 'G$BCKUPKEY_P'):\n            buffer = crypto.decryptSecret(connection.getSessionKey(), lsad.hLsarRetrievePrivateData(dce, resp['PolicyHandle'], keyname))\n            guid = bin_to_string(buffer)\n            name = 'G$BCKUPKEY_{}'.format(guid)\n            secret = crypto.decryptSecret(connection.getSessionKey(), lsad.hLsarRetrievePrivateData(dce, resp['PolicyHandle'], name))\n            keyVersion = struct.unpack('<L', secret[:4])[0]\n            if keyVersion == 1:\n                backup_key = P_BACKUP_KEY(secret)\n                backupkey = backup_key['Data']\n                if self.options.export:\n                    logging.debug('Exporting key to file {}'.format(name + '.key'))\n                    open(name + '.key', 'wb').write(backupkey)\n                else:\n                    print('Legacy key:')\n                    print('0x%s' % hexlify(backupkey).decode('latin-1'))\n                    print('\\n')\n            elif keyVersion == 2:\n                backup_key = PREFERRED_BACKUP_KEY(secret)\n                pvk = backup_key['Data'][:backup_key['KeyLength']]\n                cert = backup_key['Data'][backup_key['KeyLength']:backup_key['KeyLength'] + backup_key['CertificateLength']]\n                header = PVK_FILE_HDR()\n                header['dwMagic'] = 2964713758\n                header['dwVersion'] = 0\n                header['dwKeySpec'] = 1\n                header['dwEncryptType'] = 0\n                header['cbEncryptData'] = 0\n                header['cbPvk'] = backup_key['KeyLength']\n                backupkey_pvk = header.getData() + pvk\n                backupkey = backupkey_pvk\n                if self.options.export:\n                    logging.debug('Exporting certificate to file {}'.format(name + '.der'))\n                    open(name + '.der', 'wb').write(cert)\n                    logging.debug('Exporting private key to file {}'.format(name + '.pvk'))\n                    open(name + '.pvk', 'wb').write(backupkey)\n                else:\n                    print('Preferred key:')\n                    header.dump()\n                    print('PRIVATEKEYBLOB:{%s}' % hexlify(backupkey).decode('latin-1'))\n                    print('\\n')\n        return\n    elif self.options.action.upper() == 'CREDENTIAL':\n        fp = open(options.file, 'rb')\n        data = fp.read()\n        cred = CredentialFile(data)\n        blob = DPAPI_BLOB(cred['Data'])\n        if self.options.key is not None:\n            key = unhexlify(self.options.key[2:])\n            decrypted = blob.decrypt(key)\n            if decrypted is not None:\n                creds = CREDENTIAL_BLOB(decrypted)\n                creds.dump()\n                return\n        else:\n            blob.dump()\n    elif self.options.action.upper() == 'VAULT':\n        if options.vcrd is None and options.vpol is None:\n            print('You must specify either -vcrd or -vpol parameter. Type --help for more info')\n            return\n        if options.vcrd is not None:\n            fp = open(options.vcrd, 'rb')\n            data = fp.read()\n            blob = VAULT_VCRD(data)\n            if self.options.key is not None:\n                key = unhexlify(self.options.key[2:])\n                cleartext = None\n                for (i, entry) in enumerate(blob.attributesLen):\n                    if entry > 28:\n                        attribute = blob.attributes[i]\n                        if 'IV' in attribute.fields and len(attribute['IV']) == 16:\n                            cipher = AES.new(key, AES.MODE_CBC, iv=attribute['IV'])\n                        else:\n                            cipher = AES.new(key, AES.MODE_CBC)\n                        cleartext = cipher.decrypt(attribute['Data'])\n                if cleartext is not None:\n                    if blob['FriendlyName'].decode('utf-16le')[:-1] in VAULT_KNOWN_SCHEMAS:\n                        vault = VAULT_KNOWN_SCHEMAS[blob['FriendlyName'].decode('utf-16le')[:-1]](cleartext)\n                        vault.dump()\n                    else:\n                        hexdump(cleartext)\n                    return\n            else:\n                blob.dump()\n        elif options.vpol is not None:\n            fp = open(options.vpol, 'rb')\n            data = fp.read()\n            vpol = VAULT_VPOL(data)\n            vpol.dump()\n            if self.options.key is not None:\n                key = unhexlify(self.options.key[2:])\n                blob = vpol['Blob']\n                data = blob.decrypt(key)\n                if data is not None:\n                    keys = VAULT_VPOL_KEYS(data)\n                    keys.dump()\n                    return\n    elif self.options.action.upper() == 'UNPROTECT':\n        fp = open(options.file, 'rb')\n        data = fp.read()\n        blob = DPAPI_BLOB(data)\n        if self.options.key is not None:\n            key = unhexlify(self.options.key[2:])\n            if self.options.entropy_file is not None:\n                fp2 = open(self.options.entropy_file, 'rb')\n                entropy = fp2.read()\n                fp2.close()\n            elif self.options.entropy is not None:\n                entropy = b(self.options.entropy)\n            else:\n                entropy = None\n            decrypted = blob.decrypt(key, entropy)\n            if decrypted is not None:\n                print('Successfully decrypted data')\n                hexdump(decrypted)\n                return\n        else:\n            blob.dump()\n    elif self.options.action.upper() == 'CREDHIST':\n        fp = open(self.options.file, 'rb')\n        data = fp.read()\n        chf = CREDHIST_FILE(data)\n        if len(chf.credhist_entries_list) == 0:\n            print('The CREDHIST file is empty')\n            return\n        if self.options.key:\n            key = unhexlify(self.options.key[2:])\n            keys = deriveKeysFromUserkey(chf.credhist_entries_list[0].sid, key)\n        else:\n            if self.options.password is None:\n                from getpass import getpass\n                password = getpass('Password:')\n            else:\n                password = options.password\n            keys = deriveKeysFromUser(chf.credhist_entries_list[0].sid, password)\n        if self.options.entry is None:\n            real_key = None\n            for k in keys:\n                chf.decrypt_entry_by_index(0, k)\n                if chf.credhist_entries_list[0].pwdhash is not None:\n                    real_key = k\n                    break\n            if real_key is None:\n                chf.dump()\n                print()\n                print('Cannot decrypt (wrong key or password)')\n                return\n            else:\n                chf.decrypt(real_key)\n                chf.dump()\n                if chf.credhist_entries_list[-1].pwdhash is not None:\n                    return\n        else:\n            for k in keys:\n                chf.decrypt_entry_by_index(self.options.entry, k)\n                if chf.credhist_entries_list[self.options.entry].pwdhash is not None:\n                    chf.credhist_entries_list[self.options.entry].dump()\n                    return\n            chf.credhist_entries_list[self.options.entry].dump()\n            print()\n            print('Cannot decrypt (wrong key or password)')\n            return\n    print('Cannot decrypt (specify -key or -sid whenever applicable) ')",
            "def run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.options.action.upper() == 'MASTERKEY':\n        fp = open(options.file, 'rb')\n        data = fp.read()\n        mkf = MasterKeyFile(data)\n        mkf.dump()\n        data = data[len(mkf):]\n        if mkf['MasterKeyLen'] > 0:\n            mk = MasterKey(data[:mkf['MasterKeyLen']])\n            data = data[len(mk):]\n        if mkf['BackupKeyLen'] > 0:\n            bkmk = MasterKey(data[:mkf['BackupKeyLen']])\n            data = data[len(bkmk):]\n        if mkf['CredHistLen'] > 0:\n            ch = CredHist(data[:mkf['CredHistLen']])\n            data = data[len(ch):]\n        if mkf['DomainKeyLen'] > 0:\n            dk = DomainKey(data[:mkf['DomainKeyLen']])\n            data = data[len(dk):]\n        if self.options.system and self.options.security and (self.options.sid is None):\n            self.getLSA()\n            decryptedKey = mk.decrypt(self.dpapiSystem['UserKey'])\n            if decryptedKey:\n                print('Decrypted key with UserKey')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(self.dpapiSystem['MachineKey'])\n            if decryptedKey:\n                print('Decrypted key with MachineKey')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(self.dpapiSystem['UserKey'])\n            if decryptedKey:\n                print('Decrypted Backup key with UserKey')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(self.dpapiSystem['MachineKey'])\n            if decryptedKey:\n                print('Decrypted Backup key with MachineKey')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.system and self.options.security:\n            self.getLSA()\n            (key1, key2) = deriveKeysFromUserkey(self.options.sid, self.dpapiSystem['UserKey'])\n            decryptedKey = mk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted key with UserKey + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted Backup key with UserKey + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted key with UserKey + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted Backup key with UserKey + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.key and self.options.sid:\n            key = unhexlify(self.options.key[2:])\n            (key1, key2) = deriveKeysFromUserkey(self.options.sid, key)\n            decryptedKey = mk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted key with key provided + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted key with key provided + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.key:\n            key = unhexlify(self.options.key[2:])\n            decryptedKey = mk.decrypt(key)\n            if decryptedKey:\n                print('Decrypted key with key provided')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.pvk and dk:\n            pvkfile = open(self.options.pvk, 'rb').read()\n            key = PRIVATE_KEY_BLOB(pvkfile[len(PVK_FILE_HDR()):])\n            private = privatekeyblob_to_pkcs1(key)\n            cipher = PKCS1_v1_5.new(private)\n            decryptedKey = cipher.decrypt(dk['SecretData'][::-1], None)\n            if decryptedKey:\n                domain_master_key = DPAPI_DOMAIN_RSA_MASTER_KEY(decryptedKey)\n                key = domain_master_key['buffer'][:domain_master_key['cbMasterKey']]\n                print('Decrypted key with domain backup key provided')\n                print('Decrypted key: 0x%s' % hexlify(key).decode('latin-1'))\n            return\n        elif self.options.sid and self.options.key is None:\n            if self.options.password is None:\n                from getpass import getpass\n                password = getpass('Password:')\n            else:\n                password = options.password\n            (key1, key2, key3) = deriveKeysFromUser(self.options.sid, password)\n            decryptedKey = mk.decrypt(key3)\n            if decryptedKey:\n                print('Decrypted key with User Key (MD4 protected)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted key with User Key (MD4)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted key with User Key (SHA1)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key3)\n            if decryptedKey:\n                print('Decrypted Backup key with User Key (MD4 protected)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted Backup key with User Key (MD4)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted Backup key with User Key (SHA1)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.target is not None:\n            (domain, username, password, remoteName) = parse_target(self.options.target)\n            if domain is None:\n                domain = ''\n            if password == '' and username != '' and (self.options.hashes is None) and (self.options.no_pass is False) and (self.options.aesKey is None):\n                from getpass import getpass\n                password = getpass('Password:')\n            if self.options.hashes is not None:\n                (lmhash, nthash) = self.options.hashes.split(':')\n            else:\n                (lmhash, nthash) = ('', '')\n            rpctransport = transport.DCERPCTransportFactory('ncacn_np:%s[\\\\PIPE\\\\protected_storage]' % remoteName)\n            if hasattr(rpctransport, 'set_credentials'):\n                rpctransport.set_credentials(username, password, domain, lmhash, nthash, self.options.aesKey)\n            rpctransport.set_kerberos(self.options.k, self.options.dc_ip)\n            dce = rpctransport.get_dce_rpc()\n            dce.set_auth_level(RPC_C_AUTHN_LEVEL_PKT_PRIVACY)\n            if self.options.k is True:\n                dce.set_auth_type(RPC_C_AUTHN_GSS_NEGOTIATE)\n            dce.connect()\n            dce.bind(bkrp.MSRPC_UUID_BKRP, transfer_syntax=('8a885d04-1ceb-11c9-9fe8-08002b104860', '2.0'))\n            request = bkrp.BackuprKey()\n            request['pguidActionAgent'] = bkrp.BACKUPKEY_RESTORE_GUID\n            request['pDataIn'] = dk.getData()\n            request['cbDataIn'] = len(dk.getData())\n            request['dwParam'] = 0\n            resp = dce.request(request)\n            beginning = 0\n            for i in range(len(resp['ppDataOut'])):\n                if resp['ppDataOut'][i] == b'\\x00':\n                    beginning += 1\n                else:\n                    break\n            masterkey = b''.join(resp['ppDataOut'][beginning:])\n            print('Decrypted key using rpc call')\n            print('Decrypted key: 0x%s' % hexlify(masterkey).decode())\n            return\n        else:\n            if mkf['MasterKeyLen'] > 0:\n                mk.dump()\n            if mkf['BackupKeyLen'] > 0:\n                bkmk.dump()\n            if mkf['CredHistLen'] > 0:\n                ch.dump()\n            if mkf['DomainKeyLen'] > 0:\n                dk.dump()\n    elif self.options.action.upper() == 'BACKUPKEYS':\n        (domain, username, password, address) = parse_target(self.options.target)\n        if password == '' and username != '' and (self.options.hashes is None) and (self.options.no_pass is False) and (self.options.aesKey is None):\n            from getpass import getpass\n            password = getpass('Password:')\n        if self.options.hashes is not None:\n            (lmhash, nthash) = self.options.hashes.split(':')\n        else:\n            (lmhash, nthash) = ('', '')\n        connection = SMBConnection(address, address)\n        if self.options.k:\n            connection.kerberosLogin(username, password, domain, lmhash, nthash, self.options.aesKey)\n        else:\n            connection.login(username, password, domain, lmhash=lmhash, nthash=nthash)\n        rpctransport = transport.DCERPCTransportFactory('ncacn_np:445[\\\\pipe\\\\lsarpc]')\n        rpctransport.set_smb_connection(connection)\n        dce = rpctransport.get_dce_rpc()\n        if self.options.k:\n            dce.set_auth_type(RPC_C_AUTHN_GSS_NEGOTIATE)\n        try:\n            dce.connect()\n            dce.bind(lsad.MSRPC_UUID_LSAD)\n        except transport.DCERPCException as e:\n            raise e\n        resp = lsad.hLsarOpenPolicy2(dce, lsad.POLICY_GET_PRIVATE_INFORMATION)\n        for keyname in ('G$BCKUPKEY_PREFERRED', 'G$BCKUPKEY_P'):\n            buffer = crypto.decryptSecret(connection.getSessionKey(), lsad.hLsarRetrievePrivateData(dce, resp['PolicyHandle'], keyname))\n            guid = bin_to_string(buffer)\n            name = 'G$BCKUPKEY_{}'.format(guid)\n            secret = crypto.decryptSecret(connection.getSessionKey(), lsad.hLsarRetrievePrivateData(dce, resp['PolicyHandle'], name))\n            keyVersion = struct.unpack('<L', secret[:4])[0]\n            if keyVersion == 1:\n                backup_key = P_BACKUP_KEY(secret)\n                backupkey = backup_key['Data']\n                if self.options.export:\n                    logging.debug('Exporting key to file {}'.format(name + '.key'))\n                    open(name + '.key', 'wb').write(backupkey)\n                else:\n                    print('Legacy key:')\n                    print('0x%s' % hexlify(backupkey).decode('latin-1'))\n                    print('\\n')\n            elif keyVersion == 2:\n                backup_key = PREFERRED_BACKUP_KEY(secret)\n                pvk = backup_key['Data'][:backup_key['KeyLength']]\n                cert = backup_key['Data'][backup_key['KeyLength']:backup_key['KeyLength'] + backup_key['CertificateLength']]\n                header = PVK_FILE_HDR()\n                header['dwMagic'] = 2964713758\n                header['dwVersion'] = 0\n                header['dwKeySpec'] = 1\n                header['dwEncryptType'] = 0\n                header['cbEncryptData'] = 0\n                header['cbPvk'] = backup_key['KeyLength']\n                backupkey_pvk = header.getData() + pvk\n                backupkey = backupkey_pvk\n                if self.options.export:\n                    logging.debug('Exporting certificate to file {}'.format(name + '.der'))\n                    open(name + '.der', 'wb').write(cert)\n                    logging.debug('Exporting private key to file {}'.format(name + '.pvk'))\n                    open(name + '.pvk', 'wb').write(backupkey)\n                else:\n                    print('Preferred key:')\n                    header.dump()\n                    print('PRIVATEKEYBLOB:{%s}' % hexlify(backupkey).decode('latin-1'))\n                    print('\\n')\n        return\n    elif self.options.action.upper() == 'CREDENTIAL':\n        fp = open(options.file, 'rb')\n        data = fp.read()\n        cred = CredentialFile(data)\n        blob = DPAPI_BLOB(cred['Data'])\n        if self.options.key is not None:\n            key = unhexlify(self.options.key[2:])\n            decrypted = blob.decrypt(key)\n            if decrypted is not None:\n                creds = CREDENTIAL_BLOB(decrypted)\n                creds.dump()\n                return\n        else:\n            blob.dump()\n    elif self.options.action.upper() == 'VAULT':\n        if options.vcrd is None and options.vpol is None:\n            print('You must specify either -vcrd or -vpol parameter. Type --help for more info')\n            return\n        if options.vcrd is not None:\n            fp = open(options.vcrd, 'rb')\n            data = fp.read()\n            blob = VAULT_VCRD(data)\n            if self.options.key is not None:\n                key = unhexlify(self.options.key[2:])\n                cleartext = None\n                for (i, entry) in enumerate(blob.attributesLen):\n                    if entry > 28:\n                        attribute = blob.attributes[i]\n                        if 'IV' in attribute.fields and len(attribute['IV']) == 16:\n                            cipher = AES.new(key, AES.MODE_CBC, iv=attribute['IV'])\n                        else:\n                            cipher = AES.new(key, AES.MODE_CBC)\n                        cleartext = cipher.decrypt(attribute['Data'])\n                if cleartext is not None:\n                    if blob['FriendlyName'].decode('utf-16le')[:-1] in VAULT_KNOWN_SCHEMAS:\n                        vault = VAULT_KNOWN_SCHEMAS[blob['FriendlyName'].decode('utf-16le')[:-1]](cleartext)\n                        vault.dump()\n                    else:\n                        hexdump(cleartext)\n                    return\n            else:\n                blob.dump()\n        elif options.vpol is not None:\n            fp = open(options.vpol, 'rb')\n            data = fp.read()\n            vpol = VAULT_VPOL(data)\n            vpol.dump()\n            if self.options.key is not None:\n                key = unhexlify(self.options.key[2:])\n                blob = vpol['Blob']\n                data = blob.decrypt(key)\n                if data is not None:\n                    keys = VAULT_VPOL_KEYS(data)\n                    keys.dump()\n                    return\n    elif self.options.action.upper() == 'UNPROTECT':\n        fp = open(options.file, 'rb')\n        data = fp.read()\n        blob = DPAPI_BLOB(data)\n        if self.options.key is not None:\n            key = unhexlify(self.options.key[2:])\n            if self.options.entropy_file is not None:\n                fp2 = open(self.options.entropy_file, 'rb')\n                entropy = fp2.read()\n                fp2.close()\n            elif self.options.entropy is not None:\n                entropy = b(self.options.entropy)\n            else:\n                entropy = None\n            decrypted = blob.decrypt(key, entropy)\n            if decrypted is not None:\n                print('Successfully decrypted data')\n                hexdump(decrypted)\n                return\n        else:\n            blob.dump()\n    elif self.options.action.upper() == 'CREDHIST':\n        fp = open(self.options.file, 'rb')\n        data = fp.read()\n        chf = CREDHIST_FILE(data)\n        if len(chf.credhist_entries_list) == 0:\n            print('The CREDHIST file is empty')\n            return\n        if self.options.key:\n            key = unhexlify(self.options.key[2:])\n            keys = deriveKeysFromUserkey(chf.credhist_entries_list[0].sid, key)\n        else:\n            if self.options.password is None:\n                from getpass import getpass\n                password = getpass('Password:')\n            else:\n                password = options.password\n            keys = deriveKeysFromUser(chf.credhist_entries_list[0].sid, password)\n        if self.options.entry is None:\n            real_key = None\n            for k in keys:\n                chf.decrypt_entry_by_index(0, k)\n                if chf.credhist_entries_list[0].pwdhash is not None:\n                    real_key = k\n                    break\n            if real_key is None:\n                chf.dump()\n                print()\n                print('Cannot decrypt (wrong key or password)')\n                return\n            else:\n                chf.decrypt(real_key)\n                chf.dump()\n                if chf.credhist_entries_list[-1].pwdhash is not None:\n                    return\n        else:\n            for k in keys:\n                chf.decrypt_entry_by_index(self.options.entry, k)\n                if chf.credhist_entries_list[self.options.entry].pwdhash is not None:\n                    chf.credhist_entries_list[self.options.entry].dump()\n                    return\n            chf.credhist_entries_list[self.options.entry].dump()\n            print()\n            print('Cannot decrypt (wrong key or password)')\n            return\n    print('Cannot decrypt (specify -key or -sid whenever applicable) ')",
            "def run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.options.action.upper() == 'MASTERKEY':\n        fp = open(options.file, 'rb')\n        data = fp.read()\n        mkf = MasterKeyFile(data)\n        mkf.dump()\n        data = data[len(mkf):]\n        if mkf['MasterKeyLen'] > 0:\n            mk = MasterKey(data[:mkf['MasterKeyLen']])\n            data = data[len(mk):]\n        if mkf['BackupKeyLen'] > 0:\n            bkmk = MasterKey(data[:mkf['BackupKeyLen']])\n            data = data[len(bkmk):]\n        if mkf['CredHistLen'] > 0:\n            ch = CredHist(data[:mkf['CredHistLen']])\n            data = data[len(ch):]\n        if mkf['DomainKeyLen'] > 0:\n            dk = DomainKey(data[:mkf['DomainKeyLen']])\n            data = data[len(dk):]\n        if self.options.system and self.options.security and (self.options.sid is None):\n            self.getLSA()\n            decryptedKey = mk.decrypt(self.dpapiSystem['UserKey'])\n            if decryptedKey:\n                print('Decrypted key with UserKey')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(self.dpapiSystem['MachineKey'])\n            if decryptedKey:\n                print('Decrypted key with MachineKey')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(self.dpapiSystem['UserKey'])\n            if decryptedKey:\n                print('Decrypted Backup key with UserKey')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(self.dpapiSystem['MachineKey'])\n            if decryptedKey:\n                print('Decrypted Backup key with MachineKey')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.system and self.options.security:\n            self.getLSA()\n            (key1, key2) = deriveKeysFromUserkey(self.options.sid, self.dpapiSystem['UserKey'])\n            decryptedKey = mk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted key with UserKey + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted Backup key with UserKey + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted key with UserKey + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted Backup key with UserKey + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.key and self.options.sid:\n            key = unhexlify(self.options.key[2:])\n            (key1, key2) = deriveKeysFromUserkey(self.options.sid, key)\n            decryptedKey = mk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted key with key provided + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted key with key provided + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.key:\n            key = unhexlify(self.options.key[2:])\n            decryptedKey = mk.decrypt(key)\n            if decryptedKey:\n                print('Decrypted key with key provided')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.pvk and dk:\n            pvkfile = open(self.options.pvk, 'rb').read()\n            key = PRIVATE_KEY_BLOB(pvkfile[len(PVK_FILE_HDR()):])\n            private = privatekeyblob_to_pkcs1(key)\n            cipher = PKCS1_v1_5.new(private)\n            decryptedKey = cipher.decrypt(dk['SecretData'][::-1], None)\n            if decryptedKey:\n                domain_master_key = DPAPI_DOMAIN_RSA_MASTER_KEY(decryptedKey)\n                key = domain_master_key['buffer'][:domain_master_key['cbMasterKey']]\n                print('Decrypted key with domain backup key provided')\n                print('Decrypted key: 0x%s' % hexlify(key).decode('latin-1'))\n            return\n        elif self.options.sid and self.options.key is None:\n            if self.options.password is None:\n                from getpass import getpass\n                password = getpass('Password:')\n            else:\n                password = options.password\n            (key1, key2, key3) = deriveKeysFromUser(self.options.sid, password)\n            decryptedKey = mk.decrypt(key3)\n            if decryptedKey:\n                print('Decrypted key with User Key (MD4 protected)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted key with User Key (MD4)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted key with User Key (SHA1)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key3)\n            if decryptedKey:\n                print('Decrypted Backup key with User Key (MD4 protected)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted Backup key with User Key (MD4)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted Backup key with User Key (SHA1)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.target is not None:\n            (domain, username, password, remoteName) = parse_target(self.options.target)\n            if domain is None:\n                domain = ''\n            if password == '' and username != '' and (self.options.hashes is None) and (self.options.no_pass is False) and (self.options.aesKey is None):\n                from getpass import getpass\n                password = getpass('Password:')\n            if self.options.hashes is not None:\n                (lmhash, nthash) = self.options.hashes.split(':')\n            else:\n                (lmhash, nthash) = ('', '')\n            rpctransport = transport.DCERPCTransportFactory('ncacn_np:%s[\\\\PIPE\\\\protected_storage]' % remoteName)\n            if hasattr(rpctransport, 'set_credentials'):\n                rpctransport.set_credentials(username, password, domain, lmhash, nthash, self.options.aesKey)\n            rpctransport.set_kerberos(self.options.k, self.options.dc_ip)\n            dce = rpctransport.get_dce_rpc()\n            dce.set_auth_level(RPC_C_AUTHN_LEVEL_PKT_PRIVACY)\n            if self.options.k is True:\n                dce.set_auth_type(RPC_C_AUTHN_GSS_NEGOTIATE)\n            dce.connect()\n            dce.bind(bkrp.MSRPC_UUID_BKRP, transfer_syntax=('8a885d04-1ceb-11c9-9fe8-08002b104860', '2.0'))\n            request = bkrp.BackuprKey()\n            request['pguidActionAgent'] = bkrp.BACKUPKEY_RESTORE_GUID\n            request['pDataIn'] = dk.getData()\n            request['cbDataIn'] = len(dk.getData())\n            request['dwParam'] = 0\n            resp = dce.request(request)\n            beginning = 0\n            for i in range(len(resp['ppDataOut'])):\n                if resp['ppDataOut'][i] == b'\\x00':\n                    beginning += 1\n                else:\n                    break\n            masterkey = b''.join(resp['ppDataOut'][beginning:])\n            print('Decrypted key using rpc call')\n            print('Decrypted key: 0x%s' % hexlify(masterkey).decode())\n            return\n        else:\n            if mkf['MasterKeyLen'] > 0:\n                mk.dump()\n            if mkf['BackupKeyLen'] > 0:\n                bkmk.dump()\n            if mkf['CredHistLen'] > 0:\n                ch.dump()\n            if mkf['DomainKeyLen'] > 0:\n                dk.dump()\n    elif self.options.action.upper() == 'BACKUPKEYS':\n        (domain, username, password, address) = parse_target(self.options.target)\n        if password == '' and username != '' and (self.options.hashes is None) and (self.options.no_pass is False) and (self.options.aesKey is None):\n            from getpass import getpass\n            password = getpass('Password:')\n        if self.options.hashes is not None:\n            (lmhash, nthash) = self.options.hashes.split(':')\n        else:\n            (lmhash, nthash) = ('', '')\n        connection = SMBConnection(address, address)\n        if self.options.k:\n            connection.kerberosLogin(username, password, domain, lmhash, nthash, self.options.aesKey)\n        else:\n            connection.login(username, password, domain, lmhash=lmhash, nthash=nthash)\n        rpctransport = transport.DCERPCTransportFactory('ncacn_np:445[\\\\pipe\\\\lsarpc]')\n        rpctransport.set_smb_connection(connection)\n        dce = rpctransport.get_dce_rpc()\n        if self.options.k:\n            dce.set_auth_type(RPC_C_AUTHN_GSS_NEGOTIATE)\n        try:\n            dce.connect()\n            dce.bind(lsad.MSRPC_UUID_LSAD)\n        except transport.DCERPCException as e:\n            raise e\n        resp = lsad.hLsarOpenPolicy2(dce, lsad.POLICY_GET_PRIVATE_INFORMATION)\n        for keyname in ('G$BCKUPKEY_PREFERRED', 'G$BCKUPKEY_P'):\n            buffer = crypto.decryptSecret(connection.getSessionKey(), lsad.hLsarRetrievePrivateData(dce, resp['PolicyHandle'], keyname))\n            guid = bin_to_string(buffer)\n            name = 'G$BCKUPKEY_{}'.format(guid)\n            secret = crypto.decryptSecret(connection.getSessionKey(), lsad.hLsarRetrievePrivateData(dce, resp['PolicyHandle'], name))\n            keyVersion = struct.unpack('<L', secret[:4])[0]\n            if keyVersion == 1:\n                backup_key = P_BACKUP_KEY(secret)\n                backupkey = backup_key['Data']\n                if self.options.export:\n                    logging.debug('Exporting key to file {}'.format(name + '.key'))\n                    open(name + '.key', 'wb').write(backupkey)\n                else:\n                    print('Legacy key:')\n                    print('0x%s' % hexlify(backupkey).decode('latin-1'))\n                    print('\\n')\n            elif keyVersion == 2:\n                backup_key = PREFERRED_BACKUP_KEY(secret)\n                pvk = backup_key['Data'][:backup_key['KeyLength']]\n                cert = backup_key['Data'][backup_key['KeyLength']:backup_key['KeyLength'] + backup_key['CertificateLength']]\n                header = PVK_FILE_HDR()\n                header['dwMagic'] = 2964713758\n                header['dwVersion'] = 0\n                header['dwKeySpec'] = 1\n                header['dwEncryptType'] = 0\n                header['cbEncryptData'] = 0\n                header['cbPvk'] = backup_key['KeyLength']\n                backupkey_pvk = header.getData() + pvk\n                backupkey = backupkey_pvk\n                if self.options.export:\n                    logging.debug('Exporting certificate to file {}'.format(name + '.der'))\n                    open(name + '.der', 'wb').write(cert)\n                    logging.debug('Exporting private key to file {}'.format(name + '.pvk'))\n                    open(name + '.pvk', 'wb').write(backupkey)\n                else:\n                    print('Preferred key:')\n                    header.dump()\n                    print('PRIVATEKEYBLOB:{%s}' % hexlify(backupkey).decode('latin-1'))\n                    print('\\n')\n        return\n    elif self.options.action.upper() == 'CREDENTIAL':\n        fp = open(options.file, 'rb')\n        data = fp.read()\n        cred = CredentialFile(data)\n        blob = DPAPI_BLOB(cred['Data'])\n        if self.options.key is not None:\n            key = unhexlify(self.options.key[2:])\n            decrypted = blob.decrypt(key)\n            if decrypted is not None:\n                creds = CREDENTIAL_BLOB(decrypted)\n                creds.dump()\n                return\n        else:\n            blob.dump()\n    elif self.options.action.upper() == 'VAULT':\n        if options.vcrd is None and options.vpol is None:\n            print('You must specify either -vcrd or -vpol parameter. Type --help for more info')\n            return\n        if options.vcrd is not None:\n            fp = open(options.vcrd, 'rb')\n            data = fp.read()\n            blob = VAULT_VCRD(data)\n            if self.options.key is not None:\n                key = unhexlify(self.options.key[2:])\n                cleartext = None\n                for (i, entry) in enumerate(blob.attributesLen):\n                    if entry > 28:\n                        attribute = blob.attributes[i]\n                        if 'IV' in attribute.fields and len(attribute['IV']) == 16:\n                            cipher = AES.new(key, AES.MODE_CBC, iv=attribute['IV'])\n                        else:\n                            cipher = AES.new(key, AES.MODE_CBC)\n                        cleartext = cipher.decrypt(attribute['Data'])\n                if cleartext is not None:\n                    if blob['FriendlyName'].decode('utf-16le')[:-1] in VAULT_KNOWN_SCHEMAS:\n                        vault = VAULT_KNOWN_SCHEMAS[blob['FriendlyName'].decode('utf-16le')[:-1]](cleartext)\n                        vault.dump()\n                    else:\n                        hexdump(cleartext)\n                    return\n            else:\n                blob.dump()\n        elif options.vpol is not None:\n            fp = open(options.vpol, 'rb')\n            data = fp.read()\n            vpol = VAULT_VPOL(data)\n            vpol.dump()\n            if self.options.key is not None:\n                key = unhexlify(self.options.key[2:])\n                blob = vpol['Blob']\n                data = blob.decrypt(key)\n                if data is not None:\n                    keys = VAULT_VPOL_KEYS(data)\n                    keys.dump()\n                    return\n    elif self.options.action.upper() == 'UNPROTECT':\n        fp = open(options.file, 'rb')\n        data = fp.read()\n        blob = DPAPI_BLOB(data)\n        if self.options.key is not None:\n            key = unhexlify(self.options.key[2:])\n            if self.options.entropy_file is not None:\n                fp2 = open(self.options.entropy_file, 'rb')\n                entropy = fp2.read()\n                fp2.close()\n            elif self.options.entropy is not None:\n                entropy = b(self.options.entropy)\n            else:\n                entropy = None\n            decrypted = blob.decrypt(key, entropy)\n            if decrypted is not None:\n                print('Successfully decrypted data')\n                hexdump(decrypted)\n                return\n        else:\n            blob.dump()\n    elif self.options.action.upper() == 'CREDHIST':\n        fp = open(self.options.file, 'rb')\n        data = fp.read()\n        chf = CREDHIST_FILE(data)\n        if len(chf.credhist_entries_list) == 0:\n            print('The CREDHIST file is empty')\n            return\n        if self.options.key:\n            key = unhexlify(self.options.key[2:])\n            keys = deriveKeysFromUserkey(chf.credhist_entries_list[0].sid, key)\n        else:\n            if self.options.password is None:\n                from getpass import getpass\n                password = getpass('Password:')\n            else:\n                password = options.password\n            keys = deriveKeysFromUser(chf.credhist_entries_list[0].sid, password)\n        if self.options.entry is None:\n            real_key = None\n            for k in keys:\n                chf.decrypt_entry_by_index(0, k)\n                if chf.credhist_entries_list[0].pwdhash is not None:\n                    real_key = k\n                    break\n            if real_key is None:\n                chf.dump()\n                print()\n                print('Cannot decrypt (wrong key or password)')\n                return\n            else:\n                chf.decrypt(real_key)\n                chf.dump()\n                if chf.credhist_entries_list[-1].pwdhash is not None:\n                    return\n        else:\n            for k in keys:\n                chf.decrypt_entry_by_index(self.options.entry, k)\n                if chf.credhist_entries_list[self.options.entry].pwdhash is not None:\n                    chf.credhist_entries_list[self.options.entry].dump()\n                    return\n            chf.credhist_entries_list[self.options.entry].dump()\n            print()\n            print('Cannot decrypt (wrong key or password)')\n            return\n    print('Cannot decrypt (specify -key or -sid whenever applicable) ')",
            "def run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.options.action.upper() == 'MASTERKEY':\n        fp = open(options.file, 'rb')\n        data = fp.read()\n        mkf = MasterKeyFile(data)\n        mkf.dump()\n        data = data[len(mkf):]\n        if mkf['MasterKeyLen'] > 0:\n            mk = MasterKey(data[:mkf['MasterKeyLen']])\n            data = data[len(mk):]\n        if mkf['BackupKeyLen'] > 0:\n            bkmk = MasterKey(data[:mkf['BackupKeyLen']])\n            data = data[len(bkmk):]\n        if mkf['CredHistLen'] > 0:\n            ch = CredHist(data[:mkf['CredHistLen']])\n            data = data[len(ch):]\n        if mkf['DomainKeyLen'] > 0:\n            dk = DomainKey(data[:mkf['DomainKeyLen']])\n            data = data[len(dk):]\n        if self.options.system and self.options.security and (self.options.sid is None):\n            self.getLSA()\n            decryptedKey = mk.decrypt(self.dpapiSystem['UserKey'])\n            if decryptedKey:\n                print('Decrypted key with UserKey')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(self.dpapiSystem['MachineKey'])\n            if decryptedKey:\n                print('Decrypted key with MachineKey')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(self.dpapiSystem['UserKey'])\n            if decryptedKey:\n                print('Decrypted Backup key with UserKey')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(self.dpapiSystem['MachineKey'])\n            if decryptedKey:\n                print('Decrypted Backup key with MachineKey')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.system and self.options.security:\n            self.getLSA()\n            (key1, key2) = deriveKeysFromUserkey(self.options.sid, self.dpapiSystem['UserKey'])\n            decryptedKey = mk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted key with UserKey + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted Backup key with UserKey + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted key with UserKey + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted Backup key with UserKey + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.key and self.options.sid:\n            key = unhexlify(self.options.key[2:])\n            (key1, key2) = deriveKeysFromUserkey(self.options.sid, key)\n            decryptedKey = mk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted key with key provided + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted key with key provided + SID')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.key:\n            key = unhexlify(self.options.key[2:])\n            decryptedKey = mk.decrypt(key)\n            if decryptedKey:\n                print('Decrypted key with key provided')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.pvk and dk:\n            pvkfile = open(self.options.pvk, 'rb').read()\n            key = PRIVATE_KEY_BLOB(pvkfile[len(PVK_FILE_HDR()):])\n            private = privatekeyblob_to_pkcs1(key)\n            cipher = PKCS1_v1_5.new(private)\n            decryptedKey = cipher.decrypt(dk['SecretData'][::-1], None)\n            if decryptedKey:\n                domain_master_key = DPAPI_DOMAIN_RSA_MASTER_KEY(decryptedKey)\n                key = domain_master_key['buffer'][:domain_master_key['cbMasterKey']]\n                print('Decrypted key with domain backup key provided')\n                print('Decrypted key: 0x%s' % hexlify(key).decode('latin-1'))\n            return\n        elif self.options.sid and self.options.key is None:\n            if self.options.password is None:\n                from getpass import getpass\n                password = getpass('Password:')\n            else:\n                password = options.password\n            (key1, key2, key3) = deriveKeysFromUser(self.options.sid, password)\n            decryptedKey = mk.decrypt(key3)\n            if decryptedKey:\n                print('Decrypted key with User Key (MD4 protected)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted key with User Key (MD4)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = mk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted key with User Key (SHA1)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key3)\n            if decryptedKey:\n                print('Decrypted Backup key with User Key (MD4 protected)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key2)\n            if decryptedKey:\n                print('Decrypted Backup key with User Key (MD4)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n            decryptedKey = bkmk.decrypt(key1)\n            if decryptedKey:\n                print('Decrypted Backup key with User Key (SHA1)')\n                print('Decrypted key: 0x%s' % hexlify(decryptedKey).decode('latin-1'))\n                return\n        elif self.options.target is not None:\n            (domain, username, password, remoteName) = parse_target(self.options.target)\n            if domain is None:\n                domain = ''\n            if password == '' and username != '' and (self.options.hashes is None) and (self.options.no_pass is False) and (self.options.aesKey is None):\n                from getpass import getpass\n                password = getpass('Password:')\n            if self.options.hashes is not None:\n                (lmhash, nthash) = self.options.hashes.split(':')\n            else:\n                (lmhash, nthash) = ('', '')\n            rpctransport = transport.DCERPCTransportFactory('ncacn_np:%s[\\\\PIPE\\\\protected_storage]' % remoteName)\n            if hasattr(rpctransport, 'set_credentials'):\n                rpctransport.set_credentials(username, password, domain, lmhash, nthash, self.options.aesKey)\n            rpctransport.set_kerberos(self.options.k, self.options.dc_ip)\n            dce = rpctransport.get_dce_rpc()\n            dce.set_auth_level(RPC_C_AUTHN_LEVEL_PKT_PRIVACY)\n            if self.options.k is True:\n                dce.set_auth_type(RPC_C_AUTHN_GSS_NEGOTIATE)\n            dce.connect()\n            dce.bind(bkrp.MSRPC_UUID_BKRP, transfer_syntax=('8a885d04-1ceb-11c9-9fe8-08002b104860', '2.0'))\n            request = bkrp.BackuprKey()\n            request['pguidActionAgent'] = bkrp.BACKUPKEY_RESTORE_GUID\n            request['pDataIn'] = dk.getData()\n            request['cbDataIn'] = len(dk.getData())\n            request['dwParam'] = 0\n            resp = dce.request(request)\n            beginning = 0\n            for i in range(len(resp['ppDataOut'])):\n                if resp['ppDataOut'][i] == b'\\x00':\n                    beginning += 1\n                else:\n                    break\n            masterkey = b''.join(resp['ppDataOut'][beginning:])\n            print('Decrypted key using rpc call')\n            print('Decrypted key: 0x%s' % hexlify(masterkey).decode())\n            return\n        else:\n            if mkf['MasterKeyLen'] > 0:\n                mk.dump()\n            if mkf['BackupKeyLen'] > 0:\n                bkmk.dump()\n            if mkf['CredHistLen'] > 0:\n                ch.dump()\n            if mkf['DomainKeyLen'] > 0:\n                dk.dump()\n    elif self.options.action.upper() == 'BACKUPKEYS':\n        (domain, username, password, address) = parse_target(self.options.target)\n        if password == '' and username != '' and (self.options.hashes is None) and (self.options.no_pass is False) and (self.options.aesKey is None):\n            from getpass import getpass\n            password = getpass('Password:')\n        if self.options.hashes is not None:\n            (lmhash, nthash) = self.options.hashes.split(':')\n        else:\n            (lmhash, nthash) = ('', '')\n        connection = SMBConnection(address, address)\n        if self.options.k:\n            connection.kerberosLogin(username, password, domain, lmhash, nthash, self.options.aesKey)\n        else:\n            connection.login(username, password, domain, lmhash=lmhash, nthash=nthash)\n        rpctransport = transport.DCERPCTransportFactory('ncacn_np:445[\\\\pipe\\\\lsarpc]')\n        rpctransport.set_smb_connection(connection)\n        dce = rpctransport.get_dce_rpc()\n        if self.options.k:\n            dce.set_auth_type(RPC_C_AUTHN_GSS_NEGOTIATE)\n        try:\n            dce.connect()\n            dce.bind(lsad.MSRPC_UUID_LSAD)\n        except transport.DCERPCException as e:\n            raise e\n        resp = lsad.hLsarOpenPolicy2(dce, lsad.POLICY_GET_PRIVATE_INFORMATION)\n        for keyname in ('G$BCKUPKEY_PREFERRED', 'G$BCKUPKEY_P'):\n            buffer = crypto.decryptSecret(connection.getSessionKey(), lsad.hLsarRetrievePrivateData(dce, resp['PolicyHandle'], keyname))\n            guid = bin_to_string(buffer)\n            name = 'G$BCKUPKEY_{}'.format(guid)\n            secret = crypto.decryptSecret(connection.getSessionKey(), lsad.hLsarRetrievePrivateData(dce, resp['PolicyHandle'], name))\n            keyVersion = struct.unpack('<L', secret[:4])[0]\n            if keyVersion == 1:\n                backup_key = P_BACKUP_KEY(secret)\n                backupkey = backup_key['Data']\n                if self.options.export:\n                    logging.debug('Exporting key to file {}'.format(name + '.key'))\n                    open(name + '.key', 'wb').write(backupkey)\n                else:\n                    print('Legacy key:')\n                    print('0x%s' % hexlify(backupkey).decode('latin-1'))\n                    print('\\n')\n            elif keyVersion == 2:\n                backup_key = PREFERRED_BACKUP_KEY(secret)\n                pvk = backup_key['Data'][:backup_key['KeyLength']]\n                cert = backup_key['Data'][backup_key['KeyLength']:backup_key['KeyLength'] + backup_key['CertificateLength']]\n                header = PVK_FILE_HDR()\n                header['dwMagic'] = 2964713758\n                header['dwVersion'] = 0\n                header['dwKeySpec'] = 1\n                header['dwEncryptType'] = 0\n                header['cbEncryptData'] = 0\n                header['cbPvk'] = backup_key['KeyLength']\n                backupkey_pvk = header.getData() + pvk\n                backupkey = backupkey_pvk\n                if self.options.export:\n                    logging.debug('Exporting certificate to file {}'.format(name + '.der'))\n                    open(name + '.der', 'wb').write(cert)\n                    logging.debug('Exporting private key to file {}'.format(name + '.pvk'))\n                    open(name + '.pvk', 'wb').write(backupkey)\n                else:\n                    print('Preferred key:')\n                    header.dump()\n                    print('PRIVATEKEYBLOB:{%s}' % hexlify(backupkey).decode('latin-1'))\n                    print('\\n')\n        return\n    elif self.options.action.upper() == 'CREDENTIAL':\n        fp = open(options.file, 'rb')\n        data = fp.read()\n        cred = CredentialFile(data)\n        blob = DPAPI_BLOB(cred['Data'])\n        if self.options.key is not None:\n            key = unhexlify(self.options.key[2:])\n            decrypted = blob.decrypt(key)\n            if decrypted is not None:\n                creds = CREDENTIAL_BLOB(decrypted)\n                creds.dump()\n                return\n        else:\n            blob.dump()\n    elif self.options.action.upper() == 'VAULT':\n        if options.vcrd is None and options.vpol is None:\n            print('You must specify either -vcrd or -vpol parameter. Type --help for more info')\n            return\n        if options.vcrd is not None:\n            fp = open(options.vcrd, 'rb')\n            data = fp.read()\n            blob = VAULT_VCRD(data)\n            if self.options.key is not None:\n                key = unhexlify(self.options.key[2:])\n                cleartext = None\n                for (i, entry) in enumerate(blob.attributesLen):\n                    if entry > 28:\n                        attribute = blob.attributes[i]\n                        if 'IV' in attribute.fields and len(attribute['IV']) == 16:\n                            cipher = AES.new(key, AES.MODE_CBC, iv=attribute['IV'])\n                        else:\n                            cipher = AES.new(key, AES.MODE_CBC)\n                        cleartext = cipher.decrypt(attribute['Data'])\n                if cleartext is not None:\n                    if blob['FriendlyName'].decode('utf-16le')[:-1] in VAULT_KNOWN_SCHEMAS:\n                        vault = VAULT_KNOWN_SCHEMAS[blob['FriendlyName'].decode('utf-16le')[:-1]](cleartext)\n                        vault.dump()\n                    else:\n                        hexdump(cleartext)\n                    return\n            else:\n                blob.dump()\n        elif options.vpol is not None:\n            fp = open(options.vpol, 'rb')\n            data = fp.read()\n            vpol = VAULT_VPOL(data)\n            vpol.dump()\n            if self.options.key is not None:\n                key = unhexlify(self.options.key[2:])\n                blob = vpol['Blob']\n                data = blob.decrypt(key)\n                if data is not None:\n                    keys = VAULT_VPOL_KEYS(data)\n                    keys.dump()\n                    return\n    elif self.options.action.upper() == 'UNPROTECT':\n        fp = open(options.file, 'rb')\n        data = fp.read()\n        blob = DPAPI_BLOB(data)\n        if self.options.key is not None:\n            key = unhexlify(self.options.key[2:])\n            if self.options.entropy_file is not None:\n                fp2 = open(self.options.entropy_file, 'rb')\n                entropy = fp2.read()\n                fp2.close()\n            elif self.options.entropy is not None:\n                entropy = b(self.options.entropy)\n            else:\n                entropy = None\n            decrypted = blob.decrypt(key, entropy)\n            if decrypted is not None:\n                print('Successfully decrypted data')\n                hexdump(decrypted)\n                return\n        else:\n            blob.dump()\n    elif self.options.action.upper() == 'CREDHIST':\n        fp = open(self.options.file, 'rb')\n        data = fp.read()\n        chf = CREDHIST_FILE(data)\n        if len(chf.credhist_entries_list) == 0:\n            print('The CREDHIST file is empty')\n            return\n        if self.options.key:\n            key = unhexlify(self.options.key[2:])\n            keys = deriveKeysFromUserkey(chf.credhist_entries_list[0].sid, key)\n        else:\n            if self.options.password is None:\n                from getpass import getpass\n                password = getpass('Password:')\n            else:\n                password = options.password\n            keys = deriveKeysFromUser(chf.credhist_entries_list[0].sid, password)\n        if self.options.entry is None:\n            real_key = None\n            for k in keys:\n                chf.decrypt_entry_by_index(0, k)\n                if chf.credhist_entries_list[0].pwdhash is not None:\n                    real_key = k\n                    break\n            if real_key is None:\n                chf.dump()\n                print()\n                print('Cannot decrypt (wrong key or password)')\n                return\n            else:\n                chf.decrypt(real_key)\n                chf.dump()\n                if chf.credhist_entries_list[-1].pwdhash is not None:\n                    return\n        else:\n            for k in keys:\n                chf.decrypt_entry_by_index(self.options.entry, k)\n                if chf.credhist_entries_list[self.options.entry].pwdhash is not None:\n                    chf.credhist_entries_list[self.options.entry].dump()\n                    return\n            chf.credhist_entries_list[self.options.entry].dump()\n            print()\n            print('Cannot decrypt (wrong key or password)')\n            return\n    print('Cannot decrypt (specify -key or -sid whenever applicable) ')"
        ]
    }
]