[
    {
        "func_name": "streq",
        "original": "def streq(a, b):\n    return str(a) == str(b)",
        "mutated": [
            "def streq(a, b):\n    if False:\n        i = 10\n    return str(a) == str(b)",
            "def streq(a, b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return str(a) == str(b)",
            "def streq(a, b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return str(a) == str(b)",
            "def streq(a, b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return str(a) == str(b)",
            "def streq(a, b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return str(a) == str(b)"
        ]
    },
    {
        "func_name": "test_gauss_opt",
        "original": "def test_gauss_opt():\n    mat = RayTransferMatrix(1, 2, 3, 4)\n    assert mat == Matrix([[1, 2], [3, 4]])\n    assert mat == RayTransferMatrix(Matrix([[1, 2], [3, 4]]))\n    assert [mat.A, mat.B, mat.C, mat.D] == [1, 2, 3, 4]\n    (d, f, h, n1, n2, R) = symbols('d f h n1 n2 R')\n    lens = ThinLens(f)\n    assert lens == Matrix([[1, 0], [-1 / f, 1]])\n    assert lens.C == -1 / f\n    assert FreeSpace(d) == Matrix([[1, d], [0, 1]])\n    assert FlatRefraction(n1, n2) == Matrix([[1, 0], [0, n1 / n2]])\n    assert CurvedRefraction(R, n1, n2) == Matrix([[1, 0], [(n1 - n2) / (R * n2), n1 / n2]])\n    assert FlatMirror() == Matrix([[1, 0], [0, 1]])\n    assert CurvedMirror(R) == Matrix([[1, 0], [-2 / R, 1]])\n    assert ThinLens(f) == Matrix([[1, 0], [-1 / f, 1]])\n    mul = CurvedMirror(R) * FreeSpace(d)\n    mul_mat = Matrix([[1, 0], [-2 / R, 1]]) * Matrix([[1, d], [0, 1]])\n    assert mul.A == mul_mat[0, 0]\n    assert mul.B == mul_mat[0, 1]\n    assert mul.C == mul_mat[1, 0]\n    assert mul.D == mul_mat[1, 1]\n    angle = symbols('angle')\n    assert GeometricRay(h, angle) == Matrix([[h], [angle]])\n    assert FreeSpace(d) * GeometricRay(h, angle) == Matrix([[angle * d + h], [angle]])\n    assert GeometricRay(Matrix(((h,), (angle,)))) == Matrix([[h], [angle]])\n    assert (FreeSpace(d) * GeometricRay(h, angle)).height == angle * d + h\n    assert (FreeSpace(d) * GeometricRay(h, angle)).angle == angle\n    p = BeamParameter(5.3e-07, 1, w=0.001)\n    assert streq(p.q, 1 + 1.88679245283019 * I * pi)\n    assert streq(N(p.q), 1.0 + 5.92753330865999 * I)\n    assert streq(N(p.w_0), Float(0.001))\n    assert streq(N(p.z_r), Float(5.92753330865999))\n    fs = FreeSpace(10)\n    p1 = fs * p\n    assert streq(N(p.w), Float(0.00101413072159615))\n    assert streq(N(p1.w), Float(0.00210803120913829))\n    (w, wavelen) = symbols('w wavelen')\n    assert waist2rayleigh(w, wavelen) == pi * w ** 2 / wavelen\n    (z_r, wavelen) = symbols('z_r wavelen')\n    assert rayleigh2waist(z_r, wavelen) == sqrt(wavelen * z_r) / sqrt(pi)\n    (a, b, f) = symbols('a b f')\n    assert geometric_conj_ab(a, b) == a * b / (a + b)\n    assert geometric_conj_af(a, f) == a * f / (a - f)\n    assert geometric_conj_bf(b, f) == b * f / (b - f)\n    assert geometric_conj_ab(oo, b) == b\n    assert geometric_conj_ab(a, oo) == a\n    (s_in, z_r_in, f) = symbols('s_in z_r_in f')\n    assert gaussian_conj(s_in, z_r_in, f)[0] == 1 / (-1 / (s_in + z_r_in ** 2 / (-f + s_in)) + 1 / f)\n    assert gaussian_conj(s_in, z_r_in, f)[1] == z_r_in / (1 - s_in ** 2 / f ** 2 + z_r_in ** 2 / f ** 2)\n    assert gaussian_conj(s_in, z_r_in, f)[2] == 1 / sqrt(1 - s_in ** 2 / f ** 2 + z_r_in ** 2 / f ** 2)\n    (l, w_i, w_o, f) = symbols('l w_i w_o f')\n    assert conjugate_gauss_beams(l, w_i, w_o, f=f)[0] == f * (-sqrt(w_i ** 2 / w_o ** 2 - pi ** 2 * w_i ** 4 / (f ** 2 * l ** 2)) + 1)\n    assert factor(conjugate_gauss_beams(l, w_i, w_o, f=f)[1]) == f * w_o ** 2 * (w_i ** 2 / w_o ** 2 - sqrt(w_i ** 2 / w_o ** 2 - pi ** 2 * w_i ** 4 / (f ** 2 * l ** 2))) / w_i ** 2\n    assert conjugate_gauss_beams(l, w_i, w_o, f=f)[2] == f\n    (z, l, w_0) = symbols('z l w_0', positive=True)\n    p = BeamParameter(l, z, w=w_0)\n    assert p.radius == z * (pi ** 2 * w_0 ** 4 / (l ** 2 * z ** 2) + 1)\n    assert p.w == w_0 * sqrt(l ** 2 * z ** 2 / (pi ** 2 * w_0 ** 4) + 1)\n    assert p.w_0 == w_0\n    assert p.divergence == l / (pi * w_0)\n    assert p.gouy == atan2(z, pi * w_0 ** 2 / l)\n    assert p.waist_approximation_limit == 2 * l / pi\n    p = BeamParameter(5.3e-07, 1, w=0.001, n=2)\n    assert streq(p.q, 1 + 3.77358490566038 * I * pi)\n    assert streq(N(p.z_r), Float(11.85506661732))\n    assert streq(N(p.w_0), Float(0.001))",
        "mutated": [
            "def test_gauss_opt():\n    if False:\n        i = 10\n    mat = RayTransferMatrix(1, 2, 3, 4)\n    assert mat == Matrix([[1, 2], [3, 4]])\n    assert mat == RayTransferMatrix(Matrix([[1, 2], [3, 4]]))\n    assert [mat.A, mat.B, mat.C, mat.D] == [1, 2, 3, 4]\n    (d, f, h, n1, n2, R) = symbols('d f h n1 n2 R')\n    lens = ThinLens(f)\n    assert lens == Matrix([[1, 0], [-1 / f, 1]])\n    assert lens.C == -1 / f\n    assert FreeSpace(d) == Matrix([[1, d], [0, 1]])\n    assert FlatRefraction(n1, n2) == Matrix([[1, 0], [0, n1 / n2]])\n    assert CurvedRefraction(R, n1, n2) == Matrix([[1, 0], [(n1 - n2) / (R * n2), n1 / n2]])\n    assert FlatMirror() == Matrix([[1, 0], [0, 1]])\n    assert CurvedMirror(R) == Matrix([[1, 0], [-2 / R, 1]])\n    assert ThinLens(f) == Matrix([[1, 0], [-1 / f, 1]])\n    mul = CurvedMirror(R) * FreeSpace(d)\n    mul_mat = Matrix([[1, 0], [-2 / R, 1]]) * Matrix([[1, d], [0, 1]])\n    assert mul.A == mul_mat[0, 0]\n    assert mul.B == mul_mat[0, 1]\n    assert mul.C == mul_mat[1, 0]\n    assert mul.D == mul_mat[1, 1]\n    angle = symbols('angle')\n    assert GeometricRay(h, angle) == Matrix([[h], [angle]])\n    assert FreeSpace(d) * GeometricRay(h, angle) == Matrix([[angle * d + h], [angle]])\n    assert GeometricRay(Matrix(((h,), (angle,)))) == Matrix([[h], [angle]])\n    assert (FreeSpace(d) * GeometricRay(h, angle)).height == angle * d + h\n    assert (FreeSpace(d) * GeometricRay(h, angle)).angle == angle\n    p = BeamParameter(5.3e-07, 1, w=0.001)\n    assert streq(p.q, 1 + 1.88679245283019 * I * pi)\n    assert streq(N(p.q), 1.0 + 5.92753330865999 * I)\n    assert streq(N(p.w_0), Float(0.001))\n    assert streq(N(p.z_r), Float(5.92753330865999))\n    fs = FreeSpace(10)\n    p1 = fs * p\n    assert streq(N(p.w), Float(0.00101413072159615))\n    assert streq(N(p1.w), Float(0.00210803120913829))\n    (w, wavelen) = symbols('w wavelen')\n    assert waist2rayleigh(w, wavelen) == pi * w ** 2 / wavelen\n    (z_r, wavelen) = symbols('z_r wavelen')\n    assert rayleigh2waist(z_r, wavelen) == sqrt(wavelen * z_r) / sqrt(pi)\n    (a, b, f) = symbols('a b f')\n    assert geometric_conj_ab(a, b) == a * b / (a + b)\n    assert geometric_conj_af(a, f) == a * f / (a - f)\n    assert geometric_conj_bf(b, f) == b * f / (b - f)\n    assert geometric_conj_ab(oo, b) == b\n    assert geometric_conj_ab(a, oo) == a\n    (s_in, z_r_in, f) = symbols('s_in z_r_in f')\n    assert gaussian_conj(s_in, z_r_in, f)[0] == 1 / (-1 / (s_in + z_r_in ** 2 / (-f + s_in)) + 1 / f)\n    assert gaussian_conj(s_in, z_r_in, f)[1] == z_r_in / (1 - s_in ** 2 / f ** 2 + z_r_in ** 2 / f ** 2)\n    assert gaussian_conj(s_in, z_r_in, f)[2] == 1 / sqrt(1 - s_in ** 2 / f ** 2 + z_r_in ** 2 / f ** 2)\n    (l, w_i, w_o, f) = symbols('l w_i w_o f')\n    assert conjugate_gauss_beams(l, w_i, w_o, f=f)[0] == f * (-sqrt(w_i ** 2 / w_o ** 2 - pi ** 2 * w_i ** 4 / (f ** 2 * l ** 2)) + 1)\n    assert factor(conjugate_gauss_beams(l, w_i, w_o, f=f)[1]) == f * w_o ** 2 * (w_i ** 2 / w_o ** 2 - sqrt(w_i ** 2 / w_o ** 2 - pi ** 2 * w_i ** 4 / (f ** 2 * l ** 2))) / w_i ** 2\n    assert conjugate_gauss_beams(l, w_i, w_o, f=f)[2] == f\n    (z, l, w_0) = symbols('z l w_0', positive=True)\n    p = BeamParameter(l, z, w=w_0)\n    assert p.radius == z * (pi ** 2 * w_0 ** 4 / (l ** 2 * z ** 2) + 1)\n    assert p.w == w_0 * sqrt(l ** 2 * z ** 2 / (pi ** 2 * w_0 ** 4) + 1)\n    assert p.w_0 == w_0\n    assert p.divergence == l / (pi * w_0)\n    assert p.gouy == atan2(z, pi * w_0 ** 2 / l)\n    assert p.waist_approximation_limit == 2 * l / pi\n    p = BeamParameter(5.3e-07, 1, w=0.001, n=2)\n    assert streq(p.q, 1 + 3.77358490566038 * I * pi)\n    assert streq(N(p.z_r), Float(11.85506661732))\n    assert streq(N(p.w_0), Float(0.001))",
            "def test_gauss_opt():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mat = RayTransferMatrix(1, 2, 3, 4)\n    assert mat == Matrix([[1, 2], [3, 4]])\n    assert mat == RayTransferMatrix(Matrix([[1, 2], [3, 4]]))\n    assert [mat.A, mat.B, mat.C, mat.D] == [1, 2, 3, 4]\n    (d, f, h, n1, n2, R) = symbols('d f h n1 n2 R')\n    lens = ThinLens(f)\n    assert lens == Matrix([[1, 0], [-1 / f, 1]])\n    assert lens.C == -1 / f\n    assert FreeSpace(d) == Matrix([[1, d], [0, 1]])\n    assert FlatRefraction(n1, n2) == Matrix([[1, 0], [0, n1 / n2]])\n    assert CurvedRefraction(R, n1, n2) == Matrix([[1, 0], [(n1 - n2) / (R * n2), n1 / n2]])\n    assert FlatMirror() == Matrix([[1, 0], [0, 1]])\n    assert CurvedMirror(R) == Matrix([[1, 0], [-2 / R, 1]])\n    assert ThinLens(f) == Matrix([[1, 0], [-1 / f, 1]])\n    mul = CurvedMirror(R) * FreeSpace(d)\n    mul_mat = Matrix([[1, 0], [-2 / R, 1]]) * Matrix([[1, d], [0, 1]])\n    assert mul.A == mul_mat[0, 0]\n    assert mul.B == mul_mat[0, 1]\n    assert mul.C == mul_mat[1, 0]\n    assert mul.D == mul_mat[1, 1]\n    angle = symbols('angle')\n    assert GeometricRay(h, angle) == Matrix([[h], [angle]])\n    assert FreeSpace(d) * GeometricRay(h, angle) == Matrix([[angle * d + h], [angle]])\n    assert GeometricRay(Matrix(((h,), (angle,)))) == Matrix([[h], [angle]])\n    assert (FreeSpace(d) * GeometricRay(h, angle)).height == angle * d + h\n    assert (FreeSpace(d) * GeometricRay(h, angle)).angle == angle\n    p = BeamParameter(5.3e-07, 1, w=0.001)\n    assert streq(p.q, 1 + 1.88679245283019 * I * pi)\n    assert streq(N(p.q), 1.0 + 5.92753330865999 * I)\n    assert streq(N(p.w_0), Float(0.001))\n    assert streq(N(p.z_r), Float(5.92753330865999))\n    fs = FreeSpace(10)\n    p1 = fs * p\n    assert streq(N(p.w), Float(0.00101413072159615))\n    assert streq(N(p1.w), Float(0.00210803120913829))\n    (w, wavelen) = symbols('w wavelen')\n    assert waist2rayleigh(w, wavelen) == pi * w ** 2 / wavelen\n    (z_r, wavelen) = symbols('z_r wavelen')\n    assert rayleigh2waist(z_r, wavelen) == sqrt(wavelen * z_r) / sqrt(pi)\n    (a, b, f) = symbols('a b f')\n    assert geometric_conj_ab(a, b) == a * b / (a + b)\n    assert geometric_conj_af(a, f) == a * f / (a - f)\n    assert geometric_conj_bf(b, f) == b * f / (b - f)\n    assert geometric_conj_ab(oo, b) == b\n    assert geometric_conj_ab(a, oo) == a\n    (s_in, z_r_in, f) = symbols('s_in z_r_in f')\n    assert gaussian_conj(s_in, z_r_in, f)[0] == 1 / (-1 / (s_in + z_r_in ** 2 / (-f + s_in)) + 1 / f)\n    assert gaussian_conj(s_in, z_r_in, f)[1] == z_r_in / (1 - s_in ** 2 / f ** 2 + z_r_in ** 2 / f ** 2)\n    assert gaussian_conj(s_in, z_r_in, f)[2] == 1 / sqrt(1 - s_in ** 2 / f ** 2 + z_r_in ** 2 / f ** 2)\n    (l, w_i, w_o, f) = symbols('l w_i w_o f')\n    assert conjugate_gauss_beams(l, w_i, w_o, f=f)[0] == f * (-sqrt(w_i ** 2 / w_o ** 2 - pi ** 2 * w_i ** 4 / (f ** 2 * l ** 2)) + 1)\n    assert factor(conjugate_gauss_beams(l, w_i, w_o, f=f)[1]) == f * w_o ** 2 * (w_i ** 2 / w_o ** 2 - sqrt(w_i ** 2 / w_o ** 2 - pi ** 2 * w_i ** 4 / (f ** 2 * l ** 2))) / w_i ** 2\n    assert conjugate_gauss_beams(l, w_i, w_o, f=f)[2] == f\n    (z, l, w_0) = symbols('z l w_0', positive=True)\n    p = BeamParameter(l, z, w=w_0)\n    assert p.radius == z * (pi ** 2 * w_0 ** 4 / (l ** 2 * z ** 2) + 1)\n    assert p.w == w_0 * sqrt(l ** 2 * z ** 2 / (pi ** 2 * w_0 ** 4) + 1)\n    assert p.w_0 == w_0\n    assert p.divergence == l / (pi * w_0)\n    assert p.gouy == atan2(z, pi * w_0 ** 2 / l)\n    assert p.waist_approximation_limit == 2 * l / pi\n    p = BeamParameter(5.3e-07, 1, w=0.001, n=2)\n    assert streq(p.q, 1 + 3.77358490566038 * I * pi)\n    assert streq(N(p.z_r), Float(11.85506661732))\n    assert streq(N(p.w_0), Float(0.001))",
            "def test_gauss_opt():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mat = RayTransferMatrix(1, 2, 3, 4)\n    assert mat == Matrix([[1, 2], [3, 4]])\n    assert mat == RayTransferMatrix(Matrix([[1, 2], [3, 4]]))\n    assert [mat.A, mat.B, mat.C, mat.D] == [1, 2, 3, 4]\n    (d, f, h, n1, n2, R) = symbols('d f h n1 n2 R')\n    lens = ThinLens(f)\n    assert lens == Matrix([[1, 0], [-1 / f, 1]])\n    assert lens.C == -1 / f\n    assert FreeSpace(d) == Matrix([[1, d], [0, 1]])\n    assert FlatRefraction(n1, n2) == Matrix([[1, 0], [0, n1 / n2]])\n    assert CurvedRefraction(R, n1, n2) == Matrix([[1, 0], [(n1 - n2) / (R * n2), n1 / n2]])\n    assert FlatMirror() == Matrix([[1, 0], [0, 1]])\n    assert CurvedMirror(R) == Matrix([[1, 0], [-2 / R, 1]])\n    assert ThinLens(f) == Matrix([[1, 0], [-1 / f, 1]])\n    mul = CurvedMirror(R) * FreeSpace(d)\n    mul_mat = Matrix([[1, 0], [-2 / R, 1]]) * Matrix([[1, d], [0, 1]])\n    assert mul.A == mul_mat[0, 0]\n    assert mul.B == mul_mat[0, 1]\n    assert mul.C == mul_mat[1, 0]\n    assert mul.D == mul_mat[1, 1]\n    angle = symbols('angle')\n    assert GeometricRay(h, angle) == Matrix([[h], [angle]])\n    assert FreeSpace(d) * GeometricRay(h, angle) == Matrix([[angle * d + h], [angle]])\n    assert GeometricRay(Matrix(((h,), (angle,)))) == Matrix([[h], [angle]])\n    assert (FreeSpace(d) * GeometricRay(h, angle)).height == angle * d + h\n    assert (FreeSpace(d) * GeometricRay(h, angle)).angle == angle\n    p = BeamParameter(5.3e-07, 1, w=0.001)\n    assert streq(p.q, 1 + 1.88679245283019 * I * pi)\n    assert streq(N(p.q), 1.0 + 5.92753330865999 * I)\n    assert streq(N(p.w_0), Float(0.001))\n    assert streq(N(p.z_r), Float(5.92753330865999))\n    fs = FreeSpace(10)\n    p1 = fs * p\n    assert streq(N(p.w), Float(0.00101413072159615))\n    assert streq(N(p1.w), Float(0.00210803120913829))\n    (w, wavelen) = symbols('w wavelen')\n    assert waist2rayleigh(w, wavelen) == pi * w ** 2 / wavelen\n    (z_r, wavelen) = symbols('z_r wavelen')\n    assert rayleigh2waist(z_r, wavelen) == sqrt(wavelen * z_r) / sqrt(pi)\n    (a, b, f) = symbols('a b f')\n    assert geometric_conj_ab(a, b) == a * b / (a + b)\n    assert geometric_conj_af(a, f) == a * f / (a - f)\n    assert geometric_conj_bf(b, f) == b * f / (b - f)\n    assert geometric_conj_ab(oo, b) == b\n    assert geometric_conj_ab(a, oo) == a\n    (s_in, z_r_in, f) = symbols('s_in z_r_in f')\n    assert gaussian_conj(s_in, z_r_in, f)[0] == 1 / (-1 / (s_in + z_r_in ** 2 / (-f + s_in)) + 1 / f)\n    assert gaussian_conj(s_in, z_r_in, f)[1] == z_r_in / (1 - s_in ** 2 / f ** 2 + z_r_in ** 2 / f ** 2)\n    assert gaussian_conj(s_in, z_r_in, f)[2] == 1 / sqrt(1 - s_in ** 2 / f ** 2 + z_r_in ** 2 / f ** 2)\n    (l, w_i, w_o, f) = symbols('l w_i w_o f')\n    assert conjugate_gauss_beams(l, w_i, w_o, f=f)[0] == f * (-sqrt(w_i ** 2 / w_o ** 2 - pi ** 2 * w_i ** 4 / (f ** 2 * l ** 2)) + 1)\n    assert factor(conjugate_gauss_beams(l, w_i, w_o, f=f)[1]) == f * w_o ** 2 * (w_i ** 2 / w_o ** 2 - sqrt(w_i ** 2 / w_o ** 2 - pi ** 2 * w_i ** 4 / (f ** 2 * l ** 2))) / w_i ** 2\n    assert conjugate_gauss_beams(l, w_i, w_o, f=f)[2] == f\n    (z, l, w_0) = symbols('z l w_0', positive=True)\n    p = BeamParameter(l, z, w=w_0)\n    assert p.radius == z * (pi ** 2 * w_0 ** 4 / (l ** 2 * z ** 2) + 1)\n    assert p.w == w_0 * sqrt(l ** 2 * z ** 2 / (pi ** 2 * w_0 ** 4) + 1)\n    assert p.w_0 == w_0\n    assert p.divergence == l / (pi * w_0)\n    assert p.gouy == atan2(z, pi * w_0 ** 2 / l)\n    assert p.waist_approximation_limit == 2 * l / pi\n    p = BeamParameter(5.3e-07, 1, w=0.001, n=2)\n    assert streq(p.q, 1 + 3.77358490566038 * I * pi)\n    assert streq(N(p.z_r), Float(11.85506661732))\n    assert streq(N(p.w_0), Float(0.001))",
            "def test_gauss_opt():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mat = RayTransferMatrix(1, 2, 3, 4)\n    assert mat == Matrix([[1, 2], [3, 4]])\n    assert mat == RayTransferMatrix(Matrix([[1, 2], [3, 4]]))\n    assert [mat.A, mat.B, mat.C, mat.D] == [1, 2, 3, 4]\n    (d, f, h, n1, n2, R) = symbols('d f h n1 n2 R')\n    lens = ThinLens(f)\n    assert lens == Matrix([[1, 0], [-1 / f, 1]])\n    assert lens.C == -1 / f\n    assert FreeSpace(d) == Matrix([[1, d], [0, 1]])\n    assert FlatRefraction(n1, n2) == Matrix([[1, 0], [0, n1 / n2]])\n    assert CurvedRefraction(R, n1, n2) == Matrix([[1, 0], [(n1 - n2) / (R * n2), n1 / n2]])\n    assert FlatMirror() == Matrix([[1, 0], [0, 1]])\n    assert CurvedMirror(R) == Matrix([[1, 0], [-2 / R, 1]])\n    assert ThinLens(f) == Matrix([[1, 0], [-1 / f, 1]])\n    mul = CurvedMirror(R) * FreeSpace(d)\n    mul_mat = Matrix([[1, 0], [-2 / R, 1]]) * Matrix([[1, d], [0, 1]])\n    assert mul.A == mul_mat[0, 0]\n    assert mul.B == mul_mat[0, 1]\n    assert mul.C == mul_mat[1, 0]\n    assert mul.D == mul_mat[1, 1]\n    angle = symbols('angle')\n    assert GeometricRay(h, angle) == Matrix([[h], [angle]])\n    assert FreeSpace(d) * GeometricRay(h, angle) == Matrix([[angle * d + h], [angle]])\n    assert GeometricRay(Matrix(((h,), (angle,)))) == Matrix([[h], [angle]])\n    assert (FreeSpace(d) * GeometricRay(h, angle)).height == angle * d + h\n    assert (FreeSpace(d) * GeometricRay(h, angle)).angle == angle\n    p = BeamParameter(5.3e-07, 1, w=0.001)\n    assert streq(p.q, 1 + 1.88679245283019 * I * pi)\n    assert streq(N(p.q), 1.0 + 5.92753330865999 * I)\n    assert streq(N(p.w_0), Float(0.001))\n    assert streq(N(p.z_r), Float(5.92753330865999))\n    fs = FreeSpace(10)\n    p1 = fs * p\n    assert streq(N(p.w), Float(0.00101413072159615))\n    assert streq(N(p1.w), Float(0.00210803120913829))\n    (w, wavelen) = symbols('w wavelen')\n    assert waist2rayleigh(w, wavelen) == pi * w ** 2 / wavelen\n    (z_r, wavelen) = symbols('z_r wavelen')\n    assert rayleigh2waist(z_r, wavelen) == sqrt(wavelen * z_r) / sqrt(pi)\n    (a, b, f) = symbols('a b f')\n    assert geometric_conj_ab(a, b) == a * b / (a + b)\n    assert geometric_conj_af(a, f) == a * f / (a - f)\n    assert geometric_conj_bf(b, f) == b * f / (b - f)\n    assert geometric_conj_ab(oo, b) == b\n    assert geometric_conj_ab(a, oo) == a\n    (s_in, z_r_in, f) = symbols('s_in z_r_in f')\n    assert gaussian_conj(s_in, z_r_in, f)[0] == 1 / (-1 / (s_in + z_r_in ** 2 / (-f + s_in)) + 1 / f)\n    assert gaussian_conj(s_in, z_r_in, f)[1] == z_r_in / (1 - s_in ** 2 / f ** 2 + z_r_in ** 2 / f ** 2)\n    assert gaussian_conj(s_in, z_r_in, f)[2] == 1 / sqrt(1 - s_in ** 2 / f ** 2 + z_r_in ** 2 / f ** 2)\n    (l, w_i, w_o, f) = symbols('l w_i w_o f')\n    assert conjugate_gauss_beams(l, w_i, w_o, f=f)[0] == f * (-sqrt(w_i ** 2 / w_o ** 2 - pi ** 2 * w_i ** 4 / (f ** 2 * l ** 2)) + 1)\n    assert factor(conjugate_gauss_beams(l, w_i, w_o, f=f)[1]) == f * w_o ** 2 * (w_i ** 2 / w_o ** 2 - sqrt(w_i ** 2 / w_o ** 2 - pi ** 2 * w_i ** 4 / (f ** 2 * l ** 2))) / w_i ** 2\n    assert conjugate_gauss_beams(l, w_i, w_o, f=f)[2] == f\n    (z, l, w_0) = symbols('z l w_0', positive=True)\n    p = BeamParameter(l, z, w=w_0)\n    assert p.radius == z * (pi ** 2 * w_0 ** 4 / (l ** 2 * z ** 2) + 1)\n    assert p.w == w_0 * sqrt(l ** 2 * z ** 2 / (pi ** 2 * w_0 ** 4) + 1)\n    assert p.w_0 == w_0\n    assert p.divergence == l / (pi * w_0)\n    assert p.gouy == atan2(z, pi * w_0 ** 2 / l)\n    assert p.waist_approximation_limit == 2 * l / pi\n    p = BeamParameter(5.3e-07, 1, w=0.001, n=2)\n    assert streq(p.q, 1 + 3.77358490566038 * I * pi)\n    assert streq(N(p.z_r), Float(11.85506661732))\n    assert streq(N(p.w_0), Float(0.001))",
            "def test_gauss_opt():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mat = RayTransferMatrix(1, 2, 3, 4)\n    assert mat == Matrix([[1, 2], [3, 4]])\n    assert mat == RayTransferMatrix(Matrix([[1, 2], [3, 4]]))\n    assert [mat.A, mat.B, mat.C, mat.D] == [1, 2, 3, 4]\n    (d, f, h, n1, n2, R) = symbols('d f h n1 n2 R')\n    lens = ThinLens(f)\n    assert lens == Matrix([[1, 0], [-1 / f, 1]])\n    assert lens.C == -1 / f\n    assert FreeSpace(d) == Matrix([[1, d], [0, 1]])\n    assert FlatRefraction(n1, n2) == Matrix([[1, 0], [0, n1 / n2]])\n    assert CurvedRefraction(R, n1, n2) == Matrix([[1, 0], [(n1 - n2) / (R * n2), n1 / n2]])\n    assert FlatMirror() == Matrix([[1, 0], [0, 1]])\n    assert CurvedMirror(R) == Matrix([[1, 0], [-2 / R, 1]])\n    assert ThinLens(f) == Matrix([[1, 0], [-1 / f, 1]])\n    mul = CurvedMirror(R) * FreeSpace(d)\n    mul_mat = Matrix([[1, 0], [-2 / R, 1]]) * Matrix([[1, d], [0, 1]])\n    assert mul.A == mul_mat[0, 0]\n    assert mul.B == mul_mat[0, 1]\n    assert mul.C == mul_mat[1, 0]\n    assert mul.D == mul_mat[1, 1]\n    angle = symbols('angle')\n    assert GeometricRay(h, angle) == Matrix([[h], [angle]])\n    assert FreeSpace(d) * GeometricRay(h, angle) == Matrix([[angle * d + h], [angle]])\n    assert GeometricRay(Matrix(((h,), (angle,)))) == Matrix([[h], [angle]])\n    assert (FreeSpace(d) * GeometricRay(h, angle)).height == angle * d + h\n    assert (FreeSpace(d) * GeometricRay(h, angle)).angle == angle\n    p = BeamParameter(5.3e-07, 1, w=0.001)\n    assert streq(p.q, 1 + 1.88679245283019 * I * pi)\n    assert streq(N(p.q), 1.0 + 5.92753330865999 * I)\n    assert streq(N(p.w_0), Float(0.001))\n    assert streq(N(p.z_r), Float(5.92753330865999))\n    fs = FreeSpace(10)\n    p1 = fs * p\n    assert streq(N(p.w), Float(0.00101413072159615))\n    assert streq(N(p1.w), Float(0.00210803120913829))\n    (w, wavelen) = symbols('w wavelen')\n    assert waist2rayleigh(w, wavelen) == pi * w ** 2 / wavelen\n    (z_r, wavelen) = symbols('z_r wavelen')\n    assert rayleigh2waist(z_r, wavelen) == sqrt(wavelen * z_r) / sqrt(pi)\n    (a, b, f) = symbols('a b f')\n    assert geometric_conj_ab(a, b) == a * b / (a + b)\n    assert geometric_conj_af(a, f) == a * f / (a - f)\n    assert geometric_conj_bf(b, f) == b * f / (b - f)\n    assert geometric_conj_ab(oo, b) == b\n    assert geometric_conj_ab(a, oo) == a\n    (s_in, z_r_in, f) = symbols('s_in z_r_in f')\n    assert gaussian_conj(s_in, z_r_in, f)[0] == 1 / (-1 / (s_in + z_r_in ** 2 / (-f + s_in)) + 1 / f)\n    assert gaussian_conj(s_in, z_r_in, f)[1] == z_r_in / (1 - s_in ** 2 / f ** 2 + z_r_in ** 2 / f ** 2)\n    assert gaussian_conj(s_in, z_r_in, f)[2] == 1 / sqrt(1 - s_in ** 2 / f ** 2 + z_r_in ** 2 / f ** 2)\n    (l, w_i, w_o, f) = symbols('l w_i w_o f')\n    assert conjugate_gauss_beams(l, w_i, w_o, f=f)[0] == f * (-sqrt(w_i ** 2 / w_o ** 2 - pi ** 2 * w_i ** 4 / (f ** 2 * l ** 2)) + 1)\n    assert factor(conjugate_gauss_beams(l, w_i, w_o, f=f)[1]) == f * w_o ** 2 * (w_i ** 2 / w_o ** 2 - sqrt(w_i ** 2 / w_o ** 2 - pi ** 2 * w_i ** 4 / (f ** 2 * l ** 2))) / w_i ** 2\n    assert conjugate_gauss_beams(l, w_i, w_o, f=f)[2] == f\n    (z, l, w_0) = symbols('z l w_0', positive=True)\n    p = BeamParameter(l, z, w=w_0)\n    assert p.radius == z * (pi ** 2 * w_0 ** 4 / (l ** 2 * z ** 2) + 1)\n    assert p.w == w_0 * sqrt(l ** 2 * z ** 2 / (pi ** 2 * w_0 ** 4) + 1)\n    assert p.w_0 == w_0\n    assert p.divergence == l / (pi * w_0)\n    assert p.gouy == atan2(z, pi * w_0 ** 2 / l)\n    assert p.waist_approximation_limit == 2 * l / pi\n    p = BeamParameter(5.3e-07, 1, w=0.001, n=2)\n    assert streq(p.q, 1 + 3.77358490566038 * I * pi)\n    assert streq(N(p.z_r), Float(11.85506661732))\n    assert streq(N(p.w_0), Float(0.001))"
        ]
    }
]