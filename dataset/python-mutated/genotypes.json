[
    {
        "func_name": "to_dag",
        "original": "def to_dag(C_in, gene, reduction, bn_affine=True):\n    \"\"\" generate discrete ops from gene \"\"\"\n    dag = nn.ModuleList()\n    for edges in gene:\n        row = nn.ModuleList()\n        for (op_name, s_idx) in edges:\n            stride = 2 if reduction and s_idx < 2 else 1\n            op = ops.OPS[op_name](C_in, stride, bn_affine)\n            if not isinstance(op, ops.Identity):\n                op = nn.Sequential(op, ops.DropPath_())\n            op.s_idx = s_idx\n            row.append(op)\n        dag.append(row)\n    return dag",
        "mutated": [
            "def to_dag(C_in, gene, reduction, bn_affine=True):\n    if False:\n        i = 10\n    ' generate discrete ops from gene '\n    dag = nn.ModuleList()\n    for edges in gene:\n        row = nn.ModuleList()\n        for (op_name, s_idx) in edges:\n            stride = 2 if reduction and s_idx < 2 else 1\n            op = ops.OPS[op_name](C_in, stride, bn_affine)\n            if not isinstance(op, ops.Identity):\n                op = nn.Sequential(op, ops.DropPath_())\n            op.s_idx = s_idx\n            row.append(op)\n        dag.append(row)\n    return dag",
            "def to_dag(C_in, gene, reduction, bn_affine=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' generate discrete ops from gene '\n    dag = nn.ModuleList()\n    for edges in gene:\n        row = nn.ModuleList()\n        for (op_name, s_idx) in edges:\n            stride = 2 if reduction and s_idx < 2 else 1\n            op = ops.OPS[op_name](C_in, stride, bn_affine)\n            if not isinstance(op, ops.Identity):\n                op = nn.Sequential(op, ops.DropPath_())\n            op.s_idx = s_idx\n            row.append(op)\n        dag.append(row)\n    return dag",
            "def to_dag(C_in, gene, reduction, bn_affine=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' generate discrete ops from gene '\n    dag = nn.ModuleList()\n    for edges in gene:\n        row = nn.ModuleList()\n        for (op_name, s_idx) in edges:\n            stride = 2 if reduction and s_idx < 2 else 1\n            op = ops.OPS[op_name](C_in, stride, bn_affine)\n            if not isinstance(op, ops.Identity):\n                op = nn.Sequential(op, ops.DropPath_())\n            op.s_idx = s_idx\n            row.append(op)\n        dag.append(row)\n    return dag",
            "def to_dag(C_in, gene, reduction, bn_affine=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' generate discrete ops from gene '\n    dag = nn.ModuleList()\n    for edges in gene:\n        row = nn.ModuleList()\n        for (op_name, s_idx) in edges:\n            stride = 2 if reduction and s_idx < 2 else 1\n            op = ops.OPS[op_name](C_in, stride, bn_affine)\n            if not isinstance(op, ops.Identity):\n                op = nn.Sequential(op, ops.DropPath_())\n            op.s_idx = s_idx\n            row.append(op)\n        dag.append(row)\n    return dag",
            "def to_dag(C_in, gene, reduction, bn_affine=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' generate discrete ops from gene '\n    dag = nn.ModuleList()\n    for edges in gene:\n        row = nn.ModuleList()\n        for (op_name, s_idx) in edges:\n            stride = 2 if reduction and s_idx < 2 else 1\n            op = ops.OPS[op_name](C_in, stride, bn_affine)\n            if not isinstance(op, ops.Identity):\n                op = nn.Sequential(op, ops.DropPath_())\n            op.s_idx = s_idx\n            row.append(op)\n        dag.append(row)\n    return dag"
        ]
    },
    {
        "func_name": "from_str",
        "original": "def from_str(s):\n    \"\"\" generate genotype from string\n    e.g. \"Genotype(\n            normal=[[('sep_conv_3x3', 0), ('sep_conv_3x3', 1)],\n                    [('sep_conv_3x3', 1), ('dil_conv_3x3', 2)],\n                    [('sep_conv_3x3', 1), ('sep_conv_3x3', 2)],\n                    [('sep_conv_3x3', 1), ('dil_conv_3x3', 4)]],\n            normal_concat=range(2, 6),\n            reduce=[[('max_pool_3x3', 0), ('max_pool_3x3', 1)],\n                    [('max_pool_3x3', 0), ('skip_connect', 2)],\n                    [('max_pool_3x3', 0), ('skip_connect', 2)],\n                    [('max_pool_3x3', 0), ('skip_connect', 2)]],\n            reduce_concat=range(2, 6))\"\n    \"\"\"\n    genotype = eval(s)\n    return genotype",
        "mutated": [
            "def from_str(s):\n    if False:\n        i = 10\n    ' generate genotype from string\\n    e.g. \"Genotype(\\n            normal=[[(\\'sep_conv_3x3\\', 0), (\\'sep_conv_3x3\\', 1)],\\n                    [(\\'sep_conv_3x3\\', 1), (\\'dil_conv_3x3\\', 2)],\\n                    [(\\'sep_conv_3x3\\', 1), (\\'sep_conv_3x3\\', 2)],\\n                    [(\\'sep_conv_3x3\\', 1), (\\'dil_conv_3x3\\', 4)]],\\n            normal_concat=range(2, 6),\\n            reduce=[[(\\'max_pool_3x3\\', 0), (\\'max_pool_3x3\\', 1)],\\n                    [(\\'max_pool_3x3\\', 0), (\\'skip_connect\\', 2)],\\n                    [(\\'max_pool_3x3\\', 0), (\\'skip_connect\\', 2)],\\n                    [(\\'max_pool_3x3\\', 0), (\\'skip_connect\\', 2)]],\\n            reduce_concat=range(2, 6))\"\\n    '\n    genotype = eval(s)\n    return genotype",
            "def from_str(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' generate genotype from string\\n    e.g. \"Genotype(\\n            normal=[[(\\'sep_conv_3x3\\', 0), (\\'sep_conv_3x3\\', 1)],\\n                    [(\\'sep_conv_3x3\\', 1), (\\'dil_conv_3x3\\', 2)],\\n                    [(\\'sep_conv_3x3\\', 1), (\\'sep_conv_3x3\\', 2)],\\n                    [(\\'sep_conv_3x3\\', 1), (\\'dil_conv_3x3\\', 4)]],\\n            normal_concat=range(2, 6),\\n            reduce=[[(\\'max_pool_3x3\\', 0), (\\'max_pool_3x3\\', 1)],\\n                    [(\\'max_pool_3x3\\', 0), (\\'skip_connect\\', 2)],\\n                    [(\\'max_pool_3x3\\', 0), (\\'skip_connect\\', 2)],\\n                    [(\\'max_pool_3x3\\', 0), (\\'skip_connect\\', 2)]],\\n            reduce_concat=range(2, 6))\"\\n    '\n    genotype = eval(s)\n    return genotype",
            "def from_str(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' generate genotype from string\\n    e.g. \"Genotype(\\n            normal=[[(\\'sep_conv_3x3\\', 0), (\\'sep_conv_3x3\\', 1)],\\n                    [(\\'sep_conv_3x3\\', 1), (\\'dil_conv_3x3\\', 2)],\\n                    [(\\'sep_conv_3x3\\', 1), (\\'sep_conv_3x3\\', 2)],\\n                    [(\\'sep_conv_3x3\\', 1), (\\'dil_conv_3x3\\', 4)]],\\n            normal_concat=range(2, 6),\\n            reduce=[[(\\'max_pool_3x3\\', 0), (\\'max_pool_3x3\\', 1)],\\n                    [(\\'max_pool_3x3\\', 0), (\\'skip_connect\\', 2)],\\n                    [(\\'max_pool_3x3\\', 0), (\\'skip_connect\\', 2)],\\n                    [(\\'max_pool_3x3\\', 0), (\\'skip_connect\\', 2)]],\\n            reduce_concat=range(2, 6))\"\\n    '\n    genotype = eval(s)\n    return genotype",
            "def from_str(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' generate genotype from string\\n    e.g. \"Genotype(\\n            normal=[[(\\'sep_conv_3x3\\', 0), (\\'sep_conv_3x3\\', 1)],\\n                    [(\\'sep_conv_3x3\\', 1), (\\'dil_conv_3x3\\', 2)],\\n                    [(\\'sep_conv_3x3\\', 1), (\\'sep_conv_3x3\\', 2)],\\n                    [(\\'sep_conv_3x3\\', 1), (\\'dil_conv_3x3\\', 4)]],\\n            normal_concat=range(2, 6),\\n            reduce=[[(\\'max_pool_3x3\\', 0), (\\'max_pool_3x3\\', 1)],\\n                    [(\\'max_pool_3x3\\', 0), (\\'skip_connect\\', 2)],\\n                    [(\\'max_pool_3x3\\', 0), (\\'skip_connect\\', 2)],\\n                    [(\\'max_pool_3x3\\', 0), (\\'skip_connect\\', 2)]],\\n            reduce_concat=range(2, 6))\"\\n    '\n    genotype = eval(s)\n    return genotype",
            "def from_str(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' generate genotype from string\\n    e.g. \"Genotype(\\n            normal=[[(\\'sep_conv_3x3\\', 0), (\\'sep_conv_3x3\\', 1)],\\n                    [(\\'sep_conv_3x3\\', 1), (\\'dil_conv_3x3\\', 2)],\\n                    [(\\'sep_conv_3x3\\', 1), (\\'sep_conv_3x3\\', 2)],\\n                    [(\\'sep_conv_3x3\\', 1), (\\'dil_conv_3x3\\', 4)]],\\n            normal_concat=range(2, 6),\\n            reduce=[[(\\'max_pool_3x3\\', 0), (\\'max_pool_3x3\\', 1)],\\n                    [(\\'max_pool_3x3\\', 0), (\\'skip_connect\\', 2)],\\n                    [(\\'max_pool_3x3\\', 0), (\\'skip_connect\\', 2)],\\n                    [(\\'max_pool_3x3\\', 0), (\\'skip_connect\\', 2)]],\\n            reduce_concat=range(2, 6))\"\\n    '\n    genotype = eval(s)\n    return genotype"
        ]
    },
    {
        "func_name": "parse",
        "original": "def parse(alpha, beta, k):\n    \"\"\"\n    parse continuous alpha to discrete gene.\n    alpha is ParameterList:\n    ParameterList [\n        Parameter(n_edges1, n_ops),\n        Parameter(n_edges2, n_ops),\n        ...\n    ]\n\n    beta is ParameterList:\n    ParameterList [\n        Parameter(n_edges1),\n        Parameter(n_edges2),\n        ...\n    ]\n\n    gene is list:\n    [\n        [('node1_ops_1', node_idx), ..., ('node1_ops_k', node_idx)],\n        [('node2_ops_1', node_idx), ..., ('node2_ops_k', node_idx)],\n        ...\n    ]\n    each node has two edges (k=2) in CNN.\n    \"\"\"\n    gene = []\n    assert PRIMITIVES[-1] == 'none'\n    connect_idx = []\n    for (edges, w) in zip(alpha, beta):\n        (edge_max, primitive_indices) = torch.topk((w.view(-1, 1) * edges)[:, :-1], 1)\n        (topk_edge_values, topk_edge_indices) = torch.topk(edge_max.view(-1), k)\n        node_gene = []\n        node_idx = []\n        for edge_idx in topk_edge_indices:\n            prim_idx = primitive_indices[edge_idx]\n            prim = PRIMITIVES[prim_idx]\n            node_gene.append((prim, edge_idx.item()))\n            node_idx.append((edge_idx.item(), prim_idx.item()))\n        gene.append(node_gene)\n        connect_idx.append(node_idx)\n    return (gene, connect_idx)",
        "mutated": [
            "def parse(alpha, beta, k):\n    if False:\n        i = 10\n    \"\\n    parse continuous alpha to discrete gene.\\n    alpha is ParameterList:\\n    ParameterList [\\n        Parameter(n_edges1, n_ops),\\n        Parameter(n_edges2, n_ops),\\n        ...\\n    ]\\n\\n    beta is ParameterList:\\n    ParameterList [\\n        Parameter(n_edges1),\\n        Parameter(n_edges2),\\n        ...\\n    ]\\n\\n    gene is list:\\n    [\\n        [('node1_ops_1', node_idx), ..., ('node1_ops_k', node_idx)],\\n        [('node2_ops_1', node_idx), ..., ('node2_ops_k', node_idx)],\\n        ...\\n    ]\\n    each node has two edges (k=2) in CNN.\\n    \"\n    gene = []\n    assert PRIMITIVES[-1] == 'none'\n    connect_idx = []\n    for (edges, w) in zip(alpha, beta):\n        (edge_max, primitive_indices) = torch.topk((w.view(-1, 1) * edges)[:, :-1], 1)\n        (topk_edge_values, topk_edge_indices) = torch.topk(edge_max.view(-1), k)\n        node_gene = []\n        node_idx = []\n        for edge_idx in topk_edge_indices:\n            prim_idx = primitive_indices[edge_idx]\n            prim = PRIMITIVES[prim_idx]\n            node_gene.append((prim, edge_idx.item()))\n            node_idx.append((edge_idx.item(), prim_idx.item()))\n        gene.append(node_gene)\n        connect_idx.append(node_idx)\n    return (gene, connect_idx)",
            "def parse(alpha, beta, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    parse continuous alpha to discrete gene.\\n    alpha is ParameterList:\\n    ParameterList [\\n        Parameter(n_edges1, n_ops),\\n        Parameter(n_edges2, n_ops),\\n        ...\\n    ]\\n\\n    beta is ParameterList:\\n    ParameterList [\\n        Parameter(n_edges1),\\n        Parameter(n_edges2),\\n        ...\\n    ]\\n\\n    gene is list:\\n    [\\n        [('node1_ops_1', node_idx), ..., ('node1_ops_k', node_idx)],\\n        [('node2_ops_1', node_idx), ..., ('node2_ops_k', node_idx)],\\n        ...\\n    ]\\n    each node has two edges (k=2) in CNN.\\n    \"\n    gene = []\n    assert PRIMITIVES[-1] == 'none'\n    connect_idx = []\n    for (edges, w) in zip(alpha, beta):\n        (edge_max, primitive_indices) = torch.topk((w.view(-1, 1) * edges)[:, :-1], 1)\n        (topk_edge_values, topk_edge_indices) = torch.topk(edge_max.view(-1), k)\n        node_gene = []\n        node_idx = []\n        for edge_idx in topk_edge_indices:\n            prim_idx = primitive_indices[edge_idx]\n            prim = PRIMITIVES[prim_idx]\n            node_gene.append((prim, edge_idx.item()))\n            node_idx.append((edge_idx.item(), prim_idx.item()))\n        gene.append(node_gene)\n        connect_idx.append(node_idx)\n    return (gene, connect_idx)",
            "def parse(alpha, beta, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    parse continuous alpha to discrete gene.\\n    alpha is ParameterList:\\n    ParameterList [\\n        Parameter(n_edges1, n_ops),\\n        Parameter(n_edges2, n_ops),\\n        ...\\n    ]\\n\\n    beta is ParameterList:\\n    ParameterList [\\n        Parameter(n_edges1),\\n        Parameter(n_edges2),\\n        ...\\n    ]\\n\\n    gene is list:\\n    [\\n        [('node1_ops_1', node_idx), ..., ('node1_ops_k', node_idx)],\\n        [('node2_ops_1', node_idx), ..., ('node2_ops_k', node_idx)],\\n        ...\\n    ]\\n    each node has two edges (k=2) in CNN.\\n    \"\n    gene = []\n    assert PRIMITIVES[-1] == 'none'\n    connect_idx = []\n    for (edges, w) in zip(alpha, beta):\n        (edge_max, primitive_indices) = torch.topk((w.view(-1, 1) * edges)[:, :-1], 1)\n        (topk_edge_values, topk_edge_indices) = torch.topk(edge_max.view(-1), k)\n        node_gene = []\n        node_idx = []\n        for edge_idx in topk_edge_indices:\n            prim_idx = primitive_indices[edge_idx]\n            prim = PRIMITIVES[prim_idx]\n            node_gene.append((prim, edge_idx.item()))\n            node_idx.append((edge_idx.item(), prim_idx.item()))\n        gene.append(node_gene)\n        connect_idx.append(node_idx)\n    return (gene, connect_idx)",
            "def parse(alpha, beta, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    parse continuous alpha to discrete gene.\\n    alpha is ParameterList:\\n    ParameterList [\\n        Parameter(n_edges1, n_ops),\\n        Parameter(n_edges2, n_ops),\\n        ...\\n    ]\\n\\n    beta is ParameterList:\\n    ParameterList [\\n        Parameter(n_edges1),\\n        Parameter(n_edges2),\\n        ...\\n    ]\\n\\n    gene is list:\\n    [\\n        [('node1_ops_1', node_idx), ..., ('node1_ops_k', node_idx)],\\n        [('node2_ops_1', node_idx), ..., ('node2_ops_k', node_idx)],\\n        ...\\n    ]\\n    each node has two edges (k=2) in CNN.\\n    \"\n    gene = []\n    assert PRIMITIVES[-1] == 'none'\n    connect_idx = []\n    for (edges, w) in zip(alpha, beta):\n        (edge_max, primitive_indices) = torch.topk((w.view(-1, 1) * edges)[:, :-1], 1)\n        (topk_edge_values, topk_edge_indices) = torch.topk(edge_max.view(-1), k)\n        node_gene = []\n        node_idx = []\n        for edge_idx in topk_edge_indices:\n            prim_idx = primitive_indices[edge_idx]\n            prim = PRIMITIVES[prim_idx]\n            node_gene.append((prim, edge_idx.item()))\n            node_idx.append((edge_idx.item(), prim_idx.item()))\n        gene.append(node_gene)\n        connect_idx.append(node_idx)\n    return (gene, connect_idx)",
            "def parse(alpha, beta, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    parse continuous alpha to discrete gene.\\n    alpha is ParameterList:\\n    ParameterList [\\n        Parameter(n_edges1, n_ops),\\n        Parameter(n_edges2, n_ops),\\n        ...\\n    ]\\n\\n    beta is ParameterList:\\n    ParameterList [\\n        Parameter(n_edges1),\\n        Parameter(n_edges2),\\n        ...\\n    ]\\n\\n    gene is list:\\n    [\\n        [('node1_ops_1', node_idx), ..., ('node1_ops_k', node_idx)],\\n        [('node2_ops_1', node_idx), ..., ('node2_ops_k', node_idx)],\\n        ...\\n    ]\\n    each node has two edges (k=2) in CNN.\\n    \"\n    gene = []\n    assert PRIMITIVES[-1] == 'none'\n    connect_idx = []\n    for (edges, w) in zip(alpha, beta):\n        (edge_max, primitive_indices) = torch.topk((w.view(-1, 1) * edges)[:, :-1], 1)\n        (topk_edge_values, topk_edge_indices) = torch.topk(edge_max.view(-1), k)\n        node_gene = []\n        node_idx = []\n        for edge_idx in topk_edge_indices:\n            prim_idx = primitive_indices[edge_idx]\n            prim = PRIMITIVES[prim_idx]\n            node_gene.append((prim, edge_idx.item()))\n            node_idx.append((edge_idx.item(), prim_idx.item()))\n        gene.append(node_gene)\n        connect_idx.append(node_idx)\n    return (gene, connect_idx)"
        ]
    },
    {
        "func_name": "parse_gumbel",
        "original": "def parse_gumbel(alpha, beta, k):\n    \"\"\"\n    parse continuous alpha to discrete gene.\n    alpha is ParameterList:\n    ParameterList [\n        Parameter(n_edges1, n_ops),\n        Parameter(n_edges2, n_ops),\n        ...\n    ]\n\n    beta is ParameterList:\n    ParameterList [\n        Parameter(n_edges1),\n        Parameter(n_edges2),\n        ...\n    ]\n\n    gene is list:\n    [\n        [('node1_ops_1', node_idx), ..., ('node1_ops_k', node_idx)],\n        [('node2_ops_1', node_idx), ..., ('node2_ops_k', node_idx)],\n        ...\n    ]\n    each node has two edges (k=2) in CNN.\n    \"\"\"\n    gene = []\n    assert PRIMITIVES[-1] == 'none'\n    connect_idx = []\n    for (edges, w) in zip(alpha, beta):\n        discrete_a = F.gumbel_softmax(edges[:, :-1].reshape(-1), tau=1, hard=True)\n        for i in range(k - 1):\n            discrete_a = discrete_a + F.gumbel_softmax(edges[:, :-1].reshape(-1), tau=1, hard=True)\n        discrete_a = discrete_a.reshape(-1, len(PRIMITIVES) - 1)\n        reserved_edge = (discrete_a > 0).nonzero()\n        node_gene = []\n        node_idx = []\n        for i in range(reserved_edge.shape[0]):\n            edge_idx = reserved_edge[i][0].item()\n            prim_idx = reserved_edge[i][1].item()\n            prim = PRIMITIVES[prim_idx]\n            node_gene.append((prim, edge_idx))\n            node_idx.append((edge_idx, prim_idx))\n        gene.append(node_gene)\n        connect_idx.append(node_idx)\n    return (gene, connect_idx)",
        "mutated": [
            "def parse_gumbel(alpha, beta, k):\n    if False:\n        i = 10\n    \"\\n    parse continuous alpha to discrete gene.\\n    alpha is ParameterList:\\n    ParameterList [\\n        Parameter(n_edges1, n_ops),\\n        Parameter(n_edges2, n_ops),\\n        ...\\n    ]\\n\\n    beta is ParameterList:\\n    ParameterList [\\n        Parameter(n_edges1),\\n        Parameter(n_edges2),\\n        ...\\n    ]\\n\\n    gene is list:\\n    [\\n        [('node1_ops_1', node_idx), ..., ('node1_ops_k', node_idx)],\\n        [('node2_ops_1', node_idx), ..., ('node2_ops_k', node_idx)],\\n        ...\\n    ]\\n    each node has two edges (k=2) in CNN.\\n    \"\n    gene = []\n    assert PRIMITIVES[-1] == 'none'\n    connect_idx = []\n    for (edges, w) in zip(alpha, beta):\n        discrete_a = F.gumbel_softmax(edges[:, :-1].reshape(-1), tau=1, hard=True)\n        for i in range(k - 1):\n            discrete_a = discrete_a + F.gumbel_softmax(edges[:, :-1].reshape(-1), tau=1, hard=True)\n        discrete_a = discrete_a.reshape(-1, len(PRIMITIVES) - 1)\n        reserved_edge = (discrete_a > 0).nonzero()\n        node_gene = []\n        node_idx = []\n        for i in range(reserved_edge.shape[0]):\n            edge_idx = reserved_edge[i][0].item()\n            prim_idx = reserved_edge[i][1].item()\n            prim = PRIMITIVES[prim_idx]\n            node_gene.append((prim, edge_idx))\n            node_idx.append((edge_idx, prim_idx))\n        gene.append(node_gene)\n        connect_idx.append(node_idx)\n    return (gene, connect_idx)",
            "def parse_gumbel(alpha, beta, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    parse continuous alpha to discrete gene.\\n    alpha is ParameterList:\\n    ParameterList [\\n        Parameter(n_edges1, n_ops),\\n        Parameter(n_edges2, n_ops),\\n        ...\\n    ]\\n\\n    beta is ParameterList:\\n    ParameterList [\\n        Parameter(n_edges1),\\n        Parameter(n_edges2),\\n        ...\\n    ]\\n\\n    gene is list:\\n    [\\n        [('node1_ops_1', node_idx), ..., ('node1_ops_k', node_idx)],\\n        [('node2_ops_1', node_idx), ..., ('node2_ops_k', node_idx)],\\n        ...\\n    ]\\n    each node has two edges (k=2) in CNN.\\n    \"\n    gene = []\n    assert PRIMITIVES[-1] == 'none'\n    connect_idx = []\n    for (edges, w) in zip(alpha, beta):\n        discrete_a = F.gumbel_softmax(edges[:, :-1].reshape(-1), tau=1, hard=True)\n        for i in range(k - 1):\n            discrete_a = discrete_a + F.gumbel_softmax(edges[:, :-1].reshape(-1), tau=1, hard=True)\n        discrete_a = discrete_a.reshape(-1, len(PRIMITIVES) - 1)\n        reserved_edge = (discrete_a > 0).nonzero()\n        node_gene = []\n        node_idx = []\n        for i in range(reserved_edge.shape[0]):\n            edge_idx = reserved_edge[i][0].item()\n            prim_idx = reserved_edge[i][1].item()\n            prim = PRIMITIVES[prim_idx]\n            node_gene.append((prim, edge_idx))\n            node_idx.append((edge_idx, prim_idx))\n        gene.append(node_gene)\n        connect_idx.append(node_idx)\n    return (gene, connect_idx)",
            "def parse_gumbel(alpha, beta, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    parse continuous alpha to discrete gene.\\n    alpha is ParameterList:\\n    ParameterList [\\n        Parameter(n_edges1, n_ops),\\n        Parameter(n_edges2, n_ops),\\n        ...\\n    ]\\n\\n    beta is ParameterList:\\n    ParameterList [\\n        Parameter(n_edges1),\\n        Parameter(n_edges2),\\n        ...\\n    ]\\n\\n    gene is list:\\n    [\\n        [('node1_ops_1', node_idx), ..., ('node1_ops_k', node_idx)],\\n        [('node2_ops_1', node_idx), ..., ('node2_ops_k', node_idx)],\\n        ...\\n    ]\\n    each node has two edges (k=2) in CNN.\\n    \"\n    gene = []\n    assert PRIMITIVES[-1] == 'none'\n    connect_idx = []\n    for (edges, w) in zip(alpha, beta):\n        discrete_a = F.gumbel_softmax(edges[:, :-1].reshape(-1), tau=1, hard=True)\n        for i in range(k - 1):\n            discrete_a = discrete_a + F.gumbel_softmax(edges[:, :-1].reshape(-1), tau=1, hard=True)\n        discrete_a = discrete_a.reshape(-1, len(PRIMITIVES) - 1)\n        reserved_edge = (discrete_a > 0).nonzero()\n        node_gene = []\n        node_idx = []\n        for i in range(reserved_edge.shape[0]):\n            edge_idx = reserved_edge[i][0].item()\n            prim_idx = reserved_edge[i][1].item()\n            prim = PRIMITIVES[prim_idx]\n            node_gene.append((prim, edge_idx))\n            node_idx.append((edge_idx, prim_idx))\n        gene.append(node_gene)\n        connect_idx.append(node_idx)\n    return (gene, connect_idx)",
            "def parse_gumbel(alpha, beta, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    parse continuous alpha to discrete gene.\\n    alpha is ParameterList:\\n    ParameterList [\\n        Parameter(n_edges1, n_ops),\\n        Parameter(n_edges2, n_ops),\\n        ...\\n    ]\\n\\n    beta is ParameterList:\\n    ParameterList [\\n        Parameter(n_edges1),\\n        Parameter(n_edges2),\\n        ...\\n    ]\\n\\n    gene is list:\\n    [\\n        [('node1_ops_1', node_idx), ..., ('node1_ops_k', node_idx)],\\n        [('node2_ops_1', node_idx), ..., ('node2_ops_k', node_idx)],\\n        ...\\n    ]\\n    each node has two edges (k=2) in CNN.\\n    \"\n    gene = []\n    assert PRIMITIVES[-1] == 'none'\n    connect_idx = []\n    for (edges, w) in zip(alpha, beta):\n        discrete_a = F.gumbel_softmax(edges[:, :-1].reshape(-1), tau=1, hard=True)\n        for i in range(k - 1):\n            discrete_a = discrete_a + F.gumbel_softmax(edges[:, :-1].reshape(-1), tau=1, hard=True)\n        discrete_a = discrete_a.reshape(-1, len(PRIMITIVES) - 1)\n        reserved_edge = (discrete_a > 0).nonzero()\n        node_gene = []\n        node_idx = []\n        for i in range(reserved_edge.shape[0]):\n            edge_idx = reserved_edge[i][0].item()\n            prim_idx = reserved_edge[i][1].item()\n            prim = PRIMITIVES[prim_idx]\n            node_gene.append((prim, edge_idx))\n            node_idx.append((edge_idx, prim_idx))\n        gene.append(node_gene)\n        connect_idx.append(node_idx)\n    return (gene, connect_idx)",
            "def parse_gumbel(alpha, beta, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    parse continuous alpha to discrete gene.\\n    alpha is ParameterList:\\n    ParameterList [\\n        Parameter(n_edges1, n_ops),\\n        Parameter(n_edges2, n_ops),\\n        ...\\n    ]\\n\\n    beta is ParameterList:\\n    ParameterList [\\n        Parameter(n_edges1),\\n        Parameter(n_edges2),\\n        ...\\n    ]\\n\\n    gene is list:\\n    [\\n        [('node1_ops_1', node_idx), ..., ('node1_ops_k', node_idx)],\\n        [('node2_ops_1', node_idx), ..., ('node2_ops_k', node_idx)],\\n        ...\\n    ]\\n    each node has two edges (k=2) in CNN.\\n    \"\n    gene = []\n    assert PRIMITIVES[-1] == 'none'\n    connect_idx = []\n    for (edges, w) in zip(alpha, beta):\n        discrete_a = F.gumbel_softmax(edges[:, :-1].reshape(-1), tau=1, hard=True)\n        for i in range(k - 1):\n            discrete_a = discrete_a + F.gumbel_softmax(edges[:, :-1].reshape(-1), tau=1, hard=True)\n        discrete_a = discrete_a.reshape(-1, len(PRIMITIVES) - 1)\n        reserved_edge = (discrete_a > 0).nonzero()\n        node_gene = []\n        node_idx = []\n        for i in range(reserved_edge.shape[0]):\n            edge_idx = reserved_edge[i][0].item()\n            prim_idx = reserved_edge[i][1].item()\n            prim = PRIMITIVES[prim_idx]\n            node_gene.append((prim, edge_idx))\n            node_idx.append((edge_idx, prim_idx))\n        gene.append(node_gene)\n        connect_idx.append(node_idx)\n    return (gene, connect_idx)"
        ]
    }
]