[
    {
        "func_name": "calc_scatters",
        "original": "def calc_scatters(K):\n    \"\"\"Calculate scatter matrix: scatters[i,j] = {scatter of the sequence with\n    starting frame i and ending frame j}\n    \"\"\"\n    n = K.shape[0]\n    K1 = np.cumsum([0] + list(np.diag(K)))\n    K2 = np.zeros((n + 1, n + 1))\n    K2[1:, 1:] = np.cumsum(np.cumsum(K, 0), 1)\n    diagK2 = np.diag(K2)\n    i = np.arange(n).reshape((-1, 1))\n    j = np.arange(n).reshape((1, -1))\n    ij_f32 = (j - i + 1).astype(np.float32) + (j == i - 1).astype(np.float32)\n    diagK2_K2 = diagK2[1:].reshape((1, -1)) + diagK2[:-1].reshape((-1, 1)) - K2[1:, :-1].T - K2[:-1, 1:]\n    scatters = K1[1:].reshape((1, -1)) - K1[:-1].reshape((-1, 1)) - diagK2_K2 / ij_f32\n    scatters[j < i] = 0\n    return scatters",
        "mutated": [
            "def calc_scatters(K):\n    if False:\n        i = 10\n    'Calculate scatter matrix: scatters[i,j] = {scatter of the sequence with\\n    starting frame i and ending frame j}\\n    '\n    n = K.shape[0]\n    K1 = np.cumsum([0] + list(np.diag(K)))\n    K2 = np.zeros((n + 1, n + 1))\n    K2[1:, 1:] = np.cumsum(np.cumsum(K, 0), 1)\n    diagK2 = np.diag(K2)\n    i = np.arange(n).reshape((-1, 1))\n    j = np.arange(n).reshape((1, -1))\n    ij_f32 = (j - i + 1).astype(np.float32) + (j == i - 1).astype(np.float32)\n    diagK2_K2 = diagK2[1:].reshape((1, -1)) + diagK2[:-1].reshape((-1, 1)) - K2[1:, :-1].T - K2[:-1, 1:]\n    scatters = K1[1:].reshape((1, -1)) - K1[:-1].reshape((-1, 1)) - diagK2_K2 / ij_f32\n    scatters[j < i] = 0\n    return scatters",
            "def calc_scatters(K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Calculate scatter matrix: scatters[i,j] = {scatter of the sequence with\\n    starting frame i and ending frame j}\\n    '\n    n = K.shape[0]\n    K1 = np.cumsum([0] + list(np.diag(K)))\n    K2 = np.zeros((n + 1, n + 1))\n    K2[1:, 1:] = np.cumsum(np.cumsum(K, 0), 1)\n    diagK2 = np.diag(K2)\n    i = np.arange(n).reshape((-1, 1))\n    j = np.arange(n).reshape((1, -1))\n    ij_f32 = (j - i + 1).astype(np.float32) + (j == i - 1).astype(np.float32)\n    diagK2_K2 = diagK2[1:].reshape((1, -1)) + diagK2[:-1].reshape((-1, 1)) - K2[1:, :-1].T - K2[:-1, 1:]\n    scatters = K1[1:].reshape((1, -1)) - K1[:-1].reshape((-1, 1)) - diagK2_K2 / ij_f32\n    scatters[j < i] = 0\n    return scatters",
            "def calc_scatters(K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Calculate scatter matrix: scatters[i,j] = {scatter of the sequence with\\n    starting frame i and ending frame j}\\n    '\n    n = K.shape[0]\n    K1 = np.cumsum([0] + list(np.diag(K)))\n    K2 = np.zeros((n + 1, n + 1))\n    K2[1:, 1:] = np.cumsum(np.cumsum(K, 0), 1)\n    diagK2 = np.diag(K2)\n    i = np.arange(n).reshape((-1, 1))\n    j = np.arange(n).reshape((1, -1))\n    ij_f32 = (j - i + 1).astype(np.float32) + (j == i - 1).astype(np.float32)\n    diagK2_K2 = diagK2[1:].reshape((1, -1)) + diagK2[:-1].reshape((-1, 1)) - K2[1:, :-1].T - K2[:-1, 1:]\n    scatters = K1[1:].reshape((1, -1)) - K1[:-1].reshape((-1, 1)) - diagK2_K2 / ij_f32\n    scatters[j < i] = 0\n    return scatters",
            "def calc_scatters(K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Calculate scatter matrix: scatters[i,j] = {scatter of the sequence with\\n    starting frame i and ending frame j}\\n    '\n    n = K.shape[0]\n    K1 = np.cumsum([0] + list(np.diag(K)))\n    K2 = np.zeros((n + 1, n + 1))\n    K2[1:, 1:] = np.cumsum(np.cumsum(K, 0), 1)\n    diagK2 = np.diag(K2)\n    i = np.arange(n).reshape((-1, 1))\n    j = np.arange(n).reshape((1, -1))\n    ij_f32 = (j - i + 1).astype(np.float32) + (j == i - 1).astype(np.float32)\n    diagK2_K2 = diagK2[1:].reshape((1, -1)) + diagK2[:-1].reshape((-1, 1)) - K2[1:, :-1].T - K2[:-1, 1:]\n    scatters = K1[1:].reshape((1, -1)) - K1[:-1].reshape((-1, 1)) - diagK2_K2 / ij_f32\n    scatters[j < i] = 0\n    return scatters",
            "def calc_scatters(K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Calculate scatter matrix: scatters[i,j] = {scatter of the sequence with\\n    starting frame i and ending frame j}\\n    '\n    n = K.shape[0]\n    K1 = np.cumsum([0] + list(np.diag(K)))\n    K2 = np.zeros((n + 1, n + 1))\n    K2[1:, 1:] = np.cumsum(np.cumsum(K, 0), 1)\n    diagK2 = np.diag(K2)\n    i = np.arange(n).reshape((-1, 1))\n    j = np.arange(n).reshape((1, -1))\n    ij_f32 = (j - i + 1).astype(np.float32) + (j == i - 1).astype(np.float32)\n    diagK2_K2 = diagK2[1:].reshape((1, -1)) + diagK2[:-1].reshape((-1, 1)) - K2[1:, :-1].T - K2[:-1, 1:]\n    scatters = K1[1:].reshape((1, -1)) - K1[:-1].reshape((-1, 1)) - diagK2_K2 / ij_f32\n    scatters[j < i] = 0\n    return scatters"
        ]
    },
    {
        "func_name": "cpd_nonlin",
        "original": "def cpd_nonlin(K, ncp, lmin=1, lmax=100000, backtrack=True, verbose=True, out_scatters=None):\n    \"\"\"Change point detection with dynamic programming\n\n    :param K: Square kernel matrix\n    :param ncp: Number of change points to detect (ncp >= 0)\n    :param lmin: Minimal length of a segment\n    :param lmax: Maximal length of a segment\n    :param backtrack: If False - only evaluate objective scores (to save memory)\n    :param verbose: If true, print verbose message\n    :param out_scatters: Output scatters\n    :return: Tuple (cps, obj_vals)\n        - cps - detected array of change points: mean is thought to be constant\n            on [ cps[i], cps[i+1] )\n        - obj_vals - values of the objective function for 0..m changepoints\n    \"\"\"\n    m = int(ncp)\n    (n, n1) = K.shape\n    assert n == n1, 'Kernel matrix awaited.'\n    assert (m + 1) * lmin <= n <= (m + 1) * lmax\n    assert 1 <= lmin <= lmax\n    if verbose:\n        print('Precomputing scatters...')\n    J = calc_scatters(K)\n    if out_scatters is not None:\n        out_scatters[0] = J\n    if verbose:\n        print('Inferring best change points...')\n    Iden = 1e+101 * np.ones((m + 1, n + 1))\n    Iden[0, lmin:lmax] = J[0, lmin - 1:lmax - 1]\n    if backtrack:\n        p = np.zeros((m + 1, n + 1), dtype=int)\n    else:\n        p = np.zeros((1, 1), dtype=int)\n    for k in range(1, m + 1):\n        for l_frame in range((k + 1) * lmin, n + 1):\n            tmin = max(k * lmin, l_frame - lmax)\n            tmax = l_frame - lmin + 1\n            c = J[tmin:tmax, l_frame - 1].reshape(-1) + Iden[k - 1, tmin:tmax].reshape(-1)\n            Iden[k, l_frame] = np.min(c)\n            if backtrack:\n                p[k, l_frame] = np.argmin(c) + tmin\n    cps = np.zeros(m, dtype=int)\n    if backtrack:\n        cur = n\n        for k in range(m, 0, -1):\n            cps[k - 1] = p[k, cur]\n            cur = cps[k - 1]\n    scores = Iden[:, n].copy()\n    scores[scores > 1e+99] = np.inf\n    return (cps, scores)",
        "mutated": [
            "def cpd_nonlin(K, ncp, lmin=1, lmax=100000, backtrack=True, verbose=True, out_scatters=None):\n    if False:\n        i = 10\n    'Change point detection with dynamic programming\\n\\n    :param K: Square kernel matrix\\n    :param ncp: Number of change points to detect (ncp >= 0)\\n    :param lmin: Minimal length of a segment\\n    :param lmax: Maximal length of a segment\\n    :param backtrack: If False - only evaluate objective scores (to save memory)\\n    :param verbose: If true, print verbose message\\n    :param out_scatters: Output scatters\\n    :return: Tuple (cps, obj_vals)\\n        - cps - detected array of change points: mean is thought to be constant\\n            on [ cps[i], cps[i+1] )\\n        - obj_vals - values of the objective function for 0..m changepoints\\n    '\n    m = int(ncp)\n    (n, n1) = K.shape\n    assert n == n1, 'Kernel matrix awaited.'\n    assert (m + 1) * lmin <= n <= (m + 1) * lmax\n    assert 1 <= lmin <= lmax\n    if verbose:\n        print('Precomputing scatters...')\n    J = calc_scatters(K)\n    if out_scatters is not None:\n        out_scatters[0] = J\n    if verbose:\n        print('Inferring best change points...')\n    Iden = 1e+101 * np.ones((m + 1, n + 1))\n    Iden[0, lmin:lmax] = J[0, lmin - 1:lmax - 1]\n    if backtrack:\n        p = np.zeros((m + 1, n + 1), dtype=int)\n    else:\n        p = np.zeros((1, 1), dtype=int)\n    for k in range(1, m + 1):\n        for l_frame in range((k + 1) * lmin, n + 1):\n            tmin = max(k * lmin, l_frame - lmax)\n            tmax = l_frame - lmin + 1\n            c = J[tmin:tmax, l_frame - 1].reshape(-1) + Iden[k - 1, tmin:tmax].reshape(-1)\n            Iden[k, l_frame] = np.min(c)\n            if backtrack:\n                p[k, l_frame] = np.argmin(c) + tmin\n    cps = np.zeros(m, dtype=int)\n    if backtrack:\n        cur = n\n        for k in range(m, 0, -1):\n            cps[k - 1] = p[k, cur]\n            cur = cps[k - 1]\n    scores = Iden[:, n].copy()\n    scores[scores > 1e+99] = np.inf\n    return (cps, scores)",
            "def cpd_nonlin(K, ncp, lmin=1, lmax=100000, backtrack=True, verbose=True, out_scatters=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Change point detection with dynamic programming\\n\\n    :param K: Square kernel matrix\\n    :param ncp: Number of change points to detect (ncp >= 0)\\n    :param lmin: Minimal length of a segment\\n    :param lmax: Maximal length of a segment\\n    :param backtrack: If False - only evaluate objective scores (to save memory)\\n    :param verbose: If true, print verbose message\\n    :param out_scatters: Output scatters\\n    :return: Tuple (cps, obj_vals)\\n        - cps - detected array of change points: mean is thought to be constant\\n            on [ cps[i], cps[i+1] )\\n        - obj_vals - values of the objective function for 0..m changepoints\\n    '\n    m = int(ncp)\n    (n, n1) = K.shape\n    assert n == n1, 'Kernel matrix awaited.'\n    assert (m + 1) * lmin <= n <= (m + 1) * lmax\n    assert 1 <= lmin <= lmax\n    if verbose:\n        print('Precomputing scatters...')\n    J = calc_scatters(K)\n    if out_scatters is not None:\n        out_scatters[0] = J\n    if verbose:\n        print('Inferring best change points...')\n    Iden = 1e+101 * np.ones((m + 1, n + 1))\n    Iden[0, lmin:lmax] = J[0, lmin - 1:lmax - 1]\n    if backtrack:\n        p = np.zeros((m + 1, n + 1), dtype=int)\n    else:\n        p = np.zeros((1, 1), dtype=int)\n    for k in range(1, m + 1):\n        for l_frame in range((k + 1) * lmin, n + 1):\n            tmin = max(k * lmin, l_frame - lmax)\n            tmax = l_frame - lmin + 1\n            c = J[tmin:tmax, l_frame - 1].reshape(-1) + Iden[k - 1, tmin:tmax].reshape(-1)\n            Iden[k, l_frame] = np.min(c)\n            if backtrack:\n                p[k, l_frame] = np.argmin(c) + tmin\n    cps = np.zeros(m, dtype=int)\n    if backtrack:\n        cur = n\n        for k in range(m, 0, -1):\n            cps[k - 1] = p[k, cur]\n            cur = cps[k - 1]\n    scores = Iden[:, n].copy()\n    scores[scores > 1e+99] = np.inf\n    return (cps, scores)",
            "def cpd_nonlin(K, ncp, lmin=1, lmax=100000, backtrack=True, verbose=True, out_scatters=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Change point detection with dynamic programming\\n\\n    :param K: Square kernel matrix\\n    :param ncp: Number of change points to detect (ncp >= 0)\\n    :param lmin: Minimal length of a segment\\n    :param lmax: Maximal length of a segment\\n    :param backtrack: If False - only evaluate objective scores (to save memory)\\n    :param verbose: If true, print verbose message\\n    :param out_scatters: Output scatters\\n    :return: Tuple (cps, obj_vals)\\n        - cps - detected array of change points: mean is thought to be constant\\n            on [ cps[i], cps[i+1] )\\n        - obj_vals - values of the objective function for 0..m changepoints\\n    '\n    m = int(ncp)\n    (n, n1) = K.shape\n    assert n == n1, 'Kernel matrix awaited.'\n    assert (m + 1) * lmin <= n <= (m + 1) * lmax\n    assert 1 <= lmin <= lmax\n    if verbose:\n        print('Precomputing scatters...')\n    J = calc_scatters(K)\n    if out_scatters is not None:\n        out_scatters[0] = J\n    if verbose:\n        print('Inferring best change points...')\n    Iden = 1e+101 * np.ones((m + 1, n + 1))\n    Iden[0, lmin:lmax] = J[0, lmin - 1:lmax - 1]\n    if backtrack:\n        p = np.zeros((m + 1, n + 1), dtype=int)\n    else:\n        p = np.zeros((1, 1), dtype=int)\n    for k in range(1, m + 1):\n        for l_frame in range((k + 1) * lmin, n + 1):\n            tmin = max(k * lmin, l_frame - lmax)\n            tmax = l_frame - lmin + 1\n            c = J[tmin:tmax, l_frame - 1].reshape(-1) + Iden[k - 1, tmin:tmax].reshape(-1)\n            Iden[k, l_frame] = np.min(c)\n            if backtrack:\n                p[k, l_frame] = np.argmin(c) + tmin\n    cps = np.zeros(m, dtype=int)\n    if backtrack:\n        cur = n\n        for k in range(m, 0, -1):\n            cps[k - 1] = p[k, cur]\n            cur = cps[k - 1]\n    scores = Iden[:, n].copy()\n    scores[scores > 1e+99] = np.inf\n    return (cps, scores)",
            "def cpd_nonlin(K, ncp, lmin=1, lmax=100000, backtrack=True, verbose=True, out_scatters=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Change point detection with dynamic programming\\n\\n    :param K: Square kernel matrix\\n    :param ncp: Number of change points to detect (ncp >= 0)\\n    :param lmin: Minimal length of a segment\\n    :param lmax: Maximal length of a segment\\n    :param backtrack: If False - only evaluate objective scores (to save memory)\\n    :param verbose: If true, print verbose message\\n    :param out_scatters: Output scatters\\n    :return: Tuple (cps, obj_vals)\\n        - cps - detected array of change points: mean is thought to be constant\\n            on [ cps[i], cps[i+1] )\\n        - obj_vals - values of the objective function for 0..m changepoints\\n    '\n    m = int(ncp)\n    (n, n1) = K.shape\n    assert n == n1, 'Kernel matrix awaited.'\n    assert (m + 1) * lmin <= n <= (m + 1) * lmax\n    assert 1 <= lmin <= lmax\n    if verbose:\n        print('Precomputing scatters...')\n    J = calc_scatters(K)\n    if out_scatters is not None:\n        out_scatters[0] = J\n    if verbose:\n        print('Inferring best change points...')\n    Iden = 1e+101 * np.ones((m + 1, n + 1))\n    Iden[0, lmin:lmax] = J[0, lmin - 1:lmax - 1]\n    if backtrack:\n        p = np.zeros((m + 1, n + 1), dtype=int)\n    else:\n        p = np.zeros((1, 1), dtype=int)\n    for k in range(1, m + 1):\n        for l_frame in range((k + 1) * lmin, n + 1):\n            tmin = max(k * lmin, l_frame - lmax)\n            tmax = l_frame - lmin + 1\n            c = J[tmin:tmax, l_frame - 1].reshape(-1) + Iden[k - 1, tmin:tmax].reshape(-1)\n            Iden[k, l_frame] = np.min(c)\n            if backtrack:\n                p[k, l_frame] = np.argmin(c) + tmin\n    cps = np.zeros(m, dtype=int)\n    if backtrack:\n        cur = n\n        for k in range(m, 0, -1):\n            cps[k - 1] = p[k, cur]\n            cur = cps[k - 1]\n    scores = Iden[:, n].copy()\n    scores[scores > 1e+99] = np.inf\n    return (cps, scores)",
            "def cpd_nonlin(K, ncp, lmin=1, lmax=100000, backtrack=True, verbose=True, out_scatters=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Change point detection with dynamic programming\\n\\n    :param K: Square kernel matrix\\n    :param ncp: Number of change points to detect (ncp >= 0)\\n    :param lmin: Minimal length of a segment\\n    :param lmax: Maximal length of a segment\\n    :param backtrack: If False - only evaluate objective scores (to save memory)\\n    :param verbose: If true, print verbose message\\n    :param out_scatters: Output scatters\\n    :return: Tuple (cps, obj_vals)\\n        - cps - detected array of change points: mean is thought to be constant\\n            on [ cps[i], cps[i+1] )\\n        - obj_vals - values of the objective function for 0..m changepoints\\n    '\n    m = int(ncp)\n    (n, n1) = K.shape\n    assert n == n1, 'Kernel matrix awaited.'\n    assert (m + 1) * lmin <= n <= (m + 1) * lmax\n    assert 1 <= lmin <= lmax\n    if verbose:\n        print('Precomputing scatters...')\n    J = calc_scatters(K)\n    if out_scatters is not None:\n        out_scatters[0] = J\n    if verbose:\n        print('Inferring best change points...')\n    Iden = 1e+101 * np.ones((m + 1, n + 1))\n    Iden[0, lmin:lmax] = J[0, lmin - 1:lmax - 1]\n    if backtrack:\n        p = np.zeros((m + 1, n + 1), dtype=int)\n    else:\n        p = np.zeros((1, 1), dtype=int)\n    for k in range(1, m + 1):\n        for l_frame in range((k + 1) * lmin, n + 1):\n            tmin = max(k * lmin, l_frame - lmax)\n            tmax = l_frame - lmin + 1\n            c = J[tmin:tmax, l_frame - 1].reshape(-1) + Iden[k - 1, tmin:tmax].reshape(-1)\n            Iden[k, l_frame] = np.min(c)\n            if backtrack:\n                p[k, l_frame] = np.argmin(c) + tmin\n    cps = np.zeros(m, dtype=int)\n    if backtrack:\n        cur = n\n        for k in range(m, 0, -1):\n            cps[k - 1] = p[k, cur]\n            cur = cps[k - 1]\n    scores = Iden[:, n].copy()\n    scores[scores > 1e+99] = np.inf\n    return (cps, scores)"
        ]
    }
]