[
    {
        "func_name": "dijkstra",
        "original": "def dijkstra(start, target):\n    best = [[float('inf')] * len(grid[0]) for _ in xrange(len(grid))]\n    best[start[0]][start[1]] = 0\n    min_heap = [(0, start[0], start[1])]\n    while min_heap:\n        (curr, i, j) = heapq.heappop(min_heap)\n        if best[i][j] < curr:\n            continue\n        if (i, j) == target:\n            break\n        for (di, dj) in DIRECTIONS:\n            (ni, nj) = (i + di, j + dj)\n            if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and (best[ni][nj] > max(grid[ni][nj] + int(grid[ni][nj] % 2 == best[i][j] % 2), curr + 1))):\n                continue\n            best[ni][nj] = max(grid[ni][nj] + int(grid[ni][nj] % 2 == best[i][j] % 2), curr + 1)\n            heapq.heappush(min_heap, (best[ni][nj], ni, nj))\n    return best[target[0]][target[1]]",
        "mutated": [
            "def dijkstra(start, target):\n    if False:\n        i = 10\n    best = [[float('inf')] * len(grid[0]) for _ in xrange(len(grid))]\n    best[start[0]][start[1]] = 0\n    min_heap = [(0, start[0], start[1])]\n    while min_heap:\n        (curr, i, j) = heapq.heappop(min_heap)\n        if best[i][j] < curr:\n            continue\n        if (i, j) == target:\n            break\n        for (di, dj) in DIRECTIONS:\n            (ni, nj) = (i + di, j + dj)\n            if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and (best[ni][nj] > max(grid[ni][nj] + int(grid[ni][nj] % 2 == best[i][j] % 2), curr + 1))):\n                continue\n            best[ni][nj] = max(grid[ni][nj] + int(grid[ni][nj] % 2 == best[i][j] % 2), curr + 1)\n            heapq.heappush(min_heap, (best[ni][nj], ni, nj))\n    return best[target[0]][target[1]]",
            "def dijkstra(start, target):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    best = [[float('inf')] * len(grid[0]) for _ in xrange(len(grid))]\n    best[start[0]][start[1]] = 0\n    min_heap = [(0, start[0], start[1])]\n    while min_heap:\n        (curr, i, j) = heapq.heappop(min_heap)\n        if best[i][j] < curr:\n            continue\n        if (i, j) == target:\n            break\n        for (di, dj) in DIRECTIONS:\n            (ni, nj) = (i + di, j + dj)\n            if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and (best[ni][nj] > max(grid[ni][nj] + int(grid[ni][nj] % 2 == best[i][j] % 2), curr + 1))):\n                continue\n            best[ni][nj] = max(grid[ni][nj] + int(grid[ni][nj] % 2 == best[i][j] % 2), curr + 1)\n            heapq.heappush(min_heap, (best[ni][nj], ni, nj))\n    return best[target[0]][target[1]]",
            "def dijkstra(start, target):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    best = [[float('inf')] * len(grid[0]) for _ in xrange(len(grid))]\n    best[start[0]][start[1]] = 0\n    min_heap = [(0, start[0], start[1])]\n    while min_heap:\n        (curr, i, j) = heapq.heappop(min_heap)\n        if best[i][j] < curr:\n            continue\n        if (i, j) == target:\n            break\n        for (di, dj) in DIRECTIONS:\n            (ni, nj) = (i + di, j + dj)\n            if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and (best[ni][nj] > max(grid[ni][nj] + int(grid[ni][nj] % 2 == best[i][j] % 2), curr + 1))):\n                continue\n            best[ni][nj] = max(grid[ni][nj] + int(grid[ni][nj] % 2 == best[i][j] % 2), curr + 1)\n            heapq.heappush(min_heap, (best[ni][nj], ni, nj))\n    return best[target[0]][target[1]]",
            "def dijkstra(start, target):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    best = [[float('inf')] * len(grid[0]) for _ in xrange(len(grid))]\n    best[start[0]][start[1]] = 0\n    min_heap = [(0, start[0], start[1])]\n    while min_heap:\n        (curr, i, j) = heapq.heappop(min_heap)\n        if best[i][j] < curr:\n            continue\n        if (i, j) == target:\n            break\n        for (di, dj) in DIRECTIONS:\n            (ni, nj) = (i + di, j + dj)\n            if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and (best[ni][nj] > max(grid[ni][nj] + int(grid[ni][nj] % 2 == best[i][j] % 2), curr + 1))):\n                continue\n            best[ni][nj] = max(grid[ni][nj] + int(grid[ni][nj] % 2 == best[i][j] % 2), curr + 1)\n            heapq.heappush(min_heap, (best[ni][nj], ni, nj))\n    return best[target[0]][target[1]]",
            "def dijkstra(start, target):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    best = [[float('inf')] * len(grid[0]) for _ in xrange(len(grid))]\n    best[start[0]][start[1]] = 0\n    min_heap = [(0, start[0], start[1])]\n    while min_heap:\n        (curr, i, j) = heapq.heappop(min_heap)\n        if best[i][j] < curr:\n            continue\n        if (i, j) == target:\n            break\n        for (di, dj) in DIRECTIONS:\n            (ni, nj) = (i + di, j + dj)\n            if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and (best[ni][nj] > max(grid[ni][nj] + int(grid[ni][nj] % 2 == best[i][j] % 2), curr + 1))):\n                continue\n            best[ni][nj] = max(grid[ni][nj] + int(grid[ni][nj] % 2 == best[i][j] % 2), curr + 1)\n            heapq.heappush(min_heap, (best[ni][nj], ni, nj))\n    return best[target[0]][target[1]]"
        ]
    },
    {
        "func_name": "minimumTime",
        "original": "def minimumTime(self, grid):\n    \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n    DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    def dijkstra(start, target):\n        best = [[float('inf')] * len(grid[0]) for _ in xrange(len(grid))]\n        best[start[0]][start[1]] = 0\n        min_heap = [(0, start[0], start[1])]\n        while min_heap:\n            (curr, i, j) = heapq.heappop(min_heap)\n            if best[i][j] < curr:\n                continue\n            if (i, j) == target:\n                break\n            for (di, dj) in DIRECTIONS:\n                (ni, nj) = (i + di, j + dj)\n                if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and (best[ni][nj] > max(grid[ni][nj] + int(grid[ni][nj] % 2 == best[i][j] % 2), curr + 1))):\n                    continue\n                best[ni][nj] = max(grid[ni][nj] + int(grid[ni][nj] % 2 == best[i][j] % 2), curr + 1)\n                heapq.heappush(min_heap, (best[ni][nj], ni, nj))\n        return best[target[0]][target[1]]\n    if min(grid[0][1], grid[1][0]) > 1:\n        return -1\n    return dijkstra((0, 0), (len(grid) - 1, len(grid[0]) - 1))",
        "mutated": [
            "def minimumTime(self, grid):\n    if False:\n        i = 10\n    '\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        '\n    DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    def dijkstra(start, target):\n        best = [[float('inf')] * len(grid[0]) for _ in xrange(len(grid))]\n        best[start[0]][start[1]] = 0\n        min_heap = [(0, start[0], start[1])]\n        while min_heap:\n            (curr, i, j) = heapq.heappop(min_heap)\n            if best[i][j] < curr:\n                continue\n            if (i, j) == target:\n                break\n            for (di, dj) in DIRECTIONS:\n                (ni, nj) = (i + di, j + dj)\n                if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and (best[ni][nj] > max(grid[ni][nj] + int(grid[ni][nj] % 2 == best[i][j] % 2), curr + 1))):\n                    continue\n                best[ni][nj] = max(grid[ni][nj] + int(grid[ni][nj] % 2 == best[i][j] % 2), curr + 1)\n                heapq.heappush(min_heap, (best[ni][nj], ni, nj))\n        return best[target[0]][target[1]]\n    if min(grid[0][1], grid[1][0]) > 1:\n        return -1\n    return dijkstra((0, 0), (len(grid) - 1, len(grid[0]) - 1))",
            "def minimumTime(self, grid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        '\n    DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    def dijkstra(start, target):\n        best = [[float('inf')] * len(grid[0]) for _ in xrange(len(grid))]\n        best[start[0]][start[1]] = 0\n        min_heap = [(0, start[0], start[1])]\n        while min_heap:\n            (curr, i, j) = heapq.heappop(min_heap)\n            if best[i][j] < curr:\n                continue\n            if (i, j) == target:\n                break\n            for (di, dj) in DIRECTIONS:\n                (ni, nj) = (i + di, j + dj)\n                if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and (best[ni][nj] > max(grid[ni][nj] + int(grid[ni][nj] % 2 == best[i][j] % 2), curr + 1))):\n                    continue\n                best[ni][nj] = max(grid[ni][nj] + int(grid[ni][nj] % 2 == best[i][j] % 2), curr + 1)\n                heapq.heappush(min_heap, (best[ni][nj], ni, nj))\n        return best[target[0]][target[1]]\n    if min(grid[0][1], grid[1][0]) > 1:\n        return -1\n    return dijkstra((0, 0), (len(grid) - 1, len(grid[0]) - 1))",
            "def minimumTime(self, grid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        '\n    DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    def dijkstra(start, target):\n        best = [[float('inf')] * len(grid[0]) for _ in xrange(len(grid))]\n        best[start[0]][start[1]] = 0\n        min_heap = [(0, start[0], start[1])]\n        while min_heap:\n            (curr, i, j) = heapq.heappop(min_heap)\n            if best[i][j] < curr:\n                continue\n            if (i, j) == target:\n                break\n            for (di, dj) in DIRECTIONS:\n                (ni, nj) = (i + di, j + dj)\n                if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and (best[ni][nj] > max(grid[ni][nj] + int(grid[ni][nj] % 2 == best[i][j] % 2), curr + 1))):\n                    continue\n                best[ni][nj] = max(grid[ni][nj] + int(grid[ni][nj] % 2 == best[i][j] % 2), curr + 1)\n                heapq.heappush(min_heap, (best[ni][nj], ni, nj))\n        return best[target[0]][target[1]]\n    if min(grid[0][1], grid[1][0]) > 1:\n        return -1\n    return dijkstra((0, 0), (len(grid) - 1, len(grid[0]) - 1))",
            "def minimumTime(self, grid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        '\n    DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    def dijkstra(start, target):\n        best = [[float('inf')] * len(grid[0]) for _ in xrange(len(grid))]\n        best[start[0]][start[1]] = 0\n        min_heap = [(0, start[0], start[1])]\n        while min_heap:\n            (curr, i, j) = heapq.heappop(min_heap)\n            if best[i][j] < curr:\n                continue\n            if (i, j) == target:\n                break\n            for (di, dj) in DIRECTIONS:\n                (ni, nj) = (i + di, j + dj)\n                if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and (best[ni][nj] > max(grid[ni][nj] + int(grid[ni][nj] % 2 == best[i][j] % 2), curr + 1))):\n                    continue\n                best[ni][nj] = max(grid[ni][nj] + int(grid[ni][nj] % 2 == best[i][j] % 2), curr + 1)\n                heapq.heappush(min_heap, (best[ni][nj], ni, nj))\n        return best[target[0]][target[1]]\n    if min(grid[0][1], grid[1][0]) > 1:\n        return -1\n    return dijkstra((0, 0), (len(grid) - 1, len(grid[0]) - 1))",
            "def minimumTime(self, grid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        '\n    DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    def dijkstra(start, target):\n        best = [[float('inf')] * len(grid[0]) for _ in xrange(len(grid))]\n        best[start[0]][start[1]] = 0\n        min_heap = [(0, start[0], start[1])]\n        while min_heap:\n            (curr, i, j) = heapq.heappop(min_heap)\n            if best[i][j] < curr:\n                continue\n            if (i, j) == target:\n                break\n            for (di, dj) in DIRECTIONS:\n                (ni, nj) = (i + di, j + dj)\n                if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and (best[ni][nj] > max(grid[ni][nj] + int(grid[ni][nj] % 2 == best[i][j] % 2), curr + 1))):\n                    continue\n                best[ni][nj] = max(grid[ni][nj] + int(grid[ni][nj] % 2 == best[i][j] % 2), curr + 1)\n                heapq.heappush(min_heap, (best[ni][nj], ni, nj))\n        return best[target[0]][target[1]]\n    if min(grid[0][1], grid[1][0]) > 1:\n        return -1\n    return dijkstra((0, 0), (len(grid) - 1, len(grid[0]) - 1))"
        ]
    }
]