[
    {
        "func_name": "__init__",
        "original": "def __init__(self, datalab: Datalab, threshold: Optional[float]=None, k: int=10, **kwargs):\n    super().__init__(datalab)\n    self.k = k\n    self.threshold = threshold if threshold is not None else self.DEFAULT_THRESHOLDS",
        "mutated": [
            "def __init__(self, datalab: Datalab, threshold: Optional[float]=None, k: int=10, **kwargs):\n    if False:\n        i = 10\n    super().__init__(datalab)\n    self.k = k\n    self.threshold = threshold if threshold is not None else self.DEFAULT_THRESHOLDS",
            "def __init__(self, datalab: Datalab, threshold: Optional[float]=None, k: int=10, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super().__init__(datalab)\n    self.k = k\n    self.threshold = threshold if threshold is not None else self.DEFAULT_THRESHOLDS",
            "def __init__(self, datalab: Datalab, threshold: Optional[float]=None, k: int=10, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super().__init__(datalab)\n    self.k = k\n    self.threshold = threshold if threshold is not None else self.DEFAULT_THRESHOLDS",
            "def __init__(self, datalab: Datalab, threshold: Optional[float]=None, k: int=10, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super().__init__(datalab)\n    self.k = k\n    self.threshold = threshold if threshold is not None else self.DEFAULT_THRESHOLDS",
            "def __init__(self, datalab: Datalab, threshold: Optional[float]=None, k: int=10, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super().__init__(datalab)\n    self.k = k\n    self.threshold = threshold if threshold is not None else self.DEFAULT_THRESHOLDS"
        ]
    },
    {
        "func_name": "find_issues",
        "original": "def find_issues(self, **kwargs) -> None:\n    \"\"\"Calculate the data valuation score with a provided or existing knn graph.\n        Based on KNN-Shapley value described in https://arxiv.org/abs/1911.07128\n        The larger the score, the more valuable the data point is, the more contribution it will make to the model's training.\n        \"\"\"\n    knn_graph = self._process_knn_graph_from_inputs(kwargs)\n    labels = self.datalab.labels.reshape(-1, 1)\n    assert knn_graph is not None, 'knn_graph must be already calculated by other issue managers'\n    assert labels is not None, 'labels must be provided'\n    scores = _knn_shapley_score(knn_graph, labels)\n    self.issues = pd.DataFrame({f'is_{self.issue_name}_issue': scores < self.threshold, self.issue_score_key: scores})\n    self.summary = self.make_summary(score=scores.mean())\n    self.info = self.collect_info(self.issues)",
        "mutated": [
            "def find_issues(self, **kwargs) -> None:\n    if False:\n        i = 10\n    \"Calculate the data valuation score with a provided or existing knn graph.\\n        Based on KNN-Shapley value described in https://arxiv.org/abs/1911.07128\\n        The larger the score, the more valuable the data point is, the more contribution it will make to the model's training.\\n        \"\n    knn_graph = self._process_knn_graph_from_inputs(kwargs)\n    labels = self.datalab.labels.reshape(-1, 1)\n    assert knn_graph is not None, 'knn_graph must be already calculated by other issue managers'\n    assert labels is not None, 'labels must be provided'\n    scores = _knn_shapley_score(knn_graph, labels)\n    self.issues = pd.DataFrame({f'is_{self.issue_name}_issue': scores < self.threshold, self.issue_score_key: scores})\n    self.summary = self.make_summary(score=scores.mean())\n    self.info = self.collect_info(self.issues)",
            "def find_issues(self, **kwargs) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Calculate the data valuation score with a provided or existing knn graph.\\n        Based on KNN-Shapley value described in https://arxiv.org/abs/1911.07128\\n        The larger the score, the more valuable the data point is, the more contribution it will make to the model's training.\\n        \"\n    knn_graph = self._process_knn_graph_from_inputs(kwargs)\n    labels = self.datalab.labels.reshape(-1, 1)\n    assert knn_graph is not None, 'knn_graph must be already calculated by other issue managers'\n    assert labels is not None, 'labels must be provided'\n    scores = _knn_shapley_score(knn_graph, labels)\n    self.issues = pd.DataFrame({f'is_{self.issue_name}_issue': scores < self.threshold, self.issue_score_key: scores})\n    self.summary = self.make_summary(score=scores.mean())\n    self.info = self.collect_info(self.issues)",
            "def find_issues(self, **kwargs) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Calculate the data valuation score with a provided or existing knn graph.\\n        Based on KNN-Shapley value described in https://arxiv.org/abs/1911.07128\\n        The larger the score, the more valuable the data point is, the more contribution it will make to the model's training.\\n        \"\n    knn_graph = self._process_knn_graph_from_inputs(kwargs)\n    labels = self.datalab.labels.reshape(-1, 1)\n    assert knn_graph is not None, 'knn_graph must be already calculated by other issue managers'\n    assert labels is not None, 'labels must be provided'\n    scores = _knn_shapley_score(knn_graph, labels)\n    self.issues = pd.DataFrame({f'is_{self.issue_name}_issue': scores < self.threshold, self.issue_score_key: scores})\n    self.summary = self.make_summary(score=scores.mean())\n    self.info = self.collect_info(self.issues)",
            "def find_issues(self, **kwargs) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Calculate the data valuation score with a provided or existing knn graph.\\n        Based on KNN-Shapley value described in https://arxiv.org/abs/1911.07128\\n        The larger the score, the more valuable the data point is, the more contribution it will make to the model's training.\\n        \"\n    knn_graph = self._process_knn_graph_from_inputs(kwargs)\n    labels = self.datalab.labels.reshape(-1, 1)\n    assert knn_graph is not None, 'knn_graph must be already calculated by other issue managers'\n    assert labels is not None, 'labels must be provided'\n    scores = _knn_shapley_score(knn_graph, labels)\n    self.issues = pd.DataFrame({f'is_{self.issue_name}_issue': scores < self.threshold, self.issue_score_key: scores})\n    self.summary = self.make_summary(score=scores.mean())\n    self.info = self.collect_info(self.issues)",
            "def find_issues(self, **kwargs) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Calculate the data valuation score with a provided or existing knn graph.\\n        Based on KNN-Shapley value described in https://arxiv.org/abs/1911.07128\\n        The larger the score, the more valuable the data point is, the more contribution it will make to the model's training.\\n        \"\n    knn_graph = self._process_knn_graph_from_inputs(kwargs)\n    labels = self.datalab.labels.reshape(-1, 1)\n    assert knn_graph is not None, 'knn_graph must be already calculated by other issue managers'\n    assert labels is not None, 'labels must be provided'\n    scores = _knn_shapley_score(knn_graph, labels)\n    self.issues = pd.DataFrame({f'is_{self.issue_name}_issue': scores < self.threshold, self.issue_score_key: scores})\n    self.summary = self.make_summary(score=scores.mean())\n    self.info = self.collect_info(self.issues)"
        ]
    },
    {
        "func_name": "_process_knn_graph_from_inputs",
        "original": "def _process_knn_graph_from_inputs(self, kwargs: Dict[str, Any]) -> Union[csr_matrix, None]:\n    \"\"\"Determine if a knn_graph is provided in the kwargs or if one is already stored in the associated Datalab instance.\"\"\"\n    knn_graph_kwargs: Optional[csr_matrix] = kwargs.get('knn_graph', None)\n    knn_graph_stats = self.datalab.get_info('statistics').get('weighted_knn_graph', None)\n    knn_graph: Optional[csr_matrix] = None\n    if knn_graph_kwargs is not None:\n        knn_graph = knn_graph_kwargs\n    elif knn_graph_stats is not None:\n        knn_graph = knn_graph_stats\n    if isinstance(knn_graph, csr_matrix) and kwargs.get('k', 0) > knn_graph.nnz // knn_graph.shape[0]:\n        knn_graph = None\n    return knn_graph",
        "mutated": [
            "def _process_knn_graph_from_inputs(self, kwargs: Dict[str, Any]) -> Union[csr_matrix, None]:\n    if False:\n        i = 10\n    'Determine if a knn_graph is provided in the kwargs or if one is already stored in the associated Datalab instance.'\n    knn_graph_kwargs: Optional[csr_matrix] = kwargs.get('knn_graph', None)\n    knn_graph_stats = self.datalab.get_info('statistics').get('weighted_knn_graph', None)\n    knn_graph: Optional[csr_matrix] = None\n    if knn_graph_kwargs is not None:\n        knn_graph = knn_graph_kwargs\n    elif knn_graph_stats is not None:\n        knn_graph = knn_graph_stats\n    if isinstance(knn_graph, csr_matrix) and kwargs.get('k', 0) > knn_graph.nnz // knn_graph.shape[0]:\n        knn_graph = None\n    return knn_graph",
            "def _process_knn_graph_from_inputs(self, kwargs: Dict[str, Any]) -> Union[csr_matrix, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Determine if a knn_graph is provided in the kwargs or if one is already stored in the associated Datalab instance.'\n    knn_graph_kwargs: Optional[csr_matrix] = kwargs.get('knn_graph', None)\n    knn_graph_stats = self.datalab.get_info('statistics').get('weighted_knn_graph', None)\n    knn_graph: Optional[csr_matrix] = None\n    if knn_graph_kwargs is not None:\n        knn_graph = knn_graph_kwargs\n    elif knn_graph_stats is not None:\n        knn_graph = knn_graph_stats\n    if isinstance(knn_graph, csr_matrix) and kwargs.get('k', 0) > knn_graph.nnz // knn_graph.shape[0]:\n        knn_graph = None\n    return knn_graph",
            "def _process_knn_graph_from_inputs(self, kwargs: Dict[str, Any]) -> Union[csr_matrix, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Determine if a knn_graph is provided in the kwargs or if one is already stored in the associated Datalab instance.'\n    knn_graph_kwargs: Optional[csr_matrix] = kwargs.get('knn_graph', None)\n    knn_graph_stats = self.datalab.get_info('statistics').get('weighted_knn_graph', None)\n    knn_graph: Optional[csr_matrix] = None\n    if knn_graph_kwargs is not None:\n        knn_graph = knn_graph_kwargs\n    elif knn_graph_stats is not None:\n        knn_graph = knn_graph_stats\n    if isinstance(knn_graph, csr_matrix) and kwargs.get('k', 0) > knn_graph.nnz // knn_graph.shape[0]:\n        knn_graph = None\n    return knn_graph",
            "def _process_knn_graph_from_inputs(self, kwargs: Dict[str, Any]) -> Union[csr_matrix, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Determine if a knn_graph is provided in the kwargs or if one is already stored in the associated Datalab instance.'\n    knn_graph_kwargs: Optional[csr_matrix] = kwargs.get('knn_graph', None)\n    knn_graph_stats = self.datalab.get_info('statistics').get('weighted_knn_graph', None)\n    knn_graph: Optional[csr_matrix] = None\n    if knn_graph_kwargs is not None:\n        knn_graph = knn_graph_kwargs\n    elif knn_graph_stats is not None:\n        knn_graph = knn_graph_stats\n    if isinstance(knn_graph, csr_matrix) and kwargs.get('k', 0) > knn_graph.nnz // knn_graph.shape[0]:\n        knn_graph = None\n    return knn_graph",
            "def _process_knn_graph_from_inputs(self, kwargs: Dict[str, Any]) -> Union[csr_matrix, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Determine if a knn_graph is provided in the kwargs or if one is already stored in the associated Datalab instance.'\n    knn_graph_kwargs: Optional[csr_matrix] = kwargs.get('knn_graph', None)\n    knn_graph_stats = self.datalab.get_info('statistics').get('weighted_knn_graph', None)\n    knn_graph: Optional[csr_matrix] = None\n    if knn_graph_kwargs is not None:\n        knn_graph = knn_graph_kwargs\n    elif knn_graph_stats is not None:\n        knn_graph = knn_graph_stats\n    if isinstance(knn_graph, csr_matrix) and kwargs.get('k', 0) > knn_graph.nnz // knn_graph.shape[0]:\n        knn_graph = None\n    return knn_graph"
        ]
    },
    {
        "func_name": "collect_info",
        "original": "def collect_info(self, issues: pd.DataFrame) -> dict:\n    issues_info = {'num_low_valuation_issues': sum(issues[f'is_{self.issue_name}_issue']), 'average_data_valuation': issues[self.issue_score_key].mean()}\n    info_dict = {**issues_info}\n    return info_dict",
        "mutated": [
            "def collect_info(self, issues: pd.DataFrame) -> dict:\n    if False:\n        i = 10\n    issues_info = {'num_low_valuation_issues': sum(issues[f'is_{self.issue_name}_issue']), 'average_data_valuation': issues[self.issue_score_key].mean()}\n    info_dict = {**issues_info}\n    return info_dict",
            "def collect_info(self, issues: pd.DataFrame) -> dict:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    issues_info = {'num_low_valuation_issues': sum(issues[f'is_{self.issue_name}_issue']), 'average_data_valuation': issues[self.issue_score_key].mean()}\n    info_dict = {**issues_info}\n    return info_dict",
            "def collect_info(self, issues: pd.DataFrame) -> dict:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    issues_info = {'num_low_valuation_issues': sum(issues[f'is_{self.issue_name}_issue']), 'average_data_valuation': issues[self.issue_score_key].mean()}\n    info_dict = {**issues_info}\n    return info_dict",
            "def collect_info(self, issues: pd.DataFrame) -> dict:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    issues_info = {'num_low_valuation_issues': sum(issues[f'is_{self.issue_name}_issue']), 'average_data_valuation': issues[self.issue_score_key].mean()}\n    info_dict = {**issues_info}\n    return info_dict",
            "def collect_info(self, issues: pd.DataFrame) -> dict:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    issues_info = {'num_low_valuation_issues': sum(issues[f'is_{self.issue_name}_issue']), 'average_data_valuation': issues[self.issue_score_key].mean()}\n    info_dict = {**issues_info}\n    return info_dict"
        ]
    },
    {
        "func_name": "_knn_shapley_score",
        "original": "def _knn_shapley_score(knn_graph: csr_matrix, labels: np.ndarray) -> np.ndarray:\n    \"\"\"Compute the Shapley values of data points based on a knn graph.\"\"\"\n    N = labels.shape[0]\n    scores = np.zeros((N, N))\n    dist = knn_graph.indices.reshape(N, -1)\n    k = dist.shape[1]\n    for (i, y) in enumerate(labels):\n        idx = dist[i][::-1]\n        ans = labels[idx]\n        scores[idx[k - 1]][i] = float(ans[k - 1] == y) / k\n        cur = k - 2\n        for j in range(k - 1):\n            scores[idx[cur]][i] = scores[idx[cur + 1]][i] + float(int(ans[cur] == y) - int(ans[cur + 1] == y)) / k * (min(cur, k - 1) + 1) / (cur + 1)\n            cur -= 1\n    return 0.5 * (np.mean(scores, axis=1) + 1)",
        "mutated": [
            "def _knn_shapley_score(knn_graph: csr_matrix, labels: np.ndarray) -> np.ndarray:\n    if False:\n        i = 10\n    'Compute the Shapley values of data points based on a knn graph.'\n    N = labels.shape[0]\n    scores = np.zeros((N, N))\n    dist = knn_graph.indices.reshape(N, -1)\n    k = dist.shape[1]\n    for (i, y) in enumerate(labels):\n        idx = dist[i][::-1]\n        ans = labels[idx]\n        scores[idx[k - 1]][i] = float(ans[k - 1] == y) / k\n        cur = k - 2\n        for j in range(k - 1):\n            scores[idx[cur]][i] = scores[idx[cur + 1]][i] + float(int(ans[cur] == y) - int(ans[cur + 1] == y)) / k * (min(cur, k - 1) + 1) / (cur + 1)\n            cur -= 1\n    return 0.5 * (np.mean(scores, axis=1) + 1)",
            "def _knn_shapley_score(knn_graph: csr_matrix, labels: np.ndarray) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute the Shapley values of data points based on a knn graph.'\n    N = labels.shape[0]\n    scores = np.zeros((N, N))\n    dist = knn_graph.indices.reshape(N, -1)\n    k = dist.shape[1]\n    for (i, y) in enumerate(labels):\n        idx = dist[i][::-1]\n        ans = labels[idx]\n        scores[idx[k - 1]][i] = float(ans[k - 1] == y) / k\n        cur = k - 2\n        for j in range(k - 1):\n            scores[idx[cur]][i] = scores[idx[cur + 1]][i] + float(int(ans[cur] == y) - int(ans[cur + 1] == y)) / k * (min(cur, k - 1) + 1) / (cur + 1)\n            cur -= 1\n    return 0.5 * (np.mean(scores, axis=1) + 1)",
            "def _knn_shapley_score(knn_graph: csr_matrix, labels: np.ndarray) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute the Shapley values of data points based on a knn graph.'\n    N = labels.shape[0]\n    scores = np.zeros((N, N))\n    dist = knn_graph.indices.reshape(N, -1)\n    k = dist.shape[1]\n    for (i, y) in enumerate(labels):\n        idx = dist[i][::-1]\n        ans = labels[idx]\n        scores[idx[k - 1]][i] = float(ans[k - 1] == y) / k\n        cur = k - 2\n        for j in range(k - 1):\n            scores[idx[cur]][i] = scores[idx[cur + 1]][i] + float(int(ans[cur] == y) - int(ans[cur + 1] == y)) / k * (min(cur, k - 1) + 1) / (cur + 1)\n            cur -= 1\n    return 0.5 * (np.mean(scores, axis=1) + 1)",
            "def _knn_shapley_score(knn_graph: csr_matrix, labels: np.ndarray) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute the Shapley values of data points based on a knn graph.'\n    N = labels.shape[0]\n    scores = np.zeros((N, N))\n    dist = knn_graph.indices.reshape(N, -1)\n    k = dist.shape[1]\n    for (i, y) in enumerate(labels):\n        idx = dist[i][::-1]\n        ans = labels[idx]\n        scores[idx[k - 1]][i] = float(ans[k - 1] == y) / k\n        cur = k - 2\n        for j in range(k - 1):\n            scores[idx[cur]][i] = scores[idx[cur + 1]][i] + float(int(ans[cur] == y) - int(ans[cur + 1] == y)) / k * (min(cur, k - 1) + 1) / (cur + 1)\n            cur -= 1\n    return 0.5 * (np.mean(scores, axis=1) + 1)",
            "def _knn_shapley_score(knn_graph: csr_matrix, labels: np.ndarray) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute the Shapley values of data points based on a knn graph.'\n    N = labels.shape[0]\n    scores = np.zeros((N, N))\n    dist = knn_graph.indices.reshape(N, -1)\n    k = dist.shape[1]\n    for (i, y) in enumerate(labels):\n        idx = dist[i][::-1]\n        ans = labels[idx]\n        scores[idx[k - 1]][i] = float(ans[k - 1] == y) / k\n        cur = k - 2\n        for j in range(k - 1):\n            scores[idx[cur]][i] = scores[idx[cur + 1]][i] + float(int(ans[cur] == y) - int(ans[cur + 1] == y)) / k * (min(cur, k - 1) + 1) / (cur + 1)\n            cur -= 1\n    return 0.5 * (np.mean(scores, axis=1) + 1)"
        ]
    }
]