[
    {
        "func_name": "sparse_attention",
        "original": "def sparse_attention(query, key, value, sparse_csr_offset, sparse_csr_columns, key_padding_mask=None, attn_mask=None, name=None):\n    \"\"\"\n    This operator sparsify the Attention matrix in Transformer module\n    to achieve the effect of reducing memory consumption and computation.\n    The sparse layout is expressed in CSR format and contains two parameters,\n    ``offset`` and ``columns``. The equation is:\n\n    .. math::\n\n        result=softmax(\\\\frac{ Q * K^T }{\\\\sqrt{d}}) * V\n\n    where : ``Q``, ``K``, and ``V`` represent the three input parameters of the attention module.\n    The dimensions of the three parameters are the same.\n    ``d`` represents the size of the last dimension of the three parameters.\n\n    Warning:\n        This API is only used in ``CUDA 11.3`` and above versions.\n\n    Args:\n        query(Tensor): The query tensor in the Attention module.\n                        4-D tensor with shape:\n                        [batch_size, num_heads, seq_len, head_dim].\n                        The dtype can be float32 and float64.\n        key(Tensor): The key tensor in the Attention module.\n                        4-D tensor with shape:\n                        [batch_size, num_heads, seq_len, head_dim].\n                        The dtype can be float32 and float64.\n        value(Tensor): The value tensor in the Attention module.\n                        4-D tensor with shape:\n                        [batch_size, num_heads, seq_len, head_dim].\n                        The dtype can be float32 and float64.\n        sparse_csr_offset(Tensor): The sparsity feature in the Attention module\n                        is expressed in the CSR format, and the offset represents\n                        the number of non-zero elements in each row of the matrix.\n                        3-D tensor with shape:\n                        [batch_size, num_heads, seq_len + 1].\n                        The dtype should be int32.\n        sparse_csr_columns(Tensor): The sparsity feature in the Attention module\n                        is expressed in the CSR format, and the columns represent\n                        the column index values of non-zero elements in the matrix.\n                        3-D tensor with shape:\n                        [batch_size, num_heads, sparse_nnz].\n                        The dtype should be int32.\n        key_padding_mask(Tensor, optional):The key padding mask tensor in the Attention module.\n                        2-D tensor with shape: [batch_size, seq_len].\n                        The dtype can be float32 and float64.\n                        A value of 0 means that the position is masked.\n        attn_mask(Tensor, optional):The attention mask tensor in the Attention module.\n                        2-D tensor with shape: [seq_len, seq_len].\n                        The dtype can be float32 and float64.\n                        A value of 0 means that the position is masked.\n        name(str, optional): The default value is None. Normally there is no need for user\n                        to set this property. For more information, please refer to\n                        :ref:`api_guide_Name`.\n\n    Returns:\n        4-D tensor with shape:\n        [batch_size, num_heads, seq_len, head_dim].\n        The dtype can be float32 or float64.\n\n    Examples:\n        .. code-block:: python\n\n            >>> # doctest: +SKIP('This API is only used in CUDA11.3 and above.')\n            >>> import paddle\n\n            >>> paddle.disable_static()\n\n            >>> # `query`, `key` and `value` all have shape [1, 1, 4, 2]\n            >>> query = paddle.to_tensor([[[[0, 1, ], [2, 3],\n            ...                             [0, 1], [2, 3]]]], dtype=\"float32\")\n            >>> key = paddle.to_tensor([[[[0, 1], [2, 3],\n            ...                           [0, 1], [2, 3]]]], dtype=\"float32\")\n            >>> value = paddle.to_tensor([[[[0, 1], [2, 3],\n            ...                             [0, 1], [2, 3]]]], dtype=\"float32\")\n            ...\n            >>> offset = paddle.to_tensor([[[0, 2, 4, 6, 8]]], dtype=\"int32\")\n            >>> columns = paddle.to_tensor([[[0, 1, 0, 1, 2, 3, 2, 3]]], dtype=\"int32\")\n            ...\n            >>> print(offset.shape)\n            [1, 1, 5]\n            >>> print(columns.shape)\n            [1, 1, 8]\n            ...\n            >>> key_padding_mask = paddle.to_tensor([[1, 1, 1, 0]], dtype=\"float32\")\n            >>> attention_mask = paddle.to_tensor([[1, 0, 1, 1],\n            ...                                    [1, 1, 1, 1],\n            ...                                    [1, 1, 1, 1],\n            ...                                    [1, 1, 1, 1]], dtype=\"float32\")\n            >>> output_mask = paddle.nn.functional.sparse_attention(query, key,\n            ...                                                     value, offset, columns,\n            ...                                                     key_padding_mask=key_padding_mask,\n            ...                                                     attn_mask=attention_mask)\n            >>> print(output_mask)\n            Tensor(shape=[1, 1, 4, 2], dtype=float32, place=Place(cpu), stop_gradient=False,\n            [[[[0.        , 1.        ],\n               [1.99830270, 2.99830270],\n               [0.        , 1.        ],\n               [0.        , 1.        ]]]])\n\n            >>> output = paddle.nn.functional.sparse_attention(query, key,\n            ...                                             value, offset, columns)\n            >>> print(output)\n            Tensor(shape=[1, 1, 4, 2], dtype=float32, place=Place(cpu), stop_gradient=False,\n            [[[[1.60885942, 2.60885954],\n               [1.99830270, 2.99830270],\n               [1.60885942, 2.60885954],\n               [1.99830270, 2.99830270]]]])\n    \"\"\"\n    if in_dynamic_mode():\n        (result_attention, result_sdd, result_softmax) = _legacy_C_ops.sparse_attention(query, key, value, sparse_csr_offset, sparse_csr_columns, key_padding_mask, attn_mask)\n        return result_attention\n    helper = LayerHelper('sparse_attention', **locals())\n    dtype = helper.input_dtype(input_param_name='Q')\n    out = helper.create_variable_for_type_inference(dtype)\n    result_sdd = helper.create_variable_for_type_inference(dtype)\n    result_softmax = helper.create_variable_for_type_inference(dtype)\n    inputs = {'Q': query, 'K': key, 'V': value, 'Offset': sparse_csr_offset, 'Columns': sparse_csr_columns, 'KeyPaddingMask': key_padding_mask, 'AttnMask': attn_mask}\n    outputs = {'Out': out, 'SparseDotSdd': result_sdd, 'Softmax': result_softmax}\n    helper.append_op(type='sparse_attention', inputs=inputs, outputs=outputs)\n    return out",
        "mutated": [
            "def sparse_attention(query, key, value, sparse_csr_offset, sparse_csr_columns, key_padding_mask=None, attn_mask=None, name=None):\n    if False:\n        i = 10\n    '\\n    This operator sparsify the Attention matrix in Transformer module\\n    to achieve the effect of reducing memory consumption and computation.\\n    The sparse layout is expressed in CSR format and contains two parameters,\\n    ``offset`` and ``columns``. The equation is:\\n\\n    .. math::\\n\\n        result=softmax(\\\\frac{ Q * K^T }{\\\\sqrt{d}}) * V\\n\\n    where : ``Q``, ``K``, and ``V`` represent the three input parameters of the attention module.\\n    The dimensions of the three parameters are the same.\\n    ``d`` represents the size of the last dimension of the three parameters.\\n\\n    Warning:\\n        This API is only used in ``CUDA 11.3`` and above versions.\\n\\n    Args:\\n        query(Tensor): The query tensor in the Attention module.\\n                        4-D tensor with shape:\\n                        [batch_size, num_heads, seq_len, head_dim].\\n                        The dtype can be float32 and float64.\\n        key(Tensor): The key tensor in the Attention module.\\n                        4-D tensor with shape:\\n                        [batch_size, num_heads, seq_len, head_dim].\\n                        The dtype can be float32 and float64.\\n        value(Tensor): The value tensor in the Attention module.\\n                        4-D tensor with shape:\\n                        [batch_size, num_heads, seq_len, head_dim].\\n                        The dtype can be float32 and float64.\\n        sparse_csr_offset(Tensor): The sparsity feature in the Attention module\\n                        is expressed in the CSR format, and the offset represents\\n                        the number of non-zero elements in each row of the matrix.\\n                        3-D tensor with shape:\\n                        [batch_size, num_heads, seq_len + 1].\\n                        The dtype should be int32.\\n        sparse_csr_columns(Tensor): The sparsity feature in the Attention module\\n                        is expressed in the CSR format, and the columns represent\\n                        the column index values of non-zero elements in the matrix.\\n                        3-D tensor with shape:\\n                        [batch_size, num_heads, sparse_nnz].\\n                        The dtype should be int32.\\n        key_padding_mask(Tensor, optional):The key padding mask tensor in the Attention module.\\n                        2-D tensor with shape: [batch_size, seq_len].\\n                        The dtype can be float32 and float64.\\n                        A value of 0 means that the position is masked.\\n        attn_mask(Tensor, optional):The attention mask tensor in the Attention module.\\n                        2-D tensor with shape: [seq_len, seq_len].\\n                        The dtype can be float32 and float64.\\n                        A value of 0 means that the position is masked.\\n        name(str, optional): The default value is None. Normally there is no need for user\\n                        to set this property. For more information, please refer to\\n                        :ref:`api_guide_Name`.\\n\\n    Returns:\\n        4-D tensor with shape:\\n        [batch_size, num_heads, seq_len, head_dim].\\n        The dtype can be float32 or float64.\\n\\n    Examples:\\n        .. code-block:: python\\n\\n            >>> # doctest: +SKIP(\\'This API is only used in CUDA11.3 and above.\\')\\n            >>> import paddle\\n\\n            >>> paddle.disable_static()\\n\\n            >>> # `query`, `key` and `value` all have shape [1, 1, 4, 2]\\n            >>> query = paddle.to_tensor([[[[0, 1, ], [2, 3],\\n            ...                             [0, 1], [2, 3]]]], dtype=\"float32\")\\n            >>> key = paddle.to_tensor([[[[0, 1], [2, 3],\\n            ...                           [0, 1], [2, 3]]]], dtype=\"float32\")\\n            >>> value = paddle.to_tensor([[[[0, 1], [2, 3],\\n            ...                             [0, 1], [2, 3]]]], dtype=\"float32\")\\n            ...\\n            >>> offset = paddle.to_tensor([[[0, 2, 4, 6, 8]]], dtype=\"int32\")\\n            >>> columns = paddle.to_tensor([[[0, 1, 0, 1, 2, 3, 2, 3]]], dtype=\"int32\")\\n            ...\\n            >>> print(offset.shape)\\n            [1, 1, 5]\\n            >>> print(columns.shape)\\n            [1, 1, 8]\\n            ...\\n            >>> key_padding_mask = paddle.to_tensor([[1, 1, 1, 0]], dtype=\"float32\")\\n            >>> attention_mask = paddle.to_tensor([[1, 0, 1, 1],\\n            ...                                    [1, 1, 1, 1],\\n            ...                                    [1, 1, 1, 1],\\n            ...                                    [1, 1, 1, 1]], dtype=\"float32\")\\n            >>> output_mask = paddle.nn.functional.sparse_attention(query, key,\\n            ...                                                     value, offset, columns,\\n            ...                                                     key_padding_mask=key_padding_mask,\\n            ...                                                     attn_mask=attention_mask)\\n            >>> print(output_mask)\\n            Tensor(shape=[1, 1, 4, 2], dtype=float32, place=Place(cpu), stop_gradient=False,\\n            [[[[0.        , 1.        ],\\n               [1.99830270, 2.99830270],\\n               [0.        , 1.        ],\\n               [0.        , 1.        ]]]])\\n\\n            >>> output = paddle.nn.functional.sparse_attention(query, key,\\n            ...                                             value, offset, columns)\\n            >>> print(output)\\n            Tensor(shape=[1, 1, 4, 2], dtype=float32, place=Place(cpu), stop_gradient=False,\\n            [[[[1.60885942, 2.60885954],\\n               [1.99830270, 2.99830270],\\n               [1.60885942, 2.60885954],\\n               [1.99830270, 2.99830270]]]])\\n    '\n    if in_dynamic_mode():\n        (result_attention, result_sdd, result_softmax) = _legacy_C_ops.sparse_attention(query, key, value, sparse_csr_offset, sparse_csr_columns, key_padding_mask, attn_mask)\n        return result_attention\n    helper = LayerHelper('sparse_attention', **locals())\n    dtype = helper.input_dtype(input_param_name='Q')\n    out = helper.create_variable_for_type_inference(dtype)\n    result_sdd = helper.create_variable_for_type_inference(dtype)\n    result_softmax = helper.create_variable_for_type_inference(dtype)\n    inputs = {'Q': query, 'K': key, 'V': value, 'Offset': sparse_csr_offset, 'Columns': sparse_csr_columns, 'KeyPaddingMask': key_padding_mask, 'AttnMask': attn_mask}\n    outputs = {'Out': out, 'SparseDotSdd': result_sdd, 'Softmax': result_softmax}\n    helper.append_op(type='sparse_attention', inputs=inputs, outputs=outputs)\n    return out",
            "def sparse_attention(query, key, value, sparse_csr_offset, sparse_csr_columns, key_padding_mask=None, attn_mask=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    This operator sparsify the Attention matrix in Transformer module\\n    to achieve the effect of reducing memory consumption and computation.\\n    The sparse layout is expressed in CSR format and contains two parameters,\\n    ``offset`` and ``columns``. The equation is:\\n\\n    .. math::\\n\\n        result=softmax(\\\\frac{ Q * K^T }{\\\\sqrt{d}}) * V\\n\\n    where : ``Q``, ``K``, and ``V`` represent the three input parameters of the attention module.\\n    The dimensions of the three parameters are the same.\\n    ``d`` represents the size of the last dimension of the three parameters.\\n\\n    Warning:\\n        This API is only used in ``CUDA 11.3`` and above versions.\\n\\n    Args:\\n        query(Tensor): The query tensor in the Attention module.\\n                        4-D tensor with shape:\\n                        [batch_size, num_heads, seq_len, head_dim].\\n                        The dtype can be float32 and float64.\\n        key(Tensor): The key tensor in the Attention module.\\n                        4-D tensor with shape:\\n                        [batch_size, num_heads, seq_len, head_dim].\\n                        The dtype can be float32 and float64.\\n        value(Tensor): The value tensor in the Attention module.\\n                        4-D tensor with shape:\\n                        [batch_size, num_heads, seq_len, head_dim].\\n                        The dtype can be float32 and float64.\\n        sparse_csr_offset(Tensor): The sparsity feature in the Attention module\\n                        is expressed in the CSR format, and the offset represents\\n                        the number of non-zero elements in each row of the matrix.\\n                        3-D tensor with shape:\\n                        [batch_size, num_heads, seq_len + 1].\\n                        The dtype should be int32.\\n        sparse_csr_columns(Tensor): The sparsity feature in the Attention module\\n                        is expressed in the CSR format, and the columns represent\\n                        the column index values of non-zero elements in the matrix.\\n                        3-D tensor with shape:\\n                        [batch_size, num_heads, sparse_nnz].\\n                        The dtype should be int32.\\n        key_padding_mask(Tensor, optional):The key padding mask tensor in the Attention module.\\n                        2-D tensor with shape: [batch_size, seq_len].\\n                        The dtype can be float32 and float64.\\n                        A value of 0 means that the position is masked.\\n        attn_mask(Tensor, optional):The attention mask tensor in the Attention module.\\n                        2-D tensor with shape: [seq_len, seq_len].\\n                        The dtype can be float32 and float64.\\n                        A value of 0 means that the position is masked.\\n        name(str, optional): The default value is None. Normally there is no need for user\\n                        to set this property. For more information, please refer to\\n                        :ref:`api_guide_Name`.\\n\\n    Returns:\\n        4-D tensor with shape:\\n        [batch_size, num_heads, seq_len, head_dim].\\n        The dtype can be float32 or float64.\\n\\n    Examples:\\n        .. code-block:: python\\n\\n            >>> # doctest: +SKIP(\\'This API is only used in CUDA11.3 and above.\\')\\n            >>> import paddle\\n\\n            >>> paddle.disable_static()\\n\\n            >>> # `query`, `key` and `value` all have shape [1, 1, 4, 2]\\n            >>> query = paddle.to_tensor([[[[0, 1, ], [2, 3],\\n            ...                             [0, 1], [2, 3]]]], dtype=\"float32\")\\n            >>> key = paddle.to_tensor([[[[0, 1], [2, 3],\\n            ...                           [0, 1], [2, 3]]]], dtype=\"float32\")\\n            >>> value = paddle.to_tensor([[[[0, 1], [2, 3],\\n            ...                             [0, 1], [2, 3]]]], dtype=\"float32\")\\n            ...\\n            >>> offset = paddle.to_tensor([[[0, 2, 4, 6, 8]]], dtype=\"int32\")\\n            >>> columns = paddle.to_tensor([[[0, 1, 0, 1, 2, 3, 2, 3]]], dtype=\"int32\")\\n            ...\\n            >>> print(offset.shape)\\n            [1, 1, 5]\\n            >>> print(columns.shape)\\n            [1, 1, 8]\\n            ...\\n            >>> key_padding_mask = paddle.to_tensor([[1, 1, 1, 0]], dtype=\"float32\")\\n            >>> attention_mask = paddle.to_tensor([[1, 0, 1, 1],\\n            ...                                    [1, 1, 1, 1],\\n            ...                                    [1, 1, 1, 1],\\n            ...                                    [1, 1, 1, 1]], dtype=\"float32\")\\n            >>> output_mask = paddle.nn.functional.sparse_attention(query, key,\\n            ...                                                     value, offset, columns,\\n            ...                                                     key_padding_mask=key_padding_mask,\\n            ...                                                     attn_mask=attention_mask)\\n            >>> print(output_mask)\\n            Tensor(shape=[1, 1, 4, 2], dtype=float32, place=Place(cpu), stop_gradient=False,\\n            [[[[0.        , 1.        ],\\n               [1.99830270, 2.99830270],\\n               [0.        , 1.        ],\\n               [0.        , 1.        ]]]])\\n\\n            >>> output = paddle.nn.functional.sparse_attention(query, key,\\n            ...                                             value, offset, columns)\\n            >>> print(output)\\n            Tensor(shape=[1, 1, 4, 2], dtype=float32, place=Place(cpu), stop_gradient=False,\\n            [[[[1.60885942, 2.60885954],\\n               [1.99830270, 2.99830270],\\n               [1.60885942, 2.60885954],\\n               [1.99830270, 2.99830270]]]])\\n    '\n    if in_dynamic_mode():\n        (result_attention, result_sdd, result_softmax) = _legacy_C_ops.sparse_attention(query, key, value, sparse_csr_offset, sparse_csr_columns, key_padding_mask, attn_mask)\n        return result_attention\n    helper = LayerHelper('sparse_attention', **locals())\n    dtype = helper.input_dtype(input_param_name='Q')\n    out = helper.create_variable_for_type_inference(dtype)\n    result_sdd = helper.create_variable_for_type_inference(dtype)\n    result_softmax = helper.create_variable_for_type_inference(dtype)\n    inputs = {'Q': query, 'K': key, 'V': value, 'Offset': sparse_csr_offset, 'Columns': sparse_csr_columns, 'KeyPaddingMask': key_padding_mask, 'AttnMask': attn_mask}\n    outputs = {'Out': out, 'SparseDotSdd': result_sdd, 'Softmax': result_softmax}\n    helper.append_op(type='sparse_attention', inputs=inputs, outputs=outputs)\n    return out",
            "def sparse_attention(query, key, value, sparse_csr_offset, sparse_csr_columns, key_padding_mask=None, attn_mask=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    This operator sparsify the Attention matrix in Transformer module\\n    to achieve the effect of reducing memory consumption and computation.\\n    The sparse layout is expressed in CSR format and contains two parameters,\\n    ``offset`` and ``columns``. The equation is:\\n\\n    .. math::\\n\\n        result=softmax(\\\\frac{ Q * K^T }{\\\\sqrt{d}}) * V\\n\\n    where : ``Q``, ``K``, and ``V`` represent the three input parameters of the attention module.\\n    The dimensions of the three parameters are the same.\\n    ``d`` represents the size of the last dimension of the three parameters.\\n\\n    Warning:\\n        This API is only used in ``CUDA 11.3`` and above versions.\\n\\n    Args:\\n        query(Tensor): The query tensor in the Attention module.\\n                        4-D tensor with shape:\\n                        [batch_size, num_heads, seq_len, head_dim].\\n                        The dtype can be float32 and float64.\\n        key(Tensor): The key tensor in the Attention module.\\n                        4-D tensor with shape:\\n                        [batch_size, num_heads, seq_len, head_dim].\\n                        The dtype can be float32 and float64.\\n        value(Tensor): The value tensor in the Attention module.\\n                        4-D tensor with shape:\\n                        [batch_size, num_heads, seq_len, head_dim].\\n                        The dtype can be float32 and float64.\\n        sparse_csr_offset(Tensor): The sparsity feature in the Attention module\\n                        is expressed in the CSR format, and the offset represents\\n                        the number of non-zero elements in each row of the matrix.\\n                        3-D tensor with shape:\\n                        [batch_size, num_heads, seq_len + 1].\\n                        The dtype should be int32.\\n        sparse_csr_columns(Tensor): The sparsity feature in the Attention module\\n                        is expressed in the CSR format, and the columns represent\\n                        the column index values of non-zero elements in the matrix.\\n                        3-D tensor with shape:\\n                        [batch_size, num_heads, sparse_nnz].\\n                        The dtype should be int32.\\n        key_padding_mask(Tensor, optional):The key padding mask tensor in the Attention module.\\n                        2-D tensor with shape: [batch_size, seq_len].\\n                        The dtype can be float32 and float64.\\n                        A value of 0 means that the position is masked.\\n        attn_mask(Tensor, optional):The attention mask tensor in the Attention module.\\n                        2-D tensor with shape: [seq_len, seq_len].\\n                        The dtype can be float32 and float64.\\n                        A value of 0 means that the position is masked.\\n        name(str, optional): The default value is None. Normally there is no need for user\\n                        to set this property. For more information, please refer to\\n                        :ref:`api_guide_Name`.\\n\\n    Returns:\\n        4-D tensor with shape:\\n        [batch_size, num_heads, seq_len, head_dim].\\n        The dtype can be float32 or float64.\\n\\n    Examples:\\n        .. code-block:: python\\n\\n            >>> # doctest: +SKIP(\\'This API is only used in CUDA11.3 and above.\\')\\n            >>> import paddle\\n\\n            >>> paddle.disable_static()\\n\\n            >>> # `query`, `key` and `value` all have shape [1, 1, 4, 2]\\n            >>> query = paddle.to_tensor([[[[0, 1, ], [2, 3],\\n            ...                             [0, 1], [2, 3]]]], dtype=\"float32\")\\n            >>> key = paddle.to_tensor([[[[0, 1], [2, 3],\\n            ...                           [0, 1], [2, 3]]]], dtype=\"float32\")\\n            >>> value = paddle.to_tensor([[[[0, 1], [2, 3],\\n            ...                             [0, 1], [2, 3]]]], dtype=\"float32\")\\n            ...\\n            >>> offset = paddle.to_tensor([[[0, 2, 4, 6, 8]]], dtype=\"int32\")\\n            >>> columns = paddle.to_tensor([[[0, 1, 0, 1, 2, 3, 2, 3]]], dtype=\"int32\")\\n            ...\\n            >>> print(offset.shape)\\n            [1, 1, 5]\\n            >>> print(columns.shape)\\n            [1, 1, 8]\\n            ...\\n            >>> key_padding_mask = paddle.to_tensor([[1, 1, 1, 0]], dtype=\"float32\")\\n            >>> attention_mask = paddle.to_tensor([[1, 0, 1, 1],\\n            ...                                    [1, 1, 1, 1],\\n            ...                                    [1, 1, 1, 1],\\n            ...                                    [1, 1, 1, 1]], dtype=\"float32\")\\n            >>> output_mask = paddle.nn.functional.sparse_attention(query, key,\\n            ...                                                     value, offset, columns,\\n            ...                                                     key_padding_mask=key_padding_mask,\\n            ...                                                     attn_mask=attention_mask)\\n            >>> print(output_mask)\\n            Tensor(shape=[1, 1, 4, 2], dtype=float32, place=Place(cpu), stop_gradient=False,\\n            [[[[0.        , 1.        ],\\n               [1.99830270, 2.99830270],\\n               [0.        , 1.        ],\\n               [0.        , 1.        ]]]])\\n\\n            >>> output = paddle.nn.functional.sparse_attention(query, key,\\n            ...                                             value, offset, columns)\\n            >>> print(output)\\n            Tensor(shape=[1, 1, 4, 2], dtype=float32, place=Place(cpu), stop_gradient=False,\\n            [[[[1.60885942, 2.60885954],\\n               [1.99830270, 2.99830270],\\n               [1.60885942, 2.60885954],\\n               [1.99830270, 2.99830270]]]])\\n    '\n    if in_dynamic_mode():\n        (result_attention, result_sdd, result_softmax) = _legacy_C_ops.sparse_attention(query, key, value, sparse_csr_offset, sparse_csr_columns, key_padding_mask, attn_mask)\n        return result_attention\n    helper = LayerHelper('sparse_attention', **locals())\n    dtype = helper.input_dtype(input_param_name='Q')\n    out = helper.create_variable_for_type_inference(dtype)\n    result_sdd = helper.create_variable_for_type_inference(dtype)\n    result_softmax = helper.create_variable_for_type_inference(dtype)\n    inputs = {'Q': query, 'K': key, 'V': value, 'Offset': sparse_csr_offset, 'Columns': sparse_csr_columns, 'KeyPaddingMask': key_padding_mask, 'AttnMask': attn_mask}\n    outputs = {'Out': out, 'SparseDotSdd': result_sdd, 'Softmax': result_softmax}\n    helper.append_op(type='sparse_attention', inputs=inputs, outputs=outputs)\n    return out",
            "def sparse_attention(query, key, value, sparse_csr_offset, sparse_csr_columns, key_padding_mask=None, attn_mask=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    This operator sparsify the Attention matrix in Transformer module\\n    to achieve the effect of reducing memory consumption and computation.\\n    The sparse layout is expressed in CSR format and contains two parameters,\\n    ``offset`` and ``columns``. The equation is:\\n\\n    .. math::\\n\\n        result=softmax(\\\\frac{ Q * K^T }{\\\\sqrt{d}}) * V\\n\\n    where : ``Q``, ``K``, and ``V`` represent the three input parameters of the attention module.\\n    The dimensions of the three parameters are the same.\\n    ``d`` represents the size of the last dimension of the three parameters.\\n\\n    Warning:\\n        This API is only used in ``CUDA 11.3`` and above versions.\\n\\n    Args:\\n        query(Tensor): The query tensor in the Attention module.\\n                        4-D tensor with shape:\\n                        [batch_size, num_heads, seq_len, head_dim].\\n                        The dtype can be float32 and float64.\\n        key(Tensor): The key tensor in the Attention module.\\n                        4-D tensor with shape:\\n                        [batch_size, num_heads, seq_len, head_dim].\\n                        The dtype can be float32 and float64.\\n        value(Tensor): The value tensor in the Attention module.\\n                        4-D tensor with shape:\\n                        [batch_size, num_heads, seq_len, head_dim].\\n                        The dtype can be float32 and float64.\\n        sparse_csr_offset(Tensor): The sparsity feature in the Attention module\\n                        is expressed in the CSR format, and the offset represents\\n                        the number of non-zero elements in each row of the matrix.\\n                        3-D tensor with shape:\\n                        [batch_size, num_heads, seq_len + 1].\\n                        The dtype should be int32.\\n        sparse_csr_columns(Tensor): The sparsity feature in the Attention module\\n                        is expressed in the CSR format, and the columns represent\\n                        the column index values of non-zero elements in the matrix.\\n                        3-D tensor with shape:\\n                        [batch_size, num_heads, sparse_nnz].\\n                        The dtype should be int32.\\n        key_padding_mask(Tensor, optional):The key padding mask tensor in the Attention module.\\n                        2-D tensor with shape: [batch_size, seq_len].\\n                        The dtype can be float32 and float64.\\n                        A value of 0 means that the position is masked.\\n        attn_mask(Tensor, optional):The attention mask tensor in the Attention module.\\n                        2-D tensor with shape: [seq_len, seq_len].\\n                        The dtype can be float32 and float64.\\n                        A value of 0 means that the position is masked.\\n        name(str, optional): The default value is None. Normally there is no need for user\\n                        to set this property. For more information, please refer to\\n                        :ref:`api_guide_Name`.\\n\\n    Returns:\\n        4-D tensor with shape:\\n        [batch_size, num_heads, seq_len, head_dim].\\n        The dtype can be float32 or float64.\\n\\n    Examples:\\n        .. code-block:: python\\n\\n            >>> # doctest: +SKIP(\\'This API is only used in CUDA11.3 and above.\\')\\n            >>> import paddle\\n\\n            >>> paddle.disable_static()\\n\\n            >>> # `query`, `key` and `value` all have shape [1, 1, 4, 2]\\n            >>> query = paddle.to_tensor([[[[0, 1, ], [2, 3],\\n            ...                             [0, 1], [2, 3]]]], dtype=\"float32\")\\n            >>> key = paddle.to_tensor([[[[0, 1], [2, 3],\\n            ...                           [0, 1], [2, 3]]]], dtype=\"float32\")\\n            >>> value = paddle.to_tensor([[[[0, 1], [2, 3],\\n            ...                             [0, 1], [2, 3]]]], dtype=\"float32\")\\n            ...\\n            >>> offset = paddle.to_tensor([[[0, 2, 4, 6, 8]]], dtype=\"int32\")\\n            >>> columns = paddle.to_tensor([[[0, 1, 0, 1, 2, 3, 2, 3]]], dtype=\"int32\")\\n            ...\\n            >>> print(offset.shape)\\n            [1, 1, 5]\\n            >>> print(columns.shape)\\n            [1, 1, 8]\\n            ...\\n            >>> key_padding_mask = paddle.to_tensor([[1, 1, 1, 0]], dtype=\"float32\")\\n            >>> attention_mask = paddle.to_tensor([[1, 0, 1, 1],\\n            ...                                    [1, 1, 1, 1],\\n            ...                                    [1, 1, 1, 1],\\n            ...                                    [1, 1, 1, 1]], dtype=\"float32\")\\n            >>> output_mask = paddle.nn.functional.sparse_attention(query, key,\\n            ...                                                     value, offset, columns,\\n            ...                                                     key_padding_mask=key_padding_mask,\\n            ...                                                     attn_mask=attention_mask)\\n            >>> print(output_mask)\\n            Tensor(shape=[1, 1, 4, 2], dtype=float32, place=Place(cpu), stop_gradient=False,\\n            [[[[0.        , 1.        ],\\n               [1.99830270, 2.99830270],\\n               [0.        , 1.        ],\\n               [0.        , 1.        ]]]])\\n\\n            >>> output = paddle.nn.functional.sparse_attention(query, key,\\n            ...                                             value, offset, columns)\\n            >>> print(output)\\n            Tensor(shape=[1, 1, 4, 2], dtype=float32, place=Place(cpu), stop_gradient=False,\\n            [[[[1.60885942, 2.60885954],\\n               [1.99830270, 2.99830270],\\n               [1.60885942, 2.60885954],\\n               [1.99830270, 2.99830270]]]])\\n    '\n    if in_dynamic_mode():\n        (result_attention, result_sdd, result_softmax) = _legacy_C_ops.sparse_attention(query, key, value, sparse_csr_offset, sparse_csr_columns, key_padding_mask, attn_mask)\n        return result_attention\n    helper = LayerHelper('sparse_attention', **locals())\n    dtype = helper.input_dtype(input_param_name='Q')\n    out = helper.create_variable_for_type_inference(dtype)\n    result_sdd = helper.create_variable_for_type_inference(dtype)\n    result_softmax = helper.create_variable_for_type_inference(dtype)\n    inputs = {'Q': query, 'K': key, 'V': value, 'Offset': sparse_csr_offset, 'Columns': sparse_csr_columns, 'KeyPaddingMask': key_padding_mask, 'AttnMask': attn_mask}\n    outputs = {'Out': out, 'SparseDotSdd': result_sdd, 'Softmax': result_softmax}\n    helper.append_op(type='sparse_attention', inputs=inputs, outputs=outputs)\n    return out",
            "def sparse_attention(query, key, value, sparse_csr_offset, sparse_csr_columns, key_padding_mask=None, attn_mask=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    This operator sparsify the Attention matrix in Transformer module\\n    to achieve the effect of reducing memory consumption and computation.\\n    The sparse layout is expressed in CSR format and contains two parameters,\\n    ``offset`` and ``columns``. The equation is:\\n\\n    .. math::\\n\\n        result=softmax(\\\\frac{ Q * K^T }{\\\\sqrt{d}}) * V\\n\\n    where : ``Q``, ``K``, and ``V`` represent the three input parameters of the attention module.\\n    The dimensions of the three parameters are the same.\\n    ``d`` represents the size of the last dimension of the three parameters.\\n\\n    Warning:\\n        This API is only used in ``CUDA 11.3`` and above versions.\\n\\n    Args:\\n        query(Tensor): The query tensor in the Attention module.\\n                        4-D tensor with shape:\\n                        [batch_size, num_heads, seq_len, head_dim].\\n                        The dtype can be float32 and float64.\\n        key(Tensor): The key tensor in the Attention module.\\n                        4-D tensor with shape:\\n                        [batch_size, num_heads, seq_len, head_dim].\\n                        The dtype can be float32 and float64.\\n        value(Tensor): The value tensor in the Attention module.\\n                        4-D tensor with shape:\\n                        [batch_size, num_heads, seq_len, head_dim].\\n                        The dtype can be float32 and float64.\\n        sparse_csr_offset(Tensor): The sparsity feature in the Attention module\\n                        is expressed in the CSR format, and the offset represents\\n                        the number of non-zero elements in each row of the matrix.\\n                        3-D tensor with shape:\\n                        [batch_size, num_heads, seq_len + 1].\\n                        The dtype should be int32.\\n        sparse_csr_columns(Tensor): The sparsity feature in the Attention module\\n                        is expressed in the CSR format, and the columns represent\\n                        the column index values of non-zero elements in the matrix.\\n                        3-D tensor with shape:\\n                        [batch_size, num_heads, sparse_nnz].\\n                        The dtype should be int32.\\n        key_padding_mask(Tensor, optional):The key padding mask tensor in the Attention module.\\n                        2-D tensor with shape: [batch_size, seq_len].\\n                        The dtype can be float32 and float64.\\n                        A value of 0 means that the position is masked.\\n        attn_mask(Tensor, optional):The attention mask tensor in the Attention module.\\n                        2-D tensor with shape: [seq_len, seq_len].\\n                        The dtype can be float32 and float64.\\n                        A value of 0 means that the position is masked.\\n        name(str, optional): The default value is None. Normally there is no need for user\\n                        to set this property. For more information, please refer to\\n                        :ref:`api_guide_Name`.\\n\\n    Returns:\\n        4-D tensor with shape:\\n        [batch_size, num_heads, seq_len, head_dim].\\n        The dtype can be float32 or float64.\\n\\n    Examples:\\n        .. code-block:: python\\n\\n            >>> # doctest: +SKIP(\\'This API is only used in CUDA11.3 and above.\\')\\n            >>> import paddle\\n\\n            >>> paddle.disable_static()\\n\\n            >>> # `query`, `key` and `value` all have shape [1, 1, 4, 2]\\n            >>> query = paddle.to_tensor([[[[0, 1, ], [2, 3],\\n            ...                             [0, 1], [2, 3]]]], dtype=\"float32\")\\n            >>> key = paddle.to_tensor([[[[0, 1], [2, 3],\\n            ...                           [0, 1], [2, 3]]]], dtype=\"float32\")\\n            >>> value = paddle.to_tensor([[[[0, 1], [2, 3],\\n            ...                             [0, 1], [2, 3]]]], dtype=\"float32\")\\n            ...\\n            >>> offset = paddle.to_tensor([[[0, 2, 4, 6, 8]]], dtype=\"int32\")\\n            >>> columns = paddle.to_tensor([[[0, 1, 0, 1, 2, 3, 2, 3]]], dtype=\"int32\")\\n            ...\\n            >>> print(offset.shape)\\n            [1, 1, 5]\\n            >>> print(columns.shape)\\n            [1, 1, 8]\\n            ...\\n            >>> key_padding_mask = paddle.to_tensor([[1, 1, 1, 0]], dtype=\"float32\")\\n            >>> attention_mask = paddle.to_tensor([[1, 0, 1, 1],\\n            ...                                    [1, 1, 1, 1],\\n            ...                                    [1, 1, 1, 1],\\n            ...                                    [1, 1, 1, 1]], dtype=\"float32\")\\n            >>> output_mask = paddle.nn.functional.sparse_attention(query, key,\\n            ...                                                     value, offset, columns,\\n            ...                                                     key_padding_mask=key_padding_mask,\\n            ...                                                     attn_mask=attention_mask)\\n            >>> print(output_mask)\\n            Tensor(shape=[1, 1, 4, 2], dtype=float32, place=Place(cpu), stop_gradient=False,\\n            [[[[0.        , 1.        ],\\n               [1.99830270, 2.99830270],\\n               [0.        , 1.        ],\\n               [0.        , 1.        ]]]])\\n\\n            >>> output = paddle.nn.functional.sparse_attention(query, key,\\n            ...                                             value, offset, columns)\\n            >>> print(output)\\n            Tensor(shape=[1, 1, 4, 2], dtype=float32, place=Place(cpu), stop_gradient=False,\\n            [[[[1.60885942, 2.60885954],\\n               [1.99830270, 2.99830270],\\n               [1.60885942, 2.60885954],\\n               [1.99830270, 2.99830270]]]])\\n    '\n    if in_dynamic_mode():\n        (result_attention, result_sdd, result_softmax) = _legacy_C_ops.sparse_attention(query, key, value, sparse_csr_offset, sparse_csr_columns, key_padding_mask, attn_mask)\n        return result_attention\n    helper = LayerHelper('sparse_attention', **locals())\n    dtype = helper.input_dtype(input_param_name='Q')\n    out = helper.create_variable_for_type_inference(dtype)\n    result_sdd = helper.create_variable_for_type_inference(dtype)\n    result_softmax = helper.create_variable_for_type_inference(dtype)\n    inputs = {'Q': query, 'K': key, 'V': value, 'Offset': sparse_csr_offset, 'Columns': sparse_csr_columns, 'KeyPaddingMask': key_padding_mask, 'AttnMask': attn_mask}\n    outputs = {'Out': out, 'SparseDotSdd': result_sdd, 'Softmax': result_softmax}\n    helper.append_op(type='sparse_attention', inputs=inputs, outputs=outputs)\n    return out"
        ]
    }
]