[
    {
        "func_name": "__virtual__",
        "original": "def __virtual__():\n    \"\"\"\n    Only load if the docker execution module is available\n    \"\"\"\n    if 'docker.version' in __salt__:\n        return __virtualname__\n    return (False, __salt__.missing_fun_string('docker.version'))",
        "mutated": [
            "def __virtual__():\n    if False:\n        i = 10\n    '\\n    Only load if the docker execution module is available\\n    '\n    if 'docker.version' in __salt__:\n        return __virtualname__\n    return (False, __salt__.missing_fun_string('docker.version'))",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Only load if the docker execution module is available\\n    '\n    if 'docker.version' in __salt__:\n        return __virtualname__\n    return (False, __salt__.missing_fun_string('docker.version'))",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Only load if the docker execution module is available\\n    '\n    if 'docker.version' in __salt__:\n        return __virtualname__\n    return (False, __salt__.missing_fun_string('docker.version'))",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Only load if the docker execution module is available\\n    '\n    if 'docker.version' in __salt__:\n        return __virtualname__\n    return (False, __salt__.missing_fun_string('docker.version'))",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Only load if the docker execution module is available\\n    '\n    if 'docker.version' in __salt__:\n        return __virtualname__\n    return (False, __salt__.missing_fun_string('docker.version'))"
        ]
    },
    {
        "func_name": "present",
        "original": "def present(name, tag=None, build=None, load=None, force=False, insecure_registry=False, client_timeout=salt.utils.dockermod.CLIENT_TIMEOUT, dockerfile=None, sls=None, base='opensuse/python', saltenv='base', pillarenv=None, pillar=None, **kwargs):\n    \"\"\"\n    .. versionchanged:: 2018.3.0\n        The ``tag`` argument has been added. It is now required unless pulling\n        from a registry.\n\n    Ensure that an image is present. The image can either be pulled from a\n    Docker registry, built from a Dockerfile, loaded from a saved image, or\n    built by running SLS files against a base image.\n\n    If none of the ``build``, ``load``, or ``sls`` arguments are used, then Salt\n    will pull from the :ref:`configured registries <docker-authentication>`. If\n    the specified image already exists, it will not be pulled unless ``force``\n    is set to ``True``. Here is an example of a state that will pull an image\n    from the Docker Hub:\n\n    .. code-block:: yaml\n\n        myuser/myimage:\n          docker_image.present:\n            - tag: mytag\n\n    name\n        The name of the docker image.\n\n    tag\n        Tag name for the image. Required when using ``build``, ``load``, or\n        ``sls`` to create the image, but optional if pulling from a repository.\n\n        .. versionadded:: 2018.3.0\n\n    build\n        Path to directory on the Minion containing a Dockerfile\n\n        .. code-block:: yaml\n\n            myuser/myimage:\n              docker_image.present:\n                - build: /home/myuser/docker/myimage\n                - tag: mytag\n\n            myuser/myimage:\n              docker_image.present:\n                - build: /home/myuser/docker/myimage\n                - tag: mytag\n                - dockerfile: Dockerfile.alternative\n\n        The image will be built using :py:func:`docker.build\n        <salt.modules.dockermod.build>` and the specified image name and tag\n        will be applied to it.\n\n        .. versionadded:: 2016.11.0\n        .. versionchanged:: 2018.3.0\n            The ``tag`` must be manually specified using the ``tag`` argument.\n\n    load\n        Loads a tar archive created with :py:func:`docker.save\n        <salt.modules.dockermod.save>` (or the ``docker save`` Docker CLI\n        command), and assigns it the specified repo and tag.\n\n        .. code-block:: yaml\n\n            myuser/myimage:\n              docker_image.present:\n                - load: salt://path/to/image.tar\n                - tag: mytag\n\n        .. versionchanged:: 2018.3.0\n            The ``tag`` must be manually specified using the ``tag`` argument.\n\n    force\n        Set this parameter to ``True`` to force Salt to pull/build/load the\n        image even if it is already present.\n\n    insecure_registry\n        If ``True``, the Docker client will permit the use of insecure\n        (non-HTTPS) registries.\n\n    client_timeout\n        Timeout in seconds for the Docker client. This is not a timeout for\n        the state, but for receiving a response from the API.\n\n    dockerfile\n        Allows for an alternative Dockerfile to be specified.  Path to alternative\n        Dockefile is relative to the build path for the Docker container.\n\n        .. versionadded:: 2016.11.0\n\n    sls\n        Allow for building of image with :py:func:`docker.sls_build\n        <salt.modules.dockermod.sls_build>` by specifying the SLS files with\n        which to build. This can be a list or comma-separated string.\n\n        .. code-block:: yaml\n\n            myuser/myimage:\n              docker_image.present:\n                - tag: latest\n                - sls:\n                    - webapp1\n                    - webapp2\n                - base: centos\n                - saltenv: base\n\n        .. versionadded:: 2017.7.0\n        .. versionchanged:: 2018.3.0\n            The ``tag`` must be manually specified using the ``tag`` argument.\n\n    base\n        Base image with which to start :py:func:`docker.sls_build\n        <salt.modules.dockermod.sls_build>`\n\n        .. versionadded:: 2017.7.0\n\n    saltenv\n        Specify the environment from which to retrieve the SLS indicated by the\n        `mods` parameter.\n\n        .. versionadded:: 2017.7.0\n        .. versionchanged:: 2018.3.0\n            Now uses the effective saltenv if not explicitly passed. In earlier\n            versions, ``base`` was assumed as a default.\n\n    pillarenv\n        Specify a Pillar environment to be used when applying states. This\n        can also be set in the minion config file using the\n        :conf_minion:`pillarenv` option. When neither the\n        :conf_minion:`pillarenv` minion config option nor this CLI argument is\n        used, all Pillar environments will be merged together.\n\n        .. versionadded:: 2018.3.0\n\n    pillar\n        Custom Pillar values, passed as a dictionary of key-value pairs\n\n        .. note::\n            Values passed this way will override Pillar values set via\n            ``pillar_roots`` or an external Pillar source.\n\n        .. versionadded:: 2018.3.0\n\n    kwargs\n        Additional keyword arguments to pass to\n        :py:func:`docker.build <salt.modules.dockermod.build>`\n    \"\"\"\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n    if not isinstance(name, str):\n        name = str(name)\n    num_build_args = len([x for x in (build, load, sls) if x is not None])\n    if num_build_args > 1:\n        ret['comment'] = \"Only one of 'build', 'load', or 'sls' is permitted.\"\n        return ret\n    elif num_build_args == 1:\n        if not tag:\n            ret['comment'] = \"The 'tag' argument is required if any one of 'build', 'load', or 'sls' is used.\"\n            return ret\n        if not isinstance(tag, str):\n            tag = str(tag)\n        full_image = ':'.join((name, tag))\n    else:\n        if tag:\n            name = f'{name}:{tag}'\n        full_image = name\n    try:\n        image_info = __salt__['docker.inspect_image'](full_image)\n    except CommandExecutionError as exc:\n        msg = exc.__str__()\n        if '404' in msg:\n            image_info = None\n        else:\n            ret['comment'] = msg\n            return ret\n    if image_info is not None:\n        if not force:\n            ret['result'] = True\n            ret['comment'] = f'Image {full_image} already present'\n            return ret\n    if build or sls:\n        action = 'built'\n    elif load:\n        action = 'loaded'\n    else:\n        action = 'pulled'\n    if __opts__['test']:\n        ret['result'] = None\n        if image_info is not None and force or image_info is None:\n            ret['comment'] = f'Image {full_image} will be {action}'\n            return ret\n    if build:\n        argspec = salt.utils.args.get_function_argspec(__salt__['docker.build'])\n        build_args = dict(list(zip(argspec.args, argspec.defaults)))\n        for k in build_args:\n            if k in kwargs.get('kwargs', {}):\n                build_args[k] = kwargs.get('kwargs', {}).get(k)\n        try:\n            build_args['path'] = build\n            build_args['repository'] = name\n            build_args['tag'] = tag\n            build_args['dockerfile'] = dockerfile\n            image_update = __salt__['docker.build'](**build_args)\n        except Exception as exc:\n            ret['comment'] = 'Encountered error building {} as {}: {}'.format(build, full_image, exc)\n            return ret\n        if image_info is None or image_update['Id'] != image_info['Id'][:12]:\n            ret['changes'] = image_update\n    elif sls:\n        _locals = locals()\n        sls_build_kwargs = {k: _locals[k] for k in ('saltenv', 'pillarenv', 'pillar') if _locals[k] is not None}\n        try:\n            image_update = __salt__['docker.sls_build'](repository=name, tag=tag, base=base, mods=sls, **sls_build_kwargs)\n        except Exception as exc:\n            ret['comment'] = 'Encountered error using SLS {} for building {}: {}'.format(sls, full_image, exc)\n            return ret\n        if image_info is None or image_update['Id'] != image_info['Id'][:12]:\n            ret['changes'] = image_update\n    elif load:\n        try:\n            image_update = __salt__['docker.load'](path=load, repository=name, tag=tag)\n        except Exception as exc:\n            ret['comment'] = 'Encountered error loading {} as {}: {}'.format(load, full_image, exc)\n            return ret\n        if image_info is None or image_update.get('Layers', []):\n            ret['changes'] = image_update\n    else:\n        try:\n            image_update = __salt__['docker.pull'](name, insecure_registry=insecure_registry, client_timeout=client_timeout)\n        except Exception as exc:\n            ret['comment'] = f'Encountered error pulling {full_image}: {exc}'\n            return ret\n        if image_info is not None and image_info['Id'][:12] == image_update.get('Layers', {}).get('Already_Pulled', [None])[0]:\n            pass\n        elif image_info is None or image_update.get('Layers', {}).get('Pulled'):\n            ret['changes'] = image_update\n    error = False\n    try:\n        __salt__['docker.inspect_image'](full_image)\n    except CommandExecutionError as exc:\n        msg = exc.__str__()\n        if '404' not in msg:\n            error = \"Failed to inspect image '{}' after it was {}: {}\".format(full_image, action, msg)\n    if error:\n        ret['comment'] = error\n    else:\n        ret['result'] = True\n        if not ret['changes']:\n            ret['comment'] = \"Image '{}' was {}, but there were no changes\".format(name, action)\n        else:\n            ret['comment'] = f\"Image '{full_image}' was {action}\"\n    return ret",
        "mutated": [
            "def present(name, tag=None, build=None, load=None, force=False, insecure_registry=False, client_timeout=salt.utils.dockermod.CLIENT_TIMEOUT, dockerfile=None, sls=None, base='opensuse/python', saltenv='base', pillarenv=None, pillar=None, **kwargs):\n    if False:\n        i = 10\n    '\\n    .. versionchanged:: 2018.3.0\\n        The ``tag`` argument has been added. It is now required unless pulling\\n        from a registry.\\n\\n    Ensure that an image is present. The image can either be pulled from a\\n    Docker registry, built from a Dockerfile, loaded from a saved image, or\\n    built by running SLS files against a base image.\\n\\n    If none of the ``build``, ``load``, or ``sls`` arguments are used, then Salt\\n    will pull from the :ref:`configured registries <docker-authentication>`. If\\n    the specified image already exists, it will not be pulled unless ``force``\\n    is set to ``True``. Here is an example of a state that will pull an image\\n    from the Docker Hub:\\n\\n    .. code-block:: yaml\\n\\n        myuser/myimage:\\n          docker_image.present:\\n            - tag: mytag\\n\\n    name\\n        The name of the docker image.\\n\\n    tag\\n        Tag name for the image. Required when using ``build``, ``load``, or\\n        ``sls`` to create the image, but optional if pulling from a repository.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    build\\n        Path to directory on the Minion containing a Dockerfile\\n\\n        .. code-block:: yaml\\n\\n            myuser/myimage:\\n              docker_image.present:\\n                - build: /home/myuser/docker/myimage\\n                - tag: mytag\\n\\n            myuser/myimage:\\n              docker_image.present:\\n                - build: /home/myuser/docker/myimage\\n                - tag: mytag\\n                - dockerfile: Dockerfile.alternative\\n\\n        The image will be built using :py:func:`docker.build\\n        <salt.modules.dockermod.build>` and the specified image name and tag\\n        will be applied to it.\\n\\n        .. versionadded:: 2016.11.0\\n        .. versionchanged:: 2018.3.0\\n            The ``tag`` must be manually specified using the ``tag`` argument.\\n\\n    load\\n        Loads a tar archive created with :py:func:`docker.save\\n        <salt.modules.dockermod.save>` (or the ``docker save`` Docker CLI\\n        command), and assigns it the specified repo and tag.\\n\\n        .. code-block:: yaml\\n\\n            myuser/myimage:\\n              docker_image.present:\\n                - load: salt://path/to/image.tar\\n                - tag: mytag\\n\\n        .. versionchanged:: 2018.3.0\\n            The ``tag`` must be manually specified using the ``tag`` argument.\\n\\n    force\\n        Set this parameter to ``True`` to force Salt to pull/build/load the\\n        image even if it is already present.\\n\\n    insecure_registry\\n        If ``True``, the Docker client will permit the use of insecure\\n        (non-HTTPS) registries.\\n\\n    client_timeout\\n        Timeout in seconds for the Docker client. This is not a timeout for\\n        the state, but for receiving a response from the API.\\n\\n    dockerfile\\n        Allows for an alternative Dockerfile to be specified.  Path to alternative\\n        Dockefile is relative to the build path for the Docker container.\\n\\n        .. versionadded:: 2016.11.0\\n\\n    sls\\n        Allow for building of image with :py:func:`docker.sls_build\\n        <salt.modules.dockermod.sls_build>` by specifying the SLS files with\\n        which to build. This can be a list or comma-separated string.\\n\\n        .. code-block:: yaml\\n\\n            myuser/myimage:\\n              docker_image.present:\\n                - tag: latest\\n                - sls:\\n                    - webapp1\\n                    - webapp2\\n                - base: centos\\n                - saltenv: base\\n\\n        .. versionadded:: 2017.7.0\\n        .. versionchanged:: 2018.3.0\\n            The ``tag`` must be manually specified using the ``tag`` argument.\\n\\n    base\\n        Base image with which to start :py:func:`docker.sls_build\\n        <salt.modules.dockermod.sls_build>`\\n\\n        .. versionadded:: 2017.7.0\\n\\n    saltenv\\n        Specify the environment from which to retrieve the SLS indicated by the\\n        `mods` parameter.\\n\\n        .. versionadded:: 2017.7.0\\n        .. versionchanged:: 2018.3.0\\n            Now uses the effective saltenv if not explicitly passed. In earlier\\n            versions, ``base`` was assumed as a default.\\n\\n    pillarenv\\n        Specify a Pillar environment to be used when applying states. This\\n        can also be set in the minion config file using the\\n        :conf_minion:`pillarenv` option. When neither the\\n        :conf_minion:`pillarenv` minion config option nor this CLI argument is\\n        used, all Pillar environments will be merged together.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    pillar\\n        Custom Pillar values, passed as a dictionary of key-value pairs\\n\\n        .. note::\\n            Values passed this way will override Pillar values set via\\n            ``pillar_roots`` or an external Pillar source.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    kwargs\\n        Additional keyword arguments to pass to\\n        :py:func:`docker.build <salt.modules.dockermod.build>`\\n    '\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n    if not isinstance(name, str):\n        name = str(name)\n    num_build_args = len([x for x in (build, load, sls) if x is not None])\n    if num_build_args > 1:\n        ret['comment'] = \"Only one of 'build', 'load', or 'sls' is permitted.\"\n        return ret\n    elif num_build_args == 1:\n        if not tag:\n            ret['comment'] = \"The 'tag' argument is required if any one of 'build', 'load', or 'sls' is used.\"\n            return ret\n        if not isinstance(tag, str):\n            tag = str(tag)\n        full_image = ':'.join((name, tag))\n    else:\n        if tag:\n            name = f'{name}:{tag}'\n        full_image = name\n    try:\n        image_info = __salt__['docker.inspect_image'](full_image)\n    except CommandExecutionError as exc:\n        msg = exc.__str__()\n        if '404' in msg:\n            image_info = None\n        else:\n            ret['comment'] = msg\n            return ret\n    if image_info is not None:\n        if not force:\n            ret['result'] = True\n            ret['comment'] = f'Image {full_image} already present'\n            return ret\n    if build or sls:\n        action = 'built'\n    elif load:\n        action = 'loaded'\n    else:\n        action = 'pulled'\n    if __opts__['test']:\n        ret['result'] = None\n        if image_info is not None and force or image_info is None:\n            ret['comment'] = f'Image {full_image} will be {action}'\n            return ret\n    if build:\n        argspec = salt.utils.args.get_function_argspec(__salt__['docker.build'])\n        build_args = dict(list(zip(argspec.args, argspec.defaults)))\n        for k in build_args:\n            if k in kwargs.get('kwargs', {}):\n                build_args[k] = kwargs.get('kwargs', {}).get(k)\n        try:\n            build_args['path'] = build\n            build_args['repository'] = name\n            build_args['tag'] = tag\n            build_args['dockerfile'] = dockerfile\n            image_update = __salt__['docker.build'](**build_args)\n        except Exception as exc:\n            ret['comment'] = 'Encountered error building {} as {}: {}'.format(build, full_image, exc)\n            return ret\n        if image_info is None or image_update['Id'] != image_info['Id'][:12]:\n            ret['changes'] = image_update\n    elif sls:\n        _locals = locals()\n        sls_build_kwargs = {k: _locals[k] for k in ('saltenv', 'pillarenv', 'pillar') if _locals[k] is not None}\n        try:\n            image_update = __salt__['docker.sls_build'](repository=name, tag=tag, base=base, mods=sls, **sls_build_kwargs)\n        except Exception as exc:\n            ret['comment'] = 'Encountered error using SLS {} for building {}: {}'.format(sls, full_image, exc)\n            return ret\n        if image_info is None or image_update['Id'] != image_info['Id'][:12]:\n            ret['changes'] = image_update\n    elif load:\n        try:\n            image_update = __salt__['docker.load'](path=load, repository=name, tag=tag)\n        except Exception as exc:\n            ret['comment'] = 'Encountered error loading {} as {}: {}'.format(load, full_image, exc)\n            return ret\n        if image_info is None or image_update.get('Layers', []):\n            ret['changes'] = image_update\n    else:\n        try:\n            image_update = __salt__['docker.pull'](name, insecure_registry=insecure_registry, client_timeout=client_timeout)\n        except Exception as exc:\n            ret['comment'] = f'Encountered error pulling {full_image}: {exc}'\n            return ret\n        if image_info is not None and image_info['Id'][:12] == image_update.get('Layers', {}).get('Already_Pulled', [None])[0]:\n            pass\n        elif image_info is None or image_update.get('Layers', {}).get('Pulled'):\n            ret['changes'] = image_update\n    error = False\n    try:\n        __salt__['docker.inspect_image'](full_image)\n    except CommandExecutionError as exc:\n        msg = exc.__str__()\n        if '404' not in msg:\n            error = \"Failed to inspect image '{}' after it was {}: {}\".format(full_image, action, msg)\n    if error:\n        ret['comment'] = error\n    else:\n        ret['result'] = True\n        if not ret['changes']:\n            ret['comment'] = \"Image '{}' was {}, but there were no changes\".format(name, action)\n        else:\n            ret['comment'] = f\"Image '{full_image}' was {action}\"\n    return ret",
            "def present(name, tag=None, build=None, load=None, force=False, insecure_registry=False, client_timeout=salt.utils.dockermod.CLIENT_TIMEOUT, dockerfile=None, sls=None, base='opensuse/python', saltenv='base', pillarenv=None, pillar=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    .. versionchanged:: 2018.3.0\\n        The ``tag`` argument has been added. It is now required unless pulling\\n        from a registry.\\n\\n    Ensure that an image is present. The image can either be pulled from a\\n    Docker registry, built from a Dockerfile, loaded from a saved image, or\\n    built by running SLS files against a base image.\\n\\n    If none of the ``build``, ``load``, or ``sls`` arguments are used, then Salt\\n    will pull from the :ref:`configured registries <docker-authentication>`. If\\n    the specified image already exists, it will not be pulled unless ``force``\\n    is set to ``True``. Here is an example of a state that will pull an image\\n    from the Docker Hub:\\n\\n    .. code-block:: yaml\\n\\n        myuser/myimage:\\n          docker_image.present:\\n            - tag: mytag\\n\\n    name\\n        The name of the docker image.\\n\\n    tag\\n        Tag name for the image. Required when using ``build``, ``load``, or\\n        ``sls`` to create the image, but optional if pulling from a repository.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    build\\n        Path to directory on the Minion containing a Dockerfile\\n\\n        .. code-block:: yaml\\n\\n            myuser/myimage:\\n              docker_image.present:\\n                - build: /home/myuser/docker/myimage\\n                - tag: mytag\\n\\n            myuser/myimage:\\n              docker_image.present:\\n                - build: /home/myuser/docker/myimage\\n                - tag: mytag\\n                - dockerfile: Dockerfile.alternative\\n\\n        The image will be built using :py:func:`docker.build\\n        <salt.modules.dockermod.build>` and the specified image name and tag\\n        will be applied to it.\\n\\n        .. versionadded:: 2016.11.0\\n        .. versionchanged:: 2018.3.0\\n            The ``tag`` must be manually specified using the ``tag`` argument.\\n\\n    load\\n        Loads a tar archive created with :py:func:`docker.save\\n        <salt.modules.dockermod.save>` (or the ``docker save`` Docker CLI\\n        command), and assigns it the specified repo and tag.\\n\\n        .. code-block:: yaml\\n\\n            myuser/myimage:\\n              docker_image.present:\\n                - load: salt://path/to/image.tar\\n                - tag: mytag\\n\\n        .. versionchanged:: 2018.3.0\\n            The ``tag`` must be manually specified using the ``tag`` argument.\\n\\n    force\\n        Set this parameter to ``True`` to force Salt to pull/build/load the\\n        image even if it is already present.\\n\\n    insecure_registry\\n        If ``True``, the Docker client will permit the use of insecure\\n        (non-HTTPS) registries.\\n\\n    client_timeout\\n        Timeout in seconds for the Docker client. This is not a timeout for\\n        the state, but for receiving a response from the API.\\n\\n    dockerfile\\n        Allows for an alternative Dockerfile to be specified.  Path to alternative\\n        Dockefile is relative to the build path for the Docker container.\\n\\n        .. versionadded:: 2016.11.0\\n\\n    sls\\n        Allow for building of image with :py:func:`docker.sls_build\\n        <salt.modules.dockermod.sls_build>` by specifying the SLS files with\\n        which to build. This can be a list or comma-separated string.\\n\\n        .. code-block:: yaml\\n\\n            myuser/myimage:\\n              docker_image.present:\\n                - tag: latest\\n                - sls:\\n                    - webapp1\\n                    - webapp2\\n                - base: centos\\n                - saltenv: base\\n\\n        .. versionadded:: 2017.7.0\\n        .. versionchanged:: 2018.3.0\\n            The ``tag`` must be manually specified using the ``tag`` argument.\\n\\n    base\\n        Base image with which to start :py:func:`docker.sls_build\\n        <salt.modules.dockermod.sls_build>`\\n\\n        .. versionadded:: 2017.7.0\\n\\n    saltenv\\n        Specify the environment from which to retrieve the SLS indicated by the\\n        `mods` parameter.\\n\\n        .. versionadded:: 2017.7.0\\n        .. versionchanged:: 2018.3.0\\n            Now uses the effective saltenv if not explicitly passed. In earlier\\n            versions, ``base`` was assumed as a default.\\n\\n    pillarenv\\n        Specify a Pillar environment to be used when applying states. This\\n        can also be set in the minion config file using the\\n        :conf_minion:`pillarenv` option. When neither the\\n        :conf_minion:`pillarenv` minion config option nor this CLI argument is\\n        used, all Pillar environments will be merged together.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    pillar\\n        Custom Pillar values, passed as a dictionary of key-value pairs\\n\\n        .. note::\\n            Values passed this way will override Pillar values set via\\n            ``pillar_roots`` or an external Pillar source.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    kwargs\\n        Additional keyword arguments to pass to\\n        :py:func:`docker.build <salt.modules.dockermod.build>`\\n    '\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n    if not isinstance(name, str):\n        name = str(name)\n    num_build_args = len([x for x in (build, load, sls) if x is not None])\n    if num_build_args > 1:\n        ret['comment'] = \"Only one of 'build', 'load', or 'sls' is permitted.\"\n        return ret\n    elif num_build_args == 1:\n        if not tag:\n            ret['comment'] = \"The 'tag' argument is required if any one of 'build', 'load', or 'sls' is used.\"\n            return ret\n        if not isinstance(tag, str):\n            tag = str(tag)\n        full_image = ':'.join((name, tag))\n    else:\n        if tag:\n            name = f'{name}:{tag}'\n        full_image = name\n    try:\n        image_info = __salt__['docker.inspect_image'](full_image)\n    except CommandExecutionError as exc:\n        msg = exc.__str__()\n        if '404' in msg:\n            image_info = None\n        else:\n            ret['comment'] = msg\n            return ret\n    if image_info is not None:\n        if not force:\n            ret['result'] = True\n            ret['comment'] = f'Image {full_image} already present'\n            return ret\n    if build or sls:\n        action = 'built'\n    elif load:\n        action = 'loaded'\n    else:\n        action = 'pulled'\n    if __opts__['test']:\n        ret['result'] = None\n        if image_info is not None and force or image_info is None:\n            ret['comment'] = f'Image {full_image} will be {action}'\n            return ret\n    if build:\n        argspec = salt.utils.args.get_function_argspec(__salt__['docker.build'])\n        build_args = dict(list(zip(argspec.args, argspec.defaults)))\n        for k in build_args:\n            if k in kwargs.get('kwargs', {}):\n                build_args[k] = kwargs.get('kwargs', {}).get(k)\n        try:\n            build_args['path'] = build\n            build_args['repository'] = name\n            build_args['tag'] = tag\n            build_args['dockerfile'] = dockerfile\n            image_update = __salt__['docker.build'](**build_args)\n        except Exception as exc:\n            ret['comment'] = 'Encountered error building {} as {}: {}'.format(build, full_image, exc)\n            return ret\n        if image_info is None or image_update['Id'] != image_info['Id'][:12]:\n            ret['changes'] = image_update\n    elif sls:\n        _locals = locals()\n        sls_build_kwargs = {k: _locals[k] for k in ('saltenv', 'pillarenv', 'pillar') if _locals[k] is not None}\n        try:\n            image_update = __salt__['docker.sls_build'](repository=name, tag=tag, base=base, mods=sls, **sls_build_kwargs)\n        except Exception as exc:\n            ret['comment'] = 'Encountered error using SLS {} for building {}: {}'.format(sls, full_image, exc)\n            return ret\n        if image_info is None or image_update['Id'] != image_info['Id'][:12]:\n            ret['changes'] = image_update\n    elif load:\n        try:\n            image_update = __salt__['docker.load'](path=load, repository=name, tag=tag)\n        except Exception as exc:\n            ret['comment'] = 'Encountered error loading {} as {}: {}'.format(load, full_image, exc)\n            return ret\n        if image_info is None or image_update.get('Layers', []):\n            ret['changes'] = image_update\n    else:\n        try:\n            image_update = __salt__['docker.pull'](name, insecure_registry=insecure_registry, client_timeout=client_timeout)\n        except Exception as exc:\n            ret['comment'] = f'Encountered error pulling {full_image}: {exc}'\n            return ret\n        if image_info is not None and image_info['Id'][:12] == image_update.get('Layers', {}).get('Already_Pulled', [None])[0]:\n            pass\n        elif image_info is None or image_update.get('Layers', {}).get('Pulled'):\n            ret['changes'] = image_update\n    error = False\n    try:\n        __salt__['docker.inspect_image'](full_image)\n    except CommandExecutionError as exc:\n        msg = exc.__str__()\n        if '404' not in msg:\n            error = \"Failed to inspect image '{}' after it was {}: {}\".format(full_image, action, msg)\n    if error:\n        ret['comment'] = error\n    else:\n        ret['result'] = True\n        if not ret['changes']:\n            ret['comment'] = \"Image '{}' was {}, but there were no changes\".format(name, action)\n        else:\n            ret['comment'] = f\"Image '{full_image}' was {action}\"\n    return ret",
            "def present(name, tag=None, build=None, load=None, force=False, insecure_registry=False, client_timeout=salt.utils.dockermod.CLIENT_TIMEOUT, dockerfile=None, sls=None, base='opensuse/python', saltenv='base', pillarenv=None, pillar=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    .. versionchanged:: 2018.3.0\\n        The ``tag`` argument has been added. It is now required unless pulling\\n        from a registry.\\n\\n    Ensure that an image is present. The image can either be pulled from a\\n    Docker registry, built from a Dockerfile, loaded from a saved image, or\\n    built by running SLS files against a base image.\\n\\n    If none of the ``build``, ``load``, or ``sls`` arguments are used, then Salt\\n    will pull from the :ref:`configured registries <docker-authentication>`. If\\n    the specified image already exists, it will not be pulled unless ``force``\\n    is set to ``True``. Here is an example of a state that will pull an image\\n    from the Docker Hub:\\n\\n    .. code-block:: yaml\\n\\n        myuser/myimage:\\n          docker_image.present:\\n            - tag: mytag\\n\\n    name\\n        The name of the docker image.\\n\\n    tag\\n        Tag name for the image. Required when using ``build``, ``load``, or\\n        ``sls`` to create the image, but optional if pulling from a repository.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    build\\n        Path to directory on the Minion containing a Dockerfile\\n\\n        .. code-block:: yaml\\n\\n            myuser/myimage:\\n              docker_image.present:\\n                - build: /home/myuser/docker/myimage\\n                - tag: mytag\\n\\n            myuser/myimage:\\n              docker_image.present:\\n                - build: /home/myuser/docker/myimage\\n                - tag: mytag\\n                - dockerfile: Dockerfile.alternative\\n\\n        The image will be built using :py:func:`docker.build\\n        <salt.modules.dockermod.build>` and the specified image name and tag\\n        will be applied to it.\\n\\n        .. versionadded:: 2016.11.0\\n        .. versionchanged:: 2018.3.0\\n            The ``tag`` must be manually specified using the ``tag`` argument.\\n\\n    load\\n        Loads a tar archive created with :py:func:`docker.save\\n        <salt.modules.dockermod.save>` (or the ``docker save`` Docker CLI\\n        command), and assigns it the specified repo and tag.\\n\\n        .. code-block:: yaml\\n\\n            myuser/myimage:\\n              docker_image.present:\\n                - load: salt://path/to/image.tar\\n                - tag: mytag\\n\\n        .. versionchanged:: 2018.3.0\\n            The ``tag`` must be manually specified using the ``tag`` argument.\\n\\n    force\\n        Set this parameter to ``True`` to force Salt to pull/build/load the\\n        image even if it is already present.\\n\\n    insecure_registry\\n        If ``True``, the Docker client will permit the use of insecure\\n        (non-HTTPS) registries.\\n\\n    client_timeout\\n        Timeout in seconds for the Docker client. This is not a timeout for\\n        the state, but for receiving a response from the API.\\n\\n    dockerfile\\n        Allows for an alternative Dockerfile to be specified.  Path to alternative\\n        Dockefile is relative to the build path for the Docker container.\\n\\n        .. versionadded:: 2016.11.0\\n\\n    sls\\n        Allow for building of image with :py:func:`docker.sls_build\\n        <salt.modules.dockermod.sls_build>` by specifying the SLS files with\\n        which to build. This can be a list or comma-separated string.\\n\\n        .. code-block:: yaml\\n\\n            myuser/myimage:\\n              docker_image.present:\\n                - tag: latest\\n                - sls:\\n                    - webapp1\\n                    - webapp2\\n                - base: centos\\n                - saltenv: base\\n\\n        .. versionadded:: 2017.7.0\\n        .. versionchanged:: 2018.3.0\\n            The ``tag`` must be manually specified using the ``tag`` argument.\\n\\n    base\\n        Base image with which to start :py:func:`docker.sls_build\\n        <salt.modules.dockermod.sls_build>`\\n\\n        .. versionadded:: 2017.7.0\\n\\n    saltenv\\n        Specify the environment from which to retrieve the SLS indicated by the\\n        `mods` parameter.\\n\\n        .. versionadded:: 2017.7.0\\n        .. versionchanged:: 2018.3.0\\n            Now uses the effective saltenv if not explicitly passed. In earlier\\n            versions, ``base`` was assumed as a default.\\n\\n    pillarenv\\n        Specify a Pillar environment to be used when applying states. This\\n        can also be set in the minion config file using the\\n        :conf_minion:`pillarenv` option. When neither the\\n        :conf_minion:`pillarenv` minion config option nor this CLI argument is\\n        used, all Pillar environments will be merged together.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    pillar\\n        Custom Pillar values, passed as a dictionary of key-value pairs\\n\\n        .. note::\\n            Values passed this way will override Pillar values set via\\n            ``pillar_roots`` or an external Pillar source.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    kwargs\\n        Additional keyword arguments to pass to\\n        :py:func:`docker.build <salt.modules.dockermod.build>`\\n    '\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n    if not isinstance(name, str):\n        name = str(name)\n    num_build_args = len([x for x in (build, load, sls) if x is not None])\n    if num_build_args > 1:\n        ret['comment'] = \"Only one of 'build', 'load', or 'sls' is permitted.\"\n        return ret\n    elif num_build_args == 1:\n        if not tag:\n            ret['comment'] = \"The 'tag' argument is required if any one of 'build', 'load', or 'sls' is used.\"\n            return ret\n        if not isinstance(tag, str):\n            tag = str(tag)\n        full_image = ':'.join((name, tag))\n    else:\n        if tag:\n            name = f'{name}:{tag}'\n        full_image = name\n    try:\n        image_info = __salt__['docker.inspect_image'](full_image)\n    except CommandExecutionError as exc:\n        msg = exc.__str__()\n        if '404' in msg:\n            image_info = None\n        else:\n            ret['comment'] = msg\n            return ret\n    if image_info is not None:\n        if not force:\n            ret['result'] = True\n            ret['comment'] = f'Image {full_image} already present'\n            return ret\n    if build or sls:\n        action = 'built'\n    elif load:\n        action = 'loaded'\n    else:\n        action = 'pulled'\n    if __opts__['test']:\n        ret['result'] = None\n        if image_info is not None and force or image_info is None:\n            ret['comment'] = f'Image {full_image} will be {action}'\n            return ret\n    if build:\n        argspec = salt.utils.args.get_function_argspec(__salt__['docker.build'])\n        build_args = dict(list(zip(argspec.args, argspec.defaults)))\n        for k in build_args:\n            if k in kwargs.get('kwargs', {}):\n                build_args[k] = kwargs.get('kwargs', {}).get(k)\n        try:\n            build_args['path'] = build\n            build_args['repository'] = name\n            build_args['tag'] = tag\n            build_args['dockerfile'] = dockerfile\n            image_update = __salt__['docker.build'](**build_args)\n        except Exception as exc:\n            ret['comment'] = 'Encountered error building {} as {}: {}'.format(build, full_image, exc)\n            return ret\n        if image_info is None or image_update['Id'] != image_info['Id'][:12]:\n            ret['changes'] = image_update\n    elif sls:\n        _locals = locals()\n        sls_build_kwargs = {k: _locals[k] for k in ('saltenv', 'pillarenv', 'pillar') if _locals[k] is not None}\n        try:\n            image_update = __salt__['docker.sls_build'](repository=name, tag=tag, base=base, mods=sls, **sls_build_kwargs)\n        except Exception as exc:\n            ret['comment'] = 'Encountered error using SLS {} for building {}: {}'.format(sls, full_image, exc)\n            return ret\n        if image_info is None or image_update['Id'] != image_info['Id'][:12]:\n            ret['changes'] = image_update\n    elif load:\n        try:\n            image_update = __salt__['docker.load'](path=load, repository=name, tag=tag)\n        except Exception as exc:\n            ret['comment'] = 'Encountered error loading {} as {}: {}'.format(load, full_image, exc)\n            return ret\n        if image_info is None or image_update.get('Layers', []):\n            ret['changes'] = image_update\n    else:\n        try:\n            image_update = __salt__['docker.pull'](name, insecure_registry=insecure_registry, client_timeout=client_timeout)\n        except Exception as exc:\n            ret['comment'] = f'Encountered error pulling {full_image}: {exc}'\n            return ret\n        if image_info is not None and image_info['Id'][:12] == image_update.get('Layers', {}).get('Already_Pulled', [None])[0]:\n            pass\n        elif image_info is None or image_update.get('Layers', {}).get('Pulled'):\n            ret['changes'] = image_update\n    error = False\n    try:\n        __salt__['docker.inspect_image'](full_image)\n    except CommandExecutionError as exc:\n        msg = exc.__str__()\n        if '404' not in msg:\n            error = \"Failed to inspect image '{}' after it was {}: {}\".format(full_image, action, msg)\n    if error:\n        ret['comment'] = error\n    else:\n        ret['result'] = True\n        if not ret['changes']:\n            ret['comment'] = \"Image '{}' was {}, but there were no changes\".format(name, action)\n        else:\n            ret['comment'] = f\"Image '{full_image}' was {action}\"\n    return ret",
            "def present(name, tag=None, build=None, load=None, force=False, insecure_registry=False, client_timeout=salt.utils.dockermod.CLIENT_TIMEOUT, dockerfile=None, sls=None, base='opensuse/python', saltenv='base', pillarenv=None, pillar=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    .. versionchanged:: 2018.3.0\\n        The ``tag`` argument has been added. It is now required unless pulling\\n        from a registry.\\n\\n    Ensure that an image is present. The image can either be pulled from a\\n    Docker registry, built from a Dockerfile, loaded from a saved image, or\\n    built by running SLS files against a base image.\\n\\n    If none of the ``build``, ``load``, or ``sls`` arguments are used, then Salt\\n    will pull from the :ref:`configured registries <docker-authentication>`. If\\n    the specified image already exists, it will not be pulled unless ``force``\\n    is set to ``True``. Here is an example of a state that will pull an image\\n    from the Docker Hub:\\n\\n    .. code-block:: yaml\\n\\n        myuser/myimage:\\n          docker_image.present:\\n            - tag: mytag\\n\\n    name\\n        The name of the docker image.\\n\\n    tag\\n        Tag name for the image. Required when using ``build``, ``load``, or\\n        ``sls`` to create the image, but optional if pulling from a repository.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    build\\n        Path to directory on the Minion containing a Dockerfile\\n\\n        .. code-block:: yaml\\n\\n            myuser/myimage:\\n              docker_image.present:\\n                - build: /home/myuser/docker/myimage\\n                - tag: mytag\\n\\n            myuser/myimage:\\n              docker_image.present:\\n                - build: /home/myuser/docker/myimage\\n                - tag: mytag\\n                - dockerfile: Dockerfile.alternative\\n\\n        The image will be built using :py:func:`docker.build\\n        <salt.modules.dockermod.build>` and the specified image name and tag\\n        will be applied to it.\\n\\n        .. versionadded:: 2016.11.0\\n        .. versionchanged:: 2018.3.0\\n            The ``tag`` must be manually specified using the ``tag`` argument.\\n\\n    load\\n        Loads a tar archive created with :py:func:`docker.save\\n        <salt.modules.dockermod.save>` (or the ``docker save`` Docker CLI\\n        command), and assigns it the specified repo and tag.\\n\\n        .. code-block:: yaml\\n\\n            myuser/myimage:\\n              docker_image.present:\\n                - load: salt://path/to/image.tar\\n                - tag: mytag\\n\\n        .. versionchanged:: 2018.3.0\\n            The ``tag`` must be manually specified using the ``tag`` argument.\\n\\n    force\\n        Set this parameter to ``True`` to force Salt to pull/build/load the\\n        image even if it is already present.\\n\\n    insecure_registry\\n        If ``True``, the Docker client will permit the use of insecure\\n        (non-HTTPS) registries.\\n\\n    client_timeout\\n        Timeout in seconds for the Docker client. This is not a timeout for\\n        the state, but for receiving a response from the API.\\n\\n    dockerfile\\n        Allows for an alternative Dockerfile to be specified.  Path to alternative\\n        Dockefile is relative to the build path for the Docker container.\\n\\n        .. versionadded:: 2016.11.0\\n\\n    sls\\n        Allow for building of image with :py:func:`docker.sls_build\\n        <salt.modules.dockermod.sls_build>` by specifying the SLS files with\\n        which to build. This can be a list or comma-separated string.\\n\\n        .. code-block:: yaml\\n\\n            myuser/myimage:\\n              docker_image.present:\\n                - tag: latest\\n                - sls:\\n                    - webapp1\\n                    - webapp2\\n                - base: centos\\n                - saltenv: base\\n\\n        .. versionadded:: 2017.7.0\\n        .. versionchanged:: 2018.3.0\\n            The ``tag`` must be manually specified using the ``tag`` argument.\\n\\n    base\\n        Base image with which to start :py:func:`docker.sls_build\\n        <salt.modules.dockermod.sls_build>`\\n\\n        .. versionadded:: 2017.7.0\\n\\n    saltenv\\n        Specify the environment from which to retrieve the SLS indicated by the\\n        `mods` parameter.\\n\\n        .. versionadded:: 2017.7.0\\n        .. versionchanged:: 2018.3.0\\n            Now uses the effective saltenv if not explicitly passed. In earlier\\n            versions, ``base`` was assumed as a default.\\n\\n    pillarenv\\n        Specify a Pillar environment to be used when applying states. This\\n        can also be set in the minion config file using the\\n        :conf_minion:`pillarenv` option. When neither the\\n        :conf_minion:`pillarenv` minion config option nor this CLI argument is\\n        used, all Pillar environments will be merged together.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    pillar\\n        Custom Pillar values, passed as a dictionary of key-value pairs\\n\\n        .. note::\\n            Values passed this way will override Pillar values set via\\n            ``pillar_roots`` or an external Pillar source.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    kwargs\\n        Additional keyword arguments to pass to\\n        :py:func:`docker.build <salt.modules.dockermod.build>`\\n    '\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n    if not isinstance(name, str):\n        name = str(name)\n    num_build_args = len([x for x in (build, load, sls) if x is not None])\n    if num_build_args > 1:\n        ret['comment'] = \"Only one of 'build', 'load', or 'sls' is permitted.\"\n        return ret\n    elif num_build_args == 1:\n        if not tag:\n            ret['comment'] = \"The 'tag' argument is required if any one of 'build', 'load', or 'sls' is used.\"\n            return ret\n        if not isinstance(tag, str):\n            tag = str(tag)\n        full_image = ':'.join((name, tag))\n    else:\n        if tag:\n            name = f'{name}:{tag}'\n        full_image = name\n    try:\n        image_info = __salt__['docker.inspect_image'](full_image)\n    except CommandExecutionError as exc:\n        msg = exc.__str__()\n        if '404' in msg:\n            image_info = None\n        else:\n            ret['comment'] = msg\n            return ret\n    if image_info is not None:\n        if not force:\n            ret['result'] = True\n            ret['comment'] = f'Image {full_image} already present'\n            return ret\n    if build or sls:\n        action = 'built'\n    elif load:\n        action = 'loaded'\n    else:\n        action = 'pulled'\n    if __opts__['test']:\n        ret['result'] = None\n        if image_info is not None and force or image_info is None:\n            ret['comment'] = f'Image {full_image} will be {action}'\n            return ret\n    if build:\n        argspec = salt.utils.args.get_function_argspec(__salt__['docker.build'])\n        build_args = dict(list(zip(argspec.args, argspec.defaults)))\n        for k in build_args:\n            if k in kwargs.get('kwargs', {}):\n                build_args[k] = kwargs.get('kwargs', {}).get(k)\n        try:\n            build_args['path'] = build\n            build_args['repository'] = name\n            build_args['tag'] = tag\n            build_args['dockerfile'] = dockerfile\n            image_update = __salt__['docker.build'](**build_args)\n        except Exception as exc:\n            ret['comment'] = 'Encountered error building {} as {}: {}'.format(build, full_image, exc)\n            return ret\n        if image_info is None or image_update['Id'] != image_info['Id'][:12]:\n            ret['changes'] = image_update\n    elif sls:\n        _locals = locals()\n        sls_build_kwargs = {k: _locals[k] for k in ('saltenv', 'pillarenv', 'pillar') if _locals[k] is not None}\n        try:\n            image_update = __salt__['docker.sls_build'](repository=name, tag=tag, base=base, mods=sls, **sls_build_kwargs)\n        except Exception as exc:\n            ret['comment'] = 'Encountered error using SLS {} for building {}: {}'.format(sls, full_image, exc)\n            return ret\n        if image_info is None or image_update['Id'] != image_info['Id'][:12]:\n            ret['changes'] = image_update\n    elif load:\n        try:\n            image_update = __salt__['docker.load'](path=load, repository=name, tag=tag)\n        except Exception as exc:\n            ret['comment'] = 'Encountered error loading {} as {}: {}'.format(load, full_image, exc)\n            return ret\n        if image_info is None or image_update.get('Layers', []):\n            ret['changes'] = image_update\n    else:\n        try:\n            image_update = __salt__['docker.pull'](name, insecure_registry=insecure_registry, client_timeout=client_timeout)\n        except Exception as exc:\n            ret['comment'] = f'Encountered error pulling {full_image}: {exc}'\n            return ret\n        if image_info is not None and image_info['Id'][:12] == image_update.get('Layers', {}).get('Already_Pulled', [None])[0]:\n            pass\n        elif image_info is None or image_update.get('Layers', {}).get('Pulled'):\n            ret['changes'] = image_update\n    error = False\n    try:\n        __salt__['docker.inspect_image'](full_image)\n    except CommandExecutionError as exc:\n        msg = exc.__str__()\n        if '404' not in msg:\n            error = \"Failed to inspect image '{}' after it was {}: {}\".format(full_image, action, msg)\n    if error:\n        ret['comment'] = error\n    else:\n        ret['result'] = True\n        if not ret['changes']:\n            ret['comment'] = \"Image '{}' was {}, but there were no changes\".format(name, action)\n        else:\n            ret['comment'] = f\"Image '{full_image}' was {action}\"\n    return ret",
            "def present(name, tag=None, build=None, load=None, force=False, insecure_registry=False, client_timeout=salt.utils.dockermod.CLIENT_TIMEOUT, dockerfile=None, sls=None, base='opensuse/python', saltenv='base', pillarenv=None, pillar=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    .. versionchanged:: 2018.3.0\\n        The ``tag`` argument has been added. It is now required unless pulling\\n        from a registry.\\n\\n    Ensure that an image is present. The image can either be pulled from a\\n    Docker registry, built from a Dockerfile, loaded from a saved image, or\\n    built by running SLS files against a base image.\\n\\n    If none of the ``build``, ``load``, or ``sls`` arguments are used, then Salt\\n    will pull from the :ref:`configured registries <docker-authentication>`. If\\n    the specified image already exists, it will not be pulled unless ``force``\\n    is set to ``True``. Here is an example of a state that will pull an image\\n    from the Docker Hub:\\n\\n    .. code-block:: yaml\\n\\n        myuser/myimage:\\n          docker_image.present:\\n            - tag: mytag\\n\\n    name\\n        The name of the docker image.\\n\\n    tag\\n        Tag name for the image. Required when using ``build``, ``load``, or\\n        ``sls`` to create the image, but optional if pulling from a repository.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    build\\n        Path to directory on the Minion containing a Dockerfile\\n\\n        .. code-block:: yaml\\n\\n            myuser/myimage:\\n              docker_image.present:\\n                - build: /home/myuser/docker/myimage\\n                - tag: mytag\\n\\n            myuser/myimage:\\n              docker_image.present:\\n                - build: /home/myuser/docker/myimage\\n                - tag: mytag\\n                - dockerfile: Dockerfile.alternative\\n\\n        The image will be built using :py:func:`docker.build\\n        <salt.modules.dockermod.build>` and the specified image name and tag\\n        will be applied to it.\\n\\n        .. versionadded:: 2016.11.0\\n        .. versionchanged:: 2018.3.0\\n            The ``tag`` must be manually specified using the ``tag`` argument.\\n\\n    load\\n        Loads a tar archive created with :py:func:`docker.save\\n        <salt.modules.dockermod.save>` (or the ``docker save`` Docker CLI\\n        command), and assigns it the specified repo and tag.\\n\\n        .. code-block:: yaml\\n\\n            myuser/myimage:\\n              docker_image.present:\\n                - load: salt://path/to/image.tar\\n                - tag: mytag\\n\\n        .. versionchanged:: 2018.3.0\\n            The ``tag`` must be manually specified using the ``tag`` argument.\\n\\n    force\\n        Set this parameter to ``True`` to force Salt to pull/build/load the\\n        image even if it is already present.\\n\\n    insecure_registry\\n        If ``True``, the Docker client will permit the use of insecure\\n        (non-HTTPS) registries.\\n\\n    client_timeout\\n        Timeout in seconds for the Docker client. This is not a timeout for\\n        the state, but for receiving a response from the API.\\n\\n    dockerfile\\n        Allows for an alternative Dockerfile to be specified.  Path to alternative\\n        Dockefile is relative to the build path for the Docker container.\\n\\n        .. versionadded:: 2016.11.0\\n\\n    sls\\n        Allow for building of image with :py:func:`docker.sls_build\\n        <salt.modules.dockermod.sls_build>` by specifying the SLS files with\\n        which to build. This can be a list or comma-separated string.\\n\\n        .. code-block:: yaml\\n\\n            myuser/myimage:\\n              docker_image.present:\\n                - tag: latest\\n                - sls:\\n                    - webapp1\\n                    - webapp2\\n                - base: centos\\n                - saltenv: base\\n\\n        .. versionadded:: 2017.7.0\\n        .. versionchanged:: 2018.3.0\\n            The ``tag`` must be manually specified using the ``tag`` argument.\\n\\n    base\\n        Base image with which to start :py:func:`docker.sls_build\\n        <salt.modules.dockermod.sls_build>`\\n\\n        .. versionadded:: 2017.7.0\\n\\n    saltenv\\n        Specify the environment from which to retrieve the SLS indicated by the\\n        `mods` parameter.\\n\\n        .. versionadded:: 2017.7.0\\n        .. versionchanged:: 2018.3.0\\n            Now uses the effective saltenv if not explicitly passed. In earlier\\n            versions, ``base`` was assumed as a default.\\n\\n    pillarenv\\n        Specify a Pillar environment to be used when applying states. This\\n        can also be set in the minion config file using the\\n        :conf_minion:`pillarenv` option. When neither the\\n        :conf_minion:`pillarenv` minion config option nor this CLI argument is\\n        used, all Pillar environments will be merged together.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    pillar\\n        Custom Pillar values, passed as a dictionary of key-value pairs\\n\\n        .. note::\\n            Values passed this way will override Pillar values set via\\n            ``pillar_roots`` or an external Pillar source.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    kwargs\\n        Additional keyword arguments to pass to\\n        :py:func:`docker.build <salt.modules.dockermod.build>`\\n    '\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n    if not isinstance(name, str):\n        name = str(name)\n    num_build_args = len([x for x in (build, load, sls) if x is not None])\n    if num_build_args > 1:\n        ret['comment'] = \"Only one of 'build', 'load', or 'sls' is permitted.\"\n        return ret\n    elif num_build_args == 1:\n        if not tag:\n            ret['comment'] = \"The 'tag' argument is required if any one of 'build', 'load', or 'sls' is used.\"\n            return ret\n        if not isinstance(tag, str):\n            tag = str(tag)\n        full_image = ':'.join((name, tag))\n    else:\n        if tag:\n            name = f'{name}:{tag}'\n        full_image = name\n    try:\n        image_info = __salt__['docker.inspect_image'](full_image)\n    except CommandExecutionError as exc:\n        msg = exc.__str__()\n        if '404' in msg:\n            image_info = None\n        else:\n            ret['comment'] = msg\n            return ret\n    if image_info is not None:\n        if not force:\n            ret['result'] = True\n            ret['comment'] = f'Image {full_image} already present'\n            return ret\n    if build or sls:\n        action = 'built'\n    elif load:\n        action = 'loaded'\n    else:\n        action = 'pulled'\n    if __opts__['test']:\n        ret['result'] = None\n        if image_info is not None and force or image_info is None:\n            ret['comment'] = f'Image {full_image} will be {action}'\n            return ret\n    if build:\n        argspec = salt.utils.args.get_function_argspec(__salt__['docker.build'])\n        build_args = dict(list(zip(argspec.args, argspec.defaults)))\n        for k in build_args:\n            if k in kwargs.get('kwargs', {}):\n                build_args[k] = kwargs.get('kwargs', {}).get(k)\n        try:\n            build_args['path'] = build\n            build_args['repository'] = name\n            build_args['tag'] = tag\n            build_args['dockerfile'] = dockerfile\n            image_update = __salt__['docker.build'](**build_args)\n        except Exception as exc:\n            ret['comment'] = 'Encountered error building {} as {}: {}'.format(build, full_image, exc)\n            return ret\n        if image_info is None or image_update['Id'] != image_info['Id'][:12]:\n            ret['changes'] = image_update\n    elif sls:\n        _locals = locals()\n        sls_build_kwargs = {k: _locals[k] for k in ('saltenv', 'pillarenv', 'pillar') if _locals[k] is not None}\n        try:\n            image_update = __salt__['docker.sls_build'](repository=name, tag=tag, base=base, mods=sls, **sls_build_kwargs)\n        except Exception as exc:\n            ret['comment'] = 'Encountered error using SLS {} for building {}: {}'.format(sls, full_image, exc)\n            return ret\n        if image_info is None or image_update['Id'] != image_info['Id'][:12]:\n            ret['changes'] = image_update\n    elif load:\n        try:\n            image_update = __salt__['docker.load'](path=load, repository=name, tag=tag)\n        except Exception as exc:\n            ret['comment'] = 'Encountered error loading {} as {}: {}'.format(load, full_image, exc)\n            return ret\n        if image_info is None or image_update.get('Layers', []):\n            ret['changes'] = image_update\n    else:\n        try:\n            image_update = __salt__['docker.pull'](name, insecure_registry=insecure_registry, client_timeout=client_timeout)\n        except Exception as exc:\n            ret['comment'] = f'Encountered error pulling {full_image}: {exc}'\n            return ret\n        if image_info is not None and image_info['Id'][:12] == image_update.get('Layers', {}).get('Already_Pulled', [None])[0]:\n            pass\n        elif image_info is None or image_update.get('Layers', {}).get('Pulled'):\n            ret['changes'] = image_update\n    error = False\n    try:\n        __salt__['docker.inspect_image'](full_image)\n    except CommandExecutionError as exc:\n        msg = exc.__str__()\n        if '404' not in msg:\n            error = \"Failed to inspect image '{}' after it was {}: {}\".format(full_image, action, msg)\n    if error:\n        ret['comment'] = error\n    else:\n        ret['result'] = True\n        if not ret['changes']:\n            ret['comment'] = \"Image '{}' was {}, but there were no changes\".format(name, action)\n        else:\n            ret['comment'] = f\"Image '{full_image}' was {action}\"\n    return ret"
        ]
    },
    {
        "func_name": "absent",
        "original": "def absent(name=None, images=None, force=False):\n    \"\"\"\n    Ensure that an image is absent from the Minion. Image names can be\n    specified either using ``repo:tag`` notation, or just the repo name (in\n    which case a tag of ``latest`` is assumed).\n\n    name\n        The name of the docker image.\n\n    images\n        Run this state on more than one image at a time. The following two\n        examples accomplish the same thing:\n\n        .. code-block:: yaml\n\n            remove_images:\n              docker_image.absent:\n                - names:\n                  - busybox\n                  - centos:6\n                  - nginx\n\n        .. code-block:: yaml\n\n            remove_images:\n              docker_image.absent:\n                - images:\n                  - busybox\n                  - centos:6\n                  - nginx\n\n        However, the second example will be a bit quicker since Salt will do\n        all the deletions in a single run, rather than executing the state\n        separately on each image (as it would in the first example).\n\n    force\n        Salt will fail to remove any images currently in use by a container.\n        Set this option to true to remove the image even if it is already\n        present.\n\n        .. note::\n\n            This option can also be overridden by Pillar data. If the Minion\n            has a pillar variable named ``docker.running.force`` which is\n            set to ``True``, it will turn on this option. This pillar variable\n            can even be set at runtime. For example:\n\n            .. code-block:: bash\n\n                salt myminion state.sls docker_stuff pillar=\"{docker.force: True}\"\n\n            If this pillar variable is present and set to ``False``, then it\n            will turn off this option.\n\n            For more granular control, setting a pillar variable named\n            ``docker.force.image_name`` will affect only the named image.\n    \"\"\"\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n    if not name and (not images):\n        ret['comment'] = \"One of 'name' and 'images' must be provided\"\n        return ret\n    elif images is not None:\n        targets = images\n    elif name:\n        targets = [name]\n    to_delete = []\n    for target in targets:\n        resolved_tag = __salt__['docker.resolve_tag'](target)\n        if resolved_tag is not False:\n            to_delete.append(resolved_tag)\n    if not to_delete:\n        ret['result'] = True\n        if len(targets) == 1:\n            ret['comment'] = f'Image {name} is not present'\n        else:\n            ret['comment'] = 'All specified images are not present'\n        return ret\n    if __opts__['test']:\n        ret['result'] = None\n        if len(to_delete) == 1:\n            ret['comment'] = f'Image {to_delete[0]} will be removed'\n        else:\n            ret['comment'] = 'The following images will be removed: {}'.format(', '.join(to_delete))\n        return ret\n    result = __salt__['docker.rmi'](*to_delete, force=force)\n    post_tags = __salt__['docker.list_tags']()\n    failed = [x for x in to_delete if x in post_tags]\n    if failed:\n        if [x for x in to_delete if x not in post_tags]:\n            ret['changes'] = result\n            ret['comment'] = 'The following image(s) failed to be removed: {}'.format(', '.join(failed))\n        else:\n            ret['comment'] = 'None of the specified images were removed'\n            if 'Errors' in result:\n                ret['comment'] += '. The following errors were encountered: {}'.format('; '.join(result['Errors']))\n    else:\n        ret['changes'] = result\n        if len(to_delete) == 1:\n            ret['comment'] = f'Image {to_delete[0]} was removed'\n        else:\n            ret['comment'] = 'The following images were removed: {}'.format(', '.join(to_delete))\n        ret['result'] = True\n    return ret",
        "mutated": [
            "def absent(name=None, images=None, force=False):\n    if False:\n        i = 10\n    '\\n    Ensure that an image is absent from the Minion. Image names can be\\n    specified either using ``repo:tag`` notation, or just the repo name (in\\n    which case a tag of ``latest`` is assumed).\\n\\n    name\\n        The name of the docker image.\\n\\n    images\\n        Run this state on more than one image at a time. The following two\\n        examples accomplish the same thing:\\n\\n        .. code-block:: yaml\\n\\n            remove_images:\\n              docker_image.absent:\\n                - names:\\n                  - busybox\\n                  - centos:6\\n                  - nginx\\n\\n        .. code-block:: yaml\\n\\n            remove_images:\\n              docker_image.absent:\\n                - images:\\n                  - busybox\\n                  - centos:6\\n                  - nginx\\n\\n        However, the second example will be a bit quicker since Salt will do\\n        all the deletions in a single run, rather than executing the state\\n        separately on each image (as it would in the first example).\\n\\n    force\\n        Salt will fail to remove any images currently in use by a container.\\n        Set this option to true to remove the image even if it is already\\n        present.\\n\\n        .. note::\\n\\n            This option can also be overridden by Pillar data. If the Minion\\n            has a pillar variable named ``docker.running.force`` which is\\n            set to ``True``, it will turn on this option. This pillar variable\\n            can even be set at runtime. For example:\\n\\n            .. code-block:: bash\\n\\n                salt myminion state.sls docker_stuff pillar=\"{docker.force: True}\"\\n\\n            If this pillar variable is present and set to ``False``, then it\\n            will turn off this option.\\n\\n            For more granular control, setting a pillar variable named\\n            ``docker.force.image_name`` will affect only the named image.\\n    '\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n    if not name and (not images):\n        ret['comment'] = \"One of 'name' and 'images' must be provided\"\n        return ret\n    elif images is not None:\n        targets = images\n    elif name:\n        targets = [name]\n    to_delete = []\n    for target in targets:\n        resolved_tag = __salt__['docker.resolve_tag'](target)\n        if resolved_tag is not False:\n            to_delete.append(resolved_tag)\n    if not to_delete:\n        ret['result'] = True\n        if len(targets) == 1:\n            ret['comment'] = f'Image {name} is not present'\n        else:\n            ret['comment'] = 'All specified images are not present'\n        return ret\n    if __opts__['test']:\n        ret['result'] = None\n        if len(to_delete) == 1:\n            ret['comment'] = f'Image {to_delete[0]} will be removed'\n        else:\n            ret['comment'] = 'The following images will be removed: {}'.format(', '.join(to_delete))\n        return ret\n    result = __salt__['docker.rmi'](*to_delete, force=force)\n    post_tags = __salt__['docker.list_tags']()\n    failed = [x for x in to_delete if x in post_tags]\n    if failed:\n        if [x for x in to_delete if x not in post_tags]:\n            ret['changes'] = result\n            ret['comment'] = 'The following image(s) failed to be removed: {}'.format(', '.join(failed))\n        else:\n            ret['comment'] = 'None of the specified images were removed'\n            if 'Errors' in result:\n                ret['comment'] += '. The following errors were encountered: {}'.format('; '.join(result['Errors']))\n    else:\n        ret['changes'] = result\n        if len(to_delete) == 1:\n            ret['comment'] = f'Image {to_delete[0]} was removed'\n        else:\n            ret['comment'] = 'The following images were removed: {}'.format(', '.join(to_delete))\n        ret['result'] = True\n    return ret",
            "def absent(name=None, images=None, force=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Ensure that an image is absent from the Minion. Image names can be\\n    specified either using ``repo:tag`` notation, or just the repo name (in\\n    which case a tag of ``latest`` is assumed).\\n\\n    name\\n        The name of the docker image.\\n\\n    images\\n        Run this state on more than one image at a time. The following two\\n        examples accomplish the same thing:\\n\\n        .. code-block:: yaml\\n\\n            remove_images:\\n              docker_image.absent:\\n                - names:\\n                  - busybox\\n                  - centos:6\\n                  - nginx\\n\\n        .. code-block:: yaml\\n\\n            remove_images:\\n              docker_image.absent:\\n                - images:\\n                  - busybox\\n                  - centos:6\\n                  - nginx\\n\\n        However, the second example will be a bit quicker since Salt will do\\n        all the deletions in a single run, rather than executing the state\\n        separately on each image (as it would in the first example).\\n\\n    force\\n        Salt will fail to remove any images currently in use by a container.\\n        Set this option to true to remove the image even if it is already\\n        present.\\n\\n        .. note::\\n\\n            This option can also be overridden by Pillar data. If the Minion\\n            has a pillar variable named ``docker.running.force`` which is\\n            set to ``True``, it will turn on this option. This pillar variable\\n            can even be set at runtime. For example:\\n\\n            .. code-block:: bash\\n\\n                salt myminion state.sls docker_stuff pillar=\"{docker.force: True}\"\\n\\n            If this pillar variable is present and set to ``False``, then it\\n            will turn off this option.\\n\\n            For more granular control, setting a pillar variable named\\n            ``docker.force.image_name`` will affect only the named image.\\n    '\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n    if not name and (not images):\n        ret['comment'] = \"One of 'name' and 'images' must be provided\"\n        return ret\n    elif images is not None:\n        targets = images\n    elif name:\n        targets = [name]\n    to_delete = []\n    for target in targets:\n        resolved_tag = __salt__['docker.resolve_tag'](target)\n        if resolved_tag is not False:\n            to_delete.append(resolved_tag)\n    if not to_delete:\n        ret['result'] = True\n        if len(targets) == 1:\n            ret['comment'] = f'Image {name} is not present'\n        else:\n            ret['comment'] = 'All specified images are not present'\n        return ret\n    if __opts__['test']:\n        ret['result'] = None\n        if len(to_delete) == 1:\n            ret['comment'] = f'Image {to_delete[0]} will be removed'\n        else:\n            ret['comment'] = 'The following images will be removed: {}'.format(', '.join(to_delete))\n        return ret\n    result = __salt__['docker.rmi'](*to_delete, force=force)\n    post_tags = __salt__['docker.list_tags']()\n    failed = [x for x in to_delete if x in post_tags]\n    if failed:\n        if [x for x in to_delete if x not in post_tags]:\n            ret['changes'] = result\n            ret['comment'] = 'The following image(s) failed to be removed: {}'.format(', '.join(failed))\n        else:\n            ret['comment'] = 'None of the specified images were removed'\n            if 'Errors' in result:\n                ret['comment'] += '. The following errors were encountered: {}'.format('; '.join(result['Errors']))\n    else:\n        ret['changes'] = result\n        if len(to_delete) == 1:\n            ret['comment'] = f'Image {to_delete[0]} was removed'\n        else:\n            ret['comment'] = 'The following images were removed: {}'.format(', '.join(to_delete))\n        ret['result'] = True\n    return ret",
            "def absent(name=None, images=None, force=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Ensure that an image is absent from the Minion. Image names can be\\n    specified either using ``repo:tag`` notation, or just the repo name (in\\n    which case a tag of ``latest`` is assumed).\\n\\n    name\\n        The name of the docker image.\\n\\n    images\\n        Run this state on more than one image at a time. The following two\\n        examples accomplish the same thing:\\n\\n        .. code-block:: yaml\\n\\n            remove_images:\\n              docker_image.absent:\\n                - names:\\n                  - busybox\\n                  - centos:6\\n                  - nginx\\n\\n        .. code-block:: yaml\\n\\n            remove_images:\\n              docker_image.absent:\\n                - images:\\n                  - busybox\\n                  - centos:6\\n                  - nginx\\n\\n        However, the second example will be a bit quicker since Salt will do\\n        all the deletions in a single run, rather than executing the state\\n        separately on each image (as it would in the first example).\\n\\n    force\\n        Salt will fail to remove any images currently in use by a container.\\n        Set this option to true to remove the image even if it is already\\n        present.\\n\\n        .. note::\\n\\n            This option can also be overridden by Pillar data. If the Minion\\n            has a pillar variable named ``docker.running.force`` which is\\n            set to ``True``, it will turn on this option. This pillar variable\\n            can even be set at runtime. For example:\\n\\n            .. code-block:: bash\\n\\n                salt myminion state.sls docker_stuff pillar=\"{docker.force: True}\"\\n\\n            If this pillar variable is present and set to ``False``, then it\\n            will turn off this option.\\n\\n            For more granular control, setting a pillar variable named\\n            ``docker.force.image_name`` will affect only the named image.\\n    '\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n    if not name and (not images):\n        ret['comment'] = \"One of 'name' and 'images' must be provided\"\n        return ret\n    elif images is not None:\n        targets = images\n    elif name:\n        targets = [name]\n    to_delete = []\n    for target in targets:\n        resolved_tag = __salt__['docker.resolve_tag'](target)\n        if resolved_tag is not False:\n            to_delete.append(resolved_tag)\n    if not to_delete:\n        ret['result'] = True\n        if len(targets) == 1:\n            ret['comment'] = f'Image {name} is not present'\n        else:\n            ret['comment'] = 'All specified images are not present'\n        return ret\n    if __opts__['test']:\n        ret['result'] = None\n        if len(to_delete) == 1:\n            ret['comment'] = f'Image {to_delete[0]} will be removed'\n        else:\n            ret['comment'] = 'The following images will be removed: {}'.format(', '.join(to_delete))\n        return ret\n    result = __salt__['docker.rmi'](*to_delete, force=force)\n    post_tags = __salt__['docker.list_tags']()\n    failed = [x for x in to_delete if x in post_tags]\n    if failed:\n        if [x for x in to_delete if x not in post_tags]:\n            ret['changes'] = result\n            ret['comment'] = 'The following image(s) failed to be removed: {}'.format(', '.join(failed))\n        else:\n            ret['comment'] = 'None of the specified images were removed'\n            if 'Errors' in result:\n                ret['comment'] += '. The following errors were encountered: {}'.format('; '.join(result['Errors']))\n    else:\n        ret['changes'] = result\n        if len(to_delete) == 1:\n            ret['comment'] = f'Image {to_delete[0]} was removed'\n        else:\n            ret['comment'] = 'The following images were removed: {}'.format(', '.join(to_delete))\n        ret['result'] = True\n    return ret",
            "def absent(name=None, images=None, force=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Ensure that an image is absent from the Minion. Image names can be\\n    specified either using ``repo:tag`` notation, or just the repo name (in\\n    which case a tag of ``latest`` is assumed).\\n\\n    name\\n        The name of the docker image.\\n\\n    images\\n        Run this state on more than one image at a time. The following two\\n        examples accomplish the same thing:\\n\\n        .. code-block:: yaml\\n\\n            remove_images:\\n              docker_image.absent:\\n                - names:\\n                  - busybox\\n                  - centos:6\\n                  - nginx\\n\\n        .. code-block:: yaml\\n\\n            remove_images:\\n              docker_image.absent:\\n                - images:\\n                  - busybox\\n                  - centos:6\\n                  - nginx\\n\\n        However, the second example will be a bit quicker since Salt will do\\n        all the deletions in a single run, rather than executing the state\\n        separately on each image (as it would in the first example).\\n\\n    force\\n        Salt will fail to remove any images currently in use by a container.\\n        Set this option to true to remove the image even if it is already\\n        present.\\n\\n        .. note::\\n\\n            This option can also be overridden by Pillar data. If the Minion\\n            has a pillar variable named ``docker.running.force`` which is\\n            set to ``True``, it will turn on this option. This pillar variable\\n            can even be set at runtime. For example:\\n\\n            .. code-block:: bash\\n\\n                salt myminion state.sls docker_stuff pillar=\"{docker.force: True}\"\\n\\n            If this pillar variable is present and set to ``False``, then it\\n            will turn off this option.\\n\\n            For more granular control, setting a pillar variable named\\n            ``docker.force.image_name`` will affect only the named image.\\n    '\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n    if not name and (not images):\n        ret['comment'] = \"One of 'name' and 'images' must be provided\"\n        return ret\n    elif images is not None:\n        targets = images\n    elif name:\n        targets = [name]\n    to_delete = []\n    for target in targets:\n        resolved_tag = __salt__['docker.resolve_tag'](target)\n        if resolved_tag is not False:\n            to_delete.append(resolved_tag)\n    if not to_delete:\n        ret['result'] = True\n        if len(targets) == 1:\n            ret['comment'] = f'Image {name} is not present'\n        else:\n            ret['comment'] = 'All specified images are not present'\n        return ret\n    if __opts__['test']:\n        ret['result'] = None\n        if len(to_delete) == 1:\n            ret['comment'] = f'Image {to_delete[0]} will be removed'\n        else:\n            ret['comment'] = 'The following images will be removed: {}'.format(', '.join(to_delete))\n        return ret\n    result = __salt__['docker.rmi'](*to_delete, force=force)\n    post_tags = __salt__['docker.list_tags']()\n    failed = [x for x in to_delete if x in post_tags]\n    if failed:\n        if [x for x in to_delete if x not in post_tags]:\n            ret['changes'] = result\n            ret['comment'] = 'The following image(s) failed to be removed: {}'.format(', '.join(failed))\n        else:\n            ret['comment'] = 'None of the specified images were removed'\n            if 'Errors' in result:\n                ret['comment'] += '. The following errors were encountered: {}'.format('; '.join(result['Errors']))\n    else:\n        ret['changes'] = result\n        if len(to_delete) == 1:\n            ret['comment'] = f'Image {to_delete[0]} was removed'\n        else:\n            ret['comment'] = 'The following images were removed: {}'.format(', '.join(to_delete))\n        ret['result'] = True\n    return ret",
            "def absent(name=None, images=None, force=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Ensure that an image is absent from the Minion. Image names can be\\n    specified either using ``repo:tag`` notation, or just the repo name (in\\n    which case a tag of ``latest`` is assumed).\\n\\n    name\\n        The name of the docker image.\\n\\n    images\\n        Run this state on more than one image at a time. The following two\\n        examples accomplish the same thing:\\n\\n        .. code-block:: yaml\\n\\n            remove_images:\\n              docker_image.absent:\\n                - names:\\n                  - busybox\\n                  - centos:6\\n                  - nginx\\n\\n        .. code-block:: yaml\\n\\n            remove_images:\\n              docker_image.absent:\\n                - images:\\n                  - busybox\\n                  - centos:6\\n                  - nginx\\n\\n        However, the second example will be a bit quicker since Salt will do\\n        all the deletions in a single run, rather than executing the state\\n        separately on each image (as it would in the first example).\\n\\n    force\\n        Salt will fail to remove any images currently in use by a container.\\n        Set this option to true to remove the image even if it is already\\n        present.\\n\\n        .. note::\\n\\n            This option can also be overridden by Pillar data. If the Minion\\n            has a pillar variable named ``docker.running.force`` which is\\n            set to ``True``, it will turn on this option. This pillar variable\\n            can even be set at runtime. For example:\\n\\n            .. code-block:: bash\\n\\n                salt myminion state.sls docker_stuff pillar=\"{docker.force: True}\"\\n\\n            If this pillar variable is present and set to ``False``, then it\\n            will turn off this option.\\n\\n            For more granular control, setting a pillar variable named\\n            ``docker.force.image_name`` will affect only the named image.\\n    '\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n    if not name and (not images):\n        ret['comment'] = \"One of 'name' and 'images' must be provided\"\n        return ret\n    elif images is not None:\n        targets = images\n    elif name:\n        targets = [name]\n    to_delete = []\n    for target in targets:\n        resolved_tag = __salt__['docker.resolve_tag'](target)\n        if resolved_tag is not False:\n            to_delete.append(resolved_tag)\n    if not to_delete:\n        ret['result'] = True\n        if len(targets) == 1:\n            ret['comment'] = f'Image {name} is not present'\n        else:\n            ret['comment'] = 'All specified images are not present'\n        return ret\n    if __opts__['test']:\n        ret['result'] = None\n        if len(to_delete) == 1:\n            ret['comment'] = f'Image {to_delete[0]} will be removed'\n        else:\n            ret['comment'] = 'The following images will be removed: {}'.format(', '.join(to_delete))\n        return ret\n    result = __salt__['docker.rmi'](*to_delete, force=force)\n    post_tags = __salt__['docker.list_tags']()\n    failed = [x for x in to_delete if x in post_tags]\n    if failed:\n        if [x for x in to_delete if x not in post_tags]:\n            ret['changes'] = result\n            ret['comment'] = 'The following image(s) failed to be removed: {}'.format(', '.join(failed))\n        else:\n            ret['comment'] = 'None of the specified images were removed'\n            if 'Errors' in result:\n                ret['comment'] += '. The following errors were encountered: {}'.format('; '.join(result['Errors']))\n    else:\n        ret['changes'] = result\n        if len(to_delete) == 1:\n            ret['comment'] = f'Image {to_delete[0]} was removed'\n        else:\n            ret['comment'] = 'The following images were removed: {}'.format(', '.join(to_delete))\n        ret['result'] = True\n    return ret"
        ]
    },
    {
        "func_name": "mod_watch",
        "original": "def mod_watch(name, sfun=None, **kwargs):\n    \"\"\"\n    The docker_image  watcher, called to invoke the watch command.\n\n    .. note::\n        This state exists to support special handling of the ``watch``\n        :ref:`requisite <requisites>`. It should not be called directly.\n\n        Parameters for this function should be set by the state being triggered.\n    \"\"\"\n    if sfun == 'present':\n        kwargs['force'] = True\n        return present(name, **kwargs)\n    return {'name': name, 'changes': {}, 'result': False, 'comment': f'watch requisite is not implemented for {sfun}'}",
        "mutated": [
            "def mod_watch(name, sfun=None, **kwargs):\n    if False:\n        i = 10\n    '\\n    The docker_image  watcher, called to invoke the watch command.\\n\\n    .. note::\\n        This state exists to support special handling of the ``watch``\\n        :ref:`requisite <requisites>`. It should not be called directly.\\n\\n        Parameters for this function should be set by the state being triggered.\\n    '\n    if sfun == 'present':\n        kwargs['force'] = True\n        return present(name, **kwargs)\n    return {'name': name, 'changes': {}, 'result': False, 'comment': f'watch requisite is not implemented for {sfun}'}",
            "def mod_watch(name, sfun=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    The docker_image  watcher, called to invoke the watch command.\\n\\n    .. note::\\n        This state exists to support special handling of the ``watch``\\n        :ref:`requisite <requisites>`. It should not be called directly.\\n\\n        Parameters for this function should be set by the state being triggered.\\n    '\n    if sfun == 'present':\n        kwargs['force'] = True\n        return present(name, **kwargs)\n    return {'name': name, 'changes': {}, 'result': False, 'comment': f'watch requisite is not implemented for {sfun}'}",
            "def mod_watch(name, sfun=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    The docker_image  watcher, called to invoke the watch command.\\n\\n    .. note::\\n        This state exists to support special handling of the ``watch``\\n        :ref:`requisite <requisites>`. It should not be called directly.\\n\\n        Parameters for this function should be set by the state being triggered.\\n    '\n    if sfun == 'present':\n        kwargs['force'] = True\n        return present(name, **kwargs)\n    return {'name': name, 'changes': {}, 'result': False, 'comment': f'watch requisite is not implemented for {sfun}'}",
            "def mod_watch(name, sfun=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    The docker_image  watcher, called to invoke the watch command.\\n\\n    .. note::\\n        This state exists to support special handling of the ``watch``\\n        :ref:`requisite <requisites>`. It should not be called directly.\\n\\n        Parameters for this function should be set by the state being triggered.\\n    '\n    if sfun == 'present':\n        kwargs['force'] = True\n        return present(name, **kwargs)\n    return {'name': name, 'changes': {}, 'result': False, 'comment': f'watch requisite is not implemented for {sfun}'}",
            "def mod_watch(name, sfun=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    The docker_image  watcher, called to invoke the watch command.\\n\\n    .. note::\\n        This state exists to support special handling of the ``watch``\\n        :ref:`requisite <requisites>`. It should not be called directly.\\n\\n        Parameters for this function should be set by the state being triggered.\\n    '\n    if sfun == 'present':\n        kwargs['force'] = True\n        return present(name, **kwargs)\n    return {'name': name, 'changes': {}, 'result': False, 'comment': f'watch requisite is not implemented for {sfun}'}"
        ]
    }
]