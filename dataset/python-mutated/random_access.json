[
    {
        "func_name": "at",
        "original": "@tf_export('data.experimental.at', v1=[])\ndef at(dataset, index):\n    \"\"\"Returns the element at a specific index in a datasest.\n\n  Currently, random access is supported for the following tf.data operations:\n\n     - `tf.data.Dataset.from_tensor_slices`,\n     - `tf.data.Dataset.from_tensors`,\n     - `tf.data.Dataset.shuffle`,\n     - `tf.data.Dataset.batch`,\n     - `tf.data.Dataset.shard`,\n     - `tf.data.Dataset.map`,\n     - `tf.data.Dataset.range`,\n     - `tf.data.Dataset.zip`,\n     - `tf.data.Dataset.skip`,\n     - `tf.data.Dataset.repeat`,\n     - `tf.data.Dataset.list_files`,\n     - `tf.data.Dataset.SSTableDataset`,\n     - `tf.data.Dataset.concatenate`,\n     - `tf.data.Dataset.enumerate`,\n     - `tf.data.Dataset.parallel_map`,\n     - `tf.data.Dataset.prefetch`,\n     - `tf.data.Dataset.take`,\n     - `tf.data.Dataset.cache` (in-memory only)\n\n     Users can use the cache operation to enable random access for any dataset,\n     even one comprised of transformations which are not on this list.\n     E.g., to get the third element of a TFDS dataset:\n\n       ```python\n       ds = tfds.load(\"mnist\", split=\"train\").cache()\n       elem = tf.data.Dataset.experimental.at(ds, 3)\n       ```\n\n  Args:\n    dataset: A `tf.data.Dataset` to determine whether it supports random access.\n    index: The index at which to fetch the element.\n\n  Returns:\n      A (nested) structure of values matching `tf.data.Dataset.element_spec`.\n\n   Raises:\n     UnimplementedError: If random access is not yet supported for a dataset.\n  \"\"\"\n    return structure.from_tensor_list(dataset.element_spec, gen_experimental_dataset_ops.get_element_at_index(dataset._variant_tensor, index, output_types=structure.get_flat_tensor_types(dataset.element_spec), output_shapes=structure.get_flat_tensor_shapes(dataset.element_spec)))",
        "mutated": [
            "@tf_export('data.experimental.at', v1=[])\ndef at(dataset, index):\n    if False:\n        i = 10\n    'Returns the element at a specific index in a datasest.\\n\\n  Currently, random access is supported for the following tf.data operations:\\n\\n     - `tf.data.Dataset.from_tensor_slices`,\\n     - `tf.data.Dataset.from_tensors`,\\n     - `tf.data.Dataset.shuffle`,\\n     - `tf.data.Dataset.batch`,\\n     - `tf.data.Dataset.shard`,\\n     - `tf.data.Dataset.map`,\\n     - `tf.data.Dataset.range`,\\n     - `tf.data.Dataset.zip`,\\n     - `tf.data.Dataset.skip`,\\n     - `tf.data.Dataset.repeat`,\\n     - `tf.data.Dataset.list_files`,\\n     - `tf.data.Dataset.SSTableDataset`,\\n     - `tf.data.Dataset.concatenate`,\\n     - `tf.data.Dataset.enumerate`,\\n     - `tf.data.Dataset.parallel_map`,\\n     - `tf.data.Dataset.prefetch`,\\n     - `tf.data.Dataset.take`,\\n     - `tf.data.Dataset.cache` (in-memory only)\\n\\n     Users can use the cache operation to enable random access for any dataset,\\n     even one comprised of transformations which are not on this list.\\n     E.g., to get the third element of a TFDS dataset:\\n\\n       ```python\\n       ds = tfds.load(\"mnist\", split=\"train\").cache()\\n       elem = tf.data.Dataset.experimental.at(ds, 3)\\n       ```\\n\\n  Args:\\n    dataset: A `tf.data.Dataset` to determine whether it supports random access.\\n    index: The index at which to fetch the element.\\n\\n  Returns:\\n      A (nested) structure of values matching `tf.data.Dataset.element_spec`.\\n\\n   Raises:\\n     UnimplementedError: If random access is not yet supported for a dataset.\\n  '\n    return structure.from_tensor_list(dataset.element_spec, gen_experimental_dataset_ops.get_element_at_index(dataset._variant_tensor, index, output_types=structure.get_flat_tensor_types(dataset.element_spec), output_shapes=structure.get_flat_tensor_shapes(dataset.element_spec)))",
            "@tf_export('data.experimental.at', v1=[])\ndef at(dataset, index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the element at a specific index in a datasest.\\n\\n  Currently, random access is supported for the following tf.data operations:\\n\\n     - `tf.data.Dataset.from_tensor_slices`,\\n     - `tf.data.Dataset.from_tensors`,\\n     - `tf.data.Dataset.shuffle`,\\n     - `tf.data.Dataset.batch`,\\n     - `tf.data.Dataset.shard`,\\n     - `tf.data.Dataset.map`,\\n     - `tf.data.Dataset.range`,\\n     - `tf.data.Dataset.zip`,\\n     - `tf.data.Dataset.skip`,\\n     - `tf.data.Dataset.repeat`,\\n     - `tf.data.Dataset.list_files`,\\n     - `tf.data.Dataset.SSTableDataset`,\\n     - `tf.data.Dataset.concatenate`,\\n     - `tf.data.Dataset.enumerate`,\\n     - `tf.data.Dataset.parallel_map`,\\n     - `tf.data.Dataset.prefetch`,\\n     - `tf.data.Dataset.take`,\\n     - `tf.data.Dataset.cache` (in-memory only)\\n\\n     Users can use the cache operation to enable random access for any dataset,\\n     even one comprised of transformations which are not on this list.\\n     E.g., to get the third element of a TFDS dataset:\\n\\n       ```python\\n       ds = tfds.load(\"mnist\", split=\"train\").cache()\\n       elem = tf.data.Dataset.experimental.at(ds, 3)\\n       ```\\n\\n  Args:\\n    dataset: A `tf.data.Dataset` to determine whether it supports random access.\\n    index: The index at which to fetch the element.\\n\\n  Returns:\\n      A (nested) structure of values matching `tf.data.Dataset.element_spec`.\\n\\n   Raises:\\n     UnimplementedError: If random access is not yet supported for a dataset.\\n  '\n    return structure.from_tensor_list(dataset.element_spec, gen_experimental_dataset_ops.get_element_at_index(dataset._variant_tensor, index, output_types=structure.get_flat_tensor_types(dataset.element_spec), output_shapes=structure.get_flat_tensor_shapes(dataset.element_spec)))",
            "@tf_export('data.experimental.at', v1=[])\ndef at(dataset, index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the element at a specific index in a datasest.\\n\\n  Currently, random access is supported for the following tf.data operations:\\n\\n     - `tf.data.Dataset.from_tensor_slices`,\\n     - `tf.data.Dataset.from_tensors`,\\n     - `tf.data.Dataset.shuffle`,\\n     - `tf.data.Dataset.batch`,\\n     - `tf.data.Dataset.shard`,\\n     - `tf.data.Dataset.map`,\\n     - `tf.data.Dataset.range`,\\n     - `tf.data.Dataset.zip`,\\n     - `tf.data.Dataset.skip`,\\n     - `tf.data.Dataset.repeat`,\\n     - `tf.data.Dataset.list_files`,\\n     - `tf.data.Dataset.SSTableDataset`,\\n     - `tf.data.Dataset.concatenate`,\\n     - `tf.data.Dataset.enumerate`,\\n     - `tf.data.Dataset.parallel_map`,\\n     - `tf.data.Dataset.prefetch`,\\n     - `tf.data.Dataset.take`,\\n     - `tf.data.Dataset.cache` (in-memory only)\\n\\n     Users can use the cache operation to enable random access for any dataset,\\n     even one comprised of transformations which are not on this list.\\n     E.g., to get the third element of a TFDS dataset:\\n\\n       ```python\\n       ds = tfds.load(\"mnist\", split=\"train\").cache()\\n       elem = tf.data.Dataset.experimental.at(ds, 3)\\n       ```\\n\\n  Args:\\n    dataset: A `tf.data.Dataset` to determine whether it supports random access.\\n    index: The index at which to fetch the element.\\n\\n  Returns:\\n      A (nested) structure of values matching `tf.data.Dataset.element_spec`.\\n\\n   Raises:\\n     UnimplementedError: If random access is not yet supported for a dataset.\\n  '\n    return structure.from_tensor_list(dataset.element_spec, gen_experimental_dataset_ops.get_element_at_index(dataset._variant_tensor, index, output_types=structure.get_flat_tensor_types(dataset.element_spec), output_shapes=structure.get_flat_tensor_shapes(dataset.element_spec)))",
            "@tf_export('data.experimental.at', v1=[])\ndef at(dataset, index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the element at a specific index in a datasest.\\n\\n  Currently, random access is supported for the following tf.data operations:\\n\\n     - `tf.data.Dataset.from_tensor_slices`,\\n     - `tf.data.Dataset.from_tensors`,\\n     - `tf.data.Dataset.shuffle`,\\n     - `tf.data.Dataset.batch`,\\n     - `tf.data.Dataset.shard`,\\n     - `tf.data.Dataset.map`,\\n     - `tf.data.Dataset.range`,\\n     - `tf.data.Dataset.zip`,\\n     - `tf.data.Dataset.skip`,\\n     - `tf.data.Dataset.repeat`,\\n     - `tf.data.Dataset.list_files`,\\n     - `tf.data.Dataset.SSTableDataset`,\\n     - `tf.data.Dataset.concatenate`,\\n     - `tf.data.Dataset.enumerate`,\\n     - `tf.data.Dataset.parallel_map`,\\n     - `tf.data.Dataset.prefetch`,\\n     - `tf.data.Dataset.take`,\\n     - `tf.data.Dataset.cache` (in-memory only)\\n\\n     Users can use the cache operation to enable random access for any dataset,\\n     even one comprised of transformations which are not on this list.\\n     E.g., to get the third element of a TFDS dataset:\\n\\n       ```python\\n       ds = tfds.load(\"mnist\", split=\"train\").cache()\\n       elem = tf.data.Dataset.experimental.at(ds, 3)\\n       ```\\n\\n  Args:\\n    dataset: A `tf.data.Dataset` to determine whether it supports random access.\\n    index: The index at which to fetch the element.\\n\\n  Returns:\\n      A (nested) structure of values matching `tf.data.Dataset.element_spec`.\\n\\n   Raises:\\n     UnimplementedError: If random access is not yet supported for a dataset.\\n  '\n    return structure.from_tensor_list(dataset.element_spec, gen_experimental_dataset_ops.get_element_at_index(dataset._variant_tensor, index, output_types=structure.get_flat_tensor_types(dataset.element_spec), output_shapes=structure.get_flat_tensor_shapes(dataset.element_spec)))",
            "@tf_export('data.experimental.at', v1=[])\ndef at(dataset, index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the element at a specific index in a datasest.\\n\\n  Currently, random access is supported for the following tf.data operations:\\n\\n     - `tf.data.Dataset.from_tensor_slices`,\\n     - `tf.data.Dataset.from_tensors`,\\n     - `tf.data.Dataset.shuffle`,\\n     - `tf.data.Dataset.batch`,\\n     - `tf.data.Dataset.shard`,\\n     - `tf.data.Dataset.map`,\\n     - `tf.data.Dataset.range`,\\n     - `tf.data.Dataset.zip`,\\n     - `tf.data.Dataset.skip`,\\n     - `tf.data.Dataset.repeat`,\\n     - `tf.data.Dataset.list_files`,\\n     - `tf.data.Dataset.SSTableDataset`,\\n     - `tf.data.Dataset.concatenate`,\\n     - `tf.data.Dataset.enumerate`,\\n     - `tf.data.Dataset.parallel_map`,\\n     - `tf.data.Dataset.prefetch`,\\n     - `tf.data.Dataset.take`,\\n     - `tf.data.Dataset.cache` (in-memory only)\\n\\n     Users can use the cache operation to enable random access for any dataset,\\n     even one comprised of transformations which are not on this list.\\n     E.g., to get the third element of a TFDS dataset:\\n\\n       ```python\\n       ds = tfds.load(\"mnist\", split=\"train\").cache()\\n       elem = tf.data.Dataset.experimental.at(ds, 3)\\n       ```\\n\\n  Args:\\n    dataset: A `tf.data.Dataset` to determine whether it supports random access.\\n    index: The index at which to fetch the element.\\n\\n  Returns:\\n      A (nested) structure of values matching `tf.data.Dataset.element_spec`.\\n\\n   Raises:\\n     UnimplementedError: If random access is not yet supported for a dataset.\\n  '\n    return structure.from_tensor_list(dataset.element_spec, gen_experimental_dataset_ops.get_element_at_index(dataset._variant_tensor, index, output_types=structure.get_flat_tensor_types(dataset.element_spec), output_shapes=structure.get_flat_tensor_shapes(dataset.element_spec)))"
        ]
    }
]