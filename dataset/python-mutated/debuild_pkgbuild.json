[
    {
        "func_name": "__virtual__",
        "original": "def __virtual__():\n    \"\"\"\n    Confirm this module is on a Debian-based system, and has required utilities\n    \"\"\"\n    if __grains__.get('os_family', False) in ('Kali', 'Debian'):\n        missing_util = False\n        utils_reqd = ['gpg', 'debuild', 'pbuilder', 'reprepro']\n        for named_util in utils_reqd:\n            if not salt.utils.path.which(named_util):\n                missing_util = True\n                break\n        if HAS_LIBS and (not missing_util):\n            return __virtualname__\n        else:\n            return (False, 'The debbuild module could not be loaded: requires python-gnupg, gpg, debuild, pbuilder and reprepro utilities to be installed')\n    else:\n        return (False, 'The debbuild module could not be loaded: unsupported OS family')",
        "mutated": [
            "def __virtual__():\n    if False:\n        i = 10\n    '\\n    Confirm this module is on a Debian-based system, and has required utilities\\n    '\n    if __grains__.get('os_family', False) in ('Kali', 'Debian'):\n        missing_util = False\n        utils_reqd = ['gpg', 'debuild', 'pbuilder', 'reprepro']\n        for named_util in utils_reqd:\n            if not salt.utils.path.which(named_util):\n                missing_util = True\n                break\n        if HAS_LIBS and (not missing_util):\n            return __virtualname__\n        else:\n            return (False, 'The debbuild module could not be loaded: requires python-gnupg, gpg, debuild, pbuilder and reprepro utilities to be installed')\n    else:\n        return (False, 'The debbuild module could not be loaded: unsupported OS family')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Confirm this module is on a Debian-based system, and has required utilities\\n    '\n    if __grains__.get('os_family', False) in ('Kali', 'Debian'):\n        missing_util = False\n        utils_reqd = ['gpg', 'debuild', 'pbuilder', 'reprepro']\n        for named_util in utils_reqd:\n            if not salt.utils.path.which(named_util):\n                missing_util = True\n                break\n        if HAS_LIBS and (not missing_util):\n            return __virtualname__\n        else:\n            return (False, 'The debbuild module could not be loaded: requires python-gnupg, gpg, debuild, pbuilder and reprepro utilities to be installed')\n    else:\n        return (False, 'The debbuild module could not be loaded: unsupported OS family')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Confirm this module is on a Debian-based system, and has required utilities\\n    '\n    if __grains__.get('os_family', False) in ('Kali', 'Debian'):\n        missing_util = False\n        utils_reqd = ['gpg', 'debuild', 'pbuilder', 'reprepro']\n        for named_util in utils_reqd:\n            if not salt.utils.path.which(named_util):\n                missing_util = True\n                break\n        if HAS_LIBS and (not missing_util):\n            return __virtualname__\n        else:\n            return (False, 'The debbuild module could not be loaded: requires python-gnupg, gpg, debuild, pbuilder and reprepro utilities to be installed')\n    else:\n        return (False, 'The debbuild module could not be loaded: unsupported OS family')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Confirm this module is on a Debian-based system, and has required utilities\\n    '\n    if __grains__.get('os_family', False) in ('Kali', 'Debian'):\n        missing_util = False\n        utils_reqd = ['gpg', 'debuild', 'pbuilder', 'reprepro']\n        for named_util in utils_reqd:\n            if not salt.utils.path.which(named_util):\n                missing_util = True\n                break\n        if HAS_LIBS and (not missing_util):\n            return __virtualname__\n        else:\n            return (False, 'The debbuild module could not be loaded: requires python-gnupg, gpg, debuild, pbuilder and reprepro utilities to be installed')\n    else:\n        return (False, 'The debbuild module could not be loaded: unsupported OS family')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Confirm this module is on a Debian-based system, and has required utilities\\n    '\n    if __grains__.get('os_family', False) in ('Kali', 'Debian'):\n        missing_util = False\n        utils_reqd = ['gpg', 'debuild', 'pbuilder', 'reprepro']\n        for named_util in utils_reqd:\n            if not salt.utils.path.which(named_util):\n                missing_util = True\n                break\n        if HAS_LIBS and (not missing_util):\n            return __virtualname__\n        else:\n            return (False, 'The debbuild module could not be loaded: requires python-gnupg, gpg, debuild, pbuilder and reprepro utilities to be installed')\n    else:\n        return (False, 'The debbuild module could not be loaded: unsupported OS family')"
        ]
    },
    {
        "func_name": "_check_repo_sign_utils_support",
        "original": "def _check_repo_sign_utils_support(name):\n    \"\"\"\n    Check for specified command name in search path\n    \"\"\"\n    if salt.utils.path.which(name):\n        return True\n    else:\n        raise CommandExecutionError(\"utility '{}' needs to be installed or made available in search path\".format(name))",
        "mutated": [
            "def _check_repo_sign_utils_support(name):\n    if False:\n        i = 10\n    '\\n    Check for specified command name in search path\\n    '\n    if salt.utils.path.which(name):\n        return True\n    else:\n        raise CommandExecutionError(\"utility '{}' needs to be installed or made available in search path\".format(name))",
            "def _check_repo_sign_utils_support(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Check for specified command name in search path\\n    '\n    if salt.utils.path.which(name):\n        return True\n    else:\n        raise CommandExecutionError(\"utility '{}' needs to be installed or made available in search path\".format(name))",
            "def _check_repo_sign_utils_support(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Check for specified command name in search path\\n    '\n    if salt.utils.path.which(name):\n        return True\n    else:\n        raise CommandExecutionError(\"utility '{}' needs to be installed or made available in search path\".format(name))",
            "def _check_repo_sign_utils_support(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Check for specified command name in search path\\n    '\n    if salt.utils.path.which(name):\n        return True\n    else:\n        raise CommandExecutionError(\"utility '{}' needs to be installed or made available in search path\".format(name))",
            "def _check_repo_sign_utils_support(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Check for specified command name in search path\\n    '\n    if salt.utils.path.which(name):\n        return True\n    else:\n        raise CommandExecutionError(\"utility '{}' needs to be installed or made available in search path\".format(name))"
        ]
    },
    {
        "func_name": "_check_repo_gpg_phrase_utils",
        "original": "def _check_repo_gpg_phrase_utils():\n    \"\"\"\n    Check for /usr/lib/gnupg2/gpg-preset-passphrase is installed\n    \"\"\"\n    util_name = '/usr/lib/gnupg2/gpg-preset-passphrase'\n    if __salt__['file.file_exists'](util_name):\n        return True\n    else:\n        raise CommandExecutionError(\"utility '{}' needs to be installed\".format(util_name))",
        "mutated": [
            "def _check_repo_gpg_phrase_utils():\n    if False:\n        i = 10\n    '\\n    Check for /usr/lib/gnupg2/gpg-preset-passphrase is installed\\n    '\n    util_name = '/usr/lib/gnupg2/gpg-preset-passphrase'\n    if __salt__['file.file_exists'](util_name):\n        return True\n    else:\n        raise CommandExecutionError(\"utility '{}' needs to be installed\".format(util_name))",
            "def _check_repo_gpg_phrase_utils():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Check for /usr/lib/gnupg2/gpg-preset-passphrase is installed\\n    '\n    util_name = '/usr/lib/gnupg2/gpg-preset-passphrase'\n    if __salt__['file.file_exists'](util_name):\n        return True\n    else:\n        raise CommandExecutionError(\"utility '{}' needs to be installed\".format(util_name))",
            "def _check_repo_gpg_phrase_utils():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Check for /usr/lib/gnupg2/gpg-preset-passphrase is installed\\n    '\n    util_name = '/usr/lib/gnupg2/gpg-preset-passphrase'\n    if __salt__['file.file_exists'](util_name):\n        return True\n    else:\n        raise CommandExecutionError(\"utility '{}' needs to be installed\".format(util_name))",
            "def _check_repo_gpg_phrase_utils():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Check for /usr/lib/gnupg2/gpg-preset-passphrase is installed\\n    '\n    util_name = '/usr/lib/gnupg2/gpg-preset-passphrase'\n    if __salt__['file.file_exists'](util_name):\n        return True\n    else:\n        raise CommandExecutionError(\"utility '{}' needs to be installed\".format(util_name))",
            "def _check_repo_gpg_phrase_utils():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Check for /usr/lib/gnupg2/gpg-preset-passphrase is installed\\n    '\n    util_name = '/usr/lib/gnupg2/gpg-preset-passphrase'\n    if __salt__['file.file_exists'](util_name):\n        return True\n    else:\n        raise CommandExecutionError(\"utility '{}' needs to be installed\".format(util_name))"
        ]
    },
    {
        "func_name": "_get_build_env",
        "original": "def _get_build_env(env):\n    \"\"\"\n    Get build environment overrides dictionary to use in build process\n    \"\"\"\n    env_override = ''\n    if env is None:\n        return env_override\n    if not isinstance(env, dict):\n        raise SaltInvocationError(\"'env' must be a Python dictionary\")\n    for (key, value) in env.items():\n        env_override += '{}={}\\n'.format(key, value)\n        env_override += 'export {}\\n'.format(key)\n    return env_override",
        "mutated": [
            "def _get_build_env(env):\n    if False:\n        i = 10\n    '\\n    Get build environment overrides dictionary to use in build process\\n    '\n    env_override = ''\n    if env is None:\n        return env_override\n    if not isinstance(env, dict):\n        raise SaltInvocationError(\"'env' must be a Python dictionary\")\n    for (key, value) in env.items():\n        env_override += '{}={}\\n'.format(key, value)\n        env_override += 'export {}\\n'.format(key)\n    return env_override",
            "def _get_build_env(env):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Get build environment overrides dictionary to use in build process\\n    '\n    env_override = ''\n    if env is None:\n        return env_override\n    if not isinstance(env, dict):\n        raise SaltInvocationError(\"'env' must be a Python dictionary\")\n    for (key, value) in env.items():\n        env_override += '{}={}\\n'.format(key, value)\n        env_override += 'export {}\\n'.format(key)\n    return env_override",
            "def _get_build_env(env):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Get build environment overrides dictionary to use in build process\\n    '\n    env_override = ''\n    if env is None:\n        return env_override\n    if not isinstance(env, dict):\n        raise SaltInvocationError(\"'env' must be a Python dictionary\")\n    for (key, value) in env.items():\n        env_override += '{}={}\\n'.format(key, value)\n        env_override += 'export {}\\n'.format(key)\n    return env_override",
            "def _get_build_env(env):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Get build environment overrides dictionary to use in build process\\n    '\n    env_override = ''\n    if env is None:\n        return env_override\n    if not isinstance(env, dict):\n        raise SaltInvocationError(\"'env' must be a Python dictionary\")\n    for (key, value) in env.items():\n        env_override += '{}={}\\n'.format(key, value)\n        env_override += 'export {}\\n'.format(key)\n    return env_override",
            "def _get_build_env(env):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Get build environment overrides dictionary to use in build process\\n    '\n    env_override = ''\n    if env is None:\n        return env_override\n    if not isinstance(env, dict):\n        raise SaltInvocationError(\"'env' must be a Python dictionary\")\n    for (key, value) in env.items():\n        env_override += '{}={}\\n'.format(key, value)\n        env_override += 'export {}\\n'.format(key)\n    return env_override"
        ]
    },
    {
        "func_name": "_get_repo_options_env",
        "original": "def _get_repo_options_env(env):\n    \"\"\"\n    Get repo environment overrides dictionary to use in repo options process\n\n    env\n        A dictionary of variables to define the repository options\n        Example:\n\n        .. code-block:: yaml\n\n            - env:\n                - OPTIONS : 'ask-passphrase'\n\n        .. warning::\n\n            The above illustrates a common PyYAML pitfall, that **yes**,\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\n            boolean ``True`` and ``False`` values, and must be enclosed in\n            quotes to be used as strings. More info on this (and other) PyYAML\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\n\n    \"\"\"\n    env_options = ''\n    if env is None:\n        return env_options\n    if not isinstance(env, dict):\n        raise SaltInvocationError(\"'env' must be a Python dictionary\")\n    for (key, value) in env.items():\n        if key == 'OPTIONS':\n            env_options += '{}\\n'.format(value)\n    return env_options",
        "mutated": [
            "def _get_repo_options_env(env):\n    if False:\n        i = 10\n    \"\\n    Get repo environment overrides dictionary to use in repo options process\\n\\n    env\\n        A dictionary of variables to define the repository options\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                - OPTIONS : 'ask-passphrase'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    \"\n    env_options = ''\n    if env is None:\n        return env_options\n    if not isinstance(env, dict):\n        raise SaltInvocationError(\"'env' must be a Python dictionary\")\n    for (key, value) in env.items():\n        if key == 'OPTIONS':\n            env_options += '{}\\n'.format(value)\n    return env_options",
            "def _get_repo_options_env(env):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Get repo environment overrides dictionary to use in repo options process\\n\\n    env\\n        A dictionary of variables to define the repository options\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                - OPTIONS : 'ask-passphrase'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    \"\n    env_options = ''\n    if env is None:\n        return env_options\n    if not isinstance(env, dict):\n        raise SaltInvocationError(\"'env' must be a Python dictionary\")\n    for (key, value) in env.items():\n        if key == 'OPTIONS':\n            env_options += '{}\\n'.format(value)\n    return env_options",
            "def _get_repo_options_env(env):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Get repo environment overrides dictionary to use in repo options process\\n\\n    env\\n        A dictionary of variables to define the repository options\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                - OPTIONS : 'ask-passphrase'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    \"\n    env_options = ''\n    if env is None:\n        return env_options\n    if not isinstance(env, dict):\n        raise SaltInvocationError(\"'env' must be a Python dictionary\")\n    for (key, value) in env.items():\n        if key == 'OPTIONS':\n            env_options += '{}\\n'.format(value)\n    return env_options",
            "def _get_repo_options_env(env):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Get repo environment overrides dictionary to use in repo options process\\n\\n    env\\n        A dictionary of variables to define the repository options\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                - OPTIONS : 'ask-passphrase'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    \"\n    env_options = ''\n    if env is None:\n        return env_options\n    if not isinstance(env, dict):\n        raise SaltInvocationError(\"'env' must be a Python dictionary\")\n    for (key, value) in env.items():\n        if key == 'OPTIONS':\n            env_options += '{}\\n'.format(value)\n    return env_options",
            "def _get_repo_options_env(env):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Get repo environment overrides dictionary to use in repo options process\\n\\n    env\\n        A dictionary of variables to define the repository options\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                - OPTIONS : 'ask-passphrase'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    \"\n    env_options = ''\n    if env is None:\n        return env_options\n    if not isinstance(env, dict):\n        raise SaltInvocationError(\"'env' must be a Python dictionary\")\n    for (key, value) in env.items():\n        if key == 'OPTIONS':\n            env_options += '{}\\n'.format(value)\n    return env_options"
        ]
    },
    {
        "func_name": "_get_repo_dists_env",
        "original": "def _get_repo_dists_env(env):\n    \"\"\"\n    Get repo environment overrides dictionary to use in repo distributions process\n\n    env\n        A dictionary of variables to define the repository distributions\n        Example:\n\n        .. code-block:: yaml\n\n            - env:\n                - ORIGIN : 'jessie'\n                - LABEL : 'salt debian'\n                - SUITE : 'main'\n                - VERSION : '8.1'\n                - CODENAME : 'jessie'\n                - ARCHS : 'amd64 i386 source'\n                - COMPONENTS : 'main'\n                - DESCRIPTION : 'SaltStack Debian package repo'\n\n        .. warning::\n\n            The above illustrates a common PyYAML pitfall, that **yes**,\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\n            boolean ``True`` and ``False`` values, and must be enclosed in\n            quotes to be used as strings. More info on this (and other) PyYAML\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\n\n    \"\"\"\n    dflts_dict = {'OPTIONS': ('I', '', 'processed by _get_repo_options_env'), 'ORIGIN': ('O', 'Origin', 'SaltStack'), 'LABEL': ('O', 'Label', 'salt_debian'), 'SUITE': ('O', 'Suite', 'stable'), 'VERSION': ('O', 'Version', '9.0'), 'CODENAME': ('M', 'Codename', 'stretch'), 'ARCHS': ('M', 'Architectures', 'i386 amd64 source'), 'COMPONENTS': ('M', 'Components', 'main'), 'DESCRIPTION': ('O', 'Description', 'SaltStack debian package repo')}\n    env_dists = ''\n    codename = ''\n    dflts_keys = list(dflts_dict.keys())\n    if env is None:\n        for (key, value) in dflts_dict.items():\n            if dflts_dict[key][0] == 'M':\n                env_dists += '{}: {}\\n'.format(dflts_dict[key][1], dflts_dict[key][2])\n                if key == 'CODENAME':\n                    codename = dflts_dict[key][2]\n        return (codename, env_dists)\n    if not isinstance(env, dict):\n        raise SaltInvocationError(\"'env' must be a Python dictionary\")\n    env_man_seen = []\n    for (key, value) in env.items():\n        if key in dflts_keys:\n            if dflts_dict[key][0] == 'M':\n                env_man_seen.append(key)\n                if key == 'CODENAME':\n                    codename = value\n            if dflts_dict[key][0] != 'I':\n                env_dists += '{}: {}\\n'.format(dflts_dict[key][1], value)\n        else:\n            env_dists += '{}: {}\\n'.format(key, value)\n    env_keys = list(env.keys())\n    for key in env_keys:\n        if key in dflts_keys and dflts_dict[key][0] == 'M' and (key not in env_man_seen):\n            env_dists += '{}: {}\\n'.format(dflts_dict[key][1], dflts_dict[key][2])\n            if key == 'CODENAME':\n                codename = value\n    return (codename, env_dists)",
        "mutated": [
            "def _get_repo_dists_env(env):\n    if False:\n        i = 10\n    \"\\n    Get repo environment overrides dictionary to use in repo distributions process\\n\\n    env\\n        A dictionary of variables to define the repository distributions\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                - ORIGIN : 'jessie'\\n                - LABEL : 'salt debian'\\n                - SUITE : 'main'\\n                - VERSION : '8.1'\\n                - CODENAME : 'jessie'\\n                - ARCHS : 'amd64 i386 source'\\n                - COMPONENTS : 'main'\\n                - DESCRIPTION : 'SaltStack Debian package repo'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    \"\n    dflts_dict = {'OPTIONS': ('I', '', 'processed by _get_repo_options_env'), 'ORIGIN': ('O', 'Origin', 'SaltStack'), 'LABEL': ('O', 'Label', 'salt_debian'), 'SUITE': ('O', 'Suite', 'stable'), 'VERSION': ('O', 'Version', '9.0'), 'CODENAME': ('M', 'Codename', 'stretch'), 'ARCHS': ('M', 'Architectures', 'i386 amd64 source'), 'COMPONENTS': ('M', 'Components', 'main'), 'DESCRIPTION': ('O', 'Description', 'SaltStack debian package repo')}\n    env_dists = ''\n    codename = ''\n    dflts_keys = list(dflts_dict.keys())\n    if env is None:\n        for (key, value) in dflts_dict.items():\n            if dflts_dict[key][0] == 'M':\n                env_dists += '{}: {}\\n'.format(dflts_dict[key][1], dflts_dict[key][2])\n                if key == 'CODENAME':\n                    codename = dflts_dict[key][2]\n        return (codename, env_dists)\n    if not isinstance(env, dict):\n        raise SaltInvocationError(\"'env' must be a Python dictionary\")\n    env_man_seen = []\n    for (key, value) in env.items():\n        if key in dflts_keys:\n            if dflts_dict[key][0] == 'M':\n                env_man_seen.append(key)\n                if key == 'CODENAME':\n                    codename = value\n            if dflts_dict[key][0] != 'I':\n                env_dists += '{}: {}\\n'.format(dflts_dict[key][1], value)\n        else:\n            env_dists += '{}: {}\\n'.format(key, value)\n    env_keys = list(env.keys())\n    for key in env_keys:\n        if key in dflts_keys and dflts_dict[key][0] == 'M' and (key not in env_man_seen):\n            env_dists += '{}: {}\\n'.format(dflts_dict[key][1], dflts_dict[key][2])\n            if key == 'CODENAME':\n                codename = value\n    return (codename, env_dists)",
            "def _get_repo_dists_env(env):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Get repo environment overrides dictionary to use in repo distributions process\\n\\n    env\\n        A dictionary of variables to define the repository distributions\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                - ORIGIN : 'jessie'\\n                - LABEL : 'salt debian'\\n                - SUITE : 'main'\\n                - VERSION : '8.1'\\n                - CODENAME : 'jessie'\\n                - ARCHS : 'amd64 i386 source'\\n                - COMPONENTS : 'main'\\n                - DESCRIPTION : 'SaltStack Debian package repo'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    \"\n    dflts_dict = {'OPTIONS': ('I', '', 'processed by _get_repo_options_env'), 'ORIGIN': ('O', 'Origin', 'SaltStack'), 'LABEL': ('O', 'Label', 'salt_debian'), 'SUITE': ('O', 'Suite', 'stable'), 'VERSION': ('O', 'Version', '9.0'), 'CODENAME': ('M', 'Codename', 'stretch'), 'ARCHS': ('M', 'Architectures', 'i386 amd64 source'), 'COMPONENTS': ('M', 'Components', 'main'), 'DESCRIPTION': ('O', 'Description', 'SaltStack debian package repo')}\n    env_dists = ''\n    codename = ''\n    dflts_keys = list(dflts_dict.keys())\n    if env is None:\n        for (key, value) in dflts_dict.items():\n            if dflts_dict[key][0] == 'M':\n                env_dists += '{}: {}\\n'.format(dflts_dict[key][1], dflts_dict[key][2])\n                if key == 'CODENAME':\n                    codename = dflts_dict[key][2]\n        return (codename, env_dists)\n    if not isinstance(env, dict):\n        raise SaltInvocationError(\"'env' must be a Python dictionary\")\n    env_man_seen = []\n    for (key, value) in env.items():\n        if key in dflts_keys:\n            if dflts_dict[key][0] == 'M':\n                env_man_seen.append(key)\n                if key == 'CODENAME':\n                    codename = value\n            if dflts_dict[key][0] != 'I':\n                env_dists += '{}: {}\\n'.format(dflts_dict[key][1], value)\n        else:\n            env_dists += '{}: {}\\n'.format(key, value)\n    env_keys = list(env.keys())\n    for key in env_keys:\n        if key in dflts_keys and dflts_dict[key][0] == 'M' and (key not in env_man_seen):\n            env_dists += '{}: {}\\n'.format(dflts_dict[key][1], dflts_dict[key][2])\n            if key == 'CODENAME':\n                codename = value\n    return (codename, env_dists)",
            "def _get_repo_dists_env(env):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Get repo environment overrides dictionary to use in repo distributions process\\n\\n    env\\n        A dictionary of variables to define the repository distributions\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                - ORIGIN : 'jessie'\\n                - LABEL : 'salt debian'\\n                - SUITE : 'main'\\n                - VERSION : '8.1'\\n                - CODENAME : 'jessie'\\n                - ARCHS : 'amd64 i386 source'\\n                - COMPONENTS : 'main'\\n                - DESCRIPTION : 'SaltStack Debian package repo'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    \"\n    dflts_dict = {'OPTIONS': ('I', '', 'processed by _get_repo_options_env'), 'ORIGIN': ('O', 'Origin', 'SaltStack'), 'LABEL': ('O', 'Label', 'salt_debian'), 'SUITE': ('O', 'Suite', 'stable'), 'VERSION': ('O', 'Version', '9.0'), 'CODENAME': ('M', 'Codename', 'stretch'), 'ARCHS': ('M', 'Architectures', 'i386 amd64 source'), 'COMPONENTS': ('M', 'Components', 'main'), 'DESCRIPTION': ('O', 'Description', 'SaltStack debian package repo')}\n    env_dists = ''\n    codename = ''\n    dflts_keys = list(dflts_dict.keys())\n    if env is None:\n        for (key, value) in dflts_dict.items():\n            if dflts_dict[key][0] == 'M':\n                env_dists += '{}: {}\\n'.format(dflts_dict[key][1], dflts_dict[key][2])\n                if key == 'CODENAME':\n                    codename = dflts_dict[key][2]\n        return (codename, env_dists)\n    if not isinstance(env, dict):\n        raise SaltInvocationError(\"'env' must be a Python dictionary\")\n    env_man_seen = []\n    for (key, value) in env.items():\n        if key in dflts_keys:\n            if dflts_dict[key][0] == 'M':\n                env_man_seen.append(key)\n                if key == 'CODENAME':\n                    codename = value\n            if dflts_dict[key][0] != 'I':\n                env_dists += '{}: {}\\n'.format(dflts_dict[key][1], value)\n        else:\n            env_dists += '{}: {}\\n'.format(key, value)\n    env_keys = list(env.keys())\n    for key in env_keys:\n        if key in dflts_keys and dflts_dict[key][0] == 'M' and (key not in env_man_seen):\n            env_dists += '{}: {}\\n'.format(dflts_dict[key][1], dflts_dict[key][2])\n            if key == 'CODENAME':\n                codename = value\n    return (codename, env_dists)",
            "def _get_repo_dists_env(env):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Get repo environment overrides dictionary to use in repo distributions process\\n\\n    env\\n        A dictionary of variables to define the repository distributions\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                - ORIGIN : 'jessie'\\n                - LABEL : 'salt debian'\\n                - SUITE : 'main'\\n                - VERSION : '8.1'\\n                - CODENAME : 'jessie'\\n                - ARCHS : 'amd64 i386 source'\\n                - COMPONENTS : 'main'\\n                - DESCRIPTION : 'SaltStack Debian package repo'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    \"\n    dflts_dict = {'OPTIONS': ('I', '', 'processed by _get_repo_options_env'), 'ORIGIN': ('O', 'Origin', 'SaltStack'), 'LABEL': ('O', 'Label', 'salt_debian'), 'SUITE': ('O', 'Suite', 'stable'), 'VERSION': ('O', 'Version', '9.0'), 'CODENAME': ('M', 'Codename', 'stretch'), 'ARCHS': ('M', 'Architectures', 'i386 amd64 source'), 'COMPONENTS': ('M', 'Components', 'main'), 'DESCRIPTION': ('O', 'Description', 'SaltStack debian package repo')}\n    env_dists = ''\n    codename = ''\n    dflts_keys = list(dflts_dict.keys())\n    if env is None:\n        for (key, value) in dflts_dict.items():\n            if dflts_dict[key][0] == 'M':\n                env_dists += '{}: {}\\n'.format(dflts_dict[key][1], dflts_dict[key][2])\n                if key == 'CODENAME':\n                    codename = dflts_dict[key][2]\n        return (codename, env_dists)\n    if not isinstance(env, dict):\n        raise SaltInvocationError(\"'env' must be a Python dictionary\")\n    env_man_seen = []\n    for (key, value) in env.items():\n        if key in dflts_keys:\n            if dflts_dict[key][0] == 'M':\n                env_man_seen.append(key)\n                if key == 'CODENAME':\n                    codename = value\n            if dflts_dict[key][0] != 'I':\n                env_dists += '{}: {}\\n'.format(dflts_dict[key][1], value)\n        else:\n            env_dists += '{}: {}\\n'.format(key, value)\n    env_keys = list(env.keys())\n    for key in env_keys:\n        if key in dflts_keys and dflts_dict[key][0] == 'M' and (key not in env_man_seen):\n            env_dists += '{}: {}\\n'.format(dflts_dict[key][1], dflts_dict[key][2])\n            if key == 'CODENAME':\n                codename = value\n    return (codename, env_dists)",
            "def _get_repo_dists_env(env):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Get repo environment overrides dictionary to use in repo distributions process\\n\\n    env\\n        A dictionary of variables to define the repository distributions\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                - ORIGIN : 'jessie'\\n                - LABEL : 'salt debian'\\n                - SUITE : 'main'\\n                - VERSION : '8.1'\\n                - CODENAME : 'jessie'\\n                - ARCHS : 'amd64 i386 source'\\n                - COMPONENTS : 'main'\\n                - DESCRIPTION : 'SaltStack Debian package repo'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    \"\n    dflts_dict = {'OPTIONS': ('I', '', 'processed by _get_repo_options_env'), 'ORIGIN': ('O', 'Origin', 'SaltStack'), 'LABEL': ('O', 'Label', 'salt_debian'), 'SUITE': ('O', 'Suite', 'stable'), 'VERSION': ('O', 'Version', '9.0'), 'CODENAME': ('M', 'Codename', 'stretch'), 'ARCHS': ('M', 'Architectures', 'i386 amd64 source'), 'COMPONENTS': ('M', 'Components', 'main'), 'DESCRIPTION': ('O', 'Description', 'SaltStack debian package repo')}\n    env_dists = ''\n    codename = ''\n    dflts_keys = list(dflts_dict.keys())\n    if env is None:\n        for (key, value) in dflts_dict.items():\n            if dflts_dict[key][0] == 'M':\n                env_dists += '{}: {}\\n'.format(dflts_dict[key][1], dflts_dict[key][2])\n                if key == 'CODENAME':\n                    codename = dflts_dict[key][2]\n        return (codename, env_dists)\n    if not isinstance(env, dict):\n        raise SaltInvocationError(\"'env' must be a Python dictionary\")\n    env_man_seen = []\n    for (key, value) in env.items():\n        if key in dflts_keys:\n            if dflts_dict[key][0] == 'M':\n                env_man_seen.append(key)\n                if key == 'CODENAME':\n                    codename = value\n            if dflts_dict[key][0] != 'I':\n                env_dists += '{}: {}\\n'.format(dflts_dict[key][1], value)\n        else:\n            env_dists += '{}: {}\\n'.format(key, value)\n    env_keys = list(env.keys())\n    for key in env_keys:\n        if key in dflts_keys and dflts_dict[key][0] == 'M' and (key not in env_man_seen):\n            env_dists += '{}: {}\\n'.format(dflts_dict[key][1], dflts_dict[key][2])\n            if key == 'CODENAME':\n                codename = value\n    return (codename, env_dists)"
        ]
    },
    {
        "func_name": "_create_pbuilders",
        "original": "def _create_pbuilders(env, runas='root'):\n    \"\"\"\n    Create the .pbuilder family of files in user's home directory\n\n    env\n        A list  or dictionary of environment variables to be set prior to execution.\n        Example:\n\n        .. code-block:: yaml\n\n            - env:\n                - DEB_BUILD_OPTIONS: 'nocheck'\n\n        .. warning::\n\n            The above illustrates a common PyYAML pitfall, that **yes**,\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\n            boolean ``True`` and ``False`` values, and must be enclosed in\n            quotes to be used as strings. More info on this (and other) PyYAML\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\n\n    runas : root\n        .. versionadded:: 2019.2.1\n\n        User to create the files and directories\n\n        .. note::\n\n            Ensure the user has correct permissions to any files and\n            directories which are to be utilized.\n    \"\"\"\n    home = os.path.expanduser('~{}'.format(runas))\n    pbuilderrc = os.path.join(home, '.pbuilderrc')\n    if not os.path.isfile(pbuilderrc):\n        raise SaltInvocationError('pbuilderrc environment is incorrectly setup')\n    env_overrides = _get_build_env(env)\n    if env_overrides and (not env_overrides.isspace()):\n        with salt.utils.files.fopen(pbuilderrc, 'a') as fow:\n            fow.write(salt.utils.stringutils.to_str(env_overrides))\n    cmd = 'chown {0}:{0} {1}'.format(runas, pbuilderrc)\n    retrc = __salt__['cmd.retcode'](cmd, runas='root')\n    if retrc != 0:\n        raise SaltInvocationError(\"Create pbuilderrc in home directory failed with return error '{}', check logs for further details\".format(retrc))",
        "mutated": [
            "def _create_pbuilders(env, runas='root'):\n    if False:\n        i = 10\n    \"\\n    Create the .pbuilder family of files in user's home directory\\n\\n    env\\n        A list  or dictionary of environment variables to be set prior to execution.\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                - DEB_BUILD_OPTIONS: 'nocheck'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    runas : root\\n        .. versionadded:: 2019.2.1\\n\\n        User to create the files and directories\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n    \"\n    home = os.path.expanduser('~{}'.format(runas))\n    pbuilderrc = os.path.join(home, '.pbuilderrc')\n    if not os.path.isfile(pbuilderrc):\n        raise SaltInvocationError('pbuilderrc environment is incorrectly setup')\n    env_overrides = _get_build_env(env)\n    if env_overrides and (not env_overrides.isspace()):\n        with salt.utils.files.fopen(pbuilderrc, 'a') as fow:\n            fow.write(salt.utils.stringutils.to_str(env_overrides))\n    cmd = 'chown {0}:{0} {1}'.format(runas, pbuilderrc)\n    retrc = __salt__['cmd.retcode'](cmd, runas='root')\n    if retrc != 0:\n        raise SaltInvocationError(\"Create pbuilderrc in home directory failed with return error '{}', check logs for further details\".format(retrc))",
            "def _create_pbuilders(env, runas='root'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Create the .pbuilder family of files in user's home directory\\n\\n    env\\n        A list  or dictionary of environment variables to be set prior to execution.\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                - DEB_BUILD_OPTIONS: 'nocheck'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    runas : root\\n        .. versionadded:: 2019.2.1\\n\\n        User to create the files and directories\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n    \"\n    home = os.path.expanduser('~{}'.format(runas))\n    pbuilderrc = os.path.join(home, '.pbuilderrc')\n    if not os.path.isfile(pbuilderrc):\n        raise SaltInvocationError('pbuilderrc environment is incorrectly setup')\n    env_overrides = _get_build_env(env)\n    if env_overrides and (not env_overrides.isspace()):\n        with salt.utils.files.fopen(pbuilderrc, 'a') as fow:\n            fow.write(salt.utils.stringutils.to_str(env_overrides))\n    cmd = 'chown {0}:{0} {1}'.format(runas, pbuilderrc)\n    retrc = __salt__['cmd.retcode'](cmd, runas='root')\n    if retrc != 0:\n        raise SaltInvocationError(\"Create pbuilderrc in home directory failed with return error '{}', check logs for further details\".format(retrc))",
            "def _create_pbuilders(env, runas='root'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Create the .pbuilder family of files in user's home directory\\n\\n    env\\n        A list  or dictionary of environment variables to be set prior to execution.\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                - DEB_BUILD_OPTIONS: 'nocheck'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    runas : root\\n        .. versionadded:: 2019.2.1\\n\\n        User to create the files and directories\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n    \"\n    home = os.path.expanduser('~{}'.format(runas))\n    pbuilderrc = os.path.join(home, '.pbuilderrc')\n    if not os.path.isfile(pbuilderrc):\n        raise SaltInvocationError('pbuilderrc environment is incorrectly setup')\n    env_overrides = _get_build_env(env)\n    if env_overrides and (not env_overrides.isspace()):\n        with salt.utils.files.fopen(pbuilderrc, 'a') as fow:\n            fow.write(salt.utils.stringutils.to_str(env_overrides))\n    cmd = 'chown {0}:{0} {1}'.format(runas, pbuilderrc)\n    retrc = __salt__['cmd.retcode'](cmd, runas='root')\n    if retrc != 0:\n        raise SaltInvocationError(\"Create pbuilderrc in home directory failed with return error '{}', check logs for further details\".format(retrc))",
            "def _create_pbuilders(env, runas='root'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Create the .pbuilder family of files in user's home directory\\n\\n    env\\n        A list  or dictionary of environment variables to be set prior to execution.\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                - DEB_BUILD_OPTIONS: 'nocheck'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    runas : root\\n        .. versionadded:: 2019.2.1\\n\\n        User to create the files and directories\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n    \"\n    home = os.path.expanduser('~{}'.format(runas))\n    pbuilderrc = os.path.join(home, '.pbuilderrc')\n    if not os.path.isfile(pbuilderrc):\n        raise SaltInvocationError('pbuilderrc environment is incorrectly setup')\n    env_overrides = _get_build_env(env)\n    if env_overrides and (not env_overrides.isspace()):\n        with salt.utils.files.fopen(pbuilderrc, 'a') as fow:\n            fow.write(salt.utils.stringutils.to_str(env_overrides))\n    cmd = 'chown {0}:{0} {1}'.format(runas, pbuilderrc)\n    retrc = __salt__['cmd.retcode'](cmd, runas='root')\n    if retrc != 0:\n        raise SaltInvocationError(\"Create pbuilderrc in home directory failed with return error '{}', check logs for further details\".format(retrc))",
            "def _create_pbuilders(env, runas='root'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Create the .pbuilder family of files in user's home directory\\n\\n    env\\n        A list  or dictionary of environment variables to be set prior to execution.\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                - DEB_BUILD_OPTIONS: 'nocheck'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    runas : root\\n        .. versionadded:: 2019.2.1\\n\\n        User to create the files and directories\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n    \"\n    home = os.path.expanduser('~{}'.format(runas))\n    pbuilderrc = os.path.join(home, '.pbuilderrc')\n    if not os.path.isfile(pbuilderrc):\n        raise SaltInvocationError('pbuilderrc environment is incorrectly setup')\n    env_overrides = _get_build_env(env)\n    if env_overrides and (not env_overrides.isspace()):\n        with salt.utils.files.fopen(pbuilderrc, 'a') as fow:\n            fow.write(salt.utils.stringutils.to_str(env_overrides))\n    cmd = 'chown {0}:{0} {1}'.format(runas, pbuilderrc)\n    retrc = __salt__['cmd.retcode'](cmd, runas='root')\n    if retrc != 0:\n        raise SaltInvocationError(\"Create pbuilderrc in home directory failed with return error '{}', check logs for further details\".format(retrc))"
        ]
    },
    {
        "func_name": "_mk_tree",
        "original": "def _mk_tree():\n    \"\"\"\n    Create the debian build area\n    \"\"\"\n    basedir = tempfile.mkdtemp()\n    return basedir",
        "mutated": [
            "def _mk_tree():\n    if False:\n        i = 10\n    '\\n    Create the debian build area\\n    '\n    basedir = tempfile.mkdtemp()\n    return basedir",
            "def _mk_tree():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Create the debian build area\\n    '\n    basedir = tempfile.mkdtemp()\n    return basedir",
            "def _mk_tree():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Create the debian build area\\n    '\n    basedir = tempfile.mkdtemp()\n    return basedir",
            "def _mk_tree():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Create the debian build area\\n    '\n    basedir = tempfile.mkdtemp()\n    return basedir",
            "def _mk_tree():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Create the debian build area\\n    '\n    basedir = tempfile.mkdtemp()\n    return basedir"
        ]
    },
    {
        "func_name": "_get_spec",
        "original": "def _get_spec(tree_base, spec, saltenv='base'):\n    \"\"\"\n    Get the spec file (tarball of the debian sub-dir to use)\n    and place it in build area\n\n    \"\"\"\n    spec_tgt = os.path.basename(spec)\n    dest = os.path.join(tree_base, spec_tgt)\n    return __salt__['cp.get_url'](spec, dest, saltenv=saltenv)",
        "mutated": [
            "def _get_spec(tree_base, spec, saltenv='base'):\n    if False:\n        i = 10\n    '\\n    Get the spec file (tarball of the debian sub-dir to use)\\n    and place it in build area\\n\\n    '\n    spec_tgt = os.path.basename(spec)\n    dest = os.path.join(tree_base, spec_tgt)\n    return __salt__['cp.get_url'](spec, dest, saltenv=saltenv)",
            "def _get_spec(tree_base, spec, saltenv='base'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Get the spec file (tarball of the debian sub-dir to use)\\n    and place it in build area\\n\\n    '\n    spec_tgt = os.path.basename(spec)\n    dest = os.path.join(tree_base, spec_tgt)\n    return __salt__['cp.get_url'](spec, dest, saltenv=saltenv)",
            "def _get_spec(tree_base, spec, saltenv='base'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Get the spec file (tarball of the debian sub-dir to use)\\n    and place it in build area\\n\\n    '\n    spec_tgt = os.path.basename(spec)\n    dest = os.path.join(tree_base, spec_tgt)\n    return __salt__['cp.get_url'](spec, dest, saltenv=saltenv)",
            "def _get_spec(tree_base, spec, saltenv='base'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Get the spec file (tarball of the debian sub-dir to use)\\n    and place it in build area\\n\\n    '\n    spec_tgt = os.path.basename(spec)\n    dest = os.path.join(tree_base, spec_tgt)\n    return __salt__['cp.get_url'](spec, dest, saltenv=saltenv)",
            "def _get_spec(tree_base, spec, saltenv='base'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Get the spec file (tarball of the debian sub-dir to use)\\n    and place it in build area\\n\\n    '\n    spec_tgt = os.path.basename(spec)\n    dest = os.path.join(tree_base, spec_tgt)\n    return __salt__['cp.get_url'](spec, dest, saltenv=saltenv)"
        ]
    },
    {
        "func_name": "_get_src",
        "original": "def _get_src(tree_base, source, saltenv='base'):\n    \"\"\"\n    Get the named sources and place them into the tree_base\n    \"\"\"\n    parsed = urllib.parse.urlparse(source)\n    sbase = os.path.basename(source)\n    dest = os.path.join(tree_base, sbase)\n    if parsed.scheme:\n        __salt__['cp.get_url'](source, dest, saltenv=saltenv)\n    else:\n        shutil.copy(source, dest)",
        "mutated": [
            "def _get_src(tree_base, source, saltenv='base'):\n    if False:\n        i = 10\n    '\\n    Get the named sources and place them into the tree_base\\n    '\n    parsed = urllib.parse.urlparse(source)\n    sbase = os.path.basename(source)\n    dest = os.path.join(tree_base, sbase)\n    if parsed.scheme:\n        __salt__['cp.get_url'](source, dest, saltenv=saltenv)\n    else:\n        shutil.copy(source, dest)",
            "def _get_src(tree_base, source, saltenv='base'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Get the named sources and place them into the tree_base\\n    '\n    parsed = urllib.parse.urlparse(source)\n    sbase = os.path.basename(source)\n    dest = os.path.join(tree_base, sbase)\n    if parsed.scheme:\n        __salt__['cp.get_url'](source, dest, saltenv=saltenv)\n    else:\n        shutil.copy(source, dest)",
            "def _get_src(tree_base, source, saltenv='base'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Get the named sources and place them into the tree_base\\n    '\n    parsed = urllib.parse.urlparse(source)\n    sbase = os.path.basename(source)\n    dest = os.path.join(tree_base, sbase)\n    if parsed.scheme:\n        __salt__['cp.get_url'](source, dest, saltenv=saltenv)\n    else:\n        shutil.copy(source, dest)",
            "def _get_src(tree_base, source, saltenv='base'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Get the named sources and place them into the tree_base\\n    '\n    parsed = urllib.parse.urlparse(source)\n    sbase = os.path.basename(source)\n    dest = os.path.join(tree_base, sbase)\n    if parsed.scheme:\n        __salt__['cp.get_url'](source, dest, saltenv=saltenv)\n    else:\n        shutil.copy(source, dest)",
            "def _get_src(tree_base, source, saltenv='base'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Get the named sources and place them into the tree_base\\n    '\n    parsed = urllib.parse.urlparse(source)\n    sbase = os.path.basename(source)\n    dest = os.path.join(tree_base, sbase)\n    if parsed.scheme:\n        __salt__['cp.get_url'](source, dest, saltenv=saltenv)\n    else:\n        shutil.copy(source, dest)"
        ]
    },
    {
        "func_name": "make_src_pkg",
        "original": "def make_src_pkg(dest_dir, spec, sources, env=None, saltenv='base', runas='root'):\n    \"\"\"\n    Create a platform specific source package from the given platform spec/control file and sources\n\n    CLI Example:\n\n    **Debian**\n\n    .. code-block:: bash\n\n        salt '*' pkgbuild.make_src_pkg /var/www/html/\n                https://raw.githubusercontent.com/saltstack/libnacl/master/pkg/deb/python-libnacl.control.tar.xz\n                https://pypi.python.org/packages/source/l/libnacl/libnacl-1.3.5.tar.gz\n\n    This example command should build the libnacl SOURCE package and place it in\n    /var/www/html/ on the minion\n\n    dest_dir\n        Absolute path for directory to write source package\n\n    spec\n        Absolute path to spec file or equivalent\n\n    sources\n        Absolute path to source files to build source package from\n\n    env : None\n        A list  or dictionary of environment variables to be set prior to execution.\n        Example:\n\n        .. code-block:: yaml\n\n            - env:\n                - DEB_BUILD_OPTIONS: 'nocheck'\n\n        .. warning::\n\n            The above illustrates a common PyYAML pitfall, that **yes**,\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\n            boolean ``True`` and ``False`` values, and must be enclosed in\n            quotes to be used as strings. More info on this (and other) PyYAML\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\n\n    saltenv: base\n\n        Salt environment variables\n\n\n    runas : root\n        .. versionadded:: 2019.2.1\n\n        User to create the files and directories\n\n        .. note::\n\n            Ensure the user has correct permissions to any files and\n            directories which are to be utilized.\n    \"\"\"\n    _create_pbuilders(env, runas)\n    tree_base = _mk_tree()\n    ret = []\n    if not os.path.isdir(dest_dir):\n        os.makedirs(dest_dir)\n    root_user = 'root'\n    retrc = 0\n    cmd = 'chown {0}:{0} {1}'.format(runas, tree_base)\n    retrc = __salt__['cmd.retcode'](cmd, runas='root')\n    if retrc != 0:\n        raise SaltInvocationError(\"make_src_pkg ensuring tree_base '{}' ownership failed with return error '{}', check logs for further details\".format(tree_base, retrc))\n    cmd = 'chown {0}:{0} {1}'.format(runas, dest_dir)\n    retrc = __salt__['cmd.retcode'](cmd, runas=root_user)\n    if retrc != 0:\n        raise SaltInvocationError(\"make_src_pkg ensuring dest_dir '{}' ownership failed with return error '{}', check logs for further details\".format(dest_dir, retrc))\n    spec_pathfile = _get_spec(tree_base, spec, saltenv)\n    if isinstance(sources, str):\n        sources = sources.split(',')\n    for src in sources:\n        _get_src(tree_base, src, saltenv)\n    if spec_pathfile.endswith('.dsc'):\n        for efile in os.listdir(tree_base):\n            full = os.path.join(tree_base, efile)\n            trgt = os.path.join(dest_dir, efile)\n            shutil.copy(full, trgt)\n            ret.append(trgt)\n        return ret\n    salttarball = None\n    for afile in os.listdir(tree_base):\n        if afile.startswith('salt-') and afile.endswith('.tar.gz'):\n            salttarball = afile\n            break\n    else:\n        return ret\n    frontname = salttarball.split('.tar.gz')\n    salttar_name = frontname[0]\n    k = salttar_name.rfind('-')\n    debname = salttar_name[:k] + '_' + salttar_name[k + 1:]\n    debname += '+ds'\n    debname_orig = debname + '.orig.tar.gz'\n    abspath_debname = os.path.join(tree_base, debname)\n    cmd = 'tar -xvzf {}'.format(salttarball)\n    retrc = __salt__['cmd.retcode'](cmd, cwd=tree_base, runas=root_user)\n    cmd = 'mv {} {}'.format(salttar_name, debname)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=tree_base, runas=root_user)\n    cmd = 'tar -cvzf {} {}'.format(os.path.join(tree_base, debname_orig), debname)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=tree_base, runas=root_user)\n    cmd = 'rm -f {}'.format(salttarball)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=tree_base, runas=root_user, env=env)\n    cmd = 'cp {}  {}'.format(spec_pathfile, abspath_debname)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=abspath_debname, runas=root_user)\n    cmd = 'tar -xvJf {}'.format(spec_pathfile)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=abspath_debname, runas=root_user, env=env)\n    cmd = 'rm -f {}'.format(os.path.basename(spec_pathfile))\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=abspath_debname, runas=root_user)\n    cmd = 'debuild -S -uc -us -sa'\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=abspath_debname, runas=root_user, python_shell=True, env=env)\n    cmd = 'rm -fR {}'.format(abspath_debname)\n    retrc |= __salt__['cmd.retcode'](cmd, runas=root_user)\n    if retrc != 0:\n        raise SaltInvocationError('Make source package for destination directory {}, spec {}, sources {}, failed with return error {}, check logs for further details'.format(dest_dir, spec, sources, retrc))\n    for dfile in os.listdir(tree_base):\n        if not dfile.endswith('.build'):\n            full = os.path.join(tree_base, dfile)\n            trgt = os.path.join(dest_dir, dfile)\n            shutil.copy(full, trgt)\n            ret.append(trgt)\n    return ret",
        "mutated": [
            "def make_src_pkg(dest_dir, spec, sources, env=None, saltenv='base', runas='root'):\n    if False:\n        i = 10\n    \"\\n    Create a platform specific source package from the given platform spec/control file and sources\\n\\n    CLI Example:\\n\\n    **Debian**\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkgbuild.make_src_pkg /var/www/html/\\n                https://raw.githubusercontent.com/saltstack/libnacl/master/pkg/deb/python-libnacl.control.tar.xz\\n                https://pypi.python.org/packages/source/l/libnacl/libnacl-1.3.5.tar.gz\\n\\n    This example command should build the libnacl SOURCE package and place it in\\n    /var/www/html/ on the minion\\n\\n    dest_dir\\n        Absolute path for directory to write source package\\n\\n    spec\\n        Absolute path to spec file or equivalent\\n\\n    sources\\n        Absolute path to source files to build source package from\\n\\n    env : None\\n        A list  or dictionary of environment variables to be set prior to execution.\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                - DEB_BUILD_OPTIONS: 'nocheck'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    saltenv: base\\n\\n        Salt environment variables\\n\\n\\n    runas : root\\n        .. versionadded:: 2019.2.1\\n\\n        User to create the files and directories\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n    \"\n    _create_pbuilders(env, runas)\n    tree_base = _mk_tree()\n    ret = []\n    if not os.path.isdir(dest_dir):\n        os.makedirs(dest_dir)\n    root_user = 'root'\n    retrc = 0\n    cmd = 'chown {0}:{0} {1}'.format(runas, tree_base)\n    retrc = __salt__['cmd.retcode'](cmd, runas='root')\n    if retrc != 0:\n        raise SaltInvocationError(\"make_src_pkg ensuring tree_base '{}' ownership failed with return error '{}', check logs for further details\".format(tree_base, retrc))\n    cmd = 'chown {0}:{0} {1}'.format(runas, dest_dir)\n    retrc = __salt__['cmd.retcode'](cmd, runas=root_user)\n    if retrc != 0:\n        raise SaltInvocationError(\"make_src_pkg ensuring dest_dir '{}' ownership failed with return error '{}', check logs for further details\".format(dest_dir, retrc))\n    spec_pathfile = _get_spec(tree_base, spec, saltenv)\n    if isinstance(sources, str):\n        sources = sources.split(',')\n    for src in sources:\n        _get_src(tree_base, src, saltenv)\n    if spec_pathfile.endswith('.dsc'):\n        for efile in os.listdir(tree_base):\n            full = os.path.join(tree_base, efile)\n            trgt = os.path.join(dest_dir, efile)\n            shutil.copy(full, trgt)\n            ret.append(trgt)\n        return ret\n    salttarball = None\n    for afile in os.listdir(tree_base):\n        if afile.startswith('salt-') and afile.endswith('.tar.gz'):\n            salttarball = afile\n            break\n    else:\n        return ret\n    frontname = salttarball.split('.tar.gz')\n    salttar_name = frontname[0]\n    k = salttar_name.rfind('-')\n    debname = salttar_name[:k] + '_' + salttar_name[k + 1:]\n    debname += '+ds'\n    debname_orig = debname + '.orig.tar.gz'\n    abspath_debname = os.path.join(tree_base, debname)\n    cmd = 'tar -xvzf {}'.format(salttarball)\n    retrc = __salt__['cmd.retcode'](cmd, cwd=tree_base, runas=root_user)\n    cmd = 'mv {} {}'.format(salttar_name, debname)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=tree_base, runas=root_user)\n    cmd = 'tar -cvzf {} {}'.format(os.path.join(tree_base, debname_orig), debname)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=tree_base, runas=root_user)\n    cmd = 'rm -f {}'.format(salttarball)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=tree_base, runas=root_user, env=env)\n    cmd = 'cp {}  {}'.format(spec_pathfile, abspath_debname)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=abspath_debname, runas=root_user)\n    cmd = 'tar -xvJf {}'.format(spec_pathfile)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=abspath_debname, runas=root_user, env=env)\n    cmd = 'rm -f {}'.format(os.path.basename(spec_pathfile))\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=abspath_debname, runas=root_user)\n    cmd = 'debuild -S -uc -us -sa'\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=abspath_debname, runas=root_user, python_shell=True, env=env)\n    cmd = 'rm -fR {}'.format(abspath_debname)\n    retrc |= __salt__['cmd.retcode'](cmd, runas=root_user)\n    if retrc != 0:\n        raise SaltInvocationError('Make source package for destination directory {}, spec {}, sources {}, failed with return error {}, check logs for further details'.format(dest_dir, spec, sources, retrc))\n    for dfile in os.listdir(tree_base):\n        if not dfile.endswith('.build'):\n            full = os.path.join(tree_base, dfile)\n            trgt = os.path.join(dest_dir, dfile)\n            shutil.copy(full, trgt)\n            ret.append(trgt)\n    return ret",
            "def make_src_pkg(dest_dir, spec, sources, env=None, saltenv='base', runas='root'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Create a platform specific source package from the given platform spec/control file and sources\\n\\n    CLI Example:\\n\\n    **Debian**\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkgbuild.make_src_pkg /var/www/html/\\n                https://raw.githubusercontent.com/saltstack/libnacl/master/pkg/deb/python-libnacl.control.tar.xz\\n                https://pypi.python.org/packages/source/l/libnacl/libnacl-1.3.5.tar.gz\\n\\n    This example command should build the libnacl SOURCE package and place it in\\n    /var/www/html/ on the minion\\n\\n    dest_dir\\n        Absolute path for directory to write source package\\n\\n    spec\\n        Absolute path to spec file or equivalent\\n\\n    sources\\n        Absolute path to source files to build source package from\\n\\n    env : None\\n        A list  or dictionary of environment variables to be set prior to execution.\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                - DEB_BUILD_OPTIONS: 'nocheck'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    saltenv: base\\n\\n        Salt environment variables\\n\\n\\n    runas : root\\n        .. versionadded:: 2019.2.1\\n\\n        User to create the files and directories\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n    \"\n    _create_pbuilders(env, runas)\n    tree_base = _mk_tree()\n    ret = []\n    if not os.path.isdir(dest_dir):\n        os.makedirs(dest_dir)\n    root_user = 'root'\n    retrc = 0\n    cmd = 'chown {0}:{0} {1}'.format(runas, tree_base)\n    retrc = __salt__['cmd.retcode'](cmd, runas='root')\n    if retrc != 0:\n        raise SaltInvocationError(\"make_src_pkg ensuring tree_base '{}' ownership failed with return error '{}', check logs for further details\".format(tree_base, retrc))\n    cmd = 'chown {0}:{0} {1}'.format(runas, dest_dir)\n    retrc = __salt__['cmd.retcode'](cmd, runas=root_user)\n    if retrc != 0:\n        raise SaltInvocationError(\"make_src_pkg ensuring dest_dir '{}' ownership failed with return error '{}', check logs for further details\".format(dest_dir, retrc))\n    spec_pathfile = _get_spec(tree_base, spec, saltenv)\n    if isinstance(sources, str):\n        sources = sources.split(',')\n    for src in sources:\n        _get_src(tree_base, src, saltenv)\n    if spec_pathfile.endswith('.dsc'):\n        for efile in os.listdir(tree_base):\n            full = os.path.join(tree_base, efile)\n            trgt = os.path.join(dest_dir, efile)\n            shutil.copy(full, trgt)\n            ret.append(trgt)\n        return ret\n    salttarball = None\n    for afile in os.listdir(tree_base):\n        if afile.startswith('salt-') and afile.endswith('.tar.gz'):\n            salttarball = afile\n            break\n    else:\n        return ret\n    frontname = salttarball.split('.tar.gz')\n    salttar_name = frontname[0]\n    k = salttar_name.rfind('-')\n    debname = salttar_name[:k] + '_' + salttar_name[k + 1:]\n    debname += '+ds'\n    debname_orig = debname + '.orig.tar.gz'\n    abspath_debname = os.path.join(tree_base, debname)\n    cmd = 'tar -xvzf {}'.format(salttarball)\n    retrc = __salt__['cmd.retcode'](cmd, cwd=tree_base, runas=root_user)\n    cmd = 'mv {} {}'.format(salttar_name, debname)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=tree_base, runas=root_user)\n    cmd = 'tar -cvzf {} {}'.format(os.path.join(tree_base, debname_orig), debname)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=tree_base, runas=root_user)\n    cmd = 'rm -f {}'.format(salttarball)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=tree_base, runas=root_user, env=env)\n    cmd = 'cp {}  {}'.format(spec_pathfile, abspath_debname)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=abspath_debname, runas=root_user)\n    cmd = 'tar -xvJf {}'.format(spec_pathfile)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=abspath_debname, runas=root_user, env=env)\n    cmd = 'rm -f {}'.format(os.path.basename(spec_pathfile))\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=abspath_debname, runas=root_user)\n    cmd = 'debuild -S -uc -us -sa'\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=abspath_debname, runas=root_user, python_shell=True, env=env)\n    cmd = 'rm -fR {}'.format(abspath_debname)\n    retrc |= __salt__['cmd.retcode'](cmd, runas=root_user)\n    if retrc != 0:\n        raise SaltInvocationError('Make source package for destination directory {}, spec {}, sources {}, failed with return error {}, check logs for further details'.format(dest_dir, spec, sources, retrc))\n    for dfile in os.listdir(tree_base):\n        if not dfile.endswith('.build'):\n            full = os.path.join(tree_base, dfile)\n            trgt = os.path.join(dest_dir, dfile)\n            shutil.copy(full, trgt)\n            ret.append(trgt)\n    return ret",
            "def make_src_pkg(dest_dir, spec, sources, env=None, saltenv='base', runas='root'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Create a platform specific source package from the given platform spec/control file and sources\\n\\n    CLI Example:\\n\\n    **Debian**\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkgbuild.make_src_pkg /var/www/html/\\n                https://raw.githubusercontent.com/saltstack/libnacl/master/pkg/deb/python-libnacl.control.tar.xz\\n                https://pypi.python.org/packages/source/l/libnacl/libnacl-1.3.5.tar.gz\\n\\n    This example command should build the libnacl SOURCE package and place it in\\n    /var/www/html/ on the minion\\n\\n    dest_dir\\n        Absolute path for directory to write source package\\n\\n    spec\\n        Absolute path to spec file or equivalent\\n\\n    sources\\n        Absolute path to source files to build source package from\\n\\n    env : None\\n        A list  or dictionary of environment variables to be set prior to execution.\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                - DEB_BUILD_OPTIONS: 'nocheck'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    saltenv: base\\n\\n        Salt environment variables\\n\\n\\n    runas : root\\n        .. versionadded:: 2019.2.1\\n\\n        User to create the files and directories\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n    \"\n    _create_pbuilders(env, runas)\n    tree_base = _mk_tree()\n    ret = []\n    if not os.path.isdir(dest_dir):\n        os.makedirs(dest_dir)\n    root_user = 'root'\n    retrc = 0\n    cmd = 'chown {0}:{0} {1}'.format(runas, tree_base)\n    retrc = __salt__['cmd.retcode'](cmd, runas='root')\n    if retrc != 0:\n        raise SaltInvocationError(\"make_src_pkg ensuring tree_base '{}' ownership failed with return error '{}', check logs for further details\".format(tree_base, retrc))\n    cmd = 'chown {0}:{0} {1}'.format(runas, dest_dir)\n    retrc = __salt__['cmd.retcode'](cmd, runas=root_user)\n    if retrc != 0:\n        raise SaltInvocationError(\"make_src_pkg ensuring dest_dir '{}' ownership failed with return error '{}', check logs for further details\".format(dest_dir, retrc))\n    spec_pathfile = _get_spec(tree_base, spec, saltenv)\n    if isinstance(sources, str):\n        sources = sources.split(',')\n    for src in sources:\n        _get_src(tree_base, src, saltenv)\n    if spec_pathfile.endswith('.dsc'):\n        for efile in os.listdir(tree_base):\n            full = os.path.join(tree_base, efile)\n            trgt = os.path.join(dest_dir, efile)\n            shutil.copy(full, trgt)\n            ret.append(trgt)\n        return ret\n    salttarball = None\n    for afile in os.listdir(tree_base):\n        if afile.startswith('salt-') and afile.endswith('.tar.gz'):\n            salttarball = afile\n            break\n    else:\n        return ret\n    frontname = salttarball.split('.tar.gz')\n    salttar_name = frontname[0]\n    k = salttar_name.rfind('-')\n    debname = salttar_name[:k] + '_' + salttar_name[k + 1:]\n    debname += '+ds'\n    debname_orig = debname + '.orig.tar.gz'\n    abspath_debname = os.path.join(tree_base, debname)\n    cmd = 'tar -xvzf {}'.format(salttarball)\n    retrc = __salt__['cmd.retcode'](cmd, cwd=tree_base, runas=root_user)\n    cmd = 'mv {} {}'.format(salttar_name, debname)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=tree_base, runas=root_user)\n    cmd = 'tar -cvzf {} {}'.format(os.path.join(tree_base, debname_orig), debname)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=tree_base, runas=root_user)\n    cmd = 'rm -f {}'.format(salttarball)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=tree_base, runas=root_user, env=env)\n    cmd = 'cp {}  {}'.format(spec_pathfile, abspath_debname)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=abspath_debname, runas=root_user)\n    cmd = 'tar -xvJf {}'.format(spec_pathfile)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=abspath_debname, runas=root_user, env=env)\n    cmd = 'rm -f {}'.format(os.path.basename(spec_pathfile))\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=abspath_debname, runas=root_user)\n    cmd = 'debuild -S -uc -us -sa'\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=abspath_debname, runas=root_user, python_shell=True, env=env)\n    cmd = 'rm -fR {}'.format(abspath_debname)\n    retrc |= __salt__['cmd.retcode'](cmd, runas=root_user)\n    if retrc != 0:\n        raise SaltInvocationError('Make source package for destination directory {}, spec {}, sources {}, failed with return error {}, check logs for further details'.format(dest_dir, spec, sources, retrc))\n    for dfile in os.listdir(tree_base):\n        if not dfile.endswith('.build'):\n            full = os.path.join(tree_base, dfile)\n            trgt = os.path.join(dest_dir, dfile)\n            shutil.copy(full, trgt)\n            ret.append(trgt)\n    return ret",
            "def make_src_pkg(dest_dir, spec, sources, env=None, saltenv='base', runas='root'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Create a platform specific source package from the given platform spec/control file and sources\\n\\n    CLI Example:\\n\\n    **Debian**\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkgbuild.make_src_pkg /var/www/html/\\n                https://raw.githubusercontent.com/saltstack/libnacl/master/pkg/deb/python-libnacl.control.tar.xz\\n                https://pypi.python.org/packages/source/l/libnacl/libnacl-1.3.5.tar.gz\\n\\n    This example command should build the libnacl SOURCE package and place it in\\n    /var/www/html/ on the minion\\n\\n    dest_dir\\n        Absolute path for directory to write source package\\n\\n    spec\\n        Absolute path to spec file or equivalent\\n\\n    sources\\n        Absolute path to source files to build source package from\\n\\n    env : None\\n        A list  or dictionary of environment variables to be set prior to execution.\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                - DEB_BUILD_OPTIONS: 'nocheck'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    saltenv: base\\n\\n        Salt environment variables\\n\\n\\n    runas : root\\n        .. versionadded:: 2019.2.1\\n\\n        User to create the files and directories\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n    \"\n    _create_pbuilders(env, runas)\n    tree_base = _mk_tree()\n    ret = []\n    if not os.path.isdir(dest_dir):\n        os.makedirs(dest_dir)\n    root_user = 'root'\n    retrc = 0\n    cmd = 'chown {0}:{0} {1}'.format(runas, tree_base)\n    retrc = __salt__['cmd.retcode'](cmd, runas='root')\n    if retrc != 0:\n        raise SaltInvocationError(\"make_src_pkg ensuring tree_base '{}' ownership failed with return error '{}', check logs for further details\".format(tree_base, retrc))\n    cmd = 'chown {0}:{0} {1}'.format(runas, dest_dir)\n    retrc = __salt__['cmd.retcode'](cmd, runas=root_user)\n    if retrc != 0:\n        raise SaltInvocationError(\"make_src_pkg ensuring dest_dir '{}' ownership failed with return error '{}', check logs for further details\".format(dest_dir, retrc))\n    spec_pathfile = _get_spec(tree_base, spec, saltenv)\n    if isinstance(sources, str):\n        sources = sources.split(',')\n    for src in sources:\n        _get_src(tree_base, src, saltenv)\n    if spec_pathfile.endswith('.dsc'):\n        for efile in os.listdir(tree_base):\n            full = os.path.join(tree_base, efile)\n            trgt = os.path.join(dest_dir, efile)\n            shutil.copy(full, trgt)\n            ret.append(trgt)\n        return ret\n    salttarball = None\n    for afile in os.listdir(tree_base):\n        if afile.startswith('salt-') and afile.endswith('.tar.gz'):\n            salttarball = afile\n            break\n    else:\n        return ret\n    frontname = salttarball.split('.tar.gz')\n    salttar_name = frontname[0]\n    k = salttar_name.rfind('-')\n    debname = salttar_name[:k] + '_' + salttar_name[k + 1:]\n    debname += '+ds'\n    debname_orig = debname + '.orig.tar.gz'\n    abspath_debname = os.path.join(tree_base, debname)\n    cmd = 'tar -xvzf {}'.format(salttarball)\n    retrc = __salt__['cmd.retcode'](cmd, cwd=tree_base, runas=root_user)\n    cmd = 'mv {} {}'.format(salttar_name, debname)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=tree_base, runas=root_user)\n    cmd = 'tar -cvzf {} {}'.format(os.path.join(tree_base, debname_orig), debname)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=tree_base, runas=root_user)\n    cmd = 'rm -f {}'.format(salttarball)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=tree_base, runas=root_user, env=env)\n    cmd = 'cp {}  {}'.format(spec_pathfile, abspath_debname)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=abspath_debname, runas=root_user)\n    cmd = 'tar -xvJf {}'.format(spec_pathfile)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=abspath_debname, runas=root_user, env=env)\n    cmd = 'rm -f {}'.format(os.path.basename(spec_pathfile))\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=abspath_debname, runas=root_user)\n    cmd = 'debuild -S -uc -us -sa'\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=abspath_debname, runas=root_user, python_shell=True, env=env)\n    cmd = 'rm -fR {}'.format(abspath_debname)\n    retrc |= __salt__['cmd.retcode'](cmd, runas=root_user)\n    if retrc != 0:\n        raise SaltInvocationError('Make source package for destination directory {}, spec {}, sources {}, failed with return error {}, check logs for further details'.format(dest_dir, spec, sources, retrc))\n    for dfile in os.listdir(tree_base):\n        if not dfile.endswith('.build'):\n            full = os.path.join(tree_base, dfile)\n            trgt = os.path.join(dest_dir, dfile)\n            shutil.copy(full, trgt)\n            ret.append(trgt)\n    return ret",
            "def make_src_pkg(dest_dir, spec, sources, env=None, saltenv='base', runas='root'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Create a platform specific source package from the given platform spec/control file and sources\\n\\n    CLI Example:\\n\\n    **Debian**\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkgbuild.make_src_pkg /var/www/html/\\n                https://raw.githubusercontent.com/saltstack/libnacl/master/pkg/deb/python-libnacl.control.tar.xz\\n                https://pypi.python.org/packages/source/l/libnacl/libnacl-1.3.5.tar.gz\\n\\n    This example command should build the libnacl SOURCE package and place it in\\n    /var/www/html/ on the minion\\n\\n    dest_dir\\n        Absolute path for directory to write source package\\n\\n    spec\\n        Absolute path to spec file or equivalent\\n\\n    sources\\n        Absolute path to source files to build source package from\\n\\n    env : None\\n        A list  or dictionary of environment variables to be set prior to execution.\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                - DEB_BUILD_OPTIONS: 'nocheck'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    saltenv: base\\n\\n        Salt environment variables\\n\\n\\n    runas : root\\n        .. versionadded:: 2019.2.1\\n\\n        User to create the files and directories\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n    \"\n    _create_pbuilders(env, runas)\n    tree_base = _mk_tree()\n    ret = []\n    if not os.path.isdir(dest_dir):\n        os.makedirs(dest_dir)\n    root_user = 'root'\n    retrc = 0\n    cmd = 'chown {0}:{0} {1}'.format(runas, tree_base)\n    retrc = __salt__['cmd.retcode'](cmd, runas='root')\n    if retrc != 0:\n        raise SaltInvocationError(\"make_src_pkg ensuring tree_base '{}' ownership failed with return error '{}', check logs for further details\".format(tree_base, retrc))\n    cmd = 'chown {0}:{0} {1}'.format(runas, dest_dir)\n    retrc = __salt__['cmd.retcode'](cmd, runas=root_user)\n    if retrc != 0:\n        raise SaltInvocationError(\"make_src_pkg ensuring dest_dir '{}' ownership failed with return error '{}', check logs for further details\".format(dest_dir, retrc))\n    spec_pathfile = _get_spec(tree_base, spec, saltenv)\n    if isinstance(sources, str):\n        sources = sources.split(',')\n    for src in sources:\n        _get_src(tree_base, src, saltenv)\n    if spec_pathfile.endswith('.dsc'):\n        for efile in os.listdir(tree_base):\n            full = os.path.join(tree_base, efile)\n            trgt = os.path.join(dest_dir, efile)\n            shutil.copy(full, trgt)\n            ret.append(trgt)\n        return ret\n    salttarball = None\n    for afile in os.listdir(tree_base):\n        if afile.startswith('salt-') and afile.endswith('.tar.gz'):\n            salttarball = afile\n            break\n    else:\n        return ret\n    frontname = salttarball.split('.tar.gz')\n    salttar_name = frontname[0]\n    k = salttar_name.rfind('-')\n    debname = salttar_name[:k] + '_' + salttar_name[k + 1:]\n    debname += '+ds'\n    debname_orig = debname + '.orig.tar.gz'\n    abspath_debname = os.path.join(tree_base, debname)\n    cmd = 'tar -xvzf {}'.format(salttarball)\n    retrc = __salt__['cmd.retcode'](cmd, cwd=tree_base, runas=root_user)\n    cmd = 'mv {} {}'.format(salttar_name, debname)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=tree_base, runas=root_user)\n    cmd = 'tar -cvzf {} {}'.format(os.path.join(tree_base, debname_orig), debname)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=tree_base, runas=root_user)\n    cmd = 'rm -f {}'.format(salttarball)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=tree_base, runas=root_user, env=env)\n    cmd = 'cp {}  {}'.format(spec_pathfile, abspath_debname)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=abspath_debname, runas=root_user)\n    cmd = 'tar -xvJf {}'.format(spec_pathfile)\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=abspath_debname, runas=root_user, env=env)\n    cmd = 'rm -f {}'.format(os.path.basename(spec_pathfile))\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=abspath_debname, runas=root_user)\n    cmd = 'debuild -S -uc -us -sa'\n    retrc |= __salt__['cmd.retcode'](cmd, cwd=abspath_debname, runas=root_user, python_shell=True, env=env)\n    cmd = 'rm -fR {}'.format(abspath_debname)\n    retrc |= __salt__['cmd.retcode'](cmd, runas=root_user)\n    if retrc != 0:\n        raise SaltInvocationError('Make source package for destination directory {}, spec {}, sources {}, failed with return error {}, check logs for further details'.format(dest_dir, spec, sources, retrc))\n    for dfile in os.listdir(tree_base):\n        if not dfile.endswith('.build'):\n            full = os.path.join(tree_base, dfile)\n            trgt = os.path.join(dest_dir, dfile)\n            shutil.copy(full, trgt)\n            ret.append(trgt)\n    return ret"
        ]
    },
    {
        "func_name": "build",
        "original": "def build(runas, tgt, dest_dir, spec, sources, deps, env, template, saltenv='base', log_dir='/var/log/salt/pkgbuild'):\n    \"\"\"\n    Given the package destination directory, the tarball containing debian files (e.g. control)\n    and package sources, use pbuilder to safely build the platform package\n\n    CLI Example:\n\n    **Debian**\n\n    .. code-block:: bash\n\n        salt '*' pkgbuild.make_src_pkg deb-8-x86_64 /var/www/html\n                https://raw.githubusercontent.com/saltstack/libnacl/master/pkg/deb/python-libnacl.control\n                https://pypi.python.org/packages/source/l/libnacl/libnacl-1.3.5.tar.gz\n\n    This example command should build the libnacl package for Debian using pbuilder\n    and place it in /var/www/html/ on the minion\n    \"\"\"\n    ret = {}\n    retrc = 0\n    try:\n        os.makedirs(dest_dir)\n    except OSError as exc:\n        if exc.errno != errno.EEXIST:\n            raise\n    dsc_dir = tempfile.mkdtemp()\n    try:\n        dscs = make_src_pkg(dsc_dir, spec, sources, env, saltenv, runas)\n    except Exception as exc:\n        shutil.rmtree(dsc_dir)\n        log.error(\"Failed to make src package, exception '%s'\", exc)\n        return ret\n    root_user = 'root'\n    if runas != root_user:\n        user_home = os.path.expanduser('~{}'.format(runas))\n        root_home = os.path.expanduser('~root')\n        cmd = 'cp {}/.pbuilderrc {}/'.format(user_home, root_home)\n        retrc = __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n        cmd = 'cp -R {}/.pbuilder-hooks {}/'.format(user_home, root_home)\n        retrc = __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n        if retrc != 0:\n            raise SaltInvocationError(\"build copy pbuilder files from '{}' to '{}' returned error '{}', check logs for further details\".format(user_home, root_home, retrc))\n    cmd = '/usr/sbin/pbuilder --create'\n    retrc = __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n    if retrc != 0:\n        raise SaltInvocationError(\"pbuilder create failed with return error '{}', check logs for further details\".format(retrc))\n    results_dir = '/var/cache/pbuilder/result'\n    cmd = 'rm -fR {}'.format(results_dir)\n    retrc |= __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n    for dsc in dscs:\n        afile = os.path.basename(dsc)\n        os.path.join(dest_dir, afile)\n        if dsc.endswith('.dsc'):\n            dbase = os.path.dirname(dsc)\n            try:\n                cmd = 'chown {0}:{0} -R {1}'.format(runas, dbase)\n                retrc |= __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n                cmd = '/usr/sbin/pbuilder update --override-config'\n                retrc |= __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n                cmd = '/usr/sbin/pbuilder build --debbuildopts \"-sa\" {}'.format(dsc)\n                retrc |= __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n                if retrc != 0:\n                    raise SaltInvocationError('pbuilder build or update failed with return error {}, check logs for further details'.format(retrc))\n                for bfile in os.listdir(results_dir):\n                    if bfile != 'Packages':\n                        full = os.path.join(results_dir, bfile)\n                        bdist = os.path.join(dest_dir, bfile)\n                        shutil.copy(full, bdist)\n                        ret.setdefault('Packages', []).append(bdist)\n            except Exception as exc:\n                log.error(\"Error building from '%s', execption '%s'\", dsc, exc)\n    for pkgzfile in os.listdir(dest_dir):\n        if pkgzfile == 'Packages':\n            pkgzabsfile = os.path.join(dest_dir, pkgzfile)\n            os.remove(pkgzabsfile)\n    cmd = 'chown {0}:{0} -R {1}'.format(runas, dest_dir)\n    __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n    shutil.rmtree(dsc_dir)\n    return ret",
        "mutated": [
            "def build(runas, tgt, dest_dir, spec, sources, deps, env, template, saltenv='base', log_dir='/var/log/salt/pkgbuild'):\n    if False:\n        i = 10\n    \"\\n    Given the package destination directory, the tarball containing debian files (e.g. control)\\n    and package sources, use pbuilder to safely build the platform package\\n\\n    CLI Example:\\n\\n    **Debian**\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkgbuild.make_src_pkg deb-8-x86_64 /var/www/html\\n                https://raw.githubusercontent.com/saltstack/libnacl/master/pkg/deb/python-libnacl.control\\n                https://pypi.python.org/packages/source/l/libnacl/libnacl-1.3.5.tar.gz\\n\\n    This example command should build the libnacl package for Debian using pbuilder\\n    and place it in /var/www/html/ on the minion\\n    \"\n    ret = {}\n    retrc = 0\n    try:\n        os.makedirs(dest_dir)\n    except OSError as exc:\n        if exc.errno != errno.EEXIST:\n            raise\n    dsc_dir = tempfile.mkdtemp()\n    try:\n        dscs = make_src_pkg(dsc_dir, spec, sources, env, saltenv, runas)\n    except Exception as exc:\n        shutil.rmtree(dsc_dir)\n        log.error(\"Failed to make src package, exception '%s'\", exc)\n        return ret\n    root_user = 'root'\n    if runas != root_user:\n        user_home = os.path.expanduser('~{}'.format(runas))\n        root_home = os.path.expanduser('~root')\n        cmd = 'cp {}/.pbuilderrc {}/'.format(user_home, root_home)\n        retrc = __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n        cmd = 'cp -R {}/.pbuilder-hooks {}/'.format(user_home, root_home)\n        retrc = __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n        if retrc != 0:\n            raise SaltInvocationError(\"build copy pbuilder files from '{}' to '{}' returned error '{}', check logs for further details\".format(user_home, root_home, retrc))\n    cmd = '/usr/sbin/pbuilder --create'\n    retrc = __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n    if retrc != 0:\n        raise SaltInvocationError(\"pbuilder create failed with return error '{}', check logs for further details\".format(retrc))\n    results_dir = '/var/cache/pbuilder/result'\n    cmd = 'rm -fR {}'.format(results_dir)\n    retrc |= __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n    for dsc in dscs:\n        afile = os.path.basename(dsc)\n        os.path.join(dest_dir, afile)\n        if dsc.endswith('.dsc'):\n            dbase = os.path.dirname(dsc)\n            try:\n                cmd = 'chown {0}:{0} -R {1}'.format(runas, dbase)\n                retrc |= __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n                cmd = '/usr/sbin/pbuilder update --override-config'\n                retrc |= __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n                cmd = '/usr/sbin/pbuilder build --debbuildopts \"-sa\" {}'.format(dsc)\n                retrc |= __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n                if retrc != 0:\n                    raise SaltInvocationError('pbuilder build or update failed with return error {}, check logs for further details'.format(retrc))\n                for bfile in os.listdir(results_dir):\n                    if bfile != 'Packages':\n                        full = os.path.join(results_dir, bfile)\n                        bdist = os.path.join(dest_dir, bfile)\n                        shutil.copy(full, bdist)\n                        ret.setdefault('Packages', []).append(bdist)\n            except Exception as exc:\n                log.error(\"Error building from '%s', execption '%s'\", dsc, exc)\n    for pkgzfile in os.listdir(dest_dir):\n        if pkgzfile == 'Packages':\n            pkgzabsfile = os.path.join(dest_dir, pkgzfile)\n            os.remove(pkgzabsfile)\n    cmd = 'chown {0}:{0} -R {1}'.format(runas, dest_dir)\n    __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n    shutil.rmtree(dsc_dir)\n    return ret",
            "def build(runas, tgt, dest_dir, spec, sources, deps, env, template, saltenv='base', log_dir='/var/log/salt/pkgbuild'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Given the package destination directory, the tarball containing debian files (e.g. control)\\n    and package sources, use pbuilder to safely build the platform package\\n\\n    CLI Example:\\n\\n    **Debian**\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkgbuild.make_src_pkg deb-8-x86_64 /var/www/html\\n                https://raw.githubusercontent.com/saltstack/libnacl/master/pkg/deb/python-libnacl.control\\n                https://pypi.python.org/packages/source/l/libnacl/libnacl-1.3.5.tar.gz\\n\\n    This example command should build the libnacl package for Debian using pbuilder\\n    and place it in /var/www/html/ on the minion\\n    \"\n    ret = {}\n    retrc = 0\n    try:\n        os.makedirs(dest_dir)\n    except OSError as exc:\n        if exc.errno != errno.EEXIST:\n            raise\n    dsc_dir = tempfile.mkdtemp()\n    try:\n        dscs = make_src_pkg(dsc_dir, spec, sources, env, saltenv, runas)\n    except Exception as exc:\n        shutil.rmtree(dsc_dir)\n        log.error(\"Failed to make src package, exception '%s'\", exc)\n        return ret\n    root_user = 'root'\n    if runas != root_user:\n        user_home = os.path.expanduser('~{}'.format(runas))\n        root_home = os.path.expanduser('~root')\n        cmd = 'cp {}/.pbuilderrc {}/'.format(user_home, root_home)\n        retrc = __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n        cmd = 'cp -R {}/.pbuilder-hooks {}/'.format(user_home, root_home)\n        retrc = __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n        if retrc != 0:\n            raise SaltInvocationError(\"build copy pbuilder files from '{}' to '{}' returned error '{}', check logs for further details\".format(user_home, root_home, retrc))\n    cmd = '/usr/sbin/pbuilder --create'\n    retrc = __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n    if retrc != 0:\n        raise SaltInvocationError(\"pbuilder create failed with return error '{}', check logs for further details\".format(retrc))\n    results_dir = '/var/cache/pbuilder/result'\n    cmd = 'rm -fR {}'.format(results_dir)\n    retrc |= __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n    for dsc in dscs:\n        afile = os.path.basename(dsc)\n        os.path.join(dest_dir, afile)\n        if dsc.endswith('.dsc'):\n            dbase = os.path.dirname(dsc)\n            try:\n                cmd = 'chown {0}:{0} -R {1}'.format(runas, dbase)\n                retrc |= __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n                cmd = '/usr/sbin/pbuilder update --override-config'\n                retrc |= __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n                cmd = '/usr/sbin/pbuilder build --debbuildopts \"-sa\" {}'.format(dsc)\n                retrc |= __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n                if retrc != 0:\n                    raise SaltInvocationError('pbuilder build or update failed with return error {}, check logs for further details'.format(retrc))\n                for bfile in os.listdir(results_dir):\n                    if bfile != 'Packages':\n                        full = os.path.join(results_dir, bfile)\n                        bdist = os.path.join(dest_dir, bfile)\n                        shutil.copy(full, bdist)\n                        ret.setdefault('Packages', []).append(bdist)\n            except Exception as exc:\n                log.error(\"Error building from '%s', execption '%s'\", dsc, exc)\n    for pkgzfile in os.listdir(dest_dir):\n        if pkgzfile == 'Packages':\n            pkgzabsfile = os.path.join(dest_dir, pkgzfile)\n            os.remove(pkgzabsfile)\n    cmd = 'chown {0}:{0} -R {1}'.format(runas, dest_dir)\n    __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n    shutil.rmtree(dsc_dir)\n    return ret",
            "def build(runas, tgt, dest_dir, spec, sources, deps, env, template, saltenv='base', log_dir='/var/log/salt/pkgbuild'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Given the package destination directory, the tarball containing debian files (e.g. control)\\n    and package sources, use pbuilder to safely build the platform package\\n\\n    CLI Example:\\n\\n    **Debian**\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkgbuild.make_src_pkg deb-8-x86_64 /var/www/html\\n                https://raw.githubusercontent.com/saltstack/libnacl/master/pkg/deb/python-libnacl.control\\n                https://pypi.python.org/packages/source/l/libnacl/libnacl-1.3.5.tar.gz\\n\\n    This example command should build the libnacl package for Debian using pbuilder\\n    and place it in /var/www/html/ on the minion\\n    \"\n    ret = {}\n    retrc = 0\n    try:\n        os.makedirs(dest_dir)\n    except OSError as exc:\n        if exc.errno != errno.EEXIST:\n            raise\n    dsc_dir = tempfile.mkdtemp()\n    try:\n        dscs = make_src_pkg(dsc_dir, spec, sources, env, saltenv, runas)\n    except Exception as exc:\n        shutil.rmtree(dsc_dir)\n        log.error(\"Failed to make src package, exception '%s'\", exc)\n        return ret\n    root_user = 'root'\n    if runas != root_user:\n        user_home = os.path.expanduser('~{}'.format(runas))\n        root_home = os.path.expanduser('~root')\n        cmd = 'cp {}/.pbuilderrc {}/'.format(user_home, root_home)\n        retrc = __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n        cmd = 'cp -R {}/.pbuilder-hooks {}/'.format(user_home, root_home)\n        retrc = __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n        if retrc != 0:\n            raise SaltInvocationError(\"build copy pbuilder files from '{}' to '{}' returned error '{}', check logs for further details\".format(user_home, root_home, retrc))\n    cmd = '/usr/sbin/pbuilder --create'\n    retrc = __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n    if retrc != 0:\n        raise SaltInvocationError(\"pbuilder create failed with return error '{}', check logs for further details\".format(retrc))\n    results_dir = '/var/cache/pbuilder/result'\n    cmd = 'rm -fR {}'.format(results_dir)\n    retrc |= __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n    for dsc in dscs:\n        afile = os.path.basename(dsc)\n        os.path.join(dest_dir, afile)\n        if dsc.endswith('.dsc'):\n            dbase = os.path.dirname(dsc)\n            try:\n                cmd = 'chown {0}:{0} -R {1}'.format(runas, dbase)\n                retrc |= __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n                cmd = '/usr/sbin/pbuilder update --override-config'\n                retrc |= __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n                cmd = '/usr/sbin/pbuilder build --debbuildopts \"-sa\" {}'.format(dsc)\n                retrc |= __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n                if retrc != 0:\n                    raise SaltInvocationError('pbuilder build or update failed with return error {}, check logs for further details'.format(retrc))\n                for bfile in os.listdir(results_dir):\n                    if bfile != 'Packages':\n                        full = os.path.join(results_dir, bfile)\n                        bdist = os.path.join(dest_dir, bfile)\n                        shutil.copy(full, bdist)\n                        ret.setdefault('Packages', []).append(bdist)\n            except Exception as exc:\n                log.error(\"Error building from '%s', execption '%s'\", dsc, exc)\n    for pkgzfile in os.listdir(dest_dir):\n        if pkgzfile == 'Packages':\n            pkgzabsfile = os.path.join(dest_dir, pkgzfile)\n            os.remove(pkgzabsfile)\n    cmd = 'chown {0}:{0} -R {1}'.format(runas, dest_dir)\n    __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n    shutil.rmtree(dsc_dir)\n    return ret",
            "def build(runas, tgt, dest_dir, spec, sources, deps, env, template, saltenv='base', log_dir='/var/log/salt/pkgbuild'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Given the package destination directory, the tarball containing debian files (e.g. control)\\n    and package sources, use pbuilder to safely build the platform package\\n\\n    CLI Example:\\n\\n    **Debian**\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkgbuild.make_src_pkg deb-8-x86_64 /var/www/html\\n                https://raw.githubusercontent.com/saltstack/libnacl/master/pkg/deb/python-libnacl.control\\n                https://pypi.python.org/packages/source/l/libnacl/libnacl-1.3.5.tar.gz\\n\\n    This example command should build the libnacl package for Debian using pbuilder\\n    and place it in /var/www/html/ on the minion\\n    \"\n    ret = {}\n    retrc = 0\n    try:\n        os.makedirs(dest_dir)\n    except OSError as exc:\n        if exc.errno != errno.EEXIST:\n            raise\n    dsc_dir = tempfile.mkdtemp()\n    try:\n        dscs = make_src_pkg(dsc_dir, spec, sources, env, saltenv, runas)\n    except Exception as exc:\n        shutil.rmtree(dsc_dir)\n        log.error(\"Failed to make src package, exception '%s'\", exc)\n        return ret\n    root_user = 'root'\n    if runas != root_user:\n        user_home = os.path.expanduser('~{}'.format(runas))\n        root_home = os.path.expanduser('~root')\n        cmd = 'cp {}/.pbuilderrc {}/'.format(user_home, root_home)\n        retrc = __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n        cmd = 'cp -R {}/.pbuilder-hooks {}/'.format(user_home, root_home)\n        retrc = __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n        if retrc != 0:\n            raise SaltInvocationError(\"build copy pbuilder files from '{}' to '{}' returned error '{}', check logs for further details\".format(user_home, root_home, retrc))\n    cmd = '/usr/sbin/pbuilder --create'\n    retrc = __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n    if retrc != 0:\n        raise SaltInvocationError(\"pbuilder create failed with return error '{}', check logs for further details\".format(retrc))\n    results_dir = '/var/cache/pbuilder/result'\n    cmd = 'rm -fR {}'.format(results_dir)\n    retrc |= __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n    for dsc in dscs:\n        afile = os.path.basename(dsc)\n        os.path.join(dest_dir, afile)\n        if dsc.endswith('.dsc'):\n            dbase = os.path.dirname(dsc)\n            try:\n                cmd = 'chown {0}:{0} -R {1}'.format(runas, dbase)\n                retrc |= __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n                cmd = '/usr/sbin/pbuilder update --override-config'\n                retrc |= __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n                cmd = '/usr/sbin/pbuilder build --debbuildopts \"-sa\" {}'.format(dsc)\n                retrc |= __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n                if retrc != 0:\n                    raise SaltInvocationError('pbuilder build or update failed with return error {}, check logs for further details'.format(retrc))\n                for bfile in os.listdir(results_dir):\n                    if bfile != 'Packages':\n                        full = os.path.join(results_dir, bfile)\n                        bdist = os.path.join(dest_dir, bfile)\n                        shutil.copy(full, bdist)\n                        ret.setdefault('Packages', []).append(bdist)\n            except Exception as exc:\n                log.error(\"Error building from '%s', execption '%s'\", dsc, exc)\n    for pkgzfile in os.listdir(dest_dir):\n        if pkgzfile == 'Packages':\n            pkgzabsfile = os.path.join(dest_dir, pkgzfile)\n            os.remove(pkgzabsfile)\n    cmd = 'chown {0}:{0} -R {1}'.format(runas, dest_dir)\n    __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n    shutil.rmtree(dsc_dir)\n    return ret",
            "def build(runas, tgt, dest_dir, spec, sources, deps, env, template, saltenv='base', log_dir='/var/log/salt/pkgbuild'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Given the package destination directory, the tarball containing debian files (e.g. control)\\n    and package sources, use pbuilder to safely build the platform package\\n\\n    CLI Example:\\n\\n    **Debian**\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkgbuild.make_src_pkg deb-8-x86_64 /var/www/html\\n                https://raw.githubusercontent.com/saltstack/libnacl/master/pkg/deb/python-libnacl.control\\n                https://pypi.python.org/packages/source/l/libnacl/libnacl-1.3.5.tar.gz\\n\\n    This example command should build the libnacl package for Debian using pbuilder\\n    and place it in /var/www/html/ on the minion\\n    \"\n    ret = {}\n    retrc = 0\n    try:\n        os.makedirs(dest_dir)\n    except OSError as exc:\n        if exc.errno != errno.EEXIST:\n            raise\n    dsc_dir = tempfile.mkdtemp()\n    try:\n        dscs = make_src_pkg(dsc_dir, spec, sources, env, saltenv, runas)\n    except Exception as exc:\n        shutil.rmtree(dsc_dir)\n        log.error(\"Failed to make src package, exception '%s'\", exc)\n        return ret\n    root_user = 'root'\n    if runas != root_user:\n        user_home = os.path.expanduser('~{}'.format(runas))\n        root_home = os.path.expanduser('~root')\n        cmd = 'cp {}/.pbuilderrc {}/'.format(user_home, root_home)\n        retrc = __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n        cmd = 'cp -R {}/.pbuilder-hooks {}/'.format(user_home, root_home)\n        retrc = __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n        if retrc != 0:\n            raise SaltInvocationError(\"build copy pbuilder files from '{}' to '{}' returned error '{}', check logs for further details\".format(user_home, root_home, retrc))\n    cmd = '/usr/sbin/pbuilder --create'\n    retrc = __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n    if retrc != 0:\n        raise SaltInvocationError(\"pbuilder create failed with return error '{}', check logs for further details\".format(retrc))\n    results_dir = '/var/cache/pbuilder/result'\n    cmd = 'rm -fR {}'.format(results_dir)\n    retrc |= __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n    for dsc in dscs:\n        afile = os.path.basename(dsc)\n        os.path.join(dest_dir, afile)\n        if dsc.endswith('.dsc'):\n            dbase = os.path.dirname(dsc)\n            try:\n                cmd = 'chown {0}:{0} -R {1}'.format(runas, dbase)\n                retrc |= __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n                cmd = '/usr/sbin/pbuilder update --override-config'\n                retrc |= __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n                cmd = '/usr/sbin/pbuilder build --debbuildopts \"-sa\" {}'.format(dsc)\n                retrc |= __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n                if retrc != 0:\n                    raise SaltInvocationError('pbuilder build or update failed with return error {}, check logs for further details'.format(retrc))\n                for bfile in os.listdir(results_dir):\n                    if bfile != 'Packages':\n                        full = os.path.join(results_dir, bfile)\n                        bdist = os.path.join(dest_dir, bfile)\n                        shutil.copy(full, bdist)\n                        ret.setdefault('Packages', []).append(bdist)\n            except Exception as exc:\n                log.error(\"Error building from '%s', execption '%s'\", dsc, exc)\n    for pkgzfile in os.listdir(dest_dir):\n        if pkgzfile == 'Packages':\n            pkgzabsfile = os.path.join(dest_dir, pkgzfile)\n            os.remove(pkgzabsfile)\n    cmd = 'chown {0}:{0} -R {1}'.format(runas, dest_dir)\n    __salt__['cmd.retcode'](cmd, runas=root_user, python_shell=True, env=env)\n    shutil.rmtree(dsc_dir)\n    return ret"
        ]
    },
    {
        "func_name": "make_repo",
        "original": "def make_repo(repodir, keyid=None, env=None, use_passphrase=False, gnupghome='/etc/salt/gpgkeys', runas='root', timeout=15.0):\n    \"\"\"\n    Make a package repository and optionally sign it and packages present\n\n    Given the repodir (directory to create repository in), create a Debian\n    repository and optionally sign it and packages present. This state is\n    best used with onchanges linked to your package building states.\n\n    repodir\n        The directory to find packages that will be in the repository.\n\n    keyid\n        .. versionchanged:: 2016.3.0\n\n        Optional Key ID to use in signing packages and repository.\n        This consists of the last 8 hex digits of the GPG key ID.\n\n        Utilizes Public and Private keys associated with keyid which have\n        been loaded into the minion's Pillar data. Leverages gpg-agent and\n        gpg-preset-passphrase for caching keys, etc.\n        These pillar values are assumed to be filenames which are present\n        in ``gnupghome``. The pillar keys shown below have to match exactly.\n\n        For example, contents from a Pillar data file with named Public\n        and Private keys as follows:\n\n        .. code-block:: yaml\n\n            gpg_pkg_priv_keyname: gpg_pkg_key.pem\n            gpg_pkg_pub_keyname: gpg_pkg_key.pub\n\n    env\n        .. versionchanged:: 2016.3.0\n\n        A dictionary of environment variables to be utilized in creating the\n        repository.\n\n    use_passphrase : False\n        .. versionadded:: 2016.3.0\n\n        Use a passphrase with the signing key presented in ``keyid``.\n        Passphrase is received from Pillar data which could be passed on the\n        command line with ``pillar`` parameter. For example:\n\n        .. code-block:: bash\n\n            pillar='{ \"gpg_passphrase\" : \"my_passphrase\" }'\n\n    gnupghome : /etc/salt/gpgkeys\n        .. versionadded:: 2016.3.0\n\n        Location where GPG related files are stored, used with ``keyid``.\n\n    runas : root\n        .. versionadded:: 2016.3.0\n\n        User to create the repository as, and optionally sign packages.\n\n        .. note::\n\n            Ensure the user has correct permissions to any files and\n            directories which are to be utilized.\n\n    timeout : 15.0\n        .. versionadded:: 2016.3.4\n\n        Timeout in seconds to wait for the prompt for inputting the passphrase.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkgbuild.make_repo /var/www/html\n\n    \"\"\"\n    res = {'retcode': 1, 'stdout': '', 'stderr': 'initialization value'}\n    retrc = 0\n    if gnupghome and env is None:\n        env = {}\n        env['GNUPGHOME'] = gnupghome\n    repoconf = os.path.join(repodir, 'conf')\n    if not os.path.isdir(repoconf):\n        os.makedirs(repoconf)\n    (codename, repocfg_dists) = _get_repo_dists_env(env)\n    repoconfdist = os.path.join(repoconf, 'distributions')\n    with salt.utils.files.fopen(repoconfdist, 'w') as fow:\n        fow.write(salt.utils.stringutils.to_str(repocfg_dists))\n    repocfg_opts = _get_repo_options_env(env)\n    repoconfopts = os.path.join(repoconf, 'options')\n    with salt.utils.files.fopen(repoconfopts, 'w') as fow:\n        fow.write(salt.utils.stringutils.to_str(repocfg_opts))\n    cmd = 'chown {0}:{0} -R {1}'.format(runas, repoconf)\n    retrc = __salt__['cmd.retcode'](cmd, runas='root')\n    if retrc != 0:\n        raise SaltInvocationError('failed to ensure rights to repoconf directory, error {}, check logs for further details'.format(retrc))\n    local_keygrip_to_use = None\n    local_key_fingerprint = None\n    local_keyid = None\n    phrase = ''\n    gpg_info_file = '{}/gpg-agent-info-salt'.format(gnupghome)\n    gpg_tty_info_file = '{}/gpg-tty-info-salt'.format(gnupghome)\n    older_gnupg = __salt__['file.file_exists'](gpg_info_file)\n    if keyid is not None:\n        with salt.utils.files.fopen(repoconfdist, 'a') as fow:\n            fow.write(salt.utils.stringutils.to_str('SignWith: {}\\n'.format(keyid)))\n        pkg_pub_key_file = '{}/{}'.format(gnupghome, __salt__['pillar.get']('gpg_pkg_pub_keyname', None))\n        pkg_priv_key_file = '{}/{}'.format(gnupghome, __salt__['pillar.get']('gpg_pkg_priv_keyname', None))\n        if pkg_pub_key_file is None or pkg_priv_key_file is None:\n            raise SaltInvocationError(\"Pillar data should contain Public and Private keys associated with 'keyid'\")\n        try:\n            __salt__['gpg.import_key'](user=runas, filename=pkg_pub_key_file, gnupghome=gnupghome)\n            __salt__['gpg.import_key'](user=runas, filename=pkg_priv_key_file, gnupghome=gnupghome)\n        except SaltInvocationError:\n            raise SaltInvocationError(\"Public and Private key files associated with Pillar data and 'keyid' {} could not be found\".format(keyid))\n        local_keys = __salt__['gpg.list_keys'](user=runas, gnupghome=gnupghome)\n        for gpg_key in local_keys:\n            if keyid == gpg_key['keyid'][8:]:\n                local_keygrip_to_use = gpg_key['fingerprint']\n                local_key_fingerprint = gpg_key['fingerprint']\n                local_keyid = gpg_key['keyid']\n                break\n        if not older_gnupg:\n            try:\n                _check_repo_sign_utils_support('gpg2')\n                cmd = 'gpg2 --with-keygrip --list-secret-keys'\n            except CommandExecutionError:\n                cmd = 'gpg --with-keygrip --list-secret-keys'\n            local_keys2_keygrip = __salt__['cmd.run'](cmd, runas=runas, env=env)\n            local_keys2 = iter(local_keys2_keygrip.splitlines())\n            try:\n                for line in local_keys2:\n                    if line.startswith('sec'):\n                        line_fingerprint = next(local_keys2).lstrip().rstrip()\n                        if local_key_fingerprint == line_fingerprint:\n                            lkeygrip = next(local_keys2).split('=')\n                            local_keygrip_to_use = lkeygrip[1].lstrip().rstrip()\n                            break\n            except StopIteration:\n                raise SaltInvocationError(\"unable to find keygrip associated with fingerprint '{}' for keyid '{}'\".format(local_key_fingerprint, local_keyid))\n        if local_keyid is None:\n            raise SaltInvocationError(\"The key ID '{}' was not found in GnuPG keyring at '{}'\".format(keyid, gnupghome))\n        _check_repo_sign_utils_support('debsign')\n        if older_gnupg:\n            with salt.utils.files.fopen(gpg_info_file, 'r') as fow:\n                gpg_raw_info = fow.readlines()\n            for gpg_info_line in gpg_raw_info:\n                gpg_info_line = salt.utils.stringutils.to_unicode(gpg_info_line)\n                gpg_info = gpg_info_line.split('=')\n                env[gpg_info[0]] = gpg_info[1]\n                break\n        else:\n            with salt.utils.files.fopen(gpg_tty_info_file, 'r') as fow:\n                gpg_raw_info = fow.readlines()\n            for gpg_tty_info_line in gpg_raw_info:\n                gpg_tty_info_line = salt.utils.stringutils.to_unicode(gpg_tty_info_line)\n                gpg_tty_info = gpg_tty_info_line.split('=')\n                env[gpg_tty_info[0]] = gpg_tty_info[1]\n                break\n        if use_passphrase:\n            _check_repo_gpg_phrase_utils()\n            phrase = __salt__['pillar.get']('gpg_passphrase')\n            cmd = '/usr/lib/gnupg2/gpg-preset-passphrase --verbose --preset --passphrase \"{}\" {}'.format(phrase, local_keygrip_to_use)\n            retrc |= __salt__['cmd.retcode'](cmd, runas=runas, env=env)\n    for debfile in os.listdir(repodir):\n        abs_file = os.path.join(repodir, debfile)\n        if debfile.endswith('.changes'):\n            os.remove(abs_file)\n        if debfile.endswith('.dsc'):\n            if older_gnupg:\n                if local_keyid is not None:\n                    cmd = 'debsign --re-sign -k {} {}'.format(keyid, abs_file)\n                    retrc |= __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n                cmd = 'reprepro --ignore=wrongdistribution --component=main -Vb . includedsc {} {}'.format(codename, abs_file)\n                retrc |= __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n            else:\n                interval = 0.5\n                if local_keyid is not None:\n                    number_retries = timeout / interval\n                    times_looped = 0\n                    error_msg = 'Failed to debsign file {}'.format(abs_file)\n                    if __grains__['os'] in ['Ubuntu'] and __grains__['osmajorrelease'] < 18 or (__grains__['os'] in ['Debian'] and __grains__['osmajorrelease'] <= 8):\n                        cmd = 'debsign --re-sign -k {} {}'.format(keyid, abs_file)\n                        try:\n                            proc = salt.utils.vt.Terminal(cmd, env=env, shell=True, stream_stdout=True, stream_stderr=True)\n                            while proc.has_unread_data:\n                                (stdout, _) = proc.recv()\n                                if stdout and SIGN_PROMPT_RE.search(stdout):\n                                    proc.sendline(phrase)\n                                else:\n                                    times_looped += 1\n                                if times_looped > number_retries:\n                                    raise SaltInvocationError('Attempting to sign file {} failed, timed out after {} seconds'.format(abs_file, int(times_looped * interval)))\n                                time.sleep(interval)\n                            proc_exitstatus = proc.exitstatus\n                            if proc_exitstatus != 0:\n                                raise SaltInvocationError('Signing file {} failed with proc.status {}'.format(abs_file, proc_exitstatus))\n                        except salt.utils.vt.TerminalException as err:\n                            trace = traceback.format_exc()\n                            log.error(error_msg, err, trace)\n                            res = {'retcode': 1, 'stdout': '', 'stderr': trace}\n                        finally:\n                            proc.close(terminate=True, kill=True)\n                    else:\n                        cmd = 'debsign --re-sign -k {} {}'.format(local_key_fingerprint, abs_file)\n                        retrc |= __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n                number_retries = timeout / interval\n                times_looped = 0\n                error_msg = 'Failed to reprepro includedsc file {}'.format(abs_file)\n                cmd = 'reprepro --ignore=wrongdistribution --component=main -Vb . includedsc {} {}'.format(codename, abs_file)\n                if __grains__['os'] in ['Ubuntu'] and __grains__['osmajorrelease'] < 18 or (__grains__['os'] in ['Debian'] and __grains__['osmajorrelease'] <= 8):\n                    try:\n                        proc = salt.utils.vt.Terminal(cmd, env=env, shell=True, cwd=repodir, stream_stdout=True, stream_stderr=True)\n                        while proc.has_unread_data:\n                            (stdout, _) = proc.recv()\n                            if stdout and REPREPRO_SIGN_PROMPT_RE.search(stdout):\n                                proc.sendline(phrase)\n                            else:\n                                times_looped += 1\n                            if times_looped > number_retries:\n                                raise SaltInvocationError('Attempting to reprepro includedsc for file {} failed, timed out after {} loops'.format(abs_file, times_looped))\n                            time.sleep(interval)\n                        proc_exitstatus = proc.exitstatus\n                        if proc_exitstatus != 0:\n                            raise SaltInvocationError('Reprepro includedsc for codename {} and file {} failed with proc.status {}'.format(codename, abs_file, proc_exitstatus))\n                    except salt.utils.vt.TerminalException as err:\n                        trace = traceback.format_exc()\n                        log.error(error_msg, err, trace)\n                        res = {'retcode': 1, 'stdout': '', 'stderr': trace}\n                    finally:\n                        proc.close(terminate=True, kill=True)\n                else:\n                    retrc |= __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n        if retrc != 0:\n            raise SaltInvocationError('Making a repo encountered errors, return error {}, check logs for further details'.format(retrc))\n        if debfile.endswith('.deb'):\n            cmd = 'reprepro --ignore=wrongdistribution --component=main -Vb . includedeb {} {}'.format(codename, abs_file)\n            res = __salt__['cmd.run_all'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n    return res",
        "mutated": [
            "def make_repo(repodir, keyid=None, env=None, use_passphrase=False, gnupghome='/etc/salt/gpgkeys', runas='root', timeout=15.0):\n    if False:\n        i = 10\n    '\\n    Make a package repository and optionally sign it and packages present\\n\\n    Given the repodir (directory to create repository in), create a Debian\\n    repository and optionally sign it and packages present. This state is\\n    best used with onchanges linked to your package building states.\\n\\n    repodir\\n        The directory to find packages that will be in the repository.\\n\\n    keyid\\n        .. versionchanged:: 2016.3.0\\n\\n        Optional Key ID to use in signing packages and repository.\\n        This consists of the last 8 hex digits of the GPG key ID.\\n\\n        Utilizes Public and Private keys associated with keyid which have\\n        been loaded into the minion\\'s Pillar data. Leverages gpg-agent and\\n        gpg-preset-passphrase for caching keys, etc.\\n        These pillar values are assumed to be filenames which are present\\n        in ``gnupghome``. The pillar keys shown below have to match exactly.\\n\\n        For example, contents from a Pillar data file with named Public\\n        and Private keys as follows:\\n\\n        .. code-block:: yaml\\n\\n            gpg_pkg_priv_keyname: gpg_pkg_key.pem\\n            gpg_pkg_pub_keyname: gpg_pkg_key.pub\\n\\n    env\\n        .. versionchanged:: 2016.3.0\\n\\n        A dictionary of environment variables to be utilized in creating the\\n        repository.\\n\\n    use_passphrase : False\\n        .. versionadded:: 2016.3.0\\n\\n        Use a passphrase with the signing key presented in ``keyid``.\\n        Passphrase is received from Pillar data which could be passed on the\\n        command line with ``pillar`` parameter. For example:\\n\\n        .. code-block:: bash\\n\\n            pillar=\\'{ \"gpg_passphrase\" : \"my_passphrase\" }\\'\\n\\n    gnupghome : /etc/salt/gpgkeys\\n        .. versionadded:: 2016.3.0\\n\\n        Location where GPG related files are stored, used with ``keyid``.\\n\\n    runas : root\\n        .. versionadded:: 2016.3.0\\n\\n        User to create the repository as, and optionally sign packages.\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n\\n    timeout : 15.0\\n        .. versionadded:: 2016.3.4\\n\\n        Timeout in seconds to wait for the prompt for inputting the passphrase.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkgbuild.make_repo /var/www/html\\n\\n    '\n    res = {'retcode': 1, 'stdout': '', 'stderr': 'initialization value'}\n    retrc = 0\n    if gnupghome and env is None:\n        env = {}\n        env['GNUPGHOME'] = gnupghome\n    repoconf = os.path.join(repodir, 'conf')\n    if not os.path.isdir(repoconf):\n        os.makedirs(repoconf)\n    (codename, repocfg_dists) = _get_repo_dists_env(env)\n    repoconfdist = os.path.join(repoconf, 'distributions')\n    with salt.utils.files.fopen(repoconfdist, 'w') as fow:\n        fow.write(salt.utils.stringutils.to_str(repocfg_dists))\n    repocfg_opts = _get_repo_options_env(env)\n    repoconfopts = os.path.join(repoconf, 'options')\n    with salt.utils.files.fopen(repoconfopts, 'w') as fow:\n        fow.write(salt.utils.stringutils.to_str(repocfg_opts))\n    cmd = 'chown {0}:{0} -R {1}'.format(runas, repoconf)\n    retrc = __salt__['cmd.retcode'](cmd, runas='root')\n    if retrc != 0:\n        raise SaltInvocationError('failed to ensure rights to repoconf directory, error {}, check logs for further details'.format(retrc))\n    local_keygrip_to_use = None\n    local_key_fingerprint = None\n    local_keyid = None\n    phrase = ''\n    gpg_info_file = '{}/gpg-agent-info-salt'.format(gnupghome)\n    gpg_tty_info_file = '{}/gpg-tty-info-salt'.format(gnupghome)\n    older_gnupg = __salt__['file.file_exists'](gpg_info_file)\n    if keyid is not None:\n        with salt.utils.files.fopen(repoconfdist, 'a') as fow:\n            fow.write(salt.utils.stringutils.to_str('SignWith: {}\\n'.format(keyid)))\n        pkg_pub_key_file = '{}/{}'.format(gnupghome, __salt__['pillar.get']('gpg_pkg_pub_keyname', None))\n        pkg_priv_key_file = '{}/{}'.format(gnupghome, __salt__['pillar.get']('gpg_pkg_priv_keyname', None))\n        if pkg_pub_key_file is None or pkg_priv_key_file is None:\n            raise SaltInvocationError(\"Pillar data should contain Public and Private keys associated with 'keyid'\")\n        try:\n            __salt__['gpg.import_key'](user=runas, filename=pkg_pub_key_file, gnupghome=gnupghome)\n            __salt__['gpg.import_key'](user=runas, filename=pkg_priv_key_file, gnupghome=gnupghome)\n        except SaltInvocationError:\n            raise SaltInvocationError(\"Public and Private key files associated with Pillar data and 'keyid' {} could not be found\".format(keyid))\n        local_keys = __salt__['gpg.list_keys'](user=runas, gnupghome=gnupghome)\n        for gpg_key in local_keys:\n            if keyid == gpg_key['keyid'][8:]:\n                local_keygrip_to_use = gpg_key['fingerprint']\n                local_key_fingerprint = gpg_key['fingerprint']\n                local_keyid = gpg_key['keyid']\n                break\n        if not older_gnupg:\n            try:\n                _check_repo_sign_utils_support('gpg2')\n                cmd = 'gpg2 --with-keygrip --list-secret-keys'\n            except CommandExecutionError:\n                cmd = 'gpg --with-keygrip --list-secret-keys'\n            local_keys2_keygrip = __salt__['cmd.run'](cmd, runas=runas, env=env)\n            local_keys2 = iter(local_keys2_keygrip.splitlines())\n            try:\n                for line in local_keys2:\n                    if line.startswith('sec'):\n                        line_fingerprint = next(local_keys2).lstrip().rstrip()\n                        if local_key_fingerprint == line_fingerprint:\n                            lkeygrip = next(local_keys2).split('=')\n                            local_keygrip_to_use = lkeygrip[1].lstrip().rstrip()\n                            break\n            except StopIteration:\n                raise SaltInvocationError(\"unable to find keygrip associated with fingerprint '{}' for keyid '{}'\".format(local_key_fingerprint, local_keyid))\n        if local_keyid is None:\n            raise SaltInvocationError(\"The key ID '{}' was not found in GnuPG keyring at '{}'\".format(keyid, gnupghome))\n        _check_repo_sign_utils_support('debsign')\n        if older_gnupg:\n            with salt.utils.files.fopen(gpg_info_file, 'r') as fow:\n                gpg_raw_info = fow.readlines()\n            for gpg_info_line in gpg_raw_info:\n                gpg_info_line = salt.utils.stringutils.to_unicode(gpg_info_line)\n                gpg_info = gpg_info_line.split('=')\n                env[gpg_info[0]] = gpg_info[1]\n                break\n        else:\n            with salt.utils.files.fopen(gpg_tty_info_file, 'r') as fow:\n                gpg_raw_info = fow.readlines()\n            for gpg_tty_info_line in gpg_raw_info:\n                gpg_tty_info_line = salt.utils.stringutils.to_unicode(gpg_tty_info_line)\n                gpg_tty_info = gpg_tty_info_line.split('=')\n                env[gpg_tty_info[0]] = gpg_tty_info[1]\n                break\n        if use_passphrase:\n            _check_repo_gpg_phrase_utils()\n            phrase = __salt__['pillar.get']('gpg_passphrase')\n            cmd = '/usr/lib/gnupg2/gpg-preset-passphrase --verbose --preset --passphrase \"{}\" {}'.format(phrase, local_keygrip_to_use)\n            retrc |= __salt__['cmd.retcode'](cmd, runas=runas, env=env)\n    for debfile in os.listdir(repodir):\n        abs_file = os.path.join(repodir, debfile)\n        if debfile.endswith('.changes'):\n            os.remove(abs_file)\n        if debfile.endswith('.dsc'):\n            if older_gnupg:\n                if local_keyid is not None:\n                    cmd = 'debsign --re-sign -k {} {}'.format(keyid, abs_file)\n                    retrc |= __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n                cmd = 'reprepro --ignore=wrongdistribution --component=main -Vb . includedsc {} {}'.format(codename, abs_file)\n                retrc |= __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n            else:\n                interval = 0.5\n                if local_keyid is not None:\n                    number_retries = timeout / interval\n                    times_looped = 0\n                    error_msg = 'Failed to debsign file {}'.format(abs_file)\n                    if __grains__['os'] in ['Ubuntu'] and __grains__['osmajorrelease'] < 18 or (__grains__['os'] in ['Debian'] and __grains__['osmajorrelease'] <= 8):\n                        cmd = 'debsign --re-sign -k {} {}'.format(keyid, abs_file)\n                        try:\n                            proc = salt.utils.vt.Terminal(cmd, env=env, shell=True, stream_stdout=True, stream_stderr=True)\n                            while proc.has_unread_data:\n                                (stdout, _) = proc.recv()\n                                if stdout and SIGN_PROMPT_RE.search(stdout):\n                                    proc.sendline(phrase)\n                                else:\n                                    times_looped += 1\n                                if times_looped > number_retries:\n                                    raise SaltInvocationError('Attempting to sign file {} failed, timed out after {} seconds'.format(abs_file, int(times_looped * interval)))\n                                time.sleep(interval)\n                            proc_exitstatus = proc.exitstatus\n                            if proc_exitstatus != 0:\n                                raise SaltInvocationError('Signing file {} failed with proc.status {}'.format(abs_file, proc_exitstatus))\n                        except salt.utils.vt.TerminalException as err:\n                            trace = traceback.format_exc()\n                            log.error(error_msg, err, trace)\n                            res = {'retcode': 1, 'stdout': '', 'stderr': trace}\n                        finally:\n                            proc.close(terminate=True, kill=True)\n                    else:\n                        cmd = 'debsign --re-sign -k {} {}'.format(local_key_fingerprint, abs_file)\n                        retrc |= __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n                number_retries = timeout / interval\n                times_looped = 0\n                error_msg = 'Failed to reprepro includedsc file {}'.format(abs_file)\n                cmd = 'reprepro --ignore=wrongdistribution --component=main -Vb . includedsc {} {}'.format(codename, abs_file)\n                if __grains__['os'] in ['Ubuntu'] and __grains__['osmajorrelease'] < 18 or (__grains__['os'] in ['Debian'] and __grains__['osmajorrelease'] <= 8):\n                    try:\n                        proc = salt.utils.vt.Terminal(cmd, env=env, shell=True, cwd=repodir, stream_stdout=True, stream_stderr=True)\n                        while proc.has_unread_data:\n                            (stdout, _) = proc.recv()\n                            if stdout and REPREPRO_SIGN_PROMPT_RE.search(stdout):\n                                proc.sendline(phrase)\n                            else:\n                                times_looped += 1\n                            if times_looped > number_retries:\n                                raise SaltInvocationError('Attempting to reprepro includedsc for file {} failed, timed out after {} loops'.format(abs_file, times_looped))\n                            time.sleep(interval)\n                        proc_exitstatus = proc.exitstatus\n                        if proc_exitstatus != 0:\n                            raise SaltInvocationError('Reprepro includedsc for codename {} and file {} failed with proc.status {}'.format(codename, abs_file, proc_exitstatus))\n                    except salt.utils.vt.TerminalException as err:\n                        trace = traceback.format_exc()\n                        log.error(error_msg, err, trace)\n                        res = {'retcode': 1, 'stdout': '', 'stderr': trace}\n                    finally:\n                        proc.close(terminate=True, kill=True)\n                else:\n                    retrc |= __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n        if retrc != 0:\n            raise SaltInvocationError('Making a repo encountered errors, return error {}, check logs for further details'.format(retrc))\n        if debfile.endswith('.deb'):\n            cmd = 'reprepro --ignore=wrongdistribution --component=main -Vb . includedeb {} {}'.format(codename, abs_file)\n            res = __salt__['cmd.run_all'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n    return res",
            "def make_repo(repodir, keyid=None, env=None, use_passphrase=False, gnupghome='/etc/salt/gpgkeys', runas='root', timeout=15.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Make a package repository and optionally sign it and packages present\\n\\n    Given the repodir (directory to create repository in), create a Debian\\n    repository and optionally sign it and packages present. This state is\\n    best used with onchanges linked to your package building states.\\n\\n    repodir\\n        The directory to find packages that will be in the repository.\\n\\n    keyid\\n        .. versionchanged:: 2016.3.0\\n\\n        Optional Key ID to use in signing packages and repository.\\n        This consists of the last 8 hex digits of the GPG key ID.\\n\\n        Utilizes Public and Private keys associated with keyid which have\\n        been loaded into the minion\\'s Pillar data. Leverages gpg-agent and\\n        gpg-preset-passphrase for caching keys, etc.\\n        These pillar values are assumed to be filenames which are present\\n        in ``gnupghome``. The pillar keys shown below have to match exactly.\\n\\n        For example, contents from a Pillar data file with named Public\\n        and Private keys as follows:\\n\\n        .. code-block:: yaml\\n\\n            gpg_pkg_priv_keyname: gpg_pkg_key.pem\\n            gpg_pkg_pub_keyname: gpg_pkg_key.pub\\n\\n    env\\n        .. versionchanged:: 2016.3.0\\n\\n        A dictionary of environment variables to be utilized in creating the\\n        repository.\\n\\n    use_passphrase : False\\n        .. versionadded:: 2016.3.0\\n\\n        Use a passphrase with the signing key presented in ``keyid``.\\n        Passphrase is received from Pillar data which could be passed on the\\n        command line with ``pillar`` parameter. For example:\\n\\n        .. code-block:: bash\\n\\n            pillar=\\'{ \"gpg_passphrase\" : \"my_passphrase\" }\\'\\n\\n    gnupghome : /etc/salt/gpgkeys\\n        .. versionadded:: 2016.3.0\\n\\n        Location where GPG related files are stored, used with ``keyid``.\\n\\n    runas : root\\n        .. versionadded:: 2016.3.0\\n\\n        User to create the repository as, and optionally sign packages.\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n\\n    timeout : 15.0\\n        .. versionadded:: 2016.3.4\\n\\n        Timeout in seconds to wait for the prompt for inputting the passphrase.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkgbuild.make_repo /var/www/html\\n\\n    '\n    res = {'retcode': 1, 'stdout': '', 'stderr': 'initialization value'}\n    retrc = 0\n    if gnupghome and env is None:\n        env = {}\n        env['GNUPGHOME'] = gnupghome\n    repoconf = os.path.join(repodir, 'conf')\n    if not os.path.isdir(repoconf):\n        os.makedirs(repoconf)\n    (codename, repocfg_dists) = _get_repo_dists_env(env)\n    repoconfdist = os.path.join(repoconf, 'distributions')\n    with salt.utils.files.fopen(repoconfdist, 'w') as fow:\n        fow.write(salt.utils.stringutils.to_str(repocfg_dists))\n    repocfg_opts = _get_repo_options_env(env)\n    repoconfopts = os.path.join(repoconf, 'options')\n    with salt.utils.files.fopen(repoconfopts, 'w') as fow:\n        fow.write(salt.utils.stringutils.to_str(repocfg_opts))\n    cmd = 'chown {0}:{0} -R {1}'.format(runas, repoconf)\n    retrc = __salt__['cmd.retcode'](cmd, runas='root')\n    if retrc != 0:\n        raise SaltInvocationError('failed to ensure rights to repoconf directory, error {}, check logs for further details'.format(retrc))\n    local_keygrip_to_use = None\n    local_key_fingerprint = None\n    local_keyid = None\n    phrase = ''\n    gpg_info_file = '{}/gpg-agent-info-salt'.format(gnupghome)\n    gpg_tty_info_file = '{}/gpg-tty-info-salt'.format(gnupghome)\n    older_gnupg = __salt__['file.file_exists'](gpg_info_file)\n    if keyid is not None:\n        with salt.utils.files.fopen(repoconfdist, 'a') as fow:\n            fow.write(salt.utils.stringutils.to_str('SignWith: {}\\n'.format(keyid)))\n        pkg_pub_key_file = '{}/{}'.format(gnupghome, __salt__['pillar.get']('gpg_pkg_pub_keyname', None))\n        pkg_priv_key_file = '{}/{}'.format(gnupghome, __salt__['pillar.get']('gpg_pkg_priv_keyname', None))\n        if pkg_pub_key_file is None or pkg_priv_key_file is None:\n            raise SaltInvocationError(\"Pillar data should contain Public and Private keys associated with 'keyid'\")\n        try:\n            __salt__['gpg.import_key'](user=runas, filename=pkg_pub_key_file, gnupghome=gnupghome)\n            __salt__['gpg.import_key'](user=runas, filename=pkg_priv_key_file, gnupghome=gnupghome)\n        except SaltInvocationError:\n            raise SaltInvocationError(\"Public and Private key files associated with Pillar data and 'keyid' {} could not be found\".format(keyid))\n        local_keys = __salt__['gpg.list_keys'](user=runas, gnupghome=gnupghome)\n        for gpg_key in local_keys:\n            if keyid == gpg_key['keyid'][8:]:\n                local_keygrip_to_use = gpg_key['fingerprint']\n                local_key_fingerprint = gpg_key['fingerprint']\n                local_keyid = gpg_key['keyid']\n                break\n        if not older_gnupg:\n            try:\n                _check_repo_sign_utils_support('gpg2')\n                cmd = 'gpg2 --with-keygrip --list-secret-keys'\n            except CommandExecutionError:\n                cmd = 'gpg --with-keygrip --list-secret-keys'\n            local_keys2_keygrip = __salt__['cmd.run'](cmd, runas=runas, env=env)\n            local_keys2 = iter(local_keys2_keygrip.splitlines())\n            try:\n                for line in local_keys2:\n                    if line.startswith('sec'):\n                        line_fingerprint = next(local_keys2).lstrip().rstrip()\n                        if local_key_fingerprint == line_fingerprint:\n                            lkeygrip = next(local_keys2).split('=')\n                            local_keygrip_to_use = lkeygrip[1].lstrip().rstrip()\n                            break\n            except StopIteration:\n                raise SaltInvocationError(\"unable to find keygrip associated with fingerprint '{}' for keyid '{}'\".format(local_key_fingerprint, local_keyid))\n        if local_keyid is None:\n            raise SaltInvocationError(\"The key ID '{}' was not found in GnuPG keyring at '{}'\".format(keyid, gnupghome))\n        _check_repo_sign_utils_support('debsign')\n        if older_gnupg:\n            with salt.utils.files.fopen(gpg_info_file, 'r') as fow:\n                gpg_raw_info = fow.readlines()\n            for gpg_info_line in gpg_raw_info:\n                gpg_info_line = salt.utils.stringutils.to_unicode(gpg_info_line)\n                gpg_info = gpg_info_line.split('=')\n                env[gpg_info[0]] = gpg_info[1]\n                break\n        else:\n            with salt.utils.files.fopen(gpg_tty_info_file, 'r') as fow:\n                gpg_raw_info = fow.readlines()\n            for gpg_tty_info_line in gpg_raw_info:\n                gpg_tty_info_line = salt.utils.stringutils.to_unicode(gpg_tty_info_line)\n                gpg_tty_info = gpg_tty_info_line.split('=')\n                env[gpg_tty_info[0]] = gpg_tty_info[1]\n                break\n        if use_passphrase:\n            _check_repo_gpg_phrase_utils()\n            phrase = __salt__['pillar.get']('gpg_passphrase')\n            cmd = '/usr/lib/gnupg2/gpg-preset-passphrase --verbose --preset --passphrase \"{}\" {}'.format(phrase, local_keygrip_to_use)\n            retrc |= __salt__['cmd.retcode'](cmd, runas=runas, env=env)\n    for debfile in os.listdir(repodir):\n        abs_file = os.path.join(repodir, debfile)\n        if debfile.endswith('.changes'):\n            os.remove(abs_file)\n        if debfile.endswith('.dsc'):\n            if older_gnupg:\n                if local_keyid is not None:\n                    cmd = 'debsign --re-sign -k {} {}'.format(keyid, abs_file)\n                    retrc |= __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n                cmd = 'reprepro --ignore=wrongdistribution --component=main -Vb . includedsc {} {}'.format(codename, abs_file)\n                retrc |= __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n            else:\n                interval = 0.5\n                if local_keyid is not None:\n                    number_retries = timeout / interval\n                    times_looped = 0\n                    error_msg = 'Failed to debsign file {}'.format(abs_file)\n                    if __grains__['os'] in ['Ubuntu'] and __grains__['osmajorrelease'] < 18 or (__grains__['os'] in ['Debian'] and __grains__['osmajorrelease'] <= 8):\n                        cmd = 'debsign --re-sign -k {} {}'.format(keyid, abs_file)\n                        try:\n                            proc = salt.utils.vt.Terminal(cmd, env=env, shell=True, stream_stdout=True, stream_stderr=True)\n                            while proc.has_unread_data:\n                                (stdout, _) = proc.recv()\n                                if stdout and SIGN_PROMPT_RE.search(stdout):\n                                    proc.sendline(phrase)\n                                else:\n                                    times_looped += 1\n                                if times_looped > number_retries:\n                                    raise SaltInvocationError('Attempting to sign file {} failed, timed out after {} seconds'.format(abs_file, int(times_looped * interval)))\n                                time.sleep(interval)\n                            proc_exitstatus = proc.exitstatus\n                            if proc_exitstatus != 0:\n                                raise SaltInvocationError('Signing file {} failed with proc.status {}'.format(abs_file, proc_exitstatus))\n                        except salt.utils.vt.TerminalException as err:\n                            trace = traceback.format_exc()\n                            log.error(error_msg, err, trace)\n                            res = {'retcode': 1, 'stdout': '', 'stderr': trace}\n                        finally:\n                            proc.close(terminate=True, kill=True)\n                    else:\n                        cmd = 'debsign --re-sign -k {} {}'.format(local_key_fingerprint, abs_file)\n                        retrc |= __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n                number_retries = timeout / interval\n                times_looped = 0\n                error_msg = 'Failed to reprepro includedsc file {}'.format(abs_file)\n                cmd = 'reprepro --ignore=wrongdistribution --component=main -Vb . includedsc {} {}'.format(codename, abs_file)\n                if __grains__['os'] in ['Ubuntu'] and __grains__['osmajorrelease'] < 18 or (__grains__['os'] in ['Debian'] and __grains__['osmajorrelease'] <= 8):\n                    try:\n                        proc = salt.utils.vt.Terminal(cmd, env=env, shell=True, cwd=repodir, stream_stdout=True, stream_stderr=True)\n                        while proc.has_unread_data:\n                            (stdout, _) = proc.recv()\n                            if stdout and REPREPRO_SIGN_PROMPT_RE.search(stdout):\n                                proc.sendline(phrase)\n                            else:\n                                times_looped += 1\n                            if times_looped > number_retries:\n                                raise SaltInvocationError('Attempting to reprepro includedsc for file {} failed, timed out after {} loops'.format(abs_file, times_looped))\n                            time.sleep(interval)\n                        proc_exitstatus = proc.exitstatus\n                        if proc_exitstatus != 0:\n                            raise SaltInvocationError('Reprepro includedsc for codename {} and file {} failed with proc.status {}'.format(codename, abs_file, proc_exitstatus))\n                    except salt.utils.vt.TerminalException as err:\n                        trace = traceback.format_exc()\n                        log.error(error_msg, err, trace)\n                        res = {'retcode': 1, 'stdout': '', 'stderr': trace}\n                    finally:\n                        proc.close(terminate=True, kill=True)\n                else:\n                    retrc |= __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n        if retrc != 0:\n            raise SaltInvocationError('Making a repo encountered errors, return error {}, check logs for further details'.format(retrc))\n        if debfile.endswith('.deb'):\n            cmd = 'reprepro --ignore=wrongdistribution --component=main -Vb . includedeb {} {}'.format(codename, abs_file)\n            res = __salt__['cmd.run_all'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n    return res",
            "def make_repo(repodir, keyid=None, env=None, use_passphrase=False, gnupghome='/etc/salt/gpgkeys', runas='root', timeout=15.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Make a package repository and optionally sign it and packages present\\n\\n    Given the repodir (directory to create repository in), create a Debian\\n    repository and optionally sign it and packages present. This state is\\n    best used with onchanges linked to your package building states.\\n\\n    repodir\\n        The directory to find packages that will be in the repository.\\n\\n    keyid\\n        .. versionchanged:: 2016.3.0\\n\\n        Optional Key ID to use in signing packages and repository.\\n        This consists of the last 8 hex digits of the GPG key ID.\\n\\n        Utilizes Public and Private keys associated with keyid which have\\n        been loaded into the minion\\'s Pillar data. Leverages gpg-agent and\\n        gpg-preset-passphrase for caching keys, etc.\\n        These pillar values are assumed to be filenames which are present\\n        in ``gnupghome``. The pillar keys shown below have to match exactly.\\n\\n        For example, contents from a Pillar data file with named Public\\n        and Private keys as follows:\\n\\n        .. code-block:: yaml\\n\\n            gpg_pkg_priv_keyname: gpg_pkg_key.pem\\n            gpg_pkg_pub_keyname: gpg_pkg_key.pub\\n\\n    env\\n        .. versionchanged:: 2016.3.0\\n\\n        A dictionary of environment variables to be utilized in creating the\\n        repository.\\n\\n    use_passphrase : False\\n        .. versionadded:: 2016.3.0\\n\\n        Use a passphrase with the signing key presented in ``keyid``.\\n        Passphrase is received from Pillar data which could be passed on the\\n        command line with ``pillar`` parameter. For example:\\n\\n        .. code-block:: bash\\n\\n            pillar=\\'{ \"gpg_passphrase\" : \"my_passphrase\" }\\'\\n\\n    gnupghome : /etc/salt/gpgkeys\\n        .. versionadded:: 2016.3.0\\n\\n        Location where GPG related files are stored, used with ``keyid``.\\n\\n    runas : root\\n        .. versionadded:: 2016.3.0\\n\\n        User to create the repository as, and optionally sign packages.\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n\\n    timeout : 15.0\\n        .. versionadded:: 2016.3.4\\n\\n        Timeout in seconds to wait for the prompt for inputting the passphrase.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkgbuild.make_repo /var/www/html\\n\\n    '\n    res = {'retcode': 1, 'stdout': '', 'stderr': 'initialization value'}\n    retrc = 0\n    if gnupghome and env is None:\n        env = {}\n        env['GNUPGHOME'] = gnupghome\n    repoconf = os.path.join(repodir, 'conf')\n    if not os.path.isdir(repoconf):\n        os.makedirs(repoconf)\n    (codename, repocfg_dists) = _get_repo_dists_env(env)\n    repoconfdist = os.path.join(repoconf, 'distributions')\n    with salt.utils.files.fopen(repoconfdist, 'w') as fow:\n        fow.write(salt.utils.stringutils.to_str(repocfg_dists))\n    repocfg_opts = _get_repo_options_env(env)\n    repoconfopts = os.path.join(repoconf, 'options')\n    with salt.utils.files.fopen(repoconfopts, 'w') as fow:\n        fow.write(salt.utils.stringutils.to_str(repocfg_opts))\n    cmd = 'chown {0}:{0} -R {1}'.format(runas, repoconf)\n    retrc = __salt__['cmd.retcode'](cmd, runas='root')\n    if retrc != 0:\n        raise SaltInvocationError('failed to ensure rights to repoconf directory, error {}, check logs for further details'.format(retrc))\n    local_keygrip_to_use = None\n    local_key_fingerprint = None\n    local_keyid = None\n    phrase = ''\n    gpg_info_file = '{}/gpg-agent-info-salt'.format(gnupghome)\n    gpg_tty_info_file = '{}/gpg-tty-info-salt'.format(gnupghome)\n    older_gnupg = __salt__['file.file_exists'](gpg_info_file)\n    if keyid is not None:\n        with salt.utils.files.fopen(repoconfdist, 'a') as fow:\n            fow.write(salt.utils.stringutils.to_str('SignWith: {}\\n'.format(keyid)))\n        pkg_pub_key_file = '{}/{}'.format(gnupghome, __salt__['pillar.get']('gpg_pkg_pub_keyname', None))\n        pkg_priv_key_file = '{}/{}'.format(gnupghome, __salt__['pillar.get']('gpg_pkg_priv_keyname', None))\n        if pkg_pub_key_file is None or pkg_priv_key_file is None:\n            raise SaltInvocationError(\"Pillar data should contain Public and Private keys associated with 'keyid'\")\n        try:\n            __salt__['gpg.import_key'](user=runas, filename=pkg_pub_key_file, gnupghome=gnupghome)\n            __salt__['gpg.import_key'](user=runas, filename=pkg_priv_key_file, gnupghome=gnupghome)\n        except SaltInvocationError:\n            raise SaltInvocationError(\"Public and Private key files associated with Pillar data and 'keyid' {} could not be found\".format(keyid))\n        local_keys = __salt__['gpg.list_keys'](user=runas, gnupghome=gnupghome)\n        for gpg_key in local_keys:\n            if keyid == gpg_key['keyid'][8:]:\n                local_keygrip_to_use = gpg_key['fingerprint']\n                local_key_fingerprint = gpg_key['fingerprint']\n                local_keyid = gpg_key['keyid']\n                break\n        if not older_gnupg:\n            try:\n                _check_repo_sign_utils_support('gpg2')\n                cmd = 'gpg2 --with-keygrip --list-secret-keys'\n            except CommandExecutionError:\n                cmd = 'gpg --with-keygrip --list-secret-keys'\n            local_keys2_keygrip = __salt__['cmd.run'](cmd, runas=runas, env=env)\n            local_keys2 = iter(local_keys2_keygrip.splitlines())\n            try:\n                for line in local_keys2:\n                    if line.startswith('sec'):\n                        line_fingerprint = next(local_keys2).lstrip().rstrip()\n                        if local_key_fingerprint == line_fingerprint:\n                            lkeygrip = next(local_keys2).split('=')\n                            local_keygrip_to_use = lkeygrip[1].lstrip().rstrip()\n                            break\n            except StopIteration:\n                raise SaltInvocationError(\"unable to find keygrip associated with fingerprint '{}' for keyid '{}'\".format(local_key_fingerprint, local_keyid))\n        if local_keyid is None:\n            raise SaltInvocationError(\"The key ID '{}' was not found in GnuPG keyring at '{}'\".format(keyid, gnupghome))\n        _check_repo_sign_utils_support('debsign')\n        if older_gnupg:\n            with salt.utils.files.fopen(gpg_info_file, 'r') as fow:\n                gpg_raw_info = fow.readlines()\n            for gpg_info_line in gpg_raw_info:\n                gpg_info_line = salt.utils.stringutils.to_unicode(gpg_info_line)\n                gpg_info = gpg_info_line.split('=')\n                env[gpg_info[0]] = gpg_info[1]\n                break\n        else:\n            with salt.utils.files.fopen(gpg_tty_info_file, 'r') as fow:\n                gpg_raw_info = fow.readlines()\n            for gpg_tty_info_line in gpg_raw_info:\n                gpg_tty_info_line = salt.utils.stringutils.to_unicode(gpg_tty_info_line)\n                gpg_tty_info = gpg_tty_info_line.split('=')\n                env[gpg_tty_info[0]] = gpg_tty_info[1]\n                break\n        if use_passphrase:\n            _check_repo_gpg_phrase_utils()\n            phrase = __salt__['pillar.get']('gpg_passphrase')\n            cmd = '/usr/lib/gnupg2/gpg-preset-passphrase --verbose --preset --passphrase \"{}\" {}'.format(phrase, local_keygrip_to_use)\n            retrc |= __salt__['cmd.retcode'](cmd, runas=runas, env=env)\n    for debfile in os.listdir(repodir):\n        abs_file = os.path.join(repodir, debfile)\n        if debfile.endswith('.changes'):\n            os.remove(abs_file)\n        if debfile.endswith('.dsc'):\n            if older_gnupg:\n                if local_keyid is not None:\n                    cmd = 'debsign --re-sign -k {} {}'.format(keyid, abs_file)\n                    retrc |= __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n                cmd = 'reprepro --ignore=wrongdistribution --component=main -Vb . includedsc {} {}'.format(codename, abs_file)\n                retrc |= __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n            else:\n                interval = 0.5\n                if local_keyid is not None:\n                    number_retries = timeout / interval\n                    times_looped = 0\n                    error_msg = 'Failed to debsign file {}'.format(abs_file)\n                    if __grains__['os'] in ['Ubuntu'] and __grains__['osmajorrelease'] < 18 or (__grains__['os'] in ['Debian'] and __grains__['osmajorrelease'] <= 8):\n                        cmd = 'debsign --re-sign -k {} {}'.format(keyid, abs_file)\n                        try:\n                            proc = salt.utils.vt.Terminal(cmd, env=env, shell=True, stream_stdout=True, stream_stderr=True)\n                            while proc.has_unread_data:\n                                (stdout, _) = proc.recv()\n                                if stdout and SIGN_PROMPT_RE.search(stdout):\n                                    proc.sendline(phrase)\n                                else:\n                                    times_looped += 1\n                                if times_looped > number_retries:\n                                    raise SaltInvocationError('Attempting to sign file {} failed, timed out after {} seconds'.format(abs_file, int(times_looped * interval)))\n                                time.sleep(interval)\n                            proc_exitstatus = proc.exitstatus\n                            if proc_exitstatus != 0:\n                                raise SaltInvocationError('Signing file {} failed with proc.status {}'.format(abs_file, proc_exitstatus))\n                        except salt.utils.vt.TerminalException as err:\n                            trace = traceback.format_exc()\n                            log.error(error_msg, err, trace)\n                            res = {'retcode': 1, 'stdout': '', 'stderr': trace}\n                        finally:\n                            proc.close(terminate=True, kill=True)\n                    else:\n                        cmd = 'debsign --re-sign -k {} {}'.format(local_key_fingerprint, abs_file)\n                        retrc |= __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n                number_retries = timeout / interval\n                times_looped = 0\n                error_msg = 'Failed to reprepro includedsc file {}'.format(abs_file)\n                cmd = 'reprepro --ignore=wrongdistribution --component=main -Vb . includedsc {} {}'.format(codename, abs_file)\n                if __grains__['os'] in ['Ubuntu'] and __grains__['osmajorrelease'] < 18 or (__grains__['os'] in ['Debian'] and __grains__['osmajorrelease'] <= 8):\n                    try:\n                        proc = salt.utils.vt.Terminal(cmd, env=env, shell=True, cwd=repodir, stream_stdout=True, stream_stderr=True)\n                        while proc.has_unread_data:\n                            (stdout, _) = proc.recv()\n                            if stdout and REPREPRO_SIGN_PROMPT_RE.search(stdout):\n                                proc.sendline(phrase)\n                            else:\n                                times_looped += 1\n                            if times_looped > number_retries:\n                                raise SaltInvocationError('Attempting to reprepro includedsc for file {} failed, timed out after {} loops'.format(abs_file, times_looped))\n                            time.sleep(interval)\n                        proc_exitstatus = proc.exitstatus\n                        if proc_exitstatus != 0:\n                            raise SaltInvocationError('Reprepro includedsc for codename {} and file {} failed with proc.status {}'.format(codename, abs_file, proc_exitstatus))\n                    except salt.utils.vt.TerminalException as err:\n                        trace = traceback.format_exc()\n                        log.error(error_msg, err, trace)\n                        res = {'retcode': 1, 'stdout': '', 'stderr': trace}\n                    finally:\n                        proc.close(terminate=True, kill=True)\n                else:\n                    retrc |= __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n        if retrc != 0:\n            raise SaltInvocationError('Making a repo encountered errors, return error {}, check logs for further details'.format(retrc))\n        if debfile.endswith('.deb'):\n            cmd = 'reprepro --ignore=wrongdistribution --component=main -Vb . includedeb {} {}'.format(codename, abs_file)\n            res = __salt__['cmd.run_all'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n    return res",
            "def make_repo(repodir, keyid=None, env=None, use_passphrase=False, gnupghome='/etc/salt/gpgkeys', runas='root', timeout=15.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Make a package repository and optionally sign it and packages present\\n\\n    Given the repodir (directory to create repository in), create a Debian\\n    repository and optionally sign it and packages present. This state is\\n    best used with onchanges linked to your package building states.\\n\\n    repodir\\n        The directory to find packages that will be in the repository.\\n\\n    keyid\\n        .. versionchanged:: 2016.3.0\\n\\n        Optional Key ID to use in signing packages and repository.\\n        This consists of the last 8 hex digits of the GPG key ID.\\n\\n        Utilizes Public and Private keys associated with keyid which have\\n        been loaded into the minion\\'s Pillar data. Leverages gpg-agent and\\n        gpg-preset-passphrase for caching keys, etc.\\n        These pillar values are assumed to be filenames which are present\\n        in ``gnupghome``. The pillar keys shown below have to match exactly.\\n\\n        For example, contents from a Pillar data file with named Public\\n        and Private keys as follows:\\n\\n        .. code-block:: yaml\\n\\n            gpg_pkg_priv_keyname: gpg_pkg_key.pem\\n            gpg_pkg_pub_keyname: gpg_pkg_key.pub\\n\\n    env\\n        .. versionchanged:: 2016.3.0\\n\\n        A dictionary of environment variables to be utilized in creating the\\n        repository.\\n\\n    use_passphrase : False\\n        .. versionadded:: 2016.3.0\\n\\n        Use a passphrase with the signing key presented in ``keyid``.\\n        Passphrase is received from Pillar data which could be passed on the\\n        command line with ``pillar`` parameter. For example:\\n\\n        .. code-block:: bash\\n\\n            pillar=\\'{ \"gpg_passphrase\" : \"my_passphrase\" }\\'\\n\\n    gnupghome : /etc/salt/gpgkeys\\n        .. versionadded:: 2016.3.0\\n\\n        Location where GPG related files are stored, used with ``keyid``.\\n\\n    runas : root\\n        .. versionadded:: 2016.3.0\\n\\n        User to create the repository as, and optionally sign packages.\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n\\n    timeout : 15.0\\n        .. versionadded:: 2016.3.4\\n\\n        Timeout in seconds to wait for the prompt for inputting the passphrase.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkgbuild.make_repo /var/www/html\\n\\n    '\n    res = {'retcode': 1, 'stdout': '', 'stderr': 'initialization value'}\n    retrc = 0\n    if gnupghome and env is None:\n        env = {}\n        env['GNUPGHOME'] = gnupghome\n    repoconf = os.path.join(repodir, 'conf')\n    if not os.path.isdir(repoconf):\n        os.makedirs(repoconf)\n    (codename, repocfg_dists) = _get_repo_dists_env(env)\n    repoconfdist = os.path.join(repoconf, 'distributions')\n    with salt.utils.files.fopen(repoconfdist, 'w') as fow:\n        fow.write(salt.utils.stringutils.to_str(repocfg_dists))\n    repocfg_opts = _get_repo_options_env(env)\n    repoconfopts = os.path.join(repoconf, 'options')\n    with salt.utils.files.fopen(repoconfopts, 'w') as fow:\n        fow.write(salt.utils.stringutils.to_str(repocfg_opts))\n    cmd = 'chown {0}:{0} -R {1}'.format(runas, repoconf)\n    retrc = __salt__['cmd.retcode'](cmd, runas='root')\n    if retrc != 0:\n        raise SaltInvocationError('failed to ensure rights to repoconf directory, error {}, check logs for further details'.format(retrc))\n    local_keygrip_to_use = None\n    local_key_fingerprint = None\n    local_keyid = None\n    phrase = ''\n    gpg_info_file = '{}/gpg-agent-info-salt'.format(gnupghome)\n    gpg_tty_info_file = '{}/gpg-tty-info-salt'.format(gnupghome)\n    older_gnupg = __salt__['file.file_exists'](gpg_info_file)\n    if keyid is not None:\n        with salt.utils.files.fopen(repoconfdist, 'a') as fow:\n            fow.write(salt.utils.stringutils.to_str('SignWith: {}\\n'.format(keyid)))\n        pkg_pub_key_file = '{}/{}'.format(gnupghome, __salt__['pillar.get']('gpg_pkg_pub_keyname', None))\n        pkg_priv_key_file = '{}/{}'.format(gnupghome, __salt__['pillar.get']('gpg_pkg_priv_keyname', None))\n        if pkg_pub_key_file is None or pkg_priv_key_file is None:\n            raise SaltInvocationError(\"Pillar data should contain Public and Private keys associated with 'keyid'\")\n        try:\n            __salt__['gpg.import_key'](user=runas, filename=pkg_pub_key_file, gnupghome=gnupghome)\n            __salt__['gpg.import_key'](user=runas, filename=pkg_priv_key_file, gnupghome=gnupghome)\n        except SaltInvocationError:\n            raise SaltInvocationError(\"Public and Private key files associated with Pillar data and 'keyid' {} could not be found\".format(keyid))\n        local_keys = __salt__['gpg.list_keys'](user=runas, gnupghome=gnupghome)\n        for gpg_key in local_keys:\n            if keyid == gpg_key['keyid'][8:]:\n                local_keygrip_to_use = gpg_key['fingerprint']\n                local_key_fingerprint = gpg_key['fingerprint']\n                local_keyid = gpg_key['keyid']\n                break\n        if not older_gnupg:\n            try:\n                _check_repo_sign_utils_support('gpg2')\n                cmd = 'gpg2 --with-keygrip --list-secret-keys'\n            except CommandExecutionError:\n                cmd = 'gpg --with-keygrip --list-secret-keys'\n            local_keys2_keygrip = __salt__['cmd.run'](cmd, runas=runas, env=env)\n            local_keys2 = iter(local_keys2_keygrip.splitlines())\n            try:\n                for line in local_keys2:\n                    if line.startswith('sec'):\n                        line_fingerprint = next(local_keys2).lstrip().rstrip()\n                        if local_key_fingerprint == line_fingerprint:\n                            lkeygrip = next(local_keys2).split('=')\n                            local_keygrip_to_use = lkeygrip[1].lstrip().rstrip()\n                            break\n            except StopIteration:\n                raise SaltInvocationError(\"unable to find keygrip associated with fingerprint '{}' for keyid '{}'\".format(local_key_fingerprint, local_keyid))\n        if local_keyid is None:\n            raise SaltInvocationError(\"The key ID '{}' was not found in GnuPG keyring at '{}'\".format(keyid, gnupghome))\n        _check_repo_sign_utils_support('debsign')\n        if older_gnupg:\n            with salt.utils.files.fopen(gpg_info_file, 'r') as fow:\n                gpg_raw_info = fow.readlines()\n            for gpg_info_line in gpg_raw_info:\n                gpg_info_line = salt.utils.stringutils.to_unicode(gpg_info_line)\n                gpg_info = gpg_info_line.split('=')\n                env[gpg_info[0]] = gpg_info[1]\n                break\n        else:\n            with salt.utils.files.fopen(gpg_tty_info_file, 'r') as fow:\n                gpg_raw_info = fow.readlines()\n            for gpg_tty_info_line in gpg_raw_info:\n                gpg_tty_info_line = salt.utils.stringutils.to_unicode(gpg_tty_info_line)\n                gpg_tty_info = gpg_tty_info_line.split('=')\n                env[gpg_tty_info[0]] = gpg_tty_info[1]\n                break\n        if use_passphrase:\n            _check_repo_gpg_phrase_utils()\n            phrase = __salt__['pillar.get']('gpg_passphrase')\n            cmd = '/usr/lib/gnupg2/gpg-preset-passphrase --verbose --preset --passphrase \"{}\" {}'.format(phrase, local_keygrip_to_use)\n            retrc |= __salt__['cmd.retcode'](cmd, runas=runas, env=env)\n    for debfile in os.listdir(repodir):\n        abs_file = os.path.join(repodir, debfile)\n        if debfile.endswith('.changes'):\n            os.remove(abs_file)\n        if debfile.endswith('.dsc'):\n            if older_gnupg:\n                if local_keyid is not None:\n                    cmd = 'debsign --re-sign -k {} {}'.format(keyid, abs_file)\n                    retrc |= __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n                cmd = 'reprepro --ignore=wrongdistribution --component=main -Vb . includedsc {} {}'.format(codename, abs_file)\n                retrc |= __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n            else:\n                interval = 0.5\n                if local_keyid is not None:\n                    number_retries = timeout / interval\n                    times_looped = 0\n                    error_msg = 'Failed to debsign file {}'.format(abs_file)\n                    if __grains__['os'] in ['Ubuntu'] and __grains__['osmajorrelease'] < 18 or (__grains__['os'] in ['Debian'] and __grains__['osmajorrelease'] <= 8):\n                        cmd = 'debsign --re-sign -k {} {}'.format(keyid, abs_file)\n                        try:\n                            proc = salt.utils.vt.Terminal(cmd, env=env, shell=True, stream_stdout=True, stream_stderr=True)\n                            while proc.has_unread_data:\n                                (stdout, _) = proc.recv()\n                                if stdout and SIGN_PROMPT_RE.search(stdout):\n                                    proc.sendline(phrase)\n                                else:\n                                    times_looped += 1\n                                if times_looped > number_retries:\n                                    raise SaltInvocationError('Attempting to sign file {} failed, timed out after {} seconds'.format(abs_file, int(times_looped * interval)))\n                                time.sleep(interval)\n                            proc_exitstatus = proc.exitstatus\n                            if proc_exitstatus != 0:\n                                raise SaltInvocationError('Signing file {} failed with proc.status {}'.format(abs_file, proc_exitstatus))\n                        except salt.utils.vt.TerminalException as err:\n                            trace = traceback.format_exc()\n                            log.error(error_msg, err, trace)\n                            res = {'retcode': 1, 'stdout': '', 'stderr': trace}\n                        finally:\n                            proc.close(terminate=True, kill=True)\n                    else:\n                        cmd = 'debsign --re-sign -k {} {}'.format(local_key_fingerprint, abs_file)\n                        retrc |= __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n                number_retries = timeout / interval\n                times_looped = 0\n                error_msg = 'Failed to reprepro includedsc file {}'.format(abs_file)\n                cmd = 'reprepro --ignore=wrongdistribution --component=main -Vb . includedsc {} {}'.format(codename, abs_file)\n                if __grains__['os'] in ['Ubuntu'] and __grains__['osmajorrelease'] < 18 or (__grains__['os'] in ['Debian'] and __grains__['osmajorrelease'] <= 8):\n                    try:\n                        proc = salt.utils.vt.Terminal(cmd, env=env, shell=True, cwd=repodir, stream_stdout=True, stream_stderr=True)\n                        while proc.has_unread_data:\n                            (stdout, _) = proc.recv()\n                            if stdout and REPREPRO_SIGN_PROMPT_RE.search(stdout):\n                                proc.sendline(phrase)\n                            else:\n                                times_looped += 1\n                            if times_looped > number_retries:\n                                raise SaltInvocationError('Attempting to reprepro includedsc for file {} failed, timed out after {} loops'.format(abs_file, times_looped))\n                            time.sleep(interval)\n                        proc_exitstatus = proc.exitstatus\n                        if proc_exitstatus != 0:\n                            raise SaltInvocationError('Reprepro includedsc for codename {} and file {} failed with proc.status {}'.format(codename, abs_file, proc_exitstatus))\n                    except salt.utils.vt.TerminalException as err:\n                        trace = traceback.format_exc()\n                        log.error(error_msg, err, trace)\n                        res = {'retcode': 1, 'stdout': '', 'stderr': trace}\n                    finally:\n                        proc.close(terminate=True, kill=True)\n                else:\n                    retrc |= __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n        if retrc != 0:\n            raise SaltInvocationError('Making a repo encountered errors, return error {}, check logs for further details'.format(retrc))\n        if debfile.endswith('.deb'):\n            cmd = 'reprepro --ignore=wrongdistribution --component=main -Vb . includedeb {} {}'.format(codename, abs_file)\n            res = __salt__['cmd.run_all'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n    return res",
            "def make_repo(repodir, keyid=None, env=None, use_passphrase=False, gnupghome='/etc/salt/gpgkeys', runas='root', timeout=15.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Make a package repository and optionally sign it and packages present\\n\\n    Given the repodir (directory to create repository in), create a Debian\\n    repository and optionally sign it and packages present. This state is\\n    best used with onchanges linked to your package building states.\\n\\n    repodir\\n        The directory to find packages that will be in the repository.\\n\\n    keyid\\n        .. versionchanged:: 2016.3.0\\n\\n        Optional Key ID to use in signing packages and repository.\\n        This consists of the last 8 hex digits of the GPG key ID.\\n\\n        Utilizes Public and Private keys associated with keyid which have\\n        been loaded into the minion\\'s Pillar data. Leverages gpg-agent and\\n        gpg-preset-passphrase for caching keys, etc.\\n        These pillar values are assumed to be filenames which are present\\n        in ``gnupghome``. The pillar keys shown below have to match exactly.\\n\\n        For example, contents from a Pillar data file with named Public\\n        and Private keys as follows:\\n\\n        .. code-block:: yaml\\n\\n            gpg_pkg_priv_keyname: gpg_pkg_key.pem\\n            gpg_pkg_pub_keyname: gpg_pkg_key.pub\\n\\n    env\\n        .. versionchanged:: 2016.3.0\\n\\n        A dictionary of environment variables to be utilized in creating the\\n        repository.\\n\\n    use_passphrase : False\\n        .. versionadded:: 2016.3.0\\n\\n        Use a passphrase with the signing key presented in ``keyid``.\\n        Passphrase is received from Pillar data which could be passed on the\\n        command line with ``pillar`` parameter. For example:\\n\\n        .. code-block:: bash\\n\\n            pillar=\\'{ \"gpg_passphrase\" : \"my_passphrase\" }\\'\\n\\n    gnupghome : /etc/salt/gpgkeys\\n        .. versionadded:: 2016.3.0\\n\\n        Location where GPG related files are stored, used with ``keyid``.\\n\\n    runas : root\\n        .. versionadded:: 2016.3.0\\n\\n        User to create the repository as, and optionally sign packages.\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n\\n    timeout : 15.0\\n        .. versionadded:: 2016.3.4\\n\\n        Timeout in seconds to wait for the prompt for inputting the passphrase.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkgbuild.make_repo /var/www/html\\n\\n    '\n    res = {'retcode': 1, 'stdout': '', 'stderr': 'initialization value'}\n    retrc = 0\n    if gnupghome and env is None:\n        env = {}\n        env['GNUPGHOME'] = gnupghome\n    repoconf = os.path.join(repodir, 'conf')\n    if not os.path.isdir(repoconf):\n        os.makedirs(repoconf)\n    (codename, repocfg_dists) = _get_repo_dists_env(env)\n    repoconfdist = os.path.join(repoconf, 'distributions')\n    with salt.utils.files.fopen(repoconfdist, 'w') as fow:\n        fow.write(salt.utils.stringutils.to_str(repocfg_dists))\n    repocfg_opts = _get_repo_options_env(env)\n    repoconfopts = os.path.join(repoconf, 'options')\n    with salt.utils.files.fopen(repoconfopts, 'w') as fow:\n        fow.write(salt.utils.stringutils.to_str(repocfg_opts))\n    cmd = 'chown {0}:{0} -R {1}'.format(runas, repoconf)\n    retrc = __salt__['cmd.retcode'](cmd, runas='root')\n    if retrc != 0:\n        raise SaltInvocationError('failed to ensure rights to repoconf directory, error {}, check logs for further details'.format(retrc))\n    local_keygrip_to_use = None\n    local_key_fingerprint = None\n    local_keyid = None\n    phrase = ''\n    gpg_info_file = '{}/gpg-agent-info-salt'.format(gnupghome)\n    gpg_tty_info_file = '{}/gpg-tty-info-salt'.format(gnupghome)\n    older_gnupg = __salt__['file.file_exists'](gpg_info_file)\n    if keyid is not None:\n        with salt.utils.files.fopen(repoconfdist, 'a') as fow:\n            fow.write(salt.utils.stringutils.to_str('SignWith: {}\\n'.format(keyid)))\n        pkg_pub_key_file = '{}/{}'.format(gnupghome, __salt__['pillar.get']('gpg_pkg_pub_keyname', None))\n        pkg_priv_key_file = '{}/{}'.format(gnupghome, __salt__['pillar.get']('gpg_pkg_priv_keyname', None))\n        if pkg_pub_key_file is None or pkg_priv_key_file is None:\n            raise SaltInvocationError(\"Pillar data should contain Public and Private keys associated with 'keyid'\")\n        try:\n            __salt__['gpg.import_key'](user=runas, filename=pkg_pub_key_file, gnupghome=gnupghome)\n            __salt__['gpg.import_key'](user=runas, filename=pkg_priv_key_file, gnupghome=gnupghome)\n        except SaltInvocationError:\n            raise SaltInvocationError(\"Public and Private key files associated with Pillar data and 'keyid' {} could not be found\".format(keyid))\n        local_keys = __salt__['gpg.list_keys'](user=runas, gnupghome=gnupghome)\n        for gpg_key in local_keys:\n            if keyid == gpg_key['keyid'][8:]:\n                local_keygrip_to_use = gpg_key['fingerprint']\n                local_key_fingerprint = gpg_key['fingerprint']\n                local_keyid = gpg_key['keyid']\n                break\n        if not older_gnupg:\n            try:\n                _check_repo_sign_utils_support('gpg2')\n                cmd = 'gpg2 --with-keygrip --list-secret-keys'\n            except CommandExecutionError:\n                cmd = 'gpg --with-keygrip --list-secret-keys'\n            local_keys2_keygrip = __salt__['cmd.run'](cmd, runas=runas, env=env)\n            local_keys2 = iter(local_keys2_keygrip.splitlines())\n            try:\n                for line in local_keys2:\n                    if line.startswith('sec'):\n                        line_fingerprint = next(local_keys2).lstrip().rstrip()\n                        if local_key_fingerprint == line_fingerprint:\n                            lkeygrip = next(local_keys2).split('=')\n                            local_keygrip_to_use = lkeygrip[1].lstrip().rstrip()\n                            break\n            except StopIteration:\n                raise SaltInvocationError(\"unable to find keygrip associated with fingerprint '{}' for keyid '{}'\".format(local_key_fingerprint, local_keyid))\n        if local_keyid is None:\n            raise SaltInvocationError(\"The key ID '{}' was not found in GnuPG keyring at '{}'\".format(keyid, gnupghome))\n        _check_repo_sign_utils_support('debsign')\n        if older_gnupg:\n            with salt.utils.files.fopen(gpg_info_file, 'r') as fow:\n                gpg_raw_info = fow.readlines()\n            for gpg_info_line in gpg_raw_info:\n                gpg_info_line = salt.utils.stringutils.to_unicode(gpg_info_line)\n                gpg_info = gpg_info_line.split('=')\n                env[gpg_info[0]] = gpg_info[1]\n                break\n        else:\n            with salt.utils.files.fopen(gpg_tty_info_file, 'r') as fow:\n                gpg_raw_info = fow.readlines()\n            for gpg_tty_info_line in gpg_raw_info:\n                gpg_tty_info_line = salt.utils.stringutils.to_unicode(gpg_tty_info_line)\n                gpg_tty_info = gpg_tty_info_line.split('=')\n                env[gpg_tty_info[0]] = gpg_tty_info[1]\n                break\n        if use_passphrase:\n            _check_repo_gpg_phrase_utils()\n            phrase = __salt__['pillar.get']('gpg_passphrase')\n            cmd = '/usr/lib/gnupg2/gpg-preset-passphrase --verbose --preset --passphrase \"{}\" {}'.format(phrase, local_keygrip_to_use)\n            retrc |= __salt__['cmd.retcode'](cmd, runas=runas, env=env)\n    for debfile in os.listdir(repodir):\n        abs_file = os.path.join(repodir, debfile)\n        if debfile.endswith('.changes'):\n            os.remove(abs_file)\n        if debfile.endswith('.dsc'):\n            if older_gnupg:\n                if local_keyid is not None:\n                    cmd = 'debsign --re-sign -k {} {}'.format(keyid, abs_file)\n                    retrc |= __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n                cmd = 'reprepro --ignore=wrongdistribution --component=main -Vb . includedsc {} {}'.format(codename, abs_file)\n                retrc |= __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n            else:\n                interval = 0.5\n                if local_keyid is not None:\n                    number_retries = timeout / interval\n                    times_looped = 0\n                    error_msg = 'Failed to debsign file {}'.format(abs_file)\n                    if __grains__['os'] in ['Ubuntu'] and __grains__['osmajorrelease'] < 18 or (__grains__['os'] in ['Debian'] and __grains__['osmajorrelease'] <= 8):\n                        cmd = 'debsign --re-sign -k {} {}'.format(keyid, abs_file)\n                        try:\n                            proc = salt.utils.vt.Terminal(cmd, env=env, shell=True, stream_stdout=True, stream_stderr=True)\n                            while proc.has_unread_data:\n                                (stdout, _) = proc.recv()\n                                if stdout and SIGN_PROMPT_RE.search(stdout):\n                                    proc.sendline(phrase)\n                                else:\n                                    times_looped += 1\n                                if times_looped > number_retries:\n                                    raise SaltInvocationError('Attempting to sign file {} failed, timed out after {} seconds'.format(abs_file, int(times_looped * interval)))\n                                time.sleep(interval)\n                            proc_exitstatus = proc.exitstatus\n                            if proc_exitstatus != 0:\n                                raise SaltInvocationError('Signing file {} failed with proc.status {}'.format(abs_file, proc_exitstatus))\n                        except salt.utils.vt.TerminalException as err:\n                            trace = traceback.format_exc()\n                            log.error(error_msg, err, trace)\n                            res = {'retcode': 1, 'stdout': '', 'stderr': trace}\n                        finally:\n                            proc.close(terminate=True, kill=True)\n                    else:\n                        cmd = 'debsign --re-sign -k {} {}'.format(local_key_fingerprint, abs_file)\n                        retrc |= __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n                number_retries = timeout / interval\n                times_looped = 0\n                error_msg = 'Failed to reprepro includedsc file {}'.format(abs_file)\n                cmd = 'reprepro --ignore=wrongdistribution --component=main -Vb . includedsc {} {}'.format(codename, abs_file)\n                if __grains__['os'] in ['Ubuntu'] and __grains__['osmajorrelease'] < 18 or (__grains__['os'] in ['Debian'] and __grains__['osmajorrelease'] <= 8):\n                    try:\n                        proc = salt.utils.vt.Terminal(cmd, env=env, shell=True, cwd=repodir, stream_stdout=True, stream_stderr=True)\n                        while proc.has_unread_data:\n                            (stdout, _) = proc.recv()\n                            if stdout and REPREPRO_SIGN_PROMPT_RE.search(stdout):\n                                proc.sendline(phrase)\n                            else:\n                                times_looped += 1\n                            if times_looped > number_retries:\n                                raise SaltInvocationError('Attempting to reprepro includedsc for file {} failed, timed out after {} loops'.format(abs_file, times_looped))\n                            time.sleep(interval)\n                        proc_exitstatus = proc.exitstatus\n                        if proc_exitstatus != 0:\n                            raise SaltInvocationError('Reprepro includedsc for codename {} and file {} failed with proc.status {}'.format(codename, abs_file, proc_exitstatus))\n                    except salt.utils.vt.TerminalException as err:\n                        trace = traceback.format_exc()\n                        log.error(error_msg, err, trace)\n                        res = {'retcode': 1, 'stdout': '', 'stderr': trace}\n                    finally:\n                        proc.close(terminate=True, kill=True)\n                else:\n                    retrc |= __salt__['cmd.retcode'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n        if retrc != 0:\n            raise SaltInvocationError('Making a repo encountered errors, return error {}, check logs for further details'.format(retrc))\n        if debfile.endswith('.deb'):\n            cmd = 'reprepro --ignore=wrongdistribution --component=main -Vb . includedeb {} {}'.format(codename, abs_file)\n            res = __salt__['cmd.run_all'](cmd, runas=runas, cwd=repodir, use_vt=True, env=env)\n    return res"
        ]
    }
]