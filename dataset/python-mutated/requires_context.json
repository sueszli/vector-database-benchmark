[
    {
        "func_name": "__init__",
        "original": "def __init__(self, inner_value: Callable[[_EnvType], _ReturnType]) -> None:\n    \"\"\"\n        Public constructor for this type. Also required for typing.\n\n        Only allows functions of kind ``* -> *``.\n\n        .. code:: python\n\n          >>> from returns.context import RequiresContext\n          >>> str(RequiresContext(lambda deps: deps + 1))\n          '<RequiresContext: <function <lambda> at ...>>'\n\n        \"\"\"\n    super().__init__(inner_value)",
        "mutated": [
            "def __init__(self, inner_value: Callable[[_EnvType], _ReturnType]) -> None:\n    if False:\n        i = 10\n    \"\\n        Public constructor for this type. Also required for typing.\\n\\n        Only allows functions of kind ``* -> *``.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> str(RequiresContext(lambda deps: deps + 1))\\n          '<RequiresContext: <function <lambda> at ...>>'\\n\\n        \"\n    super().__init__(inner_value)",
            "def __init__(self, inner_value: Callable[[_EnvType], _ReturnType]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Public constructor for this type. Also required for typing.\\n\\n        Only allows functions of kind ``* -> *``.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> str(RequiresContext(lambda deps: deps + 1))\\n          '<RequiresContext: <function <lambda> at ...>>'\\n\\n        \"\n    super().__init__(inner_value)",
            "def __init__(self, inner_value: Callable[[_EnvType], _ReturnType]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Public constructor for this type. Also required for typing.\\n\\n        Only allows functions of kind ``* -> *``.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> str(RequiresContext(lambda deps: deps + 1))\\n          '<RequiresContext: <function <lambda> at ...>>'\\n\\n        \"\n    super().__init__(inner_value)",
            "def __init__(self, inner_value: Callable[[_EnvType], _ReturnType]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Public constructor for this type. Also required for typing.\\n\\n        Only allows functions of kind ``* -> *``.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> str(RequiresContext(lambda deps: deps + 1))\\n          '<RequiresContext: <function <lambda> at ...>>'\\n\\n        \"\n    super().__init__(inner_value)",
            "def __init__(self, inner_value: Callable[[_EnvType], _ReturnType]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Public constructor for this type. Also required for typing.\\n\\n        Only allows functions of kind ``* -> *``.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> str(RequiresContext(lambda deps: deps + 1))\\n          '<RequiresContext: <function <lambda> at ...>>'\\n\\n        \"\n    super().__init__(inner_value)"
        ]
    },
    {
        "func_name": "__call__",
        "original": "def __call__(self, deps: _EnvType) -> _ReturnType:\n    \"\"\"\n        Evaluates the wrapped function.\n\n        .. code:: python\n\n          >>> from returns.context import RequiresContext\n\n          >>> def first(lg: bool) -> RequiresContext[int, float]:\n          ...     # `deps` has `float` type here:\n          ...     return RequiresContext(\n          ...         lambda deps: deps if lg else -deps,\n          ...     )\n\n          >>> instance = first(False)  # creating `RequiresContext` instance\n          >>> assert instance(3.5) == -3.5 # calling it with `__call__`\n\n          >>> # Example with another logic:\n          >>> assert first(True)(3.5) == 3.5\n\n        In other things, it is a regular python magic method.\n        \"\"\"\n    return self._inner_value(deps)",
        "mutated": [
            "def __call__(self, deps: _EnvType) -> _ReturnType:\n    if False:\n        i = 10\n    '\\n        Evaluates the wrapped function.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n\\n          >>> def first(lg: bool) -> RequiresContext[int, float]:\\n          ...     # `deps` has `float` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps if lg else -deps,\\n          ...     )\\n\\n          >>> instance = first(False)  # creating `RequiresContext` instance\\n          >>> assert instance(3.5) == -3.5 # calling it with `__call__`\\n\\n          >>> # Example with another logic:\\n          >>> assert first(True)(3.5) == 3.5\\n\\n        In other things, it is a regular python magic method.\\n        '\n    return self._inner_value(deps)",
            "def __call__(self, deps: _EnvType) -> _ReturnType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Evaluates the wrapped function.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n\\n          >>> def first(lg: bool) -> RequiresContext[int, float]:\\n          ...     # `deps` has `float` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps if lg else -deps,\\n          ...     )\\n\\n          >>> instance = first(False)  # creating `RequiresContext` instance\\n          >>> assert instance(3.5) == -3.5 # calling it with `__call__`\\n\\n          >>> # Example with another logic:\\n          >>> assert first(True)(3.5) == 3.5\\n\\n        In other things, it is a regular python magic method.\\n        '\n    return self._inner_value(deps)",
            "def __call__(self, deps: _EnvType) -> _ReturnType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Evaluates the wrapped function.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n\\n          >>> def first(lg: bool) -> RequiresContext[int, float]:\\n          ...     # `deps` has `float` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps if lg else -deps,\\n          ...     )\\n\\n          >>> instance = first(False)  # creating `RequiresContext` instance\\n          >>> assert instance(3.5) == -3.5 # calling it with `__call__`\\n\\n          >>> # Example with another logic:\\n          >>> assert first(True)(3.5) == 3.5\\n\\n        In other things, it is a regular python magic method.\\n        '\n    return self._inner_value(deps)",
            "def __call__(self, deps: _EnvType) -> _ReturnType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Evaluates the wrapped function.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n\\n          >>> def first(lg: bool) -> RequiresContext[int, float]:\\n          ...     # `deps` has `float` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps if lg else -deps,\\n          ...     )\\n\\n          >>> instance = first(False)  # creating `RequiresContext` instance\\n          >>> assert instance(3.5) == -3.5 # calling it with `__call__`\\n\\n          >>> # Example with another logic:\\n          >>> assert first(True)(3.5) == 3.5\\n\\n        In other things, it is a regular python magic method.\\n        '\n    return self._inner_value(deps)",
            "def __call__(self, deps: _EnvType) -> _ReturnType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Evaluates the wrapped function.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n\\n          >>> def first(lg: bool) -> RequiresContext[int, float]:\\n          ...     # `deps` has `float` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps if lg else -deps,\\n          ...     )\\n\\n          >>> instance = first(False)  # creating `RequiresContext` instance\\n          >>> assert instance(3.5) == -3.5 # calling it with `__call__`\\n\\n          >>> # Example with another logic:\\n          >>> assert first(True)(3.5) == 3.5\\n\\n        In other things, it is a regular python magic method.\\n        '\n    return self._inner_value(deps)"
        ]
    },
    {
        "func_name": "map",
        "original": "def map(self, function: Callable[[_ReturnType], _NewReturnType]) -> RequiresContext[_NewReturnType, _EnvType]:\n    \"\"\"\n        Allows to compose functions inside the wrapped container.\n\n        Here's how it works:\n\n        .. code:: python\n\n          >>> from returns.context import RequiresContext\n          >>> def first(lg: bool) -> RequiresContext[int, float]:\n          ...     # `deps` has `float` type here:\n          ...     return RequiresContext(\n          ...         lambda deps: deps if lg else -deps,\n          ...     )\n\n          >>> assert first(True).map(lambda number: number * 10)(2.5) == 25.0\n          >>> assert first(False).map(lambda number: number * 10)(0.1) -1.0\n\n        \"\"\"\n    return RequiresContext(lambda deps: function(self(deps)))",
        "mutated": [
            "def map(self, function: Callable[[_ReturnType], _NewReturnType]) -> RequiresContext[_NewReturnType, _EnvType]:\n    if False:\n        i = 10\n    \"\\n        Allows to compose functions inside the wrapped container.\\n\\n        Here's how it works:\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> def first(lg: bool) -> RequiresContext[int, float]:\\n          ...     # `deps` has `float` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps if lg else -deps,\\n          ...     )\\n\\n          >>> assert first(True).map(lambda number: number * 10)(2.5) == 25.0\\n          >>> assert first(False).map(lambda number: number * 10)(0.1) -1.0\\n\\n        \"\n    return RequiresContext(lambda deps: function(self(deps)))",
            "def map(self, function: Callable[[_ReturnType], _NewReturnType]) -> RequiresContext[_NewReturnType, _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Allows to compose functions inside the wrapped container.\\n\\n        Here's how it works:\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> def first(lg: bool) -> RequiresContext[int, float]:\\n          ...     # `deps` has `float` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps if lg else -deps,\\n          ...     )\\n\\n          >>> assert first(True).map(lambda number: number * 10)(2.5) == 25.0\\n          >>> assert first(False).map(lambda number: number * 10)(0.1) -1.0\\n\\n        \"\n    return RequiresContext(lambda deps: function(self(deps)))",
            "def map(self, function: Callable[[_ReturnType], _NewReturnType]) -> RequiresContext[_NewReturnType, _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Allows to compose functions inside the wrapped container.\\n\\n        Here's how it works:\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> def first(lg: bool) -> RequiresContext[int, float]:\\n          ...     # `deps` has `float` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps if lg else -deps,\\n          ...     )\\n\\n          >>> assert first(True).map(lambda number: number * 10)(2.5) == 25.0\\n          >>> assert first(False).map(lambda number: number * 10)(0.1) -1.0\\n\\n        \"\n    return RequiresContext(lambda deps: function(self(deps)))",
            "def map(self, function: Callable[[_ReturnType], _NewReturnType]) -> RequiresContext[_NewReturnType, _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Allows to compose functions inside the wrapped container.\\n\\n        Here's how it works:\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> def first(lg: bool) -> RequiresContext[int, float]:\\n          ...     # `deps` has `float` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps if lg else -deps,\\n          ...     )\\n\\n          >>> assert first(True).map(lambda number: number * 10)(2.5) == 25.0\\n          >>> assert first(False).map(lambda number: number * 10)(0.1) -1.0\\n\\n        \"\n    return RequiresContext(lambda deps: function(self(deps)))",
            "def map(self, function: Callable[[_ReturnType], _NewReturnType]) -> RequiresContext[_NewReturnType, _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Allows to compose functions inside the wrapped container.\\n\\n        Here's how it works:\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> def first(lg: bool) -> RequiresContext[int, float]:\\n          ...     # `deps` has `float` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps if lg else -deps,\\n          ...     )\\n\\n          >>> assert first(True).map(lambda number: number * 10)(2.5) == 25.0\\n          >>> assert first(False).map(lambda number: number * 10)(0.1) -1.0\\n\\n        \"\n    return RequiresContext(lambda deps: function(self(deps)))"
        ]
    },
    {
        "func_name": "apply",
        "original": "def apply(self, container: Kind2[RequiresContext, Callable[[_ReturnType], _NewReturnType], _EnvType]) -> RequiresContext[_NewReturnType, _EnvType]:\n    \"\"\"\n        Calls a wrapped function in a container on this container.\n\n        .. code:: python\n\n          >>> from returns.context import RequiresContext\n          >>> assert RequiresContext.from_value('a').apply(\n          ...    RequiresContext.from_value(lambda inner: inner + 'b')\n          ... )(...) == 'ab'\n\n        \"\"\"\n    return RequiresContext(lambda deps: self.map(dekind(container)(deps))(deps))",
        "mutated": [
            "def apply(self, container: Kind2[RequiresContext, Callable[[_ReturnType], _NewReturnType], _EnvType]) -> RequiresContext[_NewReturnType, _EnvType]:\n    if False:\n        i = 10\n    \"\\n        Calls a wrapped function in a container on this container.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> assert RequiresContext.from_value('a').apply(\\n          ...    RequiresContext.from_value(lambda inner: inner + 'b')\\n          ... )(...) == 'ab'\\n\\n        \"\n    return RequiresContext(lambda deps: self.map(dekind(container)(deps))(deps))",
            "def apply(self, container: Kind2[RequiresContext, Callable[[_ReturnType], _NewReturnType], _EnvType]) -> RequiresContext[_NewReturnType, _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Calls a wrapped function in a container on this container.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> assert RequiresContext.from_value('a').apply(\\n          ...    RequiresContext.from_value(lambda inner: inner + 'b')\\n          ... )(...) == 'ab'\\n\\n        \"\n    return RequiresContext(lambda deps: self.map(dekind(container)(deps))(deps))",
            "def apply(self, container: Kind2[RequiresContext, Callable[[_ReturnType], _NewReturnType], _EnvType]) -> RequiresContext[_NewReturnType, _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Calls a wrapped function in a container on this container.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> assert RequiresContext.from_value('a').apply(\\n          ...    RequiresContext.from_value(lambda inner: inner + 'b')\\n          ... )(...) == 'ab'\\n\\n        \"\n    return RequiresContext(lambda deps: self.map(dekind(container)(deps))(deps))",
            "def apply(self, container: Kind2[RequiresContext, Callable[[_ReturnType], _NewReturnType], _EnvType]) -> RequiresContext[_NewReturnType, _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Calls a wrapped function in a container on this container.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> assert RequiresContext.from_value('a').apply(\\n          ...    RequiresContext.from_value(lambda inner: inner + 'b')\\n          ... )(...) == 'ab'\\n\\n        \"\n    return RequiresContext(lambda deps: self.map(dekind(container)(deps))(deps))",
            "def apply(self, container: Kind2[RequiresContext, Callable[[_ReturnType], _NewReturnType], _EnvType]) -> RequiresContext[_NewReturnType, _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Calls a wrapped function in a container on this container.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> assert RequiresContext.from_value('a').apply(\\n          ...    RequiresContext.from_value(lambda inner: inner + 'b')\\n          ... )(...) == 'ab'\\n\\n        \"\n    return RequiresContext(lambda deps: self.map(dekind(container)(deps))(deps))"
        ]
    },
    {
        "func_name": "bind",
        "original": "def bind(self, function: Callable[[_ReturnType], Kind2[RequiresContext, _NewReturnType, _EnvType]]) -> RequiresContext[_NewReturnType, _EnvType]:\n    \"\"\"\n        Composes a container with a function returning another container.\n\n        This is useful when you do several computations that rely on the\n        same context.\n\n        .. code:: python\n\n          >>> from returns.context import RequiresContext\n\n          >>> def first(lg: bool) -> RequiresContext[int, float]:\n          ...     # `deps` has `float` type here:\n          ...     return RequiresContext(\n          ...         lambda deps: deps if lg else -deps,\n          ...     )\n\n          >>> def second(number: int) -> RequiresContext[str, float]:\n          ...     # `deps` has `float` type here:\n          ...     return RequiresContext(\n          ...         lambda deps: '>=' if number >= deps else '<',\n          ...     )\n\n          >>> assert first(True).bind(second)(1) == '>='\n          >>> assert first(False).bind(second)(2) == '<'\n\n        \"\"\"\n    return RequiresContext(lambda deps: dekind(function(self(deps)))(deps))",
        "mutated": [
            "def bind(self, function: Callable[[_ReturnType], Kind2[RequiresContext, _NewReturnType, _EnvType]]) -> RequiresContext[_NewReturnType, _EnvType]:\n    if False:\n        i = 10\n    \"\\n        Composes a container with a function returning another container.\\n\\n        This is useful when you do several computations that rely on the\\n        same context.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n\\n          >>> def first(lg: bool) -> RequiresContext[int, float]:\\n          ...     # `deps` has `float` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps if lg else -deps,\\n          ...     )\\n\\n          >>> def second(number: int) -> RequiresContext[str, float]:\\n          ...     # `deps` has `float` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: '>=' if number >= deps else '<',\\n          ...     )\\n\\n          >>> assert first(True).bind(second)(1) == '>='\\n          >>> assert first(False).bind(second)(2) == '<'\\n\\n        \"\n    return RequiresContext(lambda deps: dekind(function(self(deps)))(deps))",
            "def bind(self, function: Callable[[_ReturnType], Kind2[RequiresContext, _NewReturnType, _EnvType]]) -> RequiresContext[_NewReturnType, _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Composes a container with a function returning another container.\\n\\n        This is useful when you do several computations that rely on the\\n        same context.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n\\n          >>> def first(lg: bool) -> RequiresContext[int, float]:\\n          ...     # `deps` has `float` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps if lg else -deps,\\n          ...     )\\n\\n          >>> def second(number: int) -> RequiresContext[str, float]:\\n          ...     # `deps` has `float` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: '>=' if number >= deps else '<',\\n          ...     )\\n\\n          >>> assert first(True).bind(second)(1) == '>='\\n          >>> assert first(False).bind(second)(2) == '<'\\n\\n        \"\n    return RequiresContext(lambda deps: dekind(function(self(deps)))(deps))",
            "def bind(self, function: Callable[[_ReturnType], Kind2[RequiresContext, _NewReturnType, _EnvType]]) -> RequiresContext[_NewReturnType, _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Composes a container with a function returning another container.\\n\\n        This is useful when you do several computations that rely on the\\n        same context.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n\\n          >>> def first(lg: bool) -> RequiresContext[int, float]:\\n          ...     # `deps` has `float` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps if lg else -deps,\\n          ...     )\\n\\n          >>> def second(number: int) -> RequiresContext[str, float]:\\n          ...     # `deps` has `float` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: '>=' if number >= deps else '<',\\n          ...     )\\n\\n          >>> assert first(True).bind(second)(1) == '>='\\n          >>> assert first(False).bind(second)(2) == '<'\\n\\n        \"\n    return RequiresContext(lambda deps: dekind(function(self(deps)))(deps))",
            "def bind(self, function: Callable[[_ReturnType], Kind2[RequiresContext, _NewReturnType, _EnvType]]) -> RequiresContext[_NewReturnType, _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Composes a container with a function returning another container.\\n\\n        This is useful when you do several computations that rely on the\\n        same context.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n\\n          >>> def first(lg: bool) -> RequiresContext[int, float]:\\n          ...     # `deps` has `float` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps if lg else -deps,\\n          ...     )\\n\\n          >>> def second(number: int) -> RequiresContext[str, float]:\\n          ...     # `deps` has `float` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: '>=' if number >= deps else '<',\\n          ...     )\\n\\n          >>> assert first(True).bind(second)(1) == '>='\\n          >>> assert first(False).bind(second)(2) == '<'\\n\\n        \"\n    return RequiresContext(lambda deps: dekind(function(self(deps)))(deps))",
            "def bind(self, function: Callable[[_ReturnType], Kind2[RequiresContext, _NewReturnType, _EnvType]]) -> RequiresContext[_NewReturnType, _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Composes a container with a function returning another container.\\n\\n        This is useful when you do several computations that rely on the\\n        same context.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n\\n          >>> def first(lg: bool) -> RequiresContext[int, float]:\\n          ...     # `deps` has `float` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps if lg else -deps,\\n          ...     )\\n\\n          >>> def second(number: int) -> RequiresContext[str, float]:\\n          ...     # `deps` has `float` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: '>=' if number >= deps else '<',\\n          ...     )\\n\\n          >>> assert first(True).bind(second)(1) == '>='\\n          >>> assert first(False).bind(second)(2) == '<'\\n\\n        \"\n    return RequiresContext(lambda deps: dekind(function(self(deps)))(deps))"
        ]
    },
    {
        "func_name": "modify_env",
        "original": "def modify_env(self, function: Callable[[_NewEnvType], _EnvType]) -> RequiresContext[_ReturnType, _NewEnvType]:\n    \"\"\"\n        Allows to modify the environment type.\n\n        .. code:: python\n\n          >>> from returns.context import RequiresContext\n\n          >>> def mul(arg: int) -> RequiresContext[float, int]:\n          ...     return RequiresContext(lambda deps: arg * deps)\n\n          >>> assert mul(3).modify_env(int)('2') == 6\n\n        \"\"\"\n    return RequiresContext(lambda deps: self(function(deps)))",
        "mutated": [
            "def modify_env(self, function: Callable[[_NewEnvType], _EnvType]) -> RequiresContext[_ReturnType, _NewEnvType]:\n    if False:\n        i = 10\n    \"\\n        Allows to modify the environment type.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n\\n          >>> def mul(arg: int) -> RequiresContext[float, int]:\\n          ...     return RequiresContext(lambda deps: arg * deps)\\n\\n          >>> assert mul(3).modify_env(int)('2') == 6\\n\\n        \"\n    return RequiresContext(lambda deps: self(function(deps)))",
            "def modify_env(self, function: Callable[[_NewEnvType], _EnvType]) -> RequiresContext[_ReturnType, _NewEnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Allows to modify the environment type.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n\\n          >>> def mul(arg: int) -> RequiresContext[float, int]:\\n          ...     return RequiresContext(lambda deps: arg * deps)\\n\\n          >>> assert mul(3).modify_env(int)('2') == 6\\n\\n        \"\n    return RequiresContext(lambda deps: self(function(deps)))",
            "def modify_env(self, function: Callable[[_NewEnvType], _EnvType]) -> RequiresContext[_ReturnType, _NewEnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Allows to modify the environment type.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n\\n          >>> def mul(arg: int) -> RequiresContext[float, int]:\\n          ...     return RequiresContext(lambda deps: arg * deps)\\n\\n          >>> assert mul(3).modify_env(int)('2') == 6\\n\\n        \"\n    return RequiresContext(lambda deps: self(function(deps)))",
            "def modify_env(self, function: Callable[[_NewEnvType], _EnvType]) -> RequiresContext[_ReturnType, _NewEnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Allows to modify the environment type.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n\\n          >>> def mul(arg: int) -> RequiresContext[float, int]:\\n          ...     return RequiresContext(lambda deps: arg * deps)\\n\\n          >>> assert mul(3).modify_env(int)('2') == 6\\n\\n        \"\n    return RequiresContext(lambda deps: self(function(deps)))",
            "def modify_env(self, function: Callable[[_NewEnvType], _EnvType]) -> RequiresContext[_ReturnType, _NewEnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Allows to modify the environment type.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n\\n          >>> def mul(arg: int) -> RequiresContext[float, int]:\\n          ...     return RequiresContext(lambda deps: arg * deps)\\n\\n          >>> assert mul(3).modify_env(int)('2') == 6\\n\\n        \"\n    return RequiresContext(lambda deps: self(function(deps)))"
        ]
    },
    {
        "func_name": "ask",
        "original": "@classmethod\ndef ask(cls) -> RequiresContext[_EnvType, _EnvType]:\n    \"\"\"\n        Get current context to use the dependencies.\n\n        It is a common scenario when you need to use the environment.\n        For example, you want to do some context-related computation,\n        but you don't have the context instance at your disposal.\n        That's where ``.ask()`` becomes useful!\n\n        .. code:: python\n\n          >>> from typing_extensions import TypedDict\n          >>> class Deps(TypedDict):\n          ...     message: str\n\n          >>> def first(lg: bool) -> RequiresContext[int, Deps]:\n          ...     # `deps` has `Deps` type here:\n          ...     return RequiresContext(\n          ...         lambda deps: deps['message'] if lg else 'error',\n          ...     )\n\n          >>> def second(text: str) -> RequiresContext[int, Deps]:\n          ...     return first(len(text) > 3)\n\n          >>> assert second('abc')({'message': 'ok'}) == 'error'\n          >>> assert second('abcd')({'message': 'ok'}) == 'ok'\n\n        And now imagine that you have to change this ``3`` limit.\n        And you want to be able to set it via environment as well.\n        Ok, let's fix it with the power of ``RequiresContext.ask()``!\n\n        .. code:: python\n\n          >>> from typing_extensions import TypedDict\n          >>> class Deps(TypedDict):\n          ...     message: str\n          ...     limit: int   # note this new field!\n\n          >>> def new_first(lg: bool) -> RequiresContext[int, Deps]:\n          ...     # `deps` has `Deps` type here:\n          ...     return RequiresContext(\n          ...         lambda deps: deps['message'] if lg else 'err',\n          ...     )\n\n          >>> def new_second(text: str) -> RequiresContext[int, Deps]:\n          ...     return RequiresContext[int, Deps].ask().bind(\n          ...         lambda deps: new_first(len(text) > deps.get('limit', 3)),\n          ...     )\n\n          >>> assert new_second('abc')({'message': 'ok', 'limit': 2}) == 'ok'\n          >>> assert new_second('abcd')({'message': 'ok'}) == 'ok'\n          >>> assert new_second('abcd')({'message': 'ok', 'limit': 5}) == 'err'\n\n        That's how ``ask`` works.\n\n        This class contains methods that require\n        to explicitly set type annotations. Why?\n        Because it is impossible to figure out the type without them.\n        So, here's how you should use them:\n\n        .. code:: python\n\n            RequiresContext[int, Dict[str, str]].ask()\n\n        Otherwise, your ``.ask()`` method\n        will return ``RequiresContext[<nothing>, <nothing>]``,\n        which is unusable:\n\n        .. code:: python\n\n            env = RequiresContext.ask()\n            env(some_deps)\n\n        And ``mypy`` will warn you: ``error: Need type annotation for '...'``\n\n        See also:\n            - https://dev.to/gcanti/getting-started-with-fp-ts-reader-1ie5\n\n        \"\"\"\n    return RequiresContext(identity)",
        "mutated": [
            "@classmethod\ndef ask(cls) -> RequiresContext[_EnvType, _EnvType]:\n    if False:\n        i = 10\n    \"\\n        Get current context to use the dependencies.\\n\\n        It is a common scenario when you need to use the environment.\\n        For example, you want to do some context-related computation,\\n        but you don't have the context instance at your disposal.\\n        That's where ``.ask()`` becomes useful!\\n\\n        .. code:: python\\n\\n          >>> from typing_extensions import TypedDict\\n          >>> class Deps(TypedDict):\\n          ...     message: str\\n\\n          >>> def first(lg: bool) -> RequiresContext[int, Deps]:\\n          ...     # `deps` has `Deps` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps['message'] if lg else 'error',\\n          ...     )\\n\\n          >>> def second(text: str) -> RequiresContext[int, Deps]:\\n          ...     return first(len(text) > 3)\\n\\n          >>> assert second('abc')({'message': 'ok'}) == 'error'\\n          >>> assert second('abcd')({'message': 'ok'}) == 'ok'\\n\\n        And now imagine that you have to change this ``3`` limit.\\n        And you want to be able to set it via environment as well.\\n        Ok, let's fix it with the power of ``RequiresContext.ask()``!\\n\\n        .. code:: python\\n\\n          >>> from typing_extensions import TypedDict\\n          >>> class Deps(TypedDict):\\n          ...     message: str\\n          ...     limit: int   # note this new field!\\n\\n          >>> def new_first(lg: bool) -> RequiresContext[int, Deps]:\\n          ...     # `deps` has `Deps` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps['message'] if lg else 'err',\\n          ...     )\\n\\n          >>> def new_second(text: str) -> RequiresContext[int, Deps]:\\n          ...     return RequiresContext[int, Deps].ask().bind(\\n          ...         lambda deps: new_first(len(text) > deps.get('limit', 3)),\\n          ...     )\\n\\n          >>> assert new_second('abc')({'message': 'ok', 'limit': 2}) == 'ok'\\n          >>> assert new_second('abcd')({'message': 'ok'}) == 'ok'\\n          >>> assert new_second('abcd')({'message': 'ok', 'limit': 5}) == 'err'\\n\\n        That's how ``ask`` works.\\n\\n        This class contains methods that require\\n        to explicitly set type annotations. Why?\\n        Because it is impossible to figure out the type without them.\\n        So, here's how you should use them:\\n\\n        .. code:: python\\n\\n            RequiresContext[int, Dict[str, str]].ask()\\n\\n        Otherwise, your ``.ask()`` method\\n        will return ``RequiresContext[<nothing>, <nothing>]``,\\n        which is unusable:\\n\\n        .. code:: python\\n\\n            env = RequiresContext.ask()\\n            env(some_deps)\\n\\n        And ``mypy`` will warn you: ``error: Need type annotation for '...'``\\n\\n        See also:\\n            - https://dev.to/gcanti/getting-started-with-fp-ts-reader-1ie5\\n\\n        \"\n    return RequiresContext(identity)",
            "@classmethod\ndef ask(cls) -> RequiresContext[_EnvType, _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Get current context to use the dependencies.\\n\\n        It is a common scenario when you need to use the environment.\\n        For example, you want to do some context-related computation,\\n        but you don't have the context instance at your disposal.\\n        That's where ``.ask()`` becomes useful!\\n\\n        .. code:: python\\n\\n          >>> from typing_extensions import TypedDict\\n          >>> class Deps(TypedDict):\\n          ...     message: str\\n\\n          >>> def first(lg: bool) -> RequiresContext[int, Deps]:\\n          ...     # `deps` has `Deps` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps['message'] if lg else 'error',\\n          ...     )\\n\\n          >>> def second(text: str) -> RequiresContext[int, Deps]:\\n          ...     return first(len(text) > 3)\\n\\n          >>> assert second('abc')({'message': 'ok'}) == 'error'\\n          >>> assert second('abcd')({'message': 'ok'}) == 'ok'\\n\\n        And now imagine that you have to change this ``3`` limit.\\n        And you want to be able to set it via environment as well.\\n        Ok, let's fix it with the power of ``RequiresContext.ask()``!\\n\\n        .. code:: python\\n\\n          >>> from typing_extensions import TypedDict\\n          >>> class Deps(TypedDict):\\n          ...     message: str\\n          ...     limit: int   # note this new field!\\n\\n          >>> def new_first(lg: bool) -> RequiresContext[int, Deps]:\\n          ...     # `deps` has `Deps` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps['message'] if lg else 'err',\\n          ...     )\\n\\n          >>> def new_second(text: str) -> RequiresContext[int, Deps]:\\n          ...     return RequiresContext[int, Deps].ask().bind(\\n          ...         lambda deps: new_first(len(text) > deps.get('limit', 3)),\\n          ...     )\\n\\n          >>> assert new_second('abc')({'message': 'ok', 'limit': 2}) == 'ok'\\n          >>> assert new_second('abcd')({'message': 'ok'}) == 'ok'\\n          >>> assert new_second('abcd')({'message': 'ok', 'limit': 5}) == 'err'\\n\\n        That's how ``ask`` works.\\n\\n        This class contains methods that require\\n        to explicitly set type annotations. Why?\\n        Because it is impossible to figure out the type without them.\\n        So, here's how you should use them:\\n\\n        .. code:: python\\n\\n            RequiresContext[int, Dict[str, str]].ask()\\n\\n        Otherwise, your ``.ask()`` method\\n        will return ``RequiresContext[<nothing>, <nothing>]``,\\n        which is unusable:\\n\\n        .. code:: python\\n\\n            env = RequiresContext.ask()\\n            env(some_deps)\\n\\n        And ``mypy`` will warn you: ``error: Need type annotation for '...'``\\n\\n        See also:\\n            - https://dev.to/gcanti/getting-started-with-fp-ts-reader-1ie5\\n\\n        \"\n    return RequiresContext(identity)",
            "@classmethod\ndef ask(cls) -> RequiresContext[_EnvType, _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Get current context to use the dependencies.\\n\\n        It is a common scenario when you need to use the environment.\\n        For example, you want to do some context-related computation,\\n        but you don't have the context instance at your disposal.\\n        That's where ``.ask()`` becomes useful!\\n\\n        .. code:: python\\n\\n          >>> from typing_extensions import TypedDict\\n          >>> class Deps(TypedDict):\\n          ...     message: str\\n\\n          >>> def first(lg: bool) -> RequiresContext[int, Deps]:\\n          ...     # `deps` has `Deps` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps['message'] if lg else 'error',\\n          ...     )\\n\\n          >>> def second(text: str) -> RequiresContext[int, Deps]:\\n          ...     return first(len(text) > 3)\\n\\n          >>> assert second('abc')({'message': 'ok'}) == 'error'\\n          >>> assert second('abcd')({'message': 'ok'}) == 'ok'\\n\\n        And now imagine that you have to change this ``3`` limit.\\n        And you want to be able to set it via environment as well.\\n        Ok, let's fix it with the power of ``RequiresContext.ask()``!\\n\\n        .. code:: python\\n\\n          >>> from typing_extensions import TypedDict\\n          >>> class Deps(TypedDict):\\n          ...     message: str\\n          ...     limit: int   # note this new field!\\n\\n          >>> def new_first(lg: bool) -> RequiresContext[int, Deps]:\\n          ...     # `deps` has `Deps` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps['message'] if lg else 'err',\\n          ...     )\\n\\n          >>> def new_second(text: str) -> RequiresContext[int, Deps]:\\n          ...     return RequiresContext[int, Deps].ask().bind(\\n          ...         lambda deps: new_first(len(text) > deps.get('limit', 3)),\\n          ...     )\\n\\n          >>> assert new_second('abc')({'message': 'ok', 'limit': 2}) == 'ok'\\n          >>> assert new_second('abcd')({'message': 'ok'}) == 'ok'\\n          >>> assert new_second('abcd')({'message': 'ok', 'limit': 5}) == 'err'\\n\\n        That's how ``ask`` works.\\n\\n        This class contains methods that require\\n        to explicitly set type annotations. Why?\\n        Because it is impossible to figure out the type without them.\\n        So, here's how you should use them:\\n\\n        .. code:: python\\n\\n            RequiresContext[int, Dict[str, str]].ask()\\n\\n        Otherwise, your ``.ask()`` method\\n        will return ``RequiresContext[<nothing>, <nothing>]``,\\n        which is unusable:\\n\\n        .. code:: python\\n\\n            env = RequiresContext.ask()\\n            env(some_deps)\\n\\n        And ``mypy`` will warn you: ``error: Need type annotation for '...'``\\n\\n        See also:\\n            - https://dev.to/gcanti/getting-started-with-fp-ts-reader-1ie5\\n\\n        \"\n    return RequiresContext(identity)",
            "@classmethod\ndef ask(cls) -> RequiresContext[_EnvType, _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Get current context to use the dependencies.\\n\\n        It is a common scenario when you need to use the environment.\\n        For example, you want to do some context-related computation,\\n        but you don't have the context instance at your disposal.\\n        That's where ``.ask()`` becomes useful!\\n\\n        .. code:: python\\n\\n          >>> from typing_extensions import TypedDict\\n          >>> class Deps(TypedDict):\\n          ...     message: str\\n\\n          >>> def first(lg: bool) -> RequiresContext[int, Deps]:\\n          ...     # `deps` has `Deps` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps['message'] if lg else 'error',\\n          ...     )\\n\\n          >>> def second(text: str) -> RequiresContext[int, Deps]:\\n          ...     return first(len(text) > 3)\\n\\n          >>> assert second('abc')({'message': 'ok'}) == 'error'\\n          >>> assert second('abcd')({'message': 'ok'}) == 'ok'\\n\\n        And now imagine that you have to change this ``3`` limit.\\n        And you want to be able to set it via environment as well.\\n        Ok, let's fix it with the power of ``RequiresContext.ask()``!\\n\\n        .. code:: python\\n\\n          >>> from typing_extensions import TypedDict\\n          >>> class Deps(TypedDict):\\n          ...     message: str\\n          ...     limit: int   # note this new field!\\n\\n          >>> def new_first(lg: bool) -> RequiresContext[int, Deps]:\\n          ...     # `deps` has `Deps` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps['message'] if lg else 'err',\\n          ...     )\\n\\n          >>> def new_second(text: str) -> RequiresContext[int, Deps]:\\n          ...     return RequiresContext[int, Deps].ask().bind(\\n          ...         lambda deps: new_first(len(text) > deps.get('limit', 3)),\\n          ...     )\\n\\n          >>> assert new_second('abc')({'message': 'ok', 'limit': 2}) == 'ok'\\n          >>> assert new_second('abcd')({'message': 'ok'}) == 'ok'\\n          >>> assert new_second('abcd')({'message': 'ok', 'limit': 5}) == 'err'\\n\\n        That's how ``ask`` works.\\n\\n        This class contains methods that require\\n        to explicitly set type annotations. Why?\\n        Because it is impossible to figure out the type without them.\\n        So, here's how you should use them:\\n\\n        .. code:: python\\n\\n            RequiresContext[int, Dict[str, str]].ask()\\n\\n        Otherwise, your ``.ask()`` method\\n        will return ``RequiresContext[<nothing>, <nothing>]``,\\n        which is unusable:\\n\\n        .. code:: python\\n\\n            env = RequiresContext.ask()\\n            env(some_deps)\\n\\n        And ``mypy`` will warn you: ``error: Need type annotation for '...'``\\n\\n        See also:\\n            - https://dev.to/gcanti/getting-started-with-fp-ts-reader-1ie5\\n\\n        \"\n    return RequiresContext(identity)",
            "@classmethod\ndef ask(cls) -> RequiresContext[_EnvType, _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Get current context to use the dependencies.\\n\\n        It is a common scenario when you need to use the environment.\\n        For example, you want to do some context-related computation,\\n        but you don't have the context instance at your disposal.\\n        That's where ``.ask()`` becomes useful!\\n\\n        .. code:: python\\n\\n          >>> from typing_extensions import TypedDict\\n          >>> class Deps(TypedDict):\\n          ...     message: str\\n\\n          >>> def first(lg: bool) -> RequiresContext[int, Deps]:\\n          ...     # `deps` has `Deps` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps['message'] if lg else 'error',\\n          ...     )\\n\\n          >>> def second(text: str) -> RequiresContext[int, Deps]:\\n          ...     return first(len(text) > 3)\\n\\n          >>> assert second('abc')({'message': 'ok'}) == 'error'\\n          >>> assert second('abcd')({'message': 'ok'}) == 'ok'\\n\\n        And now imagine that you have to change this ``3`` limit.\\n        And you want to be able to set it via environment as well.\\n        Ok, let's fix it with the power of ``RequiresContext.ask()``!\\n\\n        .. code:: python\\n\\n          >>> from typing_extensions import TypedDict\\n          >>> class Deps(TypedDict):\\n          ...     message: str\\n          ...     limit: int   # note this new field!\\n\\n          >>> def new_first(lg: bool) -> RequiresContext[int, Deps]:\\n          ...     # `deps` has `Deps` type here:\\n          ...     return RequiresContext(\\n          ...         lambda deps: deps['message'] if lg else 'err',\\n          ...     )\\n\\n          >>> def new_second(text: str) -> RequiresContext[int, Deps]:\\n          ...     return RequiresContext[int, Deps].ask().bind(\\n          ...         lambda deps: new_first(len(text) > deps.get('limit', 3)),\\n          ...     )\\n\\n          >>> assert new_second('abc')({'message': 'ok', 'limit': 2}) == 'ok'\\n          >>> assert new_second('abcd')({'message': 'ok'}) == 'ok'\\n          >>> assert new_second('abcd')({'message': 'ok', 'limit': 5}) == 'err'\\n\\n        That's how ``ask`` works.\\n\\n        This class contains methods that require\\n        to explicitly set type annotations. Why?\\n        Because it is impossible to figure out the type without them.\\n        So, here's how you should use them:\\n\\n        .. code:: python\\n\\n            RequiresContext[int, Dict[str, str]].ask()\\n\\n        Otherwise, your ``.ask()`` method\\n        will return ``RequiresContext[<nothing>, <nothing>]``,\\n        which is unusable:\\n\\n        .. code:: python\\n\\n            env = RequiresContext.ask()\\n            env(some_deps)\\n\\n        And ``mypy`` will warn you: ``error: Need type annotation for '...'``\\n\\n        See also:\\n            - https://dev.to/gcanti/getting-started-with-fp-ts-reader-1ie5\\n\\n        \"\n    return RequiresContext(identity)"
        ]
    },
    {
        "func_name": "from_value",
        "original": "@classmethod\ndef from_value(cls, inner_value: _FirstType) -> RequiresContext[_FirstType, NoDeps]:\n    \"\"\"\n        Used to return some specific value from the container.\n\n        Consider this method as some kind of factory.\n        Passed value will be a return type.\n        Make sure to use :attr:`~RequiresContext.no_args`\n        for getting the unit value.\n\n        .. code:: python\n\n          >>> from returns.context import RequiresContext\n          >>> unit = RequiresContext.from_value(5)\n          >>> assert unit(RequiresContext.no_args) == 5\n\n        Might be used with or without direct type hint.\n        \"\"\"\n    return RequiresContext(lambda _: inner_value)",
        "mutated": [
            "@classmethod\ndef from_value(cls, inner_value: _FirstType) -> RequiresContext[_FirstType, NoDeps]:\n    if False:\n        i = 10\n    '\\n        Used to return some specific value from the container.\\n\\n        Consider this method as some kind of factory.\\n        Passed value will be a return type.\\n        Make sure to use :attr:`~RequiresContext.no_args`\\n        for getting the unit value.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> unit = RequiresContext.from_value(5)\\n          >>> assert unit(RequiresContext.no_args) == 5\\n\\n        Might be used with or without direct type hint.\\n        '\n    return RequiresContext(lambda _: inner_value)",
            "@classmethod\ndef from_value(cls, inner_value: _FirstType) -> RequiresContext[_FirstType, NoDeps]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Used to return some specific value from the container.\\n\\n        Consider this method as some kind of factory.\\n        Passed value will be a return type.\\n        Make sure to use :attr:`~RequiresContext.no_args`\\n        for getting the unit value.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> unit = RequiresContext.from_value(5)\\n          >>> assert unit(RequiresContext.no_args) == 5\\n\\n        Might be used with or without direct type hint.\\n        '\n    return RequiresContext(lambda _: inner_value)",
            "@classmethod\ndef from_value(cls, inner_value: _FirstType) -> RequiresContext[_FirstType, NoDeps]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Used to return some specific value from the container.\\n\\n        Consider this method as some kind of factory.\\n        Passed value will be a return type.\\n        Make sure to use :attr:`~RequiresContext.no_args`\\n        for getting the unit value.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> unit = RequiresContext.from_value(5)\\n          >>> assert unit(RequiresContext.no_args) == 5\\n\\n        Might be used with or without direct type hint.\\n        '\n    return RequiresContext(lambda _: inner_value)",
            "@classmethod\ndef from_value(cls, inner_value: _FirstType) -> RequiresContext[_FirstType, NoDeps]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Used to return some specific value from the container.\\n\\n        Consider this method as some kind of factory.\\n        Passed value will be a return type.\\n        Make sure to use :attr:`~RequiresContext.no_args`\\n        for getting the unit value.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> unit = RequiresContext.from_value(5)\\n          >>> assert unit(RequiresContext.no_args) == 5\\n\\n        Might be used with or without direct type hint.\\n        '\n    return RequiresContext(lambda _: inner_value)",
            "@classmethod\ndef from_value(cls, inner_value: _FirstType) -> RequiresContext[_FirstType, NoDeps]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Used to return some specific value from the container.\\n\\n        Consider this method as some kind of factory.\\n        Passed value will be a return type.\\n        Make sure to use :attr:`~RequiresContext.no_args`\\n        for getting the unit value.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> unit = RequiresContext.from_value(5)\\n          >>> assert unit(RequiresContext.no_args) == 5\\n\\n        Might be used with or without direct type hint.\\n        '\n    return RequiresContext(lambda _: inner_value)"
        ]
    },
    {
        "func_name": "from_context",
        "original": "@classmethod\ndef from_context(cls, inner_value: RequiresContext[_NewReturnType, _NewEnvType]) -> RequiresContext[_NewReturnType, _NewEnvType]:\n    \"\"\"\n        Used to create new containers from existing ones.\n\n        Used as a part of ``ReaderBased2`` interface.\n\n        .. code:: python\n\n          >>> from returns.context import RequiresContext\n          >>> unit = RequiresContext.from_value(5)\n          >>> assert RequiresContext.from_context(unit)(...) == unit(...)\n\n        \"\"\"\n    return inner_value",
        "mutated": [
            "@classmethod\ndef from_context(cls, inner_value: RequiresContext[_NewReturnType, _NewEnvType]) -> RequiresContext[_NewReturnType, _NewEnvType]:\n    if False:\n        i = 10\n    '\\n        Used to create new containers from existing ones.\\n\\n        Used as a part of ``ReaderBased2`` interface.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> unit = RequiresContext.from_value(5)\\n          >>> assert RequiresContext.from_context(unit)(...) == unit(...)\\n\\n        '\n    return inner_value",
            "@classmethod\ndef from_context(cls, inner_value: RequiresContext[_NewReturnType, _NewEnvType]) -> RequiresContext[_NewReturnType, _NewEnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Used to create new containers from existing ones.\\n\\n        Used as a part of ``ReaderBased2`` interface.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> unit = RequiresContext.from_value(5)\\n          >>> assert RequiresContext.from_context(unit)(...) == unit(...)\\n\\n        '\n    return inner_value",
            "@classmethod\ndef from_context(cls, inner_value: RequiresContext[_NewReturnType, _NewEnvType]) -> RequiresContext[_NewReturnType, _NewEnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Used to create new containers from existing ones.\\n\\n        Used as a part of ``ReaderBased2`` interface.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> unit = RequiresContext.from_value(5)\\n          >>> assert RequiresContext.from_context(unit)(...) == unit(...)\\n\\n        '\n    return inner_value",
            "@classmethod\ndef from_context(cls, inner_value: RequiresContext[_NewReturnType, _NewEnvType]) -> RequiresContext[_NewReturnType, _NewEnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Used to create new containers from existing ones.\\n\\n        Used as a part of ``ReaderBased2`` interface.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> unit = RequiresContext.from_value(5)\\n          >>> assert RequiresContext.from_context(unit)(...) == unit(...)\\n\\n        '\n    return inner_value",
            "@classmethod\ndef from_context(cls, inner_value: RequiresContext[_NewReturnType, _NewEnvType]) -> RequiresContext[_NewReturnType, _NewEnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Used to create new containers from existing ones.\\n\\n        Used as a part of ``ReaderBased2`` interface.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> unit = RequiresContext.from_value(5)\\n          >>> assert RequiresContext.from_context(unit)(...) == unit(...)\\n\\n        '\n    return inner_value"
        ]
    },
    {
        "func_name": "from_requires_context_result",
        "original": "@classmethod\ndef from_requires_context_result(cls, inner_value: RequiresContextResult[_ValueType, _ErrorType, _EnvType]) -> RequiresContext[Result[_ValueType, _ErrorType], _EnvType]:\n    \"\"\"\n        Typecasts ``RequiresContextResult`` to ``RequiresContext`` instance.\n\n        Breaks ``RequiresContextResult[a, b, e]``\n        into ``RequiresContext[Result[a, b], e]``.\n\n        .. code:: python\n\n          >>> from returns.context import RequiresContext\n          >>> from returns.context import RequiresContextResult\n          >>> from returns.result import Success\n          >>> assert RequiresContext.from_requires_context_result(\n          ...    RequiresContextResult.from_value(1),\n          ... )(...) == Success(1)\n\n        Can be reverted with ``RequiresContextResult.from_typecast``.\n\n        \"\"\"\n    return RequiresContext(inner_value)",
        "mutated": [
            "@classmethod\ndef from_requires_context_result(cls, inner_value: RequiresContextResult[_ValueType, _ErrorType, _EnvType]) -> RequiresContext[Result[_ValueType, _ErrorType], _EnvType]:\n    if False:\n        i = 10\n    '\\n        Typecasts ``RequiresContextResult`` to ``RequiresContext`` instance.\\n\\n        Breaks ``RequiresContextResult[a, b, e]``\\n        into ``RequiresContext[Result[a, b], e]``.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> from returns.context import RequiresContextResult\\n          >>> from returns.result import Success\\n          >>> assert RequiresContext.from_requires_context_result(\\n          ...    RequiresContextResult.from_value(1),\\n          ... )(...) == Success(1)\\n\\n        Can be reverted with ``RequiresContextResult.from_typecast``.\\n\\n        '\n    return RequiresContext(inner_value)",
            "@classmethod\ndef from_requires_context_result(cls, inner_value: RequiresContextResult[_ValueType, _ErrorType, _EnvType]) -> RequiresContext[Result[_ValueType, _ErrorType], _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Typecasts ``RequiresContextResult`` to ``RequiresContext`` instance.\\n\\n        Breaks ``RequiresContextResult[a, b, e]``\\n        into ``RequiresContext[Result[a, b], e]``.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> from returns.context import RequiresContextResult\\n          >>> from returns.result import Success\\n          >>> assert RequiresContext.from_requires_context_result(\\n          ...    RequiresContextResult.from_value(1),\\n          ... )(...) == Success(1)\\n\\n        Can be reverted with ``RequiresContextResult.from_typecast``.\\n\\n        '\n    return RequiresContext(inner_value)",
            "@classmethod\ndef from_requires_context_result(cls, inner_value: RequiresContextResult[_ValueType, _ErrorType, _EnvType]) -> RequiresContext[Result[_ValueType, _ErrorType], _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Typecasts ``RequiresContextResult`` to ``RequiresContext`` instance.\\n\\n        Breaks ``RequiresContextResult[a, b, e]``\\n        into ``RequiresContext[Result[a, b], e]``.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> from returns.context import RequiresContextResult\\n          >>> from returns.result import Success\\n          >>> assert RequiresContext.from_requires_context_result(\\n          ...    RequiresContextResult.from_value(1),\\n          ... )(...) == Success(1)\\n\\n        Can be reverted with ``RequiresContextResult.from_typecast``.\\n\\n        '\n    return RequiresContext(inner_value)",
            "@classmethod\ndef from_requires_context_result(cls, inner_value: RequiresContextResult[_ValueType, _ErrorType, _EnvType]) -> RequiresContext[Result[_ValueType, _ErrorType], _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Typecasts ``RequiresContextResult`` to ``RequiresContext`` instance.\\n\\n        Breaks ``RequiresContextResult[a, b, e]``\\n        into ``RequiresContext[Result[a, b], e]``.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> from returns.context import RequiresContextResult\\n          >>> from returns.result import Success\\n          >>> assert RequiresContext.from_requires_context_result(\\n          ...    RequiresContextResult.from_value(1),\\n          ... )(...) == Success(1)\\n\\n        Can be reverted with ``RequiresContextResult.from_typecast``.\\n\\n        '\n    return RequiresContext(inner_value)",
            "@classmethod\ndef from_requires_context_result(cls, inner_value: RequiresContextResult[_ValueType, _ErrorType, _EnvType]) -> RequiresContext[Result[_ValueType, _ErrorType], _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Typecasts ``RequiresContextResult`` to ``RequiresContext`` instance.\\n\\n        Breaks ``RequiresContextResult[a, b, e]``\\n        into ``RequiresContext[Result[a, b], e]``.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> from returns.context import RequiresContextResult\\n          >>> from returns.result import Success\\n          >>> assert RequiresContext.from_requires_context_result(\\n          ...    RequiresContextResult.from_value(1),\\n          ... )(...) == Success(1)\\n\\n        Can be reverted with ``RequiresContextResult.from_typecast``.\\n\\n        '\n    return RequiresContext(inner_value)"
        ]
    },
    {
        "func_name": "from_requires_context_ioresult",
        "original": "@classmethod\ndef from_requires_context_ioresult(cls, inner_value: RequiresContextIOResult[_ValueType, _ErrorType, _EnvType]) -> RequiresContext[IOResult[_ValueType, _ErrorType], _EnvType]:\n    \"\"\"\n        Typecasts ``RequiresContextIOResult`` to ``RequiresContext`` instance.\n\n        Breaks ``RequiresContextIOResult[a, b, e]``\n        into ``RequiresContext[IOResult[a, b], e]``.\n\n        .. code:: python\n\n          >>> from returns.context import RequiresContext\n          >>> from returns.context import RequiresContextIOResult\n          >>> from returns.io import IOSuccess\n          >>> assert RequiresContext.from_requires_context_ioresult(\n          ...    RequiresContextIOResult.from_value(1),\n          ... )(...) == IOSuccess(1)\n\n        Can be reverted with ``RequiresContextIOResult.from_typecast``.\n\n        \"\"\"\n    return RequiresContext(inner_value)",
        "mutated": [
            "@classmethod\ndef from_requires_context_ioresult(cls, inner_value: RequiresContextIOResult[_ValueType, _ErrorType, _EnvType]) -> RequiresContext[IOResult[_ValueType, _ErrorType], _EnvType]:\n    if False:\n        i = 10\n    '\\n        Typecasts ``RequiresContextIOResult`` to ``RequiresContext`` instance.\\n\\n        Breaks ``RequiresContextIOResult[a, b, e]``\\n        into ``RequiresContext[IOResult[a, b], e]``.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> from returns.context import RequiresContextIOResult\\n          >>> from returns.io import IOSuccess\\n          >>> assert RequiresContext.from_requires_context_ioresult(\\n          ...    RequiresContextIOResult.from_value(1),\\n          ... )(...) == IOSuccess(1)\\n\\n        Can be reverted with ``RequiresContextIOResult.from_typecast``.\\n\\n        '\n    return RequiresContext(inner_value)",
            "@classmethod\ndef from_requires_context_ioresult(cls, inner_value: RequiresContextIOResult[_ValueType, _ErrorType, _EnvType]) -> RequiresContext[IOResult[_ValueType, _ErrorType], _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Typecasts ``RequiresContextIOResult`` to ``RequiresContext`` instance.\\n\\n        Breaks ``RequiresContextIOResult[a, b, e]``\\n        into ``RequiresContext[IOResult[a, b], e]``.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> from returns.context import RequiresContextIOResult\\n          >>> from returns.io import IOSuccess\\n          >>> assert RequiresContext.from_requires_context_ioresult(\\n          ...    RequiresContextIOResult.from_value(1),\\n          ... )(...) == IOSuccess(1)\\n\\n        Can be reverted with ``RequiresContextIOResult.from_typecast``.\\n\\n        '\n    return RequiresContext(inner_value)",
            "@classmethod\ndef from_requires_context_ioresult(cls, inner_value: RequiresContextIOResult[_ValueType, _ErrorType, _EnvType]) -> RequiresContext[IOResult[_ValueType, _ErrorType], _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Typecasts ``RequiresContextIOResult`` to ``RequiresContext`` instance.\\n\\n        Breaks ``RequiresContextIOResult[a, b, e]``\\n        into ``RequiresContext[IOResult[a, b], e]``.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> from returns.context import RequiresContextIOResult\\n          >>> from returns.io import IOSuccess\\n          >>> assert RequiresContext.from_requires_context_ioresult(\\n          ...    RequiresContextIOResult.from_value(1),\\n          ... )(...) == IOSuccess(1)\\n\\n        Can be reverted with ``RequiresContextIOResult.from_typecast``.\\n\\n        '\n    return RequiresContext(inner_value)",
            "@classmethod\ndef from_requires_context_ioresult(cls, inner_value: RequiresContextIOResult[_ValueType, _ErrorType, _EnvType]) -> RequiresContext[IOResult[_ValueType, _ErrorType], _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Typecasts ``RequiresContextIOResult`` to ``RequiresContext`` instance.\\n\\n        Breaks ``RequiresContextIOResult[a, b, e]``\\n        into ``RequiresContext[IOResult[a, b], e]``.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> from returns.context import RequiresContextIOResult\\n          >>> from returns.io import IOSuccess\\n          >>> assert RequiresContext.from_requires_context_ioresult(\\n          ...    RequiresContextIOResult.from_value(1),\\n          ... )(...) == IOSuccess(1)\\n\\n        Can be reverted with ``RequiresContextIOResult.from_typecast``.\\n\\n        '\n    return RequiresContext(inner_value)",
            "@classmethod\ndef from_requires_context_ioresult(cls, inner_value: RequiresContextIOResult[_ValueType, _ErrorType, _EnvType]) -> RequiresContext[IOResult[_ValueType, _ErrorType], _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Typecasts ``RequiresContextIOResult`` to ``RequiresContext`` instance.\\n\\n        Breaks ``RequiresContextIOResult[a, b, e]``\\n        into ``RequiresContext[IOResult[a, b], e]``.\\n\\n        .. code:: python\\n\\n          >>> from returns.context import RequiresContext\\n          >>> from returns.context import RequiresContextIOResult\\n          >>> from returns.io import IOSuccess\\n          >>> assert RequiresContext.from_requires_context_ioresult(\\n          ...    RequiresContextIOResult.from_value(1),\\n          ... )(...) == IOSuccess(1)\\n\\n        Can be reverted with ``RequiresContextIOResult.from_typecast``.\\n\\n        '\n    return RequiresContext(inner_value)"
        ]
    },
    {
        "func_name": "from_requires_context_future_result",
        "original": "@classmethod\ndef from_requires_context_future_result(cls, inner_value: RequiresContextFutureResult[_ValueType, _ErrorType, _EnvType]) -> RequiresContext[FutureResult[_ValueType, _ErrorType], _EnvType]:\n    \"\"\"\n        Typecasts ``RequiresContextIOResult`` to ``RequiresContext`` instance.\n\n        Breaks ``RequiresContextIOResult[a, b, e]``\n        into ``RequiresContext[IOResult[a, b], e]``.\n\n        .. code:: python\n\n          >>> import anyio\n          >>> from returns.context import RequiresContext\n          >>> from returns.context import RequiresContextFutureResult\n          >>> from returns.io import IOSuccess\n\n          >>> container = RequiresContext.from_requires_context_future_result(\n          ...    RequiresContextFutureResult.from_value(1),\n          ... )\n          >>> assert anyio.run(\n          ...     container, RequiresContext.no_args,\n          ... ) == IOSuccess(1)\n\n        Can be reverted with ``RequiresContextFutureResult.from_typecast``.\n\n        \"\"\"\n    return RequiresContext(inner_value)",
        "mutated": [
            "@classmethod\ndef from_requires_context_future_result(cls, inner_value: RequiresContextFutureResult[_ValueType, _ErrorType, _EnvType]) -> RequiresContext[FutureResult[_ValueType, _ErrorType], _EnvType]:\n    if False:\n        i = 10\n    '\\n        Typecasts ``RequiresContextIOResult`` to ``RequiresContext`` instance.\\n\\n        Breaks ``RequiresContextIOResult[a, b, e]``\\n        into ``RequiresContext[IOResult[a, b], e]``.\\n\\n        .. code:: python\\n\\n          >>> import anyio\\n          >>> from returns.context import RequiresContext\\n          >>> from returns.context import RequiresContextFutureResult\\n          >>> from returns.io import IOSuccess\\n\\n          >>> container = RequiresContext.from_requires_context_future_result(\\n          ...    RequiresContextFutureResult.from_value(1),\\n          ... )\\n          >>> assert anyio.run(\\n          ...     container, RequiresContext.no_args,\\n          ... ) == IOSuccess(1)\\n\\n        Can be reverted with ``RequiresContextFutureResult.from_typecast``.\\n\\n        '\n    return RequiresContext(inner_value)",
            "@classmethod\ndef from_requires_context_future_result(cls, inner_value: RequiresContextFutureResult[_ValueType, _ErrorType, _EnvType]) -> RequiresContext[FutureResult[_ValueType, _ErrorType], _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Typecasts ``RequiresContextIOResult`` to ``RequiresContext`` instance.\\n\\n        Breaks ``RequiresContextIOResult[a, b, e]``\\n        into ``RequiresContext[IOResult[a, b], e]``.\\n\\n        .. code:: python\\n\\n          >>> import anyio\\n          >>> from returns.context import RequiresContext\\n          >>> from returns.context import RequiresContextFutureResult\\n          >>> from returns.io import IOSuccess\\n\\n          >>> container = RequiresContext.from_requires_context_future_result(\\n          ...    RequiresContextFutureResult.from_value(1),\\n          ... )\\n          >>> assert anyio.run(\\n          ...     container, RequiresContext.no_args,\\n          ... ) == IOSuccess(1)\\n\\n        Can be reverted with ``RequiresContextFutureResult.from_typecast``.\\n\\n        '\n    return RequiresContext(inner_value)",
            "@classmethod\ndef from_requires_context_future_result(cls, inner_value: RequiresContextFutureResult[_ValueType, _ErrorType, _EnvType]) -> RequiresContext[FutureResult[_ValueType, _ErrorType], _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Typecasts ``RequiresContextIOResult`` to ``RequiresContext`` instance.\\n\\n        Breaks ``RequiresContextIOResult[a, b, e]``\\n        into ``RequiresContext[IOResult[a, b], e]``.\\n\\n        .. code:: python\\n\\n          >>> import anyio\\n          >>> from returns.context import RequiresContext\\n          >>> from returns.context import RequiresContextFutureResult\\n          >>> from returns.io import IOSuccess\\n\\n          >>> container = RequiresContext.from_requires_context_future_result(\\n          ...    RequiresContextFutureResult.from_value(1),\\n          ... )\\n          >>> assert anyio.run(\\n          ...     container, RequiresContext.no_args,\\n          ... ) == IOSuccess(1)\\n\\n        Can be reverted with ``RequiresContextFutureResult.from_typecast``.\\n\\n        '\n    return RequiresContext(inner_value)",
            "@classmethod\ndef from_requires_context_future_result(cls, inner_value: RequiresContextFutureResult[_ValueType, _ErrorType, _EnvType]) -> RequiresContext[FutureResult[_ValueType, _ErrorType], _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Typecasts ``RequiresContextIOResult`` to ``RequiresContext`` instance.\\n\\n        Breaks ``RequiresContextIOResult[a, b, e]``\\n        into ``RequiresContext[IOResult[a, b], e]``.\\n\\n        .. code:: python\\n\\n          >>> import anyio\\n          >>> from returns.context import RequiresContext\\n          >>> from returns.context import RequiresContextFutureResult\\n          >>> from returns.io import IOSuccess\\n\\n          >>> container = RequiresContext.from_requires_context_future_result(\\n          ...    RequiresContextFutureResult.from_value(1),\\n          ... )\\n          >>> assert anyio.run(\\n          ...     container, RequiresContext.no_args,\\n          ... ) == IOSuccess(1)\\n\\n        Can be reverted with ``RequiresContextFutureResult.from_typecast``.\\n\\n        '\n    return RequiresContext(inner_value)",
            "@classmethod\ndef from_requires_context_future_result(cls, inner_value: RequiresContextFutureResult[_ValueType, _ErrorType, _EnvType]) -> RequiresContext[FutureResult[_ValueType, _ErrorType], _EnvType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Typecasts ``RequiresContextIOResult`` to ``RequiresContext`` instance.\\n\\n        Breaks ``RequiresContextIOResult[a, b, e]``\\n        into ``RequiresContext[IOResult[a, b], e]``.\\n\\n        .. code:: python\\n\\n          >>> import anyio\\n          >>> from returns.context import RequiresContext\\n          >>> from returns.context import RequiresContextFutureResult\\n          >>> from returns.io import IOSuccess\\n\\n          >>> container = RequiresContext.from_requires_context_future_result(\\n          ...    RequiresContextFutureResult.from_value(1),\\n          ... )\\n          >>> assert anyio.run(\\n          ...     container, RequiresContext.no_args,\\n          ... ) == IOSuccess(1)\\n\\n        Can be reverted with ``RequiresContextFutureResult.from_typecast``.\\n\\n        '\n    return RequiresContext(inner_value)"
        ]
    }
]