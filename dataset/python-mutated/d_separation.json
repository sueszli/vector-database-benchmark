[
    {
        "func_name": "d_separated",
        "original": "@not_implemented_for('undirected')\n@nx._dispatch\ndef d_separated(G, x, y, z):\n    \"\"\"\n    Return whether node sets ``x`` and ``y`` are d-separated by ``z``.\n\n    Parameters\n    ----------\n    G : graph\n        A NetworkX DAG.\n\n    x : set\n        First set of nodes in ``G``.\n\n    y : set\n        Second set of nodes in ``G``.\n\n    z : set\n        Set of conditioning nodes in ``G``. Can be empty set.\n\n    Returns\n    -------\n    b : bool\n        A boolean that is true if ``x`` is d-separated from ``y`` given ``z`` in ``G``.\n\n    Raises\n    ------\n    NetworkXError\n        The *d-separation* test is commonly used with directed\n        graphical models which are acyclic.  Accordingly, the algorithm\n        raises a :exc:`NetworkXError` if the input graph is not a DAG.\n\n    NodeNotFound\n        If any of the input nodes are not found in the graph,\n        a :exc:`NodeNotFound` exception is raised.\n\n    Notes\n    -----\n    A d-separating set in a DAG is a set of nodes that\n    blocks all paths between the two sets. Nodes in `z`\n    block a path if they are part of the path and are not a collider,\n    or a descendant of a collider. A collider structure along a path\n    is ``... -> c <- ...`` where ``c`` is the collider node.\n\n    https://en.wikipedia.org/wiki/Bayesian_network#d-separation\n    \"\"\"\n    if not nx.is_directed_acyclic_graph(G):\n        raise nx.NetworkXError('graph should be directed acyclic')\n    union_xyz = x.union(y).union(z)\n    if any((n not in G.nodes for n in union_xyz)):\n        raise nx.NodeNotFound('one or more specified nodes not found in the graph')\n    G_copy = G.copy()\n    leaves = deque([n for n in G_copy.nodes if G_copy.out_degree[n] == 0])\n    while len(leaves) > 0:\n        leaf = leaves.popleft()\n        if leaf not in union_xyz:\n            for p in G_copy.predecessors(leaf):\n                if G_copy.out_degree[p] == 1:\n                    leaves.append(p)\n            G_copy.remove_node(leaf)\n    edges_to_remove = list(G_copy.out_edges(z))\n    G_copy.remove_edges_from(edges_to_remove)\n    disjoint_set = UnionFind(G_copy.nodes())\n    for component in nx.weakly_connected_components(G_copy):\n        disjoint_set.union(*component)\n    disjoint_set.union(*x)\n    disjoint_set.union(*y)\n    if x and y and (disjoint_set[next(iter(x))] == disjoint_set[next(iter(y))]):\n        return False\n    else:\n        return True",
        "mutated": [
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef d_separated(G, x, y, z):\n    if False:\n        i = 10\n    '\\n    Return whether node sets ``x`` and ``y`` are d-separated by ``z``.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        A NetworkX DAG.\\n\\n    x : set\\n        First set of nodes in ``G``.\\n\\n    y : set\\n        Second set of nodes in ``G``.\\n\\n    z : set\\n        Set of conditioning nodes in ``G``. Can be empty set.\\n\\n    Returns\\n    -------\\n    b : bool\\n        A boolean that is true if ``x`` is d-separated from ``y`` given ``z`` in ``G``.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        The *d-separation* test is commonly used with directed\\n        graphical models which are acyclic.  Accordingly, the algorithm\\n        raises a :exc:`NetworkXError` if the input graph is not a DAG.\\n\\n    NodeNotFound\\n        If any of the input nodes are not found in the graph,\\n        a :exc:`NodeNotFound` exception is raised.\\n\\n    Notes\\n    -----\\n    A d-separating set in a DAG is a set of nodes that\\n    blocks all paths between the two sets. Nodes in `z`\\n    block a path if they are part of the path and are not a collider,\\n    or a descendant of a collider. A collider structure along a path\\n    is ``... -> c <- ...`` where ``c`` is the collider node.\\n\\n    https://en.wikipedia.org/wiki/Bayesian_network#d-separation\\n    '\n    if not nx.is_directed_acyclic_graph(G):\n        raise nx.NetworkXError('graph should be directed acyclic')\n    union_xyz = x.union(y).union(z)\n    if any((n not in G.nodes for n in union_xyz)):\n        raise nx.NodeNotFound('one or more specified nodes not found in the graph')\n    G_copy = G.copy()\n    leaves = deque([n for n in G_copy.nodes if G_copy.out_degree[n] == 0])\n    while len(leaves) > 0:\n        leaf = leaves.popleft()\n        if leaf not in union_xyz:\n            for p in G_copy.predecessors(leaf):\n                if G_copy.out_degree[p] == 1:\n                    leaves.append(p)\n            G_copy.remove_node(leaf)\n    edges_to_remove = list(G_copy.out_edges(z))\n    G_copy.remove_edges_from(edges_to_remove)\n    disjoint_set = UnionFind(G_copy.nodes())\n    for component in nx.weakly_connected_components(G_copy):\n        disjoint_set.union(*component)\n    disjoint_set.union(*x)\n    disjoint_set.union(*y)\n    if x and y and (disjoint_set[next(iter(x))] == disjoint_set[next(iter(y))]):\n        return False\n    else:\n        return True",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef d_separated(G, x, y, z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return whether node sets ``x`` and ``y`` are d-separated by ``z``.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        A NetworkX DAG.\\n\\n    x : set\\n        First set of nodes in ``G``.\\n\\n    y : set\\n        Second set of nodes in ``G``.\\n\\n    z : set\\n        Set of conditioning nodes in ``G``. Can be empty set.\\n\\n    Returns\\n    -------\\n    b : bool\\n        A boolean that is true if ``x`` is d-separated from ``y`` given ``z`` in ``G``.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        The *d-separation* test is commonly used with directed\\n        graphical models which are acyclic.  Accordingly, the algorithm\\n        raises a :exc:`NetworkXError` if the input graph is not a DAG.\\n\\n    NodeNotFound\\n        If any of the input nodes are not found in the graph,\\n        a :exc:`NodeNotFound` exception is raised.\\n\\n    Notes\\n    -----\\n    A d-separating set in a DAG is a set of nodes that\\n    blocks all paths between the two sets. Nodes in `z`\\n    block a path if they are part of the path and are not a collider,\\n    or a descendant of a collider. A collider structure along a path\\n    is ``... -> c <- ...`` where ``c`` is the collider node.\\n\\n    https://en.wikipedia.org/wiki/Bayesian_network#d-separation\\n    '\n    if not nx.is_directed_acyclic_graph(G):\n        raise nx.NetworkXError('graph should be directed acyclic')\n    union_xyz = x.union(y).union(z)\n    if any((n not in G.nodes for n in union_xyz)):\n        raise nx.NodeNotFound('one or more specified nodes not found in the graph')\n    G_copy = G.copy()\n    leaves = deque([n for n in G_copy.nodes if G_copy.out_degree[n] == 0])\n    while len(leaves) > 0:\n        leaf = leaves.popleft()\n        if leaf not in union_xyz:\n            for p in G_copy.predecessors(leaf):\n                if G_copy.out_degree[p] == 1:\n                    leaves.append(p)\n            G_copy.remove_node(leaf)\n    edges_to_remove = list(G_copy.out_edges(z))\n    G_copy.remove_edges_from(edges_to_remove)\n    disjoint_set = UnionFind(G_copy.nodes())\n    for component in nx.weakly_connected_components(G_copy):\n        disjoint_set.union(*component)\n    disjoint_set.union(*x)\n    disjoint_set.union(*y)\n    if x and y and (disjoint_set[next(iter(x))] == disjoint_set[next(iter(y))]):\n        return False\n    else:\n        return True",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef d_separated(G, x, y, z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return whether node sets ``x`` and ``y`` are d-separated by ``z``.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        A NetworkX DAG.\\n\\n    x : set\\n        First set of nodes in ``G``.\\n\\n    y : set\\n        Second set of nodes in ``G``.\\n\\n    z : set\\n        Set of conditioning nodes in ``G``. Can be empty set.\\n\\n    Returns\\n    -------\\n    b : bool\\n        A boolean that is true if ``x`` is d-separated from ``y`` given ``z`` in ``G``.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        The *d-separation* test is commonly used with directed\\n        graphical models which are acyclic.  Accordingly, the algorithm\\n        raises a :exc:`NetworkXError` if the input graph is not a DAG.\\n\\n    NodeNotFound\\n        If any of the input nodes are not found in the graph,\\n        a :exc:`NodeNotFound` exception is raised.\\n\\n    Notes\\n    -----\\n    A d-separating set in a DAG is a set of nodes that\\n    blocks all paths between the two sets. Nodes in `z`\\n    block a path if they are part of the path and are not a collider,\\n    or a descendant of a collider. A collider structure along a path\\n    is ``... -> c <- ...`` where ``c`` is the collider node.\\n\\n    https://en.wikipedia.org/wiki/Bayesian_network#d-separation\\n    '\n    if not nx.is_directed_acyclic_graph(G):\n        raise nx.NetworkXError('graph should be directed acyclic')\n    union_xyz = x.union(y).union(z)\n    if any((n not in G.nodes for n in union_xyz)):\n        raise nx.NodeNotFound('one or more specified nodes not found in the graph')\n    G_copy = G.copy()\n    leaves = deque([n for n in G_copy.nodes if G_copy.out_degree[n] == 0])\n    while len(leaves) > 0:\n        leaf = leaves.popleft()\n        if leaf not in union_xyz:\n            for p in G_copy.predecessors(leaf):\n                if G_copy.out_degree[p] == 1:\n                    leaves.append(p)\n            G_copy.remove_node(leaf)\n    edges_to_remove = list(G_copy.out_edges(z))\n    G_copy.remove_edges_from(edges_to_remove)\n    disjoint_set = UnionFind(G_copy.nodes())\n    for component in nx.weakly_connected_components(G_copy):\n        disjoint_set.union(*component)\n    disjoint_set.union(*x)\n    disjoint_set.union(*y)\n    if x and y and (disjoint_set[next(iter(x))] == disjoint_set[next(iter(y))]):\n        return False\n    else:\n        return True",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef d_separated(G, x, y, z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return whether node sets ``x`` and ``y`` are d-separated by ``z``.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        A NetworkX DAG.\\n\\n    x : set\\n        First set of nodes in ``G``.\\n\\n    y : set\\n        Second set of nodes in ``G``.\\n\\n    z : set\\n        Set of conditioning nodes in ``G``. Can be empty set.\\n\\n    Returns\\n    -------\\n    b : bool\\n        A boolean that is true if ``x`` is d-separated from ``y`` given ``z`` in ``G``.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        The *d-separation* test is commonly used with directed\\n        graphical models which are acyclic.  Accordingly, the algorithm\\n        raises a :exc:`NetworkXError` if the input graph is not a DAG.\\n\\n    NodeNotFound\\n        If any of the input nodes are not found in the graph,\\n        a :exc:`NodeNotFound` exception is raised.\\n\\n    Notes\\n    -----\\n    A d-separating set in a DAG is a set of nodes that\\n    blocks all paths between the two sets. Nodes in `z`\\n    block a path if they are part of the path and are not a collider,\\n    or a descendant of a collider. A collider structure along a path\\n    is ``... -> c <- ...`` where ``c`` is the collider node.\\n\\n    https://en.wikipedia.org/wiki/Bayesian_network#d-separation\\n    '\n    if not nx.is_directed_acyclic_graph(G):\n        raise nx.NetworkXError('graph should be directed acyclic')\n    union_xyz = x.union(y).union(z)\n    if any((n not in G.nodes for n in union_xyz)):\n        raise nx.NodeNotFound('one or more specified nodes not found in the graph')\n    G_copy = G.copy()\n    leaves = deque([n for n in G_copy.nodes if G_copy.out_degree[n] == 0])\n    while len(leaves) > 0:\n        leaf = leaves.popleft()\n        if leaf not in union_xyz:\n            for p in G_copy.predecessors(leaf):\n                if G_copy.out_degree[p] == 1:\n                    leaves.append(p)\n            G_copy.remove_node(leaf)\n    edges_to_remove = list(G_copy.out_edges(z))\n    G_copy.remove_edges_from(edges_to_remove)\n    disjoint_set = UnionFind(G_copy.nodes())\n    for component in nx.weakly_connected_components(G_copy):\n        disjoint_set.union(*component)\n    disjoint_set.union(*x)\n    disjoint_set.union(*y)\n    if x and y and (disjoint_set[next(iter(x))] == disjoint_set[next(iter(y))]):\n        return False\n    else:\n        return True",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef d_separated(G, x, y, z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return whether node sets ``x`` and ``y`` are d-separated by ``z``.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        A NetworkX DAG.\\n\\n    x : set\\n        First set of nodes in ``G``.\\n\\n    y : set\\n        Second set of nodes in ``G``.\\n\\n    z : set\\n        Set of conditioning nodes in ``G``. Can be empty set.\\n\\n    Returns\\n    -------\\n    b : bool\\n        A boolean that is true if ``x`` is d-separated from ``y`` given ``z`` in ``G``.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        The *d-separation* test is commonly used with directed\\n        graphical models which are acyclic.  Accordingly, the algorithm\\n        raises a :exc:`NetworkXError` if the input graph is not a DAG.\\n\\n    NodeNotFound\\n        If any of the input nodes are not found in the graph,\\n        a :exc:`NodeNotFound` exception is raised.\\n\\n    Notes\\n    -----\\n    A d-separating set in a DAG is a set of nodes that\\n    blocks all paths between the two sets. Nodes in `z`\\n    block a path if they are part of the path and are not a collider,\\n    or a descendant of a collider. A collider structure along a path\\n    is ``... -> c <- ...`` where ``c`` is the collider node.\\n\\n    https://en.wikipedia.org/wiki/Bayesian_network#d-separation\\n    '\n    if not nx.is_directed_acyclic_graph(G):\n        raise nx.NetworkXError('graph should be directed acyclic')\n    union_xyz = x.union(y).union(z)\n    if any((n not in G.nodes for n in union_xyz)):\n        raise nx.NodeNotFound('one or more specified nodes not found in the graph')\n    G_copy = G.copy()\n    leaves = deque([n for n in G_copy.nodes if G_copy.out_degree[n] == 0])\n    while len(leaves) > 0:\n        leaf = leaves.popleft()\n        if leaf not in union_xyz:\n            for p in G_copy.predecessors(leaf):\n                if G_copy.out_degree[p] == 1:\n                    leaves.append(p)\n            G_copy.remove_node(leaf)\n    edges_to_remove = list(G_copy.out_edges(z))\n    G_copy.remove_edges_from(edges_to_remove)\n    disjoint_set = UnionFind(G_copy.nodes())\n    for component in nx.weakly_connected_components(G_copy):\n        disjoint_set.union(*component)\n    disjoint_set.union(*x)\n    disjoint_set.union(*y)\n    if x and y and (disjoint_set[next(iter(x))] == disjoint_set[next(iter(y))]):\n        return False\n    else:\n        return True"
        ]
    },
    {
        "func_name": "minimal_d_separator",
        "original": "@not_implemented_for('undirected')\n@nx._dispatch\ndef minimal_d_separator(G, u, v):\n    \"\"\"Compute a minimal d-separating set between 'u' and 'v'.\n\n    A d-separating set in a DAG is a set of nodes that blocks all paths\n    between the two nodes, 'u' and 'v'. This function\n    constructs a d-separating set that is \"minimal\", meaning it is the smallest\n    d-separating set for 'u' and 'v'. This is not necessarily\n    unique. For more details, see Notes.\n\n    Parameters\n    ----------\n    G : graph\n        A networkx DAG.\n    u : node\n        A node in the graph, G.\n    v : node\n        A node in the graph, G.\n\n    Raises\n    ------\n    NetworkXError\n        Raises a :exc:`NetworkXError` if the input graph is not a DAG.\n\n    NodeNotFound\n        If any of the input nodes are not found in the graph,\n        a :exc:`NodeNotFound` exception is raised.\n\n    References\n    ----------\n    .. [1] Tian, J., & Paz, A. (1998). Finding Minimal D-separators.\n\n    Notes\n    -----\n    This function only finds ``a`` minimal d-separator. It does not guarantee\n    uniqueness, since in a DAG there may be more than one minimal d-separator\n    between two nodes. Moreover, this only checks for minimal separators\n    between two nodes, not two sets. Finding minimal d-separators between\n    two sets of nodes is not supported.\n\n    Uses the algorithm presented in [1]_. The complexity of the algorithm\n    is :math:`O(|E_{An}^m|)`, where :math:`|E_{An}^m|` stands for the\n    number of edges in the moralized graph of the sub-graph consisting\n    of only the ancestors of 'u' and 'v'. For full details, see [1]_.\n\n    The algorithm works by constructing the moral graph consisting of just\n    the ancestors of `u` and `v`. Then it constructs a candidate for\n    a separating set  ``Z'`` from the predecessors of `u` and `v`.\n    Then BFS is run starting from `u` and marking nodes\n    found from ``Z'`` and calling those nodes ``Z''``.\n    Then BFS is run again starting from `v` and marking nodes if they are\n    present in ``Z''``. Those marked nodes are the returned minimal\n    d-separating set.\n\n    https://en.wikipedia.org/wiki/Bayesian_network#d-separation\n    \"\"\"\n    if not nx.is_directed_acyclic_graph(G):\n        raise nx.NetworkXError('graph should be directed acyclic')\n    union_uv = {u, v}\n    if any((n not in G.nodes for n in union_uv)):\n        raise nx.NodeNotFound('one or more specified nodes not found in the graph')\n    x_anc = nx.ancestors(G, u)\n    y_anc = nx.ancestors(G, v)\n    D_anc_xy = x_anc.union(y_anc)\n    D_anc_xy.update((u, v))\n    moral_G = nx.moral_graph(G.subgraph(D_anc_xy))\n    Z_prime = set(G.predecessors(u)).union(set(G.predecessors(v)))\n    Z_dprime = _bfs_with_marks(moral_G, u, Z_prime)\n    Z = _bfs_with_marks(moral_G, v, Z_dprime)\n    return Z",
        "mutated": [
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef minimal_d_separator(G, u, v):\n    if False:\n        i = 10\n    'Compute a minimal d-separating set between \\'u\\' and \\'v\\'.\\n\\n    A d-separating set in a DAG is a set of nodes that blocks all paths\\n    between the two nodes, \\'u\\' and \\'v\\'. This function\\n    constructs a d-separating set that is \"minimal\", meaning it is the smallest\\n    d-separating set for \\'u\\' and \\'v\\'. This is not necessarily\\n    unique. For more details, see Notes.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        A networkx DAG.\\n    u : node\\n        A node in the graph, G.\\n    v : node\\n        A node in the graph, G.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        Raises a :exc:`NetworkXError` if the input graph is not a DAG.\\n\\n    NodeNotFound\\n        If any of the input nodes are not found in the graph,\\n        a :exc:`NodeNotFound` exception is raised.\\n\\n    References\\n    ----------\\n    .. [1] Tian, J., & Paz, A. (1998). Finding Minimal D-separators.\\n\\n    Notes\\n    -----\\n    This function only finds ``a`` minimal d-separator. It does not guarantee\\n    uniqueness, since in a DAG there may be more than one minimal d-separator\\n    between two nodes. Moreover, this only checks for minimal separators\\n    between two nodes, not two sets. Finding minimal d-separators between\\n    two sets of nodes is not supported.\\n\\n    Uses the algorithm presented in [1]_. The complexity of the algorithm\\n    is :math:`O(|E_{An}^m|)`, where :math:`|E_{An}^m|` stands for the\\n    number of edges in the moralized graph of the sub-graph consisting\\n    of only the ancestors of \\'u\\' and \\'v\\'. For full details, see [1]_.\\n\\n    The algorithm works by constructing the moral graph consisting of just\\n    the ancestors of `u` and `v`. Then it constructs a candidate for\\n    a separating set  ``Z\\'`` from the predecessors of `u` and `v`.\\n    Then BFS is run starting from `u` and marking nodes\\n    found from ``Z\\'`` and calling those nodes ``Z\\'\\'``.\\n    Then BFS is run again starting from `v` and marking nodes if they are\\n    present in ``Z\\'\\'``. Those marked nodes are the returned minimal\\n    d-separating set.\\n\\n    https://en.wikipedia.org/wiki/Bayesian_network#d-separation\\n    '\n    if not nx.is_directed_acyclic_graph(G):\n        raise nx.NetworkXError('graph should be directed acyclic')\n    union_uv = {u, v}\n    if any((n not in G.nodes for n in union_uv)):\n        raise nx.NodeNotFound('one or more specified nodes not found in the graph')\n    x_anc = nx.ancestors(G, u)\n    y_anc = nx.ancestors(G, v)\n    D_anc_xy = x_anc.union(y_anc)\n    D_anc_xy.update((u, v))\n    moral_G = nx.moral_graph(G.subgraph(D_anc_xy))\n    Z_prime = set(G.predecessors(u)).union(set(G.predecessors(v)))\n    Z_dprime = _bfs_with_marks(moral_G, u, Z_prime)\n    Z = _bfs_with_marks(moral_G, v, Z_dprime)\n    return Z",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef minimal_d_separator(G, u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute a minimal d-separating set between \\'u\\' and \\'v\\'.\\n\\n    A d-separating set in a DAG is a set of nodes that blocks all paths\\n    between the two nodes, \\'u\\' and \\'v\\'. This function\\n    constructs a d-separating set that is \"minimal\", meaning it is the smallest\\n    d-separating set for \\'u\\' and \\'v\\'. This is not necessarily\\n    unique. For more details, see Notes.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        A networkx DAG.\\n    u : node\\n        A node in the graph, G.\\n    v : node\\n        A node in the graph, G.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        Raises a :exc:`NetworkXError` if the input graph is not a DAG.\\n\\n    NodeNotFound\\n        If any of the input nodes are not found in the graph,\\n        a :exc:`NodeNotFound` exception is raised.\\n\\n    References\\n    ----------\\n    .. [1] Tian, J., & Paz, A. (1998). Finding Minimal D-separators.\\n\\n    Notes\\n    -----\\n    This function only finds ``a`` minimal d-separator. It does not guarantee\\n    uniqueness, since in a DAG there may be more than one minimal d-separator\\n    between two nodes. Moreover, this only checks for minimal separators\\n    between two nodes, not two sets. Finding minimal d-separators between\\n    two sets of nodes is not supported.\\n\\n    Uses the algorithm presented in [1]_. The complexity of the algorithm\\n    is :math:`O(|E_{An}^m|)`, where :math:`|E_{An}^m|` stands for the\\n    number of edges in the moralized graph of the sub-graph consisting\\n    of only the ancestors of \\'u\\' and \\'v\\'. For full details, see [1]_.\\n\\n    The algorithm works by constructing the moral graph consisting of just\\n    the ancestors of `u` and `v`. Then it constructs a candidate for\\n    a separating set  ``Z\\'`` from the predecessors of `u` and `v`.\\n    Then BFS is run starting from `u` and marking nodes\\n    found from ``Z\\'`` and calling those nodes ``Z\\'\\'``.\\n    Then BFS is run again starting from `v` and marking nodes if they are\\n    present in ``Z\\'\\'``. Those marked nodes are the returned minimal\\n    d-separating set.\\n\\n    https://en.wikipedia.org/wiki/Bayesian_network#d-separation\\n    '\n    if not nx.is_directed_acyclic_graph(G):\n        raise nx.NetworkXError('graph should be directed acyclic')\n    union_uv = {u, v}\n    if any((n not in G.nodes for n in union_uv)):\n        raise nx.NodeNotFound('one or more specified nodes not found in the graph')\n    x_anc = nx.ancestors(G, u)\n    y_anc = nx.ancestors(G, v)\n    D_anc_xy = x_anc.union(y_anc)\n    D_anc_xy.update((u, v))\n    moral_G = nx.moral_graph(G.subgraph(D_anc_xy))\n    Z_prime = set(G.predecessors(u)).union(set(G.predecessors(v)))\n    Z_dprime = _bfs_with_marks(moral_G, u, Z_prime)\n    Z = _bfs_with_marks(moral_G, v, Z_dprime)\n    return Z",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef minimal_d_separator(G, u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute a minimal d-separating set between \\'u\\' and \\'v\\'.\\n\\n    A d-separating set in a DAG is a set of nodes that blocks all paths\\n    between the two nodes, \\'u\\' and \\'v\\'. This function\\n    constructs a d-separating set that is \"minimal\", meaning it is the smallest\\n    d-separating set for \\'u\\' and \\'v\\'. This is not necessarily\\n    unique. For more details, see Notes.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        A networkx DAG.\\n    u : node\\n        A node in the graph, G.\\n    v : node\\n        A node in the graph, G.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        Raises a :exc:`NetworkXError` if the input graph is not a DAG.\\n\\n    NodeNotFound\\n        If any of the input nodes are not found in the graph,\\n        a :exc:`NodeNotFound` exception is raised.\\n\\n    References\\n    ----------\\n    .. [1] Tian, J., & Paz, A. (1998). Finding Minimal D-separators.\\n\\n    Notes\\n    -----\\n    This function only finds ``a`` minimal d-separator. It does not guarantee\\n    uniqueness, since in a DAG there may be more than one minimal d-separator\\n    between two nodes. Moreover, this only checks for minimal separators\\n    between two nodes, not two sets. Finding minimal d-separators between\\n    two sets of nodes is not supported.\\n\\n    Uses the algorithm presented in [1]_. The complexity of the algorithm\\n    is :math:`O(|E_{An}^m|)`, where :math:`|E_{An}^m|` stands for the\\n    number of edges in the moralized graph of the sub-graph consisting\\n    of only the ancestors of \\'u\\' and \\'v\\'. For full details, see [1]_.\\n\\n    The algorithm works by constructing the moral graph consisting of just\\n    the ancestors of `u` and `v`. Then it constructs a candidate for\\n    a separating set  ``Z\\'`` from the predecessors of `u` and `v`.\\n    Then BFS is run starting from `u` and marking nodes\\n    found from ``Z\\'`` and calling those nodes ``Z\\'\\'``.\\n    Then BFS is run again starting from `v` and marking nodes if they are\\n    present in ``Z\\'\\'``. Those marked nodes are the returned minimal\\n    d-separating set.\\n\\n    https://en.wikipedia.org/wiki/Bayesian_network#d-separation\\n    '\n    if not nx.is_directed_acyclic_graph(G):\n        raise nx.NetworkXError('graph should be directed acyclic')\n    union_uv = {u, v}\n    if any((n not in G.nodes for n in union_uv)):\n        raise nx.NodeNotFound('one or more specified nodes not found in the graph')\n    x_anc = nx.ancestors(G, u)\n    y_anc = nx.ancestors(G, v)\n    D_anc_xy = x_anc.union(y_anc)\n    D_anc_xy.update((u, v))\n    moral_G = nx.moral_graph(G.subgraph(D_anc_xy))\n    Z_prime = set(G.predecessors(u)).union(set(G.predecessors(v)))\n    Z_dprime = _bfs_with_marks(moral_G, u, Z_prime)\n    Z = _bfs_with_marks(moral_G, v, Z_dprime)\n    return Z",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef minimal_d_separator(G, u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute a minimal d-separating set between \\'u\\' and \\'v\\'.\\n\\n    A d-separating set in a DAG is a set of nodes that blocks all paths\\n    between the two nodes, \\'u\\' and \\'v\\'. This function\\n    constructs a d-separating set that is \"minimal\", meaning it is the smallest\\n    d-separating set for \\'u\\' and \\'v\\'. This is not necessarily\\n    unique. For more details, see Notes.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        A networkx DAG.\\n    u : node\\n        A node in the graph, G.\\n    v : node\\n        A node in the graph, G.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        Raises a :exc:`NetworkXError` if the input graph is not a DAG.\\n\\n    NodeNotFound\\n        If any of the input nodes are not found in the graph,\\n        a :exc:`NodeNotFound` exception is raised.\\n\\n    References\\n    ----------\\n    .. [1] Tian, J., & Paz, A. (1998). Finding Minimal D-separators.\\n\\n    Notes\\n    -----\\n    This function only finds ``a`` minimal d-separator. It does not guarantee\\n    uniqueness, since in a DAG there may be more than one minimal d-separator\\n    between two nodes. Moreover, this only checks for minimal separators\\n    between two nodes, not two sets. Finding minimal d-separators between\\n    two sets of nodes is not supported.\\n\\n    Uses the algorithm presented in [1]_. The complexity of the algorithm\\n    is :math:`O(|E_{An}^m|)`, where :math:`|E_{An}^m|` stands for the\\n    number of edges in the moralized graph of the sub-graph consisting\\n    of only the ancestors of \\'u\\' and \\'v\\'. For full details, see [1]_.\\n\\n    The algorithm works by constructing the moral graph consisting of just\\n    the ancestors of `u` and `v`. Then it constructs a candidate for\\n    a separating set  ``Z\\'`` from the predecessors of `u` and `v`.\\n    Then BFS is run starting from `u` and marking nodes\\n    found from ``Z\\'`` and calling those nodes ``Z\\'\\'``.\\n    Then BFS is run again starting from `v` and marking nodes if they are\\n    present in ``Z\\'\\'``. Those marked nodes are the returned minimal\\n    d-separating set.\\n\\n    https://en.wikipedia.org/wiki/Bayesian_network#d-separation\\n    '\n    if not nx.is_directed_acyclic_graph(G):\n        raise nx.NetworkXError('graph should be directed acyclic')\n    union_uv = {u, v}\n    if any((n not in G.nodes for n in union_uv)):\n        raise nx.NodeNotFound('one or more specified nodes not found in the graph')\n    x_anc = nx.ancestors(G, u)\n    y_anc = nx.ancestors(G, v)\n    D_anc_xy = x_anc.union(y_anc)\n    D_anc_xy.update((u, v))\n    moral_G = nx.moral_graph(G.subgraph(D_anc_xy))\n    Z_prime = set(G.predecessors(u)).union(set(G.predecessors(v)))\n    Z_dprime = _bfs_with_marks(moral_G, u, Z_prime)\n    Z = _bfs_with_marks(moral_G, v, Z_dprime)\n    return Z",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef minimal_d_separator(G, u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute a minimal d-separating set between \\'u\\' and \\'v\\'.\\n\\n    A d-separating set in a DAG is a set of nodes that blocks all paths\\n    between the two nodes, \\'u\\' and \\'v\\'. This function\\n    constructs a d-separating set that is \"minimal\", meaning it is the smallest\\n    d-separating set for \\'u\\' and \\'v\\'. This is not necessarily\\n    unique. For more details, see Notes.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        A networkx DAG.\\n    u : node\\n        A node in the graph, G.\\n    v : node\\n        A node in the graph, G.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        Raises a :exc:`NetworkXError` if the input graph is not a DAG.\\n\\n    NodeNotFound\\n        If any of the input nodes are not found in the graph,\\n        a :exc:`NodeNotFound` exception is raised.\\n\\n    References\\n    ----------\\n    .. [1] Tian, J., & Paz, A. (1998). Finding Minimal D-separators.\\n\\n    Notes\\n    -----\\n    This function only finds ``a`` minimal d-separator. It does not guarantee\\n    uniqueness, since in a DAG there may be more than one minimal d-separator\\n    between two nodes. Moreover, this only checks for minimal separators\\n    between two nodes, not two sets. Finding minimal d-separators between\\n    two sets of nodes is not supported.\\n\\n    Uses the algorithm presented in [1]_. The complexity of the algorithm\\n    is :math:`O(|E_{An}^m|)`, where :math:`|E_{An}^m|` stands for the\\n    number of edges in the moralized graph of the sub-graph consisting\\n    of only the ancestors of \\'u\\' and \\'v\\'. For full details, see [1]_.\\n\\n    The algorithm works by constructing the moral graph consisting of just\\n    the ancestors of `u` and `v`. Then it constructs a candidate for\\n    a separating set  ``Z\\'`` from the predecessors of `u` and `v`.\\n    Then BFS is run starting from `u` and marking nodes\\n    found from ``Z\\'`` and calling those nodes ``Z\\'\\'``.\\n    Then BFS is run again starting from `v` and marking nodes if they are\\n    present in ``Z\\'\\'``. Those marked nodes are the returned minimal\\n    d-separating set.\\n\\n    https://en.wikipedia.org/wiki/Bayesian_network#d-separation\\n    '\n    if not nx.is_directed_acyclic_graph(G):\n        raise nx.NetworkXError('graph should be directed acyclic')\n    union_uv = {u, v}\n    if any((n not in G.nodes for n in union_uv)):\n        raise nx.NodeNotFound('one or more specified nodes not found in the graph')\n    x_anc = nx.ancestors(G, u)\n    y_anc = nx.ancestors(G, v)\n    D_anc_xy = x_anc.union(y_anc)\n    D_anc_xy.update((u, v))\n    moral_G = nx.moral_graph(G.subgraph(D_anc_xy))\n    Z_prime = set(G.predecessors(u)).union(set(G.predecessors(v)))\n    Z_dprime = _bfs_with_marks(moral_G, u, Z_prime)\n    Z = _bfs_with_marks(moral_G, v, Z_dprime)\n    return Z"
        ]
    },
    {
        "func_name": "is_minimal_d_separator",
        "original": "@not_implemented_for('undirected')\n@nx._dispatch\ndef is_minimal_d_separator(G, u, v, z):\n    \"\"\"Determine if a d-separating set is minimal.\n\n    A d-separating set, `z`, in a DAG is a set of nodes that blocks\n    all paths between the two nodes, `u` and `v`. This function\n    verifies that a set is \"minimal\", meaning there is no smaller\n    d-separating set between the two nodes.\n\n    Note: This function checks whether `z` is a d-separator AND is minimal.\n    One can use the function `d_separated` to only check if `z` is a d-separator.\n    See examples below.\n\n    Parameters\n    ----------\n    G : nx.DiGraph\n        The graph.\n    u : node\n        A node in the graph.\n    v : node\n        A node in the graph.\n    z : Set of nodes\n        The set of nodes to check if it is a minimal d-separating set.\n        The function :func:`d_separated` is called inside this function\n        to verify that `z` is in fact a d-separator.\n\n    Returns\n    -------\n    bool\n        Whether or not the set `z` is a d-separator and is also minimal.\n\n    Examples\n    --------\n    >>> G = nx.path_graph([0, 1, 2, 3], create_using=nx.DiGraph)\n    >>> G.add_node(4)\n    >>> nx.is_minimal_d_separator(G, 0, 2, {1})\n    True\n    >>> # since {1} is the minimal d-separator, {1, 3, 4} is not minimal\n    >>> nx.is_minimal_d_separator(G, 0, 2, {1, 3, 4})\n    False\n    >>> # alternatively, if we only want to check that {1, 3, 4} is a d-separator\n    >>> nx.d_separated(G, {0}, {4}, {1, 3, 4})\n    True\n\n    Raises\n    ------\n    NetworkXError\n        Raises a :exc:`NetworkXError` if the input graph is not a DAG.\n\n    NodeNotFound\n        If any of the input nodes are not found in the graph,\n        a :exc:`NodeNotFound` exception is raised.\n\n    References\n    ----------\n    .. [1] Tian, J., & Paz, A. (1998). Finding Minimal D-separators.\n\n    Notes\n    -----\n    This function only works on verifying a d-separating set is minimal\n    between two nodes. To verify that a d-separating set is minimal between\n    two sets of nodes is not supported.\n\n    Uses algorithm 2 presented in [1]_. The complexity of the algorithm\n    is :math:`O(|E_{An}^m|)`, where :math:`|E_{An}^m|` stands for the\n    number of edges in the moralized graph of the sub-graph consisting\n    of only the ancestors of ``u`` and ``v``.\n\n    The algorithm works by constructing the moral graph consisting of just\n    the ancestors of `u` and `v`. First, it performs BFS on the moral graph\n    starting from `u` and marking any nodes it encounters that are part of\n    the separating set, `z`. If a node is marked, then it does not continue\n    along that path. In the second stage, BFS with markings is repeated on the\n    moral graph starting from `v`. If at any stage, any node in `z` is\n    not marked, then `z` is considered not minimal. If the end of the algorithm\n    is reached, then `z` is minimal.\n\n    For full details, see [1]_.\n\n    https://en.wikipedia.org/wiki/Bayesian_network#d-separation\n    \"\"\"\n    if not nx.d_separated(G, {u}, {v}, z):\n        return False\n    x_anc = nx.ancestors(G, u)\n    y_anc = nx.ancestors(G, v)\n    xy_anc = x_anc.union(y_anc)\n    if any((node not in xy_anc for node in z)):\n        return False\n    D_anc_xy = x_anc.union(y_anc)\n    D_anc_xy.update((u, v))\n    moral_G = nx.moral_graph(G.subgraph(D_anc_xy))\n    marks = _bfs_with_marks(moral_G, u, z)\n    if any((node not in marks for node in z)):\n        return False\n    marks = _bfs_with_marks(moral_G, v, z)\n    if any((node not in marks for node in z)):\n        return False\n    return True",
        "mutated": [
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef is_minimal_d_separator(G, u, v, z):\n    if False:\n        i = 10\n    'Determine if a d-separating set is minimal.\\n\\n    A d-separating set, `z`, in a DAG is a set of nodes that blocks\\n    all paths between the two nodes, `u` and `v`. This function\\n    verifies that a set is \"minimal\", meaning there is no smaller\\n    d-separating set between the two nodes.\\n\\n    Note: This function checks whether `z` is a d-separator AND is minimal.\\n    One can use the function `d_separated` to only check if `z` is a d-separator.\\n    See examples below.\\n\\n    Parameters\\n    ----------\\n    G : nx.DiGraph\\n        The graph.\\n    u : node\\n        A node in the graph.\\n    v : node\\n        A node in the graph.\\n    z : Set of nodes\\n        The set of nodes to check if it is a minimal d-separating set.\\n        The function :func:`d_separated` is called inside this function\\n        to verify that `z` is in fact a d-separator.\\n\\n    Returns\\n    -------\\n    bool\\n        Whether or not the set `z` is a d-separator and is also minimal.\\n\\n    Examples\\n    --------\\n    >>> G = nx.path_graph([0, 1, 2, 3], create_using=nx.DiGraph)\\n    >>> G.add_node(4)\\n    >>> nx.is_minimal_d_separator(G, 0, 2, {1})\\n    True\\n    >>> # since {1} is the minimal d-separator, {1, 3, 4} is not minimal\\n    >>> nx.is_minimal_d_separator(G, 0, 2, {1, 3, 4})\\n    False\\n    >>> # alternatively, if we only want to check that {1, 3, 4} is a d-separator\\n    >>> nx.d_separated(G, {0}, {4}, {1, 3, 4})\\n    True\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        Raises a :exc:`NetworkXError` if the input graph is not a DAG.\\n\\n    NodeNotFound\\n        If any of the input nodes are not found in the graph,\\n        a :exc:`NodeNotFound` exception is raised.\\n\\n    References\\n    ----------\\n    .. [1] Tian, J., & Paz, A. (1998). Finding Minimal D-separators.\\n\\n    Notes\\n    -----\\n    This function only works on verifying a d-separating set is minimal\\n    between two nodes. To verify that a d-separating set is minimal between\\n    two sets of nodes is not supported.\\n\\n    Uses algorithm 2 presented in [1]_. The complexity of the algorithm\\n    is :math:`O(|E_{An}^m|)`, where :math:`|E_{An}^m|` stands for the\\n    number of edges in the moralized graph of the sub-graph consisting\\n    of only the ancestors of ``u`` and ``v``.\\n\\n    The algorithm works by constructing the moral graph consisting of just\\n    the ancestors of `u` and `v`. First, it performs BFS on the moral graph\\n    starting from `u` and marking any nodes it encounters that are part of\\n    the separating set, `z`. If a node is marked, then it does not continue\\n    along that path. In the second stage, BFS with markings is repeated on the\\n    moral graph starting from `v`. If at any stage, any node in `z` is\\n    not marked, then `z` is considered not minimal. If the end of the algorithm\\n    is reached, then `z` is minimal.\\n\\n    For full details, see [1]_.\\n\\n    https://en.wikipedia.org/wiki/Bayesian_network#d-separation\\n    '\n    if not nx.d_separated(G, {u}, {v}, z):\n        return False\n    x_anc = nx.ancestors(G, u)\n    y_anc = nx.ancestors(G, v)\n    xy_anc = x_anc.union(y_anc)\n    if any((node not in xy_anc for node in z)):\n        return False\n    D_anc_xy = x_anc.union(y_anc)\n    D_anc_xy.update((u, v))\n    moral_G = nx.moral_graph(G.subgraph(D_anc_xy))\n    marks = _bfs_with_marks(moral_G, u, z)\n    if any((node not in marks for node in z)):\n        return False\n    marks = _bfs_with_marks(moral_G, v, z)\n    if any((node not in marks for node in z)):\n        return False\n    return True",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef is_minimal_d_separator(G, u, v, z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Determine if a d-separating set is minimal.\\n\\n    A d-separating set, `z`, in a DAG is a set of nodes that blocks\\n    all paths between the two nodes, `u` and `v`. This function\\n    verifies that a set is \"minimal\", meaning there is no smaller\\n    d-separating set between the two nodes.\\n\\n    Note: This function checks whether `z` is a d-separator AND is minimal.\\n    One can use the function `d_separated` to only check if `z` is a d-separator.\\n    See examples below.\\n\\n    Parameters\\n    ----------\\n    G : nx.DiGraph\\n        The graph.\\n    u : node\\n        A node in the graph.\\n    v : node\\n        A node in the graph.\\n    z : Set of nodes\\n        The set of nodes to check if it is a minimal d-separating set.\\n        The function :func:`d_separated` is called inside this function\\n        to verify that `z` is in fact a d-separator.\\n\\n    Returns\\n    -------\\n    bool\\n        Whether or not the set `z` is a d-separator and is also minimal.\\n\\n    Examples\\n    --------\\n    >>> G = nx.path_graph([0, 1, 2, 3], create_using=nx.DiGraph)\\n    >>> G.add_node(4)\\n    >>> nx.is_minimal_d_separator(G, 0, 2, {1})\\n    True\\n    >>> # since {1} is the minimal d-separator, {1, 3, 4} is not minimal\\n    >>> nx.is_minimal_d_separator(G, 0, 2, {1, 3, 4})\\n    False\\n    >>> # alternatively, if we only want to check that {1, 3, 4} is a d-separator\\n    >>> nx.d_separated(G, {0}, {4}, {1, 3, 4})\\n    True\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        Raises a :exc:`NetworkXError` if the input graph is not a DAG.\\n\\n    NodeNotFound\\n        If any of the input nodes are not found in the graph,\\n        a :exc:`NodeNotFound` exception is raised.\\n\\n    References\\n    ----------\\n    .. [1] Tian, J., & Paz, A. (1998). Finding Minimal D-separators.\\n\\n    Notes\\n    -----\\n    This function only works on verifying a d-separating set is minimal\\n    between two nodes. To verify that a d-separating set is minimal between\\n    two sets of nodes is not supported.\\n\\n    Uses algorithm 2 presented in [1]_. The complexity of the algorithm\\n    is :math:`O(|E_{An}^m|)`, where :math:`|E_{An}^m|` stands for the\\n    number of edges in the moralized graph of the sub-graph consisting\\n    of only the ancestors of ``u`` and ``v``.\\n\\n    The algorithm works by constructing the moral graph consisting of just\\n    the ancestors of `u` and `v`. First, it performs BFS on the moral graph\\n    starting from `u` and marking any nodes it encounters that are part of\\n    the separating set, `z`. If a node is marked, then it does not continue\\n    along that path. In the second stage, BFS with markings is repeated on the\\n    moral graph starting from `v`. If at any stage, any node in `z` is\\n    not marked, then `z` is considered not minimal. If the end of the algorithm\\n    is reached, then `z` is minimal.\\n\\n    For full details, see [1]_.\\n\\n    https://en.wikipedia.org/wiki/Bayesian_network#d-separation\\n    '\n    if not nx.d_separated(G, {u}, {v}, z):\n        return False\n    x_anc = nx.ancestors(G, u)\n    y_anc = nx.ancestors(G, v)\n    xy_anc = x_anc.union(y_anc)\n    if any((node not in xy_anc for node in z)):\n        return False\n    D_anc_xy = x_anc.union(y_anc)\n    D_anc_xy.update((u, v))\n    moral_G = nx.moral_graph(G.subgraph(D_anc_xy))\n    marks = _bfs_with_marks(moral_G, u, z)\n    if any((node not in marks for node in z)):\n        return False\n    marks = _bfs_with_marks(moral_G, v, z)\n    if any((node not in marks for node in z)):\n        return False\n    return True",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef is_minimal_d_separator(G, u, v, z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Determine if a d-separating set is minimal.\\n\\n    A d-separating set, `z`, in a DAG is a set of nodes that blocks\\n    all paths between the two nodes, `u` and `v`. This function\\n    verifies that a set is \"minimal\", meaning there is no smaller\\n    d-separating set between the two nodes.\\n\\n    Note: This function checks whether `z` is a d-separator AND is minimal.\\n    One can use the function `d_separated` to only check if `z` is a d-separator.\\n    See examples below.\\n\\n    Parameters\\n    ----------\\n    G : nx.DiGraph\\n        The graph.\\n    u : node\\n        A node in the graph.\\n    v : node\\n        A node in the graph.\\n    z : Set of nodes\\n        The set of nodes to check if it is a minimal d-separating set.\\n        The function :func:`d_separated` is called inside this function\\n        to verify that `z` is in fact a d-separator.\\n\\n    Returns\\n    -------\\n    bool\\n        Whether or not the set `z` is a d-separator and is also minimal.\\n\\n    Examples\\n    --------\\n    >>> G = nx.path_graph([0, 1, 2, 3], create_using=nx.DiGraph)\\n    >>> G.add_node(4)\\n    >>> nx.is_minimal_d_separator(G, 0, 2, {1})\\n    True\\n    >>> # since {1} is the minimal d-separator, {1, 3, 4} is not minimal\\n    >>> nx.is_minimal_d_separator(G, 0, 2, {1, 3, 4})\\n    False\\n    >>> # alternatively, if we only want to check that {1, 3, 4} is a d-separator\\n    >>> nx.d_separated(G, {0}, {4}, {1, 3, 4})\\n    True\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        Raises a :exc:`NetworkXError` if the input graph is not a DAG.\\n\\n    NodeNotFound\\n        If any of the input nodes are not found in the graph,\\n        a :exc:`NodeNotFound` exception is raised.\\n\\n    References\\n    ----------\\n    .. [1] Tian, J., & Paz, A. (1998). Finding Minimal D-separators.\\n\\n    Notes\\n    -----\\n    This function only works on verifying a d-separating set is minimal\\n    between two nodes. To verify that a d-separating set is minimal between\\n    two sets of nodes is not supported.\\n\\n    Uses algorithm 2 presented in [1]_. The complexity of the algorithm\\n    is :math:`O(|E_{An}^m|)`, where :math:`|E_{An}^m|` stands for the\\n    number of edges in the moralized graph of the sub-graph consisting\\n    of only the ancestors of ``u`` and ``v``.\\n\\n    The algorithm works by constructing the moral graph consisting of just\\n    the ancestors of `u` and `v`. First, it performs BFS on the moral graph\\n    starting from `u` and marking any nodes it encounters that are part of\\n    the separating set, `z`. If a node is marked, then it does not continue\\n    along that path. In the second stage, BFS with markings is repeated on the\\n    moral graph starting from `v`. If at any stage, any node in `z` is\\n    not marked, then `z` is considered not minimal. If the end of the algorithm\\n    is reached, then `z` is minimal.\\n\\n    For full details, see [1]_.\\n\\n    https://en.wikipedia.org/wiki/Bayesian_network#d-separation\\n    '\n    if not nx.d_separated(G, {u}, {v}, z):\n        return False\n    x_anc = nx.ancestors(G, u)\n    y_anc = nx.ancestors(G, v)\n    xy_anc = x_anc.union(y_anc)\n    if any((node not in xy_anc for node in z)):\n        return False\n    D_anc_xy = x_anc.union(y_anc)\n    D_anc_xy.update((u, v))\n    moral_G = nx.moral_graph(G.subgraph(D_anc_xy))\n    marks = _bfs_with_marks(moral_G, u, z)\n    if any((node not in marks for node in z)):\n        return False\n    marks = _bfs_with_marks(moral_G, v, z)\n    if any((node not in marks for node in z)):\n        return False\n    return True",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef is_minimal_d_separator(G, u, v, z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Determine if a d-separating set is minimal.\\n\\n    A d-separating set, `z`, in a DAG is a set of nodes that blocks\\n    all paths between the two nodes, `u` and `v`. This function\\n    verifies that a set is \"minimal\", meaning there is no smaller\\n    d-separating set between the two nodes.\\n\\n    Note: This function checks whether `z` is a d-separator AND is minimal.\\n    One can use the function `d_separated` to only check if `z` is a d-separator.\\n    See examples below.\\n\\n    Parameters\\n    ----------\\n    G : nx.DiGraph\\n        The graph.\\n    u : node\\n        A node in the graph.\\n    v : node\\n        A node in the graph.\\n    z : Set of nodes\\n        The set of nodes to check if it is a minimal d-separating set.\\n        The function :func:`d_separated` is called inside this function\\n        to verify that `z` is in fact a d-separator.\\n\\n    Returns\\n    -------\\n    bool\\n        Whether or not the set `z` is a d-separator and is also minimal.\\n\\n    Examples\\n    --------\\n    >>> G = nx.path_graph([0, 1, 2, 3], create_using=nx.DiGraph)\\n    >>> G.add_node(4)\\n    >>> nx.is_minimal_d_separator(G, 0, 2, {1})\\n    True\\n    >>> # since {1} is the minimal d-separator, {1, 3, 4} is not minimal\\n    >>> nx.is_minimal_d_separator(G, 0, 2, {1, 3, 4})\\n    False\\n    >>> # alternatively, if we only want to check that {1, 3, 4} is a d-separator\\n    >>> nx.d_separated(G, {0}, {4}, {1, 3, 4})\\n    True\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        Raises a :exc:`NetworkXError` if the input graph is not a DAG.\\n\\n    NodeNotFound\\n        If any of the input nodes are not found in the graph,\\n        a :exc:`NodeNotFound` exception is raised.\\n\\n    References\\n    ----------\\n    .. [1] Tian, J., & Paz, A. (1998). Finding Minimal D-separators.\\n\\n    Notes\\n    -----\\n    This function only works on verifying a d-separating set is minimal\\n    between two nodes. To verify that a d-separating set is minimal between\\n    two sets of nodes is not supported.\\n\\n    Uses algorithm 2 presented in [1]_. The complexity of the algorithm\\n    is :math:`O(|E_{An}^m|)`, where :math:`|E_{An}^m|` stands for the\\n    number of edges in the moralized graph of the sub-graph consisting\\n    of only the ancestors of ``u`` and ``v``.\\n\\n    The algorithm works by constructing the moral graph consisting of just\\n    the ancestors of `u` and `v`. First, it performs BFS on the moral graph\\n    starting from `u` and marking any nodes it encounters that are part of\\n    the separating set, `z`. If a node is marked, then it does not continue\\n    along that path. In the second stage, BFS with markings is repeated on the\\n    moral graph starting from `v`. If at any stage, any node in `z` is\\n    not marked, then `z` is considered not minimal. If the end of the algorithm\\n    is reached, then `z` is minimal.\\n\\n    For full details, see [1]_.\\n\\n    https://en.wikipedia.org/wiki/Bayesian_network#d-separation\\n    '\n    if not nx.d_separated(G, {u}, {v}, z):\n        return False\n    x_anc = nx.ancestors(G, u)\n    y_anc = nx.ancestors(G, v)\n    xy_anc = x_anc.union(y_anc)\n    if any((node not in xy_anc for node in z)):\n        return False\n    D_anc_xy = x_anc.union(y_anc)\n    D_anc_xy.update((u, v))\n    moral_G = nx.moral_graph(G.subgraph(D_anc_xy))\n    marks = _bfs_with_marks(moral_G, u, z)\n    if any((node not in marks for node in z)):\n        return False\n    marks = _bfs_with_marks(moral_G, v, z)\n    if any((node not in marks for node in z)):\n        return False\n    return True",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef is_minimal_d_separator(G, u, v, z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Determine if a d-separating set is minimal.\\n\\n    A d-separating set, `z`, in a DAG is a set of nodes that blocks\\n    all paths between the two nodes, `u` and `v`. This function\\n    verifies that a set is \"minimal\", meaning there is no smaller\\n    d-separating set between the two nodes.\\n\\n    Note: This function checks whether `z` is a d-separator AND is minimal.\\n    One can use the function `d_separated` to only check if `z` is a d-separator.\\n    See examples below.\\n\\n    Parameters\\n    ----------\\n    G : nx.DiGraph\\n        The graph.\\n    u : node\\n        A node in the graph.\\n    v : node\\n        A node in the graph.\\n    z : Set of nodes\\n        The set of nodes to check if it is a minimal d-separating set.\\n        The function :func:`d_separated` is called inside this function\\n        to verify that `z` is in fact a d-separator.\\n\\n    Returns\\n    -------\\n    bool\\n        Whether or not the set `z` is a d-separator and is also minimal.\\n\\n    Examples\\n    --------\\n    >>> G = nx.path_graph([0, 1, 2, 3], create_using=nx.DiGraph)\\n    >>> G.add_node(4)\\n    >>> nx.is_minimal_d_separator(G, 0, 2, {1})\\n    True\\n    >>> # since {1} is the minimal d-separator, {1, 3, 4} is not minimal\\n    >>> nx.is_minimal_d_separator(G, 0, 2, {1, 3, 4})\\n    False\\n    >>> # alternatively, if we only want to check that {1, 3, 4} is a d-separator\\n    >>> nx.d_separated(G, {0}, {4}, {1, 3, 4})\\n    True\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        Raises a :exc:`NetworkXError` if the input graph is not a DAG.\\n\\n    NodeNotFound\\n        If any of the input nodes are not found in the graph,\\n        a :exc:`NodeNotFound` exception is raised.\\n\\n    References\\n    ----------\\n    .. [1] Tian, J., & Paz, A. (1998). Finding Minimal D-separators.\\n\\n    Notes\\n    -----\\n    This function only works on verifying a d-separating set is minimal\\n    between two nodes. To verify that a d-separating set is minimal between\\n    two sets of nodes is not supported.\\n\\n    Uses algorithm 2 presented in [1]_. The complexity of the algorithm\\n    is :math:`O(|E_{An}^m|)`, where :math:`|E_{An}^m|` stands for the\\n    number of edges in the moralized graph of the sub-graph consisting\\n    of only the ancestors of ``u`` and ``v``.\\n\\n    The algorithm works by constructing the moral graph consisting of just\\n    the ancestors of `u` and `v`. First, it performs BFS on the moral graph\\n    starting from `u` and marking any nodes it encounters that are part of\\n    the separating set, `z`. If a node is marked, then it does not continue\\n    along that path. In the second stage, BFS with markings is repeated on the\\n    moral graph starting from `v`. If at any stage, any node in `z` is\\n    not marked, then `z` is considered not minimal. If the end of the algorithm\\n    is reached, then `z` is minimal.\\n\\n    For full details, see [1]_.\\n\\n    https://en.wikipedia.org/wiki/Bayesian_network#d-separation\\n    '\n    if not nx.d_separated(G, {u}, {v}, z):\n        return False\n    x_anc = nx.ancestors(G, u)\n    y_anc = nx.ancestors(G, v)\n    xy_anc = x_anc.union(y_anc)\n    if any((node not in xy_anc for node in z)):\n        return False\n    D_anc_xy = x_anc.union(y_anc)\n    D_anc_xy.update((u, v))\n    moral_G = nx.moral_graph(G.subgraph(D_anc_xy))\n    marks = _bfs_with_marks(moral_G, u, z)\n    if any((node not in marks for node in z)):\n        return False\n    marks = _bfs_with_marks(moral_G, v, z)\n    if any((node not in marks for node in z)):\n        return False\n    return True"
        ]
    },
    {
        "func_name": "_bfs_with_marks",
        "original": "@not_implemented_for('directed')\ndef _bfs_with_marks(G, start_node, check_set):\n    \"\"\"Breadth-first-search with markings.\n\n    Performs BFS starting from ``start_node`` and whenever a node\n    inside ``check_set`` is met, it is \"marked\". Once a node is marked,\n    BFS does not continue along that path. The resulting marked nodes\n    are returned.\n\n    Parameters\n    ----------\n    G : nx.Graph\n        An undirected graph.\n    start_node : node\n        The start of the BFS.\n    check_set : set\n        The set of nodes to check against.\n\n    Returns\n    -------\n    marked : set\n        A set of nodes that were marked.\n    \"\"\"\n    visited = {}\n    marked = set()\n    queue = []\n    visited[start_node] = None\n    queue.append(start_node)\n    while queue:\n        m = queue.pop(0)\n        for nbr in G.neighbors(m):\n            if nbr not in visited:\n                visited[nbr] = None\n                if nbr in check_set:\n                    marked.add(nbr)\n                else:\n                    queue.append(nbr)\n    return marked",
        "mutated": [
            "@not_implemented_for('directed')\ndef _bfs_with_marks(G, start_node, check_set):\n    if False:\n        i = 10\n    'Breadth-first-search with markings.\\n\\n    Performs BFS starting from ``start_node`` and whenever a node\\n    inside ``check_set`` is met, it is \"marked\". Once a node is marked,\\n    BFS does not continue along that path. The resulting marked nodes\\n    are returned.\\n\\n    Parameters\\n    ----------\\n    G : nx.Graph\\n        An undirected graph.\\n    start_node : node\\n        The start of the BFS.\\n    check_set : set\\n        The set of nodes to check against.\\n\\n    Returns\\n    -------\\n    marked : set\\n        A set of nodes that were marked.\\n    '\n    visited = {}\n    marked = set()\n    queue = []\n    visited[start_node] = None\n    queue.append(start_node)\n    while queue:\n        m = queue.pop(0)\n        for nbr in G.neighbors(m):\n            if nbr not in visited:\n                visited[nbr] = None\n                if nbr in check_set:\n                    marked.add(nbr)\n                else:\n                    queue.append(nbr)\n    return marked",
            "@not_implemented_for('directed')\ndef _bfs_with_marks(G, start_node, check_set):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Breadth-first-search with markings.\\n\\n    Performs BFS starting from ``start_node`` and whenever a node\\n    inside ``check_set`` is met, it is \"marked\". Once a node is marked,\\n    BFS does not continue along that path. The resulting marked nodes\\n    are returned.\\n\\n    Parameters\\n    ----------\\n    G : nx.Graph\\n        An undirected graph.\\n    start_node : node\\n        The start of the BFS.\\n    check_set : set\\n        The set of nodes to check against.\\n\\n    Returns\\n    -------\\n    marked : set\\n        A set of nodes that were marked.\\n    '\n    visited = {}\n    marked = set()\n    queue = []\n    visited[start_node] = None\n    queue.append(start_node)\n    while queue:\n        m = queue.pop(0)\n        for nbr in G.neighbors(m):\n            if nbr not in visited:\n                visited[nbr] = None\n                if nbr in check_set:\n                    marked.add(nbr)\n                else:\n                    queue.append(nbr)\n    return marked",
            "@not_implemented_for('directed')\ndef _bfs_with_marks(G, start_node, check_set):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Breadth-first-search with markings.\\n\\n    Performs BFS starting from ``start_node`` and whenever a node\\n    inside ``check_set`` is met, it is \"marked\". Once a node is marked,\\n    BFS does not continue along that path. The resulting marked nodes\\n    are returned.\\n\\n    Parameters\\n    ----------\\n    G : nx.Graph\\n        An undirected graph.\\n    start_node : node\\n        The start of the BFS.\\n    check_set : set\\n        The set of nodes to check against.\\n\\n    Returns\\n    -------\\n    marked : set\\n        A set of nodes that were marked.\\n    '\n    visited = {}\n    marked = set()\n    queue = []\n    visited[start_node] = None\n    queue.append(start_node)\n    while queue:\n        m = queue.pop(0)\n        for nbr in G.neighbors(m):\n            if nbr not in visited:\n                visited[nbr] = None\n                if nbr in check_set:\n                    marked.add(nbr)\n                else:\n                    queue.append(nbr)\n    return marked",
            "@not_implemented_for('directed')\ndef _bfs_with_marks(G, start_node, check_set):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Breadth-first-search with markings.\\n\\n    Performs BFS starting from ``start_node`` and whenever a node\\n    inside ``check_set`` is met, it is \"marked\". Once a node is marked,\\n    BFS does not continue along that path. The resulting marked nodes\\n    are returned.\\n\\n    Parameters\\n    ----------\\n    G : nx.Graph\\n        An undirected graph.\\n    start_node : node\\n        The start of the BFS.\\n    check_set : set\\n        The set of nodes to check against.\\n\\n    Returns\\n    -------\\n    marked : set\\n        A set of nodes that were marked.\\n    '\n    visited = {}\n    marked = set()\n    queue = []\n    visited[start_node] = None\n    queue.append(start_node)\n    while queue:\n        m = queue.pop(0)\n        for nbr in G.neighbors(m):\n            if nbr not in visited:\n                visited[nbr] = None\n                if nbr in check_set:\n                    marked.add(nbr)\n                else:\n                    queue.append(nbr)\n    return marked",
            "@not_implemented_for('directed')\ndef _bfs_with_marks(G, start_node, check_set):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Breadth-first-search with markings.\\n\\n    Performs BFS starting from ``start_node`` and whenever a node\\n    inside ``check_set`` is met, it is \"marked\". Once a node is marked,\\n    BFS does not continue along that path. The resulting marked nodes\\n    are returned.\\n\\n    Parameters\\n    ----------\\n    G : nx.Graph\\n        An undirected graph.\\n    start_node : node\\n        The start of the BFS.\\n    check_set : set\\n        The set of nodes to check against.\\n\\n    Returns\\n    -------\\n    marked : set\\n        A set of nodes that were marked.\\n    '\n    visited = {}\n    marked = set()\n    queue = []\n    visited[start_node] = None\n    queue.append(start_node)\n    while queue:\n        m = queue.pop(0)\n        for nbr in G.neighbors(m):\n            if nbr not in visited:\n                visited[nbr] = None\n                if nbr in check_set:\n                    marked.add(nbr)\n                else:\n                    queue.append(nbr)\n    return marked"
        ]
    }
]