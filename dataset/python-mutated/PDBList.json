[
    {
        "func_name": "__init__",
        "original": "def __init__(self, server='ftp://ftp.wwpdb.org', pdb=None, obsolete_pdb=None, verbose=True):\n    \"\"\"Initialize the class with the default server or a custom one.\n\n        Argument pdb is the local path to use, defaulting to the current\n        directory at the moment of initialisation.\n        \"\"\"\n    self.pdb_server = server\n    if pdb:\n        self.local_pdb = pdb\n    else:\n        self.local_pdb = os.getcwd()\n    self._verbose = verbose\n    if obsolete_pdb:\n        self.obsolete_pdb = obsolete_pdb\n    else:\n        self.obsolete_pdb = os.path.join(self.local_pdb, 'obsolete')\n        if not os.access(self.obsolete_pdb, os.F_OK):\n            os.makedirs(self.obsolete_pdb)\n    self.flat_tree = False",
        "mutated": [
            "def __init__(self, server='ftp://ftp.wwpdb.org', pdb=None, obsolete_pdb=None, verbose=True):\n    if False:\n        i = 10\n    'Initialize the class with the default server or a custom one.\\n\\n        Argument pdb is the local path to use, defaulting to the current\\n        directory at the moment of initialisation.\\n        '\n    self.pdb_server = server\n    if pdb:\n        self.local_pdb = pdb\n    else:\n        self.local_pdb = os.getcwd()\n    self._verbose = verbose\n    if obsolete_pdb:\n        self.obsolete_pdb = obsolete_pdb\n    else:\n        self.obsolete_pdb = os.path.join(self.local_pdb, 'obsolete')\n        if not os.access(self.obsolete_pdb, os.F_OK):\n            os.makedirs(self.obsolete_pdb)\n    self.flat_tree = False",
            "def __init__(self, server='ftp://ftp.wwpdb.org', pdb=None, obsolete_pdb=None, verbose=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Initialize the class with the default server or a custom one.\\n\\n        Argument pdb is the local path to use, defaulting to the current\\n        directory at the moment of initialisation.\\n        '\n    self.pdb_server = server\n    if pdb:\n        self.local_pdb = pdb\n    else:\n        self.local_pdb = os.getcwd()\n    self._verbose = verbose\n    if obsolete_pdb:\n        self.obsolete_pdb = obsolete_pdb\n    else:\n        self.obsolete_pdb = os.path.join(self.local_pdb, 'obsolete')\n        if not os.access(self.obsolete_pdb, os.F_OK):\n            os.makedirs(self.obsolete_pdb)\n    self.flat_tree = False",
            "def __init__(self, server='ftp://ftp.wwpdb.org', pdb=None, obsolete_pdb=None, verbose=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Initialize the class with the default server or a custom one.\\n\\n        Argument pdb is the local path to use, defaulting to the current\\n        directory at the moment of initialisation.\\n        '\n    self.pdb_server = server\n    if pdb:\n        self.local_pdb = pdb\n    else:\n        self.local_pdb = os.getcwd()\n    self._verbose = verbose\n    if obsolete_pdb:\n        self.obsolete_pdb = obsolete_pdb\n    else:\n        self.obsolete_pdb = os.path.join(self.local_pdb, 'obsolete')\n        if not os.access(self.obsolete_pdb, os.F_OK):\n            os.makedirs(self.obsolete_pdb)\n    self.flat_tree = False",
            "def __init__(self, server='ftp://ftp.wwpdb.org', pdb=None, obsolete_pdb=None, verbose=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Initialize the class with the default server or a custom one.\\n\\n        Argument pdb is the local path to use, defaulting to the current\\n        directory at the moment of initialisation.\\n        '\n    self.pdb_server = server\n    if pdb:\n        self.local_pdb = pdb\n    else:\n        self.local_pdb = os.getcwd()\n    self._verbose = verbose\n    if obsolete_pdb:\n        self.obsolete_pdb = obsolete_pdb\n    else:\n        self.obsolete_pdb = os.path.join(self.local_pdb, 'obsolete')\n        if not os.access(self.obsolete_pdb, os.F_OK):\n            os.makedirs(self.obsolete_pdb)\n    self.flat_tree = False",
            "def __init__(self, server='ftp://ftp.wwpdb.org', pdb=None, obsolete_pdb=None, verbose=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Initialize the class with the default server or a custom one.\\n\\n        Argument pdb is the local path to use, defaulting to the current\\n        directory at the moment of initialisation.\\n        '\n    self.pdb_server = server\n    if pdb:\n        self.local_pdb = pdb\n    else:\n        self.local_pdb = os.getcwd()\n    self._verbose = verbose\n    if obsolete_pdb:\n        self.obsolete_pdb = obsolete_pdb\n    else:\n        self.obsolete_pdb = os.path.join(self.local_pdb, 'obsolete')\n        if not os.access(self.obsolete_pdb, os.F_OK):\n            os.makedirs(self.obsolete_pdb)\n    self.flat_tree = False"
        ]
    },
    {
        "func_name": "_print_default_format_warning",
        "original": "@staticmethod\ndef _print_default_format_warning(file_format):\n    \"\"\"Print a warning to stdout (PRIVATE).\n\n        Temporary warning (similar to a deprecation warning) that files\n        are being downloaded in mmCIF.\n        \"\"\"\n    if file_format is None:\n        sys.stderr.write('WARNING: The default download format has changed from PDB to PDBx/mmCif\\n')\n        return 'mmCif'\n    return file_format",
        "mutated": [
            "@staticmethod\ndef _print_default_format_warning(file_format):\n    if False:\n        i = 10\n    'Print a warning to stdout (PRIVATE).\\n\\n        Temporary warning (similar to a deprecation warning) that files\\n        are being downloaded in mmCIF.\\n        '\n    if file_format is None:\n        sys.stderr.write('WARNING: The default download format has changed from PDB to PDBx/mmCif\\n')\n        return 'mmCif'\n    return file_format",
            "@staticmethod\ndef _print_default_format_warning(file_format):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Print a warning to stdout (PRIVATE).\\n\\n        Temporary warning (similar to a deprecation warning) that files\\n        are being downloaded in mmCIF.\\n        '\n    if file_format is None:\n        sys.stderr.write('WARNING: The default download format has changed from PDB to PDBx/mmCif\\n')\n        return 'mmCif'\n    return file_format",
            "@staticmethod\ndef _print_default_format_warning(file_format):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Print a warning to stdout (PRIVATE).\\n\\n        Temporary warning (similar to a deprecation warning) that files\\n        are being downloaded in mmCIF.\\n        '\n    if file_format is None:\n        sys.stderr.write('WARNING: The default download format has changed from PDB to PDBx/mmCif\\n')\n        return 'mmCif'\n    return file_format",
            "@staticmethod\ndef _print_default_format_warning(file_format):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Print a warning to stdout (PRIVATE).\\n\\n        Temporary warning (similar to a deprecation warning) that files\\n        are being downloaded in mmCIF.\\n        '\n    if file_format is None:\n        sys.stderr.write('WARNING: The default download format has changed from PDB to PDBx/mmCif\\n')\n        return 'mmCif'\n    return file_format",
            "@staticmethod\ndef _print_default_format_warning(file_format):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Print a warning to stdout (PRIVATE).\\n\\n        Temporary warning (similar to a deprecation warning) that files\\n        are being downloaded in mmCIF.\\n        '\n    if file_format is None:\n        sys.stderr.write('WARNING: The default download format has changed from PDB to PDBx/mmCif\\n')\n        return 'mmCif'\n    return file_format"
        ]
    },
    {
        "func_name": "get_status_list",
        "original": "@staticmethod\ndef get_status_list(url):\n    \"\"\"Retrieve a list of pdb codes in the weekly pdb status file from given URL.\n\n        Used by get_recent_changes. Typical contents of the list files parsed\n        by this method is now very simply - one PDB name per line.\n        \"\"\"\n    with contextlib.closing(urlopen(url)) as handle:\n        answer = []\n        for line in handle:\n            pdb = line.strip()\n            assert len(pdb) == 4\n            answer.append(pdb.decode())\n    return answer",
        "mutated": [
            "@staticmethod\ndef get_status_list(url):\n    if False:\n        i = 10\n    'Retrieve a list of pdb codes in the weekly pdb status file from given URL.\\n\\n        Used by get_recent_changes. Typical contents of the list files parsed\\n        by this method is now very simply - one PDB name per line.\\n        '\n    with contextlib.closing(urlopen(url)) as handle:\n        answer = []\n        for line in handle:\n            pdb = line.strip()\n            assert len(pdb) == 4\n            answer.append(pdb.decode())\n    return answer",
            "@staticmethod\ndef get_status_list(url):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Retrieve a list of pdb codes in the weekly pdb status file from given URL.\\n\\n        Used by get_recent_changes. Typical contents of the list files parsed\\n        by this method is now very simply - one PDB name per line.\\n        '\n    with contextlib.closing(urlopen(url)) as handle:\n        answer = []\n        for line in handle:\n            pdb = line.strip()\n            assert len(pdb) == 4\n            answer.append(pdb.decode())\n    return answer",
            "@staticmethod\ndef get_status_list(url):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Retrieve a list of pdb codes in the weekly pdb status file from given URL.\\n\\n        Used by get_recent_changes. Typical contents of the list files parsed\\n        by this method is now very simply - one PDB name per line.\\n        '\n    with contextlib.closing(urlopen(url)) as handle:\n        answer = []\n        for line in handle:\n            pdb = line.strip()\n            assert len(pdb) == 4\n            answer.append(pdb.decode())\n    return answer",
            "@staticmethod\ndef get_status_list(url):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Retrieve a list of pdb codes in the weekly pdb status file from given URL.\\n\\n        Used by get_recent_changes. Typical contents of the list files parsed\\n        by this method is now very simply - one PDB name per line.\\n        '\n    with contextlib.closing(urlopen(url)) as handle:\n        answer = []\n        for line in handle:\n            pdb = line.strip()\n            assert len(pdb) == 4\n            answer.append(pdb.decode())\n    return answer",
            "@staticmethod\ndef get_status_list(url):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Retrieve a list of pdb codes in the weekly pdb status file from given URL.\\n\\n        Used by get_recent_changes. Typical contents of the list files parsed\\n        by this method is now very simply - one PDB name per line.\\n        '\n    with contextlib.closing(urlopen(url)) as handle:\n        answer = []\n        for line in handle:\n            pdb = line.strip()\n            assert len(pdb) == 4\n            answer.append(pdb.decode())\n    return answer"
        ]
    },
    {
        "func_name": "get_recent_changes",
        "original": "def get_recent_changes(self):\n    \"\"\"Return three lists of the newest weekly files (added,mod,obsolete).\n\n        Reads the directories with changed entries from the PDB server and\n        returns a tuple of three URL's to the files of new, modified and\n        obsolete entries from the most recent list. The directory with the\n        largest numerical name is used.\n        Returns None if something goes wrong.\n\n        Contents of the data/status dir (20031013 would be used);:\n\n            drwxrwxr-x   2 1002     sysadmin     512 Oct  6 18:28 20031006\n            drwxrwxr-x   2 1002     sysadmin     512 Oct 14 02:14 20031013\n            -rw-r--r--   1 1002     sysadmin    1327 Mar 12  2001 README\n\n        \"\"\"\n    path = self.pdb_server + '/pub/pdb/data/status/latest/'\n    added = self.get_status_list(path + 'added.pdb')\n    modified = self.get_status_list(path + 'modified.pdb')\n    obsolete = self.get_status_list(path + 'obsolete.pdb')\n    return [added, modified, obsolete]",
        "mutated": [
            "def get_recent_changes(self):\n    if False:\n        i = 10\n    \"Return three lists of the newest weekly files (added,mod,obsolete).\\n\\n        Reads the directories with changed entries from the PDB server and\\n        returns a tuple of three URL's to the files of new, modified and\\n        obsolete entries from the most recent list. The directory with the\\n        largest numerical name is used.\\n        Returns None if something goes wrong.\\n\\n        Contents of the data/status dir (20031013 would be used);:\\n\\n            drwxrwxr-x   2 1002     sysadmin     512 Oct  6 18:28 20031006\\n            drwxrwxr-x   2 1002     sysadmin     512 Oct 14 02:14 20031013\\n            -rw-r--r--   1 1002     sysadmin    1327 Mar 12  2001 README\\n\\n        \"\n    path = self.pdb_server + '/pub/pdb/data/status/latest/'\n    added = self.get_status_list(path + 'added.pdb')\n    modified = self.get_status_list(path + 'modified.pdb')\n    obsolete = self.get_status_list(path + 'obsolete.pdb')\n    return [added, modified, obsolete]",
            "def get_recent_changes(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Return three lists of the newest weekly files (added,mod,obsolete).\\n\\n        Reads the directories with changed entries from the PDB server and\\n        returns a tuple of three URL's to the files of new, modified and\\n        obsolete entries from the most recent list. The directory with the\\n        largest numerical name is used.\\n        Returns None if something goes wrong.\\n\\n        Contents of the data/status dir (20031013 would be used);:\\n\\n            drwxrwxr-x   2 1002     sysadmin     512 Oct  6 18:28 20031006\\n            drwxrwxr-x   2 1002     sysadmin     512 Oct 14 02:14 20031013\\n            -rw-r--r--   1 1002     sysadmin    1327 Mar 12  2001 README\\n\\n        \"\n    path = self.pdb_server + '/pub/pdb/data/status/latest/'\n    added = self.get_status_list(path + 'added.pdb')\n    modified = self.get_status_list(path + 'modified.pdb')\n    obsolete = self.get_status_list(path + 'obsolete.pdb')\n    return [added, modified, obsolete]",
            "def get_recent_changes(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Return three lists of the newest weekly files (added,mod,obsolete).\\n\\n        Reads the directories with changed entries from the PDB server and\\n        returns a tuple of three URL's to the files of new, modified and\\n        obsolete entries from the most recent list. The directory with the\\n        largest numerical name is used.\\n        Returns None if something goes wrong.\\n\\n        Contents of the data/status dir (20031013 would be used);:\\n\\n            drwxrwxr-x   2 1002     sysadmin     512 Oct  6 18:28 20031006\\n            drwxrwxr-x   2 1002     sysadmin     512 Oct 14 02:14 20031013\\n            -rw-r--r--   1 1002     sysadmin    1327 Mar 12  2001 README\\n\\n        \"\n    path = self.pdb_server + '/pub/pdb/data/status/latest/'\n    added = self.get_status_list(path + 'added.pdb')\n    modified = self.get_status_list(path + 'modified.pdb')\n    obsolete = self.get_status_list(path + 'obsolete.pdb')\n    return [added, modified, obsolete]",
            "def get_recent_changes(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Return three lists of the newest weekly files (added,mod,obsolete).\\n\\n        Reads the directories with changed entries from the PDB server and\\n        returns a tuple of three URL's to the files of new, modified and\\n        obsolete entries from the most recent list. The directory with the\\n        largest numerical name is used.\\n        Returns None if something goes wrong.\\n\\n        Contents of the data/status dir (20031013 would be used);:\\n\\n            drwxrwxr-x   2 1002     sysadmin     512 Oct  6 18:28 20031006\\n            drwxrwxr-x   2 1002     sysadmin     512 Oct 14 02:14 20031013\\n            -rw-r--r--   1 1002     sysadmin    1327 Mar 12  2001 README\\n\\n        \"\n    path = self.pdb_server + '/pub/pdb/data/status/latest/'\n    added = self.get_status_list(path + 'added.pdb')\n    modified = self.get_status_list(path + 'modified.pdb')\n    obsolete = self.get_status_list(path + 'obsolete.pdb')\n    return [added, modified, obsolete]",
            "def get_recent_changes(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Return three lists of the newest weekly files (added,mod,obsolete).\\n\\n        Reads the directories with changed entries from the PDB server and\\n        returns a tuple of three URL's to the files of new, modified and\\n        obsolete entries from the most recent list. The directory with the\\n        largest numerical name is used.\\n        Returns None if something goes wrong.\\n\\n        Contents of the data/status dir (20031013 would be used);:\\n\\n            drwxrwxr-x   2 1002     sysadmin     512 Oct  6 18:28 20031006\\n            drwxrwxr-x   2 1002     sysadmin     512 Oct 14 02:14 20031013\\n            -rw-r--r--   1 1002     sysadmin    1327 Mar 12  2001 README\\n\\n        \"\n    path = self.pdb_server + '/pub/pdb/data/status/latest/'\n    added = self.get_status_list(path + 'added.pdb')\n    modified = self.get_status_list(path + 'modified.pdb')\n    obsolete = self.get_status_list(path + 'obsolete.pdb')\n    return [added, modified, obsolete]"
        ]
    },
    {
        "func_name": "get_all_entries",
        "original": "def get_all_entries(self):\n    \"\"\"Retrieve the big file containing all the PDB entries and some annotation.\n\n        Returns a list of PDB codes in the index file.\n        \"\"\"\n    url = self.pdb_server + '/pub/pdb/derived_data/index/entries.idx'\n    if self._verbose:\n        print('Retrieving index file. Takes about 27 MB.')\n    with contextlib.closing(urlopen(url)) as handle:\n        all_entries = [line[:4].decode() for line in handle.readlines()[2:] if len(line) > 4]\n    return all_entries",
        "mutated": [
            "def get_all_entries(self):\n    if False:\n        i = 10\n    'Retrieve the big file containing all the PDB entries and some annotation.\\n\\n        Returns a list of PDB codes in the index file.\\n        '\n    url = self.pdb_server + '/pub/pdb/derived_data/index/entries.idx'\n    if self._verbose:\n        print('Retrieving index file. Takes about 27 MB.')\n    with contextlib.closing(urlopen(url)) as handle:\n        all_entries = [line[:4].decode() for line in handle.readlines()[2:] if len(line) > 4]\n    return all_entries",
            "def get_all_entries(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Retrieve the big file containing all the PDB entries and some annotation.\\n\\n        Returns a list of PDB codes in the index file.\\n        '\n    url = self.pdb_server + '/pub/pdb/derived_data/index/entries.idx'\n    if self._verbose:\n        print('Retrieving index file. Takes about 27 MB.')\n    with contextlib.closing(urlopen(url)) as handle:\n        all_entries = [line[:4].decode() for line in handle.readlines()[2:] if len(line) > 4]\n    return all_entries",
            "def get_all_entries(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Retrieve the big file containing all the PDB entries and some annotation.\\n\\n        Returns a list of PDB codes in the index file.\\n        '\n    url = self.pdb_server + '/pub/pdb/derived_data/index/entries.idx'\n    if self._verbose:\n        print('Retrieving index file. Takes about 27 MB.')\n    with contextlib.closing(urlopen(url)) as handle:\n        all_entries = [line[:4].decode() for line in handle.readlines()[2:] if len(line) > 4]\n    return all_entries",
            "def get_all_entries(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Retrieve the big file containing all the PDB entries and some annotation.\\n\\n        Returns a list of PDB codes in the index file.\\n        '\n    url = self.pdb_server + '/pub/pdb/derived_data/index/entries.idx'\n    if self._verbose:\n        print('Retrieving index file. Takes about 27 MB.')\n    with contextlib.closing(urlopen(url)) as handle:\n        all_entries = [line[:4].decode() for line in handle.readlines()[2:] if len(line) > 4]\n    return all_entries",
            "def get_all_entries(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Retrieve the big file containing all the PDB entries and some annotation.\\n\\n        Returns a list of PDB codes in the index file.\\n        '\n    url = self.pdb_server + '/pub/pdb/derived_data/index/entries.idx'\n    if self._verbose:\n        print('Retrieving index file. Takes about 27 MB.')\n    with contextlib.closing(urlopen(url)) as handle:\n        all_entries = [line[:4].decode() for line in handle.readlines()[2:] if len(line) > 4]\n    return all_entries"
        ]
    },
    {
        "func_name": "get_all_obsolete",
        "original": "def get_all_obsolete(self):\n    \"\"\"Return a list of all obsolete entries ever in the PDB.\n\n        Returns a list of all obsolete pdb codes that have ever been\n        in the PDB.\n\n        Gets and parses the file from the PDB server in the format\n        (the first pdb_code column is the one used). The file looks\n        like this::\n\n             LIST OF OBSOLETE COORDINATE ENTRIES AND SUCCESSORS\n            OBSLTE    31-JUL-94 116L     216L\n            ...\n            OBSLTE    29-JAN-96 1HFT     2HFT\n            OBSLTE    21-SEP-06 1HFV     2J5X\n            OBSLTE    21-NOV-03 1HG6\n            OBSLTE    18-JUL-84 1HHB     2HHB 3HHB\n            OBSLTE    08-NOV-96 1HID     2HID\n            OBSLTE    01-APR-97 1HIU     2HIU\n            OBSLTE    14-JAN-04 1HKE     1UUZ\n            ...\n\n        \"\"\"\n    url = self.pdb_server + '/pub/pdb/data/status/obsolete.dat'\n    with contextlib.closing(urlopen(url)) as handle:\n        obsolete = []\n        for line in handle:\n            if not line.startswith(b'OBSLTE '):\n                continue\n            pdb = line.split()[2]\n            assert len(pdb) == 4\n            obsolete.append(pdb.decode())\n    return obsolete",
        "mutated": [
            "def get_all_obsolete(self):\n    if False:\n        i = 10\n    'Return a list of all obsolete entries ever in the PDB.\\n\\n        Returns a list of all obsolete pdb codes that have ever been\\n        in the PDB.\\n\\n        Gets and parses the file from the PDB server in the format\\n        (the first pdb_code column is the one used). The file looks\\n        like this::\\n\\n             LIST OF OBSOLETE COORDINATE ENTRIES AND SUCCESSORS\\n            OBSLTE    31-JUL-94 116L     216L\\n            ...\\n            OBSLTE    29-JAN-96 1HFT     2HFT\\n            OBSLTE    21-SEP-06 1HFV     2J5X\\n            OBSLTE    21-NOV-03 1HG6\\n            OBSLTE    18-JUL-84 1HHB     2HHB 3HHB\\n            OBSLTE    08-NOV-96 1HID     2HID\\n            OBSLTE    01-APR-97 1HIU     2HIU\\n            OBSLTE    14-JAN-04 1HKE     1UUZ\\n            ...\\n\\n        '\n    url = self.pdb_server + '/pub/pdb/data/status/obsolete.dat'\n    with contextlib.closing(urlopen(url)) as handle:\n        obsolete = []\n        for line in handle:\n            if not line.startswith(b'OBSLTE '):\n                continue\n            pdb = line.split()[2]\n            assert len(pdb) == 4\n            obsolete.append(pdb.decode())\n    return obsolete",
            "def get_all_obsolete(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return a list of all obsolete entries ever in the PDB.\\n\\n        Returns a list of all obsolete pdb codes that have ever been\\n        in the PDB.\\n\\n        Gets and parses the file from the PDB server in the format\\n        (the first pdb_code column is the one used). The file looks\\n        like this::\\n\\n             LIST OF OBSOLETE COORDINATE ENTRIES AND SUCCESSORS\\n            OBSLTE    31-JUL-94 116L     216L\\n            ...\\n            OBSLTE    29-JAN-96 1HFT     2HFT\\n            OBSLTE    21-SEP-06 1HFV     2J5X\\n            OBSLTE    21-NOV-03 1HG6\\n            OBSLTE    18-JUL-84 1HHB     2HHB 3HHB\\n            OBSLTE    08-NOV-96 1HID     2HID\\n            OBSLTE    01-APR-97 1HIU     2HIU\\n            OBSLTE    14-JAN-04 1HKE     1UUZ\\n            ...\\n\\n        '\n    url = self.pdb_server + '/pub/pdb/data/status/obsolete.dat'\n    with contextlib.closing(urlopen(url)) as handle:\n        obsolete = []\n        for line in handle:\n            if not line.startswith(b'OBSLTE '):\n                continue\n            pdb = line.split()[2]\n            assert len(pdb) == 4\n            obsolete.append(pdb.decode())\n    return obsolete",
            "def get_all_obsolete(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return a list of all obsolete entries ever in the PDB.\\n\\n        Returns a list of all obsolete pdb codes that have ever been\\n        in the PDB.\\n\\n        Gets and parses the file from the PDB server in the format\\n        (the first pdb_code column is the one used). The file looks\\n        like this::\\n\\n             LIST OF OBSOLETE COORDINATE ENTRIES AND SUCCESSORS\\n            OBSLTE    31-JUL-94 116L     216L\\n            ...\\n            OBSLTE    29-JAN-96 1HFT     2HFT\\n            OBSLTE    21-SEP-06 1HFV     2J5X\\n            OBSLTE    21-NOV-03 1HG6\\n            OBSLTE    18-JUL-84 1HHB     2HHB 3HHB\\n            OBSLTE    08-NOV-96 1HID     2HID\\n            OBSLTE    01-APR-97 1HIU     2HIU\\n            OBSLTE    14-JAN-04 1HKE     1UUZ\\n            ...\\n\\n        '\n    url = self.pdb_server + '/pub/pdb/data/status/obsolete.dat'\n    with contextlib.closing(urlopen(url)) as handle:\n        obsolete = []\n        for line in handle:\n            if not line.startswith(b'OBSLTE '):\n                continue\n            pdb = line.split()[2]\n            assert len(pdb) == 4\n            obsolete.append(pdb.decode())\n    return obsolete",
            "def get_all_obsolete(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return a list of all obsolete entries ever in the PDB.\\n\\n        Returns a list of all obsolete pdb codes that have ever been\\n        in the PDB.\\n\\n        Gets and parses the file from the PDB server in the format\\n        (the first pdb_code column is the one used). The file looks\\n        like this::\\n\\n             LIST OF OBSOLETE COORDINATE ENTRIES AND SUCCESSORS\\n            OBSLTE    31-JUL-94 116L     216L\\n            ...\\n            OBSLTE    29-JAN-96 1HFT     2HFT\\n            OBSLTE    21-SEP-06 1HFV     2J5X\\n            OBSLTE    21-NOV-03 1HG6\\n            OBSLTE    18-JUL-84 1HHB     2HHB 3HHB\\n            OBSLTE    08-NOV-96 1HID     2HID\\n            OBSLTE    01-APR-97 1HIU     2HIU\\n            OBSLTE    14-JAN-04 1HKE     1UUZ\\n            ...\\n\\n        '\n    url = self.pdb_server + '/pub/pdb/data/status/obsolete.dat'\n    with contextlib.closing(urlopen(url)) as handle:\n        obsolete = []\n        for line in handle:\n            if not line.startswith(b'OBSLTE '):\n                continue\n            pdb = line.split()[2]\n            assert len(pdb) == 4\n            obsolete.append(pdb.decode())\n    return obsolete",
            "def get_all_obsolete(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return a list of all obsolete entries ever in the PDB.\\n\\n        Returns a list of all obsolete pdb codes that have ever been\\n        in the PDB.\\n\\n        Gets and parses the file from the PDB server in the format\\n        (the first pdb_code column is the one used). The file looks\\n        like this::\\n\\n             LIST OF OBSOLETE COORDINATE ENTRIES AND SUCCESSORS\\n            OBSLTE    31-JUL-94 116L     216L\\n            ...\\n            OBSLTE    29-JAN-96 1HFT     2HFT\\n            OBSLTE    21-SEP-06 1HFV     2J5X\\n            OBSLTE    21-NOV-03 1HG6\\n            OBSLTE    18-JUL-84 1HHB     2HHB 3HHB\\n            OBSLTE    08-NOV-96 1HID     2HID\\n            OBSLTE    01-APR-97 1HIU     2HIU\\n            OBSLTE    14-JAN-04 1HKE     1UUZ\\n            ...\\n\\n        '\n    url = self.pdb_server + '/pub/pdb/data/status/obsolete.dat'\n    with contextlib.closing(urlopen(url)) as handle:\n        obsolete = []\n        for line in handle:\n            if not line.startswith(b'OBSLTE '):\n                continue\n            pdb = line.split()[2]\n            assert len(pdb) == 4\n            obsolete.append(pdb.decode())\n    return obsolete"
        ]
    },
    {
        "func_name": "retrieve_pdb_file",
        "original": "def retrieve_pdb_file(self, pdb_code, obsolete=False, pdir=None, file_format=None, overwrite=False):\n    \"\"\"Fetch PDB structure file from PDB server, and store it locally.\n\n        The PDB structure's file name is returned as a single string.\n        If obsolete ``==`` True, the file will be saved in a special file tree.\n\n        NOTE. The default download format has changed from PDB to PDBx/mmCif\n\n        :param pdb_code: 4-symbols structure Id from PDB (e.g. 3J92).\n        :type pdb_code: string\n\n        :param file_format:\n            File format. Available options:\n\n            * \"mmCif\" (default, PDBx/mmCif file),\n            * \"pdb\" (format PDB),\n            * \"xml\" (PDBML/XML format),\n            * \"mmtf\" (highly compressed),\n            * \"bundle\" (PDB formatted archive for large structure)\n\n        :type file_format: string\n\n        :param overwrite: if set to True, existing structure files will be overwritten. Default: False\n        :type overwrite: bool\n\n        :param obsolete:\n            Has a meaning only for obsolete structures. If True, download the obsolete structure\n            to 'obsolete' folder, otherwise download won't be performed.\n            This option doesn't work for mmtf format as obsoleted structures aren't stored in mmtf.\n            Also doesn't have meaning when parameter pdir is specified.\n            Note: make sure that you are about to download the really obsolete structure.\n            Trying to download non-obsolete structure into obsolete folder will not work\n            and you face the \"structure doesn't exists\" error.\n            Default: False\n\n        :type obsolete: bool\n\n        :param pdir: put the file in this directory (default: create a PDB-style directory tree)\n        :type pdir: string\n\n        :return: filename\n        :rtype: string\n        \"\"\"\n    file_format = self._print_default_format_warning(file_format)\n    pdb_code = pdb_code.lower()\n    archive = {'pdb': f'pdb{pdb_code}.ent.gz', 'mmCif': f'{pdb_code}.cif.gz', 'xml': f'{pdb_code}.xml.gz', 'mmtf': f'{pdb_code}', 'bundle': f'{pdb_code}-pdb-bundle.tar.gz'}\n    archive_fn = archive[file_format]\n    if file_format not in archive.keys():\n        raise Exception(f\"Specified file_format {file_format} doesn't exists or is not supported. Maybe a typo. Please, use one of the following: mmCif, pdb, xml, mmtf, bundle\")\n    if file_format in ('pdb', 'mmCif', 'xml'):\n        pdb_dir = 'divided' if not obsolete else 'obsolete'\n        file_type = 'pdb' if file_format == 'pdb' else 'mmCIF' if file_format == 'mmCif' else 'XML'\n        url = self.pdb_server + f'/pub/pdb/data/structures/{pdb_dir}/{file_type}/{pdb_code[1:3]}/{archive_fn}'\n    elif file_format == 'bundle':\n        url = self.pdb_server + f'/pub/pdb/compatible/pdb_bundle/{pdb_code[1:3]}/{pdb_code}/{archive_fn}'\n    else:\n        url = f'http://mmtf.rcsb.org/v1.0/full/{pdb_code}'\n    if pdir is None:\n        path = self.local_pdb if not obsolete else self.obsolete_pdb\n        if not self.flat_tree:\n            path = os.path.join(path, pdb_code[1:3])\n    else:\n        path = pdir\n    if not os.access(path, os.F_OK):\n        os.makedirs(path)\n    filename = os.path.join(path, archive_fn)\n    final = {'pdb': f'pdb{pdb_code}.ent', 'mmCif': f'{pdb_code}.cif', 'xml': f'{pdb_code}.xml', 'mmtf': f'{pdb_code}.mmtf', 'bundle': f'{pdb_code}-pdb-bundle.tar'}\n    final_file = os.path.join(path, final[file_format])\n    if not overwrite:\n        if os.path.exists(final_file):\n            if self._verbose:\n                print(f\"Structure exists: '{final_file}' \")\n            return final_file\n    if self._verbose:\n        print(f\"Downloading PDB structure '{pdb_code}'...\")\n    try:\n        urlcleanup()\n        urlretrieve(url, filename)\n    except OSError:\n        print(\"Desired structure doesn't exist\")\n    else:\n        with gzip.open(filename, 'rb') as gz:\n            with open(final_file, 'wb') as out:\n                out.writelines(gz)\n        os.remove(filename)\n    return final_file",
        "mutated": [
            "def retrieve_pdb_file(self, pdb_code, obsolete=False, pdir=None, file_format=None, overwrite=False):\n    if False:\n        i = 10\n    'Fetch PDB structure file from PDB server, and store it locally.\\n\\n        The PDB structure\\'s file name is returned as a single string.\\n        If obsolete ``==`` True, the file will be saved in a special file tree.\\n\\n        NOTE. The default download format has changed from PDB to PDBx/mmCif\\n\\n        :param pdb_code: 4-symbols structure Id from PDB (e.g. 3J92).\\n        :type pdb_code: string\\n\\n        :param file_format:\\n            File format. Available options:\\n\\n            * \"mmCif\" (default, PDBx/mmCif file),\\n            * \"pdb\" (format PDB),\\n            * \"xml\" (PDBML/XML format),\\n            * \"mmtf\" (highly compressed),\\n            * \"bundle\" (PDB formatted archive for large structure)\\n\\n        :type file_format: string\\n\\n        :param overwrite: if set to True, existing structure files will be overwritten. Default: False\\n        :type overwrite: bool\\n\\n        :param obsolete:\\n            Has a meaning only for obsolete structures. If True, download the obsolete structure\\n            to \\'obsolete\\' folder, otherwise download won\\'t be performed.\\n            This option doesn\\'t work for mmtf format as obsoleted structures aren\\'t stored in mmtf.\\n            Also doesn\\'t have meaning when parameter pdir is specified.\\n            Note: make sure that you are about to download the really obsolete structure.\\n            Trying to download non-obsolete structure into obsolete folder will not work\\n            and you face the \"structure doesn\\'t exists\" error.\\n            Default: False\\n\\n        :type obsolete: bool\\n\\n        :param pdir: put the file in this directory (default: create a PDB-style directory tree)\\n        :type pdir: string\\n\\n        :return: filename\\n        :rtype: string\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    pdb_code = pdb_code.lower()\n    archive = {'pdb': f'pdb{pdb_code}.ent.gz', 'mmCif': f'{pdb_code}.cif.gz', 'xml': f'{pdb_code}.xml.gz', 'mmtf': f'{pdb_code}', 'bundle': f'{pdb_code}-pdb-bundle.tar.gz'}\n    archive_fn = archive[file_format]\n    if file_format not in archive.keys():\n        raise Exception(f\"Specified file_format {file_format} doesn't exists or is not supported. Maybe a typo. Please, use one of the following: mmCif, pdb, xml, mmtf, bundle\")\n    if file_format in ('pdb', 'mmCif', 'xml'):\n        pdb_dir = 'divided' if not obsolete else 'obsolete'\n        file_type = 'pdb' if file_format == 'pdb' else 'mmCIF' if file_format == 'mmCif' else 'XML'\n        url = self.pdb_server + f'/pub/pdb/data/structures/{pdb_dir}/{file_type}/{pdb_code[1:3]}/{archive_fn}'\n    elif file_format == 'bundle':\n        url = self.pdb_server + f'/pub/pdb/compatible/pdb_bundle/{pdb_code[1:3]}/{pdb_code}/{archive_fn}'\n    else:\n        url = f'http://mmtf.rcsb.org/v1.0/full/{pdb_code}'\n    if pdir is None:\n        path = self.local_pdb if not obsolete else self.obsolete_pdb\n        if not self.flat_tree:\n            path = os.path.join(path, pdb_code[1:3])\n    else:\n        path = pdir\n    if not os.access(path, os.F_OK):\n        os.makedirs(path)\n    filename = os.path.join(path, archive_fn)\n    final = {'pdb': f'pdb{pdb_code}.ent', 'mmCif': f'{pdb_code}.cif', 'xml': f'{pdb_code}.xml', 'mmtf': f'{pdb_code}.mmtf', 'bundle': f'{pdb_code}-pdb-bundle.tar'}\n    final_file = os.path.join(path, final[file_format])\n    if not overwrite:\n        if os.path.exists(final_file):\n            if self._verbose:\n                print(f\"Structure exists: '{final_file}' \")\n            return final_file\n    if self._verbose:\n        print(f\"Downloading PDB structure '{pdb_code}'...\")\n    try:\n        urlcleanup()\n        urlretrieve(url, filename)\n    except OSError:\n        print(\"Desired structure doesn't exist\")\n    else:\n        with gzip.open(filename, 'rb') as gz:\n            with open(final_file, 'wb') as out:\n                out.writelines(gz)\n        os.remove(filename)\n    return final_file",
            "def retrieve_pdb_file(self, pdb_code, obsolete=False, pdir=None, file_format=None, overwrite=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Fetch PDB structure file from PDB server, and store it locally.\\n\\n        The PDB structure\\'s file name is returned as a single string.\\n        If obsolete ``==`` True, the file will be saved in a special file tree.\\n\\n        NOTE. The default download format has changed from PDB to PDBx/mmCif\\n\\n        :param pdb_code: 4-symbols structure Id from PDB (e.g. 3J92).\\n        :type pdb_code: string\\n\\n        :param file_format:\\n            File format. Available options:\\n\\n            * \"mmCif\" (default, PDBx/mmCif file),\\n            * \"pdb\" (format PDB),\\n            * \"xml\" (PDBML/XML format),\\n            * \"mmtf\" (highly compressed),\\n            * \"bundle\" (PDB formatted archive for large structure)\\n\\n        :type file_format: string\\n\\n        :param overwrite: if set to True, existing structure files will be overwritten. Default: False\\n        :type overwrite: bool\\n\\n        :param obsolete:\\n            Has a meaning only for obsolete structures. If True, download the obsolete structure\\n            to \\'obsolete\\' folder, otherwise download won\\'t be performed.\\n            This option doesn\\'t work for mmtf format as obsoleted structures aren\\'t stored in mmtf.\\n            Also doesn\\'t have meaning when parameter pdir is specified.\\n            Note: make sure that you are about to download the really obsolete structure.\\n            Trying to download non-obsolete structure into obsolete folder will not work\\n            and you face the \"structure doesn\\'t exists\" error.\\n            Default: False\\n\\n        :type obsolete: bool\\n\\n        :param pdir: put the file in this directory (default: create a PDB-style directory tree)\\n        :type pdir: string\\n\\n        :return: filename\\n        :rtype: string\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    pdb_code = pdb_code.lower()\n    archive = {'pdb': f'pdb{pdb_code}.ent.gz', 'mmCif': f'{pdb_code}.cif.gz', 'xml': f'{pdb_code}.xml.gz', 'mmtf': f'{pdb_code}', 'bundle': f'{pdb_code}-pdb-bundle.tar.gz'}\n    archive_fn = archive[file_format]\n    if file_format not in archive.keys():\n        raise Exception(f\"Specified file_format {file_format} doesn't exists or is not supported. Maybe a typo. Please, use one of the following: mmCif, pdb, xml, mmtf, bundle\")\n    if file_format in ('pdb', 'mmCif', 'xml'):\n        pdb_dir = 'divided' if not obsolete else 'obsolete'\n        file_type = 'pdb' if file_format == 'pdb' else 'mmCIF' if file_format == 'mmCif' else 'XML'\n        url = self.pdb_server + f'/pub/pdb/data/structures/{pdb_dir}/{file_type}/{pdb_code[1:3]}/{archive_fn}'\n    elif file_format == 'bundle':\n        url = self.pdb_server + f'/pub/pdb/compatible/pdb_bundle/{pdb_code[1:3]}/{pdb_code}/{archive_fn}'\n    else:\n        url = f'http://mmtf.rcsb.org/v1.0/full/{pdb_code}'\n    if pdir is None:\n        path = self.local_pdb if not obsolete else self.obsolete_pdb\n        if not self.flat_tree:\n            path = os.path.join(path, pdb_code[1:3])\n    else:\n        path = pdir\n    if not os.access(path, os.F_OK):\n        os.makedirs(path)\n    filename = os.path.join(path, archive_fn)\n    final = {'pdb': f'pdb{pdb_code}.ent', 'mmCif': f'{pdb_code}.cif', 'xml': f'{pdb_code}.xml', 'mmtf': f'{pdb_code}.mmtf', 'bundle': f'{pdb_code}-pdb-bundle.tar'}\n    final_file = os.path.join(path, final[file_format])\n    if not overwrite:\n        if os.path.exists(final_file):\n            if self._verbose:\n                print(f\"Structure exists: '{final_file}' \")\n            return final_file\n    if self._verbose:\n        print(f\"Downloading PDB structure '{pdb_code}'...\")\n    try:\n        urlcleanup()\n        urlretrieve(url, filename)\n    except OSError:\n        print(\"Desired structure doesn't exist\")\n    else:\n        with gzip.open(filename, 'rb') as gz:\n            with open(final_file, 'wb') as out:\n                out.writelines(gz)\n        os.remove(filename)\n    return final_file",
            "def retrieve_pdb_file(self, pdb_code, obsolete=False, pdir=None, file_format=None, overwrite=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Fetch PDB structure file from PDB server, and store it locally.\\n\\n        The PDB structure\\'s file name is returned as a single string.\\n        If obsolete ``==`` True, the file will be saved in a special file tree.\\n\\n        NOTE. The default download format has changed from PDB to PDBx/mmCif\\n\\n        :param pdb_code: 4-symbols structure Id from PDB (e.g. 3J92).\\n        :type pdb_code: string\\n\\n        :param file_format:\\n            File format. Available options:\\n\\n            * \"mmCif\" (default, PDBx/mmCif file),\\n            * \"pdb\" (format PDB),\\n            * \"xml\" (PDBML/XML format),\\n            * \"mmtf\" (highly compressed),\\n            * \"bundle\" (PDB formatted archive for large structure)\\n\\n        :type file_format: string\\n\\n        :param overwrite: if set to True, existing structure files will be overwritten. Default: False\\n        :type overwrite: bool\\n\\n        :param obsolete:\\n            Has a meaning only for obsolete structures. If True, download the obsolete structure\\n            to \\'obsolete\\' folder, otherwise download won\\'t be performed.\\n            This option doesn\\'t work for mmtf format as obsoleted structures aren\\'t stored in mmtf.\\n            Also doesn\\'t have meaning when parameter pdir is specified.\\n            Note: make sure that you are about to download the really obsolete structure.\\n            Trying to download non-obsolete structure into obsolete folder will not work\\n            and you face the \"structure doesn\\'t exists\" error.\\n            Default: False\\n\\n        :type obsolete: bool\\n\\n        :param pdir: put the file in this directory (default: create a PDB-style directory tree)\\n        :type pdir: string\\n\\n        :return: filename\\n        :rtype: string\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    pdb_code = pdb_code.lower()\n    archive = {'pdb': f'pdb{pdb_code}.ent.gz', 'mmCif': f'{pdb_code}.cif.gz', 'xml': f'{pdb_code}.xml.gz', 'mmtf': f'{pdb_code}', 'bundle': f'{pdb_code}-pdb-bundle.tar.gz'}\n    archive_fn = archive[file_format]\n    if file_format not in archive.keys():\n        raise Exception(f\"Specified file_format {file_format} doesn't exists or is not supported. Maybe a typo. Please, use one of the following: mmCif, pdb, xml, mmtf, bundle\")\n    if file_format in ('pdb', 'mmCif', 'xml'):\n        pdb_dir = 'divided' if not obsolete else 'obsolete'\n        file_type = 'pdb' if file_format == 'pdb' else 'mmCIF' if file_format == 'mmCif' else 'XML'\n        url = self.pdb_server + f'/pub/pdb/data/structures/{pdb_dir}/{file_type}/{pdb_code[1:3]}/{archive_fn}'\n    elif file_format == 'bundle':\n        url = self.pdb_server + f'/pub/pdb/compatible/pdb_bundle/{pdb_code[1:3]}/{pdb_code}/{archive_fn}'\n    else:\n        url = f'http://mmtf.rcsb.org/v1.0/full/{pdb_code}'\n    if pdir is None:\n        path = self.local_pdb if not obsolete else self.obsolete_pdb\n        if not self.flat_tree:\n            path = os.path.join(path, pdb_code[1:3])\n    else:\n        path = pdir\n    if not os.access(path, os.F_OK):\n        os.makedirs(path)\n    filename = os.path.join(path, archive_fn)\n    final = {'pdb': f'pdb{pdb_code}.ent', 'mmCif': f'{pdb_code}.cif', 'xml': f'{pdb_code}.xml', 'mmtf': f'{pdb_code}.mmtf', 'bundle': f'{pdb_code}-pdb-bundle.tar'}\n    final_file = os.path.join(path, final[file_format])\n    if not overwrite:\n        if os.path.exists(final_file):\n            if self._verbose:\n                print(f\"Structure exists: '{final_file}' \")\n            return final_file\n    if self._verbose:\n        print(f\"Downloading PDB structure '{pdb_code}'...\")\n    try:\n        urlcleanup()\n        urlretrieve(url, filename)\n    except OSError:\n        print(\"Desired structure doesn't exist\")\n    else:\n        with gzip.open(filename, 'rb') as gz:\n            with open(final_file, 'wb') as out:\n                out.writelines(gz)\n        os.remove(filename)\n    return final_file",
            "def retrieve_pdb_file(self, pdb_code, obsolete=False, pdir=None, file_format=None, overwrite=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Fetch PDB structure file from PDB server, and store it locally.\\n\\n        The PDB structure\\'s file name is returned as a single string.\\n        If obsolete ``==`` True, the file will be saved in a special file tree.\\n\\n        NOTE. The default download format has changed from PDB to PDBx/mmCif\\n\\n        :param pdb_code: 4-symbols structure Id from PDB (e.g. 3J92).\\n        :type pdb_code: string\\n\\n        :param file_format:\\n            File format. Available options:\\n\\n            * \"mmCif\" (default, PDBx/mmCif file),\\n            * \"pdb\" (format PDB),\\n            * \"xml\" (PDBML/XML format),\\n            * \"mmtf\" (highly compressed),\\n            * \"bundle\" (PDB formatted archive for large structure)\\n\\n        :type file_format: string\\n\\n        :param overwrite: if set to True, existing structure files will be overwritten. Default: False\\n        :type overwrite: bool\\n\\n        :param obsolete:\\n            Has a meaning only for obsolete structures. If True, download the obsolete structure\\n            to \\'obsolete\\' folder, otherwise download won\\'t be performed.\\n            This option doesn\\'t work for mmtf format as obsoleted structures aren\\'t stored in mmtf.\\n            Also doesn\\'t have meaning when parameter pdir is specified.\\n            Note: make sure that you are about to download the really obsolete structure.\\n            Trying to download non-obsolete structure into obsolete folder will not work\\n            and you face the \"structure doesn\\'t exists\" error.\\n            Default: False\\n\\n        :type obsolete: bool\\n\\n        :param pdir: put the file in this directory (default: create a PDB-style directory tree)\\n        :type pdir: string\\n\\n        :return: filename\\n        :rtype: string\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    pdb_code = pdb_code.lower()\n    archive = {'pdb': f'pdb{pdb_code}.ent.gz', 'mmCif': f'{pdb_code}.cif.gz', 'xml': f'{pdb_code}.xml.gz', 'mmtf': f'{pdb_code}', 'bundle': f'{pdb_code}-pdb-bundle.tar.gz'}\n    archive_fn = archive[file_format]\n    if file_format not in archive.keys():\n        raise Exception(f\"Specified file_format {file_format} doesn't exists or is not supported. Maybe a typo. Please, use one of the following: mmCif, pdb, xml, mmtf, bundle\")\n    if file_format in ('pdb', 'mmCif', 'xml'):\n        pdb_dir = 'divided' if not obsolete else 'obsolete'\n        file_type = 'pdb' if file_format == 'pdb' else 'mmCIF' if file_format == 'mmCif' else 'XML'\n        url = self.pdb_server + f'/pub/pdb/data/structures/{pdb_dir}/{file_type}/{pdb_code[1:3]}/{archive_fn}'\n    elif file_format == 'bundle':\n        url = self.pdb_server + f'/pub/pdb/compatible/pdb_bundle/{pdb_code[1:3]}/{pdb_code}/{archive_fn}'\n    else:\n        url = f'http://mmtf.rcsb.org/v1.0/full/{pdb_code}'\n    if pdir is None:\n        path = self.local_pdb if not obsolete else self.obsolete_pdb\n        if not self.flat_tree:\n            path = os.path.join(path, pdb_code[1:3])\n    else:\n        path = pdir\n    if not os.access(path, os.F_OK):\n        os.makedirs(path)\n    filename = os.path.join(path, archive_fn)\n    final = {'pdb': f'pdb{pdb_code}.ent', 'mmCif': f'{pdb_code}.cif', 'xml': f'{pdb_code}.xml', 'mmtf': f'{pdb_code}.mmtf', 'bundle': f'{pdb_code}-pdb-bundle.tar'}\n    final_file = os.path.join(path, final[file_format])\n    if not overwrite:\n        if os.path.exists(final_file):\n            if self._verbose:\n                print(f\"Structure exists: '{final_file}' \")\n            return final_file\n    if self._verbose:\n        print(f\"Downloading PDB structure '{pdb_code}'...\")\n    try:\n        urlcleanup()\n        urlretrieve(url, filename)\n    except OSError:\n        print(\"Desired structure doesn't exist\")\n    else:\n        with gzip.open(filename, 'rb') as gz:\n            with open(final_file, 'wb') as out:\n                out.writelines(gz)\n        os.remove(filename)\n    return final_file",
            "def retrieve_pdb_file(self, pdb_code, obsolete=False, pdir=None, file_format=None, overwrite=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Fetch PDB structure file from PDB server, and store it locally.\\n\\n        The PDB structure\\'s file name is returned as a single string.\\n        If obsolete ``==`` True, the file will be saved in a special file tree.\\n\\n        NOTE. The default download format has changed from PDB to PDBx/mmCif\\n\\n        :param pdb_code: 4-symbols structure Id from PDB (e.g. 3J92).\\n        :type pdb_code: string\\n\\n        :param file_format:\\n            File format. Available options:\\n\\n            * \"mmCif\" (default, PDBx/mmCif file),\\n            * \"pdb\" (format PDB),\\n            * \"xml\" (PDBML/XML format),\\n            * \"mmtf\" (highly compressed),\\n            * \"bundle\" (PDB formatted archive for large structure)\\n\\n        :type file_format: string\\n\\n        :param overwrite: if set to True, existing structure files will be overwritten. Default: False\\n        :type overwrite: bool\\n\\n        :param obsolete:\\n            Has a meaning only for obsolete structures. If True, download the obsolete structure\\n            to \\'obsolete\\' folder, otherwise download won\\'t be performed.\\n            This option doesn\\'t work for mmtf format as obsoleted structures aren\\'t stored in mmtf.\\n            Also doesn\\'t have meaning when parameter pdir is specified.\\n            Note: make sure that you are about to download the really obsolete structure.\\n            Trying to download non-obsolete structure into obsolete folder will not work\\n            and you face the \"structure doesn\\'t exists\" error.\\n            Default: False\\n\\n        :type obsolete: bool\\n\\n        :param pdir: put the file in this directory (default: create a PDB-style directory tree)\\n        :type pdir: string\\n\\n        :return: filename\\n        :rtype: string\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    pdb_code = pdb_code.lower()\n    archive = {'pdb': f'pdb{pdb_code}.ent.gz', 'mmCif': f'{pdb_code}.cif.gz', 'xml': f'{pdb_code}.xml.gz', 'mmtf': f'{pdb_code}', 'bundle': f'{pdb_code}-pdb-bundle.tar.gz'}\n    archive_fn = archive[file_format]\n    if file_format not in archive.keys():\n        raise Exception(f\"Specified file_format {file_format} doesn't exists or is not supported. Maybe a typo. Please, use one of the following: mmCif, pdb, xml, mmtf, bundle\")\n    if file_format in ('pdb', 'mmCif', 'xml'):\n        pdb_dir = 'divided' if not obsolete else 'obsolete'\n        file_type = 'pdb' if file_format == 'pdb' else 'mmCIF' if file_format == 'mmCif' else 'XML'\n        url = self.pdb_server + f'/pub/pdb/data/structures/{pdb_dir}/{file_type}/{pdb_code[1:3]}/{archive_fn}'\n    elif file_format == 'bundle':\n        url = self.pdb_server + f'/pub/pdb/compatible/pdb_bundle/{pdb_code[1:3]}/{pdb_code}/{archive_fn}'\n    else:\n        url = f'http://mmtf.rcsb.org/v1.0/full/{pdb_code}'\n    if pdir is None:\n        path = self.local_pdb if not obsolete else self.obsolete_pdb\n        if not self.flat_tree:\n            path = os.path.join(path, pdb_code[1:3])\n    else:\n        path = pdir\n    if not os.access(path, os.F_OK):\n        os.makedirs(path)\n    filename = os.path.join(path, archive_fn)\n    final = {'pdb': f'pdb{pdb_code}.ent', 'mmCif': f'{pdb_code}.cif', 'xml': f'{pdb_code}.xml', 'mmtf': f'{pdb_code}.mmtf', 'bundle': f'{pdb_code}-pdb-bundle.tar'}\n    final_file = os.path.join(path, final[file_format])\n    if not overwrite:\n        if os.path.exists(final_file):\n            if self._verbose:\n                print(f\"Structure exists: '{final_file}' \")\n            return final_file\n    if self._verbose:\n        print(f\"Downloading PDB structure '{pdb_code}'...\")\n    try:\n        urlcleanup()\n        urlretrieve(url, filename)\n    except OSError:\n        print(\"Desired structure doesn't exist\")\n    else:\n        with gzip.open(filename, 'rb') as gz:\n            with open(final_file, 'wb') as out:\n                out.writelines(gz)\n        os.remove(filename)\n    return final_file"
        ]
    },
    {
        "func_name": "update_pdb",
        "original": "def update_pdb(self, file_format=None, with_assemblies=False):\n    \"\"\"Update your local copy of the PDB files.\n\n        I guess this is the 'most wanted' function from this module.\n        It gets the weekly lists of new and modified pdb entries and\n        automatically downloads the according PDB files.\n        You can call this module as a weekly cron job.\n        \"\"\"\n    assert os.path.isdir(self.local_pdb)\n    assert os.path.isdir(self.obsolete_pdb)\n    file_format = self._print_default_format_warning(file_format)\n    (new, modified, obsolete) = self.get_recent_changes()\n    for pdb_code in new + modified:\n        try:\n            self.retrieve_pdb_file(pdb_code, file_format=file_format)\n            if with_assemblies:\n                assemblies = self.get_all_assemblies(file_format)\n                for (a_pdb_code, assembly_num) in assemblies:\n                    if a_pdb_code == pdb_code:\n                        pl.retrieve_assembly_file(pdb_code, assembly_num, file_format=file_format, overwrite=True)\n        except Exception as err:\n            print(f'error {pdb_code}: {err}\\n')\n    for pdb_code in obsolete:\n        if self.flat_tree:\n            old_file = os.path.join(self.local_pdb, f'pdb{pdb_code}.{file_format}')\n            new_dir = self.obsolete_pdb\n        else:\n            old_file = os.path.join(self.local_pdb, pdb_code[1:3], f'pdb{pdb_code}.{file_format}')\n            new_dir = os.path.join(self.obsolete_pdb, pdb_code[1:3])\n        new_file = os.path.join(new_dir, f'pdb{pdb_code}.{file_format}')\n        if os.path.isfile(old_file):\n            if not os.path.isdir(new_dir):\n                os.mkdir(new_dir)\n            try:\n                shutil.move(old_file, new_file)\n            except Exception:\n                print(f'Could not move {old_file} to obsolete folder')\n        elif os.path.isfile(new_file):\n            if self._verbose:\n                print(f'Obsolete file {old_file} already moved')\n        elif self._verbose:\n            print(f'Obsolete file {old_file} is missing')",
        "mutated": [
            "def update_pdb(self, file_format=None, with_assemblies=False):\n    if False:\n        i = 10\n    \"Update your local copy of the PDB files.\\n\\n        I guess this is the 'most wanted' function from this module.\\n        It gets the weekly lists of new and modified pdb entries and\\n        automatically downloads the according PDB files.\\n        You can call this module as a weekly cron job.\\n        \"\n    assert os.path.isdir(self.local_pdb)\n    assert os.path.isdir(self.obsolete_pdb)\n    file_format = self._print_default_format_warning(file_format)\n    (new, modified, obsolete) = self.get_recent_changes()\n    for pdb_code in new + modified:\n        try:\n            self.retrieve_pdb_file(pdb_code, file_format=file_format)\n            if with_assemblies:\n                assemblies = self.get_all_assemblies(file_format)\n                for (a_pdb_code, assembly_num) in assemblies:\n                    if a_pdb_code == pdb_code:\n                        pl.retrieve_assembly_file(pdb_code, assembly_num, file_format=file_format, overwrite=True)\n        except Exception as err:\n            print(f'error {pdb_code}: {err}\\n')\n    for pdb_code in obsolete:\n        if self.flat_tree:\n            old_file = os.path.join(self.local_pdb, f'pdb{pdb_code}.{file_format}')\n            new_dir = self.obsolete_pdb\n        else:\n            old_file = os.path.join(self.local_pdb, pdb_code[1:3], f'pdb{pdb_code}.{file_format}')\n            new_dir = os.path.join(self.obsolete_pdb, pdb_code[1:3])\n        new_file = os.path.join(new_dir, f'pdb{pdb_code}.{file_format}')\n        if os.path.isfile(old_file):\n            if not os.path.isdir(new_dir):\n                os.mkdir(new_dir)\n            try:\n                shutil.move(old_file, new_file)\n            except Exception:\n                print(f'Could not move {old_file} to obsolete folder')\n        elif os.path.isfile(new_file):\n            if self._verbose:\n                print(f'Obsolete file {old_file} already moved')\n        elif self._verbose:\n            print(f'Obsolete file {old_file} is missing')",
            "def update_pdb(self, file_format=None, with_assemblies=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Update your local copy of the PDB files.\\n\\n        I guess this is the 'most wanted' function from this module.\\n        It gets the weekly lists of new and modified pdb entries and\\n        automatically downloads the according PDB files.\\n        You can call this module as a weekly cron job.\\n        \"\n    assert os.path.isdir(self.local_pdb)\n    assert os.path.isdir(self.obsolete_pdb)\n    file_format = self._print_default_format_warning(file_format)\n    (new, modified, obsolete) = self.get_recent_changes()\n    for pdb_code in new + modified:\n        try:\n            self.retrieve_pdb_file(pdb_code, file_format=file_format)\n            if with_assemblies:\n                assemblies = self.get_all_assemblies(file_format)\n                for (a_pdb_code, assembly_num) in assemblies:\n                    if a_pdb_code == pdb_code:\n                        pl.retrieve_assembly_file(pdb_code, assembly_num, file_format=file_format, overwrite=True)\n        except Exception as err:\n            print(f'error {pdb_code}: {err}\\n')\n    for pdb_code in obsolete:\n        if self.flat_tree:\n            old_file = os.path.join(self.local_pdb, f'pdb{pdb_code}.{file_format}')\n            new_dir = self.obsolete_pdb\n        else:\n            old_file = os.path.join(self.local_pdb, pdb_code[1:3], f'pdb{pdb_code}.{file_format}')\n            new_dir = os.path.join(self.obsolete_pdb, pdb_code[1:3])\n        new_file = os.path.join(new_dir, f'pdb{pdb_code}.{file_format}')\n        if os.path.isfile(old_file):\n            if not os.path.isdir(new_dir):\n                os.mkdir(new_dir)\n            try:\n                shutil.move(old_file, new_file)\n            except Exception:\n                print(f'Could not move {old_file} to obsolete folder')\n        elif os.path.isfile(new_file):\n            if self._verbose:\n                print(f'Obsolete file {old_file} already moved')\n        elif self._verbose:\n            print(f'Obsolete file {old_file} is missing')",
            "def update_pdb(self, file_format=None, with_assemblies=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Update your local copy of the PDB files.\\n\\n        I guess this is the 'most wanted' function from this module.\\n        It gets the weekly lists of new and modified pdb entries and\\n        automatically downloads the according PDB files.\\n        You can call this module as a weekly cron job.\\n        \"\n    assert os.path.isdir(self.local_pdb)\n    assert os.path.isdir(self.obsolete_pdb)\n    file_format = self._print_default_format_warning(file_format)\n    (new, modified, obsolete) = self.get_recent_changes()\n    for pdb_code in new + modified:\n        try:\n            self.retrieve_pdb_file(pdb_code, file_format=file_format)\n            if with_assemblies:\n                assemblies = self.get_all_assemblies(file_format)\n                for (a_pdb_code, assembly_num) in assemblies:\n                    if a_pdb_code == pdb_code:\n                        pl.retrieve_assembly_file(pdb_code, assembly_num, file_format=file_format, overwrite=True)\n        except Exception as err:\n            print(f'error {pdb_code}: {err}\\n')\n    for pdb_code in obsolete:\n        if self.flat_tree:\n            old_file = os.path.join(self.local_pdb, f'pdb{pdb_code}.{file_format}')\n            new_dir = self.obsolete_pdb\n        else:\n            old_file = os.path.join(self.local_pdb, pdb_code[1:3], f'pdb{pdb_code}.{file_format}')\n            new_dir = os.path.join(self.obsolete_pdb, pdb_code[1:3])\n        new_file = os.path.join(new_dir, f'pdb{pdb_code}.{file_format}')\n        if os.path.isfile(old_file):\n            if not os.path.isdir(new_dir):\n                os.mkdir(new_dir)\n            try:\n                shutil.move(old_file, new_file)\n            except Exception:\n                print(f'Could not move {old_file} to obsolete folder')\n        elif os.path.isfile(new_file):\n            if self._verbose:\n                print(f'Obsolete file {old_file} already moved')\n        elif self._verbose:\n            print(f'Obsolete file {old_file} is missing')",
            "def update_pdb(self, file_format=None, with_assemblies=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Update your local copy of the PDB files.\\n\\n        I guess this is the 'most wanted' function from this module.\\n        It gets the weekly lists of new and modified pdb entries and\\n        automatically downloads the according PDB files.\\n        You can call this module as a weekly cron job.\\n        \"\n    assert os.path.isdir(self.local_pdb)\n    assert os.path.isdir(self.obsolete_pdb)\n    file_format = self._print_default_format_warning(file_format)\n    (new, modified, obsolete) = self.get_recent_changes()\n    for pdb_code in new + modified:\n        try:\n            self.retrieve_pdb_file(pdb_code, file_format=file_format)\n            if with_assemblies:\n                assemblies = self.get_all_assemblies(file_format)\n                for (a_pdb_code, assembly_num) in assemblies:\n                    if a_pdb_code == pdb_code:\n                        pl.retrieve_assembly_file(pdb_code, assembly_num, file_format=file_format, overwrite=True)\n        except Exception as err:\n            print(f'error {pdb_code}: {err}\\n')\n    for pdb_code in obsolete:\n        if self.flat_tree:\n            old_file = os.path.join(self.local_pdb, f'pdb{pdb_code}.{file_format}')\n            new_dir = self.obsolete_pdb\n        else:\n            old_file = os.path.join(self.local_pdb, pdb_code[1:3], f'pdb{pdb_code}.{file_format}')\n            new_dir = os.path.join(self.obsolete_pdb, pdb_code[1:3])\n        new_file = os.path.join(new_dir, f'pdb{pdb_code}.{file_format}')\n        if os.path.isfile(old_file):\n            if not os.path.isdir(new_dir):\n                os.mkdir(new_dir)\n            try:\n                shutil.move(old_file, new_file)\n            except Exception:\n                print(f'Could not move {old_file} to obsolete folder')\n        elif os.path.isfile(new_file):\n            if self._verbose:\n                print(f'Obsolete file {old_file} already moved')\n        elif self._verbose:\n            print(f'Obsolete file {old_file} is missing')",
            "def update_pdb(self, file_format=None, with_assemblies=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Update your local copy of the PDB files.\\n\\n        I guess this is the 'most wanted' function from this module.\\n        It gets the weekly lists of new and modified pdb entries and\\n        automatically downloads the according PDB files.\\n        You can call this module as a weekly cron job.\\n        \"\n    assert os.path.isdir(self.local_pdb)\n    assert os.path.isdir(self.obsolete_pdb)\n    file_format = self._print_default_format_warning(file_format)\n    (new, modified, obsolete) = self.get_recent_changes()\n    for pdb_code in new + modified:\n        try:\n            self.retrieve_pdb_file(pdb_code, file_format=file_format)\n            if with_assemblies:\n                assemblies = self.get_all_assemblies(file_format)\n                for (a_pdb_code, assembly_num) in assemblies:\n                    if a_pdb_code == pdb_code:\n                        pl.retrieve_assembly_file(pdb_code, assembly_num, file_format=file_format, overwrite=True)\n        except Exception as err:\n            print(f'error {pdb_code}: {err}\\n')\n    for pdb_code in obsolete:\n        if self.flat_tree:\n            old_file = os.path.join(self.local_pdb, f'pdb{pdb_code}.{file_format}')\n            new_dir = self.obsolete_pdb\n        else:\n            old_file = os.path.join(self.local_pdb, pdb_code[1:3], f'pdb{pdb_code}.{file_format}')\n            new_dir = os.path.join(self.obsolete_pdb, pdb_code[1:3])\n        new_file = os.path.join(new_dir, f'pdb{pdb_code}.{file_format}')\n        if os.path.isfile(old_file):\n            if not os.path.isdir(new_dir):\n                os.mkdir(new_dir)\n            try:\n                shutil.move(old_file, new_file)\n            except Exception:\n                print(f'Could not move {old_file} to obsolete folder')\n        elif os.path.isfile(new_file):\n            if self._verbose:\n                print(f'Obsolete file {old_file} already moved')\n        elif self._verbose:\n            print(f'Obsolete file {old_file} is missing')"
        ]
    },
    {
        "func_name": "download_pdb_files",
        "original": "def download_pdb_files(self, pdb_codes, obsolete=False, pdir=None, file_format=None, overwrite=False):\n    \"\"\"Fetch set of PDB structure files from the PDB server and stores them locally.\n\n        The PDB structure's file name is returned as a single string.\n        If obsolete ``==`` True, the files will be saved in a special file tree.\n\n        :param pdb_codes: a list of 4-symbols structure Ids from PDB\n        :type pdb_codes: list of strings\n\n        :param file_format:\n            File format. Available options:\n\n            * \"mmCif\" (default, PDBx/mmCif file),\n            * \"pdb\" (format PDB),\n            * \"xml\" (PMDML/XML format),\n            * \"mmtf\" (highly compressed),\n            * \"bundle\" (PDB formatted archive for large structure)\n\n        :param overwrite: if set to True, existing structure files will be overwritten. Default: False\n        :type overwrite: bool\n\n        :param obsolete:\n            Has a meaning only for obsolete structures.\n            If True, download the obsolete structure\n            to 'obsolete' folder, otherwise download won't be performed.\n            This option doesn't work for mmtf format as obsoleted structures are not available as mmtf.\n            (default: False)\n\n        :type obsolete: bool\n\n        :param pdir: put the file in this directory (default: create a PDB-style directory tree)\n        :type pdir: string\n\n        :return: filenames\n        :rtype: string\n        \"\"\"\n    file_format = self._print_default_format_warning(file_format)\n    for pdb_code in pdb_codes:\n        self.retrieve_pdb_file(pdb_code, obsolete=obsolete, pdir=pdir, file_format=file_format, overwrite=overwrite)",
        "mutated": [
            "def download_pdb_files(self, pdb_codes, obsolete=False, pdir=None, file_format=None, overwrite=False):\n    if False:\n        i = 10\n    'Fetch set of PDB structure files from the PDB server and stores them locally.\\n\\n        The PDB structure\\'s file name is returned as a single string.\\n        If obsolete ``==`` True, the files will be saved in a special file tree.\\n\\n        :param pdb_codes: a list of 4-symbols structure Ids from PDB\\n        :type pdb_codes: list of strings\\n\\n        :param file_format:\\n            File format. Available options:\\n\\n            * \"mmCif\" (default, PDBx/mmCif file),\\n            * \"pdb\" (format PDB),\\n            * \"xml\" (PMDML/XML format),\\n            * \"mmtf\" (highly compressed),\\n            * \"bundle\" (PDB formatted archive for large structure)\\n\\n        :param overwrite: if set to True, existing structure files will be overwritten. Default: False\\n        :type overwrite: bool\\n\\n        :param obsolete:\\n            Has a meaning only for obsolete structures.\\n            If True, download the obsolete structure\\n            to \\'obsolete\\' folder, otherwise download won\\'t be performed.\\n            This option doesn\\'t work for mmtf format as obsoleted structures are not available as mmtf.\\n            (default: False)\\n\\n        :type obsolete: bool\\n\\n        :param pdir: put the file in this directory (default: create a PDB-style directory tree)\\n        :type pdir: string\\n\\n        :return: filenames\\n        :rtype: string\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    for pdb_code in pdb_codes:\n        self.retrieve_pdb_file(pdb_code, obsolete=obsolete, pdir=pdir, file_format=file_format, overwrite=overwrite)",
            "def download_pdb_files(self, pdb_codes, obsolete=False, pdir=None, file_format=None, overwrite=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Fetch set of PDB structure files from the PDB server and stores them locally.\\n\\n        The PDB structure\\'s file name is returned as a single string.\\n        If obsolete ``==`` True, the files will be saved in a special file tree.\\n\\n        :param pdb_codes: a list of 4-symbols structure Ids from PDB\\n        :type pdb_codes: list of strings\\n\\n        :param file_format:\\n            File format. Available options:\\n\\n            * \"mmCif\" (default, PDBx/mmCif file),\\n            * \"pdb\" (format PDB),\\n            * \"xml\" (PMDML/XML format),\\n            * \"mmtf\" (highly compressed),\\n            * \"bundle\" (PDB formatted archive for large structure)\\n\\n        :param overwrite: if set to True, existing structure files will be overwritten. Default: False\\n        :type overwrite: bool\\n\\n        :param obsolete:\\n            Has a meaning only for obsolete structures.\\n            If True, download the obsolete structure\\n            to \\'obsolete\\' folder, otherwise download won\\'t be performed.\\n            This option doesn\\'t work for mmtf format as obsoleted structures are not available as mmtf.\\n            (default: False)\\n\\n        :type obsolete: bool\\n\\n        :param pdir: put the file in this directory (default: create a PDB-style directory tree)\\n        :type pdir: string\\n\\n        :return: filenames\\n        :rtype: string\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    for pdb_code in pdb_codes:\n        self.retrieve_pdb_file(pdb_code, obsolete=obsolete, pdir=pdir, file_format=file_format, overwrite=overwrite)",
            "def download_pdb_files(self, pdb_codes, obsolete=False, pdir=None, file_format=None, overwrite=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Fetch set of PDB structure files from the PDB server and stores them locally.\\n\\n        The PDB structure\\'s file name is returned as a single string.\\n        If obsolete ``==`` True, the files will be saved in a special file tree.\\n\\n        :param pdb_codes: a list of 4-symbols structure Ids from PDB\\n        :type pdb_codes: list of strings\\n\\n        :param file_format:\\n            File format. Available options:\\n\\n            * \"mmCif\" (default, PDBx/mmCif file),\\n            * \"pdb\" (format PDB),\\n            * \"xml\" (PMDML/XML format),\\n            * \"mmtf\" (highly compressed),\\n            * \"bundle\" (PDB formatted archive for large structure)\\n\\n        :param overwrite: if set to True, existing structure files will be overwritten. Default: False\\n        :type overwrite: bool\\n\\n        :param obsolete:\\n            Has a meaning only for obsolete structures.\\n            If True, download the obsolete structure\\n            to \\'obsolete\\' folder, otherwise download won\\'t be performed.\\n            This option doesn\\'t work for mmtf format as obsoleted structures are not available as mmtf.\\n            (default: False)\\n\\n        :type obsolete: bool\\n\\n        :param pdir: put the file in this directory (default: create a PDB-style directory tree)\\n        :type pdir: string\\n\\n        :return: filenames\\n        :rtype: string\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    for pdb_code in pdb_codes:\n        self.retrieve_pdb_file(pdb_code, obsolete=obsolete, pdir=pdir, file_format=file_format, overwrite=overwrite)",
            "def download_pdb_files(self, pdb_codes, obsolete=False, pdir=None, file_format=None, overwrite=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Fetch set of PDB structure files from the PDB server and stores them locally.\\n\\n        The PDB structure\\'s file name is returned as a single string.\\n        If obsolete ``==`` True, the files will be saved in a special file tree.\\n\\n        :param pdb_codes: a list of 4-symbols structure Ids from PDB\\n        :type pdb_codes: list of strings\\n\\n        :param file_format:\\n            File format. Available options:\\n\\n            * \"mmCif\" (default, PDBx/mmCif file),\\n            * \"pdb\" (format PDB),\\n            * \"xml\" (PMDML/XML format),\\n            * \"mmtf\" (highly compressed),\\n            * \"bundle\" (PDB formatted archive for large structure)\\n\\n        :param overwrite: if set to True, existing structure files will be overwritten. Default: False\\n        :type overwrite: bool\\n\\n        :param obsolete:\\n            Has a meaning only for obsolete structures.\\n            If True, download the obsolete structure\\n            to \\'obsolete\\' folder, otherwise download won\\'t be performed.\\n            This option doesn\\'t work for mmtf format as obsoleted structures are not available as mmtf.\\n            (default: False)\\n\\n        :type obsolete: bool\\n\\n        :param pdir: put the file in this directory (default: create a PDB-style directory tree)\\n        :type pdir: string\\n\\n        :return: filenames\\n        :rtype: string\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    for pdb_code in pdb_codes:\n        self.retrieve_pdb_file(pdb_code, obsolete=obsolete, pdir=pdir, file_format=file_format, overwrite=overwrite)",
            "def download_pdb_files(self, pdb_codes, obsolete=False, pdir=None, file_format=None, overwrite=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Fetch set of PDB structure files from the PDB server and stores them locally.\\n\\n        The PDB structure\\'s file name is returned as a single string.\\n        If obsolete ``==`` True, the files will be saved in a special file tree.\\n\\n        :param pdb_codes: a list of 4-symbols structure Ids from PDB\\n        :type pdb_codes: list of strings\\n\\n        :param file_format:\\n            File format. Available options:\\n\\n            * \"mmCif\" (default, PDBx/mmCif file),\\n            * \"pdb\" (format PDB),\\n            * \"xml\" (PMDML/XML format),\\n            * \"mmtf\" (highly compressed),\\n            * \"bundle\" (PDB formatted archive for large structure)\\n\\n        :param overwrite: if set to True, existing structure files will be overwritten. Default: False\\n        :type overwrite: bool\\n\\n        :param obsolete:\\n            Has a meaning only for obsolete structures.\\n            If True, download the obsolete structure\\n            to \\'obsolete\\' folder, otherwise download won\\'t be performed.\\n            This option doesn\\'t work for mmtf format as obsoleted structures are not available as mmtf.\\n            (default: False)\\n\\n        :type obsolete: bool\\n\\n        :param pdir: put the file in this directory (default: create a PDB-style directory tree)\\n        :type pdir: string\\n\\n        :return: filenames\\n        :rtype: string\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    for pdb_code in pdb_codes:\n        self.retrieve_pdb_file(pdb_code, obsolete=obsolete, pdir=pdir, file_format=file_format, overwrite=overwrite)"
        ]
    },
    {
        "func_name": "get_all_assemblies",
        "original": "def get_all_assemblies(self, file_format='mmCif'):\n    \"\"\"Retrieve the list of PDB entries with an associated bio assembly.\n\n        The requested list will be cached to avoid multiple calls to the FTP\n        server.\n\n        :type  file_format: str, optional\n        :param file_format: format in which to download the entries. Available\n            options are \"mmCif\" or \"pdb\". Defaults to mmCif.\n        \"\"\"\n    if hasattr(self, 'assemblies') and self.assemblies:\n        if self._verbose:\n            print('Retrieving cached list of assemblies.')\n        return self.assemblies\n    if self._verbose:\n        print('Retrieving list of assemblies. This might take a while.')\n    idx = self.pdb_server.find('://')\n    if idx >= 0:\n        ftp = ftplib.FTP(self.pdb_server[idx + 3:])\n    else:\n        ftp = ftplib.FTP(self.pdb_server)\n    ftp.login()\n    if file_format.lower() == 'mmcif':\n        ftp.cwd('/pub/pdb/data/assemblies/mmCIF/all/')\n        re_name = re.compile('(\\\\d[0-9a-z]{3})-assembly(\\\\d+).cif.gz')\n    elif file_format.lower() == 'pdb':\n        ftp.cwd('/pub/pdb/data/biounit/PDB/all/')\n        re_name = re.compile('(\\\\d[0-9a-z]{3}).pdb(\\\\d+).gz')\n    else:\n        msg = \"file_format for assemblies must be 'pdb' or 'mmCif'\"\n        raise ValueError(msg)\n    response = []\n    ftp.retrlines('NLST', callback=response.append)\n    all_assemblies = []\n    for line in response:\n        if line.endswith('.gz'):\n            match = re_name.findall(line)\n            try:\n                if len(match):\n                    (entry, assembly) = match[0]\n            except ValueError:\n                pass\n            else:\n                all_assemblies.append((entry, assembly))\n    self.assemblies = all_assemblies\n    return all_assemblies",
        "mutated": [
            "def get_all_assemblies(self, file_format='mmCif'):\n    if False:\n        i = 10\n    'Retrieve the list of PDB entries with an associated bio assembly.\\n\\n        The requested list will be cached to avoid multiple calls to the FTP\\n        server.\\n\\n        :type  file_format: str, optional\\n        :param file_format: format in which to download the entries. Available\\n            options are \"mmCif\" or \"pdb\". Defaults to mmCif.\\n        '\n    if hasattr(self, 'assemblies') and self.assemblies:\n        if self._verbose:\n            print('Retrieving cached list of assemblies.')\n        return self.assemblies\n    if self._verbose:\n        print('Retrieving list of assemblies. This might take a while.')\n    idx = self.pdb_server.find('://')\n    if idx >= 0:\n        ftp = ftplib.FTP(self.pdb_server[idx + 3:])\n    else:\n        ftp = ftplib.FTP(self.pdb_server)\n    ftp.login()\n    if file_format.lower() == 'mmcif':\n        ftp.cwd('/pub/pdb/data/assemblies/mmCIF/all/')\n        re_name = re.compile('(\\\\d[0-9a-z]{3})-assembly(\\\\d+).cif.gz')\n    elif file_format.lower() == 'pdb':\n        ftp.cwd('/pub/pdb/data/biounit/PDB/all/')\n        re_name = re.compile('(\\\\d[0-9a-z]{3}).pdb(\\\\d+).gz')\n    else:\n        msg = \"file_format for assemblies must be 'pdb' or 'mmCif'\"\n        raise ValueError(msg)\n    response = []\n    ftp.retrlines('NLST', callback=response.append)\n    all_assemblies = []\n    for line in response:\n        if line.endswith('.gz'):\n            match = re_name.findall(line)\n            try:\n                if len(match):\n                    (entry, assembly) = match[0]\n            except ValueError:\n                pass\n            else:\n                all_assemblies.append((entry, assembly))\n    self.assemblies = all_assemblies\n    return all_assemblies",
            "def get_all_assemblies(self, file_format='mmCif'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Retrieve the list of PDB entries with an associated bio assembly.\\n\\n        The requested list will be cached to avoid multiple calls to the FTP\\n        server.\\n\\n        :type  file_format: str, optional\\n        :param file_format: format in which to download the entries. Available\\n            options are \"mmCif\" or \"pdb\". Defaults to mmCif.\\n        '\n    if hasattr(self, 'assemblies') and self.assemblies:\n        if self._verbose:\n            print('Retrieving cached list of assemblies.')\n        return self.assemblies\n    if self._verbose:\n        print('Retrieving list of assemblies. This might take a while.')\n    idx = self.pdb_server.find('://')\n    if idx >= 0:\n        ftp = ftplib.FTP(self.pdb_server[idx + 3:])\n    else:\n        ftp = ftplib.FTP(self.pdb_server)\n    ftp.login()\n    if file_format.lower() == 'mmcif':\n        ftp.cwd('/pub/pdb/data/assemblies/mmCIF/all/')\n        re_name = re.compile('(\\\\d[0-9a-z]{3})-assembly(\\\\d+).cif.gz')\n    elif file_format.lower() == 'pdb':\n        ftp.cwd('/pub/pdb/data/biounit/PDB/all/')\n        re_name = re.compile('(\\\\d[0-9a-z]{3}).pdb(\\\\d+).gz')\n    else:\n        msg = \"file_format for assemblies must be 'pdb' or 'mmCif'\"\n        raise ValueError(msg)\n    response = []\n    ftp.retrlines('NLST', callback=response.append)\n    all_assemblies = []\n    for line in response:\n        if line.endswith('.gz'):\n            match = re_name.findall(line)\n            try:\n                if len(match):\n                    (entry, assembly) = match[0]\n            except ValueError:\n                pass\n            else:\n                all_assemblies.append((entry, assembly))\n    self.assemblies = all_assemblies\n    return all_assemblies",
            "def get_all_assemblies(self, file_format='mmCif'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Retrieve the list of PDB entries with an associated bio assembly.\\n\\n        The requested list will be cached to avoid multiple calls to the FTP\\n        server.\\n\\n        :type  file_format: str, optional\\n        :param file_format: format in which to download the entries. Available\\n            options are \"mmCif\" or \"pdb\". Defaults to mmCif.\\n        '\n    if hasattr(self, 'assemblies') and self.assemblies:\n        if self._verbose:\n            print('Retrieving cached list of assemblies.')\n        return self.assemblies\n    if self._verbose:\n        print('Retrieving list of assemblies. This might take a while.')\n    idx = self.pdb_server.find('://')\n    if idx >= 0:\n        ftp = ftplib.FTP(self.pdb_server[idx + 3:])\n    else:\n        ftp = ftplib.FTP(self.pdb_server)\n    ftp.login()\n    if file_format.lower() == 'mmcif':\n        ftp.cwd('/pub/pdb/data/assemblies/mmCIF/all/')\n        re_name = re.compile('(\\\\d[0-9a-z]{3})-assembly(\\\\d+).cif.gz')\n    elif file_format.lower() == 'pdb':\n        ftp.cwd('/pub/pdb/data/biounit/PDB/all/')\n        re_name = re.compile('(\\\\d[0-9a-z]{3}).pdb(\\\\d+).gz')\n    else:\n        msg = \"file_format for assemblies must be 'pdb' or 'mmCif'\"\n        raise ValueError(msg)\n    response = []\n    ftp.retrlines('NLST', callback=response.append)\n    all_assemblies = []\n    for line in response:\n        if line.endswith('.gz'):\n            match = re_name.findall(line)\n            try:\n                if len(match):\n                    (entry, assembly) = match[0]\n            except ValueError:\n                pass\n            else:\n                all_assemblies.append((entry, assembly))\n    self.assemblies = all_assemblies\n    return all_assemblies",
            "def get_all_assemblies(self, file_format='mmCif'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Retrieve the list of PDB entries with an associated bio assembly.\\n\\n        The requested list will be cached to avoid multiple calls to the FTP\\n        server.\\n\\n        :type  file_format: str, optional\\n        :param file_format: format in which to download the entries. Available\\n            options are \"mmCif\" or \"pdb\". Defaults to mmCif.\\n        '\n    if hasattr(self, 'assemblies') and self.assemblies:\n        if self._verbose:\n            print('Retrieving cached list of assemblies.')\n        return self.assemblies\n    if self._verbose:\n        print('Retrieving list of assemblies. This might take a while.')\n    idx = self.pdb_server.find('://')\n    if idx >= 0:\n        ftp = ftplib.FTP(self.pdb_server[idx + 3:])\n    else:\n        ftp = ftplib.FTP(self.pdb_server)\n    ftp.login()\n    if file_format.lower() == 'mmcif':\n        ftp.cwd('/pub/pdb/data/assemblies/mmCIF/all/')\n        re_name = re.compile('(\\\\d[0-9a-z]{3})-assembly(\\\\d+).cif.gz')\n    elif file_format.lower() == 'pdb':\n        ftp.cwd('/pub/pdb/data/biounit/PDB/all/')\n        re_name = re.compile('(\\\\d[0-9a-z]{3}).pdb(\\\\d+).gz')\n    else:\n        msg = \"file_format for assemblies must be 'pdb' or 'mmCif'\"\n        raise ValueError(msg)\n    response = []\n    ftp.retrlines('NLST', callback=response.append)\n    all_assemblies = []\n    for line in response:\n        if line.endswith('.gz'):\n            match = re_name.findall(line)\n            try:\n                if len(match):\n                    (entry, assembly) = match[0]\n            except ValueError:\n                pass\n            else:\n                all_assemblies.append((entry, assembly))\n    self.assemblies = all_assemblies\n    return all_assemblies",
            "def get_all_assemblies(self, file_format='mmCif'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Retrieve the list of PDB entries with an associated bio assembly.\\n\\n        The requested list will be cached to avoid multiple calls to the FTP\\n        server.\\n\\n        :type  file_format: str, optional\\n        :param file_format: format in which to download the entries. Available\\n            options are \"mmCif\" or \"pdb\". Defaults to mmCif.\\n        '\n    if hasattr(self, 'assemblies') and self.assemblies:\n        if self._verbose:\n            print('Retrieving cached list of assemblies.')\n        return self.assemblies\n    if self._verbose:\n        print('Retrieving list of assemblies. This might take a while.')\n    idx = self.pdb_server.find('://')\n    if idx >= 0:\n        ftp = ftplib.FTP(self.pdb_server[idx + 3:])\n    else:\n        ftp = ftplib.FTP(self.pdb_server)\n    ftp.login()\n    if file_format.lower() == 'mmcif':\n        ftp.cwd('/pub/pdb/data/assemblies/mmCIF/all/')\n        re_name = re.compile('(\\\\d[0-9a-z]{3})-assembly(\\\\d+).cif.gz')\n    elif file_format.lower() == 'pdb':\n        ftp.cwd('/pub/pdb/data/biounit/PDB/all/')\n        re_name = re.compile('(\\\\d[0-9a-z]{3}).pdb(\\\\d+).gz')\n    else:\n        msg = \"file_format for assemblies must be 'pdb' or 'mmCif'\"\n        raise ValueError(msg)\n    response = []\n    ftp.retrlines('NLST', callback=response.append)\n    all_assemblies = []\n    for line in response:\n        if line.endswith('.gz'):\n            match = re_name.findall(line)\n            try:\n                if len(match):\n                    (entry, assembly) = match[0]\n            except ValueError:\n                pass\n            else:\n                all_assemblies.append((entry, assembly))\n    self.assemblies = all_assemblies\n    return all_assemblies"
        ]
    },
    {
        "func_name": "retrieve_assembly_file",
        "original": "def retrieve_assembly_file(self, pdb_code, assembly_num, pdir=None, file_format=None, overwrite=False):\n    \"\"\"Fetch one or more assembly structures associated with a PDB entry.\n\n        Unless noted below, parameters are described in ``retrieve_pdb_file``.\n\n        :type  assembly_num: int\n        :param assembly_num: assembly number to download.\n\n        :rtype : str\n        :return: file name of the downloaded assembly file.\n        \"\"\"\n    pdb_code = pdb_code.lower()\n    assembly_num = int(assembly_num)\n    archive = {'pdb': f'{pdb_code}.pdb{assembly_num}.gz', 'mmcif': f'{pdb_code}-assembly{assembly_num}.cif.gz'}\n    file_format = self._print_default_format_warning(file_format)\n    file_format = file_format.lower()\n    if file_format not in archive:\n        raise Exception(f\"Specified file_format '{file_format}' is not supported. Use one of the following: 'mmcif' or 'pdb'.\")\n    archive_fn = archive[file_format]\n    if file_format == 'mmcif':\n        url = self.pdb_server + f'/pub/pdb/data/assemblies/mmCIF/all/{archive_fn}'\n    elif file_format == 'pdb':\n        url = self.pdb_server + f'/pub/pdb/data/biounit/PDB/all/{archive_fn}'\n    else:\n        raise ValueError(f\"file_format '{file_format}' not supported\")\n    if pdir is None:\n        path = self.local_pdb\n        if not self.flat_tree:\n            path = os.path.join(path, pdb_code[1:3])\n    else:\n        path = pdir\n    if not os.access(path, os.F_OK):\n        os.makedirs(path)\n    assembly_gz_file = os.path.join(path, archive_fn)\n    assembly_final_file = os.path.join(path, archive_fn[:-3])\n    if not overwrite:\n        if os.path.exists(assembly_final_file):\n            if self._verbose:\n                print(f\"Structure exists: '{assembly_final_file}' \")\n            return assembly_final_file\n    if self._verbose:\n        print(f\"Downloading assembly ({assembly_num}) for PDB entry '{pdb_code}'...\")\n    try:\n        urlcleanup()\n        urlretrieve(url, assembly_gz_file)\n    except OSError as err:\n        print(f'Download failed! Maybe the desired assembly does not exist: {err}')\n    else:\n        with gzip.open(assembly_gz_file, 'rb') as gz:\n            with open(assembly_final_file, 'wb') as out:\n                out.writelines(gz)\n        os.remove(assembly_gz_file)\n    return assembly_final_file",
        "mutated": [
            "def retrieve_assembly_file(self, pdb_code, assembly_num, pdir=None, file_format=None, overwrite=False):\n    if False:\n        i = 10\n    'Fetch one or more assembly structures associated with a PDB entry.\\n\\n        Unless noted below, parameters are described in ``retrieve_pdb_file``.\\n\\n        :type  assembly_num: int\\n        :param assembly_num: assembly number to download.\\n\\n        :rtype : str\\n        :return: file name of the downloaded assembly file.\\n        '\n    pdb_code = pdb_code.lower()\n    assembly_num = int(assembly_num)\n    archive = {'pdb': f'{pdb_code}.pdb{assembly_num}.gz', 'mmcif': f'{pdb_code}-assembly{assembly_num}.cif.gz'}\n    file_format = self._print_default_format_warning(file_format)\n    file_format = file_format.lower()\n    if file_format not in archive:\n        raise Exception(f\"Specified file_format '{file_format}' is not supported. Use one of the following: 'mmcif' or 'pdb'.\")\n    archive_fn = archive[file_format]\n    if file_format == 'mmcif':\n        url = self.pdb_server + f'/pub/pdb/data/assemblies/mmCIF/all/{archive_fn}'\n    elif file_format == 'pdb':\n        url = self.pdb_server + f'/pub/pdb/data/biounit/PDB/all/{archive_fn}'\n    else:\n        raise ValueError(f\"file_format '{file_format}' not supported\")\n    if pdir is None:\n        path = self.local_pdb\n        if not self.flat_tree:\n            path = os.path.join(path, pdb_code[1:3])\n    else:\n        path = pdir\n    if not os.access(path, os.F_OK):\n        os.makedirs(path)\n    assembly_gz_file = os.path.join(path, archive_fn)\n    assembly_final_file = os.path.join(path, archive_fn[:-3])\n    if not overwrite:\n        if os.path.exists(assembly_final_file):\n            if self._verbose:\n                print(f\"Structure exists: '{assembly_final_file}' \")\n            return assembly_final_file\n    if self._verbose:\n        print(f\"Downloading assembly ({assembly_num}) for PDB entry '{pdb_code}'...\")\n    try:\n        urlcleanup()\n        urlretrieve(url, assembly_gz_file)\n    except OSError as err:\n        print(f'Download failed! Maybe the desired assembly does not exist: {err}')\n    else:\n        with gzip.open(assembly_gz_file, 'rb') as gz:\n            with open(assembly_final_file, 'wb') as out:\n                out.writelines(gz)\n        os.remove(assembly_gz_file)\n    return assembly_final_file",
            "def retrieve_assembly_file(self, pdb_code, assembly_num, pdir=None, file_format=None, overwrite=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Fetch one or more assembly structures associated with a PDB entry.\\n\\n        Unless noted below, parameters are described in ``retrieve_pdb_file``.\\n\\n        :type  assembly_num: int\\n        :param assembly_num: assembly number to download.\\n\\n        :rtype : str\\n        :return: file name of the downloaded assembly file.\\n        '\n    pdb_code = pdb_code.lower()\n    assembly_num = int(assembly_num)\n    archive = {'pdb': f'{pdb_code}.pdb{assembly_num}.gz', 'mmcif': f'{pdb_code}-assembly{assembly_num}.cif.gz'}\n    file_format = self._print_default_format_warning(file_format)\n    file_format = file_format.lower()\n    if file_format not in archive:\n        raise Exception(f\"Specified file_format '{file_format}' is not supported. Use one of the following: 'mmcif' or 'pdb'.\")\n    archive_fn = archive[file_format]\n    if file_format == 'mmcif':\n        url = self.pdb_server + f'/pub/pdb/data/assemblies/mmCIF/all/{archive_fn}'\n    elif file_format == 'pdb':\n        url = self.pdb_server + f'/pub/pdb/data/biounit/PDB/all/{archive_fn}'\n    else:\n        raise ValueError(f\"file_format '{file_format}' not supported\")\n    if pdir is None:\n        path = self.local_pdb\n        if not self.flat_tree:\n            path = os.path.join(path, pdb_code[1:3])\n    else:\n        path = pdir\n    if not os.access(path, os.F_OK):\n        os.makedirs(path)\n    assembly_gz_file = os.path.join(path, archive_fn)\n    assembly_final_file = os.path.join(path, archive_fn[:-3])\n    if not overwrite:\n        if os.path.exists(assembly_final_file):\n            if self._verbose:\n                print(f\"Structure exists: '{assembly_final_file}' \")\n            return assembly_final_file\n    if self._verbose:\n        print(f\"Downloading assembly ({assembly_num}) for PDB entry '{pdb_code}'...\")\n    try:\n        urlcleanup()\n        urlretrieve(url, assembly_gz_file)\n    except OSError as err:\n        print(f'Download failed! Maybe the desired assembly does not exist: {err}')\n    else:\n        with gzip.open(assembly_gz_file, 'rb') as gz:\n            with open(assembly_final_file, 'wb') as out:\n                out.writelines(gz)\n        os.remove(assembly_gz_file)\n    return assembly_final_file",
            "def retrieve_assembly_file(self, pdb_code, assembly_num, pdir=None, file_format=None, overwrite=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Fetch one or more assembly structures associated with a PDB entry.\\n\\n        Unless noted below, parameters are described in ``retrieve_pdb_file``.\\n\\n        :type  assembly_num: int\\n        :param assembly_num: assembly number to download.\\n\\n        :rtype : str\\n        :return: file name of the downloaded assembly file.\\n        '\n    pdb_code = pdb_code.lower()\n    assembly_num = int(assembly_num)\n    archive = {'pdb': f'{pdb_code}.pdb{assembly_num}.gz', 'mmcif': f'{pdb_code}-assembly{assembly_num}.cif.gz'}\n    file_format = self._print_default_format_warning(file_format)\n    file_format = file_format.lower()\n    if file_format not in archive:\n        raise Exception(f\"Specified file_format '{file_format}' is not supported. Use one of the following: 'mmcif' or 'pdb'.\")\n    archive_fn = archive[file_format]\n    if file_format == 'mmcif':\n        url = self.pdb_server + f'/pub/pdb/data/assemblies/mmCIF/all/{archive_fn}'\n    elif file_format == 'pdb':\n        url = self.pdb_server + f'/pub/pdb/data/biounit/PDB/all/{archive_fn}'\n    else:\n        raise ValueError(f\"file_format '{file_format}' not supported\")\n    if pdir is None:\n        path = self.local_pdb\n        if not self.flat_tree:\n            path = os.path.join(path, pdb_code[1:3])\n    else:\n        path = pdir\n    if not os.access(path, os.F_OK):\n        os.makedirs(path)\n    assembly_gz_file = os.path.join(path, archive_fn)\n    assembly_final_file = os.path.join(path, archive_fn[:-3])\n    if not overwrite:\n        if os.path.exists(assembly_final_file):\n            if self._verbose:\n                print(f\"Structure exists: '{assembly_final_file}' \")\n            return assembly_final_file\n    if self._verbose:\n        print(f\"Downloading assembly ({assembly_num}) for PDB entry '{pdb_code}'...\")\n    try:\n        urlcleanup()\n        urlretrieve(url, assembly_gz_file)\n    except OSError as err:\n        print(f'Download failed! Maybe the desired assembly does not exist: {err}')\n    else:\n        with gzip.open(assembly_gz_file, 'rb') as gz:\n            with open(assembly_final_file, 'wb') as out:\n                out.writelines(gz)\n        os.remove(assembly_gz_file)\n    return assembly_final_file",
            "def retrieve_assembly_file(self, pdb_code, assembly_num, pdir=None, file_format=None, overwrite=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Fetch one or more assembly structures associated with a PDB entry.\\n\\n        Unless noted below, parameters are described in ``retrieve_pdb_file``.\\n\\n        :type  assembly_num: int\\n        :param assembly_num: assembly number to download.\\n\\n        :rtype : str\\n        :return: file name of the downloaded assembly file.\\n        '\n    pdb_code = pdb_code.lower()\n    assembly_num = int(assembly_num)\n    archive = {'pdb': f'{pdb_code}.pdb{assembly_num}.gz', 'mmcif': f'{pdb_code}-assembly{assembly_num}.cif.gz'}\n    file_format = self._print_default_format_warning(file_format)\n    file_format = file_format.lower()\n    if file_format not in archive:\n        raise Exception(f\"Specified file_format '{file_format}' is not supported. Use one of the following: 'mmcif' or 'pdb'.\")\n    archive_fn = archive[file_format]\n    if file_format == 'mmcif':\n        url = self.pdb_server + f'/pub/pdb/data/assemblies/mmCIF/all/{archive_fn}'\n    elif file_format == 'pdb':\n        url = self.pdb_server + f'/pub/pdb/data/biounit/PDB/all/{archive_fn}'\n    else:\n        raise ValueError(f\"file_format '{file_format}' not supported\")\n    if pdir is None:\n        path = self.local_pdb\n        if not self.flat_tree:\n            path = os.path.join(path, pdb_code[1:3])\n    else:\n        path = pdir\n    if not os.access(path, os.F_OK):\n        os.makedirs(path)\n    assembly_gz_file = os.path.join(path, archive_fn)\n    assembly_final_file = os.path.join(path, archive_fn[:-3])\n    if not overwrite:\n        if os.path.exists(assembly_final_file):\n            if self._verbose:\n                print(f\"Structure exists: '{assembly_final_file}' \")\n            return assembly_final_file\n    if self._verbose:\n        print(f\"Downloading assembly ({assembly_num}) for PDB entry '{pdb_code}'...\")\n    try:\n        urlcleanup()\n        urlretrieve(url, assembly_gz_file)\n    except OSError as err:\n        print(f'Download failed! Maybe the desired assembly does not exist: {err}')\n    else:\n        with gzip.open(assembly_gz_file, 'rb') as gz:\n            with open(assembly_final_file, 'wb') as out:\n                out.writelines(gz)\n        os.remove(assembly_gz_file)\n    return assembly_final_file",
            "def retrieve_assembly_file(self, pdb_code, assembly_num, pdir=None, file_format=None, overwrite=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Fetch one or more assembly structures associated with a PDB entry.\\n\\n        Unless noted below, parameters are described in ``retrieve_pdb_file``.\\n\\n        :type  assembly_num: int\\n        :param assembly_num: assembly number to download.\\n\\n        :rtype : str\\n        :return: file name of the downloaded assembly file.\\n        '\n    pdb_code = pdb_code.lower()\n    assembly_num = int(assembly_num)\n    archive = {'pdb': f'{pdb_code}.pdb{assembly_num}.gz', 'mmcif': f'{pdb_code}-assembly{assembly_num}.cif.gz'}\n    file_format = self._print_default_format_warning(file_format)\n    file_format = file_format.lower()\n    if file_format not in archive:\n        raise Exception(f\"Specified file_format '{file_format}' is not supported. Use one of the following: 'mmcif' or 'pdb'.\")\n    archive_fn = archive[file_format]\n    if file_format == 'mmcif':\n        url = self.pdb_server + f'/pub/pdb/data/assemblies/mmCIF/all/{archive_fn}'\n    elif file_format == 'pdb':\n        url = self.pdb_server + f'/pub/pdb/data/biounit/PDB/all/{archive_fn}'\n    else:\n        raise ValueError(f\"file_format '{file_format}' not supported\")\n    if pdir is None:\n        path = self.local_pdb\n        if not self.flat_tree:\n            path = os.path.join(path, pdb_code[1:3])\n    else:\n        path = pdir\n    if not os.access(path, os.F_OK):\n        os.makedirs(path)\n    assembly_gz_file = os.path.join(path, archive_fn)\n    assembly_final_file = os.path.join(path, archive_fn[:-3])\n    if not overwrite:\n        if os.path.exists(assembly_final_file):\n            if self._verbose:\n                print(f\"Structure exists: '{assembly_final_file}' \")\n            return assembly_final_file\n    if self._verbose:\n        print(f\"Downloading assembly ({assembly_num}) for PDB entry '{pdb_code}'...\")\n    try:\n        urlcleanup()\n        urlretrieve(url, assembly_gz_file)\n    except OSError as err:\n        print(f'Download failed! Maybe the desired assembly does not exist: {err}')\n    else:\n        with gzip.open(assembly_gz_file, 'rb') as gz:\n            with open(assembly_final_file, 'wb') as out:\n                out.writelines(gz)\n        os.remove(assembly_gz_file)\n    return assembly_final_file"
        ]
    },
    {
        "func_name": "download_all_assemblies",
        "original": "def download_all_assemblies(self, listfile=None, file_format=None):\n    \"\"\"Retrieve all biological assemblies not in the local PDB copy.\n\n        :type  listfile: str, optional\n        :param listfile: file name to which all assembly codes will be written\n\n        :type  file_format: str, optional\n        :param file_format: format in which to download the entries. Available\n            options are \"mmCif\" or \"pdb\". Defaults to mmCif.\n        \"\"\"\n    file_format = self._print_default_format_warning(file_format)\n    assemblies = self.get_all_assemblies(file_format)\n    for (pdb_code, assembly_num) in assemblies:\n        self.retrieve_assembly_file(pdb_code, assembly_num, file_format=file_format)\n    if listfile:\n        with open(listfile, 'w') as outfile:\n            outfile.writelines((f'{pdb_code}.{assembly_num}\\n' for x in assemblies))",
        "mutated": [
            "def download_all_assemblies(self, listfile=None, file_format=None):\n    if False:\n        i = 10\n    'Retrieve all biological assemblies not in the local PDB copy.\\n\\n        :type  listfile: str, optional\\n        :param listfile: file name to which all assembly codes will be written\\n\\n        :type  file_format: str, optional\\n        :param file_format: format in which to download the entries. Available\\n            options are \"mmCif\" or \"pdb\". Defaults to mmCif.\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    assemblies = self.get_all_assemblies(file_format)\n    for (pdb_code, assembly_num) in assemblies:\n        self.retrieve_assembly_file(pdb_code, assembly_num, file_format=file_format)\n    if listfile:\n        with open(listfile, 'w') as outfile:\n            outfile.writelines((f'{pdb_code}.{assembly_num}\\n' for x in assemblies))",
            "def download_all_assemblies(self, listfile=None, file_format=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Retrieve all biological assemblies not in the local PDB copy.\\n\\n        :type  listfile: str, optional\\n        :param listfile: file name to which all assembly codes will be written\\n\\n        :type  file_format: str, optional\\n        :param file_format: format in which to download the entries. Available\\n            options are \"mmCif\" or \"pdb\". Defaults to mmCif.\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    assemblies = self.get_all_assemblies(file_format)\n    for (pdb_code, assembly_num) in assemblies:\n        self.retrieve_assembly_file(pdb_code, assembly_num, file_format=file_format)\n    if listfile:\n        with open(listfile, 'w') as outfile:\n            outfile.writelines((f'{pdb_code}.{assembly_num}\\n' for x in assemblies))",
            "def download_all_assemblies(self, listfile=None, file_format=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Retrieve all biological assemblies not in the local PDB copy.\\n\\n        :type  listfile: str, optional\\n        :param listfile: file name to which all assembly codes will be written\\n\\n        :type  file_format: str, optional\\n        :param file_format: format in which to download the entries. Available\\n            options are \"mmCif\" or \"pdb\". Defaults to mmCif.\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    assemblies = self.get_all_assemblies(file_format)\n    for (pdb_code, assembly_num) in assemblies:\n        self.retrieve_assembly_file(pdb_code, assembly_num, file_format=file_format)\n    if listfile:\n        with open(listfile, 'w') as outfile:\n            outfile.writelines((f'{pdb_code}.{assembly_num}\\n' for x in assemblies))",
            "def download_all_assemblies(self, listfile=None, file_format=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Retrieve all biological assemblies not in the local PDB copy.\\n\\n        :type  listfile: str, optional\\n        :param listfile: file name to which all assembly codes will be written\\n\\n        :type  file_format: str, optional\\n        :param file_format: format in which to download the entries. Available\\n            options are \"mmCif\" or \"pdb\". Defaults to mmCif.\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    assemblies = self.get_all_assemblies(file_format)\n    for (pdb_code, assembly_num) in assemblies:\n        self.retrieve_assembly_file(pdb_code, assembly_num, file_format=file_format)\n    if listfile:\n        with open(listfile, 'w') as outfile:\n            outfile.writelines((f'{pdb_code}.{assembly_num}\\n' for x in assemblies))",
            "def download_all_assemblies(self, listfile=None, file_format=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Retrieve all biological assemblies not in the local PDB copy.\\n\\n        :type  listfile: str, optional\\n        :param listfile: file name to which all assembly codes will be written\\n\\n        :type  file_format: str, optional\\n        :param file_format: format in which to download the entries. Available\\n            options are \"mmCif\" or \"pdb\". Defaults to mmCif.\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    assemblies = self.get_all_assemblies(file_format)\n    for (pdb_code, assembly_num) in assemblies:\n        self.retrieve_assembly_file(pdb_code, assembly_num, file_format=file_format)\n    if listfile:\n        with open(listfile, 'w') as outfile:\n            outfile.writelines((f'{pdb_code}.{assembly_num}\\n' for x in assemblies))"
        ]
    },
    {
        "func_name": "download_entire_pdb",
        "original": "def download_entire_pdb(self, listfile=None, file_format=None):\n    \"\"\"Retrieve all PDB entries not present in the local PDB copy.\n\n        :param listfile: filename to which all PDB codes will be written (optional)\n\n        :param file_format:\n            File format. Available options:\n\n            * \"mmCif\" (default, PDBx/mmCif file),\n            * \"pdb\" (format PDB),\n            * \"xml\" (PMDML/XML format),\n            * \"mmtf\" (highly compressed),\n            * \"bundle\" (PDB formatted archive for large structure)\n\n        NOTE. The default download format has changed from PDB to PDBx/mmCif\n        \"\"\"\n    file_format = self._print_default_format_warning(file_format)\n    entries = self.get_all_entries()\n    for pdb_code in entries:\n        self.retrieve_pdb_file(pdb_code, file_format=file_format)\n    if listfile:\n        with open(listfile, 'w') as outfile:\n            outfile.writelines((x + '\\n' for x in entries))",
        "mutated": [
            "def download_entire_pdb(self, listfile=None, file_format=None):\n    if False:\n        i = 10\n    'Retrieve all PDB entries not present in the local PDB copy.\\n\\n        :param listfile: filename to which all PDB codes will be written (optional)\\n\\n        :param file_format:\\n            File format. Available options:\\n\\n            * \"mmCif\" (default, PDBx/mmCif file),\\n            * \"pdb\" (format PDB),\\n            * \"xml\" (PMDML/XML format),\\n            * \"mmtf\" (highly compressed),\\n            * \"bundle\" (PDB formatted archive for large structure)\\n\\n        NOTE. The default download format has changed from PDB to PDBx/mmCif\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    entries = self.get_all_entries()\n    for pdb_code in entries:\n        self.retrieve_pdb_file(pdb_code, file_format=file_format)\n    if listfile:\n        with open(listfile, 'w') as outfile:\n            outfile.writelines((x + '\\n' for x in entries))",
            "def download_entire_pdb(self, listfile=None, file_format=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Retrieve all PDB entries not present in the local PDB copy.\\n\\n        :param listfile: filename to which all PDB codes will be written (optional)\\n\\n        :param file_format:\\n            File format. Available options:\\n\\n            * \"mmCif\" (default, PDBx/mmCif file),\\n            * \"pdb\" (format PDB),\\n            * \"xml\" (PMDML/XML format),\\n            * \"mmtf\" (highly compressed),\\n            * \"bundle\" (PDB formatted archive for large structure)\\n\\n        NOTE. The default download format has changed from PDB to PDBx/mmCif\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    entries = self.get_all_entries()\n    for pdb_code in entries:\n        self.retrieve_pdb_file(pdb_code, file_format=file_format)\n    if listfile:\n        with open(listfile, 'w') as outfile:\n            outfile.writelines((x + '\\n' for x in entries))",
            "def download_entire_pdb(self, listfile=None, file_format=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Retrieve all PDB entries not present in the local PDB copy.\\n\\n        :param listfile: filename to which all PDB codes will be written (optional)\\n\\n        :param file_format:\\n            File format. Available options:\\n\\n            * \"mmCif\" (default, PDBx/mmCif file),\\n            * \"pdb\" (format PDB),\\n            * \"xml\" (PMDML/XML format),\\n            * \"mmtf\" (highly compressed),\\n            * \"bundle\" (PDB formatted archive for large structure)\\n\\n        NOTE. The default download format has changed from PDB to PDBx/mmCif\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    entries = self.get_all_entries()\n    for pdb_code in entries:\n        self.retrieve_pdb_file(pdb_code, file_format=file_format)\n    if listfile:\n        with open(listfile, 'w') as outfile:\n            outfile.writelines((x + '\\n' for x in entries))",
            "def download_entire_pdb(self, listfile=None, file_format=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Retrieve all PDB entries not present in the local PDB copy.\\n\\n        :param listfile: filename to which all PDB codes will be written (optional)\\n\\n        :param file_format:\\n            File format. Available options:\\n\\n            * \"mmCif\" (default, PDBx/mmCif file),\\n            * \"pdb\" (format PDB),\\n            * \"xml\" (PMDML/XML format),\\n            * \"mmtf\" (highly compressed),\\n            * \"bundle\" (PDB formatted archive for large structure)\\n\\n        NOTE. The default download format has changed from PDB to PDBx/mmCif\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    entries = self.get_all_entries()\n    for pdb_code in entries:\n        self.retrieve_pdb_file(pdb_code, file_format=file_format)\n    if listfile:\n        with open(listfile, 'w') as outfile:\n            outfile.writelines((x + '\\n' for x in entries))",
            "def download_entire_pdb(self, listfile=None, file_format=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Retrieve all PDB entries not present in the local PDB copy.\\n\\n        :param listfile: filename to which all PDB codes will be written (optional)\\n\\n        :param file_format:\\n            File format. Available options:\\n\\n            * \"mmCif\" (default, PDBx/mmCif file),\\n            * \"pdb\" (format PDB),\\n            * \"xml\" (PMDML/XML format),\\n            * \"mmtf\" (highly compressed),\\n            * \"bundle\" (PDB formatted archive for large structure)\\n\\n        NOTE. The default download format has changed from PDB to PDBx/mmCif\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    entries = self.get_all_entries()\n    for pdb_code in entries:\n        self.retrieve_pdb_file(pdb_code, file_format=file_format)\n    if listfile:\n        with open(listfile, 'w') as outfile:\n            outfile.writelines((x + '\\n' for x in entries))"
        ]
    },
    {
        "func_name": "download_obsolete_entries",
        "original": "def download_obsolete_entries(self, listfile=None, file_format=None):\n    \"\"\"Retrieve all obsolete PDB entries not present in local obsolete PDB copy.\n\n        :param listfile: filename to which all PDB codes will be written (optional)\n\n        :param file_format: file format. Available options:\n            \"mmCif\" (default, PDBx/mmCif file),\n            \"pdb\" (format PDB),\n            \"xml\" (PMDML/XML format),\n\n        NOTE. The default download format has changed from PDB to PDBx/mmCif\n        \"\"\"\n    file_format = self._print_default_format_warning(file_format)\n    entries = self.get_all_obsolete()\n    for pdb_code in entries:\n        self.retrieve_pdb_file(pdb_code, obsolete=True, file_format=file_format)\n    if listfile:\n        with open(listfile, 'w') as outfile:\n            outfile.writelines((x + '\\n' for x in entries))",
        "mutated": [
            "def download_obsolete_entries(self, listfile=None, file_format=None):\n    if False:\n        i = 10\n    'Retrieve all obsolete PDB entries not present in local obsolete PDB copy.\\n\\n        :param listfile: filename to which all PDB codes will be written (optional)\\n\\n        :param file_format: file format. Available options:\\n            \"mmCif\" (default, PDBx/mmCif file),\\n            \"pdb\" (format PDB),\\n            \"xml\" (PMDML/XML format),\\n\\n        NOTE. The default download format has changed from PDB to PDBx/mmCif\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    entries = self.get_all_obsolete()\n    for pdb_code in entries:\n        self.retrieve_pdb_file(pdb_code, obsolete=True, file_format=file_format)\n    if listfile:\n        with open(listfile, 'w') as outfile:\n            outfile.writelines((x + '\\n' for x in entries))",
            "def download_obsolete_entries(self, listfile=None, file_format=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Retrieve all obsolete PDB entries not present in local obsolete PDB copy.\\n\\n        :param listfile: filename to which all PDB codes will be written (optional)\\n\\n        :param file_format: file format. Available options:\\n            \"mmCif\" (default, PDBx/mmCif file),\\n            \"pdb\" (format PDB),\\n            \"xml\" (PMDML/XML format),\\n\\n        NOTE. The default download format has changed from PDB to PDBx/mmCif\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    entries = self.get_all_obsolete()\n    for pdb_code in entries:\n        self.retrieve_pdb_file(pdb_code, obsolete=True, file_format=file_format)\n    if listfile:\n        with open(listfile, 'w') as outfile:\n            outfile.writelines((x + '\\n' for x in entries))",
            "def download_obsolete_entries(self, listfile=None, file_format=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Retrieve all obsolete PDB entries not present in local obsolete PDB copy.\\n\\n        :param listfile: filename to which all PDB codes will be written (optional)\\n\\n        :param file_format: file format. Available options:\\n            \"mmCif\" (default, PDBx/mmCif file),\\n            \"pdb\" (format PDB),\\n            \"xml\" (PMDML/XML format),\\n\\n        NOTE. The default download format has changed from PDB to PDBx/mmCif\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    entries = self.get_all_obsolete()\n    for pdb_code in entries:\n        self.retrieve_pdb_file(pdb_code, obsolete=True, file_format=file_format)\n    if listfile:\n        with open(listfile, 'w') as outfile:\n            outfile.writelines((x + '\\n' for x in entries))",
            "def download_obsolete_entries(self, listfile=None, file_format=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Retrieve all obsolete PDB entries not present in local obsolete PDB copy.\\n\\n        :param listfile: filename to which all PDB codes will be written (optional)\\n\\n        :param file_format: file format. Available options:\\n            \"mmCif\" (default, PDBx/mmCif file),\\n            \"pdb\" (format PDB),\\n            \"xml\" (PMDML/XML format),\\n\\n        NOTE. The default download format has changed from PDB to PDBx/mmCif\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    entries = self.get_all_obsolete()\n    for pdb_code in entries:\n        self.retrieve_pdb_file(pdb_code, obsolete=True, file_format=file_format)\n    if listfile:\n        with open(listfile, 'w') as outfile:\n            outfile.writelines((x + '\\n' for x in entries))",
            "def download_obsolete_entries(self, listfile=None, file_format=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Retrieve all obsolete PDB entries not present in local obsolete PDB copy.\\n\\n        :param listfile: filename to which all PDB codes will be written (optional)\\n\\n        :param file_format: file format. Available options:\\n            \"mmCif\" (default, PDBx/mmCif file),\\n            \"pdb\" (format PDB),\\n            \"xml\" (PMDML/XML format),\\n\\n        NOTE. The default download format has changed from PDB to PDBx/mmCif\\n        '\n    file_format = self._print_default_format_warning(file_format)\n    entries = self.get_all_obsolete()\n    for pdb_code in entries:\n        self.retrieve_pdb_file(pdb_code, obsolete=True, file_format=file_format)\n    if listfile:\n        with open(listfile, 'w') as outfile:\n            outfile.writelines((x + '\\n' for x in entries))"
        ]
    },
    {
        "func_name": "get_seqres_file",
        "original": "def get_seqres_file(self, savefile='pdb_seqres.txt'):\n    \"\"\"Retrieve and save a (big) file containing all the sequences of PDB entries.\"\"\"\n    if self._verbose:\n        print('Retrieving sequence file (takes over 110 MB).')\n    url = self.pdb_server + '/pub/pdb/derived_data/pdb_seqres.txt'\n    urlretrieve(url, savefile)",
        "mutated": [
            "def get_seqres_file(self, savefile='pdb_seqres.txt'):\n    if False:\n        i = 10\n    'Retrieve and save a (big) file containing all the sequences of PDB entries.'\n    if self._verbose:\n        print('Retrieving sequence file (takes over 110 MB).')\n    url = self.pdb_server + '/pub/pdb/derived_data/pdb_seqres.txt'\n    urlretrieve(url, savefile)",
            "def get_seqres_file(self, savefile='pdb_seqres.txt'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Retrieve and save a (big) file containing all the sequences of PDB entries.'\n    if self._verbose:\n        print('Retrieving sequence file (takes over 110 MB).')\n    url = self.pdb_server + '/pub/pdb/derived_data/pdb_seqres.txt'\n    urlretrieve(url, savefile)",
            "def get_seqres_file(self, savefile='pdb_seqres.txt'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Retrieve and save a (big) file containing all the sequences of PDB entries.'\n    if self._verbose:\n        print('Retrieving sequence file (takes over 110 MB).')\n    url = self.pdb_server + '/pub/pdb/derived_data/pdb_seqres.txt'\n    urlretrieve(url, savefile)",
            "def get_seqres_file(self, savefile='pdb_seqres.txt'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Retrieve and save a (big) file containing all the sequences of PDB entries.'\n    if self._verbose:\n        print('Retrieving sequence file (takes over 110 MB).')\n    url = self.pdb_server + '/pub/pdb/derived_data/pdb_seqres.txt'\n    urlretrieve(url, savefile)",
            "def get_seqres_file(self, savefile='pdb_seqres.txt'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Retrieve and save a (big) file containing all the sequences of PDB entries.'\n    if self._verbose:\n        print('Retrieving sequence file (takes over 110 MB).')\n    url = self.pdb_server + '/pub/pdb/derived_data/pdb_seqres.txt'\n    urlretrieve(url, savefile)"
        ]
    }
]