[
    {
        "func_name": "fbeta_score",
        "original": "def fbeta_score(outputs: torch.Tensor, targets: torch.Tensor, beta: float=1.0, eps: float=1e-07, argmax_dim: int=-1, num_classes: Optional[int]=None) -> Union[float, torch.Tensor]:\n    \"\"\"Counts fbeta score for given ``outputs`` and ``targets``.\n\n    Args:\n        outputs: A list of predicted elements\n        targets:  A list of elements that are to be predicted\n        beta: beta param for f_score\n        eps: epsilon to avoid zero division\n        argmax_dim: int, that specifies dimension for argmax transformation\n            in case of scores/probabilities in ``outputs``\n        num_classes: int, that specifies number of classes if it known\n\n    Raises:\n        ValueError: If ``beta`` is a negative number.\n\n    Returns:\n        float: F_beta score.\n\n    Example:\n\n    .. code-block:: python\n\n        import torch\n        from catalyst import metrics\n        metrics.fbeta_score(\n            outputs=torch.tensor([\n                [1, 0, 0],\n                [0, 1, 0],\n                [0, 0, 1],\n            ]),\n            targets=torch.tensor([0, 1, 2]),\n            beta=1,\n        )\n        # tensor([1., 1., 1.]),  # per class fbeta\n    \"\"\"\n    if beta < 0:\n        raise ValueError('beta parameter should be non-negative')\n    (_p, _r, fbeta, _) = precision_recall_fbeta_support(outputs=outputs, targets=targets, beta=beta, eps=eps, argmax_dim=argmax_dim, num_classes=num_classes)\n    return fbeta",
        "mutated": [
            "def fbeta_score(outputs: torch.Tensor, targets: torch.Tensor, beta: float=1.0, eps: float=1e-07, argmax_dim: int=-1, num_classes: Optional[int]=None) -> Union[float, torch.Tensor]:\n    if False:\n        i = 10\n    'Counts fbeta score for given ``outputs`` and ``targets``.\\n\\n    Args:\\n        outputs: A list of predicted elements\\n        targets:  A list of elements that are to be predicted\\n        beta: beta param for f_score\\n        eps: epsilon to avoid zero division\\n        argmax_dim: int, that specifies dimension for argmax transformation\\n            in case of scores/probabilities in ``outputs``\\n        num_classes: int, that specifies number of classes if it known\\n\\n    Raises:\\n        ValueError: If ``beta`` is a negative number.\\n\\n    Returns:\\n        float: F_beta score.\\n\\n    Example:\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.fbeta_score(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 0, 1],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n            beta=1,\\n        )\\n        # tensor([1., 1., 1.]),  # per class fbeta\\n    '\n    if beta < 0:\n        raise ValueError('beta parameter should be non-negative')\n    (_p, _r, fbeta, _) = precision_recall_fbeta_support(outputs=outputs, targets=targets, beta=beta, eps=eps, argmax_dim=argmax_dim, num_classes=num_classes)\n    return fbeta",
            "def fbeta_score(outputs: torch.Tensor, targets: torch.Tensor, beta: float=1.0, eps: float=1e-07, argmax_dim: int=-1, num_classes: Optional[int]=None) -> Union[float, torch.Tensor]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Counts fbeta score for given ``outputs`` and ``targets``.\\n\\n    Args:\\n        outputs: A list of predicted elements\\n        targets:  A list of elements that are to be predicted\\n        beta: beta param for f_score\\n        eps: epsilon to avoid zero division\\n        argmax_dim: int, that specifies dimension for argmax transformation\\n            in case of scores/probabilities in ``outputs``\\n        num_classes: int, that specifies number of classes if it known\\n\\n    Raises:\\n        ValueError: If ``beta`` is a negative number.\\n\\n    Returns:\\n        float: F_beta score.\\n\\n    Example:\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.fbeta_score(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 0, 1],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n            beta=1,\\n        )\\n        # tensor([1., 1., 1.]),  # per class fbeta\\n    '\n    if beta < 0:\n        raise ValueError('beta parameter should be non-negative')\n    (_p, _r, fbeta, _) = precision_recall_fbeta_support(outputs=outputs, targets=targets, beta=beta, eps=eps, argmax_dim=argmax_dim, num_classes=num_classes)\n    return fbeta",
            "def fbeta_score(outputs: torch.Tensor, targets: torch.Tensor, beta: float=1.0, eps: float=1e-07, argmax_dim: int=-1, num_classes: Optional[int]=None) -> Union[float, torch.Tensor]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Counts fbeta score for given ``outputs`` and ``targets``.\\n\\n    Args:\\n        outputs: A list of predicted elements\\n        targets:  A list of elements that are to be predicted\\n        beta: beta param for f_score\\n        eps: epsilon to avoid zero division\\n        argmax_dim: int, that specifies dimension for argmax transformation\\n            in case of scores/probabilities in ``outputs``\\n        num_classes: int, that specifies number of classes if it known\\n\\n    Raises:\\n        ValueError: If ``beta`` is a negative number.\\n\\n    Returns:\\n        float: F_beta score.\\n\\n    Example:\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.fbeta_score(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 0, 1],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n            beta=1,\\n        )\\n        # tensor([1., 1., 1.]),  # per class fbeta\\n    '\n    if beta < 0:\n        raise ValueError('beta parameter should be non-negative')\n    (_p, _r, fbeta, _) = precision_recall_fbeta_support(outputs=outputs, targets=targets, beta=beta, eps=eps, argmax_dim=argmax_dim, num_classes=num_classes)\n    return fbeta",
            "def fbeta_score(outputs: torch.Tensor, targets: torch.Tensor, beta: float=1.0, eps: float=1e-07, argmax_dim: int=-1, num_classes: Optional[int]=None) -> Union[float, torch.Tensor]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Counts fbeta score for given ``outputs`` and ``targets``.\\n\\n    Args:\\n        outputs: A list of predicted elements\\n        targets:  A list of elements that are to be predicted\\n        beta: beta param for f_score\\n        eps: epsilon to avoid zero division\\n        argmax_dim: int, that specifies dimension for argmax transformation\\n            in case of scores/probabilities in ``outputs``\\n        num_classes: int, that specifies number of classes if it known\\n\\n    Raises:\\n        ValueError: If ``beta`` is a negative number.\\n\\n    Returns:\\n        float: F_beta score.\\n\\n    Example:\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.fbeta_score(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 0, 1],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n            beta=1,\\n        )\\n        # tensor([1., 1., 1.]),  # per class fbeta\\n    '\n    if beta < 0:\n        raise ValueError('beta parameter should be non-negative')\n    (_p, _r, fbeta, _) = precision_recall_fbeta_support(outputs=outputs, targets=targets, beta=beta, eps=eps, argmax_dim=argmax_dim, num_classes=num_classes)\n    return fbeta",
            "def fbeta_score(outputs: torch.Tensor, targets: torch.Tensor, beta: float=1.0, eps: float=1e-07, argmax_dim: int=-1, num_classes: Optional[int]=None) -> Union[float, torch.Tensor]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Counts fbeta score for given ``outputs`` and ``targets``.\\n\\n    Args:\\n        outputs: A list of predicted elements\\n        targets:  A list of elements that are to be predicted\\n        beta: beta param for f_score\\n        eps: epsilon to avoid zero division\\n        argmax_dim: int, that specifies dimension for argmax transformation\\n            in case of scores/probabilities in ``outputs``\\n        num_classes: int, that specifies number of classes if it known\\n\\n    Raises:\\n        ValueError: If ``beta`` is a negative number.\\n\\n    Returns:\\n        float: F_beta score.\\n\\n    Example:\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.fbeta_score(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 0, 1],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n            beta=1,\\n        )\\n        # tensor([1., 1., 1.]),  # per class fbeta\\n    '\n    if beta < 0:\n        raise ValueError('beta parameter should be non-negative')\n    (_p, _r, fbeta, _) = precision_recall_fbeta_support(outputs=outputs, targets=targets, beta=beta, eps=eps, argmax_dim=argmax_dim, num_classes=num_classes)\n    return fbeta"
        ]
    },
    {
        "func_name": "f1_score",
        "original": "def f1_score(outputs: torch.Tensor, targets: torch.Tensor, eps: float=1e-07, argmax_dim: int=-1, num_classes: Optional[int]=None) -> Union[float, torch.Tensor]:\n    \"\"\"Fbeta_score with beta=1.\n\n    Args:\n        outputs: A list of predicted elements\n        targets:  A list of elements that are to be predicted\n        eps: epsilon to avoid zero division\n        argmax_dim: int, that specifies dimension for argmax transformation\n            in case of scores/probabilities in ``outputs``\n        num_classes: int, that specifies number of classes if it known\n\n    Returns:\n        float: F_1 score\n\n    Example:\n\n    .. code-block:: python\n\n        import torch\n        from catalyst import metrics\n        metrics.f1_score(\n            outputs=torch.tensor([\n                [1, 0, 0],\n                [0, 1, 0],\n                [0, 0, 1],\n            ]),\n            targets=torch.tensor([0, 1, 2]),\n        )\n        # tensor([1., 1., 1.]),  # per class fbeta\n    \"\"\"\n    score = fbeta_score(outputs=outputs, targets=targets, beta=1, eps=eps, argmax_dim=argmax_dim, num_classes=num_classes)\n    return score",
        "mutated": [
            "def f1_score(outputs: torch.Tensor, targets: torch.Tensor, eps: float=1e-07, argmax_dim: int=-1, num_classes: Optional[int]=None) -> Union[float, torch.Tensor]:\n    if False:\n        i = 10\n    'Fbeta_score with beta=1.\\n\\n    Args:\\n        outputs: A list of predicted elements\\n        targets:  A list of elements that are to be predicted\\n        eps: epsilon to avoid zero division\\n        argmax_dim: int, that specifies dimension for argmax transformation\\n            in case of scores/probabilities in ``outputs``\\n        num_classes: int, that specifies number of classes if it known\\n\\n    Returns:\\n        float: F_1 score\\n\\n    Example:\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.f1_score(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 0, 1],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n        )\\n        # tensor([1., 1., 1.]),  # per class fbeta\\n    '\n    score = fbeta_score(outputs=outputs, targets=targets, beta=1, eps=eps, argmax_dim=argmax_dim, num_classes=num_classes)\n    return score",
            "def f1_score(outputs: torch.Tensor, targets: torch.Tensor, eps: float=1e-07, argmax_dim: int=-1, num_classes: Optional[int]=None) -> Union[float, torch.Tensor]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Fbeta_score with beta=1.\\n\\n    Args:\\n        outputs: A list of predicted elements\\n        targets:  A list of elements that are to be predicted\\n        eps: epsilon to avoid zero division\\n        argmax_dim: int, that specifies dimension for argmax transformation\\n            in case of scores/probabilities in ``outputs``\\n        num_classes: int, that specifies number of classes if it known\\n\\n    Returns:\\n        float: F_1 score\\n\\n    Example:\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.f1_score(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 0, 1],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n        )\\n        # tensor([1., 1., 1.]),  # per class fbeta\\n    '\n    score = fbeta_score(outputs=outputs, targets=targets, beta=1, eps=eps, argmax_dim=argmax_dim, num_classes=num_classes)\n    return score",
            "def f1_score(outputs: torch.Tensor, targets: torch.Tensor, eps: float=1e-07, argmax_dim: int=-1, num_classes: Optional[int]=None) -> Union[float, torch.Tensor]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Fbeta_score with beta=1.\\n\\n    Args:\\n        outputs: A list of predicted elements\\n        targets:  A list of elements that are to be predicted\\n        eps: epsilon to avoid zero division\\n        argmax_dim: int, that specifies dimension for argmax transformation\\n            in case of scores/probabilities in ``outputs``\\n        num_classes: int, that specifies number of classes if it known\\n\\n    Returns:\\n        float: F_1 score\\n\\n    Example:\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.f1_score(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 0, 1],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n        )\\n        # tensor([1., 1., 1.]),  # per class fbeta\\n    '\n    score = fbeta_score(outputs=outputs, targets=targets, beta=1, eps=eps, argmax_dim=argmax_dim, num_classes=num_classes)\n    return score",
            "def f1_score(outputs: torch.Tensor, targets: torch.Tensor, eps: float=1e-07, argmax_dim: int=-1, num_classes: Optional[int]=None) -> Union[float, torch.Tensor]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Fbeta_score with beta=1.\\n\\n    Args:\\n        outputs: A list of predicted elements\\n        targets:  A list of elements that are to be predicted\\n        eps: epsilon to avoid zero division\\n        argmax_dim: int, that specifies dimension for argmax transformation\\n            in case of scores/probabilities in ``outputs``\\n        num_classes: int, that specifies number of classes if it known\\n\\n    Returns:\\n        float: F_1 score\\n\\n    Example:\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.f1_score(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 0, 1],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n        )\\n        # tensor([1., 1., 1.]),  # per class fbeta\\n    '\n    score = fbeta_score(outputs=outputs, targets=targets, beta=1, eps=eps, argmax_dim=argmax_dim, num_classes=num_classes)\n    return score",
            "def f1_score(outputs: torch.Tensor, targets: torch.Tensor, eps: float=1e-07, argmax_dim: int=-1, num_classes: Optional[int]=None) -> Union[float, torch.Tensor]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Fbeta_score with beta=1.\\n\\n    Args:\\n        outputs: A list of predicted elements\\n        targets:  A list of elements that are to be predicted\\n        eps: epsilon to avoid zero division\\n        argmax_dim: int, that specifies dimension for argmax transformation\\n            in case of scores/probabilities in ``outputs``\\n        num_classes: int, that specifies number of classes if it known\\n\\n    Returns:\\n        float: F_1 score\\n\\n    Example:\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.f1_score(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 0, 1],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n        )\\n        # tensor([1., 1., 1.]),  # per class fbeta\\n    '\n    score = fbeta_score(outputs=outputs, targets=targets, beta=1, eps=eps, argmax_dim=argmax_dim, num_classes=num_classes)\n    return score"
        ]
    }
]