[
    {
        "func_name": "setUp",
        "original": "def setUp(self):\n    self.prices = np.array([0.316698, 0.626963, 1.228723, 0.477992, 0.945398, 1.849399])\n    self.expiries = np.array([0.5, 0.5, 0.5, 1.0, 1.0, 1.0])\n    self.float_leg_start_times = np.array([[0.5, 1.0, 1.0, 1.0], [0.5, 1.0, 1.5, 1.5], [0.5, 1.0, 1.5, 2.0], [1.0, 1.5, 1.5, 1.5], [1.0, 1.5, 2.0, 2.0], [1.0, 1.5, 2.0, 2.5]])\n    self.float_leg_end_times = self.float_leg_start_times + 0.5\n    max_maturities = np.array([1.0, 1.5, 2.5, 1.5, 2.0, 3.0])\n    for i in range(self.float_leg_end_times.shape[0]):\n        self.float_leg_end_times[i] = np.clip(self.float_leg_end_times[i], 0.0, max_maturities[i])\n    self.fixed_leg_payment_times = self.float_leg_end_times\n    self.float_leg_daycount_fractions = self.float_leg_end_times - self.float_leg_start_times\n    self.fixed_leg_daycount_fractions = self.float_leg_daycount_fractions\n    self.fixed_leg_coupon = 0.01 * np.ones_like(self.fixed_leg_payment_times)\n    super(HJMCalibrationTest, self).setUp()",
        "mutated": [
            "def setUp(self):\n    if False:\n        i = 10\n    self.prices = np.array([0.316698, 0.626963, 1.228723, 0.477992, 0.945398, 1.849399])\n    self.expiries = np.array([0.5, 0.5, 0.5, 1.0, 1.0, 1.0])\n    self.float_leg_start_times = np.array([[0.5, 1.0, 1.0, 1.0], [0.5, 1.0, 1.5, 1.5], [0.5, 1.0, 1.5, 2.0], [1.0, 1.5, 1.5, 1.5], [1.0, 1.5, 2.0, 2.0], [1.0, 1.5, 2.0, 2.5]])\n    self.float_leg_end_times = self.float_leg_start_times + 0.5\n    max_maturities = np.array([1.0, 1.5, 2.5, 1.5, 2.0, 3.0])\n    for i in range(self.float_leg_end_times.shape[0]):\n        self.float_leg_end_times[i] = np.clip(self.float_leg_end_times[i], 0.0, max_maturities[i])\n    self.fixed_leg_payment_times = self.float_leg_end_times\n    self.float_leg_daycount_fractions = self.float_leg_end_times - self.float_leg_start_times\n    self.fixed_leg_daycount_fractions = self.float_leg_daycount_fractions\n    self.fixed_leg_coupon = 0.01 * np.ones_like(self.fixed_leg_payment_times)\n    super(HJMCalibrationTest, self).setUp()",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.prices = np.array([0.316698, 0.626963, 1.228723, 0.477992, 0.945398, 1.849399])\n    self.expiries = np.array([0.5, 0.5, 0.5, 1.0, 1.0, 1.0])\n    self.float_leg_start_times = np.array([[0.5, 1.0, 1.0, 1.0], [0.5, 1.0, 1.5, 1.5], [0.5, 1.0, 1.5, 2.0], [1.0, 1.5, 1.5, 1.5], [1.0, 1.5, 2.0, 2.0], [1.0, 1.5, 2.0, 2.5]])\n    self.float_leg_end_times = self.float_leg_start_times + 0.5\n    max_maturities = np.array([1.0, 1.5, 2.5, 1.5, 2.0, 3.0])\n    for i in range(self.float_leg_end_times.shape[0]):\n        self.float_leg_end_times[i] = np.clip(self.float_leg_end_times[i], 0.0, max_maturities[i])\n    self.fixed_leg_payment_times = self.float_leg_end_times\n    self.float_leg_daycount_fractions = self.float_leg_end_times - self.float_leg_start_times\n    self.fixed_leg_daycount_fractions = self.float_leg_daycount_fractions\n    self.fixed_leg_coupon = 0.01 * np.ones_like(self.fixed_leg_payment_times)\n    super(HJMCalibrationTest, self).setUp()",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.prices = np.array([0.316698, 0.626963, 1.228723, 0.477992, 0.945398, 1.849399])\n    self.expiries = np.array([0.5, 0.5, 0.5, 1.0, 1.0, 1.0])\n    self.float_leg_start_times = np.array([[0.5, 1.0, 1.0, 1.0], [0.5, 1.0, 1.5, 1.5], [0.5, 1.0, 1.5, 2.0], [1.0, 1.5, 1.5, 1.5], [1.0, 1.5, 2.0, 2.0], [1.0, 1.5, 2.0, 2.5]])\n    self.float_leg_end_times = self.float_leg_start_times + 0.5\n    max_maturities = np.array([1.0, 1.5, 2.5, 1.5, 2.0, 3.0])\n    for i in range(self.float_leg_end_times.shape[0]):\n        self.float_leg_end_times[i] = np.clip(self.float_leg_end_times[i], 0.0, max_maturities[i])\n    self.fixed_leg_payment_times = self.float_leg_end_times\n    self.float_leg_daycount_fractions = self.float_leg_end_times - self.float_leg_start_times\n    self.fixed_leg_daycount_fractions = self.float_leg_daycount_fractions\n    self.fixed_leg_coupon = 0.01 * np.ones_like(self.fixed_leg_payment_times)\n    super(HJMCalibrationTest, self).setUp()",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.prices = np.array([0.316698, 0.626963, 1.228723, 0.477992, 0.945398, 1.849399])\n    self.expiries = np.array([0.5, 0.5, 0.5, 1.0, 1.0, 1.0])\n    self.float_leg_start_times = np.array([[0.5, 1.0, 1.0, 1.0], [0.5, 1.0, 1.5, 1.5], [0.5, 1.0, 1.5, 2.0], [1.0, 1.5, 1.5, 1.5], [1.0, 1.5, 2.0, 2.0], [1.0, 1.5, 2.0, 2.5]])\n    self.float_leg_end_times = self.float_leg_start_times + 0.5\n    max_maturities = np.array([1.0, 1.5, 2.5, 1.5, 2.0, 3.0])\n    for i in range(self.float_leg_end_times.shape[0]):\n        self.float_leg_end_times[i] = np.clip(self.float_leg_end_times[i], 0.0, max_maturities[i])\n    self.fixed_leg_payment_times = self.float_leg_end_times\n    self.float_leg_daycount_fractions = self.float_leg_end_times - self.float_leg_start_times\n    self.fixed_leg_daycount_fractions = self.float_leg_daycount_fractions\n    self.fixed_leg_coupon = 0.01 * np.ones_like(self.fixed_leg_payment_times)\n    super(HJMCalibrationTest, self).setUp()",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.prices = np.array([0.316698, 0.626963, 1.228723, 0.477992, 0.945398, 1.849399])\n    self.expiries = np.array([0.5, 0.5, 0.5, 1.0, 1.0, 1.0])\n    self.float_leg_start_times = np.array([[0.5, 1.0, 1.0, 1.0], [0.5, 1.0, 1.5, 1.5], [0.5, 1.0, 1.5, 2.0], [1.0, 1.5, 1.5, 1.5], [1.0, 1.5, 2.0, 2.0], [1.0, 1.5, 2.0, 2.5]])\n    self.float_leg_end_times = self.float_leg_start_times + 0.5\n    max_maturities = np.array([1.0, 1.5, 2.5, 1.5, 2.0, 3.0])\n    for i in range(self.float_leg_end_times.shape[0]):\n        self.float_leg_end_times[i] = np.clip(self.float_leg_end_times[i], 0.0, max_maturities[i])\n    self.fixed_leg_payment_times = self.float_leg_end_times\n    self.float_leg_daycount_fractions = self.float_leg_end_times - self.float_leg_start_times\n    self.fixed_leg_daycount_fractions = self.float_leg_daycount_fractions\n    self.fixed_leg_coupon = 0.01 * np.ones_like(self.fixed_leg_payment_times)\n    super(HJMCalibrationTest, self).setUp()"
        ]
    },
    {
        "func_name": "_fn",
        "original": "@tf.function(experimental_compile=True)\ndef _fn():\n    ((calib_mr, calib_vol, calib_corr), _, _) = tff.models.hjm.calibration_from_swaptions(prices=self.prices, expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=num_hjm_factors, mean_reversion=mr0, volatility=vol0, optimizer_fn=optimizer_fn, volatility_based_calibration=vol_based_calib, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=41, maximum_iterations=max_iter, dtype=dtype)\n    return (calib_mr, calib_vol, calib_corr)",
        "mutated": [
            "@tf.function(experimental_compile=True)\ndef _fn():\n    if False:\n        i = 10\n    ((calib_mr, calib_vol, calib_corr), _, _) = tff.models.hjm.calibration_from_swaptions(prices=self.prices, expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=num_hjm_factors, mean_reversion=mr0, volatility=vol0, optimizer_fn=optimizer_fn, volatility_based_calibration=vol_based_calib, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=41, maximum_iterations=max_iter, dtype=dtype)\n    return (calib_mr, calib_vol, calib_corr)",
            "@tf.function(experimental_compile=True)\ndef _fn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ((calib_mr, calib_vol, calib_corr), _, _) = tff.models.hjm.calibration_from_swaptions(prices=self.prices, expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=num_hjm_factors, mean_reversion=mr0, volatility=vol0, optimizer_fn=optimizer_fn, volatility_based_calibration=vol_based_calib, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=41, maximum_iterations=max_iter, dtype=dtype)\n    return (calib_mr, calib_vol, calib_corr)",
            "@tf.function(experimental_compile=True)\ndef _fn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ((calib_mr, calib_vol, calib_corr), _, _) = tff.models.hjm.calibration_from_swaptions(prices=self.prices, expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=num_hjm_factors, mean_reversion=mr0, volatility=vol0, optimizer_fn=optimizer_fn, volatility_based_calibration=vol_based_calib, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=41, maximum_iterations=max_iter, dtype=dtype)\n    return (calib_mr, calib_vol, calib_corr)",
            "@tf.function(experimental_compile=True)\ndef _fn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ((calib_mr, calib_vol, calib_corr), _, _) = tff.models.hjm.calibration_from_swaptions(prices=self.prices, expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=num_hjm_factors, mean_reversion=mr0, volatility=vol0, optimizer_fn=optimizer_fn, volatility_based_calibration=vol_based_calib, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=41, maximum_iterations=max_iter, dtype=dtype)\n    return (calib_mr, calib_vol, calib_corr)",
            "@tf.function(experimental_compile=True)\ndef _fn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ((calib_mr, calib_vol, calib_corr), _, _) = tff.models.hjm.calibration_from_swaptions(prices=self.prices, expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=num_hjm_factors, mean_reversion=mr0, volatility=vol0, optimizer_fn=optimizer_fn, volatility_based_calibration=vol_based_calib, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=41, maximum_iterations=max_iter, dtype=dtype)\n    return (calib_mr, calib_vol, calib_corr)"
        ]
    },
    {
        "func_name": "test_calibration",
        "original": "@parameterized.named_parameters({'testcase_name': 'two_factor_price_xla', 'optimizer_fn': None, 'vol_based_calib': False, 'num_hjm_factors': 2, 'time_step': None, 'num_time_steps': 3, 'use_xla': True, 'use_fd': False, 'max_iter': 4})\ndef test_calibration(self, optimizer_fn, vol_based_calib, num_hjm_factors, time_step, num_time_steps, use_xla, use_fd, max_iter):\n    \"\"\"Tests calibration with constant parameters is XLA-compatible.\"\"\"\n    dtype = tf.float64\n    mr0 = [0.01, 0.05]\n    if num_hjm_factors == 1:\n        mr0 = [0.01]\n    vol0 = [0.005, 0.007]\n    if num_hjm_factors == 1:\n        vol0 = [0.002]\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    times = np.unique(np.reshape(self.expiries, [-1]))\n    curve_times = np.unique(np.reshape(self.fixed_leg_payment_times - np.expand_dims(self.expiries, axis=-1), [-1]))\n    random_type = None\n    seed = 0\n    num_samples = 200\n    valuation_method = tff.models.ValuationMethod.FINITE_DIFFERENCE if use_fd else tff.models.ValuationMethod.MONTE_CARLO\n\n    @tf.function(experimental_compile=True)\n    def _fn():\n        ((calib_mr, calib_vol, calib_corr), _, _) = tff.models.hjm.calibration_from_swaptions(prices=self.prices, expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=num_hjm_factors, mean_reversion=mr0, volatility=vol0, optimizer_fn=optimizer_fn, volatility_based_calibration=vol_based_calib, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=41, maximum_iterations=max_iter, dtype=dtype)\n        return (calib_mr, calib_vol, calib_corr)\n    hlo_text = _fn.experimental_get_compiler_ir()(stage='hlo')\n    self.assertStartsWith(hlo_text, 'HloModule')",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'two_factor_price_xla', 'optimizer_fn': None, 'vol_based_calib': False, 'num_hjm_factors': 2, 'time_step': None, 'num_time_steps': 3, 'use_xla': True, 'use_fd': False, 'max_iter': 4})\ndef test_calibration(self, optimizer_fn, vol_based_calib, num_hjm_factors, time_step, num_time_steps, use_xla, use_fd, max_iter):\n    if False:\n        i = 10\n    'Tests calibration with constant parameters is XLA-compatible.'\n    dtype = tf.float64\n    mr0 = [0.01, 0.05]\n    if num_hjm_factors == 1:\n        mr0 = [0.01]\n    vol0 = [0.005, 0.007]\n    if num_hjm_factors == 1:\n        vol0 = [0.002]\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    times = np.unique(np.reshape(self.expiries, [-1]))\n    curve_times = np.unique(np.reshape(self.fixed_leg_payment_times - np.expand_dims(self.expiries, axis=-1), [-1]))\n    random_type = None\n    seed = 0\n    num_samples = 200\n    valuation_method = tff.models.ValuationMethod.FINITE_DIFFERENCE if use_fd else tff.models.ValuationMethod.MONTE_CARLO\n\n    @tf.function(experimental_compile=True)\n    def _fn():\n        ((calib_mr, calib_vol, calib_corr), _, _) = tff.models.hjm.calibration_from_swaptions(prices=self.prices, expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=num_hjm_factors, mean_reversion=mr0, volatility=vol0, optimizer_fn=optimizer_fn, volatility_based_calibration=vol_based_calib, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=41, maximum_iterations=max_iter, dtype=dtype)\n        return (calib_mr, calib_vol, calib_corr)\n    hlo_text = _fn.experimental_get_compiler_ir()(stage='hlo')\n    self.assertStartsWith(hlo_text, 'HloModule')",
            "@parameterized.named_parameters({'testcase_name': 'two_factor_price_xla', 'optimizer_fn': None, 'vol_based_calib': False, 'num_hjm_factors': 2, 'time_step': None, 'num_time_steps': 3, 'use_xla': True, 'use_fd': False, 'max_iter': 4})\ndef test_calibration(self, optimizer_fn, vol_based_calib, num_hjm_factors, time_step, num_time_steps, use_xla, use_fd, max_iter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests calibration with constant parameters is XLA-compatible.'\n    dtype = tf.float64\n    mr0 = [0.01, 0.05]\n    if num_hjm_factors == 1:\n        mr0 = [0.01]\n    vol0 = [0.005, 0.007]\n    if num_hjm_factors == 1:\n        vol0 = [0.002]\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    times = np.unique(np.reshape(self.expiries, [-1]))\n    curve_times = np.unique(np.reshape(self.fixed_leg_payment_times - np.expand_dims(self.expiries, axis=-1), [-1]))\n    random_type = None\n    seed = 0\n    num_samples = 200\n    valuation_method = tff.models.ValuationMethod.FINITE_DIFFERENCE if use_fd else tff.models.ValuationMethod.MONTE_CARLO\n\n    @tf.function(experimental_compile=True)\n    def _fn():\n        ((calib_mr, calib_vol, calib_corr), _, _) = tff.models.hjm.calibration_from_swaptions(prices=self.prices, expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=num_hjm_factors, mean_reversion=mr0, volatility=vol0, optimizer_fn=optimizer_fn, volatility_based_calibration=vol_based_calib, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=41, maximum_iterations=max_iter, dtype=dtype)\n        return (calib_mr, calib_vol, calib_corr)\n    hlo_text = _fn.experimental_get_compiler_ir()(stage='hlo')\n    self.assertStartsWith(hlo_text, 'HloModule')",
            "@parameterized.named_parameters({'testcase_name': 'two_factor_price_xla', 'optimizer_fn': None, 'vol_based_calib': False, 'num_hjm_factors': 2, 'time_step': None, 'num_time_steps': 3, 'use_xla': True, 'use_fd': False, 'max_iter': 4})\ndef test_calibration(self, optimizer_fn, vol_based_calib, num_hjm_factors, time_step, num_time_steps, use_xla, use_fd, max_iter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests calibration with constant parameters is XLA-compatible.'\n    dtype = tf.float64\n    mr0 = [0.01, 0.05]\n    if num_hjm_factors == 1:\n        mr0 = [0.01]\n    vol0 = [0.005, 0.007]\n    if num_hjm_factors == 1:\n        vol0 = [0.002]\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    times = np.unique(np.reshape(self.expiries, [-1]))\n    curve_times = np.unique(np.reshape(self.fixed_leg_payment_times - np.expand_dims(self.expiries, axis=-1), [-1]))\n    random_type = None\n    seed = 0\n    num_samples = 200\n    valuation_method = tff.models.ValuationMethod.FINITE_DIFFERENCE if use_fd else tff.models.ValuationMethod.MONTE_CARLO\n\n    @tf.function(experimental_compile=True)\n    def _fn():\n        ((calib_mr, calib_vol, calib_corr), _, _) = tff.models.hjm.calibration_from_swaptions(prices=self.prices, expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=num_hjm_factors, mean_reversion=mr0, volatility=vol0, optimizer_fn=optimizer_fn, volatility_based_calibration=vol_based_calib, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=41, maximum_iterations=max_iter, dtype=dtype)\n        return (calib_mr, calib_vol, calib_corr)\n    hlo_text = _fn.experimental_get_compiler_ir()(stage='hlo')\n    self.assertStartsWith(hlo_text, 'HloModule')",
            "@parameterized.named_parameters({'testcase_name': 'two_factor_price_xla', 'optimizer_fn': None, 'vol_based_calib': False, 'num_hjm_factors': 2, 'time_step': None, 'num_time_steps': 3, 'use_xla': True, 'use_fd': False, 'max_iter': 4})\ndef test_calibration(self, optimizer_fn, vol_based_calib, num_hjm_factors, time_step, num_time_steps, use_xla, use_fd, max_iter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests calibration with constant parameters is XLA-compatible.'\n    dtype = tf.float64\n    mr0 = [0.01, 0.05]\n    if num_hjm_factors == 1:\n        mr0 = [0.01]\n    vol0 = [0.005, 0.007]\n    if num_hjm_factors == 1:\n        vol0 = [0.002]\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    times = np.unique(np.reshape(self.expiries, [-1]))\n    curve_times = np.unique(np.reshape(self.fixed_leg_payment_times - np.expand_dims(self.expiries, axis=-1), [-1]))\n    random_type = None\n    seed = 0\n    num_samples = 200\n    valuation_method = tff.models.ValuationMethod.FINITE_DIFFERENCE if use_fd else tff.models.ValuationMethod.MONTE_CARLO\n\n    @tf.function(experimental_compile=True)\n    def _fn():\n        ((calib_mr, calib_vol, calib_corr), _, _) = tff.models.hjm.calibration_from_swaptions(prices=self.prices, expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=num_hjm_factors, mean_reversion=mr0, volatility=vol0, optimizer_fn=optimizer_fn, volatility_based_calibration=vol_based_calib, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=41, maximum_iterations=max_iter, dtype=dtype)\n        return (calib_mr, calib_vol, calib_corr)\n    hlo_text = _fn.experimental_get_compiler_ir()(stage='hlo')\n    self.assertStartsWith(hlo_text, 'HloModule')",
            "@parameterized.named_parameters({'testcase_name': 'two_factor_price_xla', 'optimizer_fn': None, 'vol_based_calib': False, 'num_hjm_factors': 2, 'time_step': None, 'num_time_steps': 3, 'use_xla': True, 'use_fd': False, 'max_iter': 4})\ndef test_calibration(self, optimizer_fn, vol_based_calib, num_hjm_factors, time_step, num_time_steps, use_xla, use_fd, max_iter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests calibration with constant parameters is XLA-compatible.'\n    dtype = tf.float64\n    mr0 = [0.01, 0.05]\n    if num_hjm_factors == 1:\n        mr0 = [0.01]\n    vol0 = [0.005, 0.007]\n    if num_hjm_factors == 1:\n        vol0 = [0.002]\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    times = np.unique(np.reshape(self.expiries, [-1]))\n    curve_times = np.unique(np.reshape(self.fixed_leg_payment_times - np.expand_dims(self.expiries, axis=-1), [-1]))\n    random_type = None\n    seed = 0\n    num_samples = 200\n    valuation_method = tff.models.ValuationMethod.FINITE_DIFFERENCE if use_fd else tff.models.ValuationMethod.MONTE_CARLO\n\n    @tf.function(experimental_compile=True)\n    def _fn():\n        ((calib_mr, calib_vol, calib_corr), _, _) = tff.models.hjm.calibration_from_swaptions(prices=self.prices, expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=num_hjm_factors, mean_reversion=mr0, volatility=vol0, optimizer_fn=optimizer_fn, volatility_based_calibration=vol_based_calib, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=41, maximum_iterations=max_iter, dtype=dtype)\n        return (calib_mr, calib_vol, calib_corr)\n    hlo_text = _fn.experimental_get_compiler_ir()(stage='hlo')\n    self.assertStartsWith(hlo_text, 'HloModule')"
        ]
    }
]