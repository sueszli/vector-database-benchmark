[
    {
        "func_name": "trophic_levels",
        "original": "@not_implemented_for('undirected')\n@nx._dispatch(edge_attrs='weight')\ndef trophic_levels(G, weight='weight'):\n    \"\"\"Compute the trophic levels of nodes.\n\n    The trophic level of a node $i$ is\n\n    .. math::\n\n        s_i = 1 + \\\\frac{1}{k^{in}_i} \\\\sum_{j} a_{ij} s_j\n\n    where $k^{in}_i$ is the in-degree of i\n\n    .. math::\n\n        k^{in}_i = \\\\sum_{j} a_{ij}\n\n    and nodes with $k^{in}_i = 0$ have $s_i = 1$ by convention.\n\n    These are calculated using the method outlined in Levine [1]_.\n\n    Parameters\n    ----------\n    G : DiGraph\n        A directed networkx graph\n\n    Returns\n    -------\n    nodes : dict\n        Dictionary of nodes with trophic level as the value.\n\n    References\n    ----------\n    .. [1] Stephen Levine (1980) J. theor. Biol. 83, 195-207\n    \"\"\"\n    import numpy as np\n    a = nx.adjacency_matrix(G, weight=weight).T.toarray()\n    rowsum = np.sum(a, axis=1)\n    p = a[rowsum != 0][:, rowsum != 0]\n    p = p / rowsum[rowsum != 0][:, np.newaxis]\n    nn = p.shape[0]\n    i = np.eye(nn)\n    try:\n        n = np.linalg.inv(i - p)\n    except np.linalg.LinAlgError as err:\n        msg = 'Trophic levels are only defined for graphs where every ' + 'node has a path from a basal node (basal nodes are nodes ' + 'with no incoming edges).'\n        raise nx.NetworkXError(msg) from err\n    y = n.sum(axis=1) + 1\n    levels = {}\n    zero_node_ids = (node_id for (node_id, degree) in G.in_degree if degree == 0)\n    for node_id in zero_node_ids:\n        levels[node_id] = 1\n    nonzero_node_ids = (node_id for (node_id, degree) in G.in_degree if degree != 0)\n    for (i, node_id) in enumerate(nonzero_node_ids):\n        levels[node_id] = y[i]\n    return levels",
        "mutated": [
            "@not_implemented_for('undirected')\n@nx._dispatch(edge_attrs='weight')\ndef trophic_levels(G, weight='weight'):\n    if False:\n        i = 10\n    'Compute the trophic levels of nodes.\\n\\n    The trophic level of a node $i$ is\\n\\n    .. math::\\n\\n        s_i = 1 + \\\\frac{1}{k^{in}_i} \\\\sum_{j} a_{ij} s_j\\n\\n    where $k^{in}_i$ is the in-degree of i\\n\\n    .. math::\\n\\n        k^{in}_i = \\\\sum_{j} a_{ij}\\n\\n    and nodes with $k^{in}_i = 0$ have $s_i = 1$ by convention.\\n\\n    These are calculated using the method outlined in Levine [1]_.\\n\\n    Parameters\\n    ----------\\n    G : DiGraph\\n        A directed networkx graph\\n\\n    Returns\\n    -------\\n    nodes : dict\\n        Dictionary of nodes with trophic level as the value.\\n\\n    References\\n    ----------\\n    .. [1] Stephen Levine (1980) J. theor. Biol. 83, 195-207\\n    '\n    import numpy as np\n    a = nx.adjacency_matrix(G, weight=weight).T.toarray()\n    rowsum = np.sum(a, axis=1)\n    p = a[rowsum != 0][:, rowsum != 0]\n    p = p / rowsum[rowsum != 0][:, np.newaxis]\n    nn = p.shape[0]\n    i = np.eye(nn)\n    try:\n        n = np.linalg.inv(i - p)\n    except np.linalg.LinAlgError as err:\n        msg = 'Trophic levels are only defined for graphs where every ' + 'node has a path from a basal node (basal nodes are nodes ' + 'with no incoming edges).'\n        raise nx.NetworkXError(msg) from err\n    y = n.sum(axis=1) + 1\n    levels = {}\n    zero_node_ids = (node_id for (node_id, degree) in G.in_degree if degree == 0)\n    for node_id in zero_node_ids:\n        levels[node_id] = 1\n    nonzero_node_ids = (node_id for (node_id, degree) in G.in_degree if degree != 0)\n    for (i, node_id) in enumerate(nonzero_node_ids):\n        levels[node_id] = y[i]\n    return levels",
            "@not_implemented_for('undirected')\n@nx._dispatch(edge_attrs='weight')\ndef trophic_levels(G, weight='weight'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute the trophic levels of nodes.\\n\\n    The trophic level of a node $i$ is\\n\\n    .. math::\\n\\n        s_i = 1 + \\\\frac{1}{k^{in}_i} \\\\sum_{j} a_{ij} s_j\\n\\n    where $k^{in}_i$ is the in-degree of i\\n\\n    .. math::\\n\\n        k^{in}_i = \\\\sum_{j} a_{ij}\\n\\n    and nodes with $k^{in}_i = 0$ have $s_i = 1$ by convention.\\n\\n    These are calculated using the method outlined in Levine [1]_.\\n\\n    Parameters\\n    ----------\\n    G : DiGraph\\n        A directed networkx graph\\n\\n    Returns\\n    -------\\n    nodes : dict\\n        Dictionary of nodes with trophic level as the value.\\n\\n    References\\n    ----------\\n    .. [1] Stephen Levine (1980) J. theor. Biol. 83, 195-207\\n    '\n    import numpy as np\n    a = nx.adjacency_matrix(G, weight=weight).T.toarray()\n    rowsum = np.sum(a, axis=1)\n    p = a[rowsum != 0][:, rowsum != 0]\n    p = p / rowsum[rowsum != 0][:, np.newaxis]\n    nn = p.shape[0]\n    i = np.eye(nn)\n    try:\n        n = np.linalg.inv(i - p)\n    except np.linalg.LinAlgError as err:\n        msg = 'Trophic levels are only defined for graphs where every ' + 'node has a path from a basal node (basal nodes are nodes ' + 'with no incoming edges).'\n        raise nx.NetworkXError(msg) from err\n    y = n.sum(axis=1) + 1\n    levels = {}\n    zero_node_ids = (node_id for (node_id, degree) in G.in_degree if degree == 0)\n    for node_id in zero_node_ids:\n        levels[node_id] = 1\n    nonzero_node_ids = (node_id for (node_id, degree) in G.in_degree if degree != 0)\n    for (i, node_id) in enumerate(nonzero_node_ids):\n        levels[node_id] = y[i]\n    return levels",
            "@not_implemented_for('undirected')\n@nx._dispatch(edge_attrs='weight')\ndef trophic_levels(G, weight='weight'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute the trophic levels of nodes.\\n\\n    The trophic level of a node $i$ is\\n\\n    .. math::\\n\\n        s_i = 1 + \\\\frac{1}{k^{in}_i} \\\\sum_{j} a_{ij} s_j\\n\\n    where $k^{in}_i$ is the in-degree of i\\n\\n    .. math::\\n\\n        k^{in}_i = \\\\sum_{j} a_{ij}\\n\\n    and nodes with $k^{in}_i = 0$ have $s_i = 1$ by convention.\\n\\n    These are calculated using the method outlined in Levine [1]_.\\n\\n    Parameters\\n    ----------\\n    G : DiGraph\\n        A directed networkx graph\\n\\n    Returns\\n    -------\\n    nodes : dict\\n        Dictionary of nodes with trophic level as the value.\\n\\n    References\\n    ----------\\n    .. [1] Stephen Levine (1980) J. theor. Biol. 83, 195-207\\n    '\n    import numpy as np\n    a = nx.adjacency_matrix(G, weight=weight).T.toarray()\n    rowsum = np.sum(a, axis=1)\n    p = a[rowsum != 0][:, rowsum != 0]\n    p = p / rowsum[rowsum != 0][:, np.newaxis]\n    nn = p.shape[0]\n    i = np.eye(nn)\n    try:\n        n = np.linalg.inv(i - p)\n    except np.linalg.LinAlgError as err:\n        msg = 'Trophic levels are only defined for graphs where every ' + 'node has a path from a basal node (basal nodes are nodes ' + 'with no incoming edges).'\n        raise nx.NetworkXError(msg) from err\n    y = n.sum(axis=1) + 1\n    levels = {}\n    zero_node_ids = (node_id for (node_id, degree) in G.in_degree if degree == 0)\n    for node_id in zero_node_ids:\n        levels[node_id] = 1\n    nonzero_node_ids = (node_id for (node_id, degree) in G.in_degree if degree != 0)\n    for (i, node_id) in enumerate(nonzero_node_ids):\n        levels[node_id] = y[i]\n    return levels",
            "@not_implemented_for('undirected')\n@nx._dispatch(edge_attrs='weight')\ndef trophic_levels(G, weight='weight'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute the trophic levels of nodes.\\n\\n    The trophic level of a node $i$ is\\n\\n    .. math::\\n\\n        s_i = 1 + \\\\frac{1}{k^{in}_i} \\\\sum_{j} a_{ij} s_j\\n\\n    where $k^{in}_i$ is the in-degree of i\\n\\n    .. math::\\n\\n        k^{in}_i = \\\\sum_{j} a_{ij}\\n\\n    and nodes with $k^{in}_i = 0$ have $s_i = 1$ by convention.\\n\\n    These are calculated using the method outlined in Levine [1]_.\\n\\n    Parameters\\n    ----------\\n    G : DiGraph\\n        A directed networkx graph\\n\\n    Returns\\n    -------\\n    nodes : dict\\n        Dictionary of nodes with trophic level as the value.\\n\\n    References\\n    ----------\\n    .. [1] Stephen Levine (1980) J. theor. Biol. 83, 195-207\\n    '\n    import numpy as np\n    a = nx.adjacency_matrix(G, weight=weight).T.toarray()\n    rowsum = np.sum(a, axis=1)\n    p = a[rowsum != 0][:, rowsum != 0]\n    p = p / rowsum[rowsum != 0][:, np.newaxis]\n    nn = p.shape[0]\n    i = np.eye(nn)\n    try:\n        n = np.linalg.inv(i - p)\n    except np.linalg.LinAlgError as err:\n        msg = 'Trophic levels are only defined for graphs where every ' + 'node has a path from a basal node (basal nodes are nodes ' + 'with no incoming edges).'\n        raise nx.NetworkXError(msg) from err\n    y = n.sum(axis=1) + 1\n    levels = {}\n    zero_node_ids = (node_id for (node_id, degree) in G.in_degree if degree == 0)\n    for node_id in zero_node_ids:\n        levels[node_id] = 1\n    nonzero_node_ids = (node_id for (node_id, degree) in G.in_degree if degree != 0)\n    for (i, node_id) in enumerate(nonzero_node_ids):\n        levels[node_id] = y[i]\n    return levels",
            "@not_implemented_for('undirected')\n@nx._dispatch(edge_attrs='weight')\ndef trophic_levels(G, weight='weight'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute the trophic levels of nodes.\\n\\n    The trophic level of a node $i$ is\\n\\n    .. math::\\n\\n        s_i = 1 + \\\\frac{1}{k^{in}_i} \\\\sum_{j} a_{ij} s_j\\n\\n    where $k^{in}_i$ is the in-degree of i\\n\\n    .. math::\\n\\n        k^{in}_i = \\\\sum_{j} a_{ij}\\n\\n    and nodes with $k^{in}_i = 0$ have $s_i = 1$ by convention.\\n\\n    These are calculated using the method outlined in Levine [1]_.\\n\\n    Parameters\\n    ----------\\n    G : DiGraph\\n        A directed networkx graph\\n\\n    Returns\\n    -------\\n    nodes : dict\\n        Dictionary of nodes with trophic level as the value.\\n\\n    References\\n    ----------\\n    .. [1] Stephen Levine (1980) J. theor. Biol. 83, 195-207\\n    '\n    import numpy as np\n    a = nx.adjacency_matrix(G, weight=weight).T.toarray()\n    rowsum = np.sum(a, axis=1)\n    p = a[rowsum != 0][:, rowsum != 0]\n    p = p / rowsum[rowsum != 0][:, np.newaxis]\n    nn = p.shape[0]\n    i = np.eye(nn)\n    try:\n        n = np.linalg.inv(i - p)\n    except np.linalg.LinAlgError as err:\n        msg = 'Trophic levels are only defined for graphs where every ' + 'node has a path from a basal node (basal nodes are nodes ' + 'with no incoming edges).'\n        raise nx.NetworkXError(msg) from err\n    y = n.sum(axis=1) + 1\n    levels = {}\n    zero_node_ids = (node_id for (node_id, degree) in G.in_degree if degree == 0)\n    for node_id in zero_node_ids:\n        levels[node_id] = 1\n    nonzero_node_ids = (node_id for (node_id, degree) in G.in_degree if degree != 0)\n    for (i, node_id) in enumerate(nonzero_node_ids):\n        levels[node_id] = y[i]\n    return levels"
        ]
    },
    {
        "func_name": "trophic_differences",
        "original": "@not_implemented_for('undirected')\n@nx._dispatch(edge_attrs='weight')\ndef trophic_differences(G, weight='weight'):\n    \"\"\"Compute the trophic differences of the edges of a directed graph.\n\n    The trophic difference $x_ij$ for each edge is defined in Johnson et al.\n    [1]_ as:\n\n    .. math::\n        x_ij = s_j - s_i\n\n    Where $s_i$ is the trophic level of node $i$.\n\n    Parameters\n    ----------\n    G : DiGraph\n        A directed networkx graph\n\n    Returns\n    -------\n    diffs : dict\n        Dictionary of edges with trophic differences as the value.\n\n    References\n    ----------\n    .. [1] Samuel Johnson, Virginia Dominguez-Garcia, Luca Donetti, Miguel A.\n        Munoz (2014) PNAS \"Trophic coherence determines food-web stability\"\n    \"\"\"\n    levels = trophic_levels(G, weight=weight)\n    diffs = {}\n    for (u, v) in G.edges:\n        diffs[u, v] = levels[v] - levels[u]\n    return diffs",
        "mutated": [
            "@not_implemented_for('undirected')\n@nx._dispatch(edge_attrs='weight')\ndef trophic_differences(G, weight='weight'):\n    if False:\n        i = 10\n    'Compute the trophic differences of the edges of a directed graph.\\n\\n    The trophic difference $x_ij$ for each edge is defined in Johnson et al.\\n    [1]_ as:\\n\\n    .. math::\\n        x_ij = s_j - s_i\\n\\n    Where $s_i$ is the trophic level of node $i$.\\n\\n    Parameters\\n    ----------\\n    G : DiGraph\\n        A directed networkx graph\\n\\n    Returns\\n    -------\\n    diffs : dict\\n        Dictionary of edges with trophic differences as the value.\\n\\n    References\\n    ----------\\n    .. [1] Samuel Johnson, Virginia Dominguez-Garcia, Luca Donetti, Miguel A.\\n        Munoz (2014) PNAS \"Trophic coherence determines food-web stability\"\\n    '\n    levels = trophic_levels(G, weight=weight)\n    diffs = {}\n    for (u, v) in G.edges:\n        diffs[u, v] = levels[v] - levels[u]\n    return diffs",
            "@not_implemented_for('undirected')\n@nx._dispatch(edge_attrs='weight')\ndef trophic_differences(G, weight='weight'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute the trophic differences of the edges of a directed graph.\\n\\n    The trophic difference $x_ij$ for each edge is defined in Johnson et al.\\n    [1]_ as:\\n\\n    .. math::\\n        x_ij = s_j - s_i\\n\\n    Where $s_i$ is the trophic level of node $i$.\\n\\n    Parameters\\n    ----------\\n    G : DiGraph\\n        A directed networkx graph\\n\\n    Returns\\n    -------\\n    diffs : dict\\n        Dictionary of edges with trophic differences as the value.\\n\\n    References\\n    ----------\\n    .. [1] Samuel Johnson, Virginia Dominguez-Garcia, Luca Donetti, Miguel A.\\n        Munoz (2014) PNAS \"Trophic coherence determines food-web stability\"\\n    '\n    levels = trophic_levels(G, weight=weight)\n    diffs = {}\n    for (u, v) in G.edges:\n        diffs[u, v] = levels[v] - levels[u]\n    return diffs",
            "@not_implemented_for('undirected')\n@nx._dispatch(edge_attrs='weight')\ndef trophic_differences(G, weight='weight'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute the trophic differences of the edges of a directed graph.\\n\\n    The trophic difference $x_ij$ for each edge is defined in Johnson et al.\\n    [1]_ as:\\n\\n    .. math::\\n        x_ij = s_j - s_i\\n\\n    Where $s_i$ is the trophic level of node $i$.\\n\\n    Parameters\\n    ----------\\n    G : DiGraph\\n        A directed networkx graph\\n\\n    Returns\\n    -------\\n    diffs : dict\\n        Dictionary of edges with trophic differences as the value.\\n\\n    References\\n    ----------\\n    .. [1] Samuel Johnson, Virginia Dominguez-Garcia, Luca Donetti, Miguel A.\\n        Munoz (2014) PNAS \"Trophic coherence determines food-web stability\"\\n    '\n    levels = trophic_levels(G, weight=weight)\n    diffs = {}\n    for (u, v) in G.edges:\n        diffs[u, v] = levels[v] - levels[u]\n    return diffs",
            "@not_implemented_for('undirected')\n@nx._dispatch(edge_attrs='weight')\ndef trophic_differences(G, weight='weight'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute the trophic differences of the edges of a directed graph.\\n\\n    The trophic difference $x_ij$ for each edge is defined in Johnson et al.\\n    [1]_ as:\\n\\n    .. math::\\n        x_ij = s_j - s_i\\n\\n    Where $s_i$ is the trophic level of node $i$.\\n\\n    Parameters\\n    ----------\\n    G : DiGraph\\n        A directed networkx graph\\n\\n    Returns\\n    -------\\n    diffs : dict\\n        Dictionary of edges with trophic differences as the value.\\n\\n    References\\n    ----------\\n    .. [1] Samuel Johnson, Virginia Dominguez-Garcia, Luca Donetti, Miguel A.\\n        Munoz (2014) PNAS \"Trophic coherence determines food-web stability\"\\n    '\n    levels = trophic_levels(G, weight=weight)\n    diffs = {}\n    for (u, v) in G.edges:\n        diffs[u, v] = levels[v] - levels[u]\n    return diffs",
            "@not_implemented_for('undirected')\n@nx._dispatch(edge_attrs='weight')\ndef trophic_differences(G, weight='weight'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute the trophic differences of the edges of a directed graph.\\n\\n    The trophic difference $x_ij$ for each edge is defined in Johnson et al.\\n    [1]_ as:\\n\\n    .. math::\\n        x_ij = s_j - s_i\\n\\n    Where $s_i$ is the trophic level of node $i$.\\n\\n    Parameters\\n    ----------\\n    G : DiGraph\\n        A directed networkx graph\\n\\n    Returns\\n    -------\\n    diffs : dict\\n        Dictionary of edges with trophic differences as the value.\\n\\n    References\\n    ----------\\n    .. [1] Samuel Johnson, Virginia Dominguez-Garcia, Luca Donetti, Miguel A.\\n        Munoz (2014) PNAS \"Trophic coherence determines food-web stability\"\\n    '\n    levels = trophic_levels(G, weight=weight)\n    diffs = {}\n    for (u, v) in G.edges:\n        diffs[u, v] = levels[v] - levels[u]\n    return diffs"
        ]
    },
    {
        "func_name": "trophic_incoherence_parameter",
        "original": "@not_implemented_for('undirected')\n@nx._dispatch(edge_attrs='weight')\ndef trophic_incoherence_parameter(G, weight='weight', cannibalism=False):\n    \"\"\"Compute the trophic incoherence parameter of a graph.\n\n    Trophic coherence is defined as the homogeneity of the distribution of\n    trophic distances: the more similar, the more coherent. This is measured by\n    the standard deviation of the trophic differences and referred to as the\n    trophic incoherence parameter $q$ by [1].\n\n    Parameters\n    ----------\n    G : DiGraph\n        A directed networkx graph\n\n    cannibalism: Boolean\n        If set to False, self edges are not considered in the calculation\n\n    Returns\n    -------\n    trophic_incoherence_parameter : float\n        The trophic coherence of a graph\n\n    References\n    ----------\n    .. [1] Samuel Johnson, Virginia Dominguez-Garcia, Luca Donetti, Miguel A.\n        Munoz (2014) PNAS \"Trophic coherence determines food-web stability\"\n    \"\"\"\n    import numpy as np\n    if cannibalism:\n        diffs = trophic_differences(G, weight=weight)\n    else:\n        self_loops = list(nx.selfloop_edges(G))\n        if self_loops:\n            G_2 = G.copy()\n            G_2.remove_edges_from(self_loops)\n        else:\n            G_2 = G\n        diffs = trophic_differences(G_2, weight=weight)\n    return np.std(list(diffs.values()))",
        "mutated": [
            "@not_implemented_for('undirected')\n@nx._dispatch(edge_attrs='weight')\ndef trophic_incoherence_parameter(G, weight='weight', cannibalism=False):\n    if False:\n        i = 10\n    'Compute the trophic incoherence parameter of a graph.\\n\\n    Trophic coherence is defined as the homogeneity of the distribution of\\n    trophic distances: the more similar, the more coherent. This is measured by\\n    the standard deviation of the trophic differences and referred to as the\\n    trophic incoherence parameter $q$ by [1].\\n\\n    Parameters\\n    ----------\\n    G : DiGraph\\n        A directed networkx graph\\n\\n    cannibalism: Boolean\\n        If set to False, self edges are not considered in the calculation\\n\\n    Returns\\n    -------\\n    trophic_incoherence_parameter : float\\n        The trophic coherence of a graph\\n\\n    References\\n    ----------\\n    .. [1] Samuel Johnson, Virginia Dominguez-Garcia, Luca Donetti, Miguel A.\\n        Munoz (2014) PNAS \"Trophic coherence determines food-web stability\"\\n    '\n    import numpy as np\n    if cannibalism:\n        diffs = trophic_differences(G, weight=weight)\n    else:\n        self_loops = list(nx.selfloop_edges(G))\n        if self_loops:\n            G_2 = G.copy()\n            G_2.remove_edges_from(self_loops)\n        else:\n            G_2 = G\n        diffs = trophic_differences(G_2, weight=weight)\n    return np.std(list(diffs.values()))",
            "@not_implemented_for('undirected')\n@nx._dispatch(edge_attrs='weight')\ndef trophic_incoherence_parameter(G, weight='weight', cannibalism=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute the trophic incoherence parameter of a graph.\\n\\n    Trophic coherence is defined as the homogeneity of the distribution of\\n    trophic distances: the more similar, the more coherent. This is measured by\\n    the standard deviation of the trophic differences and referred to as the\\n    trophic incoherence parameter $q$ by [1].\\n\\n    Parameters\\n    ----------\\n    G : DiGraph\\n        A directed networkx graph\\n\\n    cannibalism: Boolean\\n        If set to False, self edges are not considered in the calculation\\n\\n    Returns\\n    -------\\n    trophic_incoherence_parameter : float\\n        The trophic coherence of a graph\\n\\n    References\\n    ----------\\n    .. [1] Samuel Johnson, Virginia Dominguez-Garcia, Luca Donetti, Miguel A.\\n        Munoz (2014) PNAS \"Trophic coherence determines food-web stability\"\\n    '\n    import numpy as np\n    if cannibalism:\n        diffs = trophic_differences(G, weight=weight)\n    else:\n        self_loops = list(nx.selfloop_edges(G))\n        if self_loops:\n            G_2 = G.copy()\n            G_2.remove_edges_from(self_loops)\n        else:\n            G_2 = G\n        diffs = trophic_differences(G_2, weight=weight)\n    return np.std(list(diffs.values()))",
            "@not_implemented_for('undirected')\n@nx._dispatch(edge_attrs='weight')\ndef trophic_incoherence_parameter(G, weight='weight', cannibalism=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute the trophic incoherence parameter of a graph.\\n\\n    Trophic coherence is defined as the homogeneity of the distribution of\\n    trophic distances: the more similar, the more coherent. This is measured by\\n    the standard deviation of the trophic differences and referred to as the\\n    trophic incoherence parameter $q$ by [1].\\n\\n    Parameters\\n    ----------\\n    G : DiGraph\\n        A directed networkx graph\\n\\n    cannibalism: Boolean\\n        If set to False, self edges are not considered in the calculation\\n\\n    Returns\\n    -------\\n    trophic_incoherence_parameter : float\\n        The trophic coherence of a graph\\n\\n    References\\n    ----------\\n    .. [1] Samuel Johnson, Virginia Dominguez-Garcia, Luca Donetti, Miguel A.\\n        Munoz (2014) PNAS \"Trophic coherence determines food-web stability\"\\n    '\n    import numpy as np\n    if cannibalism:\n        diffs = trophic_differences(G, weight=weight)\n    else:\n        self_loops = list(nx.selfloop_edges(G))\n        if self_loops:\n            G_2 = G.copy()\n            G_2.remove_edges_from(self_loops)\n        else:\n            G_2 = G\n        diffs = trophic_differences(G_2, weight=weight)\n    return np.std(list(diffs.values()))",
            "@not_implemented_for('undirected')\n@nx._dispatch(edge_attrs='weight')\ndef trophic_incoherence_parameter(G, weight='weight', cannibalism=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute the trophic incoherence parameter of a graph.\\n\\n    Trophic coherence is defined as the homogeneity of the distribution of\\n    trophic distances: the more similar, the more coherent. This is measured by\\n    the standard deviation of the trophic differences and referred to as the\\n    trophic incoherence parameter $q$ by [1].\\n\\n    Parameters\\n    ----------\\n    G : DiGraph\\n        A directed networkx graph\\n\\n    cannibalism: Boolean\\n        If set to False, self edges are not considered in the calculation\\n\\n    Returns\\n    -------\\n    trophic_incoherence_parameter : float\\n        The trophic coherence of a graph\\n\\n    References\\n    ----------\\n    .. [1] Samuel Johnson, Virginia Dominguez-Garcia, Luca Donetti, Miguel A.\\n        Munoz (2014) PNAS \"Trophic coherence determines food-web stability\"\\n    '\n    import numpy as np\n    if cannibalism:\n        diffs = trophic_differences(G, weight=weight)\n    else:\n        self_loops = list(nx.selfloop_edges(G))\n        if self_loops:\n            G_2 = G.copy()\n            G_2.remove_edges_from(self_loops)\n        else:\n            G_2 = G\n        diffs = trophic_differences(G_2, weight=weight)\n    return np.std(list(diffs.values()))",
            "@not_implemented_for('undirected')\n@nx._dispatch(edge_attrs='weight')\ndef trophic_incoherence_parameter(G, weight='weight', cannibalism=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute the trophic incoherence parameter of a graph.\\n\\n    Trophic coherence is defined as the homogeneity of the distribution of\\n    trophic distances: the more similar, the more coherent. This is measured by\\n    the standard deviation of the trophic differences and referred to as the\\n    trophic incoherence parameter $q$ by [1].\\n\\n    Parameters\\n    ----------\\n    G : DiGraph\\n        A directed networkx graph\\n\\n    cannibalism: Boolean\\n        If set to False, self edges are not considered in the calculation\\n\\n    Returns\\n    -------\\n    trophic_incoherence_parameter : float\\n        The trophic coherence of a graph\\n\\n    References\\n    ----------\\n    .. [1] Samuel Johnson, Virginia Dominguez-Garcia, Luca Donetti, Miguel A.\\n        Munoz (2014) PNAS \"Trophic coherence determines food-web stability\"\\n    '\n    import numpy as np\n    if cannibalism:\n        diffs = trophic_differences(G, weight=weight)\n    else:\n        self_loops = list(nx.selfloop_edges(G))\n        if self_loops:\n            G_2 = G.copy()\n            G_2.remove_edges_from(self_loops)\n        else:\n            G_2 = G\n        diffs = trophic_differences(G_2, weight=weight)\n    return np.std(list(diffs.values()))"
        ]
    }
]