[
    {
        "func_name": "__init__",
        "original": "def __init__(self, probe_radius=1.4, n_points=100, radii_dict=None):\n    \"\"\"Initialize the class.\n\n        :param probe_radius: radius of the probe in A. Default is 1.40, roughly\n            the radius of a water molecule.\n        :type probe_radius: float\n\n        :param n_points: resolution of the surface of each atom. Default is 100.\n            A higher number of points results in more precise measurements, but\n            slows down the calculation.\n        :type n_points: int\n\n        :param radii_dict: user-provided dictionary of atomic radii to use in\n            the calculation. Values will replace/complement those in the\n            default ATOMIC_RADII dictionary.\n        :type radii_dict: dict\n\n        >>> sr = ShrakeRupley()\n        >>> sr = ShrakeRupley(n_points=960)\n        >>> sr = ShrakeRupley(radii_dict={\"O\": 3.1415})\n        \"\"\"\n    if probe_radius <= 0.0:\n        raise ValueError(f'Probe radius must be a positive number: {probe_radius} <= 0')\n    self.probe_radius = float(probe_radius)\n    if n_points < 1:\n        raise ValueError(f'Number of sphere points must be larger than 1: {n_points}')\n    self.n_points = n_points\n    self.radii_dict = ATOMIC_RADII.copy()\n    if radii_dict is not None:\n        self.radii_dict.update(radii_dict)\n    self._sphere = self._compute_sphere()",
        "mutated": [
            "def __init__(self, probe_radius=1.4, n_points=100, radii_dict=None):\n    if False:\n        i = 10\n    'Initialize the class.\\n\\n        :param probe_radius: radius of the probe in A. Default is 1.40, roughly\\n            the radius of a water molecule.\\n        :type probe_radius: float\\n\\n        :param n_points: resolution of the surface of each atom. Default is 100.\\n            A higher number of points results in more precise measurements, but\\n            slows down the calculation.\\n        :type n_points: int\\n\\n        :param radii_dict: user-provided dictionary of atomic radii to use in\\n            the calculation. Values will replace/complement those in the\\n            default ATOMIC_RADII dictionary.\\n        :type radii_dict: dict\\n\\n        >>> sr = ShrakeRupley()\\n        >>> sr = ShrakeRupley(n_points=960)\\n        >>> sr = ShrakeRupley(radii_dict={\"O\": 3.1415})\\n        '\n    if probe_radius <= 0.0:\n        raise ValueError(f'Probe radius must be a positive number: {probe_radius} <= 0')\n    self.probe_radius = float(probe_radius)\n    if n_points < 1:\n        raise ValueError(f'Number of sphere points must be larger than 1: {n_points}')\n    self.n_points = n_points\n    self.radii_dict = ATOMIC_RADII.copy()\n    if radii_dict is not None:\n        self.radii_dict.update(radii_dict)\n    self._sphere = self._compute_sphere()",
            "def __init__(self, probe_radius=1.4, n_points=100, radii_dict=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Initialize the class.\\n\\n        :param probe_radius: radius of the probe in A. Default is 1.40, roughly\\n            the radius of a water molecule.\\n        :type probe_radius: float\\n\\n        :param n_points: resolution of the surface of each atom. Default is 100.\\n            A higher number of points results in more precise measurements, but\\n            slows down the calculation.\\n        :type n_points: int\\n\\n        :param radii_dict: user-provided dictionary of atomic radii to use in\\n            the calculation. Values will replace/complement those in the\\n            default ATOMIC_RADII dictionary.\\n        :type radii_dict: dict\\n\\n        >>> sr = ShrakeRupley()\\n        >>> sr = ShrakeRupley(n_points=960)\\n        >>> sr = ShrakeRupley(radii_dict={\"O\": 3.1415})\\n        '\n    if probe_radius <= 0.0:\n        raise ValueError(f'Probe radius must be a positive number: {probe_radius} <= 0')\n    self.probe_radius = float(probe_radius)\n    if n_points < 1:\n        raise ValueError(f'Number of sphere points must be larger than 1: {n_points}')\n    self.n_points = n_points\n    self.radii_dict = ATOMIC_RADII.copy()\n    if radii_dict is not None:\n        self.radii_dict.update(radii_dict)\n    self._sphere = self._compute_sphere()",
            "def __init__(self, probe_radius=1.4, n_points=100, radii_dict=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Initialize the class.\\n\\n        :param probe_radius: radius of the probe in A. Default is 1.40, roughly\\n            the radius of a water molecule.\\n        :type probe_radius: float\\n\\n        :param n_points: resolution of the surface of each atom. Default is 100.\\n            A higher number of points results in more precise measurements, but\\n            slows down the calculation.\\n        :type n_points: int\\n\\n        :param radii_dict: user-provided dictionary of atomic radii to use in\\n            the calculation. Values will replace/complement those in the\\n            default ATOMIC_RADII dictionary.\\n        :type radii_dict: dict\\n\\n        >>> sr = ShrakeRupley()\\n        >>> sr = ShrakeRupley(n_points=960)\\n        >>> sr = ShrakeRupley(radii_dict={\"O\": 3.1415})\\n        '\n    if probe_radius <= 0.0:\n        raise ValueError(f'Probe radius must be a positive number: {probe_radius} <= 0')\n    self.probe_radius = float(probe_radius)\n    if n_points < 1:\n        raise ValueError(f'Number of sphere points must be larger than 1: {n_points}')\n    self.n_points = n_points\n    self.radii_dict = ATOMIC_RADII.copy()\n    if radii_dict is not None:\n        self.radii_dict.update(radii_dict)\n    self._sphere = self._compute_sphere()",
            "def __init__(self, probe_radius=1.4, n_points=100, radii_dict=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Initialize the class.\\n\\n        :param probe_radius: radius of the probe in A. Default is 1.40, roughly\\n            the radius of a water molecule.\\n        :type probe_radius: float\\n\\n        :param n_points: resolution of the surface of each atom. Default is 100.\\n            A higher number of points results in more precise measurements, but\\n            slows down the calculation.\\n        :type n_points: int\\n\\n        :param radii_dict: user-provided dictionary of atomic radii to use in\\n            the calculation. Values will replace/complement those in the\\n            default ATOMIC_RADII dictionary.\\n        :type radii_dict: dict\\n\\n        >>> sr = ShrakeRupley()\\n        >>> sr = ShrakeRupley(n_points=960)\\n        >>> sr = ShrakeRupley(radii_dict={\"O\": 3.1415})\\n        '\n    if probe_radius <= 0.0:\n        raise ValueError(f'Probe radius must be a positive number: {probe_radius} <= 0')\n    self.probe_radius = float(probe_radius)\n    if n_points < 1:\n        raise ValueError(f'Number of sphere points must be larger than 1: {n_points}')\n    self.n_points = n_points\n    self.radii_dict = ATOMIC_RADII.copy()\n    if radii_dict is not None:\n        self.radii_dict.update(radii_dict)\n    self._sphere = self._compute_sphere()",
            "def __init__(self, probe_radius=1.4, n_points=100, radii_dict=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Initialize the class.\\n\\n        :param probe_radius: radius of the probe in A. Default is 1.40, roughly\\n            the radius of a water molecule.\\n        :type probe_radius: float\\n\\n        :param n_points: resolution of the surface of each atom. Default is 100.\\n            A higher number of points results in more precise measurements, but\\n            slows down the calculation.\\n        :type n_points: int\\n\\n        :param radii_dict: user-provided dictionary of atomic radii to use in\\n            the calculation. Values will replace/complement those in the\\n            default ATOMIC_RADII dictionary.\\n        :type radii_dict: dict\\n\\n        >>> sr = ShrakeRupley()\\n        >>> sr = ShrakeRupley(n_points=960)\\n        >>> sr = ShrakeRupley(radii_dict={\"O\": 3.1415})\\n        '\n    if probe_radius <= 0.0:\n        raise ValueError(f'Probe radius must be a positive number: {probe_radius} <= 0')\n    self.probe_radius = float(probe_radius)\n    if n_points < 1:\n        raise ValueError(f'Number of sphere points must be larger than 1: {n_points}')\n    self.n_points = n_points\n    self.radii_dict = ATOMIC_RADII.copy()\n    if radii_dict is not None:\n        self.radii_dict.update(radii_dict)\n    self._sphere = self._compute_sphere()"
        ]
    },
    {
        "func_name": "_compute_sphere",
        "original": "def _compute_sphere(self):\n    \"\"\"Return the 3D coordinates of n points on a sphere.\n\n        Uses the golden spiral algorithm to place points 'evenly' on the sphere\n        surface. We compute this once and then move the sphere to the centroid\n        of each atom as we compute the ASAs.\n        \"\"\"\n    n = self.n_points\n    dl = np.pi * (3 - 5 ** 0.5)\n    dz = 2.0 / n\n    longitude = 0\n    z = 1 - dz / 2\n    coords = np.zeros((n, 3), dtype=np.float32)\n    for k in range(n):\n        r = (1 - z * z) ** 0.5\n        coords[k, 0] = math.cos(longitude) * r\n        coords[k, 1] = math.sin(longitude) * r\n        coords[k, 2] = z\n        z -= dz\n        longitude += dl\n    return coords",
        "mutated": [
            "def _compute_sphere(self):\n    if False:\n        i = 10\n    \"Return the 3D coordinates of n points on a sphere.\\n\\n        Uses the golden spiral algorithm to place points 'evenly' on the sphere\\n        surface. We compute this once and then move the sphere to the centroid\\n        of each atom as we compute the ASAs.\\n        \"\n    n = self.n_points\n    dl = np.pi * (3 - 5 ** 0.5)\n    dz = 2.0 / n\n    longitude = 0\n    z = 1 - dz / 2\n    coords = np.zeros((n, 3), dtype=np.float32)\n    for k in range(n):\n        r = (1 - z * z) ** 0.5\n        coords[k, 0] = math.cos(longitude) * r\n        coords[k, 1] = math.sin(longitude) * r\n        coords[k, 2] = z\n        z -= dz\n        longitude += dl\n    return coords",
            "def _compute_sphere(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Return the 3D coordinates of n points on a sphere.\\n\\n        Uses the golden spiral algorithm to place points 'evenly' on the sphere\\n        surface. We compute this once and then move the sphere to the centroid\\n        of each atom as we compute the ASAs.\\n        \"\n    n = self.n_points\n    dl = np.pi * (3 - 5 ** 0.5)\n    dz = 2.0 / n\n    longitude = 0\n    z = 1 - dz / 2\n    coords = np.zeros((n, 3), dtype=np.float32)\n    for k in range(n):\n        r = (1 - z * z) ** 0.5\n        coords[k, 0] = math.cos(longitude) * r\n        coords[k, 1] = math.sin(longitude) * r\n        coords[k, 2] = z\n        z -= dz\n        longitude += dl\n    return coords",
            "def _compute_sphere(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Return the 3D coordinates of n points on a sphere.\\n\\n        Uses the golden spiral algorithm to place points 'evenly' on the sphere\\n        surface. We compute this once and then move the sphere to the centroid\\n        of each atom as we compute the ASAs.\\n        \"\n    n = self.n_points\n    dl = np.pi * (3 - 5 ** 0.5)\n    dz = 2.0 / n\n    longitude = 0\n    z = 1 - dz / 2\n    coords = np.zeros((n, 3), dtype=np.float32)\n    for k in range(n):\n        r = (1 - z * z) ** 0.5\n        coords[k, 0] = math.cos(longitude) * r\n        coords[k, 1] = math.sin(longitude) * r\n        coords[k, 2] = z\n        z -= dz\n        longitude += dl\n    return coords",
            "def _compute_sphere(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Return the 3D coordinates of n points on a sphere.\\n\\n        Uses the golden spiral algorithm to place points 'evenly' on the sphere\\n        surface. We compute this once and then move the sphere to the centroid\\n        of each atom as we compute the ASAs.\\n        \"\n    n = self.n_points\n    dl = np.pi * (3 - 5 ** 0.5)\n    dz = 2.0 / n\n    longitude = 0\n    z = 1 - dz / 2\n    coords = np.zeros((n, 3), dtype=np.float32)\n    for k in range(n):\n        r = (1 - z * z) ** 0.5\n        coords[k, 0] = math.cos(longitude) * r\n        coords[k, 1] = math.sin(longitude) * r\n        coords[k, 2] = z\n        z -= dz\n        longitude += dl\n    return coords",
            "def _compute_sphere(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Return the 3D coordinates of n points on a sphere.\\n\\n        Uses the golden spiral algorithm to place points 'evenly' on the sphere\\n        surface. We compute this once and then move the sphere to the centroid\\n        of each atom as we compute the ASAs.\\n        \"\n    n = self.n_points\n    dl = np.pi * (3 - 5 ** 0.5)\n    dz = 2.0 / n\n    longitude = 0\n    z = 1 - dz / 2\n    coords = np.zeros((n, 3), dtype=np.float32)\n    for k in range(n):\n        r = (1 - z * z) ** 0.5\n        coords[k, 0] = math.cos(longitude) * r\n        coords[k, 1] = math.sin(longitude) * r\n        coords[k, 2] = z\n        z -= dz\n        longitude += dl\n    return coords"
        ]
    },
    {
        "func_name": "compute",
        "original": "def compute(self, entity, level='A'):\n    \"\"\"Calculate surface accessibility surface area for an entity.\n\n        The resulting atomic surface accessibility values are attached to the\n        .sasa attribute of each entity (or atom), depending on the level. For\n        example, if level=\"R\", all residues will have a .sasa attribute. Atoms\n        will always be assigned a .sasa attribute with their individual values.\n\n        :param entity: input entity.\n        :type entity: Bio.PDB.Entity, e.g. Residue, Chain, ...\n\n        :param level: the level at which ASA values are assigned, which can be\n            one of \"A\" (Atom), \"R\" (Residue), \"C\" (Chain), \"M\" (Model), or\n            \"S\" (Structure). The ASA value of an entity is the sum of all ASA\n            values of its children. Defaults to \"A\".\n        :type entity: Bio.PDB.Entity\n\n        >>> from Bio.PDB import PDBParser\n        >>> from Bio.PDB.SASA import ShrakeRupley\n        >>> p = PDBParser(QUIET=1)\n        >>> # This assumes you have a local copy of 1LCD.pdb in a directory called \"PDB\"\n        >>> struct = p.get_structure(\"1LCD\", \"PDB/1LCD.pdb\")\n        >>> sr = ShrakeRupley()\n        >>> sr.compute(struct, level=\"S\")\n        >>> print(round(struct.sasa, 2))\n        7053.43\n        >>> print(round(struct[0][\"A\"][11][\"OE1\"].sasa, 2))\n        9.64\n        \"\"\"\n    is_valid = hasattr(entity, 'level') and entity.level in {'R', 'C', 'M', 'S'}\n    if not is_valid:\n        raise ValueError(f\"Invalid entity type '{type(entity)}'. Must be Residue, Chain, Model, or Structure\")\n    if level not in _ENTITY_HIERARCHY:\n        raise ValueError(f\"Invalid level '{level}'. Must be A, R, C, M, or S.\")\n    elif _ENTITY_HIERARCHY[level] > _ENTITY_HIERARCHY[entity.level]:\n        raise ValueError(f\"Level '{level}' must be equal or smaller than input entity: {entity.level}\")\n    atoms = list(entity.get_atoms())\n    n_atoms = len(atoms)\n    if not n_atoms:\n        raise ValueError('Entity has no child atoms.')\n    coords = np.array([a.coord for a in atoms], dtype=np.float64)\n    kdt = KDTree(coords, 10)\n    radii_dict = self.radii_dict\n    radii = np.array([radii_dict[a.element] for a in atoms], dtype=np.float64)\n    radii += self.probe_radius\n    twice_maxradii = np.max(radii) * 2\n    asa_array = np.zeros((n_atoms, 1), dtype=np.int64)\n    ptset = set(range(self.n_points))\n    for i in range(n_atoms):\n        r_i = radii[i]\n        s_on_i = np.array(self._sphere, copy=True) * r_i + coords[i]\n        available_set = ptset.copy()\n        kdt_sphere = KDTree(s_on_i, 10)\n        for jj in kdt.search(coords[i], twice_maxradii):\n            j = jj.index\n            if i == j:\n                continue\n            if jj.radius < r_i + radii[j]:\n                available_set -= {pt.index for pt in kdt_sphere.search(coords[j], radii[j])}\n        asa_array[i] = len(available_set)\n    f = radii * radii * (4 * np.pi / self.n_points)\n    asa_array = asa_array * f[:, np.newaxis]\n    for (i, atom) in enumerate(atoms):\n        atom.sasa = asa_array[i, 0]\n    if level != 'A':\n        entities = set(atoms)\n        target = _ENTITY_HIERARCHY[level]\n        for _ in range(target):\n            entities = {e.parent for e in entities}\n        atomdict = {a.full_id: idx for (idx, a) in enumerate(atoms)}\n        for e in entities:\n            e_atoms = [atomdict[a.full_id] for a in e.get_atoms()]\n            e.sasa = asa_array[e_atoms].sum()",
        "mutated": [
            "def compute(self, entity, level='A'):\n    if False:\n        i = 10\n    'Calculate surface accessibility surface area for an entity.\\n\\n        The resulting atomic surface accessibility values are attached to the\\n        .sasa attribute of each entity (or atom), depending on the level. For\\n        example, if level=\"R\", all residues will have a .sasa attribute. Atoms\\n        will always be assigned a .sasa attribute with their individual values.\\n\\n        :param entity: input entity.\\n        :type entity: Bio.PDB.Entity, e.g. Residue, Chain, ...\\n\\n        :param level: the level at which ASA values are assigned, which can be\\n            one of \"A\" (Atom), \"R\" (Residue), \"C\" (Chain), \"M\" (Model), or\\n            \"S\" (Structure). The ASA value of an entity is the sum of all ASA\\n            values of its children. Defaults to \"A\".\\n        :type entity: Bio.PDB.Entity\\n\\n        >>> from Bio.PDB import PDBParser\\n        >>> from Bio.PDB.SASA import ShrakeRupley\\n        >>> p = PDBParser(QUIET=1)\\n        >>> # This assumes you have a local copy of 1LCD.pdb in a directory called \"PDB\"\\n        >>> struct = p.get_structure(\"1LCD\", \"PDB/1LCD.pdb\")\\n        >>> sr = ShrakeRupley()\\n        >>> sr.compute(struct, level=\"S\")\\n        >>> print(round(struct.sasa, 2))\\n        7053.43\\n        >>> print(round(struct[0][\"A\"][11][\"OE1\"].sasa, 2))\\n        9.64\\n        '\n    is_valid = hasattr(entity, 'level') and entity.level in {'R', 'C', 'M', 'S'}\n    if not is_valid:\n        raise ValueError(f\"Invalid entity type '{type(entity)}'. Must be Residue, Chain, Model, or Structure\")\n    if level not in _ENTITY_HIERARCHY:\n        raise ValueError(f\"Invalid level '{level}'. Must be A, R, C, M, or S.\")\n    elif _ENTITY_HIERARCHY[level] > _ENTITY_HIERARCHY[entity.level]:\n        raise ValueError(f\"Level '{level}' must be equal or smaller than input entity: {entity.level}\")\n    atoms = list(entity.get_atoms())\n    n_atoms = len(atoms)\n    if not n_atoms:\n        raise ValueError('Entity has no child atoms.')\n    coords = np.array([a.coord for a in atoms], dtype=np.float64)\n    kdt = KDTree(coords, 10)\n    radii_dict = self.radii_dict\n    radii = np.array([radii_dict[a.element] for a in atoms], dtype=np.float64)\n    radii += self.probe_radius\n    twice_maxradii = np.max(radii) * 2\n    asa_array = np.zeros((n_atoms, 1), dtype=np.int64)\n    ptset = set(range(self.n_points))\n    for i in range(n_atoms):\n        r_i = radii[i]\n        s_on_i = np.array(self._sphere, copy=True) * r_i + coords[i]\n        available_set = ptset.copy()\n        kdt_sphere = KDTree(s_on_i, 10)\n        for jj in kdt.search(coords[i], twice_maxradii):\n            j = jj.index\n            if i == j:\n                continue\n            if jj.radius < r_i + radii[j]:\n                available_set -= {pt.index for pt in kdt_sphere.search(coords[j], radii[j])}\n        asa_array[i] = len(available_set)\n    f = radii * radii * (4 * np.pi / self.n_points)\n    asa_array = asa_array * f[:, np.newaxis]\n    for (i, atom) in enumerate(atoms):\n        atom.sasa = asa_array[i, 0]\n    if level != 'A':\n        entities = set(atoms)\n        target = _ENTITY_HIERARCHY[level]\n        for _ in range(target):\n            entities = {e.parent for e in entities}\n        atomdict = {a.full_id: idx for (idx, a) in enumerate(atoms)}\n        for e in entities:\n            e_atoms = [atomdict[a.full_id] for a in e.get_atoms()]\n            e.sasa = asa_array[e_atoms].sum()",
            "def compute(self, entity, level='A'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Calculate surface accessibility surface area for an entity.\\n\\n        The resulting atomic surface accessibility values are attached to the\\n        .sasa attribute of each entity (or atom), depending on the level. For\\n        example, if level=\"R\", all residues will have a .sasa attribute. Atoms\\n        will always be assigned a .sasa attribute with their individual values.\\n\\n        :param entity: input entity.\\n        :type entity: Bio.PDB.Entity, e.g. Residue, Chain, ...\\n\\n        :param level: the level at which ASA values are assigned, which can be\\n            one of \"A\" (Atom), \"R\" (Residue), \"C\" (Chain), \"M\" (Model), or\\n            \"S\" (Structure). The ASA value of an entity is the sum of all ASA\\n            values of its children. Defaults to \"A\".\\n        :type entity: Bio.PDB.Entity\\n\\n        >>> from Bio.PDB import PDBParser\\n        >>> from Bio.PDB.SASA import ShrakeRupley\\n        >>> p = PDBParser(QUIET=1)\\n        >>> # This assumes you have a local copy of 1LCD.pdb in a directory called \"PDB\"\\n        >>> struct = p.get_structure(\"1LCD\", \"PDB/1LCD.pdb\")\\n        >>> sr = ShrakeRupley()\\n        >>> sr.compute(struct, level=\"S\")\\n        >>> print(round(struct.sasa, 2))\\n        7053.43\\n        >>> print(round(struct[0][\"A\"][11][\"OE1\"].sasa, 2))\\n        9.64\\n        '\n    is_valid = hasattr(entity, 'level') and entity.level in {'R', 'C', 'M', 'S'}\n    if not is_valid:\n        raise ValueError(f\"Invalid entity type '{type(entity)}'. Must be Residue, Chain, Model, or Structure\")\n    if level not in _ENTITY_HIERARCHY:\n        raise ValueError(f\"Invalid level '{level}'. Must be A, R, C, M, or S.\")\n    elif _ENTITY_HIERARCHY[level] > _ENTITY_HIERARCHY[entity.level]:\n        raise ValueError(f\"Level '{level}' must be equal or smaller than input entity: {entity.level}\")\n    atoms = list(entity.get_atoms())\n    n_atoms = len(atoms)\n    if not n_atoms:\n        raise ValueError('Entity has no child atoms.')\n    coords = np.array([a.coord for a in atoms], dtype=np.float64)\n    kdt = KDTree(coords, 10)\n    radii_dict = self.radii_dict\n    radii = np.array([radii_dict[a.element] for a in atoms], dtype=np.float64)\n    radii += self.probe_radius\n    twice_maxradii = np.max(radii) * 2\n    asa_array = np.zeros((n_atoms, 1), dtype=np.int64)\n    ptset = set(range(self.n_points))\n    for i in range(n_atoms):\n        r_i = radii[i]\n        s_on_i = np.array(self._sphere, copy=True) * r_i + coords[i]\n        available_set = ptset.copy()\n        kdt_sphere = KDTree(s_on_i, 10)\n        for jj in kdt.search(coords[i], twice_maxradii):\n            j = jj.index\n            if i == j:\n                continue\n            if jj.radius < r_i + radii[j]:\n                available_set -= {pt.index for pt in kdt_sphere.search(coords[j], radii[j])}\n        asa_array[i] = len(available_set)\n    f = radii * radii * (4 * np.pi / self.n_points)\n    asa_array = asa_array * f[:, np.newaxis]\n    for (i, atom) in enumerate(atoms):\n        atom.sasa = asa_array[i, 0]\n    if level != 'A':\n        entities = set(atoms)\n        target = _ENTITY_HIERARCHY[level]\n        for _ in range(target):\n            entities = {e.parent for e in entities}\n        atomdict = {a.full_id: idx for (idx, a) in enumerate(atoms)}\n        for e in entities:\n            e_atoms = [atomdict[a.full_id] for a in e.get_atoms()]\n            e.sasa = asa_array[e_atoms].sum()",
            "def compute(self, entity, level='A'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Calculate surface accessibility surface area for an entity.\\n\\n        The resulting atomic surface accessibility values are attached to the\\n        .sasa attribute of each entity (or atom), depending on the level. For\\n        example, if level=\"R\", all residues will have a .sasa attribute. Atoms\\n        will always be assigned a .sasa attribute with their individual values.\\n\\n        :param entity: input entity.\\n        :type entity: Bio.PDB.Entity, e.g. Residue, Chain, ...\\n\\n        :param level: the level at which ASA values are assigned, which can be\\n            one of \"A\" (Atom), \"R\" (Residue), \"C\" (Chain), \"M\" (Model), or\\n            \"S\" (Structure). The ASA value of an entity is the sum of all ASA\\n            values of its children. Defaults to \"A\".\\n        :type entity: Bio.PDB.Entity\\n\\n        >>> from Bio.PDB import PDBParser\\n        >>> from Bio.PDB.SASA import ShrakeRupley\\n        >>> p = PDBParser(QUIET=1)\\n        >>> # This assumes you have a local copy of 1LCD.pdb in a directory called \"PDB\"\\n        >>> struct = p.get_structure(\"1LCD\", \"PDB/1LCD.pdb\")\\n        >>> sr = ShrakeRupley()\\n        >>> sr.compute(struct, level=\"S\")\\n        >>> print(round(struct.sasa, 2))\\n        7053.43\\n        >>> print(round(struct[0][\"A\"][11][\"OE1\"].sasa, 2))\\n        9.64\\n        '\n    is_valid = hasattr(entity, 'level') and entity.level in {'R', 'C', 'M', 'S'}\n    if not is_valid:\n        raise ValueError(f\"Invalid entity type '{type(entity)}'. Must be Residue, Chain, Model, or Structure\")\n    if level not in _ENTITY_HIERARCHY:\n        raise ValueError(f\"Invalid level '{level}'. Must be A, R, C, M, or S.\")\n    elif _ENTITY_HIERARCHY[level] > _ENTITY_HIERARCHY[entity.level]:\n        raise ValueError(f\"Level '{level}' must be equal or smaller than input entity: {entity.level}\")\n    atoms = list(entity.get_atoms())\n    n_atoms = len(atoms)\n    if not n_atoms:\n        raise ValueError('Entity has no child atoms.')\n    coords = np.array([a.coord for a in atoms], dtype=np.float64)\n    kdt = KDTree(coords, 10)\n    radii_dict = self.radii_dict\n    radii = np.array([radii_dict[a.element] for a in atoms], dtype=np.float64)\n    radii += self.probe_radius\n    twice_maxradii = np.max(radii) * 2\n    asa_array = np.zeros((n_atoms, 1), dtype=np.int64)\n    ptset = set(range(self.n_points))\n    for i in range(n_atoms):\n        r_i = radii[i]\n        s_on_i = np.array(self._sphere, copy=True) * r_i + coords[i]\n        available_set = ptset.copy()\n        kdt_sphere = KDTree(s_on_i, 10)\n        for jj in kdt.search(coords[i], twice_maxradii):\n            j = jj.index\n            if i == j:\n                continue\n            if jj.radius < r_i + radii[j]:\n                available_set -= {pt.index for pt in kdt_sphere.search(coords[j], radii[j])}\n        asa_array[i] = len(available_set)\n    f = radii * radii * (4 * np.pi / self.n_points)\n    asa_array = asa_array * f[:, np.newaxis]\n    for (i, atom) in enumerate(atoms):\n        atom.sasa = asa_array[i, 0]\n    if level != 'A':\n        entities = set(atoms)\n        target = _ENTITY_HIERARCHY[level]\n        for _ in range(target):\n            entities = {e.parent for e in entities}\n        atomdict = {a.full_id: idx for (idx, a) in enumerate(atoms)}\n        for e in entities:\n            e_atoms = [atomdict[a.full_id] for a in e.get_atoms()]\n            e.sasa = asa_array[e_atoms].sum()",
            "def compute(self, entity, level='A'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Calculate surface accessibility surface area for an entity.\\n\\n        The resulting atomic surface accessibility values are attached to the\\n        .sasa attribute of each entity (or atom), depending on the level. For\\n        example, if level=\"R\", all residues will have a .sasa attribute. Atoms\\n        will always be assigned a .sasa attribute with their individual values.\\n\\n        :param entity: input entity.\\n        :type entity: Bio.PDB.Entity, e.g. Residue, Chain, ...\\n\\n        :param level: the level at which ASA values are assigned, which can be\\n            one of \"A\" (Atom), \"R\" (Residue), \"C\" (Chain), \"M\" (Model), or\\n            \"S\" (Structure). The ASA value of an entity is the sum of all ASA\\n            values of its children. Defaults to \"A\".\\n        :type entity: Bio.PDB.Entity\\n\\n        >>> from Bio.PDB import PDBParser\\n        >>> from Bio.PDB.SASA import ShrakeRupley\\n        >>> p = PDBParser(QUIET=1)\\n        >>> # This assumes you have a local copy of 1LCD.pdb in a directory called \"PDB\"\\n        >>> struct = p.get_structure(\"1LCD\", \"PDB/1LCD.pdb\")\\n        >>> sr = ShrakeRupley()\\n        >>> sr.compute(struct, level=\"S\")\\n        >>> print(round(struct.sasa, 2))\\n        7053.43\\n        >>> print(round(struct[0][\"A\"][11][\"OE1\"].sasa, 2))\\n        9.64\\n        '\n    is_valid = hasattr(entity, 'level') and entity.level in {'R', 'C', 'M', 'S'}\n    if not is_valid:\n        raise ValueError(f\"Invalid entity type '{type(entity)}'. Must be Residue, Chain, Model, or Structure\")\n    if level not in _ENTITY_HIERARCHY:\n        raise ValueError(f\"Invalid level '{level}'. Must be A, R, C, M, or S.\")\n    elif _ENTITY_HIERARCHY[level] > _ENTITY_HIERARCHY[entity.level]:\n        raise ValueError(f\"Level '{level}' must be equal or smaller than input entity: {entity.level}\")\n    atoms = list(entity.get_atoms())\n    n_atoms = len(atoms)\n    if not n_atoms:\n        raise ValueError('Entity has no child atoms.')\n    coords = np.array([a.coord for a in atoms], dtype=np.float64)\n    kdt = KDTree(coords, 10)\n    radii_dict = self.radii_dict\n    radii = np.array([radii_dict[a.element] for a in atoms], dtype=np.float64)\n    radii += self.probe_radius\n    twice_maxradii = np.max(radii) * 2\n    asa_array = np.zeros((n_atoms, 1), dtype=np.int64)\n    ptset = set(range(self.n_points))\n    for i in range(n_atoms):\n        r_i = radii[i]\n        s_on_i = np.array(self._sphere, copy=True) * r_i + coords[i]\n        available_set = ptset.copy()\n        kdt_sphere = KDTree(s_on_i, 10)\n        for jj in kdt.search(coords[i], twice_maxradii):\n            j = jj.index\n            if i == j:\n                continue\n            if jj.radius < r_i + radii[j]:\n                available_set -= {pt.index for pt in kdt_sphere.search(coords[j], radii[j])}\n        asa_array[i] = len(available_set)\n    f = radii * radii * (4 * np.pi / self.n_points)\n    asa_array = asa_array * f[:, np.newaxis]\n    for (i, atom) in enumerate(atoms):\n        atom.sasa = asa_array[i, 0]\n    if level != 'A':\n        entities = set(atoms)\n        target = _ENTITY_HIERARCHY[level]\n        for _ in range(target):\n            entities = {e.parent for e in entities}\n        atomdict = {a.full_id: idx for (idx, a) in enumerate(atoms)}\n        for e in entities:\n            e_atoms = [atomdict[a.full_id] for a in e.get_atoms()]\n            e.sasa = asa_array[e_atoms].sum()",
            "def compute(self, entity, level='A'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Calculate surface accessibility surface area for an entity.\\n\\n        The resulting atomic surface accessibility values are attached to the\\n        .sasa attribute of each entity (or atom), depending on the level. For\\n        example, if level=\"R\", all residues will have a .sasa attribute. Atoms\\n        will always be assigned a .sasa attribute with their individual values.\\n\\n        :param entity: input entity.\\n        :type entity: Bio.PDB.Entity, e.g. Residue, Chain, ...\\n\\n        :param level: the level at which ASA values are assigned, which can be\\n            one of \"A\" (Atom), \"R\" (Residue), \"C\" (Chain), \"M\" (Model), or\\n            \"S\" (Structure). The ASA value of an entity is the sum of all ASA\\n            values of its children. Defaults to \"A\".\\n        :type entity: Bio.PDB.Entity\\n\\n        >>> from Bio.PDB import PDBParser\\n        >>> from Bio.PDB.SASA import ShrakeRupley\\n        >>> p = PDBParser(QUIET=1)\\n        >>> # This assumes you have a local copy of 1LCD.pdb in a directory called \"PDB\"\\n        >>> struct = p.get_structure(\"1LCD\", \"PDB/1LCD.pdb\")\\n        >>> sr = ShrakeRupley()\\n        >>> sr.compute(struct, level=\"S\")\\n        >>> print(round(struct.sasa, 2))\\n        7053.43\\n        >>> print(round(struct[0][\"A\"][11][\"OE1\"].sasa, 2))\\n        9.64\\n        '\n    is_valid = hasattr(entity, 'level') and entity.level in {'R', 'C', 'M', 'S'}\n    if not is_valid:\n        raise ValueError(f\"Invalid entity type '{type(entity)}'. Must be Residue, Chain, Model, or Structure\")\n    if level not in _ENTITY_HIERARCHY:\n        raise ValueError(f\"Invalid level '{level}'. Must be A, R, C, M, or S.\")\n    elif _ENTITY_HIERARCHY[level] > _ENTITY_HIERARCHY[entity.level]:\n        raise ValueError(f\"Level '{level}' must be equal or smaller than input entity: {entity.level}\")\n    atoms = list(entity.get_atoms())\n    n_atoms = len(atoms)\n    if not n_atoms:\n        raise ValueError('Entity has no child atoms.')\n    coords = np.array([a.coord for a in atoms], dtype=np.float64)\n    kdt = KDTree(coords, 10)\n    radii_dict = self.radii_dict\n    radii = np.array([radii_dict[a.element] for a in atoms], dtype=np.float64)\n    radii += self.probe_radius\n    twice_maxradii = np.max(radii) * 2\n    asa_array = np.zeros((n_atoms, 1), dtype=np.int64)\n    ptset = set(range(self.n_points))\n    for i in range(n_atoms):\n        r_i = radii[i]\n        s_on_i = np.array(self._sphere, copy=True) * r_i + coords[i]\n        available_set = ptset.copy()\n        kdt_sphere = KDTree(s_on_i, 10)\n        for jj in kdt.search(coords[i], twice_maxradii):\n            j = jj.index\n            if i == j:\n                continue\n            if jj.radius < r_i + radii[j]:\n                available_set -= {pt.index for pt in kdt_sphere.search(coords[j], radii[j])}\n        asa_array[i] = len(available_set)\n    f = radii * radii * (4 * np.pi / self.n_points)\n    asa_array = asa_array * f[:, np.newaxis]\n    for (i, atom) in enumerate(atoms):\n        atom.sasa = asa_array[i, 0]\n    if level != 'A':\n        entities = set(atoms)\n        target = _ENTITY_HIERARCHY[level]\n        for _ in range(target):\n            entities = {e.parent for e in entities}\n        atomdict = {a.full_id: idx for (idx, a) in enumerate(atoms)}\n        for e in entities:\n            e_atoms = [atomdict[a.full_id] for a in e.get_atoms()]\n            e.sasa = asa_array[e_atoms].sum()"
        ]
    }
]