[
    {
        "func_name": "test_smoothed_state_obs_weights_sarimax",
        "original": "@pytest.mark.parametrize('use_exog', [False, True])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\n@pytest.mark.parametrize('concentrate_scale', [False, True])\n@pytest.mark.parametrize('measurement_error', [False, True])\ndef test_smoothed_state_obs_weights_sarimax(use_exog, trend, concentrate_scale, measurement_error):\n    endog = np.array([[0.2, np.nan, 1.2, -0.3, -1.5]]).T\n    exog = np.array([2, 5.3, -1, 3.4, 0.0]) if use_exog else None\n    trend_params = [0.1]\n    ar_params = [0.5]\n    exog_params = [1.4]\n    meas_err_params = [1.2]\n    cov_params = [0.8]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    if use_exog:\n        params += exog_params\n    params += ar_params\n    if measurement_error:\n        params += meas_err_params\n    if not concentrate_scale:\n        params += cov_params\n    mod = sarimax.SARIMAX(endog, order=(1, 0, 0), trend=trend, exog=exog if use_exog else None, concentrate_scale=concentrate_scale, measurement_error=measurement_error)\n    prior_mean = np.array([-0.4])\n    prior_cov = np.eye(1) * 1.2\n    mod.ssm.initialize_known(prior_mean, prior_cov)\n    res = mod.smooth(params)\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] += 1.0\n                tmp_mod = sarimax.SARIMAX(y, order=(1, 0, 0), trend=trend, exog=exog if use_exog else None, concentrate_scale=concentrate_scale, measurement_error=measurement_error)\n                tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n                tmp_res = tmp_mod.smooth(params)\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_state_intercept_weights = np.zeros((n, n, m, m)) * np.nan\n    for j in range(n):\n        for ell in range(m):\n            tmp_mod = sarimax.SARIMAX(endog, order=(1, 0, 0), trend=trend, exog=exog if use_exog else None, concentrate_scale=concentrate_scale, measurement_error=measurement_error)\n            tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n            tmp_mod.update(params)\n            if tmp_mod['state_intercept'].ndim == 1:\n                si = tmp_mod['state_intercept']\n                tmp_mod['state_intercept'] = np.zeros((mod.k_states, mod.nobs))\n                tmp_mod['state_intercept', :, :] = si\n            tmp_mod['state_intercept', ell, j] += 1.0\n            tmp_res = tmp_mod.ssm.smooth()\n            desired_state_intercept_weights[:, j, :, ell] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_prior_weights = np.zeros((n, m, m)) * np.nan\n    for i in range(m):\n        a = prior_mean.copy()\n        a[i] += 1\n        tmp_mod = sarimax.SARIMAX(endog, order=(1, 0, 0), trend=trend, exog=exog if use_exog else None, concentrate_scale=concentrate_scale, measurement_error=measurement_error)\n        tmp_mod.ssm.initialize_known(a, prior_cov)\n        tmp_res = tmp_mod.smooth(params)\n        desired_prior_weights[:, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    mod.ssm.initialize_known(prior_mean, prior_cov)\n    (actual, actual_state_intercept_weights, actual_prior_weights) = tools.compute_smoothed_state_weights(res)\n    assert_allclose(actual, desired, atol=1e-08)\n    assert_allclose(actual_state_intercept_weights, desired_state_intercept_weights, atol=1e-12)\n    assert_allclose(actual_prior_weights, desired_prior_weights, atol=1e-12)",
        "mutated": [
            "@pytest.mark.parametrize('use_exog', [False, True])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\n@pytest.mark.parametrize('concentrate_scale', [False, True])\n@pytest.mark.parametrize('measurement_error', [False, True])\ndef test_smoothed_state_obs_weights_sarimax(use_exog, trend, concentrate_scale, measurement_error):\n    if False:\n        i = 10\n    endog = np.array([[0.2, np.nan, 1.2, -0.3, -1.5]]).T\n    exog = np.array([2, 5.3, -1, 3.4, 0.0]) if use_exog else None\n    trend_params = [0.1]\n    ar_params = [0.5]\n    exog_params = [1.4]\n    meas_err_params = [1.2]\n    cov_params = [0.8]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    if use_exog:\n        params += exog_params\n    params += ar_params\n    if measurement_error:\n        params += meas_err_params\n    if not concentrate_scale:\n        params += cov_params\n    mod = sarimax.SARIMAX(endog, order=(1, 0, 0), trend=trend, exog=exog if use_exog else None, concentrate_scale=concentrate_scale, measurement_error=measurement_error)\n    prior_mean = np.array([-0.4])\n    prior_cov = np.eye(1) * 1.2\n    mod.ssm.initialize_known(prior_mean, prior_cov)\n    res = mod.smooth(params)\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] += 1.0\n                tmp_mod = sarimax.SARIMAX(y, order=(1, 0, 0), trend=trend, exog=exog if use_exog else None, concentrate_scale=concentrate_scale, measurement_error=measurement_error)\n                tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n                tmp_res = tmp_mod.smooth(params)\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_state_intercept_weights = np.zeros((n, n, m, m)) * np.nan\n    for j in range(n):\n        for ell in range(m):\n            tmp_mod = sarimax.SARIMAX(endog, order=(1, 0, 0), trend=trend, exog=exog if use_exog else None, concentrate_scale=concentrate_scale, measurement_error=measurement_error)\n            tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n            tmp_mod.update(params)\n            if tmp_mod['state_intercept'].ndim == 1:\n                si = tmp_mod['state_intercept']\n                tmp_mod['state_intercept'] = np.zeros((mod.k_states, mod.nobs))\n                tmp_mod['state_intercept', :, :] = si\n            tmp_mod['state_intercept', ell, j] += 1.0\n            tmp_res = tmp_mod.ssm.smooth()\n            desired_state_intercept_weights[:, j, :, ell] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_prior_weights = np.zeros((n, m, m)) * np.nan\n    for i in range(m):\n        a = prior_mean.copy()\n        a[i] += 1\n        tmp_mod = sarimax.SARIMAX(endog, order=(1, 0, 0), trend=trend, exog=exog if use_exog else None, concentrate_scale=concentrate_scale, measurement_error=measurement_error)\n        tmp_mod.ssm.initialize_known(a, prior_cov)\n        tmp_res = tmp_mod.smooth(params)\n        desired_prior_weights[:, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    mod.ssm.initialize_known(prior_mean, prior_cov)\n    (actual, actual_state_intercept_weights, actual_prior_weights) = tools.compute_smoothed_state_weights(res)\n    assert_allclose(actual, desired, atol=1e-08)\n    assert_allclose(actual_state_intercept_weights, desired_state_intercept_weights, atol=1e-12)\n    assert_allclose(actual_prior_weights, desired_prior_weights, atol=1e-12)",
            "@pytest.mark.parametrize('use_exog', [False, True])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\n@pytest.mark.parametrize('concentrate_scale', [False, True])\n@pytest.mark.parametrize('measurement_error', [False, True])\ndef test_smoothed_state_obs_weights_sarimax(use_exog, trend, concentrate_scale, measurement_error):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    endog = np.array([[0.2, np.nan, 1.2, -0.3, -1.5]]).T\n    exog = np.array([2, 5.3, -1, 3.4, 0.0]) if use_exog else None\n    trend_params = [0.1]\n    ar_params = [0.5]\n    exog_params = [1.4]\n    meas_err_params = [1.2]\n    cov_params = [0.8]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    if use_exog:\n        params += exog_params\n    params += ar_params\n    if measurement_error:\n        params += meas_err_params\n    if not concentrate_scale:\n        params += cov_params\n    mod = sarimax.SARIMAX(endog, order=(1, 0, 0), trend=trend, exog=exog if use_exog else None, concentrate_scale=concentrate_scale, measurement_error=measurement_error)\n    prior_mean = np.array([-0.4])\n    prior_cov = np.eye(1) * 1.2\n    mod.ssm.initialize_known(prior_mean, prior_cov)\n    res = mod.smooth(params)\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] += 1.0\n                tmp_mod = sarimax.SARIMAX(y, order=(1, 0, 0), trend=trend, exog=exog if use_exog else None, concentrate_scale=concentrate_scale, measurement_error=measurement_error)\n                tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n                tmp_res = tmp_mod.smooth(params)\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_state_intercept_weights = np.zeros((n, n, m, m)) * np.nan\n    for j in range(n):\n        for ell in range(m):\n            tmp_mod = sarimax.SARIMAX(endog, order=(1, 0, 0), trend=trend, exog=exog if use_exog else None, concentrate_scale=concentrate_scale, measurement_error=measurement_error)\n            tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n            tmp_mod.update(params)\n            if tmp_mod['state_intercept'].ndim == 1:\n                si = tmp_mod['state_intercept']\n                tmp_mod['state_intercept'] = np.zeros((mod.k_states, mod.nobs))\n                tmp_mod['state_intercept', :, :] = si\n            tmp_mod['state_intercept', ell, j] += 1.0\n            tmp_res = tmp_mod.ssm.smooth()\n            desired_state_intercept_weights[:, j, :, ell] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_prior_weights = np.zeros((n, m, m)) * np.nan\n    for i in range(m):\n        a = prior_mean.copy()\n        a[i] += 1\n        tmp_mod = sarimax.SARIMAX(endog, order=(1, 0, 0), trend=trend, exog=exog if use_exog else None, concentrate_scale=concentrate_scale, measurement_error=measurement_error)\n        tmp_mod.ssm.initialize_known(a, prior_cov)\n        tmp_res = tmp_mod.smooth(params)\n        desired_prior_weights[:, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    mod.ssm.initialize_known(prior_mean, prior_cov)\n    (actual, actual_state_intercept_weights, actual_prior_weights) = tools.compute_smoothed_state_weights(res)\n    assert_allclose(actual, desired, atol=1e-08)\n    assert_allclose(actual_state_intercept_weights, desired_state_intercept_weights, atol=1e-12)\n    assert_allclose(actual_prior_weights, desired_prior_weights, atol=1e-12)",
            "@pytest.mark.parametrize('use_exog', [False, True])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\n@pytest.mark.parametrize('concentrate_scale', [False, True])\n@pytest.mark.parametrize('measurement_error', [False, True])\ndef test_smoothed_state_obs_weights_sarimax(use_exog, trend, concentrate_scale, measurement_error):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    endog = np.array([[0.2, np.nan, 1.2, -0.3, -1.5]]).T\n    exog = np.array([2, 5.3, -1, 3.4, 0.0]) if use_exog else None\n    trend_params = [0.1]\n    ar_params = [0.5]\n    exog_params = [1.4]\n    meas_err_params = [1.2]\n    cov_params = [0.8]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    if use_exog:\n        params += exog_params\n    params += ar_params\n    if measurement_error:\n        params += meas_err_params\n    if not concentrate_scale:\n        params += cov_params\n    mod = sarimax.SARIMAX(endog, order=(1, 0, 0), trend=trend, exog=exog if use_exog else None, concentrate_scale=concentrate_scale, measurement_error=measurement_error)\n    prior_mean = np.array([-0.4])\n    prior_cov = np.eye(1) * 1.2\n    mod.ssm.initialize_known(prior_mean, prior_cov)\n    res = mod.smooth(params)\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] += 1.0\n                tmp_mod = sarimax.SARIMAX(y, order=(1, 0, 0), trend=trend, exog=exog if use_exog else None, concentrate_scale=concentrate_scale, measurement_error=measurement_error)\n                tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n                tmp_res = tmp_mod.smooth(params)\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_state_intercept_weights = np.zeros((n, n, m, m)) * np.nan\n    for j in range(n):\n        for ell in range(m):\n            tmp_mod = sarimax.SARIMAX(endog, order=(1, 0, 0), trend=trend, exog=exog if use_exog else None, concentrate_scale=concentrate_scale, measurement_error=measurement_error)\n            tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n            tmp_mod.update(params)\n            if tmp_mod['state_intercept'].ndim == 1:\n                si = tmp_mod['state_intercept']\n                tmp_mod['state_intercept'] = np.zeros((mod.k_states, mod.nobs))\n                tmp_mod['state_intercept', :, :] = si\n            tmp_mod['state_intercept', ell, j] += 1.0\n            tmp_res = tmp_mod.ssm.smooth()\n            desired_state_intercept_weights[:, j, :, ell] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_prior_weights = np.zeros((n, m, m)) * np.nan\n    for i in range(m):\n        a = prior_mean.copy()\n        a[i] += 1\n        tmp_mod = sarimax.SARIMAX(endog, order=(1, 0, 0), trend=trend, exog=exog if use_exog else None, concentrate_scale=concentrate_scale, measurement_error=measurement_error)\n        tmp_mod.ssm.initialize_known(a, prior_cov)\n        tmp_res = tmp_mod.smooth(params)\n        desired_prior_weights[:, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    mod.ssm.initialize_known(prior_mean, prior_cov)\n    (actual, actual_state_intercept_weights, actual_prior_weights) = tools.compute_smoothed_state_weights(res)\n    assert_allclose(actual, desired, atol=1e-08)\n    assert_allclose(actual_state_intercept_weights, desired_state_intercept_weights, atol=1e-12)\n    assert_allclose(actual_prior_weights, desired_prior_weights, atol=1e-12)",
            "@pytest.mark.parametrize('use_exog', [False, True])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\n@pytest.mark.parametrize('concentrate_scale', [False, True])\n@pytest.mark.parametrize('measurement_error', [False, True])\ndef test_smoothed_state_obs_weights_sarimax(use_exog, trend, concentrate_scale, measurement_error):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    endog = np.array([[0.2, np.nan, 1.2, -0.3, -1.5]]).T\n    exog = np.array([2, 5.3, -1, 3.4, 0.0]) if use_exog else None\n    trend_params = [0.1]\n    ar_params = [0.5]\n    exog_params = [1.4]\n    meas_err_params = [1.2]\n    cov_params = [0.8]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    if use_exog:\n        params += exog_params\n    params += ar_params\n    if measurement_error:\n        params += meas_err_params\n    if not concentrate_scale:\n        params += cov_params\n    mod = sarimax.SARIMAX(endog, order=(1, 0, 0), trend=trend, exog=exog if use_exog else None, concentrate_scale=concentrate_scale, measurement_error=measurement_error)\n    prior_mean = np.array([-0.4])\n    prior_cov = np.eye(1) * 1.2\n    mod.ssm.initialize_known(prior_mean, prior_cov)\n    res = mod.smooth(params)\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] += 1.0\n                tmp_mod = sarimax.SARIMAX(y, order=(1, 0, 0), trend=trend, exog=exog if use_exog else None, concentrate_scale=concentrate_scale, measurement_error=measurement_error)\n                tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n                tmp_res = tmp_mod.smooth(params)\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_state_intercept_weights = np.zeros((n, n, m, m)) * np.nan\n    for j in range(n):\n        for ell in range(m):\n            tmp_mod = sarimax.SARIMAX(endog, order=(1, 0, 0), trend=trend, exog=exog if use_exog else None, concentrate_scale=concentrate_scale, measurement_error=measurement_error)\n            tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n            tmp_mod.update(params)\n            if tmp_mod['state_intercept'].ndim == 1:\n                si = tmp_mod['state_intercept']\n                tmp_mod['state_intercept'] = np.zeros((mod.k_states, mod.nobs))\n                tmp_mod['state_intercept', :, :] = si\n            tmp_mod['state_intercept', ell, j] += 1.0\n            tmp_res = tmp_mod.ssm.smooth()\n            desired_state_intercept_weights[:, j, :, ell] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_prior_weights = np.zeros((n, m, m)) * np.nan\n    for i in range(m):\n        a = prior_mean.copy()\n        a[i] += 1\n        tmp_mod = sarimax.SARIMAX(endog, order=(1, 0, 0), trend=trend, exog=exog if use_exog else None, concentrate_scale=concentrate_scale, measurement_error=measurement_error)\n        tmp_mod.ssm.initialize_known(a, prior_cov)\n        tmp_res = tmp_mod.smooth(params)\n        desired_prior_weights[:, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    mod.ssm.initialize_known(prior_mean, prior_cov)\n    (actual, actual_state_intercept_weights, actual_prior_weights) = tools.compute_smoothed_state_weights(res)\n    assert_allclose(actual, desired, atol=1e-08)\n    assert_allclose(actual_state_intercept_weights, desired_state_intercept_weights, atol=1e-12)\n    assert_allclose(actual_prior_weights, desired_prior_weights, atol=1e-12)",
            "@pytest.mark.parametrize('use_exog', [False, True])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\n@pytest.mark.parametrize('concentrate_scale', [False, True])\n@pytest.mark.parametrize('measurement_error', [False, True])\ndef test_smoothed_state_obs_weights_sarimax(use_exog, trend, concentrate_scale, measurement_error):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    endog = np.array([[0.2, np.nan, 1.2, -0.3, -1.5]]).T\n    exog = np.array([2, 5.3, -1, 3.4, 0.0]) if use_exog else None\n    trend_params = [0.1]\n    ar_params = [0.5]\n    exog_params = [1.4]\n    meas_err_params = [1.2]\n    cov_params = [0.8]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    if use_exog:\n        params += exog_params\n    params += ar_params\n    if measurement_error:\n        params += meas_err_params\n    if not concentrate_scale:\n        params += cov_params\n    mod = sarimax.SARIMAX(endog, order=(1, 0, 0), trend=trend, exog=exog if use_exog else None, concentrate_scale=concentrate_scale, measurement_error=measurement_error)\n    prior_mean = np.array([-0.4])\n    prior_cov = np.eye(1) * 1.2\n    mod.ssm.initialize_known(prior_mean, prior_cov)\n    res = mod.smooth(params)\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] += 1.0\n                tmp_mod = sarimax.SARIMAX(y, order=(1, 0, 0), trend=trend, exog=exog if use_exog else None, concentrate_scale=concentrate_scale, measurement_error=measurement_error)\n                tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n                tmp_res = tmp_mod.smooth(params)\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_state_intercept_weights = np.zeros((n, n, m, m)) * np.nan\n    for j in range(n):\n        for ell in range(m):\n            tmp_mod = sarimax.SARIMAX(endog, order=(1, 0, 0), trend=trend, exog=exog if use_exog else None, concentrate_scale=concentrate_scale, measurement_error=measurement_error)\n            tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n            tmp_mod.update(params)\n            if tmp_mod['state_intercept'].ndim == 1:\n                si = tmp_mod['state_intercept']\n                tmp_mod['state_intercept'] = np.zeros((mod.k_states, mod.nobs))\n                tmp_mod['state_intercept', :, :] = si\n            tmp_mod['state_intercept', ell, j] += 1.0\n            tmp_res = tmp_mod.ssm.smooth()\n            desired_state_intercept_weights[:, j, :, ell] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_prior_weights = np.zeros((n, m, m)) * np.nan\n    for i in range(m):\n        a = prior_mean.copy()\n        a[i] += 1\n        tmp_mod = sarimax.SARIMAX(endog, order=(1, 0, 0), trend=trend, exog=exog if use_exog else None, concentrate_scale=concentrate_scale, measurement_error=measurement_error)\n        tmp_mod.ssm.initialize_known(a, prior_cov)\n        tmp_res = tmp_mod.smooth(params)\n        desired_prior_weights[:, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    mod.ssm.initialize_known(prior_mean, prior_cov)\n    (actual, actual_state_intercept_weights, actual_prior_weights) = tools.compute_smoothed_state_weights(res)\n    assert_allclose(actual, desired, atol=1e-08)\n    assert_allclose(actual_state_intercept_weights, desired_state_intercept_weights, atol=1e-12)\n    assert_allclose(actual_prior_weights, desired_prior_weights, atol=1e-12)"
        ]
    },
    {
        "func_name": "test_smoothed_state_obs_weights_varmax",
        "original": "@pytest.mark.parametrize('use_exog', [False, True])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_smoothed_state_obs_weights_varmax(use_exog, trend):\n    endog = np.zeros((5, 2))\n    endog[0, 0] = np.nan\n    endog[1, :] = np.nan\n    endog[2, 1] = np.nan\n    exog = np.array([2, 5.3, -1, 3.4, 0.0]) if use_exog else None\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    mod = varmax.VARMAX(endog, order=(1, 0), trend=trend, exog=exog if use_exog else None)\n    prior_mean = np.array([-0.4, 0.9])\n    prior_cov = np.array([[1.4, 0.3], [0.3, 2.6]])\n    mod.ssm.initialize_known(prior_mean, prior_cov)\n    res = mod.smooth(params)\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = varmax.VARMAX(y, order=(1, 0), trend=trend, exog=exog if use_exog else None)\n                tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n                tmp_res = tmp_mod.smooth(params)\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_state_intercept_weights = np.zeros((n, n, m, m)) * np.nan\n    for j in range(n):\n        for ell in range(m):\n            tmp_mod = varmax.VARMAX(endog, order=(1, 0), trend=trend, exog=exog if use_exog else None)\n            tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n            tmp_mod.update(params)\n            if tmp_mod['state_intercept'].ndim == 1:\n                si = tmp_mod['state_intercept']\n                tmp_mod['state_intercept'] = np.zeros((mod.k_states, mod.nobs))\n                tmp_mod['state_intercept', :, :] = si[:, None]\n            tmp_mod['state_intercept', ell, j] += 1.0\n            tmp_res = tmp_mod.ssm.smooth()\n            desired_state_intercept_weights[:, j, :, ell] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_prior_weights = np.zeros((n, m, m)) * np.nan\n    for i in range(m):\n        a = prior_mean.copy()\n        a[i] += 1\n        tmp_mod = varmax.VARMAX(endog, order=(1, 0), trend=trend, exog=exog if use_exog else None)\n        tmp_mod.ssm.initialize_known(a, prior_cov)\n        tmp_res = tmp_mod.smooth(params)\n        desired_prior_weights[:, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    mod.ssm.initialize_known(prior_mean, prior_cov)\n    (actual, actual_state_intercept_weights, actual_prior_weights) = tools.compute_smoothed_state_weights(res)\n    assert_allclose(actual, desired, atol=1e-08)\n    assert_allclose(actual_state_intercept_weights, desired_state_intercept_weights, atol=1e-12)\n    assert_allclose(actual_prior_weights, desired_prior_weights, atol=1e-12)",
        "mutated": [
            "@pytest.mark.parametrize('use_exog', [False, True])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_smoothed_state_obs_weights_varmax(use_exog, trend):\n    if False:\n        i = 10\n    endog = np.zeros((5, 2))\n    endog[0, 0] = np.nan\n    endog[1, :] = np.nan\n    endog[2, 1] = np.nan\n    exog = np.array([2, 5.3, -1, 3.4, 0.0]) if use_exog else None\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    mod = varmax.VARMAX(endog, order=(1, 0), trend=trend, exog=exog if use_exog else None)\n    prior_mean = np.array([-0.4, 0.9])\n    prior_cov = np.array([[1.4, 0.3], [0.3, 2.6]])\n    mod.ssm.initialize_known(prior_mean, prior_cov)\n    res = mod.smooth(params)\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = varmax.VARMAX(y, order=(1, 0), trend=trend, exog=exog if use_exog else None)\n                tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n                tmp_res = tmp_mod.smooth(params)\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_state_intercept_weights = np.zeros((n, n, m, m)) * np.nan\n    for j in range(n):\n        for ell in range(m):\n            tmp_mod = varmax.VARMAX(endog, order=(1, 0), trend=trend, exog=exog if use_exog else None)\n            tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n            tmp_mod.update(params)\n            if tmp_mod['state_intercept'].ndim == 1:\n                si = tmp_mod['state_intercept']\n                tmp_mod['state_intercept'] = np.zeros((mod.k_states, mod.nobs))\n                tmp_mod['state_intercept', :, :] = si[:, None]\n            tmp_mod['state_intercept', ell, j] += 1.0\n            tmp_res = tmp_mod.ssm.smooth()\n            desired_state_intercept_weights[:, j, :, ell] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_prior_weights = np.zeros((n, m, m)) * np.nan\n    for i in range(m):\n        a = prior_mean.copy()\n        a[i] += 1\n        tmp_mod = varmax.VARMAX(endog, order=(1, 0), trend=trend, exog=exog if use_exog else None)\n        tmp_mod.ssm.initialize_known(a, prior_cov)\n        tmp_res = tmp_mod.smooth(params)\n        desired_prior_weights[:, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    mod.ssm.initialize_known(prior_mean, prior_cov)\n    (actual, actual_state_intercept_weights, actual_prior_weights) = tools.compute_smoothed_state_weights(res)\n    assert_allclose(actual, desired, atol=1e-08)\n    assert_allclose(actual_state_intercept_weights, desired_state_intercept_weights, atol=1e-12)\n    assert_allclose(actual_prior_weights, desired_prior_weights, atol=1e-12)",
            "@pytest.mark.parametrize('use_exog', [False, True])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_smoothed_state_obs_weights_varmax(use_exog, trend):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    endog = np.zeros((5, 2))\n    endog[0, 0] = np.nan\n    endog[1, :] = np.nan\n    endog[2, 1] = np.nan\n    exog = np.array([2, 5.3, -1, 3.4, 0.0]) if use_exog else None\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    mod = varmax.VARMAX(endog, order=(1, 0), trend=trend, exog=exog if use_exog else None)\n    prior_mean = np.array([-0.4, 0.9])\n    prior_cov = np.array([[1.4, 0.3], [0.3, 2.6]])\n    mod.ssm.initialize_known(prior_mean, prior_cov)\n    res = mod.smooth(params)\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = varmax.VARMAX(y, order=(1, 0), trend=trend, exog=exog if use_exog else None)\n                tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n                tmp_res = tmp_mod.smooth(params)\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_state_intercept_weights = np.zeros((n, n, m, m)) * np.nan\n    for j in range(n):\n        for ell in range(m):\n            tmp_mod = varmax.VARMAX(endog, order=(1, 0), trend=trend, exog=exog if use_exog else None)\n            tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n            tmp_mod.update(params)\n            if tmp_mod['state_intercept'].ndim == 1:\n                si = tmp_mod['state_intercept']\n                tmp_mod['state_intercept'] = np.zeros((mod.k_states, mod.nobs))\n                tmp_mod['state_intercept', :, :] = si[:, None]\n            tmp_mod['state_intercept', ell, j] += 1.0\n            tmp_res = tmp_mod.ssm.smooth()\n            desired_state_intercept_weights[:, j, :, ell] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_prior_weights = np.zeros((n, m, m)) * np.nan\n    for i in range(m):\n        a = prior_mean.copy()\n        a[i] += 1\n        tmp_mod = varmax.VARMAX(endog, order=(1, 0), trend=trend, exog=exog if use_exog else None)\n        tmp_mod.ssm.initialize_known(a, prior_cov)\n        tmp_res = tmp_mod.smooth(params)\n        desired_prior_weights[:, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    mod.ssm.initialize_known(prior_mean, prior_cov)\n    (actual, actual_state_intercept_weights, actual_prior_weights) = tools.compute_smoothed_state_weights(res)\n    assert_allclose(actual, desired, atol=1e-08)\n    assert_allclose(actual_state_intercept_weights, desired_state_intercept_weights, atol=1e-12)\n    assert_allclose(actual_prior_weights, desired_prior_weights, atol=1e-12)",
            "@pytest.mark.parametrize('use_exog', [False, True])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_smoothed_state_obs_weights_varmax(use_exog, trend):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    endog = np.zeros((5, 2))\n    endog[0, 0] = np.nan\n    endog[1, :] = np.nan\n    endog[2, 1] = np.nan\n    exog = np.array([2, 5.3, -1, 3.4, 0.0]) if use_exog else None\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    mod = varmax.VARMAX(endog, order=(1, 0), trend=trend, exog=exog if use_exog else None)\n    prior_mean = np.array([-0.4, 0.9])\n    prior_cov = np.array([[1.4, 0.3], [0.3, 2.6]])\n    mod.ssm.initialize_known(prior_mean, prior_cov)\n    res = mod.smooth(params)\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = varmax.VARMAX(y, order=(1, 0), trend=trend, exog=exog if use_exog else None)\n                tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n                tmp_res = tmp_mod.smooth(params)\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_state_intercept_weights = np.zeros((n, n, m, m)) * np.nan\n    for j in range(n):\n        for ell in range(m):\n            tmp_mod = varmax.VARMAX(endog, order=(1, 0), trend=trend, exog=exog if use_exog else None)\n            tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n            tmp_mod.update(params)\n            if tmp_mod['state_intercept'].ndim == 1:\n                si = tmp_mod['state_intercept']\n                tmp_mod['state_intercept'] = np.zeros((mod.k_states, mod.nobs))\n                tmp_mod['state_intercept', :, :] = si[:, None]\n            tmp_mod['state_intercept', ell, j] += 1.0\n            tmp_res = tmp_mod.ssm.smooth()\n            desired_state_intercept_weights[:, j, :, ell] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_prior_weights = np.zeros((n, m, m)) * np.nan\n    for i in range(m):\n        a = prior_mean.copy()\n        a[i] += 1\n        tmp_mod = varmax.VARMAX(endog, order=(1, 0), trend=trend, exog=exog if use_exog else None)\n        tmp_mod.ssm.initialize_known(a, prior_cov)\n        tmp_res = tmp_mod.smooth(params)\n        desired_prior_weights[:, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    mod.ssm.initialize_known(prior_mean, prior_cov)\n    (actual, actual_state_intercept_weights, actual_prior_weights) = tools.compute_smoothed_state_weights(res)\n    assert_allclose(actual, desired, atol=1e-08)\n    assert_allclose(actual_state_intercept_weights, desired_state_intercept_weights, atol=1e-12)\n    assert_allclose(actual_prior_weights, desired_prior_weights, atol=1e-12)",
            "@pytest.mark.parametrize('use_exog', [False, True])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_smoothed_state_obs_weights_varmax(use_exog, trend):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    endog = np.zeros((5, 2))\n    endog[0, 0] = np.nan\n    endog[1, :] = np.nan\n    endog[2, 1] = np.nan\n    exog = np.array([2, 5.3, -1, 3.4, 0.0]) if use_exog else None\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    mod = varmax.VARMAX(endog, order=(1, 0), trend=trend, exog=exog if use_exog else None)\n    prior_mean = np.array([-0.4, 0.9])\n    prior_cov = np.array([[1.4, 0.3], [0.3, 2.6]])\n    mod.ssm.initialize_known(prior_mean, prior_cov)\n    res = mod.smooth(params)\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = varmax.VARMAX(y, order=(1, 0), trend=trend, exog=exog if use_exog else None)\n                tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n                tmp_res = tmp_mod.smooth(params)\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_state_intercept_weights = np.zeros((n, n, m, m)) * np.nan\n    for j in range(n):\n        for ell in range(m):\n            tmp_mod = varmax.VARMAX(endog, order=(1, 0), trend=trend, exog=exog if use_exog else None)\n            tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n            tmp_mod.update(params)\n            if tmp_mod['state_intercept'].ndim == 1:\n                si = tmp_mod['state_intercept']\n                tmp_mod['state_intercept'] = np.zeros((mod.k_states, mod.nobs))\n                tmp_mod['state_intercept', :, :] = si[:, None]\n            tmp_mod['state_intercept', ell, j] += 1.0\n            tmp_res = tmp_mod.ssm.smooth()\n            desired_state_intercept_weights[:, j, :, ell] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_prior_weights = np.zeros((n, m, m)) * np.nan\n    for i in range(m):\n        a = prior_mean.copy()\n        a[i] += 1\n        tmp_mod = varmax.VARMAX(endog, order=(1, 0), trend=trend, exog=exog if use_exog else None)\n        tmp_mod.ssm.initialize_known(a, prior_cov)\n        tmp_res = tmp_mod.smooth(params)\n        desired_prior_weights[:, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    mod.ssm.initialize_known(prior_mean, prior_cov)\n    (actual, actual_state_intercept_weights, actual_prior_weights) = tools.compute_smoothed_state_weights(res)\n    assert_allclose(actual, desired, atol=1e-08)\n    assert_allclose(actual_state_intercept_weights, desired_state_intercept_weights, atol=1e-12)\n    assert_allclose(actual_prior_weights, desired_prior_weights, atol=1e-12)",
            "@pytest.mark.parametrize('use_exog', [False, True])\n@pytest.mark.parametrize('trend', ['n', 'c', 't'])\ndef test_smoothed_state_obs_weights_varmax(use_exog, trend):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    endog = np.zeros((5, 2))\n    endog[0, 0] = np.nan\n    endog[1, :] = np.nan\n    endog[2, 1] = np.nan\n    exog = np.array([2, 5.3, -1, 3.4, 0.0]) if use_exog else None\n    trend_params = [0.1, 0.2]\n    var_params = [0.5, -0.1, 0.0, 0.2]\n    exog_params = [1.0, 2.0]\n    cov_params = [1.0, 0.0, 1.0]\n    params = []\n    if trend in ['c', 't']:\n        params += trend_params\n    params += var_params\n    if use_exog:\n        params += exog_params\n    params += cov_params\n    mod = varmax.VARMAX(endog, order=(1, 0), trend=trend, exog=exog if use_exog else None)\n    prior_mean = np.array([-0.4, 0.9])\n    prior_cov = np.array([[1.4, 0.3], [0.3, 2.6]])\n    mod.ssm.initialize_known(prior_mean, prior_cov)\n    res = mod.smooth(params)\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = varmax.VARMAX(y, order=(1, 0), trend=trend, exog=exog if use_exog else None)\n                tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n                tmp_res = tmp_mod.smooth(params)\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_state_intercept_weights = np.zeros((n, n, m, m)) * np.nan\n    for j in range(n):\n        for ell in range(m):\n            tmp_mod = varmax.VARMAX(endog, order=(1, 0), trend=trend, exog=exog if use_exog else None)\n            tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n            tmp_mod.update(params)\n            if tmp_mod['state_intercept'].ndim == 1:\n                si = tmp_mod['state_intercept']\n                tmp_mod['state_intercept'] = np.zeros((mod.k_states, mod.nobs))\n                tmp_mod['state_intercept', :, :] = si[:, None]\n            tmp_mod['state_intercept', ell, j] += 1.0\n            tmp_res = tmp_mod.ssm.smooth()\n            desired_state_intercept_weights[:, j, :, ell] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_prior_weights = np.zeros((n, m, m)) * np.nan\n    for i in range(m):\n        a = prior_mean.copy()\n        a[i] += 1\n        tmp_mod = varmax.VARMAX(endog, order=(1, 0), trend=trend, exog=exog if use_exog else None)\n        tmp_mod.ssm.initialize_known(a, prior_cov)\n        tmp_res = tmp_mod.smooth(params)\n        desired_prior_weights[:, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    mod.ssm.initialize_known(prior_mean, prior_cov)\n    (actual, actual_state_intercept_weights, actual_prior_weights) = tools.compute_smoothed_state_weights(res)\n    assert_allclose(actual, desired, atol=1e-08)\n    assert_allclose(actual_state_intercept_weights, desired_state_intercept_weights, atol=1e-12)\n    assert_allclose(actual_prior_weights, desired_prior_weights, atol=1e-12)"
        ]
    },
    {
        "func_name": "test_smoothed_state_obs_weights_TVSS",
        "original": "@pytest.mark.parametrize('diffuse', [0, 1, 4])\n@pytest.mark.parametrize('univariate', [False, True])\ndef test_smoothed_state_obs_weights_TVSS(univariate, diffuse, reset_randomstate):\n    endog = np.zeros((10, 3))\n    if diffuse == 4:\n        endog[:3] = np.nan\n    endog[6, 0] = np.nan\n    endog[7, :] = np.nan\n    endog[8, 1] = np.nan\n    mod = TVSS(endog)\n    prior_mean = np.array([1.2, 0.8])\n    prior_cov = np.eye(2)\n    if not diffuse:\n        mod.ssm.initialize_known(prior_mean, prior_cov)\n    if univariate:\n        mod.ssm.filter_univariate = True\n    res = mod.smooth([])\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = mod.clone(y)\n                if not diffuse:\n                    tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n                if univariate:\n                    tmp_mod.ssm.filter_univariate = True\n                tmp_res = tmp_mod.smooth([])\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_state_intercept_weights = np.zeros((n, n, m, m)) * np.nan\n    for j in range(n):\n        for ell in range(m):\n            tmp_mod = mod.clone(endog)\n            if not diffuse:\n                tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n            if univariate:\n                tmp_mod.ssm.filter_univariate = True\n            if tmp_mod['state_intercept'].ndim == 1:\n                si = tmp_mod['state_intercept']\n                tmp_mod['state_intercept'] = np.zeros((mod.k_states, mod.nobs))\n                tmp_mod['state_intercept', :, :] = si[:, None]\n            tmp_mod['state_intercept', ell, j] += 1.0\n            tmp_res = tmp_mod.ssm.smooth()\n            desired_state_intercept_weights[:, j, :, ell] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_prior_weights = np.zeros((n, m, m)) * np.nan\n    if not diffuse:\n        for i in range(m):\n            a = prior_mean.copy()\n            a[i] += 1\n            tmp_mod = mod.clone(endog)\n            tmp_mod.ssm.initialize_known(a, prior_cov)\n            tmp_res = tmp_mod.smooth([])\n            desired_prior_weights[:, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    if not diffuse:\n        mod.ssm.initialize_known(prior_mean, prior_cov)\n    (actual, actual_state_intercept_weights, actual_prior_weights) = tools.compute_smoothed_state_weights(res)\n    d = res.nobs_diffuse\n    assert_equal(d, diffuse)\n    if diffuse:\n        assert_allclose(actual[:d], np.nan, atol=1e-12)\n        assert_allclose(actual[:, :d], np.nan, atol=1e-12)\n        assert_allclose(actual_state_intercept_weights[:d], np.nan)\n        assert_allclose(actual_state_intercept_weights[:, :d], np.nan)\n        assert_allclose(actual_prior_weights, np.nan)\n    else:\n        assert_allclose(actual_prior_weights, desired_prior_weights, atol=1e-12)\n        contribution_prior = np.nansum(actual_prior_weights * prior_mean[None, None, :], axis=2)\n        contribution_endog = np.nansum(actual * (endog - mod['obs_intercept'].T)[None, :, None, :], axis=(1, 3))\n        computed_smoothed_state = contribution_prior + contribution_endog\n        assert_allclose(computed_smoothed_state, res.smoothed_state.T)\n    assert_allclose(actual[d:, d:], desired[d:, d:], atol=1e-12)\n    assert_allclose(actual_state_intercept_weights[d:, d:], desired_state_intercept_weights[d:, d:], atol=1e-12)",
        "mutated": [
            "@pytest.mark.parametrize('diffuse', [0, 1, 4])\n@pytest.mark.parametrize('univariate', [False, True])\ndef test_smoothed_state_obs_weights_TVSS(univariate, diffuse, reset_randomstate):\n    if False:\n        i = 10\n    endog = np.zeros((10, 3))\n    if diffuse == 4:\n        endog[:3] = np.nan\n    endog[6, 0] = np.nan\n    endog[7, :] = np.nan\n    endog[8, 1] = np.nan\n    mod = TVSS(endog)\n    prior_mean = np.array([1.2, 0.8])\n    prior_cov = np.eye(2)\n    if not diffuse:\n        mod.ssm.initialize_known(prior_mean, prior_cov)\n    if univariate:\n        mod.ssm.filter_univariate = True\n    res = mod.smooth([])\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = mod.clone(y)\n                if not diffuse:\n                    tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n                if univariate:\n                    tmp_mod.ssm.filter_univariate = True\n                tmp_res = tmp_mod.smooth([])\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_state_intercept_weights = np.zeros((n, n, m, m)) * np.nan\n    for j in range(n):\n        for ell in range(m):\n            tmp_mod = mod.clone(endog)\n            if not diffuse:\n                tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n            if univariate:\n                tmp_mod.ssm.filter_univariate = True\n            if tmp_mod['state_intercept'].ndim == 1:\n                si = tmp_mod['state_intercept']\n                tmp_mod['state_intercept'] = np.zeros((mod.k_states, mod.nobs))\n                tmp_mod['state_intercept', :, :] = si[:, None]\n            tmp_mod['state_intercept', ell, j] += 1.0\n            tmp_res = tmp_mod.ssm.smooth()\n            desired_state_intercept_weights[:, j, :, ell] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_prior_weights = np.zeros((n, m, m)) * np.nan\n    if not diffuse:\n        for i in range(m):\n            a = prior_mean.copy()\n            a[i] += 1\n            tmp_mod = mod.clone(endog)\n            tmp_mod.ssm.initialize_known(a, prior_cov)\n            tmp_res = tmp_mod.smooth([])\n            desired_prior_weights[:, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    if not diffuse:\n        mod.ssm.initialize_known(prior_mean, prior_cov)\n    (actual, actual_state_intercept_weights, actual_prior_weights) = tools.compute_smoothed_state_weights(res)\n    d = res.nobs_diffuse\n    assert_equal(d, diffuse)\n    if diffuse:\n        assert_allclose(actual[:d], np.nan, atol=1e-12)\n        assert_allclose(actual[:, :d], np.nan, atol=1e-12)\n        assert_allclose(actual_state_intercept_weights[:d], np.nan)\n        assert_allclose(actual_state_intercept_weights[:, :d], np.nan)\n        assert_allclose(actual_prior_weights, np.nan)\n    else:\n        assert_allclose(actual_prior_weights, desired_prior_weights, atol=1e-12)\n        contribution_prior = np.nansum(actual_prior_weights * prior_mean[None, None, :], axis=2)\n        contribution_endog = np.nansum(actual * (endog - mod['obs_intercept'].T)[None, :, None, :], axis=(1, 3))\n        computed_smoothed_state = contribution_prior + contribution_endog\n        assert_allclose(computed_smoothed_state, res.smoothed_state.T)\n    assert_allclose(actual[d:, d:], desired[d:, d:], atol=1e-12)\n    assert_allclose(actual_state_intercept_weights[d:, d:], desired_state_intercept_weights[d:, d:], atol=1e-12)",
            "@pytest.mark.parametrize('diffuse', [0, 1, 4])\n@pytest.mark.parametrize('univariate', [False, True])\ndef test_smoothed_state_obs_weights_TVSS(univariate, diffuse, reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    endog = np.zeros((10, 3))\n    if diffuse == 4:\n        endog[:3] = np.nan\n    endog[6, 0] = np.nan\n    endog[7, :] = np.nan\n    endog[8, 1] = np.nan\n    mod = TVSS(endog)\n    prior_mean = np.array([1.2, 0.8])\n    prior_cov = np.eye(2)\n    if not diffuse:\n        mod.ssm.initialize_known(prior_mean, prior_cov)\n    if univariate:\n        mod.ssm.filter_univariate = True\n    res = mod.smooth([])\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = mod.clone(y)\n                if not diffuse:\n                    tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n                if univariate:\n                    tmp_mod.ssm.filter_univariate = True\n                tmp_res = tmp_mod.smooth([])\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_state_intercept_weights = np.zeros((n, n, m, m)) * np.nan\n    for j in range(n):\n        for ell in range(m):\n            tmp_mod = mod.clone(endog)\n            if not diffuse:\n                tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n            if univariate:\n                tmp_mod.ssm.filter_univariate = True\n            if tmp_mod['state_intercept'].ndim == 1:\n                si = tmp_mod['state_intercept']\n                tmp_mod['state_intercept'] = np.zeros((mod.k_states, mod.nobs))\n                tmp_mod['state_intercept', :, :] = si[:, None]\n            tmp_mod['state_intercept', ell, j] += 1.0\n            tmp_res = tmp_mod.ssm.smooth()\n            desired_state_intercept_weights[:, j, :, ell] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_prior_weights = np.zeros((n, m, m)) * np.nan\n    if not diffuse:\n        for i in range(m):\n            a = prior_mean.copy()\n            a[i] += 1\n            tmp_mod = mod.clone(endog)\n            tmp_mod.ssm.initialize_known(a, prior_cov)\n            tmp_res = tmp_mod.smooth([])\n            desired_prior_weights[:, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    if not diffuse:\n        mod.ssm.initialize_known(prior_mean, prior_cov)\n    (actual, actual_state_intercept_weights, actual_prior_weights) = tools.compute_smoothed_state_weights(res)\n    d = res.nobs_diffuse\n    assert_equal(d, diffuse)\n    if diffuse:\n        assert_allclose(actual[:d], np.nan, atol=1e-12)\n        assert_allclose(actual[:, :d], np.nan, atol=1e-12)\n        assert_allclose(actual_state_intercept_weights[:d], np.nan)\n        assert_allclose(actual_state_intercept_weights[:, :d], np.nan)\n        assert_allclose(actual_prior_weights, np.nan)\n    else:\n        assert_allclose(actual_prior_weights, desired_prior_weights, atol=1e-12)\n        contribution_prior = np.nansum(actual_prior_weights * prior_mean[None, None, :], axis=2)\n        contribution_endog = np.nansum(actual * (endog - mod['obs_intercept'].T)[None, :, None, :], axis=(1, 3))\n        computed_smoothed_state = contribution_prior + contribution_endog\n        assert_allclose(computed_smoothed_state, res.smoothed_state.T)\n    assert_allclose(actual[d:, d:], desired[d:, d:], atol=1e-12)\n    assert_allclose(actual_state_intercept_weights[d:, d:], desired_state_intercept_weights[d:, d:], atol=1e-12)",
            "@pytest.mark.parametrize('diffuse', [0, 1, 4])\n@pytest.mark.parametrize('univariate', [False, True])\ndef test_smoothed_state_obs_weights_TVSS(univariate, diffuse, reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    endog = np.zeros((10, 3))\n    if diffuse == 4:\n        endog[:3] = np.nan\n    endog[6, 0] = np.nan\n    endog[7, :] = np.nan\n    endog[8, 1] = np.nan\n    mod = TVSS(endog)\n    prior_mean = np.array([1.2, 0.8])\n    prior_cov = np.eye(2)\n    if not diffuse:\n        mod.ssm.initialize_known(prior_mean, prior_cov)\n    if univariate:\n        mod.ssm.filter_univariate = True\n    res = mod.smooth([])\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = mod.clone(y)\n                if not diffuse:\n                    tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n                if univariate:\n                    tmp_mod.ssm.filter_univariate = True\n                tmp_res = tmp_mod.smooth([])\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_state_intercept_weights = np.zeros((n, n, m, m)) * np.nan\n    for j in range(n):\n        for ell in range(m):\n            tmp_mod = mod.clone(endog)\n            if not diffuse:\n                tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n            if univariate:\n                tmp_mod.ssm.filter_univariate = True\n            if tmp_mod['state_intercept'].ndim == 1:\n                si = tmp_mod['state_intercept']\n                tmp_mod['state_intercept'] = np.zeros((mod.k_states, mod.nobs))\n                tmp_mod['state_intercept', :, :] = si[:, None]\n            tmp_mod['state_intercept', ell, j] += 1.0\n            tmp_res = tmp_mod.ssm.smooth()\n            desired_state_intercept_weights[:, j, :, ell] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_prior_weights = np.zeros((n, m, m)) * np.nan\n    if not diffuse:\n        for i in range(m):\n            a = prior_mean.copy()\n            a[i] += 1\n            tmp_mod = mod.clone(endog)\n            tmp_mod.ssm.initialize_known(a, prior_cov)\n            tmp_res = tmp_mod.smooth([])\n            desired_prior_weights[:, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    if not diffuse:\n        mod.ssm.initialize_known(prior_mean, prior_cov)\n    (actual, actual_state_intercept_weights, actual_prior_weights) = tools.compute_smoothed_state_weights(res)\n    d = res.nobs_diffuse\n    assert_equal(d, diffuse)\n    if diffuse:\n        assert_allclose(actual[:d], np.nan, atol=1e-12)\n        assert_allclose(actual[:, :d], np.nan, atol=1e-12)\n        assert_allclose(actual_state_intercept_weights[:d], np.nan)\n        assert_allclose(actual_state_intercept_weights[:, :d], np.nan)\n        assert_allclose(actual_prior_weights, np.nan)\n    else:\n        assert_allclose(actual_prior_weights, desired_prior_weights, atol=1e-12)\n        contribution_prior = np.nansum(actual_prior_weights * prior_mean[None, None, :], axis=2)\n        contribution_endog = np.nansum(actual * (endog - mod['obs_intercept'].T)[None, :, None, :], axis=(1, 3))\n        computed_smoothed_state = contribution_prior + contribution_endog\n        assert_allclose(computed_smoothed_state, res.smoothed_state.T)\n    assert_allclose(actual[d:, d:], desired[d:, d:], atol=1e-12)\n    assert_allclose(actual_state_intercept_weights[d:, d:], desired_state_intercept_weights[d:, d:], atol=1e-12)",
            "@pytest.mark.parametrize('diffuse', [0, 1, 4])\n@pytest.mark.parametrize('univariate', [False, True])\ndef test_smoothed_state_obs_weights_TVSS(univariate, diffuse, reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    endog = np.zeros((10, 3))\n    if diffuse == 4:\n        endog[:3] = np.nan\n    endog[6, 0] = np.nan\n    endog[7, :] = np.nan\n    endog[8, 1] = np.nan\n    mod = TVSS(endog)\n    prior_mean = np.array([1.2, 0.8])\n    prior_cov = np.eye(2)\n    if not diffuse:\n        mod.ssm.initialize_known(prior_mean, prior_cov)\n    if univariate:\n        mod.ssm.filter_univariate = True\n    res = mod.smooth([])\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = mod.clone(y)\n                if not diffuse:\n                    tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n                if univariate:\n                    tmp_mod.ssm.filter_univariate = True\n                tmp_res = tmp_mod.smooth([])\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_state_intercept_weights = np.zeros((n, n, m, m)) * np.nan\n    for j in range(n):\n        for ell in range(m):\n            tmp_mod = mod.clone(endog)\n            if not diffuse:\n                tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n            if univariate:\n                tmp_mod.ssm.filter_univariate = True\n            if tmp_mod['state_intercept'].ndim == 1:\n                si = tmp_mod['state_intercept']\n                tmp_mod['state_intercept'] = np.zeros((mod.k_states, mod.nobs))\n                tmp_mod['state_intercept', :, :] = si[:, None]\n            tmp_mod['state_intercept', ell, j] += 1.0\n            tmp_res = tmp_mod.ssm.smooth()\n            desired_state_intercept_weights[:, j, :, ell] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_prior_weights = np.zeros((n, m, m)) * np.nan\n    if not diffuse:\n        for i in range(m):\n            a = prior_mean.copy()\n            a[i] += 1\n            tmp_mod = mod.clone(endog)\n            tmp_mod.ssm.initialize_known(a, prior_cov)\n            tmp_res = tmp_mod.smooth([])\n            desired_prior_weights[:, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    if not diffuse:\n        mod.ssm.initialize_known(prior_mean, prior_cov)\n    (actual, actual_state_intercept_weights, actual_prior_weights) = tools.compute_smoothed_state_weights(res)\n    d = res.nobs_diffuse\n    assert_equal(d, diffuse)\n    if diffuse:\n        assert_allclose(actual[:d], np.nan, atol=1e-12)\n        assert_allclose(actual[:, :d], np.nan, atol=1e-12)\n        assert_allclose(actual_state_intercept_weights[:d], np.nan)\n        assert_allclose(actual_state_intercept_weights[:, :d], np.nan)\n        assert_allclose(actual_prior_weights, np.nan)\n    else:\n        assert_allclose(actual_prior_weights, desired_prior_weights, atol=1e-12)\n        contribution_prior = np.nansum(actual_prior_weights * prior_mean[None, None, :], axis=2)\n        contribution_endog = np.nansum(actual * (endog - mod['obs_intercept'].T)[None, :, None, :], axis=(1, 3))\n        computed_smoothed_state = contribution_prior + contribution_endog\n        assert_allclose(computed_smoothed_state, res.smoothed_state.T)\n    assert_allclose(actual[d:, d:], desired[d:, d:], atol=1e-12)\n    assert_allclose(actual_state_intercept_weights[d:, d:], desired_state_intercept_weights[d:, d:], atol=1e-12)",
            "@pytest.mark.parametrize('diffuse', [0, 1, 4])\n@pytest.mark.parametrize('univariate', [False, True])\ndef test_smoothed_state_obs_weights_TVSS(univariate, diffuse, reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    endog = np.zeros((10, 3))\n    if diffuse == 4:\n        endog[:3] = np.nan\n    endog[6, 0] = np.nan\n    endog[7, :] = np.nan\n    endog[8, 1] = np.nan\n    mod = TVSS(endog)\n    prior_mean = np.array([1.2, 0.8])\n    prior_cov = np.eye(2)\n    if not diffuse:\n        mod.ssm.initialize_known(prior_mean, prior_cov)\n    if univariate:\n        mod.ssm.filter_univariate = True\n    res = mod.smooth([])\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = mod.clone(y)\n                if not diffuse:\n                    tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n                if univariate:\n                    tmp_mod.ssm.filter_univariate = True\n                tmp_res = tmp_mod.smooth([])\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_state_intercept_weights = np.zeros((n, n, m, m)) * np.nan\n    for j in range(n):\n        for ell in range(m):\n            tmp_mod = mod.clone(endog)\n            if not diffuse:\n                tmp_mod.ssm.initialize_known(prior_mean, prior_cov)\n            if univariate:\n                tmp_mod.ssm.filter_univariate = True\n            if tmp_mod['state_intercept'].ndim == 1:\n                si = tmp_mod['state_intercept']\n                tmp_mod['state_intercept'] = np.zeros((mod.k_states, mod.nobs))\n                tmp_mod['state_intercept', :, :] = si[:, None]\n            tmp_mod['state_intercept', ell, j] += 1.0\n            tmp_res = tmp_mod.ssm.smooth()\n            desired_state_intercept_weights[:, j, :, ell] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_prior_weights = np.zeros((n, m, m)) * np.nan\n    if not diffuse:\n        for i in range(m):\n            a = prior_mean.copy()\n            a[i] += 1\n            tmp_mod = mod.clone(endog)\n            tmp_mod.ssm.initialize_known(a, prior_cov)\n            tmp_res = tmp_mod.smooth([])\n            desired_prior_weights[:, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    if not diffuse:\n        mod.ssm.initialize_known(prior_mean, prior_cov)\n    (actual, actual_state_intercept_weights, actual_prior_weights) = tools.compute_smoothed_state_weights(res)\n    d = res.nobs_diffuse\n    assert_equal(d, diffuse)\n    if diffuse:\n        assert_allclose(actual[:d], np.nan, atol=1e-12)\n        assert_allclose(actual[:, :d], np.nan, atol=1e-12)\n        assert_allclose(actual_state_intercept_weights[:d], np.nan)\n        assert_allclose(actual_state_intercept_weights[:, :d], np.nan)\n        assert_allclose(actual_prior_weights, np.nan)\n    else:\n        assert_allclose(actual_prior_weights, desired_prior_weights, atol=1e-12)\n        contribution_prior = np.nansum(actual_prior_weights * prior_mean[None, None, :], axis=2)\n        contribution_endog = np.nansum(actual * (endog - mod['obs_intercept'].T)[None, :, None, :], axis=(1, 3))\n        computed_smoothed_state = contribution_prior + contribution_endog\n        assert_allclose(computed_smoothed_state, res.smoothed_state.T)\n    assert_allclose(actual[d:, d:], desired[d:, d:], atol=1e-12)\n    assert_allclose(actual_state_intercept_weights[d:, d:], desired_state_intercept_weights[d:, d:], atol=1e-12)"
        ]
    },
    {
        "func_name": "test_smoothed_state_obs_weights_univariate_singular",
        "original": "@pytest.mark.parametrize('singular', ['both', 0, 1])\n@pytest.mark.parametrize('periods', [1, 2])\ndef test_smoothed_state_obs_weights_univariate_singular(singular, periods, reset_randomstate):\n    endog = np.zeros((10, 2))\n    endog[6, 0] = np.nan\n    endog[7, :] = np.nan\n    endog[8, 1] = np.nan\n    mod = TVSS(endog)\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2) * 0)\n    if singular == 'both':\n        mod['obs_cov', ..., :periods] = 0\n    else:\n        mod['obs_cov', 0, 1, :periods] = 0\n        mod['obs_cov', 1, 0, :periods] = 0\n        mod['obs_cov', singular, singular, :periods] = 0\n    mod['state_cov', :, :, :periods] = 0\n    mod.ssm.filter_univariate = True\n    res = mod.smooth([])\n    for i in range(periods):\n        eigvals = np.linalg.eigvalsh(res.forecasts_error_cov[..., i])\n        assert_equal(np.min(eigvals), 0)\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = mod.clone(y)\n                tmp_mod.ssm.initialize_known([1.2, 0.8], np.eye(2) * 0)\n                tmp_mod.ssm.filter_univariate = True\n                tmp_res = tmp_mod.smooth([])\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    (actual, _, _) = tools.compute_smoothed_state_weights(res)\n    assert_allclose(actual, desired, atol=1e-12)",
        "mutated": [
            "@pytest.mark.parametrize('singular', ['both', 0, 1])\n@pytest.mark.parametrize('periods', [1, 2])\ndef test_smoothed_state_obs_weights_univariate_singular(singular, periods, reset_randomstate):\n    if False:\n        i = 10\n    endog = np.zeros((10, 2))\n    endog[6, 0] = np.nan\n    endog[7, :] = np.nan\n    endog[8, 1] = np.nan\n    mod = TVSS(endog)\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2) * 0)\n    if singular == 'both':\n        mod['obs_cov', ..., :periods] = 0\n    else:\n        mod['obs_cov', 0, 1, :periods] = 0\n        mod['obs_cov', 1, 0, :periods] = 0\n        mod['obs_cov', singular, singular, :periods] = 0\n    mod['state_cov', :, :, :periods] = 0\n    mod.ssm.filter_univariate = True\n    res = mod.smooth([])\n    for i in range(periods):\n        eigvals = np.linalg.eigvalsh(res.forecasts_error_cov[..., i])\n        assert_equal(np.min(eigvals), 0)\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = mod.clone(y)\n                tmp_mod.ssm.initialize_known([1.2, 0.8], np.eye(2) * 0)\n                tmp_mod.ssm.filter_univariate = True\n                tmp_res = tmp_mod.smooth([])\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    (actual, _, _) = tools.compute_smoothed_state_weights(res)\n    assert_allclose(actual, desired, atol=1e-12)",
            "@pytest.mark.parametrize('singular', ['both', 0, 1])\n@pytest.mark.parametrize('periods', [1, 2])\ndef test_smoothed_state_obs_weights_univariate_singular(singular, periods, reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    endog = np.zeros((10, 2))\n    endog[6, 0] = np.nan\n    endog[7, :] = np.nan\n    endog[8, 1] = np.nan\n    mod = TVSS(endog)\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2) * 0)\n    if singular == 'both':\n        mod['obs_cov', ..., :periods] = 0\n    else:\n        mod['obs_cov', 0, 1, :periods] = 0\n        mod['obs_cov', 1, 0, :periods] = 0\n        mod['obs_cov', singular, singular, :periods] = 0\n    mod['state_cov', :, :, :periods] = 0\n    mod.ssm.filter_univariate = True\n    res = mod.smooth([])\n    for i in range(periods):\n        eigvals = np.linalg.eigvalsh(res.forecasts_error_cov[..., i])\n        assert_equal(np.min(eigvals), 0)\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = mod.clone(y)\n                tmp_mod.ssm.initialize_known([1.2, 0.8], np.eye(2) * 0)\n                tmp_mod.ssm.filter_univariate = True\n                tmp_res = tmp_mod.smooth([])\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    (actual, _, _) = tools.compute_smoothed_state_weights(res)\n    assert_allclose(actual, desired, atol=1e-12)",
            "@pytest.mark.parametrize('singular', ['both', 0, 1])\n@pytest.mark.parametrize('periods', [1, 2])\ndef test_smoothed_state_obs_weights_univariate_singular(singular, periods, reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    endog = np.zeros((10, 2))\n    endog[6, 0] = np.nan\n    endog[7, :] = np.nan\n    endog[8, 1] = np.nan\n    mod = TVSS(endog)\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2) * 0)\n    if singular == 'both':\n        mod['obs_cov', ..., :periods] = 0\n    else:\n        mod['obs_cov', 0, 1, :periods] = 0\n        mod['obs_cov', 1, 0, :periods] = 0\n        mod['obs_cov', singular, singular, :periods] = 0\n    mod['state_cov', :, :, :periods] = 0\n    mod.ssm.filter_univariate = True\n    res = mod.smooth([])\n    for i in range(periods):\n        eigvals = np.linalg.eigvalsh(res.forecasts_error_cov[..., i])\n        assert_equal(np.min(eigvals), 0)\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = mod.clone(y)\n                tmp_mod.ssm.initialize_known([1.2, 0.8], np.eye(2) * 0)\n                tmp_mod.ssm.filter_univariate = True\n                tmp_res = tmp_mod.smooth([])\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    (actual, _, _) = tools.compute_smoothed_state_weights(res)\n    assert_allclose(actual, desired, atol=1e-12)",
            "@pytest.mark.parametrize('singular', ['both', 0, 1])\n@pytest.mark.parametrize('periods', [1, 2])\ndef test_smoothed_state_obs_weights_univariate_singular(singular, periods, reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    endog = np.zeros((10, 2))\n    endog[6, 0] = np.nan\n    endog[7, :] = np.nan\n    endog[8, 1] = np.nan\n    mod = TVSS(endog)\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2) * 0)\n    if singular == 'both':\n        mod['obs_cov', ..., :periods] = 0\n    else:\n        mod['obs_cov', 0, 1, :periods] = 0\n        mod['obs_cov', 1, 0, :periods] = 0\n        mod['obs_cov', singular, singular, :periods] = 0\n    mod['state_cov', :, :, :periods] = 0\n    mod.ssm.filter_univariate = True\n    res = mod.smooth([])\n    for i in range(periods):\n        eigvals = np.linalg.eigvalsh(res.forecasts_error_cov[..., i])\n        assert_equal(np.min(eigvals), 0)\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = mod.clone(y)\n                tmp_mod.ssm.initialize_known([1.2, 0.8], np.eye(2) * 0)\n                tmp_mod.ssm.filter_univariate = True\n                tmp_res = tmp_mod.smooth([])\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    (actual, _, _) = tools.compute_smoothed_state_weights(res)\n    assert_allclose(actual, desired, atol=1e-12)",
            "@pytest.mark.parametrize('singular', ['both', 0, 1])\n@pytest.mark.parametrize('periods', [1, 2])\ndef test_smoothed_state_obs_weights_univariate_singular(singular, periods, reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    endog = np.zeros((10, 2))\n    endog[6, 0] = np.nan\n    endog[7, :] = np.nan\n    endog[8, 1] = np.nan\n    mod = TVSS(endog)\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2) * 0)\n    if singular == 'both':\n        mod['obs_cov', ..., :periods] = 0\n    else:\n        mod['obs_cov', 0, 1, :periods] = 0\n        mod['obs_cov', 1, 0, :periods] = 0\n        mod['obs_cov', singular, singular, :periods] = 0\n    mod['state_cov', :, :, :periods] = 0\n    mod.ssm.filter_univariate = True\n    res = mod.smooth([])\n    for i in range(periods):\n        eigvals = np.linalg.eigvalsh(res.forecasts_error_cov[..., i])\n        assert_equal(np.min(eigvals), 0)\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = mod.clone(y)\n                tmp_mod.ssm.initialize_known([1.2, 0.8], np.eye(2) * 0)\n                tmp_mod.ssm.filter_univariate = True\n                tmp_res = tmp_mod.smooth([])\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    (actual, _, _) = tools.compute_smoothed_state_weights(res)\n    assert_allclose(actual, desired, atol=1e-12)"
        ]
    },
    {
        "func_name": "test_smoothed_state_obs_weights_collapsed",
        "original": "def test_smoothed_state_obs_weights_collapsed(reset_randomstate):\n    endog = np.zeros((20, 6))\n    endog[2, :] = np.nan\n    endog[6, 0] = np.nan\n    endog[7, :] = np.nan\n    endog[8, 1] = np.nan\n    mod = TVSS(endog)\n    mod['obs_intercept'] = np.zeros((6, 1))\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n    mod.ssm.filter_collapsed = True\n    res = mod.smooth([])\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = mod.clone(y)\n                tmp_mod['obs_intercept'] = np.zeros((6, 1))\n                tmp_mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n                mod.ssm.filter_collapsed = True\n                tmp_res = tmp_mod.smooth([])\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_state_intercept_weights = np.zeros((n, n, m, m)) * np.nan\n    for j in range(n):\n        for ell in range(m):\n            tmp_mod = mod.clone(endog)\n            tmp_mod['obs_intercept'] = np.zeros((6, 1))\n            tmp_mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n            mod.ssm.filter_collapsed = True\n            if tmp_mod['state_intercept'].ndim == 1:\n                si = tmp_mod['state_intercept']\n                tmp_mod['state_intercept'] = np.zeros((mod.k_states, mod.nobs))\n                tmp_mod['state_intercept', :, :] = si[:, None]\n            tmp_mod['state_intercept', ell, j] += 1.0\n            tmp_res = tmp_mod.ssm.smooth()\n            desired_state_intercept_weights[:, j, :, ell] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    (actual, actual_state_intercept_weights, _) = tools.compute_smoothed_state_weights(res)\n    assert_allclose(actual, desired, atol=1e-12)\n    assert_allclose(actual_state_intercept_weights, desired_state_intercept_weights, atol=1e-12)",
        "mutated": [
            "def test_smoothed_state_obs_weights_collapsed(reset_randomstate):\n    if False:\n        i = 10\n    endog = np.zeros((20, 6))\n    endog[2, :] = np.nan\n    endog[6, 0] = np.nan\n    endog[7, :] = np.nan\n    endog[8, 1] = np.nan\n    mod = TVSS(endog)\n    mod['obs_intercept'] = np.zeros((6, 1))\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n    mod.ssm.filter_collapsed = True\n    res = mod.smooth([])\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = mod.clone(y)\n                tmp_mod['obs_intercept'] = np.zeros((6, 1))\n                tmp_mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n                mod.ssm.filter_collapsed = True\n                tmp_res = tmp_mod.smooth([])\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_state_intercept_weights = np.zeros((n, n, m, m)) * np.nan\n    for j in range(n):\n        for ell in range(m):\n            tmp_mod = mod.clone(endog)\n            tmp_mod['obs_intercept'] = np.zeros((6, 1))\n            tmp_mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n            mod.ssm.filter_collapsed = True\n            if tmp_mod['state_intercept'].ndim == 1:\n                si = tmp_mod['state_intercept']\n                tmp_mod['state_intercept'] = np.zeros((mod.k_states, mod.nobs))\n                tmp_mod['state_intercept', :, :] = si[:, None]\n            tmp_mod['state_intercept', ell, j] += 1.0\n            tmp_res = tmp_mod.ssm.smooth()\n            desired_state_intercept_weights[:, j, :, ell] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    (actual, actual_state_intercept_weights, _) = tools.compute_smoothed_state_weights(res)\n    assert_allclose(actual, desired, atol=1e-12)\n    assert_allclose(actual_state_intercept_weights, desired_state_intercept_weights, atol=1e-12)",
            "def test_smoothed_state_obs_weights_collapsed(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    endog = np.zeros((20, 6))\n    endog[2, :] = np.nan\n    endog[6, 0] = np.nan\n    endog[7, :] = np.nan\n    endog[8, 1] = np.nan\n    mod = TVSS(endog)\n    mod['obs_intercept'] = np.zeros((6, 1))\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n    mod.ssm.filter_collapsed = True\n    res = mod.smooth([])\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = mod.clone(y)\n                tmp_mod['obs_intercept'] = np.zeros((6, 1))\n                tmp_mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n                mod.ssm.filter_collapsed = True\n                tmp_res = tmp_mod.smooth([])\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_state_intercept_weights = np.zeros((n, n, m, m)) * np.nan\n    for j in range(n):\n        for ell in range(m):\n            tmp_mod = mod.clone(endog)\n            tmp_mod['obs_intercept'] = np.zeros((6, 1))\n            tmp_mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n            mod.ssm.filter_collapsed = True\n            if tmp_mod['state_intercept'].ndim == 1:\n                si = tmp_mod['state_intercept']\n                tmp_mod['state_intercept'] = np.zeros((mod.k_states, mod.nobs))\n                tmp_mod['state_intercept', :, :] = si[:, None]\n            tmp_mod['state_intercept', ell, j] += 1.0\n            tmp_res = tmp_mod.ssm.smooth()\n            desired_state_intercept_weights[:, j, :, ell] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    (actual, actual_state_intercept_weights, _) = tools.compute_smoothed_state_weights(res)\n    assert_allclose(actual, desired, atol=1e-12)\n    assert_allclose(actual_state_intercept_weights, desired_state_intercept_weights, atol=1e-12)",
            "def test_smoothed_state_obs_weights_collapsed(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    endog = np.zeros((20, 6))\n    endog[2, :] = np.nan\n    endog[6, 0] = np.nan\n    endog[7, :] = np.nan\n    endog[8, 1] = np.nan\n    mod = TVSS(endog)\n    mod['obs_intercept'] = np.zeros((6, 1))\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n    mod.ssm.filter_collapsed = True\n    res = mod.smooth([])\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = mod.clone(y)\n                tmp_mod['obs_intercept'] = np.zeros((6, 1))\n                tmp_mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n                mod.ssm.filter_collapsed = True\n                tmp_res = tmp_mod.smooth([])\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_state_intercept_weights = np.zeros((n, n, m, m)) * np.nan\n    for j in range(n):\n        for ell in range(m):\n            tmp_mod = mod.clone(endog)\n            tmp_mod['obs_intercept'] = np.zeros((6, 1))\n            tmp_mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n            mod.ssm.filter_collapsed = True\n            if tmp_mod['state_intercept'].ndim == 1:\n                si = tmp_mod['state_intercept']\n                tmp_mod['state_intercept'] = np.zeros((mod.k_states, mod.nobs))\n                tmp_mod['state_intercept', :, :] = si[:, None]\n            tmp_mod['state_intercept', ell, j] += 1.0\n            tmp_res = tmp_mod.ssm.smooth()\n            desired_state_intercept_weights[:, j, :, ell] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    (actual, actual_state_intercept_weights, _) = tools.compute_smoothed_state_weights(res)\n    assert_allclose(actual, desired, atol=1e-12)\n    assert_allclose(actual_state_intercept_weights, desired_state_intercept_weights, atol=1e-12)",
            "def test_smoothed_state_obs_weights_collapsed(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    endog = np.zeros((20, 6))\n    endog[2, :] = np.nan\n    endog[6, 0] = np.nan\n    endog[7, :] = np.nan\n    endog[8, 1] = np.nan\n    mod = TVSS(endog)\n    mod['obs_intercept'] = np.zeros((6, 1))\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n    mod.ssm.filter_collapsed = True\n    res = mod.smooth([])\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = mod.clone(y)\n                tmp_mod['obs_intercept'] = np.zeros((6, 1))\n                tmp_mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n                mod.ssm.filter_collapsed = True\n                tmp_res = tmp_mod.smooth([])\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_state_intercept_weights = np.zeros((n, n, m, m)) * np.nan\n    for j in range(n):\n        for ell in range(m):\n            tmp_mod = mod.clone(endog)\n            tmp_mod['obs_intercept'] = np.zeros((6, 1))\n            tmp_mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n            mod.ssm.filter_collapsed = True\n            if tmp_mod['state_intercept'].ndim == 1:\n                si = tmp_mod['state_intercept']\n                tmp_mod['state_intercept'] = np.zeros((mod.k_states, mod.nobs))\n                tmp_mod['state_intercept', :, :] = si[:, None]\n            tmp_mod['state_intercept', ell, j] += 1.0\n            tmp_res = tmp_mod.ssm.smooth()\n            desired_state_intercept_weights[:, j, :, ell] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    (actual, actual_state_intercept_weights, _) = tools.compute_smoothed_state_weights(res)\n    assert_allclose(actual, desired, atol=1e-12)\n    assert_allclose(actual_state_intercept_weights, desired_state_intercept_weights, atol=1e-12)",
            "def test_smoothed_state_obs_weights_collapsed(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    endog = np.zeros((20, 6))\n    endog[2, :] = np.nan\n    endog[6, 0] = np.nan\n    endog[7, :] = np.nan\n    endog[8, 1] = np.nan\n    mod = TVSS(endog)\n    mod['obs_intercept'] = np.zeros((6, 1))\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n    mod.ssm.filter_collapsed = True\n    res = mod.smooth([])\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = mod.clone(y)\n                tmp_mod['obs_intercept'] = np.zeros((6, 1))\n                tmp_mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n                mod.ssm.filter_collapsed = True\n                tmp_res = tmp_mod.smooth([])\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    desired_state_intercept_weights = np.zeros((n, n, m, m)) * np.nan\n    for j in range(n):\n        for ell in range(m):\n            tmp_mod = mod.clone(endog)\n            tmp_mod['obs_intercept'] = np.zeros((6, 1))\n            tmp_mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n            mod.ssm.filter_collapsed = True\n            if tmp_mod['state_intercept'].ndim == 1:\n                si = tmp_mod['state_intercept']\n                tmp_mod['state_intercept'] = np.zeros((mod.k_states, mod.nobs))\n                tmp_mod['state_intercept', :, :] = si[:, None]\n            tmp_mod['state_intercept', ell, j] += 1.0\n            tmp_res = tmp_mod.ssm.smooth()\n            desired_state_intercept_weights[:, j, :, ell] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    (actual, actual_state_intercept_weights, _) = tools.compute_smoothed_state_weights(res)\n    assert_allclose(actual, desired, atol=1e-12)\n    assert_allclose(actual_state_intercept_weights, desired_state_intercept_weights, atol=1e-12)"
        ]
    },
    {
        "func_name": "test_compute_t_compute_j",
        "original": "@pytest.mark.parametrize('compute_j', [np.arange(10), [0, 1, 2], [5, 0, 9], 8])\n@pytest.mark.parametrize('compute_t', [np.arange(10), [3, 2, 2], [0, 2, 5], 5])\ndef test_compute_t_compute_j(compute_j, compute_t, reset_randomstate):\n    endog = np.zeros((10, 6))\n    endog[2, :] = np.nan\n    endog[6, 0] = np.nan\n    endog[7, :] = np.nan\n    endog[8, 1] = np.nan\n    mod = TVSS(endog)\n    mod['obs_intercept'] = np.zeros((6, 1))\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n    mod.ssm.filter_collapsed = True\n    res = mod.smooth([])\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = mod.clone(y)\n                tmp_mod['obs_intercept'] = np.zeros((6, 1))\n                tmp_mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n                mod.ssm.filter_collapsed = True\n                tmp_res = tmp_mod.smooth([])\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    (actual, _, _) = tools.compute_smoothed_state_weights(res, compute_t=compute_t, compute_j=compute_j)\n    compute_t = np.unique(np.atleast_1d(compute_t))\n    compute_t.sort()\n    compute_j = np.unique(np.atleast_1d(compute_j))\n    compute_j.sort()\n    for t in np.arange(10):\n        if t not in compute_t:\n            desired[t, :] = np.nan\n    for j in np.arange(10):\n        if j not in compute_j:\n            desired[:, j] = np.nan\n    ix = np.ix_(compute_t, compute_j)\n    desired = desired[ix]\n    assert_allclose(actual, desired, atol=1e-07)",
        "mutated": [
            "@pytest.mark.parametrize('compute_j', [np.arange(10), [0, 1, 2], [5, 0, 9], 8])\n@pytest.mark.parametrize('compute_t', [np.arange(10), [3, 2, 2], [0, 2, 5], 5])\ndef test_compute_t_compute_j(compute_j, compute_t, reset_randomstate):\n    if False:\n        i = 10\n    endog = np.zeros((10, 6))\n    endog[2, :] = np.nan\n    endog[6, 0] = np.nan\n    endog[7, :] = np.nan\n    endog[8, 1] = np.nan\n    mod = TVSS(endog)\n    mod['obs_intercept'] = np.zeros((6, 1))\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n    mod.ssm.filter_collapsed = True\n    res = mod.smooth([])\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = mod.clone(y)\n                tmp_mod['obs_intercept'] = np.zeros((6, 1))\n                tmp_mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n                mod.ssm.filter_collapsed = True\n                tmp_res = tmp_mod.smooth([])\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    (actual, _, _) = tools.compute_smoothed_state_weights(res, compute_t=compute_t, compute_j=compute_j)\n    compute_t = np.unique(np.atleast_1d(compute_t))\n    compute_t.sort()\n    compute_j = np.unique(np.atleast_1d(compute_j))\n    compute_j.sort()\n    for t in np.arange(10):\n        if t not in compute_t:\n            desired[t, :] = np.nan\n    for j in np.arange(10):\n        if j not in compute_j:\n            desired[:, j] = np.nan\n    ix = np.ix_(compute_t, compute_j)\n    desired = desired[ix]\n    assert_allclose(actual, desired, atol=1e-07)",
            "@pytest.mark.parametrize('compute_j', [np.arange(10), [0, 1, 2], [5, 0, 9], 8])\n@pytest.mark.parametrize('compute_t', [np.arange(10), [3, 2, 2], [0, 2, 5], 5])\ndef test_compute_t_compute_j(compute_j, compute_t, reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    endog = np.zeros((10, 6))\n    endog[2, :] = np.nan\n    endog[6, 0] = np.nan\n    endog[7, :] = np.nan\n    endog[8, 1] = np.nan\n    mod = TVSS(endog)\n    mod['obs_intercept'] = np.zeros((6, 1))\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n    mod.ssm.filter_collapsed = True\n    res = mod.smooth([])\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = mod.clone(y)\n                tmp_mod['obs_intercept'] = np.zeros((6, 1))\n                tmp_mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n                mod.ssm.filter_collapsed = True\n                tmp_res = tmp_mod.smooth([])\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    (actual, _, _) = tools.compute_smoothed_state_weights(res, compute_t=compute_t, compute_j=compute_j)\n    compute_t = np.unique(np.atleast_1d(compute_t))\n    compute_t.sort()\n    compute_j = np.unique(np.atleast_1d(compute_j))\n    compute_j.sort()\n    for t in np.arange(10):\n        if t not in compute_t:\n            desired[t, :] = np.nan\n    for j in np.arange(10):\n        if j not in compute_j:\n            desired[:, j] = np.nan\n    ix = np.ix_(compute_t, compute_j)\n    desired = desired[ix]\n    assert_allclose(actual, desired, atol=1e-07)",
            "@pytest.mark.parametrize('compute_j', [np.arange(10), [0, 1, 2], [5, 0, 9], 8])\n@pytest.mark.parametrize('compute_t', [np.arange(10), [3, 2, 2], [0, 2, 5], 5])\ndef test_compute_t_compute_j(compute_j, compute_t, reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    endog = np.zeros((10, 6))\n    endog[2, :] = np.nan\n    endog[6, 0] = np.nan\n    endog[7, :] = np.nan\n    endog[8, 1] = np.nan\n    mod = TVSS(endog)\n    mod['obs_intercept'] = np.zeros((6, 1))\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n    mod.ssm.filter_collapsed = True\n    res = mod.smooth([])\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = mod.clone(y)\n                tmp_mod['obs_intercept'] = np.zeros((6, 1))\n                tmp_mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n                mod.ssm.filter_collapsed = True\n                tmp_res = tmp_mod.smooth([])\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    (actual, _, _) = tools.compute_smoothed_state_weights(res, compute_t=compute_t, compute_j=compute_j)\n    compute_t = np.unique(np.atleast_1d(compute_t))\n    compute_t.sort()\n    compute_j = np.unique(np.atleast_1d(compute_j))\n    compute_j.sort()\n    for t in np.arange(10):\n        if t not in compute_t:\n            desired[t, :] = np.nan\n    for j in np.arange(10):\n        if j not in compute_j:\n            desired[:, j] = np.nan\n    ix = np.ix_(compute_t, compute_j)\n    desired = desired[ix]\n    assert_allclose(actual, desired, atol=1e-07)",
            "@pytest.mark.parametrize('compute_j', [np.arange(10), [0, 1, 2], [5, 0, 9], 8])\n@pytest.mark.parametrize('compute_t', [np.arange(10), [3, 2, 2], [0, 2, 5], 5])\ndef test_compute_t_compute_j(compute_j, compute_t, reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    endog = np.zeros((10, 6))\n    endog[2, :] = np.nan\n    endog[6, 0] = np.nan\n    endog[7, :] = np.nan\n    endog[8, 1] = np.nan\n    mod = TVSS(endog)\n    mod['obs_intercept'] = np.zeros((6, 1))\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n    mod.ssm.filter_collapsed = True\n    res = mod.smooth([])\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = mod.clone(y)\n                tmp_mod['obs_intercept'] = np.zeros((6, 1))\n                tmp_mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n                mod.ssm.filter_collapsed = True\n                tmp_res = tmp_mod.smooth([])\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    (actual, _, _) = tools.compute_smoothed_state_weights(res, compute_t=compute_t, compute_j=compute_j)\n    compute_t = np.unique(np.atleast_1d(compute_t))\n    compute_t.sort()\n    compute_j = np.unique(np.atleast_1d(compute_j))\n    compute_j.sort()\n    for t in np.arange(10):\n        if t not in compute_t:\n            desired[t, :] = np.nan\n    for j in np.arange(10):\n        if j not in compute_j:\n            desired[:, j] = np.nan\n    ix = np.ix_(compute_t, compute_j)\n    desired = desired[ix]\n    assert_allclose(actual, desired, atol=1e-07)",
            "@pytest.mark.parametrize('compute_j', [np.arange(10), [0, 1, 2], [5, 0, 9], 8])\n@pytest.mark.parametrize('compute_t', [np.arange(10), [3, 2, 2], [0, 2, 5], 5])\ndef test_compute_t_compute_j(compute_j, compute_t, reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    endog = np.zeros((10, 6))\n    endog[2, :] = np.nan\n    endog[6, 0] = np.nan\n    endog[7, :] = np.nan\n    endog[8, 1] = np.nan\n    mod = TVSS(endog)\n    mod['obs_intercept'] = np.zeros((6, 1))\n    mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n    mod.ssm.filter_collapsed = True\n    res = mod.smooth([])\n    n = mod.nobs\n    m = mod.k_states\n    p = mod.k_endog\n    desired = np.zeros((n, n, m, p)) * np.nan\n    for j in range(n):\n        for i in range(p):\n            if np.isnan(endog[j, i]):\n                desired[:, j, :, i] = np.nan\n            else:\n                y = endog.copy()\n                y[j, i] = 1.0\n                tmp_mod = mod.clone(y)\n                tmp_mod['obs_intercept'] = np.zeros((6, 1))\n                tmp_mod.ssm.initialize_known([1.2, 0.8], np.eye(2))\n                mod.ssm.filter_collapsed = True\n                tmp_res = tmp_mod.smooth([])\n                desired[:, j, :, i] = tmp_res.smoothed_state.T - res.smoothed_state.T\n    (actual, _, _) = tools.compute_smoothed_state_weights(res, compute_t=compute_t, compute_j=compute_j)\n    compute_t = np.unique(np.atleast_1d(compute_t))\n    compute_t.sort()\n    compute_j = np.unique(np.atleast_1d(compute_j))\n    compute_j.sort()\n    for t in np.arange(10):\n        if t not in compute_t:\n            desired[t, :] = np.nan\n    for j in np.arange(10):\n        if j not in compute_j:\n            desired[:, j] = np.nan\n    ix = np.ix_(compute_t, compute_j)\n    desired = desired[ix]\n    assert_allclose(actual, desired, atol=1e-07)"
        ]
    },
    {
        "func_name": "test_resmooth",
        "original": "def test_resmooth():\n    endog = [0.1, -0.3, -0.1, 0.5, 0.02]\n    mod = sarimax.SARIMAX(endog, order=(1, 0, 0), measurement_error=True)\n    res1 = mod.smooth([0.5, 2.0, 1.0])\n    (weights1_original, _, _) = tools.compute_smoothed_state_weights(res1, resmooth=False)\n    res2 = mod.smooth([0.2, 1.0, 1.2])\n    (weights2_original, _, _) = tools.compute_smoothed_state_weights(res2, resmooth=False)\n    (weights1_no_resmooth, _, _) = tools.compute_smoothed_state_weights(res1, resmooth=False)\n    (weights1_resmooth, _, _) = tools.compute_smoothed_state_weights(res1, resmooth=True)\n    (weights2_no_resmooth, _, _) = tools.compute_smoothed_state_weights(res2, resmooth=False)\n    (weights2_resmooth, _, _) = tools.compute_smoothed_state_weights(res2, resmooth=True)\n    (weights1_default, _, _) = tools.compute_smoothed_state_weights(res1)\n    (weights2_default, _, _) = tools.compute_smoothed_state_weights(res2)\n    assert_allclose(weights1_no_resmooth, weights2_original)\n    assert_allclose(weights1_resmooth, weights1_original)\n    assert_allclose(weights1_default, weights1_original)\n    assert_allclose(weights2_no_resmooth, weights1_original)\n    assert_allclose(weights2_resmooth, weights2_original)\n    assert_allclose(weights2_default, weights2_original)",
        "mutated": [
            "def test_resmooth():\n    if False:\n        i = 10\n    endog = [0.1, -0.3, -0.1, 0.5, 0.02]\n    mod = sarimax.SARIMAX(endog, order=(1, 0, 0), measurement_error=True)\n    res1 = mod.smooth([0.5, 2.0, 1.0])\n    (weights1_original, _, _) = tools.compute_smoothed_state_weights(res1, resmooth=False)\n    res2 = mod.smooth([0.2, 1.0, 1.2])\n    (weights2_original, _, _) = tools.compute_smoothed_state_weights(res2, resmooth=False)\n    (weights1_no_resmooth, _, _) = tools.compute_smoothed_state_weights(res1, resmooth=False)\n    (weights1_resmooth, _, _) = tools.compute_smoothed_state_weights(res1, resmooth=True)\n    (weights2_no_resmooth, _, _) = tools.compute_smoothed_state_weights(res2, resmooth=False)\n    (weights2_resmooth, _, _) = tools.compute_smoothed_state_weights(res2, resmooth=True)\n    (weights1_default, _, _) = tools.compute_smoothed_state_weights(res1)\n    (weights2_default, _, _) = tools.compute_smoothed_state_weights(res2)\n    assert_allclose(weights1_no_resmooth, weights2_original)\n    assert_allclose(weights1_resmooth, weights1_original)\n    assert_allclose(weights1_default, weights1_original)\n    assert_allclose(weights2_no_resmooth, weights1_original)\n    assert_allclose(weights2_resmooth, weights2_original)\n    assert_allclose(weights2_default, weights2_original)",
            "def test_resmooth():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    endog = [0.1, -0.3, -0.1, 0.5, 0.02]\n    mod = sarimax.SARIMAX(endog, order=(1, 0, 0), measurement_error=True)\n    res1 = mod.smooth([0.5, 2.0, 1.0])\n    (weights1_original, _, _) = tools.compute_smoothed_state_weights(res1, resmooth=False)\n    res2 = mod.smooth([0.2, 1.0, 1.2])\n    (weights2_original, _, _) = tools.compute_smoothed_state_weights(res2, resmooth=False)\n    (weights1_no_resmooth, _, _) = tools.compute_smoothed_state_weights(res1, resmooth=False)\n    (weights1_resmooth, _, _) = tools.compute_smoothed_state_weights(res1, resmooth=True)\n    (weights2_no_resmooth, _, _) = tools.compute_smoothed_state_weights(res2, resmooth=False)\n    (weights2_resmooth, _, _) = tools.compute_smoothed_state_weights(res2, resmooth=True)\n    (weights1_default, _, _) = tools.compute_smoothed_state_weights(res1)\n    (weights2_default, _, _) = tools.compute_smoothed_state_weights(res2)\n    assert_allclose(weights1_no_resmooth, weights2_original)\n    assert_allclose(weights1_resmooth, weights1_original)\n    assert_allclose(weights1_default, weights1_original)\n    assert_allclose(weights2_no_resmooth, weights1_original)\n    assert_allclose(weights2_resmooth, weights2_original)\n    assert_allclose(weights2_default, weights2_original)",
            "def test_resmooth():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    endog = [0.1, -0.3, -0.1, 0.5, 0.02]\n    mod = sarimax.SARIMAX(endog, order=(1, 0, 0), measurement_error=True)\n    res1 = mod.smooth([0.5, 2.0, 1.0])\n    (weights1_original, _, _) = tools.compute_smoothed_state_weights(res1, resmooth=False)\n    res2 = mod.smooth([0.2, 1.0, 1.2])\n    (weights2_original, _, _) = tools.compute_smoothed_state_weights(res2, resmooth=False)\n    (weights1_no_resmooth, _, _) = tools.compute_smoothed_state_weights(res1, resmooth=False)\n    (weights1_resmooth, _, _) = tools.compute_smoothed_state_weights(res1, resmooth=True)\n    (weights2_no_resmooth, _, _) = tools.compute_smoothed_state_weights(res2, resmooth=False)\n    (weights2_resmooth, _, _) = tools.compute_smoothed_state_weights(res2, resmooth=True)\n    (weights1_default, _, _) = tools.compute_smoothed_state_weights(res1)\n    (weights2_default, _, _) = tools.compute_smoothed_state_weights(res2)\n    assert_allclose(weights1_no_resmooth, weights2_original)\n    assert_allclose(weights1_resmooth, weights1_original)\n    assert_allclose(weights1_default, weights1_original)\n    assert_allclose(weights2_no_resmooth, weights1_original)\n    assert_allclose(weights2_resmooth, weights2_original)\n    assert_allclose(weights2_default, weights2_original)",
            "def test_resmooth():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    endog = [0.1, -0.3, -0.1, 0.5, 0.02]\n    mod = sarimax.SARIMAX(endog, order=(1, 0, 0), measurement_error=True)\n    res1 = mod.smooth([0.5, 2.0, 1.0])\n    (weights1_original, _, _) = tools.compute_smoothed_state_weights(res1, resmooth=False)\n    res2 = mod.smooth([0.2, 1.0, 1.2])\n    (weights2_original, _, _) = tools.compute_smoothed_state_weights(res2, resmooth=False)\n    (weights1_no_resmooth, _, _) = tools.compute_smoothed_state_weights(res1, resmooth=False)\n    (weights1_resmooth, _, _) = tools.compute_smoothed_state_weights(res1, resmooth=True)\n    (weights2_no_resmooth, _, _) = tools.compute_smoothed_state_weights(res2, resmooth=False)\n    (weights2_resmooth, _, _) = tools.compute_smoothed_state_weights(res2, resmooth=True)\n    (weights1_default, _, _) = tools.compute_smoothed_state_weights(res1)\n    (weights2_default, _, _) = tools.compute_smoothed_state_weights(res2)\n    assert_allclose(weights1_no_resmooth, weights2_original)\n    assert_allclose(weights1_resmooth, weights1_original)\n    assert_allclose(weights1_default, weights1_original)\n    assert_allclose(weights2_no_resmooth, weights1_original)\n    assert_allclose(weights2_resmooth, weights2_original)\n    assert_allclose(weights2_default, weights2_original)",
            "def test_resmooth():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    endog = [0.1, -0.3, -0.1, 0.5, 0.02]\n    mod = sarimax.SARIMAX(endog, order=(1, 0, 0), measurement_error=True)\n    res1 = mod.smooth([0.5, 2.0, 1.0])\n    (weights1_original, _, _) = tools.compute_smoothed_state_weights(res1, resmooth=False)\n    res2 = mod.smooth([0.2, 1.0, 1.2])\n    (weights2_original, _, _) = tools.compute_smoothed_state_weights(res2, resmooth=False)\n    (weights1_no_resmooth, _, _) = tools.compute_smoothed_state_weights(res1, resmooth=False)\n    (weights1_resmooth, _, _) = tools.compute_smoothed_state_weights(res1, resmooth=True)\n    (weights2_no_resmooth, _, _) = tools.compute_smoothed_state_weights(res2, resmooth=False)\n    (weights2_resmooth, _, _) = tools.compute_smoothed_state_weights(res2, resmooth=True)\n    (weights1_default, _, _) = tools.compute_smoothed_state_weights(res1)\n    (weights2_default, _, _) = tools.compute_smoothed_state_weights(res2)\n    assert_allclose(weights1_no_resmooth, weights2_original)\n    assert_allclose(weights1_resmooth, weights1_original)\n    assert_allclose(weights1_default, weights1_original)\n    assert_allclose(weights2_no_resmooth, weights1_original)\n    assert_allclose(weights2_resmooth, weights2_original)\n    assert_allclose(weights2_default, weights2_original)"
        ]
    }
]