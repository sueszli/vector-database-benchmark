[
    {
        "func_name": "_write_obj",
        "original": "def _write_obj(points, out_filename):\n    \"\"\"Write points into ``obj`` format for meshlab visualization.\n\n    Args:\n        points (np.ndarray): Points in shape (N, dim).\n        out_filename (str): Filename to be saved.\n    \"\"\"\n    N = points.shape[0]\n    fout = open(out_filename, 'w')\n    for i in range(N):\n        if points.shape[1] == 6:\n            c = points[i, 3:].astype(int)\n            fout.write('v %f %f %f %d %d %d\\n' % (points[i, 0], points[i, 1], points[i, 2], c[0], c[1], c[2]))\n        else:\n            fout.write('v %f %f %f\\n' % (points[i, 0], points[i, 1], points[i, 2]))\n    fout.close()",
        "mutated": [
            "def _write_obj(points, out_filename):\n    if False:\n        i = 10\n    'Write points into ``obj`` format for meshlab visualization.\\n\\n    Args:\\n        points (np.ndarray): Points in shape (N, dim).\\n        out_filename (str): Filename to be saved.\\n    '\n    N = points.shape[0]\n    fout = open(out_filename, 'w')\n    for i in range(N):\n        if points.shape[1] == 6:\n            c = points[i, 3:].astype(int)\n            fout.write('v %f %f %f %d %d %d\\n' % (points[i, 0], points[i, 1], points[i, 2], c[0], c[1], c[2]))\n        else:\n            fout.write('v %f %f %f\\n' % (points[i, 0], points[i, 1], points[i, 2]))\n    fout.close()",
            "def _write_obj(points, out_filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Write points into ``obj`` format for meshlab visualization.\\n\\n    Args:\\n        points (np.ndarray): Points in shape (N, dim).\\n        out_filename (str): Filename to be saved.\\n    '\n    N = points.shape[0]\n    fout = open(out_filename, 'w')\n    for i in range(N):\n        if points.shape[1] == 6:\n            c = points[i, 3:].astype(int)\n            fout.write('v %f %f %f %d %d %d\\n' % (points[i, 0], points[i, 1], points[i, 2], c[0], c[1], c[2]))\n        else:\n            fout.write('v %f %f %f\\n' % (points[i, 0], points[i, 1], points[i, 2]))\n    fout.close()",
            "def _write_obj(points, out_filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Write points into ``obj`` format for meshlab visualization.\\n\\n    Args:\\n        points (np.ndarray): Points in shape (N, dim).\\n        out_filename (str): Filename to be saved.\\n    '\n    N = points.shape[0]\n    fout = open(out_filename, 'w')\n    for i in range(N):\n        if points.shape[1] == 6:\n            c = points[i, 3:].astype(int)\n            fout.write('v %f %f %f %d %d %d\\n' % (points[i, 0], points[i, 1], points[i, 2], c[0], c[1], c[2]))\n        else:\n            fout.write('v %f %f %f\\n' % (points[i, 0], points[i, 1], points[i, 2]))\n    fout.close()",
            "def _write_obj(points, out_filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Write points into ``obj`` format for meshlab visualization.\\n\\n    Args:\\n        points (np.ndarray): Points in shape (N, dim).\\n        out_filename (str): Filename to be saved.\\n    '\n    N = points.shape[0]\n    fout = open(out_filename, 'w')\n    for i in range(N):\n        if points.shape[1] == 6:\n            c = points[i, 3:].astype(int)\n            fout.write('v %f %f %f %d %d %d\\n' % (points[i, 0], points[i, 1], points[i, 2], c[0], c[1], c[2]))\n        else:\n            fout.write('v %f %f %f\\n' % (points[i, 0], points[i, 1], points[i, 2]))\n    fout.close()",
            "def _write_obj(points, out_filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Write points into ``obj`` format for meshlab visualization.\\n\\n    Args:\\n        points (np.ndarray): Points in shape (N, dim).\\n        out_filename (str): Filename to be saved.\\n    '\n    N = points.shape[0]\n    fout = open(out_filename, 'w')\n    for i in range(N):\n        if points.shape[1] == 6:\n            c = points[i, 3:].astype(int)\n            fout.write('v %f %f %f %d %d %d\\n' % (points[i, 0], points[i, 1], points[i, 2], c[0], c[1], c[2]))\n        else:\n            fout.write('v %f %f %f\\n' % (points[i, 0], points[i, 1], points[i, 2]))\n    fout.close()"
        ]
    },
    {
        "func_name": "heading2rotmat",
        "original": "def heading2rotmat(heading_angle):\n    rotmat = np.zeros((3, 3))\n    rotmat[2, 2] = 1\n    cosval = np.cos(heading_angle)\n    sinval = np.sin(heading_angle)\n    rotmat[0:2, 0:2] = np.array([[cosval, -sinval], [sinval, cosval]])\n    return rotmat",
        "mutated": [
            "def heading2rotmat(heading_angle):\n    if False:\n        i = 10\n    rotmat = np.zeros((3, 3))\n    rotmat[2, 2] = 1\n    cosval = np.cos(heading_angle)\n    sinval = np.sin(heading_angle)\n    rotmat[0:2, 0:2] = np.array([[cosval, -sinval], [sinval, cosval]])\n    return rotmat",
            "def heading2rotmat(heading_angle):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rotmat = np.zeros((3, 3))\n    rotmat[2, 2] = 1\n    cosval = np.cos(heading_angle)\n    sinval = np.sin(heading_angle)\n    rotmat[0:2, 0:2] = np.array([[cosval, -sinval], [sinval, cosval]])\n    return rotmat",
            "def heading2rotmat(heading_angle):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rotmat = np.zeros((3, 3))\n    rotmat[2, 2] = 1\n    cosval = np.cos(heading_angle)\n    sinval = np.sin(heading_angle)\n    rotmat[0:2, 0:2] = np.array([[cosval, -sinval], [sinval, cosval]])\n    return rotmat",
            "def heading2rotmat(heading_angle):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rotmat = np.zeros((3, 3))\n    rotmat[2, 2] = 1\n    cosval = np.cos(heading_angle)\n    sinval = np.sin(heading_angle)\n    rotmat[0:2, 0:2] = np.array([[cosval, -sinval], [sinval, cosval]])\n    return rotmat",
            "def heading2rotmat(heading_angle):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rotmat = np.zeros((3, 3))\n    rotmat[2, 2] = 1\n    cosval = np.cos(heading_angle)\n    sinval = np.sin(heading_angle)\n    rotmat[0:2, 0:2] = np.array([[cosval, -sinval], [sinval, cosval]])\n    return rotmat"
        ]
    },
    {
        "func_name": "convert_oriented_box_to_trimesh_fmt",
        "original": "def convert_oriented_box_to_trimesh_fmt(box):\n    ctr = box[:3]\n    lengths = box[3:6]\n    trns = np.eye(4)\n    trns[0:3, 3] = ctr\n    trns[3, 3] = 1.0\n    trns[0:3, 0:3] = heading2rotmat(box[6])\n    box_trimesh_fmt = trimesh.creation.box(lengths, trns)\n    return box_trimesh_fmt",
        "mutated": [
            "def convert_oriented_box_to_trimesh_fmt(box):\n    if False:\n        i = 10\n    ctr = box[:3]\n    lengths = box[3:6]\n    trns = np.eye(4)\n    trns[0:3, 3] = ctr\n    trns[3, 3] = 1.0\n    trns[0:3, 0:3] = heading2rotmat(box[6])\n    box_trimesh_fmt = trimesh.creation.box(lengths, trns)\n    return box_trimesh_fmt",
            "def convert_oriented_box_to_trimesh_fmt(box):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ctr = box[:3]\n    lengths = box[3:6]\n    trns = np.eye(4)\n    trns[0:3, 3] = ctr\n    trns[3, 3] = 1.0\n    trns[0:3, 0:3] = heading2rotmat(box[6])\n    box_trimesh_fmt = trimesh.creation.box(lengths, trns)\n    return box_trimesh_fmt",
            "def convert_oriented_box_to_trimesh_fmt(box):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ctr = box[:3]\n    lengths = box[3:6]\n    trns = np.eye(4)\n    trns[0:3, 3] = ctr\n    trns[3, 3] = 1.0\n    trns[0:3, 0:3] = heading2rotmat(box[6])\n    box_trimesh_fmt = trimesh.creation.box(lengths, trns)\n    return box_trimesh_fmt",
            "def convert_oriented_box_to_trimesh_fmt(box):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ctr = box[:3]\n    lengths = box[3:6]\n    trns = np.eye(4)\n    trns[0:3, 3] = ctr\n    trns[3, 3] = 1.0\n    trns[0:3, 0:3] = heading2rotmat(box[6])\n    box_trimesh_fmt = trimesh.creation.box(lengths, trns)\n    return box_trimesh_fmt",
            "def convert_oriented_box_to_trimesh_fmt(box):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ctr = box[:3]\n    lengths = box[3:6]\n    trns = np.eye(4)\n    trns[0:3, 3] = ctr\n    trns[3, 3] = 1.0\n    trns[0:3, 0:3] = heading2rotmat(box[6])\n    box_trimesh_fmt = trimesh.creation.box(lengths, trns)\n    return box_trimesh_fmt"
        ]
    },
    {
        "func_name": "_write_oriented_bbox",
        "original": "def _write_oriented_bbox(scene_bbox, out_filename):\n    \"\"\"Export oriented (around Z axis) scene bbox to meshes.\n\n    Args:\n        scene_bbox(list[ndarray] or ndarray): xyz pos of center and\n            3 lengths (x_size, y_size, z_size) and heading angle around Z axis.\n            Y forward, X right, Z upward. heading angle of positive X is 0,\n            heading angle of positive Y is 90 degrees.\n        out_filename(str): Filename.\n    \"\"\"\n\n    def heading2rotmat(heading_angle):\n        rotmat = np.zeros((3, 3))\n        rotmat[2, 2] = 1\n        cosval = np.cos(heading_angle)\n        sinval = np.sin(heading_angle)\n        rotmat[0:2, 0:2] = np.array([[cosval, -sinval], [sinval, cosval]])\n        return rotmat\n\n    def convert_oriented_box_to_trimesh_fmt(box):\n        ctr = box[:3]\n        lengths = box[3:6]\n        trns = np.eye(4)\n        trns[0:3, 3] = ctr\n        trns[3, 3] = 1.0\n        trns[0:3, 0:3] = heading2rotmat(box[6])\n        box_trimesh_fmt = trimesh.creation.box(lengths, trns)\n        return box_trimesh_fmt\n    if len(scene_bbox) == 0:\n        scene_bbox = np.zeros((1, 7))\n    scene = trimesh.scene.Scene()\n    for box in scene_bbox:\n        scene.add_geometry(convert_oriented_box_to_trimesh_fmt(box))\n    mesh_list = trimesh.util.concatenate(scene.dump())\n    trimesh.io.export.export_mesh(mesh_list, out_filename, file_type='obj')\n    return",
        "mutated": [
            "def _write_oriented_bbox(scene_bbox, out_filename):\n    if False:\n        i = 10\n    'Export oriented (around Z axis) scene bbox to meshes.\\n\\n    Args:\\n        scene_bbox(list[ndarray] or ndarray): xyz pos of center and\\n            3 lengths (x_size, y_size, z_size) and heading angle around Z axis.\\n            Y forward, X right, Z upward. heading angle of positive X is 0,\\n            heading angle of positive Y is 90 degrees.\\n        out_filename(str): Filename.\\n    '\n\n    def heading2rotmat(heading_angle):\n        rotmat = np.zeros((3, 3))\n        rotmat[2, 2] = 1\n        cosval = np.cos(heading_angle)\n        sinval = np.sin(heading_angle)\n        rotmat[0:2, 0:2] = np.array([[cosval, -sinval], [sinval, cosval]])\n        return rotmat\n\n    def convert_oriented_box_to_trimesh_fmt(box):\n        ctr = box[:3]\n        lengths = box[3:6]\n        trns = np.eye(4)\n        trns[0:3, 3] = ctr\n        trns[3, 3] = 1.0\n        trns[0:3, 0:3] = heading2rotmat(box[6])\n        box_trimesh_fmt = trimesh.creation.box(lengths, trns)\n        return box_trimesh_fmt\n    if len(scene_bbox) == 0:\n        scene_bbox = np.zeros((1, 7))\n    scene = trimesh.scene.Scene()\n    for box in scene_bbox:\n        scene.add_geometry(convert_oriented_box_to_trimesh_fmt(box))\n    mesh_list = trimesh.util.concatenate(scene.dump())\n    trimesh.io.export.export_mesh(mesh_list, out_filename, file_type='obj')\n    return",
            "def _write_oriented_bbox(scene_bbox, out_filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Export oriented (around Z axis) scene bbox to meshes.\\n\\n    Args:\\n        scene_bbox(list[ndarray] or ndarray): xyz pos of center and\\n            3 lengths (x_size, y_size, z_size) and heading angle around Z axis.\\n            Y forward, X right, Z upward. heading angle of positive X is 0,\\n            heading angle of positive Y is 90 degrees.\\n        out_filename(str): Filename.\\n    '\n\n    def heading2rotmat(heading_angle):\n        rotmat = np.zeros((3, 3))\n        rotmat[2, 2] = 1\n        cosval = np.cos(heading_angle)\n        sinval = np.sin(heading_angle)\n        rotmat[0:2, 0:2] = np.array([[cosval, -sinval], [sinval, cosval]])\n        return rotmat\n\n    def convert_oriented_box_to_trimesh_fmt(box):\n        ctr = box[:3]\n        lengths = box[3:6]\n        trns = np.eye(4)\n        trns[0:3, 3] = ctr\n        trns[3, 3] = 1.0\n        trns[0:3, 0:3] = heading2rotmat(box[6])\n        box_trimesh_fmt = trimesh.creation.box(lengths, trns)\n        return box_trimesh_fmt\n    if len(scene_bbox) == 0:\n        scene_bbox = np.zeros((1, 7))\n    scene = trimesh.scene.Scene()\n    for box in scene_bbox:\n        scene.add_geometry(convert_oriented_box_to_trimesh_fmt(box))\n    mesh_list = trimesh.util.concatenate(scene.dump())\n    trimesh.io.export.export_mesh(mesh_list, out_filename, file_type='obj')\n    return",
            "def _write_oriented_bbox(scene_bbox, out_filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Export oriented (around Z axis) scene bbox to meshes.\\n\\n    Args:\\n        scene_bbox(list[ndarray] or ndarray): xyz pos of center and\\n            3 lengths (x_size, y_size, z_size) and heading angle around Z axis.\\n            Y forward, X right, Z upward. heading angle of positive X is 0,\\n            heading angle of positive Y is 90 degrees.\\n        out_filename(str): Filename.\\n    '\n\n    def heading2rotmat(heading_angle):\n        rotmat = np.zeros((3, 3))\n        rotmat[2, 2] = 1\n        cosval = np.cos(heading_angle)\n        sinval = np.sin(heading_angle)\n        rotmat[0:2, 0:2] = np.array([[cosval, -sinval], [sinval, cosval]])\n        return rotmat\n\n    def convert_oriented_box_to_trimesh_fmt(box):\n        ctr = box[:3]\n        lengths = box[3:6]\n        trns = np.eye(4)\n        trns[0:3, 3] = ctr\n        trns[3, 3] = 1.0\n        trns[0:3, 0:3] = heading2rotmat(box[6])\n        box_trimesh_fmt = trimesh.creation.box(lengths, trns)\n        return box_trimesh_fmt\n    if len(scene_bbox) == 0:\n        scene_bbox = np.zeros((1, 7))\n    scene = trimesh.scene.Scene()\n    for box in scene_bbox:\n        scene.add_geometry(convert_oriented_box_to_trimesh_fmt(box))\n    mesh_list = trimesh.util.concatenate(scene.dump())\n    trimesh.io.export.export_mesh(mesh_list, out_filename, file_type='obj')\n    return",
            "def _write_oriented_bbox(scene_bbox, out_filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Export oriented (around Z axis) scene bbox to meshes.\\n\\n    Args:\\n        scene_bbox(list[ndarray] or ndarray): xyz pos of center and\\n            3 lengths (x_size, y_size, z_size) and heading angle around Z axis.\\n            Y forward, X right, Z upward. heading angle of positive X is 0,\\n            heading angle of positive Y is 90 degrees.\\n        out_filename(str): Filename.\\n    '\n\n    def heading2rotmat(heading_angle):\n        rotmat = np.zeros((3, 3))\n        rotmat[2, 2] = 1\n        cosval = np.cos(heading_angle)\n        sinval = np.sin(heading_angle)\n        rotmat[0:2, 0:2] = np.array([[cosval, -sinval], [sinval, cosval]])\n        return rotmat\n\n    def convert_oriented_box_to_trimesh_fmt(box):\n        ctr = box[:3]\n        lengths = box[3:6]\n        trns = np.eye(4)\n        trns[0:3, 3] = ctr\n        trns[3, 3] = 1.0\n        trns[0:3, 0:3] = heading2rotmat(box[6])\n        box_trimesh_fmt = trimesh.creation.box(lengths, trns)\n        return box_trimesh_fmt\n    if len(scene_bbox) == 0:\n        scene_bbox = np.zeros((1, 7))\n    scene = trimesh.scene.Scene()\n    for box in scene_bbox:\n        scene.add_geometry(convert_oriented_box_to_trimesh_fmt(box))\n    mesh_list = trimesh.util.concatenate(scene.dump())\n    trimesh.io.export.export_mesh(mesh_list, out_filename, file_type='obj')\n    return",
            "def _write_oriented_bbox(scene_bbox, out_filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Export oriented (around Z axis) scene bbox to meshes.\\n\\n    Args:\\n        scene_bbox(list[ndarray] or ndarray): xyz pos of center and\\n            3 lengths (x_size, y_size, z_size) and heading angle around Z axis.\\n            Y forward, X right, Z upward. heading angle of positive X is 0,\\n            heading angle of positive Y is 90 degrees.\\n        out_filename(str): Filename.\\n    '\n\n    def heading2rotmat(heading_angle):\n        rotmat = np.zeros((3, 3))\n        rotmat[2, 2] = 1\n        cosval = np.cos(heading_angle)\n        sinval = np.sin(heading_angle)\n        rotmat[0:2, 0:2] = np.array([[cosval, -sinval], [sinval, cosval]])\n        return rotmat\n\n    def convert_oriented_box_to_trimesh_fmt(box):\n        ctr = box[:3]\n        lengths = box[3:6]\n        trns = np.eye(4)\n        trns[0:3, 3] = ctr\n        trns[3, 3] = 1.0\n        trns[0:3, 0:3] = heading2rotmat(box[6])\n        box_trimesh_fmt = trimesh.creation.box(lengths, trns)\n        return box_trimesh_fmt\n    if len(scene_bbox) == 0:\n        scene_bbox = np.zeros((1, 7))\n    scene = trimesh.scene.Scene()\n    for box in scene_bbox:\n        scene.add_geometry(convert_oriented_box_to_trimesh_fmt(box))\n    mesh_list = trimesh.util.concatenate(scene.dump())\n    trimesh.io.export.export_mesh(mesh_list, out_filename, file_type='obj')\n    return"
        ]
    },
    {
        "func_name": "show_result",
        "original": "def show_result(points, gt_bboxes, pred_bboxes, out_dir, filename, show=False, snapshot=False, pred_labels=None):\n    \"\"\"Convert results into format that is directly readable for meshlab.\n\n    Args:\n        points (np.ndarray): Points.\n        gt_bboxes (np.ndarray): Ground truth boxes.\n        pred_bboxes (np.ndarray): Predicted boxes.\n        out_dir (str): Path of output directory\n        filename (str): Filename of the current frame.\n        show (bool, optional): Visualize the results online. Defaults to False.\n        snapshot (bool, optional): Whether to save the online results.\n            Defaults to False.\n        pred_labels (np.ndarray, optional): Predicted labels of boxes.\n            Defaults to None.\n    \"\"\"\n    result_path = osp.join(out_dir, filename)\n    mmcv.mkdir_or_exist(result_path)\n    if show:\n        from .open3d_vis import Visualizer\n        vis = Visualizer(points)\n        if pred_bboxes is not None:\n            if pred_labels is None or pred_labels.numel() == 0:\n                vis.add_bboxes(bbox3d=pred_bboxes)\n            else:\n                palette = np.random.randint(0, 255, size=(pred_labels.max() + 1, 3)) / 256\n                labelDict = {}\n                for j in range(len(pred_labels)):\n                    i = int(pred_labels[j].numpy())\n                    if labelDict.get(i) is None:\n                        labelDict[i] = []\n                    labelDict[i].append(pred_bboxes[j])\n                for i in labelDict:\n                    vis.add_bboxes(bbox3d=np.array(labelDict[i]), bbox_color=palette[i], points_in_box_color=palette[i])\n        if gt_bboxes is not None:\n            vis.add_bboxes(bbox3d=gt_bboxes, bbox_color=(0, 0, 1))\n        show_path = osp.join(result_path, f'{filename}_online.png') if snapshot else None\n        vis.show(show_path)\n    if points is not None:\n        _write_obj(points, osp.join(result_path, f'{filename}_points.obj'))\n    if gt_bboxes is not None:\n        gt_bboxes[..., 2] += gt_bboxes[..., 5] / 2\n        _write_oriented_bbox(gt_bboxes, osp.join(result_path, f'{filename}_gt.obj'))\n    if pred_bboxes is not None:\n        pred_bboxes[..., 2] += pred_bboxes[..., 5] / 2\n        _write_oriented_bbox(pred_bboxes, osp.join(result_path, f'{filename}_pred.obj'))",
        "mutated": [
            "def show_result(points, gt_bboxes, pred_bboxes, out_dir, filename, show=False, snapshot=False, pred_labels=None):\n    if False:\n        i = 10\n    'Convert results into format that is directly readable for meshlab.\\n\\n    Args:\\n        points (np.ndarray): Points.\\n        gt_bboxes (np.ndarray): Ground truth boxes.\\n        pred_bboxes (np.ndarray): Predicted boxes.\\n        out_dir (str): Path of output directory\\n        filename (str): Filename of the current frame.\\n        show (bool, optional): Visualize the results online. Defaults to False.\\n        snapshot (bool, optional): Whether to save the online results.\\n            Defaults to False.\\n        pred_labels (np.ndarray, optional): Predicted labels of boxes.\\n            Defaults to None.\\n    '\n    result_path = osp.join(out_dir, filename)\n    mmcv.mkdir_or_exist(result_path)\n    if show:\n        from .open3d_vis import Visualizer\n        vis = Visualizer(points)\n        if pred_bboxes is not None:\n            if pred_labels is None or pred_labels.numel() == 0:\n                vis.add_bboxes(bbox3d=pred_bboxes)\n            else:\n                palette = np.random.randint(0, 255, size=(pred_labels.max() + 1, 3)) / 256\n                labelDict = {}\n                for j in range(len(pred_labels)):\n                    i = int(pred_labels[j].numpy())\n                    if labelDict.get(i) is None:\n                        labelDict[i] = []\n                    labelDict[i].append(pred_bboxes[j])\n                for i in labelDict:\n                    vis.add_bboxes(bbox3d=np.array(labelDict[i]), bbox_color=palette[i], points_in_box_color=palette[i])\n        if gt_bboxes is not None:\n            vis.add_bboxes(bbox3d=gt_bboxes, bbox_color=(0, 0, 1))\n        show_path = osp.join(result_path, f'{filename}_online.png') if snapshot else None\n        vis.show(show_path)\n    if points is not None:\n        _write_obj(points, osp.join(result_path, f'{filename}_points.obj'))\n    if gt_bboxes is not None:\n        gt_bboxes[..., 2] += gt_bboxes[..., 5] / 2\n        _write_oriented_bbox(gt_bboxes, osp.join(result_path, f'{filename}_gt.obj'))\n    if pred_bboxes is not None:\n        pred_bboxes[..., 2] += pred_bboxes[..., 5] / 2\n        _write_oriented_bbox(pred_bboxes, osp.join(result_path, f'{filename}_pred.obj'))",
            "def show_result(points, gt_bboxes, pred_bboxes, out_dir, filename, show=False, snapshot=False, pred_labels=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Convert results into format that is directly readable for meshlab.\\n\\n    Args:\\n        points (np.ndarray): Points.\\n        gt_bboxes (np.ndarray): Ground truth boxes.\\n        pred_bboxes (np.ndarray): Predicted boxes.\\n        out_dir (str): Path of output directory\\n        filename (str): Filename of the current frame.\\n        show (bool, optional): Visualize the results online. Defaults to False.\\n        snapshot (bool, optional): Whether to save the online results.\\n            Defaults to False.\\n        pred_labels (np.ndarray, optional): Predicted labels of boxes.\\n            Defaults to None.\\n    '\n    result_path = osp.join(out_dir, filename)\n    mmcv.mkdir_or_exist(result_path)\n    if show:\n        from .open3d_vis import Visualizer\n        vis = Visualizer(points)\n        if pred_bboxes is not None:\n            if pred_labels is None or pred_labels.numel() == 0:\n                vis.add_bboxes(bbox3d=pred_bboxes)\n            else:\n                palette = np.random.randint(0, 255, size=(pred_labels.max() + 1, 3)) / 256\n                labelDict = {}\n                for j in range(len(pred_labels)):\n                    i = int(pred_labels[j].numpy())\n                    if labelDict.get(i) is None:\n                        labelDict[i] = []\n                    labelDict[i].append(pred_bboxes[j])\n                for i in labelDict:\n                    vis.add_bboxes(bbox3d=np.array(labelDict[i]), bbox_color=palette[i], points_in_box_color=palette[i])\n        if gt_bboxes is not None:\n            vis.add_bboxes(bbox3d=gt_bboxes, bbox_color=(0, 0, 1))\n        show_path = osp.join(result_path, f'{filename}_online.png') if snapshot else None\n        vis.show(show_path)\n    if points is not None:\n        _write_obj(points, osp.join(result_path, f'{filename}_points.obj'))\n    if gt_bboxes is not None:\n        gt_bboxes[..., 2] += gt_bboxes[..., 5] / 2\n        _write_oriented_bbox(gt_bboxes, osp.join(result_path, f'{filename}_gt.obj'))\n    if pred_bboxes is not None:\n        pred_bboxes[..., 2] += pred_bboxes[..., 5] / 2\n        _write_oriented_bbox(pred_bboxes, osp.join(result_path, f'{filename}_pred.obj'))",
            "def show_result(points, gt_bboxes, pred_bboxes, out_dir, filename, show=False, snapshot=False, pred_labels=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Convert results into format that is directly readable for meshlab.\\n\\n    Args:\\n        points (np.ndarray): Points.\\n        gt_bboxes (np.ndarray): Ground truth boxes.\\n        pred_bboxes (np.ndarray): Predicted boxes.\\n        out_dir (str): Path of output directory\\n        filename (str): Filename of the current frame.\\n        show (bool, optional): Visualize the results online. Defaults to False.\\n        snapshot (bool, optional): Whether to save the online results.\\n            Defaults to False.\\n        pred_labels (np.ndarray, optional): Predicted labels of boxes.\\n            Defaults to None.\\n    '\n    result_path = osp.join(out_dir, filename)\n    mmcv.mkdir_or_exist(result_path)\n    if show:\n        from .open3d_vis import Visualizer\n        vis = Visualizer(points)\n        if pred_bboxes is not None:\n            if pred_labels is None or pred_labels.numel() == 0:\n                vis.add_bboxes(bbox3d=pred_bboxes)\n            else:\n                palette = np.random.randint(0, 255, size=(pred_labels.max() + 1, 3)) / 256\n                labelDict = {}\n                for j in range(len(pred_labels)):\n                    i = int(pred_labels[j].numpy())\n                    if labelDict.get(i) is None:\n                        labelDict[i] = []\n                    labelDict[i].append(pred_bboxes[j])\n                for i in labelDict:\n                    vis.add_bboxes(bbox3d=np.array(labelDict[i]), bbox_color=palette[i], points_in_box_color=palette[i])\n        if gt_bboxes is not None:\n            vis.add_bboxes(bbox3d=gt_bboxes, bbox_color=(0, 0, 1))\n        show_path = osp.join(result_path, f'{filename}_online.png') if snapshot else None\n        vis.show(show_path)\n    if points is not None:\n        _write_obj(points, osp.join(result_path, f'{filename}_points.obj'))\n    if gt_bboxes is not None:\n        gt_bboxes[..., 2] += gt_bboxes[..., 5] / 2\n        _write_oriented_bbox(gt_bboxes, osp.join(result_path, f'{filename}_gt.obj'))\n    if pred_bboxes is not None:\n        pred_bboxes[..., 2] += pred_bboxes[..., 5] / 2\n        _write_oriented_bbox(pred_bboxes, osp.join(result_path, f'{filename}_pred.obj'))",
            "def show_result(points, gt_bboxes, pred_bboxes, out_dir, filename, show=False, snapshot=False, pred_labels=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Convert results into format that is directly readable for meshlab.\\n\\n    Args:\\n        points (np.ndarray): Points.\\n        gt_bboxes (np.ndarray): Ground truth boxes.\\n        pred_bboxes (np.ndarray): Predicted boxes.\\n        out_dir (str): Path of output directory\\n        filename (str): Filename of the current frame.\\n        show (bool, optional): Visualize the results online. Defaults to False.\\n        snapshot (bool, optional): Whether to save the online results.\\n            Defaults to False.\\n        pred_labels (np.ndarray, optional): Predicted labels of boxes.\\n            Defaults to None.\\n    '\n    result_path = osp.join(out_dir, filename)\n    mmcv.mkdir_or_exist(result_path)\n    if show:\n        from .open3d_vis import Visualizer\n        vis = Visualizer(points)\n        if pred_bboxes is not None:\n            if pred_labels is None or pred_labels.numel() == 0:\n                vis.add_bboxes(bbox3d=pred_bboxes)\n            else:\n                palette = np.random.randint(0, 255, size=(pred_labels.max() + 1, 3)) / 256\n                labelDict = {}\n                for j in range(len(pred_labels)):\n                    i = int(pred_labels[j].numpy())\n                    if labelDict.get(i) is None:\n                        labelDict[i] = []\n                    labelDict[i].append(pred_bboxes[j])\n                for i in labelDict:\n                    vis.add_bboxes(bbox3d=np.array(labelDict[i]), bbox_color=palette[i], points_in_box_color=palette[i])\n        if gt_bboxes is not None:\n            vis.add_bboxes(bbox3d=gt_bboxes, bbox_color=(0, 0, 1))\n        show_path = osp.join(result_path, f'{filename}_online.png') if snapshot else None\n        vis.show(show_path)\n    if points is not None:\n        _write_obj(points, osp.join(result_path, f'{filename}_points.obj'))\n    if gt_bboxes is not None:\n        gt_bboxes[..., 2] += gt_bboxes[..., 5] / 2\n        _write_oriented_bbox(gt_bboxes, osp.join(result_path, f'{filename}_gt.obj'))\n    if pred_bboxes is not None:\n        pred_bboxes[..., 2] += pred_bboxes[..., 5] / 2\n        _write_oriented_bbox(pred_bboxes, osp.join(result_path, f'{filename}_pred.obj'))",
            "def show_result(points, gt_bboxes, pred_bboxes, out_dir, filename, show=False, snapshot=False, pred_labels=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Convert results into format that is directly readable for meshlab.\\n\\n    Args:\\n        points (np.ndarray): Points.\\n        gt_bboxes (np.ndarray): Ground truth boxes.\\n        pred_bboxes (np.ndarray): Predicted boxes.\\n        out_dir (str): Path of output directory\\n        filename (str): Filename of the current frame.\\n        show (bool, optional): Visualize the results online. Defaults to False.\\n        snapshot (bool, optional): Whether to save the online results.\\n            Defaults to False.\\n        pred_labels (np.ndarray, optional): Predicted labels of boxes.\\n            Defaults to None.\\n    '\n    result_path = osp.join(out_dir, filename)\n    mmcv.mkdir_or_exist(result_path)\n    if show:\n        from .open3d_vis import Visualizer\n        vis = Visualizer(points)\n        if pred_bboxes is not None:\n            if pred_labels is None or pred_labels.numel() == 0:\n                vis.add_bboxes(bbox3d=pred_bboxes)\n            else:\n                palette = np.random.randint(0, 255, size=(pred_labels.max() + 1, 3)) / 256\n                labelDict = {}\n                for j in range(len(pred_labels)):\n                    i = int(pred_labels[j].numpy())\n                    if labelDict.get(i) is None:\n                        labelDict[i] = []\n                    labelDict[i].append(pred_bboxes[j])\n                for i in labelDict:\n                    vis.add_bboxes(bbox3d=np.array(labelDict[i]), bbox_color=palette[i], points_in_box_color=palette[i])\n        if gt_bboxes is not None:\n            vis.add_bboxes(bbox3d=gt_bboxes, bbox_color=(0, 0, 1))\n        show_path = osp.join(result_path, f'{filename}_online.png') if snapshot else None\n        vis.show(show_path)\n    if points is not None:\n        _write_obj(points, osp.join(result_path, f'{filename}_points.obj'))\n    if gt_bboxes is not None:\n        gt_bboxes[..., 2] += gt_bboxes[..., 5] / 2\n        _write_oriented_bbox(gt_bboxes, osp.join(result_path, f'{filename}_gt.obj'))\n    if pred_bboxes is not None:\n        pred_bboxes[..., 2] += pred_bboxes[..., 5] / 2\n        _write_oriented_bbox(pred_bboxes, osp.join(result_path, f'{filename}_pred.obj'))"
        ]
    },
    {
        "func_name": "show_seg_result",
        "original": "def show_seg_result(points, gt_seg, pred_seg, out_dir, filename, palette, ignore_index=None, show=False, snapshot=False):\n    \"\"\"Convert results into format that is directly readable for meshlab.\n\n    Args:\n        points (np.ndarray): Points.\n        gt_seg (np.ndarray): Ground truth segmentation mask.\n        pred_seg (np.ndarray): Predicted segmentation mask.\n        out_dir (str): Path of output directory\n        filename (str): Filename of the current frame.\n        palette (np.ndarray): Mapping between class labels and colors.\n        ignore_index (int, optional): The label index to be ignored, e.g.\n            unannotated points. Defaults to None.\n        show (bool, optional): Visualize the results online. Defaults to False.\n        snapshot (bool, optional): Whether to save the online results.\n            Defaults to False.\n    \"\"\"\n    if gt_seg is not None or pred_seg is not None:\n        assert points is not None, '3D coordinates are required for segmentation visualization'\n    if gt_seg is not None and ignore_index is not None:\n        if points is not None:\n            points = points[gt_seg != ignore_index]\n        if pred_seg is not None:\n            pred_seg = pred_seg[gt_seg != ignore_index]\n        gt_seg = gt_seg[gt_seg != ignore_index]\n    if gt_seg is not None:\n        gt_seg_color = palette[gt_seg]\n        gt_seg_color = np.concatenate([points[:, :3], gt_seg_color], axis=1)\n    if pred_seg is not None:\n        pred_seg_color = palette[pred_seg]\n        pred_seg_color = np.concatenate([points[:, :3], pred_seg_color], axis=1)\n    result_path = osp.join(out_dir, filename)\n    mmcv.mkdir_or_exist(result_path)\n    if show:\n        from .open3d_vis import Visualizer\n        mode = 'xyzrgb' if points.shape[1] == 6 else 'xyz'\n        vis = Visualizer(points, mode=mode)\n        if gt_seg is not None:\n            vis.add_seg_mask(gt_seg_color)\n        if pred_seg is not None:\n            vis.add_seg_mask(pred_seg_color)\n        show_path = osp.join(result_path, f'{filename}_online.png') if snapshot else None\n        vis.show(show_path)\n    if points is not None:\n        _write_obj(points, osp.join(result_path, f'{filename}_points.obj'))\n    if gt_seg is not None:\n        _write_obj(gt_seg_color, osp.join(result_path, f'{filename}_gt.obj'))\n    if pred_seg is not None:\n        _write_obj(pred_seg_color, osp.join(result_path, f'{filename}_pred.obj'))",
        "mutated": [
            "def show_seg_result(points, gt_seg, pred_seg, out_dir, filename, palette, ignore_index=None, show=False, snapshot=False):\n    if False:\n        i = 10\n    'Convert results into format that is directly readable for meshlab.\\n\\n    Args:\\n        points (np.ndarray): Points.\\n        gt_seg (np.ndarray): Ground truth segmentation mask.\\n        pred_seg (np.ndarray): Predicted segmentation mask.\\n        out_dir (str): Path of output directory\\n        filename (str): Filename of the current frame.\\n        palette (np.ndarray): Mapping between class labels and colors.\\n        ignore_index (int, optional): The label index to be ignored, e.g.\\n            unannotated points. Defaults to None.\\n        show (bool, optional): Visualize the results online. Defaults to False.\\n        snapshot (bool, optional): Whether to save the online results.\\n            Defaults to False.\\n    '\n    if gt_seg is not None or pred_seg is not None:\n        assert points is not None, '3D coordinates are required for segmentation visualization'\n    if gt_seg is not None and ignore_index is not None:\n        if points is not None:\n            points = points[gt_seg != ignore_index]\n        if pred_seg is not None:\n            pred_seg = pred_seg[gt_seg != ignore_index]\n        gt_seg = gt_seg[gt_seg != ignore_index]\n    if gt_seg is not None:\n        gt_seg_color = palette[gt_seg]\n        gt_seg_color = np.concatenate([points[:, :3], gt_seg_color], axis=1)\n    if pred_seg is not None:\n        pred_seg_color = palette[pred_seg]\n        pred_seg_color = np.concatenate([points[:, :3], pred_seg_color], axis=1)\n    result_path = osp.join(out_dir, filename)\n    mmcv.mkdir_or_exist(result_path)\n    if show:\n        from .open3d_vis import Visualizer\n        mode = 'xyzrgb' if points.shape[1] == 6 else 'xyz'\n        vis = Visualizer(points, mode=mode)\n        if gt_seg is not None:\n            vis.add_seg_mask(gt_seg_color)\n        if pred_seg is not None:\n            vis.add_seg_mask(pred_seg_color)\n        show_path = osp.join(result_path, f'{filename}_online.png') if snapshot else None\n        vis.show(show_path)\n    if points is not None:\n        _write_obj(points, osp.join(result_path, f'{filename}_points.obj'))\n    if gt_seg is not None:\n        _write_obj(gt_seg_color, osp.join(result_path, f'{filename}_gt.obj'))\n    if pred_seg is not None:\n        _write_obj(pred_seg_color, osp.join(result_path, f'{filename}_pred.obj'))",
            "def show_seg_result(points, gt_seg, pred_seg, out_dir, filename, palette, ignore_index=None, show=False, snapshot=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Convert results into format that is directly readable for meshlab.\\n\\n    Args:\\n        points (np.ndarray): Points.\\n        gt_seg (np.ndarray): Ground truth segmentation mask.\\n        pred_seg (np.ndarray): Predicted segmentation mask.\\n        out_dir (str): Path of output directory\\n        filename (str): Filename of the current frame.\\n        palette (np.ndarray): Mapping between class labels and colors.\\n        ignore_index (int, optional): The label index to be ignored, e.g.\\n            unannotated points. Defaults to None.\\n        show (bool, optional): Visualize the results online. Defaults to False.\\n        snapshot (bool, optional): Whether to save the online results.\\n            Defaults to False.\\n    '\n    if gt_seg is not None or pred_seg is not None:\n        assert points is not None, '3D coordinates are required for segmentation visualization'\n    if gt_seg is not None and ignore_index is not None:\n        if points is not None:\n            points = points[gt_seg != ignore_index]\n        if pred_seg is not None:\n            pred_seg = pred_seg[gt_seg != ignore_index]\n        gt_seg = gt_seg[gt_seg != ignore_index]\n    if gt_seg is not None:\n        gt_seg_color = palette[gt_seg]\n        gt_seg_color = np.concatenate([points[:, :3], gt_seg_color], axis=1)\n    if pred_seg is not None:\n        pred_seg_color = palette[pred_seg]\n        pred_seg_color = np.concatenate([points[:, :3], pred_seg_color], axis=1)\n    result_path = osp.join(out_dir, filename)\n    mmcv.mkdir_or_exist(result_path)\n    if show:\n        from .open3d_vis import Visualizer\n        mode = 'xyzrgb' if points.shape[1] == 6 else 'xyz'\n        vis = Visualizer(points, mode=mode)\n        if gt_seg is not None:\n            vis.add_seg_mask(gt_seg_color)\n        if pred_seg is not None:\n            vis.add_seg_mask(pred_seg_color)\n        show_path = osp.join(result_path, f'{filename}_online.png') if snapshot else None\n        vis.show(show_path)\n    if points is not None:\n        _write_obj(points, osp.join(result_path, f'{filename}_points.obj'))\n    if gt_seg is not None:\n        _write_obj(gt_seg_color, osp.join(result_path, f'{filename}_gt.obj'))\n    if pred_seg is not None:\n        _write_obj(pred_seg_color, osp.join(result_path, f'{filename}_pred.obj'))",
            "def show_seg_result(points, gt_seg, pred_seg, out_dir, filename, palette, ignore_index=None, show=False, snapshot=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Convert results into format that is directly readable for meshlab.\\n\\n    Args:\\n        points (np.ndarray): Points.\\n        gt_seg (np.ndarray): Ground truth segmentation mask.\\n        pred_seg (np.ndarray): Predicted segmentation mask.\\n        out_dir (str): Path of output directory\\n        filename (str): Filename of the current frame.\\n        palette (np.ndarray): Mapping between class labels and colors.\\n        ignore_index (int, optional): The label index to be ignored, e.g.\\n            unannotated points. Defaults to None.\\n        show (bool, optional): Visualize the results online. Defaults to False.\\n        snapshot (bool, optional): Whether to save the online results.\\n            Defaults to False.\\n    '\n    if gt_seg is not None or pred_seg is not None:\n        assert points is not None, '3D coordinates are required for segmentation visualization'\n    if gt_seg is not None and ignore_index is not None:\n        if points is not None:\n            points = points[gt_seg != ignore_index]\n        if pred_seg is not None:\n            pred_seg = pred_seg[gt_seg != ignore_index]\n        gt_seg = gt_seg[gt_seg != ignore_index]\n    if gt_seg is not None:\n        gt_seg_color = palette[gt_seg]\n        gt_seg_color = np.concatenate([points[:, :3], gt_seg_color], axis=1)\n    if pred_seg is not None:\n        pred_seg_color = palette[pred_seg]\n        pred_seg_color = np.concatenate([points[:, :3], pred_seg_color], axis=1)\n    result_path = osp.join(out_dir, filename)\n    mmcv.mkdir_or_exist(result_path)\n    if show:\n        from .open3d_vis import Visualizer\n        mode = 'xyzrgb' if points.shape[1] == 6 else 'xyz'\n        vis = Visualizer(points, mode=mode)\n        if gt_seg is not None:\n            vis.add_seg_mask(gt_seg_color)\n        if pred_seg is not None:\n            vis.add_seg_mask(pred_seg_color)\n        show_path = osp.join(result_path, f'{filename}_online.png') if snapshot else None\n        vis.show(show_path)\n    if points is not None:\n        _write_obj(points, osp.join(result_path, f'{filename}_points.obj'))\n    if gt_seg is not None:\n        _write_obj(gt_seg_color, osp.join(result_path, f'{filename}_gt.obj'))\n    if pred_seg is not None:\n        _write_obj(pred_seg_color, osp.join(result_path, f'{filename}_pred.obj'))",
            "def show_seg_result(points, gt_seg, pred_seg, out_dir, filename, palette, ignore_index=None, show=False, snapshot=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Convert results into format that is directly readable for meshlab.\\n\\n    Args:\\n        points (np.ndarray): Points.\\n        gt_seg (np.ndarray): Ground truth segmentation mask.\\n        pred_seg (np.ndarray): Predicted segmentation mask.\\n        out_dir (str): Path of output directory\\n        filename (str): Filename of the current frame.\\n        palette (np.ndarray): Mapping between class labels and colors.\\n        ignore_index (int, optional): The label index to be ignored, e.g.\\n            unannotated points. Defaults to None.\\n        show (bool, optional): Visualize the results online. Defaults to False.\\n        snapshot (bool, optional): Whether to save the online results.\\n            Defaults to False.\\n    '\n    if gt_seg is not None or pred_seg is not None:\n        assert points is not None, '3D coordinates are required for segmentation visualization'\n    if gt_seg is not None and ignore_index is not None:\n        if points is not None:\n            points = points[gt_seg != ignore_index]\n        if pred_seg is not None:\n            pred_seg = pred_seg[gt_seg != ignore_index]\n        gt_seg = gt_seg[gt_seg != ignore_index]\n    if gt_seg is not None:\n        gt_seg_color = palette[gt_seg]\n        gt_seg_color = np.concatenate([points[:, :3], gt_seg_color], axis=1)\n    if pred_seg is not None:\n        pred_seg_color = palette[pred_seg]\n        pred_seg_color = np.concatenate([points[:, :3], pred_seg_color], axis=1)\n    result_path = osp.join(out_dir, filename)\n    mmcv.mkdir_or_exist(result_path)\n    if show:\n        from .open3d_vis import Visualizer\n        mode = 'xyzrgb' if points.shape[1] == 6 else 'xyz'\n        vis = Visualizer(points, mode=mode)\n        if gt_seg is not None:\n            vis.add_seg_mask(gt_seg_color)\n        if pred_seg is not None:\n            vis.add_seg_mask(pred_seg_color)\n        show_path = osp.join(result_path, f'{filename}_online.png') if snapshot else None\n        vis.show(show_path)\n    if points is not None:\n        _write_obj(points, osp.join(result_path, f'{filename}_points.obj'))\n    if gt_seg is not None:\n        _write_obj(gt_seg_color, osp.join(result_path, f'{filename}_gt.obj'))\n    if pred_seg is not None:\n        _write_obj(pred_seg_color, osp.join(result_path, f'{filename}_pred.obj'))",
            "def show_seg_result(points, gt_seg, pred_seg, out_dir, filename, palette, ignore_index=None, show=False, snapshot=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Convert results into format that is directly readable for meshlab.\\n\\n    Args:\\n        points (np.ndarray): Points.\\n        gt_seg (np.ndarray): Ground truth segmentation mask.\\n        pred_seg (np.ndarray): Predicted segmentation mask.\\n        out_dir (str): Path of output directory\\n        filename (str): Filename of the current frame.\\n        palette (np.ndarray): Mapping between class labels and colors.\\n        ignore_index (int, optional): The label index to be ignored, e.g.\\n            unannotated points. Defaults to None.\\n        show (bool, optional): Visualize the results online. Defaults to False.\\n        snapshot (bool, optional): Whether to save the online results.\\n            Defaults to False.\\n    '\n    if gt_seg is not None or pred_seg is not None:\n        assert points is not None, '3D coordinates are required for segmentation visualization'\n    if gt_seg is not None and ignore_index is not None:\n        if points is not None:\n            points = points[gt_seg != ignore_index]\n        if pred_seg is not None:\n            pred_seg = pred_seg[gt_seg != ignore_index]\n        gt_seg = gt_seg[gt_seg != ignore_index]\n    if gt_seg is not None:\n        gt_seg_color = palette[gt_seg]\n        gt_seg_color = np.concatenate([points[:, :3], gt_seg_color], axis=1)\n    if pred_seg is not None:\n        pred_seg_color = palette[pred_seg]\n        pred_seg_color = np.concatenate([points[:, :3], pred_seg_color], axis=1)\n    result_path = osp.join(out_dir, filename)\n    mmcv.mkdir_or_exist(result_path)\n    if show:\n        from .open3d_vis import Visualizer\n        mode = 'xyzrgb' if points.shape[1] == 6 else 'xyz'\n        vis = Visualizer(points, mode=mode)\n        if gt_seg is not None:\n            vis.add_seg_mask(gt_seg_color)\n        if pred_seg is not None:\n            vis.add_seg_mask(pred_seg_color)\n        show_path = osp.join(result_path, f'{filename}_online.png') if snapshot else None\n        vis.show(show_path)\n    if points is not None:\n        _write_obj(points, osp.join(result_path, f'{filename}_points.obj'))\n    if gt_seg is not None:\n        _write_obj(gt_seg_color, osp.join(result_path, f'{filename}_gt.obj'))\n    if pred_seg is not None:\n        _write_obj(pred_seg_color, osp.join(result_path, f'{filename}_pred.obj'))"
        ]
    },
    {
        "func_name": "show_multi_modality_result",
        "original": "def show_multi_modality_result(img, gt_bboxes, pred_bboxes, proj_mat, out_dir, filename, box_mode='lidar', img_metas=None, show=False, gt_bbox_color=(61, 102, 255), pred_bbox_color=(241, 101, 72)):\n    \"\"\"Convert multi-modality detection results into 2D results.\n\n    Project the predicted 3D bbox to 2D image plane and visualize them.\n\n    Args:\n        img (np.ndarray): The numpy array of image in cv2 fashion.\n        gt_bboxes (:obj:`BaseInstance3DBoxes`): Ground truth boxes.\n        pred_bboxes (:obj:`BaseInstance3DBoxes`): Predicted boxes.\n        proj_mat (numpy.array, shape=[4, 4]): The projection matrix\n            according to the camera intrinsic parameters.\n        out_dir (str): Path of output directory.\n        filename (str): Filename of the current frame.\n        box_mode (str, optional): Coordinate system the boxes are in.\n            Should be one of 'depth', 'lidar' and 'camera'.\n            Defaults to 'lidar'.\n        img_metas (dict, optional): Used in projecting depth bbox.\n            Defaults to None.\n        show (bool, optional): Visualize the results online. Defaults to False.\n        gt_bbox_color (str or tuple(int), optional): Color of bbox lines.\n           The tuple of color should be in BGR order. Default: (255, 102, 61).\n        pred_bbox_color (str or tuple(int), optional): Color of bbox lines.\n           The tuple of color should be in BGR order. Default: (72, 101, 241).\n    \"\"\"\n    if box_mode == 'depth':\n        draw_bbox = draw_depth_bbox3d_on_img\n    elif box_mode == 'lidar':\n        draw_bbox = draw_lidar_bbox3d_on_img\n    elif box_mode == 'camera':\n        draw_bbox = draw_camera_bbox3d_on_img\n    else:\n        raise NotImplementedError(f'unsupported box mode {box_mode}')\n    result_path = osp.join(out_dir, filename)\n    mmcv.mkdir_or_exist(result_path)\n    if show:\n        show_img = img.copy()\n        if gt_bboxes is not None:\n            show_img = draw_bbox(gt_bboxes, show_img, proj_mat, img_metas, color=gt_bbox_color)\n        if pred_bboxes is not None:\n            show_img = draw_bbox(pred_bboxes, show_img, proj_mat, img_metas, color=pred_bbox_color)\n        mmcv.imshow(show_img, win_name='project_bbox3d_img', wait_time=0)\n    if img is not None:\n        mmcv.imwrite(img, osp.join(result_path, f'{filename}_img.png'))\n    if gt_bboxes is not None:\n        gt_img = draw_bbox(gt_bboxes, img, proj_mat, img_metas, color=gt_bbox_color)\n        mmcv.imwrite(gt_img, osp.join(result_path, f'{filename}_gt.png'))\n    if pred_bboxes is not None:\n        pred_img = draw_bbox(pred_bboxes, img, proj_mat, img_metas, color=pred_bbox_color)\n        mmcv.imwrite(pred_img, osp.join(result_path, f'{filename}_pred.png'))",
        "mutated": [
            "def show_multi_modality_result(img, gt_bboxes, pred_bboxes, proj_mat, out_dir, filename, box_mode='lidar', img_metas=None, show=False, gt_bbox_color=(61, 102, 255), pred_bbox_color=(241, 101, 72)):\n    if False:\n        i = 10\n    \"Convert multi-modality detection results into 2D results.\\n\\n    Project the predicted 3D bbox to 2D image plane and visualize them.\\n\\n    Args:\\n        img (np.ndarray): The numpy array of image in cv2 fashion.\\n        gt_bboxes (:obj:`BaseInstance3DBoxes`): Ground truth boxes.\\n        pred_bboxes (:obj:`BaseInstance3DBoxes`): Predicted boxes.\\n        proj_mat (numpy.array, shape=[4, 4]): The projection matrix\\n            according to the camera intrinsic parameters.\\n        out_dir (str): Path of output directory.\\n        filename (str): Filename of the current frame.\\n        box_mode (str, optional): Coordinate system the boxes are in.\\n            Should be one of 'depth', 'lidar' and 'camera'.\\n            Defaults to 'lidar'.\\n        img_metas (dict, optional): Used in projecting depth bbox.\\n            Defaults to None.\\n        show (bool, optional): Visualize the results online. Defaults to False.\\n        gt_bbox_color (str or tuple(int), optional): Color of bbox lines.\\n           The tuple of color should be in BGR order. Default: (255, 102, 61).\\n        pred_bbox_color (str or tuple(int), optional): Color of bbox lines.\\n           The tuple of color should be in BGR order. Default: (72, 101, 241).\\n    \"\n    if box_mode == 'depth':\n        draw_bbox = draw_depth_bbox3d_on_img\n    elif box_mode == 'lidar':\n        draw_bbox = draw_lidar_bbox3d_on_img\n    elif box_mode == 'camera':\n        draw_bbox = draw_camera_bbox3d_on_img\n    else:\n        raise NotImplementedError(f'unsupported box mode {box_mode}')\n    result_path = osp.join(out_dir, filename)\n    mmcv.mkdir_or_exist(result_path)\n    if show:\n        show_img = img.copy()\n        if gt_bboxes is not None:\n            show_img = draw_bbox(gt_bboxes, show_img, proj_mat, img_metas, color=gt_bbox_color)\n        if pred_bboxes is not None:\n            show_img = draw_bbox(pred_bboxes, show_img, proj_mat, img_metas, color=pred_bbox_color)\n        mmcv.imshow(show_img, win_name='project_bbox3d_img', wait_time=0)\n    if img is not None:\n        mmcv.imwrite(img, osp.join(result_path, f'{filename}_img.png'))\n    if gt_bboxes is not None:\n        gt_img = draw_bbox(gt_bboxes, img, proj_mat, img_metas, color=gt_bbox_color)\n        mmcv.imwrite(gt_img, osp.join(result_path, f'{filename}_gt.png'))\n    if pred_bboxes is not None:\n        pred_img = draw_bbox(pred_bboxes, img, proj_mat, img_metas, color=pred_bbox_color)\n        mmcv.imwrite(pred_img, osp.join(result_path, f'{filename}_pred.png'))",
            "def show_multi_modality_result(img, gt_bboxes, pred_bboxes, proj_mat, out_dir, filename, box_mode='lidar', img_metas=None, show=False, gt_bbox_color=(61, 102, 255), pred_bbox_color=(241, 101, 72)):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Convert multi-modality detection results into 2D results.\\n\\n    Project the predicted 3D bbox to 2D image plane and visualize them.\\n\\n    Args:\\n        img (np.ndarray): The numpy array of image in cv2 fashion.\\n        gt_bboxes (:obj:`BaseInstance3DBoxes`): Ground truth boxes.\\n        pred_bboxes (:obj:`BaseInstance3DBoxes`): Predicted boxes.\\n        proj_mat (numpy.array, shape=[4, 4]): The projection matrix\\n            according to the camera intrinsic parameters.\\n        out_dir (str): Path of output directory.\\n        filename (str): Filename of the current frame.\\n        box_mode (str, optional): Coordinate system the boxes are in.\\n            Should be one of 'depth', 'lidar' and 'camera'.\\n            Defaults to 'lidar'.\\n        img_metas (dict, optional): Used in projecting depth bbox.\\n            Defaults to None.\\n        show (bool, optional): Visualize the results online. Defaults to False.\\n        gt_bbox_color (str or tuple(int), optional): Color of bbox lines.\\n           The tuple of color should be in BGR order. Default: (255, 102, 61).\\n        pred_bbox_color (str or tuple(int), optional): Color of bbox lines.\\n           The tuple of color should be in BGR order. Default: (72, 101, 241).\\n    \"\n    if box_mode == 'depth':\n        draw_bbox = draw_depth_bbox3d_on_img\n    elif box_mode == 'lidar':\n        draw_bbox = draw_lidar_bbox3d_on_img\n    elif box_mode == 'camera':\n        draw_bbox = draw_camera_bbox3d_on_img\n    else:\n        raise NotImplementedError(f'unsupported box mode {box_mode}')\n    result_path = osp.join(out_dir, filename)\n    mmcv.mkdir_or_exist(result_path)\n    if show:\n        show_img = img.copy()\n        if gt_bboxes is not None:\n            show_img = draw_bbox(gt_bboxes, show_img, proj_mat, img_metas, color=gt_bbox_color)\n        if pred_bboxes is not None:\n            show_img = draw_bbox(pred_bboxes, show_img, proj_mat, img_metas, color=pred_bbox_color)\n        mmcv.imshow(show_img, win_name='project_bbox3d_img', wait_time=0)\n    if img is not None:\n        mmcv.imwrite(img, osp.join(result_path, f'{filename}_img.png'))\n    if gt_bboxes is not None:\n        gt_img = draw_bbox(gt_bboxes, img, proj_mat, img_metas, color=gt_bbox_color)\n        mmcv.imwrite(gt_img, osp.join(result_path, f'{filename}_gt.png'))\n    if pred_bboxes is not None:\n        pred_img = draw_bbox(pred_bboxes, img, proj_mat, img_metas, color=pred_bbox_color)\n        mmcv.imwrite(pred_img, osp.join(result_path, f'{filename}_pred.png'))",
            "def show_multi_modality_result(img, gt_bboxes, pred_bboxes, proj_mat, out_dir, filename, box_mode='lidar', img_metas=None, show=False, gt_bbox_color=(61, 102, 255), pred_bbox_color=(241, 101, 72)):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Convert multi-modality detection results into 2D results.\\n\\n    Project the predicted 3D bbox to 2D image plane and visualize them.\\n\\n    Args:\\n        img (np.ndarray): The numpy array of image in cv2 fashion.\\n        gt_bboxes (:obj:`BaseInstance3DBoxes`): Ground truth boxes.\\n        pred_bboxes (:obj:`BaseInstance3DBoxes`): Predicted boxes.\\n        proj_mat (numpy.array, shape=[4, 4]): The projection matrix\\n            according to the camera intrinsic parameters.\\n        out_dir (str): Path of output directory.\\n        filename (str): Filename of the current frame.\\n        box_mode (str, optional): Coordinate system the boxes are in.\\n            Should be one of 'depth', 'lidar' and 'camera'.\\n            Defaults to 'lidar'.\\n        img_metas (dict, optional): Used in projecting depth bbox.\\n            Defaults to None.\\n        show (bool, optional): Visualize the results online. Defaults to False.\\n        gt_bbox_color (str or tuple(int), optional): Color of bbox lines.\\n           The tuple of color should be in BGR order. Default: (255, 102, 61).\\n        pred_bbox_color (str or tuple(int), optional): Color of bbox lines.\\n           The tuple of color should be in BGR order. Default: (72, 101, 241).\\n    \"\n    if box_mode == 'depth':\n        draw_bbox = draw_depth_bbox3d_on_img\n    elif box_mode == 'lidar':\n        draw_bbox = draw_lidar_bbox3d_on_img\n    elif box_mode == 'camera':\n        draw_bbox = draw_camera_bbox3d_on_img\n    else:\n        raise NotImplementedError(f'unsupported box mode {box_mode}')\n    result_path = osp.join(out_dir, filename)\n    mmcv.mkdir_or_exist(result_path)\n    if show:\n        show_img = img.copy()\n        if gt_bboxes is not None:\n            show_img = draw_bbox(gt_bboxes, show_img, proj_mat, img_metas, color=gt_bbox_color)\n        if pred_bboxes is not None:\n            show_img = draw_bbox(pred_bboxes, show_img, proj_mat, img_metas, color=pred_bbox_color)\n        mmcv.imshow(show_img, win_name='project_bbox3d_img', wait_time=0)\n    if img is not None:\n        mmcv.imwrite(img, osp.join(result_path, f'{filename}_img.png'))\n    if gt_bboxes is not None:\n        gt_img = draw_bbox(gt_bboxes, img, proj_mat, img_metas, color=gt_bbox_color)\n        mmcv.imwrite(gt_img, osp.join(result_path, f'{filename}_gt.png'))\n    if pred_bboxes is not None:\n        pred_img = draw_bbox(pred_bboxes, img, proj_mat, img_metas, color=pred_bbox_color)\n        mmcv.imwrite(pred_img, osp.join(result_path, f'{filename}_pred.png'))",
            "def show_multi_modality_result(img, gt_bboxes, pred_bboxes, proj_mat, out_dir, filename, box_mode='lidar', img_metas=None, show=False, gt_bbox_color=(61, 102, 255), pred_bbox_color=(241, 101, 72)):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Convert multi-modality detection results into 2D results.\\n\\n    Project the predicted 3D bbox to 2D image plane and visualize them.\\n\\n    Args:\\n        img (np.ndarray): The numpy array of image in cv2 fashion.\\n        gt_bboxes (:obj:`BaseInstance3DBoxes`): Ground truth boxes.\\n        pred_bboxes (:obj:`BaseInstance3DBoxes`): Predicted boxes.\\n        proj_mat (numpy.array, shape=[4, 4]): The projection matrix\\n            according to the camera intrinsic parameters.\\n        out_dir (str): Path of output directory.\\n        filename (str): Filename of the current frame.\\n        box_mode (str, optional): Coordinate system the boxes are in.\\n            Should be one of 'depth', 'lidar' and 'camera'.\\n            Defaults to 'lidar'.\\n        img_metas (dict, optional): Used in projecting depth bbox.\\n            Defaults to None.\\n        show (bool, optional): Visualize the results online. Defaults to False.\\n        gt_bbox_color (str or tuple(int), optional): Color of bbox lines.\\n           The tuple of color should be in BGR order. Default: (255, 102, 61).\\n        pred_bbox_color (str or tuple(int), optional): Color of bbox lines.\\n           The tuple of color should be in BGR order. Default: (72, 101, 241).\\n    \"\n    if box_mode == 'depth':\n        draw_bbox = draw_depth_bbox3d_on_img\n    elif box_mode == 'lidar':\n        draw_bbox = draw_lidar_bbox3d_on_img\n    elif box_mode == 'camera':\n        draw_bbox = draw_camera_bbox3d_on_img\n    else:\n        raise NotImplementedError(f'unsupported box mode {box_mode}')\n    result_path = osp.join(out_dir, filename)\n    mmcv.mkdir_or_exist(result_path)\n    if show:\n        show_img = img.copy()\n        if gt_bboxes is not None:\n            show_img = draw_bbox(gt_bboxes, show_img, proj_mat, img_metas, color=gt_bbox_color)\n        if pred_bboxes is not None:\n            show_img = draw_bbox(pred_bboxes, show_img, proj_mat, img_metas, color=pred_bbox_color)\n        mmcv.imshow(show_img, win_name='project_bbox3d_img', wait_time=0)\n    if img is not None:\n        mmcv.imwrite(img, osp.join(result_path, f'{filename}_img.png'))\n    if gt_bboxes is not None:\n        gt_img = draw_bbox(gt_bboxes, img, proj_mat, img_metas, color=gt_bbox_color)\n        mmcv.imwrite(gt_img, osp.join(result_path, f'{filename}_gt.png'))\n    if pred_bboxes is not None:\n        pred_img = draw_bbox(pred_bboxes, img, proj_mat, img_metas, color=pred_bbox_color)\n        mmcv.imwrite(pred_img, osp.join(result_path, f'{filename}_pred.png'))",
            "def show_multi_modality_result(img, gt_bboxes, pred_bboxes, proj_mat, out_dir, filename, box_mode='lidar', img_metas=None, show=False, gt_bbox_color=(61, 102, 255), pred_bbox_color=(241, 101, 72)):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Convert multi-modality detection results into 2D results.\\n\\n    Project the predicted 3D bbox to 2D image plane and visualize them.\\n\\n    Args:\\n        img (np.ndarray): The numpy array of image in cv2 fashion.\\n        gt_bboxes (:obj:`BaseInstance3DBoxes`): Ground truth boxes.\\n        pred_bboxes (:obj:`BaseInstance3DBoxes`): Predicted boxes.\\n        proj_mat (numpy.array, shape=[4, 4]): The projection matrix\\n            according to the camera intrinsic parameters.\\n        out_dir (str): Path of output directory.\\n        filename (str): Filename of the current frame.\\n        box_mode (str, optional): Coordinate system the boxes are in.\\n            Should be one of 'depth', 'lidar' and 'camera'.\\n            Defaults to 'lidar'.\\n        img_metas (dict, optional): Used in projecting depth bbox.\\n            Defaults to None.\\n        show (bool, optional): Visualize the results online. Defaults to False.\\n        gt_bbox_color (str or tuple(int), optional): Color of bbox lines.\\n           The tuple of color should be in BGR order. Default: (255, 102, 61).\\n        pred_bbox_color (str or tuple(int), optional): Color of bbox lines.\\n           The tuple of color should be in BGR order. Default: (72, 101, 241).\\n    \"\n    if box_mode == 'depth':\n        draw_bbox = draw_depth_bbox3d_on_img\n    elif box_mode == 'lidar':\n        draw_bbox = draw_lidar_bbox3d_on_img\n    elif box_mode == 'camera':\n        draw_bbox = draw_camera_bbox3d_on_img\n    else:\n        raise NotImplementedError(f'unsupported box mode {box_mode}')\n    result_path = osp.join(out_dir, filename)\n    mmcv.mkdir_or_exist(result_path)\n    if show:\n        show_img = img.copy()\n        if gt_bboxes is not None:\n            show_img = draw_bbox(gt_bboxes, show_img, proj_mat, img_metas, color=gt_bbox_color)\n        if pred_bboxes is not None:\n            show_img = draw_bbox(pred_bboxes, show_img, proj_mat, img_metas, color=pred_bbox_color)\n        mmcv.imshow(show_img, win_name='project_bbox3d_img', wait_time=0)\n    if img is not None:\n        mmcv.imwrite(img, osp.join(result_path, f'{filename}_img.png'))\n    if gt_bboxes is not None:\n        gt_img = draw_bbox(gt_bboxes, img, proj_mat, img_metas, color=gt_bbox_color)\n        mmcv.imwrite(gt_img, osp.join(result_path, f'{filename}_gt.png'))\n    if pred_bboxes is not None:\n        pred_img = draw_bbox(pred_bboxes, img, proj_mat, img_metas, color=pred_bbox_color)\n        mmcv.imwrite(pred_img, osp.join(result_path, f'{filename}_pred.png'))"
        ]
    }
]