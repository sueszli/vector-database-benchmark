doctests = '\n\nUnpack tuple\n\n    >>> t = (1, 2, 3)\n    >>> a, *b, c = t\n    >>> a == 1 and b == [2] and c == 3\n    True\n\nUnpack list\n\n    >>> l = [4, 5, 6]\n    >>> a, *b = l\n    >>> a == 4 and b == [5, 6]\n    True\n\nUnpack implied tuple\n\n    >>> *a, = 7, 8, 9\n    >>> a == [7, 8, 9]\n    True\n\nUnpack string... fun!\n\n    >>> a, *b = \'one\'\n    >>> a == \'o\' and b == [\'n\', \'e\']\n    True\n\nUnpack long sequence\n\n    >>> a, b, c, *d, e, f, g = range(10)\n    >>> (a, b, c, d, e, f, g) == (0, 1, 2, [3, 4, 5, 6], 7, 8, 9)\n    True\n\nUnpack short sequence\n\n    >>> a, *b, c = (1, 2)\n    >>> a == 1 and c == 2 and b == []\n    True\n\nUnpack generic sequence\n\n    >>> class Seq:\n    ...     def __getitem__(self, i):\n    ...         if i >= 0 and i < 3: return i\n    ...         raise IndexError\n    ...\n    >>> a, *b = Seq()\n    >>> a == 0 and b == [1, 2]\n    True\n\nUnpack in for statement\n\n    >>> for a, *b, c in [(1,2,3), (4,5,6,7)]:\n    ...     print(a, b, c)\n    ...\n    1 [2] 3\n    4 [5, 6] 7\n\nUnpack in list\n\n    >>> [a, *b, c] = range(5)\n    >>> a == 0 and b == [1, 2, 3] and c == 4\n    True\n\nMultiple targets\n\n    >>> a, *b, c = *d, e = range(5)\n    >>> a == 0 and b == [1, 2, 3] and c == 4 and d == [0, 1, 2, 3] and e == 4\n    True\n\nAssignment unpacking\n\n    >>> a, b, *c = range(5)\n    >>> a, b, c\n    (0, 1, [2, 3, 4])\n    >>> *a, b, c = a, b, *c\n    >>> a, b, c\n    ([0, 1, 2], 3, 4)\n\nSet display element unpacking\n\n    >>> a = [1, 2, 3]\n    >>> sorted({1, *a, 0, 4})\n    [0, 1, 2, 3, 4]\n\n    >>> {1, *1, 0, 4}\n    Traceback (most recent call last):\n      ...\n    TypeError: \'int\' object is not iterable\n\nDict display element unpacking\n\n    >>> kwds = {\'z\': 0, \'w\': 12}\n    >>> sorted({\'x\': 1, \'y\': 2, **kwds}.items())\n    [(\'w\', 12), (\'x\', 1), (\'y\', 2), (\'z\', 0)]\n\n    >>> sorted({**{\'x\': 1}, \'y\': 2, **{\'z\': 3}}.items())\n    [(\'x\', 1), (\'y\', 2), (\'z\', 3)]\n\n    >>> sorted({**{\'x\': 1}, \'y\': 2, **{\'x\': 3}}.items())\n    [(\'x\', 3), (\'y\', 2)]\n\n    >>> sorted({**{\'x\': 1}, **{\'x\': 3}, \'x\': 4}.items())\n    [(\'x\', 4)]\n\n    >>> {**{}}\n    {}\n\n    >>> a = {}\n    >>> {**a}[0] = 1\n    >>> a\n    {}\n\n    >>> {**1}\n    Traceback (most recent call last):\n    ...\n    TypeError: \'int\' object is not a mapping\n\n    >>> {**[]}\n    Traceback (most recent call last):\n    ...\n    TypeError: \'list\' object is not a mapping\n\n    >>> len(eval("{" + ", ".join("**{{{}: {}}}".format(i, i)\n    ...                          for i in range(1000)) + "}"))\n    1000\n\n    >>> {0:1, **{0:2}, 0:3, 0:4}\n    {0: 4}\n\nList comprehension element unpacking\n\n    >>> a, b, c = [0, 1, 2], 3, 4\n    >>> [*a, b, c]\n    [0, 1, 2, 3, 4]\n\n    >>> l = [a, (3, 4), {5}, {6: None}, (i for i in range(7, 10))]\n    >>> [*item for item in l]\n    Traceback (most recent call last):\n    ...\n    SyntaxError: iterable unpacking cannot be used in comprehension\n\n    >>> [*[0, 1] for i in range(10)]\n    Traceback (most recent call last):\n    ...\n    SyntaxError: iterable unpacking cannot be used in comprehension\n\n    >>> [*\'a\' for i in range(10)]\n    Traceback (most recent call last):\n    ...\n    SyntaxError: iterable unpacking cannot be used in comprehension\n\n    >>> [*[] for i in range(10)]\n    Traceback (most recent call last):\n    ...\n    SyntaxError: iterable unpacking cannot be used in comprehension\n\n    >>> {**{} for a in [1]}\n    Traceback (most recent call last):\n    ...\n    SyntaxError: dict unpacking cannot be used in dict comprehension\n\n# Pegen is better here.\n# Generator expression in function arguments\n\n#     >>> list(*x for x in (range(5) for i in range(3)))\n#     Traceback (most recent call last):\n#     ...\n#         list(*x for x in (range(5) for i in range(3)))\n#                   ^\n#     SyntaxError: invalid syntax\n\n    >>> dict(**x for x in [{1:2}])\n    Traceback (most recent call last):\n    ...\n        dict(**x for x in [{1:2}])\n                   ^\n    SyntaxError: invalid syntax\n\nIterable argument unpacking\n\n    >>> print(*[1], *[2], 3)\n    1 2 3\n\nMake sure that they don\'t corrupt the passed-in dicts.\n\n    >>> def f(x, y):\n    ...     print(x, y)\n    ...\n    >>> original_dict = {\'x\': 1}\n    >>> f(**original_dict, y=2)\n    1 2\n    >>> original_dict\n    {\'x\': 1}\n\nNow for some failures\n\nMake sure the raised errors are right for keyword argument unpackings\n\n    >>> from collections.abc import MutableMapping\n    >>> class CrazyDict(MutableMapping):\n    ...     def __init__(self):\n    ...         self.d = {}\n    ...\n    ...     def __iter__(self):\n    ...         for x in self.d.__iter__():\n    ...             if x == \'c\':\n    ...                 self.d[\'z\'] = 10\n    ...             yield x\n    ...\n    ...     def __getitem__(self, k):\n    ...         return self.d[k]\n    ...\n    ...     def __len__(self):\n    ...         return len(self.d)\n    ...\n    ...     def __setitem__(self, k, v):\n    ...         self.d[k] = v\n    ...\n    ...     def __delitem__(self, k):\n    ...         del self.d[k]\n    ...\n    >>> d = CrazyDict()\n    >>> d.d = {chr(ord(\'a\') + x): x for x in range(5)}\n    >>> e = {**d}\n    Traceback (most recent call last):\n    ...\n    RuntimeError: dictionary changed size during iteration\n\n    >>> d.d = {chr(ord(\'a\') + x): x for x in range(5)}\n    >>> def f(**kwargs): print(kwargs)\n    >>> f(**d)\n    Traceback (most recent call last):\n    ...\n    RuntimeError: dictionary changed size during iteration\n\nOverridden parameters\n\n    >>> f(x=5, **{\'x\': 3}, y=2)\n    Traceback (most recent call last):\n      ...\n    TypeError: test.test_unpack_ex.f() got multiple values for keyword argument \'x\'\n\n    >>> f(**{\'x\': 3}, x=5, y=2)\n    Traceback (most recent call last):\n      ...\n    TypeError: test.test_unpack_ex.f() got multiple values for keyword argument \'x\'\n\n    >>> f(**{\'x\': 3}, **{\'x\': 5}, y=2)\n    Traceback (most recent call last):\n      ...\n    TypeError: test.test_unpack_ex.f() got multiple values for keyword argument \'x\'\n\n    >>> f(x=5, **{\'x\': 3}, **{\'x\': 2})\n    Traceback (most recent call last):\n      ...\n    TypeError: test.test_unpack_ex.f() got multiple values for keyword argument \'x\'\n\n    >>> f(**{1: 3}, **{1: 5})\n    Traceback (most recent call last):\n      ...\n    TypeError: test.test_unpack_ex.f() got multiple values for keyword argument \'1\'\n\nUnpacking non-sequence\n\n    >>> a, *b = 7\n    Traceback (most recent call last):\n      ...\n    TypeError: cannot unpack non-iterable int object\n\nUnpacking sequence too short\n\n    >>> a, *b, c, d, e = Seq()\n    Traceback (most recent call last):\n      ...\n    ValueError: not enough values to unpack (expected at least 4, got 3)\n\nUnpacking sequence too short and target appears last\n\n    >>> a, b, c, d, *e = Seq()\n    Traceback (most recent call last):\n      ...\n    ValueError: not enough values to unpack (expected at least 4, got 3)\n\nUnpacking a sequence where the test for too long raises a different kind of\nerror\n\n    >>> class BozoError(Exception):\n    ...     pass\n    ...\n    >>> class BadSeq:\n    ...     def __getitem__(self, i):\n    ...         if i >= 0 and i < 3:\n    ...             return i\n    ...         elif i == 3:\n    ...             raise BozoError\n    ...         else:\n    ...             raise IndexError\n    ...\n\nTrigger code while not expecting an IndexError (unpack sequence too long, wrong\nerror)\n\n    >>> a, *b, c, d, e = BadSeq()\n    Traceback (most recent call last):\n      ...\n    test.test_unpack_ex.BozoError\n\nNow some general starred expressions (all fail).\n\n    >>> a, *b, c, *d, e = range(10) # doctest:+ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    SyntaxError: multiple starred expressions in assignment\n\n    >>> [*b, *c] = range(10) # doctest:+ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    SyntaxError: multiple starred expressions in assignment\n\n    >>> a,*b,*c,*d = range(4) # doctest:+ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    SyntaxError: multiple starred expressions in assignment\n\n    >>> *a = range(10) # doctest:+ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    SyntaxError: starred assignment target must be in a list or tuple\n\n    >>> *a # doctest:+ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    SyntaxError: can\'t use starred expression here\n\n    >>> *1 # doctest:+ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    SyntaxError: can\'t use starred expression here\n\n    >>> x = *a # doctest:+ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    SyntaxError: can\'t use starred expression here\n\n    >>> (*x),y = 1, 2 # doctest:+ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    SyntaxError: cannot use starred expression here\n\n    >>> (((*x))),y = 1, 2 # doctest:+ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    SyntaxError: cannot use starred expression here\n\n    >>> z,(*x),y = 1, 2, 4 # doctest:+ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    SyntaxError: cannot use starred expression here\n\n    >>> z,(*x) = 1, 2 # doctest:+ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    SyntaxError: cannot use starred expression here\n\n    >>> ((*x),y) = 1, 2 # doctest:+ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    SyntaxError: cannot use starred expression here\n\nSome size constraints (all fail.)\n\n    >>> s = ", ".join("a%d" % i for i in range(1<<8)) + ", *rest = range(1<<8 + 1)"\n    >>> compile(s, \'test\', \'exec\') # doctest:+ELLIPSIS\n    Traceback (most recent call last):\n     ...\n    SyntaxError: too many expressions in star-unpacking assignment\n\n    >>> s = ", ".join("a%d" % i for i in range(1<<8 + 1)) + ", *rest = range(1<<8 + 2)"\n    >>> compile(s, \'test\', \'exec\') # doctest:+ELLIPSIS\n    Traceback (most recent call last):\n     ...\n    SyntaxError: too many expressions in star-unpacking assignment\n\n(there is an additional limit, on the number of expressions after the\n\'*rest\', but it\'s 1<<24 and testing it takes too much memory.)\n\n'
__test__ = {'doctests': doctests}

def test_main(verbose=False):
    if False:
        while True:
            i = 10
    from test import support
    from test import test_unpack_ex
    support.run_doctest(test_unpack_ex, verbose)
if __name__ == '__main__':
    test_main(verbose=True)