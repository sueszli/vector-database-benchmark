[
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    self.orderid = list()\n    self.order = None\n    self.counttostop = 0\n    self.datastatus = 0\n    self.sma = bt.indicators.MovAv.SMA(self.data, period=self.p.smaperiod)\n    print('--------------------------------------------------')\n    print('Strategy Created')\n    print('--------------------------------------------------')",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    self.orderid = list()\n    self.order = None\n    self.counttostop = 0\n    self.datastatus = 0\n    self.sma = bt.indicators.MovAv.SMA(self.data, period=self.p.smaperiod)\n    print('--------------------------------------------------')\n    print('Strategy Created')\n    print('--------------------------------------------------')",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.orderid = list()\n    self.order = None\n    self.counttostop = 0\n    self.datastatus = 0\n    self.sma = bt.indicators.MovAv.SMA(self.data, period=self.p.smaperiod)\n    print('--------------------------------------------------')\n    print('Strategy Created')\n    print('--------------------------------------------------')",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.orderid = list()\n    self.order = None\n    self.counttostop = 0\n    self.datastatus = 0\n    self.sma = bt.indicators.MovAv.SMA(self.data, period=self.p.smaperiod)\n    print('--------------------------------------------------')\n    print('Strategy Created')\n    print('--------------------------------------------------')",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.orderid = list()\n    self.order = None\n    self.counttostop = 0\n    self.datastatus = 0\n    self.sma = bt.indicators.MovAv.SMA(self.data, period=self.p.smaperiod)\n    print('--------------------------------------------------')\n    print('Strategy Created')\n    print('--------------------------------------------------')",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.orderid = list()\n    self.order = None\n    self.counttostop = 0\n    self.datastatus = 0\n    self.sma = bt.indicators.MovAv.SMA(self.data, period=self.p.smaperiod)\n    print('--------------------------------------------------')\n    print('Strategy Created')\n    print('--------------------------------------------------')"
        ]
    },
    {
        "func_name": "notify_data",
        "original": "def notify_data(self, data, status, *args, **kwargs):\n    print('*' * 5, 'DATA NOTIF:', data._getstatusname(status), *args)\n    if status == data.LIVE:\n        self.counttostop = self.p.stopafter\n        self.datastatus = 1",
        "mutated": [
            "def notify_data(self, data, status, *args, **kwargs):\n    if False:\n        i = 10\n    print('*' * 5, 'DATA NOTIF:', data._getstatusname(status), *args)\n    if status == data.LIVE:\n        self.counttostop = self.p.stopafter\n        self.datastatus = 1",
            "def notify_data(self, data, status, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    print('*' * 5, 'DATA NOTIF:', data._getstatusname(status), *args)\n    if status == data.LIVE:\n        self.counttostop = self.p.stopafter\n        self.datastatus = 1",
            "def notify_data(self, data, status, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    print('*' * 5, 'DATA NOTIF:', data._getstatusname(status), *args)\n    if status == data.LIVE:\n        self.counttostop = self.p.stopafter\n        self.datastatus = 1",
            "def notify_data(self, data, status, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    print('*' * 5, 'DATA NOTIF:', data._getstatusname(status), *args)\n    if status == data.LIVE:\n        self.counttostop = self.p.stopafter\n        self.datastatus = 1",
            "def notify_data(self, data, status, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    print('*' * 5, 'DATA NOTIF:', data._getstatusname(status), *args)\n    if status == data.LIVE:\n        self.counttostop = self.p.stopafter\n        self.datastatus = 1"
        ]
    },
    {
        "func_name": "notify_store",
        "original": "def notify_store(self, msg, *args, **kwargs):\n    print('*' * 5, 'STORE NOTIF:', msg)",
        "mutated": [
            "def notify_store(self, msg, *args, **kwargs):\n    if False:\n        i = 10\n    print('*' * 5, 'STORE NOTIF:', msg)",
            "def notify_store(self, msg, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    print('*' * 5, 'STORE NOTIF:', msg)",
            "def notify_store(self, msg, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    print('*' * 5, 'STORE NOTIF:', msg)",
            "def notify_store(self, msg, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    print('*' * 5, 'STORE NOTIF:', msg)",
            "def notify_store(self, msg, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    print('*' * 5, 'STORE NOTIF:', msg)"
        ]
    },
    {
        "func_name": "notify_order",
        "original": "def notify_order(self, order):\n    if order.status in [order.Completed, order.Cancelled, order.Rejected]:\n        self.order = None\n    print('-' * 50, 'ORDER BEGIN', datetime.datetime.now())\n    print(order)\n    print('-' * 50, 'ORDER END')",
        "mutated": [
            "def notify_order(self, order):\n    if False:\n        i = 10\n    if order.status in [order.Completed, order.Cancelled, order.Rejected]:\n        self.order = None\n    print('-' * 50, 'ORDER BEGIN', datetime.datetime.now())\n    print(order)\n    print('-' * 50, 'ORDER END')",
            "def notify_order(self, order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if order.status in [order.Completed, order.Cancelled, order.Rejected]:\n        self.order = None\n    print('-' * 50, 'ORDER BEGIN', datetime.datetime.now())\n    print(order)\n    print('-' * 50, 'ORDER END')",
            "def notify_order(self, order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if order.status in [order.Completed, order.Cancelled, order.Rejected]:\n        self.order = None\n    print('-' * 50, 'ORDER BEGIN', datetime.datetime.now())\n    print(order)\n    print('-' * 50, 'ORDER END')",
            "def notify_order(self, order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if order.status in [order.Completed, order.Cancelled, order.Rejected]:\n        self.order = None\n    print('-' * 50, 'ORDER BEGIN', datetime.datetime.now())\n    print(order)\n    print('-' * 50, 'ORDER END')",
            "def notify_order(self, order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if order.status in [order.Completed, order.Cancelled, order.Rejected]:\n        self.order = None\n    print('-' * 50, 'ORDER BEGIN', datetime.datetime.now())\n    print(order)\n    print('-' * 50, 'ORDER END')"
        ]
    },
    {
        "func_name": "notify_trade",
        "original": "def notify_trade(self, trade):\n    print('-' * 50, 'TRADE BEGIN', datetime.datetime.now())\n    print(trade)\n    print('-' * 50, 'TRADE END')",
        "mutated": [
            "def notify_trade(self, trade):\n    if False:\n        i = 10\n    print('-' * 50, 'TRADE BEGIN', datetime.datetime.now())\n    print(trade)\n    print('-' * 50, 'TRADE END')",
            "def notify_trade(self, trade):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    print('-' * 50, 'TRADE BEGIN', datetime.datetime.now())\n    print(trade)\n    print('-' * 50, 'TRADE END')",
            "def notify_trade(self, trade):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    print('-' * 50, 'TRADE BEGIN', datetime.datetime.now())\n    print(trade)\n    print('-' * 50, 'TRADE END')",
            "def notify_trade(self, trade):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    print('-' * 50, 'TRADE BEGIN', datetime.datetime.now())\n    print(trade)\n    print('-' * 50, 'TRADE END')",
            "def notify_trade(self, trade):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    print('-' * 50, 'TRADE BEGIN', datetime.datetime.now())\n    print(trade)\n    print('-' * 50, 'TRADE END')"
        ]
    },
    {
        "func_name": "prenext",
        "original": "def prenext(self):\n    self.next(frompre=True)",
        "mutated": [
            "def prenext(self):\n    if False:\n        i = 10\n    self.next(frompre=True)",
            "def prenext(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.next(frompre=True)",
            "def prenext(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.next(frompre=True)",
            "def prenext(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.next(frompre=True)",
            "def prenext(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.next(frompre=True)"
        ]
    },
    {
        "func_name": "next",
        "original": "def next(self, frompre=False):\n    txt = list()\n    txt.append('%04d' % len(self))\n    dtfmt = '%Y-%m-%dT%H:%M:%S.%f'\n    txt.append('%s' % self.data.datetime.datetime(0).strftime(dtfmt))\n    txt.append('{}'.format(self.data.open[0]))\n    txt.append('{}'.format(self.data.high[0]))\n    txt.append('{}'.format(self.data.low[0]))\n    txt.append('{}'.format(self.data.close[0]))\n    txt.append('{}'.format(self.data.volume[0]))\n    txt.append('{}'.format(self.data.openinterest[0]))\n    txt.append('{}'.format(self.sma[0]))\n    print(', '.join(txt))\n    if len(self.datas) > 1:\n        txt = list()\n        txt.append('%04d' % len(self))\n        dtfmt = '%Y-%m-%dT%H:%M:%S.%f'\n        txt.append('%s' % self.data1.datetime.datetime(0).strftime(dtfmt))\n        txt.append('{}'.format(self.data1.open[0]))\n        txt.append('{}'.format(self.data1.high[0]))\n        txt.append('{}'.format(self.data1.low[0]))\n        txt.append('{}'.format(self.data1.close[0]))\n        txt.append('{}'.format(self.data1.volume[0]))\n        txt.append('{}'.format(self.data1.openinterest[0]))\n        txt.append('{}'.format(float('NaN')))\n        print(', '.join(txt))\n    if self.counttostop:\n        self.counttostop -= 1\n        if not self.counttostop:\n            self.env.runstop()\n            return\n    if not self.p.trade:\n        return\n    if self.datastatus and (not self.position) and (len(self.orderid) < 1):\n        self.order = self.buy(size=self.p.stake, exectype=self.p.exectype, price=self.p.price, plimit=self.p.pstoplimit, valid=self.p.valid)\n        self.orderid.append(self.order)\n    elif self.position.size > 0 and (not self.p.donotsell):\n        if self.order is None:\n            size = self.p.stake // 2\n            if not size:\n                size = self.position.size\n            self.order = self.sell(size=size, exectype=bt.Order.Market)\n    elif self.order is not None and self.p.cancel:\n        if self.datastatus > self.p.cancel:\n            self.cancel(self.order)\n    if self.datastatus:\n        self.datastatus += 1",
        "mutated": [
            "def next(self, frompre=False):\n    if False:\n        i = 10\n    txt = list()\n    txt.append('%04d' % len(self))\n    dtfmt = '%Y-%m-%dT%H:%M:%S.%f'\n    txt.append('%s' % self.data.datetime.datetime(0).strftime(dtfmt))\n    txt.append('{}'.format(self.data.open[0]))\n    txt.append('{}'.format(self.data.high[0]))\n    txt.append('{}'.format(self.data.low[0]))\n    txt.append('{}'.format(self.data.close[0]))\n    txt.append('{}'.format(self.data.volume[0]))\n    txt.append('{}'.format(self.data.openinterest[0]))\n    txt.append('{}'.format(self.sma[0]))\n    print(', '.join(txt))\n    if len(self.datas) > 1:\n        txt = list()\n        txt.append('%04d' % len(self))\n        dtfmt = '%Y-%m-%dT%H:%M:%S.%f'\n        txt.append('%s' % self.data1.datetime.datetime(0).strftime(dtfmt))\n        txt.append('{}'.format(self.data1.open[0]))\n        txt.append('{}'.format(self.data1.high[0]))\n        txt.append('{}'.format(self.data1.low[0]))\n        txt.append('{}'.format(self.data1.close[0]))\n        txt.append('{}'.format(self.data1.volume[0]))\n        txt.append('{}'.format(self.data1.openinterest[0]))\n        txt.append('{}'.format(float('NaN')))\n        print(', '.join(txt))\n    if self.counttostop:\n        self.counttostop -= 1\n        if not self.counttostop:\n            self.env.runstop()\n            return\n    if not self.p.trade:\n        return\n    if self.datastatus and (not self.position) and (len(self.orderid) < 1):\n        self.order = self.buy(size=self.p.stake, exectype=self.p.exectype, price=self.p.price, plimit=self.p.pstoplimit, valid=self.p.valid)\n        self.orderid.append(self.order)\n    elif self.position.size > 0 and (not self.p.donotsell):\n        if self.order is None:\n            size = self.p.stake // 2\n            if not size:\n                size = self.position.size\n            self.order = self.sell(size=size, exectype=bt.Order.Market)\n    elif self.order is not None and self.p.cancel:\n        if self.datastatus > self.p.cancel:\n            self.cancel(self.order)\n    if self.datastatus:\n        self.datastatus += 1",
            "def next(self, frompre=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    txt = list()\n    txt.append('%04d' % len(self))\n    dtfmt = '%Y-%m-%dT%H:%M:%S.%f'\n    txt.append('%s' % self.data.datetime.datetime(0).strftime(dtfmt))\n    txt.append('{}'.format(self.data.open[0]))\n    txt.append('{}'.format(self.data.high[0]))\n    txt.append('{}'.format(self.data.low[0]))\n    txt.append('{}'.format(self.data.close[0]))\n    txt.append('{}'.format(self.data.volume[0]))\n    txt.append('{}'.format(self.data.openinterest[0]))\n    txt.append('{}'.format(self.sma[0]))\n    print(', '.join(txt))\n    if len(self.datas) > 1:\n        txt = list()\n        txt.append('%04d' % len(self))\n        dtfmt = '%Y-%m-%dT%H:%M:%S.%f'\n        txt.append('%s' % self.data1.datetime.datetime(0).strftime(dtfmt))\n        txt.append('{}'.format(self.data1.open[0]))\n        txt.append('{}'.format(self.data1.high[0]))\n        txt.append('{}'.format(self.data1.low[0]))\n        txt.append('{}'.format(self.data1.close[0]))\n        txt.append('{}'.format(self.data1.volume[0]))\n        txt.append('{}'.format(self.data1.openinterest[0]))\n        txt.append('{}'.format(float('NaN')))\n        print(', '.join(txt))\n    if self.counttostop:\n        self.counttostop -= 1\n        if not self.counttostop:\n            self.env.runstop()\n            return\n    if not self.p.trade:\n        return\n    if self.datastatus and (not self.position) and (len(self.orderid) < 1):\n        self.order = self.buy(size=self.p.stake, exectype=self.p.exectype, price=self.p.price, plimit=self.p.pstoplimit, valid=self.p.valid)\n        self.orderid.append(self.order)\n    elif self.position.size > 0 and (not self.p.donotsell):\n        if self.order is None:\n            size = self.p.stake // 2\n            if not size:\n                size = self.position.size\n            self.order = self.sell(size=size, exectype=bt.Order.Market)\n    elif self.order is not None and self.p.cancel:\n        if self.datastatus > self.p.cancel:\n            self.cancel(self.order)\n    if self.datastatus:\n        self.datastatus += 1",
            "def next(self, frompre=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    txt = list()\n    txt.append('%04d' % len(self))\n    dtfmt = '%Y-%m-%dT%H:%M:%S.%f'\n    txt.append('%s' % self.data.datetime.datetime(0).strftime(dtfmt))\n    txt.append('{}'.format(self.data.open[0]))\n    txt.append('{}'.format(self.data.high[0]))\n    txt.append('{}'.format(self.data.low[0]))\n    txt.append('{}'.format(self.data.close[0]))\n    txt.append('{}'.format(self.data.volume[0]))\n    txt.append('{}'.format(self.data.openinterest[0]))\n    txt.append('{}'.format(self.sma[0]))\n    print(', '.join(txt))\n    if len(self.datas) > 1:\n        txt = list()\n        txt.append('%04d' % len(self))\n        dtfmt = '%Y-%m-%dT%H:%M:%S.%f'\n        txt.append('%s' % self.data1.datetime.datetime(0).strftime(dtfmt))\n        txt.append('{}'.format(self.data1.open[0]))\n        txt.append('{}'.format(self.data1.high[0]))\n        txt.append('{}'.format(self.data1.low[0]))\n        txt.append('{}'.format(self.data1.close[0]))\n        txt.append('{}'.format(self.data1.volume[0]))\n        txt.append('{}'.format(self.data1.openinterest[0]))\n        txt.append('{}'.format(float('NaN')))\n        print(', '.join(txt))\n    if self.counttostop:\n        self.counttostop -= 1\n        if not self.counttostop:\n            self.env.runstop()\n            return\n    if not self.p.trade:\n        return\n    if self.datastatus and (not self.position) and (len(self.orderid) < 1):\n        self.order = self.buy(size=self.p.stake, exectype=self.p.exectype, price=self.p.price, plimit=self.p.pstoplimit, valid=self.p.valid)\n        self.orderid.append(self.order)\n    elif self.position.size > 0 and (not self.p.donotsell):\n        if self.order is None:\n            size = self.p.stake // 2\n            if not size:\n                size = self.position.size\n            self.order = self.sell(size=size, exectype=bt.Order.Market)\n    elif self.order is not None and self.p.cancel:\n        if self.datastatus > self.p.cancel:\n            self.cancel(self.order)\n    if self.datastatus:\n        self.datastatus += 1",
            "def next(self, frompre=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    txt = list()\n    txt.append('%04d' % len(self))\n    dtfmt = '%Y-%m-%dT%H:%M:%S.%f'\n    txt.append('%s' % self.data.datetime.datetime(0).strftime(dtfmt))\n    txt.append('{}'.format(self.data.open[0]))\n    txt.append('{}'.format(self.data.high[0]))\n    txt.append('{}'.format(self.data.low[0]))\n    txt.append('{}'.format(self.data.close[0]))\n    txt.append('{}'.format(self.data.volume[0]))\n    txt.append('{}'.format(self.data.openinterest[0]))\n    txt.append('{}'.format(self.sma[0]))\n    print(', '.join(txt))\n    if len(self.datas) > 1:\n        txt = list()\n        txt.append('%04d' % len(self))\n        dtfmt = '%Y-%m-%dT%H:%M:%S.%f'\n        txt.append('%s' % self.data1.datetime.datetime(0).strftime(dtfmt))\n        txt.append('{}'.format(self.data1.open[0]))\n        txt.append('{}'.format(self.data1.high[0]))\n        txt.append('{}'.format(self.data1.low[0]))\n        txt.append('{}'.format(self.data1.close[0]))\n        txt.append('{}'.format(self.data1.volume[0]))\n        txt.append('{}'.format(self.data1.openinterest[0]))\n        txt.append('{}'.format(float('NaN')))\n        print(', '.join(txt))\n    if self.counttostop:\n        self.counttostop -= 1\n        if not self.counttostop:\n            self.env.runstop()\n            return\n    if not self.p.trade:\n        return\n    if self.datastatus and (not self.position) and (len(self.orderid) < 1):\n        self.order = self.buy(size=self.p.stake, exectype=self.p.exectype, price=self.p.price, plimit=self.p.pstoplimit, valid=self.p.valid)\n        self.orderid.append(self.order)\n    elif self.position.size > 0 and (not self.p.donotsell):\n        if self.order is None:\n            size = self.p.stake // 2\n            if not size:\n                size = self.position.size\n            self.order = self.sell(size=size, exectype=bt.Order.Market)\n    elif self.order is not None and self.p.cancel:\n        if self.datastatus > self.p.cancel:\n            self.cancel(self.order)\n    if self.datastatus:\n        self.datastatus += 1",
            "def next(self, frompre=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    txt = list()\n    txt.append('%04d' % len(self))\n    dtfmt = '%Y-%m-%dT%H:%M:%S.%f'\n    txt.append('%s' % self.data.datetime.datetime(0).strftime(dtfmt))\n    txt.append('{}'.format(self.data.open[0]))\n    txt.append('{}'.format(self.data.high[0]))\n    txt.append('{}'.format(self.data.low[0]))\n    txt.append('{}'.format(self.data.close[0]))\n    txt.append('{}'.format(self.data.volume[0]))\n    txt.append('{}'.format(self.data.openinterest[0]))\n    txt.append('{}'.format(self.sma[0]))\n    print(', '.join(txt))\n    if len(self.datas) > 1:\n        txt = list()\n        txt.append('%04d' % len(self))\n        dtfmt = '%Y-%m-%dT%H:%M:%S.%f'\n        txt.append('%s' % self.data1.datetime.datetime(0).strftime(dtfmt))\n        txt.append('{}'.format(self.data1.open[0]))\n        txt.append('{}'.format(self.data1.high[0]))\n        txt.append('{}'.format(self.data1.low[0]))\n        txt.append('{}'.format(self.data1.close[0]))\n        txt.append('{}'.format(self.data1.volume[0]))\n        txt.append('{}'.format(self.data1.openinterest[0]))\n        txt.append('{}'.format(float('NaN')))\n        print(', '.join(txt))\n    if self.counttostop:\n        self.counttostop -= 1\n        if not self.counttostop:\n            self.env.runstop()\n            return\n    if not self.p.trade:\n        return\n    if self.datastatus and (not self.position) and (len(self.orderid) < 1):\n        self.order = self.buy(size=self.p.stake, exectype=self.p.exectype, price=self.p.price, plimit=self.p.pstoplimit, valid=self.p.valid)\n        self.orderid.append(self.order)\n    elif self.position.size > 0 and (not self.p.donotsell):\n        if self.order is None:\n            size = self.p.stake // 2\n            if not size:\n                size = self.position.size\n            self.order = self.sell(size=size, exectype=bt.Order.Market)\n    elif self.order is not None and self.p.cancel:\n        if self.datastatus > self.p.cancel:\n            self.cancel(self.order)\n    if self.datastatus:\n        self.datastatus += 1"
        ]
    },
    {
        "func_name": "start",
        "original": "def start(self):\n    header = ['Datetime', 'Open', 'High', 'Low', 'Close', 'Volume', 'OpenInterest', 'SMA']\n    print(', '.join(header))\n    self.done = False",
        "mutated": [
            "def start(self):\n    if False:\n        i = 10\n    header = ['Datetime', 'Open', 'High', 'Low', 'Close', 'Volume', 'OpenInterest', 'SMA']\n    print(', '.join(header))\n    self.done = False",
            "def start(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    header = ['Datetime', 'Open', 'High', 'Low', 'Close', 'Volume', 'OpenInterest', 'SMA']\n    print(', '.join(header))\n    self.done = False",
            "def start(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    header = ['Datetime', 'Open', 'High', 'Low', 'Close', 'Volume', 'OpenInterest', 'SMA']\n    print(', '.join(header))\n    self.done = False",
            "def start(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    header = ['Datetime', 'Open', 'High', 'Low', 'Close', 'Volume', 'OpenInterest', 'SMA']\n    print(', '.join(header))\n    self.done = False",
            "def start(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    header = ['Datetime', 'Open', 'High', 'Low', 'Close', 'Volume', 'OpenInterest', 'SMA']\n    print(', '.join(header))\n    self.done = False"
        ]
    },
    {
        "func_name": "runstrategy",
        "original": "def runstrategy():\n    args = parse_args()\n    cerebro = bt.Cerebro()\n    storekwargs = dict()\n    if not args.nostore:\n        vcstore = bt.stores.VCStore(**storekwargs)\n    if args.broker:\n        brokerargs = dict(account=args.account, **storekwargs)\n        if not args.nostore:\n            broker = vcstore.getbroker(**brokerargs)\n        else:\n            broker = bt.brokers.VCBroker(**brokerargs)\n        cerebro.setbroker(broker)\n    timeframe = bt.TimeFrame.TFrame(args.timeframe)\n    if args.resample or args.replay:\n        datatf = bt.TimeFrame.Ticks\n        datacomp = 1\n    else:\n        datatf = timeframe\n        datacomp = args.compression\n    fromdate = None\n    if args.fromdate:\n        dtformat = '%Y-%m-%d' + 'T%H:%M:%S' * ('T' in args.fromdate)\n        fromdate = datetime.datetime.strptime(args.fromdate, dtformat)\n    todate = None\n    if args.todate:\n        dtformat = '%Y-%m-%d' + 'T%H:%M:%S' * ('T' in args.todate)\n        todate = datetime.datetime.strptime(args.todate, dtformat)\n    VCDataFactory = vcstore.getdata if not args.nostore else bt.feeds.VCData\n    datakwargs = dict(timeframe=datatf, compression=datacomp, fromdate=fromdate, todate=todate, historical=args.historical, qcheck=args.qcheck, tz=args.timezone)\n    if args.nostore and (not args.broker):\n        datakwargs.update(storekwargs)\n    data0 = VCDataFactory(dataname=args.data0, tradename=args.tradename, **datakwargs)\n    data1 = None\n    if args.data1 is not None:\n        data1 = VCDataFactory(dataname=args.data1, **datakwargs)\n    rekwargs = dict(timeframe=timeframe, compression=args.compression, bar2edge=not args.no_bar2edge, adjbartime=not args.no_adjbartime, rightedge=not args.no_rightedge)\n    if args.replay:\n        cerebro.replaydata(data0, **rekwargs)\n        if data1 is not None:\n            cerebro.replaydata(data1, **rekwargs)\n    elif args.resample:\n        cerebro.resampledata(data0, **rekwargs)\n        if data1 is not None:\n            cerebro.resampledata(data1, **rekwargs)\n    else:\n        cerebro.adddata(data0)\n        if data1 is not None:\n            cerebro.adddata(data1)\n    if args.valid is None:\n        valid = None\n    else:\n        try:\n            valid = float(args.valid)\n        except:\n            dtformat = '%Y-%m-%d' + 'T%H:%M:%S' * ('T' in args.valid)\n            valid = datetime.datetime.strptime(args.valid, dtformat)\n        else:\n            valid = datetime.timedelta(seconds=args.valid)\n    cerebro.addstrategy(TestStrategy, smaperiod=args.smaperiod, trade=args.trade, exectype=bt.Order.ExecType(args.exectype), stake=args.stake, stopafter=args.stopafter, valid=valid, cancel=args.cancel, donotsell=args.donotsell, price=args.price, pstoplimit=args.pstoplimit)\n    cerebro.run(exactbars=args.exactbars)\n    if args.plot and args.exactbars < 1:\n        cerebro.plot()",
        "mutated": [
            "def runstrategy():\n    if False:\n        i = 10\n    args = parse_args()\n    cerebro = bt.Cerebro()\n    storekwargs = dict()\n    if not args.nostore:\n        vcstore = bt.stores.VCStore(**storekwargs)\n    if args.broker:\n        brokerargs = dict(account=args.account, **storekwargs)\n        if not args.nostore:\n            broker = vcstore.getbroker(**brokerargs)\n        else:\n            broker = bt.brokers.VCBroker(**brokerargs)\n        cerebro.setbroker(broker)\n    timeframe = bt.TimeFrame.TFrame(args.timeframe)\n    if args.resample or args.replay:\n        datatf = bt.TimeFrame.Ticks\n        datacomp = 1\n    else:\n        datatf = timeframe\n        datacomp = args.compression\n    fromdate = None\n    if args.fromdate:\n        dtformat = '%Y-%m-%d' + 'T%H:%M:%S' * ('T' in args.fromdate)\n        fromdate = datetime.datetime.strptime(args.fromdate, dtformat)\n    todate = None\n    if args.todate:\n        dtformat = '%Y-%m-%d' + 'T%H:%M:%S' * ('T' in args.todate)\n        todate = datetime.datetime.strptime(args.todate, dtformat)\n    VCDataFactory = vcstore.getdata if not args.nostore else bt.feeds.VCData\n    datakwargs = dict(timeframe=datatf, compression=datacomp, fromdate=fromdate, todate=todate, historical=args.historical, qcheck=args.qcheck, tz=args.timezone)\n    if args.nostore and (not args.broker):\n        datakwargs.update(storekwargs)\n    data0 = VCDataFactory(dataname=args.data0, tradename=args.tradename, **datakwargs)\n    data1 = None\n    if args.data1 is not None:\n        data1 = VCDataFactory(dataname=args.data1, **datakwargs)\n    rekwargs = dict(timeframe=timeframe, compression=args.compression, bar2edge=not args.no_bar2edge, adjbartime=not args.no_adjbartime, rightedge=not args.no_rightedge)\n    if args.replay:\n        cerebro.replaydata(data0, **rekwargs)\n        if data1 is not None:\n            cerebro.replaydata(data1, **rekwargs)\n    elif args.resample:\n        cerebro.resampledata(data0, **rekwargs)\n        if data1 is not None:\n            cerebro.resampledata(data1, **rekwargs)\n    else:\n        cerebro.adddata(data0)\n        if data1 is not None:\n            cerebro.adddata(data1)\n    if args.valid is None:\n        valid = None\n    else:\n        try:\n            valid = float(args.valid)\n        except:\n            dtformat = '%Y-%m-%d' + 'T%H:%M:%S' * ('T' in args.valid)\n            valid = datetime.datetime.strptime(args.valid, dtformat)\n        else:\n            valid = datetime.timedelta(seconds=args.valid)\n    cerebro.addstrategy(TestStrategy, smaperiod=args.smaperiod, trade=args.trade, exectype=bt.Order.ExecType(args.exectype), stake=args.stake, stopafter=args.stopafter, valid=valid, cancel=args.cancel, donotsell=args.donotsell, price=args.price, pstoplimit=args.pstoplimit)\n    cerebro.run(exactbars=args.exactbars)\n    if args.plot and args.exactbars < 1:\n        cerebro.plot()",
            "def runstrategy():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    args = parse_args()\n    cerebro = bt.Cerebro()\n    storekwargs = dict()\n    if not args.nostore:\n        vcstore = bt.stores.VCStore(**storekwargs)\n    if args.broker:\n        brokerargs = dict(account=args.account, **storekwargs)\n        if not args.nostore:\n            broker = vcstore.getbroker(**brokerargs)\n        else:\n            broker = bt.brokers.VCBroker(**brokerargs)\n        cerebro.setbroker(broker)\n    timeframe = bt.TimeFrame.TFrame(args.timeframe)\n    if args.resample or args.replay:\n        datatf = bt.TimeFrame.Ticks\n        datacomp = 1\n    else:\n        datatf = timeframe\n        datacomp = args.compression\n    fromdate = None\n    if args.fromdate:\n        dtformat = '%Y-%m-%d' + 'T%H:%M:%S' * ('T' in args.fromdate)\n        fromdate = datetime.datetime.strptime(args.fromdate, dtformat)\n    todate = None\n    if args.todate:\n        dtformat = '%Y-%m-%d' + 'T%H:%M:%S' * ('T' in args.todate)\n        todate = datetime.datetime.strptime(args.todate, dtformat)\n    VCDataFactory = vcstore.getdata if not args.nostore else bt.feeds.VCData\n    datakwargs = dict(timeframe=datatf, compression=datacomp, fromdate=fromdate, todate=todate, historical=args.historical, qcheck=args.qcheck, tz=args.timezone)\n    if args.nostore and (not args.broker):\n        datakwargs.update(storekwargs)\n    data0 = VCDataFactory(dataname=args.data0, tradename=args.tradename, **datakwargs)\n    data1 = None\n    if args.data1 is not None:\n        data1 = VCDataFactory(dataname=args.data1, **datakwargs)\n    rekwargs = dict(timeframe=timeframe, compression=args.compression, bar2edge=not args.no_bar2edge, adjbartime=not args.no_adjbartime, rightedge=not args.no_rightedge)\n    if args.replay:\n        cerebro.replaydata(data0, **rekwargs)\n        if data1 is not None:\n            cerebro.replaydata(data1, **rekwargs)\n    elif args.resample:\n        cerebro.resampledata(data0, **rekwargs)\n        if data1 is not None:\n            cerebro.resampledata(data1, **rekwargs)\n    else:\n        cerebro.adddata(data0)\n        if data1 is not None:\n            cerebro.adddata(data1)\n    if args.valid is None:\n        valid = None\n    else:\n        try:\n            valid = float(args.valid)\n        except:\n            dtformat = '%Y-%m-%d' + 'T%H:%M:%S' * ('T' in args.valid)\n            valid = datetime.datetime.strptime(args.valid, dtformat)\n        else:\n            valid = datetime.timedelta(seconds=args.valid)\n    cerebro.addstrategy(TestStrategy, smaperiod=args.smaperiod, trade=args.trade, exectype=bt.Order.ExecType(args.exectype), stake=args.stake, stopafter=args.stopafter, valid=valid, cancel=args.cancel, donotsell=args.donotsell, price=args.price, pstoplimit=args.pstoplimit)\n    cerebro.run(exactbars=args.exactbars)\n    if args.plot and args.exactbars < 1:\n        cerebro.plot()",
            "def runstrategy():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    args = parse_args()\n    cerebro = bt.Cerebro()\n    storekwargs = dict()\n    if not args.nostore:\n        vcstore = bt.stores.VCStore(**storekwargs)\n    if args.broker:\n        brokerargs = dict(account=args.account, **storekwargs)\n        if not args.nostore:\n            broker = vcstore.getbroker(**brokerargs)\n        else:\n            broker = bt.brokers.VCBroker(**brokerargs)\n        cerebro.setbroker(broker)\n    timeframe = bt.TimeFrame.TFrame(args.timeframe)\n    if args.resample or args.replay:\n        datatf = bt.TimeFrame.Ticks\n        datacomp = 1\n    else:\n        datatf = timeframe\n        datacomp = args.compression\n    fromdate = None\n    if args.fromdate:\n        dtformat = '%Y-%m-%d' + 'T%H:%M:%S' * ('T' in args.fromdate)\n        fromdate = datetime.datetime.strptime(args.fromdate, dtformat)\n    todate = None\n    if args.todate:\n        dtformat = '%Y-%m-%d' + 'T%H:%M:%S' * ('T' in args.todate)\n        todate = datetime.datetime.strptime(args.todate, dtformat)\n    VCDataFactory = vcstore.getdata if not args.nostore else bt.feeds.VCData\n    datakwargs = dict(timeframe=datatf, compression=datacomp, fromdate=fromdate, todate=todate, historical=args.historical, qcheck=args.qcheck, tz=args.timezone)\n    if args.nostore and (not args.broker):\n        datakwargs.update(storekwargs)\n    data0 = VCDataFactory(dataname=args.data0, tradename=args.tradename, **datakwargs)\n    data1 = None\n    if args.data1 is not None:\n        data1 = VCDataFactory(dataname=args.data1, **datakwargs)\n    rekwargs = dict(timeframe=timeframe, compression=args.compression, bar2edge=not args.no_bar2edge, adjbartime=not args.no_adjbartime, rightedge=not args.no_rightedge)\n    if args.replay:\n        cerebro.replaydata(data0, **rekwargs)\n        if data1 is not None:\n            cerebro.replaydata(data1, **rekwargs)\n    elif args.resample:\n        cerebro.resampledata(data0, **rekwargs)\n        if data1 is not None:\n            cerebro.resampledata(data1, **rekwargs)\n    else:\n        cerebro.adddata(data0)\n        if data1 is not None:\n            cerebro.adddata(data1)\n    if args.valid is None:\n        valid = None\n    else:\n        try:\n            valid = float(args.valid)\n        except:\n            dtformat = '%Y-%m-%d' + 'T%H:%M:%S' * ('T' in args.valid)\n            valid = datetime.datetime.strptime(args.valid, dtformat)\n        else:\n            valid = datetime.timedelta(seconds=args.valid)\n    cerebro.addstrategy(TestStrategy, smaperiod=args.smaperiod, trade=args.trade, exectype=bt.Order.ExecType(args.exectype), stake=args.stake, stopafter=args.stopafter, valid=valid, cancel=args.cancel, donotsell=args.donotsell, price=args.price, pstoplimit=args.pstoplimit)\n    cerebro.run(exactbars=args.exactbars)\n    if args.plot and args.exactbars < 1:\n        cerebro.plot()",
            "def runstrategy():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    args = parse_args()\n    cerebro = bt.Cerebro()\n    storekwargs = dict()\n    if not args.nostore:\n        vcstore = bt.stores.VCStore(**storekwargs)\n    if args.broker:\n        brokerargs = dict(account=args.account, **storekwargs)\n        if not args.nostore:\n            broker = vcstore.getbroker(**brokerargs)\n        else:\n            broker = bt.brokers.VCBroker(**brokerargs)\n        cerebro.setbroker(broker)\n    timeframe = bt.TimeFrame.TFrame(args.timeframe)\n    if args.resample or args.replay:\n        datatf = bt.TimeFrame.Ticks\n        datacomp = 1\n    else:\n        datatf = timeframe\n        datacomp = args.compression\n    fromdate = None\n    if args.fromdate:\n        dtformat = '%Y-%m-%d' + 'T%H:%M:%S' * ('T' in args.fromdate)\n        fromdate = datetime.datetime.strptime(args.fromdate, dtformat)\n    todate = None\n    if args.todate:\n        dtformat = '%Y-%m-%d' + 'T%H:%M:%S' * ('T' in args.todate)\n        todate = datetime.datetime.strptime(args.todate, dtformat)\n    VCDataFactory = vcstore.getdata if not args.nostore else bt.feeds.VCData\n    datakwargs = dict(timeframe=datatf, compression=datacomp, fromdate=fromdate, todate=todate, historical=args.historical, qcheck=args.qcheck, tz=args.timezone)\n    if args.nostore and (not args.broker):\n        datakwargs.update(storekwargs)\n    data0 = VCDataFactory(dataname=args.data0, tradename=args.tradename, **datakwargs)\n    data1 = None\n    if args.data1 is not None:\n        data1 = VCDataFactory(dataname=args.data1, **datakwargs)\n    rekwargs = dict(timeframe=timeframe, compression=args.compression, bar2edge=not args.no_bar2edge, adjbartime=not args.no_adjbartime, rightedge=not args.no_rightedge)\n    if args.replay:\n        cerebro.replaydata(data0, **rekwargs)\n        if data1 is not None:\n            cerebro.replaydata(data1, **rekwargs)\n    elif args.resample:\n        cerebro.resampledata(data0, **rekwargs)\n        if data1 is not None:\n            cerebro.resampledata(data1, **rekwargs)\n    else:\n        cerebro.adddata(data0)\n        if data1 is not None:\n            cerebro.adddata(data1)\n    if args.valid is None:\n        valid = None\n    else:\n        try:\n            valid = float(args.valid)\n        except:\n            dtformat = '%Y-%m-%d' + 'T%H:%M:%S' * ('T' in args.valid)\n            valid = datetime.datetime.strptime(args.valid, dtformat)\n        else:\n            valid = datetime.timedelta(seconds=args.valid)\n    cerebro.addstrategy(TestStrategy, smaperiod=args.smaperiod, trade=args.trade, exectype=bt.Order.ExecType(args.exectype), stake=args.stake, stopafter=args.stopafter, valid=valid, cancel=args.cancel, donotsell=args.donotsell, price=args.price, pstoplimit=args.pstoplimit)\n    cerebro.run(exactbars=args.exactbars)\n    if args.plot and args.exactbars < 1:\n        cerebro.plot()",
            "def runstrategy():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    args = parse_args()\n    cerebro = bt.Cerebro()\n    storekwargs = dict()\n    if not args.nostore:\n        vcstore = bt.stores.VCStore(**storekwargs)\n    if args.broker:\n        brokerargs = dict(account=args.account, **storekwargs)\n        if not args.nostore:\n            broker = vcstore.getbroker(**brokerargs)\n        else:\n            broker = bt.brokers.VCBroker(**brokerargs)\n        cerebro.setbroker(broker)\n    timeframe = bt.TimeFrame.TFrame(args.timeframe)\n    if args.resample or args.replay:\n        datatf = bt.TimeFrame.Ticks\n        datacomp = 1\n    else:\n        datatf = timeframe\n        datacomp = args.compression\n    fromdate = None\n    if args.fromdate:\n        dtformat = '%Y-%m-%d' + 'T%H:%M:%S' * ('T' in args.fromdate)\n        fromdate = datetime.datetime.strptime(args.fromdate, dtformat)\n    todate = None\n    if args.todate:\n        dtformat = '%Y-%m-%d' + 'T%H:%M:%S' * ('T' in args.todate)\n        todate = datetime.datetime.strptime(args.todate, dtformat)\n    VCDataFactory = vcstore.getdata if not args.nostore else bt.feeds.VCData\n    datakwargs = dict(timeframe=datatf, compression=datacomp, fromdate=fromdate, todate=todate, historical=args.historical, qcheck=args.qcheck, tz=args.timezone)\n    if args.nostore and (not args.broker):\n        datakwargs.update(storekwargs)\n    data0 = VCDataFactory(dataname=args.data0, tradename=args.tradename, **datakwargs)\n    data1 = None\n    if args.data1 is not None:\n        data1 = VCDataFactory(dataname=args.data1, **datakwargs)\n    rekwargs = dict(timeframe=timeframe, compression=args.compression, bar2edge=not args.no_bar2edge, adjbartime=not args.no_adjbartime, rightedge=not args.no_rightedge)\n    if args.replay:\n        cerebro.replaydata(data0, **rekwargs)\n        if data1 is not None:\n            cerebro.replaydata(data1, **rekwargs)\n    elif args.resample:\n        cerebro.resampledata(data0, **rekwargs)\n        if data1 is not None:\n            cerebro.resampledata(data1, **rekwargs)\n    else:\n        cerebro.adddata(data0)\n        if data1 is not None:\n            cerebro.adddata(data1)\n    if args.valid is None:\n        valid = None\n    else:\n        try:\n            valid = float(args.valid)\n        except:\n            dtformat = '%Y-%m-%d' + 'T%H:%M:%S' * ('T' in args.valid)\n            valid = datetime.datetime.strptime(args.valid, dtformat)\n        else:\n            valid = datetime.timedelta(seconds=args.valid)\n    cerebro.addstrategy(TestStrategy, smaperiod=args.smaperiod, trade=args.trade, exectype=bt.Order.ExecType(args.exectype), stake=args.stake, stopafter=args.stopafter, valid=valid, cancel=args.cancel, donotsell=args.donotsell, price=args.price, pstoplimit=args.pstoplimit)\n    cerebro.run(exactbars=args.exactbars)\n    if args.plot and args.exactbars < 1:\n        cerebro.plot()"
        ]
    },
    {
        "func_name": "parse_args",
        "original": "def parse_args():\n    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter, description='Test Visual Chart 6 integration')\n    parser.add_argument('--exactbars', default=1, type=int, required=False, action='store', help='exactbars level, use 0/-1/-2 to enable plotting')\n    parser.add_argument('--plot', required=False, action='store_true', help='Plot if possible')\n    parser.add_argument('--stopafter', default=0, type=int, required=False, action='store', help='Stop after x lines of LIVE data')\n    parser.add_argument('--nostore', required=False, action='store_true', help='Do not Use the store pattern')\n    parser.add_argument('--qcheck', default=0.5, type=float, required=False, action='store', help='Timeout for periodic notification/resampling/replaying check')\n    parser.add_argument('--no-timeoffset', required=False, action='store_true', help='Do not Use TWS/System time offset for non timestamped prices and to align resampling')\n    parser.add_argument('--data0', default=None, required=True, action='store', help='data 0 into the system')\n    parser.add_argument('--tradename', default=None, required=False, action='store', help='Actual Trading Name of the asset')\n    parser.add_argument('--data1', default=None, required=False, action='store', help='data 1 into the system')\n    parser.add_argument('--timezone', default=None, required=False, action='store', help='timezone to get time output into (pytz names)')\n    parser.add_argument('--historical', required=False, action='store_true', help='do only historical download')\n    parser.add_argument('--fromdate', required=False, action='store', help='Starting date for historical download with format: YYYY-MM-DD[THH:MM:SS]')\n    parser.add_argument('--todate', required=False, action='store', help='End date for historical download with format: YYYY-MM-DD[THH:MM:SS]')\n    parser.add_argument('--smaperiod', default=5, type=int, required=False, action='store', help='Period to apply to the Simple Moving Average')\n    pgroup = parser.add_mutually_exclusive_group(required=False)\n    pgroup.add_argument('--replay', required=False, action='store_true', help='replay to chosen timeframe')\n    pgroup.add_argument('--resample', required=False, action='store_true', help='resample to chosen timeframe')\n    parser.add_argument('--timeframe', default=bt.TimeFrame.Names[0], choices=bt.TimeFrame.Names, required=False, action='store', help='TimeFrame for Resample/Replay')\n    parser.add_argument('--compression', default=1, type=int, required=False, action='store', help='Compression for Resample/Replay')\n    parser.add_argument('--no-bar2edge', required=False, action='store_true', help='no bar2edge for resample/replay')\n    parser.add_argument('--no-adjbartime', required=False, action='store_true', help='no adjbartime for resample/replay')\n    parser.add_argument('--no-rightedge', required=False, action='store_true', help='no rightedge for resample/replay')\n    parser.add_argument('--broker', required=False, action='store_true', help='Use VisualChart as broker')\n    parser.add_argument('--account', default=None, required=False, action='store', help='Choose broker account (else first)')\n    parser.add_argument('--trade', required=False, action='store_true', help='Do Sample Buy/Sell operations')\n    parser.add_argument('--donotsell', required=False, action='store_true', help='Do not sell after a buy')\n    parser.add_argument('--exectype', default=bt.Order.ExecTypes[0], choices=bt.Order.ExecTypes, required=False, action='store', help='Execution to Use when opening position')\n    parser.add_argument('--price', default=None, type=float, required=False, action='store', help='Price in Limit orders or Stop Trigger Price')\n    parser.add_argument('--pstoplimit', default=None, type=float, required=False, action='store', help='Price for the limit in StopLimit')\n    parser.add_argument('--stake', default=10, type=int, required=False, action='store', help='Stake to use in buy operations')\n    parser.add_argument('--valid', default=None, required=False, action='store', help='Seconds or YYYY-MM-DD')\n    parser.add_argument('--cancel', default=0, type=int, required=False, action='store', help='Cancel a buy order after n bars in operation, to be combined with orders like Limit')\n    return parser.parse_args()",
        "mutated": [
            "def parse_args():\n    if False:\n        i = 10\n    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter, description='Test Visual Chart 6 integration')\n    parser.add_argument('--exactbars', default=1, type=int, required=False, action='store', help='exactbars level, use 0/-1/-2 to enable plotting')\n    parser.add_argument('--plot', required=False, action='store_true', help='Plot if possible')\n    parser.add_argument('--stopafter', default=0, type=int, required=False, action='store', help='Stop after x lines of LIVE data')\n    parser.add_argument('--nostore', required=False, action='store_true', help='Do not Use the store pattern')\n    parser.add_argument('--qcheck', default=0.5, type=float, required=False, action='store', help='Timeout for periodic notification/resampling/replaying check')\n    parser.add_argument('--no-timeoffset', required=False, action='store_true', help='Do not Use TWS/System time offset for non timestamped prices and to align resampling')\n    parser.add_argument('--data0', default=None, required=True, action='store', help='data 0 into the system')\n    parser.add_argument('--tradename', default=None, required=False, action='store', help='Actual Trading Name of the asset')\n    parser.add_argument('--data1', default=None, required=False, action='store', help='data 1 into the system')\n    parser.add_argument('--timezone', default=None, required=False, action='store', help='timezone to get time output into (pytz names)')\n    parser.add_argument('--historical', required=False, action='store_true', help='do only historical download')\n    parser.add_argument('--fromdate', required=False, action='store', help='Starting date for historical download with format: YYYY-MM-DD[THH:MM:SS]')\n    parser.add_argument('--todate', required=False, action='store', help='End date for historical download with format: YYYY-MM-DD[THH:MM:SS]')\n    parser.add_argument('--smaperiod', default=5, type=int, required=False, action='store', help='Period to apply to the Simple Moving Average')\n    pgroup = parser.add_mutually_exclusive_group(required=False)\n    pgroup.add_argument('--replay', required=False, action='store_true', help='replay to chosen timeframe')\n    pgroup.add_argument('--resample', required=False, action='store_true', help='resample to chosen timeframe')\n    parser.add_argument('--timeframe', default=bt.TimeFrame.Names[0], choices=bt.TimeFrame.Names, required=False, action='store', help='TimeFrame for Resample/Replay')\n    parser.add_argument('--compression', default=1, type=int, required=False, action='store', help='Compression for Resample/Replay')\n    parser.add_argument('--no-bar2edge', required=False, action='store_true', help='no bar2edge for resample/replay')\n    parser.add_argument('--no-adjbartime', required=False, action='store_true', help='no adjbartime for resample/replay')\n    parser.add_argument('--no-rightedge', required=False, action='store_true', help='no rightedge for resample/replay')\n    parser.add_argument('--broker', required=False, action='store_true', help='Use VisualChart as broker')\n    parser.add_argument('--account', default=None, required=False, action='store', help='Choose broker account (else first)')\n    parser.add_argument('--trade', required=False, action='store_true', help='Do Sample Buy/Sell operations')\n    parser.add_argument('--donotsell', required=False, action='store_true', help='Do not sell after a buy')\n    parser.add_argument('--exectype', default=bt.Order.ExecTypes[0], choices=bt.Order.ExecTypes, required=False, action='store', help='Execution to Use when opening position')\n    parser.add_argument('--price', default=None, type=float, required=False, action='store', help='Price in Limit orders or Stop Trigger Price')\n    parser.add_argument('--pstoplimit', default=None, type=float, required=False, action='store', help='Price for the limit in StopLimit')\n    parser.add_argument('--stake', default=10, type=int, required=False, action='store', help='Stake to use in buy operations')\n    parser.add_argument('--valid', default=None, required=False, action='store', help='Seconds or YYYY-MM-DD')\n    parser.add_argument('--cancel', default=0, type=int, required=False, action='store', help='Cancel a buy order after n bars in operation, to be combined with orders like Limit')\n    return parser.parse_args()",
            "def parse_args():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter, description='Test Visual Chart 6 integration')\n    parser.add_argument('--exactbars', default=1, type=int, required=False, action='store', help='exactbars level, use 0/-1/-2 to enable plotting')\n    parser.add_argument('--plot', required=False, action='store_true', help='Plot if possible')\n    parser.add_argument('--stopafter', default=0, type=int, required=False, action='store', help='Stop after x lines of LIVE data')\n    parser.add_argument('--nostore', required=False, action='store_true', help='Do not Use the store pattern')\n    parser.add_argument('--qcheck', default=0.5, type=float, required=False, action='store', help='Timeout for periodic notification/resampling/replaying check')\n    parser.add_argument('--no-timeoffset', required=False, action='store_true', help='Do not Use TWS/System time offset for non timestamped prices and to align resampling')\n    parser.add_argument('--data0', default=None, required=True, action='store', help='data 0 into the system')\n    parser.add_argument('--tradename', default=None, required=False, action='store', help='Actual Trading Name of the asset')\n    parser.add_argument('--data1', default=None, required=False, action='store', help='data 1 into the system')\n    parser.add_argument('--timezone', default=None, required=False, action='store', help='timezone to get time output into (pytz names)')\n    parser.add_argument('--historical', required=False, action='store_true', help='do only historical download')\n    parser.add_argument('--fromdate', required=False, action='store', help='Starting date for historical download with format: YYYY-MM-DD[THH:MM:SS]')\n    parser.add_argument('--todate', required=False, action='store', help='End date for historical download with format: YYYY-MM-DD[THH:MM:SS]')\n    parser.add_argument('--smaperiod', default=5, type=int, required=False, action='store', help='Period to apply to the Simple Moving Average')\n    pgroup = parser.add_mutually_exclusive_group(required=False)\n    pgroup.add_argument('--replay', required=False, action='store_true', help='replay to chosen timeframe')\n    pgroup.add_argument('--resample', required=False, action='store_true', help='resample to chosen timeframe')\n    parser.add_argument('--timeframe', default=bt.TimeFrame.Names[0], choices=bt.TimeFrame.Names, required=False, action='store', help='TimeFrame for Resample/Replay')\n    parser.add_argument('--compression', default=1, type=int, required=False, action='store', help='Compression for Resample/Replay')\n    parser.add_argument('--no-bar2edge', required=False, action='store_true', help='no bar2edge for resample/replay')\n    parser.add_argument('--no-adjbartime', required=False, action='store_true', help='no adjbartime for resample/replay')\n    parser.add_argument('--no-rightedge', required=False, action='store_true', help='no rightedge for resample/replay')\n    parser.add_argument('--broker', required=False, action='store_true', help='Use VisualChart as broker')\n    parser.add_argument('--account', default=None, required=False, action='store', help='Choose broker account (else first)')\n    parser.add_argument('--trade', required=False, action='store_true', help='Do Sample Buy/Sell operations')\n    parser.add_argument('--donotsell', required=False, action='store_true', help='Do not sell after a buy')\n    parser.add_argument('--exectype', default=bt.Order.ExecTypes[0], choices=bt.Order.ExecTypes, required=False, action='store', help='Execution to Use when opening position')\n    parser.add_argument('--price', default=None, type=float, required=False, action='store', help='Price in Limit orders or Stop Trigger Price')\n    parser.add_argument('--pstoplimit', default=None, type=float, required=False, action='store', help='Price for the limit in StopLimit')\n    parser.add_argument('--stake', default=10, type=int, required=False, action='store', help='Stake to use in buy operations')\n    parser.add_argument('--valid', default=None, required=False, action='store', help='Seconds or YYYY-MM-DD')\n    parser.add_argument('--cancel', default=0, type=int, required=False, action='store', help='Cancel a buy order after n bars in operation, to be combined with orders like Limit')\n    return parser.parse_args()",
            "def parse_args():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter, description='Test Visual Chart 6 integration')\n    parser.add_argument('--exactbars', default=1, type=int, required=False, action='store', help='exactbars level, use 0/-1/-2 to enable plotting')\n    parser.add_argument('--plot', required=False, action='store_true', help='Plot if possible')\n    parser.add_argument('--stopafter', default=0, type=int, required=False, action='store', help='Stop after x lines of LIVE data')\n    parser.add_argument('--nostore', required=False, action='store_true', help='Do not Use the store pattern')\n    parser.add_argument('--qcheck', default=0.5, type=float, required=False, action='store', help='Timeout for periodic notification/resampling/replaying check')\n    parser.add_argument('--no-timeoffset', required=False, action='store_true', help='Do not Use TWS/System time offset for non timestamped prices and to align resampling')\n    parser.add_argument('--data0', default=None, required=True, action='store', help='data 0 into the system')\n    parser.add_argument('--tradename', default=None, required=False, action='store', help='Actual Trading Name of the asset')\n    parser.add_argument('--data1', default=None, required=False, action='store', help='data 1 into the system')\n    parser.add_argument('--timezone', default=None, required=False, action='store', help='timezone to get time output into (pytz names)')\n    parser.add_argument('--historical', required=False, action='store_true', help='do only historical download')\n    parser.add_argument('--fromdate', required=False, action='store', help='Starting date for historical download with format: YYYY-MM-DD[THH:MM:SS]')\n    parser.add_argument('--todate', required=False, action='store', help='End date for historical download with format: YYYY-MM-DD[THH:MM:SS]')\n    parser.add_argument('--smaperiod', default=5, type=int, required=False, action='store', help='Period to apply to the Simple Moving Average')\n    pgroup = parser.add_mutually_exclusive_group(required=False)\n    pgroup.add_argument('--replay', required=False, action='store_true', help='replay to chosen timeframe')\n    pgroup.add_argument('--resample', required=False, action='store_true', help='resample to chosen timeframe')\n    parser.add_argument('--timeframe', default=bt.TimeFrame.Names[0], choices=bt.TimeFrame.Names, required=False, action='store', help='TimeFrame for Resample/Replay')\n    parser.add_argument('--compression', default=1, type=int, required=False, action='store', help='Compression for Resample/Replay')\n    parser.add_argument('--no-bar2edge', required=False, action='store_true', help='no bar2edge for resample/replay')\n    parser.add_argument('--no-adjbartime', required=False, action='store_true', help='no adjbartime for resample/replay')\n    parser.add_argument('--no-rightedge', required=False, action='store_true', help='no rightedge for resample/replay')\n    parser.add_argument('--broker', required=False, action='store_true', help='Use VisualChart as broker')\n    parser.add_argument('--account', default=None, required=False, action='store', help='Choose broker account (else first)')\n    parser.add_argument('--trade', required=False, action='store_true', help='Do Sample Buy/Sell operations')\n    parser.add_argument('--donotsell', required=False, action='store_true', help='Do not sell after a buy')\n    parser.add_argument('--exectype', default=bt.Order.ExecTypes[0], choices=bt.Order.ExecTypes, required=False, action='store', help='Execution to Use when opening position')\n    parser.add_argument('--price', default=None, type=float, required=False, action='store', help='Price in Limit orders or Stop Trigger Price')\n    parser.add_argument('--pstoplimit', default=None, type=float, required=False, action='store', help='Price for the limit in StopLimit')\n    parser.add_argument('--stake', default=10, type=int, required=False, action='store', help='Stake to use in buy operations')\n    parser.add_argument('--valid', default=None, required=False, action='store', help='Seconds or YYYY-MM-DD')\n    parser.add_argument('--cancel', default=0, type=int, required=False, action='store', help='Cancel a buy order after n bars in operation, to be combined with orders like Limit')\n    return parser.parse_args()",
            "def parse_args():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter, description='Test Visual Chart 6 integration')\n    parser.add_argument('--exactbars', default=1, type=int, required=False, action='store', help='exactbars level, use 0/-1/-2 to enable plotting')\n    parser.add_argument('--plot', required=False, action='store_true', help='Plot if possible')\n    parser.add_argument('--stopafter', default=0, type=int, required=False, action='store', help='Stop after x lines of LIVE data')\n    parser.add_argument('--nostore', required=False, action='store_true', help='Do not Use the store pattern')\n    parser.add_argument('--qcheck', default=0.5, type=float, required=False, action='store', help='Timeout for periodic notification/resampling/replaying check')\n    parser.add_argument('--no-timeoffset', required=False, action='store_true', help='Do not Use TWS/System time offset for non timestamped prices and to align resampling')\n    parser.add_argument('--data0', default=None, required=True, action='store', help='data 0 into the system')\n    parser.add_argument('--tradename', default=None, required=False, action='store', help='Actual Trading Name of the asset')\n    parser.add_argument('--data1', default=None, required=False, action='store', help='data 1 into the system')\n    parser.add_argument('--timezone', default=None, required=False, action='store', help='timezone to get time output into (pytz names)')\n    parser.add_argument('--historical', required=False, action='store_true', help='do only historical download')\n    parser.add_argument('--fromdate', required=False, action='store', help='Starting date for historical download with format: YYYY-MM-DD[THH:MM:SS]')\n    parser.add_argument('--todate', required=False, action='store', help='End date for historical download with format: YYYY-MM-DD[THH:MM:SS]')\n    parser.add_argument('--smaperiod', default=5, type=int, required=False, action='store', help='Period to apply to the Simple Moving Average')\n    pgroup = parser.add_mutually_exclusive_group(required=False)\n    pgroup.add_argument('--replay', required=False, action='store_true', help='replay to chosen timeframe')\n    pgroup.add_argument('--resample', required=False, action='store_true', help='resample to chosen timeframe')\n    parser.add_argument('--timeframe', default=bt.TimeFrame.Names[0], choices=bt.TimeFrame.Names, required=False, action='store', help='TimeFrame for Resample/Replay')\n    parser.add_argument('--compression', default=1, type=int, required=False, action='store', help='Compression for Resample/Replay')\n    parser.add_argument('--no-bar2edge', required=False, action='store_true', help='no bar2edge for resample/replay')\n    parser.add_argument('--no-adjbartime', required=False, action='store_true', help='no adjbartime for resample/replay')\n    parser.add_argument('--no-rightedge', required=False, action='store_true', help='no rightedge for resample/replay')\n    parser.add_argument('--broker', required=False, action='store_true', help='Use VisualChart as broker')\n    parser.add_argument('--account', default=None, required=False, action='store', help='Choose broker account (else first)')\n    parser.add_argument('--trade', required=False, action='store_true', help='Do Sample Buy/Sell operations')\n    parser.add_argument('--donotsell', required=False, action='store_true', help='Do not sell after a buy')\n    parser.add_argument('--exectype', default=bt.Order.ExecTypes[0], choices=bt.Order.ExecTypes, required=False, action='store', help='Execution to Use when opening position')\n    parser.add_argument('--price', default=None, type=float, required=False, action='store', help='Price in Limit orders or Stop Trigger Price')\n    parser.add_argument('--pstoplimit', default=None, type=float, required=False, action='store', help='Price for the limit in StopLimit')\n    parser.add_argument('--stake', default=10, type=int, required=False, action='store', help='Stake to use in buy operations')\n    parser.add_argument('--valid', default=None, required=False, action='store', help='Seconds or YYYY-MM-DD')\n    parser.add_argument('--cancel', default=0, type=int, required=False, action='store', help='Cancel a buy order after n bars in operation, to be combined with orders like Limit')\n    return parser.parse_args()",
            "def parse_args():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter, description='Test Visual Chart 6 integration')\n    parser.add_argument('--exactbars', default=1, type=int, required=False, action='store', help='exactbars level, use 0/-1/-2 to enable plotting')\n    parser.add_argument('--plot', required=False, action='store_true', help='Plot if possible')\n    parser.add_argument('--stopafter', default=0, type=int, required=False, action='store', help='Stop after x lines of LIVE data')\n    parser.add_argument('--nostore', required=False, action='store_true', help='Do not Use the store pattern')\n    parser.add_argument('--qcheck', default=0.5, type=float, required=False, action='store', help='Timeout for periodic notification/resampling/replaying check')\n    parser.add_argument('--no-timeoffset', required=False, action='store_true', help='Do not Use TWS/System time offset for non timestamped prices and to align resampling')\n    parser.add_argument('--data0', default=None, required=True, action='store', help='data 0 into the system')\n    parser.add_argument('--tradename', default=None, required=False, action='store', help='Actual Trading Name of the asset')\n    parser.add_argument('--data1', default=None, required=False, action='store', help='data 1 into the system')\n    parser.add_argument('--timezone', default=None, required=False, action='store', help='timezone to get time output into (pytz names)')\n    parser.add_argument('--historical', required=False, action='store_true', help='do only historical download')\n    parser.add_argument('--fromdate', required=False, action='store', help='Starting date for historical download with format: YYYY-MM-DD[THH:MM:SS]')\n    parser.add_argument('--todate', required=False, action='store', help='End date for historical download with format: YYYY-MM-DD[THH:MM:SS]')\n    parser.add_argument('--smaperiod', default=5, type=int, required=False, action='store', help='Period to apply to the Simple Moving Average')\n    pgroup = parser.add_mutually_exclusive_group(required=False)\n    pgroup.add_argument('--replay', required=False, action='store_true', help='replay to chosen timeframe')\n    pgroup.add_argument('--resample', required=False, action='store_true', help='resample to chosen timeframe')\n    parser.add_argument('--timeframe', default=bt.TimeFrame.Names[0], choices=bt.TimeFrame.Names, required=False, action='store', help='TimeFrame for Resample/Replay')\n    parser.add_argument('--compression', default=1, type=int, required=False, action='store', help='Compression for Resample/Replay')\n    parser.add_argument('--no-bar2edge', required=False, action='store_true', help='no bar2edge for resample/replay')\n    parser.add_argument('--no-adjbartime', required=False, action='store_true', help='no adjbartime for resample/replay')\n    parser.add_argument('--no-rightedge', required=False, action='store_true', help='no rightedge for resample/replay')\n    parser.add_argument('--broker', required=False, action='store_true', help='Use VisualChart as broker')\n    parser.add_argument('--account', default=None, required=False, action='store', help='Choose broker account (else first)')\n    parser.add_argument('--trade', required=False, action='store_true', help='Do Sample Buy/Sell operations')\n    parser.add_argument('--donotsell', required=False, action='store_true', help='Do not sell after a buy')\n    parser.add_argument('--exectype', default=bt.Order.ExecTypes[0], choices=bt.Order.ExecTypes, required=False, action='store', help='Execution to Use when opening position')\n    parser.add_argument('--price', default=None, type=float, required=False, action='store', help='Price in Limit orders or Stop Trigger Price')\n    parser.add_argument('--pstoplimit', default=None, type=float, required=False, action='store', help='Price for the limit in StopLimit')\n    parser.add_argument('--stake', default=10, type=int, required=False, action='store', help='Stake to use in buy operations')\n    parser.add_argument('--valid', default=None, required=False, action='store', help='Seconds or YYYY-MM-DD')\n    parser.add_argument('--cancel', default=0, type=int, required=False, action='store', help='Cancel a buy order after n bars in operation, to be combined with orders like Limit')\n    return parser.parse_args()"
        ]
    }
]