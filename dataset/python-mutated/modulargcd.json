[
    {
        "func_name": "_trivial_gcd",
        "original": "def _trivial_gcd(f, g):\n    \"\"\"\n    Compute the GCD of two polynomials in trivial cases, i.e. when one\n    or both polynomials are zero.\n    \"\"\"\n    ring = f.ring\n    if not (f or g):\n        return (ring.zero, ring.zero, ring.zero)\n    elif not f:\n        if g.LC < ring.domain.zero:\n            return (-g, ring.zero, -ring.one)\n        else:\n            return (g, ring.zero, ring.one)\n    elif not g:\n        if f.LC < ring.domain.zero:\n            return (-f, -ring.one, ring.zero)\n        else:\n            return (f, ring.one, ring.zero)\n    return None",
        "mutated": [
            "def _trivial_gcd(f, g):\n    if False:\n        i = 10\n    '\\n    Compute the GCD of two polynomials in trivial cases, i.e. when one\\n    or both polynomials are zero.\\n    '\n    ring = f.ring\n    if not (f or g):\n        return (ring.zero, ring.zero, ring.zero)\n    elif not f:\n        if g.LC < ring.domain.zero:\n            return (-g, ring.zero, -ring.one)\n        else:\n            return (g, ring.zero, ring.one)\n    elif not g:\n        if f.LC < ring.domain.zero:\n            return (-f, -ring.one, ring.zero)\n        else:\n            return (f, ring.one, ring.zero)\n    return None",
            "def _trivial_gcd(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the GCD of two polynomials in trivial cases, i.e. when one\\n    or both polynomials are zero.\\n    '\n    ring = f.ring\n    if not (f or g):\n        return (ring.zero, ring.zero, ring.zero)\n    elif not f:\n        if g.LC < ring.domain.zero:\n            return (-g, ring.zero, -ring.one)\n        else:\n            return (g, ring.zero, ring.one)\n    elif not g:\n        if f.LC < ring.domain.zero:\n            return (-f, -ring.one, ring.zero)\n        else:\n            return (f, ring.one, ring.zero)\n    return None",
            "def _trivial_gcd(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the GCD of two polynomials in trivial cases, i.e. when one\\n    or both polynomials are zero.\\n    '\n    ring = f.ring\n    if not (f or g):\n        return (ring.zero, ring.zero, ring.zero)\n    elif not f:\n        if g.LC < ring.domain.zero:\n            return (-g, ring.zero, -ring.one)\n        else:\n            return (g, ring.zero, ring.one)\n    elif not g:\n        if f.LC < ring.domain.zero:\n            return (-f, -ring.one, ring.zero)\n        else:\n            return (f, ring.one, ring.zero)\n    return None",
            "def _trivial_gcd(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the GCD of two polynomials in trivial cases, i.e. when one\\n    or both polynomials are zero.\\n    '\n    ring = f.ring\n    if not (f or g):\n        return (ring.zero, ring.zero, ring.zero)\n    elif not f:\n        if g.LC < ring.domain.zero:\n            return (-g, ring.zero, -ring.one)\n        else:\n            return (g, ring.zero, ring.one)\n    elif not g:\n        if f.LC < ring.domain.zero:\n            return (-f, -ring.one, ring.zero)\n        else:\n            return (f, ring.one, ring.zero)\n    return None",
            "def _trivial_gcd(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the GCD of two polynomials in trivial cases, i.e. when one\\n    or both polynomials are zero.\\n    '\n    ring = f.ring\n    if not (f or g):\n        return (ring.zero, ring.zero, ring.zero)\n    elif not f:\n        if g.LC < ring.domain.zero:\n            return (-g, ring.zero, -ring.one)\n        else:\n            return (g, ring.zero, ring.one)\n    elif not g:\n        if f.LC < ring.domain.zero:\n            return (-f, -ring.one, ring.zero)\n        else:\n            return (f, ring.one, ring.zero)\n    return None"
        ]
    },
    {
        "func_name": "_gf_gcd",
        "original": "def _gf_gcd(fp, gp, p):\n    \"\"\"\n    Compute the GCD of two univariate polynomials in `\\\\mathbb{Z}_p[x]`.\n    \"\"\"\n    dom = fp.ring.domain\n    while gp:\n        rem = fp\n        deg = gp.degree()\n        lcinv = dom.invert(gp.LC, p)\n        while True:\n            degrem = rem.degree()\n            if degrem < deg:\n                break\n            rem = (rem - gp.mul_monom((degrem - deg,)).mul_ground(lcinv * rem.LC)).trunc_ground(p)\n        fp = gp\n        gp = rem\n    return fp.mul_ground(dom.invert(fp.LC, p)).trunc_ground(p)",
        "mutated": [
            "def _gf_gcd(fp, gp, p):\n    if False:\n        i = 10\n    '\\n    Compute the GCD of two univariate polynomials in `\\\\mathbb{Z}_p[x]`.\\n    '\n    dom = fp.ring.domain\n    while gp:\n        rem = fp\n        deg = gp.degree()\n        lcinv = dom.invert(gp.LC, p)\n        while True:\n            degrem = rem.degree()\n            if degrem < deg:\n                break\n            rem = (rem - gp.mul_monom((degrem - deg,)).mul_ground(lcinv * rem.LC)).trunc_ground(p)\n        fp = gp\n        gp = rem\n    return fp.mul_ground(dom.invert(fp.LC, p)).trunc_ground(p)",
            "def _gf_gcd(fp, gp, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the GCD of two univariate polynomials in `\\\\mathbb{Z}_p[x]`.\\n    '\n    dom = fp.ring.domain\n    while gp:\n        rem = fp\n        deg = gp.degree()\n        lcinv = dom.invert(gp.LC, p)\n        while True:\n            degrem = rem.degree()\n            if degrem < deg:\n                break\n            rem = (rem - gp.mul_monom((degrem - deg,)).mul_ground(lcinv * rem.LC)).trunc_ground(p)\n        fp = gp\n        gp = rem\n    return fp.mul_ground(dom.invert(fp.LC, p)).trunc_ground(p)",
            "def _gf_gcd(fp, gp, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the GCD of two univariate polynomials in `\\\\mathbb{Z}_p[x]`.\\n    '\n    dom = fp.ring.domain\n    while gp:\n        rem = fp\n        deg = gp.degree()\n        lcinv = dom.invert(gp.LC, p)\n        while True:\n            degrem = rem.degree()\n            if degrem < deg:\n                break\n            rem = (rem - gp.mul_monom((degrem - deg,)).mul_ground(lcinv * rem.LC)).trunc_ground(p)\n        fp = gp\n        gp = rem\n    return fp.mul_ground(dom.invert(fp.LC, p)).trunc_ground(p)",
            "def _gf_gcd(fp, gp, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the GCD of two univariate polynomials in `\\\\mathbb{Z}_p[x]`.\\n    '\n    dom = fp.ring.domain\n    while gp:\n        rem = fp\n        deg = gp.degree()\n        lcinv = dom.invert(gp.LC, p)\n        while True:\n            degrem = rem.degree()\n            if degrem < deg:\n                break\n            rem = (rem - gp.mul_monom((degrem - deg,)).mul_ground(lcinv * rem.LC)).trunc_ground(p)\n        fp = gp\n        gp = rem\n    return fp.mul_ground(dom.invert(fp.LC, p)).trunc_ground(p)",
            "def _gf_gcd(fp, gp, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the GCD of two univariate polynomials in `\\\\mathbb{Z}_p[x]`.\\n    '\n    dom = fp.ring.domain\n    while gp:\n        rem = fp\n        deg = gp.degree()\n        lcinv = dom.invert(gp.LC, p)\n        while True:\n            degrem = rem.degree()\n            if degrem < deg:\n                break\n            rem = (rem - gp.mul_monom((degrem - deg,)).mul_ground(lcinv * rem.LC)).trunc_ground(p)\n        fp = gp\n        gp = rem\n    return fp.mul_ground(dom.invert(fp.LC, p)).trunc_ground(p)"
        ]
    },
    {
        "func_name": "_degree_bound_univariate",
        "original": "def _degree_bound_univariate(f, g):\n    \"\"\"\n    Compute an upper bound for the degree of the GCD of two univariate\n    integer polynomials `f` and `g`.\n\n    The function chooses a suitable prime `p` and computes the GCD of\n    `f` and `g` in `\\\\mathbb{Z}_p[x]`. The choice of `p` guarantees that\n    the degree in `\\\\mathbb{Z}_p[x]` is greater than or equal to the degree\n    in `\\\\mathbb{Z}[x]`.\n\n    Parameters\n    ==========\n\n    f : PolyElement\n        univariate integer polynomial\n    g : PolyElement\n        univariate integer polynomial\n\n    \"\"\"\n    gamma = f.ring.domain.gcd(f.LC, g.LC)\n    p = 1\n    p = nextprime(p)\n    while gamma % p == 0:\n        p = nextprime(p)\n    fp = f.trunc_ground(p)\n    gp = g.trunc_ground(p)\n    hp = _gf_gcd(fp, gp, p)\n    deghp = hp.degree()\n    return deghp",
        "mutated": [
            "def _degree_bound_univariate(f, g):\n    if False:\n        i = 10\n    '\\n    Compute an upper bound for the degree of the GCD of two univariate\\n    integer polynomials `f` and `g`.\\n\\n    The function chooses a suitable prime `p` and computes the GCD of\\n    `f` and `g` in `\\\\mathbb{Z}_p[x]`. The choice of `p` guarantees that\\n    the degree in `\\\\mathbb{Z}_p[x]` is greater than or equal to the degree\\n    in `\\\\mathbb{Z}[x]`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        univariate integer polynomial\\n    g : PolyElement\\n        univariate integer polynomial\\n\\n    '\n    gamma = f.ring.domain.gcd(f.LC, g.LC)\n    p = 1\n    p = nextprime(p)\n    while gamma % p == 0:\n        p = nextprime(p)\n    fp = f.trunc_ground(p)\n    gp = g.trunc_ground(p)\n    hp = _gf_gcd(fp, gp, p)\n    deghp = hp.degree()\n    return deghp",
            "def _degree_bound_univariate(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute an upper bound for the degree of the GCD of two univariate\\n    integer polynomials `f` and `g`.\\n\\n    The function chooses a suitable prime `p` and computes the GCD of\\n    `f` and `g` in `\\\\mathbb{Z}_p[x]`. The choice of `p` guarantees that\\n    the degree in `\\\\mathbb{Z}_p[x]` is greater than or equal to the degree\\n    in `\\\\mathbb{Z}[x]`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        univariate integer polynomial\\n    g : PolyElement\\n        univariate integer polynomial\\n\\n    '\n    gamma = f.ring.domain.gcd(f.LC, g.LC)\n    p = 1\n    p = nextprime(p)\n    while gamma % p == 0:\n        p = nextprime(p)\n    fp = f.trunc_ground(p)\n    gp = g.trunc_ground(p)\n    hp = _gf_gcd(fp, gp, p)\n    deghp = hp.degree()\n    return deghp",
            "def _degree_bound_univariate(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute an upper bound for the degree of the GCD of two univariate\\n    integer polynomials `f` and `g`.\\n\\n    The function chooses a suitable prime `p` and computes the GCD of\\n    `f` and `g` in `\\\\mathbb{Z}_p[x]`. The choice of `p` guarantees that\\n    the degree in `\\\\mathbb{Z}_p[x]` is greater than or equal to the degree\\n    in `\\\\mathbb{Z}[x]`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        univariate integer polynomial\\n    g : PolyElement\\n        univariate integer polynomial\\n\\n    '\n    gamma = f.ring.domain.gcd(f.LC, g.LC)\n    p = 1\n    p = nextprime(p)\n    while gamma % p == 0:\n        p = nextprime(p)\n    fp = f.trunc_ground(p)\n    gp = g.trunc_ground(p)\n    hp = _gf_gcd(fp, gp, p)\n    deghp = hp.degree()\n    return deghp",
            "def _degree_bound_univariate(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute an upper bound for the degree of the GCD of two univariate\\n    integer polynomials `f` and `g`.\\n\\n    The function chooses a suitable prime `p` and computes the GCD of\\n    `f` and `g` in `\\\\mathbb{Z}_p[x]`. The choice of `p` guarantees that\\n    the degree in `\\\\mathbb{Z}_p[x]` is greater than or equal to the degree\\n    in `\\\\mathbb{Z}[x]`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        univariate integer polynomial\\n    g : PolyElement\\n        univariate integer polynomial\\n\\n    '\n    gamma = f.ring.domain.gcd(f.LC, g.LC)\n    p = 1\n    p = nextprime(p)\n    while gamma % p == 0:\n        p = nextprime(p)\n    fp = f.trunc_ground(p)\n    gp = g.trunc_ground(p)\n    hp = _gf_gcd(fp, gp, p)\n    deghp = hp.degree()\n    return deghp",
            "def _degree_bound_univariate(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute an upper bound for the degree of the GCD of two univariate\\n    integer polynomials `f` and `g`.\\n\\n    The function chooses a suitable prime `p` and computes the GCD of\\n    `f` and `g` in `\\\\mathbb{Z}_p[x]`. The choice of `p` guarantees that\\n    the degree in `\\\\mathbb{Z}_p[x]` is greater than or equal to the degree\\n    in `\\\\mathbb{Z}[x]`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        univariate integer polynomial\\n    g : PolyElement\\n        univariate integer polynomial\\n\\n    '\n    gamma = f.ring.domain.gcd(f.LC, g.LC)\n    p = 1\n    p = nextprime(p)\n    while gamma % p == 0:\n        p = nextprime(p)\n    fp = f.trunc_ground(p)\n    gp = g.trunc_ground(p)\n    hp = _gf_gcd(fp, gp, p)\n    deghp = hp.degree()\n    return deghp"
        ]
    },
    {
        "func_name": "_chinese_remainder_reconstruction_univariate",
        "original": "def _chinese_remainder_reconstruction_univariate(hp, hq, p, q):\n    \"\"\"\n    Construct a polynomial `h_{pq}` in `\\\\mathbb{Z}_{p q}[x]` such that\n\n    .. math ::\n\n        h_{pq} = h_p \\\\; \\\\mathrm{mod} \\\\, p\n\n        h_{pq} = h_q \\\\; \\\\mathrm{mod} \\\\, q\n\n    for relatively prime integers `p` and `q` and polynomials\n    `h_p` and `h_q` in `\\\\mathbb{Z}_p[x]` and `\\\\mathbb{Z}_q[x]`\n    respectively.\n\n    The coefficients of the polynomial `h_{pq}` are computed with the\n    Chinese Remainder Theorem. The symmetric representation in\n    `\\\\mathbb{Z}_p[x]`, `\\\\mathbb{Z}_q[x]` and `\\\\mathbb{Z}_{p q}[x]` is used.\n    It is assumed that `h_p` and `h_q` have the same degree.\n\n    Parameters\n    ==========\n\n    hp : PolyElement\n        univariate integer polynomial with coefficients in `\\\\mathbb{Z}_p`\n    hq : PolyElement\n        univariate integer polynomial with coefficients in `\\\\mathbb{Z}_q`\n    p : Integer\n        modulus of `h_p`, relatively prime to `q`\n    q : Integer\n        modulus of `h_q`, relatively prime to `p`\n\n    Examples\n    ========\n\n    >>> from sympy.polys.modulargcd import _chinese_remainder_reconstruction_univariate\n    >>> from sympy.polys import ring, ZZ\n\n    >>> R, x = ring(\"x\", ZZ)\n    >>> p = 3\n    >>> q = 5\n\n    >>> hp = -x**3 - 1\n    >>> hq = 2*x**3 - 2*x**2 + x\n\n    >>> hpq = _chinese_remainder_reconstruction_univariate(hp, hq, p, q)\n    >>> hpq\n    2*x**3 + 3*x**2 + 6*x + 5\n\n    >>> hpq.trunc_ground(p) == hp\n    True\n    >>> hpq.trunc_ground(q) == hq\n    True\n\n    \"\"\"\n    n = hp.degree()\n    x = hp.ring.gens[0]\n    hpq = hp.ring.zero\n    for i in range(n + 1):\n        hpq[i,] = crt([p, q], [hp.coeff(x ** i), hq.coeff(x ** i)], symmetric=True)[0]\n    hpq.strip_zero()\n    return hpq",
        "mutated": [
            "def _chinese_remainder_reconstruction_univariate(hp, hq, p, q):\n    if False:\n        i = 10\n    '\\n    Construct a polynomial `h_{pq}` in `\\\\mathbb{Z}_{p q}[x]` such that\\n\\n    .. math ::\\n\\n        h_{pq} = h_p \\\\; \\\\mathrm{mod} \\\\, p\\n\\n        h_{pq} = h_q \\\\; \\\\mathrm{mod} \\\\, q\\n\\n    for relatively prime integers `p` and `q` and polynomials\\n    `h_p` and `h_q` in `\\\\mathbb{Z}_p[x]` and `\\\\mathbb{Z}_q[x]`\\n    respectively.\\n\\n    The coefficients of the polynomial `h_{pq}` are computed with the\\n    Chinese Remainder Theorem. The symmetric representation in\\n    `\\\\mathbb{Z}_p[x]`, `\\\\mathbb{Z}_q[x]` and `\\\\mathbb{Z}_{p q}[x]` is used.\\n    It is assumed that `h_p` and `h_q` have the same degree.\\n\\n    Parameters\\n    ==========\\n\\n    hp : PolyElement\\n        univariate integer polynomial with coefficients in `\\\\mathbb{Z}_p`\\n    hq : PolyElement\\n        univariate integer polynomial with coefficients in `\\\\mathbb{Z}_q`\\n    p : Integer\\n        modulus of `h_p`, relatively prime to `q`\\n    q : Integer\\n        modulus of `h_q`, relatively prime to `p`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _chinese_remainder_reconstruction_univariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x = ring(\"x\", ZZ)\\n    >>> p = 3\\n    >>> q = 5\\n\\n    >>> hp = -x**3 - 1\\n    >>> hq = 2*x**3 - 2*x**2 + x\\n\\n    >>> hpq = _chinese_remainder_reconstruction_univariate(hp, hq, p, q)\\n    >>> hpq\\n    2*x**3 + 3*x**2 + 6*x + 5\\n\\n    >>> hpq.trunc_ground(p) == hp\\n    True\\n    >>> hpq.trunc_ground(q) == hq\\n    True\\n\\n    '\n    n = hp.degree()\n    x = hp.ring.gens[0]\n    hpq = hp.ring.zero\n    for i in range(n + 1):\n        hpq[i,] = crt([p, q], [hp.coeff(x ** i), hq.coeff(x ** i)], symmetric=True)[0]\n    hpq.strip_zero()\n    return hpq",
            "def _chinese_remainder_reconstruction_univariate(hp, hq, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Construct a polynomial `h_{pq}` in `\\\\mathbb{Z}_{p q}[x]` such that\\n\\n    .. math ::\\n\\n        h_{pq} = h_p \\\\; \\\\mathrm{mod} \\\\, p\\n\\n        h_{pq} = h_q \\\\; \\\\mathrm{mod} \\\\, q\\n\\n    for relatively prime integers `p` and `q` and polynomials\\n    `h_p` and `h_q` in `\\\\mathbb{Z}_p[x]` and `\\\\mathbb{Z}_q[x]`\\n    respectively.\\n\\n    The coefficients of the polynomial `h_{pq}` are computed with the\\n    Chinese Remainder Theorem. The symmetric representation in\\n    `\\\\mathbb{Z}_p[x]`, `\\\\mathbb{Z}_q[x]` and `\\\\mathbb{Z}_{p q}[x]` is used.\\n    It is assumed that `h_p` and `h_q` have the same degree.\\n\\n    Parameters\\n    ==========\\n\\n    hp : PolyElement\\n        univariate integer polynomial with coefficients in `\\\\mathbb{Z}_p`\\n    hq : PolyElement\\n        univariate integer polynomial with coefficients in `\\\\mathbb{Z}_q`\\n    p : Integer\\n        modulus of `h_p`, relatively prime to `q`\\n    q : Integer\\n        modulus of `h_q`, relatively prime to `p`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _chinese_remainder_reconstruction_univariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x = ring(\"x\", ZZ)\\n    >>> p = 3\\n    >>> q = 5\\n\\n    >>> hp = -x**3 - 1\\n    >>> hq = 2*x**3 - 2*x**2 + x\\n\\n    >>> hpq = _chinese_remainder_reconstruction_univariate(hp, hq, p, q)\\n    >>> hpq\\n    2*x**3 + 3*x**2 + 6*x + 5\\n\\n    >>> hpq.trunc_ground(p) == hp\\n    True\\n    >>> hpq.trunc_ground(q) == hq\\n    True\\n\\n    '\n    n = hp.degree()\n    x = hp.ring.gens[0]\n    hpq = hp.ring.zero\n    for i in range(n + 1):\n        hpq[i,] = crt([p, q], [hp.coeff(x ** i), hq.coeff(x ** i)], symmetric=True)[0]\n    hpq.strip_zero()\n    return hpq",
            "def _chinese_remainder_reconstruction_univariate(hp, hq, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Construct a polynomial `h_{pq}` in `\\\\mathbb{Z}_{p q}[x]` such that\\n\\n    .. math ::\\n\\n        h_{pq} = h_p \\\\; \\\\mathrm{mod} \\\\, p\\n\\n        h_{pq} = h_q \\\\; \\\\mathrm{mod} \\\\, q\\n\\n    for relatively prime integers `p` and `q` and polynomials\\n    `h_p` and `h_q` in `\\\\mathbb{Z}_p[x]` and `\\\\mathbb{Z}_q[x]`\\n    respectively.\\n\\n    The coefficients of the polynomial `h_{pq}` are computed with the\\n    Chinese Remainder Theorem. The symmetric representation in\\n    `\\\\mathbb{Z}_p[x]`, `\\\\mathbb{Z}_q[x]` and `\\\\mathbb{Z}_{p q}[x]` is used.\\n    It is assumed that `h_p` and `h_q` have the same degree.\\n\\n    Parameters\\n    ==========\\n\\n    hp : PolyElement\\n        univariate integer polynomial with coefficients in `\\\\mathbb{Z}_p`\\n    hq : PolyElement\\n        univariate integer polynomial with coefficients in `\\\\mathbb{Z}_q`\\n    p : Integer\\n        modulus of `h_p`, relatively prime to `q`\\n    q : Integer\\n        modulus of `h_q`, relatively prime to `p`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _chinese_remainder_reconstruction_univariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x = ring(\"x\", ZZ)\\n    >>> p = 3\\n    >>> q = 5\\n\\n    >>> hp = -x**3 - 1\\n    >>> hq = 2*x**3 - 2*x**2 + x\\n\\n    >>> hpq = _chinese_remainder_reconstruction_univariate(hp, hq, p, q)\\n    >>> hpq\\n    2*x**3 + 3*x**2 + 6*x + 5\\n\\n    >>> hpq.trunc_ground(p) == hp\\n    True\\n    >>> hpq.trunc_ground(q) == hq\\n    True\\n\\n    '\n    n = hp.degree()\n    x = hp.ring.gens[0]\n    hpq = hp.ring.zero\n    for i in range(n + 1):\n        hpq[i,] = crt([p, q], [hp.coeff(x ** i), hq.coeff(x ** i)], symmetric=True)[0]\n    hpq.strip_zero()\n    return hpq",
            "def _chinese_remainder_reconstruction_univariate(hp, hq, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Construct a polynomial `h_{pq}` in `\\\\mathbb{Z}_{p q}[x]` such that\\n\\n    .. math ::\\n\\n        h_{pq} = h_p \\\\; \\\\mathrm{mod} \\\\, p\\n\\n        h_{pq} = h_q \\\\; \\\\mathrm{mod} \\\\, q\\n\\n    for relatively prime integers `p` and `q` and polynomials\\n    `h_p` and `h_q` in `\\\\mathbb{Z}_p[x]` and `\\\\mathbb{Z}_q[x]`\\n    respectively.\\n\\n    The coefficients of the polynomial `h_{pq}` are computed with the\\n    Chinese Remainder Theorem. The symmetric representation in\\n    `\\\\mathbb{Z}_p[x]`, `\\\\mathbb{Z}_q[x]` and `\\\\mathbb{Z}_{p q}[x]` is used.\\n    It is assumed that `h_p` and `h_q` have the same degree.\\n\\n    Parameters\\n    ==========\\n\\n    hp : PolyElement\\n        univariate integer polynomial with coefficients in `\\\\mathbb{Z}_p`\\n    hq : PolyElement\\n        univariate integer polynomial with coefficients in `\\\\mathbb{Z}_q`\\n    p : Integer\\n        modulus of `h_p`, relatively prime to `q`\\n    q : Integer\\n        modulus of `h_q`, relatively prime to `p`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _chinese_remainder_reconstruction_univariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x = ring(\"x\", ZZ)\\n    >>> p = 3\\n    >>> q = 5\\n\\n    >>> hp = -x**3 - 1\\n    >>> hq = 2*x**3 - 2*x**2 + x\\n\\n    >>> hpq = _chinese_remainder_reconstruction_univariate(hp, hq, p, q)\\n    >>> hpq\\n    2*x**3 + 3*x**2 + 6*x + 5\\n\\n    >>> hpq.trunc_ground(p) == hp\\n    True\\n    >>> hpq.trunc_ground(q) == hq\\n    True\\n\\n    '\n    n = hp.degree()\n    x = hp.ring.gens[0]\n    hpq = hp.ring.zero\n    for i in range(n + 1):\n        hpq[i,] = crt([p, q], [hp.coeff(x ** i), hq.coeff(x ** i)], symmetric=True)[0]\n    hpq.strip_zero()\n    return hpq",
            "def _chinese_remainder_reconstruction_univariate(hp, hq, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Construct a polynomial `h_{pq}` in `\\\\mathbb{Z}_{p q}[x]` such that\\n\\n    .. math ::\\n\\n        h_{pq} = h_p \\\\; \\\\mathrm{mod} \\\\, p\\n\\n        h_{pq} = h_q \\\\; \\\\mathrm{mod} \\\\, q\\n\\n    for relatively prime integers `p` and `q` and polynomials\\n    `h_p` and `h_q` in `\\\\mathbb{Z}_p[x]` and `\\\\mathbb{Z}_q[x]`\\n    respectively.\\n\\n    The coefficients of the polynomial `h_{pq}` are computed with the\\n    Chinese Remainder Theorem. The symmetric representation in\\n    `\\\\mathbb{Z}_p[x]`, `\\\\mathbb{Z}_q[x]` and `\\\\mathbb{Z}_{p q}[x]` is used.\\n    It is assumed that `h_p` and `h_q` have the same degree.\\n\\n    Parameters\\n    ==========\\n\\n    hp : PolyElement\\n        univariate integer polynomial with coefficients in `\\\\mathbb{Z}_p`\\n    hq : PolyElement\\n        univariate integer polynomial with coefficients in `\\\\mathbb{Z}_q`\\n    p : Integer\\n        modulus of `h_p`, relatively prime to `q`\\n    q : Integer\\n        modulus of `h_q`, relatively prime to `p`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _chinese_remainder_reconstruction_univariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x = ring(\"x\", ZZ)\\n    >>> p = 3\\n    >>> q = 5\\n\\n    >>> hp = -x**3 - 1\\n    >>> hq = 2*x**3 - 2*x**2 + x\\n\\n    >>> hpq = _chinese_remainder_reconstruction_univariate(hp, hq, p, q)\\n    >>> hpq\\n    2*x**3 + 3*x**2 + 6*x + 5\\n\\n    >>> hpq.trunc_ground(p) == hp\\n    True\\n    >>> hpq.trunc_ground(q) == hq\\n    True\\n\\n    '\n    n = hp.degree()\n    x = hp.ring.gens[0]\n    hpq = hp.ring.zero\n    for i in range(n + 1):\n        hpq[i,] = crt([p, q], [hp.coeff(x ** i), hq.coeff(x ** i)], symmetric=True)[0]\n    hpq.strip_zero()\n    return hpq"
        ]
    },
    {
        "func_name": "modgcd_univariate",
        "original": "def modgcd_univariate(f, g):\n    \"\"\"\n    Computes the GCD of two polynomials in `\\\\mathbb{Z}[x]` using a modular\n    algorithm.\n\n    The algorithm computes the GCD of two univariate integer polynomials\n    `f` and `g` by computing the GCD in `\\\\mathbb{Z}_p[x]` for suitable\n    primes `p` and then reconstructing the coefficients with the Chinese\n    Remainder Theorem. Trial division is only made for candidates which\n    are very likely the desired GCD.\n\n    Parameters\n    ==========\n\n    f : PolyElement\n        univariate integer polynomial\n    g : PolyElement\n        univariate integer polynomial\n\n    Returns\n    =======\n\n    h : PolyElement\n        GCD of the polynomials `f` and `g`\n    cff : PolyElement\n        cofactor of `f`, i.e. `\\\\frac{f}{h}`\n    cfg : PolyElement\n        cofactor of `g`, i.e. `\\\\frac{g}{h}`\n\n    Examples\n    ========\n\n    >>> from sympy.polys.modulargcd import modgcd_univariate\n    >>> from sympy.polys import ring, ZZ\n\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> f = x**5 - 1\n    >>> g = x - 1\n\n    >>> h, cff, cfg = modgcd_univariate(f, g)\n    >>> h, cff, cfg\n    (x - 1, x**4 + x**3 + x**2 + x + 1, 1)\n\n    >>> cff * h == f\n    True\n    >>> cfg * h == g\n    True\n\n    >>> f = 6*x**2 - 6\n    >>> g = 2*x**2 + 4*x + 2\n\n    >>> h, cff, cfg = modgcd_univariate(f, g)\n    >>> h, cff, cfg\n    (2*x + 2, 3*x - 3, x + 1)\n\n    >>> cff * h == f\n    True\n    >>> cfg * h == g\n    True\n\n    References\n    ==========\n\n    1. [Monagan00]_\n\n    \"\"\"\n    assert f.ring == g.ring and f.ring.domain.is_ZZ\n    result = _trivial_gcd(f, g)\n    if result is not None:\n        return result\n    ring = f.ring\n    (cf, f) = f.primitive()\n    (cg, g) = g.primitive()\n    ch = ring.domain.gcd(cf, cg)\n    bound = _degree_bound_univariate(f, g)\n    if bound == 0:\n        return (ring(ch), f.mul_ground(cf // ch), g.mul_ground(cg // ch))\n    gamma = ring.domain.gcd(f.LC, g.LC)\n    m = 1\n    p = 1\n    while True:\n        p = nextprime(p)\n        while gamma % p == 0:\n            p = nextprime(p)\n        fp = f.trunc_ground(p)\n        gp = g.trunc_ground(p)\n        hp = _gf_gcd(fp, gp, p)\n        deghp = hp.degree()\n        if deghp > bound:\n            continue\n        elif deghp < bound:\n            m = 1\n            bound = deghp\n            continue\n        hp = hp.mul_ground(gamma).trunc_ground(p)\n        if m == 1:\n            m = p\n            hlastm = hp\n            continue\n        hm = _chinese_remainder_reconstruction_univariate(hp, hlastm, p, m)\n        m *= p\n        if not hm == hlastm:\n            hlastm = hm\n            continue\n        h = hm.quo_ground(hm.content())\n        (fquo, frem) = f.div(h)\n        (gquo, grem) = g.div(h)\n        if not frem and (not grem):\n            if h.LC < 0:\n                ch = -ch\n            h = h.mul_ground(ch)\n            cff = fquo.mul_ground(cf // ch)\n            cfg = gquo.mul_ground(cg // ch)\n            return (h, cff, cfg)",
        "mutated": [
            "def modgcd_univariate(f, g):\n    if False:\n        i = 10\n    '\\n    Computes the GCD of two polynomials in `\\\\mathbb{Z}[x]` using a modular\\n    algorithm.\\n\\n    The algorithm computes the GCD of two univariate integer polynomials\\n    `f` and `g` by computing the GCD in `\\\\mathbb{Z}_p[x]` for suitable\\n    primes `p` and then reconstructing the coefficients with the Chinese\\n    Remainder Theorem. Trial division is only made for candidates which\\n    are very likely the desired GCD.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        univariate integer polynomial\\n    g : PolyElement\\n        univariate integer polynomial\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of the polynomials `f` and `g`\\n    cff : PolyElement\\n        cofactor of `f`, i.e. `\\\\frac{f}{h}`\\n    cfg : PolyElement\\n        cofactor of `g`, i.e. `\\\\frac{g}{h}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import modgcd_univariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x = ring(\"x\", ZZ)\\n\\n    >>> f = x**5 - 1\\n    >>> g = x - 1\\n\\n    >>> h, cff, cfg = modgcd_univariate(f, g)\\n    >>> h, cff, cfg\\n    (x - 1, x**4 + x**3 + x**2 + x + 1, 1)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> f = 6*x**2 - 6\\n    >>> g = 2*x**2 + 4*x + 2\\n\\n    >>> h, cff, cfg = modgcd_univariate(f, g)\\n    >>> h, cff, cfg\\n    (2*x + 2, 3*x - 3, x + 1)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n\\n    '\n    assert f.ring == g.ring and f.ring.domain.is_ZZ\n    result = _trivial_gcd(f, g)\n    if result is not None:\n        return result\n    ring = f.ring\n    (cf, f) = f.primitive()\n    (cg, g) = g.primitive()\n    ch = ring.domain.gcd(cf, cg)\n    bound = _degree_bound_univariate(f, g)\n    if bound == 0:\n        return (ring(ch), f.mul_ground(cf // ch), g.mul_ground(cg // ch))\n    gamma = ring.domain.gcd(f.LC, g.LC)\n    m = 1\n    p = 1\n    while True:\n        p = nextprime(p)\n        while gamma % p == 0:\n            p = nextprime(p)\n        fp = f.trunc_ground(p)\n        gp = g.trunc_ground(p)\n        hp = _gf_gcd(fp, gp, p)\n        deghp = hp.degree()\n        if deghp > bound:\n            continue\n        elif deghp < bound:\n            m = 1\n            bound = deghp\n            continue\n        hp = hp.mul_ground(gamma).trunc_ground(p)\n        if m == 1:\n            m = p\n            hlastm = hp\n            continue\n        hm = _chinese_remainder_reconstruction_univariate(hp, hlastm, p, m)\n        m *= p\n        if not hm == hlastm:\n            hlastm = hm\n            continue\n        h = hm.quo_ground(hm.content())\n        (fquo, frem) = f.div(h)\n        (gquo, grem) = g.div(h)\n        if not frem and (not grem):\n            if h.LC < 0:\n                ch = -ch\n            h = h.mul_ground(ch)\n            cff = fquo.mul_ground(cf // ch)\n            cfg = gquo.mul_ground(cg // ch)\n            return (h, cff, cfg)",
            "def modgcd_univariate(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Computes the GCD of two polynomials in `\\\\mathbb{Z}[x]` using a modular\\n    algorithm.\\n\\n    The algorithm computes the GCD of two univariate integer polynomials\\n    `f` and `g` by computing the GCD in `\\\\mathbb{Z}_p[x]` for suitable\\n    primes `p` and then reconstructing the coefficients with the Chinese\\n    Remainder Theorem. Trial division is only made for candidates which\\n    are very likely the desired GCD.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        univariate integer polynomial\\n    g : PolyElement\\n        univariate integer polynomial\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of the polynomials `f` and `g`\\n    cff : PolyElement\\n        cofactor of `f`, i.e. `\\\\frac{f}{h}`\\n    cfg : PolyElement\\n        cofactor of `g`, i.e. `\\\\frac{g}{h}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import modgcd_univariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x = ring(\"x\", ZZ)\\n\\n    >>> f = x**5 - 1\\n    >>> g = x - 1\\n\\n    >>> h, cff, cfg = modgcd_univariate(f, g)\\n    >>> h, cff, cfg\\n    (x - 1, x**4 + x**3 + x**2 + x + 1, 1)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> f = 6*x**2 - 6\\n    >>> g = 2*x**2 + 4*x + 2\\n\\n    >>> h, cff, cfg = modgcd_univariate(f, g)\\n    >>> h, cff, cfg\\n    (2*x + 2, 3*x - 3, x + 1)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n\\n    '\n    assert f.ring == g.ring and f.ring.domain.is_ZZ\n    result = _trivial_gcd(f, g)\n    if result is not None:\n        return result\n    ring = f.ring\n    (cf, f) = f.primitive()\n    (cg, g) = g.primitive()\n    ch = ring.domain.gcd(cf, cg)\n    bound = _degree_bound_univariate(f, g)\n    if bound == 0:\n        return (ring(ch), f.mul_ground(cf // ch), g.mul_ground(cg // ch))\n    gamma = ring.domain.gcd(f.LC, g.LC)\n    m = 1\n    p = 1\n    while True:\n        p = nextprime(p)\n        while gamma % p == 0:\n            p = nextprime(p)\n        fp = f.trunc_ground(p)\n        gp = g.trunc_ground(p)\n        hp = _gf_gcd(fp, gp, p)\n        deghp = hp.degree()\n        if deghp > bound:\n            continue\n        elif deghp < bound:\n            m = 1\n            bound = deghp\n            continue\n        hp = hp.mul_ground(gamma).trunc_ground(p)\n        if m == 1:\n            m = p\n            hlastm = hp\n            continue\n        hm = _chinese_remainder_reconstruction_univariate(hp, hlastm, p, m)\n        m *= p\n        if not hm == hlastm:\n            hlastm = hm\n            continue\n        h = hm.quo_ground(hm.content())\n        (fquo, frem) = f.div(h)\n        (gquo, grem) = g.div(h)\n        if not frem and (not grem):\n            if h.LC < 0:\n                ch = -ch\n            h = h.mul_ground(ch)\n            cff = fquo.mul_ground(cf // ch)\n            cfg = gquo.mul_ground(cg // ch)\n            return (h, cff, cfg)",
            "def modgcd_univariate(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Computes the GCD of two polynomials in `\\\\mathbb{Z}[x]` using a modular\\n    algorithm.\\n\\n    The algorithm computes the GCD of two univariate integer polynomials\\n    `f` and `g` by computing the GCD in `\\\\mathbb{Z}_p[x]` for suitable\\n    primes `p` and then reconstructing the coefficients with the Chinese\\n    Remainder Theorem. Trial division is only made for candidates which\\n    are very likely the desired GCD.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        univariate integer polynomial\\n    g : PolyElement\\n        univariate integer polynomial\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of the polynomials `f` and `g`\\n    cff : PolyElement\\n        cofactor of `f`, i.e. `\\\\frac{f}{h}`\\n    cfg : PolyElement\\n        cofactor of `g`, i.e. `\\\\frac{g}{h}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import modgcd_univariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x = ring(\"x\", ZZ)\\n\\n    >>> f = x**5 - 1\\n    >>> g = x - 1\\n\\n    >>> h, cff, cfg = modgcd_univariate(f, g)\\n    >>> h, cff, cfg\\n    (x - 1, x**4 + x**3 + x**2 + x + 1, 1)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> f = 6*x**2 - 6\\n    >>> g = 2*x**2 + 4*x + 2\\n\\n    >>> h, cff, cfg = modgcd_univariate(f, g)\\n    >>> h, cff, cfg\\n    (2*x + 2, 3*x - 3, x + 1)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n\\n    '\n    assert f.ring == g.ring and f.ring.domain.is_ZZ\n    result = _trivial_gcd(f, g)\n    if result is not None:\n        return result\n    ring = f.ring\n    (cf, f) = f.primitive()\n    (cg, g) = g.primitive()\n    ch = ring.domain.gcd(cf, cg)\n    bound = _degree_bound_univariate(f, g)\n    if bound == 0:\n        return (ring(ch), f.mul_ground(cf // ch), g.mul_ground(cg // ch))\n    gamma = ring.domain.gcd(f.LC, g.LC)\n    m = 1\n    p = 1\n    while True:\n        p = nextprime(p)\n        while gamma % p == 0:\n            p = nextprime(p)\n        fp = f.trunc_ground(p)\n        gp = g.trunc_ground(p)\n        hp = _gf_gcd(fp, gp, p)\n        deghp = hp.degree()\n        if deghp > bound:\n            continue\n        elif deghp < bound:\n            m = 1\n            bound = deghp\n            continue\n        hp = hp.mul_ground(gamma).trunc_ground(p)\n        if m == 1:\n            m = p\n            hlastm = hp\n            continue\n        hm = _chinese_remainder_reconstruction_univariate(hp, hlastm, p, m)\n        m *= p\n        if not hm == hlastm:\n            hlastm = hm\n            continue\n        h = hm.quo_ground(hm.content())\n        (fquo, frem) = f.div(h)\n        (gquo, grem) = g.div(h)\n        if not frem and (not grem):\n            if h.LC < 0:\n                ch = -ch\n            h = h.mul_ground(ch)\n            cff = fquo.mul_ground(cf // ch)\n            cfg = gquo.mul_ground(cg // ch)\n            return (h, cff, cfg)",
            "def modgcd_univariate(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Computes the GCD of two polynomials in `\\\\mathbb{Z}[x]` using a modular\\n    algorithm.\\n\\n    The algorithm computes the GCD of two univariate integer polynomials\\n    `f` and `g` by computing the GCD in `\\\\mathbb{Z}_p[x]` for suitable\\n    primes `p` and then reconstructing the coefficients with the Chinese\\n    Remainder Theorem. Trial division is only made for candidates which\\n    are very likely the desired GCD.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        univariate integer polynomial\\n    g : PolyElement\\n        univariate integer polynomial\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of the polynomials `f` and `g`\\n    cff : PolyElement\\n        cofactor of `f`, i.e. `\\\\frac{f}{h}`\\n    cfg : PolyElement\\n        cofactor of `g`, i.e. `\\\\frac{g}{h}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import modgcd_univariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x = ring(\"x\", ZZ)\\n\\n    >>> f = x**5 - 1\\n    >>> g = x - 1\\n\\n    >>> h, cff, cfg = modgcd_univariate(f, g)\\n    >>> h, cff, cfg\\n    (x - 1, x**4 + x**3 + x**2 + x + 1, 1)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> f = 6*x**2 - 6\\n    >>> g = 2*x**2 + 4*x + 2\\n\\n    >>> h, cff, cfg = modgcd_univariate(f, g)\\n    >>> h, cff, cfg\\n    (2*x + 2, 3*x - 3, x + 1)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n\\n    '\n    assert f.ring == g.ring and f.ring.domain.is_ZZ\n    result = _trivial_gcd(f, g)\n    if result is not None:\n        return result\n    ring = f.ring\n    (cf, f) = f.primitive()\n    (cg, g) = g.primitive()\n    ch = ring.domain.gcd(cf, cg)\n    bound = _degree_bound_univariate(f, g)\n    if bound == 0:\n        return (ring(ch), f.mul_ground(cf // ch), g.mul_ground(cg // ch))\n    gamma = ring.domain.gcd(f.LC, g.LC)\n    m = 1\n    p = 1\n    while True:\n        p = nextprime(p)\n        while gamma % p == 0:\n            p = nextprime(p)\n        fp = f.trunc_ground(p)\n        gp = g.trunc_ground(p)\n        hp = _gf_gcd(fp, gp, p)\n        deghp = hp.degree()\n        if deghp > bound:\n            continue\n        elif deghp < bound:\n            m = 1\n            bound = deghp\n            continue\n        hp = hp.mul_ground(gamma).trunc_ground(p)\n        if m == 1:\n            m = p\n            hlastm = hp\n            continue\n        hm = _chinese_remainder_reconstruction_univariate(hp, hlastm, p, m)\n        m *= p\n        if not hm == hlastm:\n            hlastm = hm\n            continue\n        h = hm.quo_ground(hm.content())\n        (fquo, frem) = f.div(h)\n        (gquo, grem) = g.div(h)\n        if not frem and (not grem):\n            if h.LC < 0:\n                ch = -ch\n            h = h.mul_ground(ch)\n            cff = fquo.mul_ground(cf // ch)\n            cfg = gquo.mul_ground(cg // ch)\n            return (h, cff, cfg)",
            "def modgcd_univariate(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Computes the GCD of two polynomials in `\\\\mathbb{Z}[x]` using a modular\\n    algorithm.\\n\\n    The algorithm computes the GCD of two univariate integer polynomials\\n    `f` and `g` by computing the GCD in `\\\\mathbb{Z}_p[x]` for suitable\\n    primes `p` and then reconstructing the coefficients with the Chinese\\n    Remainder Theorem. Trial division is only made for candidates which\\n    are very likely the desired GCD.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        univariate integer polynomial\\n    g : PolyElement\\n        univariate integer polynomial\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of the polynomials `f` and `g`\\n    cff : PolyElement\\n        cofactor of `f`, i.e. `\\\\frac{f}{h}`\\n    cfg : PolyElement\\n        cofactor of `g`, i.e. `\\\\frac{g}{h}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import modgcd_univariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x = ring(\"x\", ZZ)\\n\\n    >>> f = x**5 - 1\\n    >>> g = x - 1\\n\\n    >>> h, cff, cfg = modgcd_univariate(f, g)\\n    >>> h, cff, cfg\\n    (x - 1, x**4 + x**3 + x**2 + x + 1, 1)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> f = 6*x**2 - 6\\n    >>> g = 2*x**2 + 4*x + 2\\n\\n    >>> h, cff, cfg = modgcd_univariate(f, g)\\n    >>> h, cff, cfg\\n    (2*x + 2, 3*x - 3, x + 1)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n\\n    '\n    assert f.ring == g.ring and f.ring.domain.is_ZZ\n    result = _trivial_gcd(f, g)\n    if result is not None:\n        return result\n    ring = f.ring\n    (cf, f) = f.primitive()\n    (cg, g) = g.primitive()\n    ch = ring.domain.gcd(cf, cg)\n    bound = _degree_bound_univariate(f, g)\n    if bound == 0:\n        return (ring(ch), f.mul_ground(cf // ch), g.mul_ground(cg // ch))\n    gamma = ring.domain.gcd(f.LC, g.LC)\n    m = 1\n    p = 1\n    while True:\n        p = nextprime(p)\n        while gamma % p == 0:\n            p = nextprime(p)\n        fp = f.trunc_ground(p)\n        gp = g.trunc_ground(p)\n        hp = _gf_gcd(fp, gp, p)\n        deghp = hp.degree()\n        if deghp > bound:\n            continue\n        elif deghp < bound:\n            m = 1\n            bound = deghp\n            continue\n        hp = hp.mul_ground(gamma).trunc_ground(p)\n        if m == 1:\n            m = p\n            hlastm = hp\n            continue\n        hm = _chinese_remainder_reconstruction_univariate(hp, hlastm, p, m)\n        m *= p\n        if not hm == hlastm:\n            hlastm = hm\n            continue\n        h = hm.quo_ground(hm.content())\n        (fquo, frem) = f.div(h)\n        (gquo, grem) = g.div(h)\n        if not frem and (not grem):\n            if h.LC < 0:\n                ch = -ch\n            h = h.mul_ground(ch)\n            cff = fquo.mul_ground(cf // ch)\n            cfg = gquo.mul_ground(cg // ch)\n            return (h, cff, cfg)"
        ]
    },
    {
        "func_name": "_primitive",
        "original": "def _primitive(f, p):\n    \"\"\"\n    Compute the content and the primitive part of a polynomial in\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-2}, y] \\\\cong \\\\mathbb{Z}_p[y][x_0, \\\\ldots, x_{k-2}]`.\n\n    Parameters\n    ==========\n\n    f : PolyElement\n        integer polynomial in `\\\\mathbb{Z}_p[x0, \\\\ldots, x{k-2}, y]`\n    p : Integer\n        modulus of `f`\n\n    Returns\n    =======\n\n    contf : PolyElement\n        integer polynomial in `\\\\mathbb{Z}_p[y]`, content of `f`\n    ppf : PolyElement\n        primitive part of `f`, i.e. `\\\\frac{f}{contf}`\n\n    Examples\n    ========\n\n    >>> from sympy.polys.modulargcd import _primitive\n    >>> from sympy.polys import ring, ZZ\n\n    >>> R, x, y = ring(\"x, y\", ZZ)\n    >>> p = 3\n\n    >>> f = x**2*y**2 + x**2*y - y**2 - y\n    >>> _primitive(f, p)\n    (y**2 + y, x**2 - 1)\n\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\n\n    >>> f = x*y*z - y**2*z**2\n    >>> _primitive(f, p)\n    (z, x*y - y**2*z)\n\n    \"\"\"\n    ring = f.ring\n    dom = ring.domain\n    k = ring.ngens\n    coeffs = {}\n    for (monom, coeff) in f.iterterms():\n        if monom[:-1] not in coeffs:\n            coeffs[monom[:-1]] = {}\n        coeffs[monom[:-1]][monom[-1]] = coeff\n    cont = []\n    for coeff in iter(coeffs.values()):\n        cont = gf_gcd(cont, gf_from_dict(coeff, p, dom), p, dom)\n    yring = ring.clone(symbols=ring.symbols[k - 1])\n    contf = yring.from_dense(cont).trunc_ground(p)\n    return (contf, f.quo(contf.set_ring(ring)))",
        "mutated": [
            "def _primitive(f, p):\n    if False:\n        i = 10\n    '\\n    Compute the content and the primitive part of a polynomial in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-2}, y] \\\\cong \\\\mathbb{Z}_p[y][x_0, \\\\ldots, x_{k-2}]`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        integer polynomial in `\\\\mathbb{Z}_p[x0, \\\\ldots, x{k-2}, y]`\\n    p : Integer\\n        modulus of `f`\\n\\n    Returns\\n    =======\\n\\n    contf : PolyElement\\n        integer polynomial in `\\\\mathbb{Z}_p[y]`, content of `f`\\n    ppf : PolyElement\\n        primitive part of `f`, i.e. `\\\\frac{f}{contf}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _primitive\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n    >>> p = 3\\n\\n    >>> f = x**2*y**2 + x**2*y - y**2 - y\\n    >>> _primitive(f, p)\\n    (y**2 + y, x**2 - 1)\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n\\n    >>> f = x*y*z - y**2*z**2\\n    >>> _primitive(f, p)\\n    (z, x*y - y**2*z)\\n\\n    '\n    ring = f.ring\n    dom = ring.domain\n    k = ring.ngens\n    coeffs = {}\n    for (monom, coeff) in f.iterterms():\n        if monom[:-1] not in coeffs:\n            coeffs[monom[:-1]] = {}\n        coeffs[monom[:-1]][monom[-1]] = coeff\n    cont = []\n    for coeff in iter(coeffs.values()):\n        cont = gf_gcd(cont, gf_from_dict(coeff, p, dom), p, dom)\n    yring = ring.clone(symbols=ring.symbols[k - 1])\n    contf = yring.from_dense(cont).trunc_ground(p)\n    return (contf, f.quo(contf.set_ring(ring)))",
            "def _primitive(f, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the content and the primitive part of a polynomial in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-2}, y] \\\\cong \\\\mathbb{Z}_p[y][x_0, \\\\ldots, x_{k-2}]`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        integer polynomial in `\\\\mathbb{Z}_p[x0, \\\\ldots, x{k-2}, y]`\\n    p : Integer\\n        modulus of `f`\\n\\n    Returns\\n    =======\\n\\n    contf : PolyElement\\n        integer polynomial in `\\\\mathbb{Z}_p[y]`, content of `f`\\n    ppf : PolyElement\\n        primitive part of `f`, i.e. `\\\\frac{f}{contf}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _primitive\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n    >>> p = 3\\n\\n    >>> f = x**2*y**2 + x**2*y - y**2 - y\\n    >>> _primitive(f, p)\\n    (y**2 + y, x**2 - 1)\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n\\n    >>> f = x*y*z - y**2*z**2\\n    >>> _primitive(f, p)\\n    (z, x*y - y**2*z)\\n\\n    '\n    ring = f.ring\n    dom = ring.domain\n    k = ring.ngens\n    coeffs = {}\n    for (monom, coeff) in f.iterterms():\n        if monom[:-1] not in coeffs:\n            coeffs[monom[:-1]] = {}\n        coeffs[monom[:-1]][monom[-1]] = coeff\n    cont = []\n    for coeff in iter(coeffs.values()):\n        cont = gf_gcd(cont, gf_from_dict(coeff, p, dom), p, dom)\n    yring = ring.clone(symbols=ring.symbols[k - 1])\n    contf = yring.from_dense(cont).trunc_ground(p)\n    return (contf, f.quo(contf.set_ring(ring)))",
            "def _primitive(f, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the content and the primitive part of a polynomial in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-2}, y] \\\\cong \\\\mathbb{Z}_p[y][x_0, \\\\ldots, x_{k-2}]`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        integer polynomial in `\\\\mathbb{Z}_p[x0, \\\\ldots, x{k-2}, y]`\\n    p : Integer\\n        modulus of `f`\\n\\n    Returns\\n    =======\\n\\n    contf : PolyElement\\n        integer polynomial in `\\\\mathbb{Z}_p[y]`, content of `f`\\n    ppf : PolyElement\\n        primitive part of `f`, i.e. `\\\\frac{f}{contf}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _primitive\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n    >>> p = 3\\n\\n    >>> f = x**2*y**2 + x**2*y - y**2 - y\\n    >>> _primitive(f, p)\\n    (y**2 + y, x**2 - 1)\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n\\n    >>> f = x*y*z - y**2*z**2\\n    >>> _primitive(f, p)\\n    (z, x*y - y**2*z)\\n\\n    '\n    ring = f.ring\n    dom = ring.domain\n    k = ring.ngens\n    coeffs = {}\n    for (monom, coeff) in f.iterterms():\n        if monom[:-1] not in coeffs:\n            coeffs[monom[:-1]] = {}\n        coeffs[monom[:-1]][monom[-1]] = coeff\n    cont = []\n    for coeff in iter(coeffs.values()):\n        cont = gf_gcd(cont, gf_from_dict(coeff, p, dom), p, dom)\n    yring = ring.clone(symbols=ring.symbols[k - 1])\n    contf = yring.from_dense(cont).trunc_ground(p)\n    return (contf, f.quo(contf.set_ring(ring)))",
            "def _primitive(f, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the content and the primitive part of a polynomial in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-2}, y] \\\\cong \\\\mathbb{Z}_p[y][x_0, \\\\ldots, x_{k-2}]`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        integer polynomial in `\\\\mathbb{Z}_p[x0, \\\\ldots, x{k-2}, y]`\\n    p : Integer\\n        modulus of `f`\\n\\n    Returns\\n    =======\\n\\n    contf : PolyElement\\n        integer polynomial in `\\\\mathbb{Z}_p[y]`, content of `f`\\n    ppf : PolyElement\\n        primitive part of `f`, i.e. `\\\\frac{f}{contf}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _primitive\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n    >>> p = 3\\n\\n    >>> f = x**2*y**2 + x**2*y - y**2 - y\\n    >>> _primitive(f, p)\\n    (y**2 + y, x**2 - 1)\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n\\n    >>> f = x*y*z - y**2*z**2\\n    >>> _primitive(f, p)\\n    (z, x*y - y**2*z)\\n\\n    '\n    ring = f.ring\n    dom = ring.domain\n    k = ring.ngens\n    coeffs = {}\n    for (monom, coeff) in f.iterterms():\n        if monom[:-1] not in coeffs:\n            coeffs[monom[:-1]] = {}\n        coeffs[monom[:-1]][monom[-1]] = coeff\n    cont = []\n    for coeff in iter(coeffs.values()):\n        cont = gf_gcd(cont, gf_from_dict(coeff, p, dom), p, dom)\n    yring = ring.clone(symbols=ring.symbols[k - 1])\n    contf = yring.from_dense(cont).trunc_ground(p)\n    return (contf, f.quo(contf.set_ring(ring)))",
            "def _primitive(f, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the content and the primitive part of a polynomial in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-2}, y] \\\\cong \\\\mathbb{Z}_p[y][x_0, \\\\ldots, x_{k-2}]`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        integer polynomial in `\\\\mathbb{Z}_p[x0, \\\\ldots, x{k-2}, y]`\\n    p : Integer\\n        modulus of `f`\\n\\n    Returns\\n    =======\\n\\n    contf : PolyElement\\n        integer polynomial in `\\\\mathbb{Z}_p[y]`, content of `f`\\n    ppf : PolyElement\\n        primitive part of `f`, i.e. `\\\\frac{f}{contf}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _primitive\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n    >>> p = 3\\n\\n    >>> f = x**2*y**2 + x**2*y - y**2 - y\\n    >>> _primitive(f, p)\\n    (y**2 + y, x**2 - 1)\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n\\n    >>> f = x*y*z - y**2*z**2\\n    >>> _primitive(f, p)\\n    (z, x*y - y**2*z)\\n\\n    '\n    ring = f.ring\n    dom = ring.domain\n    k = ring.ngens\n    coeffs = {}\n    for (monom, coeff) in f.iterterms():\n        if monom[:-1] not in coeffs:\n            coeffs[monom[:-1]] = {}\n        coeffs[monom[:-1]][monom[-1]] = coeff\n    cont = []\n    for coeff in iter(coeffs.values()):\n        cont = gf_gcd(cont, gf_from_dict(coeff, p, dom), p, dom)\n    yring = ring.clone(symbols=ring.symbols[k - 1])\n    contf = yring.from_dense(cont).trunc_ground(p)\n    return (contf, f.quo(contf.set_ring(ring)))"
        ]
    },
    {
        "func_name": "_deg",
        "original": "def _deg(f):\n    \"\"\"\n    Compute the degree of a multivariate polynomial\n    `f \\\\in K[x_0, \\\\ldots, x_{k-2}, y] \\\\cong K[y][x_0, \\\\ldots, x_{k-2}]`.\n\n    Parameters\n    ==========\n\n    f : PolyElement\n        polynomial in `K[x_0, \\\\ldots, x_{k-2}, y]`\n\n    Returns\n    =======\n\n    degf : Integer tuple\n        degree of `f` in `x_0, \\\\ldots, x_{k-2}`\n\n    Examples\n    ========\n\n    >>> from sympy.polys.modulargcd import _deg\n    >>> from sympy.polys import ring, ZZ\n\n    >>> R, x, y = ring(\"x, y\", ZZ)\n\n    >>> f = x**2*y**2 + x**2*y - 1\n    >>> _deg(f)\n    (2,)\n\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\n\n    >>> f = x**2*y**2 + x**2*y - 1\n    >>> _deg(f)\n    (2, 2)\n\n    >>> f = x*y*z - y**2*z**2\n    >>> _deg(f)\n    (1, 1)\n\n    \"\"\"\n    k = f.ring.ngens\n    degf = (0,) * (k - 1)\n    for monom in f.itermonoms():\n        if monom[:-1] > degf:\n            degf = monom[:-1]\n    return degf",
        "mutated": [
            "def _deg(f):\n    if False:\n        i = 10\n    '\\n    Compute the degree of a multivariate polynomial\\n    `f \\\\in K[x_0, \\\\ldots, x_{k-2}, y] \\\\cong K[y][x_0, \\\\ldots, x_{k-2}]`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `K[x_0, \\\\ldots, x_{k-2}, y]`\\n\\n    Returns\\n    =======\\n\\n    degf : Integer tuple\\n        degree of `f` in `x_0, \\\\ldots, x_{k-2}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _deg\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n\\n    >>> f = x**2*y**2 + x**2*y - 1\\n    >>> _deg(f)\\n    (2,)\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n\\n    >>> f = x**2*y**2 + x**2*y - 1\\n    >>> _deg(f)\\n    (2, 2)\\n\\n    >>> f = x*y*z - y**2*z**2\\n    >>> _deg(f)\\n    (1, 1)\\n\\n    '\n    k = f.ring.ngens\n    degf = (0,) * (k - 1)\n    for monom in f.itermonoms():\n        if monom[:-1] > degf:\n            degf = monom[:-1]\n    return degf",
            "def _deg(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the degree of a multivariate polynomial\\n    `f \\\\in K[x_0, \\\\ldots, x_{k-2}, y] \\\\cong K[y][x_0, \\\\ldots, x_{k-2}]`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `K[x_0, \\\\ldots, x_{k-2}, y]`\\n\\n    Returns\\n    =======\\n\\n    degf : Integer tuple\\n        degree of `f` in `x_0, \\\\ldots, x_{k-2}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _deg\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n\\n    >>> f = x**2*y**2 + x**2*y - 1\\n    >>> _deg(f)\\n    (2,)\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n\\n    >>> f = x**2*y**2 + x**2*y - 1\\n    >>> _deg(f)\\n    (2, 2)\\n\\n    >>> f = x*y*z - y**2*z**2\\n    >>> _deg(f)\\n    (1, 1)\\n\\n    '\n    k = f.ring.ngens\n    degf = (0,) * (k - 1)\n    for monom in f.itermonoms():\n        if monom[:-1] > degf:\n            degf = monom[:-1]\n    return degf",
            "def _deg(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the degree of a multivariate polynomial\\n    `f \\\\in K[x_0, \\\\ldots, x_{k-2}, y] \\\\cong K[y][x_0, \\\\ldots, x_{k-2}]`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `K[x_0, \\\\ldots, x_{k-2}, y]`\\n\\n    Returns\\n    =======\\n\\n    degf : Integer tuple\\n        degree of `f` in `x_0, \\\\ldots, x_{k-2}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _deg\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n\\n    >>> f = x**2*y**2 + x**2*y - 1\\n    >>> _deg(f)\\n    (2,)\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n\\n    >>> f = x**2*y**2 + x**2*y - 1\\n    >>> _deg(f)\\n    (2, 2)\\n\\n    >>> f = x*y*z - y**2*z**2\\n    >>> _deg(f)\\n    (1, 1)\\n\\n    '\n    k = f.ring.ngens\n    degf = (0,) * (k - 1)\n    for monom in f.itermonoms():\n        if monom[:-1] > degf:\n            degf = monom[:-1]\n    return degf",
            "def _deg(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the degree of a multivariate polynomial\\n    `f \\\\in K[x_0, \\\\ldots, x_{k-2}, y] \\\\cong K[y][x_0, \\\\ldots, x_{k-2}]`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `K[x_0, \\\\ldots, x_{k-2}, y]`\\n\\n    Returns\\n    =======\\n\\n    degf : Integer tuple\\n        degree of `f` in `x_0, \\\\ldots, x_{k-2}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _deg\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n\\n    >>> f = x**2*y**2 + x**2*y - 1\\n    >>> _deg(f)\\n    (2,)\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n\\n    >>> f = x**2*y**2 + x**2*y - 1\\n    >>> _deg(f)\\n    (2, 2)\\n\\n    >>> f = x*y*z - y**2*z**2\\n    >>> _deg(f)\\n    (1, 1)\\n\\n    '\n    k = f.ring.ngens\n    degf = (0,) * (k - 1)\n    for monom in f.itermonoms():\n        if monom[:-1] > degf:\n            degf = monom[:-1]\n    return degf",
            "def _deg(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the degree of a multivariate polynomial\\n    `f \\\\in K[x_0, \\\\ldots, x_{k-2}, y] \\\\cong K[y][x_0, \\\\ldots, x_{k-2}]`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `K[x_0, \\\\ldots, x_{k-2}, y]`\\n\\n    Returns\\n    =======\\n\\n    degf : Integer tuple\\n        degree of `f` in `x_0, \\\\ldots, x_{k-2}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _deg\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n\\n    >>> f = x**2*y**2 + x**2*y - 1\\n    >>> _deg(f)\\n    (2,)\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n\\n    >>> f = x**2*y**2 + x**2*y - 1\\n    >>> _deg(f)\\n    (2, 2)\\n\\n    >>> f = x*y*z - y**2*z**2\\n    >>> _deg(f)\\n    (1, 1)\\n\\n    '\n    k = f.ring.ngens\n    degf = (0,) * (k - 1)\n    for monom in f.itermonoms():\n        if monom[:-1] > degf:\n            degf = monom[:-1]\n    return degf"
        ]
    },
    {
        "func_name": "_LC",
        "original": "def _LC(f):\n    \"\"\"\n    Compute the leading coefficient of a multivariate polynomial\n    `f \\\\in K[x_0, \\\\ldots, x_{k-2}, y] \\\\cong K[y][x_0, \\\\ldots, x_{k-2}]`.\n\n    Parameters\n    ==========\n\n    f : PolyElement\n        polynomial in `K[x_0, \\\\ldots, x_{k-2}, y]`\n\n    Returns\n    =======\n\n    lcf : PolyElement\n        polynomial in `K[y]`, leading coefficient of `f`\n\n    Examples\n    ========\n\n    >>> from sympy.polys.modulargcd import _LC\n    >>> from sympy.polys import ring, ZZ\n\n    >>> R, x, y = ring(\"x, y\", ZZ)\n\n    >>> f = x**2*y**2 + x**2*y - 1\n    >>> _LC(f)\n    y**2 + y\n\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\n\n    >>> f = x**2*y**2 + x**2*y - 1\n    >>> _LC(f)\n    1\n\n    >>> f = x*y*z - y**2*z**2\n    >>> _LC(f)\n    z\n\n    \"\"\"\n    ring = f.ring\n    k = ring.ngens\n    yring = ring.clone(symbols=ring.symbols[k - 1])\n    y = yring.gens[0]\n    degf = _deg(f)\n    lcf = yring.zero\n    for (monom, coeff) in f.iterterms():\n        if monom[:-1] == degf:\n            lcf += coeff * y ** monom[-1]\n    return lcf",
        "mutated": [
            "def _LC(f):\n    if False:\n        i = 10\n    '\\n    Compute the leading coefficient of a multivariate polynomial\\n    `f \\\\in K[x_0, \\\\ldots, x_{k-2}, y] \\\\cong K[y][x_0, \\\\ldots, x_{k-2}]`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `K[x_0, \\\\ldots, x_{k-2}, y]`\\n\\n    Returns\\n    =======\\n\\n    lcf : PolyElement\\n        polynomial in `K[y]`, leading coefficient of `f`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _LC\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n\\n    >>> f = x**2*y**2 + x**2*y - 1\\n    >>> _LC(f)\\n    y**2 + y\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n\\n    >>> f = x**2*y**2 + x**2*y - 1\\n    >>> _LC(f)\\n    1\\n\\n    >>> f = x*y*z - y**2*z**2\\n    >>> _LC(f)\\n    z\\n\\n    '\n    ring = f.ring\n    k = ring.ngens\n    yring = ring.clone(symbols=ring.symbols[k - 1])\n    y = yring.gens[0]\n    degf = _deg(f)\n    lcf = yring.zero\n    for (monom, coeff) in f.iterterms():\n        if monom[:-1] == degf:\n            lcf += coeff * y ** monom[-1]\n    return lcf",
            "def _LC(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the leading coefficient of a multivariate polynomial\\n    `f \\\\in K[x_0, \\\\ldots, x_{k-2}, y] \\\\cong K[y][x_0, \\\\ldots, x_{k-2}]`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `K[x_0, \\\\ldots, x_{k-2}, y]`\\n\\n    Returns\\n    =======\\n\\n    lcf : PolyElement\\n        polynomial in `K[y]`, leading coefficient of `f`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _LC\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n\\n    >>> f = x**2*y**2 + x**2*y - 1\\n    >>> _LC(f)\\n    y**2 + y\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n\\n    >>> f = x**2*y**2 + x**2*y - 1\\n    >>> _LC(f)\\n    1\\n\\n    >>> f = x*y*z - y**2*z**2\\n    >>> _LC(f)\\n    z\\n\\n    '\n    ring = f.ring\n    k = ring.ngens\n    yring = ring.clone(symbols=ring.symbols[k - 1])\n    y = yring.gens[0]\n    degf = _deg(f)\n    lcf = yring.zero\n    for (monom, coeff) in f.iterterms():\n        if monom[:-1] == degf:\n            lcf += coeff * y ** monom[-1]\n    return lcf",
            "def _LC(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the leading coefficient of a multivariate polynomial\\n    `f \\\\in K[x_0, \\\\ldots, x_{k-2}, y] \\\\cong K[y][x_0, \\\\ldots, x_{k-2}]`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `K[x_0, \\\\ldots, x_{k-2}, y]`\\n\\n    Returns\\n    =======\\n\\n    lcf : PolyElement\\n        polynomial in `K[y]`, leading coefficient of `f`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _LC\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n\\n    >>> f = x**2*y**2 + x**2*y - 1\\n    >>> _LC(f)\\n    y**2 + y\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n\\n    >>> f = x**2*y**2 + x**2*y - 1\\n    >>> _LC(f)\\n    1\\n\\n    >>> f = x*y*z - y**2*z**2\\n    >>> _LC(f)\\n    z\\n\\n    '\n    ring = f.ring\n    k = ring.ngens\n    yring = ring.clone(symbols=ring.symbols[k - 1])\n    y = yring.gens[0]\n    degf = _deg(f)\n    lcf = yring.zero\n    for (monom, coeff) in f.iterterms():\n        if monom[:-1] == degf:\n            lcf += coeff * y ** monom[-1]\n    return lcf",
            "def _LC(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the leading coefficient of a multivariate polynomial\\n    `f \\\\in K[x_0, \\\\ldots, x_{k-2}, y] \\\\cong K[y][x_0, \\\\ldots, x_{k-2}]`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `K[x_0, \\\\ldots, x_{k-2}, y]`\\n\\n    Returns\\n    =======\\n\\n    lcf : PolyElement\\n        polynomial in `K[y]`, leading coefficient of `f`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _LC\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n\\n    >>> f = x**2*y**2 + x**2*y - 1\\n    >>> _LC(f)\\n    y**2 + y\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n\\n    >>> f = x**2*y**2 + x**2*y - 1\\n    >>> _LC(f)\\n    1\\n\\n    >>> f = x*y*z - y**2*z**2\\n    >>> _LC(f)\\n    z\\n\\n    '\n    ring = f.ring\n    k = ring.ngens\n    yring = ring.clone(symbols=ring.symbols[k - 1])\n    y = yring.gens[0]\n    degf = _deg(f)\n    lcf = yring.zero\n    for (monom, coeff) in f.iterterms():\n        if monom[:-1] == degf:\n            lcf += coeff * y ** monom[-1]\n    return lcf",
            "def _LC(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the leading coefficient of a multivariate polynomial\\n    `f \\\\in K[x_0, \\\\ldots, x_{k-2}, y] \\\\cong K[y][x_0, \\\\ldots, x_{k-2}]`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `K[x_0, \\\\ldots, x_{k-2}, y]`\\n\\n    Returns\\n    =======\\n\\n    lcf : PolyElement\\n        polynomial in `K[y]`, leading coefficient of `f`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _LC\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n\\n    >>> f = x**2*y**2 + x**2*y - 1\\n    >>> _LC(f)\\n    y**2 + y\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n\\n    >>> f = x**2*y**2 + x**2*y - 1\\n    >>> _LC(f)\\n    1\\n\\n    >>> f = x*y*z - y**2*z**2\\n    >>> _LC(f)\\n    z\\n\\n    '\n    ring = f.ring\n    k = ring.ngens\n    yring = ring.clone(symbols=ring.symbols[k - 1])\n    y = yring.gens[0]\n    degf = _deg(f)\n    lcf = yring.zero\n    for (monom, coeff) in f.iterterms():\n        if monom[:-1] == degf:\n            lcf += coeff * y ** monom[-1]\n    return lcf"
        ]
    },
    {
        "func_name": "_swap",
        "original": "def _swap(f, i):\n    \"\"\"\n    Make the variable `x_i` the leading one in a multivariate polynomial `f`.\n    \"\"\"\n    ring = f.ring\n    fswap = ring.zero\n    for (monom, coeff) in f.iterterms():\n        monomswap = (monom[i],) + monom[:i] + monom[i + 1:]\n        fswap[monomswap] = coeff\n    return fswap",
        "mutated": [
            "def _swap(f, i):\n    if False:\n        i = 10\n    '\\n    Make the variable `x_i` the leading one in a multivariate polynomial `f`.\\n    '\n    ring = f.ring\n    fswap = ring.zero\n    for (monom, coeff) in f.iterterms():\n        monomswap = (monom[i],) + monom[:i] + monom[i + 1:]\n        fswap[monomswap] = coeff\n    return fswap",
            "def _swap(f, i):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Make the variable `x_i` the leading one in a multivariate polynomial `f`.\\n    '\n    ring = f.ring\n    fswap = ring.zero\n    for (monom, coeff) in f.iterterms():\n        monomswap = (monom[i],) + monom[:i] + monom[i + 1:]\n        fswap[monomswap] = coeff\n    return fswap",
            "def _swap(f, i):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Make the variable `x_i` the leading one in a multivariate polynomial `f`.\\n    '\n    ring = f.ring\n    fswap = ring.zero\n    for (monom, coeff) in f.iterterms():\n        monomswap = (monom[i],) + monom[:i] + monom[i + 1:]\n        fswap[monomswap] = coeff\n    return fswap",
            "def _swap(f, i):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Make the variable `x_i` the leading one in a multivariate polynomial `f`.\\n    '\n    ring = f.ring\n    fswap = ring.zero\n    for (monom, coeff) in f.iterterms():\n        monomswap = (monom[i],) + monom[:i] + monom[i + 1:]\n        fswap[monomswap] = coeff\n    return fswap",
            "def _swap(f, i):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Make the variable `x_i` the leading one in a multivariate polynomial `f`.\\n    '\n    ring = f.ring\n    fswap = ring.zero\n    for (monom, coeff) in f.iterterms():\n        monomswap = (monom[i],) + monom[:i] + monom[i + 1:]\n        fswap[monomswap] = coeff\n    return fswap"
        ]
    },
    {
        "func_name": "_degree_bound_bivariate",
        "original": "def _degree_bound_bivariate(f, g):\n    \"\"\"\n    Compute upper degree bounds for the GCD of two bivariate\n    integer polynomials `f` and `g`.\n\n    The GCD is viewed as a polynomial in `\\\\mathbb{Z}[y][x]` and the\n    function returns an upper bound for its degree and one for the degree\n    of its content. This is done by choosing a suitable prime `p` and\n    computing the GCD of the contents of `f \\\\; \\\\mathrm{mod} \\\\, p` and\n    `g \\\\; \\\\mathrm{mod} \\\\, p`. The choice of `p` guarantees that the degree\n    of the content in `\\\\mathbb{Z}_p[y]` is greater than or equal to the\n    degree in `\\\\mathbb{Z}[y]`. To obtain the degree bound in the variable\n    `x`, the polynomials are evaluated at `y = a` for a suitable\n    `a \\\\in \\\\mathbb{Z}_p` and then their GCD in `\\\\mathbb{Z}_p[x]` is\n    computed. If no such `a` exists, i.e. the degree in `\\\\mathbb{Z}_p[x]`\n    is always smaller than the one in `\\\\mathbb{Z}[y][x]`, then the bound is\n    set to the minimum of the degrees of `f` and `g` in `x`.\n\n    Parameters\n    ==========\n\n    f : PolyElement\n        bivariate integer polynomial\n    g : PolyElement\n        bivariate integer polynomial\n\n    Returns\n    =======\n\n    xbound : Integer\n        upper bound for the degree of the GCD of the polynomials `f` and\n        `g` in the variable `x`\n    ycontbound : Integer\n        upper bound for the degree of the content of the GCD of the\n        polynomials `f` and `g` in the variable `y`\n\n    References\n    ==========\n\n    1. [Monagan00]_\n\n    \"\"\"\n    ring = f.ring\n    gamma1 = ring.domain.gcd(f.LC, g.LC)\n    gamma2 = ring.domain.gcd(_swap(f, 1).LC, _swap(g, 1).LC)\n    badprimes = gamma1 * gamma2\n    p = 1\n    p = nextprime(p)\n    while badprimes % p == 0:\n        p = nextprime(p)\n    fp = f.trunc_ground(p)\n    gp = g.trunc_ground(p)\n    (contfp, fp) = _primitive(fp, p)\n    (contgp, gp) = _primitive(gp, p)\n    conthp = _gf_gcd(contfp, contgp, p)\n    ycontbound = conthp.degree()\n    delta = _gf_gcd(_LC(fp), _LC(gp), p)\n    for a in range(p):\n        if not delta.evaluate(0, a) % p:\n            continue\n        fpa = fp.evaluate(1, a).trunc_ground(p)\n        gpa = gp.evaluate(1, a).trunc_ground(p)\n        hpa = _gf_gcd(fpa, gpa, p)\n        xbound = hpa.degree()\n        return (xbound, ycontbound)\n    return (min(fp.degree(), gp.degree()), ycontbound)",
        "mutated": [
            "def _degree_bound_bivariate(f, g):\n    if False:\n        i = 10\n    '\\n    Compute upper degree bounds for the GCD of two bivariate\\n    integer polynomials `f` and `g`.\\n\\n    The GCD is viewed as a polynomial in `\\\\mathbb{Z}[y][x]` and the\\n    function returns an upper bound for its degree and one for the degree\\n    of its content. This is done by choosing a suitable prime `p` and\\n    computing the GCD of the contents of `f \\\\; \\\\mathrm{mod} \\\\, p` and\\n    `g \\\\; \\\\mathrm{mod} \\\\, p`. The choice of `p` guarantees that the degree\\n    of the content in `\\\\mathbb{Z}_p[y]` is greater than or equal to the\\n    degree in `\\\\mathbb{Z}[y]`. To obtain the degree bound in the variable\\n    `x`, the polynomials are evaluated at `y = a` for a suitable\\n    `a \\\\in \\\\mathbb{Z}_p` and then their GCD in `\\\\mathbb{Z}_p[x]` is\\n    computed. If no such `a` exists, i.e. the degree in `\\\\mathbb{Z}_p[x]`\\n    is always smaller than the one in `\\\\mathbb{Z}[y][x]`, then the bound is\\n    set to the minimum of the degrees of `f` and `g` in `x`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        bivariate integer polynomial\\n    g : PolyElement\\n        bivariate integer polynomial\\n\\n    Returns\\n    =======\\n\\n    xbound : Integer\\n        upper bound for the degree of the GCD of the polynomials `f` and\\n        `g` in the variable `x`\\n    ycontbound : Integer\\n        upper bound for the degree of the content of the GCD of the\\n        polynomials `f` and `g` in the variable `y`\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n\\n    '\n    ring = f.ring\n    gamma1 = ring.domain.gcd(f.LC, g.LC)\n    gamma2 = ring.domain.gcd(_swap(f, 1).LC, _swap(g, 1).LC)\n    badprimes = gamma1 * gamma2\n    p = 1\n    p = nextprime(p)\n    while badprimes % p == 0:\n        p = nextprime(p)\n    fp = f.trunc_ground(p)\n    gp = g.trunc_ground(p)\n    (contfp, fp) = _primitive(fp, p)\n    (contgp, gp) = _primitive(gp, p)\n    conthp = _gf_gcd(contfp, contgp, p)\n    ycontbound = conthp.degree()\n    delta = _gf_gcd(_LC(fp), _LC(gp), p)\n    for a in range(p):\n        if not delta.evaluate(0, a) % p:\n            continue\n        fpa = fp.evaluate(1, a).trunc_ground(p)\n        gpa = gp.evaluate(1, a).trunc_ground(p)\n        hpa = _gf_gcd(fpa, gpa, p)\n        xbound = hpa.degree()\n        return (xbound, ycontbound)\n    return (min(fp.degree(), gp.degree()), ycontbound)",
            "def _degree_bound_bivariate(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute upper degree bounds for the GCD of two bivariate\\n    integer polynomials `f` and `g`.\\n\\n    The GCD is viewed as a polynomial in `\\\\mathbb{Z}[y][x]` and the\\n    function returns an upper bound for its degree and one for the degree\\n    of its content. This is done by choosing a suitable prime `p` and\\n    computing the GCD of the contents of `f \\\\; \\\\mathrm{mod} \\\\, p` and\\n    `g \\\\; \\\\mathrm{mod} \\\\, p`. The choice of `p` guarantees that the degree\\n    of the content in `\\\\mathbb{Z}_p[y]` is greater than or equal to the\\n    degree in `\\\\mathbb{Z}[y]`. To obtain the degree bound in the variable\\n    `x`, the polynomials are evaluated at `y = a` for a suitable\\n    `a \\\\in \\\\mathbb{Z}_p` and then their GCD in `\\\\mathbb{Z}_p[x]` is\\n    computed. If no such `a` exists, i.e. the degree in `\\\\mathbb{Z}_p[x]`\\n    is always smaller than the one in `\\\\mathbb{Z}[y][x]`, then the bound is\\n    set to the minimum of the degrees of `f` and `g` in `x`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        bivariate integer polynomial\\n    g : PolyElement\\n        bivariate integer polynomial\\n\\n    Returns\\n    =======\\n\\n    xbound : Integer\\n        upper bound for the degree of the GCD of the polynomials `f` and\\n        `g` in the variable `x`\\n    ycontbound : Integer\\n        upper bound for the degree of the content of the GCD of the\\n        polynomials `f` and `g` in the variable `y`\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n\\n    '\n    ring = f.ring\n    gamma1 = ring.domain.gcd(f.LC, g.LC)\n    gamma2 = ring.domain.gcd(_swap(f, 1).LC, _swap(g, 1).LC)\n    badprimes = gamma1 * gamma2\n    p = 1\n    p = nextprime(p)\n    while badprimes % p == 0:\n        p = nextprime(p)\n    fp = f.trunc_ground(p)\n    gp = g.trunc_ground(p)\n    (contfp, fp) = _primitive(fp, p)\n    (contgp, gp) = _primitive(gp, p)\n    conthp = _gf_gcd(contfp, contgp, p)\n    ycontbound = conthp.degree()\n    delta = _gf_gcd(_LC(fp), _LC(gp), p)\n    for a in range(p):\n        if not delta.evaluate(0, a) % p:\n            continue\n        fpa = fp.evaluate(1, a).trunc_ground(p)\n        gpa = gp.evaluate(1, a).trunc_ground(p)\n        hpa = _gf_gcd(fpa, gpa, p)\n        xbound = hpa.degree()\n        return (xbound, ycontbound)\n    return (min(fp.degree(), gp.degree()), ycontbound)",
            "def _degree_bound_bivariate(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute upper degree bounds for the GCD of two bivariate\\n    integer polynomials `f` and `g`.\\n\\n    The GCD is viewed as a polynomial in `\\\\mathbb{Z}[y][x]` and the\\n    function returns an upper bound for its degree and one for the degree\\n    of its content. This is done by choosing a suitable prime `p` and\\n    computing the GCD of the contents of `f \\\\; \\\\mathrm{mod} \\\\, p` and\\n    `g \\\\; \\\\mathrm{mod} \\\\, p`. The choice of `p` guarantees that the degree\\n    of the content in `\\\\mathbb{Z}_p[y]` is greater than or equal to the\\n    degree in `\\\\mathbb{Z}[y]`. To obtain the degree bound in the variable\\n    `x`, the polynomials are evaluated at `y = a` for a suitable\\n    `a \\\\in \\\\mathbb{Z}_p` and then their GCD in `\\\\mathbb{Z}_p[x]` is\\n    computed. If no such `a` exists, i.e. the degree in `\\\\mathbb{Z}_p[x]`\\n    is always smaller than the one in `\\\\mathbb{Z}[y][x]`, then the bound is\\n    set to the minimum of the degrees of `f` and `g` in `x`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        bivariate integer polynomial\\n    g : PolyElement\\n        bivariate integer polynomial\\n\\n    Returns\\n    =======\\n\\n    xbound : Integer\\n        upper bound for the degree of the GCD of the polynomials `f` and\\n        `g` in the variable `x`\\n    ycontbound : Integer\\n        upper bound for the degree of the content of the GCD of the\\n        polynomials `f` and `g` in the variable `y`\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n\\n    '\n    ring = f.ring\n    gamma1 = ring.domain.gcd(f.LC, g.LC)\n    gamma2 = ring.domain.gcd(_swap(f, 1).LC, _swap(g, 1).LC)\n    badprimes = gamma1 * gamma2\n    p = 1\n    p = nextprime(p)\n    while badprimes % p == 0:\n        p = nextprime(p)\n    fp = f.trunc_ground(p)\n    gp = g.trunc_ground(p)\n    (contfp, fp) = _primitive(fp, p)\n    (contgp, gp) = _primitive(gp, p)\n    conthp = _gf_gcd(contfp, contgp, p)\n    ycontbound = conthp.degree()\n    delta = _gf_gcd(_LC(fp), _LC(gp), p)\n    for a in range(p):\n        if not delta.evaluate(0, a) % p:\n            continue\n        fpa = fp.evaluate(1, a).trunc_ground(p)\n        gpa = gp.evaluate(1, a).trunc_ground(p)\n        hpa = _gf_gcd(fpa, gpa, p)\n        xbound = hpa.degree()\n        return (xbound, ycontbound)\n    return (min(fp.degree(), gp.degree()), ycontbound)",
            "def _degree_bound_bivariate(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute upper degree bounds for the GCD of two bivariate\\n    integer polynomials `f` and `g`.\\n\\n    The GCD is viewed as a polynomial in `\\\\mathbb{Z}[y][x]` and the\\n    function returns an upper bound for its degree and one for the degree\\n    of its content. This is done by choosing a suitable prime `p` and\\n    computing the GCD of the contents of `f \\\\; \\\\mathrm{mod} \\\\, p` and\\n    `g \\\\; \\\\mathrm{mod} \\\\, p`. The choice of `p` guarantees that the degree\\n    of the content in `\\\\mathbb{Z}_p[y]` is greater than or equal to the\\n    degree in `\\\\mathbb{Z}[y]`. To obtain the degree bound in the variable\\n    `x`, the polynomials are evaluated at `y = a` for a suitable\\n    `a \\\\in \\\\mathbb{Z}_p` and then their GCD in `\\\\mathbb{Z}_p[x]` is\\n    computed. If no such `a` exists, i.e. the degree in `\\\\mathbb{Z}_p[x]`\\n    is always smaller than the one in `\\\\mathbb{Z}[y][x]`, then the bound is\\n    set to the minimum of the degrees of `f` and `g` in `x`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        bivariate integer polynomial\\n    g : PolyElement\\n        bivariate integer polynomial\\n\\n    Returns\\n    =======\\n\\n    xbound : Integer\\n        upper bound for the degree of the GCD of the polynomials `f` and\\n        `g` in the variable `x`\\n    ycontbound : Integer\\n        upper bound for the degree of the content of the GCD of the\\n        polynomials `f` and `g` in the variable `y`\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n\\n    '\n    ring = f.ring\n    gamma1 = ring.domain.gcd(f.LC, g.LC)\n    gamma2 = ring.domain.gcd(_swap(f, 1).LC, _swap(g, 1).LC)\n    badprimes = gamma1 * gamma2\n    p = 1\n    p = nextprime(p)\n    while badprimes % p == 0:\n        p = nextprime(p)\n    fp = f.trunc_ground(p)\n    gp = g.trunc_ground(p)\n    (contfp, fp) = _primitive(fp, p)\n    (contgp, gp) = _primitive(gp, p)\n    conthp = _gf_gcd(contfp, contgp, p)\n    ycontbound = conthp.degree()\n    delta = _gf_gcd(_LC(fp), _LC(gp), p)\n    for a in range(p):\n        if not delta.evaluate(0, a) % p:\n            continue\n        fpa = fp.evaluate(1, a).trunc_ground(p)\n        gpa = gp.evaluate(1, a).trunc_ground(p)\n        hpa = _gf_gcd(fpa, gpa, p)\n        xbound = hpa.degree()\n        return (xbound, ycontbound)\n    return (min(fp.degree(), gp.degree()), ycontbound)",
            "def _degree_bound_bivariate(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute upper degree bounds for the GCD of two bivariate\\n    integer polynomials `f` and `g`.\\n\\n    The GCD is viewed as a polynomial in `\\\\mathbb{Z}[y][x]` and the\\n    function returns an upper bound for its degree and one for the degree\\n    of its content. This is done by choosing a suitable prime `p` and\\n    computing the GCD of the contents of `f \\\\; \\\\mathrm{mod} \\\\, p` and\\n    `g \\\\; \\\\mathrm{mod} \\\\, p`. The choice of `p` guarantees that the degree\\n    of the content in `\\\\mathbb{Z}_p[y]` is greater than or equal to the\\n    degree in `\\\\mathbb{Z}[y]`. To obtain the degree bound in the variable\\n    `x`, the polynomials are evaluated at `y = a` for a suitable\\n    `a \\\\in \\\\mathbb{Z}_p` and then their GCD in `\\\\mathbb{Z}_p[x]` is\\n    computed. If no such `a` exists, i.e. the degree in `\\\\mathbb{Z}_p[x]`\\n    is always smaller than the one in `\\\\mathbb{Z}[y][x]`, then the bound is\\n    set to the minimum of the degrees of `f` and `g` in `x`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        bivariate integer polynomial\\n    g : PolyElement\\n        bivariate integer polynomial\\n\\n    Returns\\n    =======\\n\\n    xbound : Integer\\n        upper bound for the degree of the GCD of the polynomials `f` and\\n        `g` in the variable `x`\\n    ycontbound : Integer\\n        upper bound for the degree of the content of the GCD of the\\n        polynomials `f` and `g` in the variable `y`\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n\\n    '\n    ring = f.ring\n    gamma1 = ring.domain.gcd(f.LC, g.LC)\n    gamma2 = ring.domain.gcd(_swap(f, 1).LC, _swap(g, 1).LC)\n    badprimes = gamma1 * gamma2\n    p = 1\n    p = nextprime(p)\n    while badprimes % p == 0:\n        p = nextprime(p)\n    fp = f.trunc_ground(p)\n    gp = g.trunc_ground(p)\n    (contfp, fp) = _primitive(fp, p)\n    (contgp, gp) = _primitive(gp, p)\n    conthp = _gf_gcd(contfp, contgp, p)\n    ycontbound = conthp.degree()\n    delta = _gf_gcd(_LC(fp), _LC(gp), p)\n    for a in range(p):\n        if not delta.evaluate(0, a) % p:\n            continue\n        fpa = fp.evaluate(1, a).trunc_ground(p)\n        gpa = gp.evaluate(1, a).trunc_ground(p)\n        hpa = _gf_gcd(fpa, gpa, p)\n        xbound = hpa.degree()\n        return (xbound, ycontbound)\n    return (min(fp.degree(), gp.degree()), ycontbound)"
        ]
    },
    {
        "func_name": "crt_",
        "original": "def crt_(cp, cq, p, q):\n    return crt([p, q], [cp, cq], symmetric=True)[0]",
        "mutated": [
            "def crt_(cp, cq, p, q):\n    if False:\n        i = 10\n    return crt([p, q], [cp, cq], symmetric=True)[0]",
            "def crt_(cp, cq, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return crt([p, q], [cp, cq], symmetric=True)[0]",
            "def crt_(cp, cq, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return crt([p, q], [cp, cq], symmetric=True)[0]",
            "def crt_(cp, cq, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return crt([p, q], [cp, cq], symmetric=True)[0]",
            "def crt_(cp, cq, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return crt([p, q], [cp, cq], symmetric=True)[0]"
        ]
    },
    {
        "func_name": "_chinese_remainder_reconstruction_multivariate",
        "original": "def _chinese_remainder_reconstruction_multivariate(hp, hq, p, q):\n    \"\"\"\n    Construct a polynomial `h_{pq}` in\n    `\\\\mathbb{Z}_{p q}[x_0, \\\\ldots, x_{k-1}]` such that\n\n    .. math ::\n\n        h_{pq} = h_p \\\\; \\\\mathrm{mod} \\\\, p\n\n        h_{pq} = h_q \\\\; \\\\mathrm{mod} \\\\, q\n\n    for relatively prime integers `p` and `q` and polynomials\n    `h_p` and `h_q` in `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]` and\n    `\\\\mathbb{Z}_q[x_0, \\\\ldots, x_{k-1}]` respectively.\n\n    The coefficients of the polynomial `h_{pq}` are computed with the\n    Chinese Remainder Theorem. The symmetric representation in\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`,\n    `\\\\mathbb{Z}_q[x_0, \\\\ldots, x_{k-1}]` and\n    `\\\\mathbb{Z}_{p q}[x_0, \\\\ldots, x_{k-1}]` is used.\n\n    Parameters\n    ==========\n\n    hp : PolyElement\n        multivariate integer polynomial with coefficients in `\\\\mathbb{Z}_p`\n    hq : PolyElement\n        multivariate integer polynomial with coefficients in `\\\\mathbb{Z}_q`\n    p : Integer\n        modulus of `h_p`, relatively prime to `q`\n    q : Integer\n        modulus of `h_q`, relatively prime to `p`\n\n    Examples\n    ========\n\n    >>> from sympy.polys.modulargcd import _chinese_remainder_reconstruction_multivariate\n    >>> from sympy.polys import ring, ZZ\n\n    >>> R, x, y = ring(\"x, y\", ZZ)\n    >>> p = 3\n    >>> q = 5\n\n    >>> hp = x**3*y - x**2 - 1\n    >>> hq = -x**3*y - 2*x*y**2 + 2\n\n    >>> hpq = _chinese_remainder_reconstruction_multivariate(hp, hq, p, q)\n    >>> hpq\n    4*x**3*y + 5*x**2 + 3*x*y**2 + 2\n\n    >>> hpq.trunc_ground(p) == hp\n    True\n    >>> hpq.trunc_ground(q) == hq\n    True\n\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\n    >>> p = 6\n    >>> q = 5\n\n    >>> hp = 3*x**4 - y**3*z + z\n    >>> hq = -2*x**4 + z\n\n    >>> hpq = _chinese_remainder_reconstruction_multivariate(hp, hq, p, q)\n    >>> hpq\n    3*x**4 + 5*y**3*z + z\n\n    >>> hpq.trunc_ground(p) == hp\n    True\n    >>> hpq.trunc_ground(q) == hq\n    True\n\n    \"\"\"\n    hpmonoms = set(hp.monoms())\n    hqmonoms = set(hq.monoms())\n    monoms = hpmonoms.intersection(hqmonoms)\n    hpmonoms.difference_update(monoms)\n    hqmonoms.difference_update(monoms)\n    zero = hp.ring.domain.zero\n    hpq = hp.ring.zero\n    if isinstance(hp.ring.domain, PolynomialRing):\n        crt_ = _chinese_remainder_reconstruction_multivariate\n    else:\n\n        def crt_(cp, cq, p, q):\n            return crt([p, q], [cp, cq], symmetric=True)[0]\n    for monom in monoms:\n        hpq[monom] = crt_(hp[monom], hq[monom], p, q)\n    for monom in hpmonoms:\n        hpq[monom] = crt_(hp[monom], zero, p, q)\n    for monom in hqmonoms:\n        hpq[monom] = crt_(zero, hq[monom], p, q)\n    return hpq",
        "mutated": [
            "def _chinese_remainder_reconstruction_multivariate(hp, hq, p, q):\n    if False:\n        i = 10\n    '\\n    Construct a polynomial `h_{pq}` in\\n    `\\\\mathbb{Z}_{p q}[x_0, \\\\ldots, x_{k-1}]` such that\\n\\n    .. math ::\\n\\n        h_{pq} = h_p \\\\; \\\\mathrm{mod} \\\\, p\\n\\n        h_{pq} = h_q \\\\; \\\\mathrm{mod} \\\\, q\\n\\n    for relatively prime integers `p` and `q` and polynomials\\n    `h_p` and `h_q` in `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]` and\\n    `\\\\mathbb{Z}_q[x_0, \\\\ldots, x_{k-1}]` respectively.\\n\\n    The coefficients of the polynomial `h_{pq}` are computed with the\\n    Chinese Remainder Theorem. The symmetric representation in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`,\\n    `\\\\mathbb{Z}_q[x_0, \\\\ldots, x_{k-1}]` and\\n    `\\\\mathbb{Z}_{p q}[x_0, \\\\ldots, x_{k-1}]` is used.\\n\\n    Parameters\\n    ==========\\n\\n    hp : PolyElement\\n        multivariate integer polynomial with coefficients in `\\\\mathbb{Z}_p`\\n    hq : PolyElement\\n        multivariate integer polynomial with coefficients in `\\\\mathbb{Z}_q`\\n    p : Integer\\n        modulus of `h_p`, relatively prime to `q`\\n    q : Integer\\n        modulus of `h_q`, relatively prime to `p`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _chinese_remainder_reconstruction_multivariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n    >>> p = 3\\n    >>> q = 5\\n\\n    >>> hp = x**3*y - x**2 - 1\\n    >>> hq = -x**3*y - 2*x*y**2 + 2\\n\\n    >>> hpq = _chinese_remainder_reconstruction_multivariate(hp, hq, p, q)\\n    >>> hpq\\n    4*x**3*y + 5*x**2 + 3*x*y**2 + 2\\n\\n    >>> hpq.trunc_ground(p) == hp\\n    True\\n    >>> hpq.trunc_ground(q) == hq\\n    True\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n    >>> p = 6\\n    >>> q = 5\\n\\n    >>> hp = 3*x**4 - y**3*z + z\\n    >>> hq = -2*x**4 + z\\n\\n    >>> hpq = _chinese_remainder_reconstruction_multivariate(hp, hq, p, q)\\n    >>> hpq\\n    3*x**4 + 5*y**3*z + z\\n\\n    >>> hpq.trunc_ground(p) == hp\\n    True\\n    >>> hpq.trunc_ground(q) == hq\\n    True\\n\\n    '\n    hpmonoms = set(hp.monoms())\n    hqmonoms = set(hq.monoms())\n    monoms = hpmonoms.intersection(hqmonoms)\n    hpmonoms.difference_update(monoms)\n    hqmonoms.difference_update(monoms)\n    zero = hp.ring.domain.zero\n    hpq = hp.ring.zero\n    if isinstance(hp.ring.domain, PolynomialRing):\n        crt_ = _chinese_remainder_reconstruction_multivariate\n    else:\n\n        def crt_(cp, cq, p, q):\n            return crt([p, q], [cp, cq], symmetric=True)[0]\n    for monom in monoms:\n        hpq[monom] = crt_(hp[monom], hq[monom], p, q)\n    for monom in hpmonoms:\n        hpq[monom] = crt_(hp[monom], zero, p, q)\n    for monom in hqmonoms:\n        hpq[monom] = crt_(zero, hq[monom], p, q)\n    return hpq",
            "def _chinese_remainder_reconstruction_multivariate(hp, hq, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Construct a polynomial `h_{pq}` in\\n    `\\\\mathbb{Z}_{p q}[x_0, \\\\ldots, x_{k-1}]` such that\\n\\n    .. math ::\\n\\n        h_{pq} = h_p \\\\; \\\\mathrm{mod} \\\\, p\\n\\n        h_{pq} = h_q \\\\; \\\\mathrm{mod} \\\\, q\\n\\n    for relatively prime integers `p` and `q` and polynomials\\n    `h_p` and `h_q` in `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]` and\\n    `\\\\mathbb{Z}_q[x_0, \\\\ldots, x_{k-1}]` respectively.\\n\\n    The coefficients of the polynomial `h_{pq}` are computed with the\\n    Chinese Remainder Theorem. The symmetric representation in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`,\\n    `\\\\mathbb{Z}_q[x_0, \\\\ldots, x_{k-1}]` and\\n    `\\\\mathbb{Z}_{p q}[x_0, \\\\ldots, x_{k-1}]` is used.\\n\\n    Parameters\\n    ==========\\n\\n    hp : PolyElement\\n        multivariate integer polynomial with coefficients in `\\\\mathbb{Z}_p`\\n    hq : PolyElement\\n        multivariate integer polynomial with coefficients in `\\\\mathbb{Z}_q`\\n    p : Integer\\n        modulus of `h_p`, relatively prime to `q`\\n    q : Integer\\n        modulus of `h_q`, relatively prime to `p`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _chinese_remainder_reconstruction_multivariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n    >>> p = 3\\n    >>> q = 5\\n\\n    >>> hp = x**3*y - x**2 - 1\\n    >>> hq = -x**3*y - 2*x*y**2 + 2\\n\\n    >>> hpq = _chinese_remainder_reconstruction_multivariate(hp, hq, p, q)\\n    >>> hpq\\n    4*x**3*y + 5*x**2 + 3*x*y**2 + 2\\n\\n    >>> hpq.trunc_ground(p) == hp\\n    True\\n    >>> hpq.trunc_ground(q) == hq\\n    True\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n    >>> p = 6\\n    >>> q = 5\\n\\n    >>> hp = 3*x**4 - y**3*z + z\\n    >>> hq = -2*x**4 + z\\n\\n    >>> hpq = _chinese_remainder_reconstruction_multivariate(hp, hq, p, q)\\n    >>> hpq\\n    3*x**4 + 5*y**3*z + z\\n\\n    >>> hpq.trunc_ground(p) == hp\\n    True\\n    >>> hpq.trunc_ground(q) == hq\\n    True\\n\\n    '\n    hpmonoms = set(hp.monoms())\n    hqmonoms = set(hq.monoms())\n    monoms = hpmonoms.intersection(hqmonoms)\n    hpmonoms.difference_update(monoms)\n    hqmonoms.difference_update(monoms)\n    zero = hp.ring.domain.zero\n    hpq = hp.ring.zero\n    if isinstance(hp.ring.domain, PolynomialRing):\n        crt_ = _chinese_remainder_reconstruction_multivariate\n    else:\n\n        def crt_(cp, cq, p, q):\n            return crt([p, q], [cp, cq], symmetric=True)[0]\n    for monom in monoms:\n        hpq[monom] = crt_(hp[monom], hq[monom], p, q)\n    for monom in hpmonoms:\n        hpq[monom] = crt_(hp[monom], zero, p, q)\n    for monom in hqmonoms:\n        hpq[monom] = crt_(zero, hq[monom], p, q)\n    return hpq",
            "def _chinese_remainder_reconstruction_multivariate(hp, hq, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Construct a polynomial `h_{pq}` in\\n    `\\\\mathbb{Z}_{p q}[x_0, \\\\ldots, x_{k-1}]` such that\\n\\n    .. math ::\\n\\n        h_{pq} = h_p \\\\; \\\\mathrm{mod} \\\\, p\\n\\n        h_{pq} = h_q \\\\; \\\\mathrm{mod} \\\\, q\\n\\n    for relatively prime integers `p` and `q` and polynomials\\n    `h_p` and `h_q` in `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]` and\\n    `\\\\mathbb{Z}_q[x_0, \\\\ldots, x_{k-1}]` respectively.\\n\\n    The coefficients of the polynomial `h_{pq}` are computed with the\\n    Chinese Remainder Theorem. The symmetric representation in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`,\\n    `\\\\mathbb{Z}_q[x_0, \\\\ldots, x_{k-1}]` and\\n    `\\\\mathbb{Z}_{p q}[x_0, \\\\ldots, x_{k-1}]` is used.\\n\\n    Parameters\\n    ==========\\n\\n    hp : PolyElement\\n        multivariate integer polynomial with coefficients in `\\\\mathbb{Z}_p`\\n    hq : PolyElement\\n        multivariate integer polynomial with coefficients in `\\\\mathbb{Z}_q`\\n    p : Integer\\n        modulus of `h_p`, relatively prime to `q`\\n    q : Integer\\n        modulus of `h_q`, relatively prime to `p`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _chinese_remainder_reconstruction_multivariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n    >>> p = 3\\n    >>> q = 5\\n\\n    >>> hp = x**3*y - x**2 - 1\\n    >>> hq = -x**3*y - 2*x*y**2 + 2\\n\\n    >>> hpq = _chinese_remainder_reconstruction_multivariate(hp, hq, p, q)\\n    >>> hpq\\n    4*x**3*y + 5*x**2 + 3*x*y**2 + 2\\n\\n    >>> hpq.trunc_ground(p) == hp\\n    True\\n    >>> hpq.trunc_ground(q) == hq\\n    True\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n    >>> p = 6\\n    >>> q = 5\\n\\n    >>> hp = 3*x**4 - y**3*z + z\\n    >>> hq = -2*x**4 + z\\n\\n    >>> hpq = _chinese_remainder_reconstruction_multivariate(hp, hq, p, q)\\n    >>> hpq\\n    3*x**4 + 5*y**3*z + z\\n\\n    >>> hpq.trunc_ground(p) == hp\\n    True\\n    >>> hpq.trunc_ground(q) == hq\\n    True\\n\\n    '\n    hpmonoms = set(hp.monoms())\n    hqmonoms = set(hq.monoms())\n    monoms = hpmonoms.intersection(hqmonoms)\n    hpmonoms.difference_update(monoms)\n    hqmonoms.difference_update(monoms)\n    zero = hp.ring.domain.zero\n    hpq = hp.ring.zero\n    if isinstance(hp.ring.domain, PolynomialRing):\n        crt_ = _chinese_remainder_reconstruction_multivariate\n    else:\n\n        def crt_(cp, cq, p, q):\n            return crt([p, q], [cp, cq], symmetric=True)[0]\n    for monom in monoms:\n        hpq[monom] = crt_(hp[monom], hq[monom], p, q)\n    for monom in hpmonoms:\n        hpq[monom] = crt_(hp[monom], zero, p, q)\n    for monom in hqmonoms:\n        hpq[monom] = crt_(zero, hq[monom], p, q)\n    return hpq",
            "def _chinese_remainder_reconstruction_multivariate(hp, hq, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Construct a polynomial `h_{pq}` in\\n    `\\\\mathbb{Z}_{p q}[x_0, \\\\ldots, x_{k-1}]` such that\\n\\n    .. math ::\\n\\n        h_{pq} = h_p \\\\; \\\\mathrm{mod} \\\\, p\\n\\n        h_{pq} = h_q \\\\; \\\\mathrm{mod} \\\\, q\\n\\n    for relatively prime integers `p` and `q` and polynomials\\n    `h_p` and `h_q` in `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]` and\\n    `\\\\mathbb{Z}_q[x_0, \\\\ldots, x_{k-1}]` respectively.\\n\\n    The coefficients of the polynomial `h_{pq}` are computed with the\\n    Chinese Remainder Theorem. The symmetric representation in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`,\\n    `\\\\mathbb{Z}_q[x_0, \\\\ldots, x_{k-1}]` and\\n    `\\\\mathbb{Z}_{p q}[x_0, \\\\ldots, x_{k-1}]` is used.\\n\\n    Parameters\\n    ==========\\n\\n    hp : PolyElement\\n        multivariate integer polynomial with coefficients in `\\\\mathbb{Z}_p`\\n    hq : PolyElement\\n        multivariate integer polynomial with coefficients in `\\\\mathbb{Z}_q`\\n    p : Integer\\n        modulus of `h_p`, relatively prime to `q`\\n    q : Integer\\n        modulus of `h_q`, relatively prime to `p`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _chinese_remainder_reconstruction_multivariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n    >>> p = 3\\n    >>> q = 5\\n\\n    >>> hp = x**3*y - x**2 - 1\\n    >>> hq = -x**3*y - 2*x*y**2 + 2\\n\\n    >>> hpq = _chinese_remainder_reconstruction_multivariate(hp, hq, p, q)\\n    >>> hpq\\n    4*x**3*y + 5*x**2 + 3*x*y**2 + 2\\n\\n    >>> hpq.trunc_ground(p) == hp\\n    True\\n    >>> hpq.trunc_ground(q) == hq\\n    True\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n    >>> p = 6\\n    >>> q = 5\\n\\n    >>> hp = 3*x**4 - y**3*z + z\\n    >>> hq = -2*x**4 + z\\n\\n    >>> hpq = _chinese_remainder_reconstruction_multivariate(hp, hq, p, q)\\n    >>> hpq\\n    3*x**4 + 5*y**3*z + z\\n\\n    >>> hpq.trunc_ground(p) == hp\\n    True\\n    >>> hpq.trunc_ground(q) == hq\\n    True\\n\\n    '\n    hpmonoms = set(hp.monoms())\n    hqmonoms = set(hq.monoms())\n    monoms = hpmonoms.intersection(hqmonoms)\n    hpmonoms.difference_update(monoms)\n    hqmonoms.difference_update(monoms)\n    zero = hp.ring.domain.zero\n    hpq = hp.ring.zero\n    if isinstance(hp.ring.domain, PolynomialRing):\n        crt_ = _chinese_remainder_reconstruction_multivariate\n    else:\n\n        def crt_(cp, cq, p, q):\n            return crt([p, q], [cp, cq], symmetric=True)[0]\n    for monom in monoms:\n        hpq[monom] = crt_(hp[monom], hq[monom], p, q)\n    for monom in hpmonoms:\n        hpq[monom] = crt_(hp[monom], zero, p, q)\n    for monom in hqmonoms:\n        hpq[monom] = crt_(zero, hq[monom], p, q)\n    return hpq",
            "def _chinese_remainder_reconstruction_multivariate(hp, hq, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Construct a polynomial `h_{pq}` in\\n    `\\\\mathbb{Z}_{p q}[x_0, \\\\ldots, x_{k-1}]` such that\\n\\n    .. math ::\\n\\n        h_{pq} = h_p \\\\; \\\\mathrm{mod} \\\\, p\\n\\n        h_{pq} = h_q \\\\; \\\\mathrm{mod} \\\\, q\\n\\n    for relatively prime integers `p` and `q` and polynomials\\n    `h_p` and `h_q` in `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]` and\\n    `\\\\mathbb{Z}_q[x_0, \\\\ldots, x_{k-1}]` respectively.\\n\\n    The coefficients of the polynomial `h_{pq}` are computed with the\\n    Chinese Remainder Theorem. The symmetric representation in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`,\\n    `\\\\mathbb{Z}_q[x_0, \\\\ldots, x_{k-1}]` and\\n    `\\\\mathbb{Z}_{p q}[x_0, \\\\ldots, x_{k-1}]` is used.\\n\\n    Parameters\\n    ==========\\n\\n    hp : PolyElement\\n        multivariate integer polynomial with coefficients in `\\\\mathbb{Z}_p`\\n    hq : PolyElement\\n        multivariate integer polynomial with coefficients in `\\\\mathbb{Z}_q`\\n    p : Integer\\n        modulus of `h_p`, relatively prime to `q`\\n    q : Integer\\n        modulus of `h_q`, relatively prime to `p`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _chinese_remainder_reconstruction_multivariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n    >>> p = 3\\n    >>> q = 5\\n\\n    >>> hp = x**3*y - x**2 - 1\\n    >>> hq = -x**3*y - 2*x*y**2 + 2\\n\\n    >>> hpq = _chinese_remainder_reconstruction_multivariate(hp, hq, p, q)\\n    >>> hpq\\n    4*x**3*y + 5*x**2 + 3*x*y**2 + 2\\n\\n    >>> hpq.trunc_ground(p) == hp\\n    True\\n    >>> hpq.trunc_ground(q) == hq\\n    True\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n    >>> p = 6\\n    >>> q = 5\\n\\n    >>> hp = 3*x**4 - y**3*z + z\\n    >>> hq = -2*x**4 + z\\n\\n    >>> hpq = _chinese_remainder_reconstruction_multivariate(hp, hq, p, q)\\n    >>> hpq\\n    3*x**4 + 5*y**3*z + z\\n\\n    >>> hpq.trunc_ground(p) == hp\\n    True\\n    >>> hpq.trunc_ground(q) == hq\\n    True\\n\\n    '\n    hpmonoms = set(hp.monoms())\n    hqmonoms = set(hq.monoms())\n    monoms = hpmonoms.intersection(hqmonoms)\n    hpmonoms.difference_update(monoms)\n    hqmonoms.difference_update(monoms)\n    zero = hp.ring.domain.zero\n    hpq = hp.ring.zero\n    if isinstance(hp.ring.domain, PolynomialRing):\n        crt_ = _chinese_remainder_reconstruction_multivariate\n    else:\n\n        def crt_(cp, cq, p, q):\n            return crt([p, q], [cp, cq], symmetric=True)[0]\n    for monom in monoms:\n        hpq[monom] = crt_(hp[monom], hq[monom], p, q)\n    for monom in hpmonoms:\n        hpq[monom] = crt_(hp[monom], zero, p, q)\n    for monom in hqmonoms:\n        hpq[monom] = crt_(zero, hq[monom], p, q)\n    return hpq"
        ]
    },
    {
        "func_name": "_interpolate_multivariate",
        "original": "def _interpolate_multivariate(evalpoints, hpeval, ring, i, p, ground=False):\n    \"\"\"\n    Reconstruct a polynomial `h_p` in `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`\n    from a list of evaluation points in `\\\\mathbb{Z}_p` and a list of\n    polynomials in\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{i-1}, x_{i+1}, \\\\ldots, x_{k-1}]`, which\n    are the images of `h_p` evaluated in the variable `x_i`.\n\n    It is also possible to reconstruct a parameter of the ground domain,\n    i.e. if `h_p` is a polynomial over `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`.\n    In this case, one has to set ``ground=True``.\n\n    Parameters\n    ==========\n\n    evalpoints : list of Integer objects\n        list of evaluation points in `\\\\mathbb{Z}_p`\n    hpeval : list of PolyElement objects\n        list of polynomials in (resp. over)\n        `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{i-1}, x_{i+1}, \\\\ldots, x_{k-1}]`,\n        images of `h_p` evaluated in the variable `x_i`\n    ring : PolyRing\n        `h_p` will be an element of this ring\n    i : Integer\n        index of the variable which has to be reconstructed\n    p : Integer\n        prime number, modulus of `h_p`\n    ground : Boolean\n        indicates whether `x_i` is in the ground domain, default is\n        ``False``\n\n    Returns\n    =======\n\n    hp : PolyElement\n        interpolated polynomial in (resp. over)\n        `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`\n\n    \"\"\"\n    hp = ring.zero\n    if ground:\n        domain = ring.domain.domain\n        y = ring.domain.gens[i]\n    else:\n        domain = ring.domain\n        y = ring.gens[i]\n    for (a, hpa) in zip(evalpoints, hpeval):\n        numer = ring.one\n        denom = domain.one\n        for b in evalpoints:\n            if b == a:\n                continue\n            numer *= y - b\n            denom *= a - b\n        denom = domain.invert(denom, p)\n        coeff = numer.mul_ground(denom)\n        hp += hpa.set_ring(ring) * coeff\n    return hp.trunc_ground(p)",
        "mutated": [
            "def _interpolate_multivariate(evalpoints, hpeval, ring, i, p, ground=False):\n    if False:\n        i = 10\n    '\\n    Reconstruct a polynomial `h_p` in `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`\\n    from a list of evaluation points in `\\\\mathbb{Z}_p` and a list of\\n    polynomials in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{i-1}, x_{i+1}, \\\\ldots, x_{k-1}]`, which\\n    are the images of `h_p` evaluated in the variable `x_i`.\\n\\n    It is also possible to reconstruct a parameter of the ground domain,\\n    i.e. if `h_p` is a polynomial over `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`.\\n    In this case, one has to set ``ground=True``.\\n\\n    Parameters\\n    ==========\\n\\n    evalpoints : list of Integer objects\\n        list of evaluation points in `\\\\mathbb{Z}_p`\\n    hpeval : list of PolyElement objects\\n        list of polynomials in (resp. over)\\n        `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{i-1}, x_{i+1}, \\\\ldots, x_{k-1}]`,\\n        images of `h_p` evaluated in the variable `x_i`\\n    ring : PolyRing\\n        `h_p` will be an element of this ring\\n    i : Integer\\n        index of the variable which has to be reconstructed\\n    p : Integer\\n        prime number, modulus of `h_p`\\n    ground : Boolean\\n        indicates whether `x_i` is in the ground domain, default is\\n        ``False``\\n\\n    Returns\\n    =======\\n\\n    hp : PolyElement\\n        interpolated polynomial in (resp. over)\\n        `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`\\n\\n    '\n    hp = ring.zero\n    if ground:\n        domain = ring.domain.domain\n        y = ring.domain.gens[i]\n    else:\n        domain = ring.domain\n        y = ring.gens[i]\n    for (a, hpa) in zip(evalpoints, hpeval):\n        numer = ring.one\n        denom = domain.one\n        for b in evalpoints:\n            if b == a:\n                continue\n            numer *= y - b\n            denom *= a - b\n        denom = domain.invert(denom, p)\n        coeff = numer.mul_ground(denom)\n        hp += hpa.set_ring(ring) * coeff\n    return hp.trunc_ground(p)",
            "def _interpolate_multivariate(evalpoints, hpeval, ring, i, p, ground=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Reconstruct a polynomial `h_p` in `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`\\n    from a list of evaluation points in `\\\\mathbb{Z}_p` and a list of\\n    polynomials in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{i-1}, x_{i+1}, \\\\ldots, x_{k-1}]`, which\\n    are the images of `h_p` evaluated in the variable `x_i`.\\n\\n    It is also possible to reconstruct a parameter of the ground domain,\\n    i.e. if `h_p` is a polynomial over `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`.\\n    In this case, one has to set ``ground=True``.\\n\\n    Parameters\\n    ==========\\n\\n    evalpoints : list of Integer objects\\n        list of evaluation points in `\\\\mathbb{Z}_p`\\n    hpeval : list of PolyElement objects\\n        list of polynomials in (resp. over)\\n        `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{i-1}, x_{i+1}, \\\\ldots, x_{k-1}]`,\\n        images of `h_p` evaluated in the variable `x_i`\\n    ring : PolyRing\\n        `h_p` will be an element of this ring\\n    i : Integer\\n        index of the variable which has to be reconstructed\\n    p : Integer\\n        prime number, modulus of `h_p`\\n    ground : Boolean\\n        indicates whether `x_i` is in the ground domain, default is\\n        ``False``\\n\\n    Returns\\n    =======\\n\\n    hp : PolyElement\\n        interpolated polynomial in (resp. over)\\n        `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`\\n\\n    '\n    hp = ring.zero\n    if ground:\n        domain = ring.domain.domain\n        y = ring.domain.gens[i]\n    else:\n        domain = ring.domain\n        y = ring.gens[i]\n    for (a, hpa) in zip(evalpoints, hpeval):\n        numer = ring.one\n        denom = domain.one\n        for b in evalpoints:\n            if b == a:\n                continue\n            numer *= y - b\n            denom *= a - b\n        denom = domain.invert(denom, p)\n        coeff = numer.mul_ground(denom)\n        hp += hpa.set_ring(ring) * coeff\n    return hp.trunc_ground(p)",
            "def _interpolate_multivariate(evalpoints, hpeval, ring, i, p, ground=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Reconstruct a polynomial `h_p` in `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`\\n    from a list of evaluation points in `\\\\mathbb{Z}_p` and a list of\\n    polynomials in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{i-1}, x_{i+1}, \\\\ldots, x_{k-1}]`, which\\n    are the images of `h_p` evaluated in the variable `x_i`.\\n\\n    It is also possible to reconstruct a parameter of the ground domain,\\n    i.e. if `h_p` is a polynomial over `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`.\\n    In this case, one has to set ``ground=True``.\\n\\n    Parameters\\n    ==========\\n\\n    evalpoints : list of Integer objects\\n        list of evaluation points in `\\\\mathbb{Z}_p`\\n    hpeval : list of PolyElement objects\\n        list of polynomials in (resp. over)\\n        `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{i-1}, x_{i+1}, \\\\ldots, x_{k-1}]`,\\n        images of `h_p` evaluated in the variable `x_i`\\n    ring : PolyRing\\n        `h_p` will be an element of this ring\\n    i : Integer\\n        index of the variable which has to be reconstructed\\n    p : Integer\\n        prime number, modulus of `h_p`\\n    ground : Boolean\\n        indicates whether `x_i` is in the ground domain, default is\\n        ``False``\\n\\n    Returns\\n    =======\\n\\n    hp : PolyElement\\n        interpolated polynomial in (resp. over)\\n        `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`\\n\\n    '\n    hp = ring.zero\n    if ground:\n        domain = ring.domain.domain\n        y = ring.domain.gens[i]\n    else:\n        domain = ring.domain\n        y = ring.gens[i]\n    for (a, hpa) in zip(evalpoints, hpeval):\n        numer = ring.one\n        denom = domain.one\n        for b in evalpoints:\n            if b == a:\n                continue\n            numer *= y - b\n            denom *= a - b\n        denom = domain.invert(denom, p)\n        coeff = numer.mul_ground(denom)\n        hp += hpa.set_ring(ring) * coeff\n    return hp.trunc_ground(p)",
            "def _interpolate_multivariate(evalpoints, hpeval, ring, i, p, ground=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Reconstruct a polynomial `h_p` in `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`\\n    from a list of evaluation points in `\\\\mathbb{Z}_p` and a list of\\n    polynomials in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{i-1}, x_{i+1}, \\\\ldots, x_{k-1}]`, which\\n    are the images of `h_p` evaluated in the variable `x_i`.\\n\\n    It is also possible to reconstruct a parameter of the ground domain,\\n    i.e. if `h_p` is a polynomial over `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`.\\n    In this case, one has to set ``ground=True``.\\n\\n    Parameters\\n    ==========\\n\\n    evalpoints : list of Integer objects\\n        list of evaluation points in `\\\\mathbb{Z}_p`\\n    hpeval : list of PolyElement objects\\n        list of polynomials in (resp. over)\\n        `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{i-1}, x_{i+1}, \\\\ldots, x_{k-1}]`,\\n        images of `h_p` evaluated in the variable `x_i`\\n    ring : PolyRing\\n        `h_p` will be an element of this ring\\n    i : Integer\\n        index of the variable which has to be reconstructed\\n    p : Integer\\n        prime number, modulus of `h_p`\\n    ground : Boolean\\n        indicates whether `x_i` is in the ground domain, default is\\n        ``False``\\n\\n    Returns\\n    =======\\n\\n    hp : PolyElement\\n        interpolated polynomial in (resp. over)\\n        `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`\\n\\n    '\n    hp = ring.zero\n    if ground:\n        domain = ring.domain.domain\n        y = ring.domain.gens[i]\n    else:\n        domain = ring.domain\n        y = ring.gens[i]\n    for (a, hpa) in zip(evalpoints, hpeval):\n        numer = ring.one\n        denom = domain.one\n        for b in evalpoints:\n            if b == a:\n                continue\n            numer *= y - b\n            denom *= a - b\n        denom = domain.invert(denom, p)\n        coeff = numer.mul_ground(denom)\n        hp += hpa.set_ring(ring) * coeff\n    return hp.trunc_ground(p)",
            "def _interpolate_multivariate(evalpoints, hpeval, ring, i, p, ground=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Reconstruct a polynomial `h_p` in `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`\\n    from a list of evaluation points in `\\\\mathbb{Z}_p` and a list of\\n    polynomials in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{i-1}, x_{i+1}, \\\\ldots, x_{k-1}]`, which\\n    are the images of `h_p` evaluated in the variable `x_i`.\\n\\n    It is also possible to reconstruct a parameter of the ground domain,\\n    i.e. if `h_p` is a polynomial over `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`.\\n    In this case, one has to set ``ground=True``.\\n\\n    Parameters\\n    ==========\\n\\n    evalpoints : list of Integer objects\\n        list of evaluation points in `\\\\mathbb{Z}_p`\\n    hpeval : list of PolyElement objects\\n        list of polynomials in (resp. over)\\n        `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{i-1}, x_{i+1}, \\\\ldots, x_{k-1}]`,\\n        images of `h_p` evaluated in the variable `x_i`\\n    ring : PolyRing\\n        `h_p` will be an element of this ring\\n    i : Integer\\n        index of the variable which has to be reconstructed\\n    p : Integer\\n        prime number, modulus of `h_p`\\n    ground : Boolean\\n        indicates whether `x_i` is in the ground domain, default is\\n        ``False``\\n\\n    Returns\\n    =======\\n\\n    hp : PolyElement\\n        interpolated polynomial in (resp. over)\\n        `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`\\n\\n    '\n    hp = ring.zero\n    if ground:\n        domain = ring.domain.domain\n        y = ring.domain.gens[i]\n    else:\n        domain = ring.domain\n        y = ring.gens[i]\n    for (a, hpa) in zip(evalpoints, hpeval):\n        numer = ring.one\n        denom = domain.one\n        for b in evalpoints:\n            if b == a:\n                continue\n            numer *= y - b\n            denom *= a - b\n        denom = domain.invert(denom, p)\n        coeff = numer.mul_ground(denom)\n        hp += hpa.set_ring(ring) * coeff\n    return hp.trunc_ground(p)"
        ]
    },
    {
        "func_name": "modgcd_bivariate",
        "original": "def modgcd_bivariate(f, g):\n    \"\"\"\n    Computes the GCD of two polynomials in `\\\\mathbb{Z}[x, y]` using a\n    modular algorithm.\n\n    The algorithm computes the GCD of two bivariate integer polynomials\n    `f` and `g` by calculating the GCD in `\\\\mathbb{Z}_p[x, y]` for\n    suitable primes `p` and then reconstructing the coefficients with the\n    Chinese Remainder Theorem. To compute the bivariate GCD over\n    `\\\\mathbb{Z}_p`, the polynomials `f \\\\; \\\\mathrm{mod} \\\\, p` and\n    `g \\\\; \\\\mathrm{mod} \\\\, p` are evaluated at `y = a` for certain\n    `a \\\\in \\\\mathbb{Z}_p` and then their univariate GCD in `\\\\mathbb{Z}_p[x]`\n    is computed. Interpolating those yields the bivariate GCD in\n    `\\\\mathbb{Z}_p[x, y]`. To verify the result in `\\\\mathbb{Z}[x, y]`, trial\n    division is done, but only for candidates which are very likely the\n    desired GCD.\n\n    Parameters\n    ==========\n\n    f : PolyElement\n        bivariate integer polynomial\n    g : PolyElement\n        bivariate integer polynomial\n\n    Returns\n    =======\n\n    h : PolyElement\n        GCD of the polynomials `f` and `g`\n    cff : PolyElement\n        cofactor of `f`, i.e. `\\\\frac{f}{h}`\n    cfg : PolyElement\n        cofactor of `g`, i.e. `\\\\frac{g}{h}`\n\n    Examples\n    ========\n\n    >>> from sympy.polys.modulargcd import modgcd_bivariate\n    >>> from sympy.polys import ring, ZZ\n\n    >>> R, x, y = ring(\"x, y\", ZZ)\n\n    >>> f = x**2 - y**2\n    >>> g = x**2 + 2*x*y + y**2\n\n    >>> h, cff, cfg = modgcd_bivariate(f, g)\n    >>> h, cff, cfg\n    (x + y, x - y, x + y)\n\n    >>> cff * h == f\n    True\n    >>> cfg * h == g\n    True\n\n    >>> f = x**2*y - x**2 - 4*y + 4\n    >>> g = x + 2\n\n    >>> h, cff, cfg = modgcd_bivariate(f, g)\n    >>> h, cff, cfg\n    (x + 2, x*y - x - 2*y + 2, 1)\n\n    >>> cff * h == f\n    True\n    >>> cfg * h == g\n    True\n\n    References\n    ==========\n\n    1. [Monagan00]_\n\n    \"\"\"\n    assert f.ring == g.ring and f.ring.domain.is_ZZ\n    result = _trivial_gcd(f, g)\n    if result is not None:\n        return result\n    ring = f.ring\n    (cf, f) = f.primitive()\n    (cg, g) = g.primitive()\n    ch = ring.domain.gcd(cf, cg)\n    (xbound, ycontbound) = _degree_bound_bivariate(f, g)\n    if xbound == ycontbound == 0:\n        return (ring(ch), f.mul_ground(cf // ch), g.mul_ground(cg // ch))\n    fswap = _swap(f, 1)\n    gswap = _swap(g, 1)\n    degyf = fswap.degree()\n    degyg = gswap.degree()\n    (ybound, xcontbound) = _degree_bound_bivariate(fswap, gswap)\n    if ybound == xcontbound == 0:\n        return (ring(ch), f.mul_ground(cf // ch), g.mul_ground(cg // ch))\n    gamma1 = ring.domain.gcd(f.LC, g.LC)\n    gamma2 = ring.domain.gcd(fswap.LC, gswap.LC)\n    badprimes = gamma1 * gamma2\n    m = 1\n    p = 1\n    while True:\n        p = nextprime(p)\n        while badprimes % p == 0:\n            p = nextprime(p)\n        fp = f.trunc_ground(p)\n        gp = g.trunc_ground(p)\n        (contfp, fp) = _primitive(fp, p)\n        (contgp, gp) = _primitive(gp, p)\n        conthp = _gf_gcd(contfp, contgp, p)\n        degconthp = conthp.degree()\n        if degconthp > ycontbound:\n            continue\n        elif degconthp < ycontbound:\n            m = 1\n            ycontbound = degconthp\n            continue\n        delta = _gf_gcd(_LC(fp), _LC(gp), p)\n        degcontfp = contfp.degree()\n        degcontgp = contgp.degree()\n        degdelta = delta.degree()\n        N = min(degyf - degcontfp, degyg - degcontgp, ybound - ycontbound + degdelta) + 1\n        if p < N:\n            continue\n        n = 0\n        evalpoints = []\n        hpeval = []\n        unlucky = False\n        for a in range(p):\n            deltaa = delta.evaluate(0, a)\n            if not deltaa % p:\n                continue\n            fpa = fp.evaluate(1, a).trunc_ground(p)\n            gpa = gp.evaluate(1, a).trunc_ground(p)\n            hpa = _gf_gcd(fpa, gpa, p)\n            deghpa = hpa.degree()\n            if deghpa > xbound:\n                continue\n            elif deghpa < xbound:\n                m = 1\n                xbound = deghpa\n                unlucky = True\n                break\n            hpa = hpa.mul_ground(deltaa).trunc_ground(p)\n            evalpoints.append(a)\n            hpeval.append(hpa)\n            n += 1\n            if n == N:\n                break\n        if unlucky:\n            continue\n        if n < N:\n            continue\n        hp = _interpolate_multivariate(evalpoints, hpeval, ring, 1, p)\n        hp = _primitive(hp, p)[1]\n        hp = hp * conthp.set_ring(ring)\n        degyhp = hp.degree(1)\n        if degyhp > ybound:\n            continue\n        if degyhp < ybound:\n            m = 1\n            ybound = degyhp\n            continue\n        hp = hp.mul_ground(gamma1).trunc_ground(p)\n        if m == 1:\n            m = p\n            hlastm = hp\n            continue\n        hm = _chinese_remainder_reconstruction_multivariate(hp, hlastm, p, m)\n        m *= p\n        if not hm == hlastm:\n            hlastm = hm\n            continue\n        h = hm.quo_ground(hm.content())\n        (fquo, frem) = f.div(h)\n        (gquo, grem) = g.div(h)\n        if not frem and (not grem):\n            if h.LC < 0:\n                ch = -ch\n            h = h.mul_ground(ch)\n            cff = fquo.mul_ground(cf // ch)\n            cfg = gquo.mul_ground(cg // ch)\n            return (h, cff, cfg)",
        "mutated": [
            "def modgcd_bivariate(f, g):\n    if False:\n        i = 10\n    '\\n    Computes the GCD of two polynomials in `\\\\mathbb{Z}[x, y]` using a\\n    modular algorithm.\\n\\n    The algorithm computes the GCD of two bivariate integer polynomials\\n    `f` and `g` by calculating the GCD in `\\\\mathbb{Z}_p[x, y]` for\\n    suitable primes `p` and then reconstructing the coefficients with the\\n    Chinese Remainder Theorem. To compute the bivariate GCD over\\n    `\\\\mathbb{Z}_p`, the polynomials `f \\\\; \\\\mathrm{mod} \\\\, p` and\\n    `g \\\\; \\\\mathrm{mod} \\\\, p` are evaluated at `y = a` for certain\\n    `a \\\\in \\\\mathbb{Z}_p` and then their univariate GCD in `\\\\mathbb{Z}_p[x]`\\n    is computed. Interpolating those yields the bivariate GCD in\\n    `\\\\mathbb{Z}_p[x, y]`. To verify the result in `\\\\mathbb{Z}[x, y]`, trial\\n    division is done, but only for candidates which are very likely the\\n    desired GCD.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        bivariate integer polynomial\\n    g : PolyElement\\n        bivariate integer polynomial\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of the polynomials `f` and `g`\\n    cff : PolyElement\\n        cofactor of `f`, i.e. `\\\\frac{f}{h}`\\n    cfg : PolyElement\\n        cofactor of `g`, i.e. `\\\\frac{g}{h}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import modgcd_bivariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n\\n    >>> f = x**2 - y**2\\n    >>> g = x**2 + 2*x*y + y**2\\n\\n    >>> h, cff, cfg = modgcd_bivariate(f, g)\\n    >>> h, cff, cfg\\n    (x + y, x - y, x + y)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> f = x**2*y - x**2 - 4*y + 4\\n    >>> g = x + 2\\n\\n    >>> h, cff, cfg = modgcd_bivariate(f, g)\\n    >>> h, cff, cfg\\n    (x + 2, x*y - x - 2*y + 2, 1)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n\\n    '\n    assert f.ring == g.ring and f.ring.domain.is_ZZ\n    result = _trivial_gcd(f, g)\n    if result is not None:\n        return result\n    ring = f.ring\n    (cf, f) = f.primitive()\n    (cg, g) = g.primitive()\n    ch = ring.domain.gcd(cf, cg)\n    (xbound, ycontbound) = _degree_bound_bivariate(f, g)\n    if xbound == ycontbound == 0:\n        return (ring(ch), f.mul_ground(cf // ch), g.mul_ground(cg // ch))\n    fswap = _swap(f, 1)\n    gswap = _swap(g, 1)\n    degyf = fswap.degree()\n    degyg = gswap.degree()\n    (ybound, xcontbound) = _degree_bound_bivariate(fswap, gswap)\n    if ybound == xcontbound == 0:\n        return (ring(ch), f.mul_ground(cf // ch), g.mul_ground(cg // ch))\n    gamma1 = ring.domain.gcd(f.LC, g.LC)\n    gamma2 = ring.domain.gcd(fswap.LC, gswap.LC)\n    badprimes = gamma1 * gamma2\n    m = 1\n    p = 1\n    while True:\n        p = nextprime(p)\n        while badprimes % p == 0:\n            p = nextprime(p)\n        fp = f.trunc_ground(p)\n        gp = g.trunc_ground(p)\n        (contfp, fp) = _primitive(fp, p)\n        (contgp, gp) = _primitive(gp, p)\n        conthp = _gf_gcd(contfp, contgp, p)\n        degconthp = conthp.degree()\n        if degconthp > ycontbound:\n            continue\n        elif degconthp < ycontbound:\n            m = 1\n            ycontbound = degconthp\n            continue\n        delta = _gf_gcd(_LC(fp), _LC(gp), p)\n        degcontfp = contfp.degree()\n        degcontgp = contgp.degree()\n        degdelta = delta.degree()\n        N = min(degyf - degcontfp, degyg - degcontgp, ybound - ycontbound + degdelta) + 1\n        if p < N:\n            continue\n        n = 0\n        evalpoints = []\n        hpeval = []\n        unlucky = False\n        for a in range(p):\n            deltaa = delta.evaluate(0, a)\n            if not deltaa % p:\n                continue\n            fpa = fp.evaluate(1, a).trunc_ground(p)\n            gpa = gp.evaluate(1, a).trunc_ground(p)\n            hpa = _gf_gcd(fpa, gpa, p)\n            deghpa = hpa.degree()\n            if deghpa > xbound:\n                continue\n            elif deghpa < xbound:\n                m = 1\n                xbound = deghpa\n                unlucky = True\n                break\n            hpa = hpa.mul_ground(deltaa).trunc_ground(p)\n            evalpoints.append(a)\n            hpeval.append(hpa)\n            n += 1\n            if n == N:\n                break\n        if unlucky:\n            continue\n        if n < N:\n            continue\n        hp = _interpolate_multivariate(evalpoints, hpeval, ring, 1, p)\n        hp = _primitive(hp, p)[1]\n        hp = hp * conthp.set_ring(ring)\n        degyhp = hp.degree(1)\n        if degyhp > ybound:\n            continue\n        if degyhp < ybound:\n            m = 1\n            ybound = degyhp\n            continue\n        hp = hp.mul_ground(gamma1).trunc_ground(p)\n        if m == 1:\n            m = p\n            hlastm = hp\n            continue\n        hm = _chinese_remainder_reconstruction_multivariate(hp, hlastm, p, m)\n        m *= p\n        if not hm == hlastm:\n            hlastm = hm\n            continue\n        h = hm.quo_ground(hm.content())\n        (fquo, frem) = f.div(h)\n        (gquo, grem) = g.div(h)\n        if not frem and (not grem):\n            if h.LC < 0:\n                ch = -ch\n            h = h.mul_ground(ch)\n            cff = fquo.mul_ground(cf // ch)\n            cfg = gquo.mul_ground(cg // ch)\n            return (h, cff, cfg)",
            "def modgcd_bivariate(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Computes the GCD of two polynomials in `\\\\mathbb{Z}[x, y]` using a\\n    modular algorithm.\\n\\n    The algorithm computes the GCD of two bivariate integer polynomials\\n    `f` and `g` by calculating the GCD in `\\\\mathbb{Z}_p[x, y]` for\\n    suitable primes `p` and then reconstructing the coefficients with the\\n    Chinese Remainder Theorem. To compute the bivariate GCD over\\n    `\\\\mathbb{Z}_p`, the polynomials `f \\\\; \\\\mathrm{mod} \\\\, p` and\\n    `g \\\\; \\\\mathrm{mod} \\\\, p` are evaluated at `y = a` for certain\\n    `a \\\\in \\\\mathbb{Z}_p` and then their univariate GCD in `\\\\mathbb{Z}_p[x]`\\n    is computed. Interpolating those yields the bivariate GCD in\\n    `\\\\mathbb{Z}_p[x, y]`. To verify the result in `\\\\mathbb{Z}[x, y]`, trial\\n    division is done, but only for candidates which are very likely the\\n    desired GCD.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        bivariate integer polynomial\\n    g : PolyElement\\n        bivariate integer polynomial\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of the polynomials `f` and `g`\\n    cff : PolyElement\\n        cofactor of `f`, i.e. `\\\\frac{f}{h}`\\n    cfg : PolyElement\\n        cofactor of `g`, i.e. `\\\\frac{g}{h}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import modgcd_bivariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n\\n    >>> f = x**2 - y**2\\n    >>> g = x**2 + 2*x*y + y**2\\n\\n    >>> h, cff, cfg = modgcd_bivariate(f, g)\\n    >>> h, cff, cfg\\n    (x + y, x - y, x + y)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> f = x**2*y - x**2 - 4*y + 4\\n    >>> g = x + 2\\n\\n    >>> h, cff, cfg = modgcd_bivariate(f, g)\\n    >>> h, cff, cfg\\n    (x + 2, x*y - x - 2*y + 2, 1)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n\\n    '\n    assert f.ring == g.ring and f.ring.domain.is_ZZ\n    result = _trivial_gcd(f, g)\n    if result is not None:\n        return result\n    ring = f.ring\n    (cf, f) = f.primitive()\n    (cg, g) = g.primitive()\n    ch = ring.domain.gcd(cf, cg)\n    (xbound, ycontbound) = _degree_bound_bivariate(f, g)\n    if xbound == ycontbound == 0:\n        return (ring(ch), f.mul_ground(cf // ch), g.mul_ground(cg // ch))\n    fswap = _swap(f, 1)\n    gswap = _swap(g, 1)\n    degyf = fswap.degree()\n    degyg = gswap.degree()\n    (ybound, xcontbound) = _degree_bound_bivariate(fswap, gswap)\n    if ybound == xcontbound == 0:\n        return (ring(ch), f.mul_ground(cf // ch), g.mul_ground(cg // ch))\n    gamma1 = ring.domain.gcd(f.LC, g.LC)\n    gamma2 = ring.domain.gcd(fswap.LC, gswap.LC)\n    badprimes = gamma1 * gamma2\n    m = 1\n    p = 1\n    while True:\n        p = nextprime(p)\n        while badprimes % p == 0:\n            p = nextprime(p)\n        fp = f.trunc_ground(p)\n        gp = g.trunc_ground(p)\n        (contfp, fp) = _primitive(fp, p)\n        (contgp, gp) = _primitive(gp, p)\n        conthp = _gf_gcd(contfp, contgp, p)\n        degconthp = conthp.degree()\n        if degconthp > ycontbound:\n            continue\n        elif degconthp < ycontbound:\n            m = 1\n            ycontbound = degconthp\n            continue\n        delta = _gf_gcd(_LC(fp), _LC(gp), p)\n        degcontfp = contfp.degree()\n        degcontgp = contgp.degree()\n        degdelta = delta.degree()\n        N = min(degyf - degcontfp, degyg - degcontgp, ybound - ycontbound + degdelta) + 1\n        if p < N:\n            continue\n        n = 0\n        evalpoints = []\n        hpeval = []\n        unlucky = False\n        for a in range(p):\n            deltaa = delta.evaluate(0, a)\n            if not deltaa % p:\n                continue\n            fpa = fp.evaluate(1, a).trunc_ground(p)\n            gpa = gp.evaluate(1, a).trunc_ground(p)\n            hpa = _gf_gcd(fpa, gpa, p)\n            deghpa = hpa.degree()\n            if deghpa > xbound:\n                continue\n            elif deghpa < xbound:\n                m = 1\n                xbound = deghpa\n                unlucky = True\n                break\n            hpa = hpa.mul_ground(deltaa).trunc_ground(p)\n            evalpoints.append(a)\n            hpeval.append(hpa)\n            n += 1\n            if n == N:\n                break\n        if unlucky:\n            continue\n        if n < N:\n            continue\n        hp = _interpolate_multivariate(evalpoints, hpeval, ring, 1, p)\n        hp = _primitive(hp, p)[1]\n        hp = hp * conthp.set_ring(ring)\n        degyhp = hp.degree(1)\n        if degyhp > ybound:\n            continue\n        if degyhp < ybound:\n            m = 1\n            ybound = degyhp\n            continue\n        hp = hp.mul_ground(gamma1).trunc_ground(p)\n        if m == 1:\n            m = p\n            hlastm = hp\n            continue\n        hm = _chinese_remainder_reconstruction_multivariate(hp, hlastm, p, m)\n        m *= p\n        if not hm == hlastm:\n            hlastm = hm\n            continue\n        h = hm.quo_ground(hm.content())\n        (fquo, frem) = f.div(h)\n        (gquo, grem) = g.div(h)\n        if not frem and (not grem):\n            if h.LC < 0:\n                ch = -ch\n            h = h.mul_ground(ch)\n            cff = fquo.mul_ground(cf // ch)\n            cfg = gquo.mul_ground(cg // ch)\n            return (h, cff, cfg)",
            "def modgcd_bivariate(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Computes the GCD of two polynomials in `\\\\mathbb{Z}[x, y]` using a\\n    modular algorithm.\\n\\n    The algorithm computes the GCD of two bivariate integer polynomials\\n    `f` and `g` by calculating the GCD in `\\\\mathbb{Z}_p[x, y]` for\\n    suitable primes `p` and then reconstructing the coefficients with the\\n    Chinese Remainder Theorem. To compute the bivariate GCD over\\n    `\\\\mathbb{Z}_p`, the polynomials `f \\\\; \\\\mathrm{mod} \\\\, p` and\\n    `g \\\\; \\\\mathrm{mod} \\\\, p` are evaluated at `y = a` for certain\\n    `a \\\\in \\\\mathbb{Z}_p` and then their univariate GCD in `\\\\mathbb{Z}_p[x]`\\n    is computed. Interpolating those yields the bivariate GCD in\\n    `\\\\mathbb{Z}_p[x, y]`. To verify the result in `\\\\mathbb{Z}[x, y]`, trial\\n    division is done, but only for candidates which are very likely the\\n    desired GCD.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        bivariate integer polynomial\\n    g : PolyElement\\n        bivariate integer polynomial\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of the polynomials `f` and `g`\\n    cff : PolyElement\\n        cofactor of `f`, i.e. `\\\\frac{f}{h}`\\n    cfg : PolyElement\\n        cofactor of `g`, i.e. `\\\\frac{g}{h}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import modgcd_bivariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n\\n    >>> f = x**2 - y**2\\n    >>> g = x**2 + 2*x*y + y**2\\n\\n    >>> h, cff, cfg = modgcd_bivariate(f, g)\\n    >>> h, cff, cfg\\n    (x + y, x - y, x + y)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> f = x**2*y - x**2 - 4*y + 4\\n    >>> g = x + 2\\n\\n    >>> h, cff, cfg = modgcd_bivariate(f, g)\\n    >>> h, cff, cfg\\n    (x + 2, x*y - x - 2*y + 2, 1)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n\\n    '\n    assert f.ring == g.ring and f.ring.domain.is_ZZ\n    result = _trivial_gcd(f, g)\n    if result is not None:\n        return result\n    ring = f.ring\n    (cf, f) = f.primitive()\n    (cg, g) = g.primitive()\n    ch = ring.domain.gcd(cf, cg)\n    (xbound, ycontbound) = _degree_bound_bivariate(f, g)\n    if xbound == ycontbound == 0:\n        return (ring(ch), f.mul_ground(cf // ch), g.mul_ground(cg // ch))\n    fswap = _swap(f, 1)\n    gswap = _swap(g, 1)\n    degyf = fswap.degree()\n    degyg = gswap.degree()\n    (ybound, xcontbound) = _degree_bound_bivariate(fswap, gswap)\n    if ybound == xcontbound == 0:\n        return (ring(ch), f.mul_ground(cf // ch), g.mul_ground(cg // ch))\n    gamma1 = ring.domain.gcd(f.LC, g.LC)\n    gamma2 = ring.domain.gcd(fswap.LC, gswap.LC)\n    badprimes = gamma1 * gamma2\n    m = 1\n    p = 1\n    while True:\n        p = nextprime(p)\n        while badprimes % p == 0:\n            p = nextprime(p)\n        fp = f.trunc_ground(p)\n        gp = g.trunc_ground(p)\n        (contfp, fp) = _primitive(fp, p)\n        (contgp, gp) = _primitive(gp, p)\n        conthp = _gf_gcd(contfp, contgp, p)\n        degconthp = conthp.degree()\n        if degconthp > ycontbound:\n            continue\n        elif degconthp < ycontbound:\n            m = 1\n            ycontbound = degconthp\n            continue\n        delta = _gf_gcd(_LC(fp), _LC(gp), p)\n        degcontfp = contfp.degree()\n        degcontgp = contgp.degree()\n        degdelta = delta.degree()\n        N = min(degyf - degcontfp, degyg - degcontgp, ybound - ycontbound + degdelta) + 1\n        if p < N:\n            continue\n        n = 0\n        evalpoints = []\n        hpeval = []\n        unlucky = False\n        for a in range(p):\n            deltaa = delta.evaluate(0, a)\n            if not deltaa % p:\n                continue\n            fpa = fp.evaluate(1, a).trunc_ground(p)\n            gpa = gp.evaluate(1, a).trunc_ground(p)\n            hpa = _gf_gcd(fpa, gpa, p)\n            deghpa = hpa.degree()\n            if deghpa > xbound:\n                continue\n            elif deghpa < xbound:\n                m = 1\n                xbound = deghpa\n                unlucky = True\n                break\n            hpa = hpa.mul_ground(deltaa).trunc_ground(p)\n            evalpoints.append(a)\n            hpeval.append(hpa)\n            n += 1\n            if n == N:\n                break\n        if unlucky:\n            continue\n        if n < N:\n            continue\n        hp = _interpolate_multivariate(evalpoints, hpeval, ring, 1, p)\n        hp = _primitive(hp, p)[1]\n        hp = hp * conthp.set_ring(ring)\n        degyhp = hp.degree(1)\n        if degyhp > ybound:\n            continue\n        if degyhp < ybound:\n            m = 1\n            ybound = degyhp\n            continue\n        hp = hp.mul_ground(gamma1).trunc_ground(p)\n        if m == 1:\n            m = p\n            hlastm = hp\n            continue\n        hm = _chinese_remainder_reconstruction_multivariate(hp, hlastm, p, m)\n        m *= p\n        if not hm == hlastm:\n            hlastm = hm\n            continue\n        h = hm.quo_ground(hm.content())\n        (fquo, frem) = f.div(h)\n        (gquo, grem) = g.div(h)\n        if not frem and (not grem):\n            if h.LC < 0:\n                ch = -ch\n            h = h.mul_ground(ch)\n            cff = fquo.mul_ground(cf // ch)\n            cfg = gquo.mul_ground(cg // ch)\n            return (h, cff, cfg)",
            "def modgcd_bivariate(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Computes the GCD of two polynomials in `\\\\mathbb{Z}[x, y]` using a\\n    modular algorithm.\\n\\n    The algorithm computes the GCD of two bivariate integer polynomials\\n    `f` and `g` by calculating the GCD in `\\\\mathbb{Z}_p[x, y]` for\\n    suitable primes `p` and then reconstructing the coefficients with the\\n    Chinese Remainder Theorem. To compute the bivariate GCD over\\n    `\\\\mathbb{Z}_p`, the polynomials `f \\\\; \\\\mathrm{mod} \\\\, p` and\\n    `g \\\\; \\\\mathrm{mod} \\\\, p` are evaluated at `y = a` for certain\\n    `a \\\\in \\\\mathbb{Z}_p` and then their univariate GCD in `\\\\mathbb{Z}_p[x]`\\n    is computed. Interpolating those yields the bivariate GCD in\\n    `\\\\mathbb{Z}_p[x, y]`. To verify the result in `\\\\mathbb{Z}[x, y]`, trial\\n    division is done, but only for candidates which are very likely the\\n    desired GCD.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        bivariate integer polynomial\\n    g : PolyElement\\n        bivariate integer polynomial\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of the polynomials `f` and `g`\\n    cff : PolyElement\\n        cofactor of `f`, i.e. `\\\\frac{f}{h}`\\n    cfg : PolyElement\\n        cofactor of `g`, i.e. `\\\\frac{g}{h}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import modgcd_bivariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n\\n    >>> f = x**2 - y**2\\n    >>> g = x**2 + 2*x*y + y**2\\n\\n    >>> h, cff, cfg = modgcd_bivariate(f, g)\\n    >>> h, cff, cfg\\n    (x + y, x - y, x + y)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> f = x**2*y - x**2 - 4*y + 4\\n    >>> g = x + 2\\n\\n    >>> h, cff, cfg = modgcd_bivariate(f, g)\\n    >>> h, cff, cfg\\n    (x + 2, x*y - x - 2*y + 2, 1)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n\\n    '\n    assert f.ring == g.ring and f.ring.domain.is_ZZ\n    result = _trivial_gcd(f, g)\n    if result is not None:\n        return result\n    ring = f.ring\n    (cf, f) = f.primitive()\n    (cg, g) = g.primitive()\n    ch = ring.domain.gcd(cf, cg)\n    (xbound, ycontbound) = _degree_bound_bivariate(f, g)\n    if xbound == ycontbound == 0:\n        return (ring(ch), f.mul_ground(cf // ch), g.mul_ground(cg // ch))\n    fswap = _swap(f, 1)\n    gswap = _swap(g, 1)\n    degyf = fswap.degree()\n    degyg = gswap.degree()\n    (ybound, xcontbound) = _degree_bound_bivariate(fswap, gswap)\n    if ybound == xcontbound == 0:\n        return (ring(ch), f.mul_ground(cf // ch), g.mul_ground(cg // ch))\n    gamma1 = ring.domain.gcd(f.LC, g.LC)\n    gamma2 = ring.domain.gcd(fswap.LC, gswap.LC)\n    badprimes = gamma1 * gamma2\n    m = 1\n    p = 1\n    while True:\n        p = nextprime(p)\n        while badprimes % p == 0:\n            p = nextprime(p)\n        fp = f.trunc_ground(p)\n        gp = g.trunc_ground(p)\n        (contfp, fp) = _primitive(fp, p)\n        (contgp, gp) = _primitive(gp, p)\n        conthp = _gf_gcd(contfp, contgp, p)\n        degconthp = conthp.degree()\n        if degconthp > ycontbound:\n            continue\n        elif degconthp < ycontbound:\n            m = 1\n            ycontbound = degconthp\n            continue\n        delta = _gf_gcd(_LC(fp), _LC(gp), p)\n        degcontfp = contfp.degree()\n        degcontgp = contgp.degree()\n        degdelta = delta.degree()\n        N = min(degyf - degcontfp, degyg - degcontgp, ybound - ycontbound + degdelta) + 1\n        if p < N:\n            continue\n        n = 0\n        evalpoints = []\n        hpeval = []\n        unlucky = False\n        for a in range(p):\n            deltaa = delta.evaluate(0, a)\n            if not deltaa % p:\n                continue\n            fpa = fp.evaluate(1, a).trunc_ground(p)\n            gpa = gp.evaluate(1, a).trunc_ground(p)\n            hpa = _gf_gcd(fpa, gpa, p)\n            deghpa = hpa.degree()\n            if deghpa > xbound:\n                continue\n            elif deghpa < xbound:\n                m = 1\n                xbound = deghpa\n                unlucky = True\n                break\n            hpa = hpa.mul_ground(deltaa).trunc_ground(p)\n            evalpoints.append(a)\n            hpeval.append(hpa)\n            n += 1\n            if n == N:\n                break\n        if unlucky:\n            continue\n        if n < N:\n            continue\n        hp = _interpolate_multivariate(evalpoints, hpeval, ring, 1, p)\n        hp = _primitive(hp, p)[1]\n        hp = hp * conthp.set_ring(ring)\n        degyhp = hp.degree(1)\n        if degyhp > ybound:\n            continue\n        if degyhp < ybound:\n            m = 1\n            ybound = degyhp\n            continue\n        hp = hp.mul_ground(gamma1).trunc_ground(p)\n        if m == 1:\n            m = p\n            hlastm = hp\n            continue\n        hm = _chinese_remainder_reconstruction_multivariate(hp, hlastm, p, m)\n        m *= p\n        if not hm == hlastm:\n            hlastm = hm\n            continue\n        h = hm.quo_ground(hm.content())\n        (fquo, frem) = f.div(h)\n        (gquo, grem) = g.div(h)\n        if not frem and (not grem):\n            if h.LC < 0:\n                ch = -ch\n            h = h.mul_ground(ch)\n            cff = fquo.mul_ground(cf // ch)\n            cfg = gquo.mul_ground(cg // ch)\n            return (h, cff, cfg)",
            "def modgcd_bivariate(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Computes the GCD of two polynomials in `\\\\mathbb{Z}[x, y]` using a\\n    modular algorithm.\\n\\n    The algorithm computes the GCD of two bivariate integer polynomials\\n    `f` and `g` by calculating the GCD in `\\\\mathbb{Z}_p[x, y]` for\\n    suitable primes `p` and then reconstructing the coefficients with the\\n    Chinese Remainder Theorem. To compute the bivariate GCD over\\n    `\\\\mathbb{Z}_p`, the polynomials `f \\\\; \\\\mathrm{mod} \\\\, p` and\\n    `g \\\\; \\\\mathrm{mod} \\\\, p` are evaluated at `y = a` for certain\\n    `a \\\\in \\\\mathbb{Z}_p` and then their univariate GCD in `\\\\mathbb{Z}_p[x]`\\n    is computed. Interpolating those yields the bivariate GCD in\\n    `\\\\mathbb{Z}_p[x, y]`. To verify the result in `\\\\mathbb{Z}[x, y]`, trial\\n    division is done, but only for candidates which are very likely the\\n    desired GCD.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        bivariate integer polynomial\\n    g : PolyElement\\n        bivariate integer polynomial\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of the polynomials `f` and `g`\\n    cff : PolyElement\\n        cofactor of `f`, i.e. `\\\\frac{f}{h}`\\n    cfg : PolyElement\\n        cofactor of `g`, i.e. `\\\\frac{g}{h}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import modgcd_bivariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n\\n    >>> f = x**2 - y**2\\n    >>> g = x**2 + 2*x*y + y**2\\n\\n    >>> h, cff, cfg = modgcd_bivariate(f, g)\\n    >>> h, cff, cfg\\n    (x + y, x - y, x + y)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> f = x**2*y - x**2 - 4*y + 4\\n    >>> g = x + 2\\n\\n    >>> h, cff, cfg = modgcd_bivariate(f, g)\\n    >>> h, cff, cfg\\n    (x + 2, x*y - x - 2*y + 2, 1)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n\\n    '\n    assert f.ring == g.ring and f.ring.domain.is_ZZ\n    result = _trivial_gcd(f, g)\n    if result is not None:\n        return result\n    ring = f.ring\n    (cf, f) = f.primitive()\n    (cg, g) = g.primitive()\n    ch = ring.domain.gcd(cf, cg)\n    (xbound, ycontbound) = _degree_bound_bivariate(f, g)\n    if xbound == ycontbound == 0:\n        return (ring(ch), f.mul_ground(cf // ch), g.mul_ground(cg // ch))\n    fswap = _swap(f, 1)\n    gswap = _swap(g, 1)\n    degyf = fswap.degree()\n    degyg = gswap.degree()\n    (ybound, xcontbound) = _degree_bound_bivariate(fswap, gswap)\n    if ybound == xcontbound == 0:\n        return (ring(ch), f.mul_ground(cf // ch), g.mul_ground(cg // ch))\n    gamma1 = ring.domain.gcd(f.LC, g.LC)\n    gamma2 = ring.domain.gcd(fswap.LC, gswap.LC)\n    badprimes = gamma1 * gamma2\n    m = 1\n    p = 1\n    while True:\n        p = nextprime(p)\n        while badprimes % p == 0:\n            p = nextprime(p)\n        fp = f.trunc_ground(p)\n        gp = g.trunc_ground(p)\n        (contfp, fp) = _primitive(fp, p)\n        (contgp, gp) = _primitive(gp, p)\n        conthp = _gf_gcd(contfp, contgp, p)\n        degconthp = conthp.degree()\n        if degconthp > ycontbound:\n            continue\n        elif degconthp < ycontbound:\n            m = 1\n            ycontbound = degconthp\n            continue\n        delta = _gf_gcd(_LC(fp), _LC(gp), p)\n        degcontfp = contfp.degree()\n        degcontgp = contgp.degree()\n        degdelta = delta.degree()\n        N = min(degyf - degcontfp, degyg - degcontgp, ybound - ycontbound + degdelta) + 1\n        if p < N:\n            continue\n        n = 0\n        evalpoints = []\n        hpeval = []\n        unlucky = False\n        for a in range(p):\n            deltaa = delta.evaluate(0, a)\n            if not deltaa % p:\n                continue\n            fpa = fp.evaluate(1, a).trunc_ground(p)\n            gpa = gp.evaluate(1, a).trunc_ground(p)\n            hpa = _gf_gcd(fpa, gpa, p)\n            deghpa = hpa.degree()\n            if deghpa > xbound:\n                continue\n            elif deghpa < xbound:\n                m = 1\n                xbound = deghpa\n                unlucky = True\n                break\n            hpa = hpa.mul_ground(deltaa).trunc_ground(p)\n            evalpoints.append(a)\n            hpeval.append(hpa)\n            n += 1\n            if n == N:\n                break\n        if unlucky:\n            continue\n        if n < N:\n            continue\n        hp = _interpolate_multivariate(evalpoints, hpeval, ring, 1, p)\n        hp = _primitive(hp, p)[1]\n        hp = hp * conthp.set_ring(ring)\n        degyhp = hp.degree(1)\n        if degyhp > ybound:\n            continue\n        if degyhp < ybound:\n            m = 1\n            ybound = degyhp\n            continue\n        hp = hp.mul_ground(gamma1).trunc_ground(p)\n        if m == 1:\n            m = p\n            hlastm = hp\n            continue\n        hm = _chinese_remainder_reconstruction_multivariate(hp, hlastm, p, m)\n        m *= p\n        if not hm == hlastm:\n            hlastm = hm\n            continue\n        h = hm.quo_ground(hm.content())\n        (fquo, frem) = f.div(h)\n        (gquo, grem) = g.div(h)\n        if not frem and (not grem):\n            if h.LC < 0:\n                ch = -ch\n            h = h.mul_ground(ch)\n            cff = fquo.mul_ground(cf // ch)\n            cfg = gquo.mul_ground(cg // ch)\n            return (h, cff, cfg)"
        ]
    },
    {
        "func_name": "_modgcd_multivariate_p",
        "original": "def _modgcd_multivariate_p(f, g, p, degbound, contbound):\n    \"\"\"\n    Compute the GCD of two polynomials in\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`.\n\n    The algorithm reduces the problem step by step by evaluating the\n    polynomials `f` and `g` at `x_{k-1} = a` for suitable\n    `a \\\\in \\\\mathbb{Z}_p` and then calls itself recursively to compute the GCD\n    in `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-2}]`. If these recursive calls are\n    successful for enough evaluation points, the GCD in `k` variables is\n    interpolated, otherwise the algorithm returns ``None``. Every time a GCD\n    or a content is computed, their degrees are compared with the bounds. If\n    a degree greater then the bound is encountered, then the current call\n    returns ``None`` and a new evaluation point has to be chosen. If at some\n    point the degree is smaller, the correspondent bound is updated and the\n    algorithm fails.\n\n    Parameters\n    ==========\n\n    f : PolyElement\n        multivariate integer polynomial with coefficients in `\\\\mathbb{Z}_p`\n    g : PolyElement\n        multivariate integer polynomial with coefficients in `\\\\mathbb{Z}_p`\n    p : Integer\n        prime number, modulus of `f` and `g`\n    degbound : list of Integer objects\n        ``degbound[i]`` is an upper bound for the degree of the GCD of `f`\n        and `g` in the variable `x_i`\n    contbound : list of Integer objects\n        ``contbound[i]`` is an upper bound for the degree of the content of\n        the GCD in `\\\\mathbb{Z}_p[x_i][x_0, \\\\ldots, x_{i-1}]`,\n        ``contbound[0]`` is not used can therefore be chosen\n        arbitrarily.\n\n    Returns\n    =======\n\n    h : PolyElement\n        GCD of the polynomials `f` and `g` or ``None``\n\n    References\n    ==========\n\n    1. [Monagan00]_\n    2. [Brown71]_\n\n    \"\"\"\n    ring = f.ring\n    k = ring.ngens\n    if k == 1:\n        h = _gf_gcd(f, g, p).trunc_ground(p)\n        degh = h.degree()\n        if degh > degbound[0]:\n            return None\n        if degh < degbound[0]:\n            degbound[0] = degh\n            raise ModularGCDFailed\n        return h\n    degyf = f.degree(k - 1)\n    degyg = g.degree(k - 1)\n    (contf, f) = _primitive(f, p)\n    (contg, g) = _primitive(g, p)\n    conth = _gf_gcd(contf, contg, p)\n    degcontf = contf.degree()\n    degcontg = contg.degree()\n    degconth = conth.degree()\n    if degconth > contbound[k - 1]:\n        return None\n    if degconth < contbound[k - 1]:\n        contbound[k - 1] = degconth\n        raise ModularGCDFailed\n    lcf = _LC(f)\n    lcg = _LC(g)\n    delta = _gf_gcd(lcf, lcg, p)\n    evaltest = delta\n    for i in range(k - 1):\n        evaltest *= _gf_gcd(_LC(_swap(f, i)), _LC(_swap(g, i)), p)\n    degdelta = delta.degree()\n    N = min(degyf - degcontf, degyg - degcontg, degbound[k - 1] - contbound[k - 1] + degdelta) + 1\n    if p < N:\n        return None\n    n = 0\n    d = 0\n    evalpoints = []\n    heval = []\n    points = list(range(p))\n    while points:\n        a = random.sample(points, 1)[0]\n        points.remove(a)\n        if not evaltest.evaluate(0, a) % p:\n            continue\n        deltaa = delta.evaluate(0, a) % p\n        fa = f.evaluate(k - 1, a).trunc_ground(p)\n        ga = g.evaluate(k - 1, a).trunc_ground(p)\n        ha = _modgcd_multivariate_p(fa, ga, p, degbound, contbound)\n        if ha is None:\n            d += 1\n            if d > n:\n                return None\n            continue\n        if ha.is_ground:\n            h = conth.set_ring(ring).trunc_ground(p)\n            return h\n        ha = ha.mul_ground(deltaa).trunc_ground(p)\n        evalpoints.append(a)\n        heval.append(ha)\n        n += 1\n        if n == N:\n            h = _interpolate_multivariate(evalpoints, heval, ring, k - 1, p)\n            h = _primitive(h, p)[1] * conth.set_ring(ring)\n            degyh = h.degree(k - 1)\n            if degyh > degbound[k - 1]:\n                return None\n            if degyh < degbound[k - 1]:\n                degbound[k - 1] = degyh\n                raise ModularGCDFailed\n            return h\n    return None",
        "mutated": [
            "def _modgcd_multivariate_p(f, g, p, degbound, contbound):\n    if False:\n        i = 10\n    '\\n    Compute the GCD of two polynomials in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`.\\n\\n    The algorithm reduces the problem step by step by evaluating the\\n    polynomials `f` and `g` at `x_{k-1} = a` for suitable\\n    `a \\\\in \\\\mathbb{Z}_p` and then calls itself recursively to compute the GCD\\n    in `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-2}]`. If these recursive calls are\\n    successful for enough evaluation points, the GCD in `k` variables is\\n    interpolated, otherwise the algorithm returns ``None``. Every time a GCD\\n    or a content is computed, their degrees are compared with the bounds. If\\n    a degree greater then the bound is encountered, then the current call\\n    returns ``None`` and a new evaluation point has to be chosen. If at some\\n    point the degree is smaller, the correspondent bound is updated and the\\n    algorithm fails.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        multivariate integer polynomial with coefficients in `\\\\mathbb{Z}_p`\\n    g : PolyElement\\n        multivariate integer polynomial with coefficients in `\\\\mathbb{Z}_p`\\n    p : Integer\\n        prime number, modulus of `f` and `g`\\n    degbound : list of Integer objects\\n        ``degbound[i]`` is an upper bound for the degree of the GCD of `f`\\n        and `g` in the variable `x_i`\\n    contbound : list of Integer objects\\n        ``contbound[i]`` is an upper bound for the degree of the content of\\n        the GCD in `\\\\mathbb{Z}_p[x_i][x_0, \\\\ldots, x_{i-1}]`,\\n        ``contbound[0]`` is not used can therefore be chosen\\n        arbitrarily.\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of the polynomials `f` and `g` or ``None``\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n    2. [Brown71]_\\n\\n    '\n    ring = f.ring\n    k = ring.ngens\n    if k == 1:\n        h = _gf_gcd(f, g, p).trunc_ground(p)\n        degh = h.degree()\n        if degh > degbound[0]:\n            return None\n        if degh < degbound[0]:\n            degbound[0] = degh\n            raise ModularGCDFailed\n        return h\n    degyf = f.degree(k - 1)\n    degyg = g.degree(k - 1)\n    (contf, f) = _primitive(f, p)\n    (contg, g) = _primitive(g, p)\n    conth = _gf_gcd(contf, contg, p)\n    degcontf = contf.degree()\n    degcontg = contg.degree()\n    degconth = conth.degree()\n    if degconth > contbound[k - 1]:\n        return None\n    if degconth < contbound[k - 1]:\n        contbound[k - 1] = degconth\n        raise ModularGCDFailed\n    lcf = _LC(f)\n    lcg = _LC(g)\n    delta = _gf_gcd(lcf, lcg, p)\n    evaltest = delta\n    for i in range(k - 1):\n        evaltest *= _gf_gcd(_LC(_swap(f, i)), _LC(_swap(g, i)), p)\n    degdelta = delta.degree()\n    N = min(degyf - degcontf, degyg - degcontg, degbound[k - 1] - contbound[k - 1] + degdelta) + 1\n    if p < N:\n        return None\n    n = 0\n    d = 0\n    evalpoints = []\n    heval = []\n    points = list(range(p))\n    while points:\n        a = random.sample(points, 1)[0]\n        points.remove(a)\n        if not evaltest.evaluate(0, a) % p:\n            continue\n        deltaa = delta.evaluate(0, a) % p\n        fa = f.evaluate(k - 1, a).trunc_ground(p)\n        ga = g.evaluate(k - 1, a).trunc_ground(p)\n        ha = _modgcd_multivariate_p(fa, ga, p, degbound, contbound)\n        if ha is None:\n            d += 1\n            if d > n:\n                return None\n            continue\n        if ha.is_ground:\n            h = conth.set_ring(ring).trunc_ground(p)\n            return h\n        ha = ha.mul_ground(deltaa).trunc_ground(p)\n        evalpoints.append(a)\n        heval.append(ha)\n        n += 1\n        if n == N:\n            h = _interpolate_multivariate(evalpoints, heval, ring, k - 1, p)\n            h = _primitive(h, p)[1] * conth.set_ring(ring)\n            degyh = h.degree(k - 1)\n            if degyh > degbound[k - 1]:\n                return None\n            if degyh < degbound[k - 1]:\n                degbound[k - 1] = degyh\n                raise ModularGCDFailed\n            return h\n    return None",
            "def _modgcd_multivariate_p(f, g, p, degbound, contbound):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the GCD of two polynomials in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`.\\n\\n    The algorithm reduces the problem step by step by evaluating the\\n    polynomials `f` and `g` at `x_{k-1} = a` for suitable\\n    `a \\\\in \\\\mathbb{Z}_p` and then calls itself recursively to compute the GCD\\n    in `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-2}]`. If these recursive calls are\\n    successful for enough evaluation points, the GCD in `k` variables is\\n    interpolated, otherwise the algorithm returns ``None``. Every time a GCD\\n    or a content is computed, their degrees are compared with the bounds. If\\n    a degree greater then the bound is encountered, then the current call\\n    returns ``None`` and a new evaluation point has to be chosen. If at some\\n    point the degree is smaller, the correspondent bound is updated and the\\n    algorithm fails.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        multivariate integer polynomial with coefficients in `\\\\mathbb{Z}_p`\\n    g : PolyElement\\n        multivariate integer polynomial with coefficients in `\\\\mathbb{Z}_p`\\n    p : Integer\\n        prime number, modulus of `f` and `g`\\n    degbound : list of Integer objects\\n        ``degbound[i]`` is an upper bound for the degree of the GCD of `f`\\n        and `g` in the variable `x_i`\\n    contbound : list of Integer objects\\n        ``contbound[i]`` is an upper bound for the degree of the content of\\n        the GCD in `\\\\mathbb{Z}_p[x_i][x_0, \\\\ldots, x_{i-1}]`,\\n        ``contbound[0]`` is not used can therefore be chosen\\n        arbitrarily.\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of the polynomials `f` and `g` or ``None``\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n    2. [Brown71]_\\n\\n    '\n    ring = f.ring\n    k = ring.ngens\n    if k == 1:\n        h = _gf_gcd(f, g, p).trunc_ground(p)\n        degh = h.degree()\n        if degh > degbound[0]:\n            return None\n        if degh < degbound[0]:\n            degbound[0] = degh\n            raise ModularGCDFailed\n        return h\n    degyf = f.degree(k - 1)\n    degyg = g.degree(k - 1)\n    (contf, f) = _primitive(f, p)\n    (contg, g) = _primitive(g, p)\n    conth = _gf_gcd(contf, contg, p)\n    degcontf = contf.degree()\n    degcontg = contg.degree()\n    degconth = conth.degree()\n    if degconth > contbound[k - 1]:\n        return None\n    if degconth < contbound[k - 1]:\n        contbound[k - 1] = degconth\n        raise ModularGCDFailed\n    lcf = _LC(f)\n    lcg = _LC(g)\n    delta = _gf_gcd(lcf, lcg, p)\n    evaltest = delta\n    for i in range(k - 1):\n        evaltest *= _gf_gcd(_LC(_swap(f, i)), _LC(_swap(g, i)), p)\n    degdelta = delta.degree()\n    N = min(degyf - degcontf, degyg - degcontg, degbound[k - 1] - contbound[k - 1] + degdelta) + 1\n    if p < N:\n        return None\n    n = 0\n    d = 0\n    evalpoints = []\n    heval = []\n    points = list(range(p))\n    while points:\n        a = random.sample(points, 1)[0]\n        points.remove(a)\n        if not evaltest.evaluate(0, a) % p:\n            continue\n        deltaa = delta.evaluate(0, a) % p\n        fa = f.evaluate(k - 1, a).trunc_ground(p)\n        ga = g.evaluate(k - 1, a).trunc_ground(p)\n        ha = _modgcd_multivariate_p(fa, ga, p, degbound, contbound)\n        if ha is None:\n            d += 1\n            if d > n:\n                return None\n            continue\n        if ha.is_ground:\n            h = conth.set_ring(ring).trunc_ground(p)\n            return h\n        ha = ha.mul_ground(deltaa).trunc_ground(p)\n        evalpoints.append(a)\n        heval.append(ha)\n        n += 1\n        if n == N:\n            h = _interpolate_multivariate(evalpoints, heval, ring, k - 1, p)\n            h = _primitive(h, p)[1] * conth.set_ring(ring)\n            degyh = h.degree(k - 1)\n            if degyh > degbound[k - 1]:\n                return None\n            if degyh < degbound[k - 1]:\n                degbound[k - 1] = degyh\n                raise ModularGCDFailed\n            return h\n    return None",
            "def _modgcd_multivariate_p(f, g, p, degbound, contbound):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the GCD of two polynomials in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`.\\n\\n    The algorithm reduces the problem step by step by evaluating the\\n    polynomials `f` and `g` at `x_{k-1} = a` for suitable\\n    `a \\\\in \\\\mathbb{Z}_p` and then calls itself recursively to compute the GCD\\n    in `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-2}]`. If these recursive calls are\\n    successful for enough evaluation points, the GCD in `k` variables is\\n    interpolated, otherwise the algorithm returns ``None``. Every time a GCD\\n    or a content is computed, their degrees are compared with the bounds. If\\n    a degree greater then the bound is encountered, then the current call\\n    returns ``None`` and a new evaluation point has to be chosen. If at some\\n    point the degree is smaller, the correspondent bound is updated and the\\n    algorithm fails.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        multivariate integer polynomial with coefficients in `\\\\mathbb{Z}_p`\\n    g : PolyElement\\n        multivariate integer polynomial with coefficients in `\\\\mathbb{Z}_p`\\n    p : Integer\\n        prime number, modulus of `f` and `g`\\n    degbound : list of Integer objects\\n        ``degbound[i]`` is an upper bound for the degree of the GCD of `f`\\n        and `g` in the variable `x_i`\\n    contbound : list of Integer objects\\n        ``contbound[i]`` is an upper bound for the degree of the content of\\n        the GCD in `\\\\mathbb{Z}_p[x_i][x_0, \\\\ldots, x_{i-1}]`,\\n        ``contbound[0]`` is not used can therefore be chosen\\n        arbitrarily.\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of the polynomials `f` and `g` or ``None``\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n    2. [Brown71]_\\n\\n    '\n    ring = f.ring\n    k = ring.ngens\n    if k == 1:\n        h = _gf_gcd(f, g, p).trunc_ground(p)\n        degh = h.degree()\n        if degh > degbound[0]:\n            return None\n        if degh < degbound[0]:\n            degbound[0] = degh\n            raise ModularGCDFailed\n        return h\n    degyf = f.degree(k - 1)\n    degyg = g.degree(k - 1)\n    (contf, f) = _primitive(f, p)\n    (contg, g) = _primitive(g, p)\n    conth = _gf_gcd(contf, contg, p)\n    degcontf = contf.degree()\n    degcontg = contg.degree()\n    degconth = conth.degree()\n    if degconth > contbound[k - 1]:\n        return None\n    if degconth < contbound[k - 1]:\n        contbound[k - 1] = degconth\n        raise ModularGCDFailed\n    lcf = _LC(f)\n    lcg = _LC(g)\n    delta = _gf_gcd(lcf, lcg, p)\n    evaltest = delta\n    for i in range(k - 1):\n        evaltest *= _gf_gcd(_LC(_swap(f, i)), _LC(_swap(g, i)), p)\n    degdelta = delta.degree()\n    N = min(degyf - degcontf, degyg - degcontg, degbound[k - 1] - contbound[k - 1] + degdelta) + 1\n    if p < N:\n        return None\n    n = 0\n    d = 0\n    evalpoints = []\n    heval = []\n    points = list(range(p))\n    while points:\n        a = random.sample(points, 1)[0]\n        points.remove(a)\n        if not evaltest.evaluate(0, a) % p:\n            continue\n        deltaa = delta.evaluate(0, a) % p\n        fa = f.evaluate(k - 1, a).trunc_ground(p)\n        ga = g.evaluate(k - 1, a).trunc_ground(p)\n        ha = _modgcd_multivariate_p(fa, ga, p, degbound, contbound)\n        if ha is None:\n            d += 1\n            if d > n:\n                return None\n            continue\n        if ha.is_ground:\n            h = conth.set_ring(ring).trunc_ground(p)\n            return h\n        ha = ha.mul_ground(deltaa).trunc_ground(p)\n        evalpoints.append(a)\n        heval.append(ha)\n        n += 1\n        if n == N:\n            h = _interpolate_multivariate(evalpoints, heval, ring, k - 1, p)\n            h = _primitive(h, p)[1] * conth.set_ring(ring)\n            degyh = h.degree(k - 1)\n            if degyh > degbound[k - 1]:\n                return None\n            if degyh < degbound[k - 1]:\n                degbound[k - 1] = degyh\n                raise ModularGCDFailed\n            return h\n    return None",
            "def _modgcd_multivariate_p(f, g, p, degbound, contbound):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the GCD of two polynomials in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`.\\n\\n    The algorithm reduces the problem step by step by evaluating the\\n    polynomials `f` and `g` at `x_{k-1} = a` for suitable\\n    `a \\\\in \\\\mathbb{Z}_p` and then calls itself recursively to compute the GCD\\n    in `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-2}]`. If these recursive calls are\\n    successful for enough evaluation points, the GCD in `k` variables is\\n    interpolated, otherwise the algorithm returns ``None``. Every time a GCD\\n    or a content is computed, their degrees are compared with the bounds. If\\n    a degree greater then the bound is encountered, then the current call\\n    returns ``None`` and a new evaluation point has to be chosen. If at some\\n    point the degree is smaller, the correspondent bound is updated and the\\n    algorithm fails.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        multivariate integer polynomial with coefficients in `\\\\mathbb{Z}_p`\\n    g : PolyElement\\n        multivariate integer polynomial with coefficients in `\\\\mathbb{Z}_p`\\n    p : Integer\\n        prime number, modulus of `f` and `g`\\n    degbound : list of Integer objects\\n        ``degbound[i]`` is an upper bound for the degree of the GCD of `f`\\n        and `g` in the variable `x_i`\\n    contbound : list of Integer objects\\n        ``contbound[i]`` is an upper bound for the degree of the content of\\n        the GCD in `\\\\mathbb{Z}_p[x_i][x_0, \\\\ldots, x_{i-1}]`,\\n        ``contbound[0]`` is not used can therefore be chosen\\n        arbitrarily.\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of the polynomials `f` and `g` or ``None``\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n    2. [Brown71]_\\n\\n    '\n    ring = f.ring\n    k = ring.ngens\n    if k == 1:\n        h = _gf_gcd(f, g, p).trunc_ground(p)\n        degh = h.degree()\n        if degh > degbound[0]:\n            return None\n        if degh < degbound[0]:\n            degbound[0] = degh\n            raise ModularGCDFailed\n        return h\n    degyf = f.degree(k - 1)\n    degyg = g.degree(k - 1)\n    (contf, f) = _primitive(f, p)\n    (contg, g) = _primitive(g, p)\n    conth = _gf_gcd(contf, contg, p)\n    degcontf = contf.degree()\n    degcontg = contg.degree()\n    degconth = conth.degree()\n    if degconth > contbound[k - 1]:\n        return None\n    if degconth < contbound[k - 1]:\n        contbound[k - 1] = degconth\n        raise ModularGCDFailed\n    lcf = _LC(f)\n    lcg = _LC(g)\n    delta = _gf_gcd(lcf, lcg, p)\n    evaltest = delta\n    for i in range(k - 1):\n        evaltest *= _gf_gcd(_LC(_swap(f, i)), _LC(_swap(g, i)), p)\n    degdelta = delta.degree()\n    N = min(degyf - degcontf, degyg - degcontg, degbound[k - 1] - contbound[k - 1] + degdelta) + 1\n    if p < N:\n        return None\n    n = 0\n    d = 0\n    evalpoints = []\n    heval = []\n    points = list(range(p))\n    while points:\n        a = random.sample(points, 1)[0]\n        points.remove(a)\n        if not evaltest.evaluate(0, a) % p:\n            continue\n        deltaa = delta.evaluate(0, a) % p\n        fa = f.evaluate(k - 1, a).trunc_ground(p)\n        ga = g.evaluate(k - 1, a).trunc_ground(p)\n        ha = _modgcd_multivariate_p(fa, ga, p, degbound, contbound)\n        if ha is None:\n            d += 1\n            if d > n:\n                return None\n            continue\n        if ha.is_ground:\n            h = conth.set_ring(ring).trunc_ground(p)\n            return h\n        ha = ha.mul_ground(deltaa).trunc_ground(p)\n        evalpoints.append(a)\n        heval.append(ha)\n        n += 1\n        if n == N:\n            h = _interpolate_multivariate(evalpoints, heval, ring, k - 1, p)\n            h = _primitive(h, p)[1] * conth.set_ring(ring)\n            degyh = h.degree(k - 1)\n            if degyh > degbound[k - 1]:\n                return None\n            if degyh < degbound[k - 1]:\n                degbound[k - 1] = degyh\n                raise ModularGCDFailed\n            return h\n    return None",
            "def _modgcd_multivariate_p(f, g, p, degbound, contbound):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the GCD of two polynomials in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]`.\\n\\n    The algorithm reduces the problem step by step by evaluating the\\n    polynomials `f` and `g` at `x_{k-1} = a` for suitable\\n    `a \\\\in \\\\mathbb{Z}_p` and then calls itself recursively to compute the GCD\\n    in `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-2}]`. If these recursive calls are\\n    successful for enough evaluation points, the GCD in `k` variables is\\n    interpolated, otherwise the algorithm returns ``None``. Every time a GCD\\n    or a content is computed, their degrees are compared with the bounds. If\\n    a degree greater then the bound is encountered, then the current call\\n    returns ``None`` and a new evaluation point has to be chosen. If at some\\n    point the degree is smaller, the correspondent bound is updated and the\\n    algorithm fails.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        multivariate integer polynomial with coefficients in `\\\\mathbb{Z}_p`\\n    g : PolyElement\\n        multivariate integer polynomial with coefficients in `\\\\mathbb{Z}_p`\\n    p : Integer\\n        prime number, modulus of `f` and `g`\\n    degbound : list of Integer objects\\n        ``degbound[i]`` is an upper bound for the degree of the GCD of `f`\\n        and `g` in the variable `x_i`\\n    contbound : list of Integer objects\\n        ``contbound[i]`` is an upper bound for the degree of the content of\\n        the GCD in `\\\\mathbb{Z}_p[x_i][x_0, \\\\ldots, x_{i-1}]`,\\n        ``contbound[0]`` is not used can therefore be chosen\\n        arbitrarily.\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of the polynomials `f` and `g` or ``None``\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n    2. [Brown71]_\\n\\n    '\n    ring = f.ring\n    k = ring.ngens\n    if k == 1:\n        h = _gf_gcd(f, g, p).trunc_ground(p)\n        degh = h.degree()\n        if degh > degbound[0]:\n            return None\n        if degh < degbound[0]:\n            degbound[0] = degh\n            raise ModularGCDFailed\n        return h\n    degyf = f.degree(k - 1)\n    degyg = g.degree(k - 1)\n    (contf, f) = _primitive(f, p)\n    (contg, g) = _primitive(g, p)\n    conth = _gf_gcd(contf, contg, p)\n    degcontf = contf.degree()\n    degcontg = contg.degree()\n    degconth = conth.degree()\n    if degconth > contbound[k - 1]:\n        return None\n    if degconth < contbound[k - 1]:\n        contbound[k - 1] = degconth\n        raise ModularGCDFailed\n    lcf = _LC(f)\n    lcg = _LC(g)\n    delta = _gf_gcd(lcf, lcg, p)\n    evaltest = delta\n    for i in range(k - 1):\n        evaltest *= _gf_gcd(_LC(_swap(f, i)), _LC(_swap(g, i)), p)\n    degdelta = delta.degree()\n    N = min(degyf - degcontf, degyg - degcontg, degbound[k - 1] - contbound[k - 1] + degdelta) + 1\n    if p < N:\n        return None\n    n = 0\n    d = 0\n    evalpoints = []\n    heval = []\n    points = list(range(p))\n    while points:\n        a = random.sample(points, 1)[0]\n        points.remove(a)\n        if not evaltest.evaluate(0, a) % p:\n            continue\n        deltaa = delta.evaluate(0, a) % p\n        fa = f.evaluate(k - 1, a).trunc_ground(p)\n        ga = g.evaluate(k - 1, a).trunc_ground(p)\n        ha = _modgcd_multivariate_p(fa, ga, p, degbound, contbound)\n        if ha is None:\n            d += 1\n            if d > n:\n                return None\n            continue\n        if ha.is_ground:\n            h = conth.set_ring(ring).trunc_ground(p)\n            return h\n        ha = ha.mul_ground(deltaa).trunc_ground(p)\n        evalpoints.append(a)\n        heval.append(ha)\n        n += 1\n        if n == N:\n            h = _interpolate_multivariate(evalpoints, heval, ring, k - 1, p)\n            h = _primitive(h, p)[1] * conth.set_ring(ring)\n            degyh = h.degree(k - 1)\n            if degyh > degbound[k - 1]:\n                return None\n            if degyh < degbound[k - 1]:\n                degbound[k - 1] = degyh\n                raise ModularGCDFailed\n            return h\n    return None"
        ]
    },
    {
        "func_name": "modgcd_multivariate",
        "original": "def modgcd_multivariate(f, g):\n    \"\"\"\n    Compute the GCD of two polynomials in `\\\\mathbb{Z}[x_0, \\\\ldots, x_{k-1}]`\n    using a modular algorithm.\n\n    The algorithm computes the GCD of two multivariate integer polynomials\n    `f` and `g` by calculating the GCD in\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]` for suitable primes `p` and then\n    reconstructing the coefficients with the Chinese Remainder Theorem. To\n    compute the multivariate GCD over `\\\\mathbb{Z}_p` the recursive\n    subroutine :func:`_modgcd_multivariate_p` is used. To verify the result in\n    `\\\\mathbb{Z}[x_0, \\\\ldots, x_{k-1}]`, trial division is done, but only for\n    candidates which are very likely the desired GCD.\n\n    Parameters\n    ==========\n\n    f : PolyElement\n        multivariate integer polynomial\n    g : PolyElement\n        multivariate integer polynomial\n\n    Returns\n    =======\n\n    h : PolyElement\n        GCD of the polynomials `f` and `g`\n    cff : PolyElement\n        cofactor of `f`, i.e. `\\\\frac{f}{h}`\n    cfg : PolyElement\n        cofactor of `g`, i.e. `\\\\frac{g}{h}`\n\n    Examples\n    ========\n\n    >>> from sympy.polys.modulargcd import modgcd_multivariate\n    >>> from sympy.polys import ring, ZZ\n\n    >>> R, x, y = ring(\"x, y\", ZZ)\n\n    >>> f = x**2 - y**2\n    >>> g = x**2 + 2*x*y + y**2\n\n    >>> h, cff, cfg = modgcd_multivariate(f, g)\n    >>> h, cff, cfg\n    (x + y, x - y, x + y)\n\n    >>> cff * h == f\n    True\n    >>> cfg * h == g\n    True\n\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\n\n    >>> f = x*z**2 - y*z**2\n    >>> g = x**2*z + z\n\n    >>> h, cff, cfg = modgcd_multivariate(f, g)\n    >>> h, cff, cfg\n    (z, x*z - y*z, x**2 + 1)\n\n    >>> cff * h == f\n    True\n    >>> cfg * h == g\n    True\n\n    References\n    ==========\n\n    1. [Monagan00]_\n    2. [Brown71]_\n\n    See also\n    ========\n\n    _modgcd_multivariate_p\n\n    \"\"\"\n    assert f.ring == g.ring and f.ring.domain.is_ZZ\n    result = _trivial_gcd(f, g)\n    if result is not None:\n        return result\n    ring = f.ring\n    k = ring.ngens\n    (cf, f) = f.primitive()\n    (cg, g) = g.primitive()\n    ch = ring.domain.gcd(cf, cg)\n    gamma = ring.domain.gcd(f.LC, g.LC)\n    badprimes = ring.domain.one\n    for i in range(k):\n        badprimes *= ring.domain.gcd(_swap(f, i).LC, _swap(g, i).LC)\n    degbound = [min(fdeg, gdeg) for (fdeg, gdeg) in zip(f.degrees(), g.degrees())]\n    contbound = list(degbound)\n    m = 1\n    p = 1\n    while True:\n        p = nextprime(p)\n        while badprimes % p == 0:\n            p = nextprime(p)\n        fp = f.trunc_ground(p)\n        gp = g.trunc_ground(p)\n        try:\n            hp = _modgcd_multivariate_p(fp, gp, p, degbound, contbound)\n        except ModularGCDFailed:\n            m = 1\n            continue\n        if hp is None:\n            continue\n        hp = hp.mul_ground(gamma).trunc_ground(p)\n        if m == 1:\n            m = p\n            hlastm = hp\n            continue\n        hm = _chinese_remainder_reconstruction_multivariate(hp, hlastm, p, m)\n        m *= p\n        if not hm == hlastm:\n            hlastm = hm\n            continue\n        h = hm.primitive()[1]\n        (fquo, frem) = f.div(h)\n        (gquo, grem) = g.div(h)\n        if not frem and (not grem):\n            if h.LC < 0:\n                ch = -ch\n            h = h.mul_ground(ch)\n            cff = fquo.mul_ground(cf // ch)\n            cfg = gquo.mul_ground(cg // ch)\n            return (h, cff, cfg)",
        "mutated": [
            "def modgcd_multivariate(f, g):\n    if False:\n        i = 10\n    '\\n    Compute the GCD of two polynomials in `\\\\mathbb{Z}[x_0, \\\\ldots, x_{k-1}]`\\n    using a modular algorithm.\\n\\n    The algorithm computes the GCD of two multivariate integer polynomials\\n    `f` and `g` by calculating the GCD in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]` for suitable primes `p` and then\\n    reconstructing the coefficients with the Chinese Remainder Theorem. To\\n    compute the multivariate GCD over `\\\\mathbb{Z}_p` the recursive\\n    subroutine :func:`_modgcd_multivariate_p` is used. To verify the result in\\n    `\\\\mathbb{Z}[x_0, \\\\ldots, x_{k-1}]`, trial division is done, but only for\\n    candidates which are very likely the desired GCD.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        multivariate integer polynomial\\n    g : PolyElement\\n        multivariate integer polynomial\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of the polynomials `f` and `g`\\n    cff : PolyElement\\n        cofactor of `f`, i.e. `\\\\frac{f}{h}`\\n    cfg : PolyElement\\n        cofactor of `g`, i.e. `\\\\frac{g}{h}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import modgcd_multivariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n\\n    >>> f = x**2 - y**2\\n    >>> g = x**2 + 2*x*y + y**2\\n\\n    >>> h, cff, cfg = modgcd_multivariate(f, g)\\n    >>> h, cff, cfg\\n    (x + y, x - y, x + y)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n\\n    >>> f = x*z**2 - y*z**2\\n    >>> g = x**2*z + z\\n\\n    >>> h, cff, cfg = modgcd_multivariate(f, g)\\n    >>> h, cff, cfg\\n    (z, x*z - y*z, x**2 + 1)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n    2. [Brown71]_\\n\\n    See also\\n    ========\\n\\n    _modgcd_multivariate_p\\n\\n    '\n    assert f.ring == g.ring and f.ring.domain.is_ZZ\n    result = _trivial_gcd(f, g)\n    if result is not None:\n        return result\n    ring = f.ring\n    k = ring.ngens\n    (cf, f) = f.primitive()\n    (cg, g) = g.primitive()\n    ch = ring.domain.gcd(cf, cg)\n    gamma = ring.domain.gcd(f.LC, g.LC)\n    badprimes = ring.domain.one\n    for i in range(k):\n        badprimes *= ring.domain.gcd(_swap(f, i).LC, _swap(g, i).LC)\n    degbound = [min(fdeg, gdeg) for (fdeg, gdeg) in zip(f.degrees(), g.degrees())]\n    contbound = list(degbound)\n    m = 1\n    p = 1\n    while True:\n        p = nextprime(p)\n        while badprimes % p == 0:\n            p = nextprime(p)\n        fp = f.trunc_ground(p)\n        gp = g.trunc_ground(p)\n        try:\n            hp = _modgcd_multivariate_p(fp, gp, p, degbound, contbound)\n        except ModularGCDFailed:\n            m = 1\n            continue\n        if hp is None:\n            continue\n        hp = hp.mul_ground(gamma).trunc_ground(p)\n        if m == 1:\n            m = p\n            hlastm = hp\n            continue\n        hm = _chinese_remainder_reconstruction_multivariate(hp, hlastm, p, m)\n        m *= p\n        if not hm == hlastm:\n            hlastm = hm\n            continue\n        h = hm.primitive()[1]\n        (fquo, frem) = f.div(h)\n        (gquo, grem) = g.div(h)\n        if not frem and (not grem):\n            if h.LC < 0:\n                ch = -ch\n            h = h.mul_ground(ch)\n            cff = fquo.mul_ground(cf // ch)\n            cfg = gquo.mul_ground(cg // ch)\n            return (h, cff, cfg)",
            "def modgcd_multivariate(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the GCD of two polynomials in `\\\\mathbb{Z}[x_0, \\\\ldots, x_{k-1}]`\\n    using a modular algorithm.\\n\\n    The algorithm computes the GCD of two multivariate integer polynomials\\n    `f` and `g` by calculating the GCD in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]` for suitable primes `p` and then\\n    reconstructing the coefficients with the Chinese Remainder Theorem. To\\n    compute the multivariate GCD over `\\\\mathbb{Z}_p` the recursive\\n    subroutine :func:`_modgcd_multivariate_p` is used. To verify the result in\\n    `\\\\mathbb{Z}[x_0, \\\\ldots, x_{k-1}]`, trial division is done, but only for\\n    candidates which are very likely the desired GCD.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        multivariate integer polynomial\\n    g : PolyElement\\n        multivariate integer polynomial\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of the polynomials `f` and `g`\\n    cff : PolyElement\\n        cofactor of `f`, i.e. `\\\\frac{f}{h}`\\n    cfg : PolyElement\\n        cofactor of `g`, i.e. `\\\\frac{g}{h}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import modgcd_multivariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n\\n    >>> f = x**2 - y**2\\n    >>> g = x**2 + 2*x*y + y**2\\n\\n    >>> h, cff, cfg = modgcd_multivariate(f, g)\\n    >>> h, cff, cfg\\n    (x + y, x - y, x + y)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n\\n    >>> f = x*z**2 - y*z**2\\n    >>> g = x**2*z + z\\n\\n    >>> h, cff, cfg = modgcd_multivariate(f, g)\\n    >>> h, cff, cfg\\n    (z, x*z - y*z, x**2 + 1)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n    2. [Brown71]_\\n\\n    See also\\n    ========\\n\\n    _modgcd_multivariate_p\\n\\n    '\n    assert f.ring == g.ring and f.ring.domain.is_ZZ\n    result = _trivial_gcd(f, g)\n    if result is not None:\n        return result\n    ring = f.ring\n    k = ring.ngens\n    (cf, f) = f.primitive()\n    (cg, g) = g.primitive()\n    ch = ring.domain.gcd(cf, cg)\n    gamma = ring.domain.gcd(f.LC, g.LC)\n    badprimes = ring.domain.one\n    for i in range(k):\n        badprimes *= ring.domain.gcd(_swap(f, i).LC, _swap(g, i).LC)\n    degbound = [min(fdeg, gdeg) for (fdeg, gdeg) in zip(f.degrees(), g.degrees())]\n    contbound = list(degbound)\n    m = 1\n    p = 1\n    while True:\n        p = nextprime(p)\n        while badprimes % p == 0:\n            p = nextprime(p)\n        fp = f.trunc_ground(p)\n        gp = g.trunc_ground(p)\n        try:\n            hp = _modgcd_multivariate_p(fp, gp, p, degbound, contbound)\n        except ModularGCDFailed:\n            m = 1\n            continue\n        if hp is None:\n            continue\n        hp = hp.mul_ground(gamma).trunc_ground(p)\n        if m == 1:\n            m = p\n            hlastm = hp\n            continue\n        hm = _chinese_remainder_reconstruction_multivariate(hp, hlastm, p, m)\n        m *= p\n        if not hm == hlastm:\n            hlastm = hm\n            continue\n        h = hm.primitive()[1]\n        (fquo, frem) = f.div(h)\n        (gquo, grem) = g.div(h)\n        if not frem and (not grem):\n            if h.LC < 0:\n                ch = -ch\n            h = h.mul_ground(ch)\n            cff = fquo.mul_ground(cf // ch)\n            cfg = gquo.mul_ground(cg // ch)\n            return (h, cff, cfg)",
            "def modgcd_multivariate(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the GCD of two polynomials in `\\\\mathbb{Z}[x_0, \\\\ldots, x_{k-1}]`\\n    using a modular algorithm.\\n\\n    The algorithm computes the GCD of two multivariate integer polynomials\\n    `f` and `g` by calculating the GCD in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]` for suitable primes `p` and then\\n    reconstructing the coefficients with the Chinese Remainder Theorem. To\\n    compute the multivariate GCD over `\\\\mathbb{Z}_p` the recursive\\n    subroutine :func:`_modgcd_multivariate_p` is used. To verify the result in\\n    `\\\\mathbb{Z}[x_0, \\\\ldots, x_{k-1}]`, trial division is done, but only for\\n    candidates which are very likely the desired GCD.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        multivariate integer polynomial\\n    g : PolyElement\\n        multivariate integer polynomial\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of the polynomials `f` and `g`\\n    cff : PolyElement\\n        cofactor of `f`, i.e. `\\\\frac{f}{h}`\\n    cfg : PolyElement\\n        cofactor of `g`, i.e. `\\\\frac{g}{h}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import modgcd_multivariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n\\n    >>> f = x**2 - y**2\\n    >>> g = x**2 + 2*x*y + y**2\\n\\n    >>> h, cff, cfg = modgcd_multivariate(f, g)\\n    >>> h, cff, cfg\\n    (x + y, x - y, x + y)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n\\n    >>> f = x*z**2 - y*z**2\\n    >>> g = x**2*z + z\\n\\n    >>> h, cff, cfg = modgcd_multivariate(f, g)\\n    >>> h, cff, cfg\\n    (z, x*z - y*z, x**2 + 1)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n    2. [Brown71]_\\n\\n    See also\\n    ========\\n\\n    _modgcd_multivariate_p\\n\\n    '\n    assert f.ring == g.ring and f.ring.domain.is_ZZ\n    result = _trivial_gcd(f, g)\n    if result is not None:\n        return result\n    ring = f.ring\n    k = ring.ngens\n    (cf, f) = f.primitive()\n    (cg, g) = g.primitive()\n    ch = ring.domain.gcd(cf, cg)\n    gamma = ring.domain.gcd(f.LC, g.LC)\n    badprimes = ring.domain.one\n    for i in range(k):\n        badprimes *= ring.domain.gcd(_swap(f, i).LC, _swap(g, i).LC)\n    degbound = [min(fdeg, gdeg) for (fdeg, gdeg) in zip(f.degrees(), g.degrees())]\n    contbound = list(degbound)\n    m = 1\n    p = 1\n    while True:\n        p = nextprime(p)\n        while badprimes % p == 0:\n            p = nextprime(p)\n        fp = f.trunc_ground(p)\n        gp = g.trunc_ground(p)\n        try:\n            hp = _modgcd_multivariate_p(fp, gp, p, degbound, contbound)\n        except ModularGCDFailed:\n            m = 1\n            continue\n        if hp is None:\n            continue\n        hp = hp.mul_ground(gamma).trunc_ground(p)\n        if m == 1:\n            m = p\n            hlastm = hp\n            continue\n        hm = _chinese_remainder_reconstruction_multivariate(hp, hlastm, p, m)\n        m *= p\n        if not hm == hlastm:\n            hlastm = hm\n            continue\n        h = hm.primitive()[1]\n        (fquo, frem) = f.div(h)\n        (gquo, grem) = g.div(h)\n        if not frem and (not grem):\n            if h.LC < 0:\n                ch = -ch\n            h = h.mul_ground(ch)\n            cff = fquo.mul_ground(cf // ch)\n            cfg = gquo.mul_ground(cg // ch)\n            return (h, cff, cfg)",
            "def modgcd_multivariate(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the GCD of two polynomials in `\\\\mathbb{Z}[x_0, \\\\ldots, x_{k-1}]`\\n    using a modular algorithm.\\n\\n    The algorithm computes the GCD of two multivariate integer polynomials\\n    `f` and `g` by calculating the GCD in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]` for suitable primes `p` and then\\n    reconstructing the coefficients with the Chinese Remainder Theorem. To\\n    compute the multivariate GCD over `\\\\mathbb{Z}_p` the recursive\\n    subroutine :func:`_modgcd_multivariate_p` is used. To verify the result in\\n    `\\\\mathbb{Z}[x_0, \\\\ldots, x_{k-1}]`, trial division is done, but only for\\n    candidates which are very likely the desired GCD.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        multivariate integer polynomial\\n    g : PolyElement\\n        multivariate integer polynomial\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of the polynomials `f` and `g`\\n    cff : PolyElement\\n        cofactor of `f`, i.e. `\\\\frac{f}{h}`\\n    cfg : PolyElement\\n        cofactor of `g`, i.e. `\\\\frac{g}{h}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import modgcd_multivariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n\\n    >>> f = x**2 - y**2\\n    >>> g = x**2 + 2*x*y + y**2\\n\\n    >>> h, cff, cfg = modgcd_multivariate(f, g)\\n    >>> h, cff, cfg\\n    (x + y, x - y, x + y)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n\\n    >>> f = x*z**2 - y*z**2\\n    >>> g = x**2*z + z\\n\\n    >>> h, cff, cfg = modgcd_multivariate(f, g)\\n    >>> h, cff, cfg\\n    (z, x*z - y*z, x**2 + 1)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n    2. [Brown71]_\\n\\n    See also\\n    ========\\n\\n    _modgcd_multivariate_p\\n\\n    '\n    assert f.ring == g.ring and f.ring.domain.is_ZZ\n    result = _trivial_gcd(f, g)\n    if result is not None:\n        return result\n    ring = f.ring\n    k = ring.ngens\n    (cf, f) = f.primitive()\n    (cg, g) = g.primitive()\n    ch = ring.domain.gcd(cf, cg)\n    gamma = ring.domain.gcd(f.LC, g.LC)\n    badprimes = ring.domain.one\n    for i in range(k):\n        badprimes *= ring.domain.gcd(_swap(f, i).LC, _swap(g, i).LC)\n    degbound = [min(fdeg, gdeg) for (fdeg, gdeg) in zip(f.degrees(), g.degrees())]\n    contbound = list(degbound)\n    m = 1\n    p = 1\n    while True:\n        p = nextprime(p)\n        while badprimes % p == 0:\n            p = nextprime(p)\n        fp = f.trunc_ground(p)\n        gp = g.trunc_ground(p)\n        try:\n            hp = _modgcd_multivariate_p(fp, gp, p, degbound, contbound)\n        except ModularGCDFailed:\n            m = 1\n            continue\n        if hp is None:\n            continue\n        hp = hp.mul_ground(gamma).trunc_ground(p)\n        if m == 1:\n            m = p\n            hlastm = hp\n            continue\n        hm = _chinese_remainder_reconstruction_multivariate(hp, hlastm, p, m)\n        m *= p\n        if not hm == hlastm:\n            hlastm = hm\n            continue\n        h = hm.primitive()[1]\n        (fquo, frem) = f.div(h)\n        (gquo, grem) = g.div(h)\n        if not frem and (not grem):\n            if h.LC < 0:\n                ch = -ch\n            h = h.mul_ground(ch)\n            cff = fquo.mul_ground(cf // ch)\n            cfg = gquo.mul_ground(cg // ch)\n            return (h, cff, cfg)",
            "def modgcd_multivariate(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the GCD of two polynomials in `\\\\mathbb{Z}[x_0, \\\\ldots, x_{k-1}]`\\n    using a modular algorithm.\\n\\n    The algorithm computes the GCD of two multivariate integer polynomials\\n    `f` and `g` by calculating the GCD in\\n    `\\\\mathbb{Z}_p[x_0, \\\\ldots, x_{k-1}]` for suitable primes `p` and then\\n    reconstructing the coefficients with the Chinese Remainder Theorem. To\\n    compute the multivariate GCD over `\\\\mathbb{Z}_p` the recursive\\n    subroutine :func:`_modgcd_multivariate_p` is used. To verify the result in\\n    `\\\\mathbb{Z}[x_0, \\\\ldots, x_{k-1}]`, trial division is done, but only for\\n    candidates which are very likely the desired GCD.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        multivariate integer polynomial\\n    g : PolyElement\\n        multivariate integer polynomial\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of the polynomials `f` and `g`\\n    cff : PolyElement\\n        cofactor of `f`, i.e. `\\\\frac{f}{h}`\\n    cfg : PolyElement\\n        cofactor of `g`, i.e. `\\\\frac{g}{h}`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import modgcd_multivariate\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, y = ring(\"x, y\", ZZ)\\n\\n    >>> f = x**2 - y**2\\n    >>> g = x**2 + 2*x*y + y**2\\n\\n    >>> h, cff, cfg = modgcd_multivariate(f, g)\\n    >>> h, cff, cfg\\n    (x + y, x - y, x + y)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\\n\\n    >>> f = x*z**2 - y*z**2\\n    >>> g = x**2*z + z\\n\\n    >>> h, cff, cfg = modgcd_multivariate(f, g)\\n    >>> h, cff, cfg\\n    (z, x*z - y*z, x**2 + 1)\\n\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    References\\n    ==========\\n\\n    1. [Monagan00]_\\n    2. [Brown71]_\\n\\n    See also\\n    ========\\n\\n    _modgcd_multivariate_p\\n\\n    '\n    assert f.ring == g.ring and f.ring.domain.is_ZZ\n    result = _trivial_gcd(f, g)\n    if result is not None:\n        return result\n    ring = f.ring\n    k = ring.ngens\n    (cf, f) = f.primitive()\n    (cg, g) = g.primitive()\n    ch = ring.domain.gcd(cf, cg)\n    gamma = ring.domain.gcd(f.LC, g.LC)\n    badprimes = ring.domain.one\n    for i in range(k):\n        badprimes *= ring.domain.gcd(_swap(f, i).LC, _swap(g, i).LC)\n    degbound = [min(fdeg, gdeg) for (fdeg, gdeg) in zip(f.degrees(), g.degrees())]\n    contbound = list(degbound)\n    m = 1\n    p = 1\n    while True:\n        p = nextprime(p)\n        while badprimes % p == 0:\n            p = nextprime(p)\n        fp = f.trunc_ground(p)\n        gp = g.trunc_ground(p)\n        try:\n            hp = _modgcd_multivariate_p(fp, gp, p, degbound, contbound)\n        except ModularGCDFailed:\n            m = 1\n            continue\n        if hp is None:\n            continue\n        hp = hp.mul_ground(gamma).trunc_ground(p)\n        if m == 1:\n            m = p\n            hlastm = hp\n            continue\n        hm = _chinese_remainder_reconstruction_multivariate(hp, hlastm, p, m)\n        m *= p\n        if not hm == hlastm:\n            hlastm = hm\n            continue\n        h = hm.primitive()[1]\n        (fquo, frem) = f.div(h)\n        (gquo, grem) = g.div(h)\n        if not frem and (not grem):\n            if h.LC < 0:\n                ch = -ch\n            h = h.mul_ground(ch)\n            cff = fquo.mul_ground(cf // ch)\n            cfg = gquo.mul_ground(cg // ch)\n            return (h, cff, cfg)"
        ]
    },
    {
        "func_name": "_gf_div",
        "original": "def _gf_div(f, g, p):\n    \"\"\"\n    Compute `\\\\frac f g` modulo `p` for two univariate polynomials over\n    `\\\\mathbb Z_p`.\n    \"\"\"\n    ring = f.ring\n    (densequo, denserem) = gf_div(f.to_dense(), g.to_dense(), p, ring.domain)\n    return (ring.from_dense(densequo), ring.from_dense(denserem))",
        "mutated": [
            "def _gf_div(f, g, p):\n    if False:\n        i = 10\n    '\\n    Compute `\\\\frac f g` modulo `p` for two univariate polynomials over\\n    `\\\\mathbb Z_p`.\\n    '\n    ring = f.ring\n    (densequo, denserem) = gf_div(f.to_dense(), g.to_dense(), p, ring.domain)\n    return (ring.from_dense(densequo), ring.from_dense(denserem))",
            "def _gf_div(f, g, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute `\\\\frac f g` modulo `p` for two univariate polynomials over\\n    `\\\\mathbb Z_p`.\\n    '\n    ring = f.ring\n    (densequo, denserem) = gf_div(f.to_dense(), g.to_dense(), p, ring.domain)\n    return (ring.from_dense(densequo), ring.from_dense(denserem))",
            "def _gf_div(f, g, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute `\\\\frac f g` modulo `p` for two univariate polynomials over\\n    `\\\\mathbb Z_p`.\\n    '\n    ring = f.ring\n    (densequo, denserem) = gf_div(f.to_dense(), g.to_dense(), p, ring.domain)\n    return (ring.from_dense(densequo), ring.from_dense(denserem))",
            "def _gf_div(f, g, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute `\\\\frac f g` modulo `p` for two univariate polynomials over\\n    `\\\\mathbb Z_p`.\\n    '\n    ring = f.ring\n    (densequo, denserem) = gf_div(f.to_dense(), g.to_dense(), p, ring.domain)\n    return (ring.from_dense(densequo), ring.from_dense(denserem))",
            "def _gf_div(f, g, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute `\\\\frac f g` modulo `p` for two univariate polynomials over\\n    `\\\\mathbb Z_p`.\\n    '\n    ring = f.ring\n    (densequo, denserem) = gf_div(f.to_dense(), g.to_dense(), p, ring.domain)\n    return (ring.from_dense(densequo), ring.from_dense(denserem))"
        ]
    },
    {
        "func_name": "_rational_function_reconstruction",
        "original": "def _rational_function_reconstruction(c, p, m):\n    \"\"\"\n    Reconstruct a rational function `\\\\frac a b` in `\\\\mathbb Z_p(t)` from\n\n    .. math::\n\n        c = \\\\frac a b \\\\; \\\\mathrm{mod} \\\\, m,\n\n    where `c` and `m` are polynomials in `\\\\mathbb Z_p[t]` and `m` has\n    positive degree.\n\n    The algorithm is based on the Euclidean Algorithm. In general, `m` is\n    not irreducible, so it is possible that `b` is not invertible modulo\n    `m`. In that case ``None`` is returned.\n\n    Parameters\n    ==========\n\n    c : PolyElement\n        univariate polynomial in `\\\\mathbb Z[t]`\n    p : Integer\n        prime number\n    m : PolyElement\n        modulus, not necessarily irreducible\n\n    Returns\n    =======\n\n    frac : FracElement\n        either `\\\\frac a b` in `\\\\mathbb Z(t)` or ``None``\n\n    References\n    ==========\n\n    1. [Hoeij04]_\n\n    \"\"\"\n    ring = c.ring\n    domain = ring.domain\n    M = m.degree()\n    N = M // 2\n    D = M - N - 1\n    (r0, s0) = (m, ring.zero)\n    (r1, s1) = (c, ring.one)\n    while r1.degree() > N:\n        quo = _gf_div(r0, r1, p)[0]\n        (r0, r1) = (r1, (r0 - quo * r1).trunc_ground(p))\n        (s0, s1) = (s1, (s0 - quo * s1).trunc_ground(p))\n    (a, b) = (r1, s1)\n    if b.degree() > D or _gf_gcd(b, m, p) != 1:\n        return None\n    lc = b.LC\n    if lc != 1:\n        lcinv = domain.invert(lc, p)\n        a = a.mul_ground(lcinv).trunc_ground(p)\n        b = b.mul_ground(lcinv).trunc_ground(p)\n    field = ring.to_field()\n    return field(a) / field(b)",
        "mutated": [
            "def _rational_function_reconstruction(c, p, m):\n    if False:\n        i = 10\n    '\\n    Reconstruct a rational function `\\\\frac a b` in `\\\\mathbb Z_p(t)` from\\n\\n    .. math::\\n\\n        c = \\\\frac a b \\\\; \\\\mathrm{mod} \\\\, m,\\n\\n    where `c` and `m` are polynomials in `\\\\mathbb Z_p[t]` and `m` has\\n    positive degree.\\n\\n    The algorithm is based on the Euclidean Algorithm. In general, `m` is\\n    not irreducible, so it is possible that `b` is not invertible modulo\\n    `m`. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    c : PolyElement\\n        univariate polynomial in `\\\\mathbb Z[t]`\\n    p : Integer\\n        prime number\\n    m : PolyElement\\n        modulus, not necessarily irreducible\\n\\n    Returns\\n    =======\\n\\n    frac : FracElement\\n        either `\\\\frac a b` in `\\\\mathbb Z(t)` or ``None``\\n\\n    References\\n    ==========\\n\\n    1. [Hoeij04]_\\n\\n    '\n    ring = c.ring\n    domain = ring.domain\n    M = m.degree()\n    N = M // 2\n    D = M - N - 1\n    (r0, s0) = (m, ring.zero)\n    (r1, s1) = (c, ring.one)\n    while r1.degree() > N:\n        quo = _gf_div(r0, r1, p)[0]\n        (r0, r1) = (r1, (r0 - quo * r1).trunc_ground(p))\n        (s0, s1) = (s1, (s0 - quo * s1).trunc_ground(p))\n    (a, b) = (r1, s1)\n    if b.degree() > D or _gf_gcd(b, m, p) != 1:\n        return None\n    lc = b.LC\n    if lc != 1:\n        lcinv = domain.invert(lc, p)\n        a = a.mul_ground(lcinv).trunc_ground(p)\n        b = b.mul_ground(lcinv).trunc_ground(p)\n    field = ring.to_field()\n    return field(a) / field(b)",
            "def _rational_function_reconstruction(c, p, m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Reconstruct a rational function `\\\\frac a b` in `\\\\mathbb Z_p(t)` from\\n\\n    .. math::\\n\\n        c = \\\\frac a b \\\\; \\\\mathrm{mod} \\\\, m,\\n\\n    where `c` and `m` are polynomials in `\\\\mathbb Z_p[t]` and `m` has\\n    positive degree.\\n\\n    The algorithm is based on the Euclidean Algorithm. In general, `m` is\\n    not irreducible, so it is possible that `b` is not invertible modulo\\n    `m`. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    c : PolyElement\\n        univariate polynomial in `\\\\mathbb Z[t]`\\n    p : Integer\\n        prime number\\n    m : PolyElement\\n        modulus, not necessarily irreducible\\n\\n    Returns\\n    =======\\n\\n    frac : FracElement\\n        either `\\\\frac a b` in `\\\\mathbb Z(t)` or ``None``\\n\\n    References\\n    ==========\\n\\n    1. [Hoeij04]_\\n\\n    '\n    ring = c.ring\n    domain = ring.domain\n    M = m.degree()\n    N = M // 2\n    D = M - N - 1\n    (r0, s0) = (m, ring.zero)\n    (r1, s1) = (c, ring.one)\n    while r1.degree() > N:\n        quo = _gf_div(r0, r1, p)[0]\n        (r0, r1) = (r1, (r0 - quo * r1).trunc_ground(p))\n        (s0, s1) = (s1, (s0 - quo * s1).trunc_ground(p))\n    (a, b) = (r1, s1)\n    if b.degree() > D or _gf_gcd(b, m, p) != 1:\n        return None\n    lc = b.LC\n    if lc != 1:\n        lcinv = domain.invert(lc, p)\n        a = a.mul_ground(lcinv).trunc_ground(p)\n        b = b.mul_ground(lcinv).trunc_ground(p)\n    field = ring.to_field()\n    return field(a) / field(b)",
            "def _rational_function_reconstruction(c, p, m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Reconstruct a rational function `\\\\frac a b` in `\\\\mathbb Z_p(t)` from\\n\\n    .. math::\\n\\n        c = \\\\frac a b \\\\; \\\\mathrm{mod} \\\\, m,\\n\\n    where `c` and `m` are polynomials in `\\\\mathbb Z_p[t]` and `m` has\\n    positive degree.\\n\\n    The algorithm is based on the Euclidean Algorithm. In general, `m` is\\n    not irreducible, so it is possible that `b` is not invertible modulo\\n    `m`. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    c : PolyElement\\n        univariate polynomial in `\\\\mathbb Z[t]`\\n    p : Integer\\n        prime number\\n    m : PolyElement\\n        modulus, not necessarily irreducible\\n\\n    Returns\\n    =======\\n\\n    frac : FracElement\\n        either `\\\\frac a b` in `\\\\mathbb Z(t)` or ``None``\\n\\n    References\\n    ==========\\n\\n    1. [Hoeij04]_\\n\\n    '\n    ring = c.ring\n    domain = ring.domain\n    M = m.degree()\n    N = M // 2\n    D = M - N - 1\n    (r0, s0) = (m, ring.zero)\n    (r1, s1) = (c, ring.one)\n    while r1.degree() > N:\n        quo = _gf_div(r0, r1, p)[0]\n        (r0, r1) = (r1, (r0 - quo * r1).trunc_ground(p))\n        (s0, s1) = (s1, (s0 - quo * s1).trunc_ground(p))\n    (a, b) = (r1, s1)\n    if b.degree() > D or _gf_gcd(b, m, p) != 1:\n        return None\n    lc = b.LC\n    if lc != 1:\n        lcinv = domain.invert(lc, p)\n        a = a.mul_ground(lcinv).trunc_ground(p)\n        b = b.mul_ground(lcinv).trunc_ground(p)\n    field = ring.to_field()\n    return field(a) / field(b)",
            "def _rational_function_reconstruction(c, p, m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Reconstruct a rational function `\\\\frac a b` in `\\\\mathbb Z_p(t)` from\\n\\n    .. math::\\n\\n        c = \\\\frac a b \\\\; \\\\mathrm{mod} \\\\, m,\\n\\n    where `c` and `m` are polynomials in `\\\\mathbb Z_p[t]` and `m` has\\n    positive degree.\\n\\n    The algorithm is based on the Euclidean Algorithm. In general, `m` is\\n    not irreducible, so it is possible that `b` is not invertible modulo\\n    `m`. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    c : PolyElement\\n        univariate polynomial in `\\\\mathbb Z[t]`\\n    p : Integer\\n        prime number\\n    m : PolyElement\\n        modulus, not necessarily irreducible\\n\\n    Returns\\n    =======\\n\\n    frac : FracElement\\n        either `\\\\frac a b` in `\\\\mathbb Z(t)` or ``None``\\n\\n    References\\n    ==========\\n\\n    1. [Hoeij04]_\\n\\n    '\n    ring = c.ring\n    domain = ring.domain\n    M = m.degree()\n    N = M // 2\n    D = M - N - 1\n    (r0, s0) = (m, ring.zero)\n    (r1, s1) = (c, ring.one)\n    while r1.degree() > N:\n        quo = _gf_div(r0, r1, p)[0]\n        (r0, r1) = (r1, (r0 - quo * r1).trunc_ground(p))\n        (s0, s1) = (s1, (s0 - quo * s1).trunc_ground(p))\n    (a, b) = (r1, s1)\n    if b.degree() > D or _gf_gcd(b, m, p) != 1:\n        return None\n    lc = b.LC\n    if lc != 1:\n        lcinv = domain.invert(lc, p)\n        a = a.mul_ground(lcinv).trunc_ground(p)\n        b = b.mul_ground(lcinv).trunc_ground(p)\n    field = ring.to_field()\n    return field(a) / field(b)",
            "def _rational_function_reconstruction(c, p, m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Reconstruct a rational function `\\\\frac a b` in `\\\\mathbb Z_p(t)` from\\n\\n    .. math::\\n\\n        c = \\\\frac a b \\\\; \\\\mathrm{mod} \\\\, m,\\n\\n    where `c` and `m` are polynomials in `\\\\mathbb Z_p[t]` and `m` has\\n    positive degree.\\n\\n    The algorithm is based on the Euclidean Algorithm. In general, `m` is\\n    not irreducible, so it is possible that `b` is not invertible modulo\\n    `m`. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    c : PolyElement\\n        univariate polynomial in `\\\\mathbb Z[t]`\\n    p : Integer\\n        prime number\\n    m : PolyElement\\n        modulus, not necessarily irreducible\\n\\n    Returns\\n    =======\\n\\n    frac : FracElement\\n        either `\\\\frac a b` in `\\\\mathbb Z(t)` or ``None``\\n\\n    References\\n    ==========\\n\\n    1. [Hoeij04]_\\n\\n    '\n    ring = c.ring\n    domain = ring.domain\n    M = m.degree()\n    N = M // 2\n    D = M - N - 1\n    (r0, s0) = (m, ring.zero)\n    (r1, s1) = (c, ring.one)\n    while r1.degree() > N:\n        quo = _gf_div(r0, r1, p)[0]\n        (r0, r1) = (r1, (r0 - quo * r1).trunc_ground(p))\n        (s0, s1) = (s1, (s0 - quo * s1).trunc_ground(p))\n    (a, b) = (r1, s1)\n    if b.degree() > D or _gf_gcd(b, m, p) != 1:\n        return None\n    lc = b.LC\n    if lc != 1:\n        lcinv = domain.invert(lc, p)\n        a = a.mul_ground(lcinv).trunc_ground(p)\n        b = b.mul_ground(lcinv).trunc_ground(p)\n    field = ring.to_field()\n    return field(a) / field(b)"
        ]
    },
    {
        "func_name": "_rational_reconstruction_func_coeffs",
        "original": "def _rational_reconstruction_func_coeffs(hm, p, m, ring, k):\n    \"\"\"\n    Reconstruct every coefficient `c_h` of a polynomial `h` in\n    `\\\\mathbb Z_p(t_k)[t_1, \\\\ldots, t_{k-1}][x, z]` from the corresponding\n    coefficient `c_{h_m}` of a polynomial `h_m` in\n    `\\\\mathbb Z_p[t_1, \\\\ldots, t_k][x, z] \\\\cong \\\\mathbb Z_p[t_k][t_1, \\\\ldots, t_{k-1}][x, z]`\n    such that\n\n    .. math::\n\n        c_{h_m} = c_h \\\\; \\\\mathrm{mod} \\\\, m,\n\n    where `m \\\\in \\\\mathbb Z_p[t]`.\n\n    The reconstruction is based on the Euclidean Algorithm. In general, `m`\n    is not irreducible, so it is possible that this fails for some\n    coefficient. In that case ``None`` is returned.\n\n    Parameters\n    ==========\n\n    hm : PolyElement\n        polynomial in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\n    p : Integer\n        prime number, modulus of `\\\\mathbb Z_p`\n    m : PolyElement\n        modulus, polynomial in `\\\\mathbb Z[t]`, not necessarily irreducible\n    ring : PolyRing\n        `\\\\mathbb Z(t_k)[t_1, \\\\ldots, t_{k-1}][x, z]`, `h` will be an\n        element of this ring\n    k : Integer\n        index of the parameter `t_k` which will be reconstructed\n\n    Returns\n    =======\n\n    h : PolyElement\n        reconstructed polynomial in\n        `\\\\mathbb Z(t_k)[t_1, \\\\ldots, t_{k-1}][x, z]` or ``None``\n\n    See also\n    ========\n\n    _rational_function_reconstruction\n\n    \"\"\"\n    h = ring.zero\n    for (monom, coeff) in hm.iterterms():\n        if k == 0:\n            coeffh = _rational_function_reconstruction(coeff, p, m)\n            if not coeffh:\n                return None\n        else:\n            coeffh = ring.domain.zero\n            for (mon, c) in coeff.drop_to_ground(k).iterterms():\n                ch = _rational_function_reconstruction(c, p, m)\n                if not ch:\n                    return None\n                coeffh[mon] = ch\n        h[monom] = coeffh\n    return h",
        "mutated": [
            "def _rational_reconstruction_func_coeffs(hm, p, m, ring, k):\n    if False:\n        i = 10\n    '\\n    Reconstruct every coefficient `c_h` of a polynomial `h` in\\n    `\\\\mathbb Z_p(t_k)[t_1, \\\\ldots, t_{k-1}][x, z]` from the corresponding\\n    coefficient `c_{h_m}` of a polynomial `h_m` in\\n    `\\\\mathbb Z_p[t_1, \\\\ldots, t_k][x, z] \\\\cong \\\\mathbb Z_p[t_k][t_1, \\\\ldots, t_{k-1}][x, z]`\\n    such that\\n\\n    .. math::\\n\\n        c_{h_m} = c_h \\\\; \\\\mathrm{mod} \\\\, m,\\n\\n    where `m \\\\in \\\\mathbb Z_p[t]`.\\n\\n    The reconstruction is based on the Euclidean Algorithm. In general, `m`\\n    is not irreducible, so it is possible that this fails for some\\n    coefficient. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    hm : PolyElement\\n        polynomial in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    p : Integer\\n        prime number, modulus of `\\\\mathbb Z_p`\\n    m : PolyElement\\n        modulus, polynomial in `\\\\mathbb Z[t]`, not necessarily irreducible\\n    ring : PolyRing\\n        `\\\\mathbb Z(t_k)[t_1, \\\\ldots, t_{k-1}][x, z]`, `h` will be an\\n        element of this ring\\n    k : Integer\\n        index of the parameter `t_k` which will be reconstructed\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        reconstructed polynomial in\\n        `\\\\mathbb Z(t_k)[t_1, \\\\ldots, t_{k-1}][x, z]` or ``None``\\n\\n    See also\\n    ========\\n\\n    _rational_function_reconstruction\\n\\n    '\n    h = ring.zero\n    for (monom, coeff) in hm.iterterms():\n        if k == 0:\n            coeffh = _rational_function_reconstruction(coeff, p, m)\n            if not coeffh:\n                return None\n        else:\n            coeffh = ring.domain.zero\n            for (mon, c) in coeff.drop_to_ground(k).iterterms():\n                ch = _rational_function_reconstruction(c, p, m)\n                if not ch:\n                    return None\n                coeffh[mon] = ch\n        h[monom] = coeffh\n    return h",
            "def _rational_reconstruction_func_coeffs(hm, p, m, ring, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Reconstruct every coefficient `c_h` of a polynomial `h` in\\n    `\\\\mathbb Z_p(t_k)[t_1, \\\\ldots, t_{k-1}][x, z]` from the corresponding\\n    coefficient `c_{h_m}` of a polynomial `h_m` in\\n    `\\\\mathbb Z_p[t_1, \\\\ldots, t_k][x, z] \\\\cong \\\\mathbb Z_p[t_k][t_1, \\\\ldots, t_{k-1}][x, z]`\\n    such that\\n\\n    .. math::\\n\\n        c_{h_m} = c_h \\\\; \\\\mathrm{mod} \\\\, m,\\n\\n    where `m \\\\in \\\\mathbb Z_p[t]`.\\n\\n    The reconstruction is based on the Euclidean Algorithm. In general, `m`\\n    is not irreducible, so it is possible that this fails for some\\n    coefficient. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    hm : PolyElement\\n        polynomial in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    p : Integer\\n        prime number, modulus of `\\\\mathbb Z_p`\\n    m : PolyElement\\n        modulus, polynomial in `\\\\mathbb Z[t]`, not necessarily irreducible\\n    ring : PolyRing\\n        `\\\\mathbb Z(t_k)[t_1, \\\\ldots, t_{k-1}][x, z]`, `h` will be an\\n        element of this ring\\n    k : Integer\\n        index of the parameter `t_k` which will be reconstructed\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        reconstructed polynomial in\\n        `\\\\mathbb Z(t_k)[t_1, \\\\ldots, t_{k-1}][x, z]` or ``None``\\n\\n    See also\\n    ========\\n\\n    _rational_function_reconstruction\\n\\n    '\n    h = ring.zero\n    for (monom, coeff) in hm.iterterms():\n        if k == 0:\n            coeffh = _rational_function_reconstruction(coeff, p, m)\n            if not coeffh:\n                return None\n        else:\n            coeffh = ring.domain.zero\n            for (mon, c) in coeff.drop_to_ground(k).iterterms():\n                ch = _rational_function_reconstruction(c, p, m)\n                if not ch:\n                    return None\n                coeffh[mon] = ch\n        h[monom] = coeffh\n    return h",
            "def _rational_reconstruction_func_coeffs(hm, p, m, ring, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Reconstruct every coefficient `c_h` of a polynomial `h` in\\n    `\\\\mathbb Z_p(t_k)[t_1, \\\\ldots, t_{k-1}][x, z]` from the corresponding\\n    coefficient `c_{h_m}` of a polynomial `h_m` in\\n    `\\\\mathbb Z_p[t_1, \\\\ldots, t_k][x, z] \\\\cong \\\\mathbb Z_p[t_k][t_1, \\\\ldots, t_{k-1}][x, z]`\\n    such that\\n\\n    .. math::\\n\\n        c_{h_m} = c_h \\\\; \\\\mathrm{mod} \\\\, m,\\n\\n    where `m \\\\in \\\\mathbb Z_p[t]`.\\n\\n    The reconstruction is based on the Euclidean Algorithm. In general, `m`\\n    is not irreducible, so it is possible that this fails for some\\n    coefficient. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    hm : PolyElement\\n        polynomial in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    p : Integer\\n        prime number, modulus of `\\\\mathbb Z_p`\\n    m : PolyElement\\n        modulus, polynomial in `\\\\mathbb Z[t]`, not necessarily irreducible\\n    ring : PolyRing\\n        `\\\\mathbb Z(t_k)[t_1, \\\\ldots, t_{k-1}][x, z]`, `h` will be an\\n        element of this ring\\n    k : Integer\\n        index of the parameter `t_k` which will be reconstructed\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        reconstructed polynomial in\\n        `\\\\mathbb Z(t_k)[t_1, \\\\ldots, t_{k-1}][x, z]` or ``None``\\n\\n    See also\\n    ========\\n\\n    _rational_function_reconstruction\\n\\n    '\n    h = ring.zero\n    for (monom, coeff) in hm.iterterms():\n        if k == 0:\n            coeffh = _rational_function_reconstruction(coeff, p, m)\n            if not coeffh:\n                return None\n        else:\n            coeffh = ring.domain.zero\n            for (mon, c) in coeff.drop_to_ground(k).iterterms():\n                ch = _rational_function_reconstruction(c, p, m)\n                if not ch:\n                    return None\n                coeffh[mon] = ch\n        h[monom] = coeffh\n    return h",
            "def _rational_reconstruction_func_coeffs(hm, p, m, ring, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Reconstruct every coefficient `c_h` of a polynomial `h` in\\n    `\\\\mathbb Z_p(t_k)[t_1, \\\\ldots, t_{k-1}][x, z]` from the corresponding\\n    coefficient `c_{h_m}` of a polynomial `h_m` in\\n    `\\\\mathbb Z_p[t_1, \\\\ldots, t_k][x, z] \\\\cong \\\\mathbb Z_p[t_k][t_1, \\\\ldots, t_{k-1}][x, z]`\\n    such that\\n\\n    .. math::\\n\\n        c_{h_m} = c_h \\\\; \\\\mathrm{mod} \\\\, m,\\n\\n    where `m \\\\in \\\\mathbb Z_p[t]`.\\n\\n    The reconstruction is based on the Euclidean Algorithm. In general, `m`\\n    is not irreducible, so it is possible that this fails for some\\n    coefficient. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    hm : PolyElement\\n        polynomial in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    p : Integer\\n        prime number, modulus of `\\\\mathbb Z_p`\\n    m : PolyElement\\n        modulus, polynomial in `\\\\mathbb Z[t]`, not necessarily irreducible\\n    ring : PolyRing\\n        `\\\\mathbb Z(t_k)[t_1, \\\\ldots, t_{k-1}][x, z]`, `h` will be an\\n        element of this ring\\n    k : Integer\\n        index of the parameter `t_k` which will be reconstructed\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        reconstructed polynomial in\\n        `\\\\mathbb Z(t_k)[t_1, \\\\ldots, t_{k-1}][x, z]` or ``None``\\n\\n    See also\\n    ========\\n\\n    _rational_function_reconstruction\\n\\n    '\n    h = ring.zero\n    for (monom, coeff) in hm.iterterms():\n        if k == 0:\n            coeffh = _rational_function_reconstruction(coeff, p, m)\n            if not coeffh:\n                return None\n        else:\n            coeffh = ring.domain.zero\n            for (mon, c) in coeff.drop_to_ground(k).iterterms():\n                ch = _rational_function_reconstruction(c, p, m)\n                if not ch:\n                    return None\n                coeffh[mon] = ch\n        h[monom] = coeffh\n    return h",
            "def _rational_reconstruction_func_coeffs(hm, p, m, ring, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Reconstruct every coefficient `c_h` of a polynomial `h` in\\n    `\\\\mathbb Z_p(t_k)[t_1, \\\\ldots, t_{k-1}][x, z]` from the corresponding\\n    coefficient `c_{h_m}` of a polynomial `h_m` in\\n    `\\\\mathbb Z_p[t_1, \\\\ldots, t_k][x, z] \\\\cong \\\\mathbb Z_p[t_k][t_1, \\\\ldots, t_{k-1}][x, z]`\\n    such that\\n\\n    .. math::\\n\\n        c_{h_m} = c_h \\\\; \\\\mathrm{mod} \\\\, m,\\n\\n    where `m \\\\in \\\\mathbb Z_p[t]`.\\n\\n    The reconstruction is based on the Euclidean Algorithm. In general, `m`\\n    is not irreducible, so it is possible that this fails for some\\n    coefficient. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    hm : PolyElement\\n        polynomial in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    p : Integer\\n        prime number, modulus of `\\\\mathbb Z_p`\\n    m : PolyElement\\n        modulus, polynomial in `\\\\mathbb Z[t]`, not necessarily irreducible\\n    ring : PolyRing\\n        `\\\\mathbb Z(t_k)[t_1, \\\\ldots, t_{k-1}][x, z]`, `h` will be an\\n        element of this ring\\n    k : Integer\\n        index of the parameter `t_k` which will be reconstructed\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        reconstructed polynomial in\\n        `\\\\mathbb Z(t_k)[t_1, \\\\ldots, t_{k-1}][x, z]` or ``None``\\n\\n    See also\\n    ========\\n\\n    _rational_function_reconstruction\\n\\n    '\n    h = ring.zero\n    for (monom, coeff) in hm.iterterms():\n        if k == 0:\n            coeffh = _rational_function_reconstruction(coeff, p, m)\n            if not coeffh:\n                return None\n        else:\n            coeffh = ring.domain.zero\n            for (mon, c) in coeff.drop_to_ground(k).iterterms():\n                ch = _rational_function_reconstruction(c, p, m)\n                if not ch:\n                    return None\n                coeffh[mon] = ch\n        h[monom] = coeffh\n    return h"
        ]
    },
    {
        "func_name": "_gf_gcdex",
        "original": "def _gf_gcdex(f, g, p):\n    \"\"\"\n    Extended Euclidean Algorithm for two univariate polynomials over\n    `\\\\mathbb Z_p`.\n\n    Returns polynomials `s, t` and `h`, such that `h` is the GCD of `f` and\n    `g` and `sf + tg = h \\\\; \\\\mathrm{mod} \\\\, p`.\n\n    \"\"\"\n    ring = f.ring\n    (s, t, h) = gf_gcdex(f.to_dense(), g.to_dense(), p, ring.domain)\n    return (ring.from_dense(s), ring.from_dense(t), ring.from_dense(h))",
        "mutated": [
            "def _gf_gcdex(f, g, p):\n    if False:\n        i = 10\n    '\\n    Extended Euclidean Algorithm for two univariate polynomials over\\n    `\\\\mathbb Z_p`.\\n\\n    Returns polynomials `s, t` and `h`, such that `h` is the GCD of `f` and\\n    `g` and `sf + tg = h \\\\; \\\\mathrm{mod} \\\\, p`.\\n\\n    '\n    ring = f.ring\n    (s, t, h) = gf_gcdex(f.to_dense(), g.to_dense(), p, ring.domain)\n    return (ring.from_dense(s), ring.from_dense(t), ring.from_dense(h))",
            "def _gf_gcdex(f, g, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Extended Euclidean Algorithm for two univariate polynomials over\\n    `\\\\mathbb Z_p`.\\n\\n    Returns polynomials `s, t` and `h`, such that `h` is the GCD of `f` and\\n    `g` and `sf + tg = h \\\\; \\\\mathrm{mod} \\\\, p`.\\n\\n    '\n    ring = f.ring\n    (s, t, h) = gf_gcdex(f.to_dense(), g.to_dense(), p, ring.domain)\n    return (ring.from_dense(s), ring.from_dense(t), ring.from_dense(h))",
            "def _gf_gcdex(f, g, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Extended Euclidean Algorithm for two univariate polynomials over\\n    `\\\\mathbb Z_p`.\\n\\n    Returns polynomials `s, t` and `h`, such that `h` is the GCD of `f` and\\n    `g` and `sf + tg = h \\\\; \\\\mathrm{mod} \\\\, p`.\\n\\n    '\n    ring = f.ring\n    (s, t, h) = gf_gcdex(f.to_dense(), g.to_dense(), p, ring.domain)\n    return (ring.from_dense(s), ring.from_dense(t), ring.from_dense(h))",
            "def _gf_gcdex(f, g, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Extended Euclidean Algorithm for two univariate polynomials over\\n    `\\\\mathbb Z_p`.\\n\\n    Returns polynomials `s, t` and `h`, such that `h` is the GCD of `f` and\\n    `g` and `sf + tg = h \\\\; \\\\mathrm{mod} \\\\, p`.\\n\\n    '\n    ring = f.ring\n    (s, t, h) = gf_gcdex(f.to_dense(), g.to_dense(), p, ring.domain)\n    return (ring.from_dense(s), ring.from_dense(t), ring.from_dense(h))",
            "def _gf_gcdex(f, g, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Extended Euclidean Algorithm for two univariate polynomials over\\n    `\\\\mathbb Z_p`.\\n\\n    Returns polynomials `s, t` and `h`, such that `h` is the GCD of `f` and\\n    `g` and `sf + tg = h \\\\; \\\\mathrm{mod} \\\\, p`.\\n\\n    '\n    ring = f.ring\n    (s, t, h) = gf_gcdex(f.to_dense(), g.to_dense(), p, ring.domain)\n    return (ring.from_dense(s), ring.from_dense(t), ring.from_dense(h))"
        ]
    },
    {
        "func_name": "_trunc",
        "original": "def _trunc(f, minpoly, p):\n    \"\"\"\n    Compute the reduced representation of a polynomial `f` in\n    `\\\\mathbb Z_p[z] / (\\\\check m_{\\\\alpha}(z))[x]`\n\n    Parameters\n    ==========\n\n    f : PolyElement\n        polynomial in `\\\\mathbb Z[x, z]`\n    minpoly : PolyElement\n        polynomial `\\\\check m_{\\\\alpha} \\\\in \\\\mathbb Z[z]`, not necessarily\n        irreducible\n    p : Integer\n        prime number, modulus of `\\\\mathbb Z_p`\n\n    Returns\n    =======\n\n    ftrunc : PolyElement\n        polynomial in `\\\\mathbb Z[x, z]`, reduced modulo\n        `\\\\check m_{\\\\alpha}(z)` and `p`\n\n    \"\"\"\n    ring = f.ring\n    minpoly = minpoly.set_ring(ring)\n    p_ = ring.ground_new(p)\n    return f.trunc_ground(p).rem([minpoly, p_]).trunc_ground(p)",
        "mutated": [
            "def _trunc(f, minpoly, p):\n    if False:\n        i = 10\n    '\\n    Compute the reduced representation of a polynomial `f` in\\n    `\\\\mathbb Z_p[z] / (\\\\check m_{\\\\alpha}(z))[x]`\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `\\\\mathbb Z[x, z]`\\n    minpoly : PolyElement\\n        polynomial `\\\\check m_{\\\\alpha} \\\\in \\\\mathbb Z[z]`, not necessarily\\n        irreducible\\n    p : Integer\\n        prime number, modulus of `\\\\mathbb Z_p`\\n\\n    Returns\\n    =======\\n\\n    ftrunc : PolyElement\\n        polynomial in `\\\\mathbb Z[x, z]`, reduced modulo\\n        `\\\\check m_{\\\\alpha}(z)` and `p`\\n\\n    '\n    ring = f.ring\n    minpoly = minpoly.set_ring(ring)\n    p_ = ring.ground_new(p)\n    return f.trunc_ground(p).rem([minpoly, p_]).trunc_ground(p)",
            "def _trunc(f, minpoly, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the reduced representation of a polynomial `f` in\\n    `\\\\mathbb Z_p[z] / (\\\\check m_{\\\\alpha}(z))[x]`\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `\\\\mathbb Z[x, z]`\\n    minpoly : PolyElement\\n        polynomial `\\\\check m_{\\\\alpha} \\\\in \\\\mathbb Z[z]`, not necessarily\\n        irreducible\\n    p : Integer\\n        prime number, modulus of `\\\\mathbb Z_p`\\n\\n    Returns\\n    =======\\n\\n    ftrunc : PolyElement\\n        polynomial in `\\\\mathbb Z[x, z]`, reduced modulo\\n        `\\\\check m_{\\\\alpha}(z)` and `p`\\n\\n    '\n    ring = f.ring\n    minpoly = minpoly.set_ring(ring)\n    p_ = ring.ground_new(p)\n    return f.trunc_ground(p).rem([minpoly, p_]).trunc_ground(p)",
            "def _trunc(f, minpoly, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the reduced representation of a polynomial `f` in\\n    `\\\\mathbb Z_p[z] / (\\\\check m_{\\\\alpha}(z))[x]`\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `\\\\mathbb Z[x, z]`\\n    minpoly : PolyElement\\n        polynomial `\\\\check m_{\\\\alpha} \\\\in \\\\mathbb Z[z]`, not necessarily\\n        irreducible\\n    p : Integer\\n        prime number, modulus of `\\\\mathbb Z_p`\\n\\n    Returns\\n    =======\\n\\n    ftrunc : PolyElement\\n        polynomial in `\\\\mathbb Z[x, z]`, reduced modulo\\n        `\\\\check m_{\\\\alpha}(z)` and `p`\\n\\n    '\n    ring = f.ring\n    minpoly = minpoly.set_ring(ring)\n    p_ = ring.ground_new(p)\n    return f.trunc_ground(p).rem([minpoly, p_]).trunc_ground(p)",
            "def _trunc(f, minpoly, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the reduced representation of a polynomial `f` in\\n    `\\\\mathbb Z_p[z] / (\\\\check m_{\\\\alpha}(z))[x]`\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `\\\\mathbb Z[x, z]`\\n    minpoly : PolyElement\\n        polynomial `\\\\check m_{\\\\alpha} \\\\in \\\\mathbb Z[z]`, not necessarily\\n        irreducible\\n    p : Integer\\n        prime number, modulus of `\\\\mathbb Z_p`\\n\\n    Returns\\n    =======\\n\\n    ftrunc : PolyElement\\n        polynomial in `\\\\mathbb Z[x, z]`, reduced modulo\\n        `\\\\check m_{\\\\alpha}(z)` and `p`\\n\\n    '\n    ring = f.ring\n    minpoly = minpoly.set_ring(ring)\n    p_ = ring.ground_new(p)\n    return f.trunc_ground(p).rem([minpoly, p_]).trunc_ground(p)",
            "def _trunc(f, minpoly, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the reduced representation of a polynomial `f` in\\n    `\\\\mathbb Z_p[z] / (\\\\check m_{\\\\alpha}(z))[x]`\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `\\\\mathbb Z[x, z]`\\n    minpoly : PolyElement\\n        polynomial `\\\\check m_{\\\\alpha} \\\\in \\\\mathbb Z[z]`, not necessarily\\n        irreducible\\n    p : Integer\\n        prime number, modulus of `\\\\mathbb Z_p`\\n\\n    Returns\\n    =======\\n\\n    ftrunc : PolyElement\\n        polynomial in `\\\\mathbb Z[x, z]`, reduced modulo\\n        `\\\\check m_{\\\\alpha}(z)` and `p`\\n\\n    '\n    ring = f.ring\n    minpoly = minpoly.set_ring(ring)\n    p_ = ring.ground_new(p)\n    return f.trunc_ground(p).rem([minpoly, p_]).trunc_ground(p)"
        ]
    },
    {
        "func_name": "_euclidean_algorithm",
        "original": "def _euclidean_algorithm(f, g, minpoly, p):\n    \"\"\"\n    Compute the monic GCD of two univariate polynomials in\n    `\\\\mathbb{Z}_p[z]/(\\\\check m_{\\\\alpha}(z))[x]` with the Euclidean\n    Algorithm.\n\n    In general, `\\\\check m_{\\\\alpha}(z)` is not irreducible, so it is possible\n    that some leading coefficient is not invertible modulo\n    `\\\\check m_{\\\\alpha}(z)`. In that case ``None`` is returned.\n\n    Parameters\n    ==========\n\n    f, g : PolyElement\n        polynomials in `\\\\mathbb Z[x, z]`\n    minpoly : PolyElement\n        polynomial in `\\\\mathbb Z[z]`, not necessarily irreducible\n    p : Integer\n        prime number, modulus of `\\\\mathbb Z_p`\n\n    Returns\n    =======\n\n    h : PolyElement\n        GCD of `f` and `g` in `\\\\mathbb Z[z, x]` or ``None``, coefficients\n        are in `\\\\left[ -\\\\frac{p-1} 2, \\\\frac{p-1} 2 \\\\right]`\n\n    \"\"\"\n    ring = f.ring\n    f = _trunc(f, minpoly, p)\n    g = _trunc(g, minpoly, p)\n    while g:\n        rem = f\n        deg = g.degree(0)\n        (lcinv, _, gcd) = _gf_gcdex(ring.dmp_LC(g), minpoly, p)\n        if not gcd == 1:\n            return None\n        while True:\n            degrem = rem.degree(0)\n            if degrem < deg:\n                break\n            quo = (lcinv * ring.dmp_LC(rem)).set_ring(ring)\n            rem = _trunc(rem - g.mul_monom((degrem - deg, 0)) * quo, minpoly, p)\n        f = g\n        g = rem\n    lcfinv = _gf_gcdex(ring.dmp_LC(f), minpoly, p)[0].set_ring(ring)\n    return _trunc(f * lcfinv, minpoly, p)",
        "mutated": [
            "def _euclidean_algorithm(f, g, minpoly, p):\n    if False:\n        i = 10\n    '\\n    Compute the monic GCD of two univariate polynomials in\\n    `\\\\mathbb{Z}_p[z]/(\\\\check m_{\\\\alpha}(z))[x]` with the Euclidean\\n    Algorithm.\\n\\n    In general, `\\\\check m_{\\\\alpha}(z)` is not irreducible, so it is possible\\n    that some leading coefficient is not invertible modulo\\n    `\\\\check m_{\\\\alpha}(z)`. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    f, g : PolyElement\\n        polynomials in `\\\\mathbb Z[x, z]`\\n    minpoly : PolyElement\\n        polynomial in `\\\\mathbb Z[z]`, not necessarily irreducible\\n    p : Integer\\n        prime number, modulus of `\\\\mathbb Z_p`\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of `f` and `g` in `\\\\mathbb Z[z, x]` or ``None``, coefficients\\n        are in `\\\\left[ -\\\\frac{p-1} 2, \\\\frac{p-1} 2 \\\\right]`\\n\\n    '\n    ring = f.ring\n    f = _trunc(f, minpoly, p)\n    g = _trunc(g, minpoly, p)\n    while g:\n        rem = f\n        deg = g.degree(0)\n        (lcinv, _, gcd) = _gf_gcdex(ring.dmp_LC(g), minpoly, p)\n        if not gcd == 1:\n            return None\n        while True:\n            degrem = rem.degree(0)\n            if degrem < deg:\n                break\n            quo = (lcinv * ring.dmp_LC(rem)).set_ring(ring)\n            rem = _trunc(rem - g.mul_monom((degrem - deg, 0)) * quo, minpoly, p)\n        f = g\n        g = rem\n    lcfinv = _gf_gcdex(ring.dmp_LC(f), minpoly, p)[0].set_ring(ring)\n    return _trunc(f * lcfinv, minpoly, p)",
            "def _euclidean_algorithm(f, g, minpoly, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the monic GCD of two univariate polynomials in\\n    `\\\\mathbb{Z}_p[z]/(\\\\check m_{\\\\alpha}(z))[x]` with the Euclidean\\n    Algorithm.\\n\\n    In general, `\\\\check m_{\\\\alpha}(z)` is not irreducible, so it is possible\\n    that some leading coefficient is not invertible modulo\\n    `\\\\check m_{\\\\alpha}(z)`. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    f, g : PolyElement\\n        polynomials in `\\\\mathbb Z[x, z]`\\n    minpoly : PolyElement\\n        polynomial in `\\\\mathbb Z[z]`, not necessarily irreducible\\n    p : Integer\\n        prime number, modulus of `\\\\mathbb Z_p`\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of `f` and `g` in `\\\\mathbb Z[z, x]` or ``None``, coefficients\\n        are in `\\\\left[ -\\\\frac{p-1} 2, \\\\frac{p-1} 2 \\\\right]`\\n\\n    '\n    ring = f.ring\n    f = _trunc(f, minpoly, p)\n    g = _trunc(g, minpoly, p)\n    while g:\n        rem = f\n        deg = g.degree(0)\n        (lcinv, _, gcd) = _gf_gcdex(ring.dmp_LC(g), minpoly, p)\n        if not gcd == 1:\n            return None\n        while True:\n            degrem = rem.degree(0)\n            if degrem < deg:\n                break\n            quo = (lcinv * ring.dmp_LC(rem)).set_ring(ring)\n            rem = _trunc(rem - g.mul_monom((degrem - deg, 0)) * quo, minpoly, p)\n        f = g\n        g = rem\n    lcfinv = _gf_gcdex(ring.dmp_LC(f), minpoly, p)[0].set_ring(ring)\n    return _trunc(f * lcfinv, minpoly, p)",
            "def _euclidean_algorithm(f, g, minpoly, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the monic GCD of two univariate polynomials in\\n    `\\\\mathbb{Z}_p[z]/(\\\\check m_{\\\\alpha}(z))[x]` with the Euclidean\\n    Algorithm.\\n\\n    In general, `\\\\check m_{\\\\alpha}(z)` is not irreducible, so it is possible\\n    that some leading coefficient is not invertible modulo\\n    `\\\\check m_{\\\\alpha}(z)`. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    f, g : PolyElement\\n        polynomials in `\\\\mathbb Z[x, z]`\\n    minpoly : PolyElement\\n        polynomial in `\\\\mathbb Z[z]`, not necessarily irreducible\\n    p : Integer\\n        prime number, modulus of `\\\\mathbb Z_p`\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of `f` and `g` in `\\\\mathbb Z[z, x]` or ``None``, coefficients\\n        are in `\\\\left[ -\\\\frac{p-1} 2, \\\\frac{p-1} 2 \\\\right]`\\n\\n    '\n    ring = f.ring\n    f = _trunc(f, minpoly, p)\n    g = _trunc(g, minpoly, p)\n    while g:\n        rem = f\n        deg = g.degree(0)\n        (lcinv, _, gcd) = _gf_gcdex(ring.dmp_LC(g), minpoly, p)\n        if not gcd == 1:\n            return None\n        while True:\n            degrem = rem.degree(0)\n            if degrem < deg:\n                break\n            quo = (lcinv * ring.dmp_LC(rem)).set_ring(ring)\n            rem = _trunc(rem - g.mul_monom((degrem - deg, 0)) * quo, minpoly, p)\n        f = g\n        g = rem\n    lcfinv = _gf_gcdex(ring.dmp_LC(f), minpoly, p)[0].set_ring(ring)\n    return _trunc(f * lcfinv, minpoly, p)",
            "def _euclidean_algorithm(f, g, minpoly, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the monic GCD of two univariate polynomials in\\n    `\\\\mathbb{Z}_p[z]/(\\\\check m_{\\\\alpha}(z))[x]` with the Euclidean\\n    Algorithm.\\n\\n    In general, `\\\\check m_{\\\\alpha}(z)` is not irreducible, so it is possible\\n    that some leading coefficient is not invertible modulo\\n    `\\\\check m_{\\\\alpha}(z)`. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    f, g : PolyElement\\n        polynomials in `\\\\mathbb Z[x, z]`\\n    minpoly : PolyElement\\n        polynomial in `\\\\mathbb Z[z]`, not necessarily irreducible\\n    p : Integer\\n        prime number, modulus of `\\\\mathbb Z_p`\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of `f` and `g` in `\\\\mathbb Z[z, x]` or ``None``, coefficients\\n        are in `\\\\left[ -\\\\frac{p-1} 2, \\\\frac{p-1} 2 \\\\right]`\\n\\n    '\n    ring = f.ring\n    f = _trunc(f, minpoly, p)\n    g = _trunc(g, minpoly, p)\n    while g:\n        rem = f\n        deg = g.degree(0)\n        (lcinv, _, gcd) = _gf_gcdex(ring.dmp_LC(g), minpoly, p)\n        if not gcd == 1:\n            return None\n        while True:\n            degrem = rem.degree(0)\n            if degrem < deg:\n                break\n            quo = (lcinv * ring.dmp_LC(rem)).set_ring(ring)\n            rem = _trunc(rem - g.mul_monom((degrem - deg, 0)) * quo, minpoly, p)\n        f = g\n        g = rem\n    lcfinv = _gf_gcdex(ring.dmp_LC(f), minpoly, p)[0].set_ring(ring)\n    return _trunc(f * lcfinv, minpoly, p)",
            "def _euclidean_algorithm(f, g, minpoly, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the monic GCD of two univariate polynomials in\\n    `\\\\mathbb{Z}_p[z]/(\\\\check m_{\\\\alpha}(z))[x]` with the Euclidean\\n    Algorithm.\\n\\n    In general, `\\\\check m_{\\\\alpha}(z)` is not irreducible, so it is possible\\n    that some leading coefficient is not invertible modulo\\n    `\\\\check m_{\\\\alpha}(z)`. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    f, g : PolyElement\\n        polynomials in `\\\\mathbb Z[x, z]`\\n    minpoly : PolyElement\\n        polynomial in `\\\\mathbb Z[z]`, not necessarily irreducible\\n    p : Integer\\n        prime number, modulus of `\\\\mathbb Z_p`\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        GCD of `f` and `g` in `\\\\mathbb Z[z, x]` or ``None``, coefficients\\n        are in `\\\\left[ -\\\\frac{p-1} 2, \\\\frac{p-1} 2 \\\\right]`\\n\\n    '\n    ring = f.ring\n    f = _trunc(f, minpoly, p)\n    g = _trunc(g, minpoly, p)\n    while g:\n        rem = f\n        deg = g.degree(0)\n        (lcinv, _, gcd) = _gf_gcdex(ring.dmp_LC(g), minpoly, p)\n        if not gcd == 1:\n            return None\n        while True:\n            degrem = rem.degree(0)\n            if degrem < deg:\n                break\n            quo = (lcinv * ring.dmp_LC(rem)).set_ring(ring)\n            rem = _trunc(rem - g.mul_monom((degrem - deg, 0)) * quo, minpoly, p)\n        f = g\n        g = rem\n    lcfinv = _gf_gcdex(ring.dmp_LC(f), minpoly, p)[0].set_ring(ring)\n    return _trunc(f * lcfinv, minpoly, p)"
        ]
    },
    {
        "func_name": "_trial_division",
        "original": "def _trial_division(f, h, minpoly, p=None):\n    \"\"\"\n    Check if `h` divides `f` in\n    `\\\\mathbb K[t_1, \\\\ldots, t_k][z]/(m_{\\\\alpha}(z))`, where `\\\\mathbb K` is\n    either `\\\\mathbb Q` or `\\\\mathbb Z_p`.\n\n    This algorithm is based on pseudo division and does not use any\n    fractions. By default `\\\\mathbb K` is `\\\\mathbb Q`, if a prime number `p`\n    is given, `\\\\mathbb Z_p` is chosen instead.\n\n    Parameters\n    ==========\n\n    f, h : PolyElement\n        polynomials in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\n    minpoly : PolyElement\n        polynomial `m_{\\\\alpha}(z)` in `\\\\mathbb Z[t_1, \\\\ldots, t_k][z]`\n    p : Integer or None\n        if `p` is given, `\\\\mathbb K` is set to `\\\\mathbb Z_p` instead of\n        `\\\\mathbb Q`, default is ``None``\n\n    Returns\n    =======\n\n    rem : PolyElement\n        remainder of `\\\\frac f h`\n\n    References\n    ==========\n\n    .. [1] [Hoeij02]_\n\n    \"\"\"\n    ring = f.ring\n    zxring = ring.clone(symbols=(ring.symbols[1], ring.symbols[0]))\n    minpoly = minpoly.set_ring(ring)\n    rem = f\n    degrem = rem.degree()\n    degh = h.degree()\n    degm = minpoly.degree(1)\n    lch = _LC(h).set_ring(ring)\n    lcm = minpoly.LC\n    while rem and degrem >= degh:\n        lcrem = _LC(rem).set_ring(ring)\n        rem = rem * lch - h.mul_monom((degrem - degh, 0)) * lcrem\n        if p:\n            rem = rem.trunc_ground(p)\n        degrem = rem.degree(1)\n        while rem and degrem >= degm:\n            lcrem = _LC(rem.set_ring(zxring)).set_ring(ring)\n            rem = rem.mul_ground(lcm) - minpoly.mul_monom((0, degrem - degm)) * lcrem\n            if p:\n                rem = rem.trunc_ground(p)\n            degrem = rem.degree(1)\n        degrem = rem.degree()\n    return rem",
        "mutated": [
            "def _trial_division(f, h, minpoly, p=None):\n    if False:\n        i = 10\n    '\\n    Check if `h` divides `f` in\\n    `\\\\mathbb K[t_1, \\\\ldots, t_k][z]/(m_{\\\\alpha}(z))`, where `\\\\mathbb K` is\\n    either `\\\\mathbb Q` or `\\\\mathbb Z_p`.\\n\\n    This algorithm is based on pseudo division and does not use any\\n    fractions. By default `\\\\mathbb K` is `\\\\mathbb Q`, if a prime number `p`\\n    is given, `\\\\mathbb Z_p` is chosen instead.\\n\\n    Parameters\\n    ==========\\n\\n    f, h : PolyElement\\n        polynomials in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    minpoly : PolyElement\\n        polynomial `m_{\\\\alpha}(z)` in `\\\\mathbb Z[t_1, \\\\ldots, t_k][z]`\\n    p : Integer or None\\n        if `p` is given, `\\\\mathbb K` is set to `\\\\mathbb Z_p` instead of\\n        `\\\\mathbb Q`, default is ``None``\\n\\n    Returns\\n    =======\\n\\n    rem : PolyElement\\n        remainder of `\\\\frac f h`\\n\\n    References\\n    ==========\\n\\n    .. [1] [Hoeij02]_\\n\\n    '\n    ring = f.ring\n    zxring = ring.clone(symbols=(ring.symbols[1], ring.symbols[0]))\n    minpoly = minpoly.set_ring(ring)\n    rem = f\n    degrem = rem.degree()\n    degh = h.degree()\n    degm = minpoly.degree(1)\n    lch = _LC(h).set_ring(ring)\n    lcm = minpoly.LC\n    while rem and degrem >= degh:\n        lcrem = _LC(rem).set_ring(ring)\n        rem = rem * lch - h.mul_monom((degrem - degh, 0)) * lcrem\n        if p:\n            rem = rem.trunc_ground(p)\n        degrem = rem.degree(1)\n        while rem and degrem >= degm:\n            lcrem = _LC(rem.set_ring(zxring)).set_ring(ring)\n            rem = rem.mul_ground(lcm) - minpoly.mul_monom((0, degrem - degm)) * lcrem\n            if p:\n                rem = rem.trunc_ground(p)\n            degrem = rem.degree(1)\n        degrem = rem.degree()\n    return rem",
            "def _trial_division(f, h, minpoly, p=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Check if `h` divides `f` in\\n    `\\\\mathbb K[t_1, \\\\ldots, t_k][z]/(m_{\\\\alpha}(z))`, where `\\\\mathbb K` is\\n    either `\\\\mathbb Q` or `\\\\mathbb Z_p`.\\n\\n    This algorithm is based on pseudo division and does not use any\\n    fractions. By default `\\\\mathbb K` is `\\\\mathbb Q`, if a prime number `p`\\n    is given, `\\\\mathbb Z_p` is chosen instead.\\n\\n    Parameters\\n    ==========\\n\\n    f, h : PolyElement\\n        polynomials in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    minpoly : PolyElement\\n        polynomial `m_{\\\\alpha}(z)` in `\\\\mathbb Z[t_1, \\\\ldots, t_k][z]`\\n    p : Integer or None\\n        if `p` is given, `\\\\mathbb K` is set to `\\\\mathbb Z_p` instead of\\n        `\\\\mathbb Q`, default is ``None``\\n\\n    Returns\\n    =======\\n\\n    rem : PolyElement\\n        remainder of `\\\\frac f h`\\n\\n    References\\n    ==========\\n\\n    .. [1] [Hoeij02]_\\n\\n    '\n    ring = f.ring\n    zxring = ring.clone(symbols=(ring.symbols[1], ring.symbols[0]))\n    minpoly = minpoly.set_ring(ring)\n    rem = f\n    degrem = rem.degree()\n    degh = h.degree()\n    degm = minpoly.degree(1)\n    lch = _LC(h).set_ring(ring)\n    lcm = minpoly.LC\n    while rem and degrem >= degh:\n        lcrem = _LC(rem).set_ring(ring)\n        rem = rem * lch - h.mul_monom((degrem - degh, 0)) * lcrem\n        if p:\n            rem = rem.trunc_ground(p)\n        degrem = rem.degree(1)\n        while rem and degrem >= degm:\n            lcrem = _LC(rem.set_ring(zxring)).set_ring(ring)\n            rem = rem.mul_ground(lcm) - minpoly.mul_monom((0, degrem - degm)) * lcrem\n            if p:\n                rem = rem.trunc_ground(p)\n            degrem = rem.degree(1)\n        degrem = rem.degree()\n    return rem",
            "def _trial_division(f, h, minpoly, p=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Check if `h` divides `f` in\\n    `\\\\mathbb K[t_1, \\\\ldots, t_k][z]/(m_{\\\\alpha}(z))`, where `\\\\mathbb K` is\\n    either `\\\\mathbb Q` or `\\\\mathbb Z_p`.\\n\\n    This algorithm is based on pseudo division and does not use any\\n    fractions. By default `\\\\mathbb K` is `\\\\mathbb Q`, if a prime number `p`\\n    is given, `\\\\mathbb Z_p` is chosen instead.\\n\\n    Parameters\\n    ==========\\n\\n    f, h : PolyElement\\n        polynomials in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    minpoly : PolyElement\\n        polynomial `m_{\\\\alpha}(z)` in `\\\\mathbb Z[t_1, \\\\ldots, t_k][z]`\\n    p : Integer or None\\n        if `p` is given, `\\\\mathbb K` is set to `\\\\mathbb Z_p` instead of\\n        `\\\\mathbb Q`, default is ``None``\\n\\n    Returns\\n    =======\\n\\n    rem : PolyElement\\n        remainder of `\\\\frac f h`\\n\\n    References\\n    ==========\\n\\n    .. [1] [Hoeij02]_\\n\\n    '\n    ring = f.ring\n    zxring = ring.clone(symbols=(ring.symbols[1], ring.symbols[0]))\n    minpoly = minpoly.set_ring(ring)\n    rem = f\n    degrem = rem.degree()\n    degh = h.degree()\n    degm = minpoly.degree(1)\n    lch = _LC(h).set_ring(ring)\n    lcm = minpoly.LC\n    while rem and degrem >= degh:\n        lcrem = _LC(rem).set_ring(ring)\n        rem = rem * lch - h.mul_monom((degrem - degh, 0)) * lcrem\n        if p:\n            rem = rem.trunc_ground(p)\n        degrem = rem.degree(1)\n        while rem and degrem >= degm:\n            lcrem = _LC(rem.set_ring(zxring)).set_ring(ring)\n            rem = rem.mul_ground(lcm) - minpoly.mul_monom((0, degrem - degm)) * lcrem\n            if p:\n                rem = rem.trunc_ground(p)\n            degrem = rem.degree(1)\n        degrem = rem.degree()\n    return rem",
            "def _trial_division(f, h, minpoly, p=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Check if `h` divides `f` in\\n    `\\\\mathbb K[t_1, \\\\ldots, t_k][z]/(m_{\\\\alpha}(z))`, where `\\\\mathbb K` is\\n    either `\\\\mathbb Q` or `\\\\mathbb Z_p`.\\n\\n    This algorithm is based on pseudo division and does not use any\\n    fractions. By default `\\\\mathbb K` is `\\\\mathbb Q`, if a prime number `p`\\n    is given, `\\\\mathbb Z_p` is chosen instead.\\n\\n    Parameters\\n    ==========\\n\\n    f, h : PolyElement\\n        polynomials in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    minpoly : PolyElement\\n        polynomial `m_{\\\\alpha}(z)` in `\\\\mathbb Z[t_1, \\\\ldots, t_k][z]`\\n    p : Integer or None\\n        if `p` is given, `\\\\mathbb K` is set to `\\\\mathbb Z_p` instead of\\n        `\\\\mathbb Q`, default is ``None``\\n\\n    Returns\\n    =======\\n\\n    rem : PolyElement\\n        remainder of `\\\\frac f h`\\n\\n    References\\n    ==========\\n\\n    .. [1] [Hoeij02]_\\n\\n    '\n    ring = f.ring\n    zxring = ring.clone(symbols=(ring.symbols[1], ring.symbols[0]))\n    minpoly = minpoly.set_ring(ring)\n    rem = f\n    degrem = rem.degree()\n    degh = h.degree()\n    degm = minpoly.degree(1)\n    lch = _LC(h).set_ring(ring)\n    lcm = minpoly.LC\n    while rem and degrem >= degh:\n        lcrem = _LC(rem).set_ring(ring)\n        rem = rem * lch - h.mul_monom((degrem - degh, 0)) * lcrem\n        if p:\n            rem = rem.trunc_ground(p)\n        degrem = rem.degree(1)\n        while rem and degrem >= degm:\n            lcrem = _LC(rem.set_ring(zxring)).set_ring(ring)\n            rem = rem.mul_ground(lcm) - minpoly.mul_monom((0, degrem - degm)) * lcrem\n            if p:\n                rem = rem.trunc_ground(p)\n            degrem = rem.degree(1)\n        degrem = rem.degree()\n    return rem",
            "def _trial_division(f, h, minpoly, p=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Check if `h` divides `f` in\\n    `\\\\mathbb K[t_1, \\\\ldots, t_k][z]/(m_{\\\\alpha}(z))`, where `\\\\mathbb K` is\\n    either `\\\\mathbb Q` or `\\\\mathbb Z_p`.\\n\\n    This algorithm is based on pseudo division and does not use any\\n    fractions. By default `\\\\mathbb K` is `\\\\mathbb Q`, if a prime number `p`\\n    is given, `\\\\mathbb Z_p` is chosen instead.\\n\\n    Parameters\\n    ==========\\n\\n    f, h : PolyElement\\n        polynomials in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    minpoly : PolyElement\\n        polynomial `m_{\\\\alpha}(z)` in `\\\\mathbb Z[t_1, \\\\ldots, t_k][z]`\\n    p : Integer or None\\n        if `p` is given, `\\\\mathbb K` is set to `\\\\mathbb Z_p` instead of\\n        `\\\\mathbb Q`, default is ``None``\\n\\n    Returns\\n    =======\\n\\n    rem : PolyElement\\n        remainder of `\\\\frac f h`\\n\\n    References\\n    ==========\\n\\n    .. [1] [Hoeij02]_\\n\\n    '\n    ring = f.ring\n    zxring = ring.clone(symbols=(ring.symbols[1], ring.symbols[0]))\n    minpoly = minpoly.set_ring(ring)\n    rem = f\n    degrem = rem.degree()\n    degh = h.degree()\n    degm = minpoly.degree(1)\n    lch = _LC(h).set_ring(ring)\n    lcm = minpoly.LC\n    while rem and degrem >= degh:\n        lcrem = _LC(rem).set_ring(ring)\n        rem = rem * lch - h.mul_monom((degrem - degh, 0)) * lcrem\n        if p:\n            rem = rem.trunc_ground(p)\n        degrem = rem.degree(1)\n        while rem and degrem >= degm:\n            lcrem = _LC(rem.set_ring(zxring)).set_ring(ring)\n            rem = rem.mul_ground(lcm) - minpoly.mul_monom((0, degrem - degm)) * lcrem\n            if p:\n                rem = rem.trunc_ground(p)\n            degrem = rem.degree(1)\n        degrem = rem.degree()\n    return rem"
        ]
    },
    {
        "func_name": "_evaluate_ground",
        "original": "def _evaluate_ground(f, i, a):\n    \"\"\"\n    Evaluate a polynomial `f` at `a` in the `i`-th variable of the ground\n    domain.\n    \"\"\"\n    ring = f.ring.clone(domain=f.ring.domain.ring.drop(i))\n    fa = ring.zero\n    for (monom, coeff) in f.iterterms():\n        fa[monom] = coeff.evaluate(i, a)\n    return fa",
        "mutated": [
            "def _evaluate_ground(f, i, a):\n    if False:\n        i = 10\n    '\\n    Evaluate a polynomial `f` at `a` in the `i`-th variable of the ground\\n    domain.\\n    '\n    ring = f.ring.clone(domain=f.ring.domain.ring.drop(i))\n    fa = ring.zero\n    for (monom, coeff) in f.iterterms():\n        fa[monom] = coeff.evaluate(i, a)\n    return fa",
            "def _evaluate_ground(f, i, a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Evaluate a polynomial `f` at `a` in the `i`-th variable of the ground\\n    domain.\\n    '\n    ring = f.ring.clone(domain=f.ring.domain.ring.drop(i))\n    fa = ring.zero\n    for (monom, coeff) in f.iterterms():\n        fa[monom] = coeff.evaluate(i, a)\n    return fa",
            "def _evaluate_ground(f, i, a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Evaluate a polynomial `f` at `a` in the `i`-th variable of the ground\\n    domain.\\n    '\n    ring = f.ring.clone(domain=f.ring.domain.ring.drop(i))\n    fa = ring.zero\n    for (monom, coeff) in f.iterterms():\n        fa[monom] = coeff.evaluate(i, a)\n    return fa",
            "def _evaluate_ground(f, i, a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Evaluate a polynomial `f` at `a` in the `i`-th variable of the ground\\n    domain.\\n    '\n    ring = f.ring.clone(domain=f.ring.domain.ring.drop(i))\n    fa = ring.zero\n    for (monom, coeff) in f.iterterms():\n        fa[monom] = coeff.evaluate(i, a)\n    return fa",
            "def _evaluate_ground(f, i, a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Evaluate a polynomial `f` at `a` in the `i`-th variable of the ground\\n    domain.\\n    '\n    ring = f.ring.clone(domain=f.ring.domain.ring.drop(i))\n    fa = ring.zero\n    for (monom, coeff) in f.iterterms():\n        fa[monom] = coeff.evaluate(i, a)\n    return fa"
        ]
    },
    {
        "func_name": "_func_field_modgcd_p",
        "original": "def _func_field_modgcd_p(f, g, minpoly, p):\n    \"\"\"\n    Compute the GCD of two polynomials `f` and `g` in\n    `\\\\mathbb Z_p(t_1, \\\\ldots, t_k)[z]/(\\\\check m_\\\\alpha(z))[x]`.\n\n    The algorithm reduces the problem step by step by evaluating the\n    polynomials `f` and `g` at `t_k = a` for suitable `a \\\\in \\\\mathbb Z_p`\n    and then calls itself recursively to compute the GCD in\n    `\\\\mathbb Z_p(t_1, \\\\ldots, t_{k-1})[z]/(\\\\check m_\\\\alpha(z))[x]`. If these\n    recursive calls are successful, the GCD over `k` variables is\n    interpolated, otherwise the algorithm returns ``None``. After\n    interpolation, Rational Function Reconstruction is used to obtain the\n    correct coefficients. If this fails, a new evaluation point has to be\n    chosen, otherwise the desired polynomial is obtained by clearing\n    denominators. The result is verified with a fraction free trial\n    division.\n\n    Parameters\n    ==========\n\n    f, g : PolyElement\n        polynomials in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\n    minpoly : PolyElement\n        polynomial in `\\\\mathbb Z[t_1, \\\\ldots, t_k][z]`, not necessarily\n        irreducible\n    p : Integer\n        prime number, modulus of `\\\\mathbb Z_p`\n\n    Returns\n    =======\n\n    h : PolyElement\n        primitive associate in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]` of the\n        GCD of the polynomials `f` and `g`  or ``None``, coefficients are\n        in `\\\\left[ -\\\\frac{p-1} 2, \\\\frac{p-1} 2 \\\\right]`\n\n    References\n    ==========\n\n    1. [Hoeij04]_\n\n    \"\"\"\n    ring = f.ring\n    domain = ring.domain\n    if isinstance(domain, PolynomialRing):\n        k = domain.ngens\n    else:\n        return _euclidean_algorithm(f, g, minpoly, p)\n    if k == 1:\n        qdomain = domain.ring.to_field()\n    else:\n        qdomain = domain.ring.drop_to_ground(k - 1)\n        qdomain = qdomain.clone(domain=qdomain.domain.ring.to_field())\n    qring = ring.clone(domain=qdomain)\n    n = 1\n    d = 1\n    gamma = ring.dmp_LC(f) * ring.dmp_LC(g)\n    delta = minpoly.LC\n    evalpoints = []\n    heval = []\n    LMlist = []\n    points = list(range(p))\n    while points:\n        a = random.sample(points, 1)[0]\n        points.remove(a)\n        if k == 1:\n            test = delta.evaluate(k - 1, a) % p == 0\n        else:\n            test = delta.evaluate(k - 1, a).trunc_ground(p) == 0\n        if test:\n            continue\n        gammaa = _evaluate_ground(gamma, k - 1, a)\n        minpolya = _evaluate_ground(minpoly, k - 1, a)\n        if gammaa.rem([minpolya, gammaa.ring(p)]) == 0:\n            continue\n        fa = _evaluate_ground(f, k - 1, a)\n        ga = _evaluate_ground(g, k - 1, a)\n        ha = _func_field_modgcd_p(fa, ga, minpolya, p)\n        if ha is None:\n            d += 1\n            if d > n:\n                return None\n            continue\n        if ha == 1:\n            return ha\n        LM = [ha.degree()] + [0] * (k - 1)\n        if k > 1:\n            for (monom, coeff) in ha.iterterms():\n                if monom[0] == LM[0] and coeff.LM > tuple(LM[1:]):\n                    LM[1:] = coeff.LM\n        evalpoints_a = [a]\n        heval_a = [ha]\n        if k == 1:\n            m = qring.domain.get_ring().one\n        else:\n            m = qring.domain.domain.get_ring().one\n        t = m.ring.gens[0]\n        for (b, hb, LMhb) in zip(evalpoints, heval, LMlist):\n            if LMhb == LM:\n                evalpoints_a.append(b)\n                heval_a.append(hb)\n                m *= t - b\n        m = m.trunc_ground(p)\n        evalpoints.append(a)\n        heval.append(ha)\n        LMlist.append(LM)\n        n += 1\n        h = _interpolate_multivariate(evalpoints_a, heval_a, ring, k - 1, p, ground=True)\n        h = _rational_reconstruction_func_coeffs(h, p, m, qring, k - 1)\n        if h is None:\n            continue\n        if k == 1:\n            dom = qring.domain.field\n            den = dom.ring.one\n            for coeff in h.itercoeffs():\n                den = dom.ring.from_dense(gf_lcm(den.to_dense(), coeff.denom.to_dense(), p, dom.domain))\n        else:\n            dom = qring.domain.domain.field\n            den = dom.ring.one\n            for coeff in h.itercoeffs():\n                for c in coeff.itercoeffs():\n                    den = dom.ring.from_dense(gf_lcm(den.to_dense(), c.denom.to_dense(), p, dom.domain))\n        den = qring.domain_new(den.trunc_ground(p))\n        h = ring(h.mul_ground(den).as_expr()).trunc_ground(p)\n        if not _trial_division(f, h, minpoly, p) and (not _trial_division(g, h, minpoly, p)):\n            return h\n    return None",
        "mutated": [
            "def _func_field_modgcd_p(f, g, minpoly, p):\n    if False:\n        i = 10\n    '\\n    Compute the GCD of two polynomials `f` and `g` in\\n    `\\\\mathbb Z_p(t_1, \\\\ldots, t_k)[z]/(\\\\check m_\\\\alpha(z))[x]`.\\n\\n    The algorithm reduces the problem step by step by evaluating the\\n    polynomials `f` and `g` at `t_k = a` for suitable `a \\\\in \\\\mathbb Z_p`\\n    and then calls itself recursively to compute the GCD in\\n    `\\\\mathbb Z_p(t_1, \\\\ldots, t_{k-1})[z]/(\\\\check m_\\\\alpha(z))[x]`. If these\\n    recursive calls are successful, the GCD over `k` variables is\\n    interpolated, otherwise the algorithm returns ``None``. After\\n    interpolation, Rational Function Reconstruction is used to obtain the\\n    correct coefficients. If this fails, a new evaluation point has to be\\n    chosen, otherwise the desired polynomial is obtained by clearing\\n    denominators. The result is verified with a fraction free trial\\n    division.\\n\\n    Parameters\\n    ==========\\n\\n    f, g : PolyElement\\n        polynomials in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    minpoly : PolyElement\\n        polynomial in `\\\\mathbb Z[t_1, \\\\ldots, t_k][z]`, not necessarily\\n        irreducible\\n    p : Integer\\n        prime number, modulus of `\\\\mathbb Z_p`\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        primitive associate in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]` of the\\n        GCD of the polynomials `f` and `g`  or ``None``, coefficients are\\n        in `\\\\left[ -\\\\frac{p-1} 2, \\\\frac{p-1} 2 \\\\right]`\\n\\n    References\\n    ==========\\n\\n    1. [Hoeij04]_\\n\\n    '\n    ring = f.ring\n    domain = ring.domain\n    if isinstance(domain, PolynomialRing):\n        k = domain.ngens\n    else:\n        return _euclidean_algorithm(f, g, minpoly, p)\n    if k == 1:\n        qdomain = domain.ring.to_field()\n    else:\n        qdomain = domain.ring.drop_to_ground(k - 1)\n        qdomain = qdomain.clone(domain=qdomain.domain.ring.to_field())\n    qring = ring.clone(domain=qdomain)\n    n = 1\n    d = 1\n    gamma = ring.dmp_LC(f) * ring.dmp_LC(g)\n    delta = minpoly.LC\n    evalpoints = []\n    heval = []\n    LMlist = []\n    points = list(range(p))\n    while points:\n        a = random.sample(points, 1)[0]\n        points.remove(a)\n        if k == 1:\n            test = delta.evaluate(k - 1, a) % p == 0\n        else:\n            test = delta.evaluate(k - 1, a).trunc_ground(p) == 0\n        if test:\n            continue\n        gammaa = _evaluate_ground(gamma, k - 1, a)\n        minpolya = _evaluate_ground(minpoly, k - 1, a)\n        if gammaa.rem([minpolya, gammaa.ring(p)]) == 0:\n            continue\n        fa = _evaluate_ground(f, k - 1, a)\n        ga = _evaluate_ground(g, k - 1, a)\n        ha = _func_field_modgcd_p(fa, ga, minpolya, p)\n        if ha is None:\n            d += 1\n            if d > n:\n                return None\n            continue\n        if ha == 1:\n            return ha\n        LM = [ha.degree()] + [0] * (k - 1)\n        if k > 1:\n            for (monom, coeff) in ha.iterterms():\n                if monom[0] == LM[0] and coeff.LM > tuple(LM[1:]):\n                    LM[1:] = coeff.LM\n        evalpoints_a = [a]\n        heval_a = [ha]\n        if k == 1:\n            m = qring.domain.get_ring().one\n        else:\n            m = qring.domain.domain.get_ring().one\n        t = m.ring.gens[0]\n        for (b, hb, LMhb) in zip(evalpoints, heval, LMlist):\n            if LMhb == LM:\n                evalpoints_a.append(b)\n                heval_a.append(hb)\n                m *= t - b\n        m = m.trunc_ground(p)\n        evalpoints.append(a)\n        heval.append(ha)\n        LMlist.append(LM)\n        n += 1\n        h = _interpolate_multivariate(evalpoints_a, heval_a, ring, k - 1, p, ground=True)\n        h = _rational_reconstruction_func_coeffs(h, p, m, qring, k - 1)\n        if h is None:\n            continue\n        if k == 1:\n            dom = qring.domain.field\n            den = dom.ring.one\n            for coeff in h.itercoeffs():\n                den = dom.ring.from_dense(gf_lcm(den.to_dense(), coeff.denom.to_dense(), p, dom.domain))\n        else:\n            dom = qring.domain.domain.field\n            den = dom.ring.one\n            for coeff in h.itercoeffs():\n                for c in coeff.itercoeffs():\n                    den = dom.ring.from_dense(gf_lcm(den.to_dense(), c.denom.to_dense(), p, dom.domain))\n        den = qring.domain_new(den.trunc_ground(p))\n        h = ring(h.mul_ground(den).as_expr()).trunc_ground(p)\n        if not _trial_division(f, h, minpoly, p) and (not _trial_division(g, h, minpoly, p)):\n            return h\n    return None",
            "def _func_field_modgcd_p(f, g, minpoly, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the GCD of two polynomials `f` and `g` in\\n    `\\\\mathbb Z_p(t_1, \\\\ldots, t_k)[z]/(\\\\check m_\\\\alpha(z))[x]`.\\n\\n    The algorithm reduces the problem step by step by evaluating the\\n    polynomials `f` and `g` at `t_k = a` for suitable `a \\\\in \\\\mathbb Z_p`\\n    and then calls itself recursively to compute the GCD in\\n    `\\\\mathbb Z_p(t_1, \\\\ldots, t_{k-1})[z]/(\\\\check m_\\\\alpha(z))[x]`. If these\\n    recursive calls are successful, the GCD over `k` variables is\\n    interpolated, otherwise the algorithm returns ``None``. After\\n    interpolation, Rational Function Reconstruction is used to obtain the\\n    correct coefficients. If this fails, a new evaluation point has to be\\n    chosen, otherwise the desired polynomial is obtained by clearing\\n    denominators. The result is verified with a fraction free trial\\n    division.\\n\\n    Parameters\\n    ==========\\n\\n    f, g : PolyElement\\n        polynomials in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    minpoly : PolyElement\\n        polynomial in `\\\\mathbb Z[t_1, \\\\ldots, t_k][z]`, not necessarily\\n        irreducible\\n    p : Integer\\n        prime number, modulus of `\\\\mathbb Z_p`\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        primitive associate in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]` of the\\n        GCD of the polynomials `f` and `g`  or ``None``, coefficients are\\n        in `\\\\left[ -\\\\frac{p-1} 2, \\\\frac{p-1} 2 \\\\right]`\\n\\n    References\\n    ==========\\n\\n    1. [Hoeij04]_\\n\\n    '\n    ring = f.ring\n    domain = ring.domain\n    if isinstance(domain, PolynomialRing):\n        k = domain.ngens\n    else:\n        return _euclidean_algorithm(f, g, minpoly, p)\n    if k == 1:\n        qdomain = domain.ring.to_field()\n    else:\n        qdomain = domain.ring.drop_to_ground(k - 1)\n        qdomain = qdomain.clone(domain=qdomain.domain.ring.to_field())\n    qring = ring.clone(domain=qdomain)\n    n = 1\n    d = 1\n    gamma = ring.dmp_LC(f) * ring.dmp_LC(g)\n    delta = minpoly.LC\n    evalpoints = []\n    heval = []\n    LMlist = []\n    points = list(range(p))\n    while points:\n        a = random.sample(points, 1)[0]\n        points.remove(a)\n        if k == 1:\n            test = delta.evaluate(k - 1, a) % p == 0\n        else:\n            test = delta.evaluate(k - 1, a).trunc_ground(p) == 0\n        if test:\n            continue\n        gammaa = _evaluate_ground(gamma, k - 1, a)\n        minpolya = _evaluate_ground(minpoly, k - 1, a)\n        if gammaa.rem([minpolya, gammaa.ring(p)]) == 0:\n            continue\n        fa = _evaluate_ground(f, k - 1, a)\n        ga = _evaluate_ground(g, k - 1, a)\n        ha = _func_field_modgcd_p(fa, ga, minpolya, p)\n        if ha is None:\n            d += 1\n            if d > n:\n                return None\n            continue\n        if ha == 1:\n            return ha\n        LM = [ha.degree()] + [0] * (k - 1)\n        if k > 1:\n            for (monom, coeff) in ha.iterterms():\n                if monom[0] == LM[0] and coeff.LM > tuple(LM[1:]):\n                    LM[1:] = coeff.LM\n        evalpoints_a = [a]\n        heval_a = [ha]\n        if k == 1:\n            m = qring.domain.get_ring().one\n        else:\n            m = qring.domain.domain.get_ring().one\n        t = m.ring.gens[0]\n        for (b, hb, LMhb) in zip(evalpoints, heval, LMlist):\n            if LMhb == LM:\n                evalpoints_a.append(b)\n                heval_a.append(hb)\n                m *= t - b\n        m = m.trunc_ground(p)\n        evalpoints.append(a)\n        heval.append(ha)\n        LMlist.append(LM)\n        n += 1\n        h = _interpolate_multivariate(evalpoints_a, heval_a, ring, k - 1, p, ground=True)\n        h = _rational_reconstruction_func_coeffs(h, p, m, qring, k - 1)\n        if h is None:\n            continue\n        if k == 1:\n            dom = qring.domain.field\n            den = dom.ring.one\n            for coeff in h.itercoeffs():\n                den = dom.ring.from_dense(gf_lcm(den.to_dense(), coeff.denom.to_dense(), p, dom.domain))\n        else:\n            dom = qring.domain.domain.field\n            den = dom.ring.one\n            for coeff in h.itercoeffs():\n                for c in coeff.itercoeffs():\n                    den = dom.ring.from_dense(gf_lcm(den.to_dense(), c.denom.to_dense(), p, dom.domain))\n        den = qring.domain_new(den.trunc_ground(p))\n        h = ring(h.mul_ground(den).as_expr()).trunc_ground(p)\n        if not _trial_division(f, h, minpoly, p) and (not _trial_division(g, h, minpoly, p)):\n            return h\n    return None",
            "def _func_field_modgcd_p(f, g, minpoly, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the GCD of two polynomials `f` and `g` in\\n    `\\\\mathbb Z_p(t_1, \\\\ldots, t_k)[z]/(\\\\check m_\\\\alpha(z))[x]`.\\n\\n    The algorithm reduces the problem step by step by evaluating the\\n    polynomials `f` and `g` at `t_k = a` for suitable `a \\\\in \\\\mathbb Z_p`\\n    and then calls itself recursively to compute the GCD in\\n    `\\\\mathbb Z_p(t_1, \\\\ldots, t_{k-1})[z]/(\\\\check m_\\\\alpha(z))[x]`. If these\\n    recursive calls are successful, the GCD over `k` variables is\\n    interpolated, otherwise the algorithm returns ``None``. After\\n    interpolation, Rational Function Reconstruction is used to obtain the\\n    correct coefficients. If this fails, a new evaluation point has to be\\n    chosen, otherwise the desired polynomial is obtained by clearing\\n    denominators. The result is verified with a fraction free trial\\n    division.\\n\\n    Parameters\\n    ==========\\n\\n    f, g : PolyElement\\n        polynomials in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    minpoly : PolyElement\\n        polynomial in `\\\\mathbb Z[t_1, \\\\ldots, t_k][z]`, not necessarily\\n        irreducible\\n    p : Integer\\n        prime number, modulus of `\\\\mathbb Z_p`\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        primitive associate in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]` of the\\n        GCD of the polynomials `f` and `g`  or ``None``, coefficients are\\n        in `\\\\left[ -\\\\frac{p-1} 2, \\\\frac{p-1} 2 \\\\right]`\\n\\n    References\\n    ==========\\n\\n    1. [Hoeij04]_\\n\\n    '\n    ring = f.ring\n    domain = ring.domain\n    if isinstance(domain, PolynomialRing):\n        k = domain.ngens\n    else:\n        return _euclidean_algorithm(f, g, minpoly, p)\n    if k == 1:\n        qdomain = domain.ring.to_field()\n    else:\n        qdomain = domain.ring.drop_to_ground(k - 1)\n        qdomain = qdomain.clone(domain=qdomain.domain.ring.to_field())\n    qring = ring.clone(domain=qdomain)\n    n = 1\n    d = 1\n    gamma = ring.dmp_LC(f) * ring.dmp_LC(g)\n    delta = minpoly.LC\n    evalpoints = []\n    heval = []\n    LMlist = []\n    points = list(range(p))\n    while points:\n        a = random.sample(points, 1)[0]\n        points.remove(a)\n        if k == 1:\n            test = delta.evaluate(k - 1, a) % p == 0\n        else:\n            test = delta.evaluate(k - 1, a).trunc_ground(p) == 0\n        if test:\n            continue\n        gammaa = _evaluate_ground(gamma, k - 1, a)\n        minpolya = _evaluate_ground(minpoly, k - 1, a)\n        if gammaa.rem([minpolya, gammaa.ring(p)]) == 0:\n            continue\n        fa = _evaluate_ground(f, k - 1, a)\n        ga = _evaluate_ground(g, k - 1, a)\n        ha = _func_field_modgcd_p(fa, ga, minpolya, p)\n        if ha is None:\n            d += 1\n            if d > n:\n                return None\n            continue\n        if ha == 1:\n            return ha\n        LM = [ha.degree()] + [0] * (k - 1)\n        if k > 1:\n            for (monom, coeff) in ha.iterterms():\n                if monom[0] == LM[0] and coeff.LM > tuple(LM[1:]):\n                    LM[1:] = coeff.LM\n        evalpoints_a = [a]\n        heval_a = [ha]\n        if k == 1:\n            m = qring.domain.get_ring().one\n        else:\n            m = qring.domain.domain.get_ring().one\n        t = m.ring.gens[0]\n        for (b, hb, LMhb) in zip(evalpoints, heval, LMlist):\n            if LMhb == LM:\n                evalpoints_a.append(b)\n                heval_a.append(hb)\n                m *= t - b\n        m = m.trunc_ground(p)\n        evalpoints.append(a)\n        heval.append(ha)\n        LMlist.append(LM)\n        n += 1\n        h = _interpolate_multivariate(evalpoints_a, heval_a, ring, k - 1, p, ground=True)\n        h = _rational_reconstruction_func_coeffs(h, p, m, qring, k - 1)\n        if h is None:\n            continue\n        if k == 1:\n            dom = qring.domain.field\n            den = dom.ring.one\n            for coeff in h.itercoeffs():\n                den = dom.ring.from_dense(gf_lcm(den.to_dense(), coeff.denom.to_dense(), p, dom.domain))\n        else:\n            dom = qring.domain.domain.field\n            den = dom.ring.one\n            for coeff in h.itercoeffs():\n                for c in coeff.itercoeffs():\n                    den = dom.ring.from_dense(gf_lcm(den.to_dense(), c.denom.to_dense(), p, dom.domain))\n        den = qring.domain_new(den.trunc_ground(p))\n        h = ring(h.mul_ground(den).as_expr()).trunc_ground(p)\n        if not _trial_division(f, h, minpoly, p) and (not _trial_division(g, h, minpoly, p)):\n            return h\n    return None",
            "def _func_field_modgcd_p(f, g, minpoly, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the GCD of two polynomials `f` and `g` in\\n    `\\\\mathbb Z_p(t_1, \\\\ldots, t_k)[z]/(\\\\check m_\\\\alpha(z))[x]`.\\n\\n    The algorithm reduces the problem step by step by evaluating the\\n    polynomials `f` and `g` at `t_k = a` for suitable `a \\\\in \\\\mathbb Z_p`\\n    and then calls itself recursively to compute the GCD in\\n    `\\\\mathbb Z_p(t_1, \\\\ldots, t_{k-1})[z]/(\\\\check m_\\\\alpha(z))[x]`. If these\\n    recursive calls are successful, the GCD over `k` variables is\\n    interpolated, otherwise the algorithm returns ``None``. After\\n    interpolation, Rational Function Reconstruction is used to obtain the\\n    correct coefficients. If this fails, a new evaluation point has to be\\n    chosen, otherwise the desired polynomial is obtained by clearing\\n    denominators. The result is verified with a fraction free trial\\n    division.\\n\\n    Parameters\\n    ==========\\n\\n    f, g : PolyElement\\n        polynomials in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    minpoly : PolyElement\\n        polynomial in `\\\\mathbb Z[t_1, \\\\ldots, t_k][z]`, not necessarily\\n        irreducible\\n    p : Integer\\n        prime number, modulus of `\\\\mathbb Z_p`\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        primitive associate in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]` of the\\n        GCD of the polynomials `f` and `g`  or ``None``, coefficients are\\n        in `\\\\left[ -\\\\frac{p-1} 2, \\\\frac{p-1} 2 \\\\right]`\\n\\n    References\\n    ==========\\n\\n    1. [Hoeij04]_\\n\\n    '\n    ring = f.ring\n    domain = ring.domain\n    if isinstance(domain, PolynomialRing):\n        k = domain.ngens\n    else:\n        return _euclidean_algorithm(f, g, minpoly, p)\n    if k == 1:\n        qdomain = domain.ring.to_field()\n    else:\n        qdomain = domain.ring.drop_to_ground(k - 1)\n        qdomain = qdomain.clone(domain=qdomain.domain.ring.to_field())\n    qring = ring.clone(domain=qdomain)\n    n = 1\n    d = 1\n    gamma = ring.dmp_LC(f) * ring.dmp_LC(g)\n    delta = minpoly.LC\n    evalpoints = []\n    heval = []\n    LMlist = []\n    points = list(range(p))\n    while points:\n        a = random.sample(points, 1)[0]\n        points.remove(a)\n        if k == 1:\n            test = delta.evaluate(k - 1, a) % p == 0\n        else:\n            test = delta.evaluate(k - 1, a).trunc_ground(p) == 0\n        if test:\n            continue\n        gammaa = _evaluate_ground(gamma, k - 1, a)\n        minpolya = _evaluate_ground(minpoly, k - 1, a)\n        if gammaa.rem([minpolya, gammaa.ring(p)]) == 0:\n            continue\n        fa = _evaluate_ground(f, k - 1, a)\n        ga = _evaluate_ground(g, k - 1, a)\n        ha = _func_field_modgcd_p(fa, ga, minpolya, p)\n        if ha is None:\n            d += 1\n            if d > n:\n                return None\n            continue\n        if ha == 1:\n            return ha\n        LM = [ha.degree()] + [0] * (k - 1)\n        if k > 1:\n            for (monom, coeff) in ha.iterterms():\n                if monom[0] == LM[0] and coeff.LM > tuple(LM[1:]):\n                    LM[1:] = coeff.LM\n        evalpoints_a = [a]\n        heval_a = [ha]\n        if k == 1:\n            m = qring.domain.get_ring().one\n        else:\n            m = qring.domain.domain.get_ring().one\n        t = m.ring.gens[0]\n        for (b, hb, LMhb) in zip(evalpoints, heval, LMlist):\n            if LMhb == LM:\n                evalpoints_a.append(b)\n                heval_a.append(hb)\n                m *= t - b\n        m = m.trunc_ground(p)\n        evalpoints.append(a)\n        heval.append(ha)\n        LMlist.append(LM)\n        n += 1\n        h = _interpolate_multivariate(evalpoints_a, heval_a, ring, k - 1, p, ground=True)\n        h = _rational_reconstruction_func_coeffs(h, p, m, qring, k - 1)\n        if h is None:\n            continue\n        if k == 1:\n            dom = qring.domain.field\n            den = dom.ring.one\n            for coeff in h.itercoeffs():\n                den = dom.ring.from_dense(gf_lcm(den.to_dense(), coeff.denom.to_dense(), p, dom.domain))\n        else:\n            dom = qring.domain.domain.field\n            den = dom.ring.one\n            for coeff in h.itercoeffs():\n                for c in coeff.itercoeffs():\n                    den = dom.ring.from_dense(gf_lcm(den.to_dense(), c.denom.to_dense(), p, dom.domain))\n        den = qring.domain_new(den.trunc_ground(p))\n        h = ring(h.mul_ground(den).as_expr()).trunc_ground(p)\n        if not _trial_division(f, h, minpoly, p) and (not _trial_division(g, h, minpoly, p)):\n            return h\n    return None",
            "def _func_field_modgcd_p(f, g, minpoly, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the GCD of two polynomials `f` and `g` in\\n    `\\\\mathbb Z_p(t_1, \\\\ldots, t_k)[z]/(\\\\check m_\\\\alpha(z))[x]`.\\n\\n    The algorithm reduces the problem step by step by evaluating the\\n    polynomials `f` and `g` at `t_k = a` for suitable `a \\\\in \\\\mathbb Z_p`\\n    and then calls itself recursively to compute the GCD in\\n    `\\\\mathbb Z_p(t_1, \\\\ldots, t_{k-1})[z]/(\\\\check m_\\\\alpha(z))[x]`. If these\\n    recursive calls are successful, the GCD over `k` variables is\\n    interpolated, otherwise the algorithm returns ``None``. After\\n    interpolation, Rational Function Reconstruction is used to obtain the\\n    correct coefficients. If this fails, a new evaluation point has to be\\n    chosen, otherwise the desired polynomial is obtained by clearing\\n    denominators. The result is verified with a fraction free trial\\n    division.\\n\\n    Parameters\\n    ==========\\n\\n    f, g : PolyElement\\n        polynomials in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    minpoly : PolyElement\\n        polynomial in `\\\\mathbb Z[t_1, \\\\ldots, t_k][z]`, not necessarily\\n        irreducible\\n    p : Integer\\n        prime number, modulus of `\\\\mathbb Z_p`\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        primitive associate in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]` of the\\n        GCD of the polynomials `f` and `g`  or ``None``, coefficients are\\n        in `\\\\left[ -\\\\frac{p-1} 2, \\\\frac{p-1} 2 \\\\right]`\\n\\n    References\\n    ==========\\n\\n    1. [Hoeij04]_\\n\\n    '\n    ring = f.ring\n    domain = ring.domain\n    if isinstance(domain, PolynomialRing):\n        k = domain.ngens\n    else:\n        return _euclidean_algorithm(f, g, minpoly, p)\n    if k == 1:\n        qdomain = domain.ring.to_field()\n    else:\n        qdomain = domain.ring.drop_to_ground(k - 1)\n        qdomain = qdomain.clone(domain=qdomain.domain.ring.to_field())\n    qring = ring.clone(domain=qdomain)\n    n = 1\n    d = 1\n    gamma = ring.dmp_LC(f) * ring.dmp_LC(g)\n    delta = minpoly.LC\n    evalpoints = []\n    heval = []\n    LMlist = []\n    points = list(range(p))\n    while points:\n        a = random.sample(points, 1)[0]\n        points.remove(a)\n        if k == 1:\n            test = delta.evaluate(k - 1, a) % p == 0\n        else:\n            test = delta.evaluate(k - 1, a).trunc_ground(p) == 0\n        if test:\n            continue\n        gammaa = _evaluate_ground(gamma, k - 1, a)\n        minpolya = _evaluate_ground(minpoly, k - 1, a)\n        if gammaa.rem([minpolya, gammaa.ring(p)]) == 0:\n            continue\n        fa = _evaluate_ground(f, k - 1, a)\n        ga = _evaluate_ground(g, k - 1, a)\n        ha = _func_field_modgcd_p(fa, ga, minpolya, p)\n        if ha is None:\n            d += 1\n            if d > n:\n                return None\n            continue\n        if ha == 1:\n            return ha\n        LM = [ha.degree()] + [0] * (k - 1)\n        if k > 1:\n            for (monom, coeff) in ha.iterterms():\n                if monom[0] == LM[0] and coeff.LM > tuple(LM[1:]):\n                    LM[1:] = coeff.LM\n        evalpoints_a = [a]\n        heval_a = [ha]\n        if k == 1:\n            m = qring.domain.get_ring().one\n        else:\n            m = qring.domain.domain.get_ring().one\n        t = m.ring.gens[0]\n        for (b, hb, LMhb) in zip(evalpoints, heval, LMlist):\n            if LMhb == LM:\n                evalpoints_a.append(b)\n                heval_a.append(hb)\n                m *= t - b\n        m = m.trunc_ground(p)\n        evalpoints.append(a)\n        heval.append(ha)\n        LMlist.append(LM)\n        n += 1\n        h = _interpolate_multivariate(evalpoints_a, heval_a, ring, k - 1, p, ground=True)\n        h = _rational_reconstruction_func_coeffs(h, p, m, qring, k - 1)\n        if h is None:\n            continue\n        if k == 1:\n            dom = qring.domain.field\n            den = dom.ring.one\n            for coeff in h.itercoeffs():\n                den = dom.ring.from_dense(gf_lcm(den.to_dense(), coeff.denom.to_dense(), p, dom.domain))\n        else:\n            dom = qring.domain.domain.field\n            den = dom.ring.one\n            for coeff in h.itercoeffs():\n                for c in coeff.itercoeffs():\n                    den = dom.ring.from_dense(gf_lcm(den.to_dense(), c.denom.to_dense(), p, dom.domain))\n        den = qring.domain_new(den.trunc_ground(p))\n        h = ring(h.mul_ground(den).as_expr()).trunc_ground(p)\n        if not _trial_division(f, h, minpoly, p) and (not _trial_division(g, h, minpoly, p)):\n            return h\n    return None"
        ]
    },
    {
        "func_name": "_integer_rational_reconstruction",
        "original": "def _integer_rational_reconstruction(c, m, domain):\n    \"\"\"\n    Reconstruct a rational number `\\\\frac a b` from\n\n    .. math::\n\n        c = \\\\frac a b \\\\; \\\\mathrm{mod} \\\\, m,\n\n    where `c` and `m` are integers.\n\n    The algorithm is based on the Euclidean Algorithm. In general, `m` is\n    not a prime number, so it is possible that `b` is not invertible modulo\n    `m`. In that case ``None`` is returned.\n\n    Parameters\n    ==========\n\n    c : Integer\n        `c = \\\\frac a b \\\\; \\\\mathrm{mod} \\\\, m`\n    m : Integer\n        modulus, not necessarily prime\n    domain : IntegerRing\n        `a, b, c` are elements of ``domain``\n\n    Returns\n    =======\n\n    frac : Rational\n        either `\\\\frac a b` in `\\\\mathbb Q` or ``None``\n\n    References\n    ==========\n\n    1. [Wang81]_\n\n    \"\"\"\n    if c < 0:\n        c += m\n    (r0, s0) = (m, domain.zero)\n    (r1, s1) = (c, domain.one)\n    bound = sqrt(m / 2)\n    while int(r1) >= bound:\n        quo = r0 // r1\n        (r0, r1) = (r1, r0 - quo * r1)\n        (s0, s1) = (s1, s0 - quo * s1)\n    if abs(int(s1)) >= bound:\n        return None\n    if s1 < 0:\n        (a, b) = (-r1, -s1)\n    elif s1 > 0:\n        (a, b) = (r1, s1)\n    else:\n        return None\n    field = domain.get_field()\n    return field(a) / field(b)",
        "mutated": [
            "def _integer_rational_reconstruction(c, m, domain):\n    if False:\n        i = 10\n    '\\n    Reconstruct a rational number `\\\\frac a b` from\\n\\n    .. math::\\n\\n        c = \\\\frac a b \\\\; \\\\mathrm{mod} \\\\, m,\\n\\n    where `c` and `m` are integers.\\n\\n    The algorithm is based on the Euclidean Algorithm. In general, `m` is\\n    not a prime number, so it is possible that `b` is not invertible modulo\\n    `m`. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    c : Integer\\n        `c = \\\\frac a b \\\\; \\\\mathrm{mod} \\\\, m`\\n    m : Integer\\n        modulus, not necessarily prime\\n    domain : IntegerRing\\n        `a, b, c` are elements of ``domain``\\n\\n    Returns\\n    =======\\n\\n    frac : Rational\\n        either `\\\\frac a b` in `\\\\mathbb Q` or ``None``\\n\\n    References\\n    ==========\\n\\n    1. [Wang81]_\\n\\n    '\n    if c < 0:\n        c += m\n    (r0, s0) = (m, domain.zero)\n    (r1, s1) = (c, domain.one)\n    bound = sqrt(m / 2)\n    while int(r1) >= bound:\n        quo = r0 // r1\n        (r0, r1) = (r1, r0 - quo * r1)\n        (s0, s1) = (s1, s0 - quo * s1)\n    if abs(int(s1)) >= bound:\n        return None\n    if s1 < 0:\n        (a, b) = (-r1, -s1)\n    elif s1 > 0:\n        (a, b) = (r1, s1)\n    else:\n        return None\n    field = domain.get_field()\n    return field(a) / field(b)",
            "def _integer_rational_reconstruction(c, m, domain):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Reconstruct a rational number `\\\\frac a b` from\\n\\n    .. math::\\n\\n        c = \\\\frac a b \\\\; \\\\mathrm{mod} \\\\, m,\\n\\n    where `c` and `m` are integers.\\n\\n    The algorithm is based on the Euclidean Algorithm. In general, `m` is\\n    not a prime number, so it is possible that `b` is not invertible modulo\\n    `m`. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    c : Integer\\n        `c = \\\\frac a b \\\\; \\\\mathrm{mod} \\\\, m`\\n    m : Integer\\n        modulus, not necessarily prime\\n    domain : IntegerRing\\n        `a, b, c` are elements of ``domain``\\n\\n    Returns\\n    =======\\n\\n    frac : Rational\\n        either `\\\\frac a b` in `\\\\mathbb Q` or ``None``\\n\\n    References\\n    ==========\\n\\n    1. [Wang81]_\\n\\n    '\n    if c < 0:\n        c += m\n    (r0, s0) = (m, domain.zero)\n    (r1, s1) = (c, domain.one)\n    bound = sqrt(m / 2)\n    while int(r1) >= bound:\n        quo = r0 // r1\n        (r0, r1) = (r1, r0 - quo * r1)\n        (s0, s1) = (s1, s0 - quo * s1)\n    if abs(int(s1)) >= bound:\n        return None\n    if s1 < 0:\n        (a, b) = (-r1, -s1)\n    elif s1 > 0:\n        (a, b) = (r1, s1)\n    else:\n        return None\n    field = domain.get_field()\n    return field(a) / field(b)",
            "def _integer_rational_reconstruction(c, m, domain):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Reconstruct a rational number `\\\\frac a b` from\\n\\n    .. math::\\n\\n        c = \\\\frac a b \\\\; \\\\mathrm{mod} \\\\, m,\\n\\n    where `c` and `m` are integers.\\n\\n    The algorithm is based on the Euclidean Algorithm. In general, `m` is\\n    not a prime number, so it is possible that `b` is not invertible modulo\\n    `m`. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    c : Integer\\n        `c = \\\\frac a b \\\\; \\\\mathrm{mod} \\\\, m`\\n    m : Integer\\n        modulus, not necessarily prime\\n    domain : IntegerRing\\n        `a, b, c` are elements of ``domain``\\n\\n    Returns\\n    =======\\n\\n    frac : Rational\\n        either `\\\\frac a b` in `\\\\mathbb Q` or ``None``\\n\\n    References\\n    ==========\\n\\n    1. [Wang81]_\\n\\n    '\n    if c < 0:\n        c += m\n    (r0, s0) = (m, domain.zero)\n    (r1, s1) = (c, domain.one)\n    bound = sqrt(m / 2)\n    while int(r1) >= bound:\n        quo = r0 // r1\n        (r0, r1) = (r1, r0 - quo * r1)\n        (s0, s1) = (s1, s0 - quo * s1)\n    if abs(int(s1)) >= bound:\n        return None\n    if s1 < 0:\n        (a, b) = (-r1, -s1)\n    elif s1 > 0:\n        (a, b) = (r1, s1)\n    else:\n        return None\n    field = domain.get_field()\n    return field(a) / field(b)",
            "def _integer_rational_reconstruction(c, m, domain):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Reconstruct a rational number `\\\\frac a b` from\\n\\n    .. math::\\n\\n        c = \\\\frac a b \\\\; \\\\mathrm{mod} \\\\, m,\\n\\n    where `c` and `m` are integers.\\n\\n    The algorithm is based on the Euclidean Algorithm. In general, `m` is\\n    not a prime number, so it is possible that `b` is not invertible modulo\\n    `m`. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    c : Integer\\n        `c = \\\\frac a b \\\\; \\\\mathrm{mod} \\\\, m`\\n    m : Integer\\n        modulus, not necessarily prime\\n    domain : IntegerRing\\n        `a, b, c` are elements of ``domain``\\n\\n    Returns\\n    =======\\n\\n    frac : Rational\\n        either `\\\\frac a b` in `\\\\mathbb Q` or ``None``\\n\\n    References\\n    ==========\\n\\n    1. [Wang81]_\\n\\n    '\n    if c < 0:\n        c += m\n    (r0, s0) = (m, domain.zero)\n    (r1, s1) = (c, domain.one)\n    bound = sqrt(m / 2)\n    while int(r1) >= bound:\n        quo = r0 // r1\n        (r0, r1) = (r1, r0 - quo * r1)\n        (s0, s1) = (s1, s0 - quo * s1)\n    if abs(int(s1)) >= bound:\n        return None\n    if s1 < 0:\n        (a, b) = (-r1, -s1)\n    elif s1 > 0:\n        (a, b) = (r1, s1)\n    else:\n        return None\n    field = domain.get_field()\n    return field(a) / field(b)",
            "def _integer_rational_reconstruction(c, m, domain):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Reconstruct a rational number `\\\\frac a b` from\\n\\n    .. math::\\n\\n        c = \\\\frac a b \\\\; \\\\mathrm{mod} \\\\, m,\\n\\n    where `c` and `m` are integers.\\n\\n    The algorithm is based on the Euclidean Algorithm. In general, `m` is\\n    not a prime number, so it is possible that `b` is not invertible modulo\\n    `m`. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    c : Integer\\n        `c = \\\\frac a b \\\\; \\\\mathrm{mod} \\\\, m`\\n    m : Integer\\n        modulus, not necessarily prime\\n    domain : IntegerRing\\n        `a, b, c` are elements of ``domain``\\n\\n    Returns\\n    =======\\n\\n    frac : Rational\\n        either `\\\\frac a b` in `\\\\mathbb Q` or ``None``\\n\\n    References\\n    ==========\\n\\n    1. [Wang81]_\\n\\n    '\n    if c < 0:\n        c += m\n    (r0, s0) = (m, domain.zero)\n    (r1, s1) = (c, domain.one)\n    bound = sqrt(m / 2)\n    while int(r1) >= bound:\n        quo = r0 // r1\n        (r0, r1) = (r1, r0 - quo * r1)\n        (s0, s1) = (s1, s0 - quo * s1)\n    if abs(int(s1)) >= bound:\n        return None\n    if s1 < 0:\n        (a, b) = (-r1, -s1)\n    elif s1 > 0:\n        (a, b) = (r1, s1)\n    else:\n        return None\n    field = domain.get_field()\n    return field(a) / field(b)"
        ]
    },
    {
        "func_name": "_rational_reconstruction_int_coeffs",
        "original": "def _rational_reconstruction_int_coeffs(hm, m, ring):\n    \"\"\"\n    Reconstruct every rational coefficient `c_h` of a polynomial `h` in\n    `\\\\mathbb Q[t_1, \\\\ldots, t_k][x, z]` from the corresponding integer\n    coefficient `c_{h_m}` of a polynomial `h_m` in\n    `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]` such that\n\n    .. math::\n\n        c_{h_m} = c_h \\\\; \\\\mathrm{mod} \\\\, m,\n\n    where `m \\\\in \\\\mathbb Z`.\n\n    The reconstruction is based on the Euclidean Algorithm. In general,\n    `m` is not a prime number, so it is possible that this fails for some\n    coefficient. In that case ``None`` is returned.\n\n    Parameters\n    ==========\n\n    hm : PolyElement\n        polynomial in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\n    m : Integer\n        modulus, not necessarily prime\n    ring : PolyRing\n        `\\\\mathbb Q[t_1, \\\\ldots, t_k][x, z]`, `h` will be an element of this\n        ring\n\n    Returns\n    =======\n\n    h : PolyElement\n        reconstructed polynomial in `\\\\mathbb Q[t_1, \\\\ldots, t_k][x, z]` or\n        ``None``\n\n    See also\n    ========\n\n    _integer_rational_reconstruction\n\n    \"\"\"\n    h = ring.zero\n    if isinstance(ring.domain, PolynomialRing):\n        reconstruction = _rational_reconstruction_int_coeffs\n        domain = ring.domain.ring\n    else:\n        reconstruction = _integer_rational_reconstruction\n        domain = hm.ring.domain\n    for (monom, coeff) in hm.iterterms():\n        coeffh = reconstruction(coeff, m, domain)\n        if not coeffh:\n            return None\n        h[monom] = coeffh\n    return h",
        "mutated": [
            "def _rational_reconstruction_int_coeffs(hm, m, ring):\n    if False:\n        i = 10\n    '\\n    Reconstruct every rational coefficient `c_h` of a polynomial `h` in\\n    `\\\\mathbb Q[t_1, \\\\ldots, t_k][x, z]` from the corresponding integer\\n    coefficient `c_{h_m}` of a polynomial `h_m` in\\n    `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]` such that\\n\\n    .. math::\\n\\n        c_{h_m} = c_h \\\\; \\\\mathrm{mod} \\\\, m,\\n\\n    where `m \\\\in \\\\mathbb Z`.\\n\\n    The reconstruction is based on the Euclidean Algorithm. In general,\\n    `m` is not a prime number, so it is possible that this fails for some\\n    coefficient. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    hm : PolyElement\\n        polynomial in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    m : Integer\\n        modulus, not necessarily prime\\n    ring : PolyRing\\n        `\\\\mathbb Q[t_1, \\\\ldots, t_k][x, z]`, `h` will be an element of this\\n        ring\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        reconstructed polynomial in `\\\\mathbb Q[t_1, \\\\ldots, t_k][x, z]` or\\n        ``None``\\n\\n    See also\\n    ========\\n\\n    _integer_rational_reconstruction\\n\\n    '\n    h = ring.zero\n    if isinstance(ring.domain, PolynomialRing):\n        reconstruction = _rational_reconstruction_int_coeffs\n        domain = ring.domain.ring\n    else:\n        reconstruction = _integer_rational_reconstruction\n        domain = hm.ring.domain\n    for (monom, coeff) in hm.iterterms():\n        coeffh = reconstruction(coeff, m, domain)\n        if not coeffh:\n            return None\n        h[monom] = coeffh\n    return h",
            "def _rational_reconstruction_int_coeffs(hm, m, ring):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Reconstruct every rational coefficient `c_h` of a polynomial `h` in\\n    `\\\\mathbb Q[t_1, \\\\ldots, t_k][x, z]` from the corresponding integer\\n    coefficient `c_{h_m}` of a polynomial `h_m` in\\n    `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]` such that\\n\\n    .. math::\\n\\n        c_{h_m} = c_h \\\\; \\\\mathrm{mod} \\\\, m,\\n\\n    where `m \\\\in \\\\mathbb Z`.\\n\\n    The reconstruction is based on the Euclidean Algorithm. In general,\\n    `m` is not a prime number, so it is possible that this fails for some\\n    coefficient. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    hm : PolyElement\\n        polynomial in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    m : Integer\\n        modulus, not necessarily prime\\n    ring : PolyRing\\n        `\\\\mathbb Q[t_1, \\\\ldots, t_k][x, z]`, `h` will be an element of this\\n        ring\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        reconstructed polynomial in `\\\\mathbb Q[t_1, \\\\ldots, t_k][x, z]` or\\n        ``None``\\n\\n    See also\\n    ========\\n\\n    _integer_rational_reconstruction\\n\\n    '\n    h = ring.zero\n    if isinstance(ring.domain, PolynomialRing):\n        reconstruction = _rational_reconstruction_int_coeffs\n        domain = ring.domain.ring\n    else:\n        reconstruction = _integer_rational_reconstruction\n        domain = hm.ring.domain\n    for (monom, coeff) in hm.iterterms():\n        coeffh = reconstruction(coeff, m, domain)\n        if not coeffh:\n            return None\n        h[monom] = coeffh\n    return h",
            "def _rational_reconstruction_int_coeffs(hm, m, ring):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Reconstruct every rational coefficient `c_h` of a polynomial `h` in\\n    `\\\\mathbb Q[t_1, \\\\ldots, t_k][x, z]` from the corresponding integer\\n    coefficient `c_{h_m}` of a polynomial `h_m` in\\n    `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]` such that\\n\\n    .. math::\\n\\n        c_{h_m} = c_h \\\\; \\\\mathrm{mod} \\\\, m,\\n\\n    where `m \\\\in \\\\mathbb Z`.\\n\\n    The reconstruction is based on the Euclidean Algorithm. In general,\\n    `m` is not a prime number, so it is possible that this fails for some\\n    coefficient. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    hm : PolyElement\\n        polynomial in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    m : Integer\\n        modulus, not necessarily prime\\n    ring : PolyRing\\n        `\\\\mathbb Q[t_1, \\\\ldots, t_k][x, z]`, `h` will be an element of this\\n        ring\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        reconstructed polynomial in `\\\\mathbb Q[t_1, \\\\ldots, t_k][x, z]` or\\n        ``None``\\n\\n    See also\\n    ========\\n\\n    _integer_rational_reconstruction\\n\\n    '\n    h = ring.zero\n    if isinstance(ring.domain, PolynomialRing):\n        reconstruction = _rational_reconstruction_int_coeffs\n        domain = ring.domain.ring\n    else:\n        reconstruction = _integer_rational_reconstruction\n        domain = hm.ring.domain\n    for (monom, coeff) in hm.iterterms():\n        coeffh = reconstruction(coeff, m, domain)\n        if not coeffh:\n            return None\n        h[monom] = coeffh\n    return h",
            "def _rational_reconstruction_int_coeffs(hm, m, ring):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Reconstruct every rational coefficient `c_h` of a polynomial `h` in\\n    `\\\\mathbb Q[t_1, \\\\ldots, t_k][x, z]` from the corresponding integer\\n    coefficient `c_{h_m}` of a polynomial `h_m` in\\n    `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]` such that\\n\\n    .. math::\\n\\n        c_{h_m} = c_h \\\\; \\\\mathrm{mod} \\\\, m,\\n\\n    where `m \\\\in \\\\mathbb Z`.\\n\\n    The reconstruction is based on the Euclidean Algorithm. In general,\\n    `m` is not a prime number, so it is possible that this fails for some\\n    coefficient. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    hm : PolyElement\\n        polynomial in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    m : Integer\\n        modulus, not necessarily prime\\n    ring : PolyRing\\n        `\\\\mathbb Q[t_1, \\\\ldots, t_k][x, z]`, `h` will be an element of this\\n        ring\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        reconstructed polynomial in `\\\\mathbb Q[t_1, \\\\ldots, t_k][x, z]` or\\n        ``None``\\n\\n    See also\\n    ========\\n\\n    _integer_rational_reconstruction\\n\\n    '\n    h = ring.zero\n    if isinstance(ring.domain, PolynomialRing):\n        reconstruction = _rational_reconstruction_int_coeffs\n        domain = ring.domain.ring\n    else:\n        reconstruction = _integer_rational_reconstruction\n        domain = hm.ring.domain\n    for (monom, coeff) in hm.iterterms():\n        coeffh = reconstruction(coeff, m, domain)\n        if not coeffh:\n            return None\n        h[monom] = coeffh\n    return h",
            "def _rational_reconstruction_int_coeffs(hm, m, ring):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Reconstruct every rational coefficient `c_h` of a polynomial `h` in\\n    `\\\\mathbb Q[t_1, \\\\ldots, t_k][x, z]` from the corresponding integer\\n    coefficient `c_{h_m}` of a polynomial `h_m` in\\n    `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]` such that\\n\\n    .. math::\\n\\n        c_{h_m} = c_h \\\\; \\\\mathrm{mod} \\\\, m,\\n\\n    where `m \\\\in \\\\mathbb Z`.\\n\\n    The reconstruction is based on the Euclidean Algorithm. In general,\\n    `m` is not a prime number, so it is possible that this fails for some\\n    coefficient. In that case ``None`` is returned.\\n\\n    Parameters\\n    ==========\\n\\n    hm : PolyElement\\n        polynomial in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    m : Integer\\n        modulus, not necessarily prime\\n    ring : PolyRing\\n        `\\\\mathbb Q[t_1, \\\\ldots, t_k][x, z]`, `h` will be an element of this\\n        ring\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        reconstructed polynomial in `\\\\mathbb Q[t_1, \\\\ldots, t_k][x, z]` or\\n        ``None``\\n\\n    See also\\n    ========\\n\\n    _integer_rational_reconstruction\\n\\n    '\n    h = ring.zero\n    if isinstance(ring.domain, PolynomialRing):\n        reconstruction = _rational_reconstruction_int_coeffs\n        domain = ring.domain.ring\n    else:\n        reconstruction = _integer_rational_reconstruction\n        domain = hm.ring.domain\n    for (monom, coeff) in hm.iterterms():\n        coeffh = reconstruction(coeff, m, domain)\n        if not coeffh:\n            return None\n        h[monom] = coeffh\n    return h"
        ]
    },
    {
        "func_name": "_func_field_modgcd_m",
        "original": "def _func_field_modgcd_m(f, g, minpoly):\n    \"\"\"\n    Compute the GCD of two polynomials in\n    `\\\\mathbb Q(t_1, \\\\ldots, t_k)[z]/(m_{\\\\alpha}(z))[x]` using a modular\n    algorithm.\n\n    The algorithm computes the GCD of two polynomials `f` and `g` by\n    calculating the GCD in\n    `\\\\mathbb Z_p(t_1, \\\\ldots, t_k)[z] / (\\\\check m_{\\\\alpha}(z))[x]` for\n    suitable primes `p` and the primitive associate `\\\\check m_{\\\\alpha}(z)`\n    of `m_{\\\\alpha}(z)`. Then the coefficients are reconstructed with the\n    Chinese Remainder Theorem and Rational Reconstruction. To compute the\n    GCD over `\\\\mathbb Z_p(t_1, \\\\ldots, t_k)[z] / (\\\\check m_{\\\\alpha})[x]`,\n    the recursive subroutine ``_func_field_modgcd_p`` is used. To verify the\n    result in `\\\\mathbb Q(t_1, \\\\ldots, t_k)[z] / (m_{\\\\alpha}(z))[x]`, a\n    fraction free trial division is used.\n\n    Parameters\n    ==========\n\n    f, g : PolyElement\n        polynomials in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\n    minpoly : PolyElement\n        irreducible polynomial in `\\\\mathbb Z[t_1, \\\\ldots, t_k][z]`\n\n    Returns\n    =======\n\n    h : PolyElement\n        the primitive associate in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]` of\n        the GCD of `f` and `g`\n\n    Examples\n    ========\n\n    >>> from sympy.polys.modulargcd import _func_field_modgcd_m\n    >>> from sympy.polys import ring, ZZ\n\n    >>> R, x, z = ring('x, z', ZZ)\n    >>> minpoly = (z**2 - 2).drop(0)\n\n    >>> f = x**2 + 2*x*z + 2\n    >>> g = x + z\n    >>> _func_field_modgcd_m(f, g, minpoly)\n    x + z\n\n    >>> D, t = ring('t', ZZ)\n    >>> R, x, z = ring('x, z', D)\n    >>> minpoly = (z**2-3).drop(0)\n\n    >>> f = x**2 + (t + 1)*x*z + 3*t\n    >>> g = x*z + 3*t\n    >>> _func_field_modgcd_m(f, g, minpoly)\n    x + t*z\n\n    References\n    ==========\n\n    1. [Hoeij04]_\n\n    See also\n    ========\n\n    _func_field_modgcd_p\n\n    \"\"\"\n    ring = f.ring\n    domain = ring.domain\n    if isinstance(domain, PolynomialRing):\n        k = domain.ngens\n        QQdomain = domain.ring.clone(domain=domain.domain.get_field())\n        QQring = ring.clone(domain=QQdomain)\n    else:\n        k = 0\n        QQring = ring.clone(domain=ring.domain.get_field())\n    (cf, f) = f.primitive()\n    (cg, g) = g.primitive()\n    gamma = ring.dmp_LC(f) * ring.dmp_LC(g)\n    delta = minpoly.LC\n    p = 1\n    primes = []\n    hplist = []\n    LMlist = []\n    while True:\n        p = nextprime(p)\n        if gamma.trunc_ground(p) == 0:\n            continue\n        if k == 0:\n            test = delta % p == 0\n        else:\n            test = delta.trunc_ground(p) == 0\n        if test:\n            continue\n        fp = f.trunc_ground(p)\n        gp = g.trunc_ground(p)\n        minpolyp = minpoly.trunc_ground(p)\n        hp = _func_field_modgcd_p(fp, gp, minpolyp, p)\n        if hp is None:\n            continue\n        if hp == 1:\n            return ring.one\n        LM = [hp.degree()] + [0] * k\n        if k > 0:\n            for (monom, coeff) in hp.iterterms():\n                if monom[0] == LM[0] and coeff.LM > tuple(LM[1:]):\n                    LM[1:] = coeff.LM\n        hm = hp\n        m = p\n        for (q, hq, LMhq) in zip(primes, hplist, LMlist):\n            if LMhq == LM:\n                hm = _chinese_remainder_reconstruction_multivariate(hq, hm, q, m)\n                m *= q\n        primes.append(p)\n        hplist.append(hp)\n        LMlist.append(LM)\n        hm = _rational_reconstruction_int_coeffs(hm, m, QQring)\n        if hm is None:\n            continue\n        if k == 0:\n            h = hm.clear_denoms()[1]\n        else:\n            den = domain.domain.one\n            for coeff in hm.itercoeffs():\n                den = domain.domain.lcm(den, coeff.clear_denoms()[0])\n            h = hm.mul_ground(den)\n        h = h.set_ring(ring)\n        h = h.primitive()[1]\n        if not (_trial_division(f.mul_ground(cf), h, minpoly) or _trial_division(g.mul_ground(cg), h, minpoly)):\n            return h",
        "mutated": [
            "def _func_field_modgcd_m(f, g, minpoly):\n    if False:\n        i = 10\n    \"\\n    Compute the GCD of two polynomials in\\n    `\\\\mathbb Q(t_1, \\\\ldots, t_k)[z]/(m_{\\\\alpha}(z))[x]` using a modular\\n    algorithm.\\n\\n    The algorithm computes the GCD of two polynomials `f` and `g` by\\n    calculating the GCD in\\n    `\\\\mathbb Z_p(t_1, \\\\ldots, t_k)[z] / (\\\\check m_{\\\\alpha}(z))[x]` for\\n    suitable primes `p` and the primitive associate `\\\\check m_{\\\\alpha}(z)`\\n    of `m_{\\\\alpha}(z)`. Then the coefficients are reconstructed with the\\n    Chinese Remainder Theorem and Rational Reconstruction. To compute the\\n    GCD over `\\\\mathbb Z_p(t_1, \\\\ldots, t_k)[z] / (\\\\check m_{\\\\alpha})[x]`,\\n    the recursive subroutine ``_func_field_modgcd_p`` is used. To verify the\\n    result in `\\\\mathbb Q(t_1, \\\\ldots, t_k)[z] / (m_{\\\\alpha}(z))[x]`, a\\n    fraction free trial division is used.\\n\\n    Parameters\\n    ==========\\n\\n    f, g : PolyElement\\n        polynomials in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    minpoly : PolyElement\\n        irreducible polynomial in `\\\\mathbb Z[t_1, \\\\ldots, t_k][z]`\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        the primitive associate in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]` of\\n        the GCD of `f` and `g`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _func_field_modgcd_m\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, z = ring('x, z', ZZ)\\n    >>> minpoly = (z**2 - 2).drop(0)\\n\\n    >>> f = x**2 + 2*x*z + 2\\n    >>> g = x + z\\n    >>> _func_field_modgcd_m(f, g, minpoly)\\n    x + z\\n\\n    >>> D, t = ring('t', ZZ)\\n    >>> R, x, z = ring('x, z', D)\\n    >>> minpoly = (z**2-3).drop(0)\\n\\n    >>> f = x**2 + (t + 1)*x*z + 3*t\\n    >>> g = x*z + 3*t\\n    >>> _func_field_modgcd_m(f, g, minpoly)\\n    x + t*z\\n\\n    References\\n    ==========\\n\\n    1. [Hoeij04]_\\n\\n    See also\\n    ========\\n\\n    _func_field_modgcd_p\\n\\n    \"\n    ring = f.ring\n    domain = ring.domain\n    if isinstance(domain, PolynomialRing):\n        k = domain.ngens\n        QQdomain = domain.ring.clone(domain=domain.domain.get_field())\n        QQring = ring.clone(domain=QQdomain)\n    else:\n        k = 0\n        QQring = ring.clone(domain=ring.domain.get_field())\n    (cf, f) = f.primitive()\n    (cg, g) = g.primitive()\n    gamma = ring.dmp_LC(f) * ring.dmp_LC(g)\n    delta = minpoly.LC\n    p = 1\n    primes = []\n    hplist = []\n    LMlist = []\n    while True:\n        p = nextprime(p)\n        if gamma.trunc_ground(p) == 0:\n            continue\n        if k == 0:\n            test = delta % p == 0\n        else:\n            test = delta.trunc_ground(p) == 0\n        if test:\n            continue\n        fp = f.trunc_ground(p)\n        gp = g.trunc_ground(p)\n        minpolyp = minpoly.trunc_ground(p)\n        hp = _func_field_modgcd_p(fp, gp, minpolyp, p)\n        if hp is None:\n            continue\n        if hp == 1:\n            return ring.one\n        LM = [hp.degree()] + [0] * k\n        if k > 0:\n            for (monom, coeff) in hp.iterterms():\n                if monom[0] == LM[0] and coeff.LM > tuple(LM[1:]):\n                    LM[1:] = coeff.LM\n        hm = hp\n        m = p\n        for (q, hq, LMhq) in zip(primes, hplist, LMlist):\n            if LMhq == LM:\n                hm = _chinese_remainder_reconstruction_multivariate(hq, hm, q, m)\n                m *= q\n        primes.append(p)\n        hplist.append(hp)\n        LMlist.append(LM)\n        hm = _rational_reconstruction_int_coeffs(hm, m, QQring)\n        if hm is None:\n            continue\n        if k == 0:\n            h = hm.clear_denoms()[1]\n        else:\n            den = domain.domain.one\n            for coeff in hm.itercoeffs():\n                den = domain.domain.lcm(den, coeff.clear_denoms()[0])\n            h = hm.mul_ground(den)\n        h = h.set_ring(ring)\n        h = h.primitive()[1]\n        if not (_trial_division(f.mul_ground(cf), h, minpoly) or _trial_division(g.mul_ground(cg), h, minpoly)):\n            return h",
            "def _func_field_modgcd_m(f, g, minpoly):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Compute the GCD of two polynomials in\\n    `\\\\mathbb Q(t_1, \\\\ldots, t_k)[z]/(m_{\\\\alpha}(z))[x]` using a modular\\n    algorithm.\\n\\n    The algorithm computes the GCD of two polynomials `f` and `g` by\\n    calculating the GCD in\\n    `\\\\mathbb Z_p(t_1, \\\\ldots, t_k)[z] / (\\\\check m_{\\\\alpha}(z))[x]` for\\n    suitable primes `p` and the primitive associate `\\\\check m_{\\\\alpha}(z)`\\n    of `m_{\\\\alpha}(z)`. Then the coefficients are reconstructed with the\\n    Chinese Remainder Theorem and Rational Reconstruction. To compute the\\n    GCD over `\\\\mathbb Z_p(t_1, \\\\ldots, t_k)[z] / (\\\\check m_{\\\\alpha})[x]`,\\n    the recursive subroutine ``_func_field_modgcd_p`` is used. To verify the\\n    result in `\\\\mathbb Q(t_1, \\\\ldots, t_k)[z] / (m_{\\\\alpha}(z))[x]`, a\\n    fraction free trial division is used.\\n\\n    Parameters\\n    ==========\\n\\n    f, g : PolyElement\\n        polynomials in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    minpoly : PolyElement\\n        irreducible polynomial in `\\\\mathbb Z[t_1, \\\\ldots, t_k][z]`\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        the primitive associate in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]` of\\n        the GCD of `f` and `g`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _func_field_modgcd_m\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, z = ring('x, z', ZZ)\\n    >>> minpoly = (z**2 - 2).drop(0)\\n\\n    >>> f = x**2 + 2*x*z + 2\\n    >>> g = x + z\\n    >>> _func_field_modgcd_m(f, g, minpoly)\\n    x + z\\n\\n    >>> D, t = ring('t', ZZ)\\n    >>> R, x, z = ring('x, z', D)\\n    >>> minpoly = (z**2-3).drop(0)\\n\\n    >>> f = x**2 + (t + 1)*x*z + 3*t\\n    >>> g = x*z + 3*t\\n    >>> _func_field_modgcd_m(f, g, minpoly)\\n    x + t*z\\n\\n    References\\n    ==========\\n\\n    1. [Hoeij04]_\\n\\n    See also\\n    ========\\n\\n    _func_field_modgcd_p\\n\\n    \"\n    ring = f.ring\n    domain = ring.domain\n    if isinstance(domain, PolynomialRing):\n        k = domain.ngens\n        QQdomain = domain.ring.clone(domain=domain.domain.get_field())\n        QQring = ring.clone(domain=QQdomain)\n    else:\n        k = 0\n        QQring = ring.clone(domain=ring.domain.get_field())\n    (cf, f) = f.primitive()\n    (cg, g) = g.primitive()\n    gamma = ring.dmp_LC(f) * ring.dmp_LC(g)\n    delta = minpoly.LC\n    p = 1\n    primes = []\n    hplist = []\n    LMlist = []\n    while True:\n        p = nextprime(p)\n        if gamma.trunc_ground(p) == 0:\n            continue\n        if k == 0:\n            test = delta % p == 0\n        else:\n            test = delta.trunc_ground(p) == 0\n        if test:\n            continue\n        fp = f.trunc_ground(p)\n        gp = g.trunc_ground(p)\n        minpolyp = minpoly.trunc_ground(p)\n        hp = _func_field_modgcd_p(fp, gp, minpolyp, p)\n        if hp is None:\n            continue\n        if hp == 1:\n            return ring.one\n        LM = [hp.degree()] + [0] * k\n        if k > 0:\n            for (monom, coeff) in hp.iterterms():\n                if monom[0] == LM[0] and coeff.LM > tuple(LM[1:]):\n                    LM[1:] = coeff.LM\n        hm = hp\n        m = p\n        for (q, hq, LMhq) in zip(primes, hplist, LMlist):\n            if LMhq == LM:\n                hm = _chinese_remainder_reconstruction_multivariate(hq, hm, q, m)\n                m *= q\n        primes.append(p)\n        hplist.append(hp)\n        LMlist.append(LM)\n        hm = _rational_reconstruction_int_coeffs(hm, m, QQring)\n        if hm is None:\n            continue\n        if k == 0:\n            h = hm.clear_denoms()[1]\n        else:\n            den = domain.domain.one\n            for coeff in hm.itercoeffs():\n                den = domain.domain.lcm(den, coeff.clear_denoms()[0])\n            h = hm.mul_ground(den)\n        h = h.set_ring(ring)\n        h = h.primitive()[1]\n        if not (_trial_division(f.mul_ground(cf), h, minpoly) or _trial_division(g.mul_ground(cg), h, minpoly)):\n            return h",
            "def _func_field_modgcd_m(f, g, minpoly):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Compute the GCD of two polynomials in\\n    `\\\\mathbb Q(t_1, \\\\ldots, t_k)[z]/(m_{\\\\alpha}(z))[x]` using a modular\\n    algorithm.\\n\\n    The algorithm computes the GCD of two polynomials `f` and `g` by\\n    calculating the GCD in\\n    `\\\\mathbb Z_p(t_1, \\\\ldots, t_k)[z] / (\\\\check m_{\\\\alpha}(z))[x]` for\\n    suitable primes `p` and the primitive associate `\\\\check m_{\\\\alpha}(z)`\\n    of `m_{\\\\alpha}(z)`. Then the coefficients are reconstructed with the\\n    Chinese Remainder Theorem and Rational Reconstruction. To compute the\\n    GCD over `\\\\mathbb Z_p(t_1, \\\\ldots, t_k)[z] / (\\\\check m_{\\\\alpha})[x]`,\\n    the recursive subroutine ``_func_field_modgcd_p`` is used. To verify the\\n    result in `\\\\mathbb Q(t_1, \\\\ldots, t_k)[z] / (m_{\\\\alpha}(z))[x]`, a\\n    fraction free trial division is used.\\n\\n    Parameters\\n    ==========\\n\\n    f, g : PolyElement\\n        polynomials in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    minpoly : PolyElement\\n        irreducible polynomial in `\\\\mathbb Z[t_1, \\\\ldots, t_k][z]`\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        the primitive associate in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]` of\\n        the GCD of `f` and `g`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _func_field_modgcd_m\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, z = ring('x, z', ZZ)\\n    >>> minpoly = (z**2 - 2).drop(0)\\n\\n    >>> f = x**2 + 2*x*z + 2\\n    >>> g = x + z\\n    >>> _func_field_modgcd_m(f, g, minpoly)\\n    x + z\\n\\n    >>> D, t = ring('t', ZZ)\\n    >>> R, x, z = ring('x, z', D)\\n    >>> minpoly = (z**2-3).drop(0)\\n\\n    >>> f = x**2 + (t + 1)*x*z + 3*t\\n    >>> g = x*z + 3*t\\n    >>> _func_field_modgcd_m(f, g, minpoly)\\n    x + t*z\\n\\n    References\\n    ==========\\n\\n    1. [Hoeij04]_\\n\\n    See also\\n    ========\\n\\n    _func_field_modgcd_p\\n\\n    \"\n    ring = f.ring\n    domain = ring.domain\n    if isinstance(domain, PolynomialRing):\n        k = domain.ngens\n        QQdomain = domain.ring.clone(domain=domain.domain.get_field())\n        QQring = ring.clone(domain=QQdomain)\n    else:\n        k = 0\n        QQring = ring.clone(domain=ring.domain.get_field())\n    (cf, f) = f.primitive()\n    (cg, g) = g.primitive()\n    gamma = ring.dmp_LC(f) * ring.dmp_LC(g)\n    delta = minpoly.LC\n    p = 1\n    primes = []\n    hplist = []\n    LMlist = []\n    while True:\n        p = nextprime(p)\n        if gamma.trunc_ground(p) == 0:\n            continue\n        if k == 0:\n            test = delta % p == 0\n        else:\n            test = delta.trunc_ground(p) == 0\n        if test:\n            continue\n        fp = f.trunc_ground(p)\n        gp = g.trunc_ground(p)\n        minpolyp = minpoly.trunc_ground(p)\n        hp = _func_field_modgcd_p(fp, gp, minpolyp, p)\n        if hp is None:\n            continue\n        if hp == 1:\n            return ring.one\n        LM = [hp.degree()] + [0] * k\n        if k > 0:\n            for (monom, coeff) in hp.iterterms():\n                if monom[0] == LM[0] and coeff.LM > tuple(LM[1:]):\n                    LM[1:] = coeff.LM\n        hm = hp\n        m = p\n        for (q, hq, LMhq) in zip(primes, hplist, LMlist):\n            if LMhq == LM:\n                hm = _chinese_remainder_reconstruction_multivariate(hq, hm, q, m)\n                m *= q\n        primes.append(p)\n        hplist.append(hp)\n        LMlist.append(LM)\n        hm = _rational_reconstruction_int_coeffs(hm, m, QQring)\n        if hm is None:\n            continue\n        if k == 0:\n            h = hm.clear_denoms()[1]\n        else:\n            den = domain.domain.one\n            for coeff in hm.itercoeffs():\n                den = domain.domain.lcm(den, coeff.clear_denoms()[0])\n            h = hm.mul_ground(den)\n        h = h.set_ring(ring)\n        h = h.primitive()[1]\n        if not (_trial_division(f.mul_ground(cf), h, minpoly) or _trial_division(g.mul_ground(cg), h, minpoly)):\n            return h",
            "def _func_field_modgcd_m(f, g, minpoly):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Compute the GCD of two polynomials in\\n    `\\\\mathbb Q(t_1, \\\\ldots, t_k)[z]/(m_{\\\\alpha}(z))[x]` using a modular\\n    algorithm.\\n\\n    The algorithm computes the GCD of two polynomials `f` and `g` by\\n    calculating the GCD in\\n    `\\\\mathbb Z_p(t_1, \\\\ldots, t_k)[z] / (\\\\check m_{\\\\alpha}(z))[x]` for\\n    suitable primes `p` and the primitive associate `\\\\check m_{\\\\alpha}(z)`\\n    of `m_{\\\\alpha}(z)`. Then the coefficients are reconstructed with the\\n    Chinese Remainder Theorem and Rational Reconstruction. To compute the\\n    GCD over `\\\\mathbb Z_p(t_1, \\\\ldots, t_k)[z] / (\\\\check m_{\\\\alpha})[x]`,\\n    the recursive subroutine ``_func_field_modgcd_p`` is used. To verify the\\n    result in `\\\\mathbb Q(t_1, \\\\ldots, t_k)[z] / (m_{\\\\alpha}(z))[x]`, a\\n    fraction free trial division is used.\\n\\n    Parameters\\n    ==========\\n\\n    f, g : PolyElement\\n        polynomials in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    minpoly : PolyElement\\n        irreducible polynomial in `\\\\mathbb Z[t_1, \\\\ldots, t_k][z]`\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        the primitive associate in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]` of\\n        the GCD of `f` and `g`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _func_field_modgcd_m\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, z = ring('x, z', ZZ)\\n    >>> minpoly = (z**2 - 2).drop(0)\\n\\n    >>> f = x**2 + 2*x*z + 2\\n    >>> g = x + z\\n    >>> _func_field_modgcd_m(f, g, minpoly)\\n    x + z\\n\\n    >>> D, t = ring('t', ZZ)\\n    >>> R, x, z = ring('x, z', D)\\n    >>> minpoly = (z**2-3).drop(0)\\n\\n    >>> f = x**2 + (t + 1)*x*z + 3*t\\n    >>> g = x*z + 3*t\\n    >>> _func_field_modgcd_m(f, g, minpoly)\\n    x + t*z\\n\\n    References\\n    ==========\\n\\n    1. [Hoeij04]_\\n\\n    See also\\n    ========\\n\\n    _func_field_modgcd_p\\n\\n    \"\n    ring = f.ring\n    domain = ring.domain\n    if isinstance(domain, PolynomialRing):\n        k = domain.ngens\n        QQdomain = domain.ring.clone(domain=domain.domain.get_field())\n        QQring = ring.clone(domain=QQdomain)\n    else:\n        k = 0\n        QQring = ring.clone(domain=ring.domain.get_field())\n    (cf, f) = f.primitive()\n    (cg, g) = g.primitive()\n    gamma = ring.dmp_LC(f) * ring.dmp_LC(g)\n    delta = minpoly.LC\n    p = 1\n    primes = []\n    hplist = []\n    LMlist = []\n    while True:\n        p = nextprime(p)\n        if gamma.trunc_ground(p) == 0:\n            continue\n        if k == 0:\n            test = delta % p == 0\n        else:\n            test = delta.trunc_ground(p) == 0\n        if test:\n            continue\n        fp = f.trunc_ground(p)\n        gp = g.trunc_ground(p)\n        minpolyp = minpoly.trunc_ground(p)\n        hp = _func_field_modgcd_p(fp, gp, minpolyp, p)\n        if hp is None:\n            continue\n        if hp == 1:\n            return ring.one\n        LM = [hp.degree()] + [0] * k\n        if k > 0:\n            for (monom, coeff) in hp.iterterms():\n                if monom[0] == LM[0] and coeff.LM > tuple(LM[1:]):\n                    LM[1:] = coeff.LM\n        hm = hp\n        m = p\n        for (q, hq, LMhq) in zip(primes, hplist, LMlist):\n            if LMhq == LM:\n                hm = _chinese_remainder_reconstruction_multivariate(hq, hm, q, m)\n                m *= q\n        primes.append(p)\n        hplist.append(hp)\n        LMlist.append(LM)\n        hm = _rational_reconstruction_int_coeffs(hm, m, QQring)\n        if hm is None:\n            continue\n        if k == 0:\n            h = hm.clear_denoms()[1]\n        else:\n            den = domain.domain.one\n            for coeff in hm.itercoeffs():\n                den = domain.domain.lcm(den, coeff.clear_denoms()[0])\n            h = hm.mul_ground(den)\n        h = h.set_ring(ring)\n        h = h.primitive()[1]\n        if not (_trial_division(f.mul_ground(cf), h, minpoly) or _trial_division(g.mul_ground(cg), h, minpoly)):\n            return h",
            "def _func_field_modgcd_m(f, g, minpoly):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Compute the GCD of two polynomials in\\n    `\\\\mathbb Q(t_1, \\\\ldots, t_k)[z]/(m_{\\\\alpha}(z))[x]` using a modular\\n    algorithm.\\n\\n    The algorithm computes the GCD of two polynomials `f` and `g` by\\n    calculating the GCD in\\n    `\\\\mathbb Z_p(t_1, \\\\ldots, t_k)[z] / (\\\\check m_{\\\\alpha}(z))[x]` for\\n    suitable primes `p` and the primitive associate `\\\\check m_{\\\\alpha}(z)`\\n    of `m_{\\\\alpha}(z)`. Then the coefficients are reconstructed with the\\n    Chinese Remainder Theorem and Rational Reconstruction. To compute the\\n    GCD over `\\\\mathbb Z_p(t_1, \\\\ldots, t_k)[z] / (\\\\check m_{\\\\alpha})[x]`,\\n    the recursive subroutine ``_func_field_modgcd_p`` is used. To verify the\\n    result in `\\\\mathbb Q(t_1, \\\\ldots, t_k)[z] / (m_{\\\\alpha}(z))[x]`, a\\n    fraction free trial division is used.\\n\\n    Parameters\\n    ==========\\n\\n    f, g : PolyElement\\n        polynomials in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]`\\n    minpoly : PolyElement\\n        irreducible polynomial in `\\\\mathbb Z[t_1, \\\\ldots, t_k][z]`\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        the primitive associate in `\\\\mathbb Z[t_1, \\\\ldots, t_k][x, z]` of\\n        the GCD of `f` and `g`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import _func_field_modgcd_m\\n    >>> from sympy.polys import ring, ZZ\\n\\n    >>> R, x, z = ring('x, z', ZZ)\\n    >>> minpoly = (z**2 - 2).drop(0)\\n\\n    >>> f = x**2 + 2*x*z + 2\\n    >>> g = x + z\\n    >>> _func_field_modgcd_m(f, g, minpoly)\\n    x + z\\n\\n    >>> D, t = ring('t', ZZ)\\n    >>> R, x, z = ring('x, z', D)\\n    >>> minpoly = (z**2-3).drop(0)\\n\\n    >>> f = x**2 + (t + 1)*x*z + 3*t\\n    >>> g = x*z + 3*t\\n    >>> _func_field_modgcd_m(f, g, minpoly)\\n    x + t*z\\n\\n    References\\n    ==========\\n\\n    1. [Hoeij04]_\\n\\n    See also\\n    ========\\n\\n    _func_field_modgcd_p\\n\\n    \"\n    ring = f.ring\n    domain = ring.domain\n    if isinstance(domain, PolynomialRing):\n        k = domain.ngens\n        QQdomain = domain.ring.clone(domain=domain.domain.get_field())\n        QQring = ring.clone(domain=QQdomain)\n    else:\n        k = 0\n        QQring = ring.clone(domain=ring.domain.get_field())\n    (cf, f) = f.primitive()\n    (cg, g) = g.primitive()\n    gamma = ring.dmp_LC(f) * ring.dmp_LC(g)\n    delta = minpoly.LC\n    p = 1\n    primes = []\n    hplist = []\n    LMlist = []\n    while True:\n        p = nextprime(p)\n        if gamma.trunc_ground(p) == 0:\n            continue\n        if k == 0:\n            test = delta % p == 0\n        else:\n            test = delta.trunc_ground(p) == 0\n        if test:\n            continue\n        fp = f.trunc_ground(p)\n        gp = g.trunc_ground(p)\n        minpolyp = minpoly.trunc_ground(p)\n        hp = _func_field_modgcd_p(fp, gp, minpolyp, p)\n        if hp is None:\n            continue\n        if hp == 1:\n            return ring.one\n        LM = [hp.degree()] + [0] * k\n        if k > 0:\n            for (monom, coeff) in hp.iterterms():\n                if monom[0] == LM[0] and coeff.LM > tuple(LM[1:]):\n                    LM[1:] = coeff.LM\n        hm = hp\n        m = p\n        for (q, hq, LMhq) in zip(primes, hplist, LMlist):\n            if LMhq == LM:\n                hm = _chinese_remainder_reconstruction_multivariate(hq, hm, q, m)\n                m *= q\n        primes.append(p)\n        hplist.append(hp)\n        LMlist.append(LM)\n        hm = _rational_reconstruction_int_coeffs(hm, m, QQring)\n        if hm is None:\n            continue\n        if k == 0:\n            h = hm.clear_denoms()[1]\n        else:\n            den = domain.domain.one\n            for coeff in hm.itercoeffs():\n                den = domain.domain.lcm(den, coeff.clear_denoms()[0])\n            h = hm.mul_ground(den)\n        h = h.set_ring(ring)\n        h = h.primitive()[1]\n        if not (_trial_division(f.mul_ground(cf), h, minpoly) or _trial_division(g.mul_ground(cg), h, minpoly)):\n            return h"
        ]
    },
    {
        "func_name": "_to_ZZ_poly",
        "original": "def _to_ZZ_poly(f, ring):\n    \"\"\"\n    Compute an associate of a polynomial\n    `f \\\\in \\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]` in\n    `\\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][z] / (\\\\check m_{\\\\alpha}(z))[x_0]`,\n    where `\\\\check m_{\\\\alpha}(z) \\\\in \\\\mathbb Z[z]` is the primitive associate\n    of the minimal polynomial `m_{\\\\alpha}(z)` of `\\\\alpha` over\n    `\\\\mathbb Q`.\n\n    Parameters\n    ==========\n\n    f : PolyElement\n        polynomial in `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`\n    ring : PolyRing\n        `\\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][x_0, z]`\n\n    Returns\n    =======\n\n    f_ : PolyElement\n        associate of `f` in\n        `\\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][x_0, z]`\n\n    \"\"\"\n    f_ = ring.zero\n    if isinstance(ring.domain, PolynomialRing):\n        domain = ring.domain.domain\n    else:\n        domain = ring.domain\n    den = domain.one\n    for coeff in f.itercoeffs():\n        for c in coeff.to_list():\n            if c:\n                den = domain.lcm(den, c.denominator)\n    for (monom, coeff) in f.iterterms():\n        coeff = coeff.to_list()\n        m = ring.domain.one\n        if isinstance(ring.domain, PolynomialRing):\n            m = m.mul_monom(monom[1:])\n        n = len(coeff)\n        for i in range(n):\n            if coeff[i]:\n                c = domain.convert(coeff[i] * den) * m\n                if (monom[0], n - i - 1) not in f_:\n                    f_[monom[0], n - i - 1] = c\n                else:\n                    f_[monom[0], n - i - 1] += c\n    return f_",
        "mutated": [
            "def _to_ZZ_poly(f, ring):\n    if False:\n        i = 10\n    '\\n    Compute an associate of a polynomial\\n    `f \\\\in \\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]` in\\n    `\\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][z] / (\\\\check m_{\\\\alpha}(z))[x_0]`,\\n    where `\\\\check m_{\\\\alpha}(z) \\\\in \\\\mathbb Z[z]` is the primitive associate\\n    of the minimal polynomial `m_{\\\\alpha}(z)` of `\\\\alpha` over\\n    `\\\\mathbb Q`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`\\n    ring : PolyRing\\n        `\\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][x_0, z]`\\n\\n    Returns\\n    =======\\n\\n    f_ : PolyElement\\n        associate of `f` in\\n        `\\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][x_0, z]`\\n\\n    '\n    f_ = ring.zero\n    if isinstance(ring.domain, PolynomialRing):\n        domain = ring.domain.domain\n    else:\n        domain = ring.domain\n    den = domain.one\n    for coeff in f.itercoeffs():\n        for c in coeff.to_list():\n            if c:\n                den = domain.lcm(den, c.denominator)\n    for (monom, coeff) in f.iterterms():\n        coeff = coeff.to_list()\n        m = ring.domain.one\n        if isinstance(ring.domain, PolynomialRing):\n            m = m.mul_monom(monom[1:])\n        n = len(coeff)\n        for i in range(n):\n            if coeff[i]:\n                c = domain.convert(coeff[i] * den) * m\n                if (monom[0], n - i - 1) not in f_:\n                    f_[monom[0], n - i - 1] = c\n                else:\n                    f_[monom[0], n - i - 1] += c\n    return f_",
            "def _to_ZZ_poly(f, ring):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute an associate of a polynomial\\n    `f \\\\in \\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]` in\\n    `\\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][z] / (\\\\check m_{\\\\alpha}(z))[x_0]`,\\n    where `\\\\check m_{\\\\alpha}(z) \\\\in \\\\mathbb Z[z]` is the primitive associate\\n    of the minimal polynomial `m_{\\\\alpha}(z)` of `\\\\alpha` over\\n    `\\\\mathbb Q`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`\\n    ring : PolyRing\\n        `\\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][x_0, z]`\\n\\n    Returns\\n    =======\\n\\n    f_ : PolyElement\\n        associate of `f` in\\n        `\\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][x_0, z]`\\n\\n    '\n    f_ = ring.zero\n    if isinstance(ring.domain, PolynomialRing):\n        domain = ring.domain.domain\n    else:\n        domain = ring.domain\n    den = domain.one\n    for coeff in f.itercoeffs():\n        for c in coeff.to_list():\n            if c:\n                den = domain.lcm(den, c.denominator)\n    for (monom, coeff) in f.iterterms():\n        coeff = coeff.to_list()\n        m = ring.domain.one\n        if isinstance(ring.domain, PolynomialRing):\n            m = m.mul_monom(monom[1:])\n        n = len(coeff)\n        for i in range(n):\n            if coeff[i]:\n                c = domain.convert(coeff[i] * den) * m\n                if (monom[0], n - i - 1) not in f_:\n                    f_[monom[0], n - i - 1] = c\n                else:\n                    f_[monom[0], n - i - 1] += c\n    return f_",
            "def _to_ZZ_poly(f, ring):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute an associate of a polynomial\\n    `f \\\\in \\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]` in\\n    `\\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][z] / (\\\\check m_{\\\\alpha}(z))[x_0]`,\\n    where `\\\\check m_{\\\\alpha}(z) \\\\in \\\\mathbb Z[z]` is the primitive associate\\n    of the minimal polynomial `m_{\\\\alpha}(z)` of `\\\\alpha` over\\n    `\\\\mathbb Q`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`\\n    ring : PolyRing\\n        `\\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][x_0, z]`\\n\\n    Returns\\n    =======\\n\\n    f_ : PolyElement\\n        associate of `f` in\\n        `\\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][x_0, z]`\\n\\n    '\n    f_ = ring.zero\n    if isinstance(ring.domain, PolynomialRing):\n        domain = ring.domain.domain\n    else:\n        domain = ring.domain\n    den = domain.one\n    for coeff in f.itercoeffs():\n        for c in coeff.to_list():\n            if c:\n                den = domain.lcm(den, c.denominator)\n    for (monom, coeff) in f.iterterms():\n        coeff = coeff.to_list()\n        m = ring.domain.one\n        if isinstance(ring.domain, PolynomialRing):\n            m = m.mul_monom(monom[1:])\n        n = len(coeff)\n        for i in range(n):\n            if coeff[i]:\n                c = domain.convert(coeff[i] * den) * m\n                if (monom[0], n - i - 1) not in f_:\n                    f_[monom[0], n - i - 1] = c\n                else:\n                    f_[monom[0], n - i - 1] += c\n    return f_",
            "def _to_ZZ_poly(f, ring):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute an associate of a polynomial\\n    `f \\\\in \\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]` in\\n    `\\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][z] / (\\\\check m_{\\\\alpha}(z))[x_0]`,\\n    where `\\\\check m_{\\\\alpha}(z) \\\\in \\\\mathbb Z[z]` is the primitive associate\\n    of the minimal polynomial `m_{\\\\alpha}(z)` of `\\\\alpha` over\\n    `\\\\mathbb Q`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`\\n    ring : PolyRing\\n        `\\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][x_0, z]`\\n\\n    Returns\\n    =======\\n\\n    f_ : PolyElement\\n        associate of `f` in\\n        `\\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][x_0, z]`\\n\\n    '\n    f_ = ring.zero\n    if isinstance(ring.domain, PolynomialRing):\n        domain = ring.domain.domain\n    else:\n        domain = ring.domain\n    den = domain.one\n    for coeff in f.itercoeffs():\n        for c in coeff.to_list():\n            if c:\n                den = domain.lcm(den, c.denominator)\n    for (monom, coeff) in f.iterterms():\n        coeff = coeff.to_list()\n        m = ring.domain.one\n        if isinstance(ring.domain, PolynomialRing):\n            m = m.mul_monom(monom[1:])\n        n = len(coeff)\n        for i in range(n):\n            if coeff[i]:\n                c = domain.convert(coeff[i] * den) * m\n                if (monom[0], n - i - 1) not in f_:\n                    f_[monom[0], n - i - 1] = c\n                else:\n                    f_[monom[0], n - i - 1] += c\n    return f_",
            "def _to_ZZ_poly(f, ring):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute an associate of a polynomial\\n    `f \\\\in \\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]` in\\n    `\\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][z] / (\\\\check m_{\\\\alpha}(z))[x_0]`,\\n    where `\\\\check m_{\\\\alpha}(z) \\\\in \\\\mathbb Z[z]` is the primitive associate\\n    of the minimal polynomial `m_{\\\\alpha}(z)` of `\\\\alpha` over\\n    `\\\\mathbb Q`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`\\n    ring : PolyRing\\n        `\\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][x_0, z]`\\n\\n    Returns\\n    =======\\n\\n    f_ : PolyElement\\n        associate of `f` in\\n        `\\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][x_0, z]`\\n\\n    '\n    f_ = ring.zero\n    if isinstance(ring.domain, PolynomialRing):\n        domain = ring.domain.domain\n    else:\n        domain = ring.domain\n    den = domain.one\n    for coeff in f.itercoeffs():\n        for c in coeff.to_list():\n            if c:\n                den = domain.lcm(den, c.denominator)\n    for (monom, coeff) in f.iterterms():\n        coeff = coeff.to_list()\n        m = ring.domain.one\n        if isinstance(ring.domain, PolynomialRing):\n            m = m.mul_monom(monom[1:])\n        n = len(coeff)\n        for i in range(n):\n            if coeff[i]:\n                c = domain.convert(coeff[i] * den) * m\n                if (monom[0], n - i - 1) not in f_:\n                    f_[monom[0], n - i - 1] = c\n                else:\n                    f_[monom[0], n - i - 1] += c\n    return f_"
        ]
    },
    {
        "func_name": "_to_ANP_poly",
        "original": "def _to_ANP_poly(f, ring):\n    \"\"\"\n    Convert a polynomial\n    `f \\\\in \\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][z]/(\\\\check m_{\\\\alpha}(z))[x_0]`\n    to a polynomial in `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`,\n    where `\\\\check m_{\\\\alpha}(z) \\\\in \\\\mathbb Z[z]` is the primitive associate\n    of the minimal polynomial `m_{\\\\alpha}(z)` of `\\\\alpha` over\n    `\\\\mathbb Q`.\n\n    Parameters\n    ==========\n\n    f : PolyElement\n        polynomial in `\\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][x_0, z]`\n    ring : PolyRing\n        `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`\n\n    Returns\n    =======\n\n    f_ : PolyElement\n        polynomial in `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`\n\n    \"\"\"\n    domain = ring.domain\n    f_ = ring.zero\n    if isinstance(f.ring.domain, PolynomialRing):\n        for (monom, coeff) in f.iterterms():\n            for (mon, coef) in coeff.iterterms():\n                m = (monom[0],) + mon\n                c = domain([domain.domain(coef)] + [0] * monom[1])\n                if m not in f_:\n                    f_[m] = c\n                else:\n                    f_[m] += c\n    else:\n        for (monom, coeff) in f.iterterms():\n            m = (monom[0],)\n            c = domain([domain.domain(coeff)] + [0] * monom[1])\n            if m not in f_:\n                f_[m] = c\n            else:\n                f_[m] += c\n    return f_",
        "mutated": [
            "def _to_ANP_poly(f, ring):\n    if False:\n        i = 10\n    '\\n    Convert a polynomial\\n    `f \\\\in \\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][z]/(\\\\check m_{\\\\alpha}(z))[x_0]`\\n    to a polynomial in `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`,\\n    where `\\\\check m_{\\\\alpha}(z) \\\\in \\\\mathbb Z[z]` is the primitive associate\\n    of the minimal polynomial `m_{\\\\alpha}(z)` of `\\\\alpha` over\\n    `\\\\mathbb Q`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `\\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][x_0, z]`\\n    ring : PolyRing\\n        `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`\\n\\n    Returns\\n    =======\\n\\n    f_ : PolyElement\\n        polynomial in `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`\\n\\n    '\n    domain = ring.domain\n    f_ = ring.zero\n    if isinstance(f.ring.domain, PolynomialRing):\n        for (monom, coeff) in f.iterterms():\n            for (mon, coef) in coeff.iterterms():\n                m = (monom[0],) + mon\n                c = domain([domain.domain(coef)] + [0] * monom[1])\n                if m not in f_:\n                    f_[m] = c\n                else:\n                    f_[m] += c\n    else:\n        for (monom, coeff) in f.iterterms():\n            m = (monom[0],)\n            c = domain([domain.domain(coeff)] + [0] * monom[1])\n            if m not in f_:\n                f_[m] = c\n            else:\n                f_[m] += c\n    return f_",
            "def _to_ANP_poly(f, ring):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Convert a polynomial\\n    `f \\\\in \\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][z]/(\\\\check m_{\\\\alpha}(z))[x_0]`\\n    to a polynomial in `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`,\\n    where `\\\\check m_{\\\\alpha}(z) \\\\in \\\\mathbb Z[z]` is the primitive associate\\n    of the minimal polynomial `m_{\\\\alpha}(z)` of `\\\\alpha` over\\n    `\\\\mathbb Q`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `\\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][x_0, z]`\\n    ring : PolyRing\\n        `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`\\n\\n    Returns\\n    =======\\n\\n    f_ : PolyElement\\n        polynomial in `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`\\n\\n    '\n    domain = ring.domain\n    f_ = ring.zero\n    if isinstance(f.ring.domain, PolynomialRing):\n        for (monom, coeff) in f.iterterms():\n            for (mon, coef) in coeff.iterterms():\n                m = (monom[0],) + mon\n                c = domain([domain.domain(coef)] + [0] * monom[1])\n                if m not in f_:\n                    f_[m] = c\n                else:\n                    f_[m] += c\n    else:\n        for (monom, coeff) in f.iterterms():\n            m = (monom[0],)\n            c = domain([domain.domain(coeff)] + [0] * monom[1])\n            if m not in f_:\n                f_[m] = c\n            else:\n                f_[m] += c\n    return f_",
            "def _to_ANP_poly(f, ring):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Convert a polynomial\\n    `f \\\\in \\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][z]/(\\\\check m_{\\\\alpha}(z))[x_0]`\\n    to a polynomial in `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`,\\n    where `\\\\check m_{\\\\alpha}(z) \\\\in \\\\mathbb Z[z]` is the primitive associate\\n    of the minimal polynomial `m_{\\\\alpha}(z)` of `\\\\alpha` over\\n    `\\\\mathbb Q`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `\\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][x_0, z]`\\n    ring : PolyRing\\n        `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`\\n\\n    Returns\\n    =======\\n\\n    f_ : PolyElement\\n        polynomial in `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`\\n\\n    '\n    domain = ring.domain\n    f_ = ring.zero\n    if isinstance(f.ring.domain, PolynomialRing):\n        for (monom, coeff) in f.iterterms():\n            for (mon, coef) in coeff.iterterms():\n                m = (monom[0],) + mon\n                c = domain([domain.domain(coef)] + [0] * monom[1])\n                if m not in f_:\n                    f_[m] = c\n                else:\n                    f_[m] += c\n    else:\n        for (monom, coeff) in f.iterterms():\n            m = (monom[0],)\n            c = domain([domain.domain(coeff)] + [0] * monom[1])\n            if m not in f_:\n                f_[m] = c\n            else:\n                f_[m] += c\n    return f_",
            "def _to_ANP_poly(f, ring):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Convert a polynomial\\n    `f \\\\in \\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][z]/(\\\\check m_{\\\\alpha}(z))[x_0]`\\n    to a polynomial in `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`,\\n    where `\\\\check m_{\\\\alpha}(z) \\\\in \\\\mathbb Z[z]` is the primitive associate\\n    of the minimal polynomial `m_{\\\\alpha}(z)` of `\\\\alpha` over\\n    `\\\\mathbb Q`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `\\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][x_0, z]`\\n    ring : PolyRing\\n        `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`\\n\\n    Returns\\n    =======\\n\\n    f_ : PolyElement\\n        polynomial in `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`\\n\\n    '\n    domain = ring.domain\n    f_ = ring.zero\n    if isinstance(f.ring.domain, PolynomialRing):\n        for (monom, coeff) in f.iterterms():\n            for (mon, coef) in coeff.iterterms():\n                m = (monom[0],) + mon\n                c = domain([domain.domain(coef)] + [0] * monom[1])\n                if m not in f_:\n                    f_[m] = c\n                else:\n                    f_[m] += c\n    else:\n        for (monom, coeff) in f.iterterms():\n            m = (monom[0],)\n            c = domain([domain.domain(coeff)] + [0] * monom[1])\n            if m not in f_:\n                f_[m] = c\n            else:\n                f_[m] += c\n    return f_",
            "def _to_ANP_poly(f, ring):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Convert a polynomial\\n    `f \\\\in \\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][z]/(\\\\check m_{\\\\alpha}(z))[x_0]`\\n    to a polynomial in `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`,\\n    where `\\\\check m_{\\\\alpha}(z) \\\\in \\\\mathbb Z[z]` is the primitive associate\\n    of the minimal polynomial `m_{\\\\alpha}(z)` of `\\\\alpha` over\\n    `\\\\mathbb Q`.\\n\\n    Parameters\\n    ==========\\n\\n    f : PolyElement\\n        polynomial in `\\\\mathbb Z[x_1, \\\\ldots, x_{n-1}][x_0, z]`\\n    ring : PolyRing\\n        `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`\\n\\n    Returns\\n    =======\\n\\n    f_ : PolyElement\\n        polynomial in `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`\\n\\n    '\n    domain = ring.domain\n    f_ = ring.zero\n    if isinstance(f.ring.domain, PolynomialRing):\n        for (monom, coeff) in f.iterterms():\n            for (mon, coef) in coeff.iterterms():\n                m = (monom[0],) + mon\n                c = domain([domain.domain(coef)] + [0] * monom[1])\n                if m not in f_:\n                    f_[m] = c\n                else:\n                    f_[m] += c\n    else:\n        for (monom, coeff) in f.iterterms():\n            m = (monom[0],)\n            c = domain([domain.domain(coeff)] + [0] * monom[1])\n            if m not in f_:\n                f_[m] = c\n            else:\n                f_[m] += c\n    return f_"
        ]
    },
    {
        "func_name": "_minpoly_from_dense",
        "original": "def _minpoly_from_dense(minpoly, ring):\n    \"\"\"\n    Change representation of the minimal polynomial from ``DMP`` to\n    ``PolyElement`` for a given ring.\n    \"\"\"\n    minpoly_ = ring.zero\n    for (monom, coeff) in minpoly.terms():\n        minpoly_[monom] = ring.domain(coeff)\n    return minpoly_",
        "mutated": [
            "def _minpoly_from_dense(minpoly, ring):\n    if False:\n        i = 10\n    '\\n    Change representation of the minimal polynomial from ``DMP`` to\\n    ``PolyElement`` for a given ring.\\n    '\n    minpoly_ = ring.zero\n    for (monom, coeff) in minpoly.terms():\n        minpoly_[monom] = ring.domain(coeff)\n    return minpoly_",
            "def _minpoly_from_dense(minpoly, ring):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Change representation of the minimal polynomial from ``DMP`` to\\n    ``PolyElement`` for a given ring.\\n    '\n    minpoly_ = ring.zero\n    for (monom, coeff) in minpoly.terms():\n        minpoly_[monom] = ring.domain(coeff)\n    return minpoly_",
            "def _minpoly_from_dense(minpoly, ring):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Change representation of the minimal polynomial from ``DMP`` to\\n    ``PolyElement`` for a given ring.\\n    '\n    minpoly_ = ring.zero\n    for (monom, coeff) in minpoly.terms():\n        minpoly_[monom] = ring.domain(coeff)\n    return minpoly_",
            "def _minpoly_from_dense(minpoly, ring):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Change representation of the minimal polynomial from ``DMP`` to\\n    ``PolyElement`` for a given ring.\\n    '\n    minpoly_ = ring.zero\n    for (monom, coeff) in minpoly.terms():\n        minpoly_[monom] = ring.domain(coeff)\n    return minpoly_",
            "def _minpoly_from_dense(minpoly, ring):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Change representation of the minimal polynomial from ``DMP`` to\\n    ``PolyElement`` for a given ring.\\n    '\n    minpoly_ = ring.zero\n    for (monom, coeff) in minpoly.terms():\n        minpoly_[monom] = ring.domain(coeff)\n    return minpoly_"
        ]
    },
    {
        "func_name": "_primitive_in_x0",
        "original": "def _primitive_in_x0(f):\n    \"\"\"\n    Compute the content in `x_0` and the primitive part of a polynomial `f`\n    in\n    `\\\\mathbb Q(\\\\alpha)[x_0, x_1, \\\\ldots, x_{n-1}] \\\\cong \\\\mathbb Q(\\\\alpha)[x_1, \\\\ldots, x_{n-1}][x_0]`.\n    \"\"\"\n    fring = f.ring\n    ring = fring.drop_to_ground(*range(1, fring.ngens))\n    dom = ring.domain.ring\n    f_ = ring(f.as_expr())\n    cont = dom.zero\n    for coeff in f_.itercoeffs():\n        cont = func_field_modgcd(cont, coeff)[0]\n        if cont == dom.one:\n            return (cont, f)\n    return (cont, f.quo(cont.set_ring(fring)))",
        "mutated": [
            "def _primitive_in_x0(f):\n    if False:\n        i = 10\n    '\\n    Compute the content in `x_0` and the primitive part of a polynomial `f`\\n    in\\n    `\\\\mathbb Q(\\\\alpha)[x_0, x_1, \\\\ldots, x_{n-1}] \\\\cong \\\\mathbb Q(\\\\alpha)[x_1, \\\\ldots, x_{n-1}][x_0]`.\\n    '\n    fring = f.ring\n    ring = fring.drop_to_ground(*range(1, fring.ngens))\n    dom = ring.domain.ring\n    f_ = ring(f.as_expr())\n    cont = dom.zero\n    for coeff in f_.itercoeffs():\n        cont = func_field_modgcd(cont, coeff)[0]\n        if cont == dom.one:\n            return (cont, f)\n    return (cont, f.quo(cont.set_ring(fring)))",
            "def _primitive_in_x0(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the content in `x_0` and the primitive part of a polynomial `f`\\n    in\\n    `\\\\mathbb Q(\\\\alpha)[x_0, x_1, \\\\ldots, x_{n-1}] \\\\cong \\\\mathbb Q(\\\\alpha)[x_1, \\\\ldots, x_{n-1}][x_0]`.\\n    '\n    fring = f.ring\n    ring = fring.drop_to_ground(*range(1, fring.ngens))\n    dom = ring.domain.ring\n    f_ = ring(f.as_expr())\n    cont = dom.zero\n    for coeff in f_.itercoeffs():\n        cont = func_field_modgcd(cont, coeff)[0]\n        if cont == dom.one:\n            return (cont, f)\n    return (cont, f.quo(cont.set_ring(fring)))",
            "def _primitive_in_x0(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the content in `x_0` and the primitive part of a polynomial `f`\\n    in\\n    `\\\\mathbb Q(\\\\alpha)[x_0, x_1, \\\\ldots, x_{n-1}] \\\\cong \\\\mathbb Q(\\\\alpha)[x_1, \\\\ldots, x_{n-1}][x_0]`.\\n    '\n    fring = f.ring\n    ring = fring.drop_to_ground(*range(1, fring.ngens))\n    dom = ring.domain.ring\n    f_ = ring(f.as_expr())\n    cont = dom.zero\n    for coeff in f_.itercoeffs():\n        cont = func_field_modgcd(cont, coeff)[0]\n        if cont == dom.one:\n            return (cont, f)\n    return (cont, f.quo(cont.set_ring(fring)))",
            "def _primitive_in_x0(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the content in `x_0` and the primitive part of a polynomial `f`\\n    in\\n    `\\\\mathbb Q(\\\\alpha)[x_0, x_1, \\\\ldots, x_{n-1}] \\\\cong \\\\mathbb Q(\\\\alpha)[x_1, \\\\ldots, x_{n-1}][x_0]`.\\n    '\n    fring = f.ring\n    ring = fring.drop_to_ground(*range(1, fring.ngens))\n    dom = ring.domain.ring\n    f_ = ring(f.as_expr())\n    cont = dom.zero\n    for coeff in f_.itercoeffs():\n        cont = func_field_modgcd(cont, coeff)[0]\n        if cont == dom.one:\n            return (cont, f)\n    return (cont, f.quo(cont.set_ring(fring)))",
            "def _primitive_in_x0(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the content in `x_0` and the primitive part of a polynomial `f`\\n    in\\n    `\\\\mathbb Q(\\\\alpha)[x_0, x_1, \\\\ldots, x_{n-1}] \\\\cong \\\\mathbb Q(\\\\alpha)[x_1, \\\\ldots, x_{n-1}][x_0]`.\\n    '\n    fring = f.ring\n    ring = fring.drop_to_ground(*range(1, fring.ngens))\n    dom = ring.domain.ring\n    f_ = ring(f.as_expr())\n    cont = dom.zero\n    for coeff in f_.itercoeffs():\n        cont = func_field_modgcd(cont, coeff)[0]\n        if cont == dom.one:\n            return (cont, f)\n    return (cont, f.quo(cont.set_ring(fring)))"
        ]
    },
    {
        "func_name": "func_field_modgcd",
        "original": "def func_field_modgcd(f, g):\n    \"\"\"\n    Compute the GCD of two polynomials `f` and `g` in\n    `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]` using a modular algorithm.\n\n    The algorithm first computes the primitive associate\n    `\\\\check m_{\\\\alpha}(z)` of the minimal polynomial `m_{\\\\alpha}` in\n    `\\\\mathbb{Z}[z]` and the primitive associates of `f` and `g` in\n    `\\\\mathbb{Z}[x_1, \\\\ldots, x_{n-1}][z]/(\\\\check m_{\\\\alpha})[x_0]`. Then it\n    computes the GCD in\n    `\\\\mathbb Q(x_1, \\\\ldots, x_{n-1})[z]/(m_{\\\\alpha}(z))[x_0]`.\n    This is done by calculating the GCD in\n    `\\\\mathbb{Z}_p(x_1, \\\\ldots, x_{n-1})[z]/(\\\\check m_{\\\\alpha}(z))[x_0]` for\n    suitable primes `p` and then reconstructing the coefficients with the\n    Chinese Remainder Theorem and Rational Reconstuction. The GCD over\n    `\\\\mathbb{Z}_p(x_1, \\\\ldots, x_{n-1})[z]/(\\\\check m_{\\\\alpha}(z))[x_0]` is\n    computed with a recursive subroutine, which evaluates the polynomials at\n    `x_{n-1} = a` for suitable evaluation points `a \\\\in \\\\mathbb Z_p` and\n    then calls itself recursively until the ground domain does no longer\n    contain any parameters. For\n    `\\\\mathbb{Z}_p[z]/(\\\\check m_{\\\\alpha}(z))[x_0]` the Euclidean Algorithm is\n    used. The results of those recursive calls are then interpolated and\n    Rational Function Reconstruction is used to obtain the correct\n    coefficients. The results, both in\n    `\\\\mathbb Q(x_1, \\\\ldots, x_{n-1})[z]/(m_{\\\\alpha}(z))[x_0]` and\n    `\\\\mathbb{Z}_p(x_1, \\\\ldots, x_{n-1})[z]/(\\\\check m_{\\\\alpha}(z))[x_0]`, are\n    verified by a fraction free trial division.\n\n    Apart from the above GCD computation some GCDs in\n    `\\\\mathbb Q(\\\\alpha)[x_1, \\\\ldots, x_{n-1}]` have to be calculated,\n    because treating the polynomials as univariate ones can result in\n    a spurious content of the GCD. For this ``func_field_modgcd`` is\n    called recursively.\n\n    Parameters\n    ==========\n\n    f, g : PolyElement\n        polynomials in `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`\n\n    Returns\n    =======\n\n    h : PolyElement\n        monic GCD of the polynomials `f` and `g`\n    cff : PolyElement\n        cofactor of `f`, i.e. `\\\\frac f h`\n    cfg : PolyElement\n        cofactor of `g`, i.e. `\\\\frac g h`\n\n    Examples\n    ========\n\n    >>> from sympy.polys.modulargcd import func_field_modgcd\n    >>> from sympy.polys import AlgebraicField, QQ, ring\n    >>> from sympy import sqrt\n\n    >>> A = AlgebraicField(QQ, sqrt(2))\n    >>> R, x = ring('x', A)\n\n    >>> f = x**2 - 2\n    >>> g = x + sqrt(2)\n\n    >>> h, cff, cfg = func_field_modgcd(f, g)\n\n    >>> h == x + sqrt(2)\n    True\n    >>> cff * h == f\n    True\n    >>> cfg * h == g\n    True\n\n    >>> R, x, y = ring('x, y', A)\n\n    >>> f = x**2 + 2*sqrt(2)*x*y + 2*y**2\n    >>> g = x + sqrt(2)*y\n\n    >>> h, cff, cfg = func_field_modgcd(f, g)\n\n    >>> h == x + sqrt(2)*y\n    True\n    >>> cff * h == f\n    True\n    >>> cfg * h == g\n    True\n\n    >>> f = x + sqrt(2)*y\n    >>> g = x + y\n\n    >>> h, cff, cfg = func_field_modgcd(f, g)\n\n    >>> h == R.one\n    True\n    >>> cff * h == f\n    True\n    >>> cfg * h == g\n    True\n\n    References\n    ==========\n\n    1. [Hoeij04]_\n\n    \"\"\"\n    ring = f.ring\n    domain = ring.domain\n    n = ring.ngens\n    assert ring == g.ring and domain.is_Algebraic\n    result = _trivial_gcd(f, g)\n    if result is not None:\n        return result\n    z = Dummy('z')\n    ZZring = ring.clone(symbols=ring.symbols + (z,), domain=domain.domain.get_ring())\n    if n == 1:\n        f_ = _to_ZZ_poly(f, ZZring)\n        g_ = _to_ZZ_poly(g, ZZring)\n        minpoly = ZZring.drop(0).from_dense(domain.mod.to_list())\n        h = _func_field_modgcd_m(f_, g_, minpoly)\n        h = _to_ANP_poly(h, ring)\n    else:\n        (contx0f, f) = _primitive_in_x0(f)\n        (contx0g, g) = _primitive_in_x0(g)\n        contx0h = func_field_modgcd(contx0f, contx0g)[0]\n        ZZring_ = ZZring.drop_to_ground(*range(1, n))\n        f_ = _to_ZZ_poly(f, ZZring_)\n        g_ = _to_ZZ_poly(g, ZZring_)\n        minpoly = _minpoly_from_dense(domain.mod, ZZring_.drop(0))\n        h = _func_field_modgcd_m(f_, g_, minpoly)\n        h = _to_ANP_poly(h, ring)\n        (contx0h_, h) = _primitive_in_x0(h)\n        h *= contx0h.set_ring(ring)\n        f *= contx0f.set_ring(ring)\n        g *= contx0g.set_ring(ring)\n    h = h.quo_ground(h.LC)\n    return (h, f.quo(h), g.quo(h))",
        "mutated": [
            "def func_field_modgcd(f, g):\n    if False:\n        i = 10\n    \"\\n    Compute the GCD of two polynomials `f` and `g` in\\n    `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]` using a modular algorithm.\\n\\n    The algorithm first computes the primitive associate\\n    `\\\\check m_{\\\\alpha}(z)` of the minimal polynomial `m_{\\\\alpha}` in\\n    `\\\\mathbb{Z}[z]` and the primitive associates of `f` and `g` in\\n    `\\\\mathbb{Z}[x_1, \\\\ldots, x_{n-1}][z]/(\\\\check m_{\\\\alpha})[x_0]`. Then it\\n    computes the GCD in\\n    `\\\\mathbb Q(x_1, \\\\ldots, x_{n-1})[z]/(m_{\\\\alpha}(z))[x_0]`.\\n    This is done by calculating the GCD in\\n    `\\\\mathbb{Z}_p(x_1, \\\\ldots, x_{n-1})[z]/(\\\\check m_{\\\\alpha}(z))[x_0]` for\\n    suitable primes `p` and then reconstructing the coefficients with the\\n    Chinese Remainder Theorem and Rational Reconstuction. The GCD over\\n    `\\\\mathbb{Z}_p(x_1, \\\\ldots, x_{n-1})[z]/(\\\\check m_{\\\\alpha}(z))[x_0]` is\\n    computed with a recursive subroutine, which evaluates the polynomials at\\n    `x_{n-1} = a` for suitable evaluation points `a \\\\in \\\\mathbb Z_p` and\\n    then calls itself recursively until the ground domain does no longer\\n    contain any parameters. For\\n    `\\\\mathbb{Z}_p[z]/(\\\\check m_{\\\\alpha}(z))[x_0]` the Euclidean Algorithm is\\n    used. The results of those recursive calls are then interpolated and\\n    Rational Function Reconstruction is used to obtain the correct\\n    coefficients. The results, both in\\n    `\\\\mathbb Q(x_1, \\\\ldots, x_{n-1})[z]/(m_{\\\\alpha}(z))[x_0]` and\\n    `\\\\mathbb{Z}_p(x_1, \\\\ldots, x_{n-1})[z]/(\\\\check m_{\\\\alpha}(z))[x_0]`, are\\n    verified by a fraction free trial division.\\n\\n    Apart from the above GCD computation some GCDs in\\n    `\\\\mathbb Q(\\\\alpha)[x_1, \\\\ldots, x_{n-1}]` have to be calculated,\\n    because treating the polynomials as univariate ones can result in\\n    a spurious content of the GCD. For this ``func_field_modgcd`` is\\n    called recursively.\\n\\n    Parameters\\n    ==========\\n\\n    f, g : PolyElement\\n        polynomials in `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        monic GCD of the polynomials `f` and `g`\\n    cff : PolyElement\\n        cofactor of `f`, i.e. `\\\\frac f h`\\n    cfg : PolyElement\\n        cofactor of `g`, i.e. `\\\\frac g h`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import func_field_modgcd\\n    >>> from sympy.polys import AlgebraicField, QQ, ring\\n    >>> from sympy import sqrt\\n\\n    >>> A = AlgebraicField(QQ, sqrt(2))\\n    >>> R, x = ring('x', A)\\n\\n    >>> f = x**2 - 2\\n    >>> g = x + sqrt(2)\\n\\n    >>> h, cff, cfg = func_field_modgcd(f, g)\\n\\n    >>> h == x + sqrt(2)\\n    True\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> R, x, y = ring('x, y', A)\\n\\n    >>> f = x**2 + 2*sqrt(2)*x*y + 2*y**2\\n    >>> g = x + sqrt(2)*y\\n\\n    >>> h, cff, cfg = func_field_modgcd(f, g)\\n\\n    >>> h == x + sqrt(2)*y\\n    True\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> f = x + sqrt(2)*y\\n    >>> g = x + y\\n\\n    >>> h, cff, cfg = func_field_modgcd(f, g)\\n\\n    >>> h == R.one\\n    True\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    References\\n    ==========\\n\\n    1. [Hoeij04]_\\n\\n    \"\n    ring = f.ring\n    domain = ring.domain\n    n = ring.ngens\n    assert ring == g.ring and domain.is_Algebraic\n    result = _trivial_gcd(f, g)\n    if result is not None:\n        return result\n    z = Dummy('z')\n    ZZring = ring.clone(symbols=ring.symbols + (z,), domain=domain.domain.get_ring())\n    if n == 1:\n        f_ = _to_ZZ_poly(f, ZZring)\n        g_ = _to_ZZ_poly(g, ZZring)\n        minpoly = ZZring.drop(0).from_dense(domain.mod.to_list())\n        h = _func_field_modgcd_m(f_, g_, minpoly)\n        h = _to_ANP_poly(h, ring)\n    else:\n        (contx0f, f) = _primitive_in_x0(f)\n        (contx0g, g) = _primitive_in_x0(g)\n        contx0h = func_field_modgcd(contx0f, contx0g)[0]\n        ZZring_ = ZZring.drop_to_ground(*range(1, n))\n        f_ = _to_ZZ_poly(f, ZZring_)\n        g_ = _to_ZZ_poly(g, ZZring_)\n        minpoly = _minpoly_from_dense(domain.mod, ZZring_.drop(0))\n        h = _func_field_modgcd_m(f_, g_, minpoly)\n        h = _to_ANP_poly(h, ring)\n        (contx0h_, h) = _primitive_in_x0(h)\n        h *= contx0h.set_ring(ring)\n        f *= contx0f.set_ring(ring)\n        g *= contx0g.set_ring(ring)\n    h = h.quo_ground(h.LC)\n    return (h, f.quo(h), g.quo(h))",
            "def func_field_modgcd(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Compute the GCD of two polynomials `f` and `g` in\\n    `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]` using a modular algorithm.\\n\\n    The algorithm first computes the primitive associate\\n    `\\\\check m_{\\\\alpha}(z)` of the minimal polynomial `m_{\\\\alpha}` in\\n    `\\\\mathbb{Z}[z]` and the primitive associates of `f` and `g` in\\n    `\\\\mathbb{Z}[x_1, \\\\ldots, x_{n-1}][z]/(\\\\check m_{\\\\alpha})[x_0]`. Then it\\n    computes the GCD in\\n    `\\\\mathbb Q(x_1, \\\\ldots, x_{n-1})[z]/(m_{\\\\alpha}(z))[x_0]`.\\n    This is done by calculating the GCD in\\n    `\\\\mathbb{Z}_p(x_1, \\\\ldots, x_{n-1})[z]/(\\\\check m_{\\\\alpha}(z))[x_0]` for\\n    suitable primes `p` and then reconstructing the coefficients with the\\n    Chinese Remainder Theorem and Rational Reconstuction. The GCD over\\n    `\\\\mathbb{Z}_p(x_1, \\\\ldots, x_{n-1})[z]/(\\\\check m_{\\\\alpha}(z))[x_0]` is\\n    computed with a recursive subroutine, which evaluates the polynomials at\\n    `x_{n-1} = a` for suitable evaluation points `a \\\\in \\\\mathbb Z_p` and\\n    then calls itself recursively until the ground domain does no longer\\n    contain any parameters. For\\n    `\\\\mathbb{Z}_p[z]/(\\\\check m_{\\\\alpha}(z))[x_0]` the Euclidean Algorithm is\\n    used. The results of those recursive calls are then interpolated and\\n    Rational Function Reconstruction is used to obtain the correct\\n    coefficients. The results, both in\\n    `\\\\mathbb Q(x_1, \\\\ldots, x_{n-1})[z]/(m_{\\\\alpha}(z))[x_0]` and\\n    `\\\\mathbb{Z}_p(x_1, \\\\ldots, x_{n-1})[z]/(\\\\check m_{\\\\alpha}(z))[x_0]`, are\\n    verified by a fraction free trial division.\\n\\n    Apart from the above GCD computation some GCDs in\\n    `\\\\mathbb Q(\\\\alpha)[x_1, \\\\ldots, x_{n-1}]` have to be calculated,\\n    because treating the polynomials as univariate ones can result in\\n    a spurious content of the GCD. For this ``func_field_modgcd`` is\\n    called recursively.\\n\\n    Parameters\\n    ==========\\n\\n    f, g : PolyElement\\n        polynomials in `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        monic GCD of the polynomials `f` and `g`\\n    cff : PolyElement\\n        cofactor of `f`, i.e. `\\\\frac f h`\\n    cfg : PolyElement\\n        cofactor of `g`, i.e. `\\\\frac g h`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import func_field_modgcd\\n    >>> from sympy.polys import AlgebraicField, QQ, ring\\n    >>> from sympy import sqrt\\n\\n    >>> A = AlgebraicField(QQ, sqrt(2))\\n    >>> R, x = ring('x', A)\\n\\n    >>> f = x**2 - 2\\n    >>> g = x + sqrt(2)\\n\\n    >>> h, cff, cfg = func_field_modgcd(f, g)\\n\\n    >>> h == x + sqrt(2)\\n    True\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> R, x, y = ring('x, y', A)\\n\\n    >>> f = x**2 + 2*sqrt(2)*x*y + 2*y**2\\n    >>> g = x + sqrt(2)*y\\n\\n    >>> h, cff, cfg = func_field_modgcd(f, g)\\n\\n    >>> h == x + sqrt(2)*y\\n    True\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> f = x + sqrt(2)*y\\n    >>> g = x + y\\n\\n    >>> h, cff, cfg = func_field_modgcd(f, g)\\n\\n    >>> h == R.one\\n    True\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    References\\n    ==========\\n\\n    1. [Hoeij04]_\\n\\n    \"\n    ring = f.ring\n    domain = ring.domain\n    n = ring.ngens\n    assert ring == g.ring and domain.is_Algebraic\n    result = _trivial_gcd(f, g)\n    if result is not None:\n        return result\n    z = Dummy('z')\n    ZZring = ring.clone(symbols=ring.symbols + (z,), domain=domain.domain.get_ring())\n    if n == 1:\n        f_ = _to_ZZ_poly(f, ZZring)\n        g_ = _to_ZZ_poly(g, ZZring)\n        minpoly = ZZring.drop(0).from_dense(domain.mod.to_list())\n        h = _func_field_modgcd_m(f_, g_, minpoly)\n        h = _to_ANP_poly(h, ring)\n    else:\n        (contx0f, f) = _primitive_in_x0(f)\n        (contx0g, g) = _primitive_in_x0(g)\n        contx0h = func_field_modgcd(contx0f, contx0g)[0]\n        ZZring_ = ZZring.drop_to_ground(*range(1, n))\n        f_ = _to_ZZ_poly(f, ZZring_)\n        g_ = _to_ZZ_poly(g, ZZring_)\n        minpoly = _minpoly_from_dense(domain.mod, ZZring_.drop(0))\n        h = _func_field_modgcd_m(f_, g_, minpoly)\n        h = _to_ANP_poly(h, ring)\n        (contx0h_, h) = _primitive_in_x0(h)\n        h *= contx0h.set_ring(ring)\n        f *= contx0f.set_ring(ring)\n        g *= contx0g.set_ring(ring)\n    h = h.quo_ground(h.LC)\n    return (h, f.quo(h), g.quo(h))",
            "def func_field_modgcd(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Compute the GCD of two polynomials `f` and `g` in\\n    `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]` using a modular algorithm.\\n\\n    The algorithm first computes the primitive associate\\n    `\\\\check m_{\\\\alpha}(z)` of the minimal polynomial `m_{\\\\alpha}` in\\n    `\\\\mathbb{Z}[z]` and the primitive associates of `f` and `g` in\\n    `\\\\mathbb{Z}[x_1, \\\\ldots, x_{n-1}][z]/(\\\\check m_{\\\\alpha})[x_0]`. Then it\\n    computes the GCD in\\n    `\\\\mathbb Q(x_1, \\\\ldots, x_{n-1})[z]/(m_{\\\\alpha}(z))[x_0]`.\\n    This is done by calculating the GCD in\\n    `\\\\mathbb{Z}_p(x_1, \\\\ldots, x_{n-1})[z]/(\\\\check m_{\\\\alpha}(z))[x_0]` for\\n    suitable primes `p` and then reconstructing the coefficients with the\\n    Chinese Remainder Theorem and Rational Reconstuction. The GCD over\\n    `\\\\mathbb{Z}_p(x_1, \\\\ldots, x_{n-1})[z]/(\\\\check m_{\\\\alpha}(z))[x_0]` is\\n    computed with a recursive subroutine, which evaluates the polynomials at\\n    `x_{n-1} = a` for suitable evaluation points `a \\\\in \\\\mathbb Z_p` and\\n    then calls itself recursively until the ground domain does no longer\\n    contain any parameters. For\\n    `\\\\mathbb{Z}_p[z]/(\\\\check m_{\\\\alpha}(z))[x_0]` the Euclidean Algorithm is\\n    used. The results of those recursive calls are then interpolated and\\n    Rational Function Reconstruction is used to obtain the correct\\n    coefficients. The results, both in\\n    `\\\\mathbb Q(x_1, \\\\ldots, x_{n-1})[z]/(m_{\\\\alpha}(z))[x_0]` and\\n    `\\\\mathbb{Z}_p(x_1, \\\\ldots, x_{n-1})[z]/(\\\\check m_{\\\\alpha}(z))[x_0]`, are\\n    verified by a fraction free trial division.\\n\\n    Apart from the above GCD computation some GCDs in\\n    `\\\\mathbb Q(\\\\alpha)[x_1, \\\\ldots, x_{n-1}]` have to be calculated,\\n    because treating the polynomials as univariate ones can result in\\n    a spurious content of the GCD. For this ``func_field_modgcd`` is\\n    called recursively.\\n\\n    Parameters\\n    ==========\\n\\n    f, g : PolyElement\\n        polynomials in `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        monic GCD of the polynomials `f` and `g`\\n    cff : PolyElement\\n        cofactor of `f`, i.e. `\\\\frac f h`\\n    cfg : PolyElement\\n        cofactor of `g`, i.e. `\\\\frac g h`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import func_field_modgcd\\n    >>> from sympy.polys import AlgebraicField, QQ, ring\\n    >>> from sympy import sqrt\\n\\n    >>> A = AlgebraicField(QQ, sqrt(2))\\n    >>> R, x = ring('x', A)\\n\\n    >>> f = x**2 - 2\\n    >>> g = x + sqrt(2)\\n\\n    >>> h, cff, cfg = func_field_modgcd(f, g)\\n\\n    >>> h == x + sqrt(2)\\n    True\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> R, x, y = ring('x, y', A)\\n\\n    >>> f = x**2 + 2*sqrt(2)*x*y + 2*y**2\\n    >>> g = x + sqrt(2)*y\\n\\n    >>> h, cff, cfg = func_field_modgcd(f, g)\\n\\n    >>> h == x + sqrt(2)*y\\n    True\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> f = x + sqrt(2)*y\\n    >>> g = x + y\\n\\n    >>> h, cff, cfg = func_field_modgcd(f, g)\\n\\n    >>> h == R.one\\n    True\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    References\\n    ==========\\n\\n    1. [Hoeij04]_\\n\\n    \"\n    ring = f.ring\n    domain = ring.domain\n    n = ring.ngens\n    assert ring == g.ring and domain.is_Algebraic\n    result = _trivial_gcd(f, g)\n    if result is not None:\n        return result\n    z = Dummy('z')\n    ZZring = ring.clone(symbols=ring.symbols + (z,), domain=domain.domain.get_ring())\n    if n == 1:\n        f_ = _to_ZZ_poly(f, ZZring)\n        g_ = _to_ZZ_poly(g, ZZring)\n        minpoly = ZZring.drop(0).from_dense(domain.mod.to_list())\n        h = _func_field_modgcd_m(f_, g_, minpoly)\n        h = _to_ANP_poly(h, ring)\n    else:\n        (contx0f, f) = _primitive_in_x0(f)\n        (contx0g, g) = _primitive_in_x0(g)\n        contx0h = func_field_modgcd(contx0f, contx0g)[0]\n        ZZring_ = ZZring.drop_to_ground(*range(1, n))\n        f_ = _to_ZZ_poly(f, ZZring_)\n        g_ = _to_ZZ_poly(g, ZZring_)\n        minpoly = _minpoly_from_dense(domain.mod, ZZring_.drop(0))\n        h = _func_field_modgcd_m(f_, g_, minpoly)\n        h = _to_ANP_poly(h, ring)\n        (contx0h_, h) = _primitive_in_x0(h)\n        h *= contx0h.set_ring(ring)\n        f *= contx0f.set_ring(ring)\n        g *= contx0g.set_ring(ring)\n    h = h.quo_ground(h.LC)\n    return (h, f.quo(h), g.quo(h))",
            "def func_field_modgcd(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Compute the GCD of two polynomials `f` and `g` in\\n    `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]` using a modular algorithm.\\n\\n    The algorithm first computes the primitive associate\\n    `\\\\check m_{\\\\alpha}(z)` of the minimal polynomial `m_{\\\\alpha}` in\\n    `\\\\mathbb{Z}[z]` and the primitive associates of `f` and `g` in\\n    `\\\\mathbb{Z}[x_1, \\\\ldots, x_{n-1}][z]/(\\\\check m_{\\\\alpha})[x_0]`. Then it\\n    computes the GCD in\\n    `\\\\mathbb Q(x_1, \\\\ldots, x_{n-1})[z]/(m_{\\\\alpha}(z))[x_0]`.\\n    This is done by calculating the GCD in\\n    `\\\\mathbb{Z}_p(x_1, \\\\ldots, x_{n-1})[z]/(\\\\check m_{\\\\alpha}(z))[x_0]` for\\n    suitable primes `p` and then reconstructing the coefficients with the\\n    Chinese Remainder Theorem and Rational Reconstuction. The GCD over\\n    `\\\\mathbb{Z}_p(x_1, \\\\ldots, x_{n-1})[z]/(\\\\check m_{\\\\alpha}(z))[x_0]` is\\n    computed with a recursive subroutine, which evaluates the polynomials at\\n    `x_{n-1} = a` for suitable evaluation points `a \\\\in \\\\mathbb Z_p` and\\n    then calls itself recursively until the ground domain does no longer\\n    contain any parameters. For\\n    `\\\\mathbb{Z}_p[z]/(\\\\check m_{\\\\alpha}(z))[x_0]` the Euclidean Algorithm is\\n    used. The results of those recursive calls are then interpolated and\\n    Rational Function Reconstruction is used to obtain the correct\\n    coefficients. The results, both in\\n    `\\\\mathbb Q(x_1, \\\\ldots, x_{n-1})[z]/(m_{\\\\alpha}(z))[x_0]` and\\n    `\\\\mathbb{Z}_p(x_1, \\\\ldots, x_{n-1})[z]/(\\\\check m_{\\\\alpha}(z))[x_0]`, are\\n    verified by a fraction free trial division.\\n\\n    Apart from the above GCD computation some GCDs in\\n    `\\\\mathbb Q(\\\\alpha)[x_1, \\\\ldots, x_{n-1}]` have to be calculated,\\n    because treating the polynomials as univariate ones can result in\\n    a spurious content of the GCD. For this ``func_field_modgcd`` is\\n    called recursively.\\n\\n    Parameters\\n    ==========\\n\\n    f, g : PolyElement\\n        polynomials in `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        monic GCD of the polynomials `f` and `g`\\n    cff : PolyElement\\n        cofactor of `f`, i.e. `\\\\frac f h`\\n    cfg : PolyElement\\n        cofactor of `g`, i.e. `\\\\frac g h`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import func_field_modgcd\\n    >>> from sympy.polys import AlgebraicField, QQ, ring\\n    >>> from sympy import sqrt\\n\\n    >>> A = AlgebraicField(QQ, sqrt(2))\\n    >>> R, x = ring('x', A)\\n\\n    >>> f = x**2 - 2\\n    >>> g = x + sqrt(2)\\n\\n    >>> h, cff, cfg = func_field_modgcd(f, g)\\n\\n    >>> h == x + sqrt(2)\\n    True\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> R, x, y = ring('x, y', A)\\n\\n    >>> f = x**2 + 2*sqrt(2)*x*y + 2*y**2\\n    >>> g = x + sqrt(2)*y\\n\\n    >>> h, cff, cfg = func_field_modgcd(f, g)\\n\\n    >>> h == x + sqrt(2)*y\\n    True\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> f = x + sqrt(2)*y\\n    >>> g = x + y\\n\\n    >>> h, cff, cfg = func_field_modgcd(f, g)\\n\\n    >>> h == R.one\\n    True\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    References\\n    ==========\\n\\n    1. [Hoeij04]_\\n\\n    \"\n    ring = f.ring\n    domain = ring.domain\n    n = ring.ngens\n    assert ring == g.ring and domain.is_Algebraic\n    result = _trivial_gcd(f, g)\n    if result is not None:\n        return result\n    z = Dummy('z')\n    ZZring = ring.clone(symbols=ring.symbols + (z,), domain=domain.domain.get_ring())\n    if n == 1:\n        f_ = _to_ZZ_poly(f, ZZring)\n        g_ = _to_ZZ_poly(g, ZZring)\n        minpoly = ZZring.drop(0).from_dense(domain.mod.to_list())\n        h = _func_field_modgcd_m(f_, g_, minpoly)\n        h = _to_ANP_poly(h, ring)\n    else:\n        (contx0f, f) = _primitive_in_x0(f)\n        (contx0g, g) = _primitive_in_x0(g)\n        contx0h = func_field_modgcd(contx0f, contx0g)[0]\n        ZZring_ = ZZring.drop_to_ground(*range(1, n))\n        f_ = _to_ZZ_poly(f, ZZring_)\n        g_ = _to_ZZ_poly(g, ZZring_)\n        minpoly = _minpoly_from_dense(domain.mod, ZZring_.drop(0))\n        h = _func_field_modgcd_m(f_, g_, minpoly)\n        h = _to_ANP_poly(h, ring)\n        (contx0h_, h) = _primitive_in_x0(h)\n        h *= contx0h.set_ring(ring)\n        f *= contx0f.set_ring(ring)\n        g *= contx0g.set_ring(ring)\n    h = h.quo_ground(h.LC)\n    return (h, f.quo(h), g.quo(h))",
            "def func_field_modgcd(f, g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Compute the GCD of two polynomials `f` and `g` in\\n    `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]` using a modular algorithm.\\n\\n    The algorithm first computes the primitive associate\\n    `\\\\check m_{\\\\alpha}(z)` of the minimal polynomial `m_{\\\\alpha}` in\\n    `\\\\mathbb{Z}[z]` and the primitive associates of `f` and `g` in\\n    `\\\\mathbb{Z}[x_1, \\\\ldots, x_{n-1}][z]/(\\\\check m_{\\\\alpha})[x_0]`. Then it\\n    computes the GCD in\\n    `\\\\mathbb Q(x_1, \\\\ldots, x_{n-1})[z]/(m_{\\\\alpha}(z))[x_0]`.\\n    This is done by calculating the GCD in\\n    `\\\\mathbb{Z}_p(x_1, \\\\ldots, x_{n-1})[z]/(\\\\check m_{\\\\alpha}(z))[x_0]` for\\n    suitable primes `p` and then reconstructing the coefficients with the\\n    Chinese Remainder Theorem and Rational Reconstuction. The GCD over\\n    `\\\\mathbb{Z}_p(x_1, \\\\ldots, x_{n-1})[z]/(\\\\check m_{\\\\alpha}(z))[x_0]` is\\n    computed with a recursive subroutine, which evaluates the polynomials at\\n    `x_{n-1} = a` for suitable evaluation points `a \\\\in \\\\mathbb Z_p` and\\n    then calls itself recursively until the ground domain does no longer\\n    contain any parameters. For\\n    `\\\\mathbb{Z}_p[z]/(\\\\check m_{\\\\alpha}(z))[x_0]` the Euclidean Algorithm is\\n    used. The results of those recursive calls are then interpolated and\\n    Rational Function Reconstruction is used to obtain the correct\\n    coefficients. The results, both in\\n    `\\\\mathbb Q(x_1, \\\\ldots, x_{n-1})[z]/(m_{\\\\alpha}(z))[x_0]` and\\n    `\\\\mathbb{Z}_p(x_1, \\\\ldots, x_{n-1})[z]/(\\\\check m_{\\\\alpha}(z))[x_0]`, are\\n    verified by a fraction free trial division.\\n\\n    Apart from the above GCD computation some GCDs in\\n    `\\\\mathbb Q(\\\\alpha)[x_1, \\\\ldots, x_{n-1}]` have to be calculated,\\n    because treating the polynomials as univariate ones can result in\\n    a spurious content of the GCD. For this ``func_field_modgcd`` is\\n    called recursively.\\n\\n    Parameters\\n    ==========\\n\\n    f, g : PolyElement\\n        polynomials in `\\\\mathbb Q(\\\\alpha)[x_0, \\\\ldots, x_{n-1}]`\\n\\n    Returns\\n    =======\\n\\n    h : PolyElement\\n        monic GCD of the polynomials `f` and `g`\\n    cff : PolyElement\\n        cofactor of `f`, i.e. `\\\\frac f h`\\n    cfg : PolyElement\\n        cofactor of `g`, i.e. `\\\\frac g h`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.modulargcd import func_field_modgcd\\n    >>> from sympy.polys import AlgebraicField, QQ, ring\\n    >>> from sympy import sqrt\\n\\n    >>> A = AlgebraicField(QQ, sqrt(2))\\n    >>> R, x = ring('x', A)\\n\\n    >>> f = x**2 - 2\\n    >>> g = x + sqrt(2)\\n\\n    >>> h, cff, cfg = func_field_modgcd(f, g)\\n\\n    >>> h == x + sqrt(2)\\n    True\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> R, x, y = ring('x, y', A)\\n\\n    >>> f = x**2 + 2*sqrt(2)*x*y + 2*y**2\\n    >>> g = x + sqrt(2)*y\\n\\n    >>> h, cff, cfg = func_field_modgcd(f, g)\\n\\n    >>> h == x + sqrt(2)*y\\n    True\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    >>> f = x + sqrt(2)*y\\n    >>> g = x + y\\n\\n    >>> h, cff, cfg = func_field_modgcd(f, g)\\n\\n    >>> h == R.one\\n    True\\n    >>> cff * h == f\\n    True\\n    >>> cfg * h == g\\n    True\\n\\n    References\\n    ==========\\n\\n    1. [Hoeij04]_\\n\\n    \"\n    ring = f.ring\n    domain = ring.domain\n    n = ring.ngens\n    assert ring == g.ring and domain.is_Algebraic\n    result = _trivial_gcd(f, g)\n    if result is not None:\n        return result\n    z = Dummy('z')\n    ZZring = ring.clone(symbols=ring.symbols + (z,), domain=domain.domain.get_ring())\n    if n == 1:\n        f_ = _to_ZZ_poly(f, ZZring)\n        g_ = _to_ZZ_poly(g, ZZring)\n        minpoly = ZZring.drop(0).from_dense(domain.mod.to_list())\n        h = _func_field_modgcd_m(f_, g_, minpoly)\n        h = _to_ANP_poly(h, ring)\n    else:\n        (contx0f, f) = _primitive_in_x0(f)\n        (contx0g, g) = _primitive_in_x0(g)\n        contx0h = func_field_modgcd(contx0f, contx0g)[0]\n        ZZring_ = ZZring.drop_to_ground(*range(1, n))\n        f_ = _to_ZZ_poly(f, ZZring_)\n        g_ = _to_ZZ_poly(g, ZZring_)\n        minpoly = _minpoly_from_dense(domain.mod, ZZring_.drop(0))\n        h = _func_field_modgcd_m(f_, g_, minpoly)\n        h = _to_ANP_poly(h, ring)\n        (contx0h_, h) = _primitive_in_x0(h)\n        h *= contx0h.set_ring(ring)\n        f *= contx0f.set_ring(ring)\n        g *= contx0g.set_ring(ring)\n    h = h.quo_ground(h.LC)\n    return (h, f.quo(h), g.quo(h))"
        ]
    }
]