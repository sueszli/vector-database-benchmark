[
    {
        "func_name": "series_small_a",
        "original": "def series_small_a():\n    \"\"\"Tylor series expansion of Phi(a, b, x) in a=0 up to order 5.\n    \"\"\"\n    order = 5\n    (a, b, x, k) = symbols('a b x k')\n    A = []\n    X = []\n    B = []\n    expression = Sum(x ** k / factorial(k) / gamma(a * k + b), (k, 0, S.Infinity))\n    expression = gamma(b) / sympy.exp(x) * expression\n    for n in range(0, order + 1):\n        term = expression.diff(a, n).subs(a, 0).simplify().doit()\n        x_part = term.subs(polygamma(0, b), 1).replace(polygamma, lambda *args: 0)\n        x_part *= (-1) ** n\n        A.append(a ** n / factorial(n))\n        X.append(horner(x_part))\n        B.append(horner((term / x_part).simplify()))\n    s = 'Tylor series expansion of Phi(a, b, x) in a=0 up to order 5.\\n'\n    s += 'Phi(a, b, x) = exp(x)/gamma(b) * sum(A[i] * X[i] * B[i], i=0..5)\\n'\n    for (name, c) in zip(['A', 'X', 'B'], [A, X, B]):\n        for i in range(len(c)):\n            s += f'\\n{name}[{i}] = ' + str(c[i])\n    return s",
        "mutated": [
            "def series_small_a():\n    if False:\n        i = 10\n    'Tylor series expansion of Phi(a, b, x) in a=0 up to order 5.\\n    '\n    order = 5\n    (a, b, x, k) = symbols('a b x k')\n    A = []\n    X = []\n    B = []\n    expression = Sum(x ** k / factorial(k) / gamma(a * k + b), (k, 0, S.Infinity))\n    expression = gamma(b) / sympy.exp(x) * expression\n    for n in range(0, order + 1):\n        term = expression.diff(a, n).subs(a, 0).simplify().doit()\n        x_part = term.subs(polygamma(0, b), 1).replace(polygamma, lambda *args: 0)\n        x_part *= (-1) ** n\n        A.append(a ** n / factorial(n))\n        X.append(horner(x_part))\n        B.append(horner((term / x_part).simplify()))\n    s = 'Tylor series expansion of Phi(a, b, x) in a=0 up to order 5.\\n'\n    s += 'Phi(a, b, x) = exp(x)/gamma(b) * sum(A[i] * X[i] * B[i], i=0..5)\\n'\n    for (name, c) in zip(['A', 'X', 'B'], [A, X, B]):\n        for i in range(len(c)):\n            s += f'\\n{name}[{i}] = ' + str(c[i])\n    return s",
            "def series_small_a():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tylor series expansion of Phi(a, b, x) in a=0 up to order 5.\\n    '\n    order = 5\n    (a, b, x, k) = symbols('a b x k')\n    A = []\n    X = []\n    B = []\n    expression = Sum(x ** k / factorial(k) / gamma(a * k + b), (k, 0, S.Infinity))\n    expression = gamma(b) / sympy.exp(x) * expression\n    for n in range(0, order + 1):\n        term = expression.diff(a, n).subs(a, 0).simplify().doit()\n        x_part = term.subs(polygamma(0, b), 1).replace(polygamma, lambda *args: 0)\n        x_part *= (-1) ** n\n        A.append(a ** n / factorial(n))\n        X.append(horner(x_part))\n        B.append(horner((term / x_part).simplify()))\n    s = 'Tylor series expansion of Phi(a, b, x) in a=0 up to order 5.\\n'\n    s += 'Phi(a, b, x) = exp(x)/gamma(b) * sum(A[i] * X[i] * B[i], i=0..5)\\n'\n    for (name, c) in zip(['A', 'X', 'B'], [A, X, B]):\n        for i in range(len(c)):\n            s += f'\\n{name}[{i}] = ' + str(c[i])\n    return s",
            "def series_small_a():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tylor series expansion of Phi(a, b, x) in a=0 up to order 5.\\n    '\n    order = 5\n    (a, b, x, k) = symbols('a b x k')\n    A = []\n    X = []\n    B = []\n    expression = Sum(x ** k / factorial(k) / gamma(a * k + b), (k, 0, S.Infinity))\n    expression = gamma(b) / sympy.exp(x) * expression\n    for n in range(0, order + 1):\n        term = expression.diff(a, n).subs(a, 0).simplify().doit()\n        x_part = term.subs(polygamma(0, b), 1).replace(polygamma, lambda *args: 0)\n        x_part *= (-1) ** n\n        A.append(a ** n / factorial(n))\n        X.append(horner(x_part))\n        B.append(horner((term / x_part).simplify()))\n    s = 'Tylor series expansion of Phi(a, b, x) in a=0 up to order 5.\\n'\n    s += 'Phi(a, b, x) = exp(x)/gamma(b) * sum(A[i] * X[i] * B[i], i=0..5)\\n'\n    for (name, c) in zip(['A', 'X', 'B'], [A, X, B]):\n        for i in range(len(c)):\n            s += f'\\n{name}[{i}] = ' + str(c[i])\n    return s",
            "def series_small_a():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tylor series expansion of Phi(a, b, x) in a=0 up to order 5.\\n    '\n    order = 5\n    (a, b, x, k) = symbols('a b x k')\n    A = []\n    X = []\n    B = []\n    expression = Sum(x ** k / factorial(k) / gamma(a * k + b), (k, 0, S.Infinity))\n    expression = gamma(b) / sympy.exp(x) * expression\n    for n in range(0, order + 1):\n        term = expression.diff(a, n).subs(a, 0).simplify().doit()\n        x_part = term.subs(polygamma(0, b), 1).replace(polygamma, lambda *args: 0)\n        x_part *= (-1) ** n\n        A.append(a ** n / factorial(n))\n        X.append(horner(x_part))\n        B.append(horner((term / x_part).simplify()))\n    s = 'Tylor series expansion of Phi(a, b, x) in a=0 up to order 5.\\n'\n    s += 'Phi(a, b, x) = exp(x)/gamma(b) * sum(A[i] * X[i] * B[i], i=0..5)\\n'\n    for (name, c) in zip(['A', 'X', 'B'], [A, X, B]):\n        for i in range(len(c)):\n            s += f'\\n{name}[{i}] = ' + str(c[i])\n    return s",
            "def series_small_a():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tylor series expansion of Phi(a, b, x) in a=0 up to order 5.\\n    '\n    order = 5\n    (a, b, x, k) = symbols('a b x k')\n    A = []\n    X = []\n    B = []\n    expression = Sum(x ** k / factorial(k) / gamma(a * k + b), (k, 0, S.Infinity))\n    expression = gamma(b) / sympy.exp(x) * expression\n    for n in range(0, order + 1):\n        term = expression.diff(a, n).subs(a, 0).simplify().doit()\n        x_part = term.subs(polygamma(0, b), 1).replace(polygamma, lambda *args: 0)\n        x_part *= (-1) ** n\n        A.append(a ** n / factorial(n))\n        X.append(horner(x_part))\n        B.append(horner((term / x_part).simplify()))\n    s = 'Tylor series expansion of Phi(a, b, x) in a=0 up to order 5.\\n'\n    s += 'Phi(a, b, x) = exp(x)/gamma(b) * sum(A[i] * X[i] * B[i], i=0..5)\\n'\n    for (name, c) in zip(['A', 'X', 'B'], [A, X, B]):\n        for i in range(len(c)):\n            s += f'\\n{name}[{i}] = ' + str(c[i])\n    return s"
        ]
    },
    {
        "func_name": "dg_series",
        "original": "def dg_series(z, n):\n    \"\"\"Symbolic expansion of digamma(z) in z=0 to order n.\n\n    See https://dlmf.nist.gov/5.7.E4 and with https://dlmf.nist.gov/5.5.E2\n    \"\"\"\n    k = symbols('k')\n    return -1 / z - EulerGamma + sympy.summation((-1) ** k * zeta(k) * z ** (k - 1), (k, 2, n + 1))",
        "mutated": [
            "def dg_series(z, n):\n    if False:\n        i = 10\n    'Symbolic expansion of digamma(z) in z=0 to order n.\\n\\n    See https://dlmf.nist.gov/5.7.E4 and with https://dlmf.nist.gov/5.5.E2\\n    '\n    k = symbols('k')\n    return -1 / z - EulerGamma + sympy.summation((-1) ** k * zeta(k) * z ** (k - 1), (k, 2, n + 1))",
            "def dg_series(z, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Symbolic expansion of digamma(z) in z=0 to order n.\\n\\n    See https://dlmf.nist.gov/5.7.E4 and with https://dlmf.nist.gov/5.5.E2\\n    '\n    k = symbols('k')\n    return -1 / z - EulerGamma + sympy.summation((-1) ** k * zeta(k) * z ** (k - 1), (k, 2, n + 1))",
            "def dg_series(z, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Symbolic expansion of digamma(z) in z=0 to order n.\\n\\n    See https://dlmf.nist.gov/5.7.E4 and with https://dlmf.nist.gov/5.5.E2\\n    '\n    k = symbols('k')\n    return -1 / z - EulerGamma + sympy.summation((-1) ** k * zeta(k) * z ** (k - 1), (k, 2, n + 1))",
            "def dg_series(z, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Symbolic expansion of digamma(z) in z=0 to order n.\\n\\n    See https://dlmf.nist.gov/5.7.E4 and with https://dlmf.nist.gov/5.5.E2\\n    '\n    k = symbols('k')\n    return -1 / z - EulerGamma + sympy.summation((-1) ** k * zeta(k) * z ** (k - 1), (k, 2, n + 1))",
            "def dg_series(z, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Symbolic expansion of digamma(z) in z=0 to order n.\\n\\n    See https://dlmf.nist.gov/5.7.E4 and with https://dlmf.nist.gov/5.5.E2\\n    '\n    k = symbols('k')\n    return -1 / z - EulerGamma + sympy.summation((-1) ** k * zeta(k) * z ** (k - 1), (k, 2, n + 1))"
        ]
    },
    {
        "func_name": "pg_series",
        "original": "def pg_series(k, z, n):\n    \"\"\"Symbolic expansion of polygamma(k, z) in z=0 to order n.\"\"\"\n    return sympy.diff(dg_series(z, n + k), z, k)",
        "mutated": [
            "def pg_series(k, z, n):\n    if False:\n        i = 10\n    'Symbolic expansion of polygamma(k, z) in z=0 to order n.'\n    return sympy.diff(dg_series(z, n + k), z, k)",
            "def pg_series(k, z, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Symbolic expansion of polygamma(k, z) in z=0 to order n.'\n    return sympy.diff(dg_series(z, n + k), z, k)",
            "def pg_series(k, z, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Symbolic expansion of polygamma(k, z) in z=0 to order n.'\n    return sympy.diff(dg_series(z, n + k), z, k)",
            "def pg_series(k, z, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Symbolic expansion of polygamma(k, z) in z=0 to order n.'\n    return sympy.diff(dg_series(z, n + k), z, k)",
            "def pg_series(k, z, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Symbolic expansion of polygamma(k, z) in z=0 to order n.'\n    return sympy.diff(dg_series(z, n + k), z, k)"
        ]
    },
    {
        "func_name": "series_small_a_small_b",
        "original": "def series_small_a_small_b():\n    \"\"\"Tylor series expansion of Phi(a, b, x) in a=0 and b=0 up to order 5.\n\n    Be aware of cancellation of poles in b=0 of digamma(b)/Gamma(b) and\n    polygamma functions.\n\n    digamma(b)/Gamma(b) = -1 - 2*M_EG*b + O(b^2)\n    digamma(b)^2/Gamma(b) = 1/b + 3*M_EG + b*(-5/12*PI^2+7/2*M_EG^2) + O(b^2)\n    polygamma(1, b)/Gamma(b) = 1/b + M_EG + b*(1/12*PI^2 + 1/2*M_EG^2) + O(b^2)\n    and so on.\n    \"\"\"\n    order = 5\n    (a, b, x, k) = symbols('a b x k')\n    (M_PI, M_EG, M_Z3) = symbols('M_PI M_EG M_Z3')\n    c_subs = {pi: M_PI, EulerGamma: M_EG, zeta(3): M_Z3}\n    A = []\n    X = []\n    B = []\n    C = []\n    expression = gamma(b) / sympy.exp(x) * Sum(x ** k / factorial(k) / gamma(a * k + b), (k, 0, S.Infinity))\n    for n in range(0, order + 1):\n        term = expression.diff(a, n).subs(a, 0).simplify().doit()\n        x_part = term.subs(polygamma(0, b), 1).replace(polygamma, lambda *args: 0)\n        x_part *= (-1) ** n\n        pg_part = term / x_part / gamma(b)\n        if n >= 1:\n            pg_part = pg_part.replace(polygamma, lambda k, x: pg_series(k, x, order + 1 + n))\n            pg_part = pg_part.series(b, 0, n=order + 1 - n).removeO().subs(polygamma(2, 1), -2 * zeta(3)).simplify()\n        A.append(a ** n / factorial(n))\n        X.append(horner(x_part))\n        B.append(pg_part)\n    C = sympy.Poly(B[1].subs(c_subs), b).coeffs()\n    C.reverse()\n    for i in range(len(C)):\n        C[i] = (C[i] * factorial(i)).simplify()\n    s = 'Tylor series expansion of Phi(a, b, x) in a=0 and b=0 up to order 5.'\n    s += '\\nPhi(a, b, x) = exp(x) * sum(A[i] * X[i] * B[i], i=0..5)\\n'\n    s += 'B[0] = 1\\n'\n    s += 'B[i] = sum(C[k+i-1] * b**k/k!, k=0..)\\n'\n    s += '\\nM_PI = pi'\n    s += '\\nM_EG = EulerGamma'\n    s += '\\nM_Z3 = zeta(3)'\n    for (name, c) in zip(['A', 'X'], [A, X]):\n        for i in range(len(c)):\n            s += f'\\n{name}[{i}] = '\n            s += str(c[i])\n    for i in range(len(C)):\n        s += f'\\n# C[{i}] = '\n        s += str(C[i])\n        s += f'\\nC[{i}] = '\n        s += str(C[i].subs({M_EG: EulerGamma, M_PI: pi, M_Z3: zeta(3)}).evalf(17))\n    s += '\\n\\nTest if B[i] does have the assumed structure.'\n    s += '\\nC[i] are derived from B[1] alone.'\n    s += '\\nTest B[2] == C[1] + b*C[2] + b^2/2*C[3] + b^3/6*C[4] + ..'\n    test = sum([b ** k / factorial(k) * C[k + 1] for k in range(order - 1)])\n    test = (test - B[2].subs(c_subs)).simplify()\n    s += f'\\ntest successful = {test == S(0)}'\n    s += '\\nTest B[3] == C[2] + b*C[3] + b^2/2*C[4] + ..'\n    test = sum([b ** k / factorial(k) * C[k + 2] for k in range(order - 2)])\n    test = (test - B[3].subs(c_subs)).simplify()\n    s += f'\\ntest successful = {test == S(0)}'\n    return s",
        "mutated": [
            "def series_small_a_small_b():\n    if False:\n        i = 10\n    'Tylor series expansion of Phi(a, b, x) in a=0 and b=0 up to order 5.\\n\\n    Be aware of cancellation of poles in b=0 of digamma(b)/Gamma(b) and\\n    polygamma functions.\\n\\n    digamma(b)/Gamma(b) = -1 - 2*M_EG*b + O(b^2)\\n    digamma(b)^2/Gamma(b) = 1/b + 3*M_EG + b*(-5/12*PI^2+7/2*M_EG^2) + O(b^2)\\n    polygamma(1, b)/Gamma(b) = 1/b + M_EG + b*(1/12*PI^2 + 1/2*M_EG^2) + O(b^2)\\n    and so on.\\n    '\n    order = 5\n    (a, b, x, k) = symbols('a b x k')\n    (M_PI, M_EG, M_Z3) = symbols('M_PI M_EG M_Z3')\n    c_subs = {pi: M_PI, EulerGamma: M_EG, zeta(3): M_Z3}\n    A = []\n    X = []\n    B = []\n    C = []\n    expression = gamma(b) / sympy.exp(x) * Sum(x ** k / factorial(k) / gamma(a * k + b), (k, 0, S.Infinity))\n    for n in range(0, order + 1):\n        term = expression.diff(a, n).subs(a, 0).simplify().doit()\n        x_part = term.subs(polygamma(0, b), 1).replace(polygamma, lambda *args: 0)\n        x_part *= (-1) ** n\n        pg_part = term / x_part / gamma(b)\n        if n >= 1:\n            pg_part = pg_part.replace(polygamma, lambda k, x: pg_series(k, x, order + 1 + n))\n            pg_part = pg_part.series(b, 0, n=order + 1 - n).removeO().subs(polygamma(2, 1), -2 * zeta(3)).simplify()\n        A.append(a ** n / factorial(n))\n        X.append(horner(x_part))\n        B.append(pg_part)\n    C = sympy.Poly(B[1].subs(c_subs), b).coeffs()\n    C.reverse()\n    for i in range(len(C)):\n        C[i] = (C[i] * factorial(i)).simplify()\n    s = 'Tylor series expansion of Phi(a, b, x) in a=0 and b=0 up to order 5.'\n    s += '\\nPhi(a, b, x) = exp(x) * sum(A[i] * X[i] * B[i], i=0..5)\\n'\n    s += 'B[0] = 1\\n'\n    s += 'B[i] = sum(C[k+i-1] * b**k/k!, k=0..)\\n'\n    s += '\\nM_PI = pi'\n    s += '\\nM_EG = EulerGamma'\n    s += '\\nM_Z3 = zeta(3)'\n    for (name, c) in zip(['A', 'X'], [A, X]):\n        for i in range(len(c)):\n            s += f'\\n{name}[{i}] = '\n            s += str(c[i])\n    for i in range(len(C)):\n        s += f'\\n# C[{i}] = '\n        s += str(C[i])\n        s += f'\\nC[{i}] = '\n        s += str(C[i].subs({M_EG: EulerGamma, M_PI: pi, M_Z3: zeta(3)}).evalf(17))\n    s += '\\n\\nTest if B[i] does have the assumed structure.'\n    s += '\\nC[i] are derived from B[1] alone.'\n    s += '\\nTest B[2] == C[1] + b*C[2] + b^2/2*C[3] + b^3/6*C[4] + ..'\n    test = sum([b ** k / factorial(k) * C[k + 1] for k in range(order - 1)])\n    test = (test - B[2].subs(c_subs)).simplify()\n    s += f'\\ntest successful = {test == S(0)}'\n    s += '\\nTest B[3] == C[2] + b*C[3] + b^2/2*C[4] + ..'\n    test = sum([b ** k / factorial(k) * C[k + 2] for k in range(order - 2)])\n    test = (test - B[3].subs(c_subs)).simplify()\n    s += f'\\ntest successful = {test == S(0)}'\n    return s",
            "def series_small_a_small_b():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tylor series expansion of Phi(a, b, x) in a=0 and b=0 up to order 5.\\n\\n    Be aware of cancellation of poles in b=0 of digamma(b)/Gamma(b) and\\n    polygamma functions.\\n\\n    digamma(b)/Gamma(b) = -1 - 2*M_EG*b + O(b^2)\\n    digamma(b)^2/Gamma(b) = 1/b + 3*M_EG + b*(-5/12*PI^2+7/2*M_EG^2) + O(b^2)\\n    polygamma(1, b)/Gamma(b) = 1/b + M_EG + b*(1/12*PI^2 + 1/2*M_EG^2) + O(b^2)\\n    and so on.\\n    '\n    order = 5\n    (a, b, x, k) = symbols('a b x k')\n    (M_PI, M_EG, M_Z3) = symbols('M_PI M_EG M_Z3')\n    c_subs = {pi: M_PI, EulerGamma: M_EG, zeta(3): M_Z3}\n    A = []\n    X = []\n    B = []\n    C = []\n    expression = gamma(b) / sympy.exp(x) * Sum(x ** k / factorial(k) / gamma(a * k + b), (k, 0, S.Infinity))\n    for n in range(0, order + 1):\n        term = expression.diff(a, n).subs(a, 0).simplify().doit()\n        x_part = term.subs(polygamma(0, b), 1).replace(polygamma, lambda *args: 0)\n        x_part *= (-1) ** n\n        pg_part = term / x_part / gamma(b)\n        if n >= 1:\n            pg_part = pg_part.replace(polygamma, lambda k, x: pg_series(k, x, order + 1 + n))\n            pg_part = pg_part.series(b, 0, n=order + 1 - n).removeO().subs(polygamma(2, 1), -2 * zeta(3)).simplify()\n        A.append(a ** n / factorial(n))\n        X.append(horner(x_part))\n        B.append(pg_part)\n    C = sympy.Poly(B[1].subs(c_subs), b).coeffs()\n    C.reverse()\n    for i in range(len(C)):\n        C[i] = (C[i] * factorial(i)).simplify()\n    s = 'Tylor series expansion of Phi(a, b, x) in a=0 and b=0 up to order 5.'\n    s += '\\nPhi(a, b, x) = exp(x) * sum(A[i] * X[i] * B[i], i=0..5)\\n'\n    s += 'B[0] = 1\\n'\n    s += 'B[i] = sum(C[k+i-1] * b**k/k!, k=0..)\\n'\n    s += '\\nM_PI = pi'\n    s += '\\nM_EG = EulerGamma'\n    s += '\\nM_Z3 = zeta(3)'\n    for (name, c) in zip(['A', 'X'], [A, X]):\n        for i in range(len(c)):\n            s += f'\\n{name}[{i}] = '\n            s += str(c[i])\n    for i in range(len(C)):\n        s += f'\\n# C[{i}] = '\n        s += str(C[i])\n        s += f'\\nC[{i}] = '\n        s += str(C[i].subs({M_EG: EulerGamma, M_PI: pi, M_Z3: zeta(3)}).evalf(17))\n    s += '\\n\\nTest if B[i] does have the assumed structure.'\n    s += '\\nC[i] are derived from B[1] alone.'\n    s += '\\nTest B[2] == C[1] + b*C[2] + b^2/2*C[3] + b^3/6*C[4] + ..'\n    test = sum([b ** k / factorial(k) * C[k + 1] for k in range(order - 1)])\n    test = (test - B[2].subs(c_subs)).simplify()\n    s += f'\\ntest successful = {test == S(0)}'\n    s += '\\nTest B[3] == C[2] + b*C[3] + b^2/2*C[4] + ..'\n    test = sum([b ** k / factorial(k) * C[k + 2] for k in range(order - 2)])\n    test = (test - B[3].subs(c_subs)).simplify()\n    s += f'\\ntest successful = {test == S(0)}'\n    return s",
            "def series_small_a_small_b():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tylor series expansion of Phi(a, b, x) in a=0 and b=0 up to order 5.\\n\\n    Be aware of cancellation of poles in b=0 of digamma(b)/Gamma(b) and\\n    polygamma functions.\\n\\n    digamma(b)/Gamma(b) = -1 - 2*M_EG*b + O(b^2)\\n    digamma(b)^2/Gamma(b) = 1/b + 3*M_EG + b*(-5/12*PI^2+7/2*M_EG^2) + O(b^2)\\n    polygamma(1, b)/Gamma(b) = 1/b + M_EG + b*(1/12*PI^2 + 1/2*M_EG^2) + O(b^2)\\n    and so on.\\n    '\n    order = 5\n    (a, b, x, k) = symbols('a b x k')\n    (M_PI, M_EG, M_Z3) = symbols('M_PI M_EG M_Z3')\n    c_subs = {pi: M_PI, EulerGamma: M_EG, zeta(3): M_Z3}\n    A = []\n    X = []\n    B = []\n    C = []\n    expression = gamma(b) / sympy.exp(x) * Sum(x ** k / factorial(k) / gamma(a * k + b), (k, 0, S.Infinity))\n    for n in range(0, order + 1):\n        term = expression.diff(a, n).subs(a, 0).simplify().doit()\n        x_part = term.subs(polygamma(0, b), 1).replace(polygamma, lambda *args: 0)\n        x_part *= (-1) ** n\n        pg_part = term / x_part / gamma(b)\n        if n >= 1:\n            pg_part = pg_part.replace(polygamma, lambda k, x: pg_series(k, x, order + 1 + n))\n            pg_part = pg_part.series(b, 0, n=order + 1 - n).removeO().subs(polygamma(2, 1), -2 * zeta(3)).simplify()\n        A.append(a ** n / factorial(n))\n        X.append(horner(x_part))\n        B.append(pg_part)\n    C = sympy.Poly(B[1].subs(c_subs), b).coeffs()\n    C.reverse()\n    for i in range(len(C)):\n        C[i] = (C[i] * factorial(i)).simplify()\n    s = 'Tylor series expansion of Phi(a, b, x) in a=0 and b=0 up to order 5.'\n    s += '\\nPhi(a, b, x) = exp(x) * sum(A[i] * X[i] * B[i], i=0..5)\\n'\n    s += 'B[0] = 1\\n'\n    s += 'B[i] = sum(C[k+i-1] * b**k/k!, k=0..)\\n'\n    s += '\\nM_PI = pi'\n    s += '\\nM_EG = EulerGamma'\n    s += '\\nM_Z3 = zeta(3)'\n    for (name, c) in zip(['A', 'X'], [A, X]):\n        for i in range(len(c)):\n            s += f'\\n{name}[{i}] = '\n            s += str(c[i])\n    for i in range(len(C)):\n        s += f'\\n# C[{i}] = '\n        s += str(C[i])\n        s += f'\\nC[{i}] = '\n        s += str(C[i].subs({M_EG: EulerGamma, M_PI: pi, M_Z3: zeta(3)}).evalf(17))\n    s += '\\n\\nTest if B[i] does have the assumed structure.'\n    s += '\\nC[i] are derived from B[1] alone.'\n    s += '\\nTest B[2] == C[1] + b*C[2] + b^2/2*C[3] + b^3/6*C[4] + ..'\n    test = sum([b ** k / factorial(k) * C[k + 1] for k in range(order - 1)])\n    test = (test - B[2].subs(c_subs)).simplify()\n    s += f'\\ntest successful = {test == S(0)}'\n    s += '\\nTest B[3] == C[2] + b*C[3] + b^2/2*C[4] + ..'\n    test = sum([b ** k / factorial(k) * C[k + 2] for k in range(order - 2)])\n    test = (test - B[3].subs(c_subs)).simplify()\n    s += f'\\ntest successful = {test == S(0)}'\n    return s",
            "def series_small_a_small_b():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tylor series expansion of Phi(a, b, x) in a=0 and b=0 up to order 5.\\n\\n    Be aware of cancellation of poles in b=0 of digamma(b)/Gamma(b) and\\n    polygamma functions.\\n\\n    digamma(b)/Gamma(b) = -1 - 2*M_EG*b + O(b^2)\\n    digamma(b)^2/Gamma(b) = 1/b + 3*M_EG + b*(-5/12*PI^2+7/2*M_EG^2) + O(b^2)\\n    polygamma(1, b)/Gamma(b) = 1/b + M_EG + b*(1/12*PI^2 + 1/2*M_EG^2) + O(b^2)\\n    and so on.\\n    '\n    order = 5\n    (a, b, x, k) = symbols('a b x k')\n    (M_PI, M_EG, M_Z3) = symbols('M_PI M_EG M_Z3')\n    c_subs = {pi: M_PI, EulerGamma: M_EG, zeta(3): M_Z3}\n    A = []\n    X = []\n    B = []\n    C = []\n    expression = gamma(b) / sympy.exp(x) * Sum(x ** k / factorial(k) / gamma(a * k + b), (k, 0, S.Infinity))\n    for n in range(0, order + 1):\n        term = expression.diff(a, n).subs(a, 0).simplify().doit()\n        x_part = term.subs(polygamma(0, b), 1).replace(polygamma, lambda *args: 0)\n        x_part *= (-1) ** n\n        pg_part = term / x_part / gamma(b)\n        if n >= 1:\n            pg_part = pg_part.replace(polygamma, lambda k, x: pg_series(k, x, order + 1 + n))\n            pg_part = pg_part.series(b, 0, n=order + 1 - n).removeO().subs(polygamma(2, 1), -2 * zeta(3)).simplify()\n        A.append(a ** n / factorial(n))\n        X.append(horner(x_part))\n        B.append(pg_part)\n    C = sympy.Poly(B[1].subs(c_subs), b).coeffs()\n    C.reverse()\n    for i in range(len(C)):\n        C[i] = (C[i] * factorial(i)).simplify()\n    s = 'Tylor series expansion of Phi(a, b, x) in a=0 and b=0 up to order 5.'\n    s += '\\nPhi(a, b, x) = exp(x) * sum(A[i] * X[i] * B[i], i=0..5)\\n'\n    s += 'B[0] = 1\\n'\n    s += 'B[i] = sum(C[k+i-1] * b**k/k!, k=0..)\\n'\n    s += '\\nM_PI = pi'\n    s += '\\nM_EG = EulerGamma'\n    s += '\\nM_Z3 = zeta(3)'\n    for (name, c) in zip(['A', 'X'], [A, X]):\n        for i in range(len(c)):\n            s += f'\\n{name}[{i}] = '\n            s += str(c[i])\n    for i in range(len(C)):\n        s += f'\\n# C[{i}] = '\n        s += str(C[i])\n        s += f'\\nC[{i}] = '\n        s += str(C[i].subs({M_EG: EulerGamma, M_PI: pi, M_Z3: zeta(3)}).evalf(17))\n    s += '\\n\\nTest if B[i] does have the assumed structure.'\n    s += '\\nC[i] are derived from B[1] alone.'\n    s += '\\nTest B[2] == C[1] + b*C[2] + b^2/2*C[3] + b^3/6*C[4] + ..'\n    test = sum([b ** k / factorial(k) * C[k + 1] for k in range(order - 1)])\n    test = (test - B[2].subs(c_subs)).simplify()\n    s += f'\\ntest successful = {test == S(0)}'\n    s += '\\nTest B[3] == C[2] + b*C[3] + b^2/2*C[4] + ..'\n    test = sum([b ** k / factorial(k) * C[k + 2] for k in range(order - 2)])\n    test = (test - B[3].subs(c_subs)).simplify()\n    s += f'\\ntest successful = {test == S(0)}'\n    return s",
            "def series_small_a_small_b():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tylor series expansion of Phi(a, b, x) in a=0 and b=0 up to order 5.\\n\\n    Be aware of cancellation of poles in b=0 of digamma(b)/Gamma(b) and\\n    polygamma functions.\\n\\n    digamma(b)/Gamma(b) = -1 - 2*M_EG*b + O(b^2)\\n    digamma(b)^2/Gamma(b) = 1/b + 3*M_EG + b*(-5/12*PI^2+7/2*M_EG^2) + O(b^2)\\n    polygamma(1, b)/Gamma(b) = 1/b + M_EG + b*(1/12*PI^2 + 1/2*M_EG^2) + O(b^2)\\n    and so on.\\n    '\n    order = 5\n    (a, b, x, k) = symbols('a b x k')\n    (M_PI, M_EG, M_Z3) = symbols('M_PI M_EG M_Z3')\n    c_subs = {pi: M_PI, EulerGamma: M_EG, zeta(3): M_Z3}\n    A = []\n    X = []\n    B = []\n    C = []\n    expression = gamma(b) / sympy.exp(x) * Sum(x ** k / factorial(k) / gamma(a * k + b), (k, 0, S.Infinity))\n    for n in range(0, order + 1):\n        term = expression.diff(a, n).subs(a, 0).simplify().doit()\n        x_part = term.subs(polygamma(0, b), 1).replace(polygamma, lambda *args: 0)\n        x_part *= (-1) ** n\n        pg_part = term / x_part / gamma(b)\n        if n >= 1:\n            pg_part = pg_part.replace(polygamma, lambda k, x: pg_series(k, x, order + 1 + n))\n            pg_part = pg_part.series(b, 0, n=order + 1 - n).removeO().subs(polygamma(2, 1), -2 * zeta(3)).simplify()\n        A.append(a ** n / factorial(n))\n        X.append(horner(x_part))\n        B.append(pg_part)\n    C = sympy.Poly(B[1].subs(c_subs), b).coeffs()\n    C.reverse()\n    for i in range(len(C)):\n        C[i] = (C[i] * factorial(i)).simplify()\n    s = 'Tylor series expansion of Phi(a, b, x) in a=0 and b=0 up to order 5.'\n    s += '\\nPhi(a, b, x) = exp(x) * sum(A[i] * X[i] * B[i], i=0..5)\\n'\n    s += 'B[0] = 1\\n'\n    s += 'B[i] = sum(C[k+i-1] * b**k/k!, k=0..)\\n'\n    s += '\\nM_PI = pi'\n    s += '\\nM_EG = EulerGamma'\n    s += '\\nM_Z3 = zeta(3)'\n    for (name, c) in zip(['A', 'X'], [A, X]):\n        for i in range(len(c)):\n            s += f'\\n{name}[{i}] = '\n            s += str(c[i])\n    for i in range(len(C)):\n        s += f'\\n# C[{i}] = '\n        s += str(C[i])\n        s += f'\\nC[{i}] = '\n        s += str(C[i].subs({M_EG: EulerGamma, M_PI: pi, M_Z3: zeta(3)}).evalf(17))\n    s += '\\n\\nTest if B[i] does have the assumed structure.'\n    s += '\\nC[i] are derived from B[1] alone.'\n    s += '\\nTest B[2] == C[1] + b*C[2] + b^2/2*C[3] + b^3/6*C[4] + ..'\n    test = sum([b ** k / factorial(k) * C[k + 1] for k in range(order - 1)])\n    test = (test - B[2].subs(c_subs)).simplify()\n    s += f'\\ntest successful = {test == S(0)}'\n    s += '\\nTest B[3] == C[2] + b*C[3] + b^2/2*C[4] + ..'\n    test = sum([b ** k / factorial(k) * C[k + 2] for k in range(order - 2)])\n    test = (test - B[3].subs(c_subs)).simplify()\n    s += f'\\ntest successful = {test == S(0)}'\n    return s"
        ]
    },
    {
        "func_name": "eval",
        "original": "@classmethod\ndef eval(cls, n, rho, v):\n    if not n >= 0:\n        raise ValueError('must have n >= 0')\n    elif n == 0:\n        return 1\n    else:\n        return g(n - 1, rho, v) + gammasimp(gamma(rho + 2 + n) / gamma(rho + 2)) / gammasimp(gamma(3 + n) / gamma(3)) * v ** n",
        "mutated": [
            "@classmethod\ndef eval(cls, n, rho, v):\n    if False:\n        i = 10\n    if not n >= 0:\n        raise ValueError('must have n >= 0')\n    elif n == 0:\n        return 1\n    else:\n        return g(n - 1, rho, v) + gammasimp(gamma(rho + 2 + n) / gamma(rho + 2)) / gammasimp(gamma(3 + n) / gamma(3)) * v ** n",
            "@classmethod\ndef eval(cls, n, rho, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not n >= 0:\n        raise ValueError('must have n >= 0')\n    elif n == 0:\n        return 1\n    else:\n        return g(n - 1, rho, v) + gammasimp(gamma(rho + 2 + n) / gamma(rho + 2)) / gammasimp(gamma(3 + n) / gamma(3)) * v ** n",
            "@classmethod\ndef eval(cls, n, rho, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not n >= 0:\n        raise ValueError('must have n >= 0')\n    elif n == 0:\n        return 1\n    else:\n        return g(n - 1, rho, v) + gammasimp(gamma(rho + 2 + n) / gamma(rho + 2)) / gammasimp(gamma(3 + n) / gamma(3)) * v ** n",
            "@classmethod\ndef eval(cls, n, rho, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not n >= 0:\n        raise ValueError('must have n >= 0')\n    elif n == 0:\n        return 1\n    else:\n        return g(n - 1, rho, v) + gammasimp(gamma(rho + 2 + n) / gamma(rho + 2)) / gammasimp(gamma(3 + n) / gamma(3)) * v ** n",
            "@classmethod\ndef eval(cls, n, rho, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not n >= 0:\n        raise ValueError('must have n >= 0')\n    elif n == 0:\n        return 1\n    else:\n        return g(n - 1, rho, v) + gammasimp(gamma(rho + 2 + n) / gamma(rho + 2)) / gammasimp(gamma(3 + n) / gamma(3)) * v ** n"
        ]
    },
    {
        "func_name": "eval",
        "original": "@classmethod\ndef eval(cls, m, rho, beta):\n    if not m >= 0:\n        raise ValueError('must have m >= 0')\n    v = symbols('v')\n    expression = (1 - v) ** (-beta) * g(2 * m, rho, v) ** (-m - Rational(1, 2))\n    res = expression.diff(v, 2 * m).subs(v, 0) / factorial(2 * m)\n    res = res * (gamma(m + Rational(1, 2)) / (2 * pi) * (2 / (rho + 1)) ** (m + Rational(1, 2)))\n    return res",
        "mutated": [
            "@classmethod\ndef eval(cls, m, rho, beta):\n    if False:\n        i = 10\n    if not m >= 0:\n        raise ValueError('must have m >= 0')\n    v = symbols('v')\n    expression = (1 - v) ** (-beta) * g(2 * m, rho, v) ** (-m - Rational(1, 2))\n    res = expression.diff(v, 2 * m).subs(v, 0) / factorial(2 * m)\n    res = res * (gamma(m + Rational(1, 2)) / (2 * pi) * (2 / (rho + 1)) ** (m + Rational(1, 2)))\n    return res",
            "@classmethod\ndef eval(cls, m, rho, beta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not m >= 0:\n        raise ValueError('must have m >= 0')\n    v = symbols('v')\n    expression = (1 - v) ** (-beta) * g(2 * m, rho, v) ** (-m - Rational(1, 2))\n    res = expression.diff(v, 2 * m).subs(v, 0) / factorial(2 * m)\n    res = res * (gamma(m + Rational(1, 2)) / (2 * pi) * (2 / (rho + 1)) ** (m + Rational(1, 2)))\n    return res",
            "@classmethod\ndef eval(cls, m, rho, beta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not m >= 0:\n        raise ValueError('must have m >= 0')\n    v = symbols('v')\n    expression = (1 - v) ** (-beta) * g(2 * m, rho, v) ** (-m - Rational(1, 2))\n    res = expression.diff(v, 2 * m).subs(v, 0) / factorial(2 * m)\n    res = res * (gamma(m + Rational(1, 2)) / (2 * pi) * (2 / (rho + 1)) ** (m + Rational(1, 2)))\n    return res",
            "@classmethod\ndef eval(cls, m, rho, beta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not m >= 0:\n        raise ValueError('must have m >= 0')\n    v = symbols('v')\n    expression = (1 - v) ** (-beta) * g(2 * m, rho, v) ** (-m - Rational(1, 2))\n    res = expression.diff(v, 2 * m).subs(v, 0) / factorial(2 * m)\n    res = res * (gamma(m + Rational(1, 2)) / (2 * pi) * (2 / (rho + 1)) ** (m + Rational(1, 2)))\n    return res",
            "@classmethod\ndef eval(cls, m, rho, beta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not m >= 0:\n        raise ValueError('must have m >= 0')\n    v = symbols('v')\n    expression = (1 - v) ** (-beta) * g(2 * m, rho, v) ** (-m - Rational(1, 2))\n    res = expression.diff(v, 2 * m).subs(v, 0) / factorial(2 * m)\n    res = res * (gamma(m + Rational(1, 2)) / (2 * pi) * (2 / (rho + 1)) ** (m + Rational(1, 2)))\n    return res"
        ]
    },
    {
        "func_name": "asymptotic_series",
        "original": "def asymptotic_series():\n    \"\"\"Asymptotic expansion for large x.\n\n    Phi(a, b, x) ~ Z^(1/2-b) * exp((1+a)/a * Z) * sum_k (-1)^k * C_k / Z^k\n    Z = (a*x)^(1/(1+a))\n\n    Wright (1935) lists the coefficients C_0 and C_1 (he calls them a_0 and\n    a_1). With slightly different notation, Paris (2017) lists coefficients\n    c_k up to order k=3.\n    Paris (2017) uses ZP = (1+a)/a * Z  (ZP = Z of Paris) and\n    C_k = C_0 * (-a/(1+a))^k * c_k\n    \"\"\"\n    order = 8\n\n    class g(sympy.Function):\n        \"\"\"Helper function g according to Wright (1935)\n\n        g(n, rho, v) = (1 + (rho+2)/3 * v + (rho+2)*(rho+3)/(2*3) * v^2 + ...)\n\n        Note: Wright (1935) uses square root of above definition.\n        \"\"\"\n        nargs = 3\n\n        @classmethod\n        def eval(cls, n, rho, v):\n            if not n >= 0:\n                raise ValueError('must have n >= 0')\n            elif n == 0:\n                return 1\n            else:\n                return g(n - 1, rho, v) + gammasimp(gamma(rho + 2 + n) / gamma(rho + 2)) / gammasimp(gamma(3 + n) / gamma(3)) * v ** n\n\n    class coef_C(sympy.Function):\n        \"\"\"Calculate coefficients C_m for integer m.\n\n        C_m is the coefficient of v^(2*m) in the Taylor expansion in v=0 of\n        Gamma(m+1/2)/(2*pi) * (2/(rho+1))^(m+1/2) * (1-v)^(-b)\n            * g(rho, v)^(-m-1/2)\n        \"\"\"\n        nargs = 3\n\n        @classmethod\n        def eval(cls, m, rho, beta):\n            if not m >= 0:\n                raise ValueError('must have m >= 0')\n            v = symbols('v')\n            expression = (1 - v) ** (-beta) * g(2 * m, rho, v) ** (-m - Rational(1, 2))\n            res = expression.diff(v, 2 * m).subs(v, 0) / factorial(2 * m)\n            res = res * (gamma(m + Rational(1, 2)) / (2 * pi) * (2 / (rho + 1)) ** (m + Rational(1, 2)))\n            return res\n    (xa, b, xap1) = symbols('xa b xap1')\n    C0 = coef_C(0, xa, b)\n    s = 'Asymptotic expansion for large x\\n'\n    s += 'Phi(a, b, x) = Z**(1/2-b) * exp((1+a)/a * Z) \\n'\n    s += '               * sum((-1)**k * C[k]/Z**k, k=0..6)\\n\\n'\n    s += 'Z      = pow(a * x, 1/(1+a))\\n'\n    s += 'A[k]   = pow(a, k)\\n'\n    s += 'B[k]   = pow(b, k)\\n'\n    s += 'Ap1[k] = pow(1+a, k)\\n\\n'\n    s += 'C[0] = 1./sqrt(2. * M_PI * Ap1[1])\\n'\n    for i in range(1, order + 1):\n        expr = (coef_C(i, xa, b) / (C0 / (1 + xa) ** i)).simplify()\n        factor = [x.denominator() for x in sympy.Poly(expr).coeffs()]\n        factor = sympy.lcm(factor)\n        expr = (expr * factor).simplify().collect(b, sympy.factor)\n        expr = expr.xreplace({xa + 1: xap1})\n        s += f'C[{i}] = C[0] / ({factor} * Ap1[{i}])\\n'\n        s += f'C[{i}] *= {str(expr)}\\n\\n'\n    import re\n    re_a = re.compile('xa\\\\*\\\\*(\\\\d+)')\n    s = re_a.sub('A[\\\\1]', s)\n    re_b = re.compile('b\\\\*\\\\*(\\\\d+)')\n    s = re_b.sub('B[\\\\1]', s)\n    s = s.replace('xap1', 'Ap1[1]')\n    s = s.replace('xa', 'a')\n    re_digits = re.compile('(\\\\d{10,})')\n    s = re_digits.sub('\\\\1.', s)\n    return s",
        "mutated": [
            "def asymptotic_series():\n    if False:\n        i = 10\n    'Asymptotic expansion for large x.\\n\\n    Phi(a, b, x) ~ Z^(1/2-b) * exp((1+a)/a * Z) * sum_k (-1)^k * C_k / Z^k\\n    Z = (a*x)^(1/(1+a))\\n\\n    Wright (1935) lists the coefficients C_0 and C_1 (he calls them a_0 and\\n    a_1). With slightly different notation, Paris (2017) lists coefficients\\n    c_k up to order k=3.\\n    Paris (2017) uses ZP = (1+a)/a * Z  (ZP = Z of Paris) and\\n    C_k = C_0 * (-a/(1+a))^k * c_k\\n    '\n    order = 8\n\n    class g(sympy.Function):\n        \"\"\"Helper function g according to Wright (1935)\n\n        g(n, rho, v) = (1 + (rho+2)/3 * v + (rho+2)*(rho+3)/(2*3) * v^2 + ...)\n\n        Note: Wright (1935) uses square root of above definition.\n        \"\"\"\n        nargs = 3\n\n        @classmethod\n        def eval(cls, n, rho, v):\n            if not n >= 0:\n                raise ValueError('must have n >= 0')\n            elif n == 0:\n                return 1\n            else:\n                return g(n - 1, rho, v) + gammasimp(gamma(rho + 2 + n) / gamma(rho + 2)) / gammasimp(gamma(3 + n) / gamma(3)) * v ** n\n\n    class coef_C(sympy.Function):\n        \"\"\"Calculate coefficients C_m for integer m.\n\n        C_m is the coefficient of v^(2*m) in the Taylor expansion in v=0 of\n        Gamma(m+1/2)/(2*pi) * (2/(rho+1))^(m+1/2) * (1-v)^(-b)\n            * g(rho, v)^(-m-1/2)\n        \"\"\"\n        nargs = 3\n\n        @classmethod\n        def eval(cls, m, rho, beta):\n            if not m >= 0:\n                raise ValueError('must have m >= 0')\n            v = symbols('v')\n            expression = (1 - v) ** (-beta) * g(2 * m, rho, v) ** (-m - Rational(1, 2))\n            res = expression.diff(v, 2 * m).subs(v, 0) / factorial(2 * m)\n            res = res * (gamma(m + Rational(1, 2)) / (2 * pi) * (2 / (rho + 1)) ** (m + Rational(1, 2)))\n            return res\n    (xa, b, xap1) = symbols('xa b xap1')\n    C0 = coef_C(0, xa, b)\n    s = 'Asymptotic expansion for large x\\n'\n    s += 'Phi(a, b, x) = Z**(1/2-b) * exp((1+a)/a * Z) \\n'\n    s += '               * sum((-1)**k * C[k]/Z**k, k=0..6)\\n\\n'\n    s += 'Z      = pow(a * x, 1/(1+a))\\n'\n    s += 'A[k]   = pow(a, k)\\n'\n    s += 'B[k]   = pow(b, k)\\n'\n    s += 'Ap1[k] = pow(1+a, k)\\n\\n'\n    s += 'C[0] = 1./sqrt(2. * M_PI * Ap1[1])\\n'\n    for i in range(1, order + 1):\n        expr = (coef_C(i, xa, b) / (C0 / (1 + xa) ** i)).simplify()\n        factor = [x.denominator() for x in sympy.Poly(expr).coeffs()]\n        factor = sympy.lcm(factor)\n        expr = (expr * factor).simplify().collect(b, sympy.factor)\n        expr = expr.xreplace({xa + 1: xap1})\n        s += f'C[{i}] = C[0] / ({factor} * Ap1[{i}])\\n'\n        s += f'C[{i}] *= {str(expr)}\\n\\n'\n    import re\n    re_a = re.compile('xa\\\\*\\\\*(\\\\d+)')\n    s = re_a.sub('A[\\\\1]', s)\n    re_b = re.compile('b\\\\*\\\\*(\\\\d+)')\n    s = re_b.sub('B[\\\\1]', s)\n    s = s.replace('xap1', 'Ap1[1]')\n    s = s.replace('xa', 'a')\n    re_digits = re.compile('(\\\\d{10,})')\n    s = re_digits.sub('\\\\1.', s)\n    return s",
            "def asymptotic_series():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Asymptotic expansion for large x.\\n\\n    Phi(a, b, x) ~ Z^(1/2-b) * exp((1+a)/a * Z) * sum_k (-1)^k * C_k / Z^k\\n    Z = (a*x)^(1/(1+a))\\n\\n    Wright (1935) lists the coefficients C_0 and C_1 (he calls them a_0 and\\n    a_1). With slightly different notation, Paris (2017) lists coefficients\\n    c_k up to order k=3.\\n    Paris (2017) uses ZP = (1+a)/a * Z  (ZP = Z of Paris) and\\n    C_k = C_0 * (-a/(1+a))^k * c_k\\n    '\n    order = 8\n\n    class g(sympy.Function):\n        \"\"\"Helper function g according to Wright (1935)\n\n        g(n, rho, v) = (1 + (rho+2)/3 * v + (rho+2)*(rho+3)/(2*3) * v^2 + ...)\n\n        Note: Wright (1935) uses square root of above definition.\n        \"\"\"\n        nargs = 3\n\n        @classmethod\n        def eval(cls, n, rho, v):\n            if not n >= 0:\n                raise ValueError('must have n >= 0')\n            elif n == 0:\n                return 1\n            else:\n                return g(n - 1, rho, v) + gammasimp(gamma(rho + 2 + n) / gamma(rho + 2)) / gammasimp(gamma(3 + n) / gamma(3)) * v ** n\n\n    class coef_C(sympy.Function):\n        \"\"\"Calculate coefficients C_m for integer m.\n\n        C_m is the coefficient of v^(2*m) in the Taylor expansion in v=0 of\n        Gamma(m+1/2)/(2*pi) * (2/(rho+1))^(m+1/2) * (1-v)^(-b)\n            * g(rho, v)^(-m-1/2)\n        \"\"\"\n        nargs = 3\n\n        @classmethod\n        def eval(cls, m, rho, beta):\n            if not m >= 0:\n                raise ValueError('must have m >= 0')\n            v = symbols('v')\n            expression = (1 - v) ** (-beta) * g(2 * m, rho, v) ** (-m - Rational(1, 2))\n            res = expression.diff(v, 2 * m).subs(v, 0) / factorial(2 * m)\n            res = res * (gamma(m + Rational(1, 2)) / (2 * pi) * (2 / (rho + 1)) ** (m + Rational(1, 2)))\n            return res\n    (xa, b, xap1) = symbols('xa b xap1')\n    C0 = coef_C(0, xa, b)\n    s = 'Asymptotic expansion for large x\\n'\n    s += 'Phi(a, b, x) = Z**(1/2-b) * exp((1+a)/a * Z) \\n'\n    s += '               * sum((-1)**k * C[k]/Z**k, k=0..6)\\n\\n'\n    s += 'Z      = pow(a * x, 1/(1+a))\\n'\n    s += 'A[k]   = pow(a, k)\\n'\n    s += 'B[k]   = pow(b, k)\\n'\n    s += 'Ap1[k] = pow(1+a, k)\\n\\n'\n    s += 'C[0] = 1./sqrt(2. * M_PI * Ap1[1])\\n'\n    for i in range(1, order + 1):\n        expr = (coef_C(i, xa, b) / (C0 / (1 + xa) ** i)).simplify()\n        factor = [x.denominator() for x in sympy.Poly(expr).coeffs()]\n        factor = sympy.lcm(factor)\n        expr = (expr * factor).simplify().collect(b, sympy.factor)\n        expr = expr.xreplace({xa + 1: xap1})\n        s += f'C[{i}] = C[0] / ({factor} * Ap1[{i}])\\n'\n        s += f'C[{i}] *= {str(expr)}\\n\\n'\n    import re\n    re_a = re.compile('xa\\\\*\\\\*(\\\\d+)')\n    s = re_a.sub('A[\\\\1]', s)\n    re_b = re.compile('b\\\\*\\\\*(\\\\d+)')\n    s = re_b.sub('B[\\\\1]', s)\n    s = s.replace('xap1', 'Ap1[1]')\n    s = s.replace('xa', 'a')\n    re_digits = re.compile('(\\\\d{10,})')\n    s = re_digits.sub('\\\\1.', s)\n    return s",
            "def asymptotic_series():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Asymptotic expansion for large x.\\n\\n    Phi(a, b, x) ~ Z^(1/2-b) * exp((1+a)/a * Z) * sum_k (-1)^k * C_k / Z^k\\n    Z = (a*x)^(1/(1+a))\\n\\n    Wright (1935) lists the coefficients C_0 and C_1 (he calls them a_0 and\\n    a_1). With slightly different notation, Paris (2017) lists coefficients\\n    c_k up to order k=3.\\n    Paris (2017) uses ZP = (1+a)/a * Z  (ZP = Z of Paris) and\\n    C_k = C_0 * (-a/(1+a))^k * c_k\\n    '\n    order = 8\n\n    class g(sympy.Function):\n        \"\"\"Helper function g according to Wright (1935)\n\n        g(n, rho, v) = (1 + (rho+2)/3 * v + (rho+2)*(rho+3)/(2*3) * v^2 + ...)\n\n        Note: Wright (1935) uses square root of above definition.\n        \"\"\"\n        nargs = 3\n\n        @classmethod\n        def eval(cls, n, rho, v):\n            if not n >= 0:\n                raise ValueError('must have n >= 0')\n            elif n == 0:\n                return 1\n            else:\n                return g(n - 1, rho, v) + gammasimp(gamma(rho + 2 + n) / gamma(rho + 2)) / gammasimp(gamma(3 + n) / gamma(3)) * v ** n\n\n    class coef_C(sympy.Function):\n        \"\"\"Calculate coefficients C_m for integer m.\n\n        C_m is the coefficient of v^(2*m) in the Taylor expansion in v=0 of\n        Gamma(m+1/2)/(2*pi) * (2/(rho+1))^(m+1/2) * (1-v)^(-b)\n            * g(rho, v)^(-m-1/2)\n        \"\"\"\n        nargs = 3\n\n        @classmethod\n        def eval(cls, m, rho, beta):\n            if not m >= 0:\n                raise ValueError('must have m >= 0')\n            v = symbols('v')\n            expression = (1 - v) ** (-beta) * g(2 * m, rho, v) ** (-m - Rational(1, 2))\n            res = expression.diff(v, 2 * m).subs(v, 0) / factorial(2 * m)\n            res = res * (gamma(m + Rational(1, 2)) / (2 * pi) * (2 / (rho + 1)) ** (m + Rational(1, 2)))\n            return res\n    (xa, b, xap1) = symbols('xa b xap1')\n    C0 = coef_C(0, xa, b)\n    s = 'Asymptotic expansion for large x\\n'\n    s += 'Phi(a, b, x) = Z**(1/2-b) * exp((1+a)/a * Z) \\n'\n    s += '               * sum((-1)**k * C[k]/Z**k, k=0..6)\\n\\n'\n    s += 'Z      = pow(a * x, 1/(1+a))\\n'\n    s += 'A[k]   = pow(a, k)\\n'\n    s += 'B[k]   = pow(b, k)\\n'\n    s += 'Ap1[k] = pow(1+a, k)\\n\\n'\n    s += 'C[0] = 1./sqrt(2. * M_PI * Ap1[1])\\n'\n    for i in range(1, order + 1):\n        expr = (coef_C(i, xa, b) / (C0 / (1 + xa) ** i)).simplify()\n        factor = [x.denominator() for x in sympy.Poly(expr).coeffs()]\n        factor = sympy.lcm(factor)\n        expr = (expr * factor).simplify().collect(b, sympy.factor)\n        expr = expr.xreplace({xa + 1: xap1})\n        s += f'C[{i}] = C[0] / ({factor} * Ap1[{i}])\\n'\n        s += f'C[{i}] *= {str(expr)}\\n\\n'\n    import re\n    re_a = re.compile('xa\\\\*\\\\*(\\\\d+)')\n    s = re_a.sub('A[\\\\1]', s)\n    re_b = re.compile('b\\\\*\\\\*(\\\\d+)')\n    s = re_b.sub('B[\\\\1]', s)\n    s = s.replace('xap1', 'Ap1[1]')\n    s = s.replace('xa', 'a')\n    re_digits = re.compile('(\\\\d{10,})')\n    s = re_digits.sub('\\\\1.', s)\n    return s",
            "def asymptotic_series():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Asymptotic expansion for large x.\\n\\n    Phi(a, b, x) ~ Z^(1/2-b) * exp((1+a)/a * Z) * sum_k (-1)^k * C_k / Z^k\\n    Z = (a*x)^(1/(1+a))\\n\\n    Wright (1935) lists the coefficients C_0 and C_1 (he calls them a_0 and\\n    a_1). With slightly different notation, Paris (2017) lists coefficients\\n    c_k up to order k=3.\\n    Paris (2017) uses ZP = (1+a)/a * Z  (ZP = Z of Paris) and\\n    C_k = C_0 * (-a/(1+a))^k * c_k\\n    '\n    order = 8\n\n    class g(sympy.Function):\n        \"\"\"Helper function g according to Wright (1935)\n\n        g(n, rho, v) = (1 + (rho+2)/3 * v + (rho+2)*(rho+3)/(2*3) * v^2 + ...)\n\n        Note: Wright (1935) uses square root of above definition.\n        \"\"\"\n        nargs = 3\n\n        @classmethod\n        def eval(cls, n, rho, v):\n            if not n >= 0:\n                raise ValueError('must have n >= 0')\n            elif n == 0:\n                return 1\n            else:\n                return g(n - 1, rho, v) + gammasimp(gamma(rho + 2 + n) / gamma(rho + 2)) / gammasimp(gamma(3 + n) / gamma(3)) * v ** n\n\n    class coef_C(sympy.Function):\n        \"\"\"Calculate coefficients C_m for integer m.\n\n        C_m is the coefficient of v^(2*m) in the Taylor expansion in v=0 of\n        Gamma(m+1/2)/(2*pi) * (2/(rho+1))^(m+1/2) * (1-v)^(-b)\n            * g(rho, v)^(-m-1/2)\n        \"\"\"\n        nargs = 3\n\n        @classmethod\n        def eval(cls, m, rho, beta):\n            if not m >= 0:\n                raise ValueError('must have m >= 0')\n            v = symbols('v')\n            expression = (1 - v) ** (-beta) * g(2 * m, rho, v) ** (-m - Rational(1, 2))\n            res = expression.diff(v, 2 * m).subs(v, 0) / factorial(2 * m)\n            res = res * (gamma(m + Rational(1, 2)) / (2 * pi) * (2 / (rho + 1)) ** (m + Rational(1, 2)))\n            return res\n    (xa, b, xap1) = symbols('xa b xap1')\n    C0 = coef_C(0, xa, b)\n    s = 'Asymptotic expansion for large x\\n'\n    s += 'Phi(a, b, x) = Z**(1/2-b) * exp((1+a)/a * Z) \\n'\n    s += '               * sum((-1)**k * C[k]/Z**k, k=0..6)\\n\\n'\n    s += 'Z      = pow(a * x, 1/(1+a))\\n'\n    s += 'A[k]   = pow(a, k)\\n'\n    s += 'B[k]   = pow(b, k)\\n'\n    s += 'Ap1[k] = pow(1+a, k)\\n\\n'\n    s += 'C[0] = 1./sqrt(2. * M_PI * Ap1[1])\\n'\n    for i in range(1, order + 1):\n        expr = (coef_C(i, xa, b) / (C0 / (1 + xa) ** i)).simplify()\n        factor = [x.denominator() for x in sympy.Poly(expr).coeffs()]\n        factor = sympy.lcm(factor)\n        expr = (expr * factor).simplify().collect(b, sympy.factor)\n        expr = expr.xreplace({xa + 1: xap1})\n        s += f'C[{i}] = C[0] / ({factor} * Ap1[{i}])\\n'\n        s += f'C[{i}] *= {str(expr)}\\n\\n'\n    import re\n    re_a = re.compile('xa\\\\*\\\\*(\\\\d+)')\n    s = re_a.sub('A[\\\\1]', s)\n    re_b = re.compile('b\\\\*\\\\*(\\\\d+)')\n    s = re_b.sub('B[\\\\1]', s)\n    s = s.replace('xap1', 'Ap1[1]')\n    s = s.replace('xa', 'a')\n    re_digits = re.compile('(\\\\d{10,})')\n    s = re_digits.sub('\\\\1.', s)\n    return s",
            "def asymptotic_series():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Asymptotic expansion for large x.\\n\\n    Phi(a, b, x) ~ Z^(1/2-b) * exp((1+a)/a * Z) * sum_k (-1)^k * C_k / Z^k\\n    Z = (a*x)^(1/(1+a))\\n\\n    Wright (1935) lists the coefficients C_0 and C_1 (he calls them a_0 and\\n    a_1). With slightly different notation, Paris (2017) lists coefficients\\n    c_k up to order k=3.\\n    Paris (2017) uses ZP = (1+a)/a * Z  (ZP = Z of Paris) and\\n    C_k = C_0 * (-a/(1+a))^k * c_k\\n    '\n    order = 8\n\n    class g(sympy.Function):\n        \"\"\"Helper function g according to Wright (1935)\n\n        g(n, rho, v) = (1 + (rho+2)/3 * v + (rho+2)*(rho+3)/(2*3) * v^2 + ...)\n\n        Note: Wright (1935) uses square root of above definition.\n        \"\"\"\n        nargs = 3\n\n        @classmethod\n        def eval(cls, n, rho, v):\n            if not n >= 0:\n                raise ValueError('must have n >= 0')\n            elif n == 0:\n                return 1\n            else:\n                return g(n - 1, rho, v) + gammasimp(gamma(rho + 2 + n) / gamma(rho + 2)) / gammasimp(gamma(3 + n) / gamma(3)) * v ** n\n\n    class coef_C(sympy.Function):\n        \"\"\"Calculate coefficients C_m for integer m.\n\n        C_m is the coefficient of v^(2*m) in the Taylor expansion in v=0 of\n        Gamma(m+1/2)/(2*pi) * (2/(rho+1))^(m+1/2) * (1-v)^(-b)\n            * g(rho, v)^(-m-1/2)\n        \"\"\"\n        nargs = 3\n\n        @classmethod\n        def eval(cls, m, rho, beta):\n            if not m >= 0:\n                raise ValueError('must have m >= 0')\n            v = symbols('v')\n            expression = (1 - v) ** (-beta) * g(2 * m, rho, v) ** (-m - Rational(1, 2))\n            res = expression.diff(v, 2 * m).subs(v, 0) / factorial(2 * m)\n            res = res * (gamma(m + Rational(1, 2)) / (2 * pi) * (2 / (rho + 1)) ** (m + Rational(1, 2)))\n            return res\n    (xa, b, xap1) = symbols('xa b xap1')\n    C0 = coef_C(0, xa, b)\n    s = 'Asymptotic expansion for large x\\n'\n    s += 'Phi(a, b, x) = Z**(1/2-b) * exp((1+a)/a * Z) \\n'\n    s += '               * sum((-1)**k * C[k]/Z**k, k=0..6)\\n\\n'\n    s += 'Z      = pow(a * x, 1/(1+a))\\n'\n    s += 'A[k]   = pow(a, k)\\n'\n    s += 'B[k]   = pow(b, k)\\n'\n    s += 'Ap1[k] = pow(1+a, k)\\n\\n'\n    s += 'C[0] = 1./sqrt(2. * M_PI * Ap1[1])\\n'\n    for i in range(1, order + 1):\n        expr = (coef_C(i, xa, b) / (C0 / (1 + xa) ** i)).simplify()\n        factor = [x.denominator() for x in sympy.Poly(expr).coeffs()]\n        factor = sympy.lcm(factor)\n        expr = (expr * factor).simplify().collect(b, sympy.factor)\n        expr = expr.xreplace({xa + 1: xap1})\n        s += f'C[{i}] = C[0] / ({factor} * Ap1[{i}])\\n'\n        s += f'C[{i}] *= {str(expr)}\\n\\n'\n    import re\n    re_a = re.compile('xa\\\\*\\\\*(\\\\d+)')\n    s = re_a.sub('A[\\\\1]', s)\n    re_b = re.compile('b\\\\*\\\\*(\\\\d+)')\n    s = re_b.sub('B[\\\\1]', s)\n    s = s.replace('xap1', 'Ap1[1]')\n    s = s.replace('xa', 'a')\n    re_digits = re.compile('(\\\\d{10,})')\n    s = re_digits.sub('\\\\1.', s)\n    return s"
        ]
    },
    {
        "func_name": "fp",
        "original": "def fp(eps, a, b, x, phi):\n    \"\"\"Derivative of f w.r.t. phi.\"\"\"\n    eps_a = np.power(1.0 * eps, -a)\n    return eps * np.cos(phi) - a * x * eps_a * np.cos(a * phi) + 1 - b",
        "mutated": [
            "def fp(eps, a, b, x, phi):\n    if False:\n        i = 10\n    'Derivative of f w.r.t. phi.'\n    eps_a = np.power(1.0 * eps, -a)\n    return eps * np.cos(phi) - a * x * eps_a * np.cos(a * phi) + 1 - b",
            "def fp(eps, a, b, x, phi):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Derivative of f w.r.t. phi.'\n    eps_a = np.power(1.0 * eps, -a)\n    return eps * np.cos(phi) - a * x * eps_a * np.cos(a * phi) + 1 - b",
            "def fp(eps, a, b, x, phi):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Derivative of f w.r.t. phi.'\n    eps_a = np.power(1.0 * eps, -a)\n    return eps * np.cos(phi) - a * x * eps_a * np.cos(a * phi) + 1 - b",
            "def fp(eps, a, b, x, phi):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Derivative of f w.r.t. phi.'\n    eps_a = np.power(1.0 * eps, -a)\n    return eps * np.cos(phi) - a * x * eps_a * np.cos(a * phi) + 1 - b",
            "def fp(eps, a, b, x, phi):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Derivative of f w.r.t. phi.'\n    eps_a = np.power(1.0 * eps, -a)\n    return eps * np.cos(phi) - a * x * eps_a * np.cos(a * phi) + 1 - b"
        ]
    },
    {
        "func_name": "arclength",
        "original": "def arclength(eps, a, b, x, epsrel=0.01, limit=100):\n    \"\"\"Compute Arc length of f.\n\n        Note that the arc length of a function f from t0 to t1 is given by\n            int_t0^t1 sqrt(1 + f'(t)^2) dt\n        \"\"\"\n    return quad(lambda phi: np.sqrt(1 + fp(eps, a, b, x, phi) ** 2), 0, np.pi, epsrel=epsrel, limit=100)[0]",
        "mutated": [
            "def arclength(eps, a, b, x, epsrel=0.01, limit=100):\n    if False:\n        i = 10\n    \"Compute Arc length of f.\\n\\n        Note that the arc length of a function f from t0 to t1 is given by\\n            int_t0^t1 sqrt(1 + f'(t)^2) dt\\n        \"\n    return quad(lambda phi: np.sqrt(1 + fp(eps, a, b, x, phi) ** 2), 0, np.pi, epsrel=epsrel, limit=100)[0]",
            "def arclength(eps, a, b, x, epsrel=0.01, limit=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Compute Arc length of f.\\n\\n        Note that the arc length of a function f from t0 to t1 is given by\\n            int_t0^t1 sqrt(1 + f'(t)^2) dt\\n        \"\n    return quad(lambda phi: np.sqrt(1 + fp(eps, a, b, x, phi) ** 2), 0, np.pi, epsrel=epsrel, limit=100)[0]",
            "def arclength(eps, a, b, x, epsrel=0.01, limit=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Compute Arc length of f.\\n\\n        Note that the arc length of a function f from t0 to t1 is given by\\n            int_t0^t1 sqrt(1 + f'(t)^2) dt\\n        \"\n    return quad(lambda phi: np.sqrt(1 + fp(eps, a, b, x, phi) ** 2), 0, np.pi, epsrel=epsrel, limit=100)[0]",
            "def arclength(eps, a, b, x, epsrel=0.01, limit=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Compute Arc length of f.\\n\\n        Note that the arc length of a function f from t0 to t1 is given by\\n            int_t0^t1 sqrt(1 + f'(t)^2) dt\\n        \"\n    return quad(lambda phi: np.sqrt(1 + fp(eps, a, b, x, phi) ** 2), 0, np.pi, epsrel=epsrel, limit=100)[0]",
            "def arclength(eps, a, b, x, epsrel=0.01, limit=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Compute Arc length of f.\\n\\n        Note that the arc length of a function f from t0 to t1 is given by\\n            int_t0^t1 sqrt(1 + f'(t)^2) dt\\n        \"\n    return quad(lambda phi: np.sqrt(1 + fp(eps, a, b, x, phi) ** 2), 0, np.pi, epsrel=epsrel, limit=100)[0]"
        ]
    },
    {
        "func_name": "func",
        "original": "def func(data, A0, A1, A2, A3, A4, A5):\n    \"\"\"Compute parametric function to fit.\"\"\"\n    a = data['a']\n    b = data['b']\n    x = data['x']\n    return A0 * b * np.exp(-0.5 * a) + np.exp(A1 + 1 / (1 + a) * np.log(x) - A2 * np.exp(-A3 * a) + A4 / (1 + np.exp(A5 * a)))",
        "mutated": [
            "def func(data, A0, A1, A2, A3, A4, A5):\n    if False:\n        i = 10\n    'Compute parametric function to fit.'\n    a = data['a']\n    b = data['b']\n    x = data['x']\n    return A0 * b * np.exp(-0.5 * a) + np.exp(A1 + 1 / (1 + a) * np.log(x) - A2 * np.exp(-A3 * a) + A4 / (1 + np.exp(A5 * a)))",
            "def func(data, A0, A1, A2, A3, A4, A5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute parametric function to fit.'\n    a = data['a']\n    b = data['b']\n    x = data['x']\n    return A0 * b * np.exp(-0.5 * a) + np.exp(A1 + 1 / (1 + a) * np.log(x) - A2 * np.exp(-A3 * a) + A4 / (1 + np.exp(A5 * a)))",
            "def func(data, A0, A1, A2, A3, A4, A5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute parametric function to fit.'\n    a = data['a']\n    b = data['b']\n    x = data['x']\n    return A0 * b * np.exp(-0.5 * a) + np.exp(A1 + 1 / (1 + a) * np.log(x) - A2 * np.exp(-A3 * a) + A4 / (1 + np.exp(A5 * a)))",
            "def func(data, A0, A1, A2, A3, A4, A5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute parametric function to fit.'\n    a = data['a']\n    b = data['b']\n    x = data['x']\n    return A0 * b * np.exp(-0.5 * a) + np.exp(A1 + 1 / (1 + a) * np.log(x) - A2 * np.exp(-A3 * a) + A4 / (1 + np.exp(A5 * a)))",
            "def func(data, A0, A1, A2, A3, A4, A5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute parametric function to fit.'\n    a = data['a']\n    b = data['b']\n    x = data['x']\n    return A0 * b * np.exp(-0.5 * a) + np.exp(A1 + 1 / (1 + a) * np.log(x) - A2 * np.exp(-A3 * a) + A4 / (1 + np.exp(A5 * a)))"
        ]
    },
    {
        "func_name": "optimal_epsilon_integral",
        "original": "def optimal_epsilon_integral():\n    \"\"\"Fit optimal choice of epsilon for integral representation.\n\n    The integrand of\n        int_0^pi P(eps, a, b, x, phi) * dphi\n    can exhibit oscillatory behaviour. It stems from the cosine of P and can be\n    minimized by minimizing the arc length of the argument\n        f(phi) = eps * sin(phi) - x * eps^(-a) * sin(a * phi) + (1 - b) * phi\n    of cos(f(phi)).\n    We minimize the arc length in eps for a grid of values (a, b, x) and fit a\n    parametric function to it.\n    \"\"\"\n\n    def fp(eps, a, b, x, phi):\n        \"\"\"Derivative of f w.r.t. phi.\"\"\"\n        eps_a = np.power(1.0 * eps, -a)\n        return eps * np.cos(phi) - a * x * eps_a * np.cos(a * phi) + 1 - b\n\n    def arclength(eps, a, b, x, epsrel=0.01, limit=100):\n        \"\"\"Compute Arc length of f.\n\n        Note that the arc length of a function f from t0 to t1 is given by\n            int_t0^t1 sqrt(1 + f'(t)^2) dt\n        \"\"\"\n        return quad(lambda phi: np.sqrt(1 + fp(eps, a, b, x, phi) ** 2), 0, np.pi, epsrel=epsrel, limit=100)[0]\n    data_a = [0.001, 0.1, 0.5, 0.9, 1, 2, 4, 5, 6, 8]\n    data_b = [0, 1, 4, 7, 10]\n    data_x = [1, 1.5, 2, 4, 10, 20, 50, 100, 200, 500, 1000.0, 5000.0, 10000.0]\n    (data_a, data_b, data_x) = np.meshgrid(data_a, data_b, data_x)\n    (data_a, data_b, data_x) = (data_a.flatten(), data_b.flatten(), data_x.flatten())\n    best_eps = []\n    for i in range(data_x.size):\n        best_eps.append(minimize_scalar(lambda eps: arclength(eps, data_a[i], data_b[i], data_x[i]), bounds=(0.001, 1000), method='Bounded', options={'xatol': 0.001}).x)\n    best_eps = np.array(best_eps)\n    df = {'a': data_a, 'b': data_b, 'x': data_x, 'eps': best_eps}\n\n    def func(data, A0, A1, A2, A3, A4, A5):\n        \"\"\"Compute parametric function to fit.\"\"\"\n        a = data['a']\n        b = data['b']\n        x = data['x']\n        return A0 * b * np.exp(-0.5 * a) + np.exp(A1 + 1 / (1 + a) * np.log(x) - A2 * np.exp(-A3 * a) + A4 / (1 + np.exp(A5 * a)))\n    func_params = list(curve_fit(func, df, df['eps'], method='trf')[0])\n    s = 'Fit optimal eps for integrand P via minimal arc length\\n'\n    s += 'with parametric function:\\n'\n    s += 'optimal_eps = (A0 * b * exp(-a/2) + exp(A1 + 1 / (1 + a) * log(x)\\n'\n    s += '              - A2 * exp(-A3 * a) + A4 / (1 + exp(A5 * a)))\\n\\n'\n    s += 'Fitted parameters A0 to A5 are:\\n'\n    s += ', '.join([f'{x:.5g}' for x in func_params])\n    return s",
        "mutated": [
            "def optimal_epsilon_integral():\n    if False:\n        i = 10\n    'Fit optimal choice of epsilon for integral representation.\\n\\n    The integrand of\\n        int_0^pi P(eps, a, b, x, phi) * dphi\\n    can exhibit oscillatory behaviour. It stems from the cosine of P and can be\\n    minimized by minimizing the arc length of the argument\\n        f(phi) = eps * sin(phi) - x * eps^(-a) * sin(a * phi) + (1 - b) * phi\\n    of cos(f(phi)).\\n    We minimize the arc length in eps for a grid of values (a, b, x) and fit a\\n    parametric function to it.\\n    '\n\n    def fp(eps, a, b, x, phi):\n        \"\"\"Derivative of f w.r.t. phi.\"\"\"\n        eps_a = np.power(1.0 * eps, -a)\n        return eps * np.cos(phi) - a * x * eps_a * np.cos(a * phi) + 1 - b\n\n    def arclength(eps, a, b, x, epsrel=0.01, limit=100):\n        \"\"\"Compute Arc length of f.\n\n        Note that the arc length of a function f from t0 to t1 is given by\n            int_t0^t1 sqrt(1 + f'(t)^2) dt\n        \"\"\"\n        return quad(lambda phi: np.sqrt(1 + fp(eps, a, b, x, phi) ** 2), 0, np.pi, epsrel=epsrel, limit=100)[0]\n    data_a = [0.001, 0.1, 0.5, 0.9, 1, 2, 4, 5, 6, 8]\n    data_b = [0, 1, 4, 7, 10]\n    data_x = [1, 1.5, 2, 4, 10, 20, 50, 100, 200, 500, 1000.0, 5000.0, 10000.0]\n    (data_a, data_b, data_x) = np.meshgrid(data_a, data_b, data_x)\n    (data_a, data_b, data_x) = (data_a.flatten(), data_b.flatten(), data_x.flatten())\n    best_eps = []\n    for i in range(data_x.size):\n        best_eps.append(minimize_scalar(lambda eps: arclength(eps, data_a[i], data_b[i], data_x[i]), bounds=(0.001, 1000), method='Bounded', options={'xatol': 0.001}).x)\n    best_eps = np.array(best_eps)\n    df = {'a': data_a, 'b': data_b, 'x': data_x, 'eps': best_eps}\n\n    def func(data, A0, A1, A2, A3, A4, A5):\n        \"\"\"Compute parametric function to fit.\"\"\"\n        a = data['a']\n        b = data['b']\n        x = data['x']\n        return A0 * b * np.exp(-0.5 * a) + np.exp(A1 + 1 / (1 + a) * np.log(x) - A2 * np.exp(-A3 * a) + A4 / (1 + np.exp(A5 * a)))\n    func_params = list(curve_fit(func, df, df['eps'], method='trf')[0])\n    s = 'Fit optimal eps for integrand P via minimal arc length\\n'\n    s += 'with parametric function:\\n'\n    s += 'optimal_eps = (A0 * b * exp(-a/2) + exp(A1 + 1 / (1 + a) * log(x)\\n'\n    s += '              - A2 * exp(-A3 * a) + A4 / (1 + exp(A5 * a)))\\n\\n'\n    s += 'Fitted parameters A0 to A5 are:\\n'\n    s += ', '.join([f'{x:.5g}' for x in func_params])\n    return s",
            "def optimal_epsilon_integral():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Fit optimal choice of epsilon for integral representation.\\n\\n    The integrand of\\n        int_0^pi P(eps, a, b, x, phi) * dphi\\n    can exhibit oscillatory behaviour. It stems from the cosine of P and can be\\n    minimized by minimizing the arc length of the argument\\n        f(phi) = eps * sin(phi) - x * eps^(-a) * sin(a * phi) + (1 - b) * phi\\n    of cos(f(phi)).\\n    We minimize the arc length in eps for a grid of values (a, b, x) and fit a\\n    parametric function to it.\\n    '\n\n    def fp(eps, a, b, x, phi):\n        \"\"\"Derivative of f w.r.t. phi.\"\"\"\n        eps_a = np.power(1.0 * eps, -a)\n        return eps * np.cos(phi) - a * x * eps_a * np.cos(a * phi) + 1 - b\n\n    def arclength(eps, a, b, x, epsrel=0.01, limit=100):\n        \"\"\"Compute Arc length of f.\n\n        Note that the arc length of a function f from t0 to t1 is given by\n            int_t0^t1 sqrt(1 + f'(t)^2) dt\n        \"\"\"\n        return quad(lambda phi: np.sqrt(1 + fp(eps, a, b, x, phi) ** 2), 0, np.pi, epsrel=epsrel, limit=100)[0]\n    data_a = [0.001, 0.1, 0.5, 0.9, 1, 2, 4, 5, 6, 8]\n    data_b = [0, 1, 4, 7, 10]\n    data_x = [1, 1.5, 2, 4, 10, 20, 50, 100, 200, 500, 1000.0, 5000.0, 10000.0]\n    (data_a, data_b, data_x) = np.meshgrid(data_a, data_b, data_x)\n    (data_a, data_b, data_x) = (data_a.flatten(), data_b.flatten(), data_x.flatten())\n    best_eps = []\n    for i in range(data_x.size):\n        best_eps.append(minimize_scalar(lambda eps: arclength(eps, data_a[i], data_b[i], data_x[i]), bounds=(0.001, 1000), method='Bounded', options={'xatol': 0.001}).x)\n    best_eps = np.array(best_eps)\n    df = {'a': data_a, 'b': data_b, 'x': data_x, 'eps': best_eps}\n\n    def func(data, A0, A1, A2, A3, A4, A5):\n        \"\"\"Compute parametric function to fit.\"\"\"\n        a = data['a']\n        b = data['b']\n        x = data['x']\n        return A0 * b * np.exp(-0.5 * a) + np.exp(A1 + 1 / (1 + a) * np.log(x) - A2 * np.exp(-A3 * a) + A4 / (1 + np.exp(A5 * a)))\n    func_params = list(curve_fit(func, df, df['eps'], method='trf')[0])\n    s = 'Fit optimal eps for integrand P via minimal arc length\\n'\n    s += 'with parametric function:\\n'\n    s += 'optimal_eps = (A0 * b * exp(-a/2) + exp(A1 + 1 / (1 + a) * log(x)\\n'\n    s += '              - A2 * exp(-A3 * a) + A4 / (1 + exp(A5 * a)))\\n\\n'\n    s += 'Fitted parameters A0 to A5 are:\\n'\n    s += ', '.join([f'{x:.5g}' for x in func_params])\n    return s",
            "def optimal_epsilon_integral():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Fit optimal choice of epsilon for integral representation.\\n\\n    The integrand of\\n        int_0^pi P(eps, a, b, x, phi) * dphi\\n    can exhibit oscillatory behaviour. It stems from the cosine of P and can be\\n    minimized by minimizing the arc length of the argument\\n        f(phi) = eps * sin(phi) - x * eps^(-a) * sin(a * phi) + (1 - b) * phi\\n    of cos(f(phi)).\\n    We minimize the arc length in eps for a grid of values (a, b, x) and fit a\\n    parametric function to it.\\n    '\n\n    def fp(eps, a, b, x, phi):\n        \"\"\"Derivative of f w.r.t. phi.\"\"\"\n        eps_a = np.power(1.0 * eps, -a)\n        return eps * np.cos(phi) - a * x * eps_a * np.cos(a * phi) + 1 - b\n\n    def arclength(eps, a, b, x, epsrel=0.01, limit=100):\n        \"\"\"Compute Arc length of f.\n\n        Note that the arc length of a function f from t0 to t1 is given by\n            int_t0^t1 sqrt(1 + f'(t)^2) dt\n        \"\"\"\n        return quad(lambda phi: np.sqrt(1 + fp(eps, a, b, x, phi) ** 2), 0, np.pi, epsrel=epsrel, limit=100)[0]\n    data_a = [0.001, 0.1, 0.5, 0.9, 1, 2, 4, 5, 6, 8]\n    data_b = [0, 1, 4, 7, 10]\n    data_x = [1, 1.5, 2, 4, 10, 20, 50, 100, 200, 500, 1000.0, 5000.0, 10000.0]\n    (data_a, data_b, data_x) = np.meshgrid(data_a, data_b, data_x)\n    (data_a, data_b, data_x) = (data_a.flatten(), data_b.flatten(), data_x.flatten())\n    best_eps = []\n    for i in range(data_x.size):\n        best_eps.append(minimize_scalar(lambda eps: arclength(eps, data_a[i], data_b[i], data_x[i]), bounds=(0.001, 1000), method='Bounded', options={'xatol': 0.001}).x)\n    best_eps = np.array(best_eps)\n    df = {'a': data_a, 'b': data_b, 'x': data_x, 'eps': best_eps}\n\n    def func(data, A0, A1, A2, A3, A4, A5):\n        \"\"\"Compute parametric function to fit.\"\"\"\n        a = data['a']\n        b = data['b']\n        x = data['x']\n        return A0 * b * np.exp(-0.5 * a) + np.exp(A1 + 1 / (1 + a) * np.log(x) - A2 * np.exp(-A3 * a) + A4 / (1 + np.exp(A5 * a)))\n    func_params = list(curve_fit(func, df, df['eps'], method='trf')[0])\n    s = 'Fit optimal eps for integrand P via minimal arc length\\n'\n    s += 'with parametric function:\\n'\n    s += 'optimal_eps = (A0 * b * exp(-a/2) + exp(A1 + 1 / (1 + a) * log(x)\\n'\n    s += '              - A2 * exp(-A3 * a) + A4 / (1 + exp(A5 * a)))\\n\\n'\n    s += 'Fitted parameters A0 to A5 are:\\n'\n    s += ', '.join([f'{x:.5g}' for x in func_params])\n    return s",
            "def optimal_epsilon_integral():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Fit optimal choice of epsilon for integral representation.\\n\\n    The integrand of\\n        int_0^pi P(eps, a, b, x, phi) * dphi\\n    can exhibit oscillatory behaviour. It stems from the cosine of P and can be\\n    minimized by minimizing the arc length of the argument\\n        f(phi) = eps * sin(phi) - x * eps^(-a) * sin(a * phi) + (1 - b) * phi\\n    of cos(f(phi)).\\n    We minimize the arc length in eps for a grid of values (a, b, x) and fit a\\n    parametric function to it.\\n    '\n\n    def fp(eps, a, b, x, phi):\n        \"\"\"Derivative of f w.r.t. phi.\"\"\"\n        eps_a = np.power(1.0 * eps, -a)\n        return eps * np.cos(phi) - a * x * eps_a * np.cos(a * phi) + 1 - b\n\n    def arclength(eps, a, b, x, epsrel=0.01, limit=100):\n        \"\"\"Compute Arc length of f.\n\n        Note that the arc length of a function f from t0 to t1 is given by\n            int_t0^t1 sqrt(1 + f'(t)^2) dt\n        \"\"\"\n        return quad(lambda phi: np.sqrt(1 + fp(eps, a, b, x, phi) ** 2), 0, np.pi, epsrel=epsrel, limit=100)[0]\n    data_a = [0.001, 0.1, 0.5, 0.9, 1, 2, 4, 5, 6, 8]\n    data_b = [0, 1, 4, 7, 10]\n    data_x = [1, 1.5, 2, 4, 10, 20, 50, 100, 200, 500, 1000.0, 5000.0, 10000.0]\n    (data_a, data_b, data_x) = np.meshgrid(data_a, data_b, data_x)\n    (data_a, data_b, data_x) = (data_a.flatten(), data_b.flatten(), data_x.flatten())\n    best_eps = []\n    for i in range(data_x.size):\n        best_eps.append(minimize_scalar(lambda eps: arclength(eps, data_a[i], data_b[i], data_x[i]), bounds=(0.001, 1000), method='Bounded', options={'xatol': 0.001}).x)\n    best_eps = np.array(best_eps)\n    df = {'a': data_a, 'b': data_b, 'x': data_x, 'eps': best_eps}\n\n    def func(data, A0, A1, A2, A3, A4, A5):\n        \"\"\"Compute parametric function to fit.\"\"\"\n        a = data['a']\n        b = data['b']\n        x = data['x']\n        return A0 * b * np.exp(-0.5 * a) + np.exp(A1 + 1 / (1 + a) * np.log(x) - A2 * np.exp(-A3 * a) + A4 / (1 + np.exp(A5 * a)))\n    func_params = list(curve_fit(func, df, df['eps'], method='trf')[0])\n    s = 'Fit optimal eps for integrand P via minimal arc length\\n'\n    s += 'with parametric function:\\n'\n    s += 'optimal_eps = (A0 * b * exp(-a/2) + exp(A1 + 1 / (1 + a) * log(x)\\n'\n    s += '              - A2 * exp(-A3 * a) + A4 / (1 + exp(A5 * a)))\\n\\n'\n    s += 'Fitted parameters A0 to A5 are:\\n'\n    s += ', '.join([f'{x:.5g}' for x in func_params])\n    return s",
            "def optimal_epsilon_integral():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Fit optimal choice of epsilon for integral representation.\\n\\n    The integrand of\\n        int_0^pi P(eps, a, b, x, phi) * dphi\\n    can exhibit oscillatory behaviour. It stems from the cosine of P and can be\\n    minimized by minimizing the arc length of the argument\\n        f(phi) = eps * sin(phi) - x * eps^(-a) * sin(a * phi) + (1 - b) * phi\\n    of cos(f(phi)).\\n    We minimize the arc length in eps for a grid of values (a, b, x) and fit a\\n    parametric function to it.\\n    '\n\n    def fp(eps, a, b, x, phi):\n        \"\"\"Derivative of f w.r.t. phi.\"\"\"\n        eps_a = np.power(1.0 * eps, -a)\n        return eps * np.cos(phi) - a * x * eps_a * np.cos(a * phi) + 1 - b\n\n    def arclength(eps, a, b, x, epsrel=0.01, limit=100):\n        \"\"\"Compute Arc length of f.\n\n        Note that the arc length of a function f from t0 to t1 is given by\n            int_t0^t1 sqrt(1 + f'(t)^2) dt\n        \"\"\"\n        return quad(lambda phi: np.sqrt(1 + fp(eps, a, b, x, phi) ** 2), 0, np.pi, epsrel=epsrel, limit=100)[0]\n    data_a = [0.001, 0.1, 0.5, 0.9, 1, 2, 4, 5, 6, 8]\n    data_b = [0, 1, 4, 7, 10]\n    data_x = [1, 1.5, 2, 4, 10, 20, 50, 100, 200, 500, 1000.0, 5000.0, 10000.0]\n    (data_a, data_b, data_x) = np.meshgrid(data_a, data_b, data_x)\n    (data_a, data_b, data_x) = (data_a.flatten(), data_b.flatten(), data_x.flatten())\n    best_eps = []\n    for i in range(data_x.size):\n        best_eps.append(minimize_scalar(lambda eps: arclength(eps, data_a[i], data_b[i], data_x[i]), bounds=(0.001, 1000), method='Bounded', options={'xatol': 0.001}).x)\n    best_eps = np.array(best_eps)\n    df = {'a': data_a, 'b': data_b, 'x': data_x, 'eps': best_eps}\n\n    def func(data, A0, A1, A2, A3, A4, A5):\n        \"\"\"Compute parametric function to fit.\"\"\"\n        a = data['a']\n        b = data['b']\n        x = data['x']\n        return A0 * b * np.exp(-0.5 * a) + np.exp(A1 + 1 / (1 + a) * np.log(x) - A2 * np.exp(-A3 * a) + A4 / (1 + np.exp(A5 * a)))\n    func_params = list(curve_fit(func, df, df['eps'], method='trf')[0])\n    s = 'Fit optimal eps for integrand P via minimal arc length\\n'\n    s += 'with parametric function:\\n'\n    s += 'optimal_eps = (A0 * b * exp(-a/2) + exp(A1 + 1 / (1 + a) * log(x)\\n'\n    s += '              - A2 * exp(-A3 * a) + A4 / (1 + exp(A5 * a)))\\n\\n'\n    s += 'Fitted parameters A0 to A5 are:\\n'\n    s += ', '.join([f'{x:.5g}' for x in func_params])\n    return s"
        ]
    },
    {
        "func_name": "main",
        "original": "def main():\n    t0 = time()\n    parser = ArgumentParser(description=__doc__, formatter_class=RawTextHelpFormatter)\n    parser.add_argument('action', type=int, choices=[1, 2, 3, 4], help='chose what expansion to precompute\\n1 : Series for small a\\n2 : Series for small a and small b\\n3 : Asymptotic series for large x\\n    This may take some time (>4h).\\n4 : Fit optimal eps for integral representation.')\n    args = parser.parse_args()\n    switch = {1: lambda : print(series_small_a()), 2: lambda : print(series_small_a_small_b()), 3: lambda : print(asymptotic_series()), 4: lambda : print(optimal_epsilon_integral())}\n    switch.get(args.action, lambda : print('Invalid input.'))()\n    print(f'\\n{(time() - t0) / 60:.1f} minutes elapsed.\\n')",
        "mutated": [
            "def main():\n    if False:\n        i = 10\n    t0 = time()\n    parser = ArgumentParser(description=__doc__, formatter_class=RawTextHelpFormatter)\n    parser.add_argument('action', type=int, choices=[1, 2, 3, 4], help='chose what expansion to precompute\\n1 : Series for small a\\n2 : Series for small a and small b\\n3 : Asymptotic series for large x\\n    This may take some time (>4h).\\n4 : Fit optimal eps for integral representation.')\n    args = parser.parse_args()\n    switch = {1: lambda : print(series_small_a()), 2: lambda : print(series_small_a_small_b()), 3: lambda : print(asymptotic_series()), 4: lambda : print(optimal_epsilon_integral())}\n    switch.get(args.action, lambda : print('Invalid input.'))()\n    print(f'\\n{(time() - t0) / 60:.1f} minutes elapsed.\\n')",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    t0 = time()\n    parser = ArgumentParser(description=__doc__, formatter_class=RawTextHelpFormatter)\n    parser.add_argument('action', type=int, choices=[1, 2, 3, 4], help='chose what expansion to precompute\\n1 : Series for small a\\n2 : Series for small a and small b\\n3 : Asymptotic series for large x\\n    This may take some time (>4h).\\n4 : Fit optimal eps for integral representation.')\n    args = parser.parse_args()\n    switch = {1: lambda : print(series_small_a()), 2: lambda : print(series_small_a_small_b()), 3: lambda : print(asymptotic_series()), 4: lambda : print(optimal_epsilon_integral())}\n    switch.get(args.action, lambda : print('Invalid input.'))()\n    print(f'\\n{(time() - t0) / 60:.1f} minutes elapsed.\\n')",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    t0 = time()\n    parser = ArgumentParser(description=__doc__, formatter_class=RawTextHelpFormatter)\n    parser.add_argument('action', type=int, choices=[1, 2, 3, 4], help='chose what expansion to precompute\\n1 : Series for small a\\n2 : Series for small a and small b\\n3 : Asymptotic series for large x\\n    This may take some time (>4h).\\n4 : Fit optimal eps for integral representation.')\n    args = parser.parse_args()\n    switch = {1: lambda : print(series_small_a()), 2: lambda : print(series_small_a_small_b()), 3: lambda : print(asymptotic_series()), 4: lambda : print(optimal_epsilon_integral())}\n    switch.get(args.action, lambda : print('Invalid input.'))()\n    print(f'\\n{(time() - t0) / 60:.1f} minutes elapsed.\\n')",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    t0 = time()\n    parser = ArgumentParser(description=__doc__, formatter_class=RawTextHelpFormatter)\n    parser.add_argument('action', type=int, choices=[1, 2, 3, 4], help='chose what expansion to precompute\\n1 : Series for small a\\n2 : Series for small a and small b\\n3 : Asymptotic series for large x\\n    This may take some time (>4h).\\n4 : Fit optimal eps for integral representation.')\n    args = parser.parse_args()\n    switch = {1: lambda : print(series_small_a()), 2: lambda : print(series_small_a_small_b()), 3: lambda : print(asymptotic_series()), 4: lambda : print(optimal_epsilon_integral())}\n    switch.get(args.action, lambda : print('Invalid input.'))()\n    print(f'\\n{(time() - t0) / 60:.1f} minutes elapsed.\\n')",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    t0 = time()\n    parser = ArgumentParser(description=__doc__, formatter_class=RawTextHelpFormatter)\n    parser.add_argument('action', type=int, choices=[1, 2, 3, 4], help='chose what expansion to precompute\\n1 : Series for small a\\n2 : Series for small a and small b\\n3 : Asymptotic series for large x\\n    This may take some time (>4h).\\n4 : Fit optimal eps for integral representation.')\n    args = parser.parse_args()\n    switch = {1: lambda : print(series_small_a()), 2: lambda : print(series_small_a_small_b()), 3: lambda : print(asymptotic_series()), 4: lambda : print(optimal_epsilon_integral())}\n    switch.get(args.action, lambda : print('Invalid input.'))()\n    print(f'\\n{(time() - t0) / 60:.1f} minutes elapsed.\\n')"
        ]
    }
]