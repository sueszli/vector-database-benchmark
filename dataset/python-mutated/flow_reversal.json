[
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    super(FlowReversal, self).__init__()",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    super(FlowReversal, self).__init__()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(FlowReversal, self).__init__()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(FlowReversal, self).__init__()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(FlowReversal, self).__init__()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(FlowReversal, self).__init__()"
        ]
    },
    {
        "func_name": "forward",
        "original": "def forward(self, img, flo):\n    \"\"\"\n            -img: image (N, C, H, W)\n            -flo: optical flow (N, 2, H, W)\n            elements of flo is in [0, H] and [0, W] for dx, dy\n\n        \"\"\"\n    (N, C, _, _) = img.size()\n    y = flo[:, 0:1, :]\n    x = flo[:, 1:2, :, :]\n    x = x.repeat(1, C, 1, 1)\n    y = y.repeat(1, C, 1, 1)\n    x1 = torch.floor(x)\n    x2 = x1 + 1\n    y1 = torch.floor(y)\n    y2 = y1 + 1\n    (w11, w12, w21, w22) = self.get_gaussian_weights(x, y, x1, x2, y1, y2)\n    (img11, o11) = self.sample_one(img, x1, y1, w11)\n    (img12, o12) = self.sample_one(img, x1, y2, w12)\n    (img21, o21) = self.sample_one(img, x2, y1, w21)\n    (img22, o22) = self.sample_one(img, x2, y2, w22)\n    imgw = img11 + img12 + img21 + img22\n    o = o11 + o12 + o21 + o22\n    return (imgw, o)",
        "mutated": [
            "def forward(self, img, flo):\n    if False:\n        i = 10\n    '\\n            -img: image (N, C, H, W)\\n            -flo: optical flow (N, 2, H, W)\\n            elements of flo is in [0, H] and [0, W] for dx, dy\\n\\n        '\n    (N, C, _, _) = img.size()\n    y = flo[:, 0:1, :]\n    x = flo[:, 1:2, :, :]\n    x = x.repeat(1, C, 1, 1)\n    y = y.repeat(1, C, 1, 1)\n    x1 = torch.floor(x)\n    x2 = x1 + 1\n    y1 = torch.floor(y)\n    y2 = y1 + 1\n    (w11, w12, w21, w22) = self.get_gaussian_weights(x, y, x1, x2, y1, y2)\n    (img11, o11) = self.sample_one(img, x1, y1, w11)\n    (img12, o12) = self.sample_one(img, x1, y2, w12)\n    (img21, o21) = self.sample_one(img, x2, y1, w21)\n    (img22, o22) = self.sample_one(img, x2, y2, w22)\n    imgw = img11 + img12 + img21 + img22\n    o = o11 + o12 + o21 + o22\n    return (imgw, o)",
            "def forward(self, img, flo):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n            -img: image (N, C, H, W)\\n            -flo: optical flow (N, 2, H, W)\\n            elements of flo is in [0, H] and [0, W] for dx, dy\\n\\n        '\n    (N, C, _, _) = img.size()\n    y = flo[:, 0:1, :]\n    x = flo[:, 1:2, :, :]\n    x = x.repeat(1, C, 1, 1)\n    y = y.repeat(1, C, 1, 1)\n    x1 = torch.floor(x)\n    x2 = x1 + 1\n    y1 = torch.floor(y)\n    y2 = y1 + 1\n    (w11, w12, w21, w22) = self.get_gaussian_weights(x, y, x1, x2, y1, y2)\n    (img11, o11) = self.sample_one(img, x1, y1, w11)\n    (img12, o12) = self.sample_one(img, x1, y2, w12)\n    (img21, o21) = self.sample_one(img, x2, y1, w21)\n    (img22, o22) = self.sample_one(img, x2, y2, w22)\n    imgw = img11 + img12 + img21 + img22\n    o = o11 + o12 + o21 + o22\n    return (imgw, o)",
            "def forward(self, img, flo):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n            -img: image (N, C, H, W)\\n            -flo: optical flow (N, 2, H, W)\\n            elements of flo is in [0, H] and [0, W] for dx, dy\\n\\n        '\n    (N, C, _, _) = img.size()\n    y = flo[:, 0:1, :]\n    x = flo[:, 1:2, :, :]\n    x = x.repeat(1, C, 1, 1)\n    y = y.repeat(1, C, 1, 1)\n    x1 = torch.floor(x)\n    x2 = x1 + 1\n    y1 = torch.floor(y)\n    y2 = y1 + 1\n    (w11, w12, w21, w22) = self.get_gaussian_weights(x, y, x1, x2, y1, y2)\n    (img11, o11) = self.sample_one(img, x1, y1, w11)\n    (img12, o12) = self.sample_one(img, x1, y2, w12)\n    (img21, o21) = self.sample_one(img, x2, y1, w21)\n    (img22, o22) = self.sample_one(img, x2, y2, w22)\n    imgw = img11 + img12 + img21 + img22\n    o = o11 + o12 + o21 + o22\n    return (imgw, o)",
            "def forward(self, img, flo):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n            -img: image (N, C, H, W)\\n            -flo: optical flow (N, 2, H, W)\\n            elements of flo is in [0, H] and [0, W] for dx, dy\\n\\n        '\n    (N, C, _, _) = img.size()\n    y = flo[:, 0:1, :]\n    x = flo[:, 1:2, :, :]\n    x = x.repeat(1, C, 1, 1)\n    y = y.repeat(1, C, 1, 1)\n    x1 = torch.floor(x)\n    x2 = x1 + 1\n    y1 = torch.floor(y)\n    y2 = y1 + 1\n    (w11, w12, w21, w22) = self.get_gaussian_weights(x, y, x1, x2, y1, y2)\n    (img11, o11) = self.sample_one(img, x1, y1, w11)\n    (img12, o12) = self.sample_one(img, x1, y2, w12)\n    (img21, o21) = self.sample_one(img, x2, y1, w21)\n    (img22, o22) = self.sample_one(img, x2, y2, w22)\n    imgw = img11 + img12 + img21 + img22\n    o = o11 + o12 + o21 + o22\n    return (imgw, o)",
            "def forward(self, img, flo):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n            -img: image (N, C, H, W)\\n            -flo: optical flow (N, 2, H, W)\\n            elements of flo is in [0, H] and [0, W] for dx, dy\\n\\n        '\n    (N, C, _, _) = img.size()\n    y = flo[:, 0:1, :]\n    x = flo[:, 1:2, :, :]\n    x = x.repeat(1, C, 1, 1)\n    y = y.repeat(1, C, 1, 1)\n    x1 = torch.floor(x)\n    x2 = x1 + 1\n    y1 = torch.floor(y)\n    y2 = y1 + 1\n    (w11, w12, w21, w22) = self.get_gaussian_weights(x, y, x1, x2, y1, y2)\n    (img11, o11) = self.sample_one(img, x1, y1, w11)\n    (img12, o12) = self.sample_one(img, x1, y2, w12)\n    (img21, o21) = self.sample_one(img, x2, y1, w21)\n    (img22, o22) = self.sample_one(img, x2, y2, w22)\n    imgw = img11 + img12 + img21 + img22\n    o = o11 + o12 + o21 + o22\n    return (imgw, o)"
        ]
    },
    {
        "func_name": "get_gaussian_weights",
        "original": "def get_gaussian_weights(self, x, y, x1, x2, y1, y2):\n    w11 = torch.exp(-((x - x1) ** 2 + (y - y1) ** 2))\n    w12 = torch.exp(-((x - x1) ** 2 + (y - y2) ** 2))\n    w21 = torch.exp(-((x - x2) ** 2 + (y - y1) ** 2))\n    w22 = torch.exp(-((x - x2) ** 2 + (y - y2) ** 2))\n    return (w11, w12, w21, w22)",
        "mutated": [
            "def get_gaussian_weights(self, x, y, x1, x2, y1, y2):\n    if False:\n        i = 10\n    w11 = torch.exp(-((x - x1) ** 2 + (y - y1) ** 2))\n    w12 = torch.exp(-((x - x1) ** 2 + (y - y2) ** 2))\n    w21 = torch.exp(-((x - x2) ** 2 + (y - y1) ** 2))\n    w22 = torch.exp(-((x - x2) ** 2 + (y - y2) ** 2))\n    return (w11, w12, w21, w22)",
            "def get_gaussian_weights(self, x, y, x1, x2, y1, y2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    w11 = torch.exp(-((x - x1) ** 2 + (y - y1) ** 2))\n    w12 = torch.exp(-((x - x1) ** 2 + (y - y2) ** 2))\n    w21 = torch.exp(-((x - x2) ** 2 + (y - y1) ** 2))\n    w22 = torch.exp(-((x - x2) ** 2 + (y - y2) ** 2))\n    return (w11, w12, w21, w22)",
            "def get_gaussian_weights(self, x, y, x1, x2, y1, y2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    w11 = torch.exp(-((x - x1) ** 2 + (y - y1) ** 2))\n    w12 = torch.exp(-((x - x1) ** 2 + (y - y2) ** 2))\n    w21 = torch.exp(-((x - x2) ** 2 + (y - y1) ** 2))\n    w22 = torch.exp(-((x - x2) ** 2 + (y - y2) ** 2))\n    return (w11, w12, w21, w22)",
            "def get_gaussian_weights(self, x, y, x1, x2, y1, y2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    w11 = torch.exp(-((x - x1) ** 2 + (y - y1) ** 2))\n    w12 = torch.exp(-((x - x1) ** 2 + (y - y2) ** 2))\n    w21 = torch.exp(-((x - x2) ** 2 + (y - y1) ** 2))\n    w22 = torch.exp(-((x - x2) ** 2 + (y - y2) ** 2))\n    return (w11, w12, w21, w22)",
            "def get_gaussian_weights(self, x, y, x1, x2, y1, y2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    w11 = torch.exp(-((x - x1) ** 2 + (y - y1) ** 2))\n    w12 = torch.exp(-((x - x1) ** 2 + (y - y2) ** 2))\n    w21 = torch.exp(-((x - x2) ** 2 + (y - y1) ** 2))\n    w22 = torch.exp(-((x - x2) ** 2 + (y - y2) ** 2))\n    return (w11, w12, w21, w22)"
        ]
    },
    {
        "func_name": "sample_one",
        "original": "def sample_one(self, img, shiftx, shifty, weight):\n    \"\"\"\n        Input:\n            -img (N, C, H, W)\n            -shiftx, shifty (N, c, H, W)\n        \"\"\"\n    (N, C, H, W) = img.size()\n    flat_shiftx = shiftx.view(-1)\n    flat_shifty = shifty.view(-1)\n    flat_basex = torch.arange(0, H, requires_grad=False).view(-1, 1)[None, None].cuda().long().repeat(N, C, 1, W).view(-1)\n    flat_basey = torch.arange(0, W, requires_grad=False).view(1, -1)[None, None].cuda().long().repeat(N, C, H, 1).view(-1)\n    flat_weight = weight.view(-1)\n    flat_img = img.view(-1)\n    idxn = torch.arange(0, N, requires_grad=False).view(N, 1, 1, 1).long().cuda().repeat(1, C, H, W).view(-1)\n    idxc = torch.arange(0, C, requires_grad=False).view(1, C, 1, 1).long().cuda().repeat(N, 1, H, W).view(-1)\n    idxx = flat_shiftx.long() + flat_basex\n    idxy = flat_shifty.long() + flat_basey\n    mask = idxx.ge(0) & idxx.lt(H) & idxy.ge(0) & idxy.lt(W)\n    ids = idxn * C * H * W + idxc * H * W + idxx * W + idxy\n    ids_mask = torch.masked_select(ids, mask).clone().cuda()\n    img_warp = torch.zeros([N * C * H * W]).cuda()\n    img_warp.put_(ids_mask, torch.masked_select(flat_img * flat_weight, mask), accumulate=True)\n    one_warp = torch.zeros([N * C * H * W]).cuda()\n    one_warp.put_(ids_mask, torch.masked_select(flat_weight, mask), accumulate=True)\n    return (img_warp.view(N, C, H, W), one_warp.view(N, C, H, W))",
        "mutated": [
            "def sample_one(self, img, shiftx, shifty, weight):\n    if False:\n        i = 10\n    '\\n        Input:\\n            -img (N, C, H, W)\\n            -shiftx, shifty (N, c, H, W)\\n        '\n    (N, C, H, W) = img.size()\n    flat_shiftx = shiftx.view(-1)\n    flat_shifty = shifty.view(-1)\n    flat_basex = torch.arange(0, H, requires_grad=False).view(-1, 1)[None, None].cuda().long().repeat(N, C, 1, W).view(-1)\n    flat_basey = torch.arange(0, W, requires_grad=False).view(1, -1)[None, None].cuda().long().repeat(N, C, H, 1).view(-1)\n    flat_weight = weight.view(-1)\n    flat_img = img.view(-1)\n    idxn = torch.arange(0, N, requires_grad=False).view(N, 1, 1, 1).long().cuda().repeat(1, C, H, W).view(-1)\n    idxc = torch.arange(0, C, requires_grad=False).view(1, C, 1, 1).long().cuda().repeat(N, 1, H, W).view(-1)\n    idxx = flat_shiftx.long() + flat_basex\n    idxy = flat_shifty.long() + flat_basey\n    mask = idxx.ge(0) & idxx.lt(H) & idxy.ge(0) & idxy.lt(W)\n    ids = idxn * C * H * W + idxc * H * W + idxx * W + idxy\n    ids_mask = torch.masked_select(ids, mask).clone().cuda()\n    img_warp = torch.zeros([N * C * H * W]).cuda()\n    img_warp.put_(ids_mask, torch.masked_select(flat_img * flat_weight, mask), accumulate=True)\n    one_warp = torch.zeros([N * C * H * W]).cuda()\n    one_warp.put_(ids_mask, torch.masked_select(flat_weight, mask), accumulate=True)\n    return (img_warp.view(N, C, H, W), one_warp.view(N, C, H, W))",
            "def sample_one(self, img, shiftx, shifty, weight):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Input:\\n            -img (N, C, H, W)\\n            -shiftx, shifty (N, c, H, W)\\n        '\n    (N, C, H, W) = img.size()\n    flat_shiftx = shiftx.view(-1)\n    flat_shifty = shifty.view(-1)\n    flat_basex = torch.arange(0, H, requires_grad=False).view(-1, 1)[None, None].cuda().long().repeat(N, C, 1, W).view(-1)\n    flat_basey = torch.arange(0, W, requires_grad=False).view(1, -1)[None, None].cuda().long().repeat(N, C, H, 1).view(-1)\n    flat_weight = weight.view(-1)\n    flat_img = img.view(-1)\n    idxn = torch.arange(0, N, requires_grad=False).view(N, 1, 1, 1).long().cuda().repeat(1, C, H, W).view(-1)\n    idxc = torch.arange(0, C, requires_grad=False).view(1, C, 1, 1).long().cuda().repeat(N, 1, H, W).view(-1)\n    idxx = flat_shiftx.long() + flat_basex\n    idxy = flat_shifty.long() + flat_basey\n    mask = idxx.ge(0) & idxx.lt(H) & idxy.ge(0) & idxy.lt(W)\n    ids = idxn * C * H * W + idxc * H * W + idxx * W + idxy\n    ids_mask = torch.masked_select(ids, mask).clone().cuda()\n    img_warp = torch.zeros([N * C * H * W]).cuda()\n    img_warp.put_(ids_mask, torch.masked_select(flat_img * flat_weight, mask), accumulate=True)\n    one_warp = torch.zeros([N * C * H * W]).cuda()\n    one_warp.put_(ids_mask, torch.masked_select(flat_weight, mask), accumulate=True)\n    return (img_warp.view(N, C, H, W), one_warp.view(N, C, H, W))",
            "def sample_one(self, img, shiftx, shifty, weight):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Input:\\n            -img (N, C, H, W)\\n            -shiftx, shifty (N, c, H, W)\\n        '\n    (N, C, H, W) = img.size()\n    flat_shiftx = shiftx.view(-1)\n    flat_shifty = shifty.view(-1)\n    flat_basex = torch.arange(0, H, requires_grad=False).view(-1, 1)[None, None].cuda().long().repeat(N, C, 1, W).view(-1)\n    flat_basey = torch.arange(0, W, requires_grad=False).view(1, -1)[None, None].cuda().long().repeat(N, C, H, 1).view(-1)\n    flat_weight = weight.view(-1)\n    flat_img = img.view(-1)\n    idxn = torch.arange(0, N, requires_grad=False).view(N, 1, 1, 1).long().cuda().repeat(1, C, H, W).view(-1)\n    idxc = torch.arange(0, C, requires_grad=False).view(1, C, 1, 1).long().cuda().repeat(N, 1, H, W).view(-1)\n    idxx = flat_shiftx.long() + flat_basex\n    idxy = flat_shifty.long() + flat_basey\n    mask = idxx.ge(0) & idxx.lt(H) & idxy.ge(0) & idxy.lt(W)\n    ids = idxn * C * H * W + idxc * H * W + idxx * W + idxy\n    ids_mask = torch.masked_select(ids, mask).clone().cuda()\n    img_warp = torch.zeros([N * C * H * W]).cuda()\n    img_warp.put_(ids_mask, torch.masked_select(flat_img * flat_weight, mask), accumulate=True)\n    one_warp = torch.zeros([N * C * H * W]).cuda()\n    one_warp.put_(ids_mask, torch.masked_select(flat_weight, mask), accumulate=True)\n    return (img_warp.view(N, C, H, W), one_warp.view(N, C, H, W))",
            "def sample_one(self, img, shiftx, shifty, weight):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Input:\\n            -img (N, C, H, W)\\n            -shiftx, shifty (N, c, H, W)\\n        '\n    (N, C, H, W) = img.size()\n    flat_shiftx = shiftx.view(-1)\n    flat_shifty = shifty.view(-1)\n    flat_basex = torch.arange(0, H, requires_grad=False).view(-1, 1)[None, None].cuda().long().repeat(N, C, 1, W).view(-1)\n    flat_basey = torch.arange(0, W, requires_grad=False).view(1, -1)[None, None].cuda().long().repeat(N, C, H, 1).view(-1)\n    flat_weight = weight.view(-1)\n    flat_img = img.view(-1)\n    idxn = torch.arange(0, N, requires_grad=False).view(N, 1, 1, 1).long().cuda().repeat(1, C, H, W).view(-1)\n    idxc = torch.arange(0, C, requires_grad=False).view(1, C, 1, 1).long().cuda().repeat(N, 1, H, W).view(-1)\n    idxx = flat_shiftx.long() + flat_basex\n    idxy = flat_shifty.long() + flat_basey\n    mask = idxx.ge(0) & idxx.lt(H) & idxy.ge(0) & idxy.lt(W)\n    ids = idxn * C * H * W + idxc * H * W + idxx * W + idxy\n    ids_mask = torch.masked_select(ids, mask).clone().cuda()\n    img_warp = torch.zeros([N * C * H * W]).cuda()\n    img_warp.put_(ids_mask, torch.masked_select(flat_img * flat_weight, mask), accumulate=True)\n    one_warp = torch.zeros([N * C * H * W]).cuda()\n    one_warp.put_(ids_mask, torch.masked_select(flat_weight, mask), accumulate=True)\n    return (img_warp.view(N, C, H, W), one_warp.view(N, C, H, W))",
            "def sample_one(self, img, shiftx, shifty, weight):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Input:\\n            -img (N, C, H, W)\\n            -shiftx, shifty (N, c, H, W)\\n        '\n    (N, C, H, W) = img.size()\n    flat_shiftx = shiftx.view(-1)\n    flat_shifty = shifty.view(-1)\n    flat_basex = torch.arange(0, H, requires_grad=False).view(-1, 1)[None, None].cuda().long().repeat(N, C, 1, W).view(-1)\n    flat_basey = torch.arange(0, W, requires_grad=False).view(1, -1)[None, None].cuda().long().repeat(N, C, H, 1).view(-1)\n    flat_weight = weight.view(-1)\n    flat_img = img.view(-1)\n    idxn = torch.arange(0, N, requires_grad=False).view(N, 1, 1, 1).long().cuda().repeat(1, C, H, W).view(-1)\n    idxc = torch.arange(0, C, requires_grad=False).view(1, C, 1, 1).long().cuda().repeat(N, 1, H, W).view(-1)\n    idxx = flat_shiftx.long() + flat_basex\n    idxy = flat_shifty.long() + flat_basey\n    mask = idxx.ge(0) & idxx.lt(H) & idxy.ge(0) & idxy.lt(W)\n    ids = idxn * C * H * W + idxc * H * W + idxx * W + idxy\n    ids_mask = torch.masked_select(ids, mask).clone().cuda()\n    img_warp = torch.zeros([N * C * H * W]).cuda()\n    img_warp.put_(ids_mask, torch.masked_select(flat_img * flat_weight, mask), accumulate=True)\n    one_warp = torch.zeros([N * C * H * W]).cuda()\n    one_warp.put_(ids_mask, torch.masked_select(flat_weight, mask), accumulate=True)\n    return (img_warp.view(N, C, H, W), one_warp.view(N, C, H, W))"
        ]
    }
]