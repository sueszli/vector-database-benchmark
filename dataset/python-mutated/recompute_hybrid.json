[
    {
        "func_name": "_split_activation",
        "original": "def _split_activation(tensor, mp_group):\n    mp_degree = mp_group.nranks\n    mp_rank = mp_group.rank\n    if mp_degree < 2:\n        return tensor\n    tensor_numel = paddle.numel(tensor)\n    assert tensor_numel != 0, \"can't recompute zero element\"\n    assert tensor_numel % mp_degree == 0, 'The capacity of the activation ({}) cannot be divisible by mp_degree({})'.format(tensor_numel, mp_degree)\n    data = tensor.flatten_()\n    part_size = tensor_numel // mp_degree\n    start = part_size * mp_rank\n    end = start + part_size\n    return data[start:end]",
        "mutated": [
            "def _split_activation(tensor, mp_group):\n    if False:\n        i = 10\n    mp_degree = mp_group.nranks\n    mp_rank = mp_group.rank\n    if mp_degree < 2:\n        return tensor\n    tensor_numel = paddle.numel(tensor)\n    assert tensor_numel != 0, \"can't recompute zero element\"\n    assert tensor_numel % mp_degree == 0, 'The capacity of the activation ({}) cannot be divisible by mp_degree({})'.format(tensor_numel, mp_degree)\n    data = tensor.flatten_()\n    part_size = tensor_numel // mp_degree\n    start = part_size * mp_rank\n    end = start + part_size\n    return data[start:end]",
            "def _split_activation(tensor, mp_group):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mp_degree = mp_group.nranks\n    mp_rank = mp_group.rank\n    if mp_degree < 2:\n        return tensor\n    tensor_numel = paddle.numel(tensor)\n    assert tensor_numel != 0, \"can't recompute zero element\"\n    assert tensor_numel % mp_degree == 0, 'The capacity of the activation ({}) cannot be divisible by mp_degree({})'.format(tensor_numel, mp_degree)\n    data = tensor.flatten_()\n    part_size = tensor_numel // mp_degree\n    start = part_size * mp_rank\n    end = start + part_size\n    return data[start:end]",
            "def _split_activation(tensor, mp_group):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mp_degree = mp_group.nranks\n    mp_rank = mp_group.rank\n    if mp_degree < 2:\n        return tensor\n    tensor_numel = paddle.numel(tensor)\n    assert tensor_numel != 0, \"can't recompute zero element\"\n    assert tensor_numel % mp_degree == 0, 'The capacity of the activation ({}) cannot be divisible by mp_degree({})'.format(tensor_numel, mp_degree)\n    data = tensor.flatten_()\n    part_size = tensor_numel // mp_degree\n    start = part_size * mp_rank\n    end = start + part_size\n    return data[start:end]",
            "def _split_activation(tensor, mp_group):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mp_degree = mp_group.nranks\n    mp_rank = mp_group.rank\n    if mp_degree < 2:\n        return tensor\n    tensor_numel = paddle.numel(tensor)\n    assert tensor_numel != 0, \"can't recompute zero element\"\n    assert tensor_numel % mp_degree == 0, 'The capacity of the activation ({}) cannot be divisible by mp_degree({})'.format(tensor_numel, mp_degree)\n    data = tensor.flatten_()\n    part_size = tensor_numel // mp_degree\n    start = part_size * mp_rank\n    end = start + part_size\n    return data[start:end]",
            "def _split_activation(tensor, mp_group):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mp_degree = mp_group.nranks\n    mp_rank = mp_group.rank\n    if mp_degree < 2:\n        return tensor\n    tensor_numel = paddle.numel(tensor)\n    assert tensor_numel != 0, \"can't recompute zero element\"\n    assert tensor_numel % mp_degree == 0, 'The capacity of the activation ({}) cannot be divisible by mp_degree({})'.format(tensor_numel, mp_degree)\n    data = tensor.flatten_()\n    part_size = tensor_numel // mp_degree\n    start = part_size * mp_rank\n    end = start + part_size\n    return data[start:end]"
        ]
    },
    {
        "func_name": "_merge_activation",
        "original": "def _merge_activation(tensor, mp_group):\n    mp_degree = mp_group.nranks\n    mp_rank = mp_group.rank\n    if mp_degree < 2:\n        return tensor\n    tensor_shape = list(tensor.shape)\n    tensor_shape[0] *= mp_group.nranks\n    out = paddle.empty(tensor_shape, tensor.dtype)\n    task = mp_group.process_group.all_gather(tensor.cuda(), out)\n    task.wait()\n    return out",
        "mutated": [
            "def _merge_activation(tensor, mp_group):\n    if False:\n        i = 10\n    mp_degree = mp_group.nranks\n    mp_rank = mp_group.rank\n    if mp_degree < 2:\n        return tensor\n    tensor_shape = list(tensor.shape)\n    tensor_shape[0] *= mp_group.nranks\n    out = paddle.empty(tensor_shape, tensor.dtype)\n    task = mp_group.process_group.all_gather(tensor.cuda(), out)\n    task.wait()\n    return out",
            "def _merge_activation(tensor, mp_group):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mp_degree = mp_group.nranks\n    mp_rank = mp_group.rank\n    if mp_degree < 2:\n        return tensor\n    tensor_shape = list(tensor.shape)\n    tensor_shape[0] *= mp_group.nranks\n    out = paddle.empty(tensor_shape, tensor.dtype)\n    task = mp_group.process_group.all_gather(tensor.cuda(), out)\n    task.wait()\n    return out",
            "def _merge_activation(tensor, mp_group):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mp_degree = mp_group.nranks\n    mp_rank = mp_group.rank\n    if mp_degree < 2:\n        return tensor\n    tensor_shape = list(tensor.shape)\n    tensor_shape[0] *= mp_group.nranks\n    out = paddle.empty(tensor_shape, tensor.dtype)\n    task = mp_group.process_group.all_gather(tensor.cuda(), out)\n    task.wait()\n    return out",
            "def _merge_activation(tensor, mp_group):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mp_degree = mp_group.nranks\n    mp_rank = mp_group.rank\n    if mp_degree < 2:\n        return tensor\n    tensor_shape = list(tensor.shape)\n    tensor_shape[0] *= mp_group.nranks\n    out = paddle.empty(tensor_shape, tensor.dtype)\n    task = mp_group.process_group.all_gather(tensor.cuda(), out)\n    task.wait()\n    return out",
            "def _merge_activation(tensor, mp_group):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mp_degree = mp_group.nranks\n    mp_rank = mp_group.rank\n    if mp_degree < 2:\n        return tensor\n    tensor_shape = list(tensor.shape)\n    tensor_shape[0] *= mp_group.nranks\n    out = paddle.empty(tensor_shape, tensor.dtype)\n    task = mp_group.process_group.all_gather(tensor.cuda(), out)\n    task.wait()\n    return out"
        ]
    },
    {
        "func_name": "forward",
        "original": "@staticmethod\ndef forward(ctx, run_function, all_outputs, mp_group, offload, partition, *args, **kwargs):\n    ctx.run_function = run_function\n    ctx.kwargs = kwargs\n    ctx.fwd_rng_state = paddle.get_rng_state()\n    ctx.fwd_rng_state_tracker = get_rng_state_tracker().get_states_tracker()\n    ctx.mp_group = mp_group\n    ctx.offload = offload\n    ctx.partition = partition\n    ctx.inputs = []\n    ctx.tensor_indices = []\n    ctx.tensor_shapes = []\n    tensor_inputs = []\n    cur_device = paddle.get_device()\n    assert 'gpu:' in paddle.get_device() or 'xpu:' in paddle.get_device() or cur_device.split(':')[0] in paddle.device.get_all_custom_device_type(), f'Recompute with RNG is not support current device: {cur_device}.'\n    tracer = framework._dygraph_tracer()\n    ctx.is_fw_autocast = False if tracer._amp_level == core.AmpLevel.O0 else True\n    if tracer._amp_level == core.AmpLevel.O2:\n        ctx.amp_level = 'O2'\n    elif tracer._amp_level in (core.AmpLevel.O1, core.AmpLevel.O0):\n        ctx.amp_level = 'O1'\n    else:\n        raise ValueError(f'unsupported amp level: {tracer._amp_level}')\n    ctx.amp_dtype = tracer._amp_dtype\n    (ctx.amp_white_list, ctx.amp_black_list) = tracer._get_amp_op_list()\n    with paddle.no_grad():\n        outputs = run_function(*args, **kwargs)\n    for (i, arg) in enumerate(args):\n        if paddle.is_tensor(arg):\n            state = arg.stop_gradient\n            if partition:\n                ctx.tensor_shapes.append(arg.shape)\n                partition = _split_activation(arg.detach(), mp_group).clone()\n                arg = partition.cpu() if offload else partition\n            else:\n                arg = arg.cpu() if offload else arg\n            arg.stop_gradient = state\n            tensor_inputs.append(arg)\n            ctx.tensor_indices.append(i)\n            ctx.inputs.append(None)\n            if framework.in_dynamic_mode() and state:\n                ctx.mark_non_differentiable(arg)\n        else:\n            ctx.inputs.append(arg)\n    ctx.save_for_backward(*tensor_inputs)\n    if paddle.is_tensor(outputs):\n        all_outputs += [outputs]\n        return outputs\n    else:\n        all_outputs += outputs\n        return tuple(outputs)",
        "mutated": [
            "@staticmethod\ndef forward(ctx, run_function, all_outputs, mp_group, offload, partition, *args, **kwargs):\n    if False:\n        i = 10\n    ctx.run_function = run_function\n    ctx.kwargs = kwargs\n    ctx.fwd_rng_state = paddle.get_rng_state()\n    ctx.fwd_rng_state_tracker = get_rng_state_tracker().get_states_tracker()\n    ctx.mp_group = mp_group\n    ctx.offload = offload\n    ctx.partition = partition\n    ctx.inputs = []\n    ctx.tensor_indices = []\n    ctx.tensor_shapes = []\n    tensor_inputs = []\n    cur_device = paddle.get_device()\n    assert 'gpu:' in paddle.get_device() or 'xpu:' in paddle.get_device() or cur_device.split(':')[0] in paddle.device.get_all_custom_device_type(), f'Recompute with RNG is not support current device: {cur_device}.'\n    tracer = framework._dygraph_tracer()\n    ctx.is_fw_autocast = False if tracer._amp_level == core.AmpLevel.O0 else True\n    if tracer._amp_level == core.AmpLevel.O2:\n        ctx.amp_level = 'O2'\n    elif tracer._amp_level in (core.AmpLevel.O1, core.AmpLevel.O0):\n        ctx.amp_level = 'O1'\n    else:\n        raise ValueError(f'unsupported amp level: {tracer._amp_level}')\n    ctx.amp_dtype = tracer._amp_dtype\n    (ctx.amp_white_list, ctx.amp_black_list) = tracer._get_amp_op_list()\n    with paddle.no_grad():\n        outputs = run_function(*args, **kwargs)\n    for (i, arg) in enumerate(args):\n        if paddle.is_tensor(arg):\n            state = arg.stop_gradient\n            if partition:\n                ctx.tensor_shapes.append(arg.shape)\n                partition = _split_activation(arg.detach(), mp_group).clone()\n                arg = partition.cpu() if offload else partition\n            else:\n                arg = arg.cpu() if offload else arg\n            arg.stop_gradient = state\n            tensor_inputs.append(arg)\n            ctx.tensor_indices.append(i)\n            ctx.inputs.append(None)\n            if framework.in_dynamic_mode() and state:\n                ctx.mark_non_differentiable(arg)\n        else:\n            ctx.inputs.append(arg)\n    ctx.save_for_backward(*tensor_inputs)\n    if paddle.is_tensor(outputs):\n        all_outputs += [outputs]\n        return outputs\n    else:\n        all_outputs += outputs\n        return tuple(outputs)",
            "@staticmethod\ndef forward(ctx, run_function, all_outputs, mp_group, offload, partition, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ctx.run_function = run_function\n    ctx.kwargs = kwargs\n    ctx.fwd_rng_state = paddle.get_rng_state()\n    ctx.fwd_rng_state_tracker = get_rng_state_tracker().get_states_tracker()\n    ctx.mp_group = mp_group\n    ctx.offload = offload\n    ctx.partition = partition\n    ctx.inputs = []\n    ctx.tensor_indices = []\n    ctx.tensor_shapes = []\n    tensor_inputs = []\n    cur_device = paddle.get_device()\n    assert 'gpu:' in paddle.get_device() or 'xpu:' in paddle.get_device() or cur_device.split(':')[0] in paddle.device.get_all_custom_device_type(), f'Recompute with RNG is not support current device: {cur_device}.'\n    tracer = framework._dygraph_tracer()\n    ctx.is_fw_autocast = False if tracer._amp_level == core.AmpLevel.O0 else True\n    if tracer._amp_level == core.AmpLevel.O2:\n        ctx.amp_level = 'O2'\n    elif tracer._amp_level in (core.AmpLevel.O1, core.AmpLevel.O0):\n        ctx.amp_level = 'O1'\n    else:\n        raise ValueError(f'unsupported amp level: {tracer._amp_level}')\n    ctx.amp_dtype = tracer._amp_dtype\n    (ctx.amp_white_list, ctx.amp_black_list) = tracer._get_amp_op_list()\n    with paddle.no_grad():\n        outputs = run_function(*args, **kwargs)\n    for (i, arg) in enumerate(args):\n        if paddle.is_tensor(arg):\n            state = arg.stop_gradient\n            if partition:\n                ctx.tensor_shapes.append(arg.shape)\n                partition = _split_activation(arg.detach(), mp_group).clone()\n                arg = partition.cpu() if offload else partition\n            else:\n                arg = arg.cpu() if offload else arg\n            arg.stop_gradient = state\n            tensor_inputs.append(arg)\n            ctx.tensor_indices.append(i)\n            ctx.inputs.append(None)\n            if framework.in_dynamic_mode() and state:\n                ctx.mark_non_differentiable(arg)\n        else:\n            ctx.inputs.append(arg)\n    ctx.save_for_backward(*tensor_inputs)\n    if paddle.is_tensor(outputs):\n        all_outputs += [outputs]\n        return outputs\n    else:\n        all_outputs += outputs\n        return tuple(outputs)",
            "@staticmethod\ndef forward(ctx, run_function, all_outputs, mp_group, offload, partition, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ctx.run_function = run_function\n    ctx.kwargs = kwargs\n    ctx.fwd_rng_state = paddle.get_rng_state()\n    ctx.fwd_rng_state_tracker = get_rng_state_tracker().get_states_tracker()\n    ctx.mp_group = mp_group\n    ctx.offload = offload\n    ctx.partition = partition\n    ctx.inputs = []\n    ctx.tensor_indices = []\n    ctx.tensor_shapes = []\n    tensor_inputs = []\n    cur_device = paddle.get_device()\n    assert 'gpu:' in paddle.get_device() or 'xpu:' in paddle.get_device() or cur_device.split(':')[0] in paddle.device.get_all_custom_device_type(), f'Recompute with RNG is not support current device: {cur_device}.'\n    tracer = framework._dygraph_tracer()\n    ctx.is_fw_autocast = False if tracer._amp_level == core.AmpLevel.O0 else True\n    if tracer._amp_level == core.AmpLevel.O2:\n        ctx.amp_level = 'O2'\n    elif tracer._amp_level in (core.AmpLevel.O1, core.AmpLevel.O0):\n        ctx.amp_level = 'O1'\n    else:\n        raise ValueError(f'unsupported amp level: {tracer._amp_level}')\n    ctx.amp_dtype = tracer._amp_dtype\n    (ctx.amp_white_list, ctx.amp_black_list) = tracer._get_amp_op_list()\n    with paddle.no_grad():\n        outputs = run_function(*args, **kwargs)\n    for (i, arg) in enumerate(args):\n        if paddle.is_tensor(arg):\n            state = arg.stop_gradient\n            if partition:\n                ctx.tensor_shapes.append(arg.shape)\n                partition = _split_activation(arg.detach(), mp_group).clone()\n                arg = partition.cpu() if offload else partition\n            else:\n                arg = arg.cpu() if offload else arg\n            arg.stop_gradient = state\n            tensor_inputs.append(arg)\n            ctx.tensor_indices.append(i)\n            ctx.inputs.append(None)\n            if framework.in_dynamic_mode() and state:\n                ctx.mark_non_differentiable(arg)\n        else:\n            ctx.inputs.append(arg)\n    ctx.save_for_backward(*tensor_inputs)\n    if paddle.is_tensor(outputs):\n        all_outputs += [outputs]\n        return outputs\n    else:\n        all_outputs += outputs\n        return tuple(outputs)",
            "@staticmethod\ndef forward(ctx, run_function, all_outputs, mp_group, offload, partition, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ctx.run_function = run_function\n    ctx.kwargs = kwargs\n    ctx.fwd_rng_state = paddle.get_rng_state()\n    ctx.fwd_rng_state_tracker = get_rng_state_tracker().get_states_tracker()\n    ctx.mp_group = mp_group\n    ctx.offload = offload\n    ctx.partition = partition\n    ctx.inputs = []\n    ctx.tensor_indices = []\n    ctx.tensor_shapes = []\n    tensor_inputs = []\n    cur_device = paddle.get_device()\n    assert 'gpu:' in paddle.get_device() or 'xpu:' in paddle.get_device() or cur_device.split(':')[0] in paddle.device.get_all_custom_device_type(), f'Recompute with RNG is not support current device: {cur_device}.'\n    tracer = framework._dygraph_tracer()\n    ctx.is_fw_autocast = False if tracer._amp_level == core.AmpLevel.O0 else True\n    if tracer._amp_level == core.AmpLevel.O2:\n        ctx.amp_level = 'O2'\n    elif tracer._amp_level in (core.AmpLevel.O1, core.AmpLevel.O0):\n        ctx.amp_level = 'O1'\n    else:\n        raise ValueError(f'unsupported amp level: {tracer._amp_level}')\n    ctx.amp_dtype = tracer._amp_dtype\n    (ctx.amp_white_list, ctx.amp_black_list) = tracer._get_amp_op_list()\n    with paddle.no_grad():\n        outputs = run_function(*args, **kwargs)\n    for (i, arg) in enumerate(args):\n        if paddle.is_tensor(arg):\n            state = arg.stop_gradient\n            if partition:\n                ctx.tensor_shapes.append(arg.shape)\n                partition = _split_activation(arg.detach(), mp_group).clone()\n                arg = partition.cpu() if offload else partition\n            else:\n                arg = arg.cpu() if offload else arg\n            arg.stop_gradient = state\n            tensor_inputs.append(arg)\n            ctx.tensor_indices.append(i)\n            ctx.inputs.append(None)\n            if framework.in_dynamic_mode() and state:\n                ctx.mark_non_differentiable(arg)\n        else:\n            ctx.inputs.append(arg)\n    ctx.save_for_backward(*tensor_inputs)\n    if paddle.is_tensor(outputs):\n        all_outputs += [outputs]\n        return outputs\n    else:\n        all_outputs += outputs\n        return tuple(outputs)",
            "@staticmethod\ndef forward(ctx, run_function, all_outputs, mp_group, offload, partition, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ctx.run_function = run_function\n    ctx.kwargs = kwargs\n    ctx.fwd_rng_state = paddle.get_rng_state()\n    ctx.fwd_rng_state_tracker = get_rng_state_tracker().get_states_tracker()\n    ctx.mp_group = mp_group\n    ctx.offload = offload\n    ctx.partition = partition\n    ctx.inputs = []\n    ctx.tensor_indices = []\n    ctx.tensor_shapes = []\n    tensor_inputs = []\n    cur_device = paddle.get_device()\n    assert 'gpu:' in paddle.get_device() or 'xpu:' in paddle.get_device() or cur_device.split(':')[0] in paddle.device.get_all_custom_device_type(), f'Recompute with RNG is not support current device: {cur_device}.'\n    tracer = framework._dygraph_tracer()\n    ctx.is_fw_autocast = False if tracer._amp_level == core.AmpLevel.O0 else True\n    if tracer._amp_level == core.AmpLevel.O2:\n        ctx.amp_level = 'O2'\n    elif tracer._amp_level in (core.AmpLevel.O1, core.AmpLevel.O0):\n        ctx.amp_level = 'O1'\n    else:\n        raise ValueError(f'unsupported amp level: {tracer._amp_level}')\n    ctx.amp_dtype = tracer._amp_dtype\n    (ctx.amp_white_list, ctx.amp_black_list) = tracer._get_amp_op_list()\n    with paddle.no_grad():\n        outputs = run_function(*args, **kwargs)\n    for (i, arg) in enumerate(args):\n        if paddle.is_tensor(arg):\n            state = arg.stop_gradient\n            if partition:\n                ctx.tensor_shapes.append(arg.shape)\n                partition = _split_activation(arg.detach(), mp_group).clone()\n                arg = partition.cpu() if offload else partition\n            else:\n                arg = arg.cpu() if offload else arg\n            arg.stop_gradient = state\n            tensor_inputs.append(arg)\n            ctx.tensor_indices.append(i)\n            ctx.inputs.append(None)\n            if framework.in_dynamic_mode() and state:\n                ctx.mark_non_differentiable(arg)\n        else:\n            ctx.inputs.append(arg)\n    ctx.save_for_backward(*tensor_inputs)\n    if paddle.is_tensor(outputs):\n        all_outputs += [outputs]\n        return outputs\n    else:\n        all_outputs += outputs\n        return tuple(outputs)"
        ]
    },
    {
        "func_name": "backward",
        "original": "@staticmethod\ndef backward(ctx, *args):\n    with paddle.base.dygraph.guard():\n        inputs = list(ctx.inputs)\n        tensor_indices = ctx.tensor_indices\n        tensor_shapes = ctx.tensor_shapes\n        tensors = list(ctx.saved_tensor())\n        device_id = paddle.distributed.ParallelEnv().device_id\n        for (i, idx) in enumerate(tensor_indices):\n            if ctx.partition:\n                state = tensors[i].stop_gradient\n                tensors[i] = _merge_activation(tensors[i], ctx.mp_group).detach().reshape_(tensor_shapes[i])\n                tensors[i].stop_gradient = state\n            inputs[idx] = tensors[i].cuda(device_id) if ctx.offload else tensors[i]\n        tracer = framework._dygraph_tracer()\n        tracer._has_grad = True\n        with swith_rng_state_tracker(ctx.fwd_rng_state, ctx.fwd_rng_state_tracker):\n            if ctx.is_fw_autocast:\n                with paddle.amp.auto_cast(enable=ctx.is_fw_autocast, custom_white_list=ctx.amp_white_list, custom_black_list=ctx.amp_black_list, level=ctx.amp_level, dtype=ctx.amp_dtype):\n                    detached_inputs = detach_variable(tuple(inputs))\n                    outputs = ctx.run_function(*detached_inputs, **ctx.kwargs)\n            else:\n                detached_inputs = detach_variable(tuple(inputs))\n                outputs = ctx.run_function(*detached_inputs, **ctx.kwargs)\n        if isinstance(outputs, core.eager.Tensor):\n            outputs = (outputs,)\n        assert len(outputs) == len(args)\n        forward_outputs_with_grad = []\n        backward_inputs = []\n        for i in range(len(outputs)):\n            if isinstance(outputs[i], core.eager.Tensor) and (not outputs[i].stop_gradient):\n                forward_outputs_with_grad.append(outputs[i])\n                backward_inputs.append(args[i])\n        if len(forward_outputs_with_grad) == 0:\n            raise RuntimeError('none of output has stop_gradient=False, this recompute() is not necessary')\n        paddle.autograd.backward(forward_outputs_with_grad, backward_inputs)\n        grads = tuple((inp._grad_ivar() for inp in detached_inputs if isinstance(inp, core.eager.Tensor)))\n        return grads",
        "mutated": [
            "@staticmethod\ndef backward(ctx, *args):\n    if False:\n        i = 10\n    with paddle.base.dygraph.guard():\n        inputs = list(ctx.inputs)\n        tensor_indices = ctx.tensor_indices\n        tensor_shapes = ctx.tensor_shapes\n        tensors = list(ctx.saved_tensor())\n        device_id = paddle.distributed.ParallelEnv().device_id\n        for (i, idx) in enumerate(tensor_indices):\n            if ctx.partition:\n                state = tensors[i].stop_gradient\n                tensors[i] = _merge_activation(tensors[i], ctx.mp_group).detach().reshape_(tensor_shapes[i])\n                tensors[i].stop_gradient = state\n            inputs[idx] = tensors[i].cuda(device_id) if ctx.offload else tensors[i]\n        tracer = framework._dygraph_tracer()\n        tracer._has_grad = True\n        with swith_rng_state_tracker(ctx.fwd_rng_state, ctx.fwd_rng_state_tracker):\n            if ctx.is_fw_autocast:\n                with paddle.amp.auto_cast(enable=ctx.is_fw_autocast, custom_white_list=ctx.amp_white_list, custom_black_list=ctx.amp_black_list, level=ctx.amp_level, dtype=ctx.amp_dtype):\n                    detached_inputs = detach_variable(tuple(inputs))\n                    outputs = ctx.run_function(*detached_inputs, **ctx.kwargs)\n            else:\n                detached_inputs = detach_variable(tuple(inputs))\n                outputs = ctx.run_function(*detached_inputs, **ctx.kwargs)\n        if isinstance(outputs, core.eager.Tensor):\n            outputs = (outputs,)\n        assert len(outputs) == len(args)\n        forward_outputs_with_grad = []\n        backward_inputs = []\n        for i in range(len(outputs)):\n            if isinstance(outputs[i], core.eager.Tensor) and (not outputs[i].stop_gradient):\n                forward_outputs_with_grad.append(outputs[i])\n                backward_inputs.append(args[i])\n        if len(forward_outputs_with_grad) == 0:\n            raise RuntimeError('none of output has stop_gradient=False, this recompute() is not necessary')\n        paddle.autograd.backward(forward_outputs_with_grad, backward_inputs)\n        grads = tuple((inp._grad_ivar() for inp in detached_inputs if isinstance(inp, core.eager.Tensor)))\n        return grads",
            "@staticmethod\ndef backward(ctx, *args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with paddle.base.dygraph.guard():\n        inputs = list(ctx.inputs)\n        tensor_indices = ctx.tensor_indices\n        tensor_shapes = ctx.tensor_shapes\n        tensors = list(ctx.saved_tensor())\n        device_id = paddle.distributed.ParallelEnv().device_id\n        for (i, idx) in enumerate(tensor_indices):\n            if ctx.partition:\n                state = tensors[i].stop_gradient\n                tensors[i] = _merge_activation(tensors[i], ctx.mp_group).detach().reshape_(tensor_shapes[i])\n                tensors[i].stop_gradient = state\n            inputs[idx] = tensors[i].cuda(device_id) if ctx.offload else tensors[i]\n        tracer = framework._dygraph_tracer()\n        tracer._has_grad = True\n        with swith_rng_state_tracker(ctx.fwd_rng_state, ctx.fwd_rng_state_tracker):\n            if ctx.is_fw_autocast:\n                with paddle.amp.auto_cast(enable=ctx.is_fw_autocast, custom_white_list=ctx.amp_white_list, custom_black_list=ctx.amp_black_list, level=ctx.amp_level, dtype=ctx.amp_dtype):\n                    detached_inputs = detach_variable(tuple(inputs))\n                    outputs = ctx.run_function(*detached_inputs, **ctx.kwargs)\n            else:\n                detached_inputs = detach_variable(tuple(inputs))\n                outputs = ctx.run_function(*detached_inputs, **ctx.kwargs)\n        if isinstance(outputs, core.eager.Tensor):\n            outputs = (outputs,)\n        assert len(outputs) == len(args)\n        forward_outputs_with_grad = []\n        backward_inputs = []\n        for i in range(len(outputs)):\n            if isinstance(outputs[i], core.eager.Tensor) and (not outputs[i].stop_gradient):\n                forward_outputs_with_grad.append(outputs[i])\n                backward_inputs.append(args[i])\n        if len(forward_outputs_with_grad) == 0:\n            raise RuntimeError('none of output has stop_gradient=False, this recompute() is not necessary')\n        paddle.autograd.backward(forward_outputs_with_grad, backward_inputs)\n        grads = tuple((inp._grad_ivar() for inp in detached_inputs if isinstance(inp, core.eager.Tensor)))\n        return grads",
            "@staticmethod\ndef backward(ctx, *args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with paddle.base.dygraph.guard():\n        inputs = list(ctx.inputs)\n        tensor_indices = ctx.tensor_indices\n        tensor_shapes = ctx.tensor_shapes\n        tensors = list(ctx.saved_tensor())\n        device_id = paddle.distributed.ParallelEnv().device_id\n        for (i, idx) in enumerate(tensor_indices):\n            if ctx.partition:\n                state = tensors[i].stop_gradient\n                tensors[i] = _merge_activation(tensors[i], ctx.mp_group).detach().reshape_(tensor_shapes[i])\n                tensors[i].stop_gradient = state\n            inputs[idx] = tensors[i].cuda(device_id) if ctx.offload else tensors[i]\n        tracer = framework._dygraph_tracer()\n        tracer._has_grad = True\n        with swith_rng_state_tracker(ctx.fwd_rng_state, ctx.fwd_rng_state_tracker):\n            if ctx.is_fw_autocast:\n                with paddle.amp.auto_cast(enable=ctx.is_fw_autocast, custom_white_list=ctx.amp_white_list, custom_black_list=ctx.amp_black_list, level=ctx.amp_level, dtype=ctx.amp_dtype):\n                    detached_inputs = detach_variable(tuple(inputs))\n                    outputs = ctx.run_function(*detached_inputs, **ctx.kwargs)\n            else:\n                detached_inputs = detach_variable(tuple(inputs))\n                outputs = ctx.run_function(*detached_inputs, **ctx.kwargs)\n        if isinstance(outputs, core.eager.Tensor):\n            outputs = (outputs,)\n        assert len(outputs) == len(args)\n        forward_outputs_with_grad = []\n        backward_inputs = []\n        for i in range(len(outputs)):\n            if isinstance(outputs[i], core.eager.Tensor) and (not outputs[i].stop_gradient):\n                forward_outputs_with_grad.append(outputs[i])\n                backward_inputs.append(args[i])\n        if len(forward_outputs_with_grad) == 0:\n            raise RuntimeError('none of output has stop_gradient=False, this recompute() is not necessary')\n        paddle.autograd.backward(forward_outputs_with_grad, backward_inputs)\n        grads = tuple((inp._grad_ivar() for inp in detached_inputs if isinstance(inp, core.eager.Tensor)))\n        return grads",
            "@staticmethod\ndef backward(ctx, *args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with paddle.base.dygraph.guard():\n        inputs = list(ctx.inputs)\n        tensor_indices = ctx.tensor_indices\n        tensor_shapes = ctx.tensor_shapes\n        tensors = list(ctx.saved_tensor())\n        device_id = paddle.distributed.ParallelEnv().device_id\n        for (i, idx) in enumerate(tensor_indices):\n            if ctx.partition:\n                state = tensors[i].stop_gradient\n                tensors[i] = _merge_activation(tensors[i], ctx.mp_group).detach().reshape_(tensor_shapes[i])\n                tensors[i].stop_gradient = state\n            inputs[idx] = tensors[i].cuda(device_id) if ctx.offload else tensors[i]\n        tracer = framework._dygraph_tracer()\n        tracer._has_grad = True\n        with swith_rng_state_tracker(ctx.fwd_rng_state, ctx.fwd_rng_state_tracker):\n            if ctx.is_fw_autocast:\n                with paddle.amp.auto_cast(enable=ctx.is_fw_autocast, custom_white_list=ctx.amp_white_list, custom_black_list=ctx.amp_black_list, level=ctx.amp_level, dtype=ctx.amp_dtype):\n                    detached_inputs = detach_variable(tuple(inputs))\n                    outputs = ctx.run_function(*detached_inputs, **ctx.kwargs)\n            else:\n                detached_inputs = detach_variable(tuple(inputs))\n                outputs = ctx.run_function(*detached_inputs, **ctx.kwargs)\n        if isinstance(outputs, core.eager.Tensor):\n            outputs = (outputs,)\n        assert len(outputs) == len(args)\n        forward_outputs_with_grad = []\n        backward_inputs = []\n        for i in range(len(outputs)):\n            if isinstance(outputs[i], core.eager.Tensor) and (not outputs[i].stop_gradient):\n                forward_outputs_with_grad.append(outputs[i])\n                backward_inputs.append(args[i])\n        if len(forward_outputs_with_grad) == 0:\n            raise RuntimeError('none of output has stop_gradient=False, this recompute() is not necessary')\n        paddle.autograd.backward(forward_outputs_with_grad, backward_inputs)\n        grads = tuple((inp._grad_ivar() for inp in detached_inputs if isinstance(inp, core.eager.Tensor)))\n        return grads",
            "@staticmethod\ndef backward(ctx, *args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with paddle.base.dygraph.guard():\n        inputs = list(ctx.inputs)\n        tensor_indices = ctx.tensor_indices\n        tensor_shapes = ctx.tensor_shapes\n        tensors = list(ctx.saved_tensor())\n        device_id = paddle.distributed.ParallelEnv().device_id\n        for (i, idx) in enumerate(tensor_indices):\n            if ctx.partition:\n                state = tensors[i].stop_gradient\n                tensors[i] = _merge_activation(tensors[i], ctx.mp_group).detach().reshape_(tensor_shapes[i])\n                tensors[i].stop_gradient = state\n            inputs[idx] = tensors[i].cuda(device_id) if ctx.offload else tensors[i]\n        tracer = framework._dygraph_tracer()\n        tracer._has_grad = True\n        with swith_rng_state_tracker(ctx.fwd_rng_state, ctx.fwd_rng_state_tracker):\n            if ctx.is_fw_autocast:\n                with paddle.amp.auto_cast(enable=ctx.is_fw_autocast, custom_white_list=ctx.amp_white_list, custom_black_list=ctx.amp_black_list, level=ctx.amp_level, dtype=ctx.amp_dtype):\n                    detached_inputs = detach_variable(tuple(inputs))\n                    outputs = ctx.run_function(*detached_inputs, **ctx.kwargs)\n            else:\n                detached_inputs = detach_variable(tuple(inputs))\n                outputs = ctx.run_function(*detached_inputs, **ctx.kwargs)\n        if isinstance(outputs, core.eager.Tensor):\n            outputs = (outputs,)\n        assert len(outputs) == len(args)\n        forward_outputs_with_grad = []\n        backward_inputs = []\n        for i in range(len(outputs)):\n            if isinstance(outputs[i], core.eager.Tensor) and (not outputs[i].stop_gradient):\n                forward_outputs_with_grad.append(outputs[i])\n                backward_inputs.append(args[i])\n        if len(forward_outputs_with_grad) == 0:\n            raise RuntimeError('none of output has stop_gradient=False, this recompute() is not necessary')\n        paddle.autograd.backward(forward_outputs_with_grad, backward_inputs)\n        grads = tuple((inp._grad_ivar() for inp in detached_inputs if isinstance(inp, core.eager.Tensor)))\n        return grads"
        ]
    },
    {
        "func_name": "recompute_hybrid",
        "original": "def recompute_hybrid(ctx, function, *args, **kwargs):\n    \"\"\"\n    recompute intermediate activations to save the memory in hybrid parallel scene.\n    # NODTE(shenliang03)The current hybrid parallel recompute has limitations.\n    # It cannot handle the following situations:\n    # 1. The calculation output of recompute, there are tensors that do not require gradients.\n    # 2. The forward output tensor has no gradient. This problem can be solved temporarily by detach().\n    # 3. Here, we only use float dtype to distinguish whether a gradient is needed in output tensor\n\n    Parameters:\n        ctx(dict): include 'mp_group', 'offload', and 'partition' keys. the key 'mp_group' (Group), represents the avtivations are splitted\n                   in which group. the key 'offload' (bool, optional, default=False), represents whether to offload to cpu. the key 'partition' (bool, optional, default=False),\n                   represents whether to split activations in the mp_group.\n        function(paddle.nn.Layer): layer of sequence of layers that describes part of forward pass of the model\n              whose intermediate activations will be released to save memory in forward stage and will be recomputed\n              in backward stage for gradient calculation.\n        *args(Tensor): inputs(tuple) to the function.\n\n        **kwargs(Dict): inputs(dict) to the function.\n\n    Returns:\n        Output of function on args and kwargs.\n\n    \"\"\"\n    mp_group = ctx.get('mp_group', None)\n    assert mp_group is not None, 'ctx must contains mp_group and mp_group can not be None.'\n    offload = ctx.get('offload', False)\n    partition = ctx.get('partition', False)\n    if framework._dygraph_tracer()._has_grad:\n        check_recompute_necessary(args)\n    all_outputs = []\n    _HPRecomputeFunction.apply(function, all_outputs, mp_group, offload, partition, *args, **kwargs)\n    if len(all_outputs) == 1:\n        return all_outputs[0]\n    else:\n        for output in all_outputs:\n            if paddle.is_tensor(output) and (not utils.is_float_tensor(output)):\n                output.stop_gradient = True\n        return tuple(all_outputs)",
        "mutated": [
            "def recompute_hybrid(ctx, function, *args, **kwargs):\n    if False:\n        i = 10\n    \"\\n    recompute intermediate activations to save the memory in hybrid parallel scene.\\n    # NODTE(shenliang03)The current hybrid parallel recompute has limitations.\\n    # It cannot handle the following situations:\\n    # 1. The calculation output of recompute, there are tensors that do not require gradients.\\n    # 2. The forward output tensor has no gradient. This problem can be solved temporarily by detach().\\n    # 3. Here, we only use float dtype to distinguish whether a gradient is needed in output tensor\\n\\n    Parameters:\\n        ctx(dict): include 'mp_group', 'offload', and 'partition' keys. the key 'mp_group' (Group), represents the avtivations are splitted\\n                   in which group. the key 'offload' (bool, optional, default=False), represents whether to offload to cpu. the key 'partition' (bool, optional, default=False),\\n                   represents whether to split activations in the mp_group.\\n        function(paddle.nn.Layer): layer of sequence of layers that describes part of forward pass of the model\\n              whose intermediate activations will be released to save memory in forward stage and will be recomputed\\n              in backward stage for gradient calculation.\\n        *args(Tensor): inputs(tuple) to the function.\\n\\n        **kwargs(Dict): inputs(dict) to the function.\\n\\n    Returns:\\n        Output of function on args and kwargs.\\n\\n    \"\n    mp_group = ctx.get('mp_group', None)\n    assert mp_group is not None, 'ctx must contains mp_group and mp_group can not be None.'\n    offload = ctx.get('offload', False)\n    partition = ctx.get('partition', False)\n    if framework._dygraph_tracer()._has_grad:\n        check_recompute_necessary(args)\n    all_outputs = []\n    _HPRecomputeFunction.apply(function, all_outputs, mp_group, offload, partition, *args, **kwargs)\n    if len(all_outputs) == 1:\n        return all_outputs[0]\n    else:\n        for output in all_outputs:\n            if paddle.is_tensor(output) and (not utils.is_float_tensor(output)):\n                output.stop_gradient = True\n        return tuple(all_outputs)",
            "def recompute_hybrid(ctx, function, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    recompute intermediate activations to save the memory in hybrid parallel scene.\\n    # NODTE(shenliang03)The current hybrid parallel recompute has limitations.\\n    # It cannot handle the following situations:\\n    # 1. The calculation output of recompute, there are tensors that do not require gradients.\\n    # 2. The forward output tensor has no gradient. This problem can be solved temporarily by detach().\\n    # 3. Here, we only use float dtype to distinguish whether a gradient is needed in output tensor\\n\\n    Parameters:\\n        ctx(dict): include 'mp_group', 'offload', and 'partition' keys. the key 'mp_group' (Group), represents the avtivations are splitted\\n                   in which group. the key 'offload' (bool, optional, default=False), represents whether to offload to cpu. the key 'partition' (bool, optional, default=False),\\n                   represents whether to split activations in the mp_group.\\n        function(paddle.nn.Layer): layer of sequence of layers that describes part of forward pass of the model\\n              whose intermediate activations will be released to save memory in forward stage and will be recomputed\\n              in backward stage for gradient calculation.\\n        *args(Tensor): inputs(tuple) to the function.\\n\\n        **kwargs(Dict): inputs(dict) to the function.\\n\\n    Returns:\\n        Output of function on args and kwargs.\\n\\n    \"\n    mp_group = ctx.get('mp_group', None)\n    assert mp_group is not None, 'ctx must contains mp_group and mp_group can not be None.'\n    offload = ctx.get('offload', False)\n    partition = ctx.get('partition', False)\n    if framework._dygraph_tracer()._has_grad:\n        check_recompute_necessary(args)\n    all_outputs = []\n    _HPRecomputeFunction.apply(function, all_outputs, mp_group, offload, partition, *args, **kwargs)\n    if len(all_outputs) == 1:\n        return all_outputs[0]\n    else:\n        for output in all_outputs:\n            if paddle.is_tensor(output) and (not utils.is_float_tensor(output)):\n                output.stop_gradient = True\n        return tuple(all_outputs)",
            "def recompute_hybrid(ctx, function, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    recompute intermediate activations to save the memory in hybrid parallel scene.\\n    # NODTE(shenliang03)The current hybrid parallel recompute has limitations.\\n    # It cannot handle the following situations:\\n    # 1. The calculation output of recompute, there are tensors that do not require gradients.\\n    # 2. The forward output tensor has no gradient. This problem can be solved temporarily by detach().\\n    # 3. Here, we only use float dtype to distinguish whether a gradient is needed in output tensor\\n\\n    Parameters:\\n        ctx(dict): include 'mp_group', 'offload', and 'partition' keys. the key 'mp_group' (Group), represents the avtivations are splitted\\n                   in which group. the key 'offload' (bool, optional, default=False), represents whether to offload to cpu. the key 'partition' (bool, optional, default=False),\\n                   represents whether to split activations in the mp_group.\\n        function(paddle.nn.Layer): layer of sequence of layers that describes part of forward pass of the model\\n              whose intermediate activations will be released to save memory in forward stage and will be recomputed\\n              in backward stage for gradient calculation.\\n        *args(Tensor): inputs(tuple) to the function.\\n\\n        **kwargs(Dict): inputs(dict) to the function.\\n\\n    Returns:\\n        Output of function on args and kwargs.\\n\\n    \"\n    mp_group = ctx.get('mp_group', None)\n    assert mp_group is not None, 'ctx must contains mp_group and mp_group can not be None.'\n    offload = ctx.get('offload', False)\n    partition = ctx.get('partition', False)\n    if framework._dygraph_tracer()._has_grad:\n        check_recompute_necessary(args)\n    all_outputs = []\n    _HPRecomputeFunction.apply(function, all_outputs, mp_group, offload, partition, *args, **kwargs)\n    if len(all_outputs) == 1:\n        return all_outputs[0]\n    else:\n        for output in all_outputs:\n            if paddle.is_tensor(output) and (not utils.is_float_tensor(output)):\n                output.stop_gradient = True\n        return tuple(all_outputs)",
            "def recompute_hybrid(ctx, function, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    recompute intermediate activations to save the memory in hybrid parallel scene.\\n    # NODTE(shenliang03)The current hybrid parallel recompute has limitations.\\n    # It cannot handle the following situations:\\n    # 1. The calculation output of recompute, there are tensors that do not require gradients.\\n    # 2. The forward output tensor has no gradient. This problem can be solved temporarily by detach().\\n    # 3. Here, we only use float dtype to distinguish whether a gradient is needed in output tensor\\n\\n    Parameters:\\n        ctx(dict): include 'mp_group', 'offload', and 'partition' keys. the key 'mp_group' (Group), represents the avtivations are splitted\\n                   in which group. the key 'offload' (bool, optional, default=False), represents whether to offload to cpu. the key 'partition' (bool, optional, default=False),\\n                   represents whether to split activations in the mp_group.\\n        function(paddle.nn.Layer): layer of sequence of layers that describes part of forward pass of the model\\n              whose intermediate activations will be released to save memory in forward stage and will be recomputed\\n              in backward stage for gradient calculation.\\n        *args(Tensor): inputs(tuple) to the function.\\n\\n        **kwargs(Dict): inputs(dict) to the function.\\n\\n    Returns:\\n        Output of function on args and kwargs.\\n\\n    \"\n    mp_group = ctx.get('mp_group', None)\n    assert mp_group is not None, 'ctx must contains mp_group and mp_group can not be None.'\n    offload = ctx.get('offload', False)\n    partition = ctx.get('partition', False)\n    if framework._dygraph_tracer()._has_grad:\n        check_recompute_necessary(args)\n    all_outputs = []\n    _HPRecomputeFunction.apply(function, all_outputs, mp_group, offload, partition, *args, **kwargs)\n    if len(all_outputs) == 1:\n        return all_outputs[0]\n    else:\n        for output in all_outputs:\n            if paddle.is_tensor(output) and (not utils.is_float_tensor(output)):\n                output.stop_gradient = True\n        return tuple(all_outputs)",
            "def recompute_hybrid(ctx, function, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    recompute intermediate activations to save the memory in hybrid parallel scene.\\n    # NODTE(shenliang03)The current hybrid parallel recompute has limitations.\\n    # It cannot handle the following situations:\\n    # 1. The calculation output of recompute, there are tensors that do not require gradients.\\n    # 2. The forward output tensor has no gradient. This problem can be solved temporarily by detach().\\n    # 3. Here, we only use float dtype to distinguish whether a gradient is needed in output tensor\\n\\n    Parameters:\\n        ctx(dict): include 'mp_group', 'offload', and 'partition' keys. the key 'mp_group' (Group), represents the avtivations are splitted\\n                   in which group. the key 'offload' (bool, optional, default=False), represents whether to offload to cpu. the key 'partition' (bool, optional, default=False),\\n                   represents whether to split activations in the mp_group.\\n        function(paddle.nn.Layer): layer of sequence of layers that describes part of forward pass of the model\\n              whose intermediate activations will be released to save memory in forward stage and will be recomputed\\n              in backward stage for gradient calculation.\\n        *args(Tensor): inputs(tuple) to the function.\\n\\n        **kwargs(Dict): inputs(dict) to the function.\\n\\n    Returns:\\n        Output of function on args and kwargs.\\n\\n    \"\n    mp_group = ctx.get('mp_group', None)\n    assert mp_group is not None, 'ctx must contains mp_group and mp_group can not be None.'\n    offload = ctx.get('offload', False)\n    partition = ctx.get('partition', False)\n    if framework._dygraph_tracer()._has_grad:\n        check_recompute_necessary(args)\n    all_outputs = []\n    _HPRecomputeFunction.apply(function, all_outputs, mp_group, offload, partition, *args, **kwargs)\n    if len(all_outputs) == 1:\n        return all_outputs[0]\n    else:\n        for output in all_outputs:\n            if paddle.is_tensor(output) and (not utils.is_float_tensor(output)):\n                output.stop_gradient = True\n        return tuple(all_outputs)"
        ]
    }
]