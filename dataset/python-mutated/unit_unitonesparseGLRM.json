[
    {
        "func_name": "ind_list",
        "original": "def ind_list(k):\n    tmp = [0] * k\n    tmp[np.random.randint(0, k)] = 1\n    return tmp",
        "mutated": [
            "def ind_list(k):\n    if False:\n        i = 10\n    tmp = [0] * k\n    tmp[np.random.randint(0, k)] = 1\n    return tmp",
            "def ind_list(k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    tmp = [0] * k\n    tmp[np.random.randint(0, k)] = 1\n    return tmp",
            "def ind_list(k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    tmp = [0] * k\n    tmp[np.random.randint(0, k)] = 1\n    return tmp",
            "def ind_list(k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    tmp = [0] * k\n    tmp[np.random.randint(0, k)] = 1\n    return tmp",
            "def ind_list(k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    tmp = [0] * k\n    tmp[np.random.randint(0, k)] = 1\n    return tmp"
        ]
    },
    {
        "func_name": "is_basis",
        "original": "def is_basis(a):\n    zeros = np.where(a == 0)[0].size\n    ones = np.where(a == 1)[0].size\n    basis = ones == 1 and zeros + ones == k\n    assert basis, 'Got ' + str(ones) + ' ones and ' + str(zeros) + ' zeros, but expected all zeros except a single 1'\n    return basis",
        "mutated": [
            "def is_basis(a):\n    if False:\n        i = 10\n    zeros = np.where(a == 0)[0].size\n    ones = np.where(a == 1)[0].size\n    basis = ones == 1 and zeros + ones == k\n    assert basis, 'Got ' + str(ones) + ' ones and ' + str(zeros) + ' zeros, but expected all zeros except a single 1'\n    return basis",
            "def is_basis(a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    zeros = np.where(a == 0)[0].size\n    ones = np.where(a == 1)[0].size\n    basis = ones == 1 and zeros + ones == k\n    assert basis, 'Got ' + str(ones) + ' ones and ' + str(zeros) + ' zeros, but expected all zeros except a single 1'\n    return basis",
            "def is_basis(a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    zeros = np.where(a == 0)[0].size\n    ones = np.where(a == 1)[0].size\n    basis = ones == 1 and zeros + ones == k\n    assert basis, 'Got ' + str(ones) + ' ones and ' + str(zeros) + ' zeros, but expected all zeros except a single 1'\n    return basis",
            "def is_basis(a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    zeros = np.where(a == 0)[0].size\n    ones = np.where(a == 1)[0].size\n    basis = ones == 1 and zeros + ones == k\n    assert basis, 'Got ' + str(ones) + ' ones and ' + str(zeros) + ' zeros, but expected all zeros except a single 1'\n    return basis",
            "def is_basis(a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    zeros = np.where(a == 0)[0].size\n    ones = np.where(a == 1)[0].size\n    basis = ones == 1 and zeros + ones == k\n    assert basis, 'Got ' + str(ones) + ' ones and ' + str(zeros) + ' zeros, but expected all zeros except a single 1'\n    return basis"
        ]
    },
    {
        "func_name": "glrm_unitonesparse",
        "original": "def glrm_unitonesparse():\n    m = 1000\n    n = 100\n    k = 10\n    print('Uploading random uniform matrix with rows = ' + str(m) + ' and cols = ' + str(n))\n    Y = np.random.rand(k, n)\n\n    def ind_list(k):\n        tmp = [0] * k\n        tmp[np.random.randint(0, k)] = 1\n        return tmp\n    X = [ind_list(k) for x in range(m)]\n    X = np.array(X)\n    train = np.dot(X, Y)\n    train_h2o = h2o.H2OFrame(train.tolist())\n    print('Run GLRM with unit one-sparse regularization on X')\n    initial_y = np.random.rand(k, n)\n    initial_y_h2o = h2o.H2OFrame(initial_y.tolist())\n    glrm_h2o = H2OGeneralizedLowRankEstimator(k=k, init='User', user_y=initial_y_h2o, loss='Quadratic', regularization_x='UnitOneSparse', regularization_y='None', gamma_x=1, gamma_y=0)\n    glrm_h2o.train(x=train_h2o.names, training_frame=train_h2o)\n    glrm_h2o.show()\n    print('Check that X matrix consists of rows of basis vectors')\n    fit_x = h2o.get_frame(glrm_h2o._model_json['output']['representation_name'])\n    fit_x_np = np.array(h2o.as_list(fit_x))\n\n    def is_basis(a):\n        zeros = np.where(a == 0)[0].size\n        ones = np.where(a == 1)[0].size\n        basis = ones == 1 and zeros + ones == k\n        assert basis, 'Got ' + str(ones) + ' ones and ' + str(zeros) + ' zeros, but expected all zeros except a single 1'\n        return basis\n    np.apply_along_axis(is_basis, 1, fit_x_np)\n    print('Check final objective function value')\n    fit_y = glrm_h2o._model_json['output']['archetypes'].cell_values\n    fit_y_np = [[float(s) for s in list(row)[1:]] for row in fit_y]\n    fit_y_np = np.array(fit_y_np)\n    fit_xy = np.dot(fit_x_np, fit_y_np)\n    glrm_obj = glrm_h2o._model_json['output']['objective']\n    sse = np.sum(np.square(train.__sub__(fit_xy)))\n    assert abs(glrm_obj - sse) < 1e-06, 'Final objective was ' + str(glrm_obj) + ' but should equal ' + str(sse)\n    print('Impute XY and check error metrics')\n    pred_h2o = glrm_h2o.predict(train_h2o)\n    pred_np = np.array(h2o.as_list(pred_h2o))\n    assert np.allclose(pred_np, fit_xy), 'Imputation for numerics with quadratic loss should equal XY product'\n    glrm_numerr = glrm_h2o._model_json['output']['training_metrics']._metric_json['numerr']\n    glrm_caterr = glrm_h2o._model_json['output']['training_metrics']._metric_json['caterr']\n    assert abs(glrm_numerr - glrm_obj) < 0.001, 'Numeric error was ' + str(glrm_numerr) + ' but should equal final objective ' + str(glrm_obj)\n    assert glrm_caterr == 0, 'Categorical error was ' + str(glrm_caterr) + ' but should be zero'",
        "mutated": [
            "def glrm_unitonesparse():\n    if False:\n        i = 10\n    m = 1000\n    n = 100\n    k = 10\n    print('Uploading random uniform matrix with rows = ' + str(m) + ' and cols = ' + str(n))\n    Y = np.random.rand(k, n)\n\n    def ind_list(k):\n        tmp = [0] * k\n        tmp[np.random.randint(0, k)] = 1\n        return tmp\n    X = [ind_list(k) for x in range(m)]\n    X = np.array(X)\n    train = np.dot(X, Y)\n    train_h2o = h2o.H2OFrame(train.tolist())\n    print('Run GLRM with unit one-sparse regularization on X')\n    initial_y = np.random.rand(k, n)\n    initial_y_h2o = h2o.H2OFrame(initial_y.tolist())\n    glrm_h2o = H2OGeneralizedLowRankEstimator(k=k, init='User', user_y=initial_y_h2o, loss='Quadratic', regularization_x='UnitOneSparse', regularization_y='None', gamma_x=1, gamma_y=0)\n    glrm_h2o.train(x=train_h2o.names, training_frame=train_h2o)\n    glrm_h2o.show()\n    print('Check that X matrix consists of rows of basis vectors')\n    fit_x = h2o.get_frame(glrm_h2o._model_json['output']['representation_name'])\n    fit_x_np = np.array(h2o.as_list(fit_x))\n\n    def is_basis(a):\n        zeros = np.where(a == 0)[0].size\n        ones = np.where(a == 1)[0].size\n        basis = ones == 1 and zeros + ones == k\n        assert basis, 'Got ' + str(ones) + ' ones and ' + str(zeros) + ' zeros, but expected all zeros except a single 1'\n        return basis\n    np.apply_along_axis(is_basis, 1, fit_x_np)\n    print('Check final objective function value')\n    fit_y = glrm_h2o._model_json['output']['archetypes'].cell_values\n    fit_y_np = [[float(s) for s in list(row)[1:]] for row in fit_y]\n    fit_y_np = np.array(fit_y_np)\n    fit_xy = np.dot(fit_x_np, fit_y_np)\n    glrm_obj = glrm_h2o._model_json['output']['objective']\n    sse = np.sum(np.square(train.__sub__(fit_xy)))\n    assert abs(glrm_obj - sse) < 1e-06, 'Final objective was ' + str(glrm_obj) + ' but should equal ' + str(sse)\n    print('Impute XY and check error metrics')\n    pred_h2o = glrm_h2o.predict(train_h2o)\n    pred_np = np.array(h2o.as_list(pred_h2o))\n    assert np.allclose(pred_np, fit_xy), 'Imputation for numerics with quadratic loss should equal XY product'\n    glrm_numerr = glrm_h2o._model_json['output']['training_metrics']._metric_json['numerr']\n    glrm_caterr = glrm_h2o._model_json['output']['training_metrics']._metric_json['caterr']\n    assert abs(glrm_numerr - glrm_obj) < 0.001, 'Numeric error was ' + str(glrm_numerr) + ' but should equal final objective ' + str(glrm_obj)\n    assert glrm_caterr == 0, 'Categorical error was ' + str(glrm_caterr) + ' but should be zero'",
            "def glrm_unitonesparse():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    m = 1000\n    n = 100\n    k = 10\n    print('Uploading random uniform matrix with rows = ' + str(m) + ' and cols = ' + str(n))\n    Y = np.random.rand(k, n)\n\n    def ind_list(k):\n        tmp = [0] * k\n        tmp[np.random.randint(0, k)] = 1\n        return tmp\n    X = [ind_list(k) for x in range(m)]\n    X = np.array(X)\n    train = np.dot(X, Y)\n    train_h2o = h2o.H2OFrame(train.tolist())\n    print('Run GLRM with unit one-sparse regularization on X')\n    initial_y = np.random.rand(k, n)\n    initial_y_h2o = h2o.H2OFrame(initial_y.tolist())\n    glrm_h2o = H2OGeneralizedLowRankEstimator(k=k, init='User', user_y=initial_y_h2o, loss='Quadratic', regularization_x='UnitOneSparse', regularization_y='None', gamma_x=1, gamma_y=0)\n    glrm_h2o.train(x=train_h2o.names, training_frame=train_h2o)\n    glrm_h2o.show()\n    print('Check that X matrix consists of rows of basis vectors')\n    fit_x = h2o.get_frame(glrm_h2o._model_json['output']['representation_name'])\n    fit_x_np = np.array(h2o.as_list(fit_x))\n\n    def is_basis(a):\n        zeros = np.where(a == 0)[0].size\n        ones = np.where(a == 1)[0].size\n        basis = ones == 1 and zeros + ones == k\n        assert basis, 'Got ' + str(ones) + ' ones and ' + str(zeros) + ' zeros, but expected all zeros except a single 1'\n        return basis\n    np.apply_along_axis(is_basis, 1, fit_x_np)\n    print('Check final objective function value')\n    fit_y = glrm_h2o._model_json['output']['archetypes'].cell_values\n    fit_y_np = [[float(s) for s in list(row)[1:]] for row in fit_y]\n    fit_y_np = np.array(fit_y_np)\n    fit_xy = np.dot(fit_x_np, fit_y_np)\n    glrm_obj = glrm_h2o._model_json['output']['objective']\n    sse = np.sum(np.square(train.__sub__(fit_xy)))\n    assert abs(glrm_obj - sse) < 1e-06, 'Final objective was ' + str(glrm_obj) + ' but should equal ' + str(sse)\n    print('Impute XY and check error metrics')\n    pred_h2o = glrm_h2o.predict(train_h2o)\n    pred_np = np.array(h2o.as_list(pred_h2o))\n    assert np.allclose(pred_np, fit_xy), 'Imputation for numerics with quadratic loss should equal XY product'\n    glrm_numerr = glrm_h2o._model_json['output']['training_metrics']._metric_json['numerr']\n    glrm_caterr = glrm_h2o._model_json['output']['training_metrics']._metric_json['caterr']\n    assert abs(glrm_numerr - glrm_obj) < 0.001, 'Numeric error was ' + str(glrm_numerr) + ' but should equal final objective ' + str(glrm_obj)\n    assert glrm_caterr == 0, 'Categorical error was ' + str(glrm_caterr) + ' but should be zero'",
            "def glrm_unitonesparse():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    m = 1000\n    n = 100\n    k = 10\n    print('Uploading random uniform matrix with rows = ' + str(m) + ' and cols = ' + str(n))\n    Y = np.random.rand(k, n)\n\n    def ind_list(k):\n        tmp = [0] * k\n        tmp[np.random.randint(0, k)] = 1\n        return tmp\n    X = [ind_list(k) for x in range(m)]\n    X = np.array(X)\n    train = np.dot(X, Y)\n    train_h2o = h2o.H2OFrame(train.tolist())\n    print('Run GLRM with unit one-sparse regularization on X')\n    initial_y = np.random.rand(k, n)\n    initial_y_h2o = h2o.H2OFrame(initial_y.tolist())\n    glrm_h2o = H2OGeneralizedLowRankEstimator(k=k, init='User', user_y=initial_y_h2o, loss='Quadratic', regularization_x='UnitOneSparse', regularization_y='None', gamma_x=1, gamma_y=0)\n    glrm_h2o.train(x=train_h2o.names, training_frame=train_h2o)\n    glrm_h2o.show()\n    print('Check that X matrix consists of rows of basis vectors')\n    fit_x = h2o.get_frame(glrm_h2o._model_json['output']['representation_name'])\n    fit_x_np = np.array(h2o.as_list(fit_x))\n\n    def is_basis(a):\n        zeros = np.where(a == 0)[0].size\n        ones = np.where(a == 1)[0].size\n        basis = ones == 1 and zeros + ones == k\n        assert basis, 'Got ' + str(ones) + ' ones and ' + str(zeros) + ' zeros, but expected all zeros except a single 1'\n        return basis\n    np.apply_along_axis(is_basis, 1, fit_x_np)\n    print('Check final objective function value')\n    fit_y = glrm_h2o._model_json['output']['archetypes'].cell_values\n    fit_y_np = [[float(s) for s in list(row)[1:]] for row in fit_y]\n    fit_y_np = np.array(fit_y_np)\n    fit_xy = np.dot(fit_x_np, fit_y_np)\n    glrm_obj = glrm_h2o._model_json['output']['objective']\n    sse = np.sum(np.square(train.__sub__(fit_xy)))\n    assert abs(glrm_obj - sse) < 1e-06, 'Final objective was ' + str(glrm_obj) + ' but should equal ' + str(sse)\n    print('Impute XY and check error metrics')\n    pred_h2o = glrm_h2o.predict(train_h2o)\n    pred_np = np.array(h2o.as_list(pred_h2o))\n    assert np.allclose(pred_np, fit_xy), 'Imputation for numerics with quadratic loss should equal XY product'\n    glrm_numerr = glrm_h2o._model_json['output']['training_metrics']._metric_json['numerr']\n    glrm_caterr = glrm_h2o._model_json['output']['training_metrics']._metric_json['caterr']\n    assert abs(glrm_numerr - glrm_obj) < 0.001, 'Numeric error was ' + str(glrm_numerr) + ' but should equal final objective ' + str(glrm_obj)\n    assert glrm_caterr == 0, 'Categorical error was ' + str(glrm_caterr) + ' but should be zero'",
            "def glrm_unitonesparse():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    m = 1000\n    n = 100\n    k = 10\n    print('Uploading random uniform matrix with rows = ' + str(m) + ' and cols = ' + str(n))\n    Y = np.random.rand(k, n)\n\n    def ind_list(k):\n        tmp = [0] * k\n        tmp[np.random.randint(0, k)] = 1\n        return tmp\n    X = [ind_list(k) for x in range(m)]\n    X = np.array(X)\n    train = np.dot(X, Y)\n    train_h2o = h2o.H2OFrame(train.tolist())\n    print('Run GLRM with unit one-sparse regularization on X')\n    initial_y = np.random.rand(k, n)\n    initial_y_h2o = h2o.H2OFrame(initial_y.tolist())\n    glrm_h2o = H2OGeneralizedLowRankEstimator(k=k, init='User', user_y=initial_y_h2o, loss='Quadratic', regularization_x='UnitOneSparse', regularization_y='None', gamma_x=1, gamma_y=0)\n    glrm_h2o.train(x=train_h2o.names, training_frame=train_h2o)\n    glrm_h2o.show()\n    print('Check that X matrix consists of rows of basis vectors')\n    fit_x = h2o.get_frame(glrm_h2o._model_json['output']['representation_name'])\n    fit_x_np = np.array(h2o.as_list(fit_x))\n\n    def is_basis(a):\n        zeros = np.where(a == 0)[0].size\n        ones = np.where(a == 1)[0].size\n        basis = ones == 1 and zeros + ones == k\n        assert basis, 'Got ' + str(ones) + ' ones and ' + str(zeros) + ' zeros, but expected all zeros except a single 1'\n        return basis\n    np.apply_along_axis(is_basis, 1, fit_x_np)\n    print('Check final objective function value')\n    fit_y = glrm_h2o._model_json['output']['archetypes'].cell_values\n    fit_y_np = [[float(s) for s in list(row)[1:]] for row in fit_y]\n    fit_y_np = np.array(fit_y_np)\n    fit_xy = np.dot(fit_x_np, fit_y_np)\n    glrm_obj = glrm_h2o._model_json['output']['objective']\n    sse = np.sum(np.square(train.__sub__(fit_xy)))\n    assert abs(glrm_obj - sse) < 1e-06, 'Final objective was ' + str(glrm_obj) + ' but should equal ' + str(sse)\n    print('Impute XY and check error metrics')\n    pred_h2o = glrm_h2o.predict(train_h2o)\n    pred_np = np.array(h2o.as_list(pred_h2o))\n    assert np.allclose(pred_np, fit_xy), 'Imputation for numerics with quadratic loss should equal XY product'\n    glrm_numerr = glrm_h2o._model_json['output']['training_metrics']._metric_json['numerr']\n    glrm_caterr = glrm_h2o._model_json['output']['training_metrics']._metric_json['caterr']\n    assert abs(glrm_numerr - glrm_obj) < 0.001, 'Numeric error was ' + str(glrm_numerr) + ' but should equal final objective ' + str(glrm_obj)\n    assert glrm_caterr == 0, 'Categorical error was ' + str(glrm_caterr) + ' but should be zero'",
            "def glrm_unitonesparse():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    m = 1000\n    n = 100\n    k = 10\n    print('Uploading random uniform matrix with rows = ' + str(m) + ' and cols = ' + str(n))\n    Y = np.random.rand(k, n)\n\n    def ind_list(k):\n        tmp = [0] * k\n        tmp[np.random.randint(0, k)] = 1\n        return tmp\n    X = [ind_list(k) for x in range(m)]\n    X = np.array(X)\n    train = np.dot(X, Y)\n    train_h2o = h2o.H2OFrame(train.tolist())\n    print('Run GLRM with unit one-sparse regularization on X')\n    initial_y = np.random.rand(k, n)\n    initial_y_h2o = h2o.H2OFrame(initial_y.tolist())\n    glrm_h2o = H2OGeneralizedLowRankEstimator(k=k, init='User', user_y=initial_y_h2o, loss='Quadratic', regularization_x='UnitOneSparse', regularization_y='None', gamma_x=1, gamma_y=0)\n    glrm_h2o.train(x=train_h2o.names, training_frame=train_h2o)\n    glrm_h2o.show()\n    print('Check that X matrix consists of rows of basis vectors')\n    fit_x = h2o.get_frame(glrm_h2o._model_json['output']['representation_name'])\n    fit_x_np = np.array(h2o.as_list(fit_x))\n\n    def is_basis(a):\n        zeros = np.where(a == 0)[0].size\n        ones = np.where(a == 1)[0].size\n        basis = ones == 1 and zeros + ones == k\n        assert basis, 'Got ' + str(ones) + ' ones and ' + str(zeros) + ' zeros, but expected all zeros except a single 1'\n        return basis\n    np.apply_along_axis(is_basis, 1, fit_x_np)\n    print('Check final objective function value')\n    fit_y = glrm_h2o._model_json['output']['archetypes'].cell_values\n    fit_y_np = [[float(s) for s in list(row)[1:]] for row in fit_y]\n    fit_y_np = np.array(fit_y_np)\n    fit_xy = np.dot(fit_x_np, fit_y_np)\n    glrm_obj = glrm_h2o._model_json['output']['objective']\n    sse = np.sum(np.square(train.__sub__(fit_xy)))\n    assert abs(glrm_obj - sse) < 1e-06, 'Final objective was ' + str(glrm_obj) + ' but should equal ' + str(sse)\n    print('Impute XY and check error metrics')\n    pred_h2o = glrm_h2o.predict(train_h2o)\n    pred_np = np.array(h2o.as_list(pred_h2o))\n    assert np.allclose(pred_np, fit_xy), 'Imputation for numerics with quadratic loss should equal XY product'\n    glrm_numerr = glrm_h2o._model_json['output']['training_metrics']._metric_json['numerr']\n    glrm_caterr = glrm_h2o._model_json['output']['training_metrics']._metric_json['caterr']\n    assert abs(glrm_numerr - glrm_obj) < 0.001, 'Numeric error was ' + str(glrm_numerr) + ' but should equal final objective ' + str(glrm_obj)\n    assert glrm_caterr == 0, 'Categorical error was ' + str(glrm_caterr) + ' but should be zero'"
        ]
    }
]