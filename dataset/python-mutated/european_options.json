[
    {
        "func_name": "option_price",
        "original": "def option_price(*, strikes, expiries, forwards, is_call_options, alpha, beta, volvol, rho, shift=0.0, volatility_type=SabrImpliedVolatilityType.LOGNORMAL, approximation_type=SabrApproximationType.HAGAN, dtype=None, name=None):\n    \"\"\"Computes the approximate European option price under the SABR model.\n\n  For a review of the SABR model and the conventions used, please see the\n  docstring for `implied_volatility`.\n\n  #### Example\n  ```python\n  import tf_quant_finance as tff\n  import tensorflow.compat.v2 as tf\n\n  prices = tff.models.sabr.approximations.european_option_price(\n    strikes=np.array([90.0, 100.0]),\n    expiries=np.array([0.5, 1.0]),\n    forwards=np.array([100.0, 110.0]),\n    is_call_options=np.array([True, False]),\n    alpha=3.2,\n    beta=0.2,\n    volvol=1.4,\n    rho=0.0005,\n    dtype=tf.float64)\n\n  # Expected: [10.41244961, 1.47123225]\n\n  ```\n\n  Args:\n    strikes: Real `Tensor` of arbitrary shape, specifying the strike prices.\n      Values must be strictly positive.\n    expiries: Real `Tensor` of shape compatible with that of `strikes`,\n      specifying the corresponding time-to-expiries of the options. Values must\n      be strictly positive.\n    forwards: Real `Tensor` of shape compatible with that of `strikes`,\n      specifying the observed forward prices of the underlying. Values must be\n      strictly positive.\n    is_call_options: Boolean `Tensor` of shape compatible with that of\n      `forward`, indicating whether the option is a call option (true) or put\n      option (false).\n    alpha: Real `Tensor` of shape compatible with that of `strikes`, specifying\n      the initial values of the stochastic volatility. Values must be strictly\n      positive.\n    beta: Real `Tensor` of shape compatible with that of `strikes`, specifying\n      the model exponent `beta`. Values must satisfy 0 <= `beta` <= 1.\n    volvol: Real `Tensor` of shape compatible with that of `strikes`,\n      specifying the model vol-vol multipliers. Values must satisfy\n      `0 <= volvol`.\n    rho: Real `Tensor` of shape compatible with that of `strikes`, specifying\n      the correlation factors between the Wiener processes modeling the forward\n      and the volatility. Values must satisfy -1 < `rho` < 1.\n    shift: Optional `Tensor` of shape compatible with that of `strkies`,\n      specifying the shift parameter(s). In the shifted model, the process\n      modeling the forward is modified as: dF = sigma * (F + shift) ^ beta * dW.\n      With this modification, negative forward rates are valid as long as\n      F > -shift.\n      Default value: 0.0\n    volatility_type: Either SabrImpliedVolatility.NORMAL or LOGNORMAL.\n      Default value: `LOGNORMAL`.\n    approximation_type: Instance of `SabrApproxmationScheme`.\n      Default value: `HAGAN`.\n    dtype: Optional: `tf.DType`. If supplied, the dtype to be used for\n      converting values to `Tensor`s.\n      Default value: `None`, which means that the default dtypes inferred from\n        `strikes` is used.\n    name: str. The name for the ops created by this function.\n      Default value: 'sabr_approx_eu_option_price'.\n\n  Returns:\n    A real `Tensor` of the same shape as `strikes`, containing the\n    corresponding options price.\n  \"\"\"\n    name = name or 'sabr_approx_eu_option_price'\n    with tf.name_scope(name):\n        forwards = tf.convert_to_tensor(forwards, dtype=dtype, name='forwards')\n        dtype = dtype or forwards.dtype\n        strikes = tf.convert_to_tensor(strikes, dtype=dtype, name='strikes')\n        expiries = tf.convert_to_tensor(expiries, dtype=dtype, name='expiries')\n        is_call_options = tf.convert_to_tensor(is_call_options, dtype=tf.bool, name='is_call_options')\n        if volatility_type == SabrImpliedVolatilityType.NORMAL:\n            sigma_normal = implied_volatility(strikes=strikes, expiries=expiries, forwards=forwards, alpha=alpha, beta=beta, volvol=volvol, rho=rho, shift=shift, volatility_type=volatility_type, approximation_type=approximation_type, dtype=dtype)\n            return vanilla_prices.option_price(volatilities=sigma_normal, strikes=strikes + shift, expiries=expiries, forwards=forwards + shift, is_call_options=is_call_options, is_normal_volatility=True)\n        elif volatility_type == SabrImpliedVolatilityType.LOGNORMAL:\n            sigma_black = implied_volatility(strikes=strikes, expiries=expiries, forwards=forwards, alpha=alpha, beta=beta, volvol=volvol, rho=rho, shift=shift, volatility_type=volatility_type, approximation_type=approximation_type, dtype=dtype)\n            return vanilla_prices.option_price(volatilities=sigma_black, strikes=strikes + shift, expiries=expiries, forwards=forwards + shift, is_call_options=is_call_options, is_normal_volatility=False)",
        "mutated": [
            "def option_price(*, strikes, expiries, forwards, is_call_options, alpha, beta, volvol, rho, shift=0.0, volatility_type=SabrImpliedVolatilityType.LOGNORMAL, approximation_type=SabrApproximationType.HAGAN, dtype=None, name=None):\n    if False:\n        i = 10\n    \"Computes the approximate European option price under the SABR model.\\n\\n  For a review of the SABR model and the conventions used, please see the\\n  docstring for `implied_volatility`.\\n\\n  #### Example\\n  ```python\\n  import tf_quant_finance as tff\\n  import tensorflow.compat.v2 as tf\\n\\n  prices = tff.models.sabr.approximations.european_option_price(\\n    strikes=np.array([90.0, 100.0]),\\n    expiries=np.array([0.5, 1.0]),\\n    forwards=np.array([100.0, 110.0]),\\n    is_call_options=np.array([True, False]),\\n    alpha=3.2,\\n    beta=0.2,\\n    volvol=1.4,\\n    rho=0.0005,\\n    dtype=tf.float64)\\n\\n  # Expected: [10.41244961, 1.47123225]\\n\\n  ```\\n\\n  Args:\\n    strikes: Real `Tensor` of arbitrary shape, specifying the strike prices.\\n      Values must be strictly positive.\\n    expiries: Real `Tensor` of shape compatible with that of `strikes`,\\n      specifying the corresponding time-to-expiries of the options. Values must\\n      be strictly positive.\\n    forwards: Real `Tensor` of shape compatible with that of `strikes`,\\n      specifying the observed forward prices of the underlying. Values must be\\n      strictly positive.\\n    is_call_options: Boolean `Tensor` of shape compatible with that of\\n      `forward`, indicating whether the option is a call option (true) or put\\n      option (false).\\n    alpha: Real `Tensor` of shape compatible with that of `strikes`, specifying\\n      the initial values of the stochastic volatility. Values must be strictly\\n      positive.\\n    beta: Real `Tensor` of shape compatible with that of `strikes`, specifying\\n      the model exponent `beta`. Values must satisfy 0 <= `beta` <= 1.\\n    volvol: Real `Tensor` of shape compatible with that of `strikes`,\\n      specifying the model vol-vol multipliers. Values must satisfy\\n      `0 <= volvol`.\\n    rho: Real `Tensor` of shape compatible with that of `strikes`, specifying\\n      the correlation factors between the Wiener processes modeling the forward\\n      and the volatility. Values must satisfy -1 < `rho` < 1.\\n    shift: Optional `Tensor` of shape compatible with that of `strkies`,\\n      specifying the shift parameter(s). In the shifted model, the process\\n      modeling the forward is modified as: dF = sigma * (F + shift) ^ beta * dW.\\n      With this modification, negative forward rates are valid as long as\\n      F > -shift.\\n      Default value: 0.0\\n    volatility_type: Either SabrImpliedVolatility.NORMAL or LOGNORMAL.\\n      Default value: `LOGNORMAL`.\\n    approximation_type: Instance of `SabrApproxmationScheme`.\\n      Default value: `HAGAN`.\\n    dtype: Optional: `tf.DType`. If supplied, the dtype to be used for\\n      converting values to `Tensor`s.\\n      Default value: `None`, which means that the default dtypes inferred from\\n        `strikes` is used.\\n    name: str. The name for the ops created by this function.\\n      Default value: 'sabr_approx_eu_option_price'.\\n\\n  Returns:\\n    A real `Tensor` of the same shape as `strikes`, containing the\\n    corresponding options price.\\n  \"\n    name = name or 'sabr_approx_eu_option_price'\n    with tf.name_scope(name):\n        forwards = tf.convert_to_tensor(forwards, dtype=dtype, name='forwards')\n        dtype = dtype or forwards.dtype\n        strikes = tf.convert_to_tensor(strikes, dtype=dtype, name='strikes')\n        expiries = tf.convert_to_tensor(expiries, dtype=dtype, name='expiries')\n        is_call_options = tf.convert_to_tensor(is_call_options, dtype=tf.bool, name='is_call_options')\n        if volatility_type == SabrImpliedVolatilityType.NORMAL:\n            sigma_normal = implied_volatility(strikes=strikes, expiries=expiries, forwards=forwards, alpha=alpha, beta=beta, volvol=volvol, rho=rho, shift=shift, volatility_type=volatility_type, approximation_type=approximation_type, dtype=dtype)\n            return vanilla_prices.option_price(volatilities=sigma_normal, strikes=strikes + shift, expiries=expiries, forwards=forwards + shift, is_call_options=is_call_options, is_normal_volatility=True)\n        elif volatility_type == SabrImpliedVolatilityType.LOGNORMAL:\n            sigma_black = implied_volatility(strikes=strikes, expiries=expiries, forwards=forwards, alpha=alpha, beta=beta, volvol=volvol, rho=rho, shift=shift, volatility_type=volatility_type, approximation_type=approximation_type, dtype=dtype)\n            return vanilla_prices.option_price(volatilities=sigma_black, strikes=strikes + shift, expiries=expiries, forwards=forwards + shift, is_call_options=is_call_options, is_normal_volatility=False)",
            "def option_price(*, strikes, expiries, forwards, is_call_options, alpha, beta, volvol, rho, shift=0.0, volatility_type=SabrImpliedVolatilityType.LOGNORMAL, approximation_type=SabrApproximationType.HAGAN, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Computes the approximate European option price under the SABR model.\\n\\n  For a review of the SABR model and the conventions used, please see the\\n  docstring for `implied_volatility`.\\n\\n  #### Example\\n  ```python\\n  import tf_quant_finance as tff\\n  import tensorflow.compat.v2 as tf\\n\\n  prices = tff.models.sabr.approximations.european_option_price(\\n    strikes=np.array([90.0, 100.0]),\\n    expiries=np.array([0.5, 1.0]),\\n    forwards=np.array([100.0, 110.0]),\\n    is_call_options=np.array([True, False]),\\n    alpha=3.2,\\n    beta=0.2,\\n    volvol=1.4,\\n    rho=0.0005,\\n    dtype=tf.float64)\\n\\n  # Expected: [10.41244961, 1.47123225]\\n\\n  ```\\n\\n  Args:\\n    strikes: Real `Tensor` of arbitrary shape, specifying the strike prices.\\n      Values must be strictly positive.\\n    expiries: Real `Tensor` of shape compatible with that of `strikes`,\\n      specifying the corresponding time-to-expiries of the options. Values must\\n      be strictly positive.\\n    forwards: Real `Tensor` of shape compatible with that of `strikes`,\\n      specifying the observed forward prices of the underlying. Values must be\\n      strictly positive.\\n    is_call_options: Boolean `Tensor` of shape compatible with that of\\n      `forward`, indicating whether the option is a call option (true) or put\\n      option (false).\\n    alpha: Real `Tensor` of shape compatible with that of `strikes`, specifying\\n      the initial values of the stochastic volatility. Values must be strictly\\n      positive.\\n    beta: Real `Tensor` of shape compatible with that of `strikes`, specifying\\n      the model exponent `beta`. Values must satisfy 0 <= `beta` <= 1.\\n    volvol: Real `Tensor` of shape compatible with that of `strikes`,\\n      specifying the model vol-vol multipliers. Values must satisfy\\n      `0 <= volvol`.\\n    rho: Real `Tensor` of shape compatible with that of `strikes`, specifying\\n      the correlation factors between the Wiener processes modeling the forward\\n      and the volatility. Values must satisfy -1 < `rho` < 1.\\n    shift: Optional `Tensor` of shape compatible with that of `strkies`,\\n      specifying the shift parameter(s). In the shifted model, the process\\n      modeling the forward is modified as: dF = sigma * (F + shift) ^ beta * dW.\\n      With this modification, negative forward rates are valid as long as\\n      F > -shift.\\n      Default value: 0.0\\n    volatility_type: Either SabrImpliedVolatility.NORMAL or LOGNORMAL.\\n      Default value: `LOGNORMAL`.\\n    approximation_type: Instance of `SabrApproxmationScheme`.\\n      Default value: `HAGAN`.\\n    dtype: Optional: `tf.DType`. If supplied, the dtype to be used for\\n      converting values to `Tensor`s.\\n      Default value: `None`, which means that the default dtypes inferred from\\n        `strikes` is used.\\n    name: str. The name for the ops created by this function.\\n      Default value: 'sabr_approx_eu_option_price'.\\n\\n  Returns:\\n    A real `Tensor` of the same shape as `strikes`, containing the\\n    corresponding options price.\\n  \"\n    name = name or 'sabr_approx_eu_option_price'\n    with tf.name_scope(name):\n        forwards = tf.convert_to_tensor(forwards, dtype=dtype, name='forwards')\n        dtype = dtype or forwards.dtype\n        strikes = tf.convert_to_tensor(strikes, dtype=dtype, name='strikes')\n        expiries = tf.convert_to_tensor(expiries, dtype=dtype, name='expiries')\n        is_call_options = tf.convert_to_tensor(is_call_options, dtype=tf.bool, name='is_call_options')\n        if volatility_type == SabrImpliedVolatilityType.NORMAL:\n            sigma_normal = implied_volatility(strikes=strikes, expiries=expiries, forwards=forwards, alpha=alpha, beta=beta, volvol=volvol, rho=rho, shift=shift, volatility_type=volatility_type, approximation_type=approximation_type, dtype=dtype)\n            return vanilla_prices.option_price(volatilities=sigma_normal, strikes=strikes + shift, expiries=expiries, forwards=forwards + shift, is_call_options=is_call_options, is_normal_volatility=True)\n        elif volatility_type == SabrImpliedVolatilityType.LOGNORMAL:\n            sigma_black = implied_volatility(strikes=strikes, expiries=expiries, forwards=forwards, alpha=alpha, beta=beta, volvol=volvol, rho=rho, shift=shift, volatility_type=volatility_type, approximation_type=approximation_type, dtype=dtype)\n            return vanilla_prices.option_price(volatilities=sigma_black, strikes=strikes + shift, expiries=expiries, forwards=forwards + shift, is_call_options=is_call_options, is_normal_volatility=False)",
            "def option_price(*, strikes, expiries, forwards, is_call_options, alpha, beta, volvol, rho, shift=0.0, volatility_type=SabrImpliedVolatilityType.LOGNORMAL, approximation_type=SabrApproximationType.HAGAN, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Computes the approximate European option price under the SABR model.\\n\\n  For a review of the SABR model and the conventions used, please see the\\n  docstring for `implied_volatility`.\\n\\n  #### Example\\n  ```python\\n  import tf_quant_finance as tff\\n  import tensorflow.compat.v2 as tf\\n\\n  prices = tff.models.sabr.approximations.european_option_price(\\n    strikes=np.array([90.0, 100.0]),\\n    expiries=np.array([0.5, 1.0]),\\n    forwards=np.array([100.0, 110.0]),\\n    is_call_options=np.array([True, False]),\\n    alpha=3.2,\\n    beta=0.2,\\n    volvol=1.4,\\n    rho=0.0005,\\n    dtype=tf.float64)\\n\\n  # Expected: [10.41244961, 1.47123225]\\n\\n  ```\\n\\n  Args:\\n    strikes: Real `Tensor` of arbitrary shape, specifying the strike prices.\\n      Values must be strictly positive.\\n    expiries: Real `Tensor` of shape compatible with that of `strikes`,\\n      specifying the corresponding time-to-expiries of the options. Values must\\n      be strictly positive.\\n    forwards: Real `Tensor` of shape compatible with that of `strikes`,\\n      specifying the observed forward prices of the underlying. Values must be\\n      strictly positive.\\n    is_call_options: Boolean `Tensor` of shape compatible with that of\\n      `forward`, indicating whether the option is a call option (true) or put\\n      option (false).\\n    alpha: Real `Tensor` of shape compatible with that of `strikes`, specifying\\n      the initial values of the stochastic volatility. Values must be strictly\\n      positive.\\n    beta: Real `Tensor` of shape compatible with that of `strikes`, specifying\\n      the model exponent `beta`. Values must satisfy 0 <= `beta` <= 1.\\n    volvol: Real `Tensor` of shape compatible with that of `strikes`,\\n      specifying the model vol-vol multipliers. Values must satisfy\\n      `0 <= volvol`.\\n    rho: Real `Tensor` of shape compatible with that of `strikes`, specifying\\n      the correlation factors between the Wiener processes modeling the forward\\n      and the volatility. Values must satisfy -1 < `rho` < 1.\\n    shift: Optional `Tensor` of shape compatible with that of `strkies`,\\n      specifying the shift parameter(s). In the shifted model, the process\\n      modeling the forward is modified as: dF = sigma * (F + shift) ^ beta * dW.\\n      With this modification, negative forward rates are valid as long as\\n      F > -shift.\\n      Default value: 0.0\\n    volatility_type: Either SabrImpliedVolatility.NORMAL or LOGNORMAL.\\n      Default value: `LOGNORMAL`.\\n    approximation_type: Instance of `SabrApproxmationScheme`.\\n      Default value: `HAGAN`.\\n    dtype: Optional: `tf.DType`. If supplied, the dtype to be used for\\n      converting values to `Tensor`s.\\n      Default value: `None`, which means that the default dtypes inferred from\\n        `strikes` is used.\\n    name: str. The name for the ops created by this function.\\n      Default value: 'sabr_approx_eu_option_price'.\\n\\n  Returns:\\n    A real `Tensor` of the same shape as `strikes`, containing the\\n    corresponding options price.\\n  \"\n    name = name or 'sabr_approx_eu_option_price'\n    with tf.name_scope(name):\n        forwards = tf.convert_to_tensor(forwards, dtype=dtype, name='forwards')\n        dtype = dtype or forwards.dtype\n        strikes = tf.convert_to_tensor(strikes, dtype=dtype, name='strikes')\n        expiries = tf.convert_to_tensor(expiries, dtype=dtype, name='expiries')\n        is_call_options = tf.convert_to_tensor(is_call_options, dtype=tf.bool, name='is_call_options')\n        if volatility_type == SabrImpliedVolatilityType.NORMAL:\n            sigma_normal = implied_volatility(strikes=strikes, expiries=expiries, forwards=forwards, alpha=alpha, beta=beta, volvol=volvol, rho=rho, shift=shift, volatility_type=volatility_type, approximation_type=approximation_type, dtype=dtype)\n            return vanilla_prices.option_price(volatilities=sigma_normal, strikes=strikes + shift, expiries=expiries, forwards=forwards + shift, is_call_options=is_call_options, is_normal_volatility=True)\n        elif volatility_type == SabrImpliedVolatilityType.LOGNORMAL:\n            sigma_black = implied_volatility(strikes=strikes, expiries=expiries, forwards=forwards, alpha=alpha, beta=beta, volvol=volvol, rho=rho, shift=shift, volatility_type=volatility_type, approximation_type=approximation_type, dtype=dtype)\n            return vanilla_prices.option_price(volatilities=sigma_black, strikes=strikes + shift, expiries=expiries, forwards=forwards + shift, is_call_options=is_call_options, is_normal_volatility=False)",
            "def option_price(*, strikes, expiries, forwards, is_call_options, alpha, beta, volvol, rho, shift=0.0, volatility_type=SabrImpliedVolatilityType.LOGNORMAL, approximation_type=SabrApproximationType.HAGAN, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Computes the approximate European option price under the SABR model.\\n\\n  For a review of the SABR model and the conventions used, please see the\\n  docstring for `implied_volatility`.\\n\\n  #### Example\\n  ```python\\n  import tf_quant_finance as tff\\n  import tensorflow.compat.v2 as tf\\n\\n  prices = tff.models.sabr.approximations.european_option_price(\\n    strikes=np.array([90.0, 100.0]),\\n    expiries=np.array([0.5, 1.0]),\\n    forwards=np.array([100.0, 110.0]),\\n    is_call_options=np.array([True, False]),\\n    alpha=3.2,\\n    beta=0.2,\\n    volvol=1.4,\\n    rho=0.0005,\\n    dtype=tf.float64)\\n\\n  # Expected: [10.41244961, 1.47123225]\\n\\n  ```\\n\\n  Args:\\n    strikes: Real `Tensor` of arbitrary shape, specifying the strike prices.\\n      Values must be strictly positive.\\n    expiries: Real `Tensor` of shape compatible with that of `strikes`,\\n      specifying the corresponding time-to-expiries of the options. Values must\\n      be strictly positive.\\n    forwards: Real `Tensor` of shape compatible with that of `strikes`,\\n      specifying the observed forward prices of the underlying. Values must be\\n      strictly positive.\\n    is_call_options: Boolean `Tensor` of shape compatible with that of\\n      `forward`, indicating whether the option is a call option (true) or put\\n      option (false).\\n    alpha: Real `Tensor` of shape compatible with that of `strikes`, specifying\\n      the initial values of the stochastic volatility. Values must be strictly\\n      positive.\\n    beta: Real `Tensor` of shape compatible with that of `strikes`, specifying\\n      the model exponent `beta`. Values must satisfy 0 <= `beta` <= 1.\\n    volvol: Real `Tensor` of shape compatible with that of `strikes`,\\n      specifying the model vol-vol multipliers. Values must satisfy\\n      `0 <= volvol`.\\n    rho: Real `Tensor` of shape compatible with that of `strikes`, specifying\\n      the correlation factors between the Wiener processes modeling the forward\\n      and the volatility. Values must satisfy -1 < `rho` < 1.\\n    shift: Optional `Tensor` of shape compatible with that of `strkies`,\\n      specifying the shift parameter(s). In the shifted model, the process\\n      modeling the forward is modified as: dF = sigma * (F + shift) ^ beta * dW.\\n      With this modification, negative forward rates are valid as long as\\n      F > -shift.\\n      Default value: 0.0\\n    volatility_type: Either SabrImpliedVolatility.NORMAL or LOGNORMAL.\\n      Default value: `LOGNORMAL`.\\n    approximation_type: Instance of `SabrApproxmationScheme`.\\n      Default value: `HAGAN`.\\n    dtype: Optional: `tf.DType`. If supplied, the dtype to be used for\\n      converting values to `Tensor`s.\\n      Default value: `None`, which means that the default dtypes inferred from\\n        `strikes` is used.\\n    name: str. The name for the ops created by this function.\\n      Default value: 'sabr_approx_eu_option_price'.\\n\\n  Returns:\\n    A real `Tensor` of the same shape as `strikes`, containing the\\n    corresponding options price.\\n  \"\n    name = name or 'sabr_approx_eu_option_price'\n    with tf.name_scope(name):\n        forwards = tf.convert_to_tensor(forwards, dtype=dtype, name='forwards')\n        dtype = dtype or forwards.dtype\n        strikes = tf.convert_to_tensor(strikes, dtype=dtype, name='strikes')\n        expiries = tf.convert_to_tensor(expiries, dtype=dtype, name='expiries')\n        is_call_options = tf.convert_to_tensor(is_call_options, dtype=tf.bool, name='is_call_options')\n        if volatility_type == SabrImpliedVolatilityType.NORMAL:\n            sigma_normal = implied_volatility(strikes=strikes, expiries=expiries, forwards=forwards, alpha=alpha, beta=beta, volvol=volvol, rho=rho, shift=shift, volatility_type=volatility_type, approximation_type=approximation_type, dtype=dtype)\n            return vanilla_prices.option_price(volatilities=sigma_normal, strikes=strikes + shift, expiries=expiries, forwards=forwards + shift, is_call_options=is_call_options, is_normal_volatility=True)\n        elif volatility_type == SabrImpliedVolatilityType.LOGNORMAL:\n            sigma_black = implied_volatility(strikes=strikes, expiries=expiries, forwards=forwards, alpha=alpha, beta=beta, volvol=volvol, rho=rho, shift=shift, volatility_type=volatility_type, approximation_type=approximation_type, dtype=dtype)\n            return vanilla_prices.option_price(volatilities=sigma_black, strikes=strikes + shift, expiries=expiries, forwards=forwards + shift, is_call_options=is_call_options, is_normal_volatility=False)",
            "def option_price(*, strikes, expiries, forwards, is_call_options, alpha, beta, volvol, rho, shift=0.0, volatility_type=SabrImpliedVolatilityType.LOGNORMAL, approximation_type=SabrApproximationType.HAGAN, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Computes the approximate European option price under the SABR model.\\n\\n  For a review of the SABR model and the conventions used, please see the\\n  docstring for `implied_volatility`.\\n\\n  #### Example\\n  ```python\\n  import tf_quant_finance as tff\\n  import tensorflow.compat.v2 as tf\\n\\n  prices = tff.models.sabr.approximations.european_option_price(\\n    strikes=np.array([90.0, 100.0]),\\n    expiries=np.array([0.5, 1.0]),\\n    forwards=np.array([100.0, 110.0]),\\n    is_call_options=np.array([True, False]),\\n    alpha=3.2,\\n    beta=0.2,\\n    volvol=1.4,\\n    rho=0.0005,\\n    dtype=tf.float64)\\n\\n  # Expected: [10.41244961, 1.47123225]\\n\\n  ```\\n\\n  Args:\\n    strikes: Real `Tensor` of arbitrary shape, specifying the strike prices.\\n      Values must be strictly positive.\\n    expiries: Real `Tensor` of shape compatible with that of `strikes`,\\n      specifying the corresponding time-to-expiries of the options. Values must\\n      be strictly positive.\\n    forwards: Real `Tensor` of shape compatible with that of `strikes`,\\n      specifying the observed forward prices of the underlying. Values must be\\n      strictly positive.\\n    is_call_options: Boolean `Tensor` of shape compatible with that of\\n      `forward`, indicating whether the option is a call option (true) or put\\n      option (false).\\n    alpha: Real `Tensor` of shape compatible with that of `strikes`, specifying\\n      the initial values of the stochastic volatility. Values must be strictly\\n      positive.\\n    beta: Real `Tensor` of shape compatible with that of `strikes`, specifying\\n      the model exponent `beta`. Values must satisfy 0 <= `beta` <= 1.\\n    volvol: Real `Tensor` of shape compatible with that of `strikes`,\\n      specifying the model vol-vol multipliers. Values must satisfy\\n      `0 <= volvol`.\\n    rho: Real `Tensor` of shape compatible with that of `strikes`, specifying\\n      the correlation factors between the Wiener processes modeling the forward\\n      and the volatility. Values must satisfy -1 < `rho` < 1.\\n    shift: Optional `Tensor` of shape compatible with that of `strkies`,\\n      specifying the shift parameter(s). In the shifted model, the process\\n      modeling the forward is modified as: dF = sigma * (F + shift) ^ beta * dW.\\n      With this modification, negative forward rates are valid as long as\\n      F > -shift.\\n      Default value: 0.0\\n    volatility_type: Either SabrImpliedVolatility.NORMAL or LOGNORMAL.\\n      Default value: `LOGNORMAL`.\\n    approximation_type: Instance of `SabrApproxmationScheme`.\\n      Default value: `HAGAN`.\\n    dtype: Optional: `tf.DType`. If supplied, the dtype to be used for\\n      converting values to `Tensor`s.\\n      Default value: `None`, which means that the default dtypes inferred from\\n        `strikes` is used.\\n    name: str. The name for the ops created by this function.\\n      Default value: 'sabr_approx_eu_option_price'.\\n\\n  Returns:\\n    A real `Tensor` of the same shape as `strikes`, containing the\\n    corresponding options price.\\n  \"\n    name = name or 'sabr_approx_eu_option_price'\n    with tf.name_scope(name):\n        forwards = tf.convert_to_tensor(forwards, dtype=dtype, name='forwards')\n        dtype = dtype or forwards.dtype\n        strikes = tf.convert_to_tensor(strikes, dtype=dtype, name='strikes')\n        expiries = tf.convert_to_tensor(expiries, dtype=dtype, name='expiries')\n        is_call_options = tf.convert_to_tensor(is_call_options, dtype=tf.bool, name='is_call_options')\n        if volatility_type == SabrImpliedVolatilityType.NORMAL:\n            sigma_normal = implied_volatility(strikes=strikes, expiries=expiries, forwards=forwards, alpha=alpha, beta=beta, volvol=volvol, rho=rho, shift=shift, volatility_type=volatility_type, approximation_type=approximation_type, dtype=dtype)\n            return vanilla_prices.option_price(volatilities=sigma_normal, strikes=strikes + shift, expiries=expiries, forwards=forwards + shift, is_call_options=is_call_options, is_normal_volatility=True)\n        elif volatility_type == SabrImpliedVolatilityType.LOGNORMAL:\n            sigma_black = implied_volatility(strikes=strikes, expiries=expiries, forwards=forwards, alpha=alpha, beta=beta, volvol=volvol, rho=rho, shift=shift, volatility_type=volatility_type, approximation_type=approximation_type, dtype=dtype)\n            return vanilla_prices.option_price(volatilities=sigma_black, strikes=strikes + shift, expiries=expiries, forwards=forwards + shift, is_call_options=is_call_options, is_normal_volatility=False)"
        ]
    }
]