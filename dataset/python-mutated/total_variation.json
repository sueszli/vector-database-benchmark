[
    {
        "func_name": "tv",
        "original": "def tv(value, *args):\n    \"\"\"Total variation of a vector, matrix, or list of matrices.\n\n    Uses L1 norm of discrete gradients for vectors and\n    L2 norm of discrete gradients for matrices.\n\n    Parameters\n    ----------\n    value : Expression or numeric constant\n        The value to take the total variation of.\n    args : Matrix constants/expressions\n        Additional matrices extending the third dimension of value.\n\n    Returns\n    -------\n    Expression\n        An Expression representing the total variation.\n    \"\"\"\n    value = Expression.cast_to_const(value)\n    if value.ndim == 0:\n        raise ValueError('tv cannot take a scalar argument.')\n    elif value.ndim == 1:\n        return norm(value[1:] - value[0:value.shape[0] - 1], 1)\n    else:\n        (rows, cols) = value.shape\n        args = map(Expression.cast_to_const, args)\n        values = [value] + list(args)\n        diffs = []\n        for mat in values:\n            diffs += [mat[0:rows - 1, 1:cols] - mat[0:rows - 1, 0:cols - 1], mat[1:rows, 0:cols - 1] - mat[0:rows - 1, 0:cols - 1]]\n        length = diffs[0].shape[0] * diffs[1].shape[1]\n        stacked = vstack([reshape(diff, (1, length)) for diff in diffs])\n        return sum(norm(stacked, p=2, axis=0))",
        "mutated": [
            "def tv(value, *args):\n    if False:\n        i = 10\n    'Total variation of a vector, matrix, or list of matrices.\\n\\n    Uses L1 norm of discrete gradients for vectors and\\n    L2 norm of discrete gradients for matrices.\\n\\n    Parameters\\n    ----------\\n    value : Expression or numeric constant\\n        The value to take the total variation of.\\n    args : Matrix constants/expressions\\n        Additional matrices extending the third dimension of value.\\n\\n    Returns\\n    -------\\n    Expression\\n        An Expression representing the total variation.\\n    '\n    value = Expression.cast_to_const(value)\n    if value.ndim == 0:\n        raise ValueError('tv cannot take a scalar argument.')\n    elif value.ndim == 1:\n        return norm(value[1:] - value[0:value.shape[0] - 1], 1)\n    else:\n        (rows, cols) = value.shape\n        args = map(Expression.cast_to_const, args)\n        values = [value] + list(args)\n        diffs = []\n        for mat in values:\n            diffs += [mat[0:rows - 1, 1:cols] - mat[0:rows - 1, 0:cols - 1], mat[1:rows, 0:cols - 1] - mat[0:rows - 1, 0:cols - 1]]\n        length = diffs[0].shape[0] * diffs[1].shape[1]\n        stacked = vstack([reshape(diff, (1, length)) for diff in diffs])\n        return sum(norm(stacked, p=2, axis=0))",
            "def tv(value, *args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Total variation of a vector, matrix, or list of matrices.\\n\\n    Uses L1 norm of discrete gradients for vectors and\\n    L2 norm of discrete gradients for matrices.\\n\\n    Parameters\\n    ----------\\n    value : Expression or numeric constant\\n        The value to take the total variation of.\\n    args : Matrix constants/expressions\\n        Additional matrices extending the third dimension of value.\\n\\n    Returns\\n    -------\\n    Expression\\n        An Expression representing the total variation.\\n    '\n    value = Expression.cast_to_const(value)\n    if value.ndim == 0:\n        raise ValueError('tv cannot take a scalar argument.')\n    elif value.ndim == 1:\n        return norm(value[1:] - value[0:value.shape[0] - 1], 1)\n    else:\n        (rows, cols) = value.shape\n        args = map(Expression.cast_to_const, args)\n        values = [value] + list(args)\n        diffs = []\n        for mat in values:\n            diffs += [mat[0:rows - 1, 1:cols] - mat[0:rows - 1, 0:cols - 1], mat[1:rows, 0:cols - 1] - mat[0:rows - 1, 0:cols - 1]]\n        length = diffs[0].shape[0] * diffs[1].shape[1]\n        stacked = vstack([reshape(diff, (1, length)) for diff in diffs])\n        return sum(norm(stacked, p=2, axis=0))",
            "def tv(value, *args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Total variation of a vector, matrix, or list of matrices.\\n\\n    Uses L1 norm of discrete gradients for vectors and\\n    L2 norm of discrete gradients for matrices.\\n\\n    Parameters\\n    ----------\\n    value : Expression or numeric constant\\n        The value to take the total variation of.\\n    args : Matrix constants/expressions\\n        Additional matrices extending the third dimension of value.\\n\\n    Returns\\n    -------\\n    Expression\\n        An Expression representing the total variation.\\n    '\n    value = Expression.cast_to_const(value)\n    if value.ndim == 0:\n        raise ValueError('tv cannot take a scalar argument.')\n    elif value.ndim == 1:\n        return norm(value[1:] - value[0:value.shape[0] - 1], 1)\n    else:\n        (rows, cols) = value.shape\n        args = map(Expression.cast_to_const, args)\n        values = [value] + list(args)\n        diffs = []\n        for mat in values:\n            diffs += [mat[0:rows - 1, 1:cols] - mat[0:rows - 1, 0:cols - 1], mat[1:rows, 0:cols - 1] - mat[0:rows - 1, 0:cols - 1]]\n        length = diffs[0].shape[0] * diffs[1].shape[1]\n        stacked = vstack([reshape(diff, (1, length)) for diff in diffs])\n        return sum(norm(stacked, p=2, axis=0))",
            "def tv(value, *args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Total variation of a vector, matrix, or list of matrices.\\n\\n    Uses L1 norm of discrete gradients for vectors and\\n    L2 norm of discrete gradients for matrices.\\n\\n    Parameters\\n    ----------\\n    value : Expression or numeric constant\\n        The value to take the total variation of.\\n    args : Matrix constants/expressions\\n        Additional matrices extending the third dimension of value.\\n\\n    Returns\\n    -------\\n    Expression\\n        An Expression representing the total variation.\\n    '\n    value = Expression.cast_to_const(value)\n    if value.ndim == 0:\n        raise ValueError('tv cannot take a scalar argument.')\n    elif value.ndim == 1:\n        return norm(value[1:] - value[0:value.shape[0] - 1], 1)\n    else:\n        (rows, cols) = value.shape\n        args = map(Expression.cast_to_const, args)\n        values = [value] + list(args)\n        diffs = []\n        for mat in values:\n            diffs += [mat[0:rows - 1, 1:cols] - mat[0:rows - 1, 0:cols - 1], mat[1:rows, 0:cols - 1] - mat[0:rows - 1, 0:cols - 1]]\n        length = diffs[0].shape[0] * diffs[1].shape[1]\n        stacked = vstack([reshape(diff, (1, length)) for diff in diffs])\n        return sum(norm(stacked, p=2, axis=0))",
            "def tv(value, *args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Total variation of a vector, matrix, or list of matrices.\\n\\n    Uses L1 norm of discrete gradients for vectors and\\n    L2 norm of discrete gradients for matrices.\\n\\n    Parameters\\n    ----------\\n    value : Expression or numeric constant\\n        The value to take the total variation of.\\n    args : Matrix constants/expressions\\n        Additional matrices extending the third dimension of value.\\n\\n    Returns\\n    -------\\n    Expression\\n        An Expression representing the total variation.\\n    '\n    value = Expression.cast_to_const(value)\n    if value.ndim == 0:\n        raise ValueError('tv cannot take a scalar argument.')\n    elif value.ndim == 1:\n        return norm(value[1:] - value[0:value.shape[0] - 1], 1)\n    else:\n        (rows, cols) = value.shape\n        args = map(Expression.cast_to_const, args)\n        values = [value] + list(args)\n        diffs = []\n        for mat in values:\n            diffs += [mat[0:rows - 1, 1:cols] - mat[0:rows - 1, 0:cols - 1], mat[1:rows, 0:cols - 1] - mat[0:rows - 1, 0:cols - 1]]\n        length = diffs[0].shape[0] * diffs[1].shape[1]\n        stacked = vstack([reshape(diff, (1, length)) for diff in diffs])\n        return sum(norm(stacked, p=2, axis=0))"
        ]
    }
]