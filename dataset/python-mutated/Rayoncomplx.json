[
    {
        "func_name": "ABCD",
        "original": "def ABCD(A, B, C, D):\n    \"\"\"Fonction toute simple permettant de cr\u00e9er une matrice ABCD avec les indices\"\"\"\n    return np.matrix(((A, B), (C, D)))",
        "mutated": [
            "def ABCD(A, B, C, D):\n    if False:\n        i = 10\n    'Fonction toute simple permettant de cr\u00e9er une matrice ABCD avec les indices'\n    return np.matrix(((A, B), (C, D)))",
            "def ABCD(A, B, C, D):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Fonction toute simple permettant de cr\u00e9er une matrice ABCD avec les indices'\n    return np.matrix(((A, B), (C, D)))",
            "def ABCD(A, B, C, D):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Fonction toute simple permettant de cr\u00e9er une matrice ABCD avec les indices'\n    return np.matrix(((A, B), (C, D)))",
            "def ABCD(A, B, C, D):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Fonction toute simple permettant de cr\u00e9er une matrice ABCD avec les indices'\n    return np.matrix(((A, B), (C, D)))",
            "def ABCD(A, B, C, D):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Fonction toute simple permettant de cr\u00e9er une matrice ABCD avec les indices'\n    return np.matrix(((A, B), (C, D)))"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, complx, longueur):\n    self.q = complx\n    self.l = longueur * 10 ** (-9)\n    self.etranglement = np.sqrt(self.l * self.q.imag / np.pi)",
        "mutated": [
            "def __init__(self, complx, longueur):\n    if False:\n        i = 10\n    self.q = complx\n    self.l = longueur * 10 ** (-9)\n    self.etranglement = np.sqrt(self.l * self.q.imag / np.pi)",
            "def __init__(self, complx, longueur):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.q = complx\n    self.l = longueur * 10 ** (-9)\n    self.etranglement = np.sqrt(self.l * self.q.imag / np.pi)",
            "def __init__(self, complx, longueur):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.q = complx\n    self.l = longueur * 10 ** (-9)\n    self.etranglement = np.sqrt(self.l * self.q.imag / np.pi)",
            "def __init__(self, complx, longueur):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.q = complx\n    self.l = longueur * 10 ** (-9)\n    self.etranglement = np.sqrt(self.l * self.q.imag / np.pi)",
            "def __init__(self, complx, longueur):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.q = complx\n    self.l = longueur * 10 ** (-9)\n    self.etranglement = np.sqrt(self.l * self.q.imag / np.pi)"
        ]
    },
    {
        "func_name": "rayon",
        "original": "def rayon(self, dist):\n    return (self.q.real + dist) * np.sqrt(1 + (self.q.imag / (self.q.real + dist)) ** 2)",
        "mutated": [
            "def rayon(self, dist):\n    if False:\n        i = 10\n    return (self.q.real + dist) * np.sqrt(1 + (self.q.imag / (self.q.real + dist)) ** 2)",
            "def rayon(self, dist):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return (self.q.real + dist) * np.sqrt(1 + (self.q.imag / (self.q.real + dist)) ** 2)",
            "def rayon(self, dist):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return (self.q.real + dist) * np.sqrt(1 + (self.q.imag / (self.q.real + dist)) ** 2)",
            "def rayon(self, dist):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return (self.q.real + dist) * np.sqrt(1 + (self.q.imag / (self.q.real + dist)) ** 2)",
            "def rayon(self, dist):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return (self.q.real + dist) * np.sqrt(1 + (self.q.imag / (self.q.real + dist)) ** 2)"
        ]
    },
    {
        "func_name": "width",
        "original": "def width(self, dist):\n    return self.etranglement * np.sqrt(1 + ((self.q.real + dist) / self.q.imag) ** 2)",
        "mutated": [
            "def width(self, dist):\n    if False:\n        i = 10\n    return self.etranglement * np.sqrt(1 + ((self.q.real + dist) / self.q.imag) ** 2)",
            "def width(self, dist):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.etranglement * np.sqrt(1 + ((self.q.real + dist) / self.q.imag) ** 2)",
            "def width(self, dist):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.etranglement * np.sqrt(1 + ((self.q.real + dist) / self.q.imag) ** 2)",
            "def width(self, dist):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.etranglement * np.sqrt(1 + ((self.q.real + dist) / self.q.imag) ** 2)",
            "def width(self, dist):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.etranglement * np.sqrt(1 + ((self.q.real + dist) / self.q.imag) ** 2)"
        ]
    },
    {
        "func_name": "transform",
        "original": "def transform(self, compo):\n    \"\"\"La loi de transformation ou compo est une matrice ABCD\"\"\"\n    return RayonComplexe((compo[0, 0] * self.q + compo[0, 1]) / (compo[1, 0] * self.q + compo[1, 1]), self.l * 10 ** 9)",
        "mutated": [
            "def transform(self, compo):\n    if False:\n        i = 10\n    'La loi de transformation ou compo est une matrice ABCD'\n    return RayonComplexe((compo[0, 0] * self.q + compo[0, 1]) / (compo[1, 0] * self.q + compo[1, 1]), self.l * 10 ** 9)",
            "def transform(self, compo):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'La loi de transformation ou compo est une matrice ABCD'\n    return RayonComplexe((compo[0, 0] * self.q + compo[0, 1]) / (compo[1, 0] * self.q + compo[1, 1]), self.l * 10 ** 9)",
            "def transform(self, compo):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'La loi de transformation ou compo est une matrice ABCD'\n    return RayonComplexe((compo[0, 0] * self.q + compo[0, 1]) / (compo[1, 0] * self.q + compo[1, 1]), self.l * 10 ** 9)",
            "def transform(self, compo):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'La loi de transformation ou compo est une matrice ABCD'\n    return RayonComplexe((compo[0, 0] * self.q + compo[0, 1]) / (compo[1, 0] * self.q + compo[1, 1]), self.l * 10 ** 9)",
            "def transform(self, compo):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'La loi de transformation ou compo est une matrice ABCD'\n    return RayonComplexe((compo[0, 0] * self.q + compo[0, 1]) / (compo[1, 0] * self.q + compo[1, 1]), self.l * 10 ** 9)"
        ]
    },
    {
        "func_name": "syst4f",
        "original": "def syst4f(f1, f2):\n    return ABCD(-float(f2) / f1, 0, 0, -(float(f1) / f2))",
        "mutated": [
            "def syst4f(f1, f2):\n    if False:\n        i = 10\n    return ABCD(-float(f2) / f1, 0, 0, -(float(f1) / f2))",
            "def syst4f(f1, f2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return ABCD(-float(f2) / f1, 0, 0, -(float(f1) / f2))",
            "def syst4f(f1, f2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return ABCD(-float(f2) / f1, 0, 0, -(float(f1) / f2))",
            "def syst4f(f1, f2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return ABCD(-float(f2) / f1, 0, 0, -(float(f1) / f2))",
            "def syst4f(f1, f2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return ABCD(-float(f2) / f1, 0, 0, -(float(f1) / f2))"
        ]
    },
    {
        "func_name": "syst2f",
        "original": "def syst2f(f):\n    return ABCD(0, f, -float(1) / f, 0)",
        "mutated": [
            "def syst2f(f):\n    if False:\n        i = 10\n    return ABCD(0, f, -float(1) / f, 0)",
            "def syst2f(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return ABCD(0, f, -float(1) / f, 0)",
            "def syst2f(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return ABCD(0, f, -float(1) / f, 0)",
            "def syst2f(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return ABCD(0, f, -float(1) / f, 0)",
            "def syst2f(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return ABCD(0, f, -float(1) / f, 0)"
        ]
    },
    {
        "func_name": "space",
        "original": "def space(dist):\n    return ABCD(1, dist, 0, 1)",
        "mutated": [
            "def space(dist):\n    if False:\n        i = 10\n    return ABCD(1, dist, 0, 1)",
            "def space(dist):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return ABCD(1, dist, 0, 1)",
            "def space(dist):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return ABCD(1, dist, 0, 1)",
            "def space(dist):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return ABCD(1, dist, 0, 1)",
            "def space(dist):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return ABCD(1, dist, 0, 1)"
        ]
    },
    {
        "func_name": "lens",
        "original": "def lens(f):\n    return ABCD(1, 0, -float(1) / f, 1)",
        "mutated": [
            "def lens(f):\n    if False:\n        i = 10\n    return ABCD(1, 0, -float(1) / f, 1)",
            "def lens(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return ABCD(1, 0, -float(1) / f, 1)",
            "def lens(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return ABCD(1, 0, -float(1) / f, 1)",
            "def lens(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return ABCD(1, 0, -float(1) / f, 1)",
            "def lens(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return ABCD(1, 0, -float(1) / f, 1)"
        ]
    },
    {
        "func_name": "cheminoptiquerayon",
        "original": "def cheminoptiquerayon(rayoncomplx, system, pos=False, width=False, complx=False, label=[]):\n    \"\"\"Renvoie une liste avec un objet RayonComplexe \u00e0 la sortie de chaque matrice ABCD. En option: complx renvoie une liste de nmbr complexe, \n\twidth renvoie une liste de taille et pos permet de fixer quelles matrices seront dans la liste de sortie (permet par exemple de sauter les\n\tespaces.\"\"\"\n    if pos == False:\n        sigma = range(len(system))\n    else:\n        sigma = pos\n    liste = []\n    for i in sigma:\n        liste.append(rayoncomplx.transform(reduce(mul, list(reversed(system[0:i + 1])), 1)))\n    if complx == True:\n        for i in range(len(liste)):\n            liste[i] = liste[i].q\n    if width == True:\n        for i in range(len(liste)):\n            liste[i] = liste[i].width(0)\n    for i in range(len(liste)):\n        if i in label and system[i][0, 1] != 0:\n            if i is not 0:\n                print(\"a la fin de l'espace vide, \" + str(i) + 'e objet, q = ' + str(liste[i].q))\n            else:\n                print(\"a la fin de l'espace vide, \" + str(i) + 'e objet, q = ' + str(liste[0].q))\n        elif i in label:\n            print('a la lentille ' + str(i) + ', nous avoons q = ' + str(liste[i].q))\n    print('\\n')\n    return liste",
        "mutated": [
            "def cheminoptiquerayon(rayoncomplx, system, pos=False, width=False, complx=False, label=[]):\n    if False:\n        i = 10\n    'Renvoie une liste avec un objet RayonComplexe \u00e0 la sortie de chaque matrice ABCD. En option: complx renvoie une liste de nmbr complexe, \\n\\twidth renvoie une liste de taille et pos permet de fixer quelles matrices seront dans la liste de sortie (permet par exemple de sauter les\\n\\tespaces.'\n    if pos == False:\n        sigma = range(len(system))\n    else:\n        sigma = pos\n    liste = []\n    for i in sigma:\n        liste.append(rayoncomplx.transform(reduce(mul, list(reversed(system[0:i + 1])), 1)))\n    if complx == True:\n        for i in range(len(liste)):\n            liste[i] = liste[i].q\n    if width == True:\n        for i in range(len(liste)):\n            liste[i] = liste[i].width(0)\n    for i in range(len(liste)):\n        if i in label and system[i][0, 1] != 0:\n            if i is not 0:\n                print(\"a la fin de l'espace vide, \" + str(i) + 'e objet, q = ' + str(liste[i].q))\n            else:\n                print(\"a la fin de l'espace vide, \" + str(i) + 'e objet, q = ' + str(liste[0].q))\n        elif i in label:\n            print('a la lentille ' + str(i) + ', nous avoons q = ' + str(liste[i].q))\n    print('\\n')\n    return liste",
            "def cheminoptiquerayon(rayoncomplx, system, pos=False, width=False, complx=False, label=[]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Renvoie une liste avec un objet RayonComplexe \u00e0 la sortie de chaque matrice ABCD. En option: complx renvoie une liste de nmbr complexe, \\n\\twidth renvoie une liste de taille et pos permet de fixer quelles matrices seront dans la liste de sortie (permet par exemple de sauter les\\n\\tespaces.'\n    if pos == False:\n        sigma = range(len(system))\n    else:\n        sigma = pos\n    liste = []\n    for i in sigma:\n        liste.append(rayoncomplx.transform(reduce(mul, list(reversed(system[0:i + 1])), 1)))\n    if complx == True:\n        for i in range(len(liste)):\n            liste[i] = liste[i].q\n    if width == True:\n        for i in range(len(liste)):\n            liste[i] = liste[i].width(0)\n    for i in range(len(liste)):\n        if i in label and system[i][0, 1] != 0:\n            if i is not 0:\n                print(\"a la fin de l'espace vide, \" + str(i) + 'e objet, q = ' + str(liste[i].q))\n            else:\n                print(\"a la fin de l'espace vide, \" + str(i) + 'e objet, q = ' + str(liste[0].q))\n        elif i in label:\n            print('a la lentille ' + str(i) + ', nous avoons q = ' + str(liste[i].q))\n    print('\\n')\n    return liste",
            "def cheminoptiquerayon(rayoncomplx, system, pos=False, width=False, complx=False, label=[]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Renvoie une liste avec un objet RayonComplexe \u00e0 la sortie de chaque matrice ABCD. En option: complx renvoie une liste de nmbr complexe, \\n\\twidth renvoie une liste de taille et pos permet de fixer quelles matrices seront dans la liste de sortie (permet par exemple de sauter les\\n\\tespaces.'\n    if pos == False:\n        sigma = range(len(system))\n    else:\n        sigma = pos\n    liste = []\n    for i in sigma:\n        liste.append(rayoncomplx.transform(reduce(mul, list(reversed(system[0:i + 1])), 1)))\n    if complx == True:\n        for i in range(len(liste)):\n            liste[i] = liste[i].q\n    if width == True:\n        for i in range(len(liste)):\n            liste[i] = liste[i].width(0)\n    for i in range(len(liste)):\n        if i in label and system[i][0, 1] != 0:\n            if i is not 0:\n                print(\"a la fin de l'espace vide, \" + str(i) + 'e objet, q = ' + str(liste[i].q))\n            else:\n                print(\"a la fin de l'espace vide, \" + str(i) + 'e objet, q = ' + str(liste[0].q))\n        elif i in label:\n            print('a la lentille ' + str(i) + ', nous avoons q = ' + str(liste[i].q))\n    print('\\n')\n    return liste",
            "def cheminoptiquerayon(rayoncomplx, system, pos=False, width=False, complx=False, label=[]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Renvoie une liste avec un objet RayonComplexe \u00e0 la sortie de chaque matrice ABCD. En option: complx renvoie une liste de nmbr complexe, \\n\\twidth renvoie une liste de taille et pos permet de fixer quelles matrices seront dans la liste de sortie (permet par exemple de sauter les\\n\\tespaces.'\n    if pos == False:\n        sigma = range(len(system))\n    else:\n        sigma = pos\n    liste = []\n    for i in sigma:\n        liste.append(rayoncomplx.transform(reduce(mul, list(reversed(system[0:i + 1])), 1)))\n    if complx == True:\n        for i in range(len(liste)):\n            liste[i] = liste[i].q\n    if width == True:\n        for i in range(len(liste)):\n            liste[i] = liste[i].width(0)\n    for i in range(len(liste)):\n        if i in label and system[i][0, 1] != 0:\n            if i is not 0:\n                print(\"a la fin de l'espace vide, \" + str(i) + 'e objet, q = ' + str(liste[i].q))\n            else:\n                print(\"a la fin de l'espace vide, \" + str(i) + 'e objet, q = ' + str(liste[0].q))\n        elif i in label:\n            print('a la lentille ' + str(i) + ', nous avoons q = ' + str(liste[i].q))\n    print('\\n')\n    return liste",
            "def cheminoptiquerayon(rayoncomplx, system, pos=False, width=False, complx=False, label=[]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Renvoie une liste avec un objet RayonComplexe \u00e0 la sortie de chaque matrice ABCD. En option: complx renvoie une liste de nmbr complexe, \\n\\twidth renvoie une liste de taille et pos permet de fixer quelles matrices seront dans la liste de sortie (permet par exemple de sauter les\\n\\tespaces.'\n    if pos == False:\n        sigma = range(len(system))\n    else:\n        sigma = pos\n    liste = []\n    for i in sigma:\n        liste.append(rayoncomplx.transform(reduce(mul, list(reversed(system[0:i + 1])), 1)))\n    if complx == True:\n        for i in range(len(liste)):\n            liste[i] = liste[i].q\n    if width == True:\n        for i in range(len(liste)):\n            liste[i] = liste[i].width(0)\n    for i in range(len(liste)):\n        if i in label and system[i][0, 1] != 0:\n            if i is not 0:\n                print(\"a la fin de l'espace vide, \" + str(i) + 'e objet, q = ' + str(liste[i].q))\n            else:\n                print(\"a la fin de l'espace vide, \" + str(i) + 'e objet, q = ' + str(liste[0].q))\n        elif i in label:\n            print('a la lentille ' + str(i) + ', nous avoons q = ' + str(liste[i].q))\n    print('\\n')\n    return liste"
        ]
    },
    {
        "func_name": "plot",
        "original": "def plot(fct, deb, fin, offset=1j, div=1000000, label=False):\n    \"\"\"Simple fonction permettant de produire un graphique avec une fonction a un argument en entr\u00e9e\"\"\"\n    if isinstance(offset, complex):\n        offset = -deb\n    xdiv = np.linspace(deb, fin, div)\n    ydiv = fct(xdiv + offset)\n    if label:\n        label = ydiv[-1]\n        for y in range(1, len(ydiv)):\n            if ydiv[y] > ydiv[y - 1]:\n                label = ydiv[y]\n                break\n        nround = 5 - int(np.ceil(np.log10(label * 10 ** 6)))\n        if nround <= 0:\n            mpl.plot(xdiv, ydiv, label=str(int(label * 10 ** 6)) + '$\\\\mu m$')\n        else:\n            mpl.plot(xdiv, ydiv, label=str(round(label * 10 ** 6, nround)) + '$\\\\mu m$')\n    else:\n        mpl.plot(xdiv, ydiv)",
        "mutated": [
            "def plot(fct, deb, fin, offset=1j, div=1000000, label=False):\n    if False:\n        i = 10\n    'Simple fonction permettant de produire un graphique avec une fonction a un argument en entr\u00e9e'\n    if isinstance(offset, complex):\n        offset = -deb\n    xdiv = np.linspace(deb, fin, div)\n    ydiv = fct(xdiv + offset)\n    if label:\n        label = ydiv[-1]\n        for y in range(1, len(ydiv)):\n            if ydiv[y] > ydiv[y - 1]:\n                label = ydiv[y]\n                break\n        nround = 5 - int(np.ceil(np.log10(label * 10 ** 6)))\n        if nround <= 0:\n            mpl.plot(xdiv, ydiv, label=str(int(label * 10 ** 6)) + '$\\\\mu m$')\n        else:\n            mpl.plot(xdiv, ydiv, label=str(round(label * 10 ** 6, nround)) + '$\\\\mu m$')\n    else:\n        mpl.plot(xdiv, ydiv)",
            "def plot(fct, deb, fin, offset=1j, div=1000000, label=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Simple fonction permettant de produire un graphique avec une fonction a un argument en entr\u00e9e'\n    if isinstance(offset, complex):\n        offset = -deb\n    xdiv = np.linspace(deb, fin, div)\n    ydiv = fct(xdiv + offset)\n    if label:\n        label = ydiv[-1]\n        for y in range(1, len(ydiv)):\n            if ydiv[y] > ydiv[y - 1]:\n                label = ydiv[y]\n                break\n        nround = 5 - int(np.ceil(np.log10(label * 10 ** 6)))\n        if nround <= 0:\n            mpl.plot(xdiv, ydiv, label=str(int(label * 10 ** 6)) + '$\\\\mu m$')\n        else:\n            mpl.plot(xdiv, ydiv, label=str(round(label * 10 ** 6, nround)) + '$\\\\mu m$')\n    else:\n        mpl.plot(xdiv, ydiv)",
            "def plot(fct, deb, fin, offset=1j, div=1000000, label=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Simple fonction permettant de produire un graphique avec une fonction a un argument en entr\u00e9e'\n    if isinstance(offset, complex):\n        offset = -deb\n    xdiv = np.linspace(deb, fin, div)\n    ydiv = fct(xdiv + offset)\n    if label:\n        label = ydiv[-1]\n        for y in range(1, len(ydiv)):\n            if ydiv[y] > ydiv[y - 1]:\n                label = ydiv[y]\n                break\n        nround = 5 - int(np.ceil(np.log10(label * 10 ** 6)))\n        if nround <= 0:\n            mpl.plot(xdiv, ydiv, label=str(int(label * 10 ** 6)) + '$\\\\mu m$')\n        else:\n            mpl.plot(xdiv, ydiv, label=str(round(label * 10 ** 6, nround)) + '$\\\\mu m$')\n    else:\n        mpl.plot(xdiv, ydiv)",
            "def plot(fct, deb, fin, offset=1j, div=1000000, label=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Simple fonction permettant de produire un graphique avec une fonction a un argument en entr\u00e9e'\n    if isinstance(offset, complex):\n        offset = -deb\n    xdiv = np.linspace(deb, fin, div)\n    ydiv = fct(xdiv + offset)\n    if label:\n        label = ydiv[-1]\n        for y in range(1, len(ydiv)):\n            if ydiv[y] > ydiv[y - 1]:\n                label = ydiv[y]\n                break\n        nround = 5 - int(np.ceil(np.log10(label * 10 ** 6)))\n        if nround <= 0:\n            mpl.plot(xdiv, ydiv, label=str(int(label * 10 ** 6)) + '$\\\\mu m$')\n        else:\n            mpl.plot(xdiv, ydiv, label=str(round(label * 10 ** 6, nround)) + '$\\\\mu m$')\n    else:\n        mpl.plot(xdiv, ydiv)",
            "def plot(fct, deb, fin, offset=1j, div=1000000, label=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Simple fonction permettant de produire un graphique avec une fonction a un argument en entr\u00e9e'\n    if isinstance(offset, complex):\n        offset = -deb\n    xdiv = np.linspace(deb, fin, div)\n    ydiv = fct(xdiv + offset)\n    if label:\n        label = ydiv[-1]\n        for y in range(1, len(ydiv)):\n            if ydiv[y] > ydiv[y - 1]:\n                label = ydiv[y]\n                break\n        nround = 5 - int(np.ceil(np.log10(label * 10 ** 6)))\n        if nround <= 0:\n            mpl.plot(xdiv, ydiv, label=str(int(label * 10 ** 6)) + '$\\\\mu m$')\n        else:\n            mpl.plot(xdiv, ydiv, label=str(round(label * 10 ** 6, nround)) + '$\\\\mu m$')\n    else:\n        mpl.plot(xdiv, ydiv)"
        ]
    },
    {
        "func_name": "tracerLentille",
        "original": "def tracerLentille(pos, hauteur, longtot, hauteurmax):\n    l = (longtot / 20 * hauteur / hauteurmax) ** 2\n    x = [pos - np.sqrt(l)]\n    y = [0]\n    v = [pos - np.sqrt(l)]\n    w = [0]\n    for i in np.linspace(-np.sqrt(l), np.sqrt(l), 5000):\n        y.append(np.sqrt(hauteur ** 2 * (1 - i ** 2 / l)))\n        x.append(i + pos)\n        y.append(0)\n        x.append(i + pos)\n        w.append(np.sqrt(hauteur ** 2 * (1 - i ** 2 / l)))\n        v.append(i + pos)\n    x.append(pos + np.sqrt(l))\n    y.append(0)\n    v.append(pos + np.sqrt(l))\n    w.append(0)\n    mpl.plot(x, y, color='lightblue')\n    mpl.plot(v, w, 'k')",
        "mutated": [
            "def tracerLentille(pos, hauteur, longtot, hauteurmax):\n    if False:\n        i = 10\n    l = (longtot / 20 * hauteur / hauteurmax) ** 2\n    x = [pos - np.sqrt(l)]\n    y = [0]\n    v = [pos - np.sqrt(l)]\n    w = [0]\n    for i in np.linspace(-np.sqrt(l), np.sqrt(l), 5000):\n        y.append(np.sqrt(hauteur ** 2 * (1 - i ** 2 / l)))\n        x.append(i + pos)\n        y.append(0)\n        x.append(i + pos)\n        w.append(np.sqrt(hauteur ** 2 * (1 - i ** 2 / l)))\n        v.append(i + pos)\n    x.append(pos + np.sqrt(l))\n    y.append(0)\n    v.append(pos + np.sqrt(l))\n    w.append(0)\n    mpl.plot(x, y, color='lightblue')\n    mpl.plot(v, w, 'k')",
            "def tracerLentille(pos, hauteur, longtot, hauteurmax):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    l = (longtot / 20 * hauteur / hauteurmax) ** 2\n    x = [pos - np.sqrt(l)]\n    y = [0]\n    v = [pos - np.sqrt(l)]\n    w = [0]\n    for i in np.linspace(-np.sqrt(l), np.sqrt(l), 5000):\n        y.append(np.sqrt(hauteur ** 2 * (1 - i ** 2 / l)))\n        x.append(i + pos)\n        y.append(0)\n        x.append(i + pos)\n        w.append(np.sqrt(hauteur ** 2 * (1 - i ** 2 / l)))\n        v.append(i + pos)\n    x.append(pos + np.sqrt(l))\n    y.append(0)\n    v.append(pos + np.sqrt(l))\n    w.append(0)\n    mpl.plot(x, y, color='lightblue')\n    mpl.plot(v, w, 'k')",
            "def tracerLentille(pos, hauteur, longtot, hauteurmax):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    l = (longtot / 20 * hauteur / hauteurmax) ** 2\n    x = [pos - np.sqrt(l)]\n    y = [0]\n    v = [pos - np.sqrt(l)]\n    w = [0]\n    for i in np.linspace(-np.sqrt(l), np.sqrt(l), 5000):\n        y.append(np.sqrt(hauteur ** 2 * (1 - i ** 2 / l)))\n        x.append(i + pos)\n        y.append(0)\n        x.append(i + pos)\n        w.append(np.sqrt(hauteur ** 2 * (1 - i ** 2 / l)))\n        v.append(i + pos)\n    x.append(pos + np.sqrt(l))\n    y.append(0)\n    v.append(pos + np.sqrt(l))\n    w.append(0)\n    mpl.plot(x, y, color='lightblue')\n    mpl.plot(v, w, 'k')",
            "def tracerLentille(pos, hauteur, longtot, hauteurmax):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    l = (longtot / 20 * hauteur / hauteurmax) ** 2\n    x = [pos - np.sqrt(l)]\n    y = [0]\n    v = [pos - np.sqrt(l)]\n    w = [0]\n    for i in np.linspace(-np.sqrt(l), np.sqrt(l), 5000):\n        y.append(np.sqrt(hauteur ** 2 * (1 - i ** 2 / l)))\n        x.append(i + pos)\n        y.append(0)\n        x.append(i + pos)\n        w.append(np.sqrt(hauteur ** 2 * (1 - i ** 2 / l)))\n        v.append(i + pos)\n    x.append(pos + np.sqrt(l))\n    y.append(0)\n    v.append(pos + np.sqrt(l))\n    w.append(0)\n    mpl.plot(x, y, color='lightblue')\n    mpl.plot(v, w, 'k')",
            "def tracerLentille(pos, hauteur, longtot, hauteurmax):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    l = (longtot / 20 * hauteur / hauteurmax) ** 2\n    x = [pos - np.sqrt(l)]\n    y = [0]\n    v = [pos - np.sqrt(l)]\n    w = [0]\n    for i in np.linspace(-np.sqrt(l), np.sqrt(l), 5000):\n        y.append(np.sqrt(hauteur ** 2 * (1 - i ** 2 / l)))\n        x.append(i + pos)\n        y.append(0)\n        x.append(i + pos)\n        w.append(np.sqrt(hauteur ** 2 * (1 - i ** 2 / l)))\n        v.append(i + pos)\n    x.append(pos + np.sqrt(l))\n    y.append(0)\n    v.append(pos + np.sqrt(l))\n    w.append(0)\n    mpl.plot(x, y, color='lightblue')\n    mpl.plot(v, w, 'k')"
        ]
    },
    {
        "func_name": "propagation",
        "original": "def propagation(rayon, wavelength=488, systeme=[], affiches=[]):\n    a = RayonComplexe(rayon, wavelength)\n    b = []\n    position = [0]\n    longtot = 0\n    hauteurmax = 0\n    assert not isinstance(systeme[0], complex)\n    for i in systeme:\n        if isinstance(i, complex):\n            b.append(lens(i.imag))\n            position.append(position[-1])\n        else:\n            longtot = longtot + i\n            b.append(space(i))\n            position.append(i + position[-1])\n    c = cheminoptiquerayon(a, b, label=affiches)\n    for i in c:\n        if i.width(0) > hauteurmax:\n            hauteurmax = i.width(0)\n    for i in range(len(c)):\n        if position[i] == position[i + 1]:\n            tracerLentille(position[i], c[i].width(0), longtot, hauteurmax)\n    for i in range(len(c)):\n        if position[i] != position[i + 1]:\n            if i in affiches:\n                plot(c[i].width, position[i], position[i + 1], -position[i + 1], label=True)\n            else:\n                plot(c[i].width, position[i], position[i + 1], -position[i + 1])\n    mpl.suptitle(\"Propagation d'un laser de \" + str(wavelength) + ' nm dans le microscope, avec q = ' + str(rayon))\n    mpl.ylabel('Rayon du faisceau (m)')\n    mpl.xlabel('Position dans le montage (m)')\n    mpl.legend()\n    mpl.show()",
        "mutated": [
            "def propagation(rayon, wavelength=488, systeme=[], affiches=[]):\n    if False:\n        i = 10\n    a = RayonComplexe(rayon, wavelength)\n    b = []\n    position = [0]\n    longtot = 0\n    hauteurmax = 0\n    assert not isinstance(systeme[0], complex)\n    for i in systeme:\n        if isinstance(i, complex):\n            b.append(lens(i.imag))\n            position.append(position[-1])\n        else:\n            longtot = longtot + i\n            b.append(space(i))\n            position.append(i + position[-1])\n    c = cheminoptiquerayon(a, b, label=affiches)\n    for i in c:\n        if i.width(0) > hauteurmax:\n            hauteurmax = i.width(0)\n    for i in range(len(c)):\n        if position[i] == position[i + 1]:\n            tracerLentille(position[i], c[i].width(0), longtot, hauteurmax)\n    for i in range(len(c)):\n        if position[i] != position[i + 1]:\n            if i in affiches:\n                plot(c[i].width, position[i], position[i + 1], -position[i + 1], label=True)\n            else:\n                plot(c[i].width, position[i], position[i + 1], -position[i + 1])\n    mpl.suptitle(\"Propagation d'un laser de \" + str(wavelength) + ' nm dans le microscope, avec q = ' + str(rayon))\n    mpl.ylabel('Rayon du faisceau (m)')\n    mpl.xlabel('Position dans le montage (m)')\n    mpl.legend()\n    mpl.show()",
            "def propagation(rayon, wavelength=488, systeme=[], affiches=[]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    a = RayonComplexe(rayon, wavelength)\n    b = []\n    position = [0]\n    longtot = 0\n    hauteurmax = 0\n    assert not isinstance(systeme[0], complex)\n    for i in systeme:\n        if isinstance(i, complex):\n            b.append(lens(i.imag))\n            position.append(position[-1])\n        else:\n            longtot = longtot + i\n            b.append(space(i))\n            position.append(i + position[-1])\n    c = cheminoptiquerayon(a, b, label=affiches)\n    for i in c:\n        if i.width(0) > hauteurmax:\n            hauteurmax = i.width(0)\n    for i in range(len(c)):\n        if position[i] == position[i + 1]:\n            tracerLentille(position[i], c[i].width(0), longtot, hauteurmax)\n    for i in range(len(c)):\n        if position[i] != position[i + 1]:\n            if i in affiches:\n                plot(c[i].width, position[i], position[i + 1], -position[i + 1], label=True)\n            else:\n                plot(c[i].width, position[i], position[i + 1], -position[i + 1])\n    mpl.suptitle(\"Propagation d'un laser de \" + str(wavelength) + ' nm dans le microscope, avec q = ' + str(rayon))\n    mpl.ylabel('Rayon du faisceau (m)')\n    mpl.xlabel('Position dans le montage (m)')\n    mpl.legend()\n    mpl.show()",
            "def propagation(rayon, wavelength=488, systeme=[], affiches=[]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    a = RayonComplexe(rayon, wavelength)\n    b = []\n    position = [0]\n    longtot = 0\n    hauteurmax = 0\n    assert not isinstance(systeme[0], complex)\n    for i in systeme:\n        if isinstance(i, complex):\n            b.append(lens(i.imag))\n            position.append(position[-1])\n        else:\n            longtot = longtot + i\n            b.append(space(i))\n            position.append(i + position[-1])\n    c = cheminoptiquerayon(a, b, label=affiches)\n    for i in c:\n        if i.width(0) > hauteurmax:\n            hauteurmax = i.width(0)\n    for i in range(len(c)):\n        if position[i] == position[i + 1]:\n            tracerLentille(position[i], c[i].width(0), longtot, hauteurmax)\n    for i in range(len(c)):\n        if position[i] != position[i + 1]:\n            if i in affiches:\n                plot(c[i].width, position[i], position[i + 1], -position[i + 1], label=True)\n            else:\n                plot(c[i].width, position[i], position[i + 1], -position[i + 1])\n    mpl.suptitle(\"Propagation d'un laser de \" + str(wavelength) + ' nm dans le microscope, avec q = ' + str(rayon))\n    mpl.ylabel('Rayon du faisceau (m)')\n    mpl.xlabel('Position dans le montage (m)')\n    mpl.legend()\n    mpl.show()",
            "def propagation(rayon, wavelength=488, systeme=[], affiches=[]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    a = RayonComplexe(rayon, wavelength)\n    b = []\n    position = [0]\n    longtot = 0\n    hauteurmax = 0\n    assert not isinstance(systeme[0], complex)\n    for i in systeme:\n        if isinstance(i, complex):\n            b.append(lens(i.imag))\n            position.append(position[-1])\n        else:\n            longtot = longtot + i\n            b.append(space(i))\n            position.append(i + position[-1])\n    c = cheminoptiquerayon(a, b, label=affiches)\n    for i in c:\n        if i.width(0) > hauteurmax:\n            hauteurmax = i.width(0)\n    for i in range(len(c)):\n        if position[i] == position[i + 1]:\n            tracerLentille(position[i], c[i].width(0), longtot, hauteurmax)\n    for i in range(len(c)):\n        if position[i] != position[i + 1]:\n            if i in affiches:\n                plot(c[i].width, position[i], position[i + 1], -position[i + 1], label=True)\n            else:\n                plot(c[i].width, position[i], position[i + 1], -position[i + 1])\n    mpl.suptitle(\"Propagation d'un laser de \" + str(wavelength) + ' nm dans le microscope, avec q = ' + str(rayon))\n    mpl.ylabel('Rayon du faisceau (m)')\n    mpl.xlabel('Position dans le montage (m)')\n    mpl.legend()\n    mpl.show()",
            "def propagation(rayon, wavelength=488, systeme=[], affiches=[]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    a = RayonComplexe(rayon, wavelength)\n    b = []\n    position = [0]\n    longtot = 0\n    hauteurmax = 0\n    assert not isinstance(systeme[0], complex)\n    for i in systeme:\n        if isinstance(i, complex):\n            b.append(lens(i.imag))\n            position.append(position[-1])\n        else:\n            longtot = longtot + i\n            b.append(space(i))\n            position.append(i + position[-1])\n    c = cheminoptiquerayon(a, b, label=affiches)\n    for i in c:\n        if i.width(0) > hauteurmax:\n            hauteurmax = i.width(0)\n    for i in range(len(c)):\n        if position[i] == position[i + 1]:\n            tracerLentille(position[i], c[i].width(0), longtot, hauteurmax)\n    for i in range(len(c)):\n        if position[i] != position[i + 1]:\n            if i in affiches:\n                plot(c[i].width, position[i], position[i + 1], -position[i + 1], label=True)\n            else:\n                plot(c[i].width, position[i], position[i + 1], -position[i + 1])\n    mpl.suptitle(\"Propagation d'un laser de \" + str(wavelength) + ' nm dans le microscope, avec q = ' + str(rayon))\n    mpl.ylabel('Rayon du faisceau (m)')\n    mpl.xlabel('Position dans le montage (m)')\n    mpl.legend()\n    mpl.show()"
        ]
    }
]