[
    {
        "func_name": "__init__",
        "original": "def __init__(self, prices, n_bins, vol_adj=None, window=None):\n    \"\"\"\n        :param prices: (pd.DataFrame) Asset prices.\n        :param n_bins: (int) Number of bins to determine the quantiles for defining the tail sets. The top and\n                        bottom quantiles are considered to be the positive and negative tail sets, respectively.\n        :param vol_adj: (str) Whether to take volatility adjusted returns. Allowable inputs are ``None``,\n                        ``mean_abs_dev``, and ``stdev``.\n        :param window: (int) Window period used in the calculation of the volatility adjusted returns, if vol_adj is not\n                        None. Has no impact if vol_adj is None.\n        \"\"\"\n    pass",
        "mutated": [
            "def __init__(self, prices, n_bins, vol_adj=None, window=None):\n    if False:\n        i = 10\n    '\\n        :param prices: (pd.DataFrame) Asset prices.\\n        :param n_bins: (int) Number of bins to determine the quantiles for defining the tail sets. The top and\\n                        bottom quantiles are considered to be the positive and negative tail sets, respectively.\\n        :param vol_adj: (str) Whether to take volatility adjusted returns. Allowable inputs are ``None``,\\n                        ``mean_abs_dev``, and ``stdev``.\\n        :param window: (int) Window period used in the calculation of the volatility adjusted returns, if vol_adj is not\\n                        None. Has no impact if vol_adj is None.\\n        '\n    pass",
            "def __init__(self, prices, n_bins, vol_adj=None, window=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :param prices: (pd.DataFrame) Asset prices.\\n        :param n_bins: (int) Number of bins to determine the quantiles for defining the tail sets. The top and\\n                        bottom quantiles are considered to be the positive and negative tail sets, respectively.\\n        :param vol_adj: (str) Whether to take volatility adjusted returns. Allowable inputs are ``None``,\\n                        ``mean_abs_dev``, and ``stdev``.\\n        :param window: (int) Window period used in the calculation of the volatility adjusted returns, if vol_adj is not\\n                        None. Has no impact if vol_adj is None.\\n        '\n    pass",
            "def __init__(self, prices, n_bins, vol_adj=None, window=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :param prices: (pd.DataFrame) Asset prices.\\n        :param n_bins: (int) Number of bins to determine the quantiles for defining the tail sets. The top and\\n                        bottom quantiles are considered to be the positive and negative tail sets, respectively.\\n        :param vol_adj: (str) Whether to take volatility adjusted returns. Allowable inputs are ``None``,\\n                        ``mean_abs_dev``, and ``stdev``.\\n        :param window: (int) Window period used in the calculation of the volatility adjusted returns, if vol_adj is not\\n                        None. Has no impact if vol_adj is None.\\n        '\n    pass",
            "def __init__(self, prices, n_bins, vol_adj=None, window=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :param prices: (pd.DataFrame) Asset prices.\\n        :param n_bins: (int) Number of bins to determine the quantiles for defining the tail sets. The top and\\n                        bottom quantiles are considered to be the positive and negative tail sets, respectively.\\n        :param vol_adj: (str) Whether to take volatility adjusted returns. Allowable inputs are ``None``,\\n                        ``mean_abs_dev``, and ``stdev``.\\n        :param window: (int) Window period used in the calculation of the volatility adjusted returns, if vol_adj is not\\n                        None. Has no impact if vol_adj is None.\\n        '\n    pass",
            "def __init__(self, prices, n_bins, vol_adj=None, window=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :param prices: (pd.DataFrame) Asset prices.\\n        :param n_bins: (int) Number of bins to determine the quantiles for defining the tail sets. The top and\\n                        bottom quantiles are considered to be the positive and negative tail sets, respectively.\\n        :param vol_adj: (str) Whether to take volatility adjusted returns. Allowable inputs are ``None``,\\n                        ``mean_abs_dev``, and ``stdev``.\\n        :param window: (int) Window period used in the calculation of the volatility adjusted returns, if vol_adj is not\\n                        None. Has no impact if vol_adj is None.\\n        '\n    pass"
        ]
    },
    {
        "func_name": "get_tail_sets",
        "original": "def get_tail_sets(self):\n    \"\"\"\n        Computes the tail sets (positive and negative) and then returns a tuple with 3 elements, positive set, negative\n        set, full matrix set.\n\n        The positive and negative sets are each a series of lists with the names of the securities that fall within each\n        set at a specific timestamp.\n\n        For the full matrix a value of 1 indicates the volatility adjusted returns were in the top quantile, a value of\n        -1 for the bottom quantile.\n        :return: (tuple) positive set, negative set, full matrix set.\n        \"\"\"\n    pass",
        "mutated": [
            "def get_tail_sets(self):\n    if False:\n        i = 10\n    '\\n        Computes the tail sets (positive and negative) and then returns a tuple with 3 elements, positive set, negative\\n        set, full matrix set.\\n\\n        The positive and negative sets are each a series of lists with the names of the securities that fall within each\\n        set at a specific timestamp.\\n\\n        For the full matrix a value of 1 indicates the volatility adjusted returns were in the top quantile, a value of\\n        -1 for the bottom quantile.\\n        :return: (tuple) positive set, negative set, full matrix set.\\n        '\n    pass",
            "def get_tail_sets(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Computes the tail sets (positive and negative) and then returns a tuple with 3 elements, positive set, negative\\n        set, full matrix set.\\n\\n        The positive and negative sets are each a series of lists with the names of the securities that fall within each\\n        set at a specific timestamp.\\n\\n        For the full matrix a value of 1 indicates the volatility adjusted returns were in the top quantile, a value of\\n        -1 for the bottom quantile.\\n        :return: (tuple) positive set, negative set, full matrix set.\\n        '\n    pass",
            "def get_tail_sets(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Computes the tail sets (positive and negative) and then returns a tuple with 3 elements, positive set, negative\\n        set, full matrix set.\\n\\n        The positive and negative sets are each a series of lists with the names of the securities that fall within each\\n        set at a specific timestamp.\\n\\n        For the full matrix a value of 1 indicates the volatility adjusted returns were in the top quantile, a value of\\n        -1 for the bottom quantile.\\n        :return: (tuple) positive set, negative set, full matrix set.\\n        '\n    pass",
            "def get_tail_sets(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Computes the tail sets (positive and negative) and then returns a tuple with 3 elements, positive set, negative\\n        set, full matrix set.\\n\\n        The positive and negative sets are each a series of lists with the names of the securities that fall within each\\n        set at a specific timestamp.\\n\\n        For the full matrix a value of 1 indicates the volatility adjusted returns were in the top quantile, a value of\\n        -1 for the bottom quantile.\\n        :return: (tuple) positive set, negative set, full matrix set.\\n        '\n    pass",
            "def get_tail_sets(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Computes the tail sets (positive and negative) and then returns a tuple with 3 elements, positive set, negative\\n        set, full matrix set.\\n\\n        The positive and negative sets are each a series of lists with the names of the securities that fall within each\\n        set at a specific timestamp.\\n\\n        For the full matrix a value of 1 indicates the volatility adjusted returns were in the top quantile, a value of\\n        -1 for the bottom quantile.\\n        :return: (tuple) positive set, negative set, full matrix set.\\n        '\n    pass"
        ]
    },
    {
        "func_name": "_vol_adjusted_rets",
        "original": "def _vol_adjusted_rets(self):\n    \"\"\"\n        Computes the volatility adjusted returns. This is simply the log returns divided by a volatility estimate. We\n        have provided 2 techniques for volatility estimation: an exponential moving average and the traditional standard\n        deviation.\n        \"\"\"\n    pass",
        "mutated": [
            "def _vol_adjusted_rets(self):\n    if False:\n        i = 10\n    '\\n        Computes the volatility adjusted returns. This is simply the log returns divided by a volatility estimate. We\\n        have provided 2 techniques for volatility estimation: an exponential moving average and the traditional standard\\n        deviation.\\n        '\n    pass",
            "def _vol_adjusted_rets(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Computes the volatility adjusted returns. This is simply the log returns divided by a volatility estimate. We\\n        have provided 2 techniques for volatility estimation: an exponential moving average and the traditional standard\\n        deviation.\\n        '\n    pass",
            "def _vol_adjusted_rets(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Computes the volatility adjusted returns. This is simply the log returns divided by a volatility estimate. We\\n        have provided 2 techniques for volatility estimation: an exponential moving average and the traditional standard\\n        deviation.\\n        '\n    pass",
            "def _vol_adjusted_rets(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Computes the volatility adjusted returns. This is simply the log returns divided by a volatility estimate. We\\n        have provided 2 techniques for volatility estimation: an exponential moving average and the traditional standard\\n        deviation.\\n        '\n    pass",
            "def _vol_adjusted_rets(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Computes the volatility adjusted returns. This is simply the log returns divided by a volatility estimate. We\\n        have provided 2 techniques for volatility estimation: an exponential moving average and the traditional standard\\n        deviation.\\n        '\n    pass"
        ]
    },
    {
        "func_name": "_extract_tail_sets",
        "original": "def _extract_tail_sets(self, row):\n    \"\"\"\n        Method used in a .apply() setting to transform each row in a DataFrame to the positive and negative tail sets.\n\n        This method splits the data into quantiles determined by the user, with n_bins.\n\n        :param row: (pd.Series) Vol adjusted returns for a given date.\n        :return: (pd.Series) Tail set with positive and negative labels.\n        \"\"\"\n    pass",
        "mutated": [
            "def _extract_tail_sets(self, row):\n    if False:\n        i = 10\n    '\\n        Method used in a .apply() setting to transform each row in a DataFrame to the positive and negative tail sets.\\n\\n        This method splits the data into quantiles determined by the user, with n_bins.\\n\\n        :param row: (pd.Series) Vol adjusted returns for a given date.\\n        :return: (pd.Series) Tail set with positive and negative labels.\\n        '\n    pass",
            "def _extract_tail_sets(self, row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Method used in a .apply() setting to transform each row in a DataFrame to the positive and negative tail sets.\\n\\n        This method splits the data into quantiles determined by the user, with n_bins.\\n\\n        :param row: (pd.Series) Vol adjusted returns for a given date.\\n        :return: (pd.Series) Tail set with positive and negative labels.\\n        '\n    pass",
            "def _extract_tail_sets(self, row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Method used in a .apply() setting to transform each row in a DataFrame to the positive and negative tail sets.\\n\\n        This method splits the data into quantiles determined by the user, with n_bins.\\n\\n        :param row: (pd.Series) Vol adjusted returns for a given date.\\n        :return: (pd.Series) Tail set with positive and negative labels.\\n        '\n    pass",
            "def _extract_tail_sets(self, row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Method used in a .apply() setting to transform each row in a DataFrame to the positive and negative tail sets.\\n\\n        This method splits the data into quantiles determined by the user, with n_bins.\\n\\n        :param row: (pd.Series) Vol adjusted returns for a given date.\\n        :return: (pd.Series) Tail set with positive and negative labels.\\n        '\n    pass",
            "def _extract_tail_sets(self, row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Method used in a .apply() setting to transform each row in a DataFrame to the positive and negative tail sets.\\n\\n        This method splits the data into quantiles determined by the user, with n_bins.\\n\\n        :param row: (pd.Series) Vol adjusted returns for a given date.\\n        :return: (pd.Series) Tail set with positive and negative labels.\\n        '\n    pass"
        ]
    },
    {
        "func_name": "_positive_tail_set",
        "original": "@staticmethod\ndef _positive_tail_set(row):\n    \"\"\"\n        Takes as input a row from the vol_adj_ret DataFrame and then returns a list of names of the securities in the\n        positive tail set, for this specific row date.\n\n        This method is used in an apply() setting.\n\n        :param row: (pd.Series) Labeled row of several stocks where each is already labeled with +1 (positive tail set),\n                    -1 (negative tail set), or 0.\n        :return: (list) Securities in the positive tail set.\n        \"\"\"\n    pass",
        "mutated": [
            "@staticmethod\ndef _positive_tail_set(row):\n    if False:\n        i = 10\n    '\\n        Takes as input a row from the vol_adj_ret DataFrame and then returns a list of names of the securities in the\\n        positive tail set, for this specific row date.\\n\\n        This method is used in an apply() setting.\\n\\n        :param row: (pd.Series) Labeled row of several stocks where each is already labeled with +1 (positive tail set),\\n                    -1 (negative tail set), or 0.\\n        :return: (list) Securities in the positive tail set.\\n        '\n    pass",
            "@staticmethod\ndef _positive_tail_set(row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Takes as input a row from the vol_adj_ret DataFrame and then returns a list of names of the securities in the\\n        positive tail set, for this specific row date.\\n\\n        This method is used in an apply() setting.\\n\\n        :param row: (pd.Series) Labeled row of several stocks where each is already labeled with +1 (positive tail set),\\n                    -1 (negative tail set), or 0.\\n        :return: (list) Securities in the positive tail set.\\n        '\n    pass",
            "@staticmethod\ndef _positive_tail_set(row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Takes as input a row from the vol_adj_ret DataFrame and then returns a list of names of the securities in the\\n        positive tail set, for this specific row date.\\n\\n        This method is used in an apply() setting.\\n\\n        :param row: (pd.Series) Labeled row of several stocks where each is already labeled with +1 (positive tail set),\\n                    -1 (negative tail set), or 0.\\n        :return: (list) Securities in the positive tail set.\\n        '\n    pass",
            "@staticmethod\ndef _positive_tail_set(row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Takes as input a row from the vol_adj_ret DataFrame and then returns a list of names of the securities in the\\n        positive tail set, for this specific row date.\\n\\n        This method is used in an apply() setting.\\n\\n        :param row: (pd.Series) Labeled row of several stocks where each is already labeled with +1 (positive tail set),\\n                    -1 (negative tail set), or 0.\\n        :return: (list) Securities in the positive tail set.\\n        '\n    pass",
            "@staticmethod\ndef _positive_tail_set(row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Takes as input a row from the vol_adj_ret DataFrame and then returns a list of names of the securities in the\\n        positive tail set, for this specific row date.\\n\\n        This method is used in an apply() setting.\\n\\n        :param row: (pd.Series) Labeled row of several stocks where each is already labeled with +1 (positive tail set),\\n                    -1 (negative tail set), or 0.\\n        :return: (list) Securities in the positive tail set.\\n        '\n    pass"
        ]
    },
    {
        "func_name": "_negative_tail_set",
        "original": "@staticmethod\ndef _negative_tail_set(row):\n    \"\"\"\n        Takes as input a row from the vol_adj_ret DataFrame and then returns a list of names of the securities in the\n        negative tail set, for this specific row date.\n\n        This method is used in an apply() setting.\n\n        :param row: (pd.Series) Labeled row of several stocks where each is already labeled with +1 (positive tail set),\n                    -1 (negative tail set), or 0.\n        :return: (list) Securities in the negative tail set.\n        \"\"\"\n    pass",
        "mutated": [
            "@staticmethod\ndef _negative_tail_set(row):\n    if False:\n        i = 10\n    '\\n        Takes as input a row from the vol_adj_ret DataFrame and then returns a list of names of the securities in the\\n        negative tail set, for this specific row date.\\n\\n        This method is used in an apply() setting.\\n\\n        :param row: (pd.Series) Labeled row of several stocks where each is already labeled with +1 (positive tail set),\\n                    -1 (negative tail set), or 0.\\n        :return: (list) Securities in the negative tail set.\\n        '\n    pass",
            "@staticmethod\ndef _negative_tail_set(row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Takes as input a row from the vol_adj_ret DataFrame and then returns a list of names of the securities in the\\n        negative tail set, for this specific row date.\\n\\n        This method is used in an apply() setting.\\n\\n        :param row: (pd.Series) Labeled row of several stocks where each is already labeled with +1 (positive tail set),\\n                    -1 (negative tail set), or 0.\\n        :return: (list) Securities in the negative tail set.\\n        '\n    pass",
            "@staticmethod\ndef _negative_tail_set(row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Takes as input a row from the vol_adj_ret DataFrame and then returns a list of names of the securities in the\\n        negative tail set, for this specific row date.\\n\\n        This method is used in an apply() setting.\\n\\n        :param row: (pd.Series) Labeled row of several stocks where each is already labeled with +1 (positive tail set),\\n                    -1 (negative tail set), or 0.\\n        :return: (list) Securities in the negative tail set.\\n        '\n    pass",
            "@staticmethod\ndef _negative_tail_set(row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Takes as input a row from the vol_adj_ret DataFrame and then returns a list of names of the securities in the\\n        negative tail set, for this specific row date.\\n\\n        This method is used in an apply() setting.\\n\\n        :param row: (pd.Series) Labeled row of several stocks where each is already labeled with +1 (positive tail set),\\n                    -1 (negative tail set), or 0.\\n        :return: (list) Securities in the negative tail set.\\n        '\n    pass",
            "@staticmethod\ndef _negative_tail_set(row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Takes as input a row from the vol_adj_ret DataFrame and then returns a list of names of the securities in the\\n        negative tail set, for this specific row date.\\n\\n        This method is used in an apply() setting.\\n\\n        :param row: (pd.Series) Labeled row of several stocks where each is already labeled with +1 (positive tail set),\\n                    -1 (negative tail set), or 0.\\n        :return: (list) Securities in the negative tail set.\\n        '\n    pass"
        ]
    }
]