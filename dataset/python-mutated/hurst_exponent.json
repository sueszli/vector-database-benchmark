[
    {
        "func_name": "hurst_exponent",
        "original": "def hurst_exponent(candles: np.ndarray, min_chunksize: int=8, max_chunksize: int=200, num_chunksize: int=5, method: int=1, source_type: str='close') -> float:\n    \"\"\"\n    Hurst Exponent\n\n    :param candles: np.ndarray\n    :param min_chunksize: int - default: 8\n    :param max_chunksize: int - default: 200\n    :param num_chunksize: int - default: 5\n    :param method: int - default: 1 - 0: RS | 1: DMA | 2: DSOD\n    :param source_type: str - default: \"close\"\n\n    :return: float\n    \"\"\"\n    if len(candles.shape) == 1:\n        source = candles\n    else:\n        candles = slice_candles(candles, False)\n        source = get_candle_source(candles, source_type=source_type)\n    if method == 0:\n        h = hurst_rs(np.diff(source), min_chunksize, max_chunksize, num_chunksize)\n    elif method == 1:\n        h = hurst_dma(source, min_chunksize, max_chunksize, num_chunksize)\n    elif method == 2:\n        h = hurst_dsod(source)\n    else:\n        raise NotImplementedError('The method choose is not implemented.')\n    return None if np.isnan(h) else h",
        "mutated": [
            "def hurst_exponent(candles: np.ndarray, min_chunksize: int=8, max_chunksize: int=200, num_chunksize: int=5, method: int=1, source_type: str='close') -> float:\n    if False:\n        i = 10\n    '\\n    Hurst Exponent\\n\\n    :param candles: np.ndarray\\n    :param min_chunksize: int - default: 8\\n    :param max_chunksize: int - default: 200\\n    :param num_chunksize: int - default: 5\\n    :param method: int - default: 1 - 0: RS | 1: DMA | 2: DSOD\\n    :param source_type: str - default: \"close\"\\n\\n    :return: float\\n    '\n    if len(candles.shape) == 1:\n        source = candles\n    else:\n        candles = slice_candles(candles, False)\n        source = get_candle_source(candles, source_type=source_type)\n    if method == 0:\n        h = hurst_rs(np.diff(source), min_chunksize, max_chunksize, num_chunksize)\n    elif method == 1:\n        h = hurst_dma(source, min_chunksize, max_chunksize, num_chunksize)\n    elif method == 2:\n        h = hurst_dsod(source)\n    else:\n        raise NotImplementedError('The method choose is not implemented.')\n    return None if np.isnan(h) else h",
            "def hurst_exponent(candles: np.ndarray, min_chunksize: int=8, max_chunksize: int=200, num_chunksize: int=5, method: int=1, source_type: str='close') -> float:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Hurst Exponent\\n\\n    :param candles: np.ndarray\\n    :param min_chunksize: int - default: 8\\n    :param max_chunksize: int - default: 200\\n    :param num_chunksize: int - default: 5\\n    :param method: int - default: 1 - 0: RS | 1: DMA | 2: DSOD\\n    :param source_type: str - default: \"close\"\\n\\n    :return: float\\n    '\n    if len(candles.shape) == 1:\n        source = candles\n    else:\n        candles = slice_candles(candles, False)\n        source = get_candle_source(candles, source_type=source_type)\n    if method == 0:\n        h = hurst_rs(np.diff(source), min_chunksize, max_chunksize, num_chunksize)\n    elif method == 1:\n        h = hurst_dma(source, min_chunksize, max_chunksize, num_chunksize)\n    elif method == 2:\n        h = hurst_dsod(source)\n    else:\n        raise NotImplementedError('The method choose is not implemented.')\n    return None if np.isnan(h) else h",
            "def hurst_exponent(candles: np.ndarray, min_chunksize: int=8, max_chunksize: int=200, num_chunksize: int=5, method: int=1, source_type: str='close') -> float:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Hurst Exponent\\n\\n    :param candles: np.ndarray\\n    :param min_chunksize: int - default: 8\\n    :param max_chunksize: int - default: 200\\n    :param num_chunksize: int - default: 5\\n    :param method: int - default: 1 - 0: RS | 1: DMA | 2: DSOD\\n    :param source_type: str - default: \"close\"\\n\\n    :return: float\\n    '\n    if len(candles.shape) == 1:\n        source = candles\n    else:\n        candles = slice_candles(candles, False)\n        source = get_candle_source(candles, source_type=source_type)\n    if method == 0:\n        h = hurst_rs(np.diff(source), min_chunksize, max_chunksize, num_chunksize)\n    elif method == 1:\n        h = hurst_dma(source, min_chunksize, max_chunksize, num_chunksize)\n    elif method == 2:\n        h = hurst_dsod(source)\n    else:\n        raise NotImplementedError('The method choose is not implemented.')\n    return None if np.isnan(h) else h",
            "def hurst_exponent(candles: np.ndarray, min_chunksize: int=8, max_chunksize: int=200, num_chunksize: int=5, method: int=1, source_type: str='close') -> float:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Hurst Exponent\\n\\n    :param candles: np.ndarray\\n    :param min_chunksize: int - default: 8\\n    :param max_chunksize: int - default: 200\\n    :param num_chunksize: int - default: 5\\n    :param method: int - default: 1 - 0: RS | 1: DMA | 2: DSOD\\n    :param source_type: str - default: \"close\"\\n\\n    :return: float\\n    '\n    if len(candles.shape) == 1:\n        source = candles\n    else:\n        candles = slice_candles(candles, False)\n        source = get_candle_source(candles, source_type=source_type)\n    if method == 0:\n        h = hurst_rs(np.diff(source), min_chunksize, max_chunksize, num_chunksize)\n    elif method == 1:\n        h = hurst_dma(source, min_chunksize, max_chunksize, num_chunksize)\n    elif method == 2:\n        h = hurst_dsod(source)\n    else:\n        raise NotImplementedError('The method choose is not implemented.')\n    return None if np.isnan(h) else h",
            "def hurst_exponent(candles: np.ndarray, min_chunksize: int=8, max_chunksize: int=200, num_chunksize: int=5, method: int=1, source_type: str='close') -> float:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Hurst Exponent\\n\\n    :param candles: np.ndarray\\n    :param min_chunksize: int - default: 8\\n    :param max_chunksize: int - default: 200\\n    :param num_chunksize: int - default: 5\\n    :param method: int - default: 1 - 0: RS | 1: DMA | 2: DSOD\\n    :param source_type: str - default: \"close\"\\n\\n    :return: float\\n    '\n    if len(candles.shape) == 1:\n        source = candles\n    else:\n        candles = slice_candles(candles, False)\n        source = get_candle_source(candles, source_type=source_type)\n    if method == 0:\n        h = hurst_rs(np.diff(source), min_chunksize, max_chunksize, num_chunksize)\n    elif method == 1:\n        h = hurst_dma(source, min_chunksize, max_chunksize, num_chunksize)\n    elif method == 2:\n        h = hurst_dsod(source)\n    else:\n        raise NotImplementedError('The method choose is not implemented.')\n    return None if np.isnan(h) else h"
        ]
    },
    {
        "func_name": "hurst_rs",
        "original": "@njit\ndef hurst_rs(x, min_chunksize, max_chunksize, num_chunksize):\n    \"\"\"Estimate the Hurst exponent using R/S method.\n    Estimates the Hurst (H) exponent using the R/S method from the time series.\n    The R/S method consists of dividing the series into pieces of equal size\n    `series_len` and calculating the rescaled range. This repeats the process\n    for several `series_len` values and adjusts data regression to obtain the H.\n    `series_len` will take values between `min_chunksize` and `max_chunksize`,\n    the step size from `min_chunksize` to `max_chunksize` can be controlled\n    through the parameter `step_chunksize`.\n    Parameters\n    ----------\n    x : 1D-array\n        A time series to calculate hurst exponent, must have more elements\n        than `min_chunksize` and `max_chunksize`.\n    min_chunksize : int\n        This parameter allow you control the minimum window size.\n    max_chunksize : int\n        This parameter allow you control the maximum window size.\n    num_chunksize : int\n        This parameter allow you control the size of the step from minimum to\n        maximum window size. Bigger step means fewer calculations.\n    out : 1-element-array, optional\n        one element array to store the output.\n    Returns\n    -------\n    H : float\n        A estimation of Hurst exponent.\n    References\n    ----------\n    Hurst, H. E. (1951). Long term storage capacity of reservoirs. ASCE\n    Transactions, 116(776), 770-808.\n    Alessio, E., Carbone, A., Castelli, G. et al. Eur. Phys. J. B (2002) 27:\n    197. http://dx.doi.org/10.1140/epjb/e20020150\n    \"\"\"\n    N = len(x)\n    max_chunksize += 1\n    rs_tmp = np.empty(N, dtype=np.float64)\n    chunk_size_list = np.linspace(min_chunksize, max_chunksize, num_chunksize).astype(np.int64)\n    rs_values_list = np.empty(num_chunksize, dtype=np.float64)\n    for i in range(num_chunksize):\n        chunk_size = chunk_size_list[i]\n        number_of_chunks = int(len(x) / chunk_size)\n        for idx in range(number_of_chunks):\n            ini = idx * chunk_size\n            end = ini + chunk_size\n            chunk = x[ini:end]\n            z = np.cumsum(chunk - np.mean(chunk))\n            rs_tmp[idx] = np.divide(np.max(z) - np.min(z), np.nanstd(chunk))\n        rs_values_list[i] = np.nanmean(rs_tmp[:idx + 1])\n    (H, c) = np.linalg.lstsq(a=np.vstack((np.log(chunk_size_list), np.ones(num_chunksize))).T, b=np.log(rs_values_list))[0]\n    return H",
        "mutated": [
            "@njit\ndef hurst_rs(x, min_chunksize, max_chunksize, num_chunksize):\n    if False:\n        i = 10\n    'Estimate the Hurst exponent using R/S method.\\n    Estimates the Hurst (H) exponent using the R/S method from the time series.\\n    The R/S method consists of dividing the series into pieces of equal size\\n    `series_len` and calculating the rescaled range. This repeats the process\\n    for several `series_len` values and adjusts data regression to obtain the H.\\n    `series_len` will take values between `min_chunksize` and `max_chunksize`,\\n    the step size from `min_chunksize` to `max_chunksize` can be controlled\\n    through the parameter `step_chunksize`.\\n    Parameters\\n    ----------\\n    x : 1D-array\\n        A time series to calculate hurst exponent, must have more elements\\n        than `min_chunksize` and `max_chunksize`.\\n    min_chunksize : int\\n        This parameter allow you control the minimum window size.\\n    max_chunksize : int\\n        This parameter allow you control the maximum window size.\\n    num_chunksize : int\\n        This parameter allow you control the size of the step from minimum to\\n        maximum window size. Bigger step means fewer calculations.\\n    out : 1-element-array, optional\\n        one element array to store the output.\\n    Returns\\n    -------\\n    H : float\\n        A estimation of Hurst exponent.\\n    References\\n    ----------\\n    Hurst, H. E. (1951). Long term storage capacity of reservoirs. ASCE\\n    Transactions, 116(776), 770-808.\\n    Alessio, E., Carbone, A., Castelli, G. et al. Eur. Phys. J. B (2002) 27:\\n    197. http://dx.doi.org/10.1140/epjb/e20020150\\n    '\n    N = len(x)\n    max_chunksize += 1\n    rs_tmp = np.empty(N, dtype=np.float64)\n    chunk_size_list = np.linspace(min_chunksize, max_chunksize, num_chunksize).astype(np.int64)\n    rs_values_list = np.empty(num_chunksize, dtype=np.float64)\n    for i in range(num_chunksize):\n        chunk_size = chunk_size_list[i]\n        number_of_chunks = int(len(x) / chunk_size)\n        for idx in range(number_of_chunks):\n            ini = idx * chunk_size\n            end = ini + chunk_size\n            chunk = x[ini:end]\n            z = np.cumsum(chunk - np.mean(chunk))\n            rs_tmp[idx] = np.divide(np.max(z) - np.min(z), np.nanstd(chunk))\n        rs_values_list[i] = np.nanmean(rs_tmp[:idx + 1])\n    (H, c) = np.linalg.lstsq(a=np.vstack((np.log(chunk_size_list), np.ones(num_chunksize))).T, b=np.log(rs_values_list))[0]\n    return H",
            "@njit\ndef hurst_rs(x, min_chunksize, max_chunksize, num_chunksize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Estimate the Hurst exponent using R/S method.\\n    Estimates the Hurst (H) exponent using the R/S method from the time series.\\n    The R/S method consists of dividing the series into pieces of equal size\\n    `series_len` and calculating the rescaled range. This repeats the process\\n    for several `series_len` values and adjusts data regression to obtain the H.\\n    `series_len` will take values between `min_chunksize` and `max_chunksize`,\\n    the step size from `min_chunksize` to `max_chunksize` can be controlled\\n    through the parameter `step_chunksize`.\\n    Parameters\\n    ----------\\n    x : 1D-array\\n        A time series to calculate hurst exponent, must have more elements\\n        than `min_chunksize` and `max_chunksize`.\\n    min_chunksize : int\\n        This parameter allow you control the minimum window size.\\n    max_chunksize : int\\n        This parameter allow you control the maximum window size.\\n    num_chunksize : int\\n        This parameter allow you control the size of the step from minimum to\\n        maximum window size. Bigger step means fewer calculations.\\n    out : 1-element-array, optional\\n        one element array to store the output.\\n    Returns\\n    -------\\n    H : float\\n        A estimation of Hurst exponent.\\n    References\\n    ----------\\n    Hurst, H. E. (1951). Long term storage capacity of reservoirs. ASCE\\n    Transactions, 116(776), 770-808.\\n    Alessio, E., Carbone, A., Castelli, G. et al. Eur. Phys. J. B (2002) 27:\\n    197. http://dx.doi.org/10.1140/epjb/e20020150\\n    '\n    N = len(x)\n    max_chunksize += 1\n    rs_tmp = np.empty(N, dtype=np.float64)\n    chunk_size_list = np.linspace(min_chunksize, max_chunksize, num_chunksize).astype(np.int64)\n    rs_values_list = np.empty(num_chunksize, dtype=np.float64)\n    for i in range(num_chunksize):\n        chunk_size = chunk_size_list[i]\n        number_of_chunks = int(len(x) / chunk_size)\n        for idx in range(number_of_chunks):\n            ini = idx * chunk_size\n            end = ini + chunk_size\n            chunk = x[ini:end]\n            z = np.cumsum(chunk - np.mean(chunk))\n            rs_tmp[idx] = np.divide(np.max(z) - np.min(z), np.nanstd(chunk))\n        rs_values_list[i] = np.nanmean(rs_tmp[:idx + 1])\n    (H, c) = np.linalg.lstsq(a=np.vstack((np.log(chunk_size_list), np.ones(num_chunksize))).T, b=np.log(rs_values_list))[0]\n    return H",
            "@njit\ndef hurst_rs(x, min_chunksize, max_chunksize, num_chunksize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Estimate the Hurst exponent using R/S method.\\n    Estimates the Hurst (H) exponent using the R/S method from the time series.\\n    The R/S method consists of dividing the series into pieces of equal size\\n    `series_len` and calculating the rescaled range. This repeats the process\\n    for several `series_len` values and adjusts data regression to obtain the H.\\n    `series_len` will take values between `min_chunksize` and `max_chunksize`,\\n    the step size from `min_chunksize` to `max_chunksize` can be controlled\\n    through the parameter `step_chunksize`.\\n    Parameters\\n    ----------\\n    x : 1D-array\\n        A time series to calculate hurst exponent, must have more elements\\n        than `min_chunksize` and `max_chunksize`.\\n    min_chunksize : int\\n        This parameter allow you control the minimum window size.\\n    max_chunksize : int\\n        This parameter allow you control the maximum window size.\\n    num_chunksize : int\\n        This parameter allow you control the size of the step from minimum to\\n        maximum window size. Bigger step means fewer calculations.\\n    out : 1-element-array, optional\\n        one element array to store the output.\\n    Returns\\n    -------\\n    H : float\\n        A estimation of Hurst exponent.\\n    References\\n    ----------\\n    Hurst, H. E. (1951). Long term storage capacity of reservoirs. ASCE\\n    Transactions, 116(776), 770-808.\\n    Alessio, E., Carbone, A., Castelli, G. et al. Eur. Phys. J. B (2002) 27:\\n    197. http://dx.doi.org/10.1140/epjb/e20020150\\n    '\n    N = len(x)\n    max_chunksize += 1\n    rs_tmp = np.empty(N, dtype=np.float64)\n    chunk_size_list = np.linspace(min_chunksize, max_chunksize, num_chunksize).astype(np.int64)\n    rs_values_list = np.empty(num_chunksize, dtype=np.float64)\n    for i in range(num_chunksize):\n        chunk_size = chunk_size_list[i]\n        number_of_chunks = int(len(x) / chunk_size)\n        for idx in range(number_of_chunks):\n            ini = idx * chunk_size\n            end = ini + chunk_size\n            chunk = x[ini:end]\n            z = np.cumsum(chunk - np.mean(chunk))\n            rs_tmp[idx] = np.divide(np.max(z) - np.min(z), np.nanstd(chunk))\n        rs_values_list[i] = np.nanmean(rs_tmp[:idx + 1])\n    (H, c) = np.linalg.lstsq(a=np.vstack((np.log(chunk_size_list), np.ones(num_chunksize))).T, b=np.log(rs_values_list))[0]\n    return H",
            "@njit\ndef hurst_rs(x, min_chunksize, max_chunksize, num_chunksize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Estimate the Hurst exponent using R/S method.\\n    Estimates the Hurst (H) exponent using the R/S method from the time series.\\n    The R/S method consists of dividing the series into pieces of equal size\\n    `series_len` and calculating the rescaled range. This repeats the process\\n    for several `series_len` values and adjusts data regression to obtain the H.\\n    `series_len` will take values between `min_chunksize` and `max_chunksize`,\\n    the step size from `min_chunksize` to `max_chunksize` can be controlled\\n    through the parameter `step_chunksize`.\\n    Parameters\\n    ----------\\n    x : 1D-array\\n        A time series to calculate hurst exponent, must have more elements\\n        than `min_chunksize` and `max_chunksize`.\\n    min_chunksize : int\\n        This parameter allow you control the minimum window size.\\n    max_chunksize : int\\n        This parameter allow you control the maximum window size.\\n    num_chunksize : int\\n        This parameter allow you control the size of the step from minimum to\\n        maximum window size. Bigger step means fewer calculations.\\n    out : 1-element-array, optional\\n        one element array to store the output.\\n    Returns\\n    -------\\n    H : float\\n        A estimation of Hurst exponent.\\n    References\\n    ----------\\n    Hurst, H. E. (1951). Long term storage capacity of reservoirs. ASCE\\n    Transactions, 116(776), 770-808.\\n    Alessio, E., Carbone, A., Castelli, G. et al. Eur. Phys. J. B (2002) 27:\\n    197. http://dx.doi.org/10.1140/epjb/e20020150\\n    '\n    N = len(x)\n    max_chunksize += 1\n    rs_tmp = np.empty(N, dtype=np.float64)\n    chunk_size_list = np.linspace(min_chunksize, max_chunksize, num_chunksize).astype(np.int64)\n    rs_values_list = np.empty(num_chunksize, dtype=np.float64)\n    for i in range(num_chunksize):\n        chunk_size = chunk_size_list[i]\n        number_of_chunks = int(len(x) / chunk_size)\n        for idx in range(number_of_chunks):\n            ini = idx * chunk_size\n            end = ini + chunk_size\n            chunk = x[ini:end]\n            z = np.cumsum(chunk - np.mean(chunk))\n            rs_tmp[idx] = np.divide(np.max(z) - np.min(z), np.nanstd(chunk))\n        rs_values_list[i] = np.nanmean(rs_tmp[:idx + 1])\n    (H, c) = np.linalg.lstsq(a=np.vstack((np.log(chunk_size_list), np.ones(num_chunksize))).T, b=np.log(rs_values_list))[0]\n    return H",
            "@njit\ndef hurst_rs(x, min_chunksize, max_chunksize, num_chunksize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Estimate the Hurst exponent using R/S method.\\n    Estimates the Hurst (H) exponent using the R/S method from the time series.\\n    The R/S method consists of dividing the series into pieces of equal size\\n    `series_len` and calculating the rescaled range. This repeats the process\\n    for several `series_len` values and adjusts data regression to obtain the H.\\n    `series_len` will take values between `min_chunksize` and `max_chunksize`,\\n    the step size from `min_chunksize` to `max_chunksize` can be controlled\\n    through the parameter `step_chunksize`.\\n    Parameters\\n    ----------\\n    x : 1D-array\\n        A time series to calculate hurst exponent, must have more elements\\n        than `min_chunksize` and `max_chunksize`.\\n    min_chunksize : int\\n        This parameter allow you control the minimum window size.\\n    max_chunksize : int\\n        This parameter allow you control the maximum window size.\\n    num_chunksize : int\\n        This parameter allow you control the size of the step from minimum to\\n        maximum window size. Bigger step means fewer calculations.\\n    out : 1-element-array, optional\\n        one element array to store the output.\\n    Returns\\n    -------\\n    H : float\\n        A estimation of Hurst exponent.\\n    References\\n    ----------\\n    Hurst, H. E. (1951). Long term storage capacity of reservoirs. ASCE\\n    Transactions, 116(776), 770-808.\\n    Alessio, E., Carbone, A., Castelli, G. et al. Eur. Phys. J. B (2002) 27:\\n    197. http://dx.doi.org/10.1140/epjb/e20020150\\n    '\n    N = len(x)\n    max_chunksize += 1\n    rs_tmp = np.empty(N, dtype=np.float64)\n    chunk_size_list = np.linspace(min_chunksize, max_chunksize, num_chunksize).astype(np.int64)\n    rs_values_list = np.empty(num_chunksize, dtype=np.float64)\n    for i in range(num_chunksize):\n        chunk_size = chunk_size_list[i]\n        number_of_chunks = int(len(x) / chunk_size)\n        for idx in range(number_of_chunks):\n            ini = idx * chunk_size\n            end = ini + chunk_size\n            chunk = x[ini:end]\n            z = np.cumsum(chunk - np.mean(chunk))\n            rs_tmp[idx] = np.divide(np.max(z) - np.min(z), np.nanstd(chunk))\n        rs_values_list[i] = np.nanmean(rs_tmp[:idx + 1])\n    (H, c) = np.linalg.lstsq(a=np.vstack((np.log(chunk_size_list), np.ones(num_chunksize))).T, b=np.log(rs_values_list))[0]\n    return H"
        ]
    },
    {
        "func_name": "hurst_dma",
        "original": "def hurst_dma(prices, min_chunksize=8, max_chunksize=200, num_chunksize=5):\n    \"\"\"Estimate the Hurst exponent using R/S method.\n\n    Estimates the Hurst (H) exponent using the DMA method from the time series.\n    The DMA method consists on calculate the moving average of size `series_len`\n    and subtract it to the original series and calculating the standard\n    deviation of that result. This repeats the process for several `series_len`\n    values and adjusts data regression to obtain the H. `series_len` will take\n    values between `min_chunksize` and `max_chunksize`, the step size from\n    `min_chunksize` to `max_chunksize` can be controlled through the parameter\n    `step_chunksize`.\n\n    Parameters\n    ----------\n    prices\n    min_chunksize\n    max_chunksize\n    num_chunksize\n\n    Returns\n    -------\n    hurst_exponent : float\n        Estimation of hurst exponent.\n\n    References\n    ----------\n    Alessio, E., Carbone, A., Castelli, G. et al. Eur. Phys. J. B (2002) 27:\n    197. https://dx.doi.org/10.1140/epjb/e20020150\n\n    \"\"\"\n    max_chunksize += 1\n    N = len(prices)\n    n_list = np.arange(min_chunksize, max_chunksize, num_chunksize, dtype=np.int64)\n    dma_list = np.empty(len(n_list))\n    factor = 1 / (N - max_chunksize)\n    for (i, n) in enumerate(n_list):\n        b = np.divide([n - 1] + (n - 1) * [-1], n)\n        noise = np.power(signal.lfilter(b, 1, prices)[max_chunksize:], 2)\n        dma_list[i] = np.sqrt(factor * np.sum(noise))\n    (H, const) = np.linalg.lstsq(a=np.vstack([np.log10(n_list), np.ones(len(n_list))]).T, b=np.log10(dma_list), rcond=None)[0]\n    return H",
        "mutated": [
            "def hurst_dma(prices, min_chunksize=8, max_chunksize=200, num_chunksize=5):\n    if False:\n        i = 10\n    'Estimate the Hurst exponent using R/S method.\\n\\n    Estimates the Hurst (H) exponent using the DMA method from the time series.\\n    The DMA method consists on calculate the moving average of size `series_len`\\n    and subtract it to the original series and calculating the standard\\n    deviation of that result. This repeats the process for several `series_len`\\n    values and adjusts data regression to obtain the H. `series_len` will take\\n    values between `min_chunksize` and `max_chunksize`, the step size from\\n    `min_chunksize` to `max_chunksize` can be controlled through the parameter\\n    `step_chunksize`.\\n\\n    Parameters\\n    ----------\\n    prices\\n    min_chunksize\\n    max_chunksize\\n    num_chunksize\\n\\n    Returns\\n    -------\\n    hurst_exponent : float\\n        Estimation of hurst exponent.\\n\\n    References\\n    ----------\\n    Alessio, E., Carbone, A., Castelli, G. et al. Eur. Phys. J. B (2002) 27:\\n    197. https://dx.doi.org/10.1140/epjb/e20020150\\n\\n    '\n    max_chunksize += 1\n    N = len(prices)\n    n_list = np.arange(min_chunksize, max_chunksize, num_chunksize, dtype=np.int64)\n    dma_list = np.empty(len(n_list))\n    factor = 1 / (N - max_chunksize)\n    for (i, n) in enumerate(n_list):\n        b = np.divide([n - 1] + (n - 1) * [-1], n)\n        noise = np.power(signal.lfilter(b, 1, prices)[max_chunksize:], 2)\n        dma_list[i] = np.sqrt(factor * np.sum(noise))\n    (H, const) = np.linalg.lstsq(a=np.vstack([np.log10(n_list), np.ones(len(n_list))]).T, b=np.log10(dma_list), rcond=None)[0]\n    return H",
            "def hurst_dma(prices, min_chunksize=8, max_chunksize=200, num_chunksize=5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Estimate the Hurst exponent using R/S method.\\n\\n    Estimates the Hurst (H) exponent using the DMA method from the time series.\\n    The DMA method consists on calculate the moving average of size `series_len`\\n    and subtract it to the original series and calculating the standard\\n    deviation of that result. This repeats the process for several `series_len`\\n    values and adjusts data regression to obtain the H. `series_len` will take\\n    values between `min_chunksize` and `max_chunksize`, the step size from\\n    `min_chunksize` to `max_chunksize` can be controlled through the parameter\\n    `step_chunksize`.\\n\\n    Parameters\\n    ----------\\n    prices\\n    min_chunksize\\n    max_chunksize\\n    num_chunksize\\n\\n    Returns\\n    -------\\n    hurst_exponent : float\\n        Estimation of hurst exponent.\\n\\n    References\\n    ----------\\n    Alessio, E., Carbone, A., Castelli, G. et al. Eur. Phys. J. B (2002) 27:\\n    197. https://dx.doi.org/10.1140/epjb/e20020150\\n\\n    '\n    max_chunksize += 1\n    N = len(prices)\n    n_list = np.arange(min_chunksize, max_chunksize, num_chunksize, dtype=np.int64)\n    dma_list = np.empty(len(n_list))\n    factor = 1 / (N - max_chunksize)\n    for (i, n) in enumerate(n_list):\n        b = np.divide([n - 1] + (n - 1) * [-1], n)\n        noise = np.power(signal.lfilter(b, 1, prices)[max_chunksize:], 2)\n        dma_list[i] = np.sqrt(factor * np.sum(noise))\n    (H, const) = np.linalg.lstsq(a=np.vstack([np.log10(n_list), np.ones(len(n_list))]).T, b=np.log10(dma_list), rcond=None)[0]\n    return H",
            "def hurst_dma(prices, min_chunksize=8, max_chunksize=200, num_chunksize=5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Estimate the Hurst exponent using R/S method.\\n\\n    Estimates the Hurst (H) exponent using the DMA method from the time series.\\n    The DMA method consists on calculate the moving average of size `series_len`\\n    and subtract it to the original series and calculating the standard\\n    deviation of that result. This repeats the process for several `series_len`\\n    values and adjusts data regression to obtain the H. `series_len` will take\\n    values between `min_chunksize` and `max_chunksize`, the step size from\\n    `min_chunksize` to `max_chunksize` can be controlled through the parameter\\n    `step_chunksize`.\\n\\n    Parameters\\n    ----------\\n    prices\\n    min_chunksize\\n    max_chunksize\\n    num_chunksize\\n\\n    Returns\\n    -------\\n    hurst_exponent : float\\n        Estimation of hurst exponent.\\n\\n    References\\n    ----------\\n    Alessio, E., Carbone, A., Castelli, G. et al. Eur. Phys. J. B (2002) 27:\\n    197. https://dx.doi.org/10.1140/epjb/e20020150\\n\\n    '\n    max_chunksize += 1\n    N = len(prices)\n    n_list = np.arange(min_chunksize, max_chunksize, num_chunksize, dtype=np.int64)\n    dma_list = np.empty(len(n_list))\n    factor = 1 / (N - max_chunksize)\n    for (i, n) in enumerate(n_list):\n        b = np.divide([n - 1] + (n - 1) * [-1], n)\n        noise = np.power(signal.lfilter(b, 1, prices)[max_chunksize:], 2)\n        dma_list[i] = np.sqrt(factor * np.sum(noise))\n    (H, const) = np.linalg.lstsq(a=np.vstack([np.log10(n_list), np.ones(len(n_list))]).T, b=np.log10(dma_list), rcond=None)[0]\n    return H",
            "def hurst_dma(prices, min_chunksize=8, max_chunksize=200, num_chunksize=5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Estimate the Hurst exponent using R/S method.\\n\\n    Estimates the Hurst (H) exponent using the DMA method from the time series.\\n    The DMA method consists on calculate the moving average of size `series_len`\\n    and subtract it to the original series and calculating the standard\\n    deviation of that result. This repeats the process for several `series_len`\\n    values and adjusts data regression to obtain the H. `series_len` will take\\n    values between `min_chunksize` and `max_chunksize`, the step size from\\n    `min_chunksize` to `max_chunksize` can be controlled through the parameter\\n    `step_chunksize`.\\n\\n    Parameters\\n    ----------\\n    prices\\n    min_chunksize\\n    max_chunksize\\n    num_chunksize\\n\\n    Returns\\n    -------\\n    hurst_exponent : float\\n        Estimation of hurst exponent.\\n\\n    References\\n    ----------\\n    Alessio, E., Carbone, A., Castelli, G. et al. Eur. Phys. J. B (2002) 27:\\n    197. https://dx.doi.org/10.1140/epjb/e20020150\\n\\n    '\n    max_chunksize += 1\n    N = len(prices)\n    n_list = np.arange(min_chunksize, max_chunksize, num_chunksize, dtype=np.int64)\n    dma_list = np.empty(len(n_list))\n    factor = 1 / (N - max_chunksize)\n    for (i, n) in enumerate(n_list):\n        b = np.divide([n - 1] + (n - 1) * [-1], n)\n        noise = np.power(signal.lfilter(b, 1, prices)[max_chunksize:], 2)\n        dma_list[i] = np.sqrt(factor * np.sum(noise))\n    (H, const) = np.linalg.lstsq(a=np.vstack([np.log10(n_list), np.ones(len(n_list))]).T, b=np.log10(dma_list), rcond=None)[0]\n    return H",
            "def hurst_dma(prices, min_chunksize=8, max_chunksize=200, num_chunksize=5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Estimate the Hurst exponent using R/S method.\\n\\n    Estimates the Hurst (H) exponent using the DMA method from the time series.\\n    The DMA method consists on calculate the moving average of size `series_len`\\n    and subtract it to the original series and calculating the standard\\n    deviation of that result. This repeats the process for several `series_len`\\n    values and adjusts data regression to obtain the H. `series_len` will take\\n    values between `min_chunksize` and `max_chunksize`, the step size from\\n    `min_chunksize` to `max_chunksize` can be controlled through the parameter\\n    `step_chunksize`.\\n\\n    Parameters\\n    ----------\\n    prices\\n    min_chunksize\\n    max_chunksize\\n    num_chunksize\\n\\n    Returns\\n    -------\\n    hurst_exponent : float\\n        Estimation of hurst exponent.\\n\\n    References\\n    ----------\\n    Alessio, E., Carbone, A., Castelli, G. et al. Eur. Phys. J. B (2002) 27:\\n    197. https://dx.doi.org/10.1140/epjb/e20020150\\n\\n    '\n    max_chunksize += 1\n    N = len(prices)\n    n_list = np.arange(min_chunksize, max_chunksize, num_chunksize, dtype=np.int64)\n    dma_list = np.empty(len(n_list))\n    factor = 1 / (N - max_chunksize)\n    for (i, n) in enumerate(n_list):\n        b = np.divide([n - 1] + (n - 1) * [-1], n)\n        noise = np.power(signal.lfilter(b, 1, prices)[max_chunksize:], 2)\n        dma_list[i] = np.sqrt(factor * np.sum(noise))\n    (H, const) = np.linalg.lstsq(a=np.vstack([np.log10(n_list), np.ones(len(n_list))]).T, b=np.log10(dma_list), rcond=None)[0]\n    return H"
        ]
    },
    {
        "func_name": "hurst_dsod",
        "original": "def hurst_dsod(x):\n    \"\"\"Estimate Hurst exponent on data timeseries.\n\n    The estimation is based on the discrete second order derivative. Consists on\n    get two different noise of the original series and calculate the standard\n    deviation and calculate the slope of two point with that values.\n    source: https://gist.github.com/wmvanvliet/d883c3fe1402c7ced6fc\n\n    Parameters\n    ----------\n    x : numpy array\n        time series to estimate the Hurst exponent for.\n\n    Returns\n    -------\n    h : float\n        The estimation of the Hurst exponent for the given time series.\n\n    References\n    ----------\n    Istas, J.; G. Lang (1994), \u201cQuadratic variations and estimation of the local\n    H\u00f6lder index of data Gaussian process,\u201d Ann. Inst. Poincar\u00e9, 33, pp. 407\u2013436.\n\n\n    Notes\n    -----\n    This hurst_ets is data literal traduction of wfbmesti.m of waveleet toolbox\n    from matlab.\n    \"\"\"\n    y = np.cumsum(np.diff(x, axis=0), axis=0)\n    b1 = [1, -2, 1]\n    y1 = signal.lfilter(b1, 1, y, axis=0)\n    y1 = y1[len(b1) - 1:]\n    b2 = [1, 0, -2, 0, 1]\n    y2 = signal.lfilter(b2, 1, y, axis=0)\n    y2 = y2[len(b2) - 1:]\n    s1 = np.mean(y1 ** 2, axis=0)\n    s2 = np.mean(y2 ** 2, axis=0)\n    return 0.5 * np.log2(s2 / s1)",
        "mutated": [
            "def hurst_dsod(x):\n    if False:\n        i = 10\n    'Estimate Hurst exponent on data timeseries.\\n\\n    The estimation is based on the discrete second order derivative. Consists on\\n    get two different noise of the original series and calculate the standard\\n    deviation and calculate the slope of two point with that values.\\n    source: https://gist.github.com/wmvanvliet/d883c3fe1402c7ced6fc\\n\\n    Parameters\\n    ----------\\n    x : numpy array\\n        time series to estimate the Hurst exponent for.\\n\\n    Returns\\n    -------\\n    h : float\\n        The estimation of the Hurst exponent for the given time series.\\n\\n    References\\n    ----------\\n    Istas, J.; G. Lang (1994), \u201cQuadratic variations and estimation of the local\\n    H\u00f6lder index of data Gaussian process,\u201d Ann. Inst. Poincar\u00e9, 33, pp. 407\u2013436.\\n\\n\\n    Notes\\n    -----\\n    This hurst_ets is data literal traduction of wfbmesti.m of waveleet toolbox\\n    from matlab.\\n    '\n    y = np.cumsum(np.diff(x, axis=0), axis=0)\n    b1 = [1, -2, 1]\n    y1 = signal.lfilter(b1, 1, y, axis=0)\n    y1 = y1[len(b1) - 1:]\n    b2 = [1, 0, -2, 0, 1]\n    y2 = signal.lfilter(b2, 1, y, axis=0)\n    y2 = y2[len(b2) - 1:]\n    s1 = np.mean(y1 ** 2, axis=0)\n    s2 = np.mean(y2 ** 2, axis=0)\n    return 0.5 * np.log2(s2 / s1)",
            "def hurst_dsod(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Estimate Hurst exponent on data timeseries.\\n\\n    The estimation is based on the discrete second order derivative. Consists on\\n    get two different noise of the original series and calculate the standard\\n    deviation and calculate the slope of two point with that values.\\n    source: https://gist.github.com/wmvanvliet/d883c3fe1402c7ced6fc\\n\\n    Parameters\\n    ----------\\n    x : numpy array\\n        time series to estimate the Hurst exponent for.\\n\\n    Returns\\n    -------\\n    h : float\\n        The estimation of the Hurst exponent for the given time series.\\n\\n    References\\n    ----------\\n    Istas, J.; G. Lang (1994), \u201cQuadratic variations and estimation of the local\\n    H\u00f6lder index of data Gaussian process,\u201d Ann. Inst. Poincar\u00e9, 33, pp. 407\u2013436.\\n\\n\\n    Notes\\n    -----\\n    This hurst_ets is data literal traduction of wfbmesti.m of waveleet toolbox\\n    from matlab.\\n    '\n    y = np.cumsum(np.diff(x, axis=0), axis=0)\n    b1 = [1, -2, 1]\n    y1 = signal.lfilter(b1, 1, y, axis=0)\n    y1 = y1[len(b1) - 1:]\n    b2 = [1, 0, -2, 0, 1]\n    y2 = signal.lfilter(b2, 1, y, axis=0)\n    y2 = y2[len(b2) - 1:]\n    s1 = np.mean(y1 ** 2, axis=0)\n    s2 = np.mean(y2 ** 2, axis=0)\n    return 0.5 * np.log2(s2 / s1)",
            "def hurst_dsod(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Estimate Hurst exponent on data timeseries.\\n\\n    The estimation is based on the discrete second order derivative. Consists on\\n    get two different noise of the original series and calculate the standard\\n    deviation and calculate the slope of two point with that values.\\n    source: https://gist.github.com/wmvanvliet/d883c3fe1402c7ced6fc\\n\\n    Parameters\\n    ----------\\n    x : numpy array\\n        time series to estimate the Hurst exponent for.\\n\\n    Returns\\n    -------\\n    h : float\\n        The estimation of the Hurst exponent for the given time series.\\n\\n    References\\n    ----------\\n    Istas, J.; G. Lang (1994), \u201cQuadratic variations and estimation of the local\\n    H\u00f6lder index of data Gaussian process,\u201d Ann. Inst. Poincar\u00e9, 33, pp. 407\u2013436.\\n\\n\\n    Notes\\n    -----\\n    This hurst_ets is data literal traduction of wfbmesti.m of waveleet toolbox\\n    from matlab.\\n    '\n    y = np.cumsum(np.diff(x, axis=0), axis=0)\n    b1 = [1, -2, 1]\n    y1 = signal.lfilter(b1, 1, y, axis=0)\n    y1 = y1[len(b1) - 1:]\n    b2 = [1, 0, -2, 0, 1]\n    y2 = signal.lfilter(b2, 1, y, axis=0)\n    y2 = y2[len(b2) - 1:]\n    s1 = np.mean(y1 ** 2, axis=0)\n    s2 = np.mean(y2 ** 2, axis=0)\n    return 0.5 * np.log2(s2 / s1)",
            "def hurst_dsod(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Estimate Hurst exponent on data timeseries.\\n\\n    The estimation is based on the discrete second order derivative. Consists on\\n    get two different noise of the original series and calculate the standard\\n    deviation and calculate the slope of two point with that values.\\n    source: https://gist.github.com/wmvanvliet/d883c3fe1402c7ced6fc\\n\\n    Parameters\\n    ----------\\n    x : numpy array\\n        time series to estimate the Hurst exponent for.\\n\\n    Returns\\n    -------\\n    h : float\\n        The estimation of the Hurst exponent for the given time series.\\n\\n    References\\n    ----------\\n    Istas, J.; G. Lang (1994), \u201cQuadratic variations and estimation of the local\\n    H\u00f6lder index of data Gaussian process,\u201d Ann. Inst. Poincar\u00e9, 33, pp. 407\u2013436.\\n\\n\\n    Notes\\n    -----\\n    This hurst_ets is data literal traduction of wfbmesti.m of waveleet toolbox\\n    from matlab.\\n    '\n    y = np.cumsum(np.diff(x, axis=0), axis=0)\n    b1 = [1, -2, 1]\n    y1 = signal.lfilter(b1, 1, y, axis=0)\n    y1 = y1[len(b1) - 1:]\n    b2 = [1, 0, -2, 0, 1]\n    y2 = signal.lfilter(b2, 1, y, axis=0)\n    y2 = y2[len(b2) - 1:]\n    s1 = np.mean(y1 ** 2, axis=0)\n    s2 = np.mean(y2 ** 2, axis=0)\n    return 0.5 * np.log2(s2 / s1)",
            "def hurst_dsod(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Estimate Hurst exponent on data timeseries.\\n\\n    The estimation is based on the discrete second order derivative. Consists on\\n    get two different noise of the original series and calculate the standard\\n    deviation and calculate the slope of two point with that values.\\n    source: https://gist.github.com/wmvanvliet/d883c3fe1402c7ced6fc\\n\\n    Parameters\\n    ----------\\n    x : numpy array\\n        time series to estimate the Hurst exponent for.\\n\\n    Returns\\n    -------\\n    h : float\\n        The estimation of the Hurst exponent for the given time series.\\n\\n    References\\n    ----------\\n    Istas, J.; G. Lang (1994), \u201cQuadratic variations and estimation of the local\\n    H\u00f6lder index of data Gaussian process,\u201d Ann. Inst. Poincar\u00e9, 33, pp. 407\u2013436.\\n\\n\\n    Notes\\n    -----\\n    This hurst_ets is data literal traduction of wfbmesti.m of waveleet toolbox\\n    from matlab.\\n    '\n    y = np.cumsum(np.diff(x, axis=0), axis=0)\n    b1 = [1, -2, 1]\n    y1 = signal.lfilter(b1, 1, y, axis=0)\n    y1 = y1[len(b1) - 1:]\n    b2 = [1, 0, -2, 0, 1]\n    y2 = signal.lfilter(b2, 1, y, axis=0)\n    y2 = y2[len(b2) - 1:]\n    s1 = np.mean(y1 ** 2, axis=0)\n    s2 = np.mean(y2 ** 2, axis=0)\n    return 0.5 * np.log2(s2 / s1)"
        ]
    }
]