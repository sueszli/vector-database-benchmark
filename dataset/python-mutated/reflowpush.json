[
    {
        "func_name": "reverse_bfs",
        "original": "def reverse_bfs(src):\n    \"\"\"Perform a reverse breadth-first search from src in the residual\n        network.\n        \"\"\"\n    heights = {src: 0}\n    q = deque([(src, 0)])\n    while q:\n        (u, height) = q.popleft()\n        height += 1\n        for (v, attr) in R_pred[u].items():\n            if v not in heights and attr['flow'] < attr['capacity']:\n                heights[v] = height\n                q.append((v, height))\n    return heights",
        "mutated": [
            "def reverse_bfs(src):\n    if False:\n        i = 10\n    'Perform a reverse breadth-first search from src in the residual\\n        network.\\n        '\n    heights = {src: 0}\n    q = deque([(src, 0)])\n    while q:\n        (u, height) = q.popleft()\n        height += 1\n        for (v, attr) in R_pred[u].items():\n            if v not in heights and attr['flow'] < attr['capacity']:\n                heights[v] = height\n                q.append((v, height))\n    return heights",
            "def reverse_bfs(src):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Perform a reverse breadth-first search from src in the residual\\n        network.\\n        '\n    heights = {src: 0}\n    q = deque([(src, 0)])\n    while q:\n        (u, height) = q.popleft()\n        height += 1\n        for (v, attr) in R_pred[u].items():\n            if v not in heights and attr['flow'] < attr['capacity']:\n                heights[v] = height\n                q.append((v, height))\n    return heights",
            "def reverse_bfs(src):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Perform a reverse breadth-first search from src in the residual\\n        network.\\n        '\n    heights = {src: 0}\n    q = deque([(src, 0)])\n    while q:\n        (u, height) = q.popleft()\n        height += 1\n        for (v, attr) in R_pred[u].items():\n            if v not in heights and attr['flow'] < attr['capacity']:\n                heights[v] = height\n                q.append((v, height))\n    return heights",
            "def reverse_bfs(src):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Perform a reverse breadth-first search from src in the residual\\n        network.\\n        '\n    heights = {src: 0}\n    q = deque([(src, 0)])\n    while q:\n        (u, height) = q.popleft()\n        height += 1\n        for (v, attr) in R_pred[u].items():\n            if v not in heights and attr['flow'] < attr['capacity']:\n                heights[v] = height\n                q.append((v, height))\n    return heights",
            "def reverse_bfs(src):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Perform a reverse breadth-first search from src in the residual\\n        network.\\n        '\n    heights = {src: 0}\n    q = deque([(src, 0)])\n    while q:\n        (u, height) = q.popleft()\n        height += 1\n        for (v, attr) in R_pred[u].items():\n            if v not in heights and attr['flow'] < attr['capacity']:\n                heights[v] = height\n                q.append((v, height))\n    return heights"
        ]
    },
    {
        "func_name": "push",
        "original": "def push(u, v, flow):\n    \"\"\"Push flow units of flow from u to v.\"\"\"\n    R_succ[u][v]['flow'] += flow\n    R_succ[v][u]['flow'] -= flow\n    R_nodes[u]['excess'] -= flow\n    R_nodes[v]['excess'] += flow",
        "mutated": [
            "def push(u, v, flow):\n    if False:\n        i = 10\n    'Push flow units of flow from u to v.'\n    R_succ[u][v]['flow'] += flow\n    R_succ[v][u]['flow'] -= flow\n    R_nodes[u]['excess'] -= flow\n    R_nodes[v]['excess'] += flow",
            "def push(u, v, flow):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Push flow units of flow from u to v.'\n    R_succ[u][v]['flow'] += flow\n    R_succ[v][u]['flow'] -= flow\n    R_nodes[u]['excess'] -= flow\n    R_nodes[v]['excess'] += flow",
            "def push(u, v, flow):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Push flow units of flow from u to v.'\n    R_succ[u][v]['flow'] += flow\n    R_succ[v][u]['flow'] -= flow\n    R_nodes[u]['excess'] -= flow\n    R_nodes[v]['excess'] += flow",
            "def push(u, v, flow):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Push flow units of flow from u to v.'\n    R_succ[u][v]['flow'] += flow\n    R_succ[v][u]['flow'] -= flow\n    R_nodes[u]['excess'] -= flow\n    R_nodes[v]['excess'] += flow",
            "def push(u, v, flow):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Push flow units of flow from u to v.'\n    R_succ[u][v]['flow'] += flow\n    R_succ[v][u]['flow'] -= flow\n    R_nodes[u]['excess'] -= flow\n    R_nodes[v]['excess'] += flow"
        ]
    },
    {
        "func_name": "activate",
        "original": "def activate(v):\n    \"\"\"Move a node from the inactive set to the active set of its level.\"\"\"\n    if v != s and v != t:\n        level = levels[R_nodes[v]['height']]\n        if v in level.inactive:\n            level.inactive.remove(v)\n            level.active.add(v)",
        "mutated": [
            "def activate(v):\n    if False:\n        i = 10\n    'Move a node from the inactive set to the active set of its level.'\n    if v != s and v != t:\n        level = levels[R_nodes[v]['height']]\n        if v in level.inactive:\n            level.inactive.remove(v)\n            level.active.add(v)",
            "def activate(v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Move a node from the inactive set to the active set of its level.'\n    if v != s and v != t:\n        level = levels[R_nodes[v]['height']]\n        if v in level.inactive:\n            level.inactive.remove(v)\n            level.active.add(v)",
            "def activate(v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Move a node from the inactive set to the active set of its level.'\n    if v != s and v != t:\n        level = levels[R_nodes[v]['height']]\n        if v in level.inactive:\n            level.inactive.remove(v)\n            level.active.add(v)",
            "def activate(v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Move a node from the inactive set to the active set of its level.'\n    if v != s and v != t:\n        level = levels[R_nodes[v]['height']]\n        if v in level.inactive:\n            level.inactive.remove(v)\n            level.active.add(v)",
            "def activate(v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Move a node from the inactive set to the active set of its level.'\n    if v != s and v != t:\n        level = levels[R_nodes[v]['height']]\n        if v in level.inactive:\n            level.inactive.remove(v)\n            level.active.add(v)"
        ]
    },
    {
        "func_name": "relabel",
        "original": "def relabel(u):\n    \"\"\"Relabel a node to create an admissible edge.\"\"\"\n    grt.add_work(len(R_succ[u]))\n    return min((R_nodes[v]['height'] for (v, attr) in R_succ[u].items() if attr['flow'] < attr['capacity'])) + 1",
        "mutated": [
            "def relabel(u):\n    if False:\n        i = 10\n    'Relabel a node to create an admissible edge.'\n    grt.add_work(len(R_succ[u]))\n    return min((R_nodes[v]['height'] for (v, attr) in R_succ[u].items() if attr['flow'] < attr['capacity'])) + 1",
            "def relabel(u):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Relabel a node to create an admissible edge.'\n    grt.add_work(len(R_succ[u]))\n    return min((R_nodes[v]['height'] for (v, attr) in R_succ[u].items() if attr['flow'] < attr['capacity'])) + 1",
            "def relabel(u):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Relabel a node to create an admissible edge.'\n    grt.add_work(len(R_succ[u]))\n    return min((R_nodes[v]['height'] for (v, attr) in R_succ[u].items() if attr['flow'] < attr['capacity'])) + 1",
            "def relabel(u):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Relabel a node to create an admissible edge.'\n    grt.add_work(len(R_succ[u]))\n    return min((R_nodes[v]['height'] for (v, attr) in R_succ[u].items() if attr['flow'] < attr['capacity'])) + 1",
            "def relabel(u):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Relabel a node to create an admissible edge.'\n    grt.add_work(len(R_succ[u]))\n    return min((R_nodes[v]['height'] for (v, attr) in R_succ[u].items() if attr['flow'] < attr['capacity'])) + 1"
        ]
    },
    {
        "func_name": "discharge",
        "original": "def discharge(u, is_phase1):\n    \"\"\"Discharge a node until it becomes inactive or, during phase 1 (see\n        below), its height reaches at least n. The node is known to have the\n        largest height among active nodes.\n        \"\"\"\n    height = R_nodes[u]['height']\n    curr_edge = R_nodes[u]['curr_edge']\n    next_height = height\n    levels[height].active.remove(u)\n    while True:\n        (v, attr) = curr_edge.get()\n        if height == R_nodes[v]['height'] + 1 and attr['flow'] < attr['capacity']:\n            flow = min(R_nodes[u]['excess'], attr['capacity'] - attr['flow'])\n            push(u, v, flow)\n            activate(v)\n            if R_nodes[u]['excess'] == 0:\n                levels[height].inactive.add(u)\n                break\n        try:\n            curr_edge.move_to_next()\n        except StopIteration:\n            height = relabel(u)\n            if is_phase1 and height >= n - 1:\n                levels[height].active.add(u)\n                break\n            next_height = height\n    R_nodes[u]['height'] = height\n    return next_height",
        "mutated": [
            "def discharge(u, is_phase1):\n    if False:\n        i = 10\n    'Discharge a node until it becomes inactive or, during phase 1 (see\\n        below), its height reaches at least n. The node is known to have the\\n        largest height among active nodes.\\n        '\n    height = R_nodes[u]['height']\n    curr_edge = R_nodes[u]['curr_edge']\n    next_height = height\n    levels[height].active.remove(u)\n    while True:\n        (v, attr) = curr_edge.get()\n        if height == R_nodes[v]['height'] + 1 and attr['flow'] < attr['capacity']:\n            flow = min(R_nodes[u]['excess'], attr['capacity'] - attr['flow'])\n            push(u, v, flow)\n            activate(v)\n            if R_nodes[u]['excess'] == 0:\n                levels[height].inactive.add(u)\n                break\n        try:\n            curr_edge.move_to_next()\n        except StopIteration:\n            height = relabel(u)\n            if is_phase1 and height >= n - 1:\n                levels[height].active.add(u)\n                break\n            next_height = height\n    R_nodes[u]['height'] = height\n    return next_height",
            "def discharge(u, is_phase1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Discharge a node until it becomes inactive or, during phase 1 (see\\n        below), its height reaches at least n. The node is known to have the\\n        largest height among active nodes.\\n        '\n    height = R_nodes[u]['height']\n    curr_edge = R_nodes[u]['curr_edge']\n    next_height = height\n    levels[height].active.remove(u)\n    while True:\n        (v, attr) = curr_edge.get()\n        if height == R_nodes[v]['height'] + 1 and attr['flow'] < attr['capacity']:\n            flow = min(R_nodes[u]['excess'], attr['capacity'] - attr['flow'])\n            push(u, v, flow)\n            activate(v)\n            if R_nodes[u]['excess'] == 0:\n                levels[height].inactive.add(u)\n                break\n        try:\n            curr_edge.move_to_next()\n        except StopIteration:\n            height = relabel(u)\n            if is_phase1 and height >= n - 1:\n                levels[height].active.add(u)\n                break\n            next_height = height\n    R_nodes[u]['height'] = height\n    return next_height",
            "def discharge(u, is_phase1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Discharge a node until it becomes inactive or, during phase 1 (see\\n        below), its height reaches at least n. The node is known to have the\\n        largest height among active nodes.\\n        '\n    height = R_nodes[u]['height']\n    curr_edge = R_nodes[u]['curr_edge']\n    next_height = height\n    levels[height].active.remove(u)\n    while True:\n        (v, attr) = curr_edge.get()\n        if height == R_nodes[v]['height'] + 1 and attr['flow'] < attr['capacity']:\n            flow = min(R_nodes[u]['excess'], attr['capacity'] - attr['flow'])\n            push(u, v, flow)\n            activate(v)\n            if R_nodes[u]['excess'] == 0:\n                levels[height].inactive.add(u)\n                break\n        try:\n            curr_edge.move_to_next()\n        except StopIteration:\n            height = relabel(u)\n            if is_phase1 and height >= n - 1:\n                levels[height].active.add(u)\n                break\n            next_height = height\n    R_nodes[u]['height'] = height\n    return next_height",
            "def discharge(u, is_phase1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Discharge a node until it becomes inactive or, during phase 1 (see\\n        below), its height reaches at least n. The node is known to have the\\n        largest height among active nodes.\\n        '\n    height = R_nodes[u]['height']\n    curr_edge = R_nodes[u]['curr_edge']\n    next_height = height\n    levels[height].active.remove(u)\n    while True:\n        (v, attr) = curr_edge.get()\n        if height == R_nodes[v]['height'] + 1 and attr['flow'] < attr['capacity']:\n            flow = min(R_nodes[u]['excess'], attr['capacity'] - attr['flow'])\n            push(u, v, flow)\n            activate(v)\n            if R_nodes[u]['excess'] == 0:\n                levels[height].inactive.add(u)\n                break\n        try:\n            curr_edge.move_to_next()\n        except StopIteration:\n            height = relabel(u)\n            if is_phase1 and height >= n - 1:\n                levels[height].active.add(u)\n                break\n            next_height = height\n    R_nodes[u]['height'] = height\n    return next_height",
            "def discharge(u, is_phase1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Discharge a node until it becomes inactive or, during phase 1 (see\\n        below), its height reaches at least n. The node is known to have the\\n        largest height among active nodes.\\n        '\n    height = R_nodes[u]['height']\n    curr_edge = R_nodes[u]['curr_edge']\n    next_height = height\n    levels[height].active.remove(u)\n    while True:\n        (v, attr) = curr_edge.get()\n        if height == R_nodes[v]['height'] + 1 and attr['flow'] < attr['capacity']:\n            flow = min(R_nodes[u]['excess'], attr['capacity'] - attr['flow'])\n            push(u, v, flow)\n            activate(v)\n            if R_nodes[u]['excess'] == 0:\n                levels[height].inactive.add(u)\n                break\n        try:\n            curr_edge.move_to_next()\n        except StopIteration:\n            height = relabel(u)\n            if is_phase1 and height >= n - 1:\n                levels[height].active.add(u)\n                break\n            next_height = height\n    R_nodes[u]['height'] = height\n    return next_height"
        ]
    },
    {
        "func_name": "gap_heuristic",
        "original": "def gap_heuristic(height):\n    \"\"\"Apply the gap heuristic.\"\"\"\n    for level in islice(levels, height + 1, max_height + 1):\n        for u in level.active:\n            R_nodes[u]['height'] = n + 1\n        for u in level.inactive:\n            R_nodes[u]['height'] = n + 1\n        levels[n + 1].active.update(level.active)\n        level.active.clear()\n        levels[n + 1].inactive.update(level.inactive)\n        level.inactive.clear()",
        "mutated": [
            "def gap_heuristic(height):\n    if False:\n        i = 10\n    'Apply the gap heuristic.'\n    for level in islice(levels, height + 1, max_height + 1):\n        for u in level.active:\n            R_nodes[u]['height'] = n + 1\n        for u in level.inactive:\n            R_nodes[u]['height'] = n + 1\n        levels[n + 1].active.update(level.active)\n        level.active.clear()\n        levels[n + 1].inactive.update(level.inactive)\n        level.inactive.clear()",
            "def gap_heuristic(height):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Apply the gap heuristic.'\n    for level in islice(levels, height + 1, max_height + 1):\n        for u in level.active:\n            R_nodes[u]['height'] = n + 1\n        for u in level.inactive:\n            R_nodes[u]['height'] = n + 1\n        levels[n + 1].active.update(level.active)\n        level.active.clear()\n        levels[n + 1].inactive.update(level.inactive)\n        level.inactive.clear()",
            "def gap_heuristic(height):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Apply the gap heuristic.'\n    for level in islice(levels, height + 1, max_height + 1):\n        for u in level.active:\n            R_nodes[u]['height'] = n + 1\n        for u in level.inactive:\n            R_nodes[u]['height'] = n + 1\n        levels[n + 1].active.update(level.active)\n        level.active.clear()\n        levels[n + 1].inactive.update(level.inactive)\n        level.inactive.clear()",
            "def gap_heuristic(height):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Apply the gap heuristic.'\n    for level in islice(levels, height + 1, max_height + 1):\n        for u in level.active:\n            R_nodes[u]['height'] = n + 1\n        for u in level.inactive:\n            R_nodes[u]['height'] = n + 1\n        levels[n + 1].active.update(level.active)\n        level.active.clear()\n        levels[n + 1].inactive.update(level.inactive)\n        level.inactive.clear()",
            "def gap_heuristic(height):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Apply the gap heuristic.'\n    for level in islice(levels, height + 1, max_height + 1):\n        for u in level.active:\n            R_nodes[u]['height'] = n + 1\n        for u in level.inactive:\n            R_nodes[u]['height'] = n + 1\n        levels[n + 1].active.update(level.active)\n        level.active.clear()\n        levels[n + 1].inactive.update(level.inactive)\n        level.inactive.clear()"
        ]
    },
    {
        "func_name": "global_relabel",
        "original": "def global_relabel(from_sink):\n    \"\"\"Apply the global relabeling heuristic.\"\"\"\n    src = t if from_sink else s\n    heights = reverse_bfs(src)\n    if not from_sink:\n        del heights[t]\n    max_height = max(heights.values())\n    if from_sink:\n        for u in R:\n            if u not in heights and R_nodes[u]['height'] < n:\n                heights[u] = n + 1\n    else:\n        for u in heights:\n            heights[u] += n\n        max_height += n\n    del heights[src]\n    for (u, new_height) in heights.items():\n        old_height = R_nodes[u]['height']\n        if new_height != old_height:\n            if u in levels[old_height].active:\n                levels[old_height].active.remove(u)\n                levels[new_height].active.add(u)\n            else:\n                levels[old_height].inactive.remove(u)\n                levels[new_height].inactive.add(u)\n            R_nodes[u]['height'] = new_height\n    return max_height",
        "mutated": [
            "def global_relabel(from_sink):\n    if False:\n        i = 10\n    'Apply the global relabeling heuristic.'\n    src = t if from_sink else s\n    heights = reverse_bfs(src)\n    if not from_sink:\n        del heights[t]\n    max_height = max(heights.values())\n    if from_sink:\n        for u in R:\n            if u not in heights and R_nodes[u]['height'] < n:\n                heights[u] = n + 1\n    else:\n        for u in heights:\n            heights[u] += n\n        max_height += n\n    del heights[src]\n    for (u, new_height) in heights.items():\n        old_height = R_nodes[u]['height']\n        if new_height != old_height:\n            if u in levels[old_height].active:\n                levels[old_height].active.remove(u)\n                levels[new_height].active.add(u)\n            else:\n                levels[old_height].inactive.remove(u)\n                levels[new_height].inactive.add(u)\n            R_nodes[u]['height'] = new_height\n    return max_height",
            "def global_relabel(from_sink):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Apply the global relabeling heuristic.'\n    src = t if from_sink else s\n    heights = reverse_bfs(src)\n    if not from_sink:\n        del heights[t]\n    max_height = max(heights.values())\n    if from_sink:\n        for u in R:\n            if u not in heights and R_nodes[u]['height'] < n:\n                heights[u] = n + 1\n    else:\n        for u in heights:\n            heights[u] += n\n        max_height += n\n    del heights[src]\n    for (u, new_height) in heights.items():\n        old_height = R_nodes[u]['height']\n        if new_height != old_height:\n            if u in levels[old_height].active:\n                levels[old_height].active.remove(u)\n                levels[new_height].active.add(u)\n            else:\n                levels[old_height].inactive.remove(u)\n                levels[new_height].inactive.add(u)\n            R_nodes[u]['height'] = new_height\n    return max_height",
            "def global_relabel(from_sink):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Apply the global relabeling heuristic.'\n    src = t if from_sink else s\n    heights = reverse_bfs(src)\n    if not from_sink:\n        del heights[t]\n    max_height = max(heights.values())\n    if from_sink:\n        for u in R:\n            if u not in heights and R_nodes[u]['height'] < n:\n                heights[u] = n + 1\n    else:\n        for u in heights:\n            heights[u] += n\n        max_height += n\n    del heights[src]\n    for (u, new_height) in heights.items():\n        old_height = R_nodes[u]['height']\n        if new_height != old_height:\n            if u in levels[old_height].active:\n                levels[old_height].active.remove(u)\n                levels[new_height].active.add(u)\n            else:\n                levels[old_height].inactive.remove(u)\n                levels[new_height].inactive.add(u)\n            R_nodes[u]['height'] = new_height\n    return max_height",
            "def global_relabel(from_sink):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Apply the global relabeling heuristic.'\n    src = t if from_sink else s\n    heights = reverse_bfs(src)\n    if not from_sink:\n        del heights[t]\n    max_height = max(heights.values())\n    if from_sink:\n        for u in R:\n            if u not in heights and R_nodes[u]['height'] < n:\n                heights[u] = n + 1\n    else:\n        for u in heights:\n            heights[u] += n\n        max_height += n\n    del heights[src]\n    for (u, new_height) in heights.items():\n        old_height = R_nodes[u]['height']\n        if new_height != old_height:\n            if u in levels[old_height].active:\n                levels[old_height].active.remove(u)\n                levels[new_height].active.add(u)\n            else:\n                levels[old_height].inactive.remove(u)\n                levels[new_height].inactive.add(u)\n            R_nodes[u]['height'] = new_height\n    return max_height",
            "def global_relabel(from_sink):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Apply the global relabeling heuristic.'\n    src = t if from_sink else s\n    heights = reverse_bfs(src)\n    if not from_sink:\n        del heights[t]\n    max_height = max(heights.values())\n    if from_sink:\n        for u in R:\n            if u not in heights and R_nodes[u]['height'] < n:\n                heights[u] = n + 1\n    else:\n        for u in heights:\n            heights[u] += n\n        max_height += n\n    del heights[src]\n    for (u, new_height) in heights.items():\n        old_height = R_nodes[u]['height']\n        if new_height != old_height:\n            if u in levels[old_height].active:\n                levels[old_height].active.remove(u)\n                levels[new_height].active.add(u)\n            else:\n                levels[old_height].inactive.remove(u)\n                levels[new_height].inactive.add(u)\n            R_nodes[u]['height'] = new_height\n    return max_height"
        ]
    },
    {
        "func_name": "preflow_push_impl",
        "original": "def preflow_push_impl(G, s, t, capacity, residual, global_relabel_freq, value_only):\n    \"\"\"Implementation of the highest-label preflow-push algorithm.\"\"\"\n    if s not in G:\n        raise nx.NetworkXError(f'node {str(s)} not in graph')\n    if t not in G:\n        raise nx.NetworkXError(f'node {str(t)} not in graph')\n    if s == t:\n        raise nx.NetworkXError('source and sink are the same node')\n    if global_relabel_freq is None:\n        global_relabel_freq = 0\n    if global_relabel_freq < 0:\n        raise nx.NetworkXError('global_relabel_freq must be nonnegative.')\n    if residual is None:\n        R = build_residual_network(G, capacity)\n    else:\n        R = residual\n    detect_unboundedness(R, s, t)\n    R_nodes = R.nodes\n    R_pred = R.pred\n    R_succ = R.succ\n    for u in R:\n        R_nodes[u]['excess'] = 0\n        for e in R_succ[u].values():\n            e['flow'] = 0\n\n    def reverse_bfs(src):\n        \"\"\"Perform a reverse breadth-first search from src in the residual\n        network.\n        \"\"\"\n        heights = {src: 0}\n        q = deque([(src, 0)])\n        while q:\n            (u, height) = q.popleft()\n            height += 1\n            for (v, attr) in R_pred[u].items():\n                if v not in heights and attr['flow'] < attr['capacity']:\n                    heights[v] = height\n                    q.append((v, height))\n        return heights\n    heights = reverse_bfs(t)\n    if s not in heights:\n        R.graph['flow_value'] = 0\n        return R\n    n = len(R)\n    max_height = max((heights[u] for u in heights if u != s))\n    heights[s] = n\n    grt = GlobalRelabelThreshold(n, R.size(), global_relabel_freq)\n    for u in R:\n        R_nodes[u]['height'] = heights[u] if u in heights else n + 1\n        R_nodes[u]['curr_edge'] = CurrentEdge(R_succ[u])\n\n    def push(u, v, flow):\n        \"\"\"Push flow units of flow from u to v.\"\"\"\n        R_succ[u][v]['flow'] += flow\n        R_succ[v][u]['flow'] -= flow\n        R_nodes[u]['excess'] -= flow\n        R_nodes[v]['excess'] += flow\n    for (u, attr) in R_succ[s].items():\n        flow = attr['capacity']\n        if flow > 0:\n            push(s, u, flow)\n    levels = [Level() for i in range(2 * n)]\n    for u in R:\n        if u != s and u != t:\n            level = levels[R_nodes[u]['height']]\n            if R_nodes[u]['excess'] > 0:\n                level.active.add(u)\n            else:\n                level.inactive.add(u)\n\n    def activate(v):\n        \"\"\"Move a node from the inactive set to the active set of its level.\"\"\"\n        if v != s and v != t:\n            level = levels[R_nodes[v]['height']]\n            if v in level.inactive:\n                level.inactive.remove(v)\n                level.active.add(v)\n\n    def relabel(u):\n        \"\"\"Relabel a node to create an admissible edge.\"\"\"\n        grt.add_work(len(R_succ[u]))\n        return min((R_nodes[v]['height'] for (v, attr) in R_succ[u].items() if attr['flow'] < attr['capacity'])) + 1\n\n    def discharge(u, is_phase1):\n        \"\"\"Discharge a node until it becomes inactive or, during phase 1 (see\n        below), its height reaches at least n. The node is known to have the\n        largest height among active nodes.\n        \"\"\"\n        height = R_nodes[u]['height']\n        curr_edge = R_nodes[u]['curr_edge']\n        next_height = height\n        levels[height].active.remove(u)\n        while True:\n            (v, attr) = curr_edge.get()\n            if height == R_nodes[v]['height'] + 1 and attr['flow'] < attr['capacity']:\n                flow = min(R_nodes[u]['excess'], attr['capacity'] - attr['flow'])\n                push(u, v, flow)\n                activate(v)\n                if R_nodes[u]['excess'] == 0:\n                    levels[height].inactive.add(u)\n                    break\n            try:\n                curr_edge.move_to_next()\n            except StopIteration:\n                height = relabel(u)\n                if is_phase1 and height >= n - 1:\n                    levels[height].active.add(u)\n                    break\n                next_height = height\n        R_nodes[u]['height'] = height\n        return next_height\n\n    def gap_heuristic(height):\n        \"\"\"Apply the gap heuristic.\"\"\"\n        for level in islice(levels, height + 1, max_height + 1):\n            for u in level.active:\n                R_nodes[u]['height'] = n + 1\n            for u in level.inactive:\n                R_nodes[u]['height'] = n + 1\n            levels[n + 1].active.update(level.active)\n            level.active.clear()\n            levels[n + 1].inactive.update(level.inactive)\n            level.inactive.clear()\n\n    def global_relabel(from_sink):\n        \"\"\"Apply the global relabeling heuristic.\"\"\"\n        src = t if from_sink else s\n        heights = reverse_bfs(src)\n        if not from_sink:\n            del heights[t]\n        max_height = max(heights.values())\n        if from_sink:\n            for u in R:\n                if u not in heights and R_nodes[u]['height'] < n:\n                    heights[u] = n + 1\n        else:\n            for u in heights:\n                heights[u] += n\n            max_height += n\n        del heights[src]\n        for (u, new_height) in heights.items():\n            old_height = R_nodes[u]['height']\n            if new_height != old_height:\n                if u in levels[old_height].active:\n                    levels[old_height].active.remove(u)\n                    levels[new_height].active.add(u)\n                else:\n                    levels[old_height].inactive.remove(u)\n                    levels[new_height].inactive.add(u)\n                R_nodes[u]['height'] = new_height\n        return max_height\n    height = max_height\n    while height > 0:\n        while True:\n            level = levels[height]\n            if not level.active:\n                height -= 1\n                break\n            old_height = height\n            old_level = level\n            u = arbitrary_element(level.active)\n            height = discharge(u, True)\n            if grt.is_reached():\n                height = global_relabel(True)\n                max_height = height\n                grt.clear_work()\n            elif not old_level.active and (not old_level.inactive):\n                gap_heuristic(old_height)\n                height = old_height - 1\n                max_height = height\n            else:\n                max_height = max(max_height, height)\n    if value_only:\n        R.graph['flow_value'] = R_nodes[t]['excess']\n        return R\n    height = global_relabel(False)\n    grt.clear_work()\n    while height > n:\n        while True:\n            level = levels[height]\n            if not level.active:\n                height -= 1\n                break\n            u = arbitrary_element(level.active)\n            height = discharge(u, False)\n            if grt.is_reached():\n                height = global_relabel(False)\n                grt.clear_work()\n    R.graph['flow_value'] = R_nodes[t]['excess']\n    return R",
        "mutated": [
            "def preflow_push_impl(G, s, t, capacity, residual, global_relabel_freq, value_only):\n    if False:\n        i = 10\n    'Implementation of the highest-label preflow-push algorithm.'\n    if s not in G:\n        raise nx.NetworkXError(f'node {str(s)} not in graph')\n    if t not in G:\n        raise nx.NetworkXError(f'node {str(t)} not in graph')\n    if s == t:\n        raise nx.NetworkXError('source and sink are the same node')\n    if global_relabel_freq is None:\n        global_relabel_freq = 0\n    if global_relabel_freq < 0:\n        raise nx.NetworkXError('global_relabel_freq must be nonnegative.')\n    if residual is None:\n        R = build_residual_network(G, capacity)\n    else:\n        R = residual\n    detect_unboundedness(R, s, t)\n    R_nodes = R.nodes\n    R_pred = R.pred\n    R_succ = R.succ\n    for u in R:\n        R_nodes[u]['excess'] = 0\n        for e in R_succ[u].values():\n            e['flow'] = 0\n\n    def reverse_bfs(src):\n        \"\"\"Perform a reverse breadth-first search from src in the residual\n        network.\n        \"\"\"\n        heights = {src: 0}\n        q = deque([(src, 0)])\n        while q:\n            (u, height) = q.popleft()\n            height += 1\n            for (v, attr) in R_pred[u].items():\n                if v not in heights and attr['flow'] < attr['capacity']:\n                    heights[v] = height\n                    q.append((v, height))\n        return heights\n    heights = reverse_bfs(t)\n    if s not in heights:\n        R.graph['flow_value'] = 0\n        return R\n    n = len(R)\n    max_height = max((heights[u] for u in heights if u != s))\n    heights[s] = n\n    grt = GlobalRelabelThreshold(n, R.size(), global_relabel_freq)\n    for u in R:\n        R_nodes[u]['height'] = heights[u] if u in heights else n + 1\n        R_nodes[u]['curr_edge'] = CurrentEdge(R_succ[u])\n\n    def push(u, v, flow):\n        \"\"\"Push flow units of flow from u to v.\"\"\"\n        R_succ[u][v]['flow'] += flow\n        R_succ[v][u]['flow'] -= flow\n        R_nodes[u]['excess'] -= flow\n        R_nodes[v]['excess'] += flow\n    for (u, attr) in R_succ[s].items():\n        flow = attr['capacity']\n        if flow > 0:\n            push(s, u, flow)\n    levels = [Level() for i in range(2 * n)]\n    for u in R:\n        if u != s and u != t:\n            level = levels[R_nodes[u]['height']]\n            if R_nodes[u]['excess'] > 0:\n                level.active.add(u)\n            else:\n                level.inactive.add(u)\n\n    def activate(v):\n        \"\"\"Move a node from the inactive set to the active set of its level.\"\"\"\n        if v != s and v != t:\n            level = levels[R_nodes[v]['height']]\n            if v in level.inactive:\n                level.inactive.remove(v)\n                level.active.add(v)\n\n    def relabel(u):\n        \"\"\"Relabel a node to create an admissible edge.\"\"\"\n        grt.add_work(len(R_succ[u]))\n        return min((R_nodes[v]['height'] for (v, attr) in R_succ[u].items() if attr['flow'] < attr['capacity'])) + 1\n\n    def discharge(u, is_phase1):\n        \"\"\"Discharge a node until it becomes inactive or, during phase 1 (see\n        below), its height reaches at least n. The node is known to have the\n        largest height among active nodes.\n        \"\"\"\n        height = R_nodes[u]['height']\n        curr_edge = R_nodes[u]['curr_edge']\n        next_height = height\n        levels[height].active.remove(u)\n        while True:\n            (v, attr) = curr_edge.get()\n            if height == R_nodes[v]['height'] + 1 and attr['flow'] < attr['capacity']:\n                flow = min(R_nodes[u]['excess'], attr['capacity'] - attr['flow'])\n                push(u, v, flow)\n                activate(v)\n                if R_nodes[u]['excess'] == 0:\n                    levels[height].inactive.add(u)\n                    break\n            try:\n                curr_edge.move_to_next()\n            except StopIteration:\n                height = relabel(u)\n                if is_phase1 and height >= n - 1:\n                    levels[height].active.add(u)\n                    break\n                next_height = height\n        R_nodes[u]['height'] = height\n        return next_height\n\n    def gap_heuristic(height):\n        \"\"\"Apply the gap heuristic.\"\"\"\n        for level in islice(levels, height + 1, max_height + 1):\n            for u in level.active:\n                R_nodes[u]['height'] = n + 1\n            for u in level.inactive:\n                R_nodes[u]['height'] = n + 1\n            levels[n + 1].active.update(level.active)\n            level.active.clear()\n            levels[n + 1].inactive.update(level.inactive)\n            level.inactive.clear()\n\n    def global_relabel(from_sink):\n        \"\"\"Apply the global relabeling heuristic.\"\"\"\n        src = t if from_sink else s\n        heights = reverse_bfs(src)\n        if not from_sink:\n            del heights[t]\n        max_height = max(heights.values())\n        if from_sink:\n            for u in R:\n                if u not in heights and R_nodes[u]['height'] < n:\n                    heights[u] = n + 1\n        else:\n            for u in heights:\n                heights[u] += n\n            max_height += n\n        del heights[src]\n        for (u, new_height) in heights.items():\n            old_height = R_nodes[u]['height']\n            if new_height != old_height:\n                if u in levels[old_height].active:\n                    levels[old_height].active.remove(u)\n                    levels[new_height].active.add(u)\n                else:\n                    levels[old_height].inactive.remove(u)\n                    levels[new_height].inactive.add(u)\n                R_nodes[u]['height'] = new_height\n        return max_height\n    height = max_height\n    while height > 0:\n        while True:\n            level = levels[height]\n            if not level.active:\n                height -= 1\n                break\n            old_height = height\n            old_level = level\n            u = arbitrary_element(level.active)\n            height = discharge(u, True)\n            if grt.is_reached():\n                height = global_relabel(True)\n                max_height = height\n                grt.clear_work()\n            elif not old_level.active and (not old_level.inactive):\n                gap_heuristic(old_height)\n                height = old_height - 1\n                max_height = height\n            else:\n                max_height = max(max_height, height)\n    if value_only:\n        R.graph['flow_value'] = R_nodes[t]['excess']\n        return R\n    height = global_relabel(False)\n    grt.clear_work()\n    while height > n:\n        while True:\n            level = levels[height]\n            if not level.active:\n                height -= 1\n                break\n            u = arbitrary_element(level.active)\n            height = discharge(u, False)\n            if grt.is_reached():\n                height = global_relabel(False)\n                grt.clear_work()\n    R.graph['flow_value'] = R_nodes[t]['excess']\n    return R",
            "def preflow_push_impl(G, s, t, capacity, residual, global_relabel_freq, value_only):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Implementation of the highest-label preflow-push algorithm.'\n    if s not in G:\n        raise nx.NetworkXError(f'node {str(s)} not in graph')\n    if t not in G:\n        raise nx.NetworkXError(f'node {str(t)} not in graph')\n    if s == t:\n        raise nx.NetworkXError('source and sink are the same node')\n    if global_relabel_freq is None:\n        global_relabel_freq = 0\n    if global_relabel_freq < 0:\n        raise nx.NetworkXError('global_relabel_freq must be nonnegative.')\n    if residual is None:\n        R = build_residual_network(G, capacity)\n    else:\n        R = residual\n    detect_unboundedness(R, s, t)\n    R_nodes = R.nodes\n    R_pred = R.pred\n    R_succ = R.succ\n    for u in R:\n        R_nodes[u]['excess'] = 0\n        for e in R_succ[u].values():\n            e['flow'] = 0\n\n    def reverse_bfs(src):\n        \"\"\"Perform a reverse breadth-first search from src in the residual\n        network.\n        \"\"\"\n        heights = {src: 0}\n        q = deque([(src, 0)])\n        while q:\n            (u, height) = q.popleft()\n            height += 1\n            for (v, attr) in R_pred[u].items():\n                if v not in heights and attr['flow'] < attr['capacity']:\n                    heights[v] = height\n                    q.append((v, height))\n        return heights\n    heights = reverse_bfs(t)\n    if s not in heights:\n        R.graph['flow_value'] = 0\n        return R\n    n = len(R)\n    max_height = max((heights[u] for u in heights if u != s))\n    heights[s] = n\n    grt = GlobalRelabelThreshold(n, R.size(), global_relabel_freq)\n    for u in R:\n        R_nodes[u]['height'] = heights[u] if u in heights else n + 1\n        R_nodes[u]['curr_edge'] = CurrentEdge(R_succ[u])\n\n    def push(u, v, flow):\n        \"\"\"Push flow units of flow from u to v.\"\"\"\n        R_succ[u][v]['flow'] += flow\n        R_succ[v][u]['flow'] -= flow\n        R_nodes[u]['excess'] -= flow\n        R_nodes[v]['excess'] += flow\n    for (u, attr) in R_succ[s].items():\n        flow = attr['capacity']\n        if flow > 0:\n            push(s, u, flow)\n    levels = [Level() for i in range(2 * n)]\n    for u in R:\n        if u != s and u != t:\n            level = levels[R_nodes[u]['height']]\n            if R_nodes[u]['excess'] > 0:\n                level.active.add(u)\n            else:\n                level.inactive.add(u)\n\n    def activate(v):\n        \"\"\"Move a node from the inactive set to the active set of its level.\"\"\"\n        if v != s and v != t:\n            level = levels[R_nodes[v]['height']]\n            if v in level.inactive:\n                level.inactive.remove(v)\n                level.active.add(v)\n\n    def relabel(u):\n        \"\"\"Relabel a node to create an admissible edge.\"\"\"\n        grt.add_work(len(R_succ[u]))\n        return min((R_nodes[v]['height'] for (v, attr) in R_succ[u].items() if attr['flow'] < attr['capacity'])) + 1\n\n    def discharge(u, is_phase1):\n        \"\"\"Discharge a node until it becomes inactive or, during phase 1 (see\n        below), its height reaches at least n. The node is known to have the\n        largest height among active nodes.\n        \"\"\"\n        height = R_nodes[u]['height']\n        curr_edge = R_nodes[u]['curr_edge']\n        next_height = height\n        levels[height].active.remove(u)\n        while True:\n            (v, attr) = curr_edge.get()\n            if height == R_nodes[v]['height'] + 1 and attr['flow'] < attr['capacity']:\n                flow = min(R_nodes[u]['excess'], attr['capacity'] - attr['flow'])\n                push(u, v, flow)\n                activate(v)\n                if R_nodes[u]['excess'] == 0:\n                    levels[height].inactive.add(u)\n                    break\n            try:\n                curr_edge.move_to_next()\n            except StopIteration:\n                height = relabel(u)\n                if is_phase1 and height >= n - 1:\n                    levels[height].active.add(u)\n                    break\n                next_height = height\n        R_nodes[u]['height'] = height\n        return next_height\n\n    def gap_heuristic(height):\n        \"\"\"Apply the gap heuristic.\"\"\"\n        for level in islice(levels, height + 1, max_height + 1):\n            for u in level.active:\n                R_nodes[u]['height'] = n + 1\n            for u in level.inactive:\n                R_nodes[u]['height'] = n + 1\n            levels[n + 1].active.update(level.active)\n            level.active.clear()\n            levels[n + 1].inactive.update(level.inactive)\n            level.inactive.clear()\n\n    def global_relabel(from_sink):\n        \"\"\"Apply the global relabeling heuristic.\"\"\"\n        src = t if from_sink else s\n        heights = reverse_bfs(src)\n        if not from_sink:\n            del heights[t]\n        max_height = max(heights.values())\n        if from_sink:\n            for u in R:\n                if u not in heights and R_nodes[u]['height'] < n:\n                    heights[u] = n + 1\n        else:\n            for u in heights:\n                heights[u] += n\n            max_height += n\n        del heights[src]\n        for (u, new_height) in heights.items():\n            old_height = R_nodes[u]['height']\n            if new_height != old_height:\n                if u in levels[old_height].active:\n                    levels[old_height].active.remove(u)\n                    levels[new_height].active.add(u)\n                else:\n                    levels[old_height].inactive.remove(u)\n                    levels[new_height].inactive.add(u)\n                R_nodes[u]['height'] = new_height\n        return max_height\n    height = max_height\n    while height > 0:\n        while True:\n            level = levels[height]\n            if not level.active:\n                height -= 1\n                break\n            old_height = height\n            old_level = level\n            u = arbitrary_element(level.active)\n            height = discharge(u, True)\n            if grt.is_reached():\n                height = global_relabel(True)\n                max_height = height\n                grt.clear_work()\n            elif not old_level.active and (not old_level.inactive):\n                gap_heuristic(old_height)\n                height = old_height - 1\n                max_height = height\n            else:\n                max_height = max(max_height, height)\n    if value_only:\n        R.graph['flow_value'] = R_nodes[t]['excess']\n        return R\n    height = global_relabel(False)\n    grt.clear_work()\n    while height > n:\n        while True:\n            level = levels[height]\n            if not level.active:\n                height -= 1\n                break\n            u = arbitrary_element(level.active)\n            height = discharge(u, False)\n            if grt.is_reached():\n                height = global_relabel(False)\n                grt.clear_work()\n    R.graph['flow_value'] = R_nodes[t]['excess']\n    return R",
            "def preflow_push_impl(G, s, t, capacity, residual, global_relabel_freq, value_only):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Implementation of the highest-label preflow-push algorithm.'\n    if s not in G:\n        raise nx.NetworkXError(f'node {str(s)} not in graph')\n    if t not in G:\n        raise nx.NetworkXError(f'node {str(t)} not in graph')\n    if s == t:\n        raise nx.NetworkXError('source and sink are the same node')\n    if global_relabel_freq is None:\n        global_relabel_freq = 0\n    if global_relabel_freq < 0:\n        raise nx.NetworkXError('global_relabel_freq must be nonnegative.')\n    if residual is None:\n        R = build_residual_network(G, capacity)\n    else:\n        R = residual\n    detect_unboundedness(R, s, t)\n    R_nodes = R.nodes\n    R_pred = R.pred\n    R_succ = R.succ\n    for u in R:\n        R_nodes[u]['excess'] = 0\n        for e in R_succ[u].values():\n            e['flow'] = 0\n\n    def reverse_bfs(src):\n        \"\"\"Perform a reverse breadth-first search from src in the residual\n        network.\n        \"\"\"\n        heights = {src: 0}\n        q = deque([(src, 0)])\n        while q:\n            (u, height) = q.popleft()\n            height += 1\n            for (v, attr) in R_pred[u].items():\n                if v not in heights and attr['flow'] < attr['capacity']:\n                    heights[v] = height\n                    q.append((v, height))\n        return heights\n    heights = reverse_bfs(t)\n    if s not in heights:\n        R.graph['flow_value'] = 0\n        return R\n    n = len(R)\n    max_height = max((heights[u] for u in heights if u != s))\n    heights[s] = n\n    grt = GlobalRelabelThreshold(n, R.size(), global_relabel_freq)\n    for u in R:\n        R_nodes[u]['height'] = heights[u] if u in heights else n + 1\n        R_nodes[u]['curr_edge'] = CurrentEdge(R_succ[u])\n\n    def push(u, v, flow):\n        \"\"\"Push flow units of flow from u to v.\"\"\"\n        R_succ[u][v]['flow'] += flow\n        R_succ[v][u]['flow'] -= flow\n        R_nodes[u]['excess'] -= flow\n        R_nodes[v]['excess'] += flow\n    for (u, attr) in R_succ[s].items():\n        flow = attr['capacity']\n        if flow > 0:\n            push(s, u, flow)\n    levels = [Level() for i in range(2 * n)]\n    for u in R:\n        if u != s and u != t:\n            level = levels[R_nodes[u]['height']]\n            if R_nodes[u]['excess'] > 0:\n                level.active.add(u)\n            else:\n                level.inactive.add(u)\n\n    def activate(v):\n        \"\"\"Move a node from the inactive set to the active set of its level.\"\"\"\n        if v != s and v != t:\n            level = levels[R_nodes[v]['height']]\n            if v in level.inactive:\n                level.inactive.remove(v)\n                level.active.add(v)\n\n    def relabel(u):\n        \"\"\"Relabel a node to create an admissible edge.\"\"\"\n        grt.add_work(len(R_succ[u]))\n        return min((R_nodes[v]['height'] for (v, attr) in R_succ[u].items() if attr['flow'] < attr['capacity'])) + 1\n\n    def discharge(u, is_phase1):\n        \"\"\"Discharge a node until it becomes inactive or, during phase 1 (see\n        below), its height reaches at least n. The node is known to have the\n        largest height among active nodes.\n        \"\"\"\n        height = R_nodes[u]['height']\n        curr_edge = R_nodes[u]['curr_edge']\n        next_height = height\n        levels[height].active.remove(u)\n        while True:\n            (v, attr) = curr_edge.get()\n            if height == R_nodes[v]['height'] + 1 and attr['flow'] < attr['capacity']:\n                flow = min(R_nodes[u]['excess'], attr['capacity'] - attr['flow'])\n                push(u, v, flow)\n                activate(v)\n                if R_nodes[u]['excess'] == 0:\n                    levels[height].inactive.add(u)\n                    break\n            try:\n                curr_edge.move_to_next()\n            except StopIteration:\n                height = relabel(u)\n                if is_phase1 and height >= n - 1:\n                    levels[height].active.add(u)\n                    break\n                next_height = height\n        R_nodes[u]['height'] = height\n        return next_height\n\n    def gap_heuristic(height):\n        \"\"\"Apply the gap heuristic.\"\"\"\n        for level in islice(levels, height + 1, max_height + 1):\n            for u in level.active:\n                R_nodes[u]['height'] = n + 1\n            for u in level.inactive:\n                R_nodes[u]['height'] = n + 1\n            levels[n + 1].active.update(level.active)\n            level.active.clear()\n            levels[n + 1].inactive.update(level.inactive)\n            level.inactive.clear()\n\n    def global_relabel(from_sink):\n        \"\"\"Apply the global relabeling heuristic.\"\"\"\n        src = t if from_sink else s\n        heights = reverse_bfs(src)\n        if not from_sink:\n            del heights[t]\n        max_height = max(heights.values())\n        if from_sink:\n            for u in R:\n                if u not in heights and R_nodes[u]['height'] < n:\n                    heights[u] = n + 1\n        else:\n            for u in heights:\n                heights[u] += n\n            max_height += n\n        del heights[src]\n        for (u, new_height) in heights.items():\n            old_height = R_nodes[u]['height']\n            if new_height != old_height:\n                if u in levels[old_height].active:\n                    levels[old_height].active.remove(u)\n                    levels[new_height].active.add(u)\n                else:\n                    levels[old_height].inactive.remove(u)\n                    levels[new_height].inactive.add(u)\n                R_nodes[u]['height'] = new_height\n        return max_height\n    height = max_height\n    while height > 0:\n        while True:\n            level = levels[height]\n            if not level.active:\n                height -= 1\n                break\n            old_height = height\n            old_level = level\n            u = arbitrary_element(level.active)\n            height = discharge(u, True)\n            if grt.is_reached():\n                height = global_relabel(True)\n                max_height = height\n                grt.clear_work()\n            elif not old_level.active and (not old_level.inactive):\n                gap_heuristic(old_height)\n                height = old_height - 1\n                max_height = height\n            else:\n                max_height = max(max_height, height)\n    if value_only:\n        R.graph['flow_value'] = R_nodes[t]['excess']\n        return R\n    height = global_relabel(False)\n    grt.clear_work()\n    while height > n:\n        while True:\n            level = levels[height]\n            if not level.active:\n                height -= 1\n                break\n            u = arbitrary_element(level.active)\n            height = discharge(u, False)\n            if grt.is_reached():\n                height = global_relabel(False)\n                grt.clear_work()\n    R.graph['flow_value'] = R_nodes[t]['excess']\n    return R",
            "def preflow_push_impl(G, s, t, capacity, residual, global_relabel_freq, value_only):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Implementation of the highest-label preflow-push algorithm.'\n    if s not in G:\n        raise nx.NetworkXError(f'node {str(s)} not in graph')\n    if t not in G:\n        raise nx.NetworkXError(f'node {str(t)} not in graph')\n    if s == t:\n        raise nx.NetworkXError('source and sink are the same node')\n    if global_relabel_freq is None:\n        global_relabel_freq = 0\n    if global_relabel_freq < 0:\n        raise nx.NetworkXError('global_relabel_freq must be nonnegative.')\n    if residual is None:\n        R = build_residual_network(G, capacity)\n    else:\n        R = residual\n    detect_unboundedness(R, s, t)\n    R_nodes = R.nodes\n    R_pred = R.pred\n    R_succ = R.succ\n    for u in R:\n        R_nodes[u]['excess'] = 0\n        for e in R_succ[u].values():\n            e['flow'] = 0\n\n    def reverse_bfs(src):\n        \"\"\"Perform a reverse breadth-first search from src in the residual\n        network.\n        \"\"\"\n        heights = {src: 0}\n        q = deque([(src, 0)])\n        while q:\n            (u, height) = q.popleft()\n            height += 1\n            for (v, attr) in R_pred[u].items():\n                if v not in heights and attr['flow'] < attr['capacity']:\n                    heights[v] = height\n                    q.append((v, height))\n        return heights\n    heights = reverse_bfs(t)\n    if s not in heights:\n        R.graph['flow_value'] = 0\n        return R\n    n = len(R)\n    max_height = max((heights[u] for u in heights if u != s))\n    heights[s] = n\n    grt = GlobalRelabelThreshold(n, R.size(), global_relabel_freq)\n    for u in R:\n        R_nodes[u]['height'] = heights[u] if u in heights else n + 1\n        R_nodes[u]['curr_edge'] = CurrentEdge(R_succ[u])\n\n    def push(u, v, flow):\n        \"\"\"Push flow units of flow from u to v.\"\"\"\n        R_succ[u][v]['flow'] += flow\n        R_succ[v][u]['flow'] -= flow\n        R_nodes[u]['excess'] -= flow\n        R_nodes[v]['excess'] += flow\n    for (u, attr) in R_succ[s].items():\n        flow = attr['capacity']\n        if flow > 0:\n            push(s, u, flow)\n    levels = [Level() for i in range(2 * n)]\n    for u in R:\n        if u != s and u != t:\n            level = levels[R_nodes[u]['height']]\n            if R_nodes[u]['excess'] > 0:\n                level.active.add(u)\n            else:\n                level.inactive.add(u)\n\n    def activate(v):\n        \"\"\"Move a node from the inactive set to the active set of its level.\"\"\"\n        if v != s and v != t:\n            level = levels[R_nodes[v]['height']]\n            if v in level.inactive:\n                level.inactive.remove(v)\n                level.active.add(v)\n\n    def relabel(u):\n        \"\"\"Relabel a node to create an admissible edge.\"\"\"\n        grt.add_work(len(R_succ[u]))\n        return min((R_nodes[v]['height'] for (v, attr) in R_succ[u].items() if attr['flow'] < attr['capacity'])) + 1\n\n    def discharge(u, is_phase1):\n        \"\"\"Discharge a node until it becomes inactive or, during phase 1 (see\n        below), its height reaches at least n. The node is known to have the\n        largest height among active nodes.\n        \"\"\"\n        height = R_nodes[u]['height']\n        curr_edge = R_nodes[u]['curr_edge']\n        next_height = height\n        levels[height].active.remove(u)\n        while True:\n            (v, attr) = curr_edge.get()\n            if height == R_nodes[v]['height'] + 1 and attr['flow'] < attr['capacity']:\n                flow = min(R_nodes[u]['excess'], attr['capacity'] - attr['flow'])\n                push(u, v, flow)\n                activate(v)\n                if R_nodes[u]['excess'] == 0:\n                    levels[height].inactive.add(u)\n                    break\n            try:\n                curr_edge.move_to_next()\n            except StopIteration:\n                height = relabel(u)\n                if is_phase1 and height >= n - 1:\n                    levels[height].active.add(u)\n                    break\n                next_height = height\n        R_nodes[u]['height'] = height\n        return next_height\n\n    def gap_heuristic(height):\n        \"\"\"Apply the gap heuristic.\"\"\"\n        for level in islice(levels, height + 1, max_height + 1):\n            for u in level.active:\n                R_nodes[u]['height'] = n + 1\n            for u in level.inactive:\n                R_nodes[u]['height'] = n + 1\n            levels[n + 1].active.update(level.active)\n            level.active.clear()\n            levels[n + 1].inactive.update(level.inactive)\n            level.inactive.clear()\n\n    def global_relabel(from_sink):\n        \"\"\"Apply the global relabeling heuristic.\"\"\"\n        src = t if from_sink else s\n        heights = reverse_bfs(src)\n        if not from_sink:\n            del heights[t]\n        max_height = max(heights.values())\n        if from_sink:\n            for u in R:\n                if u not in heights and R_nodes[u]['height'] < n:\n                    heights[u] = n + 1\n        else:\n            for u in heights:\n                heights[u] += n\n            max_height += n\n        del heights[src]\n        for (u, new_height) in heights.items():\n            old_height = R_nodes[u]['height']\n            if new_height != old_height:\n                if u in levels[old_height].active:\n                    levels[old_height].active.remove(u)\n                    levels[new_height].active.add(u)\n                else:\n                    levels[old_height].inactive.remove(u)\n                    levels[new_height].inactive.add(u)\n                R_nodes[u]['height'] = new_height\n        return max_height\n    height = max_height\n    while height > 0:\n        while True:\n            level = levels[height]\n            if not level.active:\n                height -= 1\n                break\n            old_height = height\n            old_level = level\n            u = arbitrary_element(level.active)\n            height = discharge(u, True)\n            if grt.is_reached():\n                height = global_relabel(True)\n                max_height = height\n                grt.clear_work()\n            elif not old_level.active and (not old_level.inactive):\n                gap_heuristic(old_height)\n                height = old_height - 1\n                max_height = height\n            else:\n                max_height = max(max_height, height)\n    if value_only:\n        R.graph['flow_value'] = R_nodes[t]['excess']\n        return R\n    height = global_relabel(False)\n    grt.clear_work()\n    while height > n:\n        while True:\n            level = levels[height]\n            if not level.active:\n                height -= 1\n                break\n            u = arbitrary_element(level.active)\n            height = discharge(u, False)\n            if grt.is_reached():\n                height = global_relabel(False)\n                grt.clear_work()\n    R.graph['flow_value'] = R_nodes[t]['excess']\n    return R",
            "def preflow_push_impl(G, s, t, capacity, residual, global_relabel_freq, value_only):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Implementation of the highest-label preflow-push algorithm.'\n    if s not in G:\n        raise nx.NetworkXError(f'node {str(s)} not in graph')\n    if t not in G:\n        raise nx.NetworkXError(f'node {str(t)} not in graph')\n    if s == t:\n        raise nx.NetworkXError('source and sink are the same node')\n    if global_relabel_freq is None:\n        global_relabel_freq = 0\n    if global_relabel_freq < 0:\n        raise nx.NetworkXError('global_relabel_freq must be nonnegative.')\n    if residual is None:\n        R = build_residual_network(G, capacity)\n    else:\n        R = residual\n    detect_unboundedness(R, s, t)\n    R_nodes = R.nodes\n    R_pred = R.pred\n    R_succ = R.succ\n    for u in R:\n        R_nodes[u]['excess'] = 0\n        for e in R_succ[u].values():\n            e['flow'] = 0\n\n    def reverse_bfs(src):\n        \"\"\"Perform a reverse breadth-first search from src in the residual\n        network.\n        \"\"\"\n        heights = {src: 0}\n        q = deque([(src, 0)])\n        while q:\n            (u, height) = q.popleft()\n            height += 1\n            for (v, attr) in R_pred[u].items():\n                if v not in heights and attr['flow'] < attr['capacity']:\n                    heights[v] = height\n                    q.append((v, height))\n        return heights\n    heights = reverse_bfs(t)\n    if s not in heights:\n        R.graph['flow_value'] = 0\n        return R\n    n = len(R)\n    max_height = max((heights[u] for u in heights if u != s))\n    heights[s] = n\n    grt = GlobalRelabelThreshold(n, R.size(), global_relabel_freq)\n    for u in R:\n        R_nodes[u]['height'] = heights[u] if u in heights else n + 1\n        R_nodes[u]['curr_edge'] = CurrentEdge(R_succ[u])\n\n    def push(u, v, flow):\n        \"\"\"Push flow units of flow from u to v.\"\"\"\n        R_succ[u][v]['flow'] += flow\n        R_succ[v][u]['flow'] -= flow\n        R_nodes[u]['excess'] -= flow\n        R_nodes[v]['excess'] += flow\n    for (u, attr) in R_succ[s].items():\n        flow = attr['capacity']\n        if flow > 0:\n            push(s, u, flow)\n    levels = [Level() for i in range(2 * n)]\n    for u in R:\n        if u != s and u != t:\n            level = levels[R_nodes[u]['height']]\n            if R_nodes[u]['excess'] > 0:\n                level.active.add(u)\n            else:\n                level.inactive.add(u)\n\n    def activate(v):\n        \"\"\"Move a node from the inactive set to the active set of its level.\"\"\"\n        if v != s and v != t:\n            level = levels[R_nodes[v]['height']]\n            if v in level.inactive:\n                level.inactive.remove(v)\n                level.active.add(v)\n\n    def relabel(u):\n        \"\"\"Relabel a node to create an admissible edge.\"\"\"\n        grt.add_work(len(R_succ[u]))\n        return min((R_nodes[v]['height'] for (v, attr) in R_succ[u].items() if attr['flow'] < attr['capacity'])) + 1\n\n    def discharge(u, is_phase1):\n        \"\"\"Discharge a node until it becomes inactive or, during phase 1 (see\n        below), its height reaches at least n. The node is known to have the\n        largest height among active nodes.\n        \"\"\"\n        height = R_nodes[u]['height']\n        curr_edge = R_nodes[u]['curr_edge']\n        next_height = height\n        levels[height].active.remove(u)\n        while True:\n            (v, attr) = curr_edge.get()\n            if height == R_nodes[v]['height'] + 1 and attr['flow'] < attr['capacity']:\n                flow = min(R_nodes[u]['excess'], attr['capacity'] - attr['flow'])\n                push(u, v, flow)\n                activate(v)\n                if R_nodes[u]['excess'] == 0:\n                    levels[height].inactive.add(u)\n                    break\n            try:\n                curr_edge.move_to_next()\n            except StopIteration:\n                height = relabel(u)\n                if is_phase1 and height >= n - 1:\n                    levels[height].active.add(u)\n                    break\n                next_height = height\n        R_nodes[u]['height'] = height\n        return next_height\n\n    def gap_heuristic(height):\n        \"\"\"Apply the gap heuristic.\"\"\"\n        for level in islice(levels, height + 1, max_height + 1):\n            for u in level.active:\n                R_nodes[u]['height'] = n + 1\n            for u in level.inactive:\n                R_nodes[u]['height'] = n + 1\n            levels[n + 1].active.update(level.active)\n            level.active.clear()\n            levels[n + 1].inactive.update(level.inactive)\n            level.inactive.clear()\n\n    def global_relabel(from_sink):\n        \"\"\"Apply the global relabeling heuristic.\"\"\"\n        src = t if from_sink else s\n        heights = reverse_bfs(src)\n        if not from_sink:\n            del heights[t]\n        max_height = max(heights.values())\n        if from_sink:\n            for u in R:\n                if u not in heights and R_nodes[u]['height'] < n:\n                    heights[u] = n + 1\n        else:\n            for u in heights:\n                heights[u] += n\n            max_height += n\n        del heights[src]\n        for (u, new_height) in heights.items():\n            old_height = R_nodes[u]['height']\n            if new_height != old_height:\n                if u in levels[old_height].active:\n                    levels[old_height].active.remove(u)\n                    levels[new_height].active.add(u)\n                else:\n                    levels[old_height].inactive.remove(u)\n                    levels[new_height].inactive.add(u)\n                R_nodes[u]['height'] = new_height\n        return max_height\n    height = max_height\n    while height > 0:\n        while True:\n            level = levels[height]\n            if not level.active:\n                height -= 1\n                break\n            old_height = height\n            old_level = level\n            u = arbitrary_element(level.active)\n            height = discharge(u, True)\n            if grt.is_reached():\n                height = global_relabel(True)\n                max_height = height\n                grt.clear_work()\n            elif not old_level.active and (not old_level.inactive):\n                gap_heuristic(old_height)\n                height = old_height - 1\n                max_height = height\n            else:\n                max_height = max(max_height, height)\n    if value_only:\n        R.graph['flow_value'] = R_nodes[t]['excess']\n        return R\n    height = global_relabel(False)\n    grt.clear_work()\n    while height > n:\n        while True:\n            level = levels[height]\n            if not level.active:\n                height -= 1\n                break\n            u = arbitrary_element(level.active)\n            height = discharge(u, False)\n            if grt.is_reached():\n                height = global_relabel(False)\n                grt.clear_work()\n    R.graph['flow_value'] = R_nodes[t]['excess']\n    return R"
        ]
    },
    {
        "func_name": "preflow_push",
        "original": "@nx._dispatch(graphs={'G': 0, 'residual?': 4}, edge_attrs={'capacity': float('inf')}, preserve_edge_attrs={'residual': {'capacity': float('inf')}}, preserve_graph_attrs={'residual'})\ndef preflow_push(G, s, t, capacity='capacity', residual=None, global_relabel_freq=1, value_only=False):\n    \"\"\"Find a maximum single-commodity flow using the highest-label\n    preflow-push algorithm.\n\n    This function returns the residual network resulting after computing\n    the maximum flow. See below for details about the conventions\n    NetworkX uses for defining residual networks.\n\n    This algorithm has a running time of $O(n^2 \\\\sqrt{m})$ for $n$ nodes and\n    $m$ edges.\n\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        Edges of the graph are expected to have an attribute called\n        'capacity'. If this attribute is not present, the edge is\n        considered to have infinite capacity.\n\n    s : node\n        Source node for the flow.\n\n    t : node\n        Sink node for the flow.\n\n    capacity : string\n        Edges of the graph G are expected to have an attribute capacity\n        that indicates how much flow the edge can support. If this\n        attribute is not present, the edge is considered to have\n        infinite capacity. Default value: 'capacity'.\n\n    residual : NetworkX graph\n        Residual network on which the algorithm is to be executed. If None, a\n        new residual network is created. Default value: None.\n\n    global_relabel_freq : integer, float\n        Relative frequency of applying the global relabeling heuristic to speed\n        up the algorithm. If it is None, the heuristic is disabled. Default\n        value: 1.\n\n    value_only : bool\n        If False, compute a maximum flow; otherwise, compute a maximum preflow\n        which is enough for computing the maximum flow value. Default value:\n        False.\n\n    Returns\n    -------\n    R : NetworkX DiGraph\n        Residual network after computing the maximum flow.\n\n    Raises\n    ------\n    NetworkXError\n        The algorithm does not support MultiGraph and MultiDiGraph. If\n        the input graph is an instance of one of these two classes, a\n        NetworkXError is raised.\n\n    NetworkXUnbounded\n        If the graph has a path of infinite capacity, the value of a\n        feasible flow on the graph is unbounded above and the function\n        raises a NetworkXUnbounded.\n\n    See also\n    --------\n    :meth:`maximum_flow`\n    :meth:`minimum_cut`\n    :meth:`edmonds_karp`\n    :meth:`shortest_augmenting_path`\n\n    Notes\n    -----\n    The residual network :samp:`R` from an input graph :samp:`G` has the\n    same nodes as :samp:`G`. :samp:`R` is a DiGraph that contains a pair\n    of edges :samp:`(u, v)` and :samp:`(v, u)` iff :samp:`(u, v)` is not a\n    self-loop, and at least one of :samp:`(u, v)` and :samp:`(v, u)` exists\n    in :samp:`G`. For each node :samp:`u` in :samp:`R`,\n    :samp:`R.nodes[u]['excess']` represents the difference between flow into\n    :samp:`u` and flow out of :samp:`u`.\n\n    For each edge :samp:`(u, v)` in :samp:`R`, :samp:`R[u][v]['capacity']`\n    is equal to the capacity of :samp:`(u, v)` in :samp:`G` if it exists\n    in :samp:`G` or zero otherwise. If the capacity is infinite,\n    :samp:`R[u][v]['capacity']` will have a high arbitrary finite value\n    that does not affect the solution of the problem. This value is stored in\n    :samp:`R.graph['inf']`. For each edge :samp:`(u, v)` in :samp:`R`,\n    :samp:`R[u][v]['flow']` represents the flow function of :samp:`(u, v)` and\n    satisfies :samp:`R[u][v]['flow'] == -R[v][u]['flow']`.\n\n    The flow value, defined as the total flow into :samp:`t`, the sink, is\n    stored in :samp:`R.graph['flow_value']`. Reachability to :samp:`t` using\n    only edges :samp:`(u, v)` such that\n    :samp:`R[u][v]['flow'] < R[u][v]['capacity']` induces a minimum\n    :samp:`s`-:samp:`t` cut.\n\n    Examples\n    --------\n    >>> from networkx.algorithms.flow import preflow_push\n\n    The functions that implement flow algorithms and output a residual\n    network, such as this one, are not imported to the base NetworkX\n    namespace, so you have to explicitly import them from the flow package.\n\n    >>> G = nx.DiGraph()\n    >>> G.add_edge(\"x\", \"a\", capacity=3.0)\n    >>> G.add_edge(\"x\", \"b\", capacity=1.0)\n    >>> G.add_edge(\"a\", \"c\", capacity=3.0)\n    >>> G.add_edge(\"b\", \"c\", capacity=5.0)\n    >>> G.add_edge(\"b\", \"d\", capacity=4.0)\n    >>> G.add_edge(\"d\", \"e\", capacity=2.0)\n    >>> G.add_edge(\"c\", \"y\", capacity=2.0)\n    >>> G.add_edge(\"e\", \"y\", capacity=3.0)\n    >>> R = preflow_push(G, \"x\", \"y\")\n    >>> flow_value = nx.maximum_flow_value(G, \"x\", \"y\")\n    >>> flow_value == R.graph[\"flow_value\"]\n    True\n    >>> # preflow_push also stores the maximum flow value\n    >>> # in the excess attribute of the sink node t\n    >>> flow_value == R.nodes[\"y\"][\"excess\"]\n    True\n    >>> # For some problems, you might only want to compute a\n    >>> # maximum preflow.\n    >>> R = preflow_push(G, \"x\", \"y\", value_only=True)\n    >>> flow_value == R.graph[\"flow_value\"]\n    True\n    >>> flow_value == R.nodes[\"y\"][\"excess\"]\n    True\n\n    \"\"\"\n    R = preflow_push_impl(G, s, t, capacity, residual, global_relabel_freq, value_only)\n    R.graph['algorithm'] = 'preflow_push'\n    return R",
        "mutated": [
            "@nx._dispatch(graphs={'G': 0, 'residual?': 4}, edge_attrs={'capacity': float('inf')}, preserve_edge_attrs={'residual': {'capacity': float('inf')}}, preserve_graph_attrs={'residual'})\ndef preflow_push(G, s, t, capacity='capacity', residual=None, global_relabel_freq=1, value_only=False):\n    if False:\n        i = 10\n    'Find a maximum single-commodity flow using the highest-label\\n    preflow-push algorithm.\\n\\n    This function returns the residual network resulting after computing\\n    the maximum flow. See below for details about the conventions\\n    NetworkX uses for defining residual networks.\\n\\n    This algorithm has a running time of $O(n^2 \\\\sqrt{m})$ for $n$ nodes and\\n    $m$ edges.\\n\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Edges of the graph are expected to have an attribute called\\n        \\'capacity\\'. If this attribute is not present, the edge is\\n        considered to have infinite capacity.\\n\\n    s : node\\n        Source node for the flow.\\n\\n    t : node\\n        Sink node for the flow.\\n\\n    capacity : string\\n        Edges of the graph G are expected to have an attribute capacity\\n        that indicates how much flow the edge can support. If this\\n        attribute is not present, the edge is considered to have\\n        infinite capacity. Default value: \\'capacity\\'.\\n\\n    residual : NetworkX graph\\n        Residual network on which the algorithm is to be executed. If None, a\\n        new residual network is created. Default value: None.\\n\\n    global_relabel_freq : integer, float\\n        Relative frequency of applying the global relabeling heuristic to speed\\n        up the algorithm. If it is None, the heuristic is disabled. Default\\n        value: 1.\\n\\n    value_only : bool\\n        If False, compute a maximum flow; otherwise, compute a maximum preflow\\n        which is enough for computing the maximum flow value. Default value:\\n        False.\\n\\n    Returns\\n    -------\\n    R : NetworkX DiGraph\\n        Residual network after computing the maximum flow.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        The algorithm does not support MultiGraph and MultiDiGraph. If\\n        the input graph is an instance of one of these two classes, a\\n        NetworkXError is raised.\\n\\n    NetworkXUnbounded\\n        If the graph has a path of infinite capacity, the value of a\\n        feasible flow on the graph is unbounded above and the function\\n        raises a NetworkXUnbounded.\\n\\n    See also\\n    --------\\n    :meth:`maximum_flow`\\n    :meth:`minimum_cut`\\n    :meth:`edmonds_karp`\\n    :meth:`shortest_augmenting_path`\\n\\n    Notes\\n    -----\\n    The residual network :samp:`R` from an input graph :samp:`G` has the\\n    same nodes as :samp:`G`. :samp:`R` is a DiGraph that contains a pair\\n    of edges :samp:`(u, v)` and :samp:`(v, u)` iff :samp:`(u, v)` is not a\\n    self-loop, and at least one of :samp:`(u, v)` and :samp:`(v, u)` exists\\n    in :samp:`G`. For each node :samp:`u` in :samp:`R`,\\n    :samp:`R.nodes[u][\\'excess\\']` represents the difference between flow into\\n    :samp:`u` and flow out of :samp:`u`.\\n\\n    For each edge :samp:`(u, v)` in :samp:`R`, :samp:`R[u][v][\\'capacity\\']`\\n    is equal to the capacity of :samp:`(u, v)` in :samp:`G` if it exists\\n    in :samp:`G` or zero otherwise. If the capacity is infinite,\\n    :samp:`R[u][v][\\'capacity\\']` will have a high arbitrary finite value\\n    that does not affect the solution of the problem. This value is stored in\\n    :samp:`R.graph[\\'inf\\']`. For each edge :samp:`(u, v)` in :samp:`R`,\\n    :samp:`R[u][v][\\'flow\\']` represents the flow function of :samp:`(u, v)` and\\n    satisfies :samp:`R[u][v][\\'flow\\'] == -R[v][u][\\'flow\\']`.\\n\\n    The flow value, defined as the total flow into :samp:`t`, the sink, is\\n    stored in :samp:`R.graph[\\'flow_value\\']`. Reachability to :samp:`t` using\\n    only edges :samp:`(u, v)` such that\\n    :samp:`R[u][v][\\'flow\\'] < R[u][v][\\'capacity\\']` induces a minimum\\n    :samp:`s`-:samp:`t` cut.\\n\\n    Examples\\n    --------\\n    >>> from networkx.algorithms.flow import preflow_push\\n\\n    The functions that implement flow algorithms and output a residual\\n    network, such as this one, are not imported to the base NetworkX\\n    namespace, so you have to explicitly import them from the flow package.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_edge(\"x\", \"a\", capacity=3.0)\\n    >>> G.add_edge(\"x\", \"b\", capacity=1.0)\\n    >>> G.add_edge(\"a\", \"c\", capacity=3.0)\\n    >>> G.add_edge(\"b\", \"c\", capacity=5.0)\\n    >>> G.add_edge(\"b\", \"d\", capacity=4.0)\\n    >>> G.add_edge(\"d\", \"e\", capacity=2.0)\\n    >>> G.add_edge(\"c\", \"y\", capacity=2.0)\\n    >>> G.add_edge(\"e\", \"y\", capacity=3.0)\\n    >>> R = preflow_push(G, \"x\", \"y\")\\n    >>> flow_value = nx.maximum_flow_value(G, \"x\", \"y\")\\n    >>> flow_value == R.graph[\"flow_value\"]\\n    True\\n    >>> # preflow_push also stores the maximum flow value\\n    >>> # in the excess attribute of the sink node t\\n    >>> flow_value == R.nodes[\"y\"][\"excess\"]\\n    True\\n    >>> # For some problems, you might only want to compute a\\n    >>> # maximum preflow.\\n    >>> R = preflow_push(G, \"x\", \"y\", value_only=True)\\n    >>> flow_value == R.graph[\"flow_value\"]\\n    True\\n    >>> flow_value == R.nodes[\"y\"][\"excess\"]\\n    True\\n\\n    '\n    R = preflow_push_impl(G, s, t, capacity, residual, global_relabel_freq, value_only)\n    R.graph['algorithm'] = 'preflow_push'\n    return R",
            "@nx._dispatch(graphs={'G': 0, 'residual?': 4}, edge_attrs={'capacity': float('inf')}, preserve_edge_attrs={'residual': {'capacity': float('inf')}}, preserve_graph_attrs={'residual'})\ndef preflow_push(G, s, t, capacity='capacity', residual=None, global_relabel_freq=1, value_only=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Find a maximum single-commodity flow using the highest-label\\n    preflow-push algorithm.\\n\\n    This function returns the residual network resulting after computing\\n    the maximum flow. See below for details about the conventions\\n    NetworkX uses for defining residual networks.\\n\\n    This algorithm has a running time of $O(n^2 \\\\sqrt{m})$ for $n$ nodes and\\n    $m$ edges.\\n\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Edges of the graph are expected to have an attribute called\\n        \\'capacity\\'. If this attribute is not present, the edge is\\n        considered to have infinite capacity.\\n\\n    s : node\\n        Source node for the flow.\\n\\n    t : node\\n        Sink node for the flow.\\n\\n    capacity : string\\n        Edges of the graph G are expected to have an attribute capacity\\n        that indicates how much flow the edge can support. If this\\n        attribute is not present, the edge is considered to have\\n        infinite capacity. Default value: \\'capacity\\'.\\n\\n    residual : NetworkX graph\\n        Residual network on which the algorithm is to be executed. If None, a\\n        new residual network is created. Default value: None.\\n\\n    global_relabel_freq : integer, float\\n        Relative frequency of applying the global relabeling heuristic to speed\\n        up the algorithm. If it is None, the heuristic is disabled. Default\\n        value: 1.\\n\\n    value_only : bool\\n        If False, compute a maximum flow; otherwise, compute a maximum preflow\\n        which is enough for computing the maximum flow value. Default value:\\n        False.\\n\\n    Returns\\n    -------\\n    R : NetworkX DiGraph\\n        Residual network after computing the maximum flow.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        The algorithm does not support MultiGraph and MultiDiGraph. If\\n        the input graph is an instance of one of these two classes, a\\n        NetworkXError is raised.\\n\\n    NetworkXUnbounded\\n        If the graph has a path of infinite capacity, the value of a\\n        feasible flow on the graph is unbounded above and the function\\n        raises a NetworkXUnbounded.\\n\\n    See also\\n    --------\\n    :meth:`maximum_flow`\\n    :meth:`minimum_cut`\\n    :meth:`edmonds_karp`\\n    :meth:`shortest_augmenting_path`\\n\\n    Notes\\n    -----\\n    The residual network :samp:`R` from an input graph :samp:`G` has the\\n    same nodes as :samp:`G`. :samp:`R` is a DiGraph that contains a pair\\n    of edges :samp:`(u, v)` and :samp:`(v, u)` iff :samp:`(u, v)` is not a\\n    self-loop, and at least one of :samp:`(u, v)` and :samp:`(v, u)` exists\\n    in :samp:`G`. For each node :samp:`u` in :samp:`R`,\\n    :samp:`R.nodes[u][\\'excess\\']` represents the difference between flow into\\n    :samp:`u` and flow out of :samp:`u`.\\n\\n    For each edge :samp:`(u, v)` in :samp:`R`, :samp:`R[u][v][\\'capacity\\']`\\n    is equal to the capacity of :samp:`(u, v)` in :samp:`G` if it exists\\n    in :samp:`G` or zero otherwise. If the capacity is infinite,\\n    :samp:`R[u][v][\\'capacity\\']` will have a high arbitrary finite value\\n    that does not affect the solution of the problem. This value is stored in\\n    :samp:`R.graph[\\'inf\\']`. For each edge :samp:`(u, v)` in :samp:`R`,\\n    :samp:`R[u][v][\\'flow\\']` represents the flow function of :samp:`(u, v)` and\\n    satisfies :samp:`R[u][v][\\'flow\\'] == -R[v][u][\\'flow\\']`.\\n\\n    The flow value, defined as the total flow into :samp:`t`, the sink, is\\n    stored in :samp:`R.graph[\\'flow_value\\']`. Reachability to :samp:`t` using\\n    only edges :samp:`(u, v)` such that\\n    :samp:`R[u][v][\\'flow\\'] < R[u][v][\\'capacity\\']` induces a minimum\\n    :samp:`s`-:samp:`t` cut.\\n\\n    Examples\\n    --------\\n    >>> from networkx.algorithms.flow import preflow_push\\n\\n    The functions that implement flow algorithms and output a residual\\n    network, such as this one, are not imported to the base NetworkX\\n    namespace, so you have to explicitly import them from the flow package.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_edge(\"x\", \"a\", capacity=3.0)\\n    >>> G.add_edge(\"x\", \"b\", capacity=1.0)\\n    >>> G.add_edge(\"a\", \"c\", capacity=3.0)\\n    >>> G.add_edge(\"b\", \"c\", capacity=5.0)\\n    >>> G.add_edge(\"b\", \"d\", capacity=4.0)\\n    >>> G.add_edge(\"d\", \"e\", capacity=2.0)\\n    >>> G.add_edge(\"c\", \"y\", capacity=2.0)\\n    >>> G.add_edge(\"e\", \"y\", capacity=3.0)\\n    >>> R = preflow_push(G, \"x\", \"y\")\\n    >>> flow_value = nx.maximum_flow_value(G, \"x\", \"y\")\\n    >>> flow_value == R.graph[\"flow_value\"]\\n    True\\n    >>> # preflow_push also stores the maximum flow value\\n    >>> # in the excess attribute of the sink node t\\n    >>> flow_value == R.nodes[\"y\"][\"excess\"]\\n    True\\n    >>> # For some problems, you might only want to compute a\\n    >>> # maximum preflow.\\n    >>> R = preflow_push(G, \"x\", \"y\", value_only=True)\\n    >>> flow_value == R.graph[\"flow_value\"]\\n    True\\n    >>> flow_value == R.nodes[\"y\"][\"excess\"]\\n    True\\n\\n    '\n    R = preflow_push_impl(G, s, t, capacity, residual, global_relabel_freq, value_only)\n    R.graph['algorithm'] = 'preflow_push'\n    return R",
            "@nx._dispatch(graphs={'G': 0, 'residual?': 4}, edge_attrs={'capacity': float('inf')}, preserve_edge_attrs={'residual': {'capacity': float('inf')}}, preserve_graph_attrs={'residual'})\ndef preflow_push(G, s, t, capacity='capacity', residual=None, global_relabel_freq=1, value_only=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Find a maximum single-commodity flow using the highest-label\\n    preflow-push algorithm.\\n\\n    This function returns the residual network resulting after computing\\n    the maximum flow. See below for details about the conventions\\n    NetworkX uses for defining residual networks.\\n\\n    This algorithm has a running time of $O(n^2 \\\\sqrt{m})$ for $n$ nodes and\\n    $m$ edges.\\n\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Edges of the graph are expected to have an attribute called\\n        \\'capacity\\'. If this attribute is not present, the edge is\\n        considered to have infinite capacity.\\n\\n    s : node\\n        Source node for the flow.\\n\\n    t : node\\n        Sink node for the flow.\\n\\n    capacity : string\\n        Edges of the graph G are expected to have an attribute capacity\\n        that indicates how much flow the edge can support. If this\\n        attribute is not present, the edge is considered to have\\n        infinite capacity. Default value: \\'capacity\\'.\\n\\n    residual : NetworkX graph\\n        Residual network on which the algorithm is to be executed. If None, a\\n        new residual network is created. Default value: None.\\n\\n    global_relabel_freq : integer, float\\n        Relative frequency of applying the global relabeling heuristic to speed\\n        up the algorithm. If it is None, the heuristic is disabled. Default\\n        value: 1.\\n\\n    value_only : bool\\n        If False, compute a maximum flow; otherwise, compute a maximum preflow\\n        which is enough for computing the maximum flow value. Default value:\\n        False.\\n\\n    Returns\\n    -------\\n    R : NetworkX DiGraph\\n        Residual network after computing the maximum flow.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        The algorithm does not support MultiGraph and MultiDiGraph. If\\n        the input graph is an instance of one of these two classes, a\\n        NetworkXError is raised.\\n\\n    NetworkXUnbounded\\n        If the graph has a path of infinite capacity, the value of a\\n        feasible flow on the graph is unbounded above and the function\\n        raises a NetworkXUnbounded.\\n\\n    See also\\n    --------\\n    :meth:`maximum_flow`\\n    :meth:`minimum_cut`\\n    :meth:`edmonds_karp`\\n    :meth:`shortest_augmenting_path`\\n\\n    Notes\\n    -----\\n    The residual network :samp:`R` from an input graph :samp:`G` has the\\n    same nodes as :samp:`G`. :samp:`R` is a DiGraph that contains a pair\\n    of edges :samp:`(u, v)` and :samp:`(v, u)` iff :samp:`(u, v)` is not a\\n    self-loop, and at least one of :samp:`(u, v)` and :samp:`(v, u)` exists\\n    in :samp:`G`. For each node :samp:`u` in :samp:`R`,\\n    :samp:`R.nodes[u][\\'excess\\']` represents the difference between flow into\\n    :samp:`u` and flow out of :samp:`u`.\\n\\n    For each edge :samp:`(u, v)` in :samp:`R`, :samp:`R[u][v][\\'capacity\\']`\\n    is equal to the capacity of :samp:`(u, v)` in :samp:`G` if it exists\\n    in :samp:`G` or zero otherwise. If the capacity is infinite,\\n    :samp:`R[u][v][\\'capacity\\']` will have a high arbitrary finite value\\n    that does not affect the solution of the problem. This value is stored in\\n    :samp:`R.graph[\\'inf\\']`. For each edge :samp:`(u, v)` in :samp:`R`,\\n    :samp:`R[u][v][\\'flow\\']` represents the flow function of :samp:`(u, v)` and\\n    satisfies :samp:`R[u][v][\\'flow\\'] == -R[v][u][\\'flow\\']`.\\n\\n    The flow value, defined as the total flow into :samp:`t`, the sink, is\\n    stored in :samp:`R.graph[\\'flow_value\\']`. Reachability to :samp:`t` using\\n    only edges :samp:`(u, v)` such that\\n    :samp:`R[u][v][\\'flow\\'] < R[u][v][\\'capacity\\']` induces a minimum\\n    :samp:`s`-:samp:`t` cut.\\n\\n    Examples\\n    --------\\n    >>> from networkx.algorithms.flow import preflow_push\\n\\n    The functions that implement flow algorithms and output a residual\\n    network, such as this one, are not imported to the base NetworkX\\n    namespace, so you have to explicitly import them from the flow package.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_edge(\"x\", \"a\", capacity=3.0)\\n    >>> G.add_edge(\"x\", \"b\", capacity=1.0)\\n    >>> G.add_edge(\"a\", \"c\", capacity=3.0)\\n    >>> G.add_edge(\"b\", \"c\", capacity=5.0)\\n    >>> G.add_edge(\"b\", \"d\", capacity=4.0)\\n    >>> G.add_edge(\"d\", \"e\", capacity=2.0)\\n    >>> G.add_edge(\"c\", \"y\", capacity=2.0)\\n    >>> G.add_edge(\"e\", \"y\", capacity=3.0)\\n    >>> R = preflow_push(G, \"x\", \"y\")\\n    >>> flow_value = nx.maximum_flow_value(G, \"x\", \"y\")\\n    >>> flow_value == R.graph[\"flow_value\"]\\n    True\\n    >>> # preflow_push also stores the maximum flow value\\n    >>> # in the excess attribute of the sink node t\\n    >>> flow_value == R.nodes[\"y\"][\"excess\"]\\n    True\\n    >>> # For some problems, you might only want to compute a\\n    >>> # maximum preflow.\\n    >>> R = preflow_push(G, \"x\", \"y\", value_only=True)\\n    >>> flow_value == R.graph[\"flow_value\"]\\n    True\\n    >>> flow_value == R.nodes[\"y\"][\"excess\"]\\n    True\\n\\n    '\n    R = preflow_push_impl(G, s, t, capacity, residual, global_relabel_freq, value_only)\n    R.graph['algorithm'] = 'preflow_push'\n    return R",
            "@nx._dispatch(graphs={'G': 0, 'residual?': 4}, edge_attrs={'capacity': float('inf')}, preserve_edge_attrs={'residual': {'capacity': float('inf')}}, preserve_graph_attrs={'residual'})\ndef preflow_push(G, s, t, capacity='capacity', residual=None, global_relabel_freq=1, value_only=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Find a maximum single-commodity flow using the highest-label\\n    preflow-push algorithm.\\n\\n    This function returns the residual network resulting after computing\\n    the maximum flow. See below for details about the conventions\\n    NetworkX uses for defining residual networks.\\n\\n    This algorithm has a running time of $O(n^2 \\\\sqrt{m})$ for $n$ nodes and\\n    $m$ edges.\\n\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Edges of the graph are expected to have an attribute called\\n        \\'capacity\\'. If this attribute is not present, the edge is\\n        considered to have infinite capacity.\\n\\n    s : node\\n        Source node for the flow.\\n\\n    t : node\\n        Sink node for the flow.\\n\\n    capacity : string\\n        Edges of the graph G are expected to have an attribute capacity\\n        that indicates how much flow the edge can support. If this\\n        attribute is not present, the edge is considered to have\\n        infinite capacity. Default value: \\'capacity\\'.\\n\\n    residual : NetworkX graph\\n        Residual network on which the algorithm is to be executed. If None, a\\n        new residual network is created. Default value: None.\\n\\n    global_relabel_freq : integer, float\\n        Relative frequency of applying the global relabeling heuristic to speed\\n        up the algorithm. If it is None, the heuristic is disabled. Default\\n        value: 1.\\n\\n    value_only : bool\\n        If False, compute a maximum flow; otherwise, compute a maximum preflow\\n        which is enough for computing the maximum flow value. Default value:\\n        False.\\n\\n    Returns\\n    -------\\n    R : NetworkX DiGraph\\n        Residual network after computing the maximum flow.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        The algorithm does not support MultiGraph and MultiDiGraph. If\\n        the input graph is an instance of one of these two classes, a\\n        NetworkXError is raised.\\n\\n    NetworkXUnbounded\\n        If the graph has a path of infinite capacity, the value of a\\n        feasible flow on the graph is unbounded above and the function\\n        raises a NetworkXUnbounded.\\n\\n    See also\\n    --------\\n    :meth:`maximum_flow`\\n    :meth:`minimum_cut`\\n    :meth:`edmonds_karp`\\n    :meth:`shortest_augmenting_path`\\n\\n    Notes\\n    -----\\n    The residual network :samp:`R` from an input graph :samp:`G` has the\\n    same nodes as :samp:`G`. :samp:`R` is a DiGraph that contains a pair\\n    of edges :samp:`(u, v)` and :samp:`(v, u)` iff :samp:`(u, v)` is not a\\n    self-loop, and at least one of :samp:`(u, v)` and :samp:`(v, u)` exists\\n    in :samp:`G`. For each node :samp:`u` in :samp:`R`,\\n    :samp:`R.nodes[u][\\'excess\\']` represents the difference between flow into\\n    :samp:`u` and flow out of :samp:`u`.\\n\\n    For each edge :samp:`(u, v)` in :samp:`R`, :samp:`R[u][v][\\'capacity\\']`\\n    is equal to the capacity of :samp:`(u, v)` in :samp:`G` if it exists\\n    in :samp:`G` or zero otherwise. If the capacity is infinite,\\n    :samp:`R[u][v][\\'capacity\\']` will have a high arbitrary finite value\\n    that does not affect the solution of the problem. This value is stored in\\n    :samp:`R.graph[\\'inf\\']`. For each edge :samp:`(u, v)` in :samp:`R`,\\n    :samp:`R[u][v][\\'flow\\']` represents the flow function of :samp:`(u, v)` and\\n    satisfies :samp:`R[u][v][\\'flow\\'] == -R[v][u][\\'flow\\']`.\\n\\n    The flow value, defined as the total flow into :samp:`t`, the sink, is\\n    stored in :samp:`R.graph[\\'flow_value\\']`. Reachability to :samp:`t` using\\n    only edges :samp:`(u, v)` such that\\n    :samp:`R[u][v][\\'flow\\'] < R[u][v][\\'capacity\\']` induces a minimum\\n    :samp:`s`-:samp:`t` cut.\\n\\n    Examples\\n    --------\\n    >>> from networkx.algorithms.flow import preflow_push\\n\\n    The functions that implement flow algorithms and output a residual\\n    network, such as this one, are not imported to the base NetworkX\\n    namespace, so you have to explicitly import them from the flow package.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_edge(\"x\", \"a\", capacity=3.0)\\n    >>> G.add_edge(\"x\", \"b\", capacity=1.0)\\n    >>> G.add_edge(\"a\", \"c\", capacity=3.0)\\n    >>> G.add_edge(\"b\", \"c\", capacity=5.0)\\n    >>> G.add_edge(\"b\", \"d\", capacity=4.0)\\n    >>> G.add_edge(\"d\", \"e\", capacity=2.0)\\n    >>> G.add_edge(\"c\", \"y\", capacity=2.0)\\n    >>> G.add_edge(\"e\", \"y\", capacity=3.0)\\n    >>> R = preflow_push(G, \"x\", \"y\")\\n    >>> flow_value = nx.maximum_flow_value(G, \"x\", \"y\")\\n    >>> flow_value == R.graph[\"flow_value\"]\\n    True\\n    >>> # preflow_push also stores the maximum flow value\\n    >>> # in the excess attribute of the sink node t\\n    >>> flow_value == R.nodes[\"y\"][\"excess\"]\\n    True\\n    >>> # For some problems, you might only want to compute a\\n    >>> # maximum preflow.\\n    >>> R = preflow_push(G, \"x\", \"y\", value_only=True)\\n    >>> flow_value == R.graph[\"flow_value\"]\\n    True\\n    >>> flow_value == R.nodes[\"y\"][\"excess\"]\\n    True\\n\\n    '\n    R = preflow_push_impl(G, s, t, capacity, residual, global_relabel_freq, value_only)\n    R.graph['algorithm'] = 'preflow_push'\n    return R",
            "@nx._dispatch(graphs={'G': 0, 'residual?': 4}, edge_attrs={'capacity': float('inf')}, preserve_edge_attrs={'residual': {'capacity': float('inf')}}, preserve_graph_attrs={'residual'})\ndef preflow_push(G, s, t, capacity='capacity', residual=None, global_relabel_freq=1, value_only=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Find a maximum single-commodity flow using the highest-label\\n    preflow-push algorithm.\\n\\n    This function returns the residual network resulting after computing\\n    the maximum flow. See below for details about the conventions\\n    NetworkX uses for defining residual networks.\\n\\n    This algorithm has a running time of $O(n^2 \\\\sqrt{m})$ for $n$ nodes and\\n    $m$ edges.\\n\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Edges of the graph are expected to have an attribute called\\n        \\'capacity\\'. If this attribute is not present, the edge is\\n        considered to have infinite capacity.\\n\\n    s : node\\n        Source node for the flow.\\n\\n    t : node\\n        Sink node for the flow.\\n\\n    capacity : string\\n        Edges of the graph G are expected to have an attribute capacity\\n        that indicates how much flow the edge can support. If this\\n        attribute is not present, the edge is considered to have\\n        infinite capacity. Default value: \\'capacity\\'.\\n\\n    residual : NetworkX graph\\n        Residual network on which the algorithm is to be executed. If None, a\\n        new residual network is created. Default value: None.\\n\\n    global_relabel_freq : integer, float\\n        Relative frequency of applying the global relabeling heuristic to speed\\n        up the algorithm. If it is None, the heuristic is disabled. Default\\n        value: 1.\\n\\n    value_only : bool\\n        If False, compute a maximum flow; otherwise, compute a maximum preflow\\n        which is enough for computing the maximum flow value. Default value:\\n        False.\\n\\n    Returns\\n    -------\\n    R : NetworkX DiGraph\\n        Residual network after computing the maximum flow.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        The algorithm does not support MultiGraph and MultiDiGraph. If\\n        the input graph is an instance of one of these two classes, a\\n        NetworkXError is raised.\\n\\n    NetworkXUnbounded\\n        If the graph has a path of infinite capacity, the value of a\\n        feasible flow on the graph is unbounded above and the function\\n        raises a NetworkXUnbounded.\\n\\n    See also\\n    --------\\n    :meth:`maximum_flow`\\n    :meth:`minimum_cut`\\n    :meth:`edmonds_karp`\\n    :meth:`shortest_augmenting_path`\\n\\n    Notes\\n    -----\\n    The residual network :samp:`R` from an input graph :samp:`G` has the\\n    same nodes as :samp:`G`. :samp:`R` is a DiGraph that contains a pair\\n    of edges :samp:`(u, v)` and :samp:`(v, u)` iff :samp:`(u, v)` is not a\\n    self-loop, and at least one of :samp:`(u, v)` and :samp:`(v, u)` exists\\n    in :samp:`G`. For each node :samp:`u` in :samp:`R`,\\n    :samp:`R.nodes[u][\\'excess\\']` represents the difference between flow into\\n    :samp:`u` and flow out of :samp:`u`.\\n\\n    For each edge :samp:`(u, v)` in :samp:`R`, :samp:`R[u][v][\\'capacity\\']`\\n    is equal to the capacity of :samp:`(u, v)` in :samp:`G` if it exists\\n    in :samp:`G` or zero otherwise. If the capacity is infinite,\\n    :samp:`R[u][v][\\'capacity\\']` will have a high arbitrary finite value\\n    that does not affect the solution of the problem. This value is stored in\\n    :samp:`R.graph[\\'inf\\']`. For each edge :samp:`(u, v)` in :samp:`R`,\\n    :samp:`R[u][v][\\'flow\\']` represents the flow function of :samp:`(u, v)` and\\n    satisfies :samp:`R[u][v][\\'flow\\'] == -R[v][u][\\'flow\\']`.\\n\\n    The flow value, defined as the total flow into :samp:`t`, the sink, is\\n    stored in :samp:`R.graph[\\'flow_value\\']`. Reachability to :samp:`t` using\\n    only edges :samp:`(u, v)` such that\\n    :samp:`R[u][v][\\'flow\\'] < R[u][v][\\'capacity\\']` induces a minimum\\n    :samp:`s`-:samp:`t` cut.\\n\\n    Examples\\n    --------\\n    >>> from networkx.algorithms.flow import preflow_push\\n\\n    The functions that implement flow algorithms and output a residual\\n    network, such as this one, are not imported to the base NetworkX\\n    namespace, so you have to explicitly import them from the flow package.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_edge(\"x\", \"a\", capacity=3.0)\\n    >>> G.add_edge(\"x\", \"b\", capacity=1.0)\\n    >>> G.add_edge(\"a\", \"c\", capacity=3.0)\\n    >>> G.add_edge(\"b\", \"c\", capacity=5.0)\\n    >>> G.add_edge(\"b\", \"d\", capacity=4.0)\\n    >>> G.add_edge(\"d\", \"e\", capacity=2.0)\\n    >>> G.add_edge(\"c\", \"y\", capacity=2.0)\\n    >>> G.add_edge(\"e\", \"y\", capacity=3.0)\\n    >>> R = preflow_push(G, \"x\", \"y\")\\n    >>> flow_value = nx.maximum_flow_value(G, \"x\", \"y\")\\n    >>> flow_value == R.graph[\"flow_value\"]\\n    True\\n    >>> # preflow_push also stores the maximum flow value\\n    >>> # in the excess attribute of the sink node t\\n    >>> flow_value == R.nodes[\"y\"][\"excess\"]\\n    True\\n    >>> # For some problems, you might only want to compute a\\n    >>> # maximum preflow.\\n    >>> R = preflow_push(G, \"x\", \"y\", value_only=True)\\n    >>> flow_value == R.graph[\"flow_value\"]\\n    True\\n    >>> flow_value == R.nodes[\"y\"][\"excess\"]\\n    True\\n\\n    '\n    R = preflow_push_impl(G, s, t, capacity, residual, global_relabel_freq, value_only)\n    R.graph['algorithm'] = 'preflow_push'\n    return R"
        ]
    }
]