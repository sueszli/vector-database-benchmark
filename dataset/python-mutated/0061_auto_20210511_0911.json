[
    {
        "func_name": "update_history",
        "original": "def update_history(apps, schema_editor):\n    \"\"\"\n    Update each existing StockItemTracking object,\n    convert the recorded \"quantity\" to a delta\n    \"\"\"\n    StockItem = apps.get_model('stock', 'stockitem')\n    StockItemTracking = apps.get_model('stock', 'stockitemtracking')\n    StockLocation = apps.get_model('stock', 'stocklocation')\n    update_count = 0\n    locations = StockLocation.objects.all()\n    for location in locations:\n        path = [location.name]\n        loc = location\n        while loc.parent:\n            loc = loc.parent\n            path = [loc.name] + path\n        location._path = '/'.join(path)\n    for item in StockItem.objects.all():\n        history = StockItemTracking.objects.filter(item=item).order_by('date')\n        if history.count() == 0:\n            continue\n        quantity = history[0].quantity\n        for (idx, entry) in enumerate(history):\n            deltas = {}\n            updated = False\n            q = entry.quantity\n            if idx == 0 or not q == quantity:\n                try:\n                    deltas['quantity']: float(q)\n                    updated = True\n                except Exception:\n                    print(f\"WARNING: Error converting quantity '{q}'\")\n            quantity = q\n            title = entry.title.lower()\n            tracking_type = None\n            if 'completed build' in title:\n                tracking_type = StockHistoryCode.BUILD_OUTPUT_COMPLETED\n            elif 'removed' in title and 'item' in title:\n                if entry.notes.lower().startswith('split '):\n                    tracking_type = StockHistoryCode.SPLIT_CHILD_ITEM\n                else:\n                    tracking_type = StockHistoryCode.STOCK_REMOVE\n                result = re.search('^removed ([\\\\d\\\\.]+) items', title)\n                if result:\n                    removed = result.groups()[0]\n                    try:\n                        deltas['removed'] = float(removed)\n                        deltas['quantity'] = float(q)\n                    except Exception:\n                        print(f\"WARNING: Error converting removed quantity '{removed}'\")\n                else:\n                    print(f\"Could not decode '{title}'\")\n            elif 'split from existing' in title:\n                tracking_type = StockHistoryCode.SPLIT_FROM_PARENT\n                deltas['quantity'] = float(q)\n            elif 'moved to' in title:\n                tracking_type = StockHistoryCode.STOCK_MOVE\n                result = re.search('^Moved to (.*)( - )*(.*) \\\\(from.*$', entry.title)\n                if result:\n                    text = result.groups()[0]\n                    matches = set()\n                    for location in locations:\n                        if text == location._path:\n                            matches.add(location)\n                        if text == location.name:\n                            matches.add(location)\n                        compare = f'{location.name} - {location.description}'\n                        if text == compare:\n                            matches.add(location)\n                        compare = f'{location._path} - {location.description}'\n                        if text == compare:\n                            matches.add(location)\n                    if len(matches) == 1:\n                        location = list(matches)[0]\n                        deltas['location'] = location.pk\n                    else:\n                        print(f\"No location match: '{text}'\")\n                        break\n            elif 'created stock item' in title:\n                tracking_type = StockHistoryCode.CREATED\n            elif 'add serial number' in title:\n                tracking_type = StockHistoryCode.ASSIGNED_SERIAL\n            elif 'returned from customer' in title:\n                tracking_type = StockHistoryCode.RETURNED_FROM_CUSTOMER\n            elif 'counted' in title:\n                tracking_type = StockHistoryCode.STOCK_COUNT\n            elif 'added' in title:\n                tracking_type = StockHistoryCode.STOCK_ADD\n                result = re.search('^added ([\\\\d\\\\.]+) items', title)\n                if result:\n                    added = result.groups()[0]\n                    try:\n                        deltas['added'] = float(added)\n                        deltas['quantity'] = float(q)\n                    except Exception:\n                        print(f\"WARNING: Error converting added quantity '{added}'\")\n                else:\n                    print(f\"Could not decode '{title}'\")\n            elif 'assigned to customer' in title:\n                tracking_type = StockHistoryCode.SENT_TO_CUSTOMER\n            elif 'installed into stock item' in title:\n                tracking_type = StockHistoryCode.INSTALLED_INTO_ASSEMBLY\n            elif 'uninstalled into location' in title:\n                tracking_type = StockHistoryCode.REMOVED_FROM_ASSEMBLY\n            elif 'installed stock item' in title:\n                tracking_type = StockHistoryCode.INSTALLED_CHILD_ITEM\n            elif 'received items' in title:\n                tracking_type = StockHistoryCode.RECEIVED_AGAINST_PURCHASE_ORDER\n            if tracking_type is not None:\n                entry.tracking_type = tracking_type.value\n                updated = True\n            if updated:\n                entry.deltas = deltas\n                entry.save()\n                update_count += 1\n    if update_count > 0:\n        print(f'\\n==========================\\nUpdated {update_count} StockItemHistory entries')",
        "mutated": [
            "def update_history(apps, schema_editor):\n    if False:\n        i = 10\n    '\\n    Update each existing StockItemTracking object,\\n    convert the recorded \"quantity\" to a delta\\n    '\n    StockItem = apps.get_model('stock', 'stockitem')\n    StockItemTracking = apps.get_model('stock', 'stockitemtracking')\n    StockLocation = apps.get_model('stock', 'stocklocation')\n    update_count = 0\n    locations = StockLocation.objects.all()\n    for location in locations:\n        path = [location.name]\n        loc = location\n        while loc.parent:\n            loc = loc.parent\n            path = [loc.name] + path\n        location._path = '/'.join(path)\n    for item in StockItem.objects.all():\n        history = StockItemTracking.objects.filter(item=item).order_by('date')\n        if history.count() == 0:\n            continue\n        quantity = history[0].quantity\n        for (idx, entry) in enumerate(history):\n            deltas = {}\n            updated = False\n            q = entry.quantity\n            if idx == 0 or not q == quantity:\n                try:\n                    deltas['quantity']: float(q)\n                    updated = True\n                except Exception:\n                    print(f\"WARNING: Error converting quantity '{q}'\")\n            quantity = q\n            title = entry.title.lower()\n            tracking_type = None\n            if 'completed build' in title:\n                tracking_type = StockHistoryCode.BUILD_OUTPUT_COMPLETED\n            elif 'removed' in title and 'item' in title:\n                if entry.notes.lower().startswith('split '):\n                    tracking_type = StockHistoryCode.SPLIT_CHILD_ITEM\n                else:\n                    tracking_type = StockHistoryCode.STOCK_REMOVE\n                result = re.search('^removed ([\\\\d\\\\.]+) items', title)\n                if result:\n                    removed = result.groups()[0]\n                    try:\n                        deltas['removed'] = float(removed)\n                        deltas['quantity'] = float(q)\n                    except Exception:\n                        print(f\"WARNING: Error converting removed quantity '{removed}'\")\n                else:\n                    print(f\"Could not decode '{title}'\")\n            elif 'split from existing' in title:\n                tracking_type = StockHistoryCode.SPLIT_FROM_PARENT\n                deltas['quantity'] = float(q)\n            elif 'moved to' in title:\n                tracking_type = StockHistoryCode.STOCK_MOVE\n                result = re.search('^Moved to (.*)( - )*(.*) \\\\(from.*$', entry.title)\n                if result:\n                    text = result.groups()[0]\n                    matches = set()\n                    for location in locations:\n                        if text == location._path:\n                            matches.add(location)\n                        if text == location.name:\n                            matches.add(location)\n                        compare = f'{location.name} - {location.description}'\n                        if text == compare:\n                            matches.add(location)\n                        compare = f'{location._path} - {location.description}'\n                        if text == compare:\n                            matches.add(location)\n                    if len(matches) == 1:\n                        location = list(matches)[0]\n                        deltas['location'] = location.pk\n                    else:\n                        print(f\"No location match: '{text}'\")\n                        break\n            elif 'created stock item' in title:\n                tracking_type = StockHistoryCode.CREATED\n            elif 'add serial number' in title:\n                tracking_type = StockHistoryCode.ASSIGNED_SERIAL\n            elif 'returned from customer' in title:\n                tracking_type = StockHistoryCode.RETURNED_FROM_CUSTOMER\n            elif 'counted' in title:\n                tracking_type = StockHistoryCode.STOCK_COUNT\n            elif 'added' in title:\n                tracking_type = StockHistoryCode.STOCK_ADD\n                result = re.search('^added ([\\\\d\\\\.]+) items', title)\n                if result:\n                    added = result.groups()[0]\n                    try:\n                        deltas['added'] = float(added)\n                        deltas['quantity'] = float(q)\n                    except Exception:\n                        print(f\"WARNING: Error converting added quantity '{added}'\")\n                else:\n                    print(f\"Could not decode '{title}'\")\n            elif 'assigned to customer' in title:\n                tracking_type = StockHistoryCode.SENT_TO_CUSTOMER\n            elif 'installed into stock item' in title:\n                tracking_type = StockHistoryCode.INSTALLED_INTO_ASSEMBLY\n            elif 'uninstalled into location' in title:\n                tracking_type = StockHistoryCode.REMOVED_FROM_ASSEMBLY\n            elif 'installed stock item' in title:\n                tracking_type = StockHistoryCode.INSTALLED_CHILD_ITEM\n            elif 'received items' in title:\n                tracking_type = StockHistoryCode.RECEIVED_AGAINST_PURCHASE_ORDER\n            if tracking_type is not None:\n                entry.tracking_type = tracking_type.value\n                updated = True\n            if updated:\n                entry.deltas = deltas\n                entry.save()\n                update_count += 1\n    if update_count > 0:\n        print(f'\\n==========================\\nUpdated {update_count} StockItemHistory entries')",
            "def update_history(apps, schema_editor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Update each existing StockItemTracking object,\\n    convert the recorded \"quantity\" to a delta\\n    '\n    StockItem = apps.get_model('stock', 'stockitem')\n    StockItemTracking = apps.get_model('stock', 'stockitemtracking')\n    StockLocation = apps.get_model('stock', 'stocklocation')\n    update_count = 0\n    locations = StockLocation.objects.all()\n    for location in locations:\n        path = [location.name]\n        loc = location\n        while loc.parent:\n            loc = loc.parent\n            path = [loc.name] + path\n        location._path = '/'.join(path)\n    for item in StockItem.objects.all():\n        history = StockItemTracking.objects.filter(item=item).order_by('date')\n        if history.count() == 0:\n            continue\n        quantity = history[0].quantity\n        for (idx, entry) in enumerate(history):\n            deltas = {}\n            updated = False\n            q = entry.quantity\n            if idx == 0 or not q == quantity:\n                try:\n                    deltas['quantity']: float(q)\n                    updated = True\n                except Exception:\n                    print(f\"WARNING: Error converting quantity '{q}'\")\n            quantity = q\n            title = entry.title.lower()\n            tracking_type = None\n            if 'completed build' in title:\n                tracking_type = StockHistoryCode.BUILD_OUTPUT_COMPLETED\n            elif 'removed' in title and 'item' in title:\n                if entry.notes.lower().startswith('split '):\n                    tracking_type = StockHistoryCode.SPLIT_CHILD_ITEM\n                else:\n                    tracking_type = StockHistoryCode.STOCK_REMOVE\n                result = re.search('^removed ([\\\\d\\\\.]+) items', title)\n                if result:\n                    removed = result.groups()[0]\n                    try:\n                        deltas['removed'] = float(removed)\n                        deltas['quantity'] = float(q)\n                    except Exception:\n                        print(f\"WARNING: Error converting removed quantity '{removed}'\")\n                else:\n                    print(f\"Could not decode '{title}'\")\n            elif 'split from existing' in title:\n                tracking_type = StockHistoryCode.SPLIT_FROM_PARENT\n                deltas['quantity'] = float(q)\n            elif 'moved to' in title:\n                tracking_type = StockHistoryCode.STOCK_MOVE\n                result = re.search('^Moved to (.*)( - )*(.*) \\\\(from.*$', entry.title)\n                if result:\n                    text = result.groups()[0]\n                    matches = set()\n                    for location in locations:\n                        if text == location._path:\n                            matches.add(location)\n                        if text == location.name:\n                            matches.add(location)\n                        compare = f'{location.name} - {location.description}'\n                        if text == compare:\n                            matches.add(location)\n                        compare = f'{location._path} - {location.description}'\n                        if text == compare:\n                            matches.add(location)\n                    if len(matches) == 1:\n                        location = list(matches)[0]\n                        deltas['location'] = location.pk\n                    else:\n                        print(f\"No location match: '{text}'\")\n                        break\n            elif 'created stock item' in title:\n                tracking_type = StockHistoryCode.CREATED\n            elif 'add serial number' in title:\n                tracking_type = StockHistoryCode.ASSIGNED_SERIAL\n            elif 'returned from customer' in title:\n                tracking_type = StockHistoryCode.RETURNED_FROM_CUSTOMER\n            elif 'counted' in title:\n                tracking_type = StockHistoryCode.STOCK_COUNT\n            elif 'added' in title:\n                tracking_type = StockHistoryCode.STOCK_ADD\n                result = re.search('^added ([\\\\d\\\\.]+) items', title)\n                if result:\n                    added = result.groups()[0]\n                    try:\n                        deltas['added'] = float(added)\n                        deltas['quantity'] = float(q)\n                    except Exception:\n                        print(f\"WARNING: Error converting added quantity '{added}'\")\n                else:\n                    print(f\"Could not decode '{title}'\")\n            elif 'assigned to customer' in title:\n                tracking_type = StockHistoryCode.SENT_TO_CUSTOMER\n            elif 'installed into stock item' in title:\n                tracking_type = StockHistoryCode.INSTALLED_INTO_ASSEMBLY\n            elif 'uninstalled into location' in title:\n                tracking_type = StockHistoryCode.REMOVED_FROM_ASSEMBLY\n            elif 'installed stock item' in title:\n                tracking_type = StockHistoryCode.INSTALLED_CHILD_ITEM\n            elif 'received items' in title:\n                tracking_type = StockHistoryCode.RECEIVED_AGAINST_PURCHASE_ORDER\n            if tracking_type is not None:\n                entry.tracking_type = tracking_type.value\n                updated = True\n            if updated:\n                entry.deltas = deltas\n                entry.save()\n                update_count += 1\n    if update_count > 0:\n        print(f'\\n==========================\\nUpdated {update_count} StockItemHistory entries')",
            "def update_history(apps, schema_editor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Update each existing StockItemTracking object,\\n    convert the recorded \"quantity\" to a delta\\n    '\n    StockItem = apps.get_model('stock', 'stockitem')\n    StockItemTracking = apps.get_model('stock', 'stockitemtracking')\n    StockLocation = apps.get_model('stock', 'stocklocation')\n    update_count = 0\n    locations = StockLocation.objects.all()\n    for location in locations:\n        path = [location.name]\n        loc = location\n        while loc.parent:\n            loc = loc.parent\n            path = [loc.name] + path\n        location._path = '/'.join(path)\n    for item in StockItem.objects.all():\n        history = StockItemTracking.objects.filter(item=item).order_by('date')\n        if history.count() == 0:\n            continue\n        quantity = history[0].quantity\n        for (idx, entry) in enumerate(history):\n            deltas = {}\n            updated = False\n            q = entry.quantity\n            if idx == 0 or not q == quantity:\n                try:\n                    deltas['quantity']: float(q)\n                    updated = True\n                except Exception:\n                    print(f\"WARNING: Error converting quantity '{q}'\")\n            quantity = q\n            title = entry.title.lower()\n            tracking_type = None\n            if 'completed build' in title:\n                tracking_type = StockHistoryCode.BUILD_OUTPUT_COMPLETED\n            elif 'removed' in title and 'item' in title:\n                if entry.notes.lower().startswith('split '):\n                    tracking_type = StockHistoryCode.SPLIT_CHILD_ITEM\n                else:\n                    tracking_type = StockHistoryCode.STOCK_REMOVE\n                result = re.search('^removed ([\\\\d\\\\.]+) items', title)\n                if result:\n                    removed = result.groups()[0]\n                    try:\n                        deltas['removed'] = float(removed)\n                        deltas['quantity'] = float(q)\n                    except Exception:\n                        print(f\"WARNING: Error converting removed quantity '{removed}'\")\n                else:\n                    print(f\"Could not decode '{title}'\")\n            elif 'split from existing' in title:\n                tracking_type = StockHistoryCode.SPLIT_FROM_PARENT\n                deltas['quantity'] = float(q)\n            elif 'moved to' in title:\n                tracking_type = StockHistoryCode.STOCK_MOVE\n                result = re.search('^Moved to (.*)( - )*(.*) \\\\(from.*$', entry.title)\n                if result:\n                    text = result.groups()[0]\n                    matches = set()\n                    for location in locations:\n                        if text == location._path:\n                            matches.add(location)\n                        if text == location.name:\n                            matches.add(location)\n                        compare = f'{location.name} - {location.description}'\n                        if text == compare:\n                            matches.add(location)\n                        compare = f'{location._path} - {location.description}'\n                        if text == compare:\n                            matches.add(location)\n                    if len(matches) == 1:\n                        location = list(matches)[0]\n                        deltas['location'] = location.pk\n                    else:\n                        print(f\"No location match: '{text}'\")\n                        break\n            elif 'created stock item' in title:\n                tracking_type = StockHistoryCode.CREATED\n            elif 'add serial number' in title:\n                tracking_type = StockHistoryCode.ASSIGNED_SERIAL\n            elif 'returned from customer' in title:\n                tracking_type = StockHistoryCode.RETURNED_FROM_CUSTOMER\n            elif 'counted' in title:\n                tracking_type = StockHistoryCode.STOCK_COUNT\n            elif 'added' in title:\n                tracking_type = StockHistoryCode.STOCK_ADD\n                result = re.search('^added ([\\\\d\\\\.]+) items', title)\n                if result:\n                    added = result.groups()[0]\n                    try:\n                        deltas['added'] = float(added)\n                        deltas['quantity'] = float(q)\n                    except Exception:\n                        print(f\"WARNING: Error converting added quantity '{added}'\")\n                else:\n                    print(f\"Could not decode '{title}'\")\n            elif 'assigned to customer' in title:\n                tracking_type = StockHistoryCode.SENT_TO_CUSTOMER\n            elif 'installed into stock item' in title:\n                tracking_type = StockHistoryCode.INSTALLED_INTO_ASSEMBLY\n            elif 'uninstalled into location' in title:\n                tracking_type = StockHistoryCode.REMOVED_FROM_ASSEMBLY\n            elif 'installed stock item' in title:\n                tracking_type = StockHistoryCode.INSTALLED_CHILD_ITEM\n            elif 'received items' in title:\n                tracking_type = StockHistoryCode.RECEIVED_AGAINST_PURCHASE_ORDER\n            if tracking_type is not None:\n                entry.tracking_type = tracking_type.value\n                updated = True\n            if updated:\n                entry.deltas = deltas\n                entry.save()\n                update_count += 1\n    if update_count > 0:\n        print(f'\\n==========================\\nUpdated {update_count} StockItemHistory entries')",
            "def update_history(apps, schema_editor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Update each existing StockItemTracking object,\\n    convert the recorded \"quantity\" to a delta\\n    '\n    StockItem = apps.get_model('stock', 'stockitem')\n    StockItemTracking = apps.get_model('stock', 'stockitemtracking')\n    StockLocation = apps.get_model('stock', 'stocklocation')\n    update_count = 0\n    locations = StockLocation.objects.all()\n    for location in locations:\n        path = [location.name]\n        loc = location\n        while loc.parent:\n            loc = loc.parent\n            path = [loc.name] + path\n        location._path = '/'.join(path)\n    for item in StockItem.objects.all():\n        history = StockItemTracking.objects.filter(item=item).order_by('date')\n        if history.count() == 0:\n            continue\n        quantity = history[0].quantity\n        for (idx, entry) in enumerate(history):\n            deltas = {}\n            updated = False\n            q = entry.quantity\n            if idx == 0 or not q == quantity:\n                try:\n                    deltas['quantity']: float(q)\n                    updated = True\n                except Exception:\n                    print(f\"WARNING: Error converting quantity '{q}'\")\n            quantity = q\n            title = entry.title.lower()\n            tracking_type = None\n            if 'completed build' in title:\n                tracking_type = StockHistoryCode.BUILD_OUTPUT_COMPLETED\n            elif 'removed' in title and 'item' in title:\n                if entry.notes.lower().startswith('split '):\n                    tracking_type = StockHistoryCode.SPLIT_CHILD_ITEM\n                else:\n                    tracking_type = StockHistoryCode.STOCK_REMOVE\n                result = re.search('^removed ([\\\\d\\\\.]+) items', title)\n                if result:\n                    removed = result.groups()[0]\n                    try:\n                        deltas['removed'] = float(removed)\n                        deltas['quantity'] = float(q)\n                    except Exception:\n                        print(f\"WARNING: Error converting removed quantity '{removed}'\")\n                else:\n                    print(f\"Could not decode '{title}'\")\n            elif 'split from existing' in title:\n                tracking_type = StockHistoryCode.SPLIT_FROM_PARENT\n                deltas['quantity'] = float(q)\n            elif 'moved to' in title:\n                tracking_type = StockHistoryCode.STOCK_MOVE\n                result = re.search('^Moved to (.*)( - )*(.*) \\\\(from.*$', entry.title)\n                if result:\n                    text = result.groups()[0]\n                    matches = set()\n                    for location in locations:\n                        if text == location._path:\n                            matches.add(location)\n                        if text == location.name:\n                            matches.add(location)\n                        compare = f'{location.name} - {location.description}'\n                        if text == compare:\n                            matches.add(location)\n                        compare = f'{location._path} - {location.description}'\n                        if text == compare:\n                            matches.add(location)\n                    if len(matches) == 1:\n                        location = list(matches)[0]\n                        deltas['location'] = location.pk\n                    else:\n                        print(f\"No location match: '{text}'\")\n                        break\n            elif 'created stock item' in title:\n                tracking_type = StockHistoryCode.CREATED\n            elif 'add serial number' in title:\n                tracking_type = StockHistoryCode.ASSIGNED_SERIAL\n            elif 'returned from customer' in title:\n                tracking_type = StockHistoryCode.RETURNED_FROM_CUSTOMER\n            elif 'counted' in title:\n                tracking_type = StockHistoryCode.STOCK_COUNT\n            elif 'added' in title:\n                tracking_type = StockHistoryCode.STOCK_ADD\n                result = re.search('^added ([\\\\d\\\\.]+) items', title)\n                if result:\n                    added = result.groups()[0]\n                    try:\n                        deltas['added'] = float(added)\n                        deltas['quantity'] = float(q)\n                    except Exception:\n                        print(f\"WARNING: Error converting added quantity '{added}'\")\n                else:\n                    print(f\"Could not decode '{title}'\")\n            elif 'assigned to customer' in title:\n                tracking_type = StockHistoryCode.SENT_TO_CUSTOMER\n            elif 'installed into stock item' in title:\n                tracking_type = StockHistoryCode.INSTALLED_INTO_ASSEMBLY\n            elif 'uninstalled into location' in title:\n                tracking_type = StockHistoryCode.REMOVED_FROM_ASSEMBLY\n            elif 'installed stock item' in title:\n                tracking_type = StockHistoryCode.INSTALLED_CHILD_ITEM\n            elif 'received items' in title:\n                tracking_type = StockHistoryCode.RECEIVED_AGAINST_PURCHASE_ORDER\n            if tracking_type is not None:\n                entry.tracking_type = tracking_type.value\n                updated = True\n            if updated:\n                entry.deltas = deltas\n                entry.save()\n                update_count += 1\n    if update_count > 0:\n        print(f'\\n==========================\\nUpdated {update_count} StockItemHistory entries')",
            "def update_history(apps, schema_editor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Update each existing StockItemTracking object,\\n    convert the recorded \"quantity\" to a delta\\n    '\n    StockItem = apps.get_model('stock', 'stockitem')\n    StockItemTracking = apps.get_model('stock', 'stockitemtracking')\n    StockLocation = apps.get_model('stock', 'stocklocation')\n    update_count = 0\n    locations = StockLocation.objects.all()\n    for location in locations:\n        path = [location.name]\n        loc = location\n        while loc.parent:\n            loc = loc.parent\n            path = [loc.name] + path\n        location._path = '/'.join(path)\n    for item in StockItem.objects.all():\n        history = StockItemTracking.objects.filter(item=item).order_by('date')\n        if history.count() == 0:\n            continue\n        quantity = history[0].quantity\n        for (idx, entry) in enumerate(history):\n            deltas = {}\n            updated = False\n            q = entry.quantity\n            if idx == 0 or not q == quantity:\n                try:\n                    deltas['quantity']: float(q)\n                    updated = True\n                except Exception:\n                    print(f\"WARNING: Error converting quantity '{q}'\")\n            quantity = q\n            title = entry.title.lower()\n            tracking_type = None\n            if 'completed build' in title:\n                tracking_type = StockHistoryCode.BUILD_OUTPUT_COMPLETED\n            elif 'removed' in title and 'item' in title:\n                if entry.notes.lower().startswith('split '):\n                    tracking_type = StockHistoryCode.SPLIT_CHILD_ITEM\n                else:\n                    tracking_type = StockHistoryCode.STOCK_REMOVE\n                result = re.search('^removed ([\\\\d\\\\.]+) items', title)\n                if result:\n                    removed = result.groups()[0]\n                    try:\n                        deltas['removed'] = float(removed)\n                        deltas['quantity'] = float(q)\n                    except Exception:\n                        print(f\"WARNING: Error converting removed quantity '{removed}'\")\n                else:\n                    print(f\"Could not decode '{title}'\")\n            elif 'split from existing' in title:\n                tracking_type = StockHistoryCode.SPLIT_FROM_PARENT\n                deltas['quantity'] = float(q)\n            elif 'moved to' in title:\n                tracking_type = StockHistoryCode.STOCK_MOVE\n                result = re.search('^Moved to (.*)( - )*(.*) \\\\(from.*$', entry.title)\n                if result:\n                    text = result.groups()[0]\n                    matches = set()\n                    for location in locations:\n                        if text == location._path:\n                            matches.add(location)\n                        if text == location.name:\n                            matches.add(location)\n                        compare = f'{location.name} - {location.description}'\n                        if text == compare:\n                            matches.add(location)\n                        compare = f'{location._path} - {location.description}'\n                        if text == compare:\n                            matches.add(location)\n                    if len(matches) == 1:\n                        location = list(matches)[0]\n                        deltas['location'] = location.pk\n                    else:\n                        print(f\"No location match: '{text}'\")\n                        break\n            elif 'created stock item' in title:\n                tracking_type = StockHistoryCode.CREATED\n            elif 'add serial number' in title:\n                tracking_type = StockHistoryCode.ASSIGNED_SERIAL\n            elif 'returned from customer' in title:\n                tracking_type = StockHistoryCode.RETURNED_FROM_CUSTOMER\n            elif 'counted' in title:\n                tracking_type = StockHistoryCode.STOCK_COUNT\n            elif 'added' in title:\n                tracking_type = StockHistoryCode.STOCK_ADD\n                result = re.search('^added ([\\\\d\\\\.]+) items', title)\n                if result:\n                    added = result.groups()[0]\n                    try:\n                        deltas['added'] = float(added)\n                        deltas['quantity'] = float(q)\n                    except Exception:\n                        print(f\"WARNING: Error converting added quantity '{added}'\")\n                else:\n                    print(f\"Could not decode '{title}'\")\n            elif 'assigned to customer' in title:\n                tracking_type = StockHistoryCode.SENT_TO_CUSTOMER\n            elif 'installed into stock item' in title:\n                tracking_type = StockHistoryCode.INSTALLED_INTO_ASSEMBLY\n            elif 'uninstalled into location' in title:\n                tracking_type = StockHistoryCode.REMOVED_FROM_ASSEMBLY\n            elif 'installed stock item' in title:\n                tracking_type = StockHistoryCode.INSTALLED_CHILD_ITEM\n            elif 'received items' in title:\n                tracking_type = StockHistoryCode.RECEIVED_AGAINST_PURCHASE_ORDER\n            if tracking_type is not None:\n                entry.tracking_type = tracking_type.value\n                updated = True\n            if updated:\n                entry.deltas = deltas\n                entry.save()\n                update_count += 1\n    if update_count > 0:\n        print(f'\\n==========================\\nUpdated {update_count} StockItemHistory entries')"
        ]
    }
]