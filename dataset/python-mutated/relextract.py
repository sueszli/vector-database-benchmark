"""
Code for extracting relational triples from the ieer and conll2002 corpora.

Relations are stored internally as dictionaries ('reldicts').

The two serialization outputs are "rtuple" and "clause".

- An rtuple is a tuple of the form ``(subj, filler, obj)``,
  where ``subj`` and ``obj`` are pairs of Named Entity mentions, and ``filler`` is the string of words
  occurring between ``sub`` and ``obj`` (with no intervening NEs). Strings are printed via ``repr()`` to
  circumvent locale variations in rendering utf-8 encoded strings.
- A clause is an atom of the form ``relsym(subjsym, objsym)``,
  where the relation, subject and object have been canonicalized to single strings.
"""
import html
import re
from collections import defaultdict
NE_CLASSES = {'ieer': ['LOCATION', 'ORGANIZATION', 'PERSON', 'DURATION', 'DATE', 'CARDINAL', 'PERCENT', 'MONEY', 'MEASURE'], 'conll2002': ['LOC', 'PER', 'ORG'], 'ace': ['LOCATION', 'ORGANIZATION', 'PERSON', 'DURATION', 'DATE', 'CARDINAL', 'PERCENT', 'MONEY', 'MEASURE', 'FACILITY', 'GPE']}
short2long = dict(LOC='LOCATION', ORG='ORGANIZATION', PER='PERSON')
long2short = dict(LOCATION='LOC', ORGANIZATION='ORG', PERSON='PER')

def _expand(type):
    if False:
        while True:
            i = 10
    '\n    Expand an NE class name.\n    :type type: str\n    :rtype: str\n    '
    try:
        return short2long[type]
    except KeyError:
        return type

def class_abbrev(type):
    if False:
        i = 10
        return i + 15
    '\n    Abbreviate an NE class name.\n    :type type: str\n    :rtype: str\n    '
    try:
        return long2short[type]
    except KeyError:
        return type

def _join(lst, sep=' ', untag=False):
    if False:
        return 10
    '\n    Join a list into a string, turning tags tuples into tag strings or just words.\n    :param untag: if ``True``, omit the tag from tagged input strings.\n    :type lst: list\n    :rtype: str\n    '
    try:
        return sep.join(lst)
    except TypeError:
        if untag:
            return sep.join((tup[0] for tup in lst))
        from nltk.tag import tuple2str
        return sep.join((tuple2str(tup) for tup in lst))

def descape_entity(m, defs=html.entities.entitydefs):
    if False:
        return 10
    '\n    Translate one entity to its ISO Latin value.\n    Inspired by example from effbot.org\n\n\n    '
    try:
        return defs[m.group(1)]
    except KeyError:
        return m.group(0)

def list2sym(lst):
    if False:
        return 10
    '\n    Convert a list of strings into a canonical symbol.\n    :type lst: list\n    :return: a Unicode string without whitespace\n    :rtype: unicode\n    '
    sym = _join(lst, '_', untag=True)
    sym = sym.lower()
    ENT = re.compile('&(\\w+?);')
    sym = ENT.sub(descape_entity, sym)
    sym = sym.replace('.', '')
    return sym

def tree2semi_rel(tree):
    if False:
        i = 10
        return i + 15
    "\n    Group a chunk structure into a list of 'semi-relations' of the form (list(str), ``Tree``).\n\n    In order to facilitate the construction of (``Tree``, string, ``Tree``) triples, this\n    identifies pairs whose first member is a list (possibly empty) of terminal\n    strings, and whose second member is a ``Tree`` of the form (NE_label, terminals).\n\n    :param tree: a chunk tree\n    :return: a list of pairs (list(str), ``Tree``)\n    :rtype: list of tuple\n    "
    from nltk.tree import Tree
    semi_rels = []
    semi_rel = [[], None]
    for dtr in tree:
        if not isinstance(dtr, Tree):
            semi_rel[0].append(dtr)
        else:
            semi_rel[1] = dtr
            semi_rels.append(semi_rel)
            semi_rel = [[], None]
    return semi_rels

def semi_rel2reldict(pairs, window=5, trace=False):
    if False:
        while True:
            i = 10
    "\n    Converts the pairs generated by ``tree2semi_rel`` into a 'reldict': a dictionary which\n    stores information about the subject and object NEs plus the filler between them.\n    Additionally, a left and right context of length =< window are captured (within\n    a given input sentence).\n\n    :param pairs: a pair of list(str) and ``Tree``, as generated by\n    :param window: a threshold for the number of items to include in the left and right context\n    :type window: int\n    :return: 'relation' dictionaries whose keys are 'lcon', 'subjclass', 'subjtext', 'subjsym', 'filler', objclass', objtext', 'objsym' and 'rcon'\n    :rtype: list(defaultdict)\n    "
    result = []
    while len(pairs) > 2:
        reldict = defaultdict(str)
        reldict['lcon'] = _join(pairs[0][0][-window:])
        reldict['subjclass'] = pairs[0][1].label()
        reldict['subjtext'] = _join(pairs[0][1].leaves())
        reldict['subjsym'] = list2sym(pairs[0][1].leaves())
        reldict['filler'] = _join(pairs[1][0])
        reldict['untagged_filler'] = _join(pairs[1][0], untag=True)
        reldict['objclass'] = pairs[1][1].label()
        reldict['objtext'] = _join(pairs[1][1].leaves())
        reldict['objsym'] = list2sym(pairs[1][1].leaves())
        reldict['rcon'] = _join(pairs[2][0][:window])
        if trace:
            print('(%s(%s, %s)' % (reldict['untagged_filler'], reldict['subjclass'], reldict['objclass']))
        result.append(reldict)
        pairs = pairs[1:]
    return result

def extract_rels(subjclass, objclass, doc, corpus='ace', pattern=None, window=10):
    if False:
        while True:
            i = 10
    "\n    Filter the output of ``semi_rel2reldict`` according to specified NE classes and a filler pattern.\n\n    The parameters ``subjclass`` and ``objclass`` can be used to restrict the\n    Named Entities to particular types (any of 'LOCATION', 'ORGANIZATION',\n    'PERSON', 'DURATION', 'DATE', 'CARDINAL', 'PERCENT', 'MONEY', 'MEASURE').\n\n    :param subjclass: the class of the subject Named Entity.\n    :type subjclass: str\n    :param objclass: the class of the object Named Entity.\n    :type objclass: str\n    :param doc: input document\n    :type doc: ieer document or a list of chunk trees\n    :param corpus: name of the corpus to take as input; possible values are\n        'ieer' and 'conll2002'\n    :type corpus: str\n    :param pattern: a regular expression for filtering the fillers of\n        retrieved triples.\n    :type pattern: SRE_Pattern\n    :param window: filters out fillers which exceed this threshold\n    :type window: int\n    :return: see ``mk_reldicts``\n    :rtype: list(defaultdict)\n    "
    if subjclass and subjclass not in NE_CLASSES[corpus]:
        if _expand(subjclass) in NE_CLASSES[corpus]:
            subjclass = _expand(subjclass)
        else:
            raise ValueError('your value for the subject type has not been recognized: %s' % subjclass)
    if objclass and objclass not in NE_CLASSES[corpus]:
        if _expand(objclass) in NE_CLASSES[corpus]:
            objclass = _expand(objclass)
        else:
            raise ValueError('your value for the object type has not been recognized: %s' % objclass)
    if corpus == 'ace' or corpus == 'conll2002':
        pairs = tree2semi_rel(doc)
    elif corpus == 'ieer':
        pairs = tree2semi_rel(doc.text) + tree2semi_rel(doc.headline)
    else:
        raise ValueError('corpus type not recognized')
    reldicts = semi_rel2reldict(pairs)
    relfilter = lambda x: x['subjclass'] == subjclass and len(x['filler'].split()) <= window and pattern.match(x['filler']) and (x['objclass'] == objclass)
    return list(filter(relfilter, reldicts))

def rtuple(reldict, lcon=False, rcon=False):
    if False:
        while True:
            i = 10
    '\n    Pretty print the reldict as an rtuple.\n    :param reldict: a relation dictionary\n    :type reldict: defaultdict\n    '
    items = [class_abbrev(reldict['subjclass']), reldict['subjtext'], reldict['filler'], class_abbrev(reldict['objclass']), reldict['objtext']]
    format = '[%s: %r] %r [%s: %r]'
    if lcon:
        items = [reldict['lcon']] + items
        format = '...%r)' + format
    if rcon:
        items.append(reldict['rcon'])
        format = format + '(%r...'
    printargs = tuple(items)
    return format % printargs

def clause(reldict, relsym):
    if False:
        return 10
    '\n    Print the relation in clausal form.\n    :param reldict: a relation dictionary\n    :type reldict: defaultdict\n    :param relsym: a label for the relation\n    :type relsym: str\n    '
    items = (relsym, reldict['subjsym'], reldict['objsym'])
    return '%s(%r, %r)' % items

def in_demo(trace=0, sql=True):
    if False:
        for i in range(10):
            print('nop')
    '\n    Select pairs of organizations and locations whose mentions occur with an\n    intervening occurrence of the preposition "in".\n\n    If the sql parameter is set to True, then the entity pairs are loaded into\n    an in-memory database, and subsequently pulled out using an SQL "SELECT"\n    query.\n    '
    from nltk.corpus import ieer
    if sql:
        try:
            import sqlite3
            connection = sqlite3.connect(':memory:')
            cur = connection.cursor()
            cur.execute('create table Locations\n            (OrgName text, LocationName text, DocID text)')
        except ImportError:
            import warnings
            warnings.warn('Cannot import sqlite; sql flag will be ignored.')
    IN = re.compile('.*\\bin\\b(?!\\b.+ing)')
    print()
    print('IEER: in(ORG, LOC) -- just the clauses:')
    print('=' * 45)
    for file in ieer.fileids():
        for doc in ieer.parsed_docs(file):
            if trace:
                print(doc.docno)
                print('=' * 15)
            for rel in extract_rels('ORG', 'LOC', doc, corpus='ieer', pattern=IN):
                print(clause(rel, relsym='IN'))
                if sql:
                    try:
                        rtuple = (rel['subjtext'], rel['objtext'], doc.docno)
                        cur.execute('insert into Locations\n                                    values (?, ?, ?)', rtuple)
                        connection.commit()
                    except NameError:
                        pass
    if sql:
        try:
            cur.execute("select OrgName from Locations\n                        where LocationName = 'Atlanta'")
            print()
            print('Extract data from SQL table: ORGs in Atlanta')
            print('-' * 15)
            for row in cur:
                print(row)
        except NameError:
            pass

def roles_demo(trace=0):
    if False:
        while True:
            i = 10
    from nltk.corpus import ieer
    roles = '\n    (.*(                   # assorted roles\n    analyst|\n    chair(wo)?man|\n    commissioner|\n    counsel|\n    director|\n    economist|\n    editor|\n    executive|\n    foreman|\n    governor|\n    head|\n    lawyer|\n    leader|\n    librarian).*)|\n    manager|\n    partner|\n    president|\n    producer|\n    professor|\n    researcher|\n    spokes(wo)?man|\n    writer|\n    ,\\sof\\sthe?\\s*  # "X, of (the) Y"\n    '
    ROLES = re.compile(roles, re.VERBOSE)
    print()
    print('IEER: has_role(PER, ORG) -- raw rtuples:')
    print('=' * 45)
    for file in ieer.fileids():
        for doc in ieer.parsed_docs(file):
            lcon = rcon = False
            if trace:
                print(doc.docno)
                print('=' * 15)
                lcon = rcon = True
            for rel in extract_rels('PER', 'ORG', doc, corpus='ieer', pattern=ROLES):
                print(rtuple(rel, lcon=lcon, rcon=rcon))

def ieer_headlines():
    if False:
        i = 10
        return i + 15
    from nltk.corpus import ieer
    from nltk.tree import Tree
    print('IEER: First 20 Headlines')
    print('=' * 45)
    trees = [(doc.docno, doc.headline) for file in ieer.fileids() for doc in ieer.parsed_docs(file)]
    for tree in trees[:20]:
        print()
        print('%s:\n%s' % tree)

def conllned(trace=1):
    if False:
        for i in range(10):
            print('nop')
    "\n    Find the copula+'van' relation ('of') in the Dutch tagged training corpus\n    from CoNLL 2002.\n    "
    from nltk.corpus import conll2002
    vnv = "\n    (\n    is/V|    # 3rd sing present and\n    was/V|   # past forms of the verb zijn ('be')\n    werd/V|  # and also present\n    wordt/V  # past of worden ('become)\n    )\n    .*       # followed by anything\n    van/Prep # followed by van ('of')\n    "
    VAN = re.compile(vnv, re.VERBOSE)
    print()
    print('Dutch CoNLL2002: van(PER, ORG) -- raw rtuples with context:')
    print('=' * 45)
    for doc in conll2002.chunked_sents('ned.train'):
        lcon = rcon = False
        if trace:
            lcon = rcon = True
        for rel in extract_rels('PER', 'ORG', doc, corpus='conll2002', pattern=VAN, window=10):
            print(rtuple(rel, lcon=lcon, rcon=rcon))

def conllesp():
    if False:
        for i in range(10):
            print('nop')
    from nltk.corpus import conll2002
    de = '\n    .*\n    (\n    de/SP|\n    del/SP\n    )\n    '
    DE = re.compile(de, re.VERBOSE)
    print()
    print('Spanish CoNLL2002: de(ORG, LOC) -- just the first 10 clauses:')
    print('=' * 45)
    rels = [rel for doc in conll2002.chunked_sents('esp.train') for rel in extract_rels('ORG', 'LOC', doc, corpus='conll2002', pattern=DE)]
    for r in rels[:10]:
        print(clause(r, relsym='DE'))
    print()

def ne_chunked():
    if False:
        for i in range(10):
            print('nop')
    print()
    print('1500 Sentences from Penn Treebank, as processed by NLTK NE Chunker')
    print('=' * 45)
    ROLE = re.compile('.*(chairman|president|trader|scientist|economist|analyst|partner).*')
    rels = []
    for (i, sent) in enumerate(nltk.corpus.treebank.tagged_sents()[:1500]):
        sent = nltk.ne_chunk(sent)
        rels = extract_rels('PER', 'ORG', sent, corpus='ace', pattern=ROLE, window=7)
        for rel in rels:
            print(f'{i:<5}{rtuple(rel)}')
if __name__ == '__main__':
    import nltk
    from nltk.sem import relextract
    in_demo(trace=0)
    roles_demo(trace=0)
    conllned()
    conllesp()
    ieer_headlines()
    ne_chunked()