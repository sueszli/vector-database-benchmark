[
    {
        "func_name": "_group_return",
        "original": "def _group_return(pred_label: pd.DataFrame=None, reverse: bool=False, N: int=5, **kwargs) -> tuple:\n    \"\"\"\n\n    :param pred_label:\n    :param reverse:\n    :param N:\n    :return:\n    \"\"\"\n    if reverse:\n        pred_label['score'] *= -1\n    pred_label = pred_label.sort_values('score', ascending=False)\n    pred_label_drop = pred_label.dropna(subset=['score'])\n    t_df = pd.DataFrame({'Group%d' % (i + 1): pred_label_drop.groupby(level='datetime')['label'].apply(lambda x: x[len(x) // N * i:len(x) // N * (i + 1)].mean()) for i in range(N)})\n    t_df.index = pd.to_datetime(t_df.index)\n    t_df['long-short'] = t_df['Group1'] - t_df['Group%d' % N]\n    t_df['long-average'] = t_df['Group1'] - pred_label.groupby(level='datetime')['label'].mean()\n    t_df = t_df.dropna(how='all')\n    group_scatter_figure = ScatterGraph(t_df.cumsum(), layout=dict(title='Cumulative Return', xaxis=dict(tickangle=45, rangebreaks=kwargs.get('rangebreaks', guess_plotly_rangebreaks(t_df.index))))).figure\n    t_df = t_df.loc[:, ['long-short', 'long-average']]\n    _bin_size = float(((t_df.max() - t_df.min()) / 20).min())\n    group_hist_figure = SubplotsGraph(t_df, kind_map=dict(kind='DistplotGraph', kwargs=dict(bin_size=_bin_size)), subplots_kwargs=dict(rows=1, cols=2, print_grid=False, subplot_titles=['long-short', 'long-average'])).figure\n    return (group_scatter_figure, group_hist_figure)",
        "mutated": [
            "def _group_return(pred_label: pd.DataFrame=None, reverse: bool=False, N: int=5, **kwargs) -> tuple:\n    if False:\n        i = 10\n    '\\n\\n    :param pred_label:\\n    :param reverse:\\n    :param N:\\n    :return:\\n    '\n    if reverse:\n        pred_label['score'] *= -1\n    pred_label = pred_label.sort_values('score', ascending=False)\n    pred_label_drop = pred_label.dropna(subset=['score'])\n    t_df = pd.DataFrame({'Group%d' % (i + 1): pred_label_drop.groupby(level='datetime')['label'].apply(lambda x: x[len(x) // N * i:len(x) // N * (i + 1)].mean()) for i in range(N)})\n    t_df.index = pd.to_datetime(t_df.index)\n    t_df['long-short'] = t_df['Group1'] - t_df['Group%d' % N]\n    t_df['long-average'] = t_df['Group1'] - pred_label.groupby(level='datetime')['label'].mean()\n    t_df = t_df.dropna(how='all')\n    group_scatter_figure = ScatterGraph(t_df.cumsum(), layout=dict(title='Cumulative Return', xaxis=dict(tickangle=45, rangebreaks=kwargs.get('rangebreaks', guess_plotly_rangebreaks(t_df.index))))).figure\n    t_df = t_df.loc[:, ['long-short', 'long-average']]\n    _bin_size = float(((t_df.max() - t_df.min()) / 20).min())\n    group_hist_figure = SubplotsGraph(t_df, kind_map=dict(kind='DistplotGraph', kwargs=dict(bin_size=_bin_size)), subplots_kwargs=dict(rows=1, cols=2, print_grid=False, subplot_titles=['long-short', 'long-average'])).figure\n    return (group_scatter_figure, group_hist_figure)",
            "def _group_return(pred_label: pd.DataFrame=None, reverse: bool=False, N: int=5, **kwargs) -> tuple:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n\\n    :param pred_label:\\n    :param reverse:\\n    :param N:\\n    :return:\\n    '\n    if reverse:\n        pred_label['score'] *= -1\n    pred_label = pred_label.sort_values('score', ascending=False)\n    pred_label_drop = pred_label.dropna(subset=['score'])\n    t_df = pd.DataFrame({'Group%d' % (i + 1): pred_label_drop.groupby(level='datetime')['label'].apply(lambda x: x[len(x) // N * i:len(x) // N * (i + 1)].mean()) for i in range(N)})\n    t_df.index = pd.to_datetime(t_df.index)\n    t_df['long-short'] = t_df['Group1'] - t_df['Group%d' % N]\n    t_df['long-average'] = t_df['Group1'] - pred_label.groupby(level='datetime')['label'].mean()\n    t_df = t_df.dropna(how='all')\n    group_scatter_figure = ScatterGraph(t_df.cumsum(), layout=dict(title='Cumulative Return', xaxis=dict(tickangle=45, rangebreaks=kwargs.get('rangebreaks', guess_plotly_rangebreaks(t_df.index))))).figure\n    t_df = t_df.loc[:, ['long-short', 'long-average']]\n    _bin_size = float(((t_df.max() - t_df.min()) / 20).min())\n    group_hist_figure = SubplotsGraph(t_df, kind_map=dict(kind='DistplotGraph', kwargs=dict(bin_size=_bin_size)), subplots_kwargs=dict(rows=1, cols=2, print_grid=False, subplot_titles=['long-short', 'long-average'])).figure\n    return (group_scatter_figure, group_hist_figure)",
            "def _group_return(pred_label: pd.DataFrame=None, reverse: bool=False, N: int=5, **kwargs) -> tuple:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n\\n    :param pred_label:\\n    :param reverse:\\n    :param N:\\n    :return:\\n    '\n    if reverse:\n        pred_label['score'] *= -1\n    pred_label = pred_label.sort_values('score', ascending=False)\n    pred_label_drop = pred_label.dropna(subset=['score'])\n    t_df = pd.DataFrame({'Group%d' % (i + 1): pred_label_drop.groupby(level='datetime')['label'].apply(lambda x: x[len(x) // N * i:len(x) // N * (i + 1)].mean()) for i in range(N)})\n    t_df.index = pd.to_datetime(t_df.index)\n    t_df['long-short'] = t_df['Group1'] - t_df['Group%d' % N]\n    t_df['long-average'] = t_df['Group1'] - pred_label.groupby(level='datetime')['label'].mean()\n    t_df = t_df.dropna(how='all')\n    group_scatter_figure = ScatterGraph(t_df.cumsum(), layout=dict(title='Cumulative Return', xaxis=dict(tickangle=45, rangebreaks=kwargs.get('rangebreaks', guess_plotly_rangebreaks(t_df.index))))).figure\n    t_df = t_df.loc[:, ['long-short', 'long-average']]\n    _bin_size = float(((t_df.max() - t_df.min()) / 20).min())\n    group_hist_figure = SubplotsGraph(t_df, kind_map=dict(kind='DistplotGraph', kwargs=dict(bin_size=_bin_size)), subplots_kwargs=dict(rows=1, cols=2, print_grid=False, subplot_titles=['long-short', 'long-average'])).figure\n    return (group_scatter_figure, group_hist_figure)",
            "def _group_return(pred_label: pd.DataFrame=None, reverse: bool=False, N: int=5, **kwargs) -> tuple:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n\\n    :param pred_label:\\n    :param reverse:\\n    :param N:\\n    :return:\\n    '\n    if reverse:\n        pred_label['score'] *= -1\n    pred_label = pred_label.sort_values('score', ascending=False)\n    pred_label_drop = pred_label.dropna(subset=['score'])\n    t_df = pd.DataFrame({'Group%d' % (i + 1): pred_label_drop.groupby(level='datetime')['label'].apply(lambda x: x[len(x) // N * i:len(x) // N * (i + 1)].mean()) for i in range(N)})\n    t_df.index = pd.to_datetime(t_df.index)\n    t_df['long-short'] = t_df['Group1'] - t_df['Group%d' % N]\n    t_df['long-average'] = t_df['Group1'] - pred_label.groupby(level='datetime')['label'].mean()\n    t_df = t_df.dropna(how='all')\n    group_scatter_figure = ScatterGraph(t_df.cumsum(), layout=dict(title='Cumulative Return', xaxis=dict(tickangle=45, rangebreaks=kwargs.get('rangebreaks', guess_plotly_rangebreaks(t_df.index))))).figure\n    t_df = t_df.loc[:, ['long-short', 'long-average']]\n    _bin_size = float(((t_df.max() - t_df.min()) / 20).min())\n    group_hist_figure = SubplotsGraph(t_df, kind_map=dict(kind='DistplotGraph', kwargs=dict(bin_size=_bin_size)), subplots_kwargs=dict(rows=1, cols=2, print_grid=False, subplot_titles=['long-short', 'long-average'])).figure\n    return (group_scatter_figure, group_hist_figure)",
            "def _group_return(pred_label: pd.DataFrame=None, reverse: bool=False, N: int=5, **kwargs) -> tuple:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n\\n    :param pred_label:\\n    :param reverse:\\n    :param N:\\n    :return:\\n    '\n    if reverse:\n        pred_label['score'] *= -1\n    pred_label = pred_label.sort_values('score', ascending=False)\n    pred_label_drop = pred_label.dropna(subset=['score'])\n    t_df = pd.DataFrame({'Group%d' % (i + 1): pred_label_drop.groupby(level='datetime')['label'].apply(lambda x: x[len(x) // N * i:len(x) // N * (i + 1)].mean()) for i in range(N)})\n    t_df.index = pd.to_datetime(t_df.index)\n    t_df['long-short'] = t_df['Group1'] - t_df['Group%d' % N]\n    t_df['long-average'] = t_df['Group1'] - pred_label.groupby(level='datetime')['label'].mean()\n    t_df = t_df.dropna(how='all')\n    group_scatter_figure = ScatterGraph(t_df.cumsum(), layout=dict(title='Cumulative Return', xaxis=dict(tickangle=45, rangebreaks=kwargs.get('rangebreaks', guess_plotly_rangebreaks(t_df.index))))).figure\n    t_df = t_df.loc[:, ['long-short', 'long-average']]\n    _bin_size = float(((t_df.max() - t_df.min()) / 20).min())\n    group_hist_figure = SubplotsGraph(t_df, kind_map=dict(kind='DistplotGraph', kwargs=dict(bin_size=_bin_size)), subplots_kwargs=dict(rows=1, cols=2, print_grid=False, subplot_titles=['long-short', 'long-average'])).figure\n    return (group_scatter_figure, group_hist_figure)"
        ]
    },
    {
        "func_name": "_plot_qq",
        "original": "def _plot_qq(data: pd.Series=None, dist=stats.norm) -> go.Figure:\n    \"\"\"\n\n    :param data:\n    :param dist:\n    :return:\n    \"\"\"\n    _plt_fig = sm.qqplot(data.dropna(), dist=dist, fit=True, line='45')\n    plt.close(_plt_fig)\n    qqplot_data = _plt_fig.gca().lines\n    fig = go.Figure()\n    fig.add_trace({'type': 'scatter', 'x': qqplot_data[0].get_xdata(), 'y': qqplot_data[0].get_ydata(), 'mode': 'markers', 'marker': {'color': '#19d3f3'}})\n    fig.add_trace({'type': 'scatter', 'x': qqplot_data[1].get_xdata(), 'y': qqplot_data[1].get_ydata(), 'mode': 'lines', 'line': {'color': '#636efa'}})\n    del qqplot_data\n    return fig",
        "mutated": [
            "def _plot_qq(data: pd.Series=None, dist=stats.norm) -> go.Figure:\n    if False:\n        i = 10\n    '\\n\\n    :param data:\\n    :param dist:\\n    :return:\\n    '\n    _plt_fig = sm.qqplot(data.dropna(), dist=dist, fit=True, line='45')\n    plt.close(_plt_fig)\n    qqplot_data = _plt_fig.gca().lines\n    fig = go.Figure()\n    fig.add_trace({'type': 'scatter', 'x': qqplot_data[0].get_xdata(), 'y': qqplot_data[0].get_ydata(), 'mode': 'markers', 'marker': {'color': '#19d3f3'}})\n    fig.add_trace({'type': 'scatter', 'x': qqplot_data[1].get_xdata(), 'y': qqplot_data[1].get_ydata(), 'mode': 'lines', 'line': {'color': '#636efa'}})\n    del qqplot_data\n    return fig",
            "def _plot_qq(data: pd.Series=None, dist=stats.norm) -> go.Figure:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n\\n    :param data:\\n    :param dist:\\n    :return:\\n    '\n    _plt_fig = sm.qqplot(data.dropna(), dist=dist, fit=True, line='45')\n    plt.close(_plt_fig)\n    qqplot_data = _plt_fig.gca().lines\n    fig = go.Figure()\n    fig.add_trace({'type': 'scatter', 'x': qqplot_data[0].get_xdata(), 'y': qqplot_data[0].get_ydata(), 'mode': 'markers', 'marker': {'color': '#19d3f3'}})\n    fig.add_trace({'type': 'scatter', 'x': qqplot_data[1].get_xdata(), 'y': qqplot_data[1].get_ydata(), 'mode': 'lines', 'line': {'color': '#636efa'}})\n    del qqplot_data\n    return fig",
            "def _plot_qq(data: pd.Series=None, dist=stats.norm) -> go.Figure:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n\\n    :param data:\\n    :param dist:\\n    :return:\\n    '\n    _plt_fig = sm.qqplot(data.dropna(), dist=dist, fit=True, line='45')\n    plt.close(_plt_fig)\n    qqplot_data = _plt_fig.gca().lines\n    fig = go.Figure()\n    fig.add_trace({'type': 'scatter', 'x': qqplot_data[0].get_xdata(), 'y': qqplot_data[0].get_ydata(), 'mode': 'markers', 'marker': {'color': '#19d3f3'}})\n    fig.add_trace({'type': 'scatter', 'x': qqplot_data[1].get_xdata(), 'y': qqplot_data[1].get_ydata(), 'mode': 'lines', 'line': {'color': '#636efa'}})\n    del qqplot_data\n    return fig",
            "def _plot_qq(data: pd.Series=None, dist=stats.norm) -> go.Figure:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n\\n    :param data:\\n    :param dist:\\n    :return:\\n    '\n    _plt_fig = sm.qqplot(data.dropna(), dist=dist, fit=True, line='45')\n    plt.close(_plt_fig)\n    qqplot_data = _plt_fig.gca().lines\n    fig = go.Figure()\n    fig.add_trace({'type': 'scatter', 'x': qqplot_data[0].get_xdata(), 'y': qqplot_data[0].get_ydata(), 'mode': 'markers', 'marker': {'color': '#19d3f3'}})\n    fig.add_trace({'type': 'scatter', 'x': qqplot_data[1].get_xdata(), 'y': qqplot_data[1].get_ydata(), 'mode': 'lines', 'line': {'color': '#636efa'}})\n    del qqplot_data\n    return fig",
            "def _plot_qq(data: pd.Series=None, dist=stats.norm) -> go.Figure:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n\\n    :param data:\\n    :param dist:\\n    :return:\\n    '\n    _plt_fig = sm.qqplot(data.dropna(), dist=dist, fit=True, line='45')\n    plt.close(_plt_fig)\n    qqplot_data = _plt_fig.gca().lines\n    fig = go.Figure()\n    fig.add_trace({'type': 'scatter', 'x': qqplot_data[0].get_xdata(), 'y': qqplot_data[0].get_ydata(), 'mode': 'markers', 'marker': {'color': '#19d3f3'}})\n    fig.add_trace({'type': 'scatter', 'x': qqplot_data[1].get_xdata(), 'y': qqplot_data[1].get_ydata(), 'mode': 'lines', 'line': {'color': '#636efa'}})\n    del qqplot_data\n    return fig"
        ]
    },
    {
        "func_name": "_corr_series",
        "original": "def _corr_series(x, method):\n    return x['label'].corr(x['score'], method=method)",
        "mutated": [
            "def _corr_series(x, method):\n    if False:\n        i = 10\n    return x['label'].corr(x['score'], method=method)",
            "def _corr_series(x, method):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return x['label'].corr(x['score'], method=method)",
            "def _corr_series(x, method):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return x['label'].corr(x['score'], method=method)",
            "def _corr_series(x, method):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return x['label'].corr(x['score'], method=method)",
            "def _corr_series(x, method):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return x['label'].corr(x['score'], method=method)"
        ]
    },
    {
        "func_name": "_pred_ic",
        "original": "def _pred_ic(pred_label: pd.DataFrame=None, methods: Sequence[Literal['IC', 'Rank IC']]=('IC', 'Rank IC'), **kwargs) -> tuple:\n    \"\"\"\n\n    :param pred_label: pd.DataFrame\n    must contain one column of realized return with name `label` and one column of predicted score names `score`.\n    :param methods: Sequence[Literal[\"IC\", \"Rank IC\"]]\n    IC series to plot.\n    IC is sectional pearson correlation between label and score\n    Rank IC is the spearman correlation between label and score\n    For the Monthly IC, IC histogram, IC Q-Q plot.  Only the first type of IC will be plotted.\n    :return:\n    \"\"\"\n    _methods_mapping = {'IC': 'pearson', 'Rank IC': 'spearman'}\n\n    def _corr_series(x, method):\n        return x['label'].corr(x['score'], method=method)\n    ic_df = pd.concat([pred_label.groupby(level='datetime').apply(partial(_corr_series, method=_methods_mapping[m])).rename(m) for m in methods], axis=1)\n    _ic = ic_df.iloc(axis=1)[0]\n    _index = _ic.index.get_level_values(0).astype('str').str.replace('-', '').str.slice(0, 6)\n    _monthly_ic = _ic.groupby(_index).mean()\n    _monthly_ic.index = pd.MultiIndex.from_arrays([_monthly_ic.index.str.slice(0, 4), _monthly_ic.index.str.slice(4, 6)], names=['year', 'month'])\n    _month_list = pd.date_range(start=pd.Timestamp(f'{_index.min()[:4]}0101'), end=pd.Timestamp(f'{_index.max()[:4]}1231'), freq='1M')\n    _years = []\n    _month = []\n    for _date in _month_list:\n        _date = _date.strftime('%Y%m%d')\n        _years.append(_date[:4])\n        _month.append(_date[4:6])\n    fill_index = pd.MultiIndex.from_arrays([_years, _month], names=['year', 'month'])\n    _monthly_ic = _monthly_ic.reindex(fill_index)\n    ic_bar_figure = ic_figure(ic_df, kwargs.get('show_nature_day', False))\n    ic_heatmap_figure = HeatmapGraph(_monthly_ic.unstack(), layout=dict(title='Monthly IC', xaxis=dict(dtick=1), yaxis=dict(tickformat='04d', dtick=1)), graph_kwargs=dict(xtype='array', ytype='array')).figure\n    dist = stats.norm\n    _qqplot_fig = _plot_qq(_ic, dist)\n    if isinstance(dist, stats.norm.__class__):\n        dist_name = 'Normal'\n    else:\n        dist_name = 'Unknown'\n    _ic_df = _ic.to_frame('IC')\n    _bin_size = ((_ic_df.max() - _ic_df.min()) / 20).min()\n    _sub_graph_data = [('IC', dict(row=1, col=1, name='', kind='DistplotGraph', graph_kwargs=dict(bin_size=_bin_size))), (_qqplot_fig, dict(row=1, col=2))]\n    ic_hist_figure = SubplotsGraph(_ic_df.dropna(), kind_map=dict(kind='HistogramGraph', kwargs=dict()), subplots_kwargs=dict(rows=1, cols=2, print_grid=False, subplot_titles=['IC', 'IC %s Dist. Q-Q' % dist_name]), sub_graph_data=_sub_graph_data, layout=dict(yaxis2=dict(title='Observed Quantile'), xaxis2=dict(title=f'{dist_name} Distribution Quantile'))).figure\n    return (ic_bar_figure, ic_heatmap_figure, ic_hist_figure)",
        "mutated": [
            "def _pred_ic(pred_label: pd.DataFrame=None, methods: Sequence[Literal['IC', 'Rank IC']]=('IC', 'Rank IC'), **kwargs) -> tuple:\n    if False:\n        i = 10\n    '\\n\\n    :param pred_label: pd.DataFrame\\n    must contain one column of realized return with name `label` and one column of predicted score names `score`.\\n    :param methods: Sequence[Literal[\"IC\", \"Rank IC\"]]\\n    IC series to plot.\\n    IC is sectional pearson correlation between label and score\\n    Rank IC is the spearman correlation between label and score\\n    For the Monthly IC, IC histogram, IC Q-Q plot.  Only the first type of IC will be plotted.\\n    :return:\\n    '\n    _methods_mapping = {'IC': 'pearson', 'Rank IC': 'spearman'}\n\n    def _corr_series(x, method):\n        return x['label'].corr(x['score'], method=method)\n    ic_df = pd.concat([pred_label.groupby(level='datetime').apply(partial(_corr_series, method=_methods_mapping[m])).rename(m) for m in methods], axis=1)\n    _ic = ic_df.iloc(axis=1)[0]\n    _index = _ic.index.get_level_values(0).astype('str').str.replace('-', '').str.slice(0, 6)\n    _monthly_ic = _ic.groupby(_index).mean()\n    _monthly_ic.index = pd.MultiIndex.from_arrays([_monthly_ic.index.str.slice(0, 4), _monthly_ic.index.str.slice(4, 6)], names=['year', 'month'])\n    _month_list = pd.date_range(start=pd.Timestamp(f'{_index.min()[:4]}0101'), end=pd.Timestamp(f'{_index.max()[:4]}1231'), freq='1M')\n    _years = []\n    _month = []\n    for _date in _month_list:\n        _date = _date.strftime('%Y%m%d')\n        _years.append(_date[:4])\n        _month.append(_date[4:6])\n    fill_index = pd.MultiIndex.from_arrays([_years, _month], names=['year', 'month'])\n    _monthly_ic = _monthly_ic.reindex(fill_index)\n    ic_bar_figure = ic_figure(ic_df, kwargs.get('show_nature_day', False))\n    ic_heatmap_figure = HeatmapGraph(_monthly_ic.unstack(), layout=dict(title='Monthly IC', xaxis=dict(dtick=1), yaxis=dict(tickformat='04d', dtick=1)), graph_kwargs=dict(xtype='array', ytype='array')).figure\n    dist = stats.norm\n    _qqplot_fig = _plot_qq(_ic, dist)\n    if isinstance(dist, stats.norm.__class__):\n        dist_name = 'Normal'\n    else:\n        dist_name = 'Unknown'\n    _ic_df = _ic.to_frame('IC')\n    _bin_size = ((_ic_df.max() - _ic_df.min()) / 20).min()\n    _sub_graph_data = [('IC', dict(row=1, col=1, name='', kind='DistplotGraph', graph_kwargs=dict(bin_size=_bin_size))), (_qqplot_fig, dict(row=1, col=2))]\n    ic_hist_figure = SubplotsGraph(_ic_df.dropna(), kind_map=dict(kind='HistogramGraph', kwargs=dict()), subplots_kwargs=dict(rows=1, cols=2, print_grid=False, subplot_titles=['IC', 'IC %s Dist. Q-Q' % dist_name]), sub_graph_data=_sub_graph_data, layout=dict(yaxis2=dict(title='Observed Quantile'), xaxis2=dict(title=f'{dist_name} Distribution Quantile'))).figure\n    return (ic_bar_figure, ic_heatmap_figure, ic_hist_figure)",
            "def _pred_ic(pred_label: pd.DataFrame=None, methods: Sequence[Literal['IC', 'Rank IC']]=('IC', 'Rank IC'), **kwargs) -> tuple:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n\\n    :param pred_label: pd.DataFrame\\n    must contain one column of realized return with name `label` and one column of predicted score names `score`.\\n    :param methods: Sequence[Literal[\"IC\", \"Rank IC\"]]\\n    IC series to plot.\\n    IC is sectional pearson correlation between label and score\\n    Rank IC is the spearman correlation between label and score\\n    For the Monthly IC, IC histogram, IC Q-Q plot.  Only the first type of IC will be plotted.\\n    :return:\\n    '\n    _methods_mapping = {'IC': 'pearson', 'Rank IC': 'spearman'}\n\n    def _corr_series(x, method):\n        return x['label'].corr(x['score'], method=method)\n    ic_df = pd.concat([pred_label.groupby(level='datetime').apply(partial(_corr_series, method=_methods_mapping[m])).rename(m) for m in methods], axis=1)\n    _ic = ic_df.iloc(axis=1)[0]\n    _index = _ic.index.get_level_values(0).astype('str').str.replace('-', '').str.slice(0, 6)\n    _monthly_ic = _ic.groupby(_index).mean()\n    _monthly_ic.index = pd.MultiIndex.from_arrays([_monthly_ic.index.str.slice(0, 4), _monthly_ic.index.str.slice(4, 6)], names=['year', 'month'])\n    _month_list = pd.date_range(start=pd.Timestamp(f'{_index.min()[:4]}0101'), end=pd.Timestamp(f'{_index.max()[:4]}1231'), freq='1M')\n    _years = []\n    _month = []\n    for _date in _month_list:\n        _date = _date.strftime('%Y%m%d')\n        _years.append(_date[:4])\n        _month.append(_date[4:6])\n    fill_index = pd.MultiIndex.from_arrays([_years, _month], names=['year', 'month'])\n    _monthly_ic = _monthly_ic.reindex(fill_index)\n    ic_bar_figure = ic_figure(ic_df, kwargs.get('show_nature_day', False))\n    ic_heatmap_figure = HeatmapGraph(_monthly_ic.unstack(), layout=dict(title='Monthly IC', xaxis=dict(dtick=1), yaxis=dict(tickformat='04d', dtick=1)), graph_kwargs=dict(xtype='array', ytype='array')).figure\n    dist = stats.norm\n    _qqplot_fig = _plot_qq(_ic, dist)\n    if isinstance(dist, stats.norm.__class__):\n        dist_name = 'Normal'\n    else:\n        dist_name = 'Unknown'\n    _ic_df = _ic.to_frame('IC')\n    _bin_size = ((_ic_df.max() - _ic_df.min()) / 20).min()\n    _sub_graph_data = [('IC', dict(row=1, col=1, name='', kind='DistplotGraph', graph_kwargs=dict(bin_size=_bin_size))), (_qqplot_fig, dict(row=1, col=2))]\n    ic_hist_figure = SubplotsGraph(_ic_df.dropna(), kind_map=dict(kind='HistogramGraph', kwargs=dict()), subplots_kwargs=dict(rows=1, cols=2, print_grid=False, subplot_titles=['IC', 'IC %s Dist. Q-Q' % dist_name]), sub_graph_data=_sub_graph_data, layout=dict(yaxis2=dict(title='Observed Quantile'), xaxis2=dict(title=f'{dist_name} Distribution Quantile'))).figure\n    return (ic_bar_figure, ic_heatmap_figure, ic_hist_figure)",
            "def _pred_ic(pred_label: pd.DataFrame=None, methods: Sequence[Literal['IC', 'Rank IC']]=('IC', 'Rank IC'), **kwargs) -> tuple:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n\\n    :param pred_label: pd.DataFrame\\n    must contain one column of realized return with name `label` and one column of predicted score names `score`.\\n    :param methods: Sequence[Literal[\"IC\", \"Rank IC\"]]\\n    IC series to plot.\\n    IC is sectional pearson correlation between label and score\\n    Rank IC is the spearman correlation between label and score\\n    For the Monthly IC, IC histogram, IC Q-Q plot.  Only the first type of IC will be plotted.\\n    :return:\\n    '\n    _methods_mapping = {'IC': 'pearson', 'Rank IC': 'spearman'}\n\n    def _corr_series(x, method):\n        return x['label'].corr(x['score'], method=method)\n    ic_df = pd.concat([pred_label.groupby(level='datetime').apply(partial(_corr_series, method=_methods_mapping[m])).rename(m) for m in methods], axis=1)\n    _ic = ic_df.iloc(axis=1)[0]\n    _index = _ic.index.get_level_values(0).astype('str').str.replace('-', '').str.slice(0, 6)\n    _monthly_ic = _ic.groupby(_index).mean()\n    _monthly_ic.index = pd.MultiIndex.from_arrays([_monthly_ic.index.str.slice(0, 4), _monthly_ic.index.str.slice(4, 6)], names=['year', 'month'])\n    _month_list = pd.date_range(start=pd.Timestamp(f'{_index.min()[:4]}0101'), end=pd.Timestamp(f'{_index.max()[:4]}1231'), freq='1M')\n    _years = []\n    _month = []\n    for _date in _month_list:\n        _date = _date.strftime('%Y%m%d')\n        _years.append(_date[:4])\n        _month.append(_date[4:6])\n    fill_index = pd.MultiIndex.from_arrays([_years, _month], names=['year', 'month'])\n    _monthly_ic = _monthly_ic.reindex(fill_index)\n    ic_bar_figure = ic_figure(ic_df, kwargs.get('show_nature_day', False))\n    ic_heatmap_figure = HeatmapGraph(_monthly_ic.unstack(), layout=dict(title='Monthly IC', xaxis=dict(dtick=1), yaxis=dict(tickformat='04d', dtick=1)), graph_kwargs=dict(xtype='array', ytype='array')).figure\n    dist = stats.norm\n    _qqplot_fig = _plot_qq(_ic, dist)\n    if isinstance(dist, stats.norm.__class__):\n        dist_name = 'Normal'\n    else:\n        dist_name = 'Unknown'\n    _ic_df = _ic.to_frame('IC')\n    _bin_size = ((_ic_df.max() - _ic_df.min()) / 20).min()\n    _sub_graph_data = [('IC', dict(row=1, col=1, name='', kind='DistplotGraph', graph_kwargs=dict(bin_size=_bin_size))), (_qqplot_fig, dict(row=1, col=2))]\n    ic_hist_figure = SubplotsGraph(_ic_df.dropna(), kind_map=dict(kind='HistogramGraph', kwargs=dict()), subplots_kwargs=dict(rows=1, cols=2, print_grid=False, subplot_titles=['IC', 'IC %s Dist. Q-Q' % dist_name]), sub_graph_data=_sub_graph_data, layout=dict(yaxis2=dict(title='Observed Quantile'), xaxis2=dict(title=f'{dist_name} Distribution Quantile'))).figure\n    return (ic_bar_figure, ic_heatmap_figure, ic_hist_figure)",
            "def _pred_ic(pred_label: pd.DataFrame=None, methods: Sequence[Literal['IC', 'Rank IC']]=('IC', 'Rank IC'), **kwargs) -> tuple:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n\\n    :param pred_label: pd.DataFrame\\n    must contain one column of realized return with name `label` and one column of predicted score names `score`.\\n    :param methods: Sequence[Literal[\"IC\", \"Rank IC\"]]\\n    IC series to plot.\\n    IC is sectional pearson correlation between label and score\\n    Rank IC is the spearman correlation between label and score\\n    For the Monthly IC, IC histogram, IC Q-Q plot.  Only the first type of IC will be plotted.\\n    :return:\\n    '\n    _methods_mapping = {'IC': 'pearson', 'Rank IC': 'spearman'}\n\n    def _corr_series(x, method):\n        return x['label'].corr(x['score'], method=method)\n    ic_df = pd.concat([pred_label.groupby(level='datetime').apply(partial(_corr_series, method=_methods_mapping[m])).rename(m) for m in methods], axis=1)\n    _ic = ic_df.iloc(axis=1)[0]\n    _index = _ic.index.get_level_values(0).astype('str').str.replace('-', '').str.slice(0, 6)\n    _monthly_ic = _ic.groupby(_index).mean()\n    _monthly_ic.index = pd.MultiIndex.from_arrays([_monthly_ic.index.str.slice(0, 4), _monthly_ic.index.str.slice(4, 6)], names=['year', 'month'])\n    _month_list = pd.date_range(start=pd.Timestamp(f'{_index.min()[:4]}0101'), end=pd.Timestamp(f'{_index.max()[:4]}1231'), freq='1M')\n    _years = []\n    _month = []\n    for _date in _month_list:\n        _date = _date.strftime('%Y%m%d')\n        _years.append(_date[:4])\n        _month.append(_date[4:6])\n    fill_index = pd.MultiIndex.from_arrays([_years, _month], names=['year', 'month'])\n    _monthly_ic = _monthly_ic.reindex(fill_index)\n    ic_bar_figure = ic_figure(ic_df, kwargs.get('show_nature_day', False))\n    ic_heatmap_figure = HeatmapGraph(_monthly_ic.unstack(), layout=dict(title='Monthly IC', xaxis=dict(dtick=1), yaxis=dict(tickformat='04d', dtick=1)), graph_kwargs=dict(xtype='array', ytype='array')).figure\n    dist = stats.norm\n    _qqplot_fig = _plot_qq(_ic, dist)\n    if isinstance(dist, stats.norm.__class__):\n        dist_name = 'Normal'\n    else:\n        dist_name = 'Unknown'\n    _ic_df = _ic.to_frame('IC')\n    _bin_size = ((_ic_df.max() - _ic_df.min()) / 20).min()\n    _sub_graph_data = [('IC', dict(row=1, col=1, name='', kind='DistplotGraph', graph_kwargs=dict(bin_size=_bin_size))), (_qqplot_fig, dict(row=1, col=2))]\n    ic_hist_figure = SubplotsGraph(_ic_df.dropna(), kind_map=dict(kind='HistogramGraph', kwargs=dict()), subplots_kwargs=dict(rows=1, cols=2, print_grid=False, subplot_titles=['IC', 'IC %s Dist. Q-Q' % dist_name]), sub_graph_data=_sub_graph_data, layout=dict(yaxis2=dict(title='Observed Quantile'), xaxis2=dict(title=f'{dist_name} Distribution Quantile'))).figure\n    return (ic_bar_figure, ic_heatmap_figure, ic_hist_figure)",
            "def _pred_ic(pred_label: pd.DataFrame=None, methods: Sequence[Literal['IC', 'Rank IC']]=('IC', 'Rank IC'), **kwargs) -> tuple:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n\\n    :param pred_label: pd.DataFrame\\n    must contain one column of realized return with name `label` and one column of predicted score names `score`.\\n    :param methods: Sequence[Literal[\"IC\", \"Rank IC\"]]\\n    IC series to plot.\\n    IC is sectional pearson correlation between label and score\\n    Rank IC is the spearman correlation between label and score\\n    For the Monthly IC, IC histogram, IC Q-Q plot.  Only the first type of IC will be plotted.\\n    :return:\\n    '\n    _methods_mapping = {'IC': 'pearson', 'Rank IC': 'spearman'}\n\n    def _corr_series(x, method):\n        return x['label'].corr(x['score'], method=method)\n    ic_df = pd.concat([pred_label.groupby(level='datetime').apply(partial(_corr_series, method=_methods_mapping[m])).rename(m) for m in methods], axis=1)\n    _ic = ic_df.iloc(axis=1)[0]\n    _index = _ic.index.get_level_values(0).astype('str').str.replace('-', '').str.slice(0, 6)\n    _monthly_ic = _ic.groupby(_index).mean()\n    _monthly_ic.index = pd.MultiIndex.from_arrays([_monthly_ic.index.str.slice(0, 4), _monthly_ic.index.str.slice(4, 6)], names=['year', 'month'])\n    _month_list = pd.date_range(start=pd.Timestamp(f'{_index.min()[:4]}0101'), end=pd.Timestamp(f'{_index.max()[:4]}1231'), freq='1M')\n    _years = []\n    _month = []\n    for _date in _month_list:\n        _date = _date.strftime('%Y%m%d')\n        _years.append(_date[:4])\n        _month.append(_date[4:6])\n    fill_index = pd.MultiIndex.from_arrays([_years, _month], names=['year', 'month'])\n    _monthly_ic = _monthly_ic.reindex(fill_index)\n    ic_bar_figure = ic_figure(ic_df, kwargs.get('show_nature_day', False))\n    ic_heatmap_figure = HeatmapGraph(_monthly_ic.unstack(), layout=dict(title='Monthly IC', xaxis=dict(dtick=1), yaxis=dict(tickformat='04d', dtick=1)), graph_kwargs=dict(xtype='array', ytype='array')).figure\n    dist = stats.norm\n    _qqplot_fig = _plot_qq(_ic, dist)\n    if isinstance(dist, stats.norm.__class__):\n        dist_name = 'Normal'\n    else:\n        dist_name = 'Unknown'\n    _ic_df = _ic.to_frame('IC')\n    _bin_size = ((_ic_df.max() - _ic_df.min()) / 20).min()\n    _sub_graph_data = [('IC', dict(row=1, col=1, name='', kind='DistplotGraph', graph_kwargs=dict(bin_size=_bin_size))), (_qqplot_fig, dict(row=1, col=2))]\n    ic_hist_figure = SubplotsGraph(_ic_df.dropna(), kind_map=dict(kind='HistogramGraph', kwargs=dict()), subplots_kwargs=dict(rows=1, cols=2, print_grid=False, subplot_titles=['IC', 'IC %s Dist. Q-Q' % dist_name]), sub_graph_data=_sub_graph_data, layout=dict(yaxis2=dict(title='Observed Quantile'), xaxis2=dict(title=f'{dist_name} Distribution Quantile'))).figure\n    return (ic_bar_figure, ic_heatmap_figure, ic_hist_figure)"
        ]
    },
    {
        "func_name": "_pred_autocorr",
        "original": "def _pred_autocorr(pred_label: pd.DataFrame, lag=1, **kwargs) -> tuple:\n    pred = pred_label.copy()\n    pred['score_last'] = pred.groupby(level='instrument')['score'].shift(lag)\n    ac = pred.groupby(level='datetime').apply(lambda x: x['score'].rank(pct=True).corr(x['score_last'].rank(pct=True)))\n    _df = ac.to_frame('value')\n    ac_figure = ScatterGraph(_df, layout=dict(title='Auto Correlation', xaxis=dict(tickangle=45, rangebreaks=kwargs.get('rangebreaks', guess_plotly_rangebreaks(_df.index))))).figure\n    return (ac_figure,)",
        "mutated": [
            "def _pred_autocorr(pred_label: pd.DataFrame, lag=1, **kwargs) -> tuple:\n    if False:\n        i = 10\n    pred = pred_label.copy()\n    pred['score_last'] = pred.groupby(level='instrument')['score'].shift(lag)\n    ac = pred.groupby(level='datetime').apply(lambda x: x['score'].rank(pct=True).corr(x['score_last'].rank(pct=True)))\n    _df = ac.to_frame('value')\n    ac_figure = ScatterGraph(_df, layout=dict(title='Auto Correlation', xaxis=dict(tickangle=45, rangebreaks=kwargs.get('rangebreaks', guess_plotly_rangebreaks(_df.index))))).figure\n    return (ac_figure,)",
            "def _pred_autocorr(pred_label: pd.DataFrame, lag=1, **kwargs) -> tuple:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pred = pred_label.copy()\n    pred['score_last'] = pred.groupby(level='instrument')['score'].shift(lag)\n    ac = pred.groupby(level='datetime').apply(lambda x: x['score'].rank(pct=True).corr(x['score_last'].rank(pct=True)))\n    _df = ac.to_frame('value')\n    ac_figure = ScatterGraph(_df, layout=dict(title='Auto Correlation', xaxis=dict(tickangle=45, rangebreaks=kwargs.get('rangebreaks', guess_plotly_rangebreaks(_df.index))))).figure\n    return (ac_figure,)",
            "def _pred_autocorr(pred_label: pd.DataFrame, lag=1, **kwargs) -> tuple:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pred = pred_label.copy()\n    pred['score_last'] = pred.groupby(level='instrument')['score'].shift(lag)\n    ac = pred.groupby(level='datetime').apply(lambda x: x['score'].rank(pct=True).corr(x['score_last'].rank(pct=True)))\n    _df = ac.to_frame('value')\n    ac_figure = ScatterGraph(_df, layout=dict(title='Auto Correlation', xaxis=dict(tickangle=45, rangebreaks=kwargs.get('rangebreaks', guess_plotly_rangebreaks(_df.index))))).figure\n    return (ac_figure,)",
            "def _pred_autocorr(pred_label: pd.DataFrame, lag=1, **kwargs) -> tuple:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pred = pred_label.copy()\n    pred['score_last'] = pred.groupby(level='instrument')['score'].shift(lag)\n    ac = pred.groupby(level='datetime').apply(lambda x: x['score'].rank(pct=True).corr(x['score_last'].rank(pct=True)))\n    _df = ac.to_frame('value')\n    ac_figure = ScatterGraph(_df, layout=dict(title='Auto Correlation', xaxis=dict(tickangle=45, rangebreaks=kwargs.get('rangebreaks', guess_plotly_rangebreaks(_df.index))))).figure\n    return (ac_figure,)",
            "def _pred_autocorr(pred_label: pd.DataFrame, lag=1, **kwargs) -> tuple:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pred = pred_label.copy()\n    pred['score_last'] = pred.groupby(level='instrument')['score'].shift(lag)\n    ac = pred.groupby(level='datetime').apply(lambda x: x['score'].rank(pct=True).corr(x['score_last'].rank(pct=True)))\n    _df = ac.to_frame('value')\n    ac_figure = ScatterGraph(_df, layout=dict(title='Auto Correlation', xaxis=dict(tickangle=45, rangebreaks=kwargs.get('rangebreaks', guess_plotly_rangebreaks(_df.index))))).figure\n    return (ac_figure,)"
        ]
    },
    {
        "func_name": "_pred_turnover",
        "original": "def _pred_turnover(pred_label: pd.DataFrame, N=5, lag=1, **kwargs) -> tuple:\n    pred = pred_label.copy()\n    pred['score_last'] = pred.groupby(level='instrument')['score'].shift(lag)\n    top = pred.groupby(level='datetime').apply(lambda x: 1 - x.nlargest(len(x) // N, columns='score').index.isin(x.nlargest(len(x) // N, columns='score_last').index).sum() / (len(x) // N))\n    bottom = pred.groupby(level='datetime').apply(lambda x: 1 - x.nsmallest(len(x) // N, columns='score').index.isin(x.nsmallest(len(x) // N, columns='score_last').index).sum() / (len(x) // N))\n    r_df = pd.DataFrame({'Top': top, 'Bottom': bottom})\n    turnover_figure = ScatterGraph(r_df, layout=dict(title='Top-Bottom Turnover', xaxis=dict(tickangle=45, rangebreaks=kwargs.get('rangebreaks', guess_plotly_rangebreaks(r_df.index))))).figure\n    return (turnover_figure,)",
        "mutated": [
            "def _pred_turnover(pred_label: pd.DataFrame, N=5, lag=1, **kwargs) -> tuple:\n    if False:\n        i = 10\n    pred = pred_label.copy()\n    pred['score_last'] = pred.groupby(level='instrument')['score'].shift(lag)\n    top = pred.groupby(level='datetime').apply(lambda x: 1 - x.nlargest(len(x) // N, columns='score').index.isin(x.nlargest(len(x) // N, columns='score_last').index).sum() / (len(x) // N))\n    bottom = pred.groupby(level='datetime').apply(lambda x: 1 - x.nsmallest(len(x) // N, columns='score').index.isin(x.nsmallest(len(x) // N, columns='score_last').index).sum() / (len(x) // N))\n    r_df = pd.DataFrame({'Top': top, 'Bottom': bottom})\n    turnover_figure = ScatterGraph(r_df, layout=dict(title='Top-Bottom Turnover', xaxis=dict(tickangle=45, rangebreaks=kwargs.get('rangebreaks', guess_plotly_rangebreaks(r_df.index))))).figure\n    return (turnover_figure,)",
            "def _pred_turnover(pred_label: pd.DataFrame, N=5, lag=1, **kwargs) -> tuple:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pred = pred_label.copy()\n    pred['score_last'] = pred.groupby(level='instrument')['score'].shift(lag)\n    top = pred.groupby(level='datetime').apply(lambda x: 1 - x.nlargest(len(x) // N, columns='score').index.isin(x.nlargest(len(x) // N, columns='score_last').index).sum() / (len(x) // N))\n    bottom = pred.groupby(level='datetime').apply(lambda x: 1 - x.nsmallest(len(x) // N, columns='score').index.isin(x.nsmallest(len(x) // N, columns='score_last').index).sum() / (len(x) // N))\n    r_df = pd.DataFrame({'Top': top, 'Bottom': bottom})\n    turnover_figure = ScatterGraph(r_df, layout=dict(title='Top-Bottom Turnover', xaxis=dict(tickangle=45, rangebreaks=kwargs.get('rangebreaks', guess_plotly_rangebreaks(r_df.index))))).figure\n    return (turnover_figure,)",
            "def _pred_turnover(pred_label: pd.DataFrame, N=5, lag=1, **kwargs) -> tuple:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pred = pred_label.copy()\n    pred['score_last'] = pred.groupby(level='instrument')['score'].shift(lag)\n    top = pred.groupby(level='datetime').apply(lambda x: 1 - x.nlargest(len(x) // N, columns='score').index.isin(x.nlargest(len(x) // N, columns='score_last').index).sum() / (len(x) // N))\n    bottom = pred.groupby(level='datetime').apply(lambda x: 1 - x.nsmallest(len(x) // N, columns='score').index.isin(x.nsmallest(len(x) // N, columns='score_last').index).sum() / (len(x) // N))\n    r_df = pd.DataFrame({'Top': top, 'Bottom': bottom})\n    turnover_figure = ScatterGraph(r_df, layout=dict(title='Top-Bottom Turnover', xaxis=dict(tickangle=45, rangebreaks=kwargs.get('rangebreaks', guess_plotly_rangebreaks(r_df.index))))).figure\n    return (turnover_figure,)",
            "def _pred_turnover(pred_label: pd.DataFrame, N=5, lag=1, **kwargs) -> tuple:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pred = pred_label.copy()\n    pred['score_last'] = pred.groupby(level='instrument')['score'].shift(lag)\n    top = pred.groupby(level='datetime').apply(lambda x: 1 - x.nlargest(len(x) // N, columns='score').index.isin(x.nlargest(len(x) // N, columns='score_last').index).sum() / (len(x) // N))\n    bottom = pred.groupby(level='datetime').apply(lambda x: 1 - x.nsmallest(len(x) // N, columns='score').index.isin(x.nsmallest(len(x) // N, columns='score_last').index).sum() / (len(x) // N))\n    r_df = pd.DataFrame({'Top': top, 'Bottom': bottom})\n    turnover_figure = ScatterGraph(r_df, layout=dict(title='Top-Bottom Turnover', xaxis=dict(tickangle=45, rangebreaks=kwargs.get('rangebreaks', guess_plotly_rangebreaks(r_df.index))))).figure\n    return (turnover_figure,)",
            "def _pred_turnover(pred_label: pd.DataFrame, N=5, lag=1, **kwargs) -> tuple:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pred = pred_label.copy()\n    pred['score_last'] = pred.groupby(level='instrument')['score'].shift(lag)\n    top = pred.groupby(level='datetime').apply(lambda x: 1 - x.nlargest(len(x) // N, columns='score').index.isin(x.nlargest(len(x) // N, columns='score_last').index).sum() / (len(x) // N))\n    bottom = pred.groupby(level='datetime').apply(lambda x: 1 - x.nsmallest(len(x) // N, columns='score').index.isin(x.nsmallest(len(x) // N, columns='score_last').index).sum() / (len(x) // N))\n    r_df = pd.DataFrame({'Top': top, 'Bottom': bottom})\n    turnover_figure = ScatterGraph(r_df, layout=dict(title='Top-Bottom Turnover', xaxis=dict(tickangle=45, rangebreaks=kwargs.get('rangebreaks', guess_plotly_rangebreaks(r_df.index))))).figure\n    return (turnover_figure,)"
        ]
    },
    {
        "func_name": "ic_figure",
        "original": "def ic_figure(ic_df: pd.DataFrame, show_nature_day=True, **kwargs) -> go.Figure:\n    \"\"\"IC figure\n\n    :param ic_df: ic DataFrame\n    :param show_nature_day: whether to display the abscissa of non-trading day\n    :param \\\\*\\\\*kwargs: contains some parameters to control plot style in plotly. Currently, supports\n       - `rangebreaks`: https://plotly.com/python/time-series/#Hiding-Weekends-and-Holidays\n    :return: plotly.graph_objs.Figure\n    \"\"\"\n    if show_nature_day:\n        date_index = pd.date_range(ic_df.index.min(), ic_df.index.max())\n        ic_df = ic_df.reindex(date_index)\n    ic_bar_figure = BarGraph(ic_df, layout=dict(title='Information Coefficient (IC)', xaxis=dict(tickangle=45, rangebreaks=kwargs.get('rangebreaks', guess_plotly_rangebreaks(ic_df.index))))).figure\n    return ic_bar_figure",
        "mutated": [
            "def ic_figure(ic_df: pd.DataFrame, show_nature_day=True, **kwargs) -> go.Figure:\n    if False:\n        i = 10\n    'IC figure\\n\\n    :param ic_df: ic DataFrame\\n    :param show_nature_day: whether to display the abscissa of non-trading day\\n    :param \\\\*\\\\*kwargs: contains some parameters to control plot style in plotly. Currently, supports\\n       - `rangebreaks`: https://plotly.com/python/time-series/#Hiding-Weekends-and-Holidays\\n    :return: plotly.graph_objs.Figure\\n    '\n    if show_nature_day:\n        date_index = pd.date_range(ic_df.index.min(), ic_df.index.max())\n        ic_df = ic_df.reindex(date_index)\n    ic_bar_figure = BarGraph(ic_df, layout=dict(title='Information Coefficient (IC)', xaxis=dict(tickangle=45, rangebreaks=kwargs.get('rangebreaks', guess_plotly_rangebreaks(ic_df.index))))).figure\n    return ic_bar_figure",
            "def ic_figure(ic_df: pd.DataFrame, show_nature_day=True, **kwargs) -> go.Figure:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'IC figure\\n\\n    :param ic_df: ic DataFrame\\n    :param show_nature_day: whether to display the abscissa of non-trading day\\n    :param \\\\*\\\\*kwargs: contains some parameters to control plot style in plotly. Currently, supports\\n       - `rangebreaks`: https://plotly.com/python/time-series/#Hiding-Weekends-and-Holidays\\n    :return: plotly.graph_objs.Figure\\n    '\n    if show_nature_day:\n        date_index = pd.date_range(ic_df.index.min(), ic_df.index.max())\n        ic_df = ic_df.reindex(date_index)\n    ic_bar_figure = BarGraph(ic_df, layout=dict(title='Information Coefficient (IC)', xaxis=dict(tickangle=45, rangebreaks=kwargs.get('rangebreaks', guess_plotly_rangebreaks(ic_df.index))))).figure\n    return ic_bar_figure",
            "def ic_figure(ic_df: pd.DataFrame, show_nature_day=True, **kwargs) -> go.Figure:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'IC figure\\n\\n    :param ic_df: ic DataFrame\\n    :param show_nature_day: whether to display the abscissa of non-trading day\\n    :param \\\\*\\\\*kwargs: contains some parameters to control plot style in plotly. Currently, supports\\n       - `rangebreaks`: https://plotly.com/python/time-series/#Hiding-Weekends-and-Holidays\\n    :return: plotly.graph_objs.Figure\\n    '\n    if show_nature_day:\n        date_index = pd.date_range(ic_df.index.min(), ic_df.index.max())\n        ic_df = ic_df.reindex(date_index)\n    ic_bar_figure = BarGraph(ic_df, layout=dict(title='Information Coefficient (IC)', xaxis=dict(tickangle=45, rangebreaks=kwargs.get('rangebreaks', guess_plotly_rangebreaks(ic_df.index))))).figure\n    return ic_bar_figure",
            "def ic_figure(ic_df: pd.DataFrame, show_nature_day=True, **kwargs) -> go.Figure:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'IC figure\\n\\n    :param ic_df: ic DataFrame\\n    :param show_nature_day: whether to display the abscissa of non-trading day\\n    :param \\\\*\\\\*kwargs: contains some parameters to control plot style in plotly. Currently, supports\\n       - `rangebreaks`: https://plotly.com/python/time-series/#Hiding-Weekends-and-Holidays\\n    :return: plotly.graph_objs.Figure\\n    '\n    if show_nature_day:\n        date_index = pd.date_range(ic_df.index.min(), ic_df.index.max())\n        ic_df = ic_df.reindex(date_index)\n    ic_bar_figure = BarGraph(ic_df, layout=dict(title='Information Coefficient (IC)', xaxis=dict(tickangle=45, rangebreaks=kwargs.get('rangebreaks', guess_plotly_rangebreaks(ic_df.index))))).figure\n    return ic_bar_figure",
            "def ic_figure(ic_df: pd.DataFrame, show_nature_day=True, **kwargs) -> go.Figure:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'IC figure\\n\\n    :param ic_df: ic DataFrame\\n    :param show_nature_day: whether to display the abscissa of non-trading day\\n    :param \\\\*\\\\*kwargs: contains some parameters to control plot style in plotly. Currently, supports\\n       - `rangebreaks`: https://plotly.com/python/time-series/#Hiding-Weekends-and-Holidays\\n    :return: plotly.graph_objs.Figure\\n    '\n    if show_nature_day:\n        date_index = pd.date_range(ic_df.index.min(), ic_df.index.max())\n        ic_df = ic_df.reindex(date_index)\n    ic_bar_figure = BarGraph(ic_df, layout=dict(title='Information Coefficient (IC)', xaxis=dict(tickangle=45, rangebreaks=kwargs.get('rangebreaks', guess_plotly_rangebreaks(ic_df.index))))).figure\n    return ic_bar_figure"
        ]
    },
    {
        "func_name": "model_performance_graph",
        "original": "def model_performance_graph(pred_label: pd.DataFrame, lag: int=1, N: int=5, reverse=False, rank=False, graph_names: list=['group_return', 'pred_ic', 'pred_autocorr'], show_notebook: bool=True, show_nature_day: bool=False, **kwargs) -> [list, tuple]:\n    \"\"\"Model performance\n\n    :param pred_label: index is **pd.MultiIndex**, index name is **[instrument, datetime]**; columns names is **[score, label]**.\n           It is usually same as the label of model training(e.g. \"Ref($close, -2)/Ref($close, -1) - 1\").\n\n\n            .. code-block:: python\n\n                instrument  datetime        score       label\n                SH600004    2017-12-11  -0.013502       -0.013502\n                                2017-12-12  -0.072367       -0.072367\n                                2017-12-13  -0.068605       -0.068605\n                                2017-12-14  0.012440        0.012440\n                                2017-12-15  -0.102778       -0.102778\n\n\n    :param lag: `pred.groupby(level='instrument')['score'].shift(lag)`. It will be only used in the auto-correlation computing.\n    :param N: group number, default 5.\n    :param reverse: if `True`, `pred['score'] *= -1`.\n    :param rank: if **True**, calculate rank ic.\n    :param graph_names: graph names; default ['cumulative_return', 'pred_ic', 'pred_autocorr', 'pred_turnover'].\n    :param show_notebook: whether to display graphics in notebook, the default is `True`.\n    :param show_nature_day: whether to display the abscissa of non-trading day.\n    :param \\\\*\\\\*kwargs: contains some parameters to control plot style in plotly. Currently, supports\n       - `rangebreaks`: https://plotly.com/python/time-series/#Hiding-Weekends-and-Holidays\n    :return: if show_notebook is True, display in notebook; else return `plotly.graph_objs.Figure` list.\n    \"\"\"\n    figure_list = []\n    for graph_name in graph_names:\n        fun_res = eval(f'_{graph_name}')(pred_label=pred_label, lag=lag, N=N, reverse=reverse, rank=rank, show_nature_day=show_nature_day, **kwargs)\n        figure_list += fun_res\n    if show_notebook:\n        BarGraph.show_graph_in_notebook(figure_list)\n    else:\n        return figure_list",
        "mutated": [
            "def model_performance_graph(pred_label: pd.DataFrame, lag: int=1, N: int=5, reverse=False, rank=False, graph_names: list=['group_return', 'pred_ic', 'pred_autocorr'], show_notebook: bool=True, show_nature_day: bool=False, **kwargs) -> [list, tuple]:\n    if False:\n        i = 10\n    'Model performance\\n\\n    :param pred_label: index is **pd.MultiIndex**, index name is **[instrument, datetime]**; columns names is **[score, label]**.\\n           It is usually same as the label of model training(e.g. \"Ref($close, -2)/Ref($close, -1) - 1\").\\n\\n\\n            .. code-block:: python\\n\\n                instrument  datetime        score       label\\n                SH600004    2017-12-11  -0.013502       -0.013502\\n                                2017-12-12  -0.072367       -0.072367\\n                                2017-12-13  -0.068605       -0.068605\\n                                2017-12-14  0.012440        0.012440\\n                                2017-12-15  -0.102778       -0.102778\\n\\n\\n    :param lag: `pred.groupby(level=\\'instrument\\')[\\'score\\'].shift(lag)`. It will be only used in the auto-correlation computing.\\n    :param N: group number, default 5.\\n    :param reverse: if `True`, `pred[\\'score\\'] *= -1`.\\n    :param rank: if **True**, calculate rank ic.\\n    :param graph_names: graph names; default [\\'cumulative_return\\', \\'pred_ic\\', \\'pred_autocorr\\', \\'pred_turnover\\'].\\n    :param show_notebook: whether to display graphics in notebook, the default is `True`.\\n    :param show_nature_day: whether to display the abscissa of non-trading day.\\n    :param \\\\*\\\\*kwargs: contains some parameters to control plot style in plotly. Currently, supports\\n       - `rangebreaks`: https://plotly.com/python/time-series/#Hiding-Weekends-and-Holidays\\n    :return: if show_notebook is True, display in notebook; else return `plotly.graph_objs.Figure` list.\\n    '\n    figure_list = []\n    for graph_name in graph_names:\n        fun_res = eval(f'_{graph_name}')(pred_label=pred_label, lag=lag, N=N, reverse=reverse, rank=rank, show_nature_day=show_nature_day, **kwargs)\n        figure_list += fun_res\n    if show_notebook:\n        BarGraph.show_graph_in_notebook(figure_list)\n    else:\n        return figure_list",
            "def model_performance_graph(pred_label: pd.DataFrame, lag: int=1, N: int=5, reverse=False, rank=False, graph_names: list=['group_return', 'pred_ic', 'pred_autocorr'], show_notebook: bool=True, show_nature_day: bool=False, **kwargs) -> [list, tuple]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Model performance\\n\\n    :param pred_label: index is **pd.MultiIndex**, index name is **[instrument, datetime]**; columns names is **[score, label]**.\\n           It is usually same as the label of model training(e.g. \"Ref($close, -2)/Ref($close, -1) - 1\").\\n\\n\\n            .. code-block:: python\\n\\n                instrument  datetime        score       label\\n                SH600004    2017-12-11  -0.013502       -0.013502\\n                                2017-12-12  -0.072367       -0.072367\\n                                2017-12-13  -0.068605       -0.068605\\n                                2017-12-14  0.012440        0.012440\\n                                2017-12-15  -0.102778       -0.102778\\n\\n\\n    :param lag: `pred.groupby(level=\\'instrument\\')[\\'score\\'].shift(lag)`. It will be only used in the auto-correlation computing.\\n    :param N: group number, default 5.\\n    :param reverse: if `True`, `pred[\\'score\\'] *= -1`.\\n    :param rank: if **True**, calculate rank ic.\\n    :param graph_names: graph names; default [\\'cumulative_return\\', \\'pred_ic\\', \\'pred_autocorr\\', \\'pred_turnover\\'].\\n    :param show_notebook: whether to display graphics in notebook, the default is `True`.\\n    :param show_nature_day: whether to display the abscissa of non-trading day.\\n    :param \\\\*\\\\*kwargs: contains some parameters to control plot style in plotly. Currently, supports\\n       - `rangebreaks`: https://plotly.com/python/time-series/#Hiding-Weekends-and-Holidays\\n    :return: if show_notebook is True, display in notebook; else return `plotly.graph_objs.Figure` list.\\n    '\n    figure_list = []\n    for graph_name in graph_names:\n        fun_res = eval(f'_{graph_name}')(pred_label=pred_label, lag=lag, N=N, reverse=reverse, rank=rank, show_nature_day=show_nature_day, **kwargs)\n        figure_list += fun_res\n    if show_notebook:\n        BarGraph.show_graph_in_notebook(figure_list)\n    else:\n        return figure_list",
            "def model_performance_graph(pred_label: pd.DataFrame, lag: int=1, N: int=5, reverse=False, rank=False, graph_names: list=['group_return', 'pred_ic', 'pred_autocorr'], show_notebook: bool=True, show_nature_day: bool=False, **kwargs) -> [list, tuple]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Model performance\\n\\n    :param pred_label: index is **pd.MultiIndex**, index name is **[instrument, datetime]**; columns names is **[score, label]**.\\n           It is usually same as the label of model training(e.g. \"Ref($close, -2)/Ref($close, -1) - 1\").\\n\\n\\n            .. code-block:: python\\n\\n                instrument  datetime        score       label\\n                SH600004    2017-12-11  -0.013502       -0.013502\\n                                2017-12-12  -0.072367       -0.072367\\n                                2017-12-13  -0.068605       -0.068605\\n                                2017-12-14  0.012440        0.012440\\n                                2017-12-15  -0.102778       -0.102778\\n\\n\\n    :param lag: `pred.groupby(level=\\'instrument\\')[\\'score\\'].shift(lag)`. It will be only used in the auto-correlation computing.\\n    :param N: group number, default 5.\\n    :param reverse: if `True`, `pred[\\'score\\'] *= -1`.\\n    :param rank: if **True**, calculate rank ic.\\n    :param graph_names: graph names; default [\\'cumulative_return\\', \\'pred_ic\\', \\'pred_autocorr\\', \\'pred_turnover\\'].\\n    :param show_notebook: whether to display graphics in notebook, the default is `True`.\\n    :param show_nature_day: whether to display the abscissa of non-trading day.\\n    :param \\\\*\\\\*kwargs: contains some parameters to control plot style in plotly. Currently, supports\\n       - `rangebreaks`: https://plotly.com/python/time-series/#Hiding-Weekends-and-Holidays\\n    :return: if show_notebook is True, display in notebook; else return `plotly.graph_objs.Figure` list.\\n    '\n    figure_list = []\n    for graph_name in graph_names:\n        fun_res = eval(f'_{graph_name}')(pred_label=pred_label, lag=lag, N=N, reverse=reverse, rank=rank, show_nature_day=show_nature_day, **kwargs)\n        figure_list += fun_res\n    if show_notebook:\n        BarGraph.show_graph_in_notebook(figure_list)\n    else:\n        return figure_list",
            "def model_performance_graph(pred_label: pd.DataFrame, lag: int=1, N: int=5, reverse=False, rank=False, graph_names: list=['group_return', 'pred_ic', 'pred_autocorr'], show_notebook: bool=True, show_nature_day: bool=False, **kwargs) -> [list, tuple]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Model performance\\n\\n    :param pred_label: index is **pd.MultiIndex**, index name is **[instrument, datetime]**; columns names is **[score, label]**.\\n           It is usually same as the label of model training(e.g. \"Ref($close, -2)/Ref($close, -1) - 1\").\\n\\n\\n            .. code-block:: python\\n\\n                instrument  datetime        score       label\\n                SH600004    2017-12-11  -0.013502       -0.013502\\n                                2017-12-12  -0.072367       -0.072367\\n                                2017-12-13  -0.068605       -0.068605\\n                                2017-12-14  0.012440        0.012440\\n                                2017-12-15  -0.102778       -0.102778\\n\\n\\n    :param lag: `pred.groupby(level=\\'instrument\\')[\\'score\\'].shift(lag)`. It will be only used in the auto-correlation computing.\\n    :param N: group number, default 5.\\n    :param reverse: if `True`, `pred[\\'score\\'] *= -1`.\\n    :param rank: if **True**, calculate rank ic.\\n    :param graph_names: graph names; default [\\'cumulative_return\\', \\'pred_ic\\', \\'pred_autocorr\\', \\'pred_turnover\\'].\\n    :param show_notebook: whether to display graphics in notebook, the default is `True`.\\n    :param show_nature_day: whether to display the abscissa of non-trading day.\\n    :param \\\\*\\\\*kwargs: contains some parameters to control plot style in plotly. Currently, supports\\n       - `rangebreaks`: https://plotly.com/python/time-series/#Hiding-Weekends-and-Holidays\\n    :return: if show_notebook is True, display in notebook; else return `plotly.graph_objs.Figure` list.\\n    '\n    figure_list = []\n    for graph_name in graph_names:\n        fun_res = eval(f'_{graph_name}')(pred_label=pred_label, lag=lag, N=N, reverse=reverse, rank=rank, show_nature_day=show_nature_day, **kwargs)\n        figure_list += fun_res\n    if show_notebook:\n        BarGraph.show_graph_in_notebook(figure_list)\n    else:\n        return figure_list",
            "def model_performance_graph(pred_label: pd.DataFrame, lag: int=1, N: int=5, reverse=False, rank=False, graph_names: list=['group_return', 'pred_ic', 'pred_autocorr'], show_notebook: bool=True, show_nature_day: bool=False, **kwargs) -> [list, tuple]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Model performance\\n\\n    :param pred_label: index is **pd.MultiIndex**, index name is **[instrument, datetime]**; columns names is **[score, label]**.\\n           It is usually same as the label of model training(e.g. \"Ref($close, -2)/Ref($close, -1) - 1\").\\n\\n\\n            .. code-block:: python\\n\\n                instrument  datetime        score       label\\n                SH600004    2017-12-11  -0.013502       -0.013502\\n                                2017-12-12  -0.072367       -0.072367\\n                                2017-12-13  -0.068605       -0.068605\\n                                2017-12-14  0.012440        0.012440\\n                                2017-12-15  -0.102778       -0.102778\\n\\n\\n    :param lag: `pred.groupby(level=\\'instrument\\')[\\'score\\'].shift(lag)`. It will be only used in the auto-correlation computing.\\n    :param N: group number, default 5.\\n    :param reverse: if `True`, `pred[\\'score\\'] *= -1`.\\n    :param rank: if **True**, calculate rank ic.\\n    :param graph_names: graph names; default [\\'cumulative_return\\', \\'pred_ic\\', \\'pred_autocorr\\', \\'pred_turnover\\'].\\n    :param show_notebook: whether to display graphics in notebook, the default is `True`.\\n    :param show_nature_day: whether to display the abscissa of non-trading day.\\n    :param \\\\*\\\\*kwargs: contains some parameters to control plot style in plotly. Currently, supports\\n       - `rangebreaks`: https://plotly.com/python/time-series/#Hiding-Weekends-and-Holidays\\n    :return: if show_notebook is True, display in notebook; else return `plotly.graph_objs.Figure` list.\\n    '\n    figure_list = []\n    for graph_name in graph_names:\n        fun_res = eval(f'_{graph_name}')(pred_label=pred_label, lag=lag, N=N, reverse=reverse, rank=rank, show_nature_day=show_nature_day, **kwargs)\n        figure_list += fun_res\n    if show_notebook:\n        BarGraph.show_graph_in_notebook(figure_list)\n    else:\n        return figure_list"
        ]
    }
]